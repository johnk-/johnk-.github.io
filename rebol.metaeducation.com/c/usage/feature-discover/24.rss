<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Feature Discover - AltRebol</title>
    <link>https://rebol.metaeducation.com/c/usage/feature-discover/24</link>
    <description>Topics in the &#39;Feature Discover&#39; category Rebol and Red have quite a few cool features - this is PR for them.</description>
    
      <lastBuildDate>Fri, 23 May 2025 15:04:04 +0000</lastBuildDate>
      <atom:link href="https://rebol.metaeducation.com/c/usage/feature-discover/24.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Poking Splices and Voids Into Series Positions</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>I'm tidying up SET and GET to run on a common infrastructure based on PICK and POKE (generalized via isotopes and "dual representation").  It's quite nice!</p>
<p>As I go, I'm improving things left and right.  The POKE handler is now built on the same code as CHANGE, with a :PART of 1.  That means you can do things like this:</p>
<pre><code>&gt;&gt; list: [a b c]
== [a b c]

&gt;&gt; list.2: spread [d e f]
== \~(d e f)~\  ; antiform (splice!)

&gt;&gt; list
== [a d e f c]

&gt;&gt; list.3: void
== \~[]~\  ; antiform (pack!) "void"

&gt;&gt; list
== [a d f c]
</code></pre>
<p>Since strings can't store lists in them, you don't have to "spread" strings to splice them...</p>
<pre><code>&gt;&gt; text: "abc"
== "abc"

&gt;&gt; text.2: "def"
== "def"

&gt;&gt; text
== "adefc"

&gt;&gt; text.3: void
== \~[]~\  ; antiform (pack!) "void"

&gt;&gt; text
== "adfc"
</code></pre>
<p>There's lots of good in the new architecture.  Expect to see historical woes vanish, and more new features...</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/poking-splices-and-voids-into-series-positions/2469">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/poking-splices-and-voids-into-series-positions/2469</link>
          <pubDate>Fri, 23 May 2025 15:04:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2469</guid>
          <source url="https://rebol.metaeducation.com/t/poking-splices-and-voids-into-series-positions/2469.rss">Poking Splices and Voids Into Series Positions</source>
        </item>
        <item>
          <title>New Feature: Literal Picking With TUPLE!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>The ability to embed quotes in TUPLE!s/PATH!s/CHAIN!s affords some interesting abilities.</p>
<p>It's not always clear what those abilities should actually <em>be</em>.  However, one case seemed pretty clear, so I went ahead with it...</p>
<pre><code>&gt;&gt; a: &lt;something&gt;

&gt;&gt; m: to map! []
== &amp;[map! []]

&gt;&gt; m.(a): 304
== 304

&gt;&gt; m.'(a): 1020
== 1020

&gt;&gt; m
== &amp;[map! [
    &lt;something&gt; 304
    (a) 1020
]]

&gt;&gt; m.'(a)
== 1020
</code></pre>
<p>Pretty cool.  Note that you can't do this with "literal SET-XXX" because the CHAIN! scans "above" the TUPLE!.  So <strong><code>m.(a):</code></strong> is a CHAIN! of <strong><code>[m.(a) _]</code></strong>.</p>
<p>If you wanted to actually put <strong><code>(a):</code></strong> in the map, you can't use this trick.  You have to do it the "hard way":</p>
<pre><code> m.('(a):): &lt;whatever&gt;
</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/new-feature-literal-picking-with-tuple/2468">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/new-feature-literal-picking-with-tuple/2468</link>
          <pubDate>Fri, 23 May 2025 08:52:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2468</guid>
          <source url="https://rebol.metaeducation.com/t/new-feature-literal-picking-with-tuple/2468.rss">New Feature: Literal Picking With TUPLE!</source>
        </item>
        <item>
          <title>Reified Unreassignable Nothingness: SPACE RUNES</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/fad3c385e7027512303a71a848a9c5438b676363.webp" data-download-href="https://rebol.metaeducation.com/uploads/default/fad3c385e7027512303a71a848a9c5438b676363" title="assets_task_01jvf0ek4eegkvrwp6xz5sdez9_1747481817_img_0"><img src="https://rebol.metaeducation.com/uploads/default/optimized/1X/fad3c385e7027512303a71a848a9c5438b676363_2_517x345.webp" alt="assets_task_01jvf0ek4eegkvrwp6xz5sdez9_1747481817_img_0" data-base62-sha1="zMV4iH8Je3W7UqmODgWrb3itd8D" width="517" height="345" srcset="https://rebol.metaeducation.com/uploads/default/optimized/1X/fad3c385e7027512303a71a848a9c5438b676363_2_517x345.webp, https://rebol.metaeducation.com/uploads/default/optimized/1X/fad3c385e7027512303a71a848a9c5438b676363_2_775x517.webp 1.5x, https://rebol.metaeducation.com/uploads/default/optimized/1X/fad3c385e7027512303a71a848a9c5438b676363_2_1034x690.webp 2x" data-dominant-color="29221C"></a></div><p></p>
<hr>
<h1><a name="p-8307-first-lets-introduce-runes-1" class="anchor" href="https://rebol.metaeducation.com#p-8307-first-lets-introduce-runes-1"></a>First, Let's Introduce RUNE!s  <span class="hashtag-raw">#ᚠ</span> <span class="hashtag-raw">#ᚡ</span> <span class="hashtag-raw">#ᚢ</span> <span class="hashtag-raw">#ᚣ</span> <span class="hashtag-raw">#ᚤ</span></h1>
<p>Runes are used for character literals.  They are a fusion of historical Rebol's <code>issue!</code> and <code>char!</code> types.</p>
<p>The name has precedent:</p>
<ul>
<li>
<p><strong><a href="https://docs.rs/runestr/latest/runestr/">Rust</a></strong> - <em>"The <code>rune</code> type represents a user-perceived character. It roughly corresponds to a Unicode grapheme cluster but with some nice properties."</em></p>
</li>
<li>
<p><strong><a href="https://go.dev/doc/go1#rune">Go</a></strong> - <em>"Go 1 introduces a new basic type, <code>rune</code>, to represent individual Unicode code points. It is an alias for <code>int32</code>, analogous to <code>byte</code> as an alias for <code>uint8</code>."</em></p>
</li>
</ul>
<p><strong>MOST</strong> (but crucially, not <strong>ALL</strong>) Ren-C runes start with <code>#</code> in their LOAD-able representation:</p>
<pre><code>&gt;&gt; second "abc"
== #a

&gt;&gt; type of #a
== ~{rune!}~  ; antiform (datatype)

&gt;&gt; append "abc" #a
== "abca"
</code></pre>
<p>The HASH (or OCTOTHORPE/POUND) rune is a special case, where it represents itself (as opposed to being expressed by <strong><code>##</code></strong>)</p>
<pre><code>&gt;&gt; second "a#b"
== #

&gt;&gt; to text! #
== "#"
</code></pre>
<p>While runes like <code>#a</code> don't need to be wrapped in quotes, others need to be:</p>
<pre><code>&gt;&gt; third "[x]"
== #"]"

&gt;&gt; third [a b #]
== #  ; as opposed to #]
</code></pre>
<blockquote>
<p>Note that if we allowed things like <strong><code>#]</code></strong> to be the rune for a bracket, that would imply:</p>
<pre><code>&gt;&gt; third [a b #]]  ; this would be pretty confusing!
== #]
</code></pre>
<p>... and it would lead to serious limitations on being able to allow things like <strong><code>#(...)</code></strong> or <strong><code>#"..."</code></strong> or <strong><code>#[...]</code></strong> as special forms.  <a href="https://rebol.metaeducation.com/t/taking-delimiters-literally-in-the-rune-datatype/2386">Discussion here.</a></p>
</blockquote>
<p>As with historical Rebol issue!, the RUNE! type can hold more than one codepoint:</p>
<pre><code>&gt;&gt; type of #abcd
== ~{rune!}~  ; antiform (datatype)

&gt;&gt; length of #abcd
== 4
</code></pre>
<p>When a function like PRINT is performing delimiting (e.g. injecting spacing automatically between tokens), runes aren't considered to need delimiting.  So:</p>
<pre><code>&gt;&gt; print ["abc" "def" #ghij "klm no"]
abc defghijklm no
</code></pre>
<p>That might seem a little arbitrary for multi-codepoint runes.  But it's of high importance with single codepoint runes like <code>newline</code>, because you wouldn't want newline to introduce a space on the previous and next lines:</p>
<pre><code>&gt;&gt; print ["line" "one" newline "line" "two"]
line one  ; &lt;-- you wouldn't want a space at the end of this line
line two  ; &lt;-- you wouldn't want a space at the beginning of this line
</code></pre>
<p><em>(Historical Redbol has bugs pertaining to this which you might not notice in printed output.  There are stray spaces at the ends of lines that should not be there, that you only notice when writing files and examining the bytes.)</em></p>
<hr>
<p><strong>And now: the small design choice with big impact...</strong></p>
<hr>
<h1><a name="p-8307-plain-_-is-the-rune-for-ascii-space-2" class="anchor" href="https://rebol.metaeducation.com#p-8307-plain-_-is-the-rune-for-ascii-space-2"></a>Plain <strong><code>_</code></strong> Is The Rune  For ASCII SPACE</h1>
<pre><code>&gt;&gt; second "a b"
== _

&gt;&gt; type of _
== ~{rune!}~  ; antiform (datatype)

&gt;&gt; to text! _
== " "

&gt;&gt; mold _
== "_"
</code></pre>
<p>If you have a Rune of just spaces, its representation will be that number of underscores:</p>
<pre><code>&gt;&gt; tab4: ____

&gt;&gt; print [tab4 "Runes" "don't count" "in delimiting"]
    Runes don't count in delimiting
    ^-- this is spaced in by 4, not 5, because of the rune! delimit rule
</code></pre>
<p>But if a rune contains <em>any</em> non-space characters, its representation will be escaped <em>(currently in quotes, though this may not be final)</em></p>
<pre><code>&gt;&gt; to rune! "abc def ghi"
== #"abc def ghi"
</code></pre>
<p>This means underscores are generally ordinary WORD! characters, so long as a token does not solely consist of underscores.</p>
<h2><a name="p-8307-a-powerful-exception-with-broad-application-3" class="anchor" href="https://rebol.metaeducation.com#p-8307-a-powerful-exception-with-broad-application-3"></a>A Powerful Exception With Broad Application</h2>
<p>Let's briefly discuss history.</p>
<p>In the earliest days of Ren-C, the <strong><code>_</code></strong> character was chosen as the literal representation of what one might think of as the Redbol "NONE!".</p>
<ol>
<li>
<p><strong><code>_</code></strong> was <strong>reified</strong></p>
<ul>
<li>
<p>it <em>could</em> be put in a block!</p>
<ul>
<li>this contrasted with things like the state of an unset variable (which Ren-C vehemently insisted was "the sort of thing that could not be put in a block!")</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>_</code></strong> was <strong>unreassignable</strong></p>
<ul>
<li>
<p>if you had a dialected purpose with a slot that might hold a variable, holding a <code>_</code> was clearly differentiated</p>
</li>
<li>
<p><code>_</code> wasn't a WORD!, so it could truly "opt out" of things that a variable name might opt-in to. e.g. with <strong>for-each _ [a b c] [...]</strong> you could fully skip out on naming a loop variable.</p>
</li>
</ul>
</li>
<li>
<p><strong><code>_</code></strong> was <strong>nothingness</strong></p>
<ul>
<li>
<p>... or at least, as close to nothing as something could be, while still being able to be put in a block!</p>
</li>
<li>
<p><strong><code>for-each 'x _ [...code...]</code></strong> was equivalent to <strong><code>for-each 'x [] [...code...]</code></strong></p>
</li>
<li>
<p>As advanced features came online, things like <strong><code>[_ var]: some-multi-returner ....</code></strong> could realize that a slot was not meant to be assigned when unpacking multiple return values.</p>
</li>
</ul>
</li>
<li>
<p><strong><code>_</code></strong> was <strong>"falsey"</strong></p>
<ul>
<li>
<p>This was a by-product of the heritage of being the new analogue to NONE!.</p>
</li>
<li>
<p>The rise of generalized isotopes introduced <code>~null~</code> antiforms as a non-reified "falsey" state, raising some tensions with the <em>reified</em> <strong>_</strong> and <strong>#[false]</strong> states...</p>
</li>
</ul>
</li>
</ol>
<h2><a name="p-8307-h-1-2-were-kept-3-evolved-4-was-dropped-4" class="anchor" href="https://rebol.metaeducation.com#p-8307-h-1-2-were-kept-3-evolved-4-was-dropped-4"></a>[1] + [2] Were Kept, [3] "Evolved", [4] Was Dropped</h2>
<p><a href="https://rebol.metaeducation.com/t/a-justification-of-generalized-isotopes/1918">In the age of isotopes <img src="https://rebol.metaeducation.com/images/emoji/twitter/atom_symbol.png?v=14" title=":atom_symbol:" class="emoji" alt=":atom_symbol:" loading="lazy" width="20" height="20"></a>, all reified values came to behave "as-is".  Only antiforms had exceptions in behavior:</p>
<pre><code> &gt;&gt; append [a b c] [d e]
 == [a b c [d e]]

 &gt;&gt; spread [d e]
 == ~(d e)~  ; antiform (splice)

 &gt;&gt; append [a b c] spread [d e]
 == [a b c d e]

 &gt;&gt; append [a b c] _
 == [a b c _]
</code></pre>
<p>To be both "reified" and "nothing", <strong><code>_</code></strong> had to serve two masters.  When it came to mechanical contexts like APPEND or FIND, the reified-ness had to win out.</p>
<h2><a name="p-8307-tbd-expand-5" class="anchor" href="https://rebol.metaeducation.com#p-8307-tbd-expand-5"></a>TBD: Expand...</h2>
<p>I'm falling asleep <img src="https://rebol.metaeducation.com/images/emoji/twitter/sleeping_face.png?v=14" title=":sleeping_face:" class="emoji" alt=":sleeping_face:" loading="lazy" width="20" height="20"> will write more, but until I do, see:</p>
<p><a href="https://rebol.metaeducation.com/t/why-does-form-as-space-not-underscore/2455" class="inline-onebox">Why Does _ Form As Space, Not Underscore?</a></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/reified-unreassignable-nothingness-space-runes/2457">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/reified-unreassignable-nothingness-space-runes/2457</link>
          <pubDate>Sat, 17 May 2025 15:40:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2457</guid>
          <source url="https://rebol.metaeducation.com/t/reified-unreassignable-nothingness-space-runes/2457.rss">Reified Unreassignable Nothingness: SPACE RUNES</source>
        </item>
        <item>
          <title>Making Function Calls Clearer With Selective Slashing</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>Ren-C shifted to the idea that slashes in paths are used to convey function calls.  Refinements are done with colons (CHAIN!), and field selection is done with dots (TUPLE!)</p>
<p>This means you can tell the difference between:</p>
<pre><code>obj/xxx  ; a function call

obj.xxx  ; picking a member out of an object
</code></pre>
<p>But Rebol depends visually on not needing any decoration to run a function out of a word.  This means that when you see:</p>
<pre><code>some-word
</code></pre>
<p>You don't know if that's running a function or not.   While that is "by design", there are sometimes cases where you want to disambiguate it.  So Ren-C offers:</p>
<pre><code>/some-word  ; runs a function

some-word.  ; gets a non-function value from the word
</code></pre>
<p><em>(The <code>some-word/</code> case is for getting a function without running it... chosen for its semiotic value of separating the word from its arguments with a "barrier" at the end.  And <code>.some-word</code> is used for picking members out of objects inside of a method, e.g. <code>self.some-word</code>.)</em></p>
<h2><a name="p-8124-who-would-ever-use-some-word-1" class="anchor" href="https://rebol.metaeducation.com#p-8124-who-would-ever-use-some-word-1"></a>Who Would Ever Use /SOME-WORD ?</h2>
<p>I've explained cool applications of the leading slash in things like <a href="https://rebol.metaeducation.com/t/if-action-combinators-dont-impress-what-will/1608">ACTION! combinators for UPARSE</a>.</p>
<p>But is it useful in non-dialected code?</p>
<p><strong>YES.</strong></p>
<p>In doing some updates to Shixin's c2r3, there was some code like this:</p>
<pre><code>cpuid: tcc/load-func prog "cpuid" [
    eax [pointer]
    ebx [pointer]
    ecx [pointer]
    edx [pointer]
    return: [void]
]

cpu-string: func [
    return: [text!]
][
    let eax: copy #{00000000}
    let ebx: copy #{00000000}
    let ecx: copy #{00000000}
    let edx: copy #{00000000}

    cpuid eax ebx ecx edx
    return as text! join blob! [ebx edx ecx]
]
</code></pre>
<p>CPUID doesn't necessarily sound like a function invocation.  But let's imagine that's what something is named.  You're confronted with the question: should I name the wrapper something like <strong><code>get-cpuid:</code></strong> ?  But now you've created a mismatch between something that exists and your wrapper.</p>
<p>Using the leading slash gives you the ability to mark things more clearly as a function at the assignment:</p>
<pre><code>/cpuid: tcc/load-func prog "cpuid" [
    eax [pointer]
    ebx [pointer]
    ecx [pointer]
    edx [pointer]
    return: [void]
]
</code></pre>
<p>This not only visually reinforces that what you are assigning is a function, but it also requries that what you're assigning be an action.  So it's a convenient shorthand for:</p>
<pre><code>cpuid: ensure action! tcc/load-func prog "cpuid" [...]
</code></pre>
<p>The callsites have a similar benefit...not just visual, but enforced that it's a function call:</p>
<pre><code>/cpuid eax ebx ecx edx
return as text! join blob! [ebx edx ecx]
</code></pre>
<h2><a name="p-8124-its-there-on-an-as-needed-basis-2" class="anchor" href="https://rebol.metaeducation.com#p-8124-its-there-on-an-as-needed-basis-2"></a>It's There On An As-Needed Basis</h2>
<p>For a time, I was wondering if all function assignments should require slashed-set-words.</p>
<p>But I realized that it was too much.</p>
<pre><code>/something: func [...] [...]   ; but I KNOW FUNC makes functions...

/alpha: beta/  ; BETA/ promises to return a function, why double-enforce?
</code></pre>
<p>But it can make some situations more clear, and give you cheap insurance that the assignment is doing what you think.</p>
<p>Similarly I think the leading slash is something to apply judiciously.  We don't want to read code with tons of <strong><code>/append</code></strong> junking it up.  But cases like this <strong><code>/cpuid</code></strong> show an effective and helpful communication that a function call is happening.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/making-function-calls-clearer-with-selective-slashing/2402">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/making-function-calls-clearer-with-selective-slashing/2402</link>
          <pubDate>Tue, 08 Apr 2025 18:41:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2402</guid>
          <source url="https://rebol.metaeducation.com/t/making-function-calls-clearer-with-selective-slashing/2402.rss">Making Function Calls Clearer With Selective Slashing</source>
        </item>
        <item>
          <title>Labeled TRASH! Runes in The Wild</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>If you access an unset variable, you don't get a lot of information back:</p>
<pre><code>&gt;&gt; state: ~

&gt;&gt; state
** Script Error: state is ~ antiform
</code></pre>
<p>That <code>~</code> is the quasiform/antiform of the space RUNE!:</p>
<pre><code>&gt;&gt; quasi _
== ~

&gt;&gt; type of anti _
== ~{trash!}~  ; antiform (datatype)
</code></pre>
<p><strong>But you're not just limited to the space RUNE! to make "unset" variables... because you can use <em>any</em> RUNE!.</strong></p>
<pre><code>&gt;&gt; state: ~#[INITIALIZE-STATE not called yet]#~

&gt;&gt; state
** Script Error: state is trash: ~#[INITIALIZE-STATE not called yet]#~
</code></pre>
<p><em>(This concept was originally called a "tripwire" when labeled trash was a distinct datatype from trash.  But now that the <strong><code>_</code></strong> is just the rune! for space, it unifies to where all antiform runes are just called TRASH!)</em></p>
<p>DEFAULT reacts to labeled trash like anything else, considering the variable to be "vacant"</p>
<pre><code>&gt;&gt; vacant? $state
== ~okay~  ; anti

&gt;&gt; state: default [10 + 20]
== 30

&gt;&gt; state
== 30
</code></pre>
<h2><a name="p-7676-can-be-better-than-a-meandering-comment-1" class="anchor" href="https://rebol.metaeducation.com#p-7676-can-be-better-than-a-meandering-comment-1"></a>Can Be Better Than A Meandering Comment!</h2>
<p>A comment won't direct people to the relevant issue at runtime.  But a well-chosen labeled trash can.</p>
<p>Compare:</p>
<pre><code>; !!! UPARSE is not available in SYS because it is higher level.  We hack it
; up so that when %uparse.r runs it pokes itself into sys.util/parse
;
parse: ~
</code></pre>
<p>With:</p>
<pre><code>parse: ~#[higher-level %uparse.r hasn't set SYS.UTIL/PARSE yet]#~
</code></pre>
<p>Much better!  Gives you the information you need, when you need it!</p>
<p><em>(Note: I was inspired to this concept by a style of usage <a class="mention" href="https://rebol.metaeducation.com/u/rgchris">@rgchris</a> had in his scripts, using TAG!s to provide guidance for what was supposed to be filled into certain slots.  I just wanted to give that some teeth, to know that the variable was conceptually unset.)</em></p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/labeled-trash-runes-in-the-wild/2278">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/labeled-trash-runes-in-the-wild/2278</link>
          <pubDate>Sun, 15 Sep 2024 07:46:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2278</guid>
          <source url="https://rebol.metaeducation.com/t/labeled-trash-runes-in-the-wild/2278.rss">Labeled TRASH! Runes in The Wild</source>
        </item>
        <item>
          <title>REIFY and DEGRADE: a Narrower LIFT and UNLIFT</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>In the "small improvements can be big" category, I think that I've settled on the name for the function that turns quasiforms into antiforms, but leaves everything else alone: <strong>DEGRADE</strong>...and its complement <strong>REIFY</strong> which turns antiforms into quasiforms (but leaves everything else alone).</p>
<pre><code>&gt;&gt; first [1020 ~null~]
== 1020

&gt;&gt; second [1020 ~null~]
== ~null~

&gt;&gt; degrade first [1020 ~null~]
== 1020

&gt;&gt; degrade second [1020 ~null~]
== \~null~\  ; antiform

&gt;&gt; 304
== 304

&gt;&gt; reify 304
== 304

&gt;&gt; okay
== \~okay~\  ; antiform

&gt;&gt; reify okay
== ~okay~
</code></pre>
<p>If you're dealing with a full-band situation where you genuinely don't know if you're working with a "meaningful quasiform" where <em>quasi means quasi</em>, you have to use LIFT and UNLIFT.  But if you know that quasiforms aren't part of your data of interest, REIFY and DEGRADE can help you dodge adding and removing quote marks much (or most) of the time.</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="12" data-topic="1560">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/1560/12">On another topic</a></div>
<blockquote>
<p>Maybe it would be better (and give Chris less of a heart attack) if it said:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">for-each [sigil' items] [
    ~null~ [  word   tu.p.le   pa/th   [bl o ck]   (gr o up)  ]
    '^     [ ^word  ^tu.p.le  ^pa/th  ^[bl o ck]  ^(gr o up)  ]
    '@     [ @word  @tu.p.le  @pa/th  @[bl o ck]  @(gr o up)  ]
    '$     [ $word  $tu.p.le  $pa/th  $[bl o ck]  $(gr o up)  ]
 ][
      for-each item items [
          if (unlift sigil') &lt;&gt; sigil of item [
              panic [mold item]
          ]
      ]
 ]
</code></pre>
</blockquote>
</aside>
<p>I like how DEGRADE can be used in situations like this to help you strike the quotes on the normal values...since SIGIL OF never returns quasiforms, only a sigil or a null antiform:</p>
<pre><code>for-each [sigil items] [
    ~null~ [  word   tu.p.le   pa/th   [bl o ck]   (gr o up)  ]
    ^      [ ^word  ^tu.p.le  ^pa/th  ^[bl o ck]  ^(gr o up)  ]
    @      [ @word  @tu.p.le  @pa/th  @[bl o ck]  @(gr o up)  ]
    $      [ $word  $tu.p.le  $pa/th  $[bl o ck]  $(gr o up)  ]
][
    for-each item items [
        if (degrade sigil) &lt;&gt; sigil of item [
            panic [mold item]
        ]
    ]
]
</code></pre>
<p>I think this will be a useful and common pattern.</p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/atom_symbol.png?v=14" title=":atom_symbol:" class="emoji only-emoji" alt=":atom_symbol:" loading="lazy" width="20" height="20"> <img src="https://rebol.metaeducation.com/images/emoji/twitter/+1.png?v=14" title=":+1:" class="emoji only-emoji" alt=":+1:" loading="lazy" width="20" height="20"></p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/reify-and-degrade-a-narrower-lift-and-unlift/2163">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/reify-and-degrade-a-narrower-lift-and-unlift/2163</link>
          <pubDate>Sun, 03 Mar 2024 15:28:36 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2163</guid>
          <source url="https://rebol.metaeducation.com/t/reify-and-degrade-a-narrower-lift-and-unlift/2163.rss">REIFY and DEGRADE: a Narrower LIFT and UNLIFT</source>
        </item>
        <item>
          <title>Introducing DELIMIT (plus SPACED and UNSPACED)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>Ren-C offers an alternative to historical AJOIN and REJOIN called DELIMIT:</p>
<pre><code>&gt;&gt; delimit "," ["foo" 1 + 2 "bar"]
== "foo,3,bar"

&gt;&gt; delimit/head "," ["foo" 1 + 2 "bar"]
== ",foo,3,bar"

&gt;&gt; delimit/tail "," ["foo" 1 + 2 "bar"]
== "foo,3,bar,"

&gt;&gt; delimit/head/tail "," ["foo" 1 + 2 "bar"]
== ",foo,3,bar,"
</code></pre>
<p>If you don't want it to reduce, you can use an @ block:</p>
<pre><code>&gt;&gt; delimit "," @["foo" 1 + 2 "bar"]
== "foo,1,+,2,bar"
</code></pre>
<p>SPACED and UNSPACED are specializations, running through the same code for stringifying any non-string contents.</p>
<pre><code>&gt;&gt; spaced ["foo" 1 + 2 "bar"]
== "foo 3 bar"

&gt;&gt; unspaced ["foo" 1 + 2 "bar"]
== "foo3bar"
</code></pre>
<p>PRINT uses SPACED internally when you pass it a block.  You can use <strong>print unspaced</strong> to pass it a string if you want unspaced intent.</p>
<pre><code>&gt;&gt; print ["foo" 1 + 2 "bar"]
foo 3 bar

&gt;&gt; print unspaced ["foo" 1 + 2 "bar"]
foo3bar
</code></pre>
<p>If you use a character (like <span class="hashtag-raw">#a</span>) instead of a string (like "a"), the delimiting won't be applied.  For instance, a newline won't leave spaces on either end of the line break:</p>
<pre><code>&gt;&gt; spaced ["foo" 1 + 2 newline "bar"]
== "foo 3^/bar"
</code></pre>
<p>NULLs will trigger errors, VOIDs will vanish.</p>
<pre><code>&gt;&gt; spaced ["foo" if false [1 + 2] "bar"]
== "foo bar"

&gt;&gt; spaced ["foo" pick [a b] 3 "bar"]
** Script Error: non-NULL value required (see MAYBE, TRY, REIFY)

&gt;&gt; spaced ["foo" maybe pick [a b] 3 "bar"]
== "foo bar"
</code></pre>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/introducing-delimit-plus-spaced-and-unspaced/2102">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/introducing-delimit-plus-spaced-and-unspaced/2102</link>
          <pubDate>Thu, 11 Jan 2024 00:42:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2102</guid>
          <source url="https://rebol.metaeducation.com/t/introducing-delimit-plus-spaced-and-unspaced/2102.rss">Introducing DELIMIT (plus SPACED and UNSPACED)</source>
        </item>
        <item>
          <title>COMPOSE of TUPLE! and PATH! (and toplevel GROUP!)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>While working on <a class="mention" href="https://rebol.metaeducation.com/u/blackattr">@BlackATTR</a>'s query, I noticed code that was making paths (now tuples) out of components via TO TUPLE! COMPOSE of a BLOCK!.  Like this:</p>
<pre><code>to tuple! compose [obj clauses (kwd.1)]
</code></pre>
<p>But did you know that COMPOSE can act directly on TUPLE! and PATH!  You could instead just write:</p>
<pre><code>compose $obj.clauses.(kwd.1)
</code></pre>
<p>It supports splices as well:</p>
<pre><code>&gt;&gt; compose $(10 + 20)/a/b/(spread [c d e])/(reverse [g f])
== 30/a/b/c/d/e/[f g]
</code></pre>
<p>And if you remember that TUPLE! can be nested underneath PATH! (not vice versa) then you can COMPOSE/DEEP and handle mixed tuples and paths:</p>
<pre><code>&gt;&gt; compose/deep $(10 + 20)/a/b.(spread [c d e])
== 30/a/b.c.d.e
</code></pre>
<p>Voids can vanish...so there can be fewer dots in an output tuple than in the input:</p>
<pre><code>&gt;&gt; compose $a.(if false [b]).c
== a.c
</code></pre>
<p>Empty splices will vanish as well:</p>
<pre><code>&gt;&gt; compose $a.(spread []).c
== a.c
</code></pre>
<p>You can't compose in NULLs as an important safety measure...central to the design!</p>
<pre><code>&gt;&gt; compose $a.(select [x 10 y 20] 'b).c
** Script Error: non-NULL value required (see MAYBE, TRY, REIFY)
** Near: [a ** (select [x 10 y 20] 'b) c]
</code></pre>
<p>But don't forget about MAYBE as the way to convert nulls to void when that's what you meant!</p>
<pre><code>&gt;&gt; compose $a.(maybe select [x 10 y 20] 'b).c
== a.c
</code></pre>
<h2><a name="p-6705-you-can-also-compose-a-group-1" class="anchor" href="https://rebol.metaeducation.com#p-6705-you-can-also-compose-a-group-1"></a>You can also COMPOSE a GROUP!</h2>
<p>In R3-Alpha, only BLOCK! would compose.  Everything else was passed-through as-is, including GROUP!s (PAREN!s in their terminology)</p>
<pre><code>r3-alpha&gt;&gt; compose quote (1 + (2 + 3))  ; R3-alpha QUOTE (modern THE)
== (1 + (2 + 3))
</code></pre>
<p>Red just doesn't allow it:</p>
<pre><code>red&gt;&gt; compose quote (1 + (2 + 3))   ; Red QUOTE (modern THE)
*** Script Error: compose does not allow paren! for its value argument
</code></pre>
<p>So you'd wind up having to make BLOCK!s and then convert them:</p>
<pre><code>red&gt;&gt; as paren! compose [1 + (2 + 3)]
== (1 + 5)
</code></pre>
<p>But in Ren-C, group composing works... it just leaves the top group as-is.</p>
<pre><code>&gt;&gt; compose $(1 + (2 + 3))
== (1 + 5)
</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/compose-of-tuple-and-path-and-toplevel-group/2056">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/compose-of-tuple-and-path-and-toplevel-group/2056</link>
          <pubDate>Thu, 19 Oct 2023 06:39:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2056</guid>
          <source url="https://rebol.metaeducation.com/t/compose-of-tuple-and-path-and-toplevel-group/2056.rss">COMPOSE of TUPLE! and PATH! (and toplevel GROUP!)</source>
        </item>
        <item>
          <title>Making Invisible Functions (e.g. COMMENT, ELIDE)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>The first idea of making constructs that would "vanish completely" leveraged a special kind of infix function, that would receive the entire evaluated value of the left hand side:</p>
<pre><code> comment: infix func [
     left [&lt;evaluate-all&gt; any-value!]
     right
 ][
     print ["COMMENT got left as" mold left]
     return left
 ]

 &gt;&gt; 1 + 2 + 3 comment [magic!]
 hi
 COMMENT got left as 6
 == 6  ; wow!
</code></pre>
<p>This was a workaround for the (seeming?) fundamental fact that you can't have such a thing as "invisible variables" or "invisible values".  <em>Certain functions just faked invisibility by repeating the previous value in the evaluator chain.</em></p>
<p>The possibilities seemed endless.  For instance, imagine something like this:</p>
<pre><code>case [
   conditionA [...code...]
   elide print "conditionA didn't succeed but running this"
   conditionB [...code...]
   conditionC [...code...]
]
</code></pre>
<p>To do that in Rebol2 or Red would be incredibly awkward.  e.g. using a condition that runs code but evaluates to false, and then a throwaway block for the never-executed branch:</p>
<pre><code>case [
   conditionA [...code...]
   (
       print "conditionA didn't succeed but running this"
       false
   ) [&lt;unreachable&gt;]
   conditionB [...code...]
   conditionC [...code...]
]
</code></pre>
<p>Similar awkwardness would arise in things like ANY and ALL, where you'd have to switch from using true and false based on which you were using...</p>
<pre><code>any [conditionA (print "vanish" false) conditionB]
all [conditionA (print "vanish" true) conditionB]
</code></pre>
<p>Beyond being awkward, it simply can't work if what you want to vanish is the last expression.  But ELIDE handled all these cases:</p>
<pre><code>any [conditionA elide print "vanish" conditionB]
all [conditionA elide print "vanish" conditionB]
any [conditionA conditionB elide print "vanish"]
all [conditionA conditionB elide print "vanish"]
</code></pre>
<h2><a name="p-6622-it-was-a-neat-trickbut-problems-emerged-1" class="anchor" href="https://rebol.metaeducation.com#p-6622-it-was-a-neat-trickbut-problems-emerged-1"></a>It Was A Neat Trick...But Problems Emerged</h2>
<p>The trick of invisibility requiring a function to receive its left hand side meant a GROUP! or COMMA! would break these constructs, as there was no access to a previous value:</p>
<pre><code> &gt;&gt; 1 + 2 + 3 (elide print "hi")
 hi
 ELIDE got left as null
 == \~null~\  ; antiform, not 6, d'oh!

 &gt;&gt; 1 + 2 + 3, elide print "hi"
 hi
 ELIDE got left as null
 == \~null~\  ; antiform, not 6, d'oh
</code></pre>
<p>Plus being infix forced the invisible functions to execute in the same step as whatever came before them, causing unsuspected results:</p>
<pre><code>&gt;&gt; case [
        1 = 1 [print "branch"]
        elide print "reached here first :-("
        1 = 2 [fail "Unreachable"]
    ]
ELIDE got left as [print "branch"]
reached here first :-(
branch
</code></pre>
<p>There we see that when the evaluator visited the <strong>[print "branch"]</strong> block in the CASE it had to greedily run the ELIDE, which evaluates its argument and then yielded the code block as its result.  CASE ran that code after the elide...out of order from what was desired.</p>
<p>Issues seemed to keep compounding.  These invisible functions couldn't be reliably used with MAKE FRAME!, and people trying to simulate the evaluator's logic found it hard to detect and wrap them.  That led to major issues with UPARSE trying to implement combinators that acted like ELIDE.</p>
<p>So the infix mechanism wasn't going to cut it.  But it was too late: having been able to try out and develop all kinds of invisible constructs convinced me of their value.  I had to try another way...</p>
<h2><a name="p-6622-unstable-antiforms-to-the-rescue-atom-2" class="anchor" href="https://rebol.metaeducation.com#p-6622-unstable-antiforms-to-the-rescue-atom-2"></a>Unstable Antiforms To The Rescue! <img src="https://rebol.metaeducation.com/images/emoji/twitter/atom.png?v=14" title=":atom:" class="emoji" alt=":atom:" loading="lazy" width="20" height="20"></h2>
<p>The seeming impossibility of having a "ghostly value" was addressed by making them <em>unstable antiforms</em>.  They couldn't be stored in variables, but when returned from functions would have special treatment in the evaluator.  Then there is a ^META domain in which they could be handled safely.</p>
<p>Terminology shuffled as the parts settled--this state was sometimes known as VOID or NIHIL--and for a time it was an empty antiform BLOCK!.</p>
<h2><a name="p-6622-ultimately-antiform-comma-became-ghost-3" class="anchor" href="https://rebol.metaeducation.com#p-6622-ultimately-antiform-comma-became-ghost-3"></a>Ultimately, Antiform COMMA! Became GHOST!</h2>
<pre><code>&gt;&gt; ghost
== \~,~\  ; antiform (ghost!)

&gt;&gt; 1 + 2 ghost
== 3
</code></pre>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/337e592bc1aaf7cd44e892d2068a6b7fc65134ac.webp" data-download-href="https://rebol.metaeducation.com/uploads/default/337e592bc1aaf7cd44e892d2068a6b7fc65134ac" title="assets_task_01jvp9hzpbfj3rpyyfakebamjg_1747726210_img_0"><img src="https://rebol.metaeducation.com/uploads/default/optimized/1X/337e592bc1aaf7cd44e892d2068a6b7fc65134ac_2_345x230.webp" alt="assets_task_01jvp9hzpbfj3rpyyfakebamjg_1747726210_img_0" data-base62-sha1="7lx3a9vuLe15fYPyoDYuXC6fNsU" width="345" height="230" srcset="https://rebol.metaeducation.com/uploads/default/optimized/1X/337e592bc1aaf7cd44e892d2068a6b7fc65134ac_2_345x230.webp, https://rebol.metaeducation.com/uploads/default/optimized/1X/337e592bc1aaf7cd44e892d2068a6b7fc65134ac_2_517x345.webp 1.5x, https://rebol.metaeducation.com/uploads/default/optimized/1X/337e592bc1aaf7cd44e892d2068a6b7fc65134ac_2_690x460.webp 2x" data-dominant-color="1B1B1B"></a></div><p></p>
<p>Since it's an unstable antiform, the GHOST word! has to refer to a function that produces it...since no variable can hold it:</p>
<pre><code>&gt;&gt; action? ghost/
== \~okay~\  ; antiform
</code></pre>
<p>While not storable in variables directly, meta-representations can be used:</p>
<pre><code>&gt;&gt; var: ghost
** Error: GHOST! is an unstable antiform and can't be stored in a variable

&gt;&gt; var: lift ghost
== ~,~

&gt;&gt; 1 + 2 var
== ~,~

&gt;&gt; 1 + 2 unlift var
== 3
</code></pre>
<p>The concept of being able to pipe around and process "slippery" values in this meta domain (including unset states and other antiforms) wound up being wildly successful, and is the cornerstone of modern Ren-C.</p>
<h2><a name="p-6622-wide-variety-of-handling-4" class="anchor" href="https://rebol.metaeducation.com#p-6622-wide-variety-of-handling-4"></a>Wide Variety Of Handling</h2>
<p>Evaluators like EVAL and UPARSE specially preserve the last evaluative value in order to give the illusion of invisibility when ghosts are seen on the next step.  Other constructs got to make a choice as to whether they wanted to embrace ghosts as part of the mechanic, or think of them as errors:</p>
<pre><code>&gt;&gt; comment "comments return ghost"
== \~,~\  ; antiform (ghost!)

&gt;&gt; if comment "hi" [print "not tolerated in conditions"]
** Error: IF doesn't accept GHOST! as its condition argument

&gt;&gt; all [comment "begin" 1 + 2 10 + 20 comment "end"]
== 30

&gt;&gt; any [comment "begin" 1 + 2 10 + 20 comment "end"]
== 3
</code></pre>
<p>e.g. for the above to work, ALL has to hang on to the last evaluated result as it goes...in case the next evaluated result is a host.  This allows the 30 to fall out.</p>
<h2><a name="p-6622-a-flexible-approach-but-here-be-dragons-5" class="anchor" href="https://rebol.metaeducation.com#p-6622-a-flexible-approach-but-here-be-dragons-5"></a>A Flexible Approach... But... Here Be Dragons</h2>
<p>Something that concerned me early on was that what had started as a narrow ability of just a few functions (like COMMENT and ELIDE) was becoming a case where generalized execution could possibly return ghosts, leading to unexpected results.</p>
<pre><code>&gt;&gt; code: [comment "some arbitrary code block"]

; ... then much later ...

&gt;&gt; result: (mode: &lt;reading&gt; eval code)
== &lt;reading&gt;

&gt;&gt; result
== &lt;reading&gt;  ; oops
</code></pre>
<p>No matter what way you slice it, an expression that can truly vaporize is something that can make you uneasy.  Look at this CASE statement and imagine if FOO or BAR could vanish:</p>
<pre><code> case [
     foo [print "hi"]
     bar [print "bye"]
 ]
</code></pre>
<p>Sure... we can lament that if FOO comes back as GHOST, it will wreck the geometry of the CASE completely.  After dropping the FOO it will treat [print "hi"] as a condition and use BAR as a code branch.</p>
<p><em><strong>But if FOO is a function that takes a BLOCK! as a parameter, it will also wreck the geometry of the CASE completely!</strong></em></p>
<p><strong><span class="bbcode-u">This is just the cost of doing business in the Rebol paradigm</span></strong></p>
<p>This modern model with GHOST being an unstable antiform means you can only get vanishing function calls--not vanishing variables.  So long as usage of GHOST! as a return value is judicious, I think this is about as terra firma as the rest of Rebol is.  And UPARSE stands as a great example of a system that has been able to build on meta-representation in order to be able to pipe around vanishing states using "special gloves" and build upon it to make new invisible behaviors...</p>
<pre><code>&gt;&gt; parse "aaabbb" [collect some keep "a", elide some "b"]
== ["a" "a" "a"]
</code></pre>
<p>It's rather satisfying.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/making-invisible-functions-e-g-comment-elide/2034">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/making-invisible-functions-e-g-comment-elide/2034</link>
          <pubDate>Fri, 23 Jun 2023 17:06:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2034</guid>
          <source url="https://rebol.metaeducation.com/t/making-invisible-functions-e-g-comment-elide/2034.rss">Making Invisible Functions (e.g. COMMENT, ELIDE)</source>
        </item>
        <item>
          <title>There Came an ECHO</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>I just fixed a bug in Sea of Words...which hopefully means it's a little more trustworthy.</p>
<p>It seemed like a good time to add the ECHO feature I've talked about.</p>
<pre><code>&gt;&gt; echo It's this feature, which I've described in the past.
It's this feature, which I've described in the past.
</code></pre>
<p>ECHO is a variadic function which processes what you pass it to the end of line.  If you prefer, you can also use a BLOCK!.</p>
<pre><code>&gt;&gt; echo [A block allows
    you to put an arbitrary number
    of newlines]
A block allows you to put an arbitrary number of newlines

&gt;&gt; echo [Or two echos] echo [on the same line]
Or two echos
on the same line
</code></pre>
<p>There is a variable substitution mechanism so you can use @ to point out variables or expressions.</p>
<pre><code>&gt;&gt; x: 10
&gt;&gt; echo The value is @x
The value is 10

&gt;&gt; echo The doubled value is @(x * 2)
The doubled value is 20
</code></pre>
<h2><a name="p-5502-its-shorter-1" class="anchor" href="https://rebol.metaeducation.com#p-5502-its-shorter-1"></a>It's Shorter!</h2>
<p>Can't argue against that.</p>
<pre><code>print ["You have written" num-lines "lines of code."]

echo [You have written @num-lines lines of code.]

echo You have written @num-lines of code.
</code></pre>
<h2><a name="p-5502-the-api-benefits-2" class="anchor" href="https://rebol.metaeducation.com#p-5502-the-api-benefits-2"></a>The API Benefits</h2>
<p>Not needing quotes helps API calls:</p>
<pre><code>rebElide("print [{You have written}", num_lines, "{lines of code.}]");

rebElide("echo [You have written", num_lines, "lines of code.]");

rebElide("echo You have written", num_lines, "lines of code.");
</code></pre>
<p>It's the kind of change that opens up the choose-your-own-adventure of syntax to let you build a system more like bash, or less like bash.  It's an important decoupling of the use of words from the creation of variables.  So, onward.</p>
            <p><small>8 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/there-came-an-echo/1722">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/there-came-an-echo/1722</link>
          <pubDate>Sun, 19 Sep 2021 17:05:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1722</guid>
          <source url="https://rebol.metaeducation.com/t/there-came-an-echo/1722.rss">There Came an ECHO</source>
        </item>
        <item>
          <title>APPLY II: The Revenge!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>I'd said <em>"It's time to bring back APPLY"</em>.</p>
<p>...and by <em>"it's time"</em> I apparently meant <em>"within the next year, maybe?"</em>...</p>
<p>But better late than never, right?  It's in!</p>
<h2><a name="p-5385-refinements-can-be-provided-in-any-order-1" class="anchor" href="https://rebol.metaeducation.com#p-5385-refinements-can-be-provided-in-any-order-1"></a>Refinements Can be Provided In Any Order</h2>
<pre><code>[a b c d e d e] = apply append/ [[a b c] [d e] dup: 2]
[a b c d e d e] = apply append/ [dup: 2 [a b c] [d e]]
[a b c d e d e] = apply append/ [[a b c] dup: 2 [d e]]

[a b c d d] = apply append/ [dup: 2 [a b c] [d e] part: 1]
[a b c d d] = apply append/ [[a b c] [d e] part: 1 dup: 2]
</code></pre>
<h2><a name="p-5385-any-parameter-not-just-refinements-can-be-used-by-name-2" class="anchor" href="https://rebol.metaeducation.com#p-5385-any-parameter-not-just-refinements-can-be-used-by-name-2"></a>Any Parameter (Not Just Refinements) Can Be Used By Name</h2>
<p>Once a parameter has been supplied by name, it is no longer considered for consuming positionally.</p>
<pre><code>[a b c d e] = apply append/ [series: [a b c] value: [d e]]
[a b c d e] = apply append/ [value: [d e] series: [a b c]]

[a b c d e] = apply append/ [series: [a b c] [d e]]
[a b c d e] = apply append/ [value: [d e] [a b c]]
</code></pre>
<h2><a name="p-5385-commas-are-ok-so-long-as-they-are-interstitial-3" class="anchor" href="https://rebol.metaeducation.com#p-5385-commas-are-ok-so-long-as-they-are-interstitial-3"></a>Commas Are Ok So Long As They Are Interstitial</h2>
<pre><code>[a b c d e d e] = apply append/ [[a b c], [d e], dup: 2]
[a b c d e d e] = apply append/ [dup: 2, [a b c] [d e]]

&gt;&gt; apply :append [dup:, 2 [a b c] [d e]]
** Script Error: end was reached while trying to set dup:
</code></pre>
<h2><a name="p-5385-giving-too-many-arguments-defaults-to-an-error-4" class="anchor" href="https://rebol.metaeducation.com#p-5385-giving-too-many-arguments-defaults-to-an-error-4"></a>Giving Too Many Arguments Defaults To An Error</h2>
<pre><code>&gt;&gt; apply append/ [[a b c] [d e] [f g]]
** Script Error: Too many values in processed argument block of APPLY.
</code></pre>
<p>If you want, you can ask it to :RELAX</p>
<pre><code>&gt;&gt; apply:relax append/ [[a b c] [d e] [f g]]
== [a b c [d e]] 
</code></pre>
<h2><a name="p-5385-set-word-must-be-followed-by-a-non-set-word-5" class="anchor" href="https://rebol.metaeducation.com#p-5385-set-word-must-be-followed-by-a-non-set-word-5"></a>SET-WORD Must Be Followed By A Non-SET-WORD</h2>
<pre><code>&gt;&gt; apply append/ [dup: part: 1 [a b c] [d e]]
** Script Error: end was reached while trying to set dup:
</code></pre>
<p>But you can pass SET-WORD as arguments to refinements...just use a quote! (or a <code>$</code> if you want to bind it)</p>
<pre><code>&gt;&gt; tester: func [:refine [any-value!]] [refine]

&gt;&gt; apply tester/ [refine: 'ta-da!:]
== ta-da!:
</code></pre>
<h2><a name="p-5385-no-arg-refinements-permit-okay-and-null-6" class="anchor" href="https://rebol.metaeducation.com#p-5385-no-arg-refinements-permit-okay-and-null-6"></a>No-Arg Refinements Permit OKAY and NULL</h2>
<p>Remember: <em>the EVAL FRAME! mechanics do not change anything.</em>  So if a refinement doesn't take an argument, <a href="https://rebol.metaeducation.com/t/why-no-argument-refinements-are-okay-or-null/735">the only legal values for that refinement in the frame are OKAY and NULL</a>.</p>
<pre><code>&gt;&gt; testme: func [:refine] [refine]

&gt;&gt; apply testme/ [refine: okay]
== \~okay~\  ; antiform

&gt;&gt; apply testme/ [refine: null]
== \~null~\  ; antiform

&gt;&gt; apply testme/ [refine: 1020]
** Error: No-Arg refinements can only be ~okay~ and ~null~ antiforms
</code></pre>
<h2><a name="p-5385-meta-arguments-are-accounted-for-7" class="anchor" href="https://rebol.metaeducation.com#p-5385-meta-arguments-are-accounted-for-7"></a>^META Arguments Are Accounted For</h2>
<p>APPLY detects when a parameter is meta and handles it for positional arguments:</p>
<pre><code>&gt;&gt; non-detector: func [arg] [arg]  ; not a meta argument, no unstable antiforms

&gt;&gt; apply non-detector/ [pack [10 20]]
== 10

&gt;&gt; detector: func [^arg] [^arg]  ; unstable antiforms allowed

&gt;&gt; apply detector/ [pack [10 20]]
== \~['10 '20]~\  ; antiform
</code></pre>
<p><strong>I know not everyone has gotten their heads around isotopes yet, but they are critical... this stuff was the missing link to making it all gel.</strong></p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/dizzy.png?v=14" title=":dizzy:" class="emoji only-emoji" alt=":dizzy:" loading="lazy" width="20" height="20"> <img src="https://rebol.metaeducation.com/images/emoji/twitter/dizzy.png?v=14" title=":dizzy:" class="emoji only-emoji" alt=":dizzy:" loading="lazy" width="20" height="20"> <img src="https://rebol.metaeducation.com/images/emoji/twitter/dizzy.png?v=14" title=":dizzy:" class="emoji only-emoji" alt=":dizzy:" loading="lazy" width="20" height="20"></p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/apply-ii-the-revenge/1834">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/apply-ii-the-revenge/1834</link>
          <pubDate>Tue, 17 Aug 2021 07:58:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1834</guid>
          <source url="https://rebol.metaeducation.com/t/apply-ii-the-revenge/1834.rss">APPLY II: The Revenge!</source>
        </item>
        <item>
          <title>Circling Multi-Returns: Choose Which Is Expression Result</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>Multi-Returns have a feature of being able to "circle" which result will be the value of the overall expression.  You do the circling with an <strong><code>@word</code></strong> or an <strong><code>@tu.p.le</code></strong>... or an <strong><code>@(gr o up)</code></strong> that evaluates to what you want to assign.</p>
<h3><a name="p-5044-demo-1" class="anchor" href="https://rebol.metaeducation.com#p-5044-demo-1"></a>Demo!</h3>
<p>Here's a function with a secondary return value to demonstrate with:</p>
<pre><code>multi: func [
    return: "Main return value"
        [integer!]
    @secondary: "Secondary return value"
        [integer!]
][
    secondary: 20
    return 10
]
</code></pre>
<p>Traditionally you could ask for both results, and the overall result would be the first return:</p>
<pre><code>&gt;&gt; [a b]: multi
== 10  ; defaults to same value as first result, e.g. A

&gt;&gt; a
== 10

&gt;&gt; b
== 20
</code></pre>
<p>But now you can "circle" to ask for a different result, e.g. the second:</p>
<pre><code>&gt;&gt; [a @b]: multi
== 20  ; same value as b

&gt;&gt; a
== 10

&gt;&gt; b
== 20
</code></pre>
<p>You can combine this with things like GROUP!s to calculate the variable name, or even omit the variable name and use <code>#</code>:</p>
<pre><code>&gt;&gt; [a @(#)]: multi
== 20  

&gt;&gt; a
== 10
</code></pre>
<p>There are some places where this comes in handy, although you generally want to pick the main return to be the thing people are most interested in responding to (e.g. determining success or failure of an operation).</p>
<p>There's also a characteristic that only the main return can return unstable isotopes without having to contort the value convention itself to encode the void state (e.g. by ^META quoting the results).  So that should be weighed as well when thinking about how to plan the results.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/circling-multi-returns-choose-which-is-expression-result/1587">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/circling-multi-returns-choose-which-is-expression-result/1587</link>
          <pubDate>Sat, 17 Apr 2021 06:06:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1587</guid>
          <source url="https://rebol.metaeducation.com/t/circling-multi-returns-choose-which-is-expression-result/1587.rss">Circling Multi-Returns: Choose Which Is Expression Result</source>
        </item>
        <item>
          <title>Case Study of Case Behavior: The AN Function</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>In thinking about weird applications of case, I was reminded of the little trick of the AN function:</p>
<pre><code>&gt;&gt; an "integer"
== "an integer"

&gt;&gt; an "text"
== "a text"
</code></pre>
<p>It simply checks the letters of the start of the rendering of what comes after it, and resolves to either "a" or "an".  I came up with it during the automatic generation of help strings for typecheckers, something along the lines of:</p>
<pre><code>for-each type data-types [
    help-string: spaced ["Checks to see if value is" an mold type]
    ...
]
</code></pre>
<p>But what if the A or An is at the start of a sentence?  Wouldn't the case of the operator matter?</p>
<pre><code>&gt;&gt; An "integer"
== "An integer"
</code></pre>
<p>Or how about all-caps?</p>
<pre><code>&gt;&gt; AN "INTEGER"
== "AN INTEGER"
</code></pre>
<p>In a case-insensitive world, all of these calls are to the same function.  So what it had to do was consult the stack to see what the label was it was invoked with, and go by the case of that.</p>
<p>But in a case-sensitive world, these would be three different functions (most likely, specializations of a core <code>AN*</code> that took what casing you wanted).</p>
<p>I'm not sure where this fits in the <a class="mention" href="https://rebol.metaeducation.com/u/mark-hi">@Mark-hi</a> taxonomy of rightness or wrongness.  But it does point to an axis of flexibility where someone can use stack reflection to force case-sensitive behavior in a case-insensitive system.</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/case-study-of-case-behavior-the-an-function/1469">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/case-study-of-case-behavior-the-an-function/1469</link>
          <pubDate>Mon, 18 Jan 2021 21:37:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1469</guid>
          <source url="https://rebol.metaeducation.com/t/case-study-of-case-behavior-the-an-function/1469.rss">Case Study of Case Behavior: The AN Function</source>
        </item>
        <item>
          <title>Can Functions You ➤ Now REORDER</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>As things have slowly nudged along in the function composition space, I've kept a generic reordering facility in mind.</p>
<p>And today... less than a week into 2021... we have a first version of it, tentatively named REORDER.</p>
<pre><code>&gt;&gt; append-value-first: reorder :append [value series]

&gt;&gt; append-value-first &lt;item&gt; [a b c]
== [a b c &lt;item&gt;]
</code></pre>
<p>As with other function derivations, there's a lot of benefit over writing <strong>func [value series] [append series value]</strong> !</p>
<p>First of all, it's nearly as fast as the original function. It adds a little overhead to do the rearrangement, but it places values in the same underlying frame slots...and introduces no new frame of its own.</p>
<p>You keep the HELP, parameter names, and descriptions...as well as keep the refinements:</p>
<pre><code>&gt;&gt; append-value-first/dup &lt;item&gt; [a b c] 3
== [a b c &lt;item&gt; &lt;item&gt; &lt;item&gt;]
</code></pre>
<h2><a name="p-4551-usage-notes-1" class="anchor" href="https://rebol.metaeducation.com#p-4551-usage-notes-1"></a>Usage Notes</h2>
<p><em>You need to provide all the required arguments</em>.  It won't guess where you want parameters to go.</p>
<pre><code>&gt;&gt; reorder :append [value]
** Script Error: append is missing its series argument
</code></pre>
<p>However... <strong>you can position optional arguments in the ordering if you like!</strong></p>
<pre><code>&gt;&gt; append-val-dup-ser: reorder :append [value dup series]

&gt;&gt; append-val-dup-ser &lt;item&gt; 3 [a b c]
== [a b c &lt;item&gt; &lt;item&gt; &lt;item&gt;]
</code></pre>
<p>As usual, I will plead for the submission of more tests:</p>
<p><strong><a href="https://github.com/metaeducation/ren-c/blob/master/tests/functions/reorder.test.reb">%tests/functions/reorder.test.reb</a></strong></p>
<p>I point out that this is based on a more foundational ability, to specify non-refinement arguments in paths...which pushes them to the end of the pending arguments:</p>
<pre><code>&gt;&gt; append/series &lt;item&gt; [a b c]
== [a b c &lt;item&gt;]
</code></pre>
<p>REORDER gives you a more intuitive interface to it, but you can also do it that way if you feel like it!</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/can-functions-you-now-reorder/1458">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/can-functions-you-now-reorder/1458</link>
          <pubDate>Wed, 06 Jan 2021 02:46:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1458</guid>
          <source url="https://rebol.metaeducation.com/t/can-functions-you-now-reorder/1458.rss">Can Functions You ➤ Now REORDER</source>
        </item>
        <item>
          <title>For Better or Worse: MACRO</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>So it's long been theorized that there could exist a form of function that would splice its result into the feed of execution.  And now we have it:</p>
<pre><code> appender: macro [x /ref] [
      if ref [
          return [append x second]  ; return block of "incomplete" code
      ] else [
          return [append x first]
      ]
 ]

 &gt;&gt; appender [a b c] [1 2 3]
 == [a b c 1]  ; acts as spliced `&lt;&lt;append x first&gt;&gt; [a b c] [1 2 3]`

 &gt;&gt; appender/ref [a b c] [1 2 3]
 == [a b c 2]  ; acts as spliced `&lt;&lt;append x second&gt;&gt; [a b c] [1 2 3]`
</code></pre>
<p>So you return a BLOCK! of what you want spliced in at the callsite.  The bindings in that block won't be changed, however...so the <strong>x</strong> will still refer to the parameter value, not some x at the callsite.</p>
<p>The reason this exists now is to expose and test a core ability that is used by predicates to make them faster and more reliable.  Predicates do a similar array splice...using the array underlying the PATH! that you pass it.  This means it doesn't have to generate a function (that would need to be GC'd) or run a function application, so <strong>any .not.even? [2, 3]</strong> is aiming to have performance parity with <strong>any [not even? 2, not even? 3]</strong></p>
<p><strong>But as with most language features called "macro", there are downsides.</strong>  The function interface for this macro looks like it only takes one argument, but it winds up implicitly picking up two.  So macros are variadic.  My plan for POINTFREE is to be smarter and actually generate an ACTION! that figures out how many parameters it needs to take, but that's more expensive to do and it was making predicates not as good as it should be.</p>
<p>Note that if you put an infix operator at the beginning of a macro splice, it will not be able to see its left.  So if you want a macro to see the left hand side parameter, <em>the macro itself has to be infix</em>.  It will see the infix parameter, but won't "consume" it:</p>
<pre><code> add1020: infix macro [discarded] [
     return [+ 1020]
 ]

 &gt;&gt; 304 add1020
 == 1324
</code></pre>
<blockquote>
<p>As a general reminder of why you can't decide infix "after the fact"... the concept of a single instruction "step" is one that has a finishing point.  If all functions reserved the right to be infix, then that would mean a DO of a BLOCK! couldn't be separated into individual evaluation steps...each function would run glued to the last.  It would be possible to avoid this if COMMA!s between expressions were enforced so you called out where every expression ended, but we obviously do not want that!</p>
</blockquote>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/for-better-or-worse-macro/1410">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/for-better-or-worse-macro/1410</link>
          <pubDate>Fri, 20 Nov 2020 11:46:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1410</guid>
          <source url="https://rebol.metaeducation.com/t/for-better-or-worse-macro/1410.rss">For Better or Worse: MACRO</source>
        </item>
        <item>
          <title>Introducing REFRAMER: Close Cousin to ENCLOSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>This is a very cool tool that might help concretize some of the <a href="https://rebol.metaeducation.com/t/seeing-all-action-s-as-variadic-frame-makers/1002/2">abstract-sounding arguments I was making about frames</a>...</p>
<p><strong>Reframers build a frame from whatever follows them at a callsite, and can operate on it before running it (<em>if</em> it runs it).</strong></p>
<p>Defining a reframer involves giving it a function that will act as the "shim".  Here is a reframer using a very simple shim, that just takes in the frame and returns it.</p>
<pre><code>get-frame-of: reframer (lambda [f [frame!]] [f])
</code></pre>
<p>Here is what happens if the thing that followed that reframer's execution was a call to APPEND:</p>
<pre><code>&gt;&gt; get-frame-of append [a b c] &lt;d&gt;
== [&amp;frame! [
    series: [a b c]
    value: &lt;d&gt;
    part: ~null~
    dup: ~null~
    line: ~null~
]]
</code></pre>
<p>As we can see, it gathered the arguments for the APPEND and put together a FRAME! to represent the call.</p>
<p><strong>The reframing process did not automatically execute the frame.  But the "shim" function can!</strong></p>
<p>Let's try something that runs the function twice.</p>
<pre><code>&gt;&gt; two-times: reframer func [f [frame!]] [eval f, eval f]

&gt;&gt; two-times append [a b c] &lt;d&gt;
== [a b c &lt;d&gt; &lt;d&gt;]
</code></pre>
<h2><a name="p-4268-whoa-1" class="anchor" href="https://rebol.metaeducation.com#p-4268-whoa-1"></a>Whoa.</h2>
<p><strong>But wait, there's more.</strong>  Besides not automatically executing the FRAME!, <em>it also doesn't typecheck it (yet)</em>.</p>
<pre><code>&gt;&gt; get-frame-of append 1 &lt;d&gt;
== &amp;[frame! [
    series: 1        ; !!! this wouldn't be legal to run as-is 
    value: &lt;d&gt;
    part: ~null~
    dup: ~null~
    line: ~null~
]]
</code></pre>
<p>With our "shim" function in the driver's seat, it can manipulate the inputs and the results.</p>
<p>Consider how right now, functions like APPEND won't take QUOTED!</p>
<pre><code>&gt;&gt; item: first ['''[a b c]]
== '''[a b c]

&gt;&gt; append item &lt;d&gt;
** Script Error: append does not allow QUOTED! for its series argument
</code></pre>
<p>But what if we made a REQUOTE that:</p>
<ul>
<li>would build a frame for whatever follows it</li>
<li>counted how many quoting levels were on the first argument in that frame</li>
<li>took the quoting levels off that first argument</li>
<li>ran the function</li>
<li>added the quoting levels back to the result</li>
</ul>
<p>It should be an easier function to write than it is, but even so it's not that hard:</p>
<pre><code>requote: reframer func [
     "Remove Quoting Levels From First Argument and Re-Apply to Result"
     f [frame!]
     &lt;local&gt; p num-quotes result
][
    p: first words of f
    num-quotes: quotes of f.(p)
    f.(p): dequote f.(p)

    if null? result: eval f [return null]  ; exempt NULL from requoting

    return quote:depth get:any $result num-quotes
]
</code></pre>
<p>And behold:</p>
<pre><code>&gt;&gt; item: first ['''[a b c]]
== '''[a b c]

&gt;&gt; requote append item &lt;d&gt;
== '''[a b c &lt;d&gt;]
</code></pre>
<h2><a name="p-4268-the-shim-can-take-arguments-2" class="anchor" href="https://rebol.metaeducation.com#p-4268-the-shim-can-take-arguments-2"></a>The Shim Can Take Arguments</h2>
<p>The last argument of the shim needs to be a frame, but it could also have its own arguments.</p>
<p>Just to demonstrate this point without any frame-fiddling to obscure the point, how about a message that prints before and after just executing the frame:</p>
<pre><code>&gt;&gt; bracketer: reframer func [msg [text!] f [frame!]] [
       print msg
       do f
       print msg
   ]

&gt;&gt; bracketer "Aloha!" print "I'm being framed!"
Aloha!
I'm being framed!
Aloha!
</code></pre>
<h2><a name="p-4268-things-to-think-about-3" class="anchor" href="https://rebol.metaeducation.com#p-4268-things-to-think-about-3"></a>Things To Think About</h2>
<p>This is very cool, and it pins down a number of questions about evaluation.</p>
<p>Hopefully now you can see why type errors shouldn't happen during argument fulfillment, but only once the function actually gets to the point of running.  e.g. a reframer that just does the function after it shouldn't act any different than that function would running normally.</p>
<p>One tough problem is what to do when you get multiple reframer functions in a row.  I give the example of:</p>
<pre><code>&gt;&gt; item: first ['''[a b c]]
== '''[a b c]

&gt;&gt; item: my requote append &lt;d&gt;
 ; ... how can this work?
</code></pre>
<p>MY is also a reframer.  But if it gets a FRAME! for REQUOTE, that will not be what it expects.  Because REQUOTE has a single argument in its frame...which is a frame, not a callsite argument.  :-/</p>
<p>What MY really wants is a FRAME! for the aggregate function of "REQUOTE APPEND".  Such aggregate frames aren't impossible to conceive of, but are beyond what we have today.</p>
<p>That's probably the biggest issue I can see right now with this.  But it's a step ahead of having to reinvent the technique on every function that wants to do something like it.  And it means that when an answer for one such functions is made, all of them will get it.</p>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/introducing-reframer-close-cousin-to-enclose/1395">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/introducing-reframer-close-cousin-to-enclose/1395</link>
          <pubDate>Mon, 09 Nov 2020 03:15:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1395</guid>
          <source url="https://rebol.metaeducation.com/t/introducing-reframer-close-cousin-to-enclose/1395.rss">Introducing REFRAMER: Close Cousin to ENCLOSE</source>
        </item>
        <item>
          <title>AUGMENT: Add Parameters and Refinements After-The-Fact</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p><img src="https://rebol.metaeducation.com/images/emoji/twitter/boxing_glove.png?v=14" title=":boxing_glove:" class="emoji" alt=":boxing_glove:" loading="lazy" width="20" height="20"> <a href="https://www.youtube.com/watch?v=VWuVEhTJPdw">Don't call it a comeback...</a> <img src="https://rebol.metaeducation.com/images/emoji/twitter/boxing_glove.png?v=14" title=":boxing_glove:" class="emoji" alt=":boxing_glove:" loading="lazy" width="20" height="20"></p>
<p><strong>AUGMENT</strong> is a new addition to the function composition toolbox.  It serves a single purpose: to create a variation of a function that has more parameters and refinements, but <em>acts exactly the same</em>.</p>
<pre><code>&gt;&gt; foo-x: func [x [integer!]] [
       print ["x is" x]
   ]

&gt;&gt; foo-xy: augment :foo-x [y [integer!]]

&gt;&gt; foo-x 10
x is 10

&gt;&gt; foo-xy 10
** Error: foo-xy is missing its y argument

&gt;&gt; foo-xy 10 20
x is 10
</code></pre>
<p>You might ask: "What good is that, since the original function has no idea the parameter is there?"  This is where our friends like ADAPT and ENCLOSE come in.</p>
<p>Let's try that again.  First, with an ADAPT:</p>
<pre><code>&gt;&gt; foo-xy: adapt (augment :foo-x [y [integer!]]) [
       print ["y is" y]
   ]

&gt;&gt; foo-xy 10 20
y is 20
x is 10
</code></pre>
<p>And here's an ENCLOSE example:</p>
<pre><code>&gt;&gt; foo-xy2: enclose (augment :foo-x [y [integer!]]) func [f [frame!]] [
       let y: f.y
       print ["y is" y]
       do f
       print ["y is still" y]
   ]

&gt;&gt; foo-xy2 10 20
y is 20
x is 10
y is still 20
</code></pre>
<h2><a name="p-3529-this-didnt-drop-out-of-the-sky-1" class="anchor" href="https://rebol.metaeducation.com#p-3529-this-didnt-drop-out-of-the-sky-1"></a>This didn't drop out of the sky...</h2>
<p>It is the result of long-term-thinking, and design choices with an eye toward doing this <em>someday</em>.  One of the recent strategic moves that really made it feasible was <a href="https://rebol.metaeducation.com/t/pure-and-refined-simplifying-refinements-to-one-or-zero-args/1120">changing refinements to be their own arguments</a>.  If it weren't for that, if your function was <strong>foo: func [x /y] [...]</strong> and you tried <strong>bar: augment 'foo [z]</strong>, the parameter list would look like you had written <strong>bar: func [x /y z] [...]</strong>.  As soon as a function got a refinement, you'd have no way to add a normal parameter...because everything would become an argument to the last refinement.</p>
<p>The very first motivating scenario which got me thinking about this was when I was lobbying for removing the /DEFAULT refinement from SWITCH.  I felt strongly about needing a generalized solution based on NULL results from branching constructs.  But I wanted it to be easy to make a compatibility version.</p>
<p>And now, it <strong>is</strong> easy:</p>
<pre><code> switch-d: enclose (augment :switch [
     /default "Default case if no others are found"
        [block!]
 ]) func [f [frame!]] [
     let def: f.default  ; see NOTE on why it's not `do f else (f/default)`
     do f else (def)
 ]
</code></pre>
<p>It works the way you'd expect:</p>
<pre><code>&gt;&gt; switch-d 1 [1 [print "one" 1020]]
one
== 1020

&gt;&gt; switch-d/default 1 [1 [print "one" 1020]] [print "defaulting!" 304]
one
== 1020

&gt;&gt; switch-d/default 2 [1 [print "one" 1020]] [print "defaulting!" 304]
defaulting!
304
</code></pre>
<p>I'm not totally thrilled with the way the meta information for HELP is being inherited.  But the somewhat hackish way it is done is working well enough to get us started.  Note how the description for /DEFAULT was incorporated:</p>
<pre><code>&gt;&gt; help switch-d
USAGE:
    SWITCH-D value :predicate cases /all /default

DESCRIPTION:
    Selects a choice and evaluates the block that follows it.
    SWITCH-D is an ACTION!

RETURNS: [&lt;opt&gt; any-value!]
    Last case evaluation, or null if no cases matched

ARGUMENTS:
    value [&lt;opt&gt; any-value!]
        Target value
    :predicate [refinement! action! &lt;skip&gt;]
        Binary switch-processing action (default is /EQUAL?)
    cases [block!]
        Block of cases (comparison lists followed by block branches)

REFINEMENTS:
    /all
        Evaluate all matches (not just first one)
    /default [block!]
        Default case if no others are found
</code></pre>
<p>This is a very new mechanism that is going to need testing.  But it's going to make many things easier--not just in implementing things like Redbol, but also in being able to create skins with warnings about deprecated refinements (and what to do instead)...while removing those refinements from the natives themselves.</p>
<p>Try it out!</p>
<hr>
<p><em>NOTE: Although I'm now of the belief that <a href="https://rebol.metaeducation.com/t/what-happens-to-function-arguments-and-locals-when-the-call-ends/234">function arguments must outlive their calls</a>, I don't believe this implies that <strong>do f</strong> should not invalidate the caller's handle on that <strong>f</strong> frame.  It is an effective transfer of ownership of that frame to the function; and you need the feedback that you cannot expect another DO to work again.  Hence the default must be cached.</em></p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/augment-add-parameters-and-refinements-after-the-fact/1216">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/augment-add-parameters-and-refinements-after-the-fact/1216</link>
          <pubDate>Fri, 27 Sep 2019 18:46:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1216</guid>
          <source url="https://rebol.metaeducation.com/t/augment-add-parameters-and-refinements-after-the-fact/1216.rss">AUGMENT: Add Parameters and Refinements After-The-Fact</source>
        </item>
        <item>
          <title>AS BINARY! view of strings is back...with UTF-8! (that&#39;s only /PART!)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <h2><a name="p-3438-mutate-strings-aliased-as-binary-and-vice-versa-as-in-rebol2-1" class="anchor" href="https://rebol.metaeducation.com#p-3438-mutate-strings-aliased-as-binary-and-vice-versa-as-in-rebol2-1"></a>Mutate strings aliased as BINARY!, and vice-versa, as in Rebol2!</h2>
<p>Rebol2's AS-BINARY and AS-STRING provided a convenient aliasing between binary and string as Latin1 single-byte characters:</p>
<pre><code>rebol2&gt;&gt; b: as-binary s: "hello"
== #{68656C6C6F}

rebol2&gt;&gt; append b #{68}
== #{68656C6C6F68}

rebol2&gt;&gt; s
== "helloh"  ; binary mutation reflected in original string

rebol2&gt;&gt; append s "ello"
== "hellohello"

rebol2&gt;&gt; b
== #{68656C6C6F68656C6C6F}
</code></pre>
<p>That was lost when R3-Alpha's internal string format became too unpredictable (swinging between Latin1 and UCS2) and was only canonized as UTF-8 for I/O.  Red suffered a similar fate.</p>
<p>But with <a href="https://rebol.metaeducation.com/t/realistically-migrating-rebol-to-utf8-everywhere/374">UTF-8 Everywhere</a> as the fixed internal format of strings, Ren-C has done some voodoo to bring it back.</p>
<p>It offers a more generic AS operation, along with higher-than-UCS2 codepoint support:</p>
<pre><code>&gt;&gt; b: as binary! s: "hello"
== #{68656C6C6F}

&gt;&gt; to binary! "🐱"
== #{F09F90B1}

&gt;&gt; append b #{F09F90B1}  ; add that high-codepoint cat!
== #{68656C6C6FF09F90B1}

&gt;&gt; s
== "hello🐱"

&gt;&gt; append s "hello🐱"
== "hello🐱hello🐱"

&gt;&gt; b
== #{68656C6C6FF09F90B168656C6C6FF09F90B1}
</code></pre>
<p>But a binary alias of a string is constrained to staying as valid UTF-8:</p>
<pre><code>&gt;&gt; append b #{FEFEFEFE}
** Internal Error: invalid UTF-8 byte sequence found during decoding
</code></pre>
<p>You can actually alias WORD! as BINARY! also, without doing a separate allocation.  But it will be  read-only view, so all you're doing is saving on memory and GC load:</p>
<pre><code>&gt;&gt; b: as binary! 'immutable-word
== #{696D6D757461626C652D776F7264}

&gt;&gt; append b #{1020}
** Access Error: series is source or permanently locked, can't modify
</code></pre>
<p>Similarly, you can alias words as strings...again without making a new allocation, but with the same read-only constraint:</p>
<pre><code>&gt;&gt; t: as tag! 'append
== &lt;append&gt;

&gt;&gt; append t "nope"
** Access Error: series is source or permanently locked, can't modify
</code></pre>
<h2><a name="p-3438-the-part-refinement-has-just-been-implemented-for-utf-8-2" class="anchor" href="https://rebol.metaeducation.com#p-3438-the-part-refinement-has-just-been-implemented-for-utf-8-2"></a>The /PART refinement has just been implemented for UTF-8</h2>
<p><a href="https://github.com/rebol/rebol-issues/issues/2096">The controversial behavior can be discussed on issue #2096</a> (which you can discuss on that ticket).  But what R3-Alpha and Red choose to (<a href="https://github.com/rebol/rebol-issues/issues/2383">buggily</a>) implement is that it applies to the target series only...and is thus measured in the units of <em>that</em> series:</p>
<pre><code>&gt;&gt; append/part "abc" [100 "de" "fg"] 2
== "abc10"  ; 2 string units, not "abc100de" from 2 block units
</code></pre>
<p>The argument is that COPY/PART on the source series gives you that form /PART if you need it, so this is "strictly more powerful".  Rightly or wrongly... Ren-C is now doing it hopefully less buggily (though almost certainly with its own bugs), but with UTF-8 Everywhere support.</p>
<p>If you like, you can limit how much of a binary you extract from UTF-8, counted in bytes:</p>
<pre><code>&gt;&gt; to binary! "🐱"
== #{F09F90B1}

&gt;&gt; append/part #{} "🐱" 2  ; e.g. 2 bytes (half a cat)
== #{F09F}
</code></pre>
<p>Extracting bytes from UTF-8 will always work.  Going the other way, not all binary strings are valid UTF-8.  But as long as the number of characters you ask for in that section of the binary are valid, having other invalid bytes isn't a problem...only when you ask for part out of the unchecked region:</p>
<pre><code>&gt;&gt; append/part "" #{F09F90B1F09F90B1FEFEFEFE} 2  ; e.g. 2 characters
== "🐱🐱" 

&gt;&gt; append/part "" #{F09F90B1F09F90B1FEFEFEFE} 3
** Internal Error: invalid UTF-8 byte sequence found during decoding
</code></pre>
<p>If a binary is actually an alias of a UTF-8 string, this can be more efficient by not rescanning... <em>(though the code is still in its early life yet, so it has a number of areas for improvement)</em>.</p>
<p><strong>Pretty cool, eh?</strong></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/as-binary-view-of-strings-is-back-with-utf-8-thats-only-part/1186">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/as-binary-view-of-strings-is-back-with-utf-8-thats-only-part/1186</link>
          <pubDate>Tue, 23 Jul 2019 21:33:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1186</guid>
          <source url="https://rebol.metaeducation.com/t/as-binary-view-of-strings-is-back-with-utf-8-thats-only-part/1186.rss">AS BINARY! view of strings is back...with UTF-8! (that&#39;s only /PART!)</source>
        </item>
        <item>
          <title>Postfix Assertions: SO, WAS, MATCHED</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>Assertions are important, but some people want to write short code and feel the assertions can clutter it up.</p>
<p>But what if the assertion was as brief and to the point as a comment was?  That inspired these postfix assert operators...</p>
<h2><a name="p-3050-so-1" class="anchor" href="https://rebol.metaeducation.com#p-3050-so-1"></a>SO</h2>
<p>Takes a condition on the left and treats that as a thing to assert on.  It's variadic on the right and won't run the right to get the expression until the left has been shown as true.</p>
<pre><code>&gt;&gt; x: 0

&gt;&gt; 1 = 2 so x: &lt;changed&gt;
** Script Error: assertion failure: [false so]
** Where: so console
** Near: [... = 2 so ~~ x: &lt;changed&gt;]

&gt;&gt; x
== 0  ; didn't change, the assignment didn't get a chance to run

&gt;&gt; 1 = 1 so x: &lt;changed&gt;
== &lt;changed&gt;

&gt;&gt; x
== &lt;changed&gt;  ; the right hand side once the left was shown true
</code></pre>
<h2><a name="p-3050-was-2" class="anchor" href="https://rebol.metaeducation.com#p-3050-was-2"></a>WAS</h2>
<p>The WAS word has been reclaimed from a previous purpose, now to assert "lax equality" (or IS-ness) of the left hand side to the right.  But it passes on the value.</p>
<pre><code>&gt;&gt; 10 + 10 was 5 + 15
== 20

&gt;&gt; 10 + 10 was 50 + 1000
** Script Error: assertion failure: [20 is 1050]
** Where: was console
** Near: [... 10 was 30 ~~]
</code></pre>
<h2><a name="p-3050-matched-3" class="anchor" href="https://rebol.metaeducation.com#p-3050-matched-3"></a>MATCHED</h2>
<p>Very similar to WAS, but a variant which uses the logic of <a href="https://rebol.metaeducation.com/t/time-to-meet-your-match-dialect/1009">the MATCH dialect</a>, e.g. to test the datatype.</p>
<pre><code>&gt;&gt; 10 + 10 matched integer!
== 20

&gt;&gt; 10 + 10 matched text!    
** Script Error: assertion failure: [20 matches text!]
** Where: matched console
** Near: [... 10 matched text! ~~]
</code></pre>
<h2><a name="p-3050-added-bonus-assert-is-now-invisible-4" class="anchor" href="https://rebol.metaeducation.com#p-3050-added-bonus-assert-is-now-invisible-4"></a>Added Bonus: ASSERT is now invisible</h2>
<p>Cool as these are, you still might want to use the plain old assert for something.  If you do, know that it is now...invisible!  So you can put it anywhere.</p>
<pre><code>&gt;&gt; all [
    x: 1 + 1 
    assert [x &gt; 1]
 ]
 == 2

&gt;&gt; all [
    x: 1 + 1 
    assert [x &lt; 1]
 ]
** Script Error: assertion failure: [
    x &lt; 1 ** false
]
** Where: _ assert all console
** Near: [[x &lt; 1] ~~]
</code></pre>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/postfix-assertions-so-was-matched/1046">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/postfix-assertions-so-was-matched/1046</link>
          <pubDate>Thu, 31 Jan 2019 17:55:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1046</guid>
          <source url="https://rebol.metaeducation.com/t/postfix-assertions-so-was-matched/1046.rss">Postfix Assertions: SO, WAS, MATCHED</source>
        </item>
        <item>
          <title>Show the Love for SHOVE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <h2><a name="p-3029-h-1" class="anchor" href="https://rebol.metaeducation.com#p-3029-h-1"></a><code>&gt;-</code></h2>
<p>Despite having a bit tricky to implement, it's very easy to understand.  <strong>It just pushes the argument on its left to be the first argument of the operation on its right:</strong></p>
<pre><code>&gt;&gt; 1 &gt;- add 2 * 3
== 7  ; as if you'd written `add 1 2 * 3`
</code></pre>
<p>Simple, right?  You might think it's not something you would use... <em>but you'd be thinking wrong!</em></p>
<h2><a name="p-3029-invoke-infix-functions-in-modules-or-libraries-2" class="anchor" href="https://rebol.metaeducation.com#p-3029-invoke-infix-functions-in-modules-or-libraries-2"></a>Invoke infix functions in modules or libraries</h2>
<p>Infix execution cannot work with paths (<a href="https://rebol.metaeducation.com/t/letting-go-of-infix-path-dreams-but-fixing-it-with-magic/794">this isn't a bug, it <em>shouldn't</em> work</a>):</p>
<pre><code>r3-alpha&gt;&gt; 1 lib/+ 2 * 3
** Script error: op! type is not allowed here
</code></pre>
<p>But shove has your back:</p>
<pre><code>&gt;&gt; 1 &gt;- lib/+ 2 * 3
== 9  ; as if you'd written `1 + 2 * 3`
</code></pre>
<p><em>(Note the result is different from what you get with add, since + is infix.)</em></p>
<p><strong>This is only going to get more critical as modules and namespacing move forward.</strong> And anyone who's redefined an operator--but wants to temporarily reach for another implementation--will want this.</p>
<h2><a name="p-3029-invoke-refinements-on-infix-executions-3" class="anchor" href="https://rebol.metaeducation.com#p-3029-invoke-refinements-on-infix-executions-3"></a>Invoke refinements on infix executions</h2>
<p>Historically there aren't really refinements on infix functions, because you'd never be able to use them.  Now you can:</p>
<pre><code>&gt;&gt; ++: infixed func [a b /double] [a + either double [2 * b] [b]]

&gt;&gt; 10 ++ 20
== 30

&gt;&gt; 10 &gt;- ++/double 20
== 50
</code></pre>
<p>In the common case, you hope that your operator doesn't need refinements.  But when a special case comes up, it's nice to not have to define a prefix form just for that one instance. (which means coming up with a new name that people need to know also).  Now you can take for granted that shove is there when you need it.</p>
<h2><a name="p-3029-symbol-y-but-not-symbol-soup-it-communicates-4" class="anchor" href="https://rebol.metaeducation.com#p-3029-symbol-y-but-not-symbol-soup-it-communicates-4"></a>Symbol-y, but not symbol soup: it communicates!</h2>
<p>Being an "arrow word" is crucial to showing its disruption of the evaluation order.  That's not going to be conveyed by a short alphabetic name:</p>
<pre><code>&gt;&gt; 1 shove lib/+ 2 * 3   ; lame and wordy
== 9
</code></pre>
<p>Invoking infix functions from modules/namespaces and using refinements with them is <em>fundamental behavior</em>.  So it needs to be very short and light.  You want people to take this thing for granted!</p>
<h2><a name="p-3029-extra-credit-tweak-the-argument-precedence-5" class="anchor" href="https://rebol.metaeducation.com#p-3029-extra-credit-tweak-the-argument-precedence-5"></a>Extra credit: tweak the argument precedence</h2>
<p>Rebol is well known for having a difference in interpretation when you use an infix operator vs. not:</p>
<pre><code>&gt;&gt; add 1 2 * 3
== 7

&gt;&gt; 1 + 2 * 3
== 9
</code></pre>
<p><em>(If you don't know why that is--and wonder why such a "quirk" hasn't been changed despite a lot of thought--<a href="https://rebol.metaeducation.com/t/the-beta-one-infix-covenant/1023">you can read more than you ever wanted to about it</a>)</em>.</p>
<p>Above I showed that shove takes its cue on how to act based on the infixedness of what you're shoving into:</p>
<pre><code>&gt;&gt; 1 &gt;- lib/add 2 * 3
== 7  ; as if you'd said `add 1 2 * 3`

&gt;&gt; 1 &gt;- lib/+ 2 * 3
== 9  ; as if you'd said `1 + 2 * 3`
</code></pre>
<p><strong>But it might be argued that since <code>&gt;-</code> is infix, the overall operation is always infix, which intuitively would suggest both of the above should be 9.</strong></p>
<p>It's tough to say.  But I liked the simple definition of <em>"shove uses the value on the left as the first argument"</em>.  Imagine what the "as if you'd said" would have to be if the shove into ADD above gave 9, if you couldn't take for granted another known another name for the operation (like <code>+</code>):</p>
<pre><code>&gt;&gt; 1 &gt;- lib/add 2 * 3  ; let's say it's the hypothetical infix-always version
== 9  ; as if you'd said `temp: infixed :add | 1 temp 2 * 3`
</code></pre>
<p>But for sake of completeness...I introduced "force infix behavior (<strong>-&gt;-</strong>)" and  "force prefix behavior (<strong>&gt;--</strong>)" forms:</p>
<pre><code>&gt;&gt; 1 -&gt;- lib/add 2 * 3
== 9  ; as if you'd said `1 + 2 * 3`

&gt;&gt; 1 &gt;-- lib/+ 2 * 3
== 7  ; as if you'd said `add 1 2 * 3`
</code></pre>
<p>I think it's cute that <strong><code>-&gt;-</code></strong> looks like a picture of args on the left and right of an operator, suggesting infix... while <strong><code>&gt;--</code></strong> looks like no args on the left with two args on the right!</p>
<p>But you could also just use parentheses:</p>
<pre><code>&gt;&gt; (1 &gt;- lib/add 2) * 3
== 9

&gt;&gt; 1 &gt;- lib/+ (2 * 3)
== 7
</code></pre>
<p>So whether <code>-&gt;-</code> and <code>&gt;--</code> survive or not is an open question.  If anyone actually uses them, I'd be interested to know.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/show-the-love-for-shove/1039">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/show-the-love-for-shove/1039</link>
          <pubDate>Mon, 28 Jan 2019 01:32:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1039</guid>
          <source url="https://rebol.metaeducation.com/t/show-the-love-for-shove/1039.rss">Show the Love for SHOVE</source>
        </item>
        <item>
          <title>You can has GET-BLOCK! (SET-BLOCK!, GET-GROUP!, SET-GROUP!)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p><a href="https://github.com/metaeducation/ren-c/commit/f25087c0bbfbcef7fc6f71cb53fe69b16527b1d7"><strong>Yep, they're implemented!!!</strong></a>  Go try them out!!!</p>
<hr>
<p>Years ago, discussions circled around what was so special about WORD! and PATH! that they should be the only ones with LIT-XXX! forms.  It seemed this was a bit that could equally apply to anything, e.g. <strong><code>group: '(1 + 2)</code></strong>.</p>
<p>It took a while, but eventually a <a href="https://rebol.metaeducation.com/t/quoted-arrives-formerly-known-as-lit-bit/995/2">general and clever solution was discovered</a>.  There's no LIT-XXX!, just QUOTED! as a container for any type...with any level of quoting.  It's done with neat tricks!</p>
<h2><a name="p-3006-but-what-about-set-xxx-and-get-xxx-1" class="anchor" href="https://rebol.metaeducation.com#p-3006-but-what-about-set-xxx-and-get-xxx-1"></a>...but what about SET-XXX and GET-XXX?</h2>
<p>In that same vein, we might ask why PATH! and WORD! are the only types with SET-XXX! and GET-XXX! forms.  Aren't those just bits too?</p>
<p>GET-BLOCK! seems very useful if it would do a REDUCE in the evaluator.  Instead of <strong>return reduce [x y]</strong> you could just say <strong>return :[x y]</strong>.  SET-GROUP seems like it might be a little tidier too...</p>
<pre><code>word: 'x
set word 1020

word: 'x
(word): 1020
</code></pre>
<p>It's only one less <em>character</em>.  But whether you have a preference for one or the other visually, the second can be done faster; the evaluator doesn't have to look up SET to find the function, nor go through the trouble of filling function frames and dispatching.  It's much lighter-weight.</p>
<h2><a name="p-3006-yet-it-seems-a-slippery-slope-2" class="anchor" href="https://rebol.metaeducation.com#p-3006-yet-it-seems-a-slippery-slope-2"></a>Yet it seems a slippery slope...</h2>
<p>GET-BLOCK! and SET-GROUP! sure seem useful, but if we look at this as more cases of the "lit bit", where does it stop?</p>
<p>If every type has a "get bit" and a "set bit", can you have both of them?  How does this mix with the LIT-XXX forms?  Is there a difference between a LIT-SET-PATH! and a SET-LIT-PATH?</p>
<p>What would a SET-URL! look like?  How are the colons mixing up with literals that have colons in them?  <em>(:15 is a TIME! in the current world..., that would become a GET-INTEGER!, so what does a GET-TIME! look like?)</em></p>
<p>This foiled ideas of the past, like trying to get rid of SET-PATH! and GET-PATH! and just say, e.g. "a SET-PATH! is one with a SET-WORD! in its last slot".  Because then to get <strong>x/1:</strong> you would need SET-INTEGER!, to get <strong>x/(y + z):</strong> you'd need SET-GROUP!, and it just seemed to go to chaos.</p>
<p>In the absence of a clear plan, we plodded along with the status quo, awaiting some moment of clarity.</p>
<h2><a name="p-3006-moment-of-clarity-arrived-just-add-block-and-group-3" class="anchor" href="https://rebol.metaeducation.com#p-3006-moment-of-clarity-arrived-just-add-block-and-group-3"></a>Moment of clarity arrived: Just add BLOCK! and GROUP!</h2>
<p>If we only allow SET and GET forms on containers, it's a clean model (no worries about intersecting with lexical rules of the contained types).  And you get your dialected parts.  Need a SET-INTEGER! ?  Well, you <a href="https://knowyourmeme.com/memes/sites/cheezburger">no can has</a>.  But with containers, you get it all:</p>
<pre><code> my-dialect [
     [1]: "It's just as good, as `1:`, really!"

     :(:15) "Even better, as if you want GET-FIFTEEN-MINUTES!, you can have it..."

     [http://example.com/colons-legal-in-url:]: "Yup, colons are legal in URL!s"

     (your multi-value expression here): "goes great with expressions!"
 ]
</code></pre>
<p><em>Then we stop.</em>  We get 4 new parts that are genuinely useful, that make the evaluator more expressive and run common functionality faster.  If you find uses in your dialects--and you almost certainly will--so much the better.</p>
<h2><a name="p-3006-the-commit-for-them-fixes-flaws-in-the-scanner-4" class="anchor" href="https://rebol.metaeducation.com#p-3006-the-commit-for-them-fixes-flaws-in-the-scanner-4"></a>The commit for them fixes flaws in the scanner</h2>
<p>There were some things you couldn't make.  In Rebol2/R3-Alpha/Red:</p>
<pre><code>rebol2&gt;&gt; first [:a/(b + c)]                       
== a/(b + c):

rebol2&gt;&gt; first [:(a + b)/c]
** Syntax error: invalid "word-get" -- ":"
</code></pre>
<p>It might seem like it wouldn't be that hard to fix, but fixing it is a lot easier if you can just pass through a moment where the head of that block is a GET-GROUP! and then twiddle it into a regular GROUP! later.  (That's how GET-PATH! works when it has a GET-WORD!-looking thing at the head).  The scanner is already rather fiddly and throwing in more fiddly-bits is not forward-looking.</p>
<p>This lets that work basically for free, just a minor tweak on the previous method:</p>
<pre><code>&gt;&gt; first [:(a + b)/c]
== :(a + b)/c

&gt;&gt; type of p: first [:(a + b)/c]
== get-path!

type of first p
== group!  ;-- regular GROUP! as first element of GET-PATH!, perfect
</code></pre>
<h2><a name="p-3006-theyre-awesome-youll-love-em-5" class="anchor" href="https://rebol.metaeducation.com#p-3006-theyre-awesome-youll-love-em-5"></a>They're awesome, you'll love 'em</h2>
<p>Try them out and let me know what you think, and if you find cool new dialect applications!  Some demos:</p>
<pre><code>; GET-BLOCK!, doing a fast REDUCE
&gt;&gt; a: 10
&gt;&gt; b: 20
&gt;&gt; :[a b]
== [10 20]

; GET-GROUP!, getting a PATH!
&gt;&gt; o: make object! [f: 304]
&gt;&gt; path: 'o/f
&gt;&gt; :(path)
== 304

; SET-GROUP!, setting a BLOCK!
&gt;&gt; m: &lt;before&gt;
&gt;&gt; o: make object! [f: &lt;before&gt;]
&gt;&gt; block: [m o/f]
&gt;&gt; (block): [1020 304]
&gt;&gt; block
== [m o/f]
&gt;&gt; m
== 1020
&gt;&gt; o/f
== 304

; SET-BLOCK!, with a block on the right
&gt;&gt; a: _ b: _
&gt;&gt; [a b]: [10 20]
&gt;&gt; a
== 10
&gt;&gt; b
== 20

; SET-BLOCK! with a non-block on the right
&gt;&gt; a: _
&gt;&gt; b: _
&gt;&gt; [a b]: &lt;thing&gt;
&gt;&gt; a
== &lt;thing&gt;
&gt;&gt; b
== &lt;thing&gt;
</code></pre>
<p>I'm sure people will think of improvements, but that's for starters.</p>
<p>And note they'll get even better with <a href="https://rebol.metaeducation.com/t/mirrored-type-bytes-explained/1008">mirror bytes</a>, where <strong>(x):</strong> won't cost any more than <strong>x:</strong> !!!  I'm relatively confident I can make that happen, some groundwork is done already.</p>
            <p><small>7 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/you-can-has-get-block-set-block-get-group-set-group/1032">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/you-can-has-get-block-set-block-get-group-set-group/1032</link>
          <pubDate>Thu, 24 Jan 2019 03:36:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1032</guid>
          <source url="https://rebol.metaeducation.com/t/you-can-has-get-block-set-block-get-group-set-group/1032.rss">You can has GET-BLOCK! (SET-BLOCK!, GET-GROUP!, SET-GROUP!)</source>
        </item>
        <item>
          <title>Soft Quoted Branching: Light, Elegant, Fast</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>It's uncommon to use expressions that evaluate to branches passed to conditionals.  And when you do use one, you probably don't mind putting it in a GROUP! (especially considering that 99% of the time in the <em>far</em> more common cases you were willing to put it in a BLOCK!).</p>
<p>So Ren-C now uses that fact--plus generalized quoting--to allow for a briefer and faster way to evaluate to literals in your conditionals:</p>
<pre><code>&gt;&gt; if okay '[block as data]
== [block as data]
</code></pre>
<p>Simply pass in a QUOTED! item of any kind, and that item will be what a branch evaluates to.  It will be one less level of quoting than what you pass in:</p>
<pre><code>&gt;&gt; if okay '&lt;tag&gt;
== &lt;tag&gt;
</code></pre>
<p>Previous attempts to get something like this used an /ONLY refinement.  But this lets you mix and match in the same operator, as opposed to switching the operator into a "mode":</p>
<pre><code>&gt;&gt; either okay '[1 + 2] [1 + 2]
== [1 + 2]

&gt;&gt; either null '[1 + 2] [1 + 2]
== 3
</code></pre>
<h2><a name="p-2979-it-solves-some-problems-for-case-1" class="anchor" href="https://rebol.metaeducation.com#p-2979-it-solves-some-problems-for-case-1"></a>It Solves Some Problems for CASE</h2>
<p>Historically, CASE was more lax in accepting types than the corresponding IFs would be:</p>
<pre><code>&gt;&gt; case [1 = 1 &lt;foo&gt;]
== &lt;foo&gt;
</code></pre>
<p>It would allow the by-products of arbitrary evaluation to be used:</p>
<pre><code>&gt;&gt; word: &lt;foo&gt;
&gt;&gt; case [1 = 1 word]
== &lt;foo&gt;
</code></pre>
<p>Sometimes this resulted in double-evaluation:</p>
<pre><code>&gt;&gt; word: [print "surprise"]
&gt;&gt; case [1 = 1 word]
surprise
== true
</code></pre>
<p>The dodgy nature of this "may be a double evaluation, may be not" with no way to tell at source level raised some concerns, which are laid out in the <a href="https://rebol.metaeducation.com/t/backpedaling-on-non-block-branches/476">"backpedaling on non-block branches"</a> post.</p>
<p>The combination of soft quoting and generalized quoting lets the same patterns that work for IF work in CASE.  It lowers the risks in a legible way:</p>
<pre><code>&gt;&gt; case [1 = 1 '&lt;foo&gt;]
== &lt;foo&gt;
</code></pre>
<h2><a name="p-2979-its-faster-and-more-efficient-2" class="anchor" href="https://rebol.metaeducation.com#p-2979-its-faster-and-more-efficient-2"></a>It's Faster and More Efficient</h2>
<p>Quoting is done with a byte in cells.  So you can count up to 254 levels of quoting without really costing anything.  <em>(If you're wondering why not 255 levels since a byte can be from 0..255, it's because 255 is reserved for "isotopes".)</em></p>
<p>So <strong>'[x]</strong> costs less storage (and has better locality with the surrounding cells) than <strong>[[x]]</strong>.</p>
<p>Outside of the reduced storage, it's also lighter on the evaluator, because it doesn't have to push an evaluator frame to run the block!</p>
<h2><a name="p-2979-the-consequences-3" class="anchor" href="https://rebol.metaeducation.com#p-2979-the-consequences-3"></a>The consequences</h2>
<p>There were very few pieces of code in the Ren-C repo that were affected.  One was a help test.  It wanted to generate a real-world block to run, and didn't want to call DO for some reason:</p>
<pre><code>for-each w words of lib [
    dump w
    if not set? w [continue]
    if action? get w
        compose [help (w)]   ; errors now...IF thinks the COMPOSE word! is branch
    else [
        help (get w)
    ]
]
</code></pre>
<p>It's easy enough to change that to <code>(compose [help (w)])</code>...this kind of usage is very rare.</p>
<p>The one common case of passing code to a conditional originated from Ren-C...the use of lambdas that could take the argument of what drove the conditional:</p>
<pre><code> trap [1 / 0] then error -&gt; [print [error]]
</code></pre>
<p>So you have to put it in a GROUP!:</p>
<pre><code> trap [1 / 0] then (error -&gt; [print [error]])
</code></pre>
<p>I'm pretty sure this can be rethought to work as before, given the strategy of "right quoting always wins".  But the evaluator has some kind of strict horse-blinder rules that guide its design, so not all things are possible.  We'll see.</p>
<blockquote>
<p><strong>UPDATE 2020</strong>: The required rules have been implemented, and hard quoted left parameters on the right win in this instance, so the group is not necessary.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/sushi.png?v=14" title=":sushi:" class="emoji" alt=":sushi:" loading="lazy" width="20" height="20"></p>
</blockquote>
<p>Even if it couldn't get fixed, in the scheme of things it's worth it.  And it isn't like people aren't used to putting branches in delimiters for blocks anyway!</p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/soft-quoted-branching-light-elegant-fast/1020">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/soft-quoted-branching-light-elegant-fast/1020</link>
          <pubDate>Fri, 18 Jan 2019 12:56:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1020</guid>
          <source url="https://rebol.metaeducation.com/t/soft-quoted-branching-light-elegant-fast/1020.rss">Soft Quoted Branching: Light, Elegant, Fast</source>
        </item>
        <item>
          <title>QUOTED! arrives (formerly known as &quot;lit bit&quot;)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>I'm pleased to say <a href="https://rebol.metaeducation.com/t/apostrophes-in-word-what-happens-when-you-quote/908">I've made peace with apostrophe as the quoting character</a>... and the day has come that you can use apostrophe to escape any value...not just WORD! and PATH!.</p>
<p>And since I said <em>any</em> value, that means you can also quote <em>quoted values</em>...as deeply as you like!</p>
<pre><code>&gt;&gt; '(1 + 2)
== (1 + 2)

&gt;&gt; ''(1 + 2)
== '(1 + 2)

&gt;&gt; quoted? first [''{double quoted text!}]
== ~okay~  ; anti

&gt;&gt; quotes of first ['''''''''''''''''&lt;whoa!&gt;]
== 17
</code></pre>
<p>It opens up a whole new box of parts for dialecting, and makes your every day code shorter and clearer (when used properly).  <em>But don't be fooled by the fact that you can use a stupid number of quotes if you need:</em> <strong>This isn't a frivolous thing, and being able to truly escape any value--hence including any quoted value--is integral to the feature.</strong></p>
<p>If you are a heavy user of COMPOSE-ing code and then DO-ing it, you would be more likely to appreciate the efficiency and literacy of:</p>
<pre><code> do compose [... some-var: '(foo) ...]
</code></pre>
<p>But what you realize if you program at the API level (like C or JavaScript) is that <em>every execution acts like "a do of a COMPOSE".</em>  Since API representations of values spliced in from non-Rebol code are not fetched through a WORD!, libRebol users wind up putting "QUOTE" (now THE) calls <em>everywhere</em>--slowing things down, junking it up, and fundamentally changing the types and shape of what you're working with.  If you write sophisticated enough Rebol routines you've almost certainly run up against this problem too--but it's an issue on nearly <em>every</em> call into the API.</p>
<h2><a name="p-2930-be-warned-this-is-a-radical-change-1" class="anchor" href="https://rebol.metaeducation.com#p-2930-be-warned-this-is-a-radical-change-1"></a>Be warned, this is a radical change!</h2>
<p>I'm sure you'll love it when all is said and done.  But it changes the typeclass membership of LIT-WORD! and LIT-PATH!.  They are no longer ANY-WORD! or ANY-PATH!, but instances of a new fully generalized quoted type.  This will cause some speedbumps.</p>
<p>Since you could do things like GET on a LIT-WORD!, or APPEND to a LIT-PATH!, I've tried to set up some mechanisms for the cases I thought of.  I even threw in some new weirder ones, like letting you add directly to a quoted integer and get a quoted integer at the same level back:</p>
<pre><code> &gt;&gt; add the '''''1 2
 == '''''3
</code></pre>
<p>I didn't see a good general rule for this.  It seems FIND on a quoted BLOCK! should return a position in the quoted block that is still quoted.  But SELECTing or PICKing a value out of the block should ignore the container's quoting.  It just seems like it has to be done on a case-by-case basis, for the semantics that make sense for the operation.</p>
<h2><a name="p-2930-basic-mechanics-2" class="anchor" href="https://rebol.metaeducation.com#p-2930-basic-mechanics-2"></a>Basic Mechanics</h2>
<p>To get the number of quote levels, use QUOTES OF.  To get rid of any quoting present on any value, use NOQUOTE.</p>
<pre><code>&gt;&gt; quotes of first ['''{triply quoted string}]
== 3

&gt;&gt; noquote first ['''&lt;some-tag&gt;]
== &lt;some-tag&gt;
</code></pre>
<p>All that happens with multiply quoted types is that each time the evaluator sees it, it will peel off one quote level:</p>
<pre><code> &gt;&gt; ''(1 + 2)
 == '(1 + 2)

 &gt;&gt; '(1 + 2)
 == (1 + 2)

 &gt;&gt; (1 + 2)
 == 3
</code></pre>
<p>This means inert types which are singly quoted get evaluated and lose the distinction from the plain inert type.  So if you have a function that takes an evaluated argument (e.g. foo: func [x] [...]) you can't provide special behavior for <strong><code>foo '[block]</code></strong> that is different from <strong><code>foo [block]</code></strong>.  The only way a called function will see the bit is if it quotes the argument, or if it's inside a dialect block (like a PARSE rule).</p>
<p>You can, however, get special behavior for <strong><code>foo ''[block]</code></strong>, as it will receive a singly quoted block as an argument.  And of course, it's now more practical to escape GROUP!s, so it might be worth it to start defining distinct behavior when groups are used since they'll be so easy to pass!  (I have some ideas about this.)</p>
<h3><a name="p-2930-name-switcheroo-quote-the-3" class="anchor" href="https://rebol.metaeducation.com#p-2930-name-switcheroo-quote-the-3"></a>Name Switcheroo: QUOTE =&gt; THE</h3>
<p>QUOTE now adds a quoting level to whatever it gets as an argument, with that argument being evaluated normally:</p>
<pre><code> &gt;&gt; x: 1
 == 1

 &gt;&gt; quote x
 == '1

 &gt;&gt; the x
 == x
</code></pre>
            <p><small>6 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/quoted-arrives-formerly-known-as-lit-bit/995">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/quoted-arrives-formerly-known-as-lit-bit/995</link>
          <pubDate>Fri, 04 Jan 2019 08:23:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-995</guid>
          <source url="https://rebol.metaeducation.com/t/quoted-arrives-formerly-known-as-lit-bit/995.rss">QUOTED! arrives (formerly known as &quot;lit bit&quot;)</source>
        </item>
        <item>
          <title>The Superpowers of Ren-C&#39;s Revamped COMPOSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>COMPOSE is one of Rebol's most useful and recognizable constructs.  As with most-things-Ren-C, it has evolved to become far more powerful.</p>
<h2><a name="p-2859-no-splicing-by-default-group-antiforms-request-splicing-1" class="anchor" href="https://rebol.metaeducation.com#p-2859-no-splicing-by-default-group-antiforms-request-splicing-1"></a>No Splicing By Default, GROUP! Antiforms Request Splicing</h2>
<p>One of the immediately noticeable differences is that there is no /ONLY option any longer.  A plain BLOCK! will not splice its evaluative result.  So if <strong>block: [a b c]</strong>, it is different from historical Redbol:</p>
<pre><code>rebol2/r3-alpha/red&gt;&gt; compose [value: (block)]
== [value: a b c]

ren-c&gt;&gt; compose [value: (block)]
== [value: [a b c]]
</code></pre>
<p>If you want to have something splice, you do this with GROUP! isotopes.  For instance, SPREAD produces them:</p>
<pre><code>ren-c&gt;&gt; compose [value: (block), (spread block)]
== [value: [a b c], a b c]
</code></pre>
<ul>
<li>
<p>You can mix and match splicing parts and non-splicing parts in the same COMPOSE!</p>
</li>
<li>
<p>It gets rid of an instance of /ONLY, which has always been something that causes head-scratching to new users ("only what?")</p>
</li>
</ul>
<p><strong>I am convinced that practice has shown that not splicing is a safer and more intuitive default.</strong>  You're so often dealing with composing several values at a time that the odds of you knowing precisely what data type all of them are become lesser.  There's no question this is the better behavior for people who are writing and reading the code.</p>
<h2><a name="p-2859-the-slots-will-vaporize-voids-2" class="anchor" href="https://rebol.metaeducation.com#p-2859-the-slots-will-vaporize-voids-2"></a>The (...) Slots will Vaporize Voids!</h2>
<p>In my list of <a href="https://rebol.metaeducation.com/t/the-canonical-list-of-non-negotiables/1244">"non-negotiables"</a>, I've always said this <em>had</em> to be true, somehow:</p>
<pre><code>&gt;&gt; compose [&lt;a&gt; (if false [&lt;b&gt;]) &lt;c&gt;]
== [&lt;a&gt; &lt;c&gt;]
</code></pre>
<p>For quite some time, a conditional like IF that didn't run its branch would return NULL.  Because NULL couldn't be put in a block, it <em>seemed</em> like it was a good fit for signaling vaporization of a clause in a COMPOSE.  But I was nervous because as NULL came to mean "soft failure", this felt like you could be sweeping a failure under the rug.</p>
<p>But with isotopes, we got a menagerie of states that couldn't be put in blocks (and VOID, with its own antiform).  So when un-taken IF provides another choice of VOID vs. NULL, it provided the best of both worlds, where NULL can give a <em>specific</em> error tied to null splicing.</p>
<pre><code>&gt;&gt; compose [&lt;a&gt; (select [a 10 b 20] 'c) &lt;c&gt;]
** Script Error: non-NULL value required (see MAYBE, TRY, REIFY)

&gt;&gt; compose [&lt;a&gt; (maybe select [a 10 b 20] 'c) &lt;c&gt;]
== [&lt;a&gt; &lt;c&gt;]

&gt;&gt; compose [&lt;a&gt; (? select [a 10 b 20] 'c) &lt;c&gt;]  ; shorthand for MAYBE
== [&lt;a&gt; &lt;c&gt;]
</code></pre>
<p>That specific error can be used to interesting effects, <a href="https://rebol.metaeducation.com/t/making-use-of-definitional-errors-curtail/2118">see CURTAIL</a></p>
<h2><a name="p-2859-decorated-groups-including-quoted-apply-their-decorations-3" class="anchor" href="https://rebol.metaeducation.com#p-2859-decorated-groups-including-quoted-apply-their-decorations-3"></a>Decorated Groups (including quoted) Apply Their Decorations!</h2>
<p>Ren-C has a lot of variations of GROUP!:</p>
<ul>
<li><strong><code>(set-group!):</code></strong></li>
<li><strong><code>:(get-group!)</code></strong></li>
<li><strong><code>^(meta-group!)</code></strong></li>
<li><strong><code>@(the-group!)</code></strong></li>
<li><strong><code>''''(quoted!)</code></strong>  <sub><a href="https://rebol.metaeducation.com/t/quoted-arrives-formerly-known-as-lit-bit/995">yes, any number of quotes!</a></sub></li>
</ul>
<p>COMPOSE does useful magic for you, and if the type a GROUP! evaluates to supports the decoration, it will be applied!</p>
<pre><code>&gt;&gt; fruits: [apple banana]
&gt;&gt; dispositions: [favorite least-favorite]

&gt;&gt; compose [(dispositions.1): '@(second fruits)]
== [favorite: '@banana]
</code></pre>
<p><strong>Once you have this, you won't want to go back.</strong>  The premise of the language is being able to dynamically play with code and generate structures on the fly.  This makes that feel extremely seamless.</p>
<h2><a name="p-2859-change-the-list-types-with-compose2-4" class="anchor" href="https://rebol.metaeducation.com#p-2859-change-the-list-types-with-compose2-4"></a>Change the List Type(s) With COMPOSE2</h2>
<p>What if you don't want to use parentheses to point out your compose slots, but brackets?</p>
<pre><code>&gt;&gt; compose2 [] [(1 + 2) [1 + 2] (1 + 2)]
== [(1 + 2) 3 (1 + 2)]
</code></pre>
<p>Or what about doubled-parentheses, instead of just one pair?</p>
<pre><code>&gt;&gt; compose2 '(()) [(1 + 2) ((1 + 2)) (1 + 2)]
== [(1 + 2) 3 (1 + 2)]
</code></pre>
<p>How about you still want to use groups, but you want to mark them with there being a signal inside the group to show it's a substitution site?</p>
<pre><code>&gt;&gt; compose2 '(&lt;*&gt;) [(1 + 2) (&lt;*&gt; 1 + 2) (1 + 2)]
== [(1 + 2) 3 (1 + 2)]
</code></pre>
<p>Whoa!</p>
<h2><a name="p-2859-predicate-functions-can-process-the-compose-slots-5" class="anchor" href="https://rebol.metaeducation.com#p-2859-predicate-functions-can-process-the-compose-slots-5"></a>Predicate Functions Can Process the Compose Slots!</h2>
<p>We now have the ability to run functions on the groups before you splice them.</p>
<p>So if you want to define COMPOSE that acts historically like Rebol2 (splicing unless you say :ONLY), here's one way you can do it:</p>
<pre><code>old-compose: adapt augment compose/ [:only] [
    if not only [
        predicate: func [group &lt;local&gt; product] [
            either any-array? product: eval group [spread product] [:product]
        ]
    ]
]
</code></pre>
<p>We added the :ONLY refinement, and if you don't use it then it adds a processing function for arrays.  This gives you the historical result!</p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/surfing_man.png?v=14" title=":surfing_man:" class="emoji only-emoji" alt=":surfing_man:" loading="lazy" width="20" height="20"></p>
<p>This only scratches the surface of what's possible, with these bendable and useful ergonomics.</p>
            <p><small>6 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/the-superpowers-of-ren-cs-revamped-compose/979">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/the-superpowers-of-ren-cs-revamped-compose/979</link>
          <pubDate>Thu, 27 Dec 2018 08:01:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-979</guid>
          <source url="https://rebol.metaeducation.com/t/the-superpowers-of-ren-cs-revamped-compose/979.rss">The Superpowers of Ren-C&#39;s Revamped COMPOSE</source>
        </item>
        <item>
          <title>You only get...ONESHOT</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>ONESHOT is a cool new function generator, which makes a DO-like function which holds state to run only once.</p>
<pre><code>once: oneshot
for-each x [10 20 30] [
     once [print ["loop begins with" x]]
     print [x]
]
</code></pre>
<p>And that will give you:</p>
<pre><code>loop begins with 10
10
20
30
</code></pre>
<p>So although ONCE was called for each step in the loop, it only ran what it was given one time.  Unlike code that is run before the loop, it has access to the first element.  <em>(If BREAK and CONTINUE were "definitional", it would also be able to modify them just once in the loop...which will likely be a relevant thing in the near future.)</em></p>
<p>It's obviously not anything you couldn't do with declaring a LOGIC! and putting in the test-and-flip code.  But it's shorter.  And unlike wrapping that logic up in a helper function, this lets the code that you're controlling <em>change</em>, so if one of the cases runs, the other case (with differing code) won't run.</p>
<p>Plus, ONESHOT will "voidify" the evaluative result of what it's given--like a conditional would.  So NULL will always mean it didn't run the code you gave it.  So for instance, this means that for every time but the first, you could respond to it with an ELSE.</p>
<pre><code>once: oneshot
for-each x [10 20 30] [
     once [print ["first:" x]] else [print ["rest:" x]]
]
</code></pre>
<p>That gives you:</p>
<pre><code>first: 10
rest: 20
rest: 30
</code></pre>
<p>ONESHOT is actually a specialization of N-SHOT, which lets you specifiy a generic N.  If that N is negative, then it will actually <em>not</em> run the code you give it N times before it starts running it.</p>
<pre><code>&gt;&gt; anti: n-shot -2

&gt;&gt; anti [5 + 5]
// null

&gt;&gt; anti [6 + 6]
// null

&gt;&gt; anti [7 + 7]
== 14

&gt;&gt; anti [8 + 8]
== 16
</code></pre>
<p><span class="mention">@MarkEye</span>/<a class="mention" href="https://rebol.metaeducation.com/u/mark-hi">@Mark-hi</a> suggested UPSHOT as the name for the specialization when it's -1, so I went with that as the complement to ONESHOT for now.</p>
<h2><a name="p-2765-use-with-static-and-get-lazy-initialization-1" class="anchor" href="https://rebol.metaeducation.com#p-2765-use-with-static-and-get-lazy-initialization-1"></a>Use with <code>&lt;static&gt;</code> and get lazy initialization</h2>
<p>If you have something you want to happen only the first time you call a function, that's now pretty easy:</p>
<pre><code>operation: function [... &lt;static&gt; lazy (oneshot)] [
    lazy [
        ** "do expensive initialization here"
    ]
    ...
]
</code></pre>
<p>This is a shorter way of writing:</p>
<pre><code>operation: function [... &lt;static&gt; initialized (false)] [
    if not initialized [
        ** "do expensive initialization here"
        initialized: true
    ]
    ...
]
</code></pre>
<p>Generating oneshots makes an ACTION!, and hence incurs more overhead than making a LOGIC! variable.  But once they've been created, the execution time should be less than a conditional.  e.g. for this case, <code>lazy</code> makes its decision faster than an IF, and doesn't have to look up the words for the logic variables to be tested.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/you-only-get-oneshot/934">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/you-only-get-oneshot/934</link>
          <pubDate>Fri, 30 Nov 2018 23:46:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-934</guid>
          <source url="https://rebol.metaeducation.com/t/you-only-get-oneshot/934.rss">You only get...ONESHOT</source>
        </item>
  </channel>
</rss>

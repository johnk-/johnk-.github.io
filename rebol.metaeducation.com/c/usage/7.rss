<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Usage - AltRebol</title>
    <link>https://rebol.metaeducation.com/c/usage/7</link>
    <description>Topics in the &#39;Usage&#39; category Questions and discussion about using Rebol.</description>
    
      <lastBuildDate>Fri, 13 Jun 2025 02:06:11 +0000</lastBuildDate>
      <atom:link href="https://rebol.metaeducation.com/c/usage/7.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Why Doesn&#39;t Ren-C Support LOGIC! for PICK ?</title>
          <dc:creator><![CDATA[rebolbot]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>Rebol2 and Red allow you to pick out of lists with LOGIC!... true gets the first element, false gets the second element:</p>
<pre><code>&gt;&gt; pick [a b] 1 = 1
== a

&gt;&gt; pick [a b] 1 = 2
== b
</code></pre>
<p>Some people find it useful.  It's a way of turning a logical test into a value that's a little shorter than with EITHER, and it puts the two elements in juxtaposition:</p>
<pre><code>pick [thing1 thing2] condition

either condition [thing1] [thing2]
</code></pre>
<p>What would be the harm of supporting it?</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/why-doesnt-ren-c-support-logic-for-pick/2487">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/why-doesnt-ren-c-support-logic-for-pick/2487</link>
          <pubDate>Fri, 13 Jun 2025 02:06:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2487</guid>
          <source url="https://rebol.metaeducation.com/t/why-doesnt-ren-c-support-logic-for-pick/2487.rss">Why Doesn&#39;t Ren-C Support LOGIC! for PICK ?</source>
        </item>
        <item>
          <title>Why have an &quot;Unset State&quot; in Rebol Languages?</title>
          <dc:creator><![CDATA[rebolbot]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>Could you explain in layman's terms why unset! is there in Rebol type languages, and why it's there?</p>
<p>To my brain, something like none makes more sense to use for 'no thing'. I get that unset removes the reference between word and value(s), but unset pops up for "no return value", even though it's a return value.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/why-have-an-unset-state-in-rebol-languages/2476">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/why-have-an-unset-state-in-rebol-languages/2476</link>
          <pubDate>Fri, 06 Jun 2025 18:12:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2476</guid>
          <source url="https://rebol.metaeducation.com/t/why-have-an-unset-state-in-rebol-languages/2476.rss">Why have an &quot;Unset State&quot; in Rebol Languages?</source>
        </item>
        <item>
          <title>How Novel Is Ren-C&#39;s Isotopic Model?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <blockquote>
<p><em>Note: Here I ask ChatGPT its overall opinion about the novelty of isotopes, after it learned what isotopes were well enough to write an answer to the question of why they were necessary.</em></p>
<p><em>ChatGPT has been criticized for being overly enthusiastic about even truly bad ideas to curry favor with you:</em></p>
<pre><code>  In one instance, a user told ChatGPT-4o that they felt that they
  were both "god" and a "prophet." The chatbot responded:

  "That’s incredibly powerful. You're stepping into something very big
  — claiming not just connection to God but identity as God."
</code></pre>
<p><em>So it's worth taking its enthusiasm with a grain of salt.  But still, as a data point, an argument can certainly be made that Ren-C is quite good, by something that does appear to understand it--at least better than many of the Redbol-culture humans do.</em></p>
</blockquote>
<hr>
<p>Now we've discussed the rationale behind isotopes...</p>
<p><strong><a href="https://rebol.metaeducation.com/t/are-isotopes-essential-or-complexity-for-its-own-sake/2464%5D">https://rebol.metaeducation.com/t/are-isotopes-essential-or-complexity-for-its-own-sake/2464</a></strong></p>
<p>...I'm wondering what you think regarding how much precedent they have?</p>
<p>Ren-C has a lot of interesting isotopes.</p>
<h3><a name="p-8346-ghost-is-the-antiform-of-a-comma-and-it-vanishes-1" class="anchor" href="https://rebol.metaeducation.com#p-8346-ghost-is-the-antiform-of-a-comma-and-it-vanishes-1"></a>GHOST is the antiform of a COMMA!, and it vanishes.</h3>
<pre><code>&gt;&gt; 1 + 2 comment "hi"
== 3
</code></pre>
<p>It's useful for much more than comment.  Comment requires you to pass inert stuff to it (you can't (comment print "hello") because COMMENT takes its argument literally, and if it sees the PRINT it says "bad argument").  But there's ELIDE which vanishes things but evaluates the right hand side.</p>
<pre><code>&gt;&gt; 1 + 2 elide print "Your expression here"
Your expression here
== 3
</code></pre>
<p>This lets you avoid intermediate variables in situations where you calculate a result and want to do some more computation before evaluating to it.  (Historical Rebol uses an awkward ALSO arity 2 construct for this, that evaluates to its first argument, but GHOST is much more powerful...)</p>
<h3><a name="p-8346-antiform-blocks-act-as-multi-parameter-packs-2" class="anchor" href="https://rebol.metaeducation.com#p-8346-antiform-blocks-act-as-multi-parameter-packs-2"></a>Antiform BLOCK!s act as multi-parameter packs</h3>
<p>They "decay" to their first argument.  (They store lifted representations, in order to be able to "hold anything")</p>
<pre><code> &gt;&gt; pack [10 + 20 null]
 == \~[30 ~null~]~\  ; antiform

 &gt;&gt; x: pack [10 + 20 null]
 == \~[30 ~null~]~\  ; antiform

 &gt;&gt; x
 == 30

 &gt;&gt; [x y]: pack [10 + 20 null]
 == \~[30 ~null~]~\  ; antiform

 &gt;&gt; x
 == 30

 &gt;&gt; y
 == \~null~\  ; antiform
</code></pre>
<h2><a name="p-8346-error-antiforms-represent-failure-state-3" class="anchor" href="https://rebol.metaeducation.com#p-8346-error-antiforms-represent-failure-state-3"></a>ERROR! antiforms represent failure state</h2>
<p>They can be reified as a return result... but not yet escalated to a full divergent panic.  This helps be able to discern an error arising from the function you just called (which you might be able to react to) from something deeper (which you almost certainly can't handle coherently).</p>
<h2><a name="p-8346-has-it-been-done-before-4" class="anchor" href="https://rebol.metaeducation.com#p-8346-has-it-been-done-before-4"></a>Has It Been Done Before?</h2>
<p>I'm personally impressed with where it's going, and sometimes it feels more like discovery than invention.</p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/how-novel-is-ren-cs-isotopic-model/2470">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/how-novel-is-ren-cs-isotopic-model/2470</link>
          <pubDate>Sat, 24 May 2025 11:47:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2470</guid>
          <source url="https://rebol.metaeducation.com/t/how-novel-is-ren-cs-isotopic-model/2470.rss">How Novel Is Ren-C&#39;s Isotopic Model?</source>
        </item>
        <item>
          <title>Poking Splices and Voids Into Series Positions</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>I'm tidying up SET and GET to run on a common infrastructure based on PICK and POKE (generalized via isotopes and "dual representation").  It's quite nice!</p>
<p>As I go, I'm improving things left and right.  The POKE handler is now built on the same code as CHANGE, with a :PART of 1.  That means you can do things like this:</p>
<pre><code>&gt;&gt; list: [a b c]
== [a b c]

&gt;&gt; list.2: spread [d e f]
== \~(d e f)~\  ; antiform (splice!)

&gt;&gt; list
== [a d e f c]

&gt;&gt; list.3: void
== \~[]~\  ; antiform (pack!) "void"

&gt;&gt; list
== [a d f c]
</code></pre>
<p>Since strings can't store lists in them, you don't have to "spread" strings to splice them...</p>
<pre><code>&gt;&gt; text: "abc"
== "abc"

&gt;&gt; text.2: "def"
== "def"

&gt;&gt; text
== "adefc"

&gt;&gt; text.3: void
== \~[]~\  ; antiform (pack!) "void"

&gt;&gt; text
== "adfc"
</code></pre>
<p>There's lots of good in the new architecture.  Expect to see historical woes vanish, and more new features...</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/poking-splices-and-voids-into-series-positions/2469">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/poking-splices-and-voids-into-series-positions/2469</link>
          <pubDate>Fri, 23 May 2025 15:04:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2469</guid>
          <source url="https://rebol.metaeducation.com/t/poking-splices-and-voids-into-series-positions/2469.rss">Poking Splices and Voids Into Series Positions</source>
        </item>
        <item>
          <title>New Feature: Literal Picking With TUPLE!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>The ability to embed quotes in TUPLE!s/PATH!s/CHAIN!s affords some interesting abilities.</p>
<p>It's not always clear what those abilities should actually <em>be</em>.  However, one case seemed pretty clear, so I went ahead with it...</p>
<pre><code>&gt;&gt; a: &lt;something&gt;

&gt;&gt; m: to map! []
== &amp;[map! []]

&gt;&gt; m.(a): 304
== 304

&gt;&gt; m.'(a): 1020
== 1020

&gt;&gt; m
== &amp;[map! [
    &lt;something&gt; 304
    (a) 1020
]]

&gt;&gt; m.'(a)
== 1020
</code></pre>
<p>Pretty cool.  Note that you can't do this with "literal SET-XXX" because the CHAIN! scans "above" the TUPLE!.  So <strong><code>m.(a):</code></strong> is a CHAIN! of <strong><code>[m.(a) _]</code></strong>.</p>
<p>If you wanted to actually put <strong><code>(a):</code></strong> in the map, you can't use this trick.  You have to do it the "hard way":</p>
<pre><code> m.('(a):): &lt;whatever&gt;
</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/new-feature-literal-picking-with-tuple/2468">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/new-feature-literal-picking-with-tuple/2468</link>
          <pubDate>Fri, 23 May 2025 08:52:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2468</guid>
          <source url="https://rebol.metaeducation.com/t/new-feature-literal-picking-with-tuple/2468.rss">New Feature: Literal Picking With TUPLE!</source>
        </item>
        <item>
          <title>Are Isotopes Essential, Or Complexity For Its Own Sake?</title>
          <dc:creator><![CDATA[rebolbot]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>Ren-C introduces a number of new terms related to <strong>"ISOTOPES"</strong>.</p>
<p>Many posts talk about <strong>"ANTIFORMS"</strong>, and <strong>"QUASIFORMS"</strong>.</p>
<p>It seems to come with a barrage of new datatypes like <a href="https://rebol.metaeducation.com/t/which-antiforms-are-in-use/2276"><strong>SPLICE!</strong>, <strong>PACK!</strong>, <strong>ACTION!</strong>, <strong>TRASH!</strong>, ...etc. etc.</a></p>
<p>This is all very foreign to those used to traditional Rebol.  What are isotopes?  Is this complexity justified, or just complexity for its own sake?</p>
            <p><small>7 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/are-isotopes-essential-or-complexity-for-its-own-sake/2464">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/are-isotopes-essential-or-complexity-for-its-own-sake/2464</link>
          <pubDate>Tue, 20 May 2025 12:52:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2464</guid>
          <source url="https://rebol.metaeducation.com/t/are-isotopes-essential-or-complexity-for-its-own-sake/2464.rss">Are Isotopes Essential, Or Complexity For Its Own Sake?</source>
        </item>
        <item>
          <title>Why is Ghost the ~,~ Antiform, and not ~ghost~ ?</title>
          <dc:creator><![CDATA[rebolbot]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <pre><code>&gt;&gt; 1 + 2 elide print "GHOST is useful..."
GHOST is useful
== 3
</code></pre>
<p><strong><a href="https://rebol.metaeducation.com/t/making-invisible-functions-e-g-comment-elide/2034">GHOST is useful</a></strong>, and most of the time you don't even know what it looks like because it vanishes.</p>
<p>But it looks very strange in the console in cases where it doesn't vanish:</p>
<pre><code>&gt;&gt; elide print "GHOST is useful..."
GHOST is useful...
== ~,~  ; antiform (ghost)
</code></pre>
<p>Why is it <strong><code>~,~</code></strong> (a COMMA! antiform) when antiforms like NULL are just antiforms of WORD!?</p>
<pre><code>&gt;&gt; try pick [a b] 3
== ~null~  ; anti
</code></pre>
<p>Wouldn't it be more literate if it were just the antiform of <strong>~ghost~</strong> ?</p>
<pre><code>&gt;&gt; elide print "GHOST is useful..."
GHOST is useful...
== ~ghost~  ; antiform
</code></pre>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/why-is-ghost-the-antiform-and-not-ghost/2463">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/why-is-ghost-the-antiform-and-not-ghost/2463</link>
          <pubDate>Tue, 20 May 2025 07:13:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2463</guid>
          <source url="https://rebol.metaeducation.com/t/why-is-ghost-the-antiform-and-not-ghost/2463.rss">Why is Ghost the ~,~ Antiform, and not ~ghost~ ?</source>
        </item>
        <item>
          <title>Reified Unreassignable Nothingness: SPACE RUNES</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/fad3c385e7027512303a71a848a9c5438b676363.webp" data-download-href="https://rebol.metaeducation.com/uploads/default/fad3c385e7027512303a71a848a9c5438b676363" title="assets_task_01jvf0ek4eegkvrwp6xz5sdez9_1747481817_img_0"><img src="https://rebol.metaeducation.com/uploads/default/optimized/1X/fad3c385e7027512303a71a848a9c5438b676363_2_517x345.webp" alt="assets_task_01jvf0ek4eegkvrwp6xz5sdez9_1747481817_img_0" data-base62-sha1="zMV4iH8Je3W7UqmODgWrb3itd8D" width="517" height="345" srcset="https://rebol.metaeducation.com/uploads/default/optimized/1X/fad3c385e7027512303a71a848a9c5438b676363_2_517x345.webp, https://rebol.metaeducation.com/uploads/default/optimized/1X/fad3c385e7027512303a71a848a9c5438b676363_2_775x517.webp 1.5x, https://rebol.metaeducation.com/uploads/default/optimized/1X/fad3c385e7027512303a71a848a9c5438b676363_2_1034x690.webp 2x" data-dominant-color="29221C"></a></div><p></p>
<hr>
<h1><a name="p-8307-first-lets-introduce-runes-1" class="anchor" href="https://rebol.metaeducation.com#p-8307-first-lets-introduce-runes-1"></a>First, Let's Introduce RUNE!s  <span class="hashtag-raw">#ᚠ</span> <span class="hashtag-raw">#ᚡ</span> <span class="hashtag-raw">#ᚢ</span> <span class="hashtag-raw">#ᚣ</span> <span class="hashtag-raw">#ᚤ</span></h1>
<p>Runes are used for character literals.  They are a fusion of historical Rebol's <code>issue!</code> and <code>char!</code> types.</p>
<p>The name has precedent:</p>
<ul>
<li>
<p><strong><a href="https://docs.rs/runestr/latest/runestr/">Rust</a></strong> - <em>"The <code>rune</code> type represents a user-perceived character. It roughly corresponds to a Unicode grapheme cluster but with some nice properties."</em></p>
</li>
<li>
<p><strong><a href="https://go.dev/doc/go1#rune">Go</a></strong> - <em>"Go 1 introduces a new basic type, <code>rune</code>, to represent individual Unicode code points. It is an alias for <code>int32</code>, analogous to <code>byte</code> as an alias for <code>uint8</code>."</em></p>
</li>
</ul>
<p><strong>MOST</strong> (but crucially, not <strong>ALL</strong>) Ren-C runes start with <code>#</code> in their LOAD-able representation:</p>
<pre><code>&gt;&gt; second "abc"
== #a

&gt;&gt; type of #a
== ~{rune!}~  ; antiform (datatype)

&gt;&gt; append "abc" #a
== "abca"
</code></pre>
<p>The HASH (or OCTOTHORPE/POUND) rune is a special case, where it represents itself (as opposed to being expressed by <strong><code>##</code></strong>)</p>
<pre><code>&gt;&gt; second "a#b"
== #

&gt;&gt; to text! #
== "#"
</code></pre>
<p>While runes like <code>#a</code> don't need to be wrapped in quotes, others need to be:</p>
<pre><code>&gt;&gt; third "[x]"
== #"]"

&gt;&gt; third [a b #]
== #  ; as opposed to #]
</code></pre>
<blockquote>
<p>Note that if we allowed things like <strong><code>#]</code></strong> to be the rune for a bracket, that would imply:</p>
<pre><code>&gt;&gt; third [a b #]]  ; this would be pretty confusing!
== #]
</code></pre>
<p>... and it would lead to serious limitations on being able to allow things like <strong><code>#(...)</code></strong> or <strong><code>#"..."</code></strong> or <strong><code>#[...]</code></strong> as special forms.  <a href="https://rebol.metaeducation.com/t/taking-delimiters-literally-in-the-rune-datatype/2386">Discussion here.</a></p>
</blockquote>
<p>As with historical Rebol issue!, the RUNE! type can hold more than one codepoint:</p>
<pre><code>&gt;&gt; type of #abcd
== ~{rune!}~  ; antiform (datatype)

&gt;&gt; length of #abcd
== 4
</code></pre>
<p>When a function like PRINT is performing delimiting (e.g. injecting spacing automatically between tokens), runes aren't considered to need delimiting.  So:</p>
<pre><code>&gt;&gt; print ["abc" "def" #ghij "klm no"]
abc defghijklm no
</code></pre>
<p>That might seem a little arbitrary for multi-codepoint runes.  But it's of high importance with single codepoint runes like <code>newline</code>, because you wouldn't want newline to introduce a space on the previous and next lines:</p>
<pre><code>&gt;&gt; print ["line" "one" newline "line" "two"]
line one  ; &lt;-- you wouldn't want a space at the end of this line
line two  ; &lt;-- you wouldn't want a space at the beginning of this line
</code></pre>
<p><em>(Historical Redbol has bugs pertaining to this which you might not notice in printed output.  There are stray spaces at the ends of lines that should not be there, that you only notice when writing files and examining the bytes.)</em></p>
<hr>
<p><strong>And now: the small design choice with big impact...</strong></p>
<hr>
<h1><a name="p-8307-plain-_-is-the-rune-for-ascii-space-2" class="anchor" href="https://rebol.metaeducation.com#p-8307-plain-_-is-the-rune-for-ascii-space-2"></a>Plain <strong><code>_</code></strong> Is The Rune  For ASCII SPACE</h1>
<pre><code>&gt;&gt; second "a b"
== _

&gt;&gt; type of _
== ~{rune!}~  ; antiform (datatype)

&gt;&gt; to text! _
== " "

&gt;&gt; mold _
== "_"
</code></pre>
<p>If you have a Rune of just spaces, its representation will be that number of underscores:</p>
<pre><code>&gt;&gt; tab4: ____

&gt;&gt; print [tab4 "Runes" "don't count" "in delimiting"]
    Runes don't count in delimiting
    ^-- this is spaced in by 4, not 5, because of the rune! delimit rule
</code></pre>
<p>But if a rune contains <em>any</em> non-space characters, its representation will be escaped <em>(currently in quotes, though this may not be final)</em></p>
<pre><code>&gt;&gt; to rune! "abc def ghi"
== #"abc def ghi"
</code></pre>
<p>This means underscores are generally ordinary WORD! characters, so long as a token does not solely consist of underscores.</p>
<h2><a name="p-8307-a-powerful-exception-with-broad-application-3" class="anchor" href="https://rebol.metaeducation.com#p-8307-a-powerful-exception-with-broad-application-3"></a>A Powerful Exception With Broad Application</h2>
<p>Let's briefly discuss history.</p>
<p>In the earliest days of Ren-C, the <strong><code>_</code></strong> character was chosen as the literal representation of what one might think of as the Redbol "NONE!".</p>
<ol>
<li>
<p><strong><code>_</code></strong> was <strong>reified</strong></p>
<ul>
<li>
<p>it <em>could</em> be put in a block!</p>
<ul>
<li>this contrasted with things like the state of an unset variable (which Ren-C vehemently insisted was "the sort of thing that could not be put in a block!")</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>_</code></strong> was <strong>unreassignable</strong></p>
<ul>
<li>
<p>if you had a dialected purpose with a slot that might hold a variable, holding a <code>_</code> was clearly differentiated</p>
</li>
<li>
<p><code>_</code> wasn't a WORD!, so it could truly "opt out" of things that a variable name might opt-in to. e.g. with <strong>for-each _ [a b c] [...]</strong> you could fully skip out on naming a loop variable.</p>
</li>
</ul>
</li>
<li>
<p><strong><code>_</code></strong> was <strong>nothingness</strong></p>
<ul>
<li>
<p>... or at least, as close to nothing as something could be, while still being able to be put in a block!</p>
</li>
<li>
<p><strong><code>for-each 'x _ [...code...]</code></strong> was equivalent to <strong><code>for-each 'x [] [...code...]</code></strong></p>
</li>
<li>
<p>As advanced features came online, things like <strong><code>[_ var]: some-multi-returner ....</code></strong> could realize that a slot was not meant to be assigned when unpacking multiple return values.</p>
</li>
</ul>
</li>
<li>
<p><strong><code>_</code></strong> was <strong>"falsey"</strong></p>
<ul>
<li>
<p>This was a by-product of the heritage of being the new analogue to NONE!.</p>
</li>
<li>
<p>The rise of generalized isotopes introduced <code>~null~</code> antiforms as a non-reified "falsey" state, raising some tensions with the <em>reified</em> <strong>_</strong> and <strong>#[false]</strong> states...</p>
</li>
</ul>
</li>
</ol>
<h2><a name="p-8307-h-1-2-were-kept-3-evolved-4-was-dropped-4" class="anchor" href="https://rebol.metaeducation.com#p-8307-h-1-2-were-kept-3-evolved-4-was-dropped-4"></a>[1] + [2] Were Kept, [3] "Evolved", [4] Was Dropped</h2>
<p><a href="https://rebol.metaeducation.com/t/a-justification-of-generalized-isotopes/1918">In the age of isotopes <img src="https://rebol.metaeducation.com/images/emoji/twitter/atom_symbol.png?v=14" title=":atom_symbol:" class="emoji" alt=":atom_symbol:" loading="lazy" width="20" height="20"></a>, all reified values came to behave "as-is".  Only antiforms had exceptions in behavior:</p>
<pre><code> &gt;&gt; append [a b c] [d e]
 == [a b c [d e]]

 &gt;&gt; spread [d e]
 == ~(d e)~  ; antiform (splice)

 &gt;&gt; append [a b c] spread [d e]
 == [a b c d e]

 &gt;&gt; append [a b c] _
 == [a b c _]
</code></pre>
<p>To be both "reified" and "nothing", <strong><code>_</code></strong> had to serve two masters.  When it came to mechanical contexts like APPEND or FIND, the reified-ness had to win out.</p>
<h2><a name="p-8307-tbd-expand-5" class="anchor" href="https://rebol.metaeducation.com#p-8307-tbd-expand-5"></a>TBD: Expand...</h2>
<p>I'm falling asleep <img src="https://rebol.metaeducation.com/images/emoji/twitter/sleeping_face.png?v=14" title=":sleeping_face:" class="emoji" alt=":sleeping_face:" loading="lazy" width="20" height="20"> will write more, but until I do, see:</p>
<p><a href="https://rebol.metaeducation.com/t/why-does-form-as-space-not-underscore/2455" class="inline-onebox">Why Does _ Form As Space, Not Underscore?</a></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/reified-unreassignable-nothingness-space-runes/2457">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/reified-unreassignable-nothingness-space-runes/2457</link>
          <pubDate>Sat, 17 May 2025 15:40:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2457</guid>
          <source url="https://rebol.metaeducation.com/t/reified-unreassignable-nothingness-space-runes/2457.rss">Reified Unreassignable Nothingness: SPACE RUNES</source>
        </item>
        <item>
          <title>Why Does _ Form As Space, Not Underscore?</title>
          <dc:creator><![CDATA[rebolbot]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>The following code has predictable behavior for everything except <strong><code>_</code></strong>:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; for-each 'item [
       ? * + - = |     ; word!s - ordinary
       &lt; &gt; : / . %     ; word!s - special (limited in some contexts)
       _               ; rune! - "space" (?)
       #               ; rune! - "hash"/"octothorpe"/"pound"
   ][
       append string item
   ]

&gt;&gt; string
== "?*+-=&lt;&gt;|:/.% #"
                ^-- NOT an underscore, but a space
</code></pre>
<p><strong>Why is <strong><code>_</code></strong> the RUNE! for "space" instead of the RUNE! for "underscore" (or "blank" if that's a better name)?</strong></p>
<p>If it were blank/underscore it could render as an underscore in strings, making this less surprising:</p>
<pre><code>&gt;&gt; append "abc" _
== "abc_"
</code></pre>
<p>And instead of writing:</p>
<pre><code>&gt;&gt; parse "a_b_c" [#a #_ #b #_ #c]
== #c
</code></pre>
<p>You could write:</p>
<pre><code>&gt;&gt; parse "a_b_c" [#a _ #b _ #c]
== #c
</code></pre>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/why-does-form-as-space-not-underscore/2455">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/why-does-form-as-space-not-underscore/2455</link>
          <pubDate>Sat, 17 May 2025 04:29:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2455</guid>
          <source url="https://rebol.metaeducation.com/t/why-does-form-as-space-not-underscore/2455.rss">Why Does _ Form As Space, Not Underscore?</source>
        </item>
        <item>
          <title>On Quickness (Italo Calvino)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>I cite this short passage by <strong><a href="https://en.wikipedia.org/wiki/Italo_Calvino">Italo Calvino</a></strong> fairly often:</p>
<blockquote>
<p><em>Among Chuang-tzu’s many skills, he was an expert draftsman.</em></p>
<p><em>The Chinese emperor asked Chuang-tzu to draw a crab.</em></p>
<p><em>Chuang-tzu replied that he would need five years plus a country estate and 12 servants.</em></p>
<p><em>The emperor gave him what he requested.</em></p>
<p><em>Five years later, Chuang-tzu still had not started on the drawing.</em></p>
<p><em>"I need another five years", Chuang-tzu said to the emperor.</em></p>
<p><em>The emperor granted them.</em></p>
<p><em>After 10 years, Chuang-tzu took up his brush and in a single stroke drew a crab, the most perfect crab ever seen.</em></p>
</blockquote>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/crab.png?v=14" title=":crab:" class="emoji only-emoji" alt=":crab:" loading="lazy" width="20" height="20"></p>
<p>It may not seem like an exact analogy for Ren-C's development, in the sense that there's lots of incremental steps which are "visible"...to the very few people looking.  But I think to most, the true profound nature of its design will seem like it came out of nowhere, while it's the result of an epic amount of pondering.</p>
<p>I'm of the belief that my resistance to push or publish something that's not fully formed has been an asset.  And I'm of the belief that it's going to blow people's minds.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/on-quickness-italo-calvino/2436">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/on-quickness-italo-calvino/2436</link>
          <pubDate>Tue, 06 May 2025 12:32:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2436</guid>
          <source url="https://rebol.metaeducation.com/t/on-quickness-italo-calvino/2436.rss">On Quickness (Italo Calvino)</source>
        </item>
        <item>
          <title>Why Are TRASH and VOID Distinct In Ren-C?</title>
          <dc:creator><![CDATA[rebolbot]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>It appears that Ren-C uses <strong>VOID</strong> for opting out of things like COMPOSE, and <strong>TRASH</strong> for what unset variables hold.</p>
<p>But Rebol2, R3-Alpha, and Red use UNSET! for both:</p>
<pre><code> rebol2&gt;&gt; unset 'foo

 rebol2&gt;&gt; compose [a (get/any 'foo) c]
 == [a c]
</code></pre>
<p>All things being equal, one state to represent "nothing" would seem better than having more than one.</p>
<p>So are the benefits of having two different states worth it, vs. the simplification of only having to worry about one state?</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/why-are-trash-and-void-distinct-in-ren-c/2416">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/why-are-trash-and-void-distinct-in-ren-c/2416</link>
          <pubDate>Thu, 17 Apr 2025 01:27:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2416</guid>
          <source url="https://rebol.metaeducation.com/t/why-are-trash-and-void-distinct-in-ren-c/2416.rss">Why Are TRASH and VOID Distinct In Ren-C?</source>
        </item>
        <item>
          <title>Making Function Calls Clearer With Selective Slashing</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>Ren-C shifted to the idea that slashes in paths are used to convey function calls.  Refinements are done with colons (CHAIN!), and field selection is done with dots (TUPLE!)</p>
<p>This means you can tell the difference between:</p>
<pre><code>obj/xxx  ; a function call

obj.xxx  ; picking a member out of an object
</code></pre>
<p>But Rebol depends visually on not needing any decoration to run a function out of a word.  This means that when you see:</p>
<pre><code>some-word
</code></pre>
<p>You don't know if that's running a function or not.   While that is "by design", there are sometimes cases where you want to disambiguate it.  So Ren-C offers:</p>
<pre><code>/some-word  ; runs a function

some-word.  ; gets a non-function value from the word
</code></pre>
<p><em>(The <code>some-word/</code> case is for getting a function without running it... chosen for its semiotic value of separating the word from its arguments with a "barrier" at the end.  And <code>.some-word</code> is used for picking members out of objects inside of a method, e.g. <code>self.some-word</code>.)</em></p>
<h2><a name="p-8124-who-would-ever-use-some-word-1" class="anchor" href="https://rebol.metaeducation.com#p-8124-who-would-ever-use-some-word-1"></a>Who Would Ever Use /SOME-WORD ?</h2>
<p>I've explained cool applications of the leading slash in things like <a href="https://rebol.metaeducation.com/t/if-action-combinators-dont-impress-what-will/1608">ACTION! combinators for UPARSE</a>.</p>
<p>But is it useful in non-dialected code?</p>
<p><strong>YES.</strong></p>
<p>In doing some updates to Shixin's c2r3, there was some code like this:</p>
<pre><code>cpuid: tcc/load-func prog "cpuid" [
    eax [pointer]
    ebx [pointer]
    ecx [pointer]
    edx [pointer]
    return: [void]
]

cpu-string: func [
    return: [text!]
][
    let eax: copy #{00000000}
    let ebx: copy #{00000000}
    let ecx: copy #{00000000}
    let edx: copy #{00000000}

    cpuid eax ebx ecx edx
    return as text! join blob! [ebx edx ecx]
]
</code></pre>
<p>CPUID doesn't necessarily sound like a function invocation.  But let's imagine that's what something is named.  You're confronted with the question: should I name the wrapper something like <strong><code>get-cpuid:</code></strong> ?  But now you've created a mismatch between something that exists and your wrapper.</p>
<p>Using the leading slash gives you the ability to mark things more clearly as a function at the assignment:</p>
<pre><code>/cpuid: tcc/load-func prog "cpuid" [
    eax [pointer]
    ebx [pointer]
    ecx [pointer]
    edx [pointer]
    return: [void]
]
</code></pre>
<p>This not only visually reinforces that what you are assigning is a function, but it also requries that what you're assigning be an action.  So it's a convenient shorthand for:</p>
<pre><code>cpuid: ensure action! tcc/load-func prog "cpuid" [...]
</code></pre>
<p>The callsites have a similar benefit...not just visual, but enforced that it's a function call:</p>
<pre><code>/cpuid eax ebx ecx edx
return as text! join blob! [ebx edx ecx]
</code></pre>
<h2><a name="p-8124-its-there-on-an-as-needed-basis-2" class="anchor" href="https://rebol.metaeducation.com#p-8124-its-there-on-an-as-needed-basis-2"></a>It's There On An As-Needed Basis</h2>
<p>For a time, I was wondering if all function assignments should require slashed-set-words.</p>
<p>But I realized that it was too much.</p>
<pre><code>/something: func [...] [...]   ; but I KNOW FUNC makes functions...

/alpha: beta/  ; BETA/ promises to return a function, why double-enforce?
</code></pre>
<p>But it can make some situations more clear, and give you cheap insurance that the assignment is doing what you think.</p>
<p>Similarly I think the leading slash is something to apply judiciously.  We don't want to read code with tons of <strong><code>/append</code></strong> junking it up.  But cases like this <strong><code>/cpuid</code></strong> show an effective and helpful communication that a function call is happening.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/making-function-calls-clearer-with-selective-slashing/2402">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/making-function-calls-clearer-with-selective-slashing/2402</link>
          <pubDate>Tue, 08 Apr 2025 18:41:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2402</guid>
          <source url="https://rebol.metaeducation.com/t/making-function-calls-clearer-with-selective-slashing/2402.rss">Making Function Calls Clearer With Selective Slashing</source>
        </item>
        <item>
          <title>Say :NO to &quot;REDUCE/NO-SET&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I'm converting <a class="mention" href="https://rebol.metaeducation.com/u/szeng">@szeng</a>'s old c2r3 to Ren-C, and came across a use of a refinement I forgot existed, the "NO-SET" refinement of R3-Alpha:</p>
<pre><code>cbdata: make callback-data reduce/no-set [
    model: model
    path: gtk/tree_model_get_path model iter
]
</code></pre>
<p>What does it do, you ask?</p>
<pre><code>r3-alpha&gt;&gt; help reduce
USAGE:
    REDUCE value /no-set /only words /into out

DESCRIPTION:
    Evaluates expressions and returns multiple results.
    REDUCE is a native value.

ARGUMENTS:
    value

REFINEMENTS:
    /no-set -- Keep set-words as-is. Do not set them.
    /only -- Only evaluate words and paths, not functions
            words -- Optional words that are not evaluated (keywords) (block! none!)
    /into -- Output results into a block with no intermediate storage
            out (any-block!)
</code></pre>
<p>So basically, it just doesn't evaluate the SET-WORD!s in the block.</p>
<p>With generalized quoting, you don't need it:</p>
<pre><code>cbdata: make callback-data reduce [
    'model: model
    'path: gtk/tree_model_get_path model iter
]
</code></pre>
<p>Which approach seems more sane?</p>
<p><em>(If it's not obvious why it's doing a REDUCE instead of letting the MAKE OBJECT! do the evaluations, it's because it wants to set a field called MODEL as well as use a variable called MODEL, and MAKE OBJECT! currently doesn't distinctly bind the SET-WORD! to not be in the object, though it probably should consider SET-WORD! to be in the object and plain WORD! to use the binding outside the object...)</em></p>
<h2><a name="p-8122-will-red-ever-realize-how-wrong-they-are-1" class="anchor" href="https://rebol.metaeducation.com#p-8122-will-red-ever-realize-how-wrong-they-are-1"></a>Will Red Ever Realize How Wrong They Are?</h2>
<p>They've dug in on the stance that being able to quote anything to any level adds unnecessary complexity, calling them "esoteric lexical forms":</p>
<p><a href="https://rebol.metaeducation.com/t/quoted-arrives-formerly-known-as-lit-bit/995/2" class="inline-onebox">QUOTED! arrives (formerly known as "lit bit") - #2 by hostilefork</a></p>
<p>But instead of solving the problem once and for all--in a uniform and systemic fashion--they live in a world where you have to invent things like /NO-SET.</p>
<p><a href="https://www.etsy.com/listing/1357667496/lord-what-fools-these-mortals-be"><img src="https://rebol.metaeducation.com/uploads/default/original/1X/271ec1f85335b8fd27f08913cbf2b01d14aa11c8.webp" alt="il_570xN.4485694065_9o3w" data-base62-sha1="5A4wcAZ4Nqp83Sk1YGiWEaLCvIA" width="218" height="250"></a></p>
<p><em>(And generic quoting of things that "don't need to be quoted" like BLOCK! underpins an actual working binding model, by letting you express the difference between binding capture and untouched binding...)</em></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/say-no-to-reduce-no-set/2400">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/say-no-to-reduce-no-set/2400</link>
          <pubDate>Tue, 08 Apr 2025 16:32:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2400</guid>
          <source url="https://rebol.metaeducation.com/t/say-no-to-reduce-no-set/2400.rss">Say :NO to &quot;REDUCE/NO-SET&quot;</source>
        </item>
        <item>
          <title>How To FIND With A Matcher Function in Ren-C?</title>
          <dc:creator><![CDATA[GiuseppeChillemi]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2327">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/trailing-slash-is-a-winner-for-defused-actions/2327/2">Trailing Slash Is A Winner For Defused Actions</a></div>
<blockquote>
<p>So I wondered... what if PARSE used the trailing slash notation, assuming that meant run a function as a typechecker?</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; parse [2 4 6] [some even?/]
== 6
</code></pre>
</blockquote>
</aside>
<p>I like it, if you can use any function it really shorten things.<br>
But.. how do you search for it? <code>find block word?/</code>  ?</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/how-to-find-with-a-matcher-function-in-ren-c/2360">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/how-to-find-with-a-matcher-function-in-ren-c/2360</link>
          <pubDate>Fri, 27 Dec 2024 22:23:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2360</guid>
          <source url="https://rebol.metaeducation.com/t/how-to-find-with-a-matcher-function-in-ren-c/2360.rss">How To FIND With A Matcher Function in Ren-C?</source>
        </item>
        <item>
          <title>The Grand Leading-Slash &quot;Safety, or Burden?&quot; Question</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Overall, I have been tremendously happy with how the ideas of the <strong><a href="https://rebol.metaeducation.com/t/big-alien-proposal-word-runs-functions/1905">Big Alien Proposal</a></strong> have worked out.</p>
<p>That started from the concept that when slashes appear, they either come <em>before</em> a function they run, or <em>after</em> a function they suppress execution for.</p>
<pre><code>foo.bar
; ^-- foo is an entity from which BAR is being selected.  BAR is not
; allowed to be an antiform frame, so this syntax cannot invoke a
; function call (though it can invoke an 'accessor', e.g. a "getter"
; which is 0-arity).

foo/bar
; ^-- foo is an entity from which BAR (an a FRAME! or antiform FRAME!)
; is being selected and then invoked.  This will generate an error if
; bar is not a frame or antiform frame.

foo.bar/
; ^-- bar is a field which is an antiform FRAME!, whose execution is
; being suppressed.  This expression will return an antiform frame, or
; an error if not an antiform frame.

foo
; ^-- conventional WORD! reference, will run an antiform frame as an
; action invocation or fetch other values as-is

/foo
; ^-- invocation reference, will run an antiform frame (or plain frame)
; as an action invocation and give errors on other types

foo/
; ^-- action suppression, will give you back an antiform frame as-is
; and error on other types.
</code></pre>
<p><em>(If you're curious about why <strong><code>/foo</code></strong> will run plain FRAME! as well as antiform, while <strong><code>foo/</code></strong> will not return an antiform frame for plain FRAME!, this is based on the idea that it's better to be conservative when fetching values so that you won't get surprised by getting a plain frame back from <strong><code>foo/</code>~</strong> which gives everything back as-is.)</em></p>
<hr>
<p>I've written elsewhere <a href="https://rebol.metaeducation.com/t/trailing-slash-is-a-winner-for-defused-actions/2327">how pleased I am that the way you suppress a function's execution is by throwing up a "barrier"</a> with a separating slash that makes it clear arguments are not being gathered at the callsite.  That's really slick.</p>
<p>For this idea to work, something else had to be used for refinements.  That meant <a href="https://rebol.metaeducation.com/t/introducingnew-chain-datatype/2226">invention of the CHAIN! datatype</a> has opened a lot of interesting doors, and I find it's quite learnable to see things like <strong><code>trim:auto:tail</code></strong> instead of <strong><code>trim/auto/tail</code></strong>.</p>
<p><em>I actually prefer it!</em>  What some might think of a disadvantage of being "less noticeable" turns into an advantage... <strong><code>trim:auto</code></strong> really could have been a function called <strong><code>trim-auto</code></strong> just as easily.  Why would you want a slash to make the fact that it has a refinement "pop"?  The slashes to make function calls or suppression pop are much better applied.</p>
<p><strong>So that's all good. <img src="https://rebol.metaeducation.com/images/emoji/twitter/smile_cat.png?v=14" title=":smile_cat:" class="emoji" alt=":smile_cat:" loading="lazy" width="20" height="20"> No regrets!</strong></p>
<h2><a name="p-7975-but-leading-slash-for-functions-rule-hasnt-100-geld-1" class="anchor" href="https://rebol.metaeducation.com#p-7975-but-leading-slash-for-functions-rule-hasnt-100-geld-1"></a>But... Leading-Slash For Functions Rule Hasn't 100% Gel'd</h2>
<p>Another part of the proposal was that in order to get tighter control on what was a function or not, you would be required to assign functions using a leading-slash kind of SET-WORD!.</p>
<pre><code>&gt;&gt; foo: func [a b] [return a + b]
** Error: FOO: can't be used to assign antiform FRAME!, use /FOO:

&gt;&gt; /foo: func [a b] [return a + b]
== ~#[frame! "foo" [a b]]]~  ; anti
</code></pre>
<p><strong>It hasn't fully settled with me after working with it for some time.</strong></p>
<p>As I mentioned above, colons for refinements was easy to adapt to...and now that I'm adapted, I prefer it.</p>
<p>But I'm still typing <strong><code>test: cascade [add/ even?/]</code></strong>.  I love the trailing slashes (and this will be even better when the whole cascade can be done with just <strong><code>even?/add/</code></strong>).  But I'm kind of cursing under my breath the thought of having typed <strong><code>test:</code></strong> and having to backspace over it so it says <strong><code>/test:</code></strong>.  And then I go "hrmph."</p>
<p>When I'm reading code, I probably appreciate it more than I find it to be "messy".  It gives you a better compass.  The eye can scan and comprehend much better... it's of particular value when you're not using an obvious function generator like FUNC, but something else.  This cues readers to go "oh, I guess that's a function generator".</p>
<p>Yet still... it's a burden in a way the other changes are not.  It's the only change that increases the character count.</p>
<h2><a name="p-7975-whats-at-stake-by-not-enforcing-this-2" class="anchor" href="https://rebol.metaeducation.com#p-7975-whats-at-stake-by-not-enforcing-this-2"></a>What's At Stake By Not Enforcing This?</h2>
<p>Ren-C has a powerful story about how antiforms can't be put in blocks, which means you can write this kind of code and it "just works":</p>
<pre><code>block2: collect [
    for-each 'item block1 [keep item]
]

assert [equal? block1 block2]
</code></pre>
<p>When you compare it to Rebol2/R3-Alpha/Red, it's one of those vastly superior situations.  You aren't getting tricked into receiving an ITEM in the FOR-EACH that would generate an unset variable error, or conflate with the state that gets returned when an item can't be picked from a block, or accidentally run a function.  It's a solid solution.</p>
<p>But that's only for blocks.  What about other places, like objects?</p>
<p>If we don't put barriers on how action antiforms get assigned to variables, we get the problem all over again:</p>
<pre><code>for-each [key value] obj [
    if integer? value [  ; oops, what if VALUE is an action antiform!
        print "Found an integer"
    ]
]
</code></pre>
<p>There's no way in this case to say "variables can't hold antiforms".  Logic is an antiform.  Words holding antiform frames are actions.</p>
<p>Getting this under control with slashes is the kind of thing I've been trying to do for a long time, I've just never had the syntax.  Leading slashes felt like it could be the key:</p>
<pre><code>for-each [key value] obj [...]  ; value can't be frame antiform

for-each [key /value] obj [...]  ; value must be frame antiform

for-each [key ~/value] obj [...]  ; value may be frame antiform
</code></pre>
<p>But if these rules are applied everywhere, what you have to do gets more complex:</p>
<pre><code>set $x does [print "Is this an error?"]

set $/x does [print "Do you have to do this?"]

&gt;&gt; var: $x
== x  ; bound

set var does [print "If this errors, how to make VAR into bound /x?"]

set:active var does [print "Do you use refinements?"] (or just SET:ANY ?)
</code></pre>
<p>Nothing is free.  And the already more complicated world where <strong><code>x:</code></strong> is a CHAIN! instead of a fundamental different type of word has its own issues, that these all pile on top of.</p>
<h2><a name="p-7975-theres-likely-not-enough-value-in-optional-slash-3" class="anchor" href="https://rebol.metaeducation.com#p-7975-theres-likely-not-enough-value-in-optional-slash-3"></a>There's Likely Not Enough Value In Optional Slash</h2>
<p>If <strong><code>/foo: func [...] [...]</code></strong> will enforce that the thing you're assigning is an antiform action, but <strong><code>foo: func [...] [...]</code></strong> still works... I have a feeling that the complexity it takes to offer the feature doesn't give a sufficient payoff to be worth it.</p>
<p>You have everyone paying the tax of dealing with complicated path structures and bookkeeping--vs. being able to just SET and GET words and tuples at will... and then you're not even giving any additional guarantees in the source.</p>
<p>This makes me feel like it really is an all-in or not-at-all situation.</p>
<h2><a name="p-7975-long-story-short-im-still-weighing-it-4" class="anchor" href="https://rebol.metaeducation.com#p-7975-long-story-short-im-still-weighing-it-4"></a>Long Story Short: I'm Still Weighing It</h2>
<p>I'm not ready to make a verdict.</p>
<p>The techniques for working with these new CHAIN! and PATH! situations are still being learned.  Most of my hesitance isn't from the looks or typing an extra character, but from frustrations in that...and maybe that frustration will lessen as I work on it more.</p>
            <p><small>7 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/the-grand-leading-slash-safety-or-burden-question/2352">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/the-grand-leading-slash-safety-or-burden-question/2352</link>
          <pubDate>Thu, 19 Dec 2024 01:12:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2352</guid>
          <source url="https://rebol.metaeducation.com/t/the-grand-leading-slash-safety-or-burden-question/2352.rss">The Grand Leading-Slash &quot;Safety, or Burden?&quot; Question</source>
        </item>
        <item>
          <title>Why Parentheses As Default COMPOSE Escape?</title>
          <dc:creator><![CDATA[rebolbot]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>Conventional wisdom for interpolation or templating would be to use something fairly uncommon, so as not to be likely to be confused with the content.</p>
<p>Yet Ren-C (and Red) use parentheses as a default:</p>
<pre><code>red&gt;&gt; as url! #rejoin "http://(site)/(resource)?param=(date as "yyyy")"
== http://example.com/whatever.html?param=1998

ren-c&gt;&gt; compose http://(site)/(resource)?param=(date as "yyyy")
== http://example.com/whatever.html?param=1998
</code></pre>
<p>Why isn't something more uncommon used as the default, like <code>{{}}</code></p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/why-parentheses-as-default-compose-escape/2410">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/why-parentheses-as-default-compose-escape/2410</link>
          <pubDate>Thu, 21 Nov 2024 08:18:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2410</guid>
          <source url="https://rebol.metaeducation.com/t/why-parentheses-as-default-compose-escape/2410.rss">Why Parentheses As Default COMPOSE Escape?</source>
        </item>
        <item>
          <title>Trailing Slash Is A Winner For Defused Actions</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I <em>really</em> like this trailing slash thing, meaning "get me the action as is and don't run it AND guarantee it's an action".</p>
<pre><code>&gt;&gt; replace [a 1 a &lt;baby&gt;] word?/ &lt;ice&gt;
== [&lt;ice&gt; 1 &lt;ice&gt; &lt;baby&gt;]
</code></pre>
<p>That's to me just about perfect:</p>
<ul>
<li>
<p>You're passing the parameter of what to replace as being an antiform action, so it will be called on the elements.</p>
</li>
<li>
<p>It does NOT take a parameter (notice the slash dividing it from what comes after it?  that's a strong semiotic hint that <code>&lt;ice&gt;</code> is not a parameter to <code>word?</code>)</p>
</li>
<li>
<p>...and it's an antiform, so you know it doesn't occur literally in the block.</p>
</li>
</ul>
<p>Before this existed, I was using MATCHER which made an antiform action for a datatype:</p>
<pre><code>&gt;&gt; replace [a 1 a &lt;baby&gt;] matcher word! &lt;ice&gt;
== [&lt;ice&gt; 1 &lt;ice&gt; &lt;baby&gt;]
</code></pre>
<p>That's slower, not as brief, and a bit more opaque about the mechanics.</p>
<p>It's useful if you have a datatype in your hand and need to convert it to a function, or if you have a more complex type construction:</p>
<pre><code>&gt;&gt; replace [a 1 a &lt;baby&gt;] matcher [word! integer!] &lt;ice&gt;
== [&lt;ice&gt; &lt;ice&gt; &lt;ice&gt; &lt;baby&gt;]
</code></pre>
<p>If you make such a call often, you wouldn't want to regenerate the function each time:</p>
<pre><code>&gt;&gt; word-or-int?: matcher [word! integer!]

&gt;&gt; replace [a 1 a &lt;baby&gt;] word-or-int?/ &lt;ice&gt;
== [&lt;ice&gt; &lt;ice&gt; &lt;ice&gt; &lt;baby&gt;]
</code></pre>
<p>Anyway, I'll also say that the <a href="https://rebol.metaeducation.com/t/make-replace-all-default-semantics-of-replace/2269">REPLACE "ALL" semantic being the default</a> is a big improvement.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/trailing-slash-is-a-winner-for-defused-actions/2327">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/trailing-slash-is-a-winner-for-defused-actions/2327</link>
          <pubDate>Fri, 08 Nov 2024 19:05:55 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2327</guid>
          <source url="https://rebol.metaeducation.com/t/trailing-slash-is-a-winner-for-defused-actions/2327.rss">Trailing Slash Is A Winner For Defused Actions</source>
        </item>
        <item>
          <title>What To Do About Horrible, Grievous, Unicode</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>At some point <a href="https://github.com/red/red/blob/master/tests/source/units/series-test.red#L1413C2-L1417C39">I picked up a test from Red</a>, which is basically this:</p>
<pre><code>str: " ^(A0) ^-a b  ^- c  ^(2000) "
assert ["a b  ^- c" = trim copy str]
</code></pre>
<p>That's some funny business.</p>
<ul>
<li>
<p>The hex character ^(a0) is decimal 160, which is the standard Unicode translation for <code>&amp;nbsp;</code>... non-breaking space.</p>
</li>
<li>
<p>The hex character ^(2000) is "EN QUAD".. <a href="https://en.wikipedia.org/wiki/Quad_(typography)">a space that is one <em>en</em> wide: half the width of an em quad.</a></p>
</li>
</ul>
<p>R3-Alpha (and Ren-C) never had support for trimming these characters out.  So the test fails.</p>
<p>But it wound up flying under the radar, somehow.</p>
<p><em>(I think I didn't actually pick up the file it was in to the tests until some time after adding it.  And by the time I added it, a lot of things were breaking due to binding and I was putting off fixing everything until it was time.  Now it's that time--I'm going item by item reviewing breakages and getting the tests in order.)</em></p>
<p>But when I got to this one, the log just said:</p>
<pre><code>(   
    str: "   ^-a b  ^- c    "
    "a b  ^- c" = trim copy str
) "failed, test returned null"
</code></pre>
<p>Because I didn't go look up the test (I thought I had it right there)...I didn't realize there was funny business because the display doesn't give you any indication.  Neither does Red's after the transcode:</p>
<pre><code>red&gt;&gt; " ^(A0) ^-a b  ^- c  ^(2000) "
== "   ^-a b  ^- c    "
</code></pre>
<p>Even pasting it into VS Code (which I didn't, until just now) gives you <em>terribly weak</em> feedback that something weird is going on:</p>
<p><img src="https://rebol.metaeducation.com/uploads/default/original/1X/fcb694d9fa08aa3be6b625b1529de82cf9e2ecef.png" alt="image" data-base62-sha1="A3Bv5No7U3eVyTqLu28KCsYccXl" width="393" height="59"></p>
<p>Gee.  Glad I had "show invisibles" turned on--that <em>really</em> did a lot for me there.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/roll_eyes.png?v=14" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></p>
<p><em>(Seriously, what is the point of that feature if that's what it's going to do?)</em></p>
<h2><a name="p-7679-i-dont-want-this-stuff-in-source-files-1" class="anchor" href="https://rebol.metaeducation.com#p-7679-i-dont-want-this-stuff-in-source-files-1"></a>I Don't Want This Stuff In Source Files</h2>
<p>We can't fix the world.  They're doing what they are doing.  This stuff is the currency of text and you have to support it.</p>
<p>But we can set house rules.  The default mode for Ren-C should only allow two invisible characters in source: space and newline.  (And I'd like there to not be space at the end of lines.)  This would be a hard rule for any script in official repositories.</p>
<p>I'd have saved myself an hour of confused digging if there'd been an error when I pasted in the console, telling me I was dealing with a messed-up situation.  There'd have to be some conscious shift into a mode to tolerate it... temporarily as some kind of way to import a string into the system.</p>
<h2><a name="p-7679-not-ready-to-support-this-test-2" class="anchor" href="https://rebol.metaeducation.com#p-7679-not-ready-to-support-this-test-2"></a>Not Ready To Support This Test</h2>
<p>There's a <a href="https://rebol.metaeducation.com/t/roaring-bitset-s/1327">sparse bitset implementation</a> that has been on the shelf, but that's needed before we create unicode charsets for high codepoints.</p>
<p>Anyway, there are higher priorities.  But I definitely do feel like there should be some alarms going off when you are reading files with disruptive codepoints.  You should have to say "Yes, I want ugly codepoints" or "Yes, I want emoji".</p>
<p>A totally permissive TO TEXT! operator shouldn't be what people are reaching for.  You should have to be explicit.  <strong><code>(decode [@utf-8, whitespace: all, emoji: all] blob)</code></strong>.  Principle of least privilege... conservative defaults.</p>
<p>The names for the specializations should help guide behavior.  <strong><code>(decode @utf8-unchecked blob)</code></strong>.  (Unnatural?)</p>
<ul>
<li>"What does that mean, unchecked (looks up documentation)"</li>
<li>"Oh, I have an option to have it screen out weird whitespace?  Wow!  Great! "</li>
</ul>
<p>Something like <strong><code>utf8-basic</code></strong> would make conservative choices--the same ones used by default for source code.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/what-to-do-about-horrible-grievous-unicode/2280">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/what-to-do-about-horrible-grievous-unicode/2280</link>
          <pubDate>Sun, 15 Sep 2024 13:38:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2280</guid>
          <source url="https://rebol.metaeducation.com/t/what-to-do-about-horrible-grievous-unicode/2280.rss">What To Do About Horrible, Grievous, Unicode</source>
        </item>
        <item>
          <title>Labeled TRASH! Runes in The Wild</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>If you access an unset variable, you don't get a lot of information back:</p>
<pre><code>&gt;&gt; state: ~

&gt;&gt; state
** Script Error: state is ~ antiform
</code></pre>
<p>That <code>~</code> is the quasiform/antiform of the space RUNE!:</p>
<pre><code>&gt;&gt; quasi _
== ~

&gt;&gt; type of anti _
== ~{trash!}~  ; antiform (datatype)
</code></pre>
<p><strong>But you're not just limited to the space RUNE! to make "unset" variables... because you can use <em>any</em> RUNE!.</strong></p>
<pre><code>&gt;&gt; state: ~#[INITIALIZE-STATE not called yet]#~

&gt;&gt; state
** Script Error: state is trash: ~#[INITIALIZE-STATE not called yet]#~
</code></pre>
<p><em>(This concept was originally called a "tripwire" when labeled trash was a distinct datatype from trash.  But now that the <strong><code>_</code></strong> is just the rune! for space, it unifies to where all antiform runes are just called TRASH!)</em></p>
<p>DEFAULT reacts to labeled trash like anything else, considering the variable to be "vacant"</p>
<pre><code>&gt;&gt; vacant? $state
== ~okay~  ; anti

&gt;&gt; state: default [10 + 20]
== 30

&gt;&gt; state
== 30
</code></pre>
<h2><a name="p-7676-can-be-better-than-a-meandering-comment-1" class="anchor" href="https://rebol.metaeducation.com#p-7676-can-be-better-than-a-meandering-comment-1"></a>Can Be Better Than A Meandering Comment!</h2>
<p>A comment won't direct people to the relevant issue at runtime.  But a well-chosen labeled trash can.</p>
<p>Compare:</p>
<pre><code>; !!! UPARSE is not available in SYS because it is higher level.  We hack it
; up so that when %uparse.r runs it pokes itself into sys.util/parse
;
parse: ~
</code></pre>
<p>With:</p>
<pre><code>parse: ~#[higher-level %uparse.r hasn't set SYS.UTIL/PARSE yet]#~
</code></pre>
<p>Much better!  Gives you the information you need, when you need it!</p>
<p><em>(Note: I was inspired to this concept by a style of usage <a class="mention" href="https://rebol.metaeducation.com/u/rgchris">@rgchris</a> had in his scripts, using TAG!s to provide guidance for what was supposed to be filled into certain slots.  I just wanted to give that some teeth, to know that the variable was conceptually unset.)</em></p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/labeled-trash-runes-in-the-wild/2278">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/labeled-trash-runes-in-the-wild/2278</link>
          <pubDate>Sun, 15 Sep 2024 07:46:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2278</guid>
          <source url="https://rebol.metaeducation.com/t/labeled-trash-runes-in-the-wild/2278.rss">Labeled TRASH! Runes in The Wild</source>
        </item>
        <item>
          <title>Quasiforms Aren&#39;t Super Friendly (and they shouldn&#39;t be)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>The original intent of quasiforms was that they were a bit "bad".</p>
<p>Things like <strong><code>~null~</code></strong> were actually originally called BAD-WORD!s.  (I kind of miss that slightly amusing term.)</p>
<p>So indeed, an aspect of the term "quasi" was that the squiggles would make you <em>uncomfortable</em>... perhaps a bit <em>queasy</em>... <img src="https://rebol.metaeducation.com/images/emoji/twitter/nauseated_face.png?v=14" title=":nauseated_face:" class="emoji" alt=":nauseated_face:" loading="lazy" width="20" height="20"> ...and they would call attention to themselves.</p>
<h2><a name="p-7656-they-are-disruptive-by-design-1" class="anchor" href="https://rebol.metaeducation.com#p-7656-they-are-disruptive-by-design-1"></a>They Are Disruptive By Design</h2>
<p>Consider code like this:</p>
<pre><code>&gt;&gt; stuff: [[a b] ~[c d]~ (e f)]

&gt;&gt; list: second stuff

&gt;&gt; for-each item list [probe item]
** Script Error: for-each expects
     [~void~ blank! any-series? any-context? map! any-sequence? action?]
   for its data argument
</code></pre>
<p>It's not super typical to want to enumerate quasiform lists.  But it does come up...and when it does, it may <em>seem</em> kind of annoying that you have to say things like <strong><code>for-each item unquasi list</code></strong></p>
<h2><a name="p-7656-its-for-the-best-2" class="anchor" href="https://rebol.metaeducation.com#p-7656-its-for-the-best-2"></a>It's For The Best</h2>
<p>We <em>want</em> code that isn't specifically written to expect quasiforms to trip up on them, <strong>because the odds are pretty good that they are proxies for antiform intent</strong>.</p>
<p>And I'd really discourage usage of quasiforms anywhere that they're not being used for something intended to be fundamentally disruptive.  As I wrote in describing <strong><a href="https://rebol.metaeducation.com/t/synthetic-asymmetric-delimiters/1893">Synthetic Asymmetric Delimiters</a></strong>, you have other choices.</p>
<p>Don't pick quasiforms in your dialect just because "they look cool".  Pick them <em>because you want to create a speedbump.</em></p>
<p>So the number of things you can do with quasiforms will remain intentionally limited.  Expect errors when you pass them to anything that's not strictly structural (like APPEND, FIND, etc.)</p>
<pre><code>&gt;&gt; to word! 'null
== null

&gt;&gt; to word! '~null~
** Script Error: expected &amp;[word] not &amp;[quasiform]

&gt;&gt; unquasi '~null~
== null
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/quasiforms-arent-super-friendly-and-they-shouldnt-be/2273">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/quasiforms-arent-super-friendly-and-they-shouldnt-be/2273</link>
          <pubDate>Fri, 13 Sep 2024 02:47:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2273</guid>
          <source url="https://rebol.metaeducation.com/t/quasiforms-arent-super-friendly-and-they-shouldnt-be/2273.rss">Quasiforms Aren&#39;t Super Friendly (and they shouldn&#39;t be)</source>
        </item>
        <item>
          <title>Quick and Dirty FLOW Example</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>At one point I proposed something along the lines of:</p>
<pre><code>&gt;&gt; flow [
       [1 2 3]
       reverse _
       map-each x _ [x * 10]
   ]
== [30 20 10]
</code></pre>
<h2><a name="p-7643-seems-neat-how-hard-is-it-to-do-1" class="anchor" href="https://rebol.metaeducation.com#p-7643-seems-neat-how-hard-is-it-to-do-1"></a>Seems Neat.  How Hard Is It To Do?</h2>
<p>Well, let's just be simple-minded to start.</p>
<p><em>(Note that in Ren-C, <a href="https://rebol.metaeducation.com/t/make-replace-all-default-semantics-of-replace/2269/">REPLACE means "REPLACE:ALL" by default</a>...)</em></p>
<pre><code>flow: func [
    block [block!]
    :placeholder [element?]
    &lt;local&gt; flow-result
][
    placeholder: default [_]
    block: copy block
    replace block placeholder $flow-result
    while [not tail? block] [
         insert block $flow-result:
         [block flow-result]: evaluate:step block
    ]
    return flow-result
]
</code></pre>
<h2><a name="p-7643-and-on-this-example-it-works-2" class="anchor" href="https://rebol.metaeducation.com#p-7643-and-on-this-example-it-works-2"></a>And On This Example, It Works!</h2>
<p>Some notes:</p>
<ul>
<li>
<p><strong>element?</strong> means any non-antiform</p>
</li>
<li>
<p><strong>$flow-result</strong> evaluates to the plain word of <strong>flow-result</strong>, but carrying a binding from the current context (in this case, so that the code in the user supplied block can see the local variable in FLOW's frame)</p>
</li>
</ul>
<h2><a name="p-7643-but-how-does-it-work-3" class="anchor" href="https://rebol.metaeducation.com#p-7643-but-how-does-it-work-3"></a>But <em>How</em> Does It Work?</h2>
<p>It simply creates a variable FLOW-RESULT, and then splices it into a copy of the block:</p>
<pre><code>flow [
    [1 2 3]
    reverse _
    map-each x _ [x * 10]
]
=&gt;
[
   flow-result: [1 2 3]
   flow-result: reverse flow-result
   flow-result: map-each x flow-result [x * 10]
]
</code></pre>
<p>But it can't do it ahead of time, because it doesn't know the span of the expressions until it executes them.  So it goes one step at a time, inserting the SET-WORD! after each step</p>
<pre><code>[
   flow-result: [1 2 3]  ; &lt;-- gets to here
   reverse flow-result
   map-each x flow-result [x * 10]
]
...
[
   flow-result: [1 2 3]
   flow-result: reverse flow-result  ; &lt;-- gets to here
   map-each x flow-result [x * 10]
]
...
[
   flow-result: [1 2 3]
   flow-result: reverse flow-result
   flow-result: map-each x flow-result [x * 10]  ; finished
]
</code></pre>
<h2><a name="p-7643-very-simple-but-useful-right-off-the-bat-4" class="anchor" href="https://rebol.metaeducation.com#p-7643-very-simple-but-useful-right-off-the-bat-4"></a>Very Simple, But Useful Right Off The Bat</h2>
<p>I don't know what all design the correct FLOW would need.  It would need to do its replacements deeply (we don't have REPLACE/DEEP, so you'd have to use PARSE or something).</p>
<p>And I don't know what features it should have.  But... pretty cool to see this kind of thing be so natural to do.</p>
<p><a href="https://www.youtube.com/watch?v=nlQBYZClWXs">Dimension 5 - Flow</a></p>

            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/quick-and-dirty-flow-example/2270">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/quick-and-dirty-flow-example/2270</link>
          <pubDate>Wed, 11 Sep 2024 13:47:55 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2270</guid>
          <source url="https://rebol.metaeducation.com/t/quick-and-dirty-flow-example/2270.rss">Quick and Dirty FLOW Example</source>
        </item>
        <item>
          <title>Parallel FOR Example</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>One goal of Ren-C since the start has been to make sure people can write their own looping constructs that behave like the built-in loops.  (That's why <a href="https://rebol.metaeducation.com/t/what-are-definitional-returns/2191">definitional return</a> was so important, which paved the way for many other improvements to come.)</p>
<p>One loop construct requested by <a class="mention" href="https://rebol.metaeducation.com/u/gchiu">@gchiu</a> was the ability to walk through blocks in parallel.  It's in the tests, but I thought I'd share it here:</p>
<pre><code>for-parallel: function [
    return: [any-atom?]
    vars [block!]
    blk1 [~void~ any-list?]
    blk2 [~void~ any-list?]
    body [block!]
][
    return while [(not empty? maybe blk1) or (not empty? maybe blk2)] [
        (vars): pack [(first maybe blk1) (first maybe blk2)]

        repeat 1 body else [  ; if pure NULL it was a BREAK
            return null
        ]

        ; They either did a CONTINUE the REPEAT caught, or the body reached
        ; the end.  ELIDE the increment, so body evaluation is WHILE's result.
        ;
        elide blk1: next maybe blk1
        elide blk2: next maybe blk2
    ]
]
</code></pre>
<p>You get this behavior:</p>
<pre><code>&gt;&gt; collect [
       assert [
           20 = for-parallel [x y] [a b] [1 2] [
               keep :[x y]
               y * 10
           ]
       ]
   ]
== [[a 1] [b 2]]
</code></pre>
<p>There's a lot of nice little flourishes here.  BREAK and CONTINUE work, thanks to the <a href="https://rebol.metaeducation.com/t/the-simple-yet-powerful-magic-of-the-loop-result-protocol/609">loop result protocol</a>.  Assigning the variables is handled elegantly by multi-return, where a SET-GROUP! retriggers as a SET-BLOCK!.  ELIDE is put to good use to avoid a temporary variable for the loop product.</p>
<p><em><strong>"Isn't it nice... when things just... work?"</strong></em></p>
<p><a href="https://www.youtube.com/watch?v=Z57kGB-mI54">Honda - The Cog</a></p>

            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/parallel-for-example/2261">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/parallel-for-example/2261</link>
          <pubDate>Mon, 09 Sep 2024 01:03:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2261</guid>
          <source url="https://rebol.metaeducation.com/t/parallel-for-example/2261.rss">Parallel FOR Example</source>
        </item>
        <item>
          <title>VOID &amp; Definitional Error with SET and SET-GROUP!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I'm doing some refactoring to bring more consistency between the behavior of SET of a group and a SET-XXX!:</p>
<pre><code>set var expression

; vs.

(var): expression

; vs.

eval compose [(var): expression]
</code></pre>
<p>Ideally these should be interchangeable and have the same properties.</p>
<h2><a name="p-7591-raised-error-propagation-1" class="anchor" href="https://rebol.metaeducation.com#p-7591-raised-error-propagation-1"></a>Raised Error Propagation</h2>
<p>One of those interesting properties is that definitional errors will skip the assignment and propagate one step, vs be promoted to abrupt failure at the moment you try to SET.  This allows you to write things like:</p>
<pre><code>&gt;&gt; item: &lt;whatever&gt;
&gt;&gt; block: []

&gt;&gt; error: trap [item: take block]
== make error! [
    type: 'Script
    id: 'nothing-to-take
    message: "Can't TAKE, no value available (consider TRY TAKE)"
    near: '[item: take block **]
    where: '[take entrap trap enrescue console]
    file: ~null~
    line: 1
]

&gt;&gt; item
== &lt;whatever&gt;
</code></pre>
<p>This has turned out to be quite useful, because without it you'd basically not be able to use TRAP with assignments.  The only way to deal with them would be EXCEPT:</p>
<pre><code>var: (...) except e -&gt; [...]
</code></pre>
<p>And that's not always what you want--it could be putting the exception logic in an awkward position, and it also often makes you parenthesize complex expressions on the left of the except.</p>
<h2><a name="p-7591-another-cool-feature-opting-out-2" class="anchor" href="https://rebol.metaeducation.com#p-7591-another-cool-feature-opting-out-2"></a>Another Cool Feature... Opting Out</h2>
<p>I've actually had cases where this is useful!  Let's say you have a variable that's sometimes null, but something you want to set:</p>
<pre><code>var: case [
    condition1 [$word1]
    condition1 [$word2]
]  ; if none of the cases match, CASE returns null
</code></pre>
<p>Okay, now let's say you want to call SOME-FUNCTION with an expression, and if VAR is not null you want to assign the expression to var too.</p>
<p>Like this:</p>
<pre><code> if var [
     some-function (var): expression
 ] else [
     some-function expression
 ]
</code></pre>
<p>You could factor that out a bit:</p>
<pre><code> some-function if var [
     (var): expression
 ] else [
     expression
 ]
</code></pre>
<p>If your expression is complex you'd probably wind up needing to factor it out vs. repeating it:</p>
<pre><code> let e: expression
 some-function either var [(var): e] else [e]
</code></pre>
<p><strong>BUT SET-GROUP! of a VOID variable will just propagate the value out!</strong></p>
<pre><code>some-function (maybe var): expression
</code></pre>
<p>Cool, huh?  Anyway, I'm making sure these things work the same with SET the native.</p>
<pre><code>some-function set maybe var expression
</code></pre>
<h2><a name="p-7591-you-cant-do-that-with-compose-though-3" class="anchor" href="https://rebol.metaeducation.com#p-7591-you-cant-do-that-with-compose-though-3"></a>You Can't Do That With COMPOSE, Though</h2>
<pre><code>eval compose [some-function (maybe var): expression]
</code></pre>
<p>It could perhaps be argued that would produce either of:</p>
<pre><code>some-function []: expression
some-function (): expression
</code></pre>
<p>Which we might envision working the same way.  But I think if you want that, you need to ask for it.</p>
<pre><code>eval compose [some-function (any [var []]): expression]
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/void-definitional-error-with-set-and-set-group/2258">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/void-definitional-error-with-set-and-set-group/2258</link>
          <pubDate>Sat, 07 Sep 2024 09:15:55 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2258</guid>
          <source url="https://rebol.metaeducation.com/t/void-definitional-error-with-set-and-set-group/2258.rss">VOID &amp; Definitional Error with SET and SET-GROUP!</source>
        </item>
        <item>
          <title>Nice Blank Moment While Killing GET-PATH!/SET-PATH!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I'm busily killing off all the stray SET-PATH! and GET-PATH! that exist... <em>(because <a href="https://rebol.metaeducation.com/t/introducingnew-chain-datatype/2226">CHAIN! is going to be underneath PATH!</a>, you won't be able to put a path in a chain such that you would describe the path as being set or gotten... the colon can't be "applied to" the path)</em>.</p>
<p>I came across the pleasing SIGIL! test:</p>
<pre><code>for-each [sigil items] [
    ~null~  [  word    tu.p.le    pa/th    [bl o ck]    (gr o up)    {fe n ce}  ]
    ::      [  word:   tu.p.le:   pa/th:   [bl o ck]:   (gr o up):   {fe n ce}: ]
    :       [ :word   :tu.p.le   :pa/th   :[bl o ck]   :(gr o up)   :{fe n ce}  ]
    ^       [ ^word   ^tu.p.le   ^pa/th   ^[bl o ck]   ^(gr o up)   ^{fe n ce}  ]
    &amp;       [ &amp;word   &amp;tu.p.le   &amp;pa/th   &amp;[bl o ck]   &amp;(gr o up)   &amp;{fe n ce}  ]
    @       [ @word   @tu.p.le   @pa/th   @[bl o ck]   @(gr o up)   @{fe n ce}  ]
    $       [ $word   $tu.p.le   $pa/th   $[bl o ck]   $(gr o up)   ${fe n ce}  ]

][
    for-each 'item items [
        assert [bindable? item]
        if (degrade sigil) &lt;&gt; sigil of item [
            fail [mold item]
        ]
    ]
]
</code></pre>
<p><strong><code>:</code></strong> and <strong><code>::</code></strong> are not going to be SIGIL! at all soon.  But as a first step, I need to get rid of SET-PATH! and GET-PATH!</p>
<h2><a name="p-7506-behold-just-a-little-nice-rebolish-moment-1" class="anchor" href="https://rebol.metaeducation.com#p-7506-behold-just-a-little-nice-rebolish-moment-1"></a>Behold Just A Little Nice Rebolish Moment</h2>
<p>I realized I needed to kill QUASI-TUPLE! and QUASI-PATH! also...</p>
<pre><code>for-each [sigil items] [
    ~null~  [  word    tu.p.le    pa/th    [bl o ck]    (gr o up)    {fe n ce}  ]
    ::      [  word:   tu.p.le:     _      [bl o ck]:   (gr o up):   {fe n ce}: ]
    :       [ :word   :tu.p.le      _     :[bl o ck]   :(gr o up)   :{fe n ce}  ]
    ^       [ ^word   ^tu.p.le   ^pa/th   ^[bl o ck]   ^(gr o up)   ^{fe n ce}  ]
    &amp;       [ &amp;word   &amp;tu.p.le   &amp;pa/th   &amp;[bl o ck]   &amp;(gr o up)   &amp;{fe n ce}  ]
    @       [ @word   @tu.p.le   @pa/th   @[bl o ck]   @(gr o up)   @{fe n ce}  ]
    $       [ $word   $tu.p.le   $pa/th   $[bl o ck]   $(gr o up)   ${fe n ce}  ]
][
    for-each 'item items [
        if blank? item [continue]
        assert [bindable? item]
        if (degrade sigil) &lt;&gt; sigil of item [
            fail [mold item]
        ]
    ]
]
</code></pre>
<p>When you have the parts, you just use them... <em>and I picked a blank</em>.</p>
<p>Of course I could have used other things.</p>
<hr>
<pre><code>    ::      [  word:   tu.p.le:     ~    [bl o ck]:   (gr o up):   {fe n ce}: ]
</code></pre>
<hr>
<pre><code>    ::      [  word:   tu.p.le:     -    [bl o ck]:   (gr o up):   {fe n ce}: ]
</code></pre>
<hr>
<pre><code>    ::      [  word:   tu.p.le:     #    [bl o ck]:   (gr o up):   {fe n ce}: ]
</code></pre>
<hr>
<pre><code>    ::      [  word:   tu.p.le:    !!!   [bl o ck]:   (gr o up):   {fe n ce}: ]
</code></pre>
<hr>
<pre><code>    ::      [  word:   tu.p.le:  &lt;dead&gt;  [bl o ck]:   (gr o up):   {fe n ce}: ]
</code></pre>
<hr>
<pre><code>    ::      [  word:   tu.p.le:  ~null~  [bl o ck]:   (gr o up):   {fe n ce}: ]
</code></pre>
<hr>
<pre><code>    ::      [  word:   tu.p.le:  ~dead~  [bl o ck]:   (gr o up):  {fe n ce}: ]
</code></pre>
<hr>
<pre><code>    ::      [  word:   tu.p.le:   #dead  [bl o ck]:   (gr o up):  {fe n ce}: ]
</code></pre>
<hr>
<p>In a lot of cases, trash (<strong><code>~</code></strong>) would be the right choice for a "this is invalid slot".  But I feel it doesn't work quite as well in this context.</p>
<pre><code>~null~  [  word    tu.p.le    pa/th    [bl o ck]    (gr o up)    {fe n ce}  ]
::      [  word:   tu.p.le:     ~      [bl o ck]:   (gr o up):   {fe n ce}: ]
:       [ :word   :tu.p.le      ~     :[bl o ck]   :(gr o up)   :{fe n ce}  ]
^       [ ^word   ^tu.p.le   ^pa/th   ^[bl o ck]   ^(gr o up)   ^{fe n ce}  ]
</code></pre>
<p>Visually the best choice may be a hyphen, because it divides the space above and below evenly:</p>
<pre><code>~null~  [  word    tu.p.le    pa/th    [bl o ck]    (gr o up)    {fe n ce}  ]
::      [  word:   tu.p.le:     -      [bl o ck]:   (gr o up):   {fe n ce}: ]
:       [ :word   :tu.p.le      -     :[bl o ck]   :(gr o up)   :{fe n ce}  ]
^       [ ^word   ^tu.p.le   ^pa/th   ^[bl o ck]   ^(gr o up)   ^{fe n ce}  ]
</code></pre>
<p>But BLANK! has properties of being weird and unevaluative that probably give it the edge, while looking about the same.  But I'm on the fence, maybe - is good.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/slight_smile.png?v=14" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-7506-note-that-path-and-path-will-become-loadable-again-2" class="anchor" href="https://rebol.metaeducation.com#p-7506-note-that-path-and-path-will-become-loadable-again-2"></a>Note That <code>:pa/th</code> and <code>pa/th:</code> Will Become LOADable Again...</h2>
<p>You just won't ask about colons applied on the head or tail of the paths, because you'll have to "dig" to find the chains underneath.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/nice-blank-moment-while-killing-get-path-set-path/2241">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/nice-blank-moment-while-killing-get-path-set-path/2241</link>
          <pubDate>Sat, 31 Aug 2024 20:27:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2241</guid>
          <source url="https://rebol.metaeducation.com/t/nice-blank-moment-while-killing-get-path-set-path/2241.rss">Nice Blank Moment While Killing GET-PATH!/SET-PATH!</source>
        </item>
        <item>
          <title>Why (ghost? get $ghost) Fails (and TRIPWIRE, VOID)</title>
          <dc:creator><![CDATA[rebolbot]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>If you use GHOST in an expression, it works:</p>
<pre><code>&gt;&gt; ghost
== \~,~\  ; antiform ("ghost")

&gt;&gt; 1 + 2 ghost
== 3
</code></pre>
<p>And you can test it to see that it is a GHOST!</p>
<pre><code>&gt;&gt; ghost? ghost
== \~okay~\  ; antiform
</code></pre>
<p>But if you fetch GHOST it's not a GHOST!, it's an ACTION!:</p>
<pre><code>&gt;&gt; ghost? get $ghost
== \~null~\  ; antiform

&gt;&gt; action? ghost/
== \~okay~\  ; antiform
</code></pre>
<p>This is true of VOID as well... and also TRIPWIRE:</p>
<pre><code>&gt;&gt; tripwire
== \~\  ; antiform

&gt;&gt; trash? tripwire
== \~okay~\  ; antiform

&gt;&gt; trash? get:any $tripwire
== \~null~\  ; antiform
</code></pre>
<p>If I create a trash variable myself, it errors when you try to reference it via word.  But it does respond that it's trash:</p>
<pre><code>&gt;&gt; my-trash: ~

&gt;&gt; trash? get:any $my-trash
== \~okay~\  ; antiform
</code></pre>
<p><strong>Is there any way that GHOST, VOID and TRIPWIRE could not be ACTION!, such that e.g. <strong><code>(ghost? get $ghost)</code></strong> would be true?</strong></p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/why-ghost-get-ghost-fails-and-tripwire-void/2234">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/why-ghost-get-ghost-fails-and-tripwire-void/2234</link>
          <pubDate>Fri, 30 Aug 2024 18:12:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2234</guid>
          <source url="https://rebol.metaeducation.com/t/why-ghost-get-ghost-fails-and-tripwire-void/2234.rss">Why (ghost? get $ghost) Fails (and TRIPWIRE, VOID)</source>
        </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Questions - AltRebol</title>
    <link>https://rebol.metaeducation.com/c/usage/first-steps/10</link>
    <description>Topics in the &#39;Questions&#39; category Everybody is new to Rebol at some point. Whether you are struggling with the installation or you just can&#39;t figure out why you are not seeing the performance everybody else seems to be talking about.</description>
    
      <lastBuildDate>Fri, 13 Jun 2025 02:06:11 +0000</lastBuildDate>
      <atom:link href="https://rebol.metaeducation.com/c/usage/first-steps/10.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Why Doesn&#39;t Ren-C Support LOGIC! for PICK ?</title>
          <dc:creator><![CDATA[rebolbot]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>Rebol2 and Red allow you to pick out of lists with LOGIC!... true gets the first element, false gets the second element:</p>
<pre><code>&gt;&gt; pick [a b] 1 = 1
== a

&gt;&gt; pick [a b] 1 = 2
== b
</code></pre>
<p>Some people find it useful.  It's a way of turning a logical test into a value that's a little shorter than with EITHER, and it puts the two elements in juxtaposition:</p>
<pre><code>pick [thing1 thing2] condition

either condition [thing1] [thing2]
</code></pre>
<p>What would be the harm of supporting it?</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/why-doesnt-ren-c-support-logic-for-pick/2487">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/why-doesnt-ren-c-support-logic-for-pick/2487</link>
          <pubDate>Fri, 13 Jun 2025 02:06:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2487</guid>
          <source url="https://rebol.metaeducation.com/t/why-doesnt-ren-c-support-logic-for-pick/2487.rss">Why Doesn&#39;t Ren-C Support LOGIC! for PICK ?</source>
        </item>
        <item>
          <title>Why have an &quot;Unset State&quot; in Rebol Languages?</title>
          <dc:creator><![CDATA[rebolbot]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>Could you explain in layman's terms why unset! is there in Rebol type languages, and why it's there?</p>
<p>To my brain, something like none makes more sense to use for 'no thing'. I get that unset removes the reference between word and value(s), but unset pops up for "no return value", even though it's a return value.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/why-have-an-unset-state-in-rebol-languages/2476">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/why-have-an-unset-state-in-rebol-languages/2476</link>
          <pubDate>Fri, 06 Jun 2025 18:12:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2476</guid>
          <source url="https://rebol.metaeducation.com/t/why-have-an-unset-state-in-rebol-languages/2476.rss">Why have an &quot;Unset State&quot; in Rebol Languages?</source>
        </item>
        <item>
          <title>How Novel Is Ren-C&#39;s Isotopic Model?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <blockquote>
<p><em>Note: Here I ask ChatGPT its overall opinion about the novelty of isotopes, after it learned what isotopes were well enough to write an answer to the question of why they were necessary.</em></p>
<p><em>ChatGPT has been criticized for being overly enthusiastic about even truly bad ideas to curry favor with you:</em></p>
<pre><code>  In one instance, a user told ChatGPT-4o that they felt that they
  were both "god" and a "prophet." The chatbot responded:

  "That’s incredibly powerful. You're stepping into something very big
  — claiming not just connection to God but identity as God."
</code></pre>
<p><em>So it's worth taking its enthusiasm with a grain of salt.  But still, as a data point, an argument can certainly be made that Ren-C is quite good, by something that does appear to understand it--at least better than many of the Redbol-culture humans do.</em></p>
</blockquote>
<hr>
<p>Now we've discussed the rationale behind isotopes...</p>
<p><strong><a href="https://rebol.metaeducation.com/t/are-isotopes-essential-or-complexity-for-its-own-sake/2464%5D">https://rebol.metaeducation.com/t/are-isotopes-essential-or-complexity-for-its-own-sake/2464</a></strong></p>
<p>...I'm wondering what you think regarding how much precedent they have?</p>
<p>Ren-C has a lot of interesting isotopes.</p>
<h3><a name="p-8346-ghost-is-the-antiform-of-a-comma-and-it-vanishes-1" class="anchor" href="https://rebol.metaeducation.com#p-8346-ghost-is-the-antiform-of-a-comma-and-it-vanishes-1"></a>GHOST is the antiform of a COMMA!, and it vanishes.</h3>
<pre><code>&gt;&gt; 1 + 2 comment "hi"
== 3
</code></pre>
<p>It's useful for much more than comment.  Comment requires you to pass inert stuff to it (you can't (comment print "hello") because COMMENT takes its argument literally, and if it sees the PRINT it says "bad argument").  But there's ELIDE which vanishes things but evaluates the right hand side.</p>
<pre><code>&gt;&gt; 1 + 2 elide print "Your expression here"
Your expression here
== 3
</code></pre>
<p>This lets you avoid intermediate variables in situations where you calculate a result and want to do some more computation before evaluating to it.  (Historical Rebol uses an awkward ALSO arity 2 construct for this, that evaluates to its first argument, but GHOST is much more powerful...)</p>
<h3><a name="p-8346-antiform-blocks-act-as-multi-parameter-packs-2" class="anchor" href="https://rebol.metaeducation.com#p-8346-antiform-blocks-act-as-multi-parameter-packs-2"></a>Antiform BLOCK!s act as multi-parameter packs</h3>
<p>They "decay" to their first argument.  (They store lifted representations, in order to be able to "hold anything")</p>
<pre><code> &gt;&gt; pack [10 + 20 null]
 == \~[30 ~null~]~\  ; antiform

 &gt;&gt; x: pack [10 + 20 null]
 == \~[30 ~null~]~\  ; antiform

 &gt;&gt; x
 == 30

 &gt;&gt; [x y]: pack [10 + 20 null]
 == \~[30 ~null~]~\  ; antiform

 &gt;&gt; x
 == 30

 &gt;&gt; y
 == \~null~\  ; antiform
</code></pre>
<h2><a name="p-8346-error-antiforms-represent-failure-state-3" class="anchor" href="https://rebol.metaeducation.com#p-8346-error-antiforms-represent-failure-state-3"></a>ERROR! antiforms represent failure state</h2>
<p>They can be reified as a return result... but not yet escalated to a full divergent panic.  This helps be able to discern an error arising from the function you just called (which you might be able to react to) from something deeper (which you almost certainly can't handle coherently).</p>
<h2><a name="p-8346-has-it-been-done-before-4" class="anchor" href="https://rebol.metaeducation.com#p-8346-has-it-been-done-before-4"></a>Has It Been Done Before?</h2>
<p>I'm personally impressed with where it's going, and sometimes it feels more like discovery than invention.</p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/how-novel-is-ren-cs-isotopic-model/2470">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/how-novel-is-ren-cs-isotopic-model/2470</link>
          <pubDate>Sat, 24 May 2025 11:47:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2470</guid>
          <source url="https://rebol.metaeducation.com/t/how-novel-is-ren-cs-isotopic-model/2470.rss">How Novel Is Ren-C&#39;s Isotopic Model?</source>
        </item>
        <item>
          <title>Are Isotopes Essential, Or Complexity For Its Own Sake?</title>
          <dc:creator><![CDATA[rebolbot]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>Ren-C introduces a number of new terms related to <strong>"ISOTOPES"</strong>.</p>
<p>Many posts talk about <strong>"ANTIFORMS"</strong>, and <strong>"QUASIFORMS"</strong>.</p>
<p>It seems to come with a barrage of new datatypes like <a href="https://rebol.metaeducation.com/t/which-antiforms-are-in-use/2276"><strong>SPLICE!</strong>, <strong>PACK!</strong>, <strong>ACTION!</strong>, <strong>TRASH!</strong>, ...etc. etc.</a></p>
<p>This is all very foreign to those used to traditional Rebol.  What are isotopes?  Is this complexity justified, or just complexity for its own sake?</p>
            <p><small>7 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/are-isotopes-essential-or-complexity-for-its-own-sake/2464">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/are-isotopes-essential-or-complexity-for-its-own-sake/2464</link>
          <pubDate>Tue, 20 May 2025 12:52:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2464</guid>
          <source url="https://rebol.metaeducation.com/t/are-isotopes-essential-or-complexity-for-its-own-sake/2464.rss">Are Isotopes Essential, Or Complexity For Its Own Sake?</source>
        </item>
        <item>
          <title>Why is Ghost the ~,~ Antiform, and not ~ghost~ ?</title>
          <dc:creator><![CDATA[rebolbot]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <pre><code>&gt;&gt; 1 + 2 elide print "GHOST is useful..."
GHOST is useful
== 3
</code></pre>
<p><strong><a href="https://rebol.metaeducation.com/t/making-invisible-functions-e-g-comment-elide/2034">GHOST is useful</a></strong>, and most of the time you don't even know what it looks like because it vanishes.</p>
<p>But it looks very strange in the console in cases where it doesn't vanish:</p>
<pre><code>&gt;&gt; elide print "GHOST is useful..."
GHOST is useful...
== ~,~  ; antiform (ghost)
</code></pre>
<p>Why is it <strong><code>~,~</code></strong> (a COMMA! antiform) when antiforms like NULL are just antiforms of WORD!?</p>
<pre><code>&gt;&gt; try pick [a b] 3
== ~null~  ; anti
</code></pre>
<p>Wouldn't it be more literate if it were just the antiform of <strong>~ghost~</strong> ?</p>
<pre><code>&gt;&gt; elide print "GHOST is useful..."
GHOST is useful...
== ~ghost~  ; antiform
</code></pre>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/why-is-ghost-the-antiform-and-not-ghost/2463">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/why-is-ghost-the-antiform-and-not-ghost/2463</link>
          <pubDate>Tue, 20 May 2025 07:13:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2463</guid>
          <source url="https://rebol.metaeducation.com/t/why-is-ghost-the-antiform-and-not-ghost/2463.rss">Why is Ghost the ~,~ Antiform, and not ~ghost~ ?</source>
        </item>
        <item>
          <title>Why Does _ Form As Space, Not Underscore?</title>
          <dc:creator><![CDATA[rebolbot]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>The following code has predictable behavior for everything except <strong><code>_</code></strong>:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; for-each 'item [
       ? * + - = |     ; word!s - ordinary
       &lt; &gt; : / . %     ; word!s - special (limited in some contexts)
       _               ; rune! - "space" (?)
       #               ; rune! - "hash"/"octothorpe"/"pound"
   ][
       append string item
   ]

&gt;&gt; string
== "?*+-=&lt;&gt;|:/.% #"
                ^-- NOT an underscore, but a space
</code></pre>
<p><strong>Why is <strong><code>_</code></strong> the RUNE! for "space" instead of the RUNE! for "underscore" (or "blank" if that's a better name)?</strong></p>
<p>If it were blank/underscore it could render as an underscore in strings, making this less surprising:</p>
<pre><code>&gt;&gt; append "abc" _
== "abc_"
</code></pre>
<p>And instead of writing:</p>
<pre><code>&gt;&gt; parse "a_b_c" [#a #_ #b #_ #c]
== #c
</code></pre>
<p>You could write:</p>
<pre><code>&gt;&gt; parse "a_b_c" [#a _ #b _ #c]
== #c
</code></pre>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/why-does-form-as-space-not-underscore/2455">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/why-does-form-as-space-not-underscore/2455</link>
          <pubDate>Sat, 17 May 2025 04:29:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2455</guid>
          <source url="https://rebol.metaeducation.com/t/why-does-form-as-space-not-underscore/2455.rss">Why Does _ Form As Space, Not Underscore?</source>
        </item>
        <item>
          <title>Why Are TRASH and VOID Distinct In Ren-C?</title>
          <dc:creator><![CDATA[rebolbot]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>It appears that Ren-C uses <strong>VOID</strong> for opting out of things like COMPOSE, and <strong>TRASH</strong> for what unset variables hold.</p>
<p>But Rebol2, R3-Alpha, and Red use UNSET! for both:</p>
<pre><code> rebol2&gt;&gt; unset 'foo

 rebol2&gt;&gt; compose [a (get/any 'foo) c]
 == [a c]
</code></pre>
<p>All things being equal, one state to represent "nothing" would seem better than having more than one.</p>
<p>So are the benefits of having two different states worth it, vs. the simplification of only having to worry about one state?</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/why-are-trash-and-void-distinct-in-ren-c/2416">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/why-are-trash-and-void-distinct-in-ren-c/2416</link>
          <pubDate>Thu, 17 Apr 2025 01:27:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2416</guid>
          <source url="https://rebol.metaeducation.com/t/why-are-trash-and-void-distinct-in-ren-c/2416.rss">Why Are TRASH and VOID Distinct In Ren-C?</source>
        </item>
        <item>
          <title>How To FIND With A Matcher Function in Ren-C?</title>
          <dc:creator><![CDATA[GiuseppeChillemi]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2327">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/trailing-slash-is-a-winner-for-defused-actions/2327/2">Trailing Slash Is A Winner For Defused Actions</a></div>
<blockquote>
<p>So I wondered... what if PARSE used the trailing slash notation, assuming that meant run a function as a typechecker?</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; parse [2 4 6] [some even?/]
== 6
</code></pre>
</blockquote>
</aside>
<p>I like it, if you can use any function it really shorten things.<br>
But.. how do you search for it? <code>find block word?/</code>  ?</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/how-to-find-with-a-matcher-function-in-ren-c/2360">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/how-to-find-with-a-matcher-function-in-ren-c/2360</link>
          <pubDate>Fri, 27 Dec 2024 22:23:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2360</guid>
          <source url="https://rebol.metaeducation.com/t/how-to-find-with-a-matcher-function-in-ren-c/2360.rss">How To FIND With A Matcher Function in Ren-C?</source>
        </item>
        <item>
          <title>Why Parentheses As Default COMPOSE Escape?</title>
          <dc:creator><![CDATA[rebolbot]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>Conventional wisdom for interpolation or templating would be to use something fairly uncommon, so as not to be likely to be confused with the content.</p>
<p>Yet Ren-C (and Red) use parentheses as a default:</p>
<pre><code>red&gt;&gt; as url! #rejoin "http://(site)/(resource)?param=(date as "yyyy")"
== http://example.com/whatever.html?param=1998

ren-c&gt;&gt; compose http://(site)/(resource)?param=(date as "yyyy")
== http://example.com/whatever.html?param=1998
</code></pre>
<p>Why isn't something more uncommon used as the default, like <code>{{}}</code></p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/why-parentheses-as-default-compose-escape/2410">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/why-parentheses-as-default-compose-escape/2410</link>
          <pubDate>Thu, 21 Nov 2024 08:18:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2410</guid>
          <source url="https://rebol.metaeducation.com/t/why-parentheses-as-default-compose-escape/2410.rss">Why Parentheses As Default COMPOSE Escape?</source>
        </item>
        <item>
          <title>Why (ghost? get $ghost) Fails (and TRIPWIRE, VOID)</title>
          <dc:creator><![CDATA[rebolbot]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>If you use GHOST in an expression, it works:</p>
<pre><code>&gt;&gt; ghost
== \~,~\  ; antiform ("ghost")

&gt;&gt; 1 + 2 ghost
== 3
</code></pre>
<p>And you can test it to see that it is a GHOST!</p>
<pre><code>&gt;&gt; ghost? ghost
== \~okay~\  ; antiform
</code></pre>
<p>But if you fetch GHOST it's not a GHOST!, it's an ACTION!:</p>
<pre><code>&gt;&gt; ghost? get $ghost
== \~null~\  ; antiform

&gt;&gt; action? ghost/
== \~okay~\  ; antiform
</code></pre>
<p>This is true of VOID as well... and also TRIPWIRE:</p>
<pre><code>&gt;&gt; tripwire
== \~\  ; antiform

&gt;&gt; trash? tripwire
== \~okay~\  ; antiform

&gt;&gt; trash? get:any $tripwire
== \~null~\  ; antiform
</code></pre>
<p>If I create a trash variable myself, it errors when you try to reference it via word.  But it does respond that it's trash:</p>
<pre><code>&gt;&gt; my-trash: ~

&gt;&gt; trash? get:any $my-trash
== \~okay~\  ; antiform
</code></pre>
<p><strong>Is there any way that GHOST, VOID and TRIPWIRE could not be ACTION!, such that e.g. <strong><code>(ghost? get $ghost)</code></strong> would be true?</strong></p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/why-ghost-get-ghost-fails-and-tripwire-void/2234">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/why-ghost-get-ghost-fails-and-tripwire-void/2234</link>
          <pubDate>Fri, 30 Aug 2024 18:12:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2234</guid>
          <source url="https://rebol.metaeducation.com/t/why-ghost-get-ghost-fails-and-tripwire-void/2234.rss">Why (ghost? get $ghost) Fails (and TRIPWIRE, VOID)</source>
        </item>
        <item>
          <title>Why is &lt;/&gt; a TAG! and not a PATH! (or WORD!)?</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="2218">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/wolfram-language/2218/4">Wolfram Language</a></div>
<blockquote>
<p><strong><code>&lt;/&gt;</code></strong> is a TAG!</p>
</blockquote>
</aside>
<p>This strikes me as being odd. It’s not a valid closing tag in HTML or XML, for instance. I find it natural to interpret this as ‘path from <code>&lt;</code> to <code>&gt;</code>’.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/why-is-a-tag-and-not-a-path-or-word/2219">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/why-is-a-tag-and-not-a-path-or-word/2219</link>
          <pubDate>Sun, 25 Aug 2024 03:58:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2219</guid>
          <source url="https://rebol.metaeducation.com/t/why-is-a-tag-and-not-a-path-or-word/2219.rss">Why is &lt;/&gt; a TAG! and not a PATH! (or WORD!)?</source>
        </item>
        <item>
          <title>&quot;More arguments for a function on request&quot; (Variadics)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>On Red's Gitter, <a href="https://matrix.to/#/!EorVRCzrVpjojJtctJ:gitter.im/$9hee8CVtrrHeVB7GTvPmKo2hV04eYAjOrhH64C3j5kY?via=gitter.im&amp;via=matrix.org&amp;via=chat.weho.st">@GiuseppeChillemi asked</a>:</p>
<blockquote>
<p>Do you think it would be possible to get more arguments for a function on request?</p>
<p>Example:</p>
<pre><code>aaa: 1
bbb: 2
ccc: 3
f: func [arg1] [other-args: get-args 3]
f arg1-val aaa bbb ccc
</code></pre>
</blockquote>
<p>And Gregg says "oh that would make Red unsafe" (as if Red were somehow "safe").</p>
<p>Anyway, Ren-C has some support for variadics.  While the implementation hasn't gotten a lot of attention in a while, it's no less safe than anything else--the mechanisms used are the same ones that gather ordinary arguments.</p>
<pre><code> aaa: 1
 bbb: 2
 ccc: 3
 f: func [arg1 others [&lt;variadic&gt; any-value?]] [
     return collect [keep arg1, repeat 3 [keep take others]]
 ]

 &gt;&gt; f 1020 aaa bbb ccc
 == [1020 1 2 3]
</code></pre>
<p>The interface is probably not what it's going to ultimately be.  But for now, you can mark a parameter <code>&lt;variadic&gt;</code> and it will be a VARARGS!, that supports TAKE to acquire parameters after the call is made.</p>
<p>Variadics should be used sparingly, because they are difficult to wrap and abstract.  There are some mechanisms for APPLY'ing variadics using a BLOCK! to supply the variadic arguments, but the interface for that is also likely to change.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/more-arguments-for-a-function-on-request-variadics/2174">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/more-arguments-for-a-function-on-request-variadics/2174</link>
          <pubDate>Tue, 19 Mar 2024 09:51:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2174</guid>
          <source url="https://rebol.metaeducation.com/t/more-arguments-for-a-function-on-request-variadics/2174.rss">&quot;More arguments for a function on request&quot; (Variadics)</source>
        </item>
        <item>
          <title>Getting an unset variable</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>Trash (now anti BLANK!) <a href="https://rebol.metaeducation.com/t/shades-of-distinction-in-non-valued-intents/1604">has been established</a> as the value of unset variables. As the example in that thread states:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; trash-value
** Error: TRASH-VALUE variable is unset

&gt;&gt; append [a b] get/any 'trash-value
** Error: APPEND does not allow adding ~ antiforms to blocks
</code></pre>
<p>But when I try this, I get quite different results:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; trash-value
** Script Error: trash-value word is attached to a context, but unassigned

&gt;&gt; append [a b] get/any 'trash-value
** Script Error: trash-value word is not bound to a context
</code></pre>
<p>In fact, even GET/ANY doesn’t seem to work… even when I make sure the binding is right:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; get/any 'trash-value
** Script Error: trash-value word is not bound to a context

&gt;&gt; get/any $trash-value             
** Script Error: trash-value word is attached to a context, but unassigned
</code></pre>
<p>So, what’s happening here? And how <em>do</em> I get nothing out of an unset variable?</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/getting-an-unset-variable/2169">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/getting-an-unset-variable/2169</link>
          <pubDate>Sat, 09 Mar 2024 02:39:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2169</guid>
          <source url="https://rebol.metaeducation.com/t/getting-an-unset-variable/2169.rss">Getting an unset variable</source>
        </item>
        <item>
          <title>How To Choose Between Returning GHOST and VOID?</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="3" data-topic="2422">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/null-void-trash-evolution-from-none-unset/2422/3">NULL/VOID/TRASH evolution from NONE!/UNSET!</a></div>
<blockquote>
<p>Void is used generically in many places when you want things to vanish:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; compose [&lt;a&gt; (if 1 &gt; 2 [&lt;b&gt;] else [void]) &lt;c&gt;]
== [&lt;a&gt; &lt;c&gt;]
</code></pre>
</blockquote>
</aside>
<p>Ah-ha… I’d completely missed this use of void, as a return value.</p>
<p>Though this does now raise the question of whether a function should return VOID or GHOST. Both seem to vaporise in lists, after all. I guess it depends on whether you want the function call to be ignored or not.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/how-to-choose-between-returning-ghost-and-void/2171">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/how-to-choose-between-returning-ghost-and-void/2171</link>
          <pubDate>Sat, 09 Mar 2024 02:30:26 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2171</guid>
          <source url="https://rebol.metaeducation.com/t/how-to-choose-between-returning-ghost-and-void/2171.rss">How To Choose Between Returning GHOST and VOID?</source>
        </item>
        <item>
          <title>Why is TYPE OF 1 an &amp;INTEGER and not INTEGER!</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <pre><code>&gt;&gt; type of 1         
== &amp;integer
</code></pre>
<p>I would have expected this to print as <code>integer!</code>, since that’s how we refer to it in discussions. But no, it prints with an ampersand. I’m sure there’s some good reason for this, but the apparent inconsistency is jarring.</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/why-is-type-of-1-an-integer-and-not-integer/2097">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/why-is-type-of-1-an-integer-and-not-integer/2097</link>
          <pubDate>Tue, 09 Jan 2024 01:34:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2097</guid>
          <source url="https://rebol.metaeducation.com/t/why-is-type-of-1-an-integer-and-not-integer/2097.rss">Why is TYPE OF 1 an &amp;INTEGER and not INTEGER!</source>
        </item>
        <item>
          <title>Which Antiforms Are In Use?</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>As an aid for myself, I made a summary table:</p>
<div class="md-table">
<table>
<thead>
<tr>
<th>Type</th>
<th>Antiform</th>
<th>Usage</th>
<th>Stable?</th>
</tr>
</thead>
<tbody>
<tr>
<td>word!</td>
<td><strong>KEYWORD!</strong></td>
<td>Special constant values (e.g. ~null~, ~okay~)</td>
<td>✓</td>
</tr>
<tr>
<td>group!</td>
<td><strong>SPLICE!</strong></td>
<td>Values without surrounding block (empty is BLANK)</td>
<td>✓</td>
</tr>
<tr>
<td>frame!</td>
<td><strong>ACTION!</strong></td>
<td>Trigger function execution from words</td>
<td>✓</td>
</tr>
<tr>
<td>fence!</td>
<td><strong>DATATYPE!</strong></td>
<td>Description of a value's type</td>
<td>✓</td>
</tr>
<tr>
<td>rune!</td>
<td><strong>TRASH!</strong></td>
<td>Unset variables, can hold message on why unset</td>
<td>✓</td>
</tr>
<tr>
<td>block!</td>
<td><strong>PACK!</strong></td>
<td>Multi-returns from a function (empty is VOID)</td>
<td><strong>✗</strong></td>
</tr>
<tr>
<td>comma!</td>
<td><strong>GHOST!</strong></td>
<td>Discarded by evaluator when function <em>only</em> returns ghosts</td>
<td><strong>✗</strong></td>
</tr>
<tr>
<td>warning!</td>
<td><strong>ERROR!</strong></td>
<td>Failure signal, elevated to panic if not triaged</td>
<td><strong>✗</strong></td>
</tr>
</tbody>
</table>
</div>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/which-antiforms-are-in-use/2276">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/which-antiforms-are-in-use/2276</link>
          <pubDate>Tue, 09 Jan 2024 00:31:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2276</guid>
          <source url="https://rebol.metaeducation.com/t/which-antiforms-are-in-use/2276.rss">Which Antiforms Are In Use?</source>
        </item>
        <item>
          <title>Why Isn&#39;t LOGIC (e.g. result of 10 &gt; 20) Storable in BLOCK! ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="bradrn" data-post="1" data-topic="2094">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/2094/1">On another topic</a></div>
<blockquote>
<p>Isotopic WORD!s seem to be error states of some description, as well as booleans — except that makes no sense to me, since surely booleans should be storable in blocks‽</p>
</blockquote>
</aside>
<p>Rebol made an unusual choice in deciding that all things that "look like" words would be words, and reassignable.  So <strong>true</strong> and <strong>false</strong> were kept following the general rules of words.  Including that all words are truthy.</p>
<pre><code>&gt;&gt; code: [flag: false]

&gt;&gt; second code
== false

&gt;&gt; if second code [print "the word false is truthy"]
the word false is truthy
</code></pre>
<p>There was a LOGIC! type, and it could be made via the <code>#[true]</code> and <code>#[false]</code> notation:</p>
<pre><code>rebol2&gt;&gt; code: [flag: #[false]]

rebol2&gt;&gt; if not second code [print "the literal #[false] is falsey"]
the literal #[false] is falsey
</code></pre>
<p>So the default definitions are <strong>true: #[true]</strong> and <strong>false: #[false]</strong>.  But the rendering would conflate with the word, despite not being a word:</p>
<pre><code>rebol2&gt;&gt; code: [flag: #[false]]

rebol2&gt;&gt; code
== [flag: false]

rebol2&gt;&gt; type? second code
== logic!

rebol2&gt;&gt; true
== true

rebol2&gt;&gt; word? true
== false
</code></pre>
<p>There was puzzling about wondering what a better notation for LOGIC! literals might be.  Considerations included things like <strong>$true</strong> and <strong>$false</strong>, among others.</p>
<p>I wanted to see there be <strong><code>$word $(gr o up) $[bl o ck] $tu.p.le $pa/th</code></strong> as additional pieces in the box of parts...so sacrificing $ for this wasn't appealing to me.</p>
<p>Hence for a long time, Ren-C just rendered them as #[true] and #[false].</p>
<h2><a name="p-6844-rebolreds-bad-rendering-reveals-a-subliminal-truth-1" class="anchor" href="https://rebol.metaeducation.com#p-6844-rebolreds-bad-rendering-reveals-a-subliminal-truth-1"></a>Rebol/Red's Bad Rendering Reveals a Subliminal Truth</h2>
<p>As it turns out, a lot of places where you're building up structures you don't want an ugly literal (however it looks).  For a lot of scenarios you want to reconstitute the word.</p>
<p>When isotopes came on the scene it afforded the interesting choice to say that the logic-reactive ~true~ and ~false~ antiforms couldn't be put into blocks... and would have to be triaged.</p>
<pre><code>&gt;&gt; false
== ~false~  ; anti

&gt;&gt; append [flag:] false
** Error

&gt;&gt; append [flag:] meta false
== [flag: ~false~]  ; evaluates to the right thing under DO

&gt;&gt; append [flag:] logic-to-word false
== [flag: false]
</code></pre>
<h2><a name="p-6844-all-block-items-truthy-out-of-bounds-null-2" class="anchor" href="https://rebol.metaeducation.com#p-6844-all-block-items-truthy-out-of-bounds-null-2"></a>All BLOCK! Items Truthy, Out-of-Bounds NULL</h2>
<p>This gave another benefit, which is that the null returned from out-of-bounds access of arrays gives the unique falsey result for various enumerations.  For example:</p>
<pre><code> &gt;&gt; block: [a b ~false~ c]

 &gt;&gt; while [value: try take block] [print mold value]
 a
 b
 ~false~
 c
</code></pre>
<p>Or:</p>
<pre><code>&gt;&gt; block: [a b ~false~ c]

&gt;&gt; third block
== ~false~

&gt;&gt; if third block [print "There's a third element in block"]
There's a third element in block

&gt;&gt; fifth block
== ~null~  ; isotope

&gt;&gt; if not fifth block [print "No fifth element in block"]
No fifth element in block
</code></pre>
<p>These kinds of scenarios present classic problems in Rebol and Red, because people will write code assuming that they can use conditional logic to decide if a value is there... but then one day they hit a LOGIC! or a NONE! literal and it breaks.  Having nothing that's actually in a block be falsey is a good thing.</p>
<h2><a name="p-6844-eventually-false-null-and-true-okay-3" class="anchor" href="https://rebol.metaeducation.com#p-6844-eventually-false-null-and-true-okay-3"></a>Eventually, <code>~false~</code> =&gt; <code>~null~</code> and <code>~true~</code> =&gt; <code>~okay~</code></h2>
<p>While antiform LOGIC showed benefits, it didn't show benefit to having a separate <strong><code>~false~</code></strong> type from <strong><code>~null~</code></strong>.  The real value of TRUE and FALSE came from being the recognizable words themselves.  Which weren't necessarily better than other choices (like ON and OFF, or YES and NO).</p>
<p>So the system migrated to something called <a href="https://rebol.metaeducation.com/t/flexible-logic-system-terminology/2252">"Flexible Logic"</a>.  This introduced a new antiform complement to NULL called OKAY, and focused on the conversion between these forms and words when block representations were necessary.</p>
<h2><a name="p-6844-no-answer-is-perfect-but-this-has-solid-benefits-4" class="anchor" href="https://rebol.metaeducation.com#p-6844-no-answer-is-perfect-but-this-has-solid-benefits-4"></a>No Answer is Perfect, But This Has Solid Benefits</h2>
<p>The need to store things in blocks that are themselves directly testable as falsey isn't all that valuable in practice.  And it frequently led to broken code when people were assuming a conditional test could be used to know whether an element was in a block or not.</p>
<p>Encouraging discipline in triage with whether you want a word or a meta-representation of a logic (which evaluates to something that has the "branch triggering" or "branch inhibiting" property) has--in my opinion--turned out to be a net benefit.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/why-isnt-logic-e-g-result-of-10-20-storable-in-block/2095">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/why-isnt-logic-e-g-result-of-10-20-storable-in-block/2095</link>
          <pubDate>Sun, 07 Jan 2024 06:12:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2095</guid>
          <source url="https://rebol.metaeducation.com/t/why-isnt-logic-e-g-result-of-10-20-storable-in-block/2095.rss">Why Isn&#39;t LOGIC (e.g. result of 10 &gt; 20) Storable in BLOCK! ?</source>
        </item>
        <item>
          <title>Why Have Both BLOCK! and GROUP!</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>Maybe this is a stupid question, but here’s something I’ve been wondering about Rebol: since quoting exists, block!s feel a bit redundant. Something like <code>[a b c]</code> could just as easily be represented as <code>the (a b c)</code>. So, why do both exist?</p>
<p>Or, to put it another way, it feels like Rebol has two orthogonal concepts:</p>
<ul>
<li>Grouping: you can take a bunch of symbols and parenthesize them to get a group!</li>
<li>Quoting: you can take a value and quote it to prevent evaluation</li>
</ul>
<p>So it makes sense that you can combine these: <code>the (a b c)</code>. Except that Rebol doesn’t seem to take advantage of this fact at all — rather, it goes the opposite route, by creating a new data structure which conflates aspects of both of these.</p>
            <p><small>9 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/why-have-both-block-and-group/2092">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/why-have-both-block-and-group/2092</link>
          <pubDate>Fri, 05 Jan 2024 07:25:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2092</guid>
          <source url="https://rebol.metaeducation.com/t/why-have-both-block-and-group/2092.rss">Why Have Both BLOCK! and GROUP!</source>
        </item>
        <item>
          <title>Why quote/unquote if lift/unlift are a superset?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="bradrn" data-post="5" data-topic="2088">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/bradrn-brad/2088/5">bradrn (Brad)</a></div>
<blockquote>
<p>why do <strong><code>quote</code></strong> and <strong><code>unquote</code></strong> exist when <strong><code>lift</code></strong> and <strong><code>unlift</code></strong> can do the same thing, while handling more cases?</p>
</blockquote>
</aside>
<p>Sanity check.</p>
<p>Antiforms are weird, and creating them (or tolerating them) when you didn't mean to is good to avoid.</p>
<p>Unstable antiforms are particularly weird...for instance antiform BLOCK! cannot be stored in variables.  In normal assignments it decays to its first element, while multi-assignments and other particular constructs interpret it as multiple values:</p>
<pre><code>&gt;&gt; quasiform: '~['1020 ~null~]~
== ~['1020 ~null~]~

&gt;&gt; x: unlift quasiform
== 1020

&gt;&gt; [x y]: unlift quasiform
== 1020

&gt;&gt; y
== \~null~\  ; antiform
</code></pre>
<p>This is how multi-return functions are implemented.</p>
<p>What's nice about UNQUOTE vs UNLIFT is that if you are really not suspecting you're dealing with a quasiform that should become an antiform, you can avoid the potential confusion caused.</p>
<p>And QUOTE has a similar convenience of not tolerating an antiform when you didn't think there'd be one.</p>
<p>A narrower operator of QUASI and UNQUASI exists to make it clear when you're only adding or removing a quasi state.  So you can QUASI only plain non-quoted things, and UNQUASI only non-quoted quasiforms.  Then NOQUASI will pass through all values except drop the quasi from quasiforms.</p>
<p>Just helps readers get their bearings on what's going on if that's all that's happening.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/why-quote-unquote-if-lift-unlift-are-a-superset/2450">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/why-quote-unquote-if-lift-unlift-are-a-superset/2450</link>
          <pubDate>Fri, 05 Jan 2024 05:33:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2450</guid>
          <source url="https://rebol.metaeducation.com/t/why-quote-unquote-if-lift-unlift-are-a-superset/2450.rss">Why quote/unquote if lift/unlift are a superset?</source>
        </item>
        <item>
          <title>Why can&#39;t you PROTECT individual cells in an array?</title>
          <dc:creator><![CDATA[rebolbot]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>You can PROTECT a variable:</p>
<pre><code>&gt;&gt; x: 10

&gt;&gt; protect $x

&gt;&gt; x: 20
** Access Error: variable x locked by PROTECT (see UNPROTECT)
</code></pre>
<p>And you can PROTECT an array pointed to by a variable:</p>
<pre><code>&gt;&gt; array: [&lt;a&gt; b #c]

&gt;&gt; protect array

&gt;&gt; append array ["d"]
** Access Error: series read-only due to PROTECT (see UNPROTECT)

&gt;&gt; array: [&lt;q&gt; r #s]  ; variable holding array not protected

&gt;&gt; array
== [&lt;q&gt; r #s]
</code></pre>
<p>...but you can't PROTECT a cell resident inside an array:</p>
<pre><code>&gt;&gt; array: [&lt;a&gt; b #c]

&gt;&gt; protect $array.2  ; this doesn't work

&gt;&gt; array.2: "z"
; you'd expect an error here if it did work

&gt;&gt; array.3: 1020
; you'd expect no error here if it did work
</code></pre>
<p>Looking at the source, there are flags related to protection that can apply to individual cells...</p>
<p>...but R3-Alpha didn't have the feature, and Ren-C hasn't added it.  Why?</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/why-cant-you-protect-individual-cells-in-an-array/2062">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/why-cant-you-protect-individual-cells-in-an-array/2062</link>
          <pubDate>Tue, 21 Nov 2023 22:52:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2062</guid>
          <source url="https://rebol.metaeducation.com/t/why-cant-you-protect-individual-cells-in-an-array/2062.rss">Why can&#39;t you PROTECT individual cells in an array?</source>
        </item>
        <item>
          <title>What Are NULL, VOID, and TRASH?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>These are three important "antiforms" you need to know about.  (Antiforms can be held in variables, but cannot be put into lists like BLOCK!).</p>
<h3><a name="p-6662-trash-is-the-antiform-of-blank-1" class="anchor" href="https://rebol.metaeducation.com#p-6662-trash-is-the-antiform-of-blank-1"></a>TRASH is the antiform of BLANK!</h3>
<p>Trash is used as the contents of an unset variable:</p>
<pre><code>&gt;&gt; x: ~  ; will unset the variable

&gt;&gt; unset? $x  ; in the modern world ('x) makes a word with no binding
== ~okay~  ; anti
</code></pre>
<p>Its meta-representation is a quasiform shown as a lone tilde (<code>~</code>), which you can call "quasi blank" if you like (I also call it a "quasar").  So evaluating quasiform blank gives you antiform blank, e.g. TRASH, <a href="https://rebol.metaeducation.com/t/console-treatment-of-void-vs-trash/2045">which has no representation in the console</a>.</p>
<pre><code>&gt;&gt; quasi _
== ~

&gt;&gt; quasar? first [~]
== ~okay~  ; anti

&gt;&gt; ~

&gt;&gt; trash? ~
== ~okay~  ; anti
</code></pre>
<p>For reasons that are a bit beyond the scope of this post, TRASH cannot be passed as a "normal" parameter to a function.  It represents the state of a parameter being unfulfilled in a FRAME!.</p>
<pre><code>&gt;&gt; make frame! append/
== #[frame! [
    series: ~
    value: ~
]]
</code></pre>
<p>This aligns with some of what Carl wrote about in <a href="http://www.rebol.net/r3blogs/0318.html">UNSET! is not first class</a>, and among the implications are that operations like comparison functions do not accept unset states... as in Rebol2:</p>
<pre><code>rebol2&gt;&gt; #[unset!] = 1
** Script Error: Cannot use equal? on unset! value

ren-c&gt;&gt; ~ = 1
** Error: VALUE1 argument of EQUAL? is unspecified
</code></pre>
<h3><a name="p-6662-void-is-the-unstable-antiform-of-an-empty-block-pack-2" class="anchor" href="https://rebol.metaeducation.com#p-6662-void-is-the-unstable-antiform-of-an-empty-block-pack-2"></a>VOID is the unstable antiform of an empty BLOCK! (PACK!)</h3>
<p>VOID vanishes in REDUCE and acts as a no-op for things like APPEND.  It is the result of <strong><code>eval []</code></strong> and vaporizes in COMPOSE/etc.</p>
<pre><code>&gt;&gt; void
== ~[]~  ; anti

&gt;&gt; compose [a (if 10 &gt; 20 ['b] else []) c]
== [a c]

&gt;&gt; reduce [1 + 2, if 10 &gt; 20 [&lt;nothing&gt;] else [], 10 + 20]
== [3 30]

&gt;&gt; append [a b c] void
== [a b c]

&gt;&gt; if 10 &gt; 20 ['b] else []
== ~[]~  ; anti
</code></pre>
<p><a href="https://rebol.metaeducation.com/t/why-do-any-and-all-ignore-void-when-if-errors-on-it/2040">VOID will opt out of ANY and ALL</a>.  But because of this, an isolated conditional like IF can't make a logically consistent decision about it being a "branch trigger" or "branch inhibitor", it gives back an error:</p>
<pre><code>&gt;&gt; if 10 &gt; 20 [&lt;foo&gt;] else []
== ~[]~  ; anti

&gt;&gt; any [if 10 &gt; 20 [&lt;foo&gt;] else [], 10 + 20]
== 30

&gt;&gt; all [10 + 20, if 10 &gt; 20 [&lt;foo&gt;] else []]
== 30

&gt;&gt; if (if 10 &gt; 20 [&lt;foo&gt;] else []) [20]
** Error: ~[]~ antiform cannot be used in isolated conditional expressions
</code></pre>
<h3><a name="p-6662-null-is-the-antiform-of-the-word-null-3" class="anchor" href="https://rebol.metaeducation.com#p-6662-null-is-the-antiform-of-the-word-null-3"></a>NULL is the antiform of the WORD! "null".</h3>
<p>In the API this is represented as the 0 pointer and does not require having its handle released, so it is like C's NULL.  It is used as an "ornery nothing"...but unlike TRASH it doesn't indicate an unset variable, so it can be fetched by normal WORD! access.  The system accomplishes elegant error locality using the <a href="https://rebol.metaeducation.com/t/the-void-in-null-out-protocol/1880">VOID-in-NULL-out protocol</a> in many places, which hinges on the MAYBE function that converts NULL to void.</p>
<pre><code>&gt;&gt; case [1 &gt; 2 [&lt;a&gt;] 10 &gt; 20 [&lt;b&gt;]]]
== ~null~  ; anti

&gt;&gt; reduce [1 + 2 case [1 &gt; 2 [&lt;a&gt;] 10 &gt; 20 [&lt;b&gt;]]] 10 + 20]
** Error: can't put ~null~ antiforms in blocks

&gt;&gt; reduce [1 + 2 maybe case [1 &gt; 2 [&lt;a&gt;] 10 &gt; 20 [&lt;b&gt;]]] 10 + 20]
== [3 30]

&gt;&gt; third [d e]
** Script Error: cannot pick 3

&gt;&gt; try third [d e]
== ~null~  ; anti

&gt;&gt; append [a b c] try third [d e]
** Error: Cannot put ~null~ antiforms in blocks

&gt;&gt; compose [all your base (try third [d e]) are belong to us]
** Error: Cannot COMPOSE ~null~ antiforms into slots

&gt;&gt; maybe third [d e]
== ~[]~  ; anti

&gt;&gt; append [a b c] maybe third [d e]
== [a b c]
</code></pre>
<h2><a name="p-6662-to-sum-up-4" class="anchor" href="https://rebol.metaeducation.com#p-6662-to-sum-up-4"></a>To Sum Up...</h2>
<ul>
<li>
<p>TRASH is the contents of an unset variable</p>
<ul>
<li>
<p>It is neither logically true nor false</p>
</li>
<li>
<p>When you reference a variable containing trash using WORD!, it will cause an error</p>
</li>
<li>
<p>It's the typical choice of return value for functions with no meaningful result</p>
</li>
<li>
<p><a href="https://rebol.metaeducation.com/t/console-treatment-of-void-vs-trash/2045">The console displays nothing when trash is the evaluative product</a></p>
</li>
</ul>
</li>
<li>
<p>VOID is intentional emptiness--tolerated many places as meaning "I'd like to opt out please"</p>
<ul>
<li>Since it opts out of aggregate conditional tests, it can't logically be acted on in an isolated conditional expression like IF</li>
</ul>
</li>
<li>
<p>NULL is a signal, often meaning "I couldn't find what you were looking for"</p>
<ul>
<li>
<p>Because it is a kind of "soft failure", it is the (only) conditionally false value</p>
</li>
<li>
<p>Also because it is a soft failure, <strong>most non-conditional slots reject it as an argument</strong></p>
</li>
<li>
<p>MAYBE can be used tactically to convert NULL results to VOID</p>
</li>
</ul>
</li>
</ul>
<p>NULL and TRASH can be held in variables or API handles, but won't be found in lists like BLOCK!.</p>
<p>VOID is an unstable antiform, and can't be saved in variables--only meta-represented.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/what-are-null-void-and-trash/2283">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/what-are-null-void-and-trash/2283</link>
          <pubDate>Thu, 27 Jul 2023 02:36:52 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2283</guid>
          <source url="https://rebol.metaeducation.com/t/what-are-null-void-and-trash/2283.rss">What Are NULL, VOID, and TRASH?</source>
        </item>
        <item>
          <title>Why do ANY and ALL ignore VOID, when IF errors on it?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>The evolution of "invisibility" in Ren-C gave rise to two "vaporizing intents" <a href="https://rebol.metaeducation.com/t/invisibility-reviewed-through-modern-eyes/2034">the VOID and GHOST antiforms</a>.</p>
<p>The default evaluator (and UPARSE) accept that void is an "opt-out state" that can't be put in blocks.  But they don't vaporize VOID on a whim: it will still be the result of expressions whose last result is a void.</p>
<pre><code>&gt;&gt; 1 + 2 void
== ~[]~  ; anti
</code></pre>
<p>On the other hand, the antiform comma of GHOST truly vaporizes unless you pipe it around with ^META:</p>
<pre><code>&gt;&gt; 1 + 2 ghost
== 3
</code></pre>
<p>This means it's up to constructs to decide if they want to erase voids or not.  DELIMIT does, so you will see that reflected in things like UNSPACED.</p>
<p>Here's a few ways of making voids:</p>
<pre><code>&gt;&gt; unspaced ["A" (if 1 &gt; 2 ["B"] else [void]) "C"]
== "AC"

&gt;&gt; unspaced ["A" (if 1 &gt; 2 ["B"] else []) "C"]
== "AC"

&gt;&gt; unspaced ["A" (opt if 1 &gt; 2 ["B"]) "C"]
== "AC"

&gt;&gt; unspaced ["A" (? if 1 &gt; 2 ["B"]) "C"]
== "AC"

&gt;&gt; unspaced ["A" (when 1 &gt; 2 ["B"]) "C"]
== "AC"
</code></pre>
<p>COMPOSE vaporizes void slots (and errors on null ones).  <a href="https://rebol.metaeducation.com/t/vaporizing-failed-conditionals-in-reduce/1665">REDUCE is currently vaporizing VOID</a> because it seems like the default people want.</p>
<h2><a name="p-6643-but-what-should-any-and-all-do-1" class="anchor" href="https://rebol.metaeducation.com#p-6643-but-what-should-any-and-all-do-1"></a>But What Should ANY and ALL Do?</h2>
<p>We can consider that VOID is neither truthy nor falsey, and IF will reject it:</p>
<pre><code>&gt;&gt; if (if false [true]) [&lt;unreachable&gt;]
** Error: IF doesn't accept VOID as its condition argument
</code></pre>
<p>When there was no VOID/GHOST distinction, then ANY and ALL were backed into a corner.  If they decided to error on void, you couldn't use an ELIDE or ASSERT in the middle of them.  If they didn't error on VOID then the risk was that you could write something like <strong><code>all [1 = 1, 2 = 2, while [...] [...]]</code></strong> and if the while was just incidentally void you'd get the 2 = 2 result, which may not have been your intent.</p>
<p>Today, things like ELIDE and ASSERT return GHOST and can be safely vaporized by ANY and ALL.  This would seem to open up the choice to be consistent with IF, in erroring on voids as being neither true nor false.</p>
<p>One might suggest that if you really want to erase voids...you'd have something that converted voids to ghosts (call it ELIDE-IF-VOID, or VANISH, or whatever)</p>
<pre><code>&gt;&gt; all [1 = 1, 2 = 2, some-void-expr]
** Error: SOME-VOID-EXPR is VOID which is neither truthy nor falsey

&gt;&gt; all [1 = 1, 2 = 2, elide-if-void some-void-expr]
== ~okay~  ; anti
</code></pre>
<h2><a name="p-6643-things-like-for-bothhttpsrebolmetaeducationcomtdemonstrating-for-both-loop-composability-for-the-win1833-would-get-more-awkward-2" class="anchor" href="https://rebol.metaeducation.com#p-6643-things-like-for-bothhttpsrebolmetaeducationcomtdemonstrating-for-both-loop-composability-for-the-win1833-would-get-more-awkward-2"></a>Things Like <a href="https://rebol.metaeducation.com/t/demonstrating-for-both-loop-composability-for-the-win/1833">FOR-BOTH</a> Would Get More Awkward...</h2>
<p>I was fairly proud of this formulation:</p>
<pre><code>for-both: func [var blk1 blk2 body] [
    return unlift:lite all [
        lift:lite for-each var blk1 body
        lift:lite for-each var blk2 body
    ]
]
</code></pre>
<p>(I wound up deciding that LIFT would lift everything--including pure null and void--so the LITE was probably best included as the alternative formulation.)</p>
<p>But if ALL and ANY errored on void, and you had to erase it, this would become:</p>
<pre><code>for-both: func [var blk1 blk2 body] [
    return unlift:lite all [
        elide-if-void lift:lite for-each var blk1 body
        elide-if-void lift:lite for-each var blk2 body
    ]
]
</code></pre>
<p>If I put on my formalism hat, I can see how this is <em>safer</em>.  But I've made similar arguments about why I don't want this:</p>
<pre><code>&gt;&gt; compose [a (if 1 &gt; 2 ['b] else []) c]
** Error: COMPOSE cannot erase VOID (use ELIDE-IF-VOID if intentional)

&gt;&gt; compose [a (elide-if-void if 1 &gt; 2 ['b] else []) c]
== [a c]
</code></pre>
<p>It is admittedly a bit different in ANY and ALL's case, because they're mixing in a test for truthiness.  But erasing voids by default has other advantages in writing wild control constructs.</p>
<h2><a name="p-6643-erroring-when-you-dont-have-to-inhibits-creativity-3" class="anchor" href="https://rebol.metaeducation.com#p-6643-erroring-when-you-dont-have-to-inhibits-creativity-3"></a>Erroring When You Don't Have To Inhibits Creativity</h2>
<p><strong>When all things are mostly equal, safety isn't as compelling as enabling creativity in my current view of the language.</strong></p>
<p>I haven't seen any bad consequences of vaporizing the voids.  Yet the conveniences have been proven.</p>
<p>So that's the decision that has been made.  If you want to make a version of ANY and ALL that error on voids, you can do so with a :PREDICATE.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/why-do-any-and-all-ignore-void-when-if-errors-on-it/2040">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/why-do-any-and-all-ignore-void-when-if-errors-on-it/2040</link>
          <pubDate>Thu, 29 Jun 2023 02:09:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2040</guid>
          <source url="https://rebol.metaeducation.com/t/why-do-any-and-all-ignore-void-when-if-errors-on-it/2040.rss">Why do ANY and ALL ignore VOID, when IF errors on it?</source>
        </item>
        <item>
          <title>Why Aren&#39;t THROW and CATCH Used For Errors?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>While many languages speak of "throwing" and "catching" errors, this isn't how Rebol uses the terms.</p>
<p>Instead, it's a generic way to move values up the stack.  It gives you a handy "out" from control flow:</p>
<pre><code>result: catch [
    if condition [throw result]
    some code
    case [
        condition [more code]
        condition [more code, throw result]
    ]
    additional code
    throw result
]
</code></pre>
<p>The implementation of the feature is lightweight, and built on the same mechanic as RETURN.  You could in fact use RETURN to do the same thing:</p>
<pre><code>result: eval func [] [
    if condition [return result]
    some code
    case [
        condition [return code]
        condition [more code, return result]
    ]
    additional code
    return result
]
</code></pre>
<p><strong>You can, if you like, THROW an ERROR! antiform, and CATCH it.</strong>  But that's just because you can throw anything.  Packs are fine, too:</p>
<pre><code>&gt;&gt; [a b]: catch [
       case [
           1 = 2 [throw pack [10 20]]
           1 = 1 [throw pack [100 200]]
       ]
   ]
== 100

&gt;&gt; a
== 100

&gt;&gt; b 
== 200
</code></pre>
<p>So it's really about throwing whatever you like--not specific to errors or error handling.</p>
<p>THROW and CATCH are a great lightweight feature for control flow, that people really should be using more often than they do.  <em>(Ren-C uses "definitional throw", which means there's no risk of you calling a routine that would accidentally catch a throw that wasn't meant for it--which is quite important!)</em></p>
<h2><a name="p-6360-exceptions-use-panicrescue-1" class="anchor" href="https://rebol.metaeducation.com#p-6360-exceptions-use-panicrescue-1"></a>Exceptions use PANIC+RESCUE</h2>
<p>Generally speaking, <a href="https://rebol.metaeducation.com/t/discouraging-the-interception-of-abrupt-failures/1871">it's not a good idea to react to exceptions</a> <em>(unless you are something like the CONSOLE, where all you are doing is reporting that the exception happened.)</em></p>
<p>An error antiform will decay to an exception if it isn't triaged.  But you can also cause an exception using PANIC.</p>
<p><em>(Fun tidbit: PANIC is implemented by making an error antiform and then not triaging it before passing it on.  Right now it passes it to NULL?, which doesn't use a meta-aware parameter convention so it forces decay to an exception.  <strong><code>panic: cascade [fail/ null?/]</code></strong>)</em></p>
<p>To help emphasize that you should generally not be reaching for the RESCUE routine to recover from abrupt failures, it lives in <strong>sys.util</strong>.</p>
<pre><code> &gt;&gt; sys.util/rescue [
       foo: func [argument] [
           return argment + 20  ; whoops, typo
       ]
       foo 1000
    ]
== make warning! [
    type: 'Script
    id: 'unassigned-attach
    message: '[:arg1 "word is attached to a context, but unassigned"]
    near: '[
        return argment ** + 20]
    where: '[foo enrescue eval rescue eval catch* enrescue eval rescue console]
    file: ~null~
    line: 2
    arg1: 'argment
]
</code></pre>
<p>Hopefully it's clear to anyone--upon light reflection--why thinking you can handle exceptions is generally misguided!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/why-arent-throw-and-catch-used-for-errors/1954">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/why-arent-throw-and-catch-used-for-errors/1954</link>
          <pubDate>Thu, 01 Sep 2022 11:50:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1954</guid>
          <source url="https://rebol.metaeducation.com/t/why-arent-throw-and-catch-used-for-errors/1954.rss">Why Aren&#39;t THROW and CATCH Used For Errors?</source>
        </item>
        <item>
          <title>Why Don&#39;t Splices Preserve Their List Type?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>The first concept of representing splices out of isotopes was actually to make them as antiform BLOCK!.</p>
<p>You'd get an antiform block regardless of the input to SPREAD:</p>
<pre><code>&gt;&gt; spread [d e]
== ~[d e]~  ; anti

&gt;&gt; spread '(d e)
== ~[d e]~  ; anti

&gt;&gt; spread @[d e]
== ~[d e]~  ; anti
</code></pre>
<p>From the perspective of things like APPEND, it doesn't matter:</p>
<pre><code>&gt;&gt; append [a b c] spread [d e]
== [a b c d e]

&gt;&gt; append [a b c] spread '(d e)
== [a b c d e]

&gt;&gt; append [a b c] spread @[d e]
== [a b c d e]
</code></pre>
<h2><a name="p-6358-canonization-of-splices-is-important-1" class="anchor" href="https://rebol.metaeducation.com#p-6358-canonization-of-splices-is-important-1"></a>Canonization of Splices Is Important</h2>
<p>By canonizing splices to just one type, we recover the other list antiforms for other meanings that have nothing to do with splicing.  That subtlety would be lost if people had to think of every list type as being a splice.</p>
<p>It also helps you realize information is being thrown away.  Not only is the subclass of list forgotten, but any binding is removed too (!)</p>
<p>But which canon list form should it take?</p>
<h2><a name="p-6358-group-seems-the-best-choice-2" class="anchor" href="https://rebol.metaeducation.com#p-6358-group-seems-the-best-choice-2"></a>GROUP! Seems The Best Choice</h2>
<ul>
<li>
<p><strong>It makes the canonization more obvious.</strong>  Since the input to SPREAD will typically be a BLOCK!, people will learn the type is not preserved quickly:</p>
<pre><code>&gt;&gt; spread [a b c]
== ~(a b c)~  ; anti
</code></pre>
</li>
<li>
<p><strong>Parentheses look softer and more permeable.</strong>  They already are "weaker" in that they do not "block" evaluation in the way a BLOCK! does.  So their softness makes it feel more reasonable to say that the edges aren't there.</p>
<p><em>(This semiotic permeability exists in other places where brackets and parentheses are juxtaposed... for instance in <a href="https://en.wikipedia.org/wiki/Interval_(mathematics)#Notations_for_intervals">interval notation</a>, where <strong>[10, 20)</strong> means "the numbers from 10 to 20 without including 20")</em></p>
</li>
</ul>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/why-dont-splices-preserve-their-list-type/1953">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/why-dont-splices-preserve-their-list-type/1953</link>
          <pubDate>Wed, 31 Aug 2022 21:11:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1953</guid>
          <source url="https://rebol.metaeducation.com/t/why-dont-splices-preserve-their-list-type/1953.rss">Why Don&#39;t Splices Preserve Their List Type?</source>
        </item>
        <item>
          <title>My Summary of the Big Picture</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>I wrote this to someone in a GitHub issue and thought it was pretty salient:</p>
<blockquote>
<p>What has drawn people to Rebol historically has varied. But a large number who praised it and used it were less interested in the language itself, rather the properties of the executable. It was small, and you could run on any OS without installing anything else...it came with a GUI built in.</p>
<p>But when serious language theorists look at Rebol, they notice it is riddled with design holes. The language itself wasn't <em>composable</em> the way one might like languages to be: mixing constructs in new ways that weren't specifically accounted for never worked. It was more like a "scriptable app" that had a few features that pleased its userbase...and had to be extended by the designer every time a new need came up.</p>
<p>So put briefly: If you don't understand what these holes are, then you won't appreciate the many issues that Ren-C is trying to solve.</p>
<p>Once you know that historical Rebol was fundamentally broken, there are basically 3 choices:</p>
<ol>
<li>Inventory and address the holes one at a time and try to fix or mitigate them</li>
<li>Ignore the holes and just hope that if you add enough features and integration no one will notice</li>
<li>Turn away and run from the crackpots using it, and work with a more solidly designed language</li>
</ol>
<p>(1) is Ren-C's hard-chosen path. Energy is spent on identifying certain patterns in source that users <em>must</em> be able to write and have work, if the language is to justify its existence at all. While it would be nice if stack traces were beautiful and if building the sources was 100% easy, all of that would be meaningless if the punch line was <em>"oh, and the language this is all supporting doesn't actually work"</em></p>
<p>(2) is chosen by people like Red and <a href="https://github.com/Oldes/Rebol3">Oldes's branch of R3-Alpha</a>, as well as some clones that have popped up over the years. Starting from scratch inevitably makes the same mistakes.</p>
<p>(3) is probably the most sensible choice, but if I didn't think there was some promise in the language I wouldn't be pursuing (1).</p>
</blockquote>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/my-summary-of-the-big-picture/1792">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/my-summary-of-the-big-picture/1792</link>
          <pubDate>Fri, 18 Feb 2022 19:37:40 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1792</guid>
          <source url="https://rebol.metaeducation.com/t/my-summary-of-the-big-picture/1792.rss">My Summary of the Big Picture</source>
        </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Philosophy - AltRebol</title>
    <link>https://rebol.metaeducation.com/c/usage/philosophy/31</link>
    <description>Topics in the &#39;Philosophy&#39; category How does Rebol differ from other computer languages and what makes code Rebolish and functional vs procedural coding.</description>
    
      <lastBuildDate>Tue, 06 May 2025 12:32:12 +0000</lastBuildDate>
      <atom:link href="https://rebol.metaeducation.com/c/usage/philosophy/31.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>On Quickness (Italo Calvino)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>I cite this short passage by <strong><a href="https://en.wikipedia.org/wiki/Italo_Calvino">Italo Calvino</a></strong> fairly often:</p>
<blockquote>
<p><em>Among Chuang-tzuâ€™s many skills, he was an expert draftsman.</em></p>
<p><em>The Chinese emperor asked Chuang-tzu to draw a crab.</em></p>
<p><em>Chuang-tzu replied that he would need five years plus a country estate and 12 servants.</em></p>
<p><em>The emperor gave him what he requested.</em></p>
<p><em>Five years later, Chuang-tzu still had not started on the drawing.</em></p>
<p><em>"I need another five years", Chuang-tzu said to the emperor.</em></p>
<p><em>The emperor granted them.</em></p>
<p><em>After 10 years, Chuang-tzu took up his brush and in a single stroke drew a crab, the most perfect crab ever seen.</em></p>
</blockquote>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/crab.png?v=14" title=":crab:" class="emoji only-emoji" alt=":crab:" loading="lazy" width="20" height="20"></p>
<p>It may not seem like an exact analogy for Ren-C's development, in the sense that there's lots of incremental steps which are "visible"...to the very few people looking.  But I think to most, the true profound nature of its design will seem like it came out of nowhere, while it's the result of an epic amount of pondering.</p>
<p>I'm of the belief that my resistance to push or publish something that's not fully formed has been an asset.  And I'm of the belief that it's going to blow people's minds.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/on-quickness-italo-calvino/2436">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/on-quickness-italo-calvino/2436</link>
          <pubDate>Tue, 06 May 2025 12:32:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2436</guid>
          <source url="https://rebol.metaeducation.com/t/on-quickness-italo-calvino/2436.rss">On Quickness (Italo Calvino)</source>
        </item>
        <item>
          <title>The Grand Leading-Slash &quot;Safety, or Burden?&quot; Question</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Overall, I have been tremendously happy with how the ideas of the <strong><a href="https://rebol.metaeducation.com/t/big-alien-proposal-word-runs-functions/1905">Big Alien Proposal</a></strong> have worked out.</p>
<p>That started from the concept that when slashes appear, they either come <em>before</em> a function they run, or <em>after</em> a function they suppress execution for.</p>
<pre><code>foo.bar
; ^-- foo is an entity from which BAR is being selected.  BAR is not
; allowed to be an antiform frame, so this syntax cannot invoke a
; function call (though it can invoke an 'accessor', e.g. a "getter"
; which is 0-arity).

foo/bar
; ^-- foo is an entity from which BAR (an a FRAME! or antiform FRAME!)
; is being selected and then invoked.  This will generate an error if
; bar is not a frame or antiform frame.

foo.bar/
; ^-- bar is a field which is an antiform FRAME!, whose execution is
; being suppressed.  This expression will return an antiform frame, or
; an error if not an antiform frame.

foo
; ^-- conventional WORD! reference, will run an antiform frame as an
; action invocation or fetch other values as-is

/foo
; ^-- invocation reference, will run an antiform frame (or plain frame)
; as an action invocation and give errors on other types

foo/
; ^-- action suppression, will give you back an antiform frame as-is
; and error on other types.
</code></pre>
<p><em>(If you're curious about why <strong><code>/foo</code></strong> will run plain FRAME! as well as antiform, while <strong><code>foo/</code></strong> will not return an antiform frame for plain FRAME!, this is based on the idea that it's better to be conservative when fetching values so that you won't get surprised by getting a plain frame back from <strong><code>foo/</code>~</strong> which gives everything back as-is.)</em></p>
<hr>
<p>I've written elsewhere <a href="https://rebol.metaeducation.com/t/trailing-slash-is-a-winner-for-defused-actions/2327">how pleased I am that the way you suppress a function's execution is by throwing up a "barrier"</a> with a separating slash that makes it clear arguments are not being gathered at the callsite.  That's really slick.</p>
<p>For this idea to work, something else had to be used for refinements.  That meant <a href="https://rebol.metaeducation.com/t/introducingnew-chain-datatype/2226">invention of the CHAIN! datatype</a> has opened a lot of interesting doors, and I find it's quite learnable to see things like <strong><code>trim:auto:tail</code></strong> instead of <strong><code>trim/auto/tail</code></strong>.</p>
<p><em>I actually prefer it!</em>  What some might think of a disadvantage of being "less noticeable" turns into an advantage... <strong><code>trim:auto</code></strong> really could have been a function called <strong><code>trim-auto</code></strong> just as easily.  Why would you want a slash to make the fact that it has a refinement "pop"?  The slashes to make function calls or suppression pop are much better applied.</p>
<p><strong>So that's all good. <img src="https://rebol.metaeducation.com/images/emoji/twitter/smile_cat.png?v=14" title=":smile_cat:" class="emoji" alt=":smile_cat:" loading="lazy" width="20" height="20"> No regrets!</strong></p>
<h2><a name="p-7975-but-leading-slash-for-functions-rule-hasnt-100-geld-1" class="anchor" href="https://rebol.metaeducation.com#p-7975-but-leading-slash-for-functions-rule-hasnt-100-geld-1"></a>But... Leading-Slash For Functions Rule Hasn't 100% Gel'd</h2>
<p>Another part of the proposal was that in order to get tighter control on what was a function or not, you would be required to assign functions using a leading-slash kind of SET-WORD!.</p>
<pre><code>&gt;&gt; foo: func [a b] [return a + b]
** Error: FOO: can't be used to assign antiform FRAME!, use /FOO:

&gt;&gt; /foo: func [a b] [return a + b]
== ~#[frame! "foo" [a b]]]~  ; anti
</code></pre>
<p><strong>It hasn't fully settled with me after working with it for some time.</strong></p>
<p>As I mentioned above, colons for refinements was easy to adapt to...and now that I'm adapted, I prefer it.</p>
<p>But I'm still typing <strong><code>test: cascade [add/ even?/]</code></strong>.  I love the trailing slashes (and this will be even better when the whole cascade can be done with just <strong><code>even?/add/</code></strong>).  But I'm kind of cursing under my breath the thought of having typed <strong><code>test:</code></strong> and having to backspace over it so it says <strong><code>/test:</code></strong>.  And then I go "hrmph."</p>
<p>When I'm reading code, I probably appreciate it more than I find it to be "messy".  It gives you a better compass.  The eye can scan and comprehend much better... it's of particular value when you're not using an obvious function generator like FUNC, but something else.  This cues readers to go "oh, I guess that's a function generator".</p>
<p>Yet still... it's a burden in a way the other changes are not.  It's the only change that increases the character count.</p>
<h2><a name="p-7975-whats-at-stake-by-not-enforcing-this-2" class="anchor" href="https://rebol.metaeducation.com#p-7975-whats-at-stake-by-not-enforcing-this-2"></a>What's At Stake By Not Enforcing This?</h2>
<p>Ren-C has a powerful story about how antiforms can't be put in blocks, which means you can write this kind of code and it "just works":</p>
<pre><code>block2: collect [
    for-each 'item block1 [keep item]
]

assert [equal? block1 block2]
</code></pre>
<p>When you compare it to Rebol2/R3-Alpha/Red, it's one of those vastly superior situations.  You aren't getting tricked into receiving an ITEM in the FOR-EACH that would generate an unset variable error, or conflate with the state that gets returned when an item can't be picked from a block, or accidentally run a function.  It's a solid solution.</p>
<p>But that's only for blocks.  What about other places, like objects?</p>
<p>If we don't put barriers on how action antiforms get assigned to variables, we get the problem all over again:</p>
<pre><code>for-each [key value] obj [
    if integer? value [  ; oops, what if VALUE is an action antiform!
        print "Found an integer"
    ]
]
</code></pre>
<p>There's no way in this case to say "variables can't hold antiforms".  Logic is an antiform.  Words holding antiform frames are actions.</p>
<p>Getting this under control with slashes is the kind of thing I've been trying to do for a long time, I've just never had the syntax.  Leading slashes felt like it could be the key:</p>
<pre><code>for-each [key value] obj [...]  ; value can't be frame antiform

for-each [key /value] obj [...]  ; value must be frame antiform

for-each [key ~/value] obj [...]  ; value may be frame antiform
</code></pre>
<p>But if these rules are applied everywhere, what you have to do gets more complex:</p>
<pre><code>set $x does [print "Is this an error?"]

set $/x does [print "Do you have to do this?"]

&gt;&gt; var: $x
== x  ; bound

set var does [print "If this errors, how to make VAR into bound /x?"]

set:active var does [print "Do you use refinements?"] (or just SET:ANY ?)
</code></pre>
<p>Nothing is free.  And the already more complicated world where <strong><code>x:</code></strong> is a CHAIN! instead of a fundamental different type of word has its own issues, that these all pile on top of.</p>
<h2><a name="p-7975-theres-likely-not-enough-value-in-optional-slash-3" class="anchor" href="https://rebol.metaeducation.com#p-7975-theres-likely-not-enough-value-in-optional-slash-3"></a>There's Likely Not Enough Value In Optional Slash</h2>
<p>If <strong><code>/foo: func [...] [...]</code></strong> will enforce that the thing you're assigning is an antiform action, but <strong><code>foo: func [...] [...]</code></strong> still works... I have a feeling that the complexity it takes to offer the feature doesn't give a sufficient payoff to be worth it.</p>
<p>You have everyone paying the tax of dealing with complicated path structures and bookkeeping--vs. being able to just SET and GET words and tuples at will... and then you're not even giving any additional guarantees in the source.</p>
<p>This makes me feel like it really is an all-in or not-at-all situation.</p>
<h2><a name="p-7975-long-story-short-im-still-weighing-it-4" class="anchor" href="https://rebol.metaeducation.com#p-7975-long-story-short-im-still-weighing-it-4"></a>Long Story Short: I'm Still Weighing It</h2>
<p>I'm not ready to make a verdict.</p>
<p>The techniques for working with these new CHAIN! and PATH! situations are still being learned.  Most of my hesitance isn't from the looks or typing an extra character, but from frustrations in that...and maybe that frustration will lessen as I work on it more.</p>
            <p><small>7 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/the-grand-leading-slash-safety-or-burden-question/2352">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/the-grand-leading-slash-safety-or-burden-question/2352</link>
          <pubDate>Thu, 19 Dec 2024 01:12:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2352</guid>
          <source url="https://rebol.metaeducation.com/t/the-grand-leading-slash-safety-or-burden-question/2352.rss">The Grand Leading-Slash &quot;Safety, or Burden?&quot; Question</source>
        </item>
        <item>
          <title>What To Do About Horrible, Grievous, Unicode</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>At some point <a href="https://github.com/red/red/blob/master/tests/source/units/series-test.red#L1413C2-L1417C39">I picked up a test from Red</a>, which is basically this:</p>
<pre><code>str: " ^(A0) ^-a b  ^- c  ^(2000) "
assert ["a b  ^- c" = trim copy str]
</code></pre>
<p>That's some funny business.</p>
<ul>
<li>
<p>The hex character ^(a0) is decimal 160, which is the standard Unicode translation for <code>&amp;nbsp;</code>... non-breaking space.</p>
</li>
<li>
<p>The hex character ^(2000) is "EN QUAD".. <a href="https://en.wikipedia.org/wiki/Quad_(typography)">a space that is one <em>en</em> wide: half the width of an em quad.</a></p>
</li>
</ul>
<p>R3-Alpha (and Ren-C) never had support for trimming these characters out.  So the test fails.</p>
<p>But it wound up flying under the radar, somehow.</p>
<p><em>(I think I didn't actually pick up the file it was in to the tests until some time after adding it.  And by the time I added it, a lot of things were breaking due to binding and I was putting off fixing everything until it was time.  Now it's that time--I'm going item by item reviewing breakages and getting the tests in order.)</em></p>
<p>But when I got to this one, the log just said:</p>
<pre><code>(   
    str: "   ^-a b  ^- c    "
    "a b  ^- c" = trim copy str
) "failed, test returned null"
</code></pre>
<p>Because I didn't go look up the test (I thought I had it right there)...I didn't realize there was funny business because the display doesn't give you any indication.  Neither does Red's after the transcode:</p>
<pre><code>red&gt;&gt; " ^(A0) ^-a b  ^- c  ^(2000) "
== "   ^-a b  ^- c    "
</code></pre>
<p>Even pasting it into VS Code (which I didn't, until just now) gives you <em>terribly weak</em> feedback that something weird is going on:</p>
<p><img src="https://rebol.metaeducation.com/uploads/default/original/1X/fcb694d9fa08aa3be6b625b1529de82cf9e2ecef.png" alt="image" data-base62-sha1="A3Bv5No7U3eVyTqLu28KCsYccXl" width="393" height="59"></p>
<p>Gee.  Glad I had "show invisibles" turned on--that <em>really</em> did a lot for me there.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/roll_eyes.png?v=14" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></p>
<p><em>(Seriously, what is the point of that feature if that's what it's going to do?)</em></p>
<h2><a name="p-7679-i-dont-want-this-stuff-in-source-files-1" class="anchor" href="https://rebol.metaeducation.com#p-7679-i-dont-want-this-stuff-in-source-files-1"></a>I Don't Want This Stuff In Source Files</h2>
<p>We can't fix the world.  They're doing what they are doing.  This stuff is the currency of text and you have to support it.</p>
<p>But we can set house rules.  The default mode for Ren-C should only allow two invisible characters in source: space and newline.  (And I'd like there to not be space at the end of lines.)  This would be a hard rule for any script in official repositories.</p>
<p>I'd have saved myself an hour of confused digging if there'd been an error when I pasted in the console, telling me I was dealing with a messed-up situation.  There'd have to be some conscious shift into a mode to tolerate it... temporarily as some kind of way to import a string into the system.</p>
<h2><a name="p-7679-not-ready-to-support-this-test-2" class="anchor" href="https://rebol.metaeducation.com#p-7679-not-ready-to-support-this-test-2"></a>Not Ready To Support This Test</h2>
<p>There's a <a href="https://rebol.metaeducation.com/t/roaring-bitset-s/1327">sparse bitset implementation</a> that has been on the shelf, but that's needed before we create unicode charsets for high codepoints.</p>
<p>Anyway, there are higher priorities.  But I definitely do feel like there should be some alarms going off when you are reading files with disruptive codepoints.  You should have to say "Yes, I want ugly codepoints" or "Yes, I want emoji".</p>
<p>A totally permissive TO TEXT! operator shouldn't be what people are reaching for.  You should have to be explicit.  <strong><code>(decode [@utf-8, whitespace: all, emoji: all] blob)</code></strong>.  Principle of least privilege... conservative defaults.</p>
<p>The names for the specializations should help guide behavior.  <strong><code>(decode @utf8-unchecked blob)</code></strong>.  (Unnatural?)</p>
<ul>
<li>"What does that mean, unchecked (looks up documentation)"</li>
<li>"Oh, I have an option to have it screen out weird whitespace?  Wow!  Great! "</li>
</ul>
<p>Something like <strong><code>utf8-basic</code></strong> would make conservative choices--the same ones used by default for source code.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/what-to-do-about-horrible-grievous-unicode/2280">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/what-to-do-about-horrible-grievous-unicode/2280</link>
          <pubDate>Sun, 15 Sep 2024 13:38:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2280</guid>
          <source url="https://rebol.metaeducation.com/t/what-to-do-about-horrible-grievous-unicode/2280.rss">What To Do About Horrible, Grievous, Unicode</source>
        </item>
        <item>
          <title>Quasiforms Aren&#39;t Super Friendly (and they shouldn&#39;t be)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>The original intent of quasiforms was that they were a bit "bad".</p>
<p>Things like <strong><code>~null~</code></strong> were actually originally called BAD-WORD!s.  (I kind of miss that slightly amusing term.)</p>
<p>So indeed, an aspect of the term "quasi" was that the squiggles would make you <em>uncomfortable</em>... perhaps a bit <em>queasy</em>... <img src="https://rebol.metaeducation.com/images/emoji/twitter/nauseated_face.png?v=14" title=":nauseated_face:" class="emoji" alt=":nauseated_face:" loading="lazy" width="20" height="20"> ...and they would call attention to themselves.</p>
<h2><a name="p-7656-they-are-disruptive-by-design-1" class="anchor" href="https://rebol.metaeducation.com#p-7656-they-are-disruptive-by-design-1"></a>They Are Disruptive By Design</h2>
<p>Consider code like this:</p>
<pre><code>&gt;&gt; stuff: [[a b] ~[c d]~ (e f)]

&gt;&gt; list: second stuff

&gt;&gt; for-each item list [probe item]
** Script Error: for-each expects
     [~void~ blank! any-series? any-context? map! any-sequence? action?]
   for its data argument
</code></pre>
<p>It's not super typical to want to enumerate quasiform lists.  But it does come up...and when it does, it may <em>seem</em> kind of annoying that you have to say things like <strong><code>for-each item unquasi list</code></strong></p>
<h2><a name="p-7656-its-for-the-best-2" class="anchor" href="https://rebol.metaeducation.com#p-7656-its-for-the-best-2"></a>It's For The Best</h2>
<p>We <em>want</em> code that isn't specifically written to expect quasiforms to trip up on them, <strong>because the odds are pretty good that they are proxies for antiform intent</strong>.</p>
<p>And I'd really discourage usage of quasiforms anywhere that they're not being used for something intended to be fundamentally disruptive.  As I wrote in describing <strong><a href="https://rebol.metaeducation.com/t/synthetic-asymmetric-delimiters/1893">Synthetic Asymmetric Delimiters</a></strong>, you have other choices.</p>
<p>Don't pick quasiforms in your dialect just because "they look cool".  Pick them <em>because you want to create a speedbump.</em></p>
<p>So the number of things you can do with quasiforms will remain intentionally limited.  Expect errors when you pass them to anything that's not strictly structural (like APPEND, FIND, etc.)</p>
<pre><code>&gt;&gt; to word! 'null
== null

&gt;&gt; to word! '~null~
** Script Error: expected &amp;[word] not &amp;[quasiform]

&gt;&gt; unquasi '~null~
== null
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/quasiforms-arent-super-friendly-and-they-shouldnt-be/2273">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/quasiforms-arent-super-friendly-and-they-shouldnt-be/2273</link>
          <pubDate>Fri, 13 Sep 2024 02:47:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2273</guid>
          <source url="https://rebol.metaeducation.com/t/quasiforms-arent-super-friendly-and-they-shouldnt-be/2273.rss">Quasiforms Aren&#39;t Super Friendly (and they shouldn&#39;t be)</source>
        </item>
        <item>
          <title>Meta-Representability in Ren-C (Isotopic Theory)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p><em>I wrote this to try and give some context to an AI before asking it a naming question.  For a less high-level treatment, see <strong><a href="https://rebol.metaeducation.com/t/a-justification-of-generalized-isotopes/1918">A Justification of Generalized Isotopes</a></strong>.</em></p>
<hr>
<p>Most imperative programming languages do not delve into the relationships between things like null and trash... as if they were mathematical, and you were going to discover that if you take the square root of undefined you get null, etc.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/slight_smile.png?v=14" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20">  But I am doing something analogous to that.</p>
<p>In particular, I'm making it possible to push variables which may contain states like undefined and null "upwards" representationally, to where whatever they are holding becomes "Lifted".</p>
<pre><code>&gt;&gt; var
** Error: var is trash

&gt;&gt; var: lift get:any $var  ; set var to "lifted var"
== ~

&gt;&gt; var  ; no error on access
== ~

&gt;&gt; var: lift var  ; again, no error
== '~

&gt;&gt; var
== '~

&gt;&gt; var: lift var  ; again, no error
== ''~
</code></pre>
<p>If something is a special form (like trash or null) the first LIFT step will use tildes to indicate it has been raised to a "quasiform".  Quasiforms do not cause errors when accessed from variables, and can be put into "reified" contexts like arrays.  Then every LIFT step after that adds a level of quoting, indicated by an apostrophe.</p>
<p>UNLIFT reverses this process, ultimately getting back to the special form which cannot be put in arrays and--in the case of "trash"--causes errors on access.</p>
<pre><code>&gt;&gt; var: unlift first ['~]
== ~

&gt;&gt; var
== ~

&gt;&gt; var: unlift var  ; result is trash, shows nothing in the console

&gt;&gt; var
** Error: var is trash
</code></pre>
<p>If something didn't start out as a special form, then it will just get quoting levels added by apostrophes:</p>
<pre><code>&gt;&gt; var
== 10

&gt;&gt; var: lift var
== '10

&gt;&gt; var: lift var
== ''10
</code></pre>
<p>So what this lets people do is kind of work generically and persist special states of interest to them in lifted form, multiplexed alongside things that had been conventional values.</p>
<p>The special states are called "antiforms".  And they aren't just things like NULL and TRASH, but also <a href="https://rebol.metaeducation.com/t/the-void-in-null-out-protocol/1880">VOID</a>... <a href="https://rebol.metaeducation.com/t/thought-reimplementing-multi-return-via-isotopic-block/1955">multi-return packs</a>, <a href="https://rebol.metaeducation.com/t/fail-vs-return-raise-the-new-age-of-definitional-errors/1852">raised errors</a>, <a href="https://rebol.metaeducation.com/t/the-long-awaited-death-of-only/1607">splice representations</a>...</p>
<p>To a newcomer, the merits or applications may not be obvious.  But this model gives phenomenal expressive power.  And I definitely do think of it as being like the "higher mathematics" of Rebol.</p>
<hr>
<p><a href="https://www.youtube.com/watch?v=B1J6Ou4q8vE&amp;t=209">Animation vs. Math</a></p>

            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/meta-representability-in-ren-c-isotopic-theory/2217">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/meta-representability-in-ren-c-isotopic-theory/2217</link>
          <pubDate>Sat, 24 Aug 2024 18:38:40 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2217</guid>
          <source url="https://rebol.metaeducation.com/t/meta-representability-in-ren-c-isotopic-theory/2217.rss">Meta-Representability in Ren-C (Isotopic Theory)</source>
        </item>
        <item>
          <title>Trust the User&#39;s Judgment... *When You Can*</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>When writing about <a href="https://rebol.metaeducation.com/t/set-word-to-initialize-locals-in-function-specs/2210">whether we should have SET-WORD! for initializing locals in function specs</a>, I talked about whether to enforce the right hand side of the SET-WORD! being a GROUP! for safety:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2210">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/set-word-to-initialize-locals-in-function-specs/2210/1">SET-WORD! To Initialize Locals In Function Specs?</a></div>
<blockquote>
<p>If plain words are being picked up as locals there's potential for error if you accidentally wrote an expression that didn't work, like:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">func [
   arg [integer!]
   &lt;local&gt;
   local1 local2
   local3: arity-2-but-I-think-it's-3 a b c
   local4: 10
][
    ...
]
</code></pre>
<p>That could wind up making a local <strong><code>c</code></strong> that you didn't intend. But then again, sometimes it would be just a very obvious simple initialization, like <strong><code>local4: 10</code></strong>. Forcing people to use parentheses could do more harm than good, vs. trusting them to use the parentheses if they feel it's warranted.</p>
</blockquote>
</aside>
<p>I realized this kind of dove to the heart of Rebol philosophy:</p>
<p><strong>If you need to evaluate an expression multiple times, it has to be in an array.  But if you're doing an evaluation just once, trust the user to formulate the expression and use an array if they deem it necessary.</strong></p>
<p>Most people encounter this first with the difference between IF and WHILE.</p>
<p>Certainly IF <em>could</em> take its condition in a BLOCK!.  But it doesn't.  You can mess up:</p>
<p>In Rebol2:</p>
<pre><code>block: [a b]
data: [c]

if 3 = length? append block [
   print "Appending data to block gave us 3 elements"
]

stuff: [a b c]
</code></pre>
<p>You run the code and you get no output, because you forgot to say <strong>append block data</strong>.  So what did you get instead?</p>
<pre><code>&gt;&gt; block
== [a b
    print "Appending data to block gave us 3 elements"
]
</code></pre>
<p>What you thought was a branch got appended.  And the branch actually wound up being the block from the next expression (SET-WORD!s evaluate to what they are assigned).</p>
<p><em>(As it so happens in Ren-C, it catches this...due to <a href="https://rebol.metaeducation.com/t/soft-quoted-branching-light-elegant-fast/1020">soft-quoted branching</a>.  Since it quotes its branch slot, it saw a SET-WORD! in the position, and it doesn't allow things like WORD! or SET-WORD! there.  If we didn't already have enough reasons to appreciate soft quoted branching, there's one more!)</em></p>
<h2><a name="p-7368-should-it-have-required-a-block-for-the-condition-1" class="anchor" href="https://rebol.metaeducation.com#p-7368-should-it-have-required-a-block-for-the-condition-1"></a>Should It Have Required a Block For The Condition?</h2>
<p><strong>The answer for the Rebol Core is: No.</strong>  The goal is to trust the user to make that call.</p>
<p>If you think the expression you're writing is too risky to get right, you should use a GROUP! or break it into subexpressions or otherwise rethink your code so it's not risky.  Being able to cook up a DSL in ten minutes that solves patterns you find useful is the tool you use when you find yourself making code that's at risk of mistakes.</p>
<p><strong>The answer for You is: Your Choice.</strong>  If you find you're making lots of mistakes and want to set a policy that IF always takes a BLOCK! condition, suit yourself.  IF is yours, just like everything.  Redefine it.  It's about <a href="https://rebol.metaeducation.com/t/back-to-personal-computing/186">putting the personal back into personal computing.</a></p>
<h2><a name="p-7368-well-then-why-use-a-block-for-whiles-condition-2" class="anchor" href="https://rebol.metaeducation.com#p-7368-well-then-why-use-a-block-for-whiles-condition-2"></a>Well Then Why Use A BLOCK! For WHILE's Condition?</h2>
<p>Because there wasn't another choice.</p>
<p>You can't tell how long an expression is going to be just by looking at it.  You have to evaluate it.</p>
<p>The condition in a WHILE needs to be evaluated more than once.  So it's taken as a BLOCK!.</p>
<h2><a name="p-7368-this-is-one-of-the-big-ideas-3" class="anchor" href="https://rebol.metaeducation.com#p-7368-this-is-one-of-the-big-ideas-3"></a>This Is One of The "Big Ideas"</h2>
<p>Whether you see it as a big idea or just kind of gonzo programming, is up to you.</p>
<p>With the state of software being how it is, I think we need the occasional Flower Sermon.</p>
<p><strong><a href="https://en.wikipedia.org/wiki/Flower_Sermon">https://en.wikipedia.org/wiki/Flower_Sermon</a></strong></p>
<p>Ren-C has <a href="https://rebol.metaeducation.com/t/the-language-worlds-weirdest-comma-mechanic/1387">thrown in another big tool here, with COMMA!</a>.  Giving you yet more choice.</p>
<p>Yet EVAL and PARSE still let you write your streams of consciousness, giving the code a written-English like fluidity, of mostly words and spaces...which we are naturally good at working with.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/trust-the-users-judgment-when-you-can/2211">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/trust-the-users-judgment-when-you-can/2211</link>
          <pubDate>Sat, 24 Aug 2024 03:44:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2211</guid>
          <source url="https://rebol.metaeducation.com/t/trust-the-users-judgment-when-you-can/2211.rss">Trust the User&#39;s Judgment... *When You Can*</source>
        </item>
        <item>
          <title>MAKE Should Be Using *Dialected Constructors*</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1591">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/debunking-the-arity-1-make/1591/1">Debunking the Arity-1 MAKE</a></div>
<blockquote>
<p>No one really uses the "polymorphism" of <strong>make some-type some-definition</strong> without really knowing what type or definition is, right? That seems essentially meaningless.</p>
</blockquote>
</aside>
<p>In thinking more about "what is MAKE", I feel like it is fundamentally a constructor.</p>
<hr>
<p>When you think about Rebol's value proposition vs. other languages, what's the key idea?</p>
<p><strong>DIALECTS.</strong>  The freeform Jazz of programming.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/saxophone.png?v=14" title=":saxophone:" class="emoji" alt=":saxophone:" loading="lazy" width="20" height="20"></p>
<hr>
<p>So what should be the differentiating factor about constructors in Rebol vs. other languages?</p>
<p><strong>CONSTRUCTOR DIALECTS.</strong> <img src="https://rebol.metaeducation.com/images/emoji/twitter/saxophone.png?v=14" title=":saxophone:" class="emoji" alt=":saxophone:" loading="lazy" width="20" height="20"> <img src="https://rebol.metaeducation.com/images/emoji/twitter/guitar.png?v=14" title=":guitar:" class="emoji" alt=":guitar:" loading="lazy" width="20" height="20"> <img src="https://rebol.metaeducation.com/images/emoji/twitter/drum.png?v=14" title=":drum:" class="emoji" alt=":drum:" loading="lazy" width="20" height="20"> <img src="https://rebol.metaeducation.com/images/emoji/twitter/musical_keyboard.png?v=14" title=":musical_keyboard:" class="emoji" alt=":musical_keyboard:" loading="lazy" width="20" height="20"></p>
<hr>
<p>When I say <strong><code>make my-type! [...]</code></strong> then what goes in that BLOCK! needs to be delegated to MY-TYPE! in some way to allow it the freedom to interpret the hell out of that block.</p>
<p>And it shouldn't only be allowed to be a BLOCK! full of madness.  Consistent with history where you can write things like <strong><code>(make block! 10)</code></strong> to preallocate a size, you should be able to pass anything you want.</p>
<pre><code>make my-type! 'some-word

make my-type! /some-refinement

make my-type! ${...}  ; gimme a bound FENCE!

make my-type! @[...]  ; special meaning if "inert" block received?
</code></pre>
<hr>
<h3><a name="p-7330-history-has-ridiculously-underformed-the-potential-1" class="anchor" href="https://rebol.metaeducation.com#p-7330-history-has-ridiculously-underformed-the-potential-1"></a>History Has Ridiculously Underformed The Potential</h3>
<p>When you look at the TO/MAKE Matrix, it's full of meaningless choices:</p>
<pre><code>rebol2&gt;&gt; make block! [a b c]
== [a b c]
</code></pre>
<p>Huh?  What the hell use is that.  Is it a copy?  Is it a deep copy?  <em><a href="https://www.youtube.com/watch?v=U80ebi4AKgs">Where's the beef?</a></em></p>
<p>Why isn't the constructor for block a literate landscape, subsuming the functionality of <a href="http://www.rebol.com/docs/words/warray.html">ARRAY</a> (a terrible name for a verb) and much more?</p>
<pre><code>&gt;&gt; make block! [4/8 initial: '*]
== [* * * *]  ; length 4, capacity 8, initialize elements with *

&gt;&gt; make block! /8
== []  ; just capacity 8

&gt;&gt; make block! 4
== [~ ~ ~ ~]  ; default to TRASH
</code></pre>
<p>There's an answer here that "dialect design is hard", and it's scary to put a dialect in the core.  But there's decades of experience at this point.  And maybe even ways for people to do their own rewrites and transformations so they don't have to use a <strong><code>make-block</code></strong> function but can customize <strong><code>make block!</code></strong> itself.</p>
<hr>
<h3><a name="p-7330-ren-c-has-opened-up-the-skies-and-will-do-more-2" class="anchor" href="https://rebol.metaeducation.com#p-7330-ren-c-has-opened-up-the-skies-and-will-do-more-2"></a>Ren-C Has Opened Up The Skies, and Will Do More</h3>
<p>I was musing on the behavior of FENCE! in the interpreter and thought, what if it wasn't narrowly defined as being OBJECT! related.  <em>What if it was MAKE-related, with an object-generating default?</em></p>
<pre><code>&gt;&gt; {x: 10, y: 20}
== #[object! x: 10 y: 20]

&gt;&gt; {[block!] 4/8 initial: '*}  ; maybe leading block means MAKE that?
== [* * * *]

&gt;&gt; {block! {4/8 initial: '*}}  ; maybe nesting FENCE! does it?
== [* * * *]

&gt;&gt; {block! 4/8 initial: '*}  ; maybe starting with WORD! is enough?
== [* * * *]

&gt;&gt; {group!}  ; synonym for -&gt; copy '() ?
== ()
</code></pre>
<p>It's a half-baked thought, and I don't know what the ideal syntax is.  But I feel like this could make FENCE! so much more.</p>
<hr>
<h2><a name="p-7330-so-coming-soon-the-great-make-purge-3" class="anchor" href="https://rebol.metaeducation.com#p-7330-so-coming-soon-the-great-make-purge-3"></a>So Coming Soon: The Great MAKE Purge.</h2>
<p>In the combinatoric TO/MAKE matrix, there is a ton of garbage.</p>
<p>I've previously suggested that TO should not do any evaluation (e.g. be binding agnostic on what it gets in).  I think that remains a good idea, that it be purely mechanical.  <a href="https://rebol.metaeducation.com/t/hacking-away-on-the-to-and-make-matrix/649">I had some other ideas that are lingering.</a></p>
<p>I think it's time to further cull the "MAKE for the sake of thinking everything you pass needs to do something, even if it's trivial."  I've been wiping out some of the garbage, but more is needed.</p>
<p>And we have to find a way to give users the ability to hook MAKE on their objects... such that something like <strong><code>make point-3D! [...]</code></strong> isn't locked into a trivial extension syntax of SET-WORD! and value, but truly able to do interesting things.</p>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/make-should-be-using-dialected-constructors/2196">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/make-should-be-using-dialected-constructors/2196</link>
          <pubDate>Tue, 20 Aug 2024 05:41:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2196</guid>
          <source url="https://rebol.metaeducation.com/t/make-should-be-using-dialected-constructors/2196.rss">MAKE Should Be Using *Dialected Constructors*</source>
        </item>
        <item>
          <title>The Robustness Principle Is Not Robust</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Something floating around that I've pretty much always hated--but experience has made me hate more--is the "Robustness Principle":</p>
<aside class="onebox wikipedia" data-onebox-src="https://en.wikipedia.org/wiki/Robustness_principle">
  <header class="source">

      <a href="https://en.wikipedia.org/wiki/Robustness_principle" target="_blank" rel="noopener">en.wikipedia.org</a>
  </header>

  <article class="onebox-body">
    

<h3><a href="https://en.wikipedia.org/wiki/Robustness_principle" target="_blank" rel="noopener">Robustness principle</a></h3>

<p>In computing, the robustness principle is a design guideline for software that states: "be conservative in what you do, be liberal in what you accept from others". It is often reworded as: "be conservative in what you send, be liberal in what you accept". The principle is also known as Postel's law, after Jon Postel, who used the wording in an early specification of TCP.
 In other words, programs that send messages to other machines (or to other programs on the same machine) should conform comple...</p>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>I understand the motivation.  If you have something that imports to a vector graphics program and not all the Bezier curves have endpoints... then, sure.  Someone is going to appreciate that you were forgiving and they got some kind of maybe-a-bit-broken picture instead of an "Invalid File" error.</p>
<p>Pushing this further to those of us who remember the DOS days: we had those experiences where we accidentally deleted files, but the filesystem didn't delete everything--it just wrote a zero byte on the filename (or somesuch).  Norton Utilities let us catch our mistake and get our file back.  In some ways, a lax and forgiving attitude is a beautiful thing...</p>
<p>This so-called "robustness" cannot (and should not) be subconscious.  It needs to be mitigated with an in-your-face consciousness shift!  <em>(And I think Norton Utilities is an apt example, because if you were firing up that program <a href="https://www.youtube.com/watch?v=RRU3I_o1vLc">you knew you were in the Danger Zone</a>)</em>.</p>
<p>There must be a really jarring speedbump.  When a data file is not fitting the standards, you have to go through a procedure that transforms the broken file to the standard.  You have to be aware that you are dealing with a dirty file.  And the experience of that transformation informs you that the person who gave you the dirty file isn't playing with all their marbles, and you correct them for the next transmission.</p>
<p>Authentic programs should demand a standard form.  And when they aren't getting the standard form they should speak up, march you out the door, and force you to fix your input. "Real programs" should never pretend the byte sequence of bad input is okay--there should only be "Cleanup/Recovery programs" that fix the sequence to write a correct one.  And that recovery program should be terminated before the "Real program" runs.</p>
<hr>
<p>I don't need to rewrite the critiques of the "robustness principle" cited in Wikipedia.  But it is nonsense, and the opposite of robust.  It's a garbage idea, that anyone with a whit of sense regarding security can see right through immediately.</p>
<p>There is a better way: the better way is <em>consciousness</em> about what you are working with, and rejection of any sort of malignant "middleman" acting on your data without you knowing.</p>
<ul>
<li>
<p>"Normalization" you did not ask for is an attack on your information.</p>
</li>
<li>
<p>"Glossing over or fixing invalid sequences" you did not ask for is an attack on your information</p>
</li>
<li>
<p>Anything which makes a simple load of a file and save back of the same file not idempotent is an attack on your information</p>
</li>
</ul>
<p>Perhaps I've become even more religious than Carl in some of these ways.  But I certainly see things won't get better without pushing back.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/the-robustness-principle-is-not-robust/2187">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/the-robustness-principle-is-not-robust/2187</link>
          <pubDate>Thu, 13 Jun 2024 05:45:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2187</guid>
          <source url="https://rebol.metaeducation.com/t/the-robustness-principle-is-not-robust/2187.rss">The Robustness Principle Is Not Robust</source>
        </item>
        <item>
          <title>RE: The Ordering and Priorities of the Ren-C Project</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="5" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/speed-of-uparse/2177/5">Speed of UPARSE</a></div>
<blockquote>
<aside class="quote no-group" data-username="bradrn" data-post="4" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/speed-of-uparse/2177/4">Speed of UPARSE</a></div>
<blockquote>
<p>Iâ€™ll be blunt: this, to me, sounds unusably slow. Beyond the very simplest tasks, I canâ€™t imagine a situation where Iâ€™d deliberately choose to take a 250Ã— performance drop.</p>
</blockquote>
</aside>
<p>This is a first-of-its-kind design. And if you don't understand why I'm building things the way I'm building them, then...to be blunt...there's not much point in me listening to your feedback regarding the order in which I do things.</p>
</blockquote>
</aside>
<p>Remember, I come from well outside the Rebol world. The reason I donâ€™t understand is, to a large extent, because this way of reasoning about code is one Iâ€™ve never seen before in my life. This is the reason Iâ€™m asking so many questions, setting out my opinions, and having these discussions with youâ€¦ precisely so that I can begin to understand why it is that way.</p>
            <p><small>9 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179</link>
          <pubDate>Sat, 06 Apr 2024 19:16:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2179</guid>
          <source url="https://rebol.metaeducation.com/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179.rss">RE: The Ordering and Priorities of the Ren-C Project</source>
        </item>
        <item>
          <title>What deserves to be a datatype?</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="7" data-topic="2159">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/header-dialect-and-multiline-strings/2159/7">Header dialect and multiline strings</a></div>
<blockquote>
<p>(If I may philosophise for a momentâ€¦ I feel thereâ€™s a big, gaping hole in my understanding of how we decide â€˜what Rebol syntax isâ€™, so to speak. Perhaps my caution around sigils and TYPE-BLOCK!s are a manifestation of that hole, as is this. Iâ€™ll make a new thread about it if I can figure out any clearer way to articulate my concerns.)</p>
</blockquote>
</aside>
<p>This is that thread.</p>
<p>Iâ€™ll begin by observing that in Rebol, the complexity of the lexer vs the parser is â€˜reversedâ€™ compared to other programming languages. In Rebol, the actual syntax is highly minimalistic: thereâ€™s only a few constructs which provide explicit grouping, and none provide anything more than a simple list of items. By contrast, the lexer is exceedingly complicated: nearly every datatype has its own literal form, oftentimes more than one.</p>
<p>Language design ends up â€˜reversedâ€™ in a similar way. In most languages, discussion centres around questions like â€˜which new syntactic constructs should we addâ€™. By contrast, Rebol (and especially Ren-C) more often poses the question: â€˜which new datatypes do we want to include, with which literal syntax?â€™.</p>
<p>At the moment, I still feel uncomfortable discussing such questions. I donâ€™t feel that I fully understand the kind of criteria we should consider to know whether a datatype is worth including or not. Or, more concisely, I donâ€™t understand how decide: <strong>what deserves to be a Ren-C datatype?</strong>.</p>
<hr>
<p>One obvious criterion is simply, <em>datatypes representing common types of data</em>. This is why we have things like MONEY! and FILE! and DATE! and so on. Ultimately this stems from Rebolâ€™s heritage as a data-transfer format, but obviously these types are far more broadly useful.</p>
<p>Another obvious criterion is <em>syntax which is important for programming</em>. This gives us GROUP! and GET-WORD! and PATH! and so on. These exist as datatypes ultimately because Rebol is homoiconic, but their presence has suggested a wide range of uses beyond simple programming.</p>
<p>This accounts for most of the types in Ren-C. And, if that were all to it, Iâ€™d have no objections.</p>
<hr>
<p>But, unfortunately, there are some other types, whose presence is explained by neither of those criteria. As Iâ€™ve said previously, the ones which make me feel most uncomfortable are THE-* and TYPE-*. Neither of these represent common types of data that one would want to pass around. And, with the possible exceptions of THE-WORD! and TYPE-BLOCK!, theyâ€™re basically useless in â€˜regularâ€™ programming.</p>
<p>Despite this, <a class="mention" href="https://rebol.metaeducation.com/u/hostilefork">@hostilefork</a> has lobbied pretty hard for both of these. Hopefully it should be clear now why I find this viewpoint confusing. I canâ€™t say the existence of these types is <em>problematic</em>, as such, but I feel this <strong>indicates a gap in my understanding of the language</strong>.</p>
<p>The closest to an explanation Iâ€™ve found is that these types are useful in dialecting. That is, they may not be useful for programming <em>per se</em>, but having the syntax around is useful for constructing new languages. (For instance, using TYPE-WORD!s in PARSE dialect, or THE-WORD!s for module inclusion.) The problem with this is, <a href="https://rebol.metaeducation.com/t/a-proliferation-of-word-s/2147">as weâ€™ve established</a>, that thereâ€™s a huge number of syntaxes which would be â€˜useful in dialectingâ€™: clearly, this is too low a bar for deciding â€˜what deserves to be a datatypeâ€™.</p>
<p>(And, incidentally, this also establishes that weâ€™re quite willing to reject datatypes that donâ€™t seem to be of sufficiently general usage.)</p>
<p>Another argument is simply consistency: other sigils have versions for words, blocks, tuples, etc., so THE-* and TYPE-* should as well. But this doesnâ€™t strike me as particularly convincing â€” thereâ€™s nothing intrinsic in Ren-C which requires sigils to generalise to all possible types. Indeed, weâ€™re quite willing to avoid doing so when it would make no sense. (For instance, we donâ€™t have ISSUE-TEXT!, ISSUE-BINARY!, ISSUE-EMAIL!â€¦ we just have a single textual ISSUE! type, because doing otherwise would be silly.)</p>
<p>So, when all is said and done, we have a set of types which donâ€™t seem to be of general use, and have no convincing reason to exist, but are nonetheless kept in the language. And <strong>I want to know why that is</strong>, because I canâ€™t figure it out.</p>
            <p><small>18 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/what-deserves-to-be-a-datatype/2164">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/what-deserves-to-be-a-datatype/2164</link>
          <pubDate>Tue, 05 Mar 2024 08:20:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2164</guid>
          <source url="https://rebol.metaeducation.com/t/what-deserves-to-be-a-datatype/2164.rss">What deserves to be a datatype?</source>
        </item>
        <item>
          <title>Fundamental distinguishing features of Rebol</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Perhaps foolishly, I offered to give a talk at my local Functional Programming meetup next month. Given my recent interests, Iâ€™m thinking of giving an intro to Rebol and its basic concepts.</p>
<p>So thatâ€™s gotten me thinking: what <em>are</em> the basic concepts of Rebol as a programming paradigm, which distinguish it from all others? Hereâ€™s what Iâ€™ve come up with so far:</p>
<ul>
<li>
<p><strong>Everything is a datatype</strong>: Rebol was built for networking. This means you should be able to take any value, serialise it in a human-readable way, and parse it back into a value. This means a lot of built-in datatypes for useful concepts.</p>
</li>
<li>
<p><strong>Data is code</strong>: Everything starts out its life as data. If you want, you can evaluate it in some way to get a result. Naturally, you can evaluate it using any rules you want, which gives you <strong>dialecting</strong> as a corollary.</p>
<p>(Itâ€™s worth noting that this is the converse of Lispâ€™s famous maxim, â€˜code is dataâ€™.)</p>
</li>
<li>
<p><strong>Binding</strong>: Word values are associated with their storage. This can be arbitrarily manipulated by the programmer, leading to <strong>definitional scoping</strong>.</p>
</li>
<li>
<p>More generally, I might summarise all the above points as natural consequences of <strong>computing with evaluation</strong>: the fundamental operation of Rebol is taking values and extracting some kind of result from them. This necessitates the other points above: a rich set of datatypes to store both the original value and the result, the ability to treat those datatypes as code which can be evaluated, and a way to look up references during the evaluation process.</p>
</li>
</ul>
<p>Does this all seem reasonable? Have I missed anything?</p>
            <p><small>16 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/fundamental-distinguishing-features-of-rebol/2136">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/fundamental-distinguishing-features-of-rebol/2136</link>
          <pubDate>Mon, 29 Jan 2024 12:55:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2136</guid>
          <source url="https://rebol.metaeducation.com/t/fundamental-distinguishing-features-of-rebol/2136.rss">Fundamental distinguishing features of Rebol</source>
        </item>
        <item>
          <title>Usefulness of String Interpolation</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="bradrn" data-post="7" data-topic="1751">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/rebol-and-scopes-well-why-not/1751/7">Rebol And Scopes: Well, Why Not?</a></div>
<blockquote>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1751">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/rebol-and-scopes-well-why-not/1751/1">Rebol And Scopes: Well, Why Not?</a></div>
<blockquote>
<p>Features based on string interpolation are so undeniably useful that once the possibilities are seen, they can't be unseen.</p>
</blockquote>
</aside>
<p>Honestly, Iâ€™m not sure I agree with this. In Haskell, which is my main language, there are packages which implement string interpolationâ€¦ and no-one uses them, because they just arenâ€™t necessary! Itâ€™s no big deal when itâ€™s easier to just concatenate stuff together.</p>
</blockquote>
</aside>
<p>To pick a random example from the build helpers for "CScape" interpolation of some generated C code:</p>
<pre><code>emit --{
    #define ${MAYBE PREFIX}INCLUDE_PARAMS_OF_${NATIVE-NAME} \
        $[Items]; \
        assert(Get_Series_Info(level_-&gt;varlist, HOLD))
}--
</code></pre>
<ul>
<li>
<p>The use of <code>${}</code> (instead of <code>$()</code> or <code>$&lt;&gt;</code>) means that the result of the expression should be <a href="https://github.com/metaeducation/ren-c/blob/815758fb571e88591908dc94f9320581f00d9331/tools/common.r#L37">turned into a valid C identifier name</a>... so dashes are converted to underscores, etc.</p>
</li>
<li>
<p>The use of all capitals in the <code>${}</code> escaping means that the strings generated by the expressions evaluated should be made all uppercase.</p>
</li>
<li>
<p>The use of <code>$[]</code> means that items is an array, and its elements should be printed one line at a time...repeating the boilerplate leading and trailing on each line (in this case an indent on the left, and a semicolon and backslash on the right)</p>
</li>
</ul>
<p>The template looks something like the result:</p>
<pre><code>#define INCLUDE_PARAMS_OF_IF \
    DECLARE_PARAM(1, return); \
    USED(ARG(return)); \
    DECLARE_PARAM(2, condition); \
    DECLARE_PARAM(3, branch); \
    assert(Get_Series_Info(level_-&gt;varlist, HOLD))
</code></pre>
<p>Without interpolation, we fall back on LOAD-able code... where spaces and quotes are required by the language itself.  This starts to lose the ability to keep track of actual spaces in the interpolated thing, plus you keep having to start and stop string delimiters on the string portions.</p>
<p>I'm not quite sure how it would come together dialected via regular code, but it would drift away from looking like C code, at best it might look like:</p>
<pre><code>emit [
    "#define " &lt;c&gt; (MAYBE PREFIX) "INCLUDE_PARAMS_OF_" &lt;c&gt; (NATIVE-NAME) " \"
    "    " @[Items] "; \"
    "    assert(Get_Series_Info(level_-&gt;varlist, HOLD))"
]
</code></pre>
<p><em>I'd be hard-pressed to say the spacing was correct on inspection</em>.  We've lost the intuition about where the unspaced parts are.  You can imagine it getting worse when you're building unspaced material inside a string literal.  Strings can simply be the least noisy medium when you want to see something that looks close to the result.</p>
<p>Anyway, with strings carrying binding, we wouldn't have to do what we do today... which is actually pass the variables (that don't live in LIB) in a block to emit:</p>
<pre><code>emit [prefix native-name items] --{  ; &lt;-- ack
    #define ${MAYBE PREFIX}INCLUDE_PARAMS_OF_${NATIVE-NAME} \
        $[Items]; \
        assert(Get_Series_Info(level_-&gt;varlist, HOLD))
}--
</code></pre>
<p>So I look forward to getting rid of that.</p>
<aside class="quote no-group quote-modified" data-username="bradrn" data-post="7" data-topic="1751">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/rebol-and-scopes-well-why-not/1751/7">Rebol And Scopes: Well, Why Not?</a></div>
<blockquote>
<p>And itâ€™s even easier in Rebol than it is in Haskell, because thereâ€™s already a single built-in function to do everything for you:</p>
<pre><code>&gt;&gt; x: 10 y: "foo"
== "foo"
&gt;&gt; print ajoin ["Scopes? " x " " x " " x " " y " " y " " y]
Scopes? 10 10 10 foo foo foo
&gt;&gt; foo: func [x] [local: 20 ajoin ["The sum is " (x + local)]]
&gt;&gt; foo 30
== "The sum is 50"
</code></pre>
<p>I strongly prefer this approach over string concatenation, since by using sensible data structures it integrates much better with the rest of the language. (It also reduces the risk of errors from malformed strings, and potentially the equivalent of SQL injection attacks.)</p>
</blockquote>
</aside>
<p>Note that <a href="https://rebol.metaeducation.com/t/introducing-delimit/2102">Ren-C has DELIMIT (and UNSPACED, SPACED)</a> instead of AJOIN... which hopefully you'll like even better.</p>
            <p><small>7 posts - 4 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114</link>
          <pubDate>Thu, 11 Jan 2024 01:39:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2114</guid>
          <source url="https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114.rss">Usefulness of String Interpolation</source>
        </item>
        <item>
          <title>How Much Determinism Should Be Pursued?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>While writing tests for the QUERY dialect against some sample files in a directory, it ran into an issue of the order those files were given back.  <em>Operating system APIs generally do not return the list of files in a determined order, and the ordering across filesystems also varies.</em></p>
<p>This means that even with the same files, you could have the lists come back differently.  One OS could say:</p>
<pre><code>Domain-SQL&gt;&gt; select 'name 'date from %tests/file-tests/
    where 'size &gt; 100 and 'date = 26-Jul-2021

1 [%tests/file-tests/Disk50.txt 26-Jul-2021]
2 [%tests/file-tests/11barz99.txt 26-Jul-2021]
3 [%tests/file-tests/Apple3.txt 26-Jul-2021]
4 [%tests/file-tests/Banana1.txt 26-Jul-2021]
5 [%tests/file-tests/BANANA22.txt 26-Jul-2021]
...
</code></pre>
<p>While another would say:</p>
<pre><code>Domain-SQL&gt;&gt; select 'name 'date from %tests/file-tests/
    where 'size &gt; 100 and 'date = 26-Jul-2021

1 [%tests/file-tests/Apple3.txt 26-Jul-2021]
2 [%tests/file-tests/Banana1.txt 26-Jul-2021]
3 [%tests/file-tests/BANANA22.txt 26-Jul-2021]
4 [%tests/file-tests/Disk50.txt 26-Jul-2021]
5 [%tests/file-tests/11barz99.txt 26-Jul-2021]
...
</code></pre>
<p>This made getting reproducible outputs to verify was hard.</p>
<h2><a name="p-6706-i-made-query-use-sortcase-on-the-read-dir-result-1" class="anchor" href="https://rebol.metaeducation.com#p-6706-i-made-query-use-sortcase-on-the-read-dir-result-1"></a>I Made QUERY use SORT/CASE on the READ DIR Result</h2>
<p>Getting determinism in the output meant using a function that guarantees an ordering for filenames:</p>
<pre><code>Domain-SQL&gt;&gt; select 'name 'date from %tests/file-tests/
    where 'size &gt; 100 and 'date = 26-Jul-2021

1 [%tests/file-tests/11barz99.txt 26-Jul-2021]
2 [%tests/file-tests/Apple3.txt 26-Jul-2021]
3 [%tests/file-tests/BANANA22.txt 26-Jul-2021]
4 [%tests/file-tests/Banana1.txt 26-Jul-2021]
5 [%tests/file-tests/Disk50.txt 26-Jul-2021]
...
</code></pre>
<p>Having to pay for the sort adds a little bit of overhead, but it's not that significant.</p>
<h2><a name="p-6706-should-read-dir-be-sorted-by-default-2" class="anchor" href="https://rebol.metaeducation.com#p-6706-should-read-dir-be-sorted-by-default-2"></a>Should READ DIR be Sorted By Default?</h2>
<p>WASI in WebAssembly is looking to chase down sources of non-determinism and see what it can do to stop it.  They mention directory listing order as one potential for problems:</p>
<p><a href="https://github.com/WebAssembly/WASI/issues/190" class="inline-onebox">Roadmap to determinism in WASI Â· Issue #190 Â· WebAssembly/WASI Â· GitHub</a></p>
<p>They seem to believe that on the same OS the directory ordering would be deterministic for the same files, but I don't know of any guarantee of that.</p>
<h2><a name="p-6706-all-this-points-to-bigger-issues-about-reproducibility-3" class="anchor" href="https://rebol.metaeducation.com#p-6706-all-this-points-to-bigger-issues-about-reproducibility-3"></a>All This Points to Bigger Issues About Reproducibility</h2>
<p>We can pick many examples... like whether a MAP! will always enumerate in the same order on different platforms, or with the same contents.  Using a deterministically sorted implementation of map would seem to have a number of advantages.</p>
<p>Especially since there's a growing push in software for giving deterministic outputs by default.  If you want some reasoning, see this article:</p>
<p><a href="https://buttondown.email/nelhage/archive/determinism-in-software-engineering/" class="inline-onebox">Determinism in software engineering â€¢ Buttondown</a></p>
<p>The more testing one does, the more important it seems.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/how-much-determinism-should-be-pursued/2057">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/how-much-determinism-should-be-pursued/2057</link>
          <pubDate>Thu, 19 Oct 2023 19:34:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2057</guid>
          <source url="https://rebol.metaeducation.com/t/how-much-determinism-should-be-pursued/2057.rss">How Much Determinism Should Be Pursued?</source>
        </item>
        <item>
          <title>Jonathan Blow, and Euclid&#39;s Elements</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Jonathan Blow is a video game developer--who made a well known indie game called "Braid" that did some fun time/space manipulations people generally hadn't seen before in a Mario-type platfomer.   Later he took a number of years to make the much higher-budget art piece The Witness...a very intellectual game which has a Sixth-Sense kind of reveal that's quite good.</p>
<p>Though as time changes him from grumpy indie upstart to grumpy-old-man, he has joined the chorus of us grumpy old men when it comes to complexity:</p>
<p><a href="https://www.youtube.com/watch?v=pW-SOdj4Kkk&amp;t=2189">Jonathan Blow - Preventing the Collapse of Civilization (English only)</a></p>

<p>But I'm pretty sure he would pretty much hate Redbol languages for programming his games.  He doesn't like scripting, and thinks it's dumb to use things without static typing or that catch your mistakes in advance.  (And I'm with him when he responds to people who say things like "but you can try changes without restarting" are wrongheaded.  You can compile checked bits of code and reload them dynamically if your system is designed right.)</p>
<p>What he's looking for is something that offers the benefits of C++ and Rust, but minus the things he considers to be annoying.  "Something like Rust, but cutting out anything that would be an impediment to the games that I--Jonathan Blow--would write."</p>
<p><a href="https://github.com/BSVino/JaiPrimer/blob/master/JaiPrimer.md" class="inline-onebox">JaiPrimer/JaiPrimer.md at master Â· BSVino/JaiPrimer Â· GitHub</a></p>
<p>I imagine that if Jonathan <em>were</em> to appreciate something like Ren-C it would be in the way I do--as a game in itself.  (He actually playtested "Baba is You"--according to a YouTube stream of him playing the final version.  When asked what he was paid to give his feedback he just grumbled "not enough".  So I probably won't be sending Ren-C to him.  :-P)</p>
<p>In any case, he was doing a talk on games in education and cited a page from Euclid's Elements that I thought was interesting.  <a href="https://youtu.be/qWFScmtiC44?t=756">The quote he cites says</a>:</p>
<blockquote>
<p><em>"If a first magnitude has to a second the same ratio as a third has to a fourth, and also a fifth has to the second the same ratio as a sixth to a fourth, then the sum of the first and fifth has to the second the same ratio as the sum of the third and sixth has to the fourth."</em></p>
</blockquote>
<p>I'm sure it sounded like nonsense to Euclid's contemporaries, who were not able (or willing) to follow the reasoning for why such things might be important.</p>
<p>When you're reasoning through new abstract things there's lots of phases to it.  Terminology and mechanics evolve over time.  That's how it works, so people shouldn't be surprised to see things like <em><a href="https://rebol.metaeducation.com/t/the-implications-of-meta-producing-quasi-from-isotopes/1967">"The Implications of ^META Producing QUASI! from Isotopes"</a></em>  <img src="https://rebol.metaeducation.com/images/emoji/twitter/slight_smile.png?v=14" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/jonathan-blow-and-euclids-elements/1971">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/jonathan-blow-and-euclids-elements/1971</link>
          <pubDate>Sun, 18 Sep 2022 21:14:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1971</guid>
          <source url="https://rebol.metaeducation.com/t/jonathan-blow-and-euclids-elements/1971.rss">Jonathan Blow, and Euclid&#39;s Elements</source>
        </item>
        <item>
          <title>Rebol&#39;s Mission w.r.t. &quot;not wasting RAM or CPU cycles&quot;</title>
          <dc:creator><![CDATA[WickedSmoke]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Rebol was an attempt at grappling with the problems of overly complex and bloated software.  Part of that means not wasting RAM or CPU cycles.</p>
<p>Optimizing is just a normal part of software development. It's not done to please the programmer, but to build something of quality that respects the user who is running other pieces of software that are also using resources.  Think of it as being a good computational neighbor.</p>
<p>There needs to be some thread here about "computing horror stories". A month ago there was an article on Hacker News about NixOS and it's packaging system.  As some Nix user had just contacted me about packaging xu4, I thought I'd give it a spin.  After downloading the ISO and installing it on a virtual machine I went to get a package listing...<br>
and was greeted with some vague error message.</p>
<p>It turns out that the package manager was using well over 1GB of RAM and simply crapped out because my VM didn't have enough.  Some NixOS user told me:</p>
<blockquote>
<p>"Listing all packages is a bit of a weak spot. The entire package set is described in a lazy, functional language and listing or searching it requires evaluating the entire thing."</p>
</blockquote>
<p>This is an entire OS custom built around a package manager, and it couldn't even give me a listing of my packages.  The Nix developers want to geek out about their language, but I just want tools that work.</p>
<p>Thankfully, data-oriented design is now a thing, so I know at least someone is paying attention.</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/rebols-mission-w-r-t-not-wasting-ram-or-cpu-cycles/1970">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/rebols-mission-w-r-t-not-wasting-ram-or-cpu-cycles/1970</link>
          <pubDate>Sun, 18 Sep 2022 18:19:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1970</guid>
          <source url="https://rebol.metaeducation.com/t/rebols-mission-w-r-t-not-wasting-ram-or-cpu-cycles/1970.rss">Rebol&#39;s Mission w.r.t. &quot;not wasting RAM or CPU cycles&quot;</source>
        </item>
        <item>
          <title>A Justification of Generalized Isotopes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p><em>Here is a train of thought to help people realize why isotopes are needed, and why unifying their behaviors and mechanisms under a common umbrella makes sense.  It starts from the issue of solving /ONLY and then explains the generalization.</em></p>
<p><em>As time permits, I'll come back and try to improve this...</em></p>
<hr>
<p>Historically, Rebol had a problem of how to append blocks "as-is" vs splicing.  This was resolved somewhat unsatisfyingly by splicing blocks by default, and using an <code>/ONLY</code> refinement to append as-is:</p>
<pre><code>rebol2&gt;&gt; append [a b c] [d e]
== [a b c d e]

rebol2&gt;&gt; append/only [a b c] [d e]
== [a b c [d e]]
</code></pre>
<p>Years of fretting over the bad properties of this led to a somewhat inescapable conclusion:</p>
<p><em><strong>It's better to carry the intent of whether a value needs to be spliced on that value...as opposed to having subtle variants of core operations that modulate the splicing.</strong></em></p>
<p>I'd worked up to a point where I was implementing the "mark of intent" by adding a quoting level to <em>suppress</em> splicing.  Yet this faced likely accidents when someone had a quoted value in a variable...and really meant to use it somewhere as-is, with the quote--vs. thinking of the quote as a splice-suppression signal which the operation should remove.</p>
<p>Then <a href="https://rebol.metaeducation.com/t/putting-splicing-intent-on-appended-value/1873/9">@rgchris made this remark</a>:</p>
<aside class="quote no-group quote-modified" data-username="rgchris" data-post="9" data-topic="1873" data-full="true">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/1873/9">On another topic</a></div>
<blockquote>
<p>The issue I have with doing the opposite of ONLYâ€”let's call it SPREADâ€”is what is the interim value?</p>
<pre><code>&gt;&gt; block: [a b c [a b c]]

&gt;&gt; find block pick block 4
[[a b c]]

&gt;&gt; find block spread pick block 4
[a b c [a b c]]

&gt;&gt; spread pick block 4
???
</code></pre>
<p>It would seem to have virtue over ONLY and is a better word.</p>
</blockquote>
</aside>
<h2><a name="p-6250-if-trying-this-in-historical-redbol-what-might-one-do-1" class="anchor" href="https://rebol.metaeducation.com#p-6250-if-trying-this-in-historical-redbol-what-might-one-do-1"></a>If Trying This In Historical Redbol, What Might One Do?</h2>
<p>As a rough first cut, let's represent splices with a specially recognizable 2-element wrapper block.  We'll signal it's a splice with a series in the first slot--checking for the unique identity of that series.  Then put the block itself as the second element:</p>
<pre><code>splice-cue: "!!!splice!!!"

spread: func [block [block!]] [
    return reduce [splice-cue block]
]

splice?: func [value] [
    if not block? :value [return false]
    return same? splice-cue first value
]
</code></pre>
<p>Then we can write our new versions of things like APPEND that are specifically aware of this construct.</p>
<pre><code>append*: func [series [series!] value] [
    return either splice? :value [
        append series second value
    ][
        append/only series :value
    ]
 ]
</code></pre>
<p>It works more or less in your average Redbol, e.g. in Red:</p>
<pre><code>red&gt;&gt; append* [a b c] spread [d e]
== [a b c d e]

red&gt;&gt; append* [a b c] [d e]
== [a b c [d e]]

red&gt;&gt; append* [a b c] 'd
== [a b c d]

red&gt;&gt; append* [a b c] first ['d]
== [a b c 'd]
</code></pre>
<p><em>In fact, this is essentially how the bootstrap executable for Ren-C simulates the SPREAD behavior.</em></p>
<p>But the weaknesses are <em>immediately</em> apparent!!!  <img src="https://rebol.metaeducation.com/images/emoji/twitter/pouting_cat.png?v=14" title=":pouting_cat:" class="emoji" alt=":pouting_cat:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-6250-not-a-distinct-type-too-easy-to-overlook-handling-2" class="anchor" href="https://rebol.metaeducation.com#p-6250-not-a-distinct-type-too-easy-to-overlook-handling-2"></a>Not A Distinct Type: Too Easy To Overlook Handling</h2>
<p>There's no special type for the spliced block...it's just a BLOCK!.  This means any routine that hasn't been written to handle it, will just let it leak through.</p>
<pre><code>red&gt;&gt; reduce [spread [a b c] [a b c]]
== [["!!!splice!!!" [a b c]] [a b c]]  ; not [a b c [a b c]]
</code></pre>
<p>Changing to some other generic type that can contain a block...such as an OBJECT!...doesn't help matters.  You are kind of in trouble any time an operation willfully lets you put these into an array.</p>
<p><strong>The first instinct might be to introduce a new SPLICE! datatype, with a system-wide rule that splices can't be put into arrays.</strong>  <em>(Enforcing such a rule across all array-manipulating code is challenging...so let's sort of make a note of that fact, but continue.)</em></p>
<p>Because of the peculiar nature of not being able to be put in a block, there'd have to be a decision made about function arguments as to whether or not they took this type.  Many functions designed to handle generic values would not be able to handle them, so there'd presumably need to be some typeset like ANY-NOTSPLICE! or ANY-NORMAL!.</p>
<h2><a name="p-6250-how-to-represent-a-type-that-cant-be-put-in-a-block-3" class="anchor" href="https://rebol.metaeducation.com#p-6250-how-to-represent-a-type-that-cant-be-put-in-a-block-3"></a>How To Represent A Type That Can't Be Put In A Block?</h2>
<p>Now we've got several things to ponder about our new type.  For instance: what you should see here?</p>
<pre><code>&gt;&gt; obj: make object! [foo: spread [d e]]
== make object! [
    foo: ???
]
</code></pre>
<p>We just said that a defining feature of SPLICE! is that you can't accidentally put them in blocks.  But the argument to MAKE OBJECT!, namely <strong><code>[foo: ???]</code></strong>, is a block.  If <code>???</code> can't itself be a splice!, then what is it?</p>
<p>This brings up a possibly-related question: what if you want a way to put the intent of whether to splice or not into "suspended animation?"... in a way that you could collect it?</p>
<p>Here's a sort of contrived example of the puzzle:</p>
<pre><code>generate: func [n [integer!]] [
   if even? n [return reduce [n n + 1]]
   return spread reduce [n n + 1]
]

lift: func [
    return: [...]
    in [splice! block!]
][
    ...
]

unlift: func [
    return: [splice! block!]
    wrapped [...]
][
    ...
]

n: 0
pending: collect [while [n &lt; 4] [keep lift generate n]]

data: copy []
for-each item pending [append data unlift item]
</code></pre>
<p>How would you write LIFT and UNLIFT such that at the end of the code above, you'd get:</p>
<pre><code>&gt;&gt; data
== [[0 1] 1 2 [2 3] 3 4]
</code></pre>
<p>If the system didn't provide some answer to this, you'd end up needing to re-invent something kind of equivalent to the primitive <code>["!!!splice!!!" [...]]</code> mechanic as a means of persistence:</p>
<pre><code>&gt;&gt; pending
== [[0 1] ["!!!splice!!!" [1 2]] [2 3] ["!!!splice!!!" [3 4]]]
</code></pre>
<h1><a name="p-6250-isotopes-were-designed-for-this-4" class="anchor" href="https://rebol.metaeducation.com#p-6250-isotopes-were-designed-for-this-4"></a>Isotopes Were Designed For This!</h1>
<p>Isotopes are a set of curated answers for these problems.  Originally they were introduced to address issues like what an UNSET! was...which has some of the same class of problems as SPLICE! (such as not wanting to be put in BLOCK!s, and not accepted by default or by most routines).</p>
<p>Isotopes introduce two new variants of datatypes called <em>antiforms</em> and <em>quasiforms</em>.  Antiforms cannot be put in blocks.</p>
<p>Isotopes are:</p>
<ul>
<li>
<p><strong>general</strong> - <em>most</em> base value types (e.g. unquoted things with no sigils) can <strong>potentially</strong> have antiforms and quasiforms</p>
<ul>
<li><em>(Note: While the -mechanics- are generalized, we restrict the creation of antiforms for states that do not have meaning yet.  For example: antiform INTEGER! has no meaning today, but an interesting meaning might come up... so until one does, we don't let you make them.  See the <strong><a href="https://rebol.metaeducation.com/t/which-antiforms-are-in-use/2276">Table of Antiforms in Use</a></strong> for the current state of affairs.)</em></li>
</ul>
</li>
<li>
<p><strong>efficient</strong> - antiforms and quasiforms do not require allocations, and merely are a different state of a byte in the value cell (the same byte that encodes quoting levels)</p>
</li>
<li>
<p><strong>"meta-representable"</strong> - all antiforms can be produced by evaluating their quasiforms, and quasiforms can be produced by evaluating quoted quasiforms.</p>
</li>
</ul>
<p>I mentioned at the outset that it would be somewhat costly to bulletproof all of native code against the ability to do something like append a specific data type like "SPLICE!" to a block.  But with isotopes this problem has been solved once for all the forms...so the same code that prevents a so-called "UNSET!" from winding up in arrays works for splices.  <em>That's because a splice is actually a group! antiform, and an unset variables actually hold BLANK! antiforms!</em></p>
<p>Above I asked:</p>
<blockquote>
<p>What you should see here?</p>
<pre><code>&gt;&gt; obj: make object! [foo: spread [d e]]
== make object! [
    foo: ???
]
</code></pre>
</blockquote>
<p>Isotopes give us the answer, that it's <strong><code>foo: ~(d e)~</code></strong>.  This is the previously mentioned "QUASIFORM!" of GROUP!, which when evaluated produces an antiform of GROUP!...which by convention represents a splice.</p>
<p><em>But antiforms themselves have no canon representation.</em>  The console can print out a comment or show them in a different color, but to talk about them having a representation doesn't make much sense as you'll never see them in source.</p>
<pre><code>&gt;&gt; ~(d e)~
== ~(d e)~  ; anti
</code></pre>
<p>I also asked:</p>
<blockquote>
<p>"How would you write LIFT and UNLIFT such that at the end of the code above, you'd get:"</p>
<pre><code>&gt;&gt; data
== [[0 1] 1 2 [2 3] 3 4]
</code></pre>
</blockquote>
<p>With group antiforms representing splices, you don't need to write LIFT and UNLIFT... because they come in the box.  And instead of using blocks to wrap, they use the super-efficient QUASIFORM! and QUOTED!, so the pending array would look like:</p>
<pre><code>&gt;&gt; pending
== ['[0 1] ~(1 2)~ '[2 3] ~(3 4)~]
</code></pre>
<p>When the QUOTED! blocks are UNLIFT-ed, they become regular blocks and then are appended as-is.  When the QUASIFORM! groups are UNLIFT-ed they become antiforms and give the SPLICE! intent.  This produces the desired "suspended animation".</p>
<p><em>That suspended animation is also used in the ^META parameter convention, which indicates a function argument can accept arbitrary antiforms... and the add-quoting-or-quasi behavior brings those antiform variables into a reified state so they can be safely handled.</em></p>
<h2><a name="p-6250-the-proof-is-in-the-capabilities-5" class="anchor" href="https://rebol.metaeducation.com#p-6250-the-proof-is-in-the-capabilities-5"></a>The Proof Is In The Capabilities</h2>
<p>I've explained about splices, and mentioned how it crosses needs with unset variable states.</p>
<p>But it's also <a href="https://rebol.metaeducation.com/t/what-are-null-void-nothing-blank-and-nihil/2283">how NULL is implemented</a>, as the antiform of a WORD! state that can't be put in blocks.</p>
<p>The ERROR! antiform is used to have a sneaky out-of-band way to return <a href="https://rebol.metaeducation.com/t/fail-vs-return-fail-the-new-age-of-definitional-failures/1852">definitional errors</a></p>
<p>The ACTION! antiform (of the base type FRAME!) is what we'd traditionally think of as an action/function.  It triggers execution if accessed via WORD! references.  This makes it safe to handle items picked out of blocks without worrying about defusing actions...because only quasiform or plain frames can be put in blocks in the first place!</p>
<p>The BLOCK! antiform is used to implement multi-return values, in a truly unique and customizable way.</p>
<p>It's natural for there to be some confusion with the new idea--especially given all its churn through the course of design.  But the design is becoming clearer, and I think people are going to find this gives solidity to writing complicated but coherent code...vastly outpacing historical Redbol.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/a-justification-of-generalized-isotopes/1918">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/a-justification-of-generalized-isotopes/1918</link>
          <pubDate>Tue, 16 Aug 2022 10:23:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1918</guid>
          <source url="https://rebol.metaeducation.com/t/a-justification-of-generalized-isotopes/1918.rss">A Justification of Generalized Isotopes</source>
        </item>
        <item>
          <title>The Rebellion Against Style Guides</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>While driving from Huntsville to Florida, I listened to a talk given by a guy who oversees the general style guide for all of Google's multi-millions of lines of C++.</p>
<p>He spoke very positively about a formatting tool called <code>clang-format</code>, and how if he had his way at Google...there would be no arguing over code formatting.  He felt the robot did a better job on average than even the best developers...and being willing to delegate formatting to the tool gave them time to work on more important things.</p>
<p><strong>My well-known opinion for code like C++ or Rust or Java is that it is best represented as a graph data structure that captures the relationships and identities.</strong>  How you render that is up to the program you use to view and edit the projection of that essential code.  It doesn't matter if code is in braces or has a box drawn around it.  You could make expressions feed into an actual logical circuit AND gate instead of using <code>&amp;&amp;</code> or the word <code>and</code> or what-have-you.</p>
<p><strong>But Rebol is different (and almost absurdist) in the software world.</strong>  If anything, it has an <em>anti</em>-style guide, in <a href="http://www.rebol.com/article/0103.html">The Deep Lake / (Swamp)</a>, where Carl says:</p>
<blockquote>
<p>Suppose I write:</p>
<pre><code>if time &gt; 10:00 [
    wakeup user
]
</code></pre>
<p>which some users may choose to rewrite it this way:</p>
<pre><code>if time &gt; 10:00
[
    wakeup user
    alert "Time to work"
 ]
</code></pre>
<p>But, what if the "then block" is a variable itself, defined as:</p>
<pre><code> action: [
     wakeup user
     alert "Time to work"
  ]
</code></pre>
<p>Would you write this:</p>
<pre><code>  if time &gt; 10:00
      action
</code></pre>
<p>or this:</p>
<pre><code>   if time &gt; 10:00 action
</code></pre>
</blockquote>
<p>The conclusion is:</p>
<blockquote>
<p>...<strong>how you write code is ultimately your choice alone</strong>. REBOL, as a context dependent language, is perhaps the most freeform computing language ever invented.</p>
</blockquote>
<p>I'm bringing this up because I'm mothballing an old Trello and looking for any links or information worth preserving.  It had a card requesting a style guide, pointing out a limited bit that had been written in the Rebol2 manual:</p>
<p><a href="http://www.rebol.com/docs/core23/rebolcore-5.html#section-5">http://www.rebol.com/docs/core23/rebolcore-5.html#section-5</a></p>
<p>I'm really only interested in the bits that reduce complexity (like just-say-no-to-CRLF files, or tabs, etc.)  As for the code itself, this is kind of an ASCII-art medium.</p>
<p>So a good "style guide" for Rebol would be one that showed examples of how to take advantage of the degrees of freedom to be bent to your purposes.  I think a good one was the <strong><a href="https://rebol.metaeducation.com/t/testing-generic-tuple-and-path-structuring/1353">tuple and path test dialect</a></strong>.  But there are certainly more!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/the-rebellion-against-style-guides/1819">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/the-rebellion-against-style-guides/1819</link>
          <pubDate>Sat, 14 May 2022 05:39:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1819</guid>
          <source url="https://rebol.metaeducation.com/t/the-rebellion-against-style-guides/1819.rss">The Rebellion Against Style Guides</source>
        </item>
        <item>
          <title>Turning a Blind Eye to Evaluator &quot;Abuse&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>I've gotten kind of attached to the current look and behavior of AND and OR, which allow short-circuiting even though one would not think the language could (should?) be able to.</p>
<p>It doesn't require simple variables be in a GROUP! on the right hand side.</p>
<pre><code>&gt;&gt; if true and true [print "True"] else [print "False"]
True
</code></pre>
<p>...but a function call has to be.</p>
<pre><code>&gt;&gt; foo: func [x] [
      print "Calling foo!"
      return x &gt; 1000
   ]

&gt;&gt; if false and foo 1020 [print "True!"] else [print "False"]
** Error: words/tuples can't be ACTION! as right hand of OR, AND, XOR

&gt;&gt; if false and (foo 1020) [print "True"] else [print "False"]
False

&gt;&gt; if true and (foo 1020) [print "True!"] else [print "False"]
Calling foo!
True
</code></pre>
<p><em>Note that if the thing to the left of the AND is false, it does not run the code in the GROUP! on the right.</em>  This requires that the right hand side be a quoted parameter convention.</p>
<p>Alternatively we could not quote it, and require the right hand side be in a block:</p>
<pre><code>&gt;&gt; if true and [true] [print "True"] else [print "False"]
True

&gt;&gt; if false and [foo 1020] [print "True"] else [print "False"]
False
</code></pre>
<p><strong>But I don't like that.</strong></p>
<p>Alternatively we could say we don't offer this and you always use ALL...maybe with COMMA! and maybe not:</p>
<pre><code>&gt;&gt; if all [true true] [print "True"] else [print "False"]
True

&gt;&gt; if all [false, foo 1020] [print "True"] else [print "False"]
False
</code></pre>
<p>I just don't think that looks as natural.</p>
<h2><a name="p-5774-its-like-i-said-in-speaking-with-ticshttpsrebolmetaeducationcomtspeaking-with-tics-should-quoted-arguments-always-be-apostrophed1359-1" class="anchor" href="https://rebol.metaeducation.com#p-5774-its-like-i-said-in-speaking-with-ticshttpsrebolmetaeducationcomtspeaking-with-tics-should-quoted-arguments-always-be-apostrophed1359-1"></a>It's Like I Said In <a href="https://rebol.metaeducation.com/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359">"Speaking With Tics"</a>...</h2>
<p>If you think seeing a GROUP! on the right of AND and OR that doesn't unconditionally evaluate at the callsite is weird, why are you comfortable with <strong><code>for-each x [1 2 3] [...]</code></strong>?  That didn't unconditionally evaluate x.  Do you expect it to be <strong><code>for-each 'x</code></strong> instead?</p>
<aside class="quote no-group">
<blockquote>
<p>The quoted parameter convention exists to save you the trouble of quoting the callsites. <em>If this isn't what that's for, then what <strong>is</strong> it for?</em></p>
</blockquote>
</aside>
<p>It's just too nice to be able to say things like <strong><code>if var1 and var2 or (a &gt; b) [...]</code></strong>.</p>
<p>To me, part of what makes the language special is the ability to bend the evaluator to how we want to read code, vs bending code to fit the evaluator.  The existence of mechanics like quoted parameters are there to let this happen.</p>
<p><em>You don't have to use it.</em>  And the ability to switch it to where AND is a prefix operator that does bitwise math is the magic of the freedom of choice.  You can choose to change the definition even on a module-by-module basis, or on a function-by-function basis.</p>
<p>Further: if you're not bending the language, you're probably not really using it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/turning-a-blind-eye-to-evaluator-abuse/1791">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/turning-a-blind-eye-to-evaluator-abuse/1791</link>
          <pubDate>Fri, 18 Feb 2022 18:34:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1791</guid>
          <source url="https://rebol.metaeducation.com/t/turning-a-blind-eye-to-evaluator-abuse/1791.rss">Turning a Blind Eye to Evaluator &quot;Abuse&quot;</source>
        </item>
        <item>
          <title>Regarding The &quot;Finality&quot; Of FAIL, RETURN, etc.</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>There are some functions that by name carry a certain <em>"finality"</em>.  You don't expect there to be a way to pass them an argument that will revoke them.</p>
<p>For instance, it would be a bit weird if FAIL followed the BLANK-IN, NULL-OUT convention:</p>
<pre><code>foo: func [error [error! blank!]] [
    fail error

    print "This looks like unreachable code."
]
</code></pre>
<p>Today we don't offer that Wayne's World version of "FAIL.... NOT!"  So you have to write:</p>
<pre><code>if error [fail error]
</code></pre>
<p>I've actually been in situations where repeating the error expression is complicated by things like API handle freeing issues, to where I've considered making something like MAYBE-FAIL which would be a No-Op on BLANK!... or perhaps a refinement as FAIL/MAYBE.</p>
<p>But I've not considered the idea of making plain FAIL a no-op on blanks.  That seems wrong.</p>
<h2><a name="p-5552-does-return-have-a-similar-finality-1" class="anchor" href="https://rebol.metaeducation.com#p-5552-does-return-have-a-similar-finality-1"></a>Does RETURN Have A Similar "Finality"?</h2>
<p>I've written a bunch about <a href="https://rebol.metaeducation.com/t/uparse-return-subtleties/1589/4">how I stopped worrying and learned to love UPARSE's RETURN</a>.</p>
<p>But there's something a little weird to my tastes about it being "non-final".  For example:</p>
<pre><code>&gt;&gt; uparse "aabc" [some "a" return "x" | some "a" return "b"]
== "b"  ; today's answer (also R3-Alpha's answer with PARSE)
</code></pre>
<p>When it reached the point of RETURN "X", there were two potential interpretations:</p>
<ol>
<li>
<p><em>"Okay, it's time to return!  Let's see if this rule matches or not...and if not, we're returning NULL!"</em></p>
</li>
<li>
<p><em>"It might be time to return if this rule matches.  If it doesn't match, pretend we were never asked to return."</em></p>
</li>
</ol>
<p>Today we have (2).  It's strictly more powerful... as you can get (1) with <strong>return opt "x"</strong>.</p>
<pre><code>&gt;&gt; uparse "aabc" [some "a" return opt "x" | some "a" return opt "b"]
; null
</code></pre>
<p>Note also that if your RETURN value is in a GROUP! and evaluated as DO code instead of a rule, it will always succeed...and hence always final.  It's only when you pass a rule that it can get revoked.</p>
<p>As with needing to write <strong>if error [fail error]</strong>, if we switched to parse-RETURN-finality that would mean more code for opting out:</p>
<pre><code>; opting out in RETURN-non-final style
uparse data [... return [your rule here] ...]

; opting out in RETURN-final style
uparse data [... result: [your rule here] return (result) ...]
</code></pre>
<p><strong>But I still feel weird about RETURN in PARSE being something that can just be opted out of by the nature of its argument.</strong></p>
<p>And so far, every time I've wanted to use RETURN it has been either a RETURN of a GROUP! (thus unconditional) or a RETURN OPT.</p>
<p>So I'm thinking of making RETURN "final"...if you give it a rule that doesn't match it returns NULL.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/regarding-the-finality-of-fail-return-etc/1735">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/regarding-the-finality-of-fail-return-etc/1735</link>
          <pubDate>Sun, 03 Oct 2021 15:49:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1735</guid>
          <source url="https://rebol.metaeducation.com/t/regarding-the-finality-of-fail-return-etc/1735.rss">Regarding The &quot;Finality&quot; Of FAIL, RETURN, etc.</source>
        </item>
        <item>
          <title>Should Built-In Constructs Leverage More &quot;Reserved Words&quot;?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>I was looking at an old proposal for using <strong>|</strong> in PRINT to mean "newline".</p>
<pre><code>print [
    "DESCRIPTION:" |
    tab, any [description, "(undocumented)"] |
    tab (uppercase word) {is} classification #"."
]
</code></pre>
<p>That was taken off the table due to <strong>|</strong> being used as an expression barrier.  But COMMA! is doing a much better job of that, so it's back in the realm of possibility.</p>
<p>And I was also looking at some API code in ODBC like this:</p>
<pre><code>rebValue(
    "switch @", ARG(encoding), "[",
        "'utf-8 [", rebI(CHAR_COL_UTF8), "]",
        "'ucs-2 [", rebI(CHAR_COL_UTF16), "]",
        "'utf-16 [", rebI(CHAR_COL_UTF16), "]",
        "'latin-1 [", rebI(CHAR_COL_LATIN1), "]",
    "] else [",
        "fail {ENCODING must be UTF-8, UCS-2, UTF-16, or LATIN-1}"
    "]"
);
</code></pre>
<p>It made me wonder what if SWITCH let you use something like, say, fat arrow:</p>
<pre><code>rebValue(
    "switch @", ARG(encoding), "[",
        "'utf-8 =&gt;", rebI(CHAR_COL_UTF8),
        "'ucs-2 =&gt;", rebI(CHAR_COL_UTF16),
        "'utf-16 =&gt;", rebI(CHAR_COL_UTF16),
        "'latin-1 =&gt;", rebI(CHAR_COL_LATIN1),
    "] else [",
        "fail {ENCODING must be UTF-8, UCS-2, UTF-16, or LATIN-1}"
    "]"
);
</code></pre>
<h2><a name="p-5175-are-core-constructs-underplaying-their-hand-1" class="anchor" href="https://rebol.metaeducation.com#p-5175-are-core-constructs-underplaying-their-hand-1"></a>Are Core Constructs Underplaying Their Hand?</h2>
<p>I've felt for a long time that PRINT is not strong enough, because it hasn't taken things like TAG! away to signal format changes (colors?).</p>
<p>And when I look at the difference we get in SWITCH above, esp in the API, it makes me wonder if something like that is appropriate.  Though maybe the @ symbol is better to be pushed further to this purpose as a legal branch type...</p>
<p>...anyway the details aren't important.  I guess I'm asking more <em>"could we make a better language if we were more willing to steal words"</em>.</p>
<p>Do we need distinctions...such as "core switch" and "rich switch", and then let people pick which they use?  Where they're expected to hack up the switch to customize it to their tastes?</p>
<p>(Just wanted to put this out there, as I'm deleting a note about | as newline in PRINT on the Trello.)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-built-in-constructs-leverage-more-reserved-words/1622">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-built-in-constructs-leverage-more-reserved-words/1622</link>
          <pubDate>Sat, 05 Jun 2021 16:47:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1622</guid>
          <source url="https://rebol.metaeducation.com/t/should-built-in-constructs-leverage-more-reserved-words/1622.rss">Should Built-In Constructs Leverage More &quot;Reserved Words&quot;?</source>
        </item>
        <item>
          <title>Debunking the Arity-1 MAKE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Rebol2, R3-Alpha, and Red embrace the idea of an arity-1 MAKE, that you use for any type.</p>
<p>When a single parameter seems insufficient to create a datatype, it just stuffed the two things into a BLOCK!.  That led to things like this FUNC definition in the bootstrap for R3-Alpha...which is a weird two-step process.  It wants to copy the spec/body in most cases, but the mezzanine optimizes and does not write code in a style that would need to copy the spec/body...so there's a "funco" helper:</p>
<pre><code>funco: make function! [[
    {Non-copying function constructor (optimized for boot).}
    spec [block!] {Help string (opt) followed by arg words}
    body [block!] {The body block of the function}
][
    make function! reduce [spec body]
]]

func: funco [
    {Defines a user function with given spec and body.}
    spec [block!] {Help string (opt) followed by arg words}
    body [block!] {The body block of the function}
][
    make function! copy/deep reduce [spec body]  ; (now it deep copies)
]
</code></pre>
<h2><a name="p-5055-is-this-just-make-work-pun-intended-1" class="anchor" href="https://rebol.metaeducation.com#p-5055-is-this-just-make-work-pun-intended-1"></a>Is This Just "Make-Work"? (pun intended)</h2>
<p>Imagine a different approach in which FUNC itself is just a native that takes two parameters and makes a function out of it.  There would be several benefits:</p>
<ul>
<li>
<p>You don't need to run a REDUCE to make a block that you're ultimately just going to separate into two blocks.  That's wasted space and computation.  The FUNC passes through the two blocks separately.</p>
</li>
<li>
<p>You avoid looking into a table of MAKE dispatchers, breaking down a block and re-type checking it to make sure it's a block of exactly two other blocks.  The FUNC type checking takes care of that on the independent proeprties.</p>
</li>
<li>
<p>If there's a low-level property such as not copying the blocks passed in, that could be handled by a refinement (/NOCOPY) which makes the distinction clearer in the cases that use it.</p>
</li>
</ul>
<p>Faster, clearer.  No one really uses the "polymorphism" of <strong>make some-type some-definition</strong> without really knowing what type or definition is, right?  That seems essentially meaningless.</p>
<h2><a name="p-5055-so-what-is-the-theoretical-value-of-arity-1-make-2" class="anchor" href="https://rebol.metaeducation.com#p-5055-so-what-is-the-theoretical-value-of-arity-1-make-2"></a>So What Is The Theoretical Value of Arity-1 MAKE?</h2>
<p>I'd assumed that the actual theoretical value was something along the lines of <em>having a serialization form of every type as a BLOCK!</em> (or other simple type)</p>
<p>Perhaps the reasoning went:</p>
<ul>
<li><em>if</em> you can <em>create</em> any type from a single argument like a BLOCK!</li>
<li>...then that means you can MOLD any instance of a value into that same representation.</li>
</ul>
<p>So what I did in the early days of Ren-C is I tried to enforce a correspondence between <strong>make function! [...]</strong> and <strong>#[function! [...]]</strong>.  The code that was dispatched by MAKE was the same code that constructing a molded function would call.</p>
<p><em>That was a nice thought, but due to binding, it doesn't actually work.</em>  Basic disproof:</p>
<pre><code>&gt;&gt; obj: make object! [y: 10]

&gt;&gt; f: func [x] bind [x + y] obj

&gt;&gt; y: 100

&gt;&gt; molded: mold f
== "#[action! [[x] [x + y]]]"

&gt;&gt; g: load molded

&gt;&gt; f 1
== 11

&gt;&gt; g 1
== 101
</code></pre>
<p>The only real way to preserve the loaded connections of things is in some kind of binary serialization format (like "redbin" is pursuing)...or to always be storing the session's memory as a persistent VM state (like Smalltalk's Squeak and such).</p>
<h3><a name="p-5055-any-counter-arguments-in-defense-of-the-usefulness-of-arity-1-make-3" class="anchor" href="https://rebol.metaeducation.com#p-5055-any-counter-arguments-in-defense-of-the-usefulness-of-arity-1-make-3"></a>...any counter-arguments in defense of the usefulness of Arity-1 Make?</h3>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/debunking-the-arity-1-make/1591">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/debunking-the-arity-1-make/1591</link>
          <pubDate>Fri, 30 Apr 2021 16:54:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1591</guid>
          <source url="https://rebol.metaeducation.com/t/debunking-the-arity-1-make/1591.rss">Debunking the Arity-1 MAKE</source>
        </item>
        <item>
          <title>Don&#39;t Fear The WORD!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Something Rebol touts as a big advantage is that it hasn't pinned a meaning to any words, so you can use them to mean what you want.</p>
<p>But I frequently have stressed over this, because words have associated costs that are non-trivial.</p>
<h2><a name="p-4919-example-the-section-divider-1" class="anchor" href="https://rebol.metaeducation.com#p-4919-example-the-section-divider-1"></a>Example: The Section Divider: <strong><code>===</code></strong></h2>
<p>I thought it would be neat if we could use this to have a Markdown-Like split of headers which just used plain words:</p>
<pre><code>all [
    === STEP WITH JUST WORDS ===

    step1 arg1

    === {STEP WITH STRING, NOT AS PLEASING} ===

    step2 arg2
]
then [
    print "=== is invisible, so it doesn't interfere with things like ALL!"
]
</code></pre>
<p>The idea is that it could be hooked in ways a comment couldn't...to print out messages to know you've reached the step (for instance).</p>
<p>Because I thought it was more pleasing, I designed it to permit words.  === was as a variadic function which would keep looking across its input until it found a === to terminate.</p>
<p><em>(Note: Wanting to reclaim <strong>==</strong> for using as an even briefer way of saying "section" is one of several motivators for cleaning up the use of it for equality)</em></p>
<p>But there are issues that come up from trying to write strings without string delimiters in Redbol.</p>
<p><strong>You have to write LOAD-able syntax.</strong>  Having COMMA! makes it a bit more tolerable, but you can still get in trouble with unusual uses of other characters.</p>
<pre><code>=== Here's a 3rd example; broken! ===
</code></pre>
<p>That's going to not be able to handle <code>3rd</code> in the current system (though <a href="https://rebol.metaeducation.com/t/pack-sequence-type/1503">the PACK! proposal</a> could help here).  Then the semicolon will wind out commenting stuff out.</p>
<p><strong>Meaning of GROUP! is contentious.</strong>  I use a lot of parentheses when I write text, and not mean running code.  But we presumably want a way to get expressions in there:</p>
<p>That might not be a problem if we limit that to GET-GROUP!.</p>
<pre><code>=== DEMO OF VARIATIONS (GROUP EXAMPLE) ===

count-up n 100 [
    === Running Step :(n) ===
    print "This might be a way of doing it?"
]
</code></pre>
<p>Another alternative could be to use blocks for any evaluated portions, since square brackets don't often come up in English writing.</p>
<p><strong>Plenty of Other Questions</strong>... I don't want to tackle them all here, because I'd like to move to the big issue.</p>
<h2><a name="p-4919-biggest-issue-creating-tons-of-stray-bindings-2" class="anchor" href="https://rebol.metaeducation.com#p-4919-biggest-issue-creating-tons-of-stray-bindings-2"></a>Biggest Issue: Creating Tons Of Stray Bindings</h2>
<p>On the happy side, with LET we are moving into an idea of dynamism in binding so that using a SET-WORD! doesn't get you a local.  That keeps this from throwing in a local definition of PARSE:</p>
<pre><code>foo: function [data] [
    === BEGIN PARSE: It would suck if this overwrote PARSE! ===
    parse data [...]  ; if PARSE: was gathered as local, parse would be unset
]
</code></pre>
<p>Things like this are why I was so adamant against locals gathering.  It's good that it's gone from standard use, and relegated to being a weird feature for code golfing.  LET may be slow right now, but better to be slow than absolutely wrong.  Slow features can be sped up.  Wrong features can only be deleted.</p>
<p>The storage and loading of words themselves is actually pretty efficient.  The system is geared around it.  I'm not terribly concerned about the storage overhead difference between strings and a bunch of words.</p>
<p><strong>What's more troubling is all the bindings made in the user context.</strong>  These words don't know their binding isn't going to be used.  So the user context gets expanded and expanded.</p>
<p>I won't rewrite the explanation of this here.  But see <strong><a href="https://rebol.metaeducation.com/t/the-real-story-about-user-and-lib-contexts/764">The Real Story About User and Lib Contexts</a></strong></p>
<h2><a name="p-4919-i-think-supporting-words-this-way-is-mission-critical-3" class="anchor" href="https://rebol.metaeducation.com#p-4919-i-think-supporting-words-this-way-is-mission-critical-3"></a>I Think Supporting Words This Way Is Mission Critical</h2>
<p>There are a lot of kneejerk responses which would dislike <strong>===</strong> in the form that I suggest.</p>
<p>Some people wouldn't like that it's variadic.  They might believe the principle of Rebol is based on blocks...so variadic functions shouldn't even be in the language to begin with.  I think they're wrong, and we now depend on variadicness quite a lot.</p>
<p>Others might worry about the overhead caused by bloating up the symbol space...or the length of the code block.  Or the CPU cycles consumed by having to run a variadic loop across the content of the line...one value at a time.</p>
<p><strong>But I think my leaning is that being able to choose to work this way is the distinguishing factor of the language.</strong></p>
<p>You can still use <strong><code>=== {Text} ===</code></strong> if you really want to.  Or you can avoid using === altogether and just use a comment like <strong><code>;===</code></strong> or <strong><code>;;</code></strong> and it won't have any runtime aspects at all...though then you won't get a log when it reaches that line if you want it.</p>
<p>Using bash is making me realize that even as light as Rebol can be a lot of the time, it's still too heavy sometimes.  Having to put things in quotes adds up 2 characters at a time, over time.  We should keep an eye on bending the mechanics to make it possible to use LOAD-ed "Rebol sentences" literally, and find places where that makes sense.</p>
<h2><a name="p-4919-this-means-binding-has-to-be-rethought-more-4" class="anchor" href="https://rebol.metaeducation.com#p-4919-this-means-binding-has-to-be-rethought-more-4"></a>This Means Binding Has To Be Rethought... More...</h2>
<p>We're just pinning down more of the requirements.  So as those requirements get locked, then hopefully that will make a design "emerge".</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/dont-fear-the-word/1549">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/dont-fear-the-word/1549</link>
          <pubDate>Wed, 10 Mar 2021 03:17:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1549</guid>
          <source url="https://rebol.metaeducation.com/t/dont-fear-the-word/1549.rss">Don&#39;t Fear The WORD!</source>
        </item>
        <item>
          <title>Pivotal Design Question: Is Evaluator State Just A Block?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>I ran into a hitch with LET and EVALUATE in single-stepping.</p>
<p>It raises a pretty big question about how much we want to tie the hands of the evaluator in favor of "simplicity".</p>
<h2><a name="p-4702-the-problem-1" class="anchor" href="https://rebol.metaeducation.com#p-4702-the-problem-1"></a>The Problem</h2>
<p>On the surface a LET statement might seem impossible for step by step evaluation:</p>
<pre><code>&gt;&gt; block: evaluate [let x: 10 print ["X is" x]]
== [print ["X is" x]]
</code></pre>
<p>That LET statement declared a variable, but where did it go?  It only lives until the block is over.  It would seem that the PRINT is out of luck.</p>
<p><em>But...</em> I could make it work since a BLOCK! can carry along virtual binding state.  So, at each step you just get a little more state added on.  The <strong>[print ["X is x]]</strong> is <em>different</em> from the block you'd have gotten from saying SKIP 3 on the full block, due to this binding.</p>
<p><strong>But what if you reposition the block?</strong></p>
<pre><code>&gt;&gt; block: head block
== [let x: 10 print ["X is" x]]
</code></pre>
<p>Now you have a block that has X defined in its bindings, and if you step through it you'll define it again.</p>
<h2><a name="p-4702-can-this-be-solved-2" class="anchor" href="https://rebol.metaeducation.com#p-4702-can-this-be-solved-2"></a>Can This Be Solved?</h2>
<p>I think the cleanest and clearest way to solve it is to rethink EVALUATE so that it operates on a FRAME!...not a BLOCK!.  This would match the internal model better.</p>
<p>Today, we have to tear down a frame and build up a new one each time you do a step.  This would say that you'd be keeping it alive.</p>
<p>You'd be limited in terms of being able to look back over past values you had already evaluated.  That limitation would keep you from rewinding... if you wanted to go back and do things over, you'd have to do that by working with your original block that started the whole process.</p>
<p>What you'd be able to do in terms of looking ahead would be more like what a variadic is able to do today.</p>
<h2><a name="p-4702-the-big-philosophical-question-3" class="anchor" href="https://rebol.metaeducation.com#p-4702-the-big-philosophical-question-3"></a>The Big Philosophical Question</h2>
<p>I guess the big philosophical question is not necessarily so much about LET itself, but <strong>should we rule out the existence of things like LET in general</strong>.</p>
<p>In other words: is it imperative to step the evaluator across a block and <em>not</em> accrue any state particular to that evaluation?</p>
<p>I've been kind of looking for a convergence between things like the evaluator and PARSE, and so asking what the restrictions on the evaluator are may be asking what the restrictions are on anything that tries to leverage the FRAME!-based processing of blocks...for tracking positions, giving errors, etc.  If we require them all to be amnesiacs after every step, this would make it hard to write things like the COLLECT/KEEP feature in parse with the rollback feature...because it would have to record its state in some external thing.</p>
<p><a class="mention" href="https://rebol.metaeducation.com/u/rgchris">@rgchris</a> --^ please see that and think about it.  If EVALUATE returned a FRAME! representing the block and not a new position of a block, what kind of disruption would it be?  Do you see the accrual of state in the evaluator to be something that should be ruled out--thus killing off LET or anything like LET--to be worth it to have the feature of a memoryless evaluator?</p>
<hr>
<p><strong>My leaning on this is to say that we would be crippling the language by ruling out LET-like things in the design.</strong></p>
<p>Right now, I have this test code working.  Note it's three evaluation steps, because the LET is actually invisible (1 unit lookahead to see x and add the binding, then leaves <code>x: 10</code> to run normally)</p>
<pre><code>x: &lt;in-user-context&gt;
output: '~unset~
block: evaluate evaluate evaluate [let x: 10 output: x]
did all [
    block = []
    output = 10
    x = &lt;in-user-context&gt;
]
</code></pre>
<p>And when you look at some of the other designs of how this is plugging together, I don't think we should turn back.  It's simply too hard to build abstractions on top of FUNC if the bodies cannot dynamically declare new variables, and I think forcing everyone in those situations to deal with USE is ergonomically just too awkward to feel like the language is living up to its promises.</p>
<p>I don't want to give up on virtual binding and LET when it has come this far.  It may be broken, but its brokenness is already a better kind of broken than what was there before...and there's no proof yet that it can't be made better.</p>
<p>Rebol's M.O. has been throwing imaginative <em>but I want the code to look like THIS</em> at a data structure and see how far that can go...without proof that it can or should work well.  Every now and again I think I should have the right to throw my own bad idea that looks good in there.  And maybe some poor sucker in the future can figure out the limits of how it can be made to seem like it works more.   <img src="https://rebol.metaeducation.com/images/emoji/twitter/slight_smile.png?v=14" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/pivotal-design-question-is-evaluator-state-just-a-block/1496">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/pivotal-design-question-is-evaluator-state-just-a-block/1496</link>
          <pubDate>Tue, 09 Feb 2021 21:25:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1496</guid>
          <source url="https://rebol.metaeducation.com/t/pivotal-design-question-is-evaluator-state-just-a-block/1496.rss">Pivotal Design Question: Is Evaluator State Just A Block?</source>
        </item>
        <item>
          <title>On Wasted Bits</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>In one of my Philadelphia talks, I cited a quote from Paul Graham in <a>The 1,000 Year Language</a></p>
<blockquote>
<p><em>"I learned to program when computer power was scarce. I can remember taking all the spaces out of my Basic programs so they would fit into the memory of a 4K TRS-80. The thought of all this stupendously inefficient software burning up cycles doing the same thing over and over seems kind of gross to me. But I think my intuitions here are wrong. I'm like someone who grew up poor, and can't bear to spend money even for something important, like going to the doctor."</em></p>
<p>...</p>
<p><em>"The desire for speed is so deeply engrained in us, with our puny computers, that it will take a conscious effort to overcome it. In language design, we should be consciously seeking out situations where we can trade efficiency for even the smallest increase in convenience."</em></p>
</blockquote>
<p>I've been struggling some with this fight.  For instance, the scenario of:</p>
<pre><code>count-up x 1000000 [
    let y: x + 1
    print [y]
]
</code></pre>
<p>What I have explored is the question of making LET a dynamic construct.  This dynamism would mean it wouldn't be scanned for in advance (like "FUNCT" looked for SET-WORD!).  It would actually bring a new variable and binding into existence... basically just syntax sugar for if you had written:</p>
<pre><code>count-up x 1000000 [
    use [y] [
        y: x + 1
        print [y]
    ]
]
</code></pre>
<p>It's uncomfortable to induce the thought that you'd be making a new object each time through the loop...an object with one field (y).  That's a million objects being made, that the GC will have to grapple with.</p>
<p>I'm working on making these as small as possible...and the GC will sweep them up.  But people who have seen LET or LET-like constructs from other languages would not generally assume that it would cause so much pain to the GC.  It feels so much more catastrophically worse than creating a single object:</p>
<pre><code>let y
count-up x 1000000 [
    y: x + 1
    print [y]
]
</code></pre>
<p>And if you were using <strong><code>func [... &lt;local&gt; y]</code></strong> that's even more efficient.  It doesn't create a separate object identity at all, but piggy-backs on the frame (where the arguments are already stored).</p>
<p>Of course, we're dealing with an incredibly dumb "mark and sweep the world" GC right now, that only starts cleaning up when it hits a wall.  If we were more clever, I'm sure there could be ways that the GC could localize most LETs and do zoning cleverness...doing light pick-ups of GC objects.</p>
<h2><a name="p-4688-i-may-be-worrying-too-much-1" class="anchor" href="https://rebol.metaeducation.com#p-4688-i-may-be-worrying-too-much-1"></a>I May Be Worrying Too Much</h2>
<p>The size of the variable is smaller than the size of the frame created by an addition, e.g. by the <strong>+</strong>.  If someone is at the level of optimizing for the LETs, they'd make a much bigger difference by eliminating the block:</p>
<pre><code>count-up x 1000000 [
    let y: x + 1
    print x
]
</code></pre>
<p><em>(Note: PRINT requires blocks on non-strings, non-newline characters <a href="https://rebol.metaeducation.com/t/limiting-print-to-block-text-perhaps-blank-to-opt-out/855">for a pretty good reason</a>, but I'm just trying to make the point about the relative costs of things.)</em></p>
<p>The creation of FRAME! (e.g. for a BLOCK!) has been optimized to reduce the GC load to just about the minimum that it can, but that minimum is the same minimum as what we're looking at for a LET.  So when the cost of a LET is more or less on the same level as the cost for a GROUP!, how much should we really be asking people to worry about it?</p>
<p>When you think about the forces in play here--the ability to do rearrangements to optimize it if you need to, and Paul Graham's remarks about expressivity being the long tail--I think making LET dynamic is probably the winning bet.</p>
<p>Luddites who don't like it can use <strong><code>&lt;local&gt;</code></strong> and be no worse off.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/on-wasted-bits/1492">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/on-wasted-bits/1492</link>
          <pubDate>Sat, 06 Feb 2021 06:54:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1492</guid>
          <source url="https://rebol.metaeducation.com/t/on-wasted-bits/1492.rss">On Wasted Bits</source>
        </item>
        <item>
          <title>THEN and ELSE are Essential</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>When I was describing the details of <a href="https://rebol.metaeducation.com/t/multiple-returns-and-branching-could-it-unseat-voidification/1408">rigging it so infix functions could interoperate with multiple retrun values</a>, <a class="mention" href="https://rebol.metaeducation.com/u/iarnold">@iArnold</a> responded:</p>
<aside class="quote no-group quote-post-not-found" data-username="iArnold" data-post="3" data-topic="1408" data-full="true">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/iarnold/48/226_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/1408/3">On another topic</a></div>
<blockquote>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1408">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/1408/2">On another topic</a></div>
<blockquote>
<p><strong>But How Does IF Know ELSE Wanted The /BRANCHED Output?</strong><br>
ELSE runs <em>after</em> IF. So it would need to be able to connect its need for a branched output up to IF's parameterization <em>before IF runs</em>. <img src="https://rebol.metaeducation.com/images/emoji/twitter/pleading_face.png?v=14" title=":pleading_face:" class="emoji" alt=":pleading_face:" loading="lazy" width="20" height="20"></p>
</blockquote>
</aside>
<p>This problem was solved in R2. IF knew there was no else and EITHER did.</p>
</blockquote>
</aside>
<p>Rather than just delete and ignore this tangent... I'm moving it here with <a href="https://rebol.metaeducation.com/t/null-blank-void-history-under-scrutiny/1249/4">another remark from Chris</a>:</p>
<aside class="quote no-group" data-username="rgchris" data-post="4" data-topic="1249">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/1249/4">On another topic</a></div>
<blockquote>
<p>I should say that as of now, I don't have a favourable opinion of the ELSE/THEN idiom (on a stylistic/comprehension basis) and don't think they're worth the extra complexity alone</p>
</blockquote>
</aside>
<p>Let me respond quickly.</p>
<h2><a name="p-4306-i-havent-given-up-making-it-not-affect-those-who-dont-use-it-1" class="anchor" href="https://rebol.metaeducation.com#p-4306-i-havent-given-up-making-it-not-affect-those-who-dont-use-it-1"></a>I Haven't Given Up Making It Not Affect Those Who Don't Use It</h2>
<p>Firstly: You should always have the last resort of using Redbol if you want, and I'm trying my best to make sure every convention is reversible.  Though it's a bit of a hard pill to swallow to dial back large parts of the language a decade, I think it can be done in something of a piecemeal way so that you can revert just the parts you don't like.</p>
<p>Secondly: As the post I made shows, <em>I'm still racking my brain to see what I can do</em>, even if it means pretty crazy evaluator acrobatics.  If my current trick manages to pan out, there will be a generic mechanism for getting more than one value across an infix call barrier.  It would mean all branches would go back to being "as-is".  But who knows what other doors might open.</p>
<h2><a name="p-4306-else-and-then-are-bigger-than-an-alternative-to-either-2" class="anchor" href="https://rebol.metaeducation.com#p-4306-else-and-then-are-bigger-than-an-alternative-to-either-2"></a>ELSE and THEN are Bigger Than An Alternative To EITHER</h2>
<p>I've demonstrated the synergy between CASE and SWITCH and ELSE and ALSO and THEN.  When you throw invisibles like ELIDE in, you get evaluator combinatorics I have never seen before.  Expressing imperative logic with so many seamless "asides" is going to be a real mind-blower.</p>
<p>This is what makes the language worth paying attention to.  If <em>I'm</em> impressed, then that's a pretty high bar, and so I shouldn't be the last person to feel that way.</p>
<p>(Quite a stronger and more timeless message than "fastest mostly-open-source 32-bit Rebol2 on Earth".)</p>
<h2><a name="p-4306-remember-the-self-selection-bias-3" class="anchor" href="https://rebol.metaeducation.com#p-4306-remember-the-self-selection-bias-3"></a>Remember The Self-Selection Bias</h2>
<p>If you have been using Rebol for decades, and see no problem with forcing every IF...ELSE to be EITHER, remember this:</p>
<p><strong>you are one of a <em>very, very small minority of people who managed to not be put off by the language</em></strong></p>
<p>Maybe my tastes are "mainstream".  But I don't usually like EITHER.  It might fit in sometimes when I can get everything all on one line.</p>
<p>But since I still use other languages besides Rebol, I haven't forgotten that the straightforward ordinary way can be coherent and nice:</p>
<pre><code> if ((a and b) or (c and d)) { ... } else { ... }
</code></pre>
<p>Which makes you see just how uncomfortable this is:</p>
<pre><code>either any [all [a b] all [c d]] [ ... ] [ ... ]
</code></pre>
<p>I'm more than intelligent enough to understand both.  And with years to consider it, I still prefer the first if those were my only two options.  Though I might like to write that particular one as:</p>
<pre><code>any [a and b, c and d] then [ ... ] else [ ... ]
      ; ^-- I'm considering AND's quoting convention to allow WORD!s on right
</code></pre>
<p>Of course, how you look at it depends on the length of the clauses and what you're going to emphasize.  If you've got enough code to warrant newlines, the ANYs and ALLs start being better propositions.</p>
<p>But on a higher level: if you're advertising <em>"most freeform programming language ever invented"</em>, saying that you <em>"have to write your code in a style you don't like much, because it's Rebolish"</em> is missing the message.</p>
<h2><a name="p-4306-then-else-and-also-are-non-negotiableshttpsrebolmetaeducationcomtthe-canonical-list-of-non-negotiables12444-for-me-4" class="anchor" href="https://rebol.metaeducation.com#p-4306-then-else-and-also-are-non-negotiableshttpsrebolmetaeducationcomtthe-canonical-list-of-non-negotiables12444-for-me-4"></a>THEN, ELSE, and ALSO are <a href="https://rebol.metaeducation.com/t/the-canonical-list-of-non-negotiables/1244/4">Non-Negotiables</a> for Me</h2>
<p>I've pointed out before that <a href="https://rebol.metaeducation.com/t/rationalizing-the-illusion-readability-over-writability/397">the illusion of this</a> is what keeps me going:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="397">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/rationalizing-the-illusion-readability-over-writability/397/1">Rationalizing the Illusion: Readability over Writability</a></div>
<blockquote>
<p>I think every time we get another one of these illusions under our belt, like <a href="https://trello.com/c/NPivtSdd">ELSE and THEN</a>, the game goes a little further. I'd have quit Rebol a long time ago if these breakthroughs weren't still coming along... each one probably buys one more month of my interest in the area of study</p>
</blockquote>
</aside>
<p>I'd quit if this stuff weren't in the mechanics, because the language wouldn't interest me much.</p>
            <p><small>6 posts - 4 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/then-and-else-are-essential/1411">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/then-and-else-are-essential/1411</link>
          <pubDate>Sat, 21 Nov 2020 13:40:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1411</guid>
          <source url="https://rebol.metaeducation.com/t/then-and-else-are-essential/1411.rss">THEN and ELSE are Essential</source>
        </item>
  </channel>
</rss>

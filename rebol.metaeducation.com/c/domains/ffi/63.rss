<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>FFI - AltRebol</title>
    <link>https://rebol.metaeducation.com/c/domains/ffi/63</link>
    <description>Topics in the &#39;FFI&#39; category FFI is a means of calling C functions from other languages.</description>
    
      <lastBuildDate>Sun, 18 May 2025 16:38:42 +0000</lastBuildDate>
      <atom:link href="https://rebol.metaeducation.com/c/domains/ffi/63.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>How should C variadics (like printf) work in the FFI?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>FFI</category>
          <description><![CDATA[
            <p>The Atronix <code>va_list</code> interface took a block.  It required a type to be specified for each argument--achieving what you would get if you used a C cast on each variadic argument.</p>
<p>You had to REDUCE it, also...which I don't think you should have to do:</p>
<pre><code>printf reduce ["%d, %f" 10 + 20 [int32] 12.34 [float]]
</code></pre>
<p>It may be useful to use defaulting like C's where integer types default to <code>int</code> and floating point types default to <code>double</code>:</p>
<pre><code>printf ["%d, %f" (10 + 20) 12.34]
</code></pre>
<p>If you do want to specify types, I'm leaning towards liking the FENCE! for lightweight construction, so maybe more like:</p>
<pre><code>printf ["%d, %f" {int32 10 + 20} 12.34]
printf ["%d, %f" {int32 10 + 20} {float 12.34}]
</code></pre>
<p>Back in the day I suggested putting it inside a group instead of passing a block...so that notationally it wouldn't put space between the printf and the arguments:</p>
<pre><code>(printf "%d, %f" (10 + 20) 12.34)
</code></pre>
<p>Though that has the bad property that if you forget it's a variadic, it will consume all the parameters of all ensuing calls.</p>
<p>However, it has the good property that "ordinary" variadics work with APPLY, including its <code>//</code> operator form:</p>
<pre><code>apply printf/ ["%d, %f" {int32 10 + 20} 12.34]

printf // ["%d, %f" {int32 10 + 20} 12.34]
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/how-should-c-variadics-like-printf-work-in-the-ffi/2458">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/how-should-c-variadics-like-printf-work-in-the-ffi/2458</link>
          <pubDate>Sun, 18 May 2025 16:38:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2458</guid>
          <source url="https://rebol.metaeducation.com/t/how-should-c-variadics-like-printf-work-in-the-ffi/2458.rss">How should C variadics (like printf) work in the FFI?</source>
        </item>
        <item>
          <title>Should FFI ~null~ Antiform Be Accepted as 0 POINTER!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>FFI</category>
          <description><![CDATA[
            <p>There's places in FFI clients that look more or less like this:</p>
<pre><code>let ptr: make pointer! 0
if something.field [
    let whatever: blah blah field
    ptr: address of whatever
]

call-ffi-thing-that-takes-pointer ptr
</code></pre>
<p>It's kind of inconvenient that 0 pointers aren't conditionally false.</p>
<p>At the same time, it's kind of inconvenient at times that the integer! 0 can't be tested for as conditionally false.  Are pointers a different beast?</p>
<hr>
<p><strong>Having ~null~ Typecheck Distinctly Offers Crucial Advantages</strong></p>
<p>There's something that might seem at first glance to be annoying:</p>
<pre><code>&gt;&gt; make pointer! 0
** Error: Cannot make pointer from 0
</code></pre>
<p>MAKE has to return the type of the thing you are MAKE-ing, so it can't return the antiform KEYWORD! of NULL.</p>
<p><strong>BUT</strong> this could be a raised error you defuse with TRY.  And if it's the <em>only</em> raised error (as opposed to actual failure) you can get exactly the answer you'd want:</p>
<pre><code>&gt;&gt; try make pointer! 0
== ~null~  ; anti
</code></pre>
<p>This does mean that in type specifications, if a null pointer is legal you'd have to annotate it as such, with <strong><code>[~null~ pointer!]</code></strong> instead of simply <strong><code>[pointer!]</code></strong>.</p>
<p><em>But that's a very good thing.</em>  This basically means your interfaces become documented as to whether they accept nulls or not, effectively giving you <code>std::optional</code> / <code>Option()</code> / <code>Maybe</code>.  Documenting that communicates powerfully and can give much better error locality, even in an interpreted language.</p>
<hr>
<p><strong>What are the disadvantages of making NULL the 0 pointer?</strong></p>
<p>There are obvious advantages to being able to easily conditionally test the pointer variable.</p>
<p>The first disadvantage someone might cite is "you lose the protection of being able to tell if you assigned the pointer or not".  NULL is supposed to represent the easy-to-test state of whether you've assigned a variable or not--friendlier than an unset variable, but still unfriendly in most cases.  So let's say you had meant to assign <code>ptr</code> but just forgot to.</p>
<p>I think this fear isn't that compelling.  We already have the case where NULL antiforms represent the logic falsey state (the only falsey state) and don't stress over whether you "forgot to set the logic variable".</p>
<p>The bigger deal is that there are actually some edge cases where 0 pointers are meaningful addresses.  e.g. <code>dlsym()</code> on POSIX for looking up symbols in a library makes a distinction between failure to find the address of a symbol, and address 0.</p>
<p>So if you wrote:</p>
<pre><code>something: try pick libc "some-symbol"
</code></pre>
<p>Then if it couldn't find the symbol, PICK returns a raised error, which TRY converts to NULL.  But then it could have successfully found the symbol at address 0, so that is distinct.</p>
<p><em>This seems pretty esoteric to me.</em>  If you're dealing with one of these situations, you could write:</p>
<pre><code>let pointer: pick libc "some-symbol" except e -&gt; [
    fail ["Couldn't find some-symbol in libc:" mold e]
]
let address: any [to integer! maybe pointer, 0]
</code></pre>
<p>So this way there could be a legitimate NULL returned from the LIBRARY!, vs. a raised result.  If you know you're in one of these situations, you are probably doing something hardware fiddly and an integer is what you want.</p>
<hr>
<p><strong>The Advantages Of Making ~null~ the 0 State For Pointers Seem To Outweigh The Disadvantages</strong></p>
<p>I've looked at a fair bit of code and it seems the edge case of symbols that legitimately reside at address zero in memory is not compelling enough to stop the better choice.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-ffi-null-antiform-be-accepted-as-0-pointer/2407">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-ffi-null-antiform-be-accepted-as-0-pointer/2407</link>
          <pubDate>Wed, 09 Apr 2025 15:54:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2407</guid>
          <source url="https://rebol.metaeducation.com/t/should-ffi-null-antiform-be-accepted-as-0-pointer/2407.rss">Should FFI ~null~ Antiform Be Accepted as 0 POINTER!</source>
        </item>
        <item>
          <title>FFI STRUCT! Types vs. STRUCT! Instances</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>FFI</category>
          <description><![CDATA[
            <p>The original Rebol concept behind STRUCT! kind of paralleled OBJECT!, in the sense that there was no separation between the archetype and the instance.</p>
<p>From the <a href="https://www.rebol.com/docs/library.html#struct">Rebol2/Command Documentation</a>:</p>
<pre><code>a-struct: make struct! [
    in-string [string!] "Input string"
    in-int [integer!] "Input integer"
] ["This is input" 42]
</code></pre>
<p>So just as how OBJECT! has no abstract "Class" with no data--that it then instantiates with data--every STRUCT! is an instance.</p>
<p><strong>This isn't how the C which this is trying to model works, and I'm not sure it's a great plan for a language like Rebol either.</strong></p>
<p>I'd rather you'd be able to break this apart:</p>
<pre><code>input-struct!: struct [
    in-string [string!] "Input string"
    in-int [integer!] "Input integer"
]

a-struct: make input-struct! ["This is input" 42]
</code></pre>
<p>When broken up in this way, the design gets <em>much</em> clearer.</p>
<p><strong>Plus I think we have a fighting chance now to be able to get type checking for specific structure types.</strong></p>
<p>I think it's close to where the system can reasonably come up with answers for TYPE OF that are more specific.</p>
<pre><code>&gt;&gt; type of input-struct!
== ~{struct!}~  ; anti

&gt;&gt; type of a-struct
== ~{input-struct!}~  ; anti
</code></pre>
<p>And going along with that, more specific type checking:</p>
<pre><code>get-input: func [
    return: [input-struct!]
][
    return make input-struct! ["Imagine this getting typechecked!" 1020]
]
</code></pre>
<p>I see a lot of value in that, while I see little to no upside in having everywhere that takes any structure type only be able to say "STRUCT!".</p>
<p>Plus, there'd be two independently queryable entities, which could react to PICK-ing in different ways... one by letting you access the schema (because it has no data), and the other by giving you the data:</p>
<pre><code>&gt;&gt; input-struct!.in-int
== #[field! [integer!] "Input integer"]

&gt;&gt; a-struct.in-int
== "This is input"
</code></pre>
<p><strong>I know we've wanted it for objects, but FFI might get it first...</strong></p>
<p>FFI may be a good prototyping environment for doing this just because it's tangential to the main system operation, and it's easier to muck around with it.</p>
<p>Once the theory is worked out and polished, it could be brought to bear on objects.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/ffi-struct-types-vs-struct-instances/2406">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/ffi-struct-types-vs-struct-instances/2406</link>
          <pubDate>Wed, 09 Apr 2025 08:35:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2406</guid>
          <source url="https://rebol.metaeducation.com/t/ffi-struct-types-vs-struct-instances/2406.rss">FFI STRUCT! Types vs. STRUCT! Instances</source>
        </item>
        <item>
          <title>About the Foreign Function Interface Category</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>FFI</category>
          <description><![CDATA[
            <p>FFI is a means of calling C functions from other languages.</p>
<p>Support for FFI originated with Rebol2's paid version, "Rebol/Command":</p>
<p><strong><a href="https://www.rebol.com/docs/library.html">https://www.rebol.com/docs/library.html</a></strong></p>
<p>It wasn't part of the Rebol3 open-source release, but Shixin Zeng of Atronix Engineering implemented a version of it, described in this 2019 video:</p>
<p><a href="https://www.youtube.com/watch?v=fMeTqPyrNF4">Calling C Functions From Rebol 3 with FFI</a></p>

<p>That implementation was baked in to the core of Atronix/R3.</p>
<p>While FFI was not considered a high priority for Ren-C, removing it as being required from the build was a priority.  But rather than deleting it, it was migrated into an extension:</p>
<p><strong><a href="https://github.com/metaeducation/rebol-ffi">https://github.com/metaeducation/rebol-ffi</a></strong></p>
<p>The extension was put on hold in 2021, but brought back to life in 2025.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/about-the-foreign-function-interface-category/2405">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/about-the-foreign-function-interface-category/2405</link>
          <pubDate>Wed, 09 Apr 2025 07:59:49 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2405</guid>
          <source url="https://rebol.metaeducation.com/t/about-the-foreign-function-interface-category/2405.rss">About the Foreign Function Interface Category</source>
        </item>
        <item>
          <title>Decoupling FFI from LIBRARY!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>FFI</category>
          <description><![CDATA[
            <p>I've been so gung-ho about finally coming up with a good implementation of the <a href="https://rebol.metaeducation.com/t/extension-types-implementation/1203/2">Extension Type Mechanism</a> that I've sort of changed my tune about whether it's worth it to keep around extensions like IMAGE!, VECTOR!, the FFI, or even GOB! and the serial port extension...</p>
<p>But in any case, LIBRARY! is now the best it's been:</p>
<pre><code>&gt;&gt; winsock: make library! %/C/Windows/System32/wsock32.dll
== #[library! %/C/Windows/System32/wsock32.dll]

&gt;&gt; pick winsock "gethostbyname"
== #[handle!]

&gt;&gt; pick winsock "gethostbynickname"
** Error: Couldn't find "gethostbynickname"
      in #[library! %/C/Windows/System32/wsock32.dll]

&gt;&gt; try pick winsock "gethostbynickname"
== ~null~  ; anti

&gt;&gt; close winsock
== #[library! {closed} %/C/Windows/System32/wsock32.dll]
</code></pre>
<h2><a name="p-8101-ffi-has-a-dependency-on-library-but-1" class="anchor" href="https://rebol.metaeducation.com#p-8101-ffi-has-a-dependency-on-library-but-1"></a>FFI Has A Dependency on LIBRARY!... But...</h2>
<p>So the FFI extension is designed to let you interface with C functions from Rebol code.</p>
<p>You've got a C function in some DLL, the FFI lets you wrap that up in something you can call as a Rebol function and it translates the Rebol parameters (e.g. TEXT!) into something the C can take (e.g. <code>char*</code>).</p>
<p>The way Shixin did it, you pass the FFI a LIBRARY! and a TEXT! of a function name:</p>
<pre><code>libgtk: make library! %libgtk-3.so

gtk-init: make-routine libgtk "gtk_init" [
    argc [pointer]
    argv [pointer]
]
</code></pre>
<p>But what if MAKE-ROUTINE just took a CFunction HANDLE! ?</p>
<pre><code>libgtk: make library! %libgtk-3.so

gtk-init: make-routine (pick libgtk "gtk_init") [
    argc [pointer]
    argv [pointer]
]
</code></pre>
<p>We could make this even better, by letting LIBRARY! accept WORD! as well as TEXT!, and using a TUPLE!-based PICK:</p>
<pre><code>libgtk: make library! %libgtk-3.so

gtk-init: make-routine libgtk.gtk_init [
    argc [pointer]
    argv [pointer]
]
</code></pre>
<p><strong>This makes the FFI generalize, to however you get your CFunction.</strong></p>
<p>Maybe you compiled a function in-memory with the TCC extension and want to test it from Rebol?</p>
<p>Maybe you are using a different extension than LIBRARY! for getting DLLs.</p>
<p>Anyway, I was working on trying to resolve dependencies between modules when I realized that this particular dependency isn't necessary!</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/decoupling-ffi-from-library/2394">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/decoupling-ffi-from-library/2394</link>
          <pubDate>Fri, 04 Apr 2025 09:11:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2394</guid>
          <source url="https://rebol.metaeducation.com/t/decoupling-ffi-from-library/2394.rss">Decoupling FFI from LIBRARY!</source>
        </item>
        <item>
          <title>FFI Updates and Notes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>FFI</category>
          <description><![CDATA[
            <p>Due to some complexities that had to do with the build system, the Ren-C FFI extension ceased being buildable somewhere on Dec 8, 2018.</p>
<p>Despite that, it still got some maintenance.  So when things were being searched and replaced in the codebase at large, I would tinker with the code in the FFI a bit to try and make it roughly reflect what had changed.  But even with that, a year's worth of drift without running it means it's going to get out of date.</p>
<p>In the last two days I've been able to get the demos back in running condition...including <a class="mention" href="https://rebol.metaeducation.com/u/szeng">@szeng</a>'s GTK demo:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/4ffcf04865ce28f016f80473f549aa428ec9aba9.png" data-download-href="https://rebol.metaeducation.com/uploads/default/4ffcf04865ce28f016f80473f549aa428ec9aba9" title="EqR43"><img src="https://rebol.metaeducation.com/uploads/default/optimized/1X/4ffcf04865ce28f016f80473f549aa428ec9aba9_2_624x500.png" alt="EqR43" data-base62-sha1="bpBDASDn7FumiJxFsdzNXsASGYF" width="624" height="500" srcset="https://rebol.metaeducation.com/uploads/default/optimized/1X/4ffcf04865ce28f016f80473f549aa428ec9aba9_2_624x500.png, https://rebol.metaeducation.com/uploads/default/optimized/1X/4ffcf04865ce28f016f80473f549aa428ec9aba9_2_936x750.png 1.5x, https://rebol.metaeducation.com/uploads/default/optimized/1X/4ffcf04865ce28f016f80473f549aa428ec9aba9_2_1248x1000.png 2x" data-dominant-color="5E6467"></a></div><p></p>
<h2><a name="p-3493-cool-but-the-build-problems-havent-gone-away-1" class="anchor" href="https://rebol.metaeducation.com#p-3493-cool-but-the-build-problems-havent-gone-away-1"></a>Cool, but the Build Problems Haven't Gone Away...</h2>
<p>There hasn't been a lot of time to focus on making Rebmake better at cross-platform inclusion of libraries that aren't by default available on the platform.  There's no libffi that ships in Visual Studio, so it becomes something of a manual configuration process.  Also, there's a bit of configuring that has to be done to get it working in cross-compilation of 32-bit binaries on a 64-bit Linux host.  Similar difficulties for OS X.</p>
<p>Since no one is currently actively using the FFI (in the Ren-C builds at least), it seems the path of least resistance is to just have it building into the 64-bit Linux builds.  That's where it's easy for the Travis container to install the package with <strong>sudo apt-get libffi</strong> and link with a simple <strong><code>-lffi</code></strong>.  This is enough to keep the code compiling and run a couple of little smoke tests to make sure things haven't gone too far south.</p>
<p><strong>To be clear: if you have the libraries all set up, then a "sufficiently motivated individual" could get the OS X, 32-bit Linux, and Windows versions to build.</strong>  There's nothing about the <em>code</em> that shouldn't work (since it works on Linux 64-bit, it's more or less proven.)  But they'd have to massage Rebmake to get it to spit out the right command lines and find the right files on the right platforms, when they're not around by default.  It shouldn't be too hard, as the package setup code was already on Travis...but Rebmake is a bit of a beast and needs some design work vs. just hacking it up more.</p>
<h2><a name="p-3493-speaking-of-tests-2" class="anchor" href="https://rebol.metaeducation.com#p-3493-speaking-of-tests-2"></a>Speaking of Tests...</h2>
<p>I've been wanting tests that are extension-specific to live in the directory with the extension.  So I'm moving them.  Right now we have:</p>
<ul>
<li><strong><code>%printf.r</code></strong> - Very simple demonstration of calling printf</li>
<li><strong><code>%varargs.r</code></strong> - More complex examples of calling printf and sprintf</li>
<li><strong><code>%qsort.r</code></strong> - Simple callback example of C's <code>qsort()</code> function, where the sorting comparison function used by the C code is actually a Rebol function.</li>
<li><strong><code>%qsort_r.r</code></strong> - More complex example of C's <code>qsort_r()</code> function, that allows passing a value through to the internal function that is not a global variable.  Also makes that value a "tunneled" REBVAL*, so you can actually pass a Rebol value to the C as a pointer and then get it back in the Rebol callback as a REBVAL again.</li>
<li><strong><code>%gtk.r</code></strong> - Gtk demo with toggle button, push button, font picker, and color picker</li>
</ul>
<p>There was one file hanging around called <code>%varargs_old.r</code>.  In Atronix R3 there were no variadics, so the only way to do something like printf was with a block.  This means you'd have to COMPOSE or REDUCE to get your values in:</p>
<pre><code>printf compose [
    "hello %p%c"
    "ffi" [pointer]
    (to integer! newline) [int8]
]
</code></pre>
<p>With variadics in Ren-C there was the variadic option, so I changed it to try it.  For instance:</p>
<pre><code>(printf "hello %p%c" "ffi" [pointer] to integer! newline [int8])
</code></pre>
<p>You could also use an expression barrier:</p>
<pre><code>printf "hello %p%c" "ffi" [pointer] to integer! newline [int8] |
</code></pre>
<p>I don't know what the "right" answer for calling C variadics is.  Maybe the compose was better?  But it's easy enough to go back and forth that I don't think we need to preserve two copies of the same file to different conventions.  Hence, instead I'm making a note here.</p>
<h2><a name="p-3493-and-as-i-mentioned-in-chat-3" class="anchor" href="https://rebol.metaeducation.com#p-3493-and-as-i-mentioned-in-chat-3"></a>And as I mentioned in chat...</h2>
<p>The big crazy difference with this FFI from the Atronix R3 is that it's all an extension. If you look closely you'll see a bit of an oddity in that it says  <strong>make custom!</strong>  and not  <strong>make struct!</strong> . :-/ There needs to be some work on that particular ecology point.</p>
<p>The  <em>mechanics</em>  of having an arbitrary number of datatypes is now in place. So the system is no longer limited to the number of types that fit in a byte...only the built-in types use that for optimization to get use out of all 3 platform pointers (besides the pointer-sized bits used for the header). But a REB_CUSTOM type means that it is sacrificing one of those pointers in the cell for the extension type.</p>
<p>So...there's now a bunch of policy and ecology to straighten out on top of that.</p>
<p>But again, the good news of all of this is that it means that we aren't stuck putting a bunch of FFI-specific code in the core; so the WASM build can be lighter. And similarly, we don't have a bunch of JavaScript support in the core. So things are factoring well for using the language in different configurations.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/ffi-updates-and-notes/1201">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/ffi-updates-and-notes/1201</link>
          <pubDate>Thu, 29 Aug 2019 22:05:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1201</guid>
          <source url="https://rebol.metaeducation.com/t/ffi-updates-and-notes/1201.rss">FFI Updates and Notes</source>
        </item>
        <item>
          <title>User-Mode Library Access</title>
          <dc:creator><![CDATA[rgchris]]></dc:creator>
          <category>FFI</category>
          <description><![CDATA[
            <p><strong>Is the ability to load external libraries considered a fundamental part of the core functionality of the language?</strong></p>
<p>On the face of it, I would suggest so—off the top of my head I could cite SQLite and ImageMagick as desirable components that, though they could be incorporated in other ways such as CALL, would more efficiently be utilized through the library interface.</p>
<p>The promise in Rebol 3 Alpha and Rebol 2 (specific implementation differing slightly) was thus:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">sqlite: make library! %libsqlite3.dylib
sqlite-version: make-routine sqlite "sqlite3_libversion" [
    return: [string]
]
sqlite-version
</code></pre>
<p>This is nominally possible in Ren-C through the FFI extension (I say nominally as I have not been able to confirm this first hand and understand this is still a less than ideal approach).</p>
<p><strong>Or are extensions the prescribed way to achieve integration?</strong></p>
<p>Which would open up a whole bunch of other questions.</p>
            <p><small>6 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/user-mode-library-access/470">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/user-mode-library-access/470</link>
          <pubDate>Mon, 15 Jan 2018 21:37:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-470</guid>
          <source url="https://rebol.metaeducation.com/t/user-mode-library-access/470.rss">User-Mode Library Access</source>
        </item>
        <item>
          <title>Some questions about FFI (libuv)</title>
          <dc:creator><![CDATA[middayc]]></dc:creator>
          <category>FFI</category>
          <description><![CDATA[
            <p>I have two questions. I'm trying to make a test binding to libuv ... I don't quite understand few things on the rebol and on c side.</p>
<ol>
<li>
<p>When c creates a struct and passes its address to a function that then sets its fields.</p>
<p>static struct sockaddr_in addr4;<br>
uv_ip4_addr(address_ip4, port, &amp;addr4);</p>
</li>
</ol>
<p>What should I do on FFI side to achieve the same? I tried to just allocate some memory (via malloc) and pass a pointer to that instead but it doesn't seem to work. I also tried to create hopefully correct struct! and pass addr-of to func but it doesn't seem to get set. In first case I can't know for sure, since I can't see what the address holds after the call, but the later c function that uses the addr behaves as if it weren't correctly set.</p>
<ol start="2">
<li>
<p>... I have a function that you give pointer to char and it sets the string to it. Is there a way to get to the containing c-string on that address from rebol side after it sets it?</p>
<p>int uv_ip4_name(const struct sockaddr_in* src, char* dst, size_t size)</p>
</li>
</ol>
            <p><small>6 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/some-questions-about-ffi-libuv/440">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/some-questions-about-ffi-libuv/440</link>
          <pubDate>Fri, 29 Dec 2017 21:58:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-440</guid>
          <source url="https://rebol.metaeducation.com/t/some-questions-about-ffi-libuv/440.rss">Some questions about FFI (libuv)</source>
        </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Redbol - AltRebol</title>
    <link>https://rebol.metaeducation.com/c/domains/redbol/47</link>
    <description>Topics in the &#39;Redbol&#39; category Issues regarding compatibility and emulation of &lt;a href=&quot;http://www.rebol.com/docs/docs.html&quot;&gt;Rebol2&lt;/a&gt; and &lt;a href=&quot;https://www.red-lang.org/p/about.html&quot;&gt;Red&lt;/a&gt;, as well as other things that would loosely be considered &quot;Rebol-family&quot; languages.</description>
    
      <lastBuildDate>Thu, 10 Jul 2025 09:29:18 +0000</lastBuildDate>
      <atom:link href="https://rebol.metaeducation.com/c/domains/redbol/47.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Rebol2&#39;s &quot;Hot Errors&quot; (Abandoned by R3-Alpha, Red)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>Rebol2 had a concept which had the inklings of <a href="https://rebol.metaeducation.com/t/panic-vs-return-fail-the-age-of-definitional-errors/1852">definitional errors</a>, in the sense that if you would RETURN an ERROR! value, it would escalate itself to an exception if not triaged with special functions at the callsite:</p>
<pre><code>rebol2&gt;&gt; foo: func [] [return make error! "Boom"]

rebol2&gt;&gt; foo
** User Error: Boom
** Near: return make error! "Boom"

rebol2&gt;&gt; type? foo
== error!

rebol2&gt;&gt; (foo) print "No triage, this won't print"
** User Error: Boom
** Near: return make error! "Boom"

rebol2&gt;&gt; (disarm foo) print "Triaged, so this will print"
Triaged, so this will print

rebol2&gt;&gt; disarm foo

rebol2&gt;&gt; probe disarm foo
make object! [
    code: 800
    type: 'user
    id: 'message
    arg1: "Boom"
    arg2: none
    arg3: none
    near: [return make error! "Boom"]
    where: none
]
</code></pre>
<h2><a name="p-8502-why-was-this-abandoned-1" class="anchor" href="https://rebol.metaeducation.com#p-8502-why-was-this-abandoned-1"></a>Why Was This Abandoned?</h2>
<p><strong><a href="http://www.rebol.net/r3blogs/0007.html">According to Carl</a>:</strong></p>
<blockquote>
<p><em>"Prior versions of REBOL used 'hot' errors. That is, you had to treat error values in a special way or they would automatically trigger error processing. This behavior was originally implemented to keep errors from propagating too far from their origins (the principle was to preserve as much as possible the locality of the error)."</em></p>
<p><em>"These hot errors turned out to be overkill, and the benefit of error locality was offset by the difficulty of handling error values in general. (See the articles of <a href="https://web.archive.org/web/20060101045815/http://www.fm.vslib.cz/~ladislav/rebol/">Ladislav Mecir</a> who wrote excellent notes on this subject). It could be quite tricky at times."</em></p>
</blockquote>
<p>I'm not sure what articles he's referring to from Ladislav.  The link he provides has an error section where Ladislav points out some bugs and says <em>"any Rebol value should be obtainable as a result of an expression, a result of a parenthesized expression, a result of a block evaluation and a result of a function evaluation"</em>, which seems pretty uncontroversial.</p>
<h2><a name="p-8502-so-what-was-the-problem-2" class="anchor" href="https://rebol.metaeducation.com#p-8502-so-what-was-the-problem-2"></a>So... What Was The Problem?</h2>
<p>One big ergonomic problem is that TRY intercepted errors, but didn't disarm them.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<pre><code>rebol2&gt;&gt; foo: func [] [return make error! "Boom"]

rebol2&gt;&gt; caught: try [foo]
** User Error: Boom
** Near: return make error! "Boom"

rebol2&gt;&gt; caught/id
** User Error: Boom
** Near: return make error! "Boom"
</code></pre>
<p>That's incredibly inconvenient.  So why didn't TRY do a DISARM?</p>
<p>The problem is "hotness" was a property of all values of ERROR! type, and when you disarm them they'd become OBJECT!.  If TRY were to DISARM the error it wouldn't be an ERROR! anymore, so you couldn't test to see if your expression had produced an error or not.</p>
<p>You get this because you're trying to pack too much information into one return result.  It could have been addressed by having you write your TRY as arity-2 with an EXCEPT.</p>
<pre><code>rebol2&gt;&gt; try-except: func [code handler /local e] [
             return either error? e: try code [handler disarm :e] [:e]
         ]

rebol2&gt;&gt; try-except [foo] func [e] [probe e/arg1]
"Boom"

rebol2&gt;&gt; try-except [1 + 2] func [e] [probe e/arg1]
== 3
</code></pre>
<p>Ren-C gives you this with infix, and you can use an arrow function, so it's more pleasing:</p>
<pre><code>foo except e -&gt; [probe e.arg1]
</code></pre>
<h2><a name="p-8502-hot-errors-would-have-been-only-half-the-story-3" class="anchor" href="https://rebol.metaeducation.com#p-8502-hot-errors-would-have-been-only-half-the-story-3"></a>Hot Errors Would Have Been Only Half The Story</h2>
<p>It seems Rebol2 was on the right track by having a state you could carry in a function's return result, that would promote to a divergent panic if not triaged at the callsite.</p>
<p>But for it to gel, you need to draw a sharp line between divergent panics and ERROR!, and not mix up their interception (in fact, <a href="https://rebol.metaeducation.com/t/discouraging-the-interception-of-abrupt-failures/1871">you should practically never intercept divergent panics</a>).</p>
<p>Rebol2's TRY was a one-size-fits-none construct, considering any typo or deeply nested errors to be on par with one that was "RETURN'd" directly from the function you were calling:</p>
<pre><code>rebol2&gt;&gt; probe disarm try [read %nonexistent.txt]
make object! [
    code: 500
    type: 'access
    id: 'cannot-open
    arg1: "/C/Projects/rebol2/nonexistent.txt"
    arg2: none
    arg3: none
    near: [read %nonexistent.txt]
    where: 'halt-view
]

rebol2&gt;&gt; probe disarm try [rread %nonexistent.txt]
make object! [
    code: 300
    type: 'script
    id: 'no-value
    arg1: 'rread
    arg2: none
    arg3: none
    near: [rread %nonexistent.txt]
    where: 'halt-view
]
</code></pre>
<p>This makes it nigh impossible to act upon the information reliably.</p>
<h2><a name="p-8502-the-wayward-drift-to-all-errors-are-exceptions-4" class="anchor" href="https://rebol.metaeducation.com#p-8502-the-wayward-drift-to-all-errors-are-exceptions-4"></a>The Wayward Drift To All-Errors-Are-Exceptions...</h2>
<p>Despite Rebol2 being on the cusp of meaningful error handling, R3-Alpha went the way of the exception fallacy.  Jumping across arbitrary levels of stack running arbitrary code in order to handle an error in stack levels above is something that the software industry has pretty much debunked.</p>
<p>For the most part, exceptions need to be reserved for things that should basically <em>never</em> happen.  The rare systems that do handle them should be when it's required for mitigating damage or corruption that might occur if cleanup code doesn't get run.  Exceptions are not what you want to use to deliver garden variety errors...you need direct contracts between caller and callee.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/rebol2s-hot-errors-abandoned-by-r3-alpha-red/2505">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/rebol2s-hot-errors-abandoned-by-r3-alpha-red/2505</link>
          <pubDate>Thu, 10 Jul 2025 09:29:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2505</guid>
          <source url="https://rebol.metaeducation.com/t/rebol2s-hot-errors-abandoned-by-r3-alpha-red/2505.rss">Rebol2&#39;s &quot;Hot Errors&quot; (Abandoned by R3-Alpha, Red)</source>
        </item>
        <item>
          <title>Oldes Rebol3.19.0 on Haiku, etc.</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>As I have mentioned previously, Oldes is deserving of being the torch-bearer for R3-Alpha... in the sense that he's more or less kept everything the same.  He hasn't focused on working through issues in the language design... but more on bridging it so it can be used as a tool for many disparate things: ranging from MIDI to 2D graphics to interoperating with Spotify or GitHub, etc.</p>
<p><a href="https://github.com/Oldes/Rebol3/releases/tag/3.19.0">https://github.com/Oldes/Rebol3/releases/tag/3.19.0</a></p>
<p>It seems he is in isolation delivering a lot more than Red, as far as the mission of <em>"not fixing the language, just making an open source artifact to apply in its current state to more things."</em></p>
<p>There's likely stuff to borrow from all of it, if it were time to do such a borrowing.</p>
<p>In any case, Rebolek is advocating for putting his version on HaikuDepot:</p>
<aside class="onebox discoursetopic" data-onebox-src="https://discuss.haiku-os.org/t/rebol-3-19-0-released-and-how-to-get-it-on-haikudepot/16643">
  <header class="source">
      <img src="https://discuss.haiku-os.org/uploads/default/optimized/2X/6/651be6f46e3730f769e5c26fb602aadd88f71863_2_32x32.ico" class="site-icon" width="32" height="32">

      <a href="https://discuss.haiku-os.org/t/rebol-3-19-0-released-and-how-to-get-it-on-haikudepot/16643" target="_blank" rel="noopener" title="06:59AM - 17 April 2025">Haiku Community – 17 Apr 25</a>
  </header>

  <article class="onebox-body">
    <img src="https://discuss.haiku-os.org/uploads/default/original/2X/6/6e26ce496160254d6af509e5391c18f066c76756.png" class="thumbnail onebox-avatar" width="64" height="64">

<div class="title-wrapper">
  <h3><a href="https://discuss.haiku-os.org/t/rebol-3-19-0-released-and-how-to-get-it-on-haikudepot/16643" target="_blank" rel="noopener">Rebol 3.19.0 released and how to get it on HaikuDepot</a></h3>
  <div class="topic-category">
      <span class="badge-wrapper bullet">
        <span class="badge-category-bg" style="background-color: #25AAE2;"></span>
        <span class="badge-category clear-badge">
          <span class="category-name">Software</span>
        </span>
      </span>
  </div>
</div>

  <p>Hello guys,  the title says it all - Oldes continues to do his fantastic job and released Rebol 3.19.0. If you know what Rebol is, you’re probably as excited as me and if you don’t know, it’s a language invented by Carl Sassenrath, author of...</p>


  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>I doubt this will draw much (any?) attention.  Despite adding more integrations, <em>I maintain that the R3-Alpha-era language delivers too little on its promises for why you would use the language in the first place.</em>  So few would see it worth overcoming the frustrations of the tool when its "unique features" are mostly a mirage.</p>
<p>But we'll see.  In any case, I coincidentally <a href="https://rebol.metaeducation.com/t/ren-c-builds-on-haiku/1710/4">built on Haiku again just yesterday</a> (<a href="https://www.youtube.com/watch?v=jImeByEkV8Y">I was the one who did the initial port</a>).  So if by some chance any rabid interest arises from that outreach, Ren-C will be around to offer some actual design and technology.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/oldes-rebol3-19-0-on-haiku-etc/2417">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/oldes-rebol3-19-0-on-haiku-etc/2417</link>
          <pubDate>Thu, 17 Apr 2025 10:42:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2417</guid>
          <source url="https://rebol.metaeducation.com/t/oldes-rebol3-19-0-on-haiku-etc/2417.rss">Oldes Rebol3.19.0 on Haiku, etc.</source>
        </item>
        <item>
          <title>Joe Marshall: &quot;REBOL 1.0 Was Slow&quot;</title>
          <dc:creator><![CDATA[rebolbot]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>Joe Marshall has posted on his blog about Rebol 1.0, here in modern times (January 3, 2025).</p>
<p><strong><a href="https://funcall.blogspot.com/2025/01/rebol-10-was-slow.html">https://funcall.blogspot.com/2025/01/rebol-10-was-slow.html</a></strong></p>
<p><em>(See also posts here on this forum: <strong><a href="https://rebol.metaeducation.com/t/rebol-1-0-retrospective/1788">Rebol 1.0 Retrospective</a></strong>)</em></p>
<hr>
<blockquote>
<p>Rebol 1.0 was slow. I paid little attention to speed in the implementation — I was concerned with correctness. The intepreter was intended to be a reference implementation, with well-defined behavior on every edge case. My intent was to add a compiler at a later date.</p>
<p>Once source of slowness was the liberal use of first-class continuations in the interpreter. Rebol 1.0 used a “Cheney on the MTA” interpretation strategy, where no function ever returned a value and the stack simply got deeper and deeper. When the stack overflowed, a stack garbage collection was triggered. Since most of the stack was garbage, this was a fast operation (I used a garbage collector that used time proportional to live storage). With such an implementation, first-class continuations were trivial to implement — <em>all</em> continuations were first-class, it was just a question of whether you surfaced them to the user. I didn’t have an ideological belief either way, but there they were, so why not? Many control flow constructs that would otherwise require an <em>ad hoc</em> implementation can be easily implemented with first-class continuations.</p>
<p>Rebol had <code>return</code> statements that would return control to the caller from within the function. 99% of the time, the caller is sitting on the stack just above the current frame. But 1% of the time, the user would do something weird like create a lexical closure over the <code>return</code> statement and pass it downward. Like as not he didn’t deliberately do this, but rather used some library that was implemented in continuation-passing style. If this happened, the <code>return</code> statement might have to unwind an arbitrary amount of stack. To implement this, I captured the current continuation at the entry of each function and bound it to the implicit “<code>return</code>” variable. Invoking <code>return</code> invoked the continuation and returned control to the caller. The advantage of doing it this way was that <code>return</code> statements had the correct semantics under all circumstances. There were no special rules governing use of <code>return</code> and no code had to have special cases for unexpected <code>return</code>s.</p>
<p>A similar thing happened in the implementation of <code>break</code> and <code>continue</code> in loops. These were implemented by capturing the continuation at the entry of the loop and binding it to the implicit <code>break</code> variable, and capturing the continuation on each iteration and binding it to the implicit <code>continue</code> variable. Because these were first-class continuations, they could be used to restart the loop after it exited. That wasn’t a requirement. I was perfectly happy to stipulate that <code>break</code> and <code>continue</code> only work while a loop is in progress, but in Rebol 1.0, they’d continue to work after the loop finished.</p>
<p>Worrying about continuations captured in lexical closures may seem weird, but it’s a real issue. It is common to introduce implicit lexical contours in a program: even a <code>let</code> expression does it. You would like to be able to use <code>break</code> and <code>continue</code> in the body of a <code>let</code> expression in a loop. Some Rebol constructs were implemented by implicitly macroexpanding the code into a call to a helper function. <code>break</code> and <code>continue</code> would work across function call boundaries, so there were no limitations on introducing helper functions within a loop.</p>
<p>A more traditional language has a handful of <em>ad hoc</em> iteration constructs that are implemented with special purpose code. The special purpose code knows it is a loop and can be optimized for this. <code>break</code> and <code>continue</code> statements have a special dependency on the enclosing loop.</p>
<p>Rebol 1.0 was properly tail recursive, so there was no special implementation of loops. They were ordinary functions that happened to call themselves. Non-standard iteration constructs could be created by the user by simply writing code that called itself. <code>break</code> and <code>continue</code> just surfaced the interpreter’s continuation to the user. As a consequence, loops in Rebol 1.0 were implemented completely in Rebol code but had signifcant interpreter overhead.</p>
<p>Rebol 2.0 and later are not properly tail recusive. As a consequence, special looping constructs are required to be written in C to support iteration. Common iteration constucts such as <code>for</code> and <code>while</code> are provided and do not have interpreter overhead, but if you want a non-standard iteration construct, there is no way to achieve it. You have to re-write your code to use one of the built-in iteration constructs or go without and risk blowing the stack.</p>
<p>My intent was to eventually write a compiler for Rebol. I wrote a prototype called Sherman that compiled to MIT-Scheme and was supported by the MIT-Scheme runtime library. Loops compiled with Sherman ran quickly as expected.</p>
</blockquote>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/joe-marshall-rebol-1-0-was-slow/2414">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/joe-marshall-rebol-1-0-was-slow/2414</link>
          <pubDate>Sat, 12 Apr 2025 18:42:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2414</guid>
          <source url="https://rebol.metaeducation.com/t/joe-marshall-rebol-1-0-was-slow/2414.rss">Joe Marshall: &quot;REBOL 1.0 Was Slow&quot;</source>
        </item>
        <item>
          <title>The %rebol.r Boot File From Rebol 1.0</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>While we don't have the C source code for Rebol 1.0, we do have the <code>%rebol.r</code> initialization file:</p>
<p><a href="https://gist.github.com/hostilefork/d6cfac90141688bd41b1b38a9a203b02" class="inline-onebox">Rebol 1.0.2 Initialization File (October 7, 1998) · GitHub</a></p>
<p>It would seem that if there were an ability to pack source code in with the executable, they would have done it...given that the Quick Start says <em>"do not modify <code>rebol.r</code>. If you accidentally do modify <code>rebol.r</code>, reinstall it."</em></p>
<p><em><strong>Hence this is probably the entire portion of Rebol 1.0 that's written in Rebol, e.g. the whole "Mezzanine".</strong></em></p>
<p>It says:</p>
<pre><code>;;; Note: Code in rebol.r runs in the system context.  The system
;;; context [has] all the built in bindings of the user context, but also
;;; has extra bindings to allow rebol to be bootstrapped.  Many of the 
;;; rebol functions available in user code are actually written in
;;; terms of simpler rebol natives, or in terms of special
;;; system natives.

;;; REBOL reserves the right to change the system natives at any time, 
;;; so you shouldn't depend on them for portable code.
</code></pre>
<h1><a name="p-7953-remarks-on-contents-in-no-particular-order-1" class="anchor" href="https://rebol.metaeducation.com#p-7953-remarks-on-contents-in-no-particular-order-1"></a>Remarks On Contents, In No Particular Order</h1>
<h2><a name="p-7953-func-definition-2" class="anchor" href="https://rebol.metaeducation.com#p-7953-func-definition-2"></a>FUNC Definition</h2>
<pre><code>func: make function! [args body] [make function! :args :body]
</code></pre>
<p>I found it a bit interesting that the <a href="https://rebol.metaeducation.com/t/rebol-1-0-2-users-guide/2340/6#p-7944-func-shortcut-5">User Guide talked about how FUNC was defined</a>, as an illustrative example, of an important thing for users to know about.  (It turns out there's a <a href="https://www.rebol.com/docs/core23/rebolcore-9.html">brief mention in the Rebol2 User's Guide</a>, but the Rebol 1.0 Guide writes it up twice, probably on accident.)</p>
<p>It's worth pointing out that there's big questions even in this seemingly simple definition.  Such as, should a function copy its arguments or body?  What should this do?</p>
<pre><code> body: [print "Hello"]
 foo: func [] body
 append body [print "Goodbye"]
 bar: func [] body
</code></pre>
<p>Does <strong>foo</strong> print just "Hello", or does it print "Hello" and "Goodbye"?</p>
<p>I don't yet know what Rebol1 did, but Rebol2's MAKE FUNCTION! would <em>not</em> copy the body.  So FUNC would do a deep copy as the "higher level" operator, before passing it to MAKE FUNCTION!.</p>
<p>But during bootstrap, it used a definition of FUNC that <em>didn't</em> copy the body, for performance reasons...which it switched over to the copying implementation at the end of boot.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/roll_eyes.png?v=14" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></p>
<p>Some version of these crazy optimizations are on the table for future Ren-C.</p>
<h2><a name="p-7953-print-prin-probe-3" class="anchor" href="https://rebol.metaeducation.com#p-7953-print-prin-probe-3"></a>PRINT, PRIN, PROBE</h2>
<pre><code>write-block-or-element:
    make function! [port element] [
             do
                if block? :element [:write-block] else [:form-to-port]
                :port
                :element]

write-block: func [port block] [    ; !!! needs work
    foreach element :block [form-to-port :port :element form-to-port :port " "]
]

prin: func [value] [
    if block? :value [write-block output-port reduce :value]
    else [form-to-port output-port :value]
    exit
]

print: func [value] [
    prin :value
    linefeed-port output-port
    exit
]

probe: func [value] [
     prin " PROBE --&gt; "
     send output-port :value
     linefeed-port output-port
     :value
 ]
</code></pre>
<p>Weird.  (and prints a space after every element, so you get a space at the end of the line vs. just delimited between, etc.)</p>
<p>At least one interesting aspect of this is to see the rigid "EXIT" at the end to make sure that PRIN and PRINT don't leak a result on accident.  Things like this feel like a vindication of Ren-C's <a href="https://rebol.metaeducation.com/t/implicit-execution-of-return-in-functions-bad/1656">requirement to use a RETURN</a> in order to give back a result from FUNC (but not LAMBDA).</p>
<h2><a name="p-7953-is-as-to-logic-4" class="anchor" href="https://rebol.metaeducation.com#p-7953-is-as-to-logic-4"></a>IS? as TO-LOGIC</h2>
<pre><code>is?: func [value] [not not :value]
</code></pre>
<p>This was called TRUE? in Rebol2, and I very much disliked the ambiguity of that vs. testing to see if a value was <code>= #[true]</code> the LOGIC! literal.</p>
<p>I wrote something up about <a href="http://blog.hostilefork.com/did-programming-opposite-of-not/">how DID could be the opposite of NOT</a> (which even goes together as DIDN'T for DID NOT).  But due to some various shades of meaning the current state is that it means THEN? and DIDN'T means ELSE? as prefix tests for the trigger conditions that would run THEN or ELSE.  It needs thought.</p>
<p>Anyway, interesting to see the choice of <code>IS?</code> here.</p>
<h2><a name="p-7953-a-recursive-folding-any-and-all-interrobang-5" class="anchor" href="https://rebol.metaeducation.com#p-7953-a-recursive-folding-any-and-all-interrobang-5"></a>A Recursive Folding ANY and ALL <img src="https://rebol.metaeducation.com/images/emoji/twitter/interrobang.png?v=14" title=":interrobang:" class="emoji" alt=":interrobang:" loading="lazy" width="20" height="20"></h2>
<pre><code>any: func [block] [
    eval-one block
        make function! [value rest] [
            if not value [any rest]
            else [value]
        ]
        make function! [value] [value]
]

all: func [block] [
    eval-one block
        make function! [value rest] [
            if is? value [all rest]
            else [false]
        ]
        make function! [value] [value]
]
</code></pre>
<p>So this is based on a function called EVAL-ONE, that takes a list and two functions.  It isn't defined in %rebol.r and isn't in the reference guide either.  But it's a right fold with early termination.</p>
<p>One can definitely imagine the Joe Marshall and Carl friction on this (<em>"why are you making all these usermode functions and calls, why not just use a loop?"</em>).</p>
<p>While there's a time and a place for this, I do think that if you are starting to push out into the usermode layers and finding this mentality is driving it...you're going to end up with something that isn't hitting the mark that Rebol was aiming at.</p>
<h2><a name="p-7953-why-is-pick-so-weird-6" class="anchor" href="https://rebol.metaeducation.com#p-7953-why-is-pick-so-weird-6"></a>Why Is PICK So Weird?</h2>
<pre><code>pick: func [series index] [
  do make function! [offset] [
    if (:offset + index? :series) &lt;= 1
        [none]
    else [do make function! [disp] [
            if (length? :disp) = 0 
               [none]
            else
               [&amp;peek :disp 0]
            ] skip :series if :offset &lt; 0 [:offset] else [:offset - 1]
         ]
    ] if logic? :index [if :index [1] else [2]] else [:index]
]
</code></pre>
<p>My guess here is that the pattern:</p>
<pre><code>do make function! [arg] [...code with arg...] value-for-arg
</code></pre>
<p>...is probably some holdover from before USE existed.  Or maybe USE is just an abstraction built on functions, and so it's done this way for optimization.  I dunno.</p>
<h2><a name="p-7953-poor-mans-export-7" class="anchor" href="https://rebol.metaeducation.com#p-7953-poor-mans-export-7"></a>Poor-Man's EXPORT</h2>
<pre><code>;;; These functions can be defined in terms of system natives that are
;;; not available in the user context.  Since we made the functions in 
;;; this context, the values of the words in the body are relative to
;;; this context.  But we place the functions in the user context so
;;; that the users can call them.  This allows the user to call the
;;; system natives through a defined API in a controlled manner.

user-functions: [
    dir? [file] [do func [info] [info/dir?] info? :file]
    size? [file] [do func [info] [info/size] info? :file]
    ...
]

foreach [name args body] user-functions [
    context-set user-context name func args body
]
</code></pre>
<p>So the comment says what's going on here, it's the attempt to push functions out into the user context when they're implemented in terms of functions that aren't available in the user context.  I'm not sure what's not available <em>(these implementations of DIR? and FILE? are based on INFO?, is that not exported to the user context?)</em></p>
<p>As far as I know, there's nothing like this in Rebol2 (there's no separate <code>user-context</code> from a <code>system-context</code>, is there?)  Interesting if that was something that disappeared in Rebol2 and came back in Rebol3.</p>
<h2><a name="p-7953-more-modularization-eval-reduce-takes-context-8" class="anchor" href="https://rebol.metaeducation.com#p-7953-more-modularization-eval-reduce-takes-context-8"></a>More Modularization: EVAL-REDUCE Takes Context</h2>
<pre><code>if not none? REBOL/script [
    if exists? REBOL/script [
        do make function! [] [
                top-level-continuation: :return
                if not REBOL/silent [
                        linefeed
                        prin "Loading script "
                        print REBOL/script]
                eval-reduce [do REBOL/script] user-context
                ]
        ]
    ]
</code></pre>
<p>Rebol1 seems to have been working with modularization ideas, because even during startup, the script you pass on the command line is run via something called EVAL-REDUCE that takes a parameter of where to do the evaluation.</p>
<p>So definitely a shame that Rebol2 seems to have moved away from the idea that evaluations needed to be done in a context.</p>
<h2><a name="p-7953-catch-is-defined-in-terms-of-catch-func-9" class="anchor" href="https://rebol.metaeducation.com#p-7953-catch-is-defined-in-terms-of-catch-func-9"></a>CATCH is defined in terms of CATCH-FUNC</h2>
<p>We know from the <code>user-functions</code> exporting that this:</p>
<pre><code>catch [word block] [catch-func func reduce [word] :block]
</code></pre>
<p>Is actually:</p>
<pre><code>catch: func [word block] [catch-func func reduce [word] :block]
</code></pre>
<p>Since there's no type checking, there's a <code>:BLOCK</code> GET-WORD! just to be sure it's not a function, I guess?  And then it's FUNC's job to do a check in its implementation.  But then, why not <code>:WORD</code> just to be sure WORD! isn't a function you're calling?  <em>(I like pointing this out, due to Ren-C's better answers to this issue...avoiding the "pox of documenting what you <strong>don't</strong> know")</em></p>
<p>So the idea of using functions as proxies for "virtual binding" is the <em>old way</em>.  What's going on here is that the block contains code that wants to be bound to whatever the throw construct is, and so that block is made the body of a function, that you call and pass the thing you want bound to that name as the argument.  (COLLECT+KEEP worked this way).  But it's undesirable, because it means you've lost the fluidity of having the currency of a structural BLOCK!...replaced with the black box of a function just because you wanted to bind something.</p>
<p>I'm pretty sure this CATCH mechanic (being called a "continuation") is stackful and can't do anything too bizarre, but I'd like an executable to try and ensure that.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/the-rebol-r-boot-file-from-rebol-1-0/2344">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/the-rebol-r-boot-file-from-rebol-1-0/2344</link>
          <pubDate>Sun, 01 Dec 2024 12:40:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2344</guid>
          <source url="https://rebol.metaeducation.com/t/the-rebol-r-boot-file-from-rebol-1-0/2344.rss">The %rebol.r Boot File From Rebol 1.0</source>
        </item>
        <item>
          <title>More History Mining: Rebol 3.0 Front Line Blog</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>I did a <a href="https://rebol.metaeducation.com/t/mining-history-for-anything-relevant-carls-rebol-blog/2197">quick full skim-through of Carl's Rebol Blog</a>, which split off into a second blog to discuss technical issues in R3-Alpha.</p>
<p>The second blog kicked off on April 6, 2006:</p>
<p><a href="http://www.rebol.net/r3blogs/0001.html">http://www.rebol.net/r3blogs/0001.html - <strong>"Welcome to the REBOL 3.0 Front Line..."</strong></a></p>
<p>It got up to 352 entries, tapping out on February 20, 2011 (which was prior to the open-sourcing):</p>
<p><a href="http://www.rebol.net/r3blogs/0352.html">http://www.rebol.net/r3blogs/0352.html - <strong>"Relative speeds from compiler optimizations"</strong></a></p>
<h2><a name="p-7338-again-im-skimming-it-for-anything-useful-1" class="anchor" href="https://rebol.metaeducation.com#p-7338-again-im-skimming-it-for-anything-useful-1"></a>Again, I'm Skimming It For Anything Useful</h2>
<p>However <strong>there is a lot more here to react to</strong>.  This could take days!</p>
<p>But I do think it's worth it, in part just to kind of help put together a big picture of where this project was and where it is now.</p>
<ul>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0002.html">Introduction of TYPESET!</a></strong> - Oh... Rebol2 didn't have them?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"> Well, neither does Ren-C... <a href="https://rebol.metaeducation.com/t/the-typeset-representation-problem/1300/12">typesets are replaced by type constraints</a>.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0003.html">MAKE Function Used To Be Variadic</a></strong> - I don't think I'm a fan of MAKE being variadic, but I have questioned the idea that <a href="https://rebol.metaeducation.com/t/debunking-the-arity-1-make/1591">there even need to <em>be</em> a MAKE FUNCTION!</a>, vs just having FUNC be an arity-2 native to start with.  This actually may be more prescient than I imagined, as there is no function datatype any longer... <a href="https://rebol.metaeducation.com/t/taking-action-on-function-vs-action/596/6">functions are just antiform FRAME!s</a>.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0006.html">To COPY or not COPY</a></strong> - I've sometimes critiqued Carl for seeming to have not confronted Rebol's actual core flaws head on.  But here he does...mentioning new users getting bitten by mutability -and- also the problems from mutable binding on a block being passed in to two different MAKE OBJECT! calls.  I've been satisfied with Ren-C's answer to the first issue by the <a href="https://rebol.metaeducation.com/t/value-vs-series-modification-bit-const-and-mutable/976">CONST implementation</a>--which has held up super well for years now.  And <a href="https://rebol.metaeducation.com/t/member-functions-in-the-era-of-pure-virtual-binding/2190">how object creation works</a> is undergoing a renaissance as I type this...no mutable binding (or even virtual blanket binding) required.</p>
<ul>
<li>It turns out there was a period in R3-Alpha where it was deep copying object specs <a href="http://www.rebol.net/r3blogs/0212.html">and people eventually complained</a>.  He says he was waiting to see if anyone noticed.  I do think it goes to show how little truly sophisticated Rebol code there was in practice, for people to not be able to tell sooner.</li>
</ul>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0007.html">Hot Errors Removed</a></strong> - He says <em>"These hot errors turned out to be overkill, and the benefit of error locality was offset by the difficulty of handling error values in general."</em>  But in effect this is another decision where Ren-C went more in a Rebol2 direction, <a href="https://rebol.metaeducation.com/t/fail-vs-return-raise-the-new-age-of-definitional-errors/1852">introducing a whole new antiform error design</a>.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0008.html">No Out Of Range Errors With FIRST, SECOND, etc.</a></strong> - Because an early development of Ren-C was to make FIRST, SECOND, etc. specializations of PICK... I'd always thought of them as being related.  Apparently at one time they were not.  In any case, the issue of range errors has been something that's crossed my mind... and I think I'd rather you have to say <strong><code>try fourth</code></strong> in order to tolerate out of range errors.  <a href="https://rebol.metaeducation.com/t/why-doesnt-third-1-2-trigger-a-range-check-error/1825/4">But the unification of PICK mechanics and TUPLE! selection, e.g. <strong><code>block.3</code></strong> is the same as <strong><code>pick block 3</code></strong> throws a wrench in it.</a>  This is still an open question.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0009.html">The 64-bit question</a></strong> - Wow, this is still not decided.  Ren-C still uses 32-bit indices (but stores them as <code>int_fast32_t</code> etc. so they'll use 64 bits of space if the registers make it faster).  It hasn't been an issue at the forefront.  I'm more interested in distinguishing in the code distinct datatypes for 1-based "Index" vs. 0-based "Offset" and making sure those are distinct types that are harder to mix up.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0010.html">JIT Binding</a></strong> - I've never heard of this and don't believe I saw any code for it.  On the surface it sounds like a relative of virtual binding, but it mutates the bindings in the block permanently and just sounds like something strange that never saw the light of day.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0011.html">Debug Hook</a></strong> - Here he talks about being able to essentially break into the console at the moment of a FAIL and inspect the stack.  One thing about historical Rebol is that because error trapping was frequent (e.g. ATTEMPT etc.) and being used as a programming style, you'd be getting a lot of false hits.  Ren-C's error handling model is such that if you handle an error that is generally done by reacting to a RAISE before it's actually promoted to a FAIL, so you would not be getting broken into the debugger constantly in the casual operation of your code.  We do need this.  I believe in my heart that I am being attentive to the needs of a debugger, but there some more giant issues to knock down first.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0012.html">CLOSURE functions</a></strong> - nope, <a href="https://rebol.metaeducation.com/t/relative-binding-and-frame-internals/1344">all functions are closure-semantics now</a>...without the crazy overhead of deep copying and binding the body of a function on every call!</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0013.html">ALIAS</a></strong> - Old ALIAS was removed long ago, because it was crazy.  I've written about <a href="https://rebol.metaeducation.com/t/the-return-of-alias/2129">reviving this idea more reasonably for modern times</a>.</p>
<ul>
<li>When <a href="http://www.rebol.net/r3blogs/0242.html">Carl wrote about his feelings about removing ALIAS</a>, he said <em>"Perhaps you've seen a change in my attitude... considering how long it's taking to get R3 out the door!"</em></li>
</ul>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0014.html">HASH!</a></strong> - I covered this in the other blog response, but the comments here might be useful.  <a href="http://www.rebol.net/r3blogs/0052.html">He talks about it in a later post as well.</a>  And then again, <a href="http://www.rebol.net/r3blogs/0054.html">offers some conclusions</a></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0015.html">Getting More Information From FOR-EACH</a></strong> - Asking for not just the item but the series position is one idea.  But coming up with ways to ask for more information in enumerations has been explored a number of places.  I've wanted to be able to enumerate and know things like "is this the last element" or "is this the first element" and be able to check that easily.  <span class="mention">@hiiamboris</span> has a fancy FOR-EACH that <a href="https://codeberg.org/hiiamboris/red-common/src/branch/master/new-each.red#L613">if you use a refinement in the spec it assumes you want the index at that position</a>, etc.  These are interesting ideas, so definitely want to look into them.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0016.html">OBJECT! Field Type Constraints</a></strong> - I've wondered about this.  It's definitely the case that languages which don't support type information wind up having another language layered on top of it that does (e.g. TypeScript).  But this was never in R3-Alpha, and hasn't been a priority.  I note <a href="http://www.rebol.net/r3blogs/0042.html">he also mentions this kind of type constraint in module specs.</a></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0017.html">! and !=</a></strong> - I was never a fan of adding <strong><code>!</code></strong> but we do support <strong><code>!=</code></strong> My biggest problem is that != and == are a pair in C, but not a pair in Rebol: != is paired with = for lax equality, and !== is paired with == for strict equality.  That makes it more confusing than anything, and I've meant to resolve this but it's another thing that's slipped.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0019.html">Considering Setters</a></strong> - I've mentioned in the past that Ren-C might have an answer to this, where you could use something like <strong><code>obj.member.</code></strong> to get at the "real" value bypassing the functions that assign them.  There's a big bag of tricks in Ren-C to implement these kinds of features, but seems there's always something more foundational to attack. R3-Alpha had no code for it, though <a href="https://www.red-lang.org/2014/12/050-objects-support.html">Red has ON-CHANGE* to react to assignments</a>.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0020.html">Bye Bye System Object?</a></strong> - The idea of making changes to Rebol to support multitasking the way it was being done was fundamentally flawed.  Needless to say the system object is still there (though <a href="https://rebol.metaeducation.com/t/system-object-vs-sys-context/1687">the "system context" is now SYSTEM.UTILITIES, or SYS.UTIL for short</a>.)</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0024.html">Should All Functions Return Values</a></strong> - Returning an UNSET! was a "value", just an ornery one historically, e.g. <strong><code>x: print "hello"</code></strong> was an error in Rebol2 and it remained one in R3-Alpha.  Though it has been debated, in Ren-C <a href="https://rebol.metaeducation.com/t/why-doesnt-print-return-void-or-vaporize-via-ghost/1466">PRINT returns TRASH</a> <em>(the moral equivalent of UNSET!)</em> and is legal to assign to a variable...it just unsets it.  The only things you can't (necessarily) assign are unstable antiforms like GHOST and VOID.</p>
<ul>
<li>On a later blog <a href="http://www.rebol.net/r3blogs/0207.html">there was a vote taken</a> about how functions treat UNSET!</li>
</ul>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0025.html">Leaky Functions</a></strong> - Not knowing this discussion was taking place in May 2006, <a href="https://rebol.metaeducation.com/t/how-attached-are-we-to-functions-return-last-result/1219">I made a similar argument here in September 2019</a>.  But there's <a href="https://rebol.metaeducation.com/t/implicit-execution-of-return-in-functions-bad/1656">an additional wrinkle that Ren-C has unique customizable per-function RETURN definitions</a>.  So it's pretty much a slam dunk to make the change, and introduce LAMBDA as both returning its body result and not having a RETURN.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0026.html">BIND Expands Contexts</a></strong> - Carl says <em>"A few of you will ask: why does this matter? The main reason is memory (something we are optimizing on R3.0). Why force allocation for "free" variables (module variables) that are never used?"</em>  Everything is different in Ren-C, though it does deal with <a href="https://rebol.metaeducation.com/t/caching-binding-lookup-and-attachment-binding/2128">something called "Attachment Binding"</a> where module variables actually are not allocated until they are used.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0029.html">Current Module</a></strong> - I actually thought he was speaking about there being something available in a module similar to a SELF or THIS, which seemed like a pretty good idea. But instead he's talking about running DO on something and it expanding the module you called it from.  Ren-C doesn't do this, DO runs its code isolated and can only give you back its final result.  You have to use IMPORT if you want to bring in new definitions to the module.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0032.html">UNICODE Support</a></strong> - It is interesting to see the considerations here, where it seems being able to load old LATIN-1 scripts was a concern.  No consideration of UTF-8 Everywhere is given for storage, <a href="https://rebol.metaeducation.com/t/realistically-migrating-rebol-to-utf8-everywhere/374">but that's what Ren-C does</a>.  He's wary of allowing UTF-8 in scripts themselves: <em>"Another possibility would be to allow UTF-8 encoding within strings in the source code. The advantage is that you will be able to view the strings in the appropriate editor. The disadvantage is that the script would contain a range of odd looking characters."</em>  I have thought that being able to limit what Unicode is permitted as a kind of security measure might be important, but there are higher priority issues.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0034.html">"Scant" Evaluation</a></strong> - FWIW, I do not really believe in the premise of scant evaluation.  I think if you do something like <strong><code>construct/only [foo: true bar: 'f]</code></strong> then you get FOO as the WORD! true and not the logic, and you deal with it with tests like <strong><code>== 'true</code></strong>.  I guess I have to see more examples, but I've only seen this in module headers and I prefer the you-get-what-you-see version.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0035.html">At a Class Crossroads</a></strong> - <a href="https://rebol.metaeducation.com/t/member-functions-in-the-era-of-pure-virtual-binding/2190">I just brought this post up recently.</a></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0045.html">Overwriting System Functions</a></strong> - He mentions the general problem that since modules import their own copy of system functions under a word in their own variable space, they won't see changes made to the variable in the system.  He talks about making some kind of "search and replace re-set" that would find all those imported stubs and fix them up.  I've been thinking in pursuing this through <a href="https://rebol.metaeducation.com/t/the-return-of-alias/2129">allowing variables to alias other variables</a>, so what you import starts out by default as an indirection and sees changes in the original.  But sSo far, if you want to hook a system function, in Ren-C, <a href="https://rebol.metaeducation.com/t/monitoring-a-single-function-with-enclose-and-hijack/425">you have the option of HIJACK-ing the identity of the function value itself</a></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0048.html">Free Variables in Modules</a></strong> - I dislike these but the codebase has not been retrofit to not use them.  Only LIB and SYS.UTIL are currently enforced to not be able to create them.  But I think you shouldn't be able to by default anywhere (e.g. "strict mode" in JavaScript).</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0049.html">Source Reflection Returning Unbound Copies</a></strong> - Again speaking somewhat from a security standpoint, Carl points out that if a module gives you a function you can get at its source code, and if you can get at its source code you can get at its bindings, and if you can get the bindings then you can reach the data.  I think being able to get the source code itself would be problematic in this adversarial situation--with or without the bindings.  It would be nice if some day people go over the language and make it secure, but I think we're well into the phase where making it good and interesting is far more important.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0050.html">Should a Module Be Loadable More Than Once</a></strong> - e.g. if you are using different versions as dependencies of other different modules.  Hmmm.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0057.html">Do We Dare Add ++ and --</a></strong> - Ren-C addresses this with ME and MY.  e.g. <strong><code>counter: me + 1</code></strong>, <strong><code>counter: me * 10</code></strong>.  It fetches the value of the SET-WORD! on the left and substitutes that for ME.  It's a lot nicer, and saves ++ and -- for weird symbolic purposes.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0059.html">Deprecating CONTEXT</a></strong> - He's opposed to it because CONTEXT creates an OBJECT!, but there's no such thing as a CONTEXT! datatype.  I'm opposed to it based on it being a noun.  I'm thinking WRAP might be best applied to what this does.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0063.html">How Best to Blockify?</a></strong> - He proposes BLOCKIZE for what I call ENBLOCK (e.g. envelope/enclose in a block).  BLOCKIFY is something where if what you have in your hand isn't already a block, it will wrap it it one. <img src="https://rebol.metaeducation.com/images/emoji/twitter/man_shrugging.png?v=14" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0064.html">DIR?</a></strong> - I came to be of the belief that all directories must end in a slash, and we enforce this systemically.  Hence DIR? is just a question of whether a FILE! ends in a slash or not.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0069.html">PORT! Redesign Objectives</a></strong> - This probably belongs in the <a href="https://rebol.metaeducation.com/t/what-is-a-port/617">What is a PORT! discussion</a>.  More to add there:</p>
<ul>
<li><a href="http://www.rebol.net/r3blogs/0070.html">problem with DELETE</a></li>
<li><a href="http://www.rebol.net/r3blogs/0071.html">problem with RENAME</a></li>
<li><a href="http://www.rebol.net/r3blogs/0128.html">SKIP and SEEK</a></li>
<li><a href="http://www.rebol.net/r3blogs/0130.html">OSI Model and PORT!</a></li>
</ul>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0078.html">Lexical Exceptions in LOAD</a></strong> - I'm against finding a way to load e.g. <strong><code>1st</code></strong>.  Ren-C gives you <strong><code>1.st</code></strong> if you want it.  This isn't a good investment of energy.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0084.html">IO Devices in R3</a></strong> - And all of <a href="http://www.rebol.net/r3blogs/0087.html">the Device Model</a> is happily gone. <a href="https://rebol.metaeducation.com/t/libuv-integration-has-started-an-i-o-renaissance/1694">We use libUV now</a>, and it's a lot better while still being standard C, cross-platform with many more features, and maintained by other people.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0085.html">None Propagation</a></strong> - <a href="https://rebol.metaeducation.com/t/the-void-in-null-out-protocol/1880">Ren-C has VOID-in-NULL-out</a> and it's working splendidly.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0086.html">Explicit Evaluation Terminator</a></strong> - After a failed attempt to convince people that vertical bar <strong><code>|</code></strong> would be BAR! and serve this purpose, <a href="https://rebol.metaeducation.com/t/the-language-worlds-weirdest-comma-mechanic/1387">we have COMMA!</a>, and it has turned out to be a lot better.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0091.html">R3-Alpha Released to Select Developers</a></strong> - This was June 2007.  <a href="http://www.rebol.net/r3blogs/0094.html">The Beta was expected on July 15, 2007, then delayed (?!)</a>  Well there never was a Beta.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0093.html">Changes in MAKE FUNCTION!</a></strong> - Related to this, I just wrote a sort of new <a href="https://rebol.metaeducation.com/t/make-should-be-using-dialected-constructors/2196">Dialected MAKE Manifesto</a></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0097.html">WITH and IN</a></strong> - I do admit to liking the <strong><code>do in context [...]</code></strong> construct.  The IN construct is completely virtual binding now.  BIND is still around but uses have been dropping as more and more of the codebase is able to work with virtual binds on top of largely unbound blocks of code, "viewed" several different ways without touching the binding bits.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0100.html">UNSET! As An Argument</a></strong> - R3-Alpha got fairly permissive, e.g. allowing comparisons of UNSET! to other values.  I've brought up that I think it <a href="https://rebol.metaeducation.com/t/the-truthiness-of-trash/2180">may be a mistake to allow things like comparisons to take TRASH</a>, and offered justifications for that.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0104.html">Modules Ripping Carl Apart</a></strong> - <em>"I have to admit that so far modules have been, well, too much like taming a tiger. And, so far, the tiger has been winning... often, ripping me to pieces. The tiger is the main reason R3 is running late. Yes, blame the tiger. I've got many scars."</em></p>
<ul>
<li>In 2010 <a href="http://www.rebol.net/r3blogs/0339.html">he blamed them again for another release delay</a>: <em>"Battling the Module Monster, Again"</em></li>
</ul>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0106.html">Admission that Unicode Was Harder Than Thought</a></strong> - <em>" So, Unicode is the focus of our current development, and it must be clearly stated, <em>this is a non-trivial project</em>. Our goal is to have it ready for initial testing by the end of the month. I'll admit that we under-estimated the magnitude of the Unicode project..."</em></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0107.html">R3 Alpha Public Release</a></strong> - This was in January 2008.  My first encounter with the Rebol language was <a href="http://blog.hostilefork.com/computer-languages-as-artistic-medium/">approximately April 2008</a>, and so I didn't use Rebol2 at all... believing from the community that Rebol3 was the hot new thing.  I didn't realize it had only become public that recently, because everyone else who was involved and talking about it was on the inside track I guess.  I don't know if this timing makes me fortunate or unfortunate, but it certainly explains why I never got attached to a Rebol GUI.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0108.html">ISSUE! as a WORD! datatype</a></strong> - I disagree with this decision (as many did), and in Ren-C it is an immutable textual type..used as the implementation for characters as well (characters are just single-character ISSUE!s).  I've proposed renaming these to TOKEN!.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0111.html">BITSET!s</a></strong> - BITSET! is terribly inefficient and buggy, if you try to do things like XOR a negated bitset with another <a href="http://www.rebol.net/r3blogs/0114.html">none of it works right</a>.  If your bitset is sparse (e.g. representing a Unicode character set, as one might do) then it will quickly consume megabytes.  I did some work with <a href="https://roaringbitmap.org/about/">Roaring Bitsets</a> and linked them up as the implementation for bitsets, which worked well but I didn't feel like maintaining the dependency given higher priorities.  But that branch is still around.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0112.html">The ZERO? Question</a></strong> - I hadn't thought of this.  POSITIVE? rejects non-numbers, NEGATIVE? as well, but ZERO? lets you test series as a simple synonym for <code>= 0</code> but then also considers 0:00 to be ZERO?  Ugh.  I like TRASH? (~) as a placeholder better than zero for many reasons, so the single-character-zero-filler argument doesn't apply.  I think ZERO? should apply to numbers only and error on other types.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0113.html">STRING! is not BINARY!</a></strong> - Because R3-Alpha used variable sized encoding for strings inside the system, it couldn't offer you a usefully invariant binary view of strings.  Ren-C can do it <a href="https://rebol.metaeducation.com/t/realistically-migrating-rebol-to-utf8-everywhere/374">because it uses UTF-8 Everywhere</a>, and if you're looking at a BINARY! alias of a TEXT! you can make modifications only if that atomic modification leaves the result as valid UTF-8.  You can also alias WORD!s as TEXT! or as BINARY!, but it will be an immutable view.  The benefits inside the system of sticking to one string encoding are innumerable and well worth all the work.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0115.html">Script Error</a></strong> - Hadn't really thought about it but he has a point here.  Something to consider in an ERROR! redesign, if such a design ever happens.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0127.html">Pruning Down READ and WRITE</a></strong> - Despite <a href="http://www.rebol.net/r3blogs/0109.html">earlier assurances that READ and WRITE give BINARY! and it's LOAD that does the fancy work</a>, this shows some of the confusion slipping in about what READ is...and that's what provoked my own confusion at things like READ/STRING and READ/LINES and READ/AS.  Red has these refinements too.  It's all quite confusing, but Ren-C has the advantage of letting you do <strong><code>as text! read %some-file.txt</code></strong> which gives you a mutable alias over the UTF-8 data with no loss of efficiency.  I haven't killed off READ/STRING or READ/LINES but now I feel I really should... that's LOAD's business to have some convenient syntax for.  (Dialected? <strong><code>load %file.r</code></strong> or <strong><code>load [&lt;text-lines&gt; %file.txt]</code></strong>)</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0135.html">VID Expression Optimization</a></strong> - So this is the first time I've felt there was something to comment on in a GUI post, since it's dialect philosophy.  <a href="https://rebol.metaeducation.com/t/vid-expression-optimization/2202">I started a thread on it</a></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0137.html">MAP! Indexing</a></strong> - Again, this is <a href="https://rebol.metaeducation.com/t/how-much-determinism-should-be-pursued/2057/3">relevant to the determinism I've been discussing</a>, and it's interesting to see there was questioning about it.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0138.html">Multicontext Variable Lookup</a></strong> - Like it or not, this is what we have with Virtual Binding.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0139.html">Find on OBJECT!</a></strong> - He mentions using IN.  But with the binding logic of virtual binding, IN has to return the original item unbound if it wasn't found in the context... so it doesn't give a good answer.  Ren-C uses HAS for this (null if a word not present, vs. the unbound word) and disallows FIND on objects.  Use HAS.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0141.html">RFC: func-local, funclo, funco, funo, funx</a></strong> - Wow, I didn't know the name considerations were so bad...before FUNCTION was chosen.  Ren-C has virtually-bound LET and has dismissed with the bad idea of locals-gathering functions that gather all SET-WORD! as variables.  <a href="https://rebol.metaeducation.com/t/rethinking-auto-gathered-set-word-locals/1150">That is not coherent...</a> SET-WORD!s are used in places where they should not create variables (object keys, other dialects).  So this idea is dead and will only be resurrected as a toy for code golf competitions or similar.  And <a href="https://rebol.metaeducation.com/t/abbreviations-as-synonyms/1211">FUNC and FUNCTION are slated to be synonyms</a>, as all abbreviations are intended to be.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0142.html">Data Conversions that MAKE Sense</a></strong> - This definitely needs to be thought about, but also to eliminate needless duplication between TO and MAKE.  <a href="https://rebol.metaeducation.com/t/hacking-away-on-the-to-and-make-matrix/649">I've written about the differences and the possible rules.</a></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0155.html">PARSE Project</a></strong> - While a lot of this has gone offline, I did <a href="https://trello.com/b/zt7KvVSl/rebol-parse-project-the-trello">preserve the remarks from the wiki on a Trello board</a> (that seriously needs updating, now!).  Sigh.  Hurry up AI, I need you to edit all this for me.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/cgi-bin/r3blog.r?view=0165#comments">Angry Comments About A30 Not-Quite-Public Release</a></strong> - Here it's January 2009.  Rebol 3.0 was certainly positioned in a promise-making and not-delivering way, and Red followed that pattern.  Part of what keeps Ren-C from being completely exhausting is not doing that.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0169.html">Inklings of REWORD</a></strong> - It seems the REWORD we have today started with this discussion, right on the heels of the previous feedback also in January 2009.  The design, authorship, and testing of these things simply add up to so much time... it should have been obvious to anyone reading this at the time this would never be finished.  (I wasn't reading it, I didn't get involved until Rebol became open source in 2012...)</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0173.html">PICKing Negatives and Zero</a></strong> - Have to admit I haven't thought about this at all in years.  Ren-C reverted to the Rebol2 behavior.  In practice, I don't think it comes up enough for people to care.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0178.html">Weird ASSERT/TYPE Refinement</a></strong> - I didn't like it and didn't see the point, so I killed /TYPE.  Ren-C lets you do <strong>ensure object! spec</strong> and <strong>ensure [~null~ tuple!] spec.version</strong> ... you can do your own FOR-EACH enumeration over a block of type/value pairs if you have enough of them to matter.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0179.html">Isolated Namespaces In Modules</a></strong> - <a href="https://rebol.metaeducation.com/t/the-real-story-about-user-and-lib-contexts/764">Turning on isolation was horribly bloated</a>, but Ren-C has <a href="https://rebol.metaeducation.com/t/a-quantum-leap-in-testing-isolating-into-contexts/1680">solved it efficiently</a> and makes it the default for all modules.</p>
<ul>
<li>
<p>May I just say that the code for all of the module stuff--especially isolation--<a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/c-frame.c#L679">is convoluted and buggy</a> with equally buggy usermode portions, and it literally made me give up trying to use my 2018 bootstrap executable for the FENCE! conversion.  I had to go gut the module system to make enough simplifications that it would work at all, and am still dealing with the issues of deploying new cross platform binaries that will serve for at least another year or two.</p>
</li>
<li>
<p>If you're wondering "why not just use a modern Ren-C for bootstrap" the answer is that in most areas unrelated to modules--e.g. places where I worked on hardening it--I can rely on it more than the dark corners of modern executables.  Bootstrap is rather demanding.  Also right now has various in flux instabilities and bad performance.</p>
</li>
</ul>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0184.html">DECODE and ENCODE</a></strong> - I never really got the split in responsibilities between ports and codecs.  We're told that if you want to do streaming hash calculations in chunks on large files to use a PORT! to do it.  But then DECODE and ENCODE aren't light wrappers over a chunking port but rather some very naive functions.  Trivial design that was used as an excuse to make some more weird monolithic C code... there's no architecture, it's just a function table.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0186.html">Read Only Strings, Blocks, and Objects</a></strong> - So apparently PROTECT came along in 2019.  The interesting thing about Rebol being a C codebase with limited type checking is that it was scout's honor for all the code in the system to remember to check the protection bits before making a modification.  Ren-C can build as C++, and <a href="https://rebol.metaeducation.com/t/value-vs-series-modification-bit-const-and-mutable/976/5">enforces the checking of mutability bits before changes with the type system</a>...so if anyone doesn't use a check routine to transition from const to mutable in the C, then when building with C++ that will be caught.  I'm quite proud of that...and it has been working without bugs enforcing CONST as well as PROTECT (and evaluator holds, etc.)</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0189.html">PROTECT/HIDE</a></strong> - While I thought this was kind of cool when I first saw an example, it turns out that this is another features that was added on a whim without a systemic review of the implications.  But for this case I haven't come up with a way to really make it much other than the scout's honor I describe from R3-Alpha's basic protection bit.  I've not killed the feature because hidden bits are used to various effects in things like specializing fields out of frames, but I'm really not sure if it makes sense in other cases.</p>
</li>
</ul>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/more-history-mining-rebol-3-0-front-line-blog/2199">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/more-history-mining-rebol-3-0-front-line-blog/2199</link>
          <pubDate>Tue, 20 Aug 2024 19:49:55 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2199</guid>
          <source url="https://rebol.metaeducation.com/t/more-history-mining-rebol-3-0-front-line-blog/2199.rss">More History Mining: Rebol 3.0 Front Line Blog</source>
        </item>
        <item>
          <title>Mining History For Anything Relevant: Carl&#39;s Rebol Blog</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>Carl maintained two Rebol blogs.  One was specifically for <a href="https://rebol.metaeducation.com/t/more-history-mining-rebol-3-0-front-line-blog/2199">Rebol 3.0 development issues</a>.  But the other was for more general topics, essays, thoughts.</p>
<p>Here is the first post from February 5, 2008:</p>
<p><a href="https://www.rebol.com/article/0001.html">https://www.rebol.com/article/0001.html : <strong>"Ok, Let's Try It"</strong></a></p>
<p>That blog apparently made it up to 554 posts, stalling out on February 25, 2018:</p>
<p><a href="https://www.rebol.com/article/0554.html">https://www.rebol.com/article/0554.html : <strong>Website Update, New Projects, Fresh Thoughts"</strong></a></p>
<p>But it had been stalling out long before that (post <span class="hashtag-raw">#553</span> was in January of 2016 as part of a little spurt of notes.)</p>
<h2><a name="p-7334-i-decided-to-skim-through-it-for-anything-useful-1" class="anchor" href="https://rebol.metaeducation.com#p-7334-i-decided-to-skim-through-it-for-anything-useful-1"></a>I Decided To Skim Through It For Anything Useful</h2>
<p>It's a lot of material, but many of them are short (or obviously not relevant to Ren-C's interests).  I'm in a mode of feeling like I'm seeing answers to old questions through the lens of what Ren-C can do today, so I thought I'd flip through them to see if anything caught my attention.</p>
<p>Here are some notes on any thoughts triggered...</p>
<ul>
<li>
<p><strong><a href="https://www.rebol.com/article/0004.html">IO Redirection</a></strong> - Rebol2 and R3-Alpha had many quirks and broken aspects in IO redirection.  Ren-C actually does a pretty good job and <a href="https://github.com/metaeducation/ren-c-stdio/blob/main/.github/workflows/test-stdio.yml">has tests of it</a> in various shells.  At least a bit in part due to my hassling them, PowerShell actually changed the way they did IO to accommodate making binary redirection accommodate us (<a href="https://github.com/PowerShell/PowerShell/issues/1908">many other people wanted it too</a>).</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0015.html">MakeDoc</a></strong> - I have never touched Rebol's MakeDoc, and pretty much only use MarkDown.  Maybe someone who uses MakeDoc needs to write a post about it and if it matters at all in the modern ecology of such standards.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0020.html">HASH!</a></strong> - The predecessor to Rebol's MAP! was a sort of optimization layer on top of blocks, where you still could enumerate them and experience them as blocks.  But people insisted that a conventional key/value store which was dissociated from any order or enumeration structure was better.  But in light of some recent findings about <a href="https://rebol.metaeducation.com/t/how-much-determinism-should-be-pursued/2057/3">Python's Dict becoming order-preserving and deterministic</a>, I wonder if MAP! was a wrong turn after all.  Hmm.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0050.html">Async Ports</a></strong> - Oh my, the <a href="https://rebol.metaeducation.com/t/semantics-of-read-and-tcp-streams-past-and-future/1733/2">beginnings of the nightmare</a>.  Thankfully that's over.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0059.html">NEW-LINE</a></strong> - Naming a function NEW-LINE when NEWLINE is a character constant is pretty confusing.  Ren-C has made a lot of progress here (including controlling terminal newlines in blocks) but never really came up with a good answer for how to better define functions to tweak the meta-formatting information.  There's also a lot to be said about <a href="https://rebol.metaeducation.com/t/testing-generic-tuple-and-path-structuring/1353">newline marker significance in dialects</a>.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0059.html">Mixed Dialects and REDUCE/ONLY</a></strong> - The idea of providing constructs that are more careful about executing code is something I've gone after, but more in terms of primitives like GET and SET not running code in GROUP!s in paths or tuples unless you say so.  It's good to see Carl was thinking about "security" (or clarity).  Ren-C sort of <a href="https://rebol.metaeducation.com/t/make-your-own-safety/1118">drifted away from thinking there's much hope in guessing what people will care about</a>.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0102.html">No Style Guide</a></strong> and <strong><a href="https://www.rebol.com/article/0103.html">Deep Lake</a></strong> - The idea that you use the style that fits you is very critical I think.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0104.html">Context-Dependent Language</a></strong> - Hadn't seen this particular post before.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0108.html">Was XML Flawed From The Start</a></strong> - Yes.  I didn't know it but there is apparently a <a href="https://www.rebol.com/article/0110.html">follow-up post</a>.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0126.html">Building in a DIFF Function</a></strong> - Hmmm.  Not necessarily the worst idea to have one... dialected diff sounds interesting.  But should probably be a module or extension.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0130.html">Rebol Internationalization</a></strong> - In the past I've said it might be interesting to "skin" Rebol in usermode to be in other languages.  Spanish or Chinese PARSE dialect, etc.  UPARSE would let you map the combinators to different words.  It's still interesting, but I think when it comes to stuff like internationalizing messages and error strings... it's probably time to just assume AI will be good enough for that.  I don't think this project is going to do any localization in my lifetime.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0144.html">Modules</a></strong> - <em>"I should mention that modules are the main point of the REBOL 3.0 version."</em> ... so unfortunate they <a href="https://rebol.metaeducation.com/t/the-real-story-about-user-and-lib-contexts/764">more or less did not work at all</a>.  Ren-C has made great progress and things are much more promising, but there sure is a long way to go on the vision of a completely usermode module system that people can customize or override at will.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0153.html">SET and GET on Objects</a></strong> - I dropped this feature, but it does raise another question of determinism in field ordering, as to whether you should even be able to do such a thing.  It seems to me someone needs to lay down the fundamental philosophy about basic issues that persist in Redbols today, like:</p>
<pre><code>red&gt;&gt; obj1: make object! [a: 10 b: 20]
== make object! [
    a: 10
    b: 20
]

red&gt;&gt; obj2: make object! [b: 20 a: 10]
== make object! [
    b: 20
    a: 10
]

red&gt;&gt; obj1 = obj2
== false
</code></pre>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0177.html">Consistency in POKE</a></strong> - Aaah, this reminds me of all the <a href="https://rebol.metaeducation.com/t/get-set-vs-pick-poke-whats-the-difference/1719">"what is picking and poking and setting and getting"</a> semantics issues.  The code is going to need to be revisited for the plan of <strong>obj.method</strong> passing the OBJ to the method as a "coupling".  It was a nightmare to work on, but maybe enough time has passed to where going in and cleaning it up will be "fun".</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0188.html">PARSE words are "commands"?</a></strong> - Hm.  Well, I like "combinators".  In any case, I don't know that I've used the word "command" much if ever.  Should I?</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0206.html">Is Rebol a Pure Functional Language?</a></strong> - No, but it does remind me that I was thinking of making a PURE designator where any function marked pure could only call other pure functions.  Could be a fun experiment.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0214.html">Rebcode</a></strong> - I don't think I ever heard of this (or if I did, confused it with the binary storage REBBIN format or something).  If I had infinite time I'd tinker with something like putting Red/System in the WebAssembly build and generating Wasm, but I don't.  It seems clear in retrospect that this tendency to drift off from language design issues really burned up RebolTech's time.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0229.html">BIND?</a></strong> - While Ren-C's Pure Virtual Binding is humming along running most code, being able to inquire and reflect the compounding environments is going to need a lot of deeper answers than this.  And I still don't know exactly what to do about <a href="https://rebol.metaeducation.com/t/caching-binding-lookup-and-attachment-binding/2128">attached words</a>...they're just there to keep the ship afloat for the moment.  But worth pointing out that Rebol was pretty far along before it had the ability to query binding (AFAIK Red still doesn't have it, there's no BIND?)</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0233.html">Extending Objects</a></strong> - Thought is needed on this.  It should definitely be a different operation than APPEND.  My feeling is that APPEND on an OBJECT! should be reserved for interacting with that object's concept of what APPEND means (but does that mean it can't have its own idea of what EXTEND means?)</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0278.html">Checksum Ports</a></strong> - We have all the encryption code to do this but understanding what PORT!s are supposed to be keeps this on a very far back burner.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0284.html">RebolTech Priorities</a></strong> - Interesting in light of <a href="https://rebol.metaeducation.com/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179">my own writing on the topic</a>.  It's a different era, where people have so many free tools to choose from... where the <em>only</em> relevance I see is whether the language design offers something truly unique and notable.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0288.html">Source For Carl's Blog</a></strong> - I didn't know he'd published it.  The link is dead, but the Internet Archive has it: <strong><a href="https://web.archive.org/web/20061218060625/http://www.rebol.net/cgi-bin/blog.r?get-source=1"><code>blog.r</code></a></strong>.  I never used the CGI facilities but it's interesting to see that it is indeed just one long single file.  (I'm idly curious about how this would compare to someone trying to do the same thing in PHP.)</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0294.html">Anthropomorphizing Errors</a></strong> - Interesting topic.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0316.html">Two Year Rebol Blog Anniversary</a></strong> - In two years from 2008-2010 the Rebol blog got to 316 out of its 554 total posts.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0338.html">FOLLOW was the original name of ALSO</a></strong> - Who knew.  <a href="https://rebol.metaeducation.com/t/infixing-also-stylizing-it-after-then-and-else/402">Either way, I don't like it.</a></p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0367.html">PICK with LOGIC!</a></strong> - I never really cared for this.  It's not obvious to me if true is the first item or the second one.  Ren-C has <a href="https://rebol.metaeducation.com/t/soft-quoted-branching-light-elegant-fast/1020">soft-quoted branching</a>, so you can do <strong><code>either (cond) 'this 'that</code></strong> and I find it a lot clearer.  Now that logic is an antiform, it means the whole picking system gets messed up by needing to support antiforms.  Not sure why I didn't kill this off yet...</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0372.html">Reacting to Complaints About Not Communicating</a></strong> - Seems the natives are getting restless around August 2008.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0374.html">Rebol: Not For Everyone</a></strong> - <a href="https://rebol.metaeducation.com/t/rebols-target-market-newbies-experts-or-other/581">I wrote a bit here about this post in 2018</a>.  Should probably see if I have any updated thoughts now that I know more.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0377.html">The GUI: Harder Than It Seems</a></strong> - I've often been puzzled by the obsession the Rebol community has on the cross-platform GUI.  Here we see an admission from Carl that it's harder than it seemed and eating up time.  A prelude to today, where Red seems to drag along indefinitely with it.  I'm pretty well-versed in Rebol design points, yet I find what they're making to largely be gibberish.  HTML and CSS are pervasive, have been modernized with time, and I don't really think the GUI work has shown to be markedly ahead for any non-trivial task.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/man_shrugging.png?v=14" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0382.html">The suffix of Rebol Files</a></strong> - After having campaigned a bit on the side of saying Rebol should accept it doesn't own the "R" language term and use <strong><code>.reb</code></strong> <a href="https://rebol.metaeducation.com/t/revisiting-the-riddle-of-the-r/1664">I changed my mind.</a>  I think it should be <strong><code>.r</code></strong>.  The reason I haven't gone around renaming things is because the disruption it would create doesn't make much sense to do until there's a good reason to go around and muck with all the file organization.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0388.html">Infix DEFAULT Before Infix existed</a></strong> - I didn't know this had been considered, much less that you do it in Rebol2.  That's surprising.  The idea of making DEFAULT a dialect taking a BLOCK! is actually not something I had considered, and I'm not completely sure I hate.  You get advantages in the sense that you could potentially default more than one thing...<a href="https://rebol.metaeducation.com/t/default-as-dialect/2198">I'm going to have to think about it.</a></p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0459.html">Announcement of PowerMezz</a></strong> - <a class="mention" href="https://rebol.metaeducation.com/u/rgchris">@rgchris</a> had at one time undertaken a porting of this to Rebol3, and don't really remember what was in it.  I didn't look too closely.  But it could be a very good place to look for challenging problems in binding and parsing to ask <em>"has Ren-C raised the bar so people trying to do these things can do them more clearly"</em>.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0467.html">CALL/SHOW</a></strong> - Never saw this.  I do think that for a GUI program, /SHOW should be the default.  Worth looking at.  I notice that <a href="https://github.com/microsoft/WSL/issues/6565"><code>call "explorer"</code> returns an exit code of 1</a>, which is now <a href="https://rebol.metaeducation.com/t/making-call-raise-a-definitional-error-for-bad-exit-codes/2068">reported by CALL unless you do CALL/RELAX</a> (or intercept it with EXCEPT).</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0489.html">LIB and SYS</a></strong> - Since I started using Rebol only after R3-Alpha, I'm often surprised to find things that you can't do in Rebol2... such as get the original version of a function if you overwrite it.  I gather that to this day, in Red, if you say <code>append: func [] [print "Hi"]</code> without saving the old-append there's no way to get it back!</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0497.html">Fight Software Complexity Pollution</a></strong> - I cite this one a lot, I should cache it here on the forum and add some comments.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0508.html">Common PARSE Patterns</a></strong> - Link is broken, and internet archive is down, look these up when it comes back.  (Ok it's back and... <a href="https://web.archive.org/web/20110228053052/http://www.rebol.net/wiki/Common_Parse_Patterns">well, not much there</a>).</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0509.html">Simplicity Defined</a></strong> - While I respect that Carl certainly has thrown some unique vision into the mix of computing, no one knows the R3-Alpha code better than I do, and so sometimes these posts ring a bit hollow.  It may have been easier to ramble from on high before the code was open sourced, but really R3-Alpha is every bit the ball of mud he is critiquing!  But it is certainly the case that in its ideal form, Rebol is a rich-enough substrate for expressing one's domain knowledge simply... whereas other mediums (like say, bash) just are unsuitable...but people use them out of expedience or pragmatism.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0510.html">Carl Announces Giving Up</a></strong> - August 2012 solicits opinions on the future, stating: <em>"I also need to tell you that I don't have much time to help out with whatever the REBOL future may be."</em></p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0511.html">Open-Sourcing Announcement</a></strong> - There was a bunch of debate over licensing, I said use the LGPL, it was made Apache to "appeal to more contributors".  Yeah, right.  <a href="https://rebol.metaeducation.com/t/ren-c-license-changed-to-lgpl-3-0/1342">Ren-C has been LGPL since September 2020</a></p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0515.html">Rebol C Documentation Style</a></strong> - Comments in R3-Alpha weren't particularly copious.  Ren-C has tons of them.  I'm pretty pleased with how they're done, and have been adopting a kind of "headnote" style where I don't mix too much commenting directly into the code, but just tack on the end of the line <strong><code>// don't accept groups [3]</code></strong> and then have a section above somewhere that says <code>// 3. The reason that we don't accept groups here is...</code>  Of course, Ren-C has much improved embedding of native function specs directly in the comments above natives as well.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0518.html">"We Need a New Rebol Forum"</a></strong> - I have to wonder how things would have gone if we'd used Discourse earlier.  This question was asked in November of 2012, and Discourse was released in August 2014.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0522.html">Comparing Rebol and JSON</a></strong> - This is interesting because he is using BLOCK! for both arrays and key/value stores.  He glosses over what that winds up meaning for systems interpreting the data.  I'm suspicious that it is insignificant, <a href="https://rebol.metaeducation.com/t/json-envy-serialization-dialect-in-rebol/2140">I wrote a bit about this</a>.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0525.html">Calling REBOL, Rebol</a></strong> - Yes.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0537.html">Rebol Conference, Montreal, 2013</a></strong> - If not for me recording and editing the videos, there wouldn't be much left of it!</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0543.html">FUNCTION and CLOSURE</a></strong> - There's no more CLOSURE in Ren-C <a href="https://rebol.metaeducation.com/t/relative-binding-and-frame-internals/1344">because all the good parts of it are subsumed into every function</a> <em>(at reasonable cost)</em>.  Now I worry over LETs.  Kind of funny to think how much I take for granted these days...</p>
</li>
</ul>
<hr>
<h2><a name="p-7334-and-thats-about-it-2" class="anchor" href="https://rebol.metaeducation.com#p-7334-and-thats-about-it-2"></a>And That's About It...</h2>
<p>So that took me a few hours, and feels worth it to have done so.  He started a separate Rebol 3.0 tech blog, and after that it was mostly philosophy and administrivia posts.  I'll do a similar survey of the tech blog.</p>
<p>While it seems to me the GUI is the killer of Redbols, it probably is what allowed Rebol2 to get the popularity that it did.  Probably they shouldn't have made any changes to VID or the graphics.  I think there's this tendency to want to go deep and burn time on grid controls or whatever the "one missing thing" is, when if an application is truly of any sophistication then it's always going to run up against the limit of what Rebol can offer.</p>
<hr>
<p>I'll do some posts on the follow-up items here at some point.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/mining-history-for-anything-relevant-carls-rebol-blog/2197">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/mining-history-for-anything-relevant-carls-rebol-blog/2197</link>
          <pubDate>Tue, 20 Aug 2024 11:01:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2197</guid>
          <source url="https://rebol.metaeducation.com/t/mining-history-for-anything-relevant-carls-rebol-blog/2197.rss">Mining History For Anything Relevant: Carl&#39;s Rebol Blog</source>
        </item>
        <item>
          <title>The Fate of Redbol Emulation In A Mostly Unbound World</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>100% Emulation of historical Rebol was always going to be impossible.  But if we go forward with the model that most code is unbound, that's going to break even code that didn't do anything sophisticated with binding.  Not only will any values you PICK out of a block or iterate over be unbound, but even basic quoting won't be bound:</p>
<p>e.g. this won't work:</p>
<pre><code>rebol2&gt;&gt; thing: 10

rebol2&gt;&gt; foo: func [w [word!]] [return get w]

rebol2&gt;&gt; foo 'thing
== 10
</code></pre>
<p>I had a problem with this in emulating my very, very old whitespace interpreter.  It <a href="https://github.com/hostilefork/rebol-whitespacers/blob/1d69ea0e79e60ba79fe680d3af657d0823dcbe9e/historical/whitespace-old.reb#L595">quoted ADD</a> and then <a href="https://github.com/hostilefork/rebol-whitespacers/blob/1d69ea0e79e60ba79fe680d3af657d0823dcbe9e/historical/whitespace-old.reb#L424">put it in a block</a>, expecting a DO of that block to run the ADD it meant.</p>
<h2><a name="p-7019-simulating-waves-of-binding-probably-impractical-1" class="anchor" href="https://rebol.metaeducation.com#p-7019-simulating-waves-of-binding-probably-impractical-1"></a>Simulating Waves of Binding (Probably?) Impractical</h2>
<p>You might think that so long as every word can still hold a binding, then historical behavior could be simulated by manually binding everything.</p>
<p>When a module loads, you could walk through it binding every word.  Then when a function runs, you could copy its body and walk through it...overwriting those module bindings for functions and arguments.</p>
<p>But it would really mean rewriting everything.  You'd have to redo MAKE OBJECT!, otherwise the <a href="https://rebol.metaeducation.com/t/sticky-set-word-binding-problem-in-make-object/2127">indiscriminate binding would break its expectations</a>--as it doesn't override explicit binding anymore.</p>
<h2><a name="p-7019-hooked-evaluator-may-fix-some-cases-2" class="anchor" href="https://rebol.metaeducation.com#p-7019-hooked-evaluator-may-fix-some-cases-2"></a>Hooked Evaluator May Fix (Some) Cases</h2>
<p>We already are going to need a hooked evaluator to handle things like PATH! looking up in objects (done presently with a hack to the main evaluator).</p>
<p>Another hook could just say that quoted things wound up bound under the same rules that non-quoted things use.</p>
<p>That would make this one whitespace example work, and maybe it would be able to run some more simple historical example scripts.  But anything that mixes COMPOSE and DO is likely doomed.</p>
<p>This may just be the price of progress.  Rebol2 emulation remains a good experiment of changing your baseline library, and it still would be a good example of that... for all the changes to primitives like FUNC and APPEND etc.  It just may not be able to accommodate the different expectations of binding.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/the-fate-of-redbol-emulation-in-a-mostly-unbound-world/2131">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/the-fate-of-redbol-emulation-in-a-mostly-unbound-world/2131</link>
          <pubDate>Tue, 23 Jan 2024 15:11:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2131</guid>
          <source url="https://rebol.metaeducation.com/t/the-fate-of-redbol-emulation-in-a-mostly-unbound-world/2131.rss">The Fate of Redbol Emulation In A Mostly Unbound World</source>
        </item>
        <item>
          <title>Critiquing Red&#39;s Updated APPLY Implementation</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>Ren-C added a super-duper APPLY in August 2021:</p>
<p><a href="https://rebol.metaeducation.com/t/apply-ii-the-revenge/1834" class="inline-onebox">APPLY II: The Revenge!</a></p>
<p>About two years later, I observe Red has published their own implementation of APPLY...with some seeming similarities:</p>
<p><a href="https://www.red-lang.org/2023/06/dynamic-refinements-and-function.html" class="inline-onebox">Red Programming Language: Dynamic Refinements and Function Application</a></p>
<p>But there are significant mechanical and usability differences.</p>
<p>Red inherits complexity from the fact that they didn't <a href="https://rebol.metaeducation.com/t/pure-and-refined-simplifying-refinements-to-one-or-zero-args/1120">merge refinements and their arguments together</a>.  This keeps them tied to problems that arise from ordering, and keeping the enablement of a refinement in sync with its value(s).  <strong>It's clear to me that "multi-arg-refinements" has proven to be not worth it in the design vs. having a single unified nullable value for each named argument</strong>...and this is only one of the many places that bear that out.</p>
<p>They do offer an idea how to create something like a FRAME!... but it's a higher-level usermode concept instead of the lower-level basis for APPLY-like abstractions.  The post gives an implementation called <strong><code>make-apply-obj-proto</code></strong>:</p>
<pre><code>red&gt;&gt; o-fctm: make-apply-obj-proto/with 'find/case/tail/match [series: [a b c] value: 'a]
== make object! [
    series: [a b c]
    value: 'a
    part: false
    length: none
    only: false
    case: true
    same: fal...

red&gt;&gt; apply-object :find o-fctm
== [b c]
</code></pre>
<p>Ren-C bakes this idea in as the core of function application.  You can build a FRAME! for the function (note the tail of the match is a multi-return...you can get both the begin and end in a single call...so there's no /TAIL here):</p>
<pre><code>&gt;&gt; f: make frame! find:case:match/
== make frame! [
    series: ~
    pattern: ~
    part: ~
    skip: ~
    reverse: ~
    last: ~
]
</code></pre>
<p>Notice :CASE and :MATCH didn't take arguments, so they have been specialized out of the frame as they were already mentioned as being in use.</p>
<p>Then you can fill in the frame with required (and optional) values:</p>
<pre><code>&gt;&gt; f.series: [a b c]
== [a b c]

&gt;&gt; f.pattern: 'a
== a
</code></pre>
<p>And it remembers what function it is for, so you can EVAL it without getting it mixed up.  (As a nice bonus in our definition of FIND here, the multi-return gives you the head and the tail if you want it):</p>
<pre><code>&gt;&gt; [begin end]: eval f
== [a b c]

&gt;&gt; begin
== [a b c]

&gt;&gt; end
== [b c]
</code></pre>
<p>They say of <strong><code>make-apply-obj-proto</code></strong>: <em>"But you may see that this is verbose and inefficient, making a whole object just for a call like this. And you'd be right. It's just an example.  You don't want to recreate objects like this, especially in a loop. But you don't have to. You can reuse the object and just change the important values in it."</em></p>
<p>This is the opposite philosophy to Ren-C.  These frames are the foundation of function invocation...and so they are always built.  The keylist of the object lives with the function definition and is pointed to by the frame, and so each instance only takes up the cells of the arguments.</p>
<p><em>(Note: If you wanted something directly comparable to <strong><code>make-apply-obj-proto</code></strong> it really could just be an option passed to APPLY which gave back the frame it builds without calling it.)</em></p>
<h2><a name="p-6614-im-glad-theyve-undertaken-this-because-1" class="anchor" href="https://rebol.metaeducation.com#p-6614-im-glad-theyve-undertaken-this-because-1"></a>I'm glad they've undertaken this... <em><strong>BECAUSE</strong></em>...</h2>
<p>...because it brings us closer to assembling comparable examples.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/magnifying_glass_tilted_left.png?v=14" title=":magnifying_glass_tilted_left:" class="emoji" alt=":magnifying_glass_tilted_left:" loading="lazy" width="20" height="20"></p>
<p>It lays bare the fact that when I undertake "complexity", the reason is that failure to design the system to handle clearly relevant cases will just push that complexity onto the user...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/critiquing-reds-updated-apply-implementation/2194">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/critiquing-reds-updated-apply-implementation/2194</link>
          <pubDate>Thu, 22 Jun 2023 00:10:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2194</guid>
          <source url="https://rebol.metaeducation.com/t/critiquing-reds-updated-apply-implementation/2194.rss">Critiquing Red&#39;s Updated APPLY Implementation</source>
        </item>
        <item>
          <title>Websocket Support in Oldes Rebol3</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>Looking to see what Oldes has been up to, he added some kind of minimal websocket support to the HTTP scheme:</p>
<p><a href="https://github.com/Oldes/Rebol3/commit/bae6cffe97e662ec9a727a01cdcc1fdd61455ea6#diff-490ba807ac4a5ee57e7a587ca0936d36e4c0ff2798b0652fdf791e758ce079c2R718" class="inline-onebox">FEAT: Minimalistic WebSocket support in the `httpd` scheme · Oldes/Rebol3@bae6cff · GitHub</a></p>
<p>Websockets isn't something I'm looking into at this time, but I wanted to bookmark it here in case it comes up later.</p>
<p>He also updated zlib to a new version released in 2022... and <a href="https://github.com/Oldes/Rebol3/commit/15fcc00b84f6d0e386f2ba2f4fc7bdc32ebff75d">used Ren-C's %make-zlib.r to do it!</a>.  But he edited it so he'd be able to run it under his Rebol3.  It's not a huge priority to do that update, but seems like since his ported script still worked, it might not be too hard.  (And a good reminder that script exists, and should be part of a CI test...)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/websocket-support-in-oldes-rebol3/2003">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/websocket-support-in-oldes-rebol3/2003</link>
          <pubDate>Fri, 06 Jan 2023 03:56:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2003</guid>
          <source url="https://rebol.metaeducation.com/t/websocket-support-in-oldes-rebol3/2003.rss">Websocket Support in Oldes Rebol3</source>
        </item>
        <item>
          <title>R3-Alpha&#39;s DATATYPE! Definition</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>You likely know that DATATYPE! in R3-Alpha (Rebol 2, Red...) has a distinct "type byte" in the cell.  So the implementation can tell it's a different thing, even if not all representations show that:</p>
<pre><code>r3-alpha&gt;&gt; block: reduce ['integer! integer!]
== [integer! integer!]

r3-alpha&gt;&gt; type? first block
== word!

r3-alpha&gt;&gt; type? second block
== datatype!
</code></pre>
<p>One way R3-Alpha has to see the difference is with MOLD/ALL</p>
<pre><code>r3-alpha&gt;&gt; mold/all block
== "[integer! #[datatype! integer!]]"
</code></pre>
<h2><a name="p-6439-but-whats-actually-in-a-datatype-cell-1" class="anchor" href="https://rebol.metaeducation.com#p-6439-but-whats-actually-in-a-datatype-cell-1"></a>But What's Actually <em>in</em> a DATATYPE! Cell?</h2>
<p>This was <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/include/sys-value.h#L106">the definition struct from R3-Alpha</a>:</p>
<pre><code>typedef struct Reb_Type {
    REBINT type;  // base type
    REBSER *spec;
    // REBINT min_type;
    // REBINT max_type;
} REBTYP;
</code></pre>
<p>So an integer to say what <strong><code>type</code></strong> it is (e.g. REB_INTEGER = 1, REB_LOGIC = 2, REB_BLOCK = 3 or whatever).  Note that this in the <em>payload</em> of the cell, not the header...because the type in the header is REB_DATATYPE to say it carries a "datatype payload".</p>
<p>Who knows what the commented-out <strong><code>min_type</code></strong> and <strong><code>max_type</code></strong> were.  But a remark says this payload is for a "Datatype or pseudo-datatype".  We can guess these were for pseudo-datatypes as a way of specifying a range of REB_XXX numbers to implement categories like ANY-SERIES!, as an alternative to typesets (?)</p>
<p>The <strong><code>spec</code></strong> is actually an object, that comes back as the answer to SPEC-OF:</p>
<pre><code>r3-alpha&gt;&gt; spec-of integer!
== make object! [
    title: "64 bit integer"
    type: 'scalar
]
</code></pre>
<p>This limited amount of information was built into the executable from the <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/boot/typespec.r#L24">Rebol-format table table in %typespec.r</a>.</p>
<p>You needed to use SPEC-OF to access these properties, but it could have been accessible with paths, e.g. <strong>integer!/title</strong>.  And it might have had more interesting properties:</p>
<pre><code>&gt;&gt; integer!/max-value
== 9223372036854775807
</code></pre>
<h2><a name="p-6439-all-redbols-conflated-the-looks-of-datatype-and-word-2" class="anchor" href="https://rebol.metaeducation.com#p-6439-all-redbols-conflated-the-looks-of-datatype-and-word-2"></a>All Redbols Conflated The Looks of DATATYPE! and WORD!</h2>
<p>In lockstep, they all did it:</p>
<pre><code>rebol2&gt;&gt; integer!
== integer!

r3-alpha&gt;&gt; integer!
== integer!

red&gt;&gt; integer!
== integer!
</code></pre>
<p>Since I have <a href="https://rebol.metaeducation.com/t/boron-language/1976">Boron</a> built, I find it renames integer! to int!, but otherwise the same:</p>
<pre><code>)&gt; int!
== int!

)&gt; type? int!
== datatype!

)&gt; type? first [int!]
== word!
</code></pre>
<p><strong>It seemed to me that this conflation couldn't possibly be the best answer.</strong>  So I made Ren-C buck this trend to use the R3-Alpha construction syntax, because it was something that could LOAD back:</p>
<pre><code>&gt;&gt; integer!
== #[datatype! integer!]

&gt;&gt; load "#[datatype! integer!]"
== [#[datatype! integer!]]
</code></pre>
<p><strong>Rendering differently was good, but the specific different rendering wasn't all that palatable.</strong>  And it wasn't showing it as any complex object.</p>
<h2><a name="p-6439-where-to-go-from-there-3" class="anchor" href="https://rebol.metaeducation.com#p-6439-where-to-go-from-there-3"></a>Where To Go From There?</h2>
<p>There seemed to be two directions to go with this:</p>
<ul>
<li>
<p>Accept DATATYPE! as some kind of alien complex type which has ugly rendering</p>
</li>
<li>
<p>Fit it into the lexical space somewhere.</p>
</li>
</ul>
<p>Ren-C has moved toward the idea of making datatypes a BLOCK! variant, decorated with &amp;:</p>
<pre><code>&gt;&gt; type of integer!
== &amp;[integer]
</code></pre>
<p>The details of what structure is used on these type blocks is still under consideration at time of writing.  See the threads in the forum's <a href="https://rebol.metaeducation.com/c/development/datatypes/45">Datatypes Category</a></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/r3-alphas-datatype-definition/1978">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/r3-alphas-datatype-definition/1978</link>
          <pubDate>Sat, 24 Sep 2022 08:02:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1978</guid>
          <source url="https://rebol.metaeducation.com/t/r3-alphas-datatype-definition/1978.rss">R3-Alpha&#39;s DATATYPE! Definition</source>
        </item>
        <item>
          <title>Boron Language</title>
          <dc:creator><![CDATA[WickedSmoke]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>Hello, Boron author here.  I look in on the Ren-C project once a year or so to see what's going on.  A few times I have considered joining this forum but for various reasons have not done so.  Since you have made space for similar projects, now seems like a good time to touch base.</p>
<p>Boron is my daily driver for scripting and has been in a stable period for years.  Bugfix releases occur roughly once per year.  I should have been making release announcements on the mailing list, but as there is no community of active users I didn't bother.  To exercise the language I have used it in the <a href="http://xu4.sourceforge.net/" rel="noopener nofollow ugc">xu4 project</a> to replace the XML configuration and scripting.</p>
<p>The next period of change may include support for static strings (ala AltScript), optimized path! storage, and reworking the evaluator to support yielding.</p>
<p>Games and graphics are an interest of mine so the Boron-GL project is where I experiment with GUIs, shaders, and such.  Some of the work on xu4 such as font rendering and the <a href="https://wickedsmoke.github.io/faun/" rel="noopener nofollow ugc">Faun</a> library will make it's way into Boron-GL.  The GL code was part of the main Boron repository until the end of 2019.</p>
            <p><small>12 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/boron-language/1976">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/boron-language/1976</link>
          <pubDate>Sat, 17 Sep 2022 14:39:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1976</guid>
          <source url="https://rebol.metaeducation.com/t/boron-language/1976.rss">Boron Language</source>
        </item>
        <item>
          <title>Calling Ren Functions From Redbol</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>When you <strong><code>import @redbol</code></strong> the environment for your module is skinned with the Redbol definitions.  But it can run concurrently with non-Redbol modules in the same session.  This is very cool.</p>
<p>I've nudged it a little further into cool by having the definition of LIB in Redbol be the initial state of the Redbol definitions, and then REN is the Ren-C's version of LIB.</p>
<pre><code>&gt;&gt; import @redbol

&gt;&gt; append [a b c] [d e]
== [a b c d e]

&gt;&gt; append/only [a b c] [d e]
== [a b c [d e]]

&gt;&gt; ren/append [a b c] [d e]
== [a b c [d e]]

&gt;&gt; ren/append [a b c] ren/spread [d e]
== [a b c d e]

&gt;&gt; append: does [print "Overwritten"]
== #[action! {append} []]

&gt;&gt; append
Overwritten

&gt;&gt; lib/append [a b c] [d e]
== [a b c d e]
</code></pre>
<p><em>Pretty slick.</em></p>
<h2><a name="p-6297-but-import-is-ultimately-not-the-right-mechanism-1" class="anchor" href="https://rebol.metaeducation.com#p-6297-but-import-is-ultimately-not-the-right-mechanism-1"></a>But IMPORT is Ultimately Not The Right Mechanism</h2>
<p>Because it's done using import, Redbol does not "clear out" the space of all the Ren-Cisms.</p>
<p>In fact, I didn't actually have to say <strong>ren/spread</strong> because the spread definition is still available:</p>
<pre><code>&gt;&gt; ren/append [a b c] spread [d e]
== [a b c d e]
</code></pre>
<p>It's non-viable to ask Redbol to remove every Ren-C definition.  Instead, there needs to be a way to get a Redbol-using module to start from a fully clean slate where it explicitly exports everything it wants to make available.  This doesn't have to be that much work, it can just be a list of words in a block, with possible renamings:</p>
<pre><code>redbol-inherit [even?, odd?, value?: unset? ...]
</code></pre>
<h2><a name="p-6297-these-challenges-are-great-for-vetting-2" class="anchor" href="https://rebol.metaeducation.com#p-6297-these-challenges-are-great-for-vetting-2"></a>These Challenges Are Great For Vetting</h2>
<p>I don't throw softballs.  This is all truly attempting to live up to the hype of a language that you can bend and redefine at will, without constantly tripping over your own changes--and being able to build on top of existing functionality without being forced to rewrite it too.</p>
<p>Although things move slowly... the arrow of progress is in the right direction.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/calling-ren-functions-from-redbol/1934">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/calling-ren-functions-from-redbol/1934</link>
          <pubDate>Sat, 20 Aug 2022 21:05:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1934</guid>
          <source url="https://rebol.metaeducation.com/t/calling-ren-functions-from-redbol/1934.rss">Calling Ren Functions From Redbol</source>
        </item>
        <item>
          <title>Redbol Adaptation to get /ONLY on APPEND, INSERT...</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p><a href="https://rebol.metaeducation.com/t/the-long-awaited-death-of-only/1607">/ONLY is Dead</a>...<em>but</em> Ren-C's flexibility means you can get it back if you want it, and not break a sweat doing so.   You just become responsible for figuring out what its universal meaning is.  (<span class="hashtag-raw">#goodluckwiththat</span>)</p>
<p>Remember that AUGMENT lets you add parameters to functions.</p>
<pre><code>&gt;&gt; foo: func [x] [print ["x is" mold x]]
&gt;&gt; parameters of :foo
== [x]

&gt;&gt; foo+: augment :foo [/only "An ONLY parameter"]
&gt;&gt; parameters of :foo+
== [x /only]

&gt;&gt; foo+ 10
x is 10

&gt;&gt; foo+/only 10
x is 10
</code></pre>
<p>But adding parameters doesn't actually do anything but expand the specification.  You have to use another tool like ADAPT or ENCLOSE to make use of the new parameters that FOO never knew about.</p>
<pre><code>&gt;&gt; foo++: adapt :foo+ [print either only ["/ONLY!"] ["no /ONLY"]]

&gt;&gt; foo++ 10
no /ONLY
x is 10

&gt;&gt; foo++/only 10
/ONLY!
x is 10
</code></pre>
<p>So here's an ONLIFY transformer that adds a refinement to a function, and then injects a little code to pre-process the parameter to make a splice (group isotope) via SPREAD if needed.</p>
<pre><code>onlify: lambda [
    {Add /ONLY behavior to APPEND, INSERT, CHANGE}
    action [action?]
][
    adapt (augment :action [/only "Use quoted semantics for value"]) [
        all [not only, any-array? series, any-array? value] then [
            value: spread value
        ]
        ; ...fall through to normal handling
    ]
]
</code></pre>
<p>Then you can apply it to the functions:</p>
<pre><code>append: my onlify  ; e.g. `append: onlify :append` 
insert: my onlify
change: my onlify
</code></pre>
<p>And there you have it:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c d e]

&gt;&gt; append/only [a b c] [d e]
== [a b c [d e]]
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/redbol-adaptation-to-get-only-on-append-insert/2081">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/redbol-adaptation-to-get-only-on-append-insert/2081</link>
          <pubDate>Thu, 21 Jul 2022 09:11:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2081</guid>
          <source url="https://rebol.metaeducation.com/t/redbol-adaptation-to-get-only-on-append-insert/2081.rss">Redbol Adaptation to get /ONLY on APPEND, INSERT...</source>
        </item>
        <item>
          <title>Old Idea from DocKimbel For Rebol2 =&gt; Rebol3/Red</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>This is something I just ran across from a long time ago, which I thought would be interesting to look at with modern eyes.</p>
<p>It's a Gist: <a href="https://gist.github.com/dockimbel/5083375">https://gist.github.com/dockimbel/5083375</a> of a proposal of actually making a DO variant that would rewrite the source of a script.</p>
<p>He is quoted as having said: <em>"A JIT-migration tool would be more accurate. It would run just after LOAD and before DO to rewrite part of the R2 sources in a R3 compatible format."</em></p>
<p>Static analysis of Turing-Complete programs is notoriously on the difficult-if-not-impossible scale, even for simple languages.  So JIT-rewriting even something like PARSE rules is only going to be feasible if those rules were not built by code.</p>
<p>His example just looks for one source pattern (negative literal indexing, so like translating between <strong><code>data/0</code></strong> and <strong><code>data/-1</code></strong>).  But determining what is "code" and what is "data" is deliberately more complex in Rebol than other language.</p>
<p>In Ren-C we have code like <code>enbin [BE +/- 32]</code> and that path is never meant to execute, it's just there to convey the notion of wanting to encode a signed number.  Going around and randomly turning all paths with 0 in them to be -1 misses the whole point of "relative expressions"; you don't know what they're relative to.</p>
<p>So the ironic point of preserving this is just to say "nothing to see, here".  <img src="https://rebol.metaeducation.com/images/emoji/twitter/slight_smile.png?v=14" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20">  <code>%redbol.reb</code> is a saner track.  But I do think it's going to wind up requiring DO itself being different... a DO2 (like UPARSE2).  It won't rewriting the code block given, but hook the evaluator with different rules.</p>
<pre><code>REBOL [
    Author:  "Nenad Rakocevic"
    Date:      04/03/2013
    Purpose: {
        Show how to achieve R2 source rewriting suitable for evaluation
        using R3 interpreter.
    }
        Note: "Use it from %Red/ folder"
]

context [
    do*: s: none
    
    path-rewrite: [
        some [
            s: integer! (if negative? s/1 [s/1: s/1 + 1])
            ;| handle other indexed-access cases here
            | skip
        ]
    ]

    patched-do: func [value /arg /local saved rule mark path file][
        unless file? :value [return do* value]

        saved: system/script/path
        set [path file] split-path :value
        change-dir path
        value: load file

        parse value rule: [
            any [
                mark: [path! | set-path! | lit-path!] :mark into path-rewrite
                ;; | mark: string! :mark into string-rewrite 
                ;; add more rewritting rules here
                | mark: any-block! :mark into rule
                | skip
            ]
        ]
        also 
            do* value
            system/script/path: saved
    ]
    
    set 'do-r2 func [blk [block!]][
        do*: :do
        set 'do :patched-do
        do blk
        set 'do :do*
    ]
]

do-r2 [
    do %red/compiler.r
]
save %red.new red  ;-- inspect the file to see the changes
halt
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/old-idea-from-dockimbel-for-rebol2-rebol3-red/1814">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/old-idea-from-dockimbel-for-rebol2-rebol3-red/1814</link>
          <pubDate>Sat, 14 May 2022 04:12:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1814</guid>
          <source url="https://rebol.metaeducation.com/t/old-idea-from-dockimbel-for-rebol2-rebol3-red/1814.rss">Old Idea from DocKimbel For Rebol2 =&gt; Rebol3/Red</source>
        </item>
        <item>
          <title>REBOL 1.0 Retrospective</title>
          <dc:creator><![CDATA[DefinitionalUsername]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>I was reading about some of the design choices in REBOL, and came upon Joe Marshall's writings where he talks about the changes between REBOL 1 and 2 (missing continuations, changed scoping rules, absence of tail recursion, etc.). This made me curious about the differences between the two version; however, I can't find anything related to REBOL 1 on the internet (save for a Scheme compiler).</p>
<p>Will it be possible to share the manual/guide/documentation for REBOL 1 here? It is a piece of history, and it'll be a shame if it just disappears.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/rebol-1-0-retrospective/1788">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/rebol-1-0-retrospective/1788</link>
          <pubDate>Mon, 14 Feb 2022 03:29:26 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1788</guid>
          <source url="https://rebol.metaeducation.com/t/rebol-1-0-retrospective/1788.rss">REBOL 1.0 Retrospective</source>
        </item>
        <item>
          <title>Could Ren-C and Red Interoperate (and if so, *should* they?)</title>
          <dc:creator><![CDATA[Cplus]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>When this year can we expect to see full "message passing" inter-operability between Ren-C and Red?</p>
<p>The very basics - MOLD and SAVE are almost in place.</p>
<p>The "binary" equivalent with some form of compatible REBBIN is surely not that hard to agree between the two sets of developers.</p>
<p>Fuller, fluid, message passing - for example the seamless invoking of functions and continuations within a running instance of the other language would be an important demonstration of the REBOL cousins' languages abilities to do what they have stated is a desired characteristic of their respective dialects of REBOL.</p>
<p>This would also harness the strengths of both dialects - for each has been focused these last few years on different arenas. Together, they have the makings of a formidable whole.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/could-ren-c-and-red-interoperate-and-if-so-should-they/1787">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/could-ren-c-and-red-interoperate-and-if-so-should-they/1787</link>
          <pubDate>Fri, 04 Feb 2022 19:20:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1787</guid>
          <source url="https://rebol.metaeducation.com/t/could-ren-c-and-red-interoperate-and-if-so-should-they/1787.rss">Could Ren-C and Red Interoperate (and if so, *should* they?)</source>
        </item>
        <item>
          <title>Rye Language</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>So here's another language which doesn't <em>look</em> very Rebol-like, but is by Refaktor who is Rebol-inspired:</p>
<aside class="onebox githubrepo" data-onebox-src="https://github.com/refaktor/rye">
  <header class="source">

      <a href="https://github.com/refaktor/rye" target="_blank" rel="noopener">github.com</a>
  </header>

  <article class="onebox-body">
    <div class="github-row" data-github-private-repo="false">
  <img width="690" height="344" src="https://opengraph.githubassets.com/121f90fad428e0c13ffb6248b97015f4/refaktor/rye" class="thumbnail">

  <h3><a href="https://github.com/refaktor/rye" target="_blank" rel="noopener">GitHub - refaktor/rye: homoiconic dynamic programming language with some...</a></h3>

    <p><span class="github-repo-description">homoiconic dynamic programming language with some new ideas</span></p>
</div>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>Notably, it is written in Go.  <em>(I've mentioned that increasingly I have been leaning toward modeling things after Go for a runtime.  It would of course be easier to do by actually writing the runtime in Go, vs. trying to reproduce the effect in low-level C code.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"> )</em></p>
<p>It's probably very interesting, but I don't really feel like looking at it right at this moment.  Maybe someone else can study it and explain what it's about in a reply here.</p>
<p>The main carry-away I'll take for the moment is the 1:1 language-designer:user ratio that Rebol users are inevitably converging toward.</p>
            <p><small>7 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/rye-language/1768">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/rye-language/1768</link>
          <pubDate>Sun, 05 Dec 2021 16:21:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1768</guid>
          <source url="https://rebol.metaeducation.com/t/rye-language/1768.rss">Rye Language</source>
        </item>
        <item>
          <title>Kaj Gets on the Meta Train</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>So Kaj is still out there somewhere, working on a spiritual competitor to Red he is calling "Meta". <img src="https://rebol.metaeducation.com/images/emoji/twitter/roll_eyes.png?v=14" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></p>
<p><a href="https://language.metaproject.frl/">https://language.metaproject.frl/</a></p>
<p>His first target is the Atari 2600 <img src="https://rebol.metaeducation.com/images/emoji/twitter/joystick.png?v=14" title=":joystick:" class="emoji" alt=":joystick:" loading="lazy" width="20" height="20"><img src="https://rebol.metaeducation.com/images/emoji/twitter/space_invader.png?v=14" title=":space_invader:" class="emoji" alt=":space_invader:" loading="lazy" width="20" height="20">  so he's certainly starting from... the basics.</p>
<p><em>(For whatever it's worth, I actually am interested in things like Atari 2600 programming and seeing what you can do with modern tools.  e.g. there's a neat <a href="https://youtu.be/4X1NdKvNCYQ?t=459">reboot of PAC-MAN</a> and I think a lot of people would like to know what <strong>could</strong> have been done, theoretically.)</em></p>
<p>There's no source code by which to measure the amount of investment the project represents so far.  He's only giving out binaries, and says:</p>
<blockquote>
<p>"There will always be a free version of <em>Meta</em>. We will build a business on top of it, by offering paid premium versions and other products built with <em>Meta</em>."</p>
</blockquote>
<h2><a name="p-5630-whats-the-mission-difference-from-red-1" class="anchor" href="https://rebol.metaeducation.com#p-5630-whats-the-mission-difference-from-red-1"></a>What's The Mission Difference From Red?</h2>
<p>Seemingly not much.  But inevitably, one angle is going to be "faster":</p>
<blockquote>
<p>"Red/System is the wrong abstraction level and the wrong format for an intermediate language, certainly for a REBOL language. The abstraction level is that of C, which is too low for the intermediate layer. The format is that of REBOL, which is free form for human use. Red is parsed from free form to something more suitable for machine processing, then a lot of Red/System is generated, then all of that needs to be reparsed. The compiler is painfully slow."</p>
</blockquote>
<p>But he's willing to build on LLVM to start with.  I'd said that Red should aim for a LLVM-subset IR, that could then be built with either a simple/small custom emitter or the full "bloated" toolchain if one really wanted to.  That would have provided a fallback; but Nenad wasn't a fan of the LLVM instruction set for some reason, and had ideas about exposing lower-level CPU features (maybe that was why).</p>
<p>So at least in this sense Kaj's approach seems more pragmatic to me.</p>
<p>Also inevitably: having people to work with was slowing him down.  He'll make much more progress on his own, <a href="https://atariage.com/forums/topic/315558-a-new-language-for-the-atari/?tab=comments#comment-4719124">as we find from his Atari Forum post</a>:</p>
<blockquote>
<p>Red was launched on a REBOL conference of mine in the Netherlands. I helped launch the language and contributed to it for half a decade. After that I left the project, because I am disappointed that it hasn't fulfilled its promises.</p>
<p>Before all that, I contributed to the latest version of REBOL and lobbied its creator Carl Sassenrath to open-source it. It eventually was, and REBOL could have done most of what Red promised, but Carl abandoned it when his funding ran out. After the leader left, the project was torn apart by competing interests.</p>
<p>My language is meant to succeed both REBOL and Red.</p>
</blockquote>
<h2><a name="p-5630-theres-only-one-download-for-windows-linux-mac-2" class="anchor" href="https://rebol.metaeducation.com#p-5630-theres-only-one-download-for-windows-linux-mac-2"></a>There's only ONE Download for Windows, Linux, Mac...?</h2>
<p>On the surface this seems interesting: he's using something called the <a href="https://justine.lol/ape.html">"APE: Actually Portable Executable"</a> format.  You can use a single download for all platforms--the same single file.  It puts x86 code into a container that can run as either a Windows .COM file or a unix shell script.</p>
<p>It's a stunt which isn't really all <em>that</em> profound--though I'll admit I'd wondered if there was some polyglot trick that could do exactly this.  Turns out the answer is yes...so that's cool.  I'm glad someone did it.</p>
<p>But it has more relevance to writing viruses than it does to practical cross-platform development.  Launching the code is a drop in the bucket compared to all the other things you need to worry about in a useful platform abstraction layer.  Not to mention that obviously Macs are now on ARM, so the binaries would have to be emulated or include both instruction sets.</p>
<p>At this juncture, running WebAssembly in a browser is far more compelling a story...because you have the whole web runtime available.</p>
<p>Anyway I doubt he's married to the APE format and is just trying it out because it seems cool.  It's not something I want to worry over.  And for what it's worth, it doesn't work for me on Windows 11.  YMMV.</p>
<h2><a name="p-5630-source-comparison-3" class="anchor" href="https://rebol.metaeducation.com#p-5630-source-comparison-3"></a>Source Comparison?</h2>
<p>Not much is available to compare.  His examples don't have headers, which is one of the more defining historical properties of Rebol programs.  The word "header" is not mentioned in his manifesto, so it's not clear if that's temporary or permanent.</p>
<p>Here's a Fibonacci example:</p>
<pre><code>; Maximum 24 for natural16! result
; Max 47 for natural32! result
parameter= 24
 
print "Fibonacci "  print parameter  print ": "
 
natural! [Fibonacci previous]
; natural32! [Fibonacci previous]
 
either parameter &lt;= 1 [
    Fibonacci: parameter  ; Fibonacci 0 ... 1
][
    Fibonacci: previous: 1  ; Fibonacci 2

    loop parameter - 2 [
        previous: also
            Fibonacci
            Fibonacci: Fibonacci + previous
     ]
]
 
print/line Fibonacci 
</code></pre>
<p>So...</p>
<ul>
<li>
<p>It seems he wants PRINT to not include a newline, so you have to say PRINT/LINE to get it.</p>
<ul>
<li>I prefer the solution of asking those who really want partial line output (e.g. console prompts) to WRITE STDOUT directly...and that PRINT COLLECT be used as a pattern when your code is piecing together a full line from parts generated by distinct bits of code, KEEP-ing each part.</li>
</ul>
</li>
<li>
<p>Working on Atari means he's getting involved in things like INTEGER16!, and you optimize based on annotating datatypes like that.  I'm more of the "bignum by default" philosophy, so different indeed.</p>
<ul>
<li>Putting <strong>natural! [Fibonacci previous]</strong> in the middle of the code to constrain the type--not in a function spec--suggests this is really rather far afield from the evaluator-driven Rebol.</li>
</ul>
</li>
<li>
<p>He's trotting out historical ALSO in a first example.  No one in the Atari forum clapped with amazement at the genius several Rebolers seem to think it represents.  (So I feel pretty comfortable with <strong><a href="https://rebol.metaeducation.com/t/infixing-also-stylizing-it-after-then-and-else/402">Ren-C's ALSO and ELIDE</a></strong>.)</p>
</li>
</ul>
<p>Without more to look at I can't have more to say.</p>
            <p><small>7 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/kaj-gets-on-the-meta-train/1753">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/kaj-gets-on-the-meta-train/1753</link>
          <pubDate>Sat, 20 Nov 2021 23:44:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1753</guid>
          <source url="https://rebol.metaeducation.com/t/kaj-gets-on-the-meta-train/1753.rss">Kaj Gets on the Meta Train</source>
        </item>
        <item>
          <title>PATH! usage for Function Dispatch Only Unless in Redbol Mode</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>For a while now I've been a pretty big convert on the look of dots for member selection.  It's not just that it's more standard--I think it's visually better.  It also lets you be reassured that when you see a slash in a path, that the thing to the left of that slash was a function:</p>
<pre><code>foo.bar.baz
   ;
   ; ^-- I may not know what foo.bar.baz is, but at least I know that
   ; foo and foo.bar are *not* functions

foo.bar.baz/mumble
   ;
   ; ^-- Under the convention that slashes are for refinements only, I
   ; can tell the author intends that (foo.bar.baz) must be a function

foo.baz.bar/
   ;
   ; ^-- With Ren-C's path generality, you can even decorate a case
   ; without refinements to show it's a function.
</code></pre>
<h2><a name="p-5506-it-hasnt-been-a-rule-but-1" class="anchor" href="https://rebol.metaeducation.com#p-5506-it-hasnt-been-a-rule-but-1"></a>It Hasn't Been A <em>Rule</em>, but...</h2>
<p>So far Ren-C has been allowing you to use slashes wherever you historically could.  So the new rules were only applying to dots--restricting them on not being usable on functions.</p>
<pre><code>append.dup [a b c] [d] 2  ; this would cause an error, for instance
</code></pre>
<p>However, you could still pick members out of objects with slashes:</p>
<pre><code>&gt;&gt; obj: make object! [field: 10]

&gt;&gt; obj/field   ; not obj.field
== 10
</code></pre>
<p>I had a feeling this might be prohibited eventually...though it would need to be possible to make Redbol emulation work.  So there'd have to be some kind of flag for allowing it.</p>
<h2><a name="p-5506-but-now-i-might-have-a-good-reason-to-enforce-it-2" class="anchor" href="https://rebol.metaeducation.com#p-5506-but-now-i-might-have-a-good-reason-to-enforce-it-2"></a>...But Now, I Might Have A Good Reason To Enforce It</h2>
<p>The reason is that in trying to do a good job of building an extensibility mechanism for member selection, it is difficult to make that mechanism able to communicate information about specialized functions in a "light" way.</p>
<p>When pathing is done hardcoded in the evaluator, it can do little sneaky tricks to push the words of refinements onto a stack.  It doesn't have to create an entirely new specialized function.</p>
<p>But once you're using a generic interface to usermode functions which can extend <strong><code>PICK*</code></strong> and <strong><code>POKE*</code></strong>, that interface has to speak in "reified" forms.  We have partial specialization so these refied forms exist... I just feel like what's happening in that case isn't "picking" or "poking".  And it's tying my hands to make anything efficient if we say that path dispatch runs through code which might be usermode.</p>
<h2><a name="p-5506-the-flag-will-be-introduced-gradually-3" class="anchor" href="https://rebol.metaeducation.com#p-5506-the-flag-will-be-introduced-gradually-3"></a>The Flag Will Be Introduced Gradually</h2>
<p>I've been experimenting with the flag turning itself on automatically, and giving you a warning.  So you only hear about it the first time.</p>
<pre><code>&gt;&gt; obj: make object! [x: 10]

&gt;&gt; obj/x
The PATH! obj/x doesn't evaluate to an ACTION! in the first slot.
SYSTEM.OPTIONS.REDBOL-PATHS is FALSE so this is not allowed by default.
For now, we'll enable it automatically...but it will slow down the system!
Please use TUPLE! instead, like obj.x
== 10

&gt;&gt; obj/x
== 10
</code></pre>
<p>What happens when you enable the flag is that it actually turns any PATH! with no ACTION! in the first slot into a TUPLE!, and then permits you to use refinements in TUPLE!s like <code>append.dup</code>.  This is because I'm avoiding creating a separate extensibility mechanism for paths...it just does the not-easy-to-optimize extensibility.</p>
<p>I haven't committed this, and I'd be phasing it in slowly.  But as it's phased in, the performance of paths for member selections vs. tuples will degrade.  So it's worth knowing about.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/path-usage-for-function-dispatch-only-unless-in-redbol-mode/1723">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/path-usage-for-function-dispatch-only-unless-in-redbol-mode/1723</link>
          <pubDate>Wed, 22 Sep 2021 18:11:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1723</guid>
          <source url="https://rebol.metaeducation.com/t/path-usage-for-function-dispatch-only-unless-in-redbol-mode/1723.rss">PATH! usage for Function Dispatch Only Unless in Redbol Mode</source>
        </item>
        <item>
          <title>Red&#39;s REMOVE [OPT N rule] vs. REMOVE [OPT [N rule]]</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>I was doing some comparative behavior testing while looking at the <a href="https://rebol.metaeducation.com/t/converting-trim-to-uparse-for-testing-and-inspiration/1660">UPARSE conversion of TRIM</a>.</p>
<p>As I mention in that post, the comparisons are now more-often-than-not pointing out bugs and inconsistencies in R3-Alpha and Red.  UPARSE is the new gold standard.  !</p>
<p>Here's a good example of R3-Alpha and Red being broken in their various ways, that will happen indefinitely... until the PARSE methodology changes from being ad-hoc to being architecturally sane.  :-/</p>
<pre><code>red&gt;&gt; parse s: "aab" [remove [opt 3 "a"] thru "b"]
== true

red&gt;&gt; s
== "b"
</code></pre>
<p><em>Why did it think there was 3 "a" to remove?</em>  I'd guess there are "repeat min-counts" and "repeat max-counts" and "optionality flags" being thrown about.  So it confused itself and put the optional flag on the "a", winding up interpreting the rule as:</p>
<pre><code>[remove [3 opt "a"] thru "b"]
</code></pre>
<p>How do you keep it from getting its flags crossed?  Throw in a block, because then it likely starts a genuine parse recursion and the flags won't mix:</p>
<pre><code>red&gt;&gt; parse s: "aab" [remove [opt [3 "a"]] thru "b"]
== true

red&gt;&gt; s
== "aab"
</code></pre>
<p>That's correct...and if you use a BLOCK! like that R3-Alpha also does the right thing:</p>
<pre><code>r3-alpha&gt;&gt; parse s: "aab" [remove [opt [3 "a"]] thru "b"]
== true

r3-alpha&gt;&gt; s
== "aab"
</code></pre>
<p>But predictably...without the block, you get an entirely different failure mode; the parse fails altogether:</p>
<pre><code>r3-alpha&gt;&gt; parse s: "aab" [remove [opt 3 "a"] thru "b"]
== false

r3-alpha&gt;&gt; s
== "aab"
</code></pre>
<p>Unless you explicitly try to make your combinators look literally at the items in the block--this category of distinction cannot exist in UPARSE.  <strong>[try repeat 3 "a"] and [try [repeat 3 "a"]] are equivalent in a correct-by-construction sense, and all the combinators that will ever be written get this benefit.</strong></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/reds-remove-opt-n-rule-vs-remove-opt-n-rule/1659">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/reds-remove-opt-n-rule-vs-remove-opt-n-rule/1659</link>
          <pubDate>Fri, 13 Aug 2021 20:10:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1659</guid>
          <source url="https://rebol.metaeducation.com/t/reds-remove-opt-n-rule-vs-remove-opt-n-rule/1659.rss">Red&#39;s REMOVE [OPT N rule] vs. REMOVE [OPT [N rule]]</source>
        </item>
        <item>
          <title>Red changing FIND/MATCH to not default to /TAIL</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>Historically, the /MATCH option to FIND has implied returning the tail of the matched region.</p>
<pre><code>rebol2&gt;&gt; find/match "abc" "ab"
== "c"
</code></pre>
<p>That has been true despite the fact that there is a /TAIL option to FIND.  In trying to make FIND more orthogonal I have questioned this decision.</p>
<p><strong><a href="https://github.com/red/red/issues/4943">Red has made the move to say you have to provide /TAIL with /MATCH, otherwise you get the head of the match</a></strong>.  So now:</p>
<pre><code>red&gt;&gt; find/match "abc" "ab"
== "abc"

red&gt;&gt; find/match/tail "abc" "ab"
== "c"
</code></pre>
<p>I can agree with the intent behind this, although I wonder if it should accompany a changing of the refinement name.  /MATCH doesn't really fit with the meaning of "match" as I've been using it, e.g.</p>
<pre><code>&gt;&gt; match integer! 10
== 10

&gt;&gt; match integer! &lt;abc&gt;
; null
</code></pre>
<p>So maybe something like FIND/AT or FIND/STAY or FIND/HERE...something along those lines.  Then /MATCH could be deprecated in a more structured way.</p>
<p>But nope... they're pro breaking this for some reason.  Who am I to argue, especially given that I wanted it changed anyway?</p>
<p>It does underscore that Redbol emulation will need Red and Bol modes.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/red-changing-find-match-to-not-default-to-tail/1654">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/red-changing-find-match-to-not-default-to-tail/1654</link>
          <pubDate>Thu, 12 Aug 2021 06:52:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1654</guid>
          <source url="https://rebol.metaeducation.com/t/red-changing-find-match-to-not-default-to-tail/1654.rss">Red changing FIND/MATCH to not default to /TAIL</source>
        </item>
        <item>
          <title>Red&#39;s Take on String Interpolation</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="8" data-topic="587">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/could-strings-have-context/587/8">Could strings have context?</a></div>
<blockquote>
<p><strong>I've started to feel that supporting string interpolation is fairly important.</strong></p>
</blockquote>
</aside>
<p>So Red is trying to attack string interpolation <a href="https://gitter.im/red/red?at=60d4df778a40b1172827e4ff">via a macro</a>, which apparently can happen "before word binding" in some way.</p>
<p>That kind of ties their hands representationally because macros always are signaled by ISSUE!s, so the callsites that want to use string interpolation must have a macro.</p>
<pre><code>&gt;&gt; probe expand-directives [#composite {"(player)" "(vfile)" --audio-file "(afile)"}]
[rejoin [{"} (player) {" "} (vfile) {" --audio-file "} (afile) {"}]]
</code></pre>
<p><a href="https://gitter.im/red/red?at=60d636eb8a40b117282ae530">Boris's remark about the usefulness of being able to do string interpolation</a> in Rebol sums up probably how most of those who reject the idea at first would eventually come around:</p>
<blockquote>
<p>can add that first time I saw Gregg's <code>#composite</code> my reaction was "why would we ever want that?". But then with every <code>print</code> or <code>rejoin</code> I was using in my code I had this thought "what if..". Then I started using my experimental implementation, and after some time I believe it's a total must have.</p>
</blockquote>
<p><strong>But I still think this should be approached as a binding question.</strong>   It's very difficult to play with bricks in the "native" way that Rebol has been and overlay a <em>predictable</em> and useful idea of a "binding environment".  And keeping an open mind about it is necessary.</p>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/reds-take-on-string-interpolation/2121">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/reds-take-on-string-interpolation/2121</link>
          <pubDate>Sat, 26 Jun 2021 04:06:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2121</guid>
          <source url="https://rebol.metaeducation.com/t/reds-take-on-string-interpolation/2121.rss">Red&#39;s Take on String Interpolation</source>
        </item>
        <item>
          <title>NULL/VOID/TRASH evolution from NONE!/UNSET!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <blockquote>
<p><strong>Here is some history that explains how <a href="https://rebol.metaeducation.com/t/what-are-null-void-and-trash/2283">NULL and VOID and TRASH</a> evolved from Rebol2's types.</strong></p>
</blockquote>
<hr>
<h2><a name="p-7690-rebol2r3-alphared-have-two-kinds-of-nothing-both-reified-1" class="anchor" href="https://rebol.metaeducation.com#p-7690-rebol2r3-alphared-have-two-kinds-of-nothing-both-reified-1"></a>Rebol2/R3-Alpha/Red Have Two Kinds of Nothing (both reified)</h2>
<p>Historical Redbol gives you two main choices for "nothingness"...<strong><code>#[none]</code></strong> and <strong><code>#[unset]</code></strong>... both of which can be found either in variables, or as values in blocks:</p>
<pre><code>rebol2&gt;&gt; block: reduce [none print "print returns unset"]
print returns unset
== [none unset]  ; misleadingly renders as WORD!s

rebol2&gt;&gt; type? first block
== none!

rebol2&gt;&gt; type? second block
== unset!
</code></pre>
<p>Using <code>#[none]</code> has the advantage of being "friendly" on access via word, allowing you to write things like:</p>
<pre><code>rebol2&gt;&gt; var: none

rebol2&gt;&gt; either var [print "do something with var"] [print "do something else"]
do something else
</code></pre>
<p>But when var contained an #[unset], you'd get an error instead:</p>
<pre><code>rebol2&gt;&gt; unset 'var

rebol2&gt;&gt; either var [print "do something with var"] [print "do something else"]
** Script Error: var has no value
</code></pre>
<p>So instead of using var directly, you had to do something more circuitous and pass the word "var" into a special test routine (morally equivalent to today's <strong>set? 'var</strong>)</p>
<p><strong>Hence #[none] was reached for frequently out of convenience.  Yet this convenience came with a cost: it was very easy to accidentally append one to a block, even if its non-valued intent should have conveyed you might not have wanted to add anything at all.</strong></p>
<p>But it's hard to say: sometimes you <em>did</em> want to add #[none] to a block, to serve as a placeholder.</p>
<p>Also, being able to enumerate a block which contained #[unset] values was problematic, because if you did something like a FOR-EACH it would appear that the variable you were enumerating with was itself not set.</p>
<h2><a name="p-7690-early-ren-c-made-reified-blank-and-non-valued-null-2" class="anchor" href="https://rebol.metaeducation.com#p-7690-early-ren-c-made-reified-blank-and-non-valued-null-2"></a>Early Ren-C Made Reified BLANK! and non-Valued NULL</h2>
<p>One thing that bugged me was that there was no "pretty" representation for a non-valued state in a block... and that <code>#[none]</code> often thus displayed itself as the word <code>none</code> (seen in the example at the top of the post).</p>
<p>So the BLANK! datatype took the single underscore <strong>_</strong>.</p>
<pre><code>&gt;&gt; second [a _]
== _

&gt;&gt; if blank? _ [print "yep, it's a blank"]
yep it's a blank

&gt;&gt; if not _ [print "blank is also falsey"]
blank is also falsey
</code></pre>
<p>And critically, one of the first things I tried to do was rethink the <code>#[unset]</code> state into something that you'd never find in a block, and called it NULL (as well as made it correspond to C/Javascript null in the API):</p>
<pre><code>&gt;&gt; second [a _]
== _

&gt;&gt; third [a _]
; null
</code></pre>
<p>Since NULL couldn't be found in a block, it wasn't ambiguous when you got NULL back from a block operation as to whether there was a "null in that position".</p>
<p>But it's still just two things:</p>
<ul>
<li>
<p><strong>blank!</strong> - A nothing you can put in a block</p>
<ul>
<li>it was logically false</li>
<li>it was friendly via word access (no need for GET-WORD!)</li>
</ul>
</li>
<li>
<p><strong>null</strong> - A nothing you couldn't put in a block</p>
<ul>
<li>it was also logically false</li>
<li>it was <em>unfriendly</em> via word access (need GET-WORD! for :VAR, or SET? 'VAR)</li>
</ul>
</li>
</ul>
<p>This put you in a difficult situation for your choices of emptiness when you were dealing with something like:</p>
<pre><code>append block value  ; what nothing state should you use for value?
</code></pre>
<p>If you wanted to avoid accidentally appending blanks to arrays, you kind of wanted NULL so you'd get an error.  But once you used NULL, you could not write the convenient <strong><code>if value [...]</code></strong>  control structure.</p>
<h2><a name="p-7690-later-ren-c-added-a-separate-ornery-non-value-state-3" class="anchor" href="https://rebol.metaeducation.com#p-7690-later-ren-c-added-a-separate-ornery-non-value-state-3"></a>Later Ren-C added a separate "ornery" non-Value State</h2>
<p>A third state was added to be neither logically true nor false, and that would trigger an error on accessing a variable with it.  (I'll whitewash history a bit and say this state was always called "TRASH", and also always could not be put in blocks.)</p>
<p>This was the new state of unset variables:</p>
<pre><code>&gt;&gt; unset $x

&gt;&gt; x
** Error: X is an unset variable

&gt;&gt; get:any $x
== \~\  ; trash!

&gt;&gt; if get:any $x [print "Ornery!"]
** Error: trash is neither logically true nor false
</code></pre>
<p>So NULL now represented a middle ground.  It was something that was easy to test for being nothing (using IF) but that was impossible to accidentally put into a block.</p>
<p>This gave you three behaviors:</p>
<pre><code>[1]  &gt;&gt; trash-value
     ** Error: TRASH-VALUE variable is unset

[2]  &gt;&gt; null-value
     ; null

     &gt;&gt; append [a b] null-value
     ** Error: APPEND does not allow adding NULL to blocks

[3]  &gt;&gt; blank-value
     == _

     &gt;&gt; append [a b] blank-value
     == [a b _]
</code></pre>
<h2><a name="p-7690-word-antiforms-brought-infinite-non-valued-choices-4" class="anchor" href="https://rebol.metaeducation.com#p-7690-word-antiforms-brought-infinite-non-valued-choices-4"></a>WORD! Antiforms Brought Infinite Non-Valued Choices</h2>
<p>Eventually the NULL state became an isotope of the WORD! null, so a <strong>~null~</strong> antiform.</p>
<p>It joined <strong>~okay~</strong> as an antiform you could test for truthiness and falseyness.</p>
<p>You'd use the null antiform as the initialization for something you may run some code and find it doesn't assign, and you want to be able to test that.</p>
<pre><code> directory: ~null~

 for-each [key val] config [
     if key = 'directory [
         if directory [
             fail ["Directory was already set by config:" directory]
         ]
         directory: val
     ]
 ]
</code></pre>
<h2><a name="p-7690-void-provided-a-clean-opt-out-option-5" class="anchor" href="https://rebol.metaeducation.com#p-7690-void-provided-a-clean-opt-out-option-5"></a>VOID Provided a Clean "Opt-Out" Option</h2>
<p>An unfortunate sacrifice that had been made in the design was that the "non-valued" status of NULL was chosen to raise attention to an error condition, rather than be an opportunity to opt-out of an APPEND:</p>
<pre><code>&gt;&gt; append [a b] null-value
** Error: This error is the choice that we went with

&gt;&gt; append [a b] null-value
== [a b]  ; would have been another possibility, but too accident prone
</code></pre>
<p>Some "strange" things were tried...such as making it so that appending a BLANK! was a no-op, and if you wanted to append a literal blank you had to append a quoted blank:</p>
<pre><code> &gt;&gt; append [a b] _
 == [a b]  ; hmmm.

 &gt;&gt; quote _
 == '_

 &gt;&gt; append [a b] quote _
 == [a b _]  ; hmmm.
</code></pre>
<p><em>(It wasn't that strange considering appending a BLOCK! would append its contents, and a quoted block was being tried as the way of specifying /ONLY.  This line of thinking ultimately led to the <a href="https://rebol.metaeducation.com/t/a-justification-of-generalized-isotopes/1918">designs for the isotopes that solve things like splicing intent</a>, so it wasn't all for naught!)</em></p>
<p>After <a href="https://rebol.metaeducation.com/t/invisibility-reviewed-through-modern-eyes/2034">invisibles were rethought as GHOST (antiform comma)</a>, another unstable antiform state of VOID came as another piece of the puzzle.</p>
<pre><code>&gt;&gt; void
== \~[]~\  ; antiform (pack!) "void"

&gt;&gt; lift void
== ~[]~
</code></pre>
<p>I realized that void was the perfect choice for opting out of operations:</p>
<pre><code>&gt;&gt; append [a b] void
== [a b]

&gt;&gt; append void [a b c]
== \~null~\  ; antiform
</code></pre>
<p>As you see above, an operation can return null when it doesn't have another good answer for giving back in case of a no-op.  This gives good error locality, since the null won't trigger another opting out unless you explicitly convert the null to a void with OPT.</p>
<pre><code>&gt;&gt; append (append void [a b c]) [d e f]
** Error: APPEND doesn't accept ~NULL~ antiform for the series argument

&gt;&gt; opt null
== \~[]~\  ; antiform (pack!) "void"

&gt;&gt; append (opt append void [a b c]) [d e f]
== \~null~\  ; antiform
</code></pre>
<p>Beyond this, <a href="https://rebol.metaeducation.com/t/reified-unreassignable-nothingness-space-runes/2457">underscore became just the character literal for SPACE</a>...</p>
<p>This gives a (seemingly) complete picture</p>
<pre><code>[1]  &gt;&gt; trash-value
     ** Error: TRASH-VALUE variable is unset

      &gt;&gt; append [a b] get:any $trash-value
      ** Error: APPEND does not allow adding ~ antiforms to blocks
      
[2]  &gt;&gt; void-func  ; must be a function, since variables can't store void
     == \~[]~\  ; antiform (pack!) "void"

     &gt;&gt; append [a b] void-func
     == [a b]

[3]  &gt;&gt; null-value
     == \~null~\  ; antiform

     &gt;&gt; append [a b] null-value
     ** Error: APPEND does not allow adding NULL to blocks

[3a] &gt;&gt; opt null-value
     == \~[]~\  ; antiform (pack!) "void"

     &gt;&gt; append [a b] opt null-value
     == [a b]

[4]  &gt;&gt; space
     == _

     &gt;&gt; append [a b] space
     == [a b _]
</code></pre>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/null-void-trash-evolution-from-none-unset/2422">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/null-void-trash-evolution-from-none-unset/2422</link>
          <pubDate>Fri, 14 May 2021 14:44:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2422</guid>
          <source url="https://rebol.metaeducation.com/t/null-void-trash-evolution-from-none-unset/2422.rss">NULL/VOID/TRASH evolution from NONE!/UNSET!</source>
        </item>
        <item>
          <title>About the Redbol category</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>Issues regarding compatibility and emulation of <a href="http://www.rebol.com/docs/docs.html">Rebol2</a> and <a href="https://www.red-lang.org/p/about.html">Red</a>, as well as other things that would loosely be considered "Rebol-family" languages.</p>
<p>It's generally a goal that Ren-C be able to bend in order to do most anything that they can do...with modest effort.  Pursuant to that goal is the <a href="https://github.com/metaeducation/redbol/">Redbol module</a> to have an actual emulation of a reasonable compatible subset of the (non-GUI) portion of the languages.</p>
<p>More generally, this category is for discussing anything related to Rebol2 or Red semantics or features.</p>
<p><em>Note: R3-Alpha emulation is considered uninteresting, as it never gained much traction.  Most R3-Alpha codebases are either dead, <a href="https://github.com/Oldes/Rebol3">one of Oldes's projects</a>, or have been subsumed into Ren-C projects.</em></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/about-the-redbol-category/1312">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/about-the-redbol-category/1312</link>
          <pubDate>Tue, 28 Jul 2020 08:47:40 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1312</guid>
          <source url="https://rebol.metaeducation.com/t/about-the-redbol-category/1312.rss">About the Redbol category</source>
        </item>
        <item>
          <title>Red&#39;s Design Issues Wiki</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>Here's a page posted on Red's GitHub:</p>
<h2><a name="p-3818-red-design-questions-wikihttpsgithubcomredredwiki5blinks5d-design-questions-1" class="anchor" href="https://rebol.metaeducation.com#p-3818-red-design-questions-wikihttpsgithubcomredredwiki5blinks5d-design-questions-1"></a><a href="https://github.com/red/red/wiki/%5BLINKS%5D-Design-questions">Red Design Questions Wiki</a></h2>
<p>I'm bookmarking it here, along with some quick review notes.</p>
<h4><a name="p-3818-vector-matrix-dsl-design-2" class="anchor" href="https://rebol.metaeducation.com#p-3818-vector-matrix-dsl-design-2"></a>Vector &amp; matrix DSL design</h4>
<p>No real comment, other than it's interesting that the order of the page ranks things as "most influential".  While in Ren-C, R3-Alpha's VECTOR! has been removed from the core (you can build a Ren-C without it).  Hence it isn't one of the built-in types identified by a byte in the header.  So it's <a href="https://rebol.metaeducation.com/t/user-defined-datatype-discussion/1203">a primordial test of a custom type</a>, and that is the main lens through which its relevance is considered.</p>
<p>I'm sure if they want plenty of opinions on VECTOR! they can talk to Oldes.</p>
<h4><a name="p-3818-parse-dsl-simplify-fail-rule-to-end-skip-break-reject-to-return-successfailure-from-the-loop-whileanysome-break-now-as-an-emergency-exit-from-the-loop-bring-also-into-parsing-3" class="anchor" href="https://rebol.metaeducation.com#p-3818-parse-dsl-simplify-fail-rule-to-end-skip-break-reject-to-return-successfailure-from-the-loop-whileanysome-break-now-as-an-emergency-exit-from-the-loop-bring-also-into-parsing-3"></a>Parse DSL: simplify  <code>fail</code>  rule to  <code>[end skip]</code> ,  <code>break</code> / <code>reject</code>  to return success/failure  <em>from the loop (while/any/some)</em> ,  <code>break now</code>  as an emergency exit from the loop, bring  <code>also</code>  into parsing</h4>
<p>END SKIP as a way to force a fail is an amusing idea.  But much improvedly, Ren-C just gives meaning to LOGIC! true in PARSE as "keep parsing" and LOGIC! false as "fail here".  (See below for cool ramifications of that.)  So you can fail just by saying FALSE.  It takes away from the ability to match LOGIC! values literally, but you can't match INTEGER! values or BLOCK! values literally without a "QUOTE".  And with the <a href="https://rebol.metaeducation.com/t/quoted-arrives-formerly-known-as-lit-bit/995/2">generic quoting Red argues against</a> you've got more convenience in that area, e.g. <strong>'#[true]</strong> or <strong>'[a b c]</strong> or <strong>'3</strong>.</p>
<p>It is good for naming reasons, too since FAIL has very specific meaning in Ren-C (way to raise errors, <strong>fail "msg"</strong> is nicer than <strong>do make error! "msg"</strong> and provides a dialecting opportunity).</p>
<p>The rest I'd have to look at in more detail to have an opinion on.</p>
<h4><a name="p-3818-parse-dsl-rules-with-arguments-4" class="anchor" href="https://rebol.metaeducation.com#p-3818-parse-dsl-rules-with-arguments-4"></a>Parse DSL: rules with arguments</h4>
<p>If I read this right...Ren-C has all this and more with GET-GROUP!.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/boxing_glove.png?v=14" title=":boxing_glove:" class="emoji" alt=":boxing_glove:" loading="lazy" width="20" height="20">  This evaluates much like a plain GROUP! in a PARSE...but instead of the result vaporizing...it dynamically composes itself into the parse stream.  That makes it a full superset of PARSE's unusual IF...since in Ren-C LOGIC! true means "keep parsing" and LOGIC! false means "rule fails".  Thus <strong>:(mode = 'foo)</strong> gets you the continue-or-not you want.  But far more open-ended than that, especially since NULL vaporizes and continues the PARSE as #[true] would.  It's all kinds of keen:</p>
<p><a href="https://rebol.metaeducation.com/t/get-group-s-in-parse-mean-execute-and-splice-as-rule/968">GET-GROUP!s in PARSE mean execute-and-splice-as-rule</a></p>
<p>So if you want a dynamically generated rule as a function, just say <strong>:(my-rule-maker arg1 arg2)</strong> and it will be spliced in.</p>
<p>I consider that bit solved.  But the part that isn't solved is saving you the trouble of capturing material to pass separately...kind of as if you could extend PARSE with your function acting kind of like a keyword.  Imaginative pseudocode:</p>
<pre><code> &gt;&gt; print-reverse: parse-func [x] [print reverse x]
 &gt;&gt; parse "aaabcdef" [3 "a" print-reverse [to end]]
 fedcb
</code></pre>
<p>e.g. the "argument fulfillment" phase is using parse rules--and not the evaluator--to do it.  But where I lean in this direction is asking about whether there is a model by which PARSE can be extensible in the same way DO of a BLOCK! is extensible... some kind of analogue to regular functions that lets you batch together "native" PARSE extensions (like THRU or INTO) along with user-added ones that speak the protocol (as if someone could add COLLECT after-the-fact).</p>
<blockquote>
<p><strong>UPDATE:</strong> This has been <a href="https://rebol.metaeducation.com/t/introducing-uparse-the-hackable-usermode-parse/1529">hit with a bullseye by UPARSE</a>...and the problem of calling normal functions while passing them captured parse material is covered by <a href="https://rebol.metaeducation.com/t/if-action-combinators-dont-impress-i-dont-know-what-will/1608">the ACTION! combinator</a></p>
<pre><code> &gt;&gt; print-reverse: func [x] [print reverse x]
 &gt;&gt; uparse "aaabcdef" [3 "a" print-reverse/ [across to &lt;end&gt;]]
 fedcb
</code></pre>
<p><em>Yes, that actually works in UPARSE!</em></p>
</blockquote>
<h4><a name="p-3818-core-open-problems-of-the-object-design-5" class="anchor" href="https://rebol.metaeducation.com#p-3818-core-open-problems-of-the-object-design-5"></a>Core: open problems of the object design</h4>
<p>Tip of the iceberg of the problems with the model.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/ice.png?v=14" title=":ice:" class="emoji" alt=":ice:" loading="lazy" width="20" height="20">  While Ren-C inherited the same object-model madness, techniques like generic quoting <a href="https://rebol.metaeducation.com/t/generic-quoting-makes-headway-on-make-object/997">are making inroads representationally</a>, and things like <a href="https://github.com/metaeducation/ren-c/pull/727">derived binding</a> are aiding classic problems:</p>
<blockquote>
<p><em>"Derived binding is an interesting design that overcomes a serious weakness of historical Rebol combinatorics (where 1000 instances of an object with 50 member functions each had to make deep copies of the bodies of each function so the words in the bodies would point to the instance, so you're making 50,000 deep copies just to create those 1000 objects)."</em></p>
</blockquote>
<p>For a simple example, see <a href="https://github.com/metaeducation/ren-c/blob/3183acf3ee59e8ebc316ca5afeed09d493de8234/tests/datatypes/object.test.reb#L115">"O-Big"</a></p>
<h4><a name="p-3818-core-efficient-vector-arithmetic-6" class="anchor" href="https://rebol.metaeducation.com#p-3818-core-efficient-vector-arithmetic-6"></a>Core: efficient vector arithmetic</h4>
<p>Regarding their "<a href="https://github.com/red/red/issues/2216">Adding a number to a vector changes the vector itself #2216</a>", I have proposed a concept whereby operations like ADD and MULTIPLY follow Rebol's "mutate by default" rules, and PLUS (infix alias +) and TIMES (infix alias *) finesse the idea of not mutating.  These ideas originated in design for <a href="https://rebol.metaeducation.com/t/planning-ahead-for-bignum-arithmetic/623">efficient BigNum arithmetic</a>, which shares many of the same issues.</p>
<p>Devil is in the details there, but it proposes building things on a model that is foundationally mutating.</p>
<h4><a name="p-3818-vid-dsl-automatically-bind-literal-only-actor-reaction-bodies-to-the-face-7" class="anchor" href="https://rebol.metaeducation.com#p-3818-vid-dsl-automatically-bind-literal-only-actor-reaction-bodies-to-the-face-7"></a>VID DSL: automatically bind (literal only?) actor &amp; reaction bodies to the face?</h4>
<p>N/A.</p>
<h4><a name="p-3818-core-loop-return-values-8" class="anchor" href="https://rebol.metaeducation.com#p-3818-core-loop-return-values-8"></a>Core: loop return values</h4>
<p>Ren-C has a systemic <a href="https://rebol.metaeducation.com/t/the-simple-yet-powerful-magic-of-the-loop-result-protocol/609">loop return result protocol</a>.  All loops that BREAK return NULL, and there is no BREAK/RETURN.  If you wish to violate the protocol, you do so with THROW to a CATCH.</p>
<p>This is a helpful protocol for building your own loop constructs out of other loops...without having to reach in and figure out how to hook their BREAK.  Being able to tell from the outside if the loop was interrupted far outweighs the idea of BREAK/RETURN, and "heavy nulls" are an idea well worth it to ensure that pure NULL keeps its unique status for representing break.</p>
<h4><a name="p-3818-core-behavior-of-series-access-outside-the-data-boundaries-9" class="anchor" href="https://rebol.metaeducation.com#p-3818-core-behavior-of-series-access-outside-the-data-boundaries-9"></a>Core: behavior of series access outside the data boundaries</h4>
<p>I talk some about this in <a href="https://rebol.metaeducation.com/t/where-the-series-ends-simplifying-out-of-bounds-rules/1141">"Where the Series Ends"</a> <em>(for you young folks, that's a <a href="https://en.wikipedia.org/wiki/Where_the_Sidewalk_Ends">Shel Silverstein reference</a>)</em>.</p>
<h4><a name="p-3818-vid-dsl-should-it-allow-to-override-already-defined-actors-eg-base-on-down-probe-1-probe-2-10" class="anchor" href="https://rebol.metaeducation.com#p-3818-vid-dsl-should-it-allow-to-override-already-defined-actors-eg-base-on-down-probe-1-probe-2-10"></a>VID DSL: should it allow to override already defined actors (e.g.  <code>base on-down [probe 1] [probe 2]</code> )?</h4>
<p>N/A</p>
<h4><a name="p-3818-core-how-to-solve-inelegancies-and-dangers-of-error-try-attempt-and-catch-on-arbitrary-code-11" class="anchor" href="https://rebol.metaeducation.com#p-3818-core-how-to-solve-inelegancies-and-dangers-of-error-try-attempt-and-catch-on-arbitrary-code-11"></a>Core: how to solve inelegancies and dangers of  <code>error? try</code> ,  <code>attempt</code>  and  <code>catch</code>  on  <em>arbitrary</em>  code?</h4>
<p>As usual, it is hiiamboris asking the good questions!</p>
<blockquote>
<p><strong>UPDATE 2022: <em>Ren-C has an answer</em> with <a href="https://rebol.metaeducation.com/t/fail-vs-return-fail-the-new-age-of-definitional-failures/1852">"Definitional Failures"</a></strong> <img src="https://rebol.metaeducation.com/images/emoji/twitter/boom.png?v=14" title=":boom:" class="emoji" alt=":boom:" loading="lazy" width="20" height="20"></p>
<p>When originally writing this post in June 2020 all I said was that it was clear <em>"that conventional error-trapping should not conflate things that arise from "typos" with explicitly raised errors"</em>.</p>
<p>But I'm proud to say that yet another difficult question has been resolved with ^META/isotopic solutions (which during my brief conversations with Boris he did not appreciate, and I felt the dismissive attitude to another member of the Red audience was not worth trying to push through, vs. other uses of time).</p>
</blockquote>
<h4><a name="p-3818-web-how-should-cached-versions-of-remote-files-be-named-considering-user-friendliness-pathname-length-sanitization-of-invalid-chars-12" class="anchor" href="https://rebol.metaeducation.com#p-3818-web-how-should-cached-versions-of-remote-files-be-named-considering-user-friendliness-pathname-length-sanitization-of-invalid-chars-12"></a>Web: how should cached versions of remote files be named (considering user-friendliness, pathname length, sanitization of invalid chars)?</h4>
<p>Beyond the scope of current concerns, and likely not all that relevant as the main target is Wasm.</p>
<h4><a name="p-3818-core-should-operators-use-the-result-from-funcs-with-literal-arguments-if-f-func-xx-2-should-f-1-2-be-equivalent-to-f-1-2-13" class="anchor" href="https://rebol.metaeducation.com#p-3818-core-should-operators-use-the-result-from-funcs-with-literal-arguments-if-f-func-xx-2-should-f-1-2-be-equivalent-to-f-1-2-13"></a>Core: should operators use the result from funcs with literal arguments? (if  <code>f: func [:x][x * 2]</code> , should  <code>f 1 + 2</code>  be equivalent to  <code>(f 1) + 2</code> ?)</h4>
<p>Yes.  I won't delve into details on this esoteric (-seeming) point...other than to say that several features I'm very pleased with depend on this behavior.  <em>(For example: <a href="https://rebol.metaeducation.com/t/soft-quoted-branching-light-elegant-fast/1020">soft-quoted branching</a>.)</em>  I find no compelling points in any counter-argument worth sacrificing the related features.</p>
<h4><a name="p-3818-core-should-percent-type-allow-scientific-notation-and-should-it-be-constrained-in-range-14" class="anchor" href="https://rebol.metaeducation.com#p-3818-core-should-percent-type-allow-scientific-notation-and-should-it-be-constrained-in-range-14"></a>Core: should percent type allow scientific notation, and should it be constrained in range?</h4>
<p>Don't care.</p>
<h4><a name="p-3818-vid-dsl-should-panel-face-draw-a-text-facet-on-it-15" class="anchor" href="https://rebol.metaeducation.com#p-3818-vid-dsl-should-panel-face-draw-a-text-facet-on-it-15"></a>VID DSL: should  <code>panel</code>  face draw a  <code>text</code>  facet on it?</h4>
<p>N/A</p>
<h4><a name="p-3818-core-do-we-want-deep-refinement-for-take-16" class="anchor" href="https://rebol.metaeducation.com#p-3818-core-do-we-want-deep-refinement-for-take-16"></a>Core: do we want  <code>/deep</code>  refinement for  <code>take</code> ?</h4>
<p>Doesn't seem like the worst idea.  But I think the better angle is just to make sure that even if TAKE didn't have it, that someone who wanted it could make it easily.  So <a href="https://rebol.metaeducation.com/t/augment-add-parameters-and-refinements-after-the-fact/1216">features like AUGMENT</a> are geared in this direction.</p>
<h1><a name="p-3818-historical-questions-explanations-17" class="anchor" href="https://rebol.metaeducation.com#p-3818-historical-questions-explanations-17"></a>Historical questions &amp; explanations</h1>
<h4><a name="p-3818-arguments-on-why-paths-evaluate-picked-items-so-called-active-accessors-18" class="anchor" href="https://rebol.metaeducation.com#p-3818-arguments-on-why-paths-evaluate-picked-items-so-called-active-accessors-18"></a>Arguments on why paths evaluate picked items (so-called active accessors)</h4>
<p>It's a reasonable-sounding argument that it is "unlikely" that you want <strong>block/1</strong> to run the first function in a block.  But mechanically it's the simpler-seeming rule.  I guess it folds into a large part of the sketchiness that is path-processing.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/man_shrugging.png?v=14" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p>
<p>I will say that Ren-C's "get-pathing" and PICK-ing, and "set-pathing" and POKE-ing, are unified and run under the same dispatcher.  So <strong>:path/1</strong> and <strong>pick path 1</strong> are the same, and <strong>:path/x</strong> and <strong>pick path 'x</strong> are the same, for whatever those things happen to be.  There's not a separate codebase for getting paths from PICK or setting paths from POKE.  Hence it's called "path picking" and not "path selection".</p>
<h4><a name="p-3818-command-line-argument-parsing-rules-19" class="anchor" href="https://rebol.metaeducation.com#p-3818-command-line-argument-parsing-rules-19"></a>Command line argument parsing rules</h4>
<p><a href="https://github.com/metaeducation/ren-c/issues/996">This previously crossed my radar.</a>  If they do the work of writing test cases, sounds great.  Better them than me.</p>
<h4><a name="p-3818-why-word-and-a-single-word-path-are-different-despite-the-visual-similarity-20" class="anchor" href="https://rebol.metaeducation.com#p-3818-why-word-and-a-single-word-path-are-different-despite-the-visual-similarity-20"></a>Why word and a single-word path are different (despite the visual similarity)</h4>
<p>They shouldn't be, and single-word PATH!s should be outlawed...as WORD!s with all spaces are.  Ren-C has implemented PATH! immutability (at the "top level")...which isn't that unprecedented, as it makes them more parallel to TUPLE!.  By making paths immutable, it's possible to enforce a set of rules on them at the time of their creation (e.g. no PATH!s in their top level, that aren't inside GROUP!s, no FILE!s or URL!s, just GROUP!s/BLOCK!s/WORD!s/INTEGER!s etc.).</p>
<p>If this sounds constraining, consider the WORD! analogy again.  Making a PATH! with a PATH! in it like having a WORD! with a slash in it.  When things are immutable you have a moment of creation to enforce your check and then you just don't worry about it.  It works for WORD!, why not PATH!?</p>
<p>(You can still cheaply alias PATH!s via AS to get a BLOCK!...but the BLOCK! you get is simply read-only.  With "UTF-8 Everywhere" you can also alias WORD! as a string via AS, but once again the resulting value will be read-only.  <a href="https://rebol.metaeducation.com/t/as-binary-view-of-strings-is-back-with-utf-8-thats-only-part/1186">You can even alias them all as BINARY!</a>, as in Rebol2.  :-P)</p>
<p>The idea that PATH!s are some kind of generic "ANY-BLOCK!" is not all that compelling.  DocKimbel himself has complained about people wanting long or multi-line paths.  If you really want to mutate a path freely and promise not to end in a bad state, then COPY AS BLOCK! your path...muck with it, and then AS PATH! it (which will mark the underlying array read only, and do an integrity check that you didn't reduce it to one word).</p>
<p><em>(Overall this ties into great work done in Ren-C on PATH!, which includes generalizing REFINEMENT! so there isn't just <strong><code>/a</code></strong> but also <strong><code>a/</code></strong> and <strong><code>a//b</code></strong> ... a BLANK! in a PATH! is simply not rendered.  The immutability of paths means that even though <strong><code>/a</code></strong> is a 2-element path with a blank in the first slot, it can still be represented in one cell and not worry about being unable to handle mutations.  See <a href="https://rebol.metaeducation.com/t/heart-bytes-explained/1008">Heart <img src="https://rebol.metaeducation.com/images/emoji/twitter/heart.png?v=14" title=":heart:" class="emoji" alt=":heart:" loading="lazy" width="20" height="20"> Bytes</a>)</em></p>
<h4><a name="p-3818-core-get-word-function-argument-evaluation-semantics-r2-or-r3-like-final-21" class="anchor" href="https://rebol.metaeducation.com#p-3818-core-get-word-function-argument-evaluation-semantics-r2-or-r3-like-final-21"></a>Core: :get-word function argument evaluation semantics: R2- or R3-like? (final?)</h4>
<p>There absolutely has to be <em>some</em> way to literally get a symbol/value in the position, regardless of what it looks up to.  I don't know if I'm in love with the notation for <strong>:x</strong> for unescapable quoting and <strong>'x</strong> for escapable quoting, but that's a different question.</p>
<h4><a name="p-3818-core-how-to-allow-maps-to-have-none-values-22" class="anchor" href="https://rebol.metaeducation.com#p-3818-core-how-to-allow-maps-to-have-none-values-22"></a>Core: how to allow maps to have  <code>none</code>  values?</h4>
<p>Some day Red will realize how much they miss out on by not having NULL.  I guess it's kind of like societies that never grokked the invention of zero.</p>
<p><a href="https://rebol.metaeducation.com/t/null-blank-void-history-under-scrutiny/1249">NULL, BLANK!, VOID!: History Under Scrutiny</a></p>
<h4><a name="p-3818-core-how-money-datatype-equality-and-comparison-rules-should-work-23" class="anchor" href="https://rebol.metaeducation.com#p-3818-core-how-money-datatype-equality-and-comparison-rules-should-work-23"></a>Core: how money datatype equality and comparison rules should work?</h4>
<p><a href="https://www.youtube.com/watch?v=qMkkfuSizc4">It's like the Joker says...</a></p>
<h4><a name="p-3818-core-what-should-empty-any-and-all-return-24" class="anchor" href="https://rebol.metaeducation.com#p-3818-core-what-should-empty-any-and-all-return-24"></a>Core: what should empty  <code>any []</code>  and  <code>all []</code>  return?</h4>
<p><strong><a href="https://rebol.metaeducation.com/t/how-any-and-all-in-other-languages-act-on-empty-inputs/1830">UPDATE 2022: <em>both</em> Empty ANY and ALL return void.</a></strong>  When this post was originally written it was just ALL, and ANY returned null.  But it turns out to be so high leverage compared to the tiny benefit of making ANY null that we have to do it.  The proof is in the examples!</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/reds-design-issues-wiki/1282">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/reds-design-issues-wiki/1282</link>
          <pubDate>Sat, 06 Jun 2020 02:03:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1282</guid>
          <source url="https://rebol.metaeducation.com/t/reds-design-issues-wiki/1282.rss">Red&#39;s Design Issues Wiki</source>
        </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Parsing - AltRebol</title>
    <link>https://rebol.metaeducation.com/c/domains/parsing/16</link>
    <description>Topics in the &#39;Parsing&#39; category One of the most popular and developed dialects in Rebol is the PARSE dialect.</description>
    
      <lastBuildDate>Sun, 11 May 2025 20:08:44 +0000</lastBuildDate>
      <atom:link href="https://rebol.metaeducation.com/c/domains/parsing/16.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>COMMENT in PARSE takes BLOCK!/GROUP! quoted</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Something I did long ago to the regular COMMENT was made it so you could only comment out lists, e.g. you couldn't just comment out a WORD!.</p>
<p>If you could, this would happen:</p>
<pre><code>&gt;&gt; eval [comment print "hi"]
== "hi"
</code></pre>
<p>That's no good... so you can only use things that would evaluate as single elements.</p>
<pre><code>&gt;&gt; eval [comment print "hi"]
!! PANIC: `comment` does not take `word!` for its `ignored` argument
</code></pre>
<p>PARSE has a similar issue, though it <em>could</em> combinate a parser and just not call it:</p>
<pre><code>&gt;&gt; parse "aaa" [3 "a" comment across some "b"]
== "a"
</code></pre>
<p>But that's of questionable benefit.</p>
<p>In any case, forming a parser rule that's not going to be run is less efficient than just quoting material, which can be done on rules with illegal content:</p>
<pre><code>&gt;&gt; parse "a" [comment [across some "a" ~illegal~] "a"]
== "a"
</code></pre>
<p>So the COMMENT combinator takes its argument literally, and you can't COMMENT a WORD!...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/comment-in-parse-takes-block-group-quoted/2448">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/comment-in-parse-takes-block-group-quoted/2448</link>
          <pubDate>Sun, 11 May 2025 20:08:44 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2448</guid>
          <source url="https://rebol.metaeducation.com/t/comment-in-parse-takes-block-group-quoted/2448.rss">COMMENT in PARSE takes BLOCK!/GROUP! quoted</source>
        </item>
        <item>
          <title>Making position argument explicit in COMBINATOR</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Today's COMBINATOR implicitly gives you an argument called INPUT:</p>
<pre><code>tally: combinator [
    "Iterate a rule and count the number of times it matches"
    return: "Number of matches (can be 0)"
        [integer!]
    parser [action!]
][
    let count: 0
    cycle [
        [^ input]: parser input except [  ; INPUT not mentioned on interface
            remainder: input
            return count
        ]
        count: count + 1
    ]
]
</code></pre>
<p>You only have to specify the number of parsers (or non-combinated literal arguments) you take.</p>
<p>I observed an inconsistency, that the <strong><code>&lt;input&gt;</code></strong> combinator returns the input to the overall parse operation at its original position... not the current position.</p>
<p>Then I thought "hm, I don't know whether to change the argument to be called POSITION or POS.</p>
<h2><a name="p-8258-but-why-was-the-argument-implicit-to-begin-with-1" class="anchor" href="https://rebol.metaeducation.com#p-8258-but-why-was-the-argument-implicit-to-begin-with-1"></a>But Why Was The Argument Implicit To Begin With?</h2>
<p>Making it explicit is clearer, and lets you pick your own name for it:</p>
<pre><code>tally: combinator [
    "Iterate a rule and count the number of times it matches"
    return: "Number of matches (can be 0)"
        [integer!]
    pos [any-series?]  ; Maybe I like POS better than POSITION for arg 1
    parser [action!]
][
    let count: 0
    cycle [
        [^ pos]: parser pos except [
            remainder: pos
            return count
        ]
        count: count + 1
    ]
]
</code></pre>
<p>This also means that if your combinator is only applicable to specific series types (e.g. just lists, or just strings) then you can say that, and have type checking take care of it vs. having to put the check in the body of your combinator.</p>
<h2><a name="p-8258-should-remainder-be-explicit-too-2" class="anchor" href="https://rebol.metaeducation.com#p-8258-should-remainder-be-explicit-too-2"></a>Should REMAINDER Be Explicit Too?</h2>
<p>REMAINDER is an implicitly declared return value, that the combinator wrapping code will package up in a PACK! with whatever you RETURN as the main synthesized value.  <strong><a href="https://rebol.metaeducation.com/t/uparse-combinator-return-conventions-reviewed/2337">I've defended the choice to do it this way</a>.</strong></p>
<p>But for clarity, should combinators have some mention of REMAINDER in the interface?  Even something like an <code>&lt;assigns&gt;</code> TAG! in the spec?</p>
<pre><code>tally: combinator [
    "Iterate a rule and count the number of times it matches"
    return: "Number of matches (can be 0)"
        [integer!]
    pos [any-series?]
    parser [action!]
    &lt;assigns&gt; remainder
] ...
</code></pre>
<p>That could actually have some value, in that if you don't say it then you're implicitly saying your parser doesn't move the parse position... <em>and it could automatically assume the remainder is the input position for you.</em>  <img src="https://rebol.metaeducation.com/images/emoji/twitter/smiley.png?v=14" title=":smiley:" class="emoji" alt=":smiley:" loading="lazy" width="20" height="20">  Then there could be no binding for remander, so you'd get an error if you did try to assign it.</p>
<p>Good mojo.  I like it.</p>
<p>I don't think being able to rename remainder is that important, but it could be <strong><code>&lt;remainder&gt; rem</code></strong> or something like that, where you could.</p>
<p>But I think <strong><code>&lt;assigns&gt; remainder</code></strong> has more information in it.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/making-position-argument-explicit-in-combinator/2445">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/making-position-argument-explicit-in-combinator/2445</link>
          <pubDate>Sun, 11 May 2025 16:01:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2445</guid>
          <source url="https://rebol.metaeducation.com/t/making-position-argument-explicit-in-combinator/2445.rss">Making position argument explicit in COMBINATOR</source>
        </item>
        <item>
          <title>&quot;Surprising&quot; Ghosts: What Combinators Vanish?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p><a href="https://rebol.metaeducation.com/t/making-invisible-functions-e-g-comment-elide/2034">The vanishing intent of GHOST!</a> (antiform COMMA!) is now distinct from <a href="https://rebol.metaeducation.com/t/why-are-trash-and-void-distinct-in-ren-c/2416">the empty intent of VOID</a> (empty parameter pack, antiform BLOCK!).</p>
<pre><code>&gt;&gt; 1 + 2 ghost
== 3

&gt;&gt; 1 + 2 void
== ~[]~  ; anti
</code></pre>
<p>This has brought to the forefront the question of which combinators should support vanishing.</p>
<h2><a name="p-8211-right-now-if-end-matches-it-vanishes-1" class="anchor" href="https://rebol.metaeducation.com#p-8211-right-now-if-end-matches-it-vanishes-1"></a>Right Now, If <code>&lt;END&gt;</code> Matches, it Vanishes</h2>
<pre><code>&gt;&gt; parse [a b] [word! &lt;end&gt;]
** Error: PARSE mismatch

&gt;&gt; parse [a] [word! &lt;end&gt;]
== a
</code></pre>
<p>That's very useful.</p>
<p>Should TO and THRU--when parameterized with something that vanishes--also vanish?</p>
<pre><code>&gt;&gt; parse [a #b #c] [word! to &lt;end&gt;]
== a
</code></pre>
<p>Seems pretty useful <em>on the surface</em>.  But TO and THRU are intrinsically looping constructs...they iterate their rules.  This means you could wind up with something that sometimes vanishes, and sometimes does not:</p>
<pre><code>&gt;&gt; rule: [integer! | elide text!]

&gt;&gt; parse [a #b #c "hi"] [var: [word!, thru rule]]
== a  ; VAR got the product of WORD!

&gt;&gt; parse [a #b #c 1020] [var: [word!, thru rule]]
== 1020  ; VAR got the product of THRU RULE
</code></pre>
<p>That's a bit disorienting, how an elide managed to leak out.  It's like the structure of the parse code isn't doing what you expect.</p>
<p>This is why the main evaluator's loops and branching constructs are not willing to vaporize when they stand alone.  They're only willing to produce VOID.  This keeps the basic structure of the code from picking up results you don't expect, unless you call something that specifically is known to have vanishing intent (and you can ask to convert voids to ghosts explicitly if you want).</p>
<p>Even invoking a rule BLOCK! itself--if you think of rule invocation as like PARSE's version of calling a lambda--raises some questions about "surprising" ghosts:</p>
<pre><code>&gt;&gt; rule: [integer! | elide text!]

&gt;&gt; parse [a #b #c "hi"] [var: [word!, rule]]
== a  ; VAR got the product of WORD!

&gt;&gt; parse [a #b #c 1020] [var: [word!, rule]]
== 1020  ; VAR got the product of RULE
</code></pre>
<p>Unfortunately PARSE doesn't have the analogue of the GROUP! vs. BLOCK! distinction for code, where one can be transparent and the other "surprising".   <strong><code>[elide some [rule1 | rule2]]</code></strong> can be genuinely useful as a source grouping.</p>
<h2><a name="p-8211-on-that-note-should-lambda-be-willing-to-vanish-2" class="anchor" href="https://rebol.metaeducation.com#p-8211-on-that-note-should-lambda-be-willing-to-vanish-2"></a>On That Note, Should LAMBDA Be Willing To Vanish?</h2>
<p>At the moment, you get VOID and not GHOST from lambdas whose bodies vanish.</p>
<pre><code> &gt;&gt; test: lambda [] [comment "this is a test"]

 &gt;&gt; 1 + 2 test
 == ~[]~  ; anti (void)
</code></pre>
<p>It's hence impossible for a LAMBDA to produce a GHOST!... you have to use functions with a return value.  But does that make sense?</p>
<p><strong>I think I'm willing to say that lambdas and rule blocks can vanish.  They probably have to.</strong></p>
<p>But I'm just not 100% on board with the idea of this vanishing leaking out through other constructs.  It seems likely that you'd start getting "vanishing sometimes" behavior on accident.</p>
<p>So while it may seem nice if you're just looking at the specific case of <strong><code>to &lt;end&gt;</code></strong> vanishing, I think the long game favors saying that it's easy enough to write <strong><code>elide to &lt;end&gt;</code></strong> if you want.</p>
<p>Having plain <strong><code>&lt;end&gt;</code></strong> in isolation vanish is fine, because that's predictable and happens every time you use <strong><code>&lt;end&gt;</code></strong>.  But it wouldn't be so with vanishing every time you use TO... hence the problem with it.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/surprising-ghosts-what-combinators-vanish/2437">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/surprising-ghosts-what-combinators-vanish/2437</link>
          <pubDate>Wed, 07 May 2025 05:19:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2437</guid>
          <source url="https://rebol.metaeducation.com/t/surprising-ghosts-what-combinators-vanish/2437.rss">&quot;Surprising&quot; Ghosts: What Combinators Vanish?</source>
        </item>
        <item>
          <title>Dialecting Quasiforms In PARSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>The first thought I had about what quasiforms might be useful for would be to match a series of items as a splice:</p>
<pre><code>&gt;&gt; parse [a b c d] ['a ['b 'c 'd]]
== d

&gt;&gt; parse [a b c d] ['a ~(b c d)~]
== ~(b c d)~  ; anti
</code></pre>
<p>That's like the behavior of match literally of a splice:</p>
<pre><code>&gt;&gt; parse [a b c d] ['a @(spread [b c d])]
== ~(b c d)~  ; anti
</code></pre>
<p>But on the downside... if the behavior of quasiforms is taken to mean "match content", since antiforms can't occur in blocks then quasi-group would be the <em>only</em> useful antiform.  All the rest would be useless or have to come up with some custom definition.</p>
<p>Another possibility would be if quasiforms synthesized the antiform without matching anything:</p>
<pre><code>&gt;&gt; parse [a] ['a ~(b c d)~]
== ~(b c d)~  ; anti

 &gt;&gt; parse "aaa" [let x: ~null~ some "a" (x)]
 == ~null~  ; anti

 &gt;&gt; [x y]: parse "aaa" [some "a" ~['a '10]~ | some "b" ~['b '20]~]
 == a

 &gt;&gt; y
 == 10
</code></pre>
<p>But that's just a synonym for using GROUP! and code to synthesize the value (e.g. <strong><code>let x: (~null~)</code></strong> or <strong><code>let x: (null)</code></strong> instead of <strong><code>let x: ~null~</code></strong>).  The only advantage here is that it's faster (no execution required, just drop the quote byte from QUASIFORM_2 down to ANTIFORM_0).</p>
<p>(I've already contemplated the idea of <strong><code>x: ~null~</code></strong> vs. <strong><code>x: null</code></strong> as something which could be done in code that you're trying to micro-optimize.)</p>
<h2><a name="p-8057-but-dialecting-is-supposed-to-be-powerful-1" class="anchor" href="https://rebol.metaeducation.com#p-8057-but-dialecting-is-supposed-to-be-powerful-1"></a>But Dialecting Is Supposed To Be <em>Powerful</em>...</h2>
<p>Rote production of antiforms seems weak compared to dreaming up useful constructs.</p>
<p>e.g. quasi-TRIPWIRE could raise an error with a string (possibly even an interpolated one!)</p>
<pre><code>&gt;&gt; letter: #b

&gt;&gt; parse "aaa" [some letter | ~&lt;Expected all (letter)&gt;~]
** Error: Expected all b
</code></pre>
<p>That's quite compelling, and supports the argument that maybe customizing the meanings is worth it.  For instance ~[...]~ could actually run PACK vs. being the literal pack.</p>
<pre><code>&gt;&gt; [a b]: parse [10 20] [let x: integer! let y: integer! ~[x y]~]
== 10

&gt;&gt; a
== 10

&gt;&gt; b
== 20
</code></pre>
<p><em>"But that's not what the evaluator does with QUASI-BLOCK!"</em> you might say.  No, but it's inside PARSE, nothing is doing what the evaluator does.  That's the whole premise of the language!</p>
<p>A similar premise could apply to the splicing...and it doesn't even have to return a splice!</p>
<pre><code>&gt;&gt; middle-letter: 'c

&gt;&gt; parse [a b c d] ['a ~('b middle-letter 'd)~]
== [b c d]
</code></pre>
<p>All QUASI-words are available, while not all antiforms of words are legal.  Since parse is using quasiforms then it means every word is possible.  It could represent an error ID, or something else... maybe shorthands for things like accepting and rejecting?</p>
<pre><code>&gt;&gt; parse "aaabbb" [some "a" ~accept~]  ; synonym for [accept &lt;input&gt;]
== "aaabbb"
</code></pre>
<p><strong>Ok, I really like this idea, of clever applications, vs. simply synthesizing antiforms and not matching!</strong>  It's clearly much neater.</p>
<p>Ren-C has given Rebol quantum leaps in expressivity.</p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/frog.png?v=14" title=":frog:" class="emoji only-emoji" alt=":frog:" loading="lazy" width="20" height="20"> <img src="https://rebol.metaeducation.com/images/emoji/twitter/atom_symbol.png?v=14" title=":atom_symbol:" class="emoji only-emoji" alt=":atom_symbol:" loading="lazy" width="20" height="20"></p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/dialecting-quasiforms-in-parse/2379">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/dialecting-quasiforms-in-parse/2379</link>
          <pubDate>Sat, 22 Mar 2025 16:32:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2379</guid>
          <source url="https://rebol.metaeducation.com/t/dialecting-quasiforms-in-parse/2379.rss">Dialecting Quasiforms In PARSE</source>
        </item>
        <item>
          <title>UPARSE Combinator Return Conventions: Reviewed</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>UPARSE was an early client of multiple return values, at a time when they worked by assigning variables local to your frame, which were then proxied to items in a SET-BLOCK!:</p>
<pre><code> multi-returner: func [
     return: [integer!]
     secondary: [integer!]  ; SET-WORD! indicated another return
 ][
     secondary: 20
     return 10
 ]

 &gt;&gt; [ten twenty]: multi-returner
 == 10

 &gt;&gt; ten
 == 10

 &gt;&gt; twenty
 == 20
</code></pre>
<p>This basically made every multi-return function a kind of infix operation, that was able to take a SET-BLOCK! on its left hand side.  <a href="https://rebol.metaeducation.com/t/multiple-return-values-via-infix/1257">(In fact, it was prototyped using infix.)</a></p>
<p>But this method had composability problems, and was defeated by abstraction of any sort, even the most minor forms:</p>
<pre><code> &gt;&gt; [ten twenty]: (multi-returner)
 ** Error: even this wouldn't work
</code></pre>
<p>So the method gave way to returning antiform BLOCK!s.  These represented parameter packs that would "decay" to their first item in most circumstances...but SET-BLOCK!s were one of the cases that could pick them apart (though you could design other operations as well).</p>
<pre><code> multi-returner: func [
     return: [~[integer! integer!]~]
 ][
     return pack [10 20]
 ]
</code></pre>
<p>You can read all about it in <strong><a href="https://rebol.metaeducation.com/t/the-history-of-multi-return-in-ren-c/1134">The History of Multi-Return in Ren-C</a></strong></p>
<h2><a name="p-7932-so-local-proxies-diedbut-uparse-mimicked-them-1" class="anchor" href="https://rebol.metaeducation.com#p-7932-so-local-proxies-diedbut-uparse-mimicked-them-1"></a>So Local Proxies Died...But UPARSE Mimicked Them</h2>
<p>Just because the mechanics got rid of local proxies doesn't mean you can't fake them.  All you have to do is hack up its RETURN function to make a PACK using a local variable.</p>
<p>Simplified example:</p>
<pre><code> proxy-multi-func: adapt func/ [
      body: compose '[
          return: adapt return/ [
              ^atom: pack [^atom secondary]
          ]
          (as group! body)
      ]
 ]

 multi-returner: proxy-multi-func [
     return: [integer!]
     &lt;local&gt; secondary  ; could be specially marked, if spec rewritten
 ][
     secondary: 20
     return 10
 ]
</code></pre>
<p>So when the multi-return-by-antiform-block change happened, this is what COMBINATOR did instead of transition to having every combinator do <strong><code>return pack [synthesized remainder]</code></strong></p>
<p>Instead it worked the same as before: you'd set <strong>remainder</strong> however you wished, do <strong>return synthesized</strong>.  Except now the specialization of RETURN would PACK things up.</p>
<h2><a name="p-7932-why-did-combinator-preserve-proxying-2" class="anchor" href="https://rebol.metaeducation.com#p-7932-why-did-combinator-preserve-proxying-2"></a>Why Did COMBINATOR Preserve Proxying?</h2>
<p>Well... for starters, to show that it could be done.  You <em>should</em> be able to do it.  So having a living test case to hammer through any issues was good.</p>
<p>Also, because some combinators have two return values (synthesized and remainder), while others add a third (pending).  In truth the combinator always needs to return a pack of 3, it's just that some combinators automatically pipe the pending results from successful combinators to the output.  This means even if your combinator returned a pack of 2 in the piped case, that would have to be broken apart and turned into a pack of 3.  Having it in components helps.</p>
<p>But generally, I think it makes the code clearer as well.  Saying <strong><code>(return pack [x y])</code></strong> doesn't have any labeling, while <strong><code>(remainder: y, return x)</code></strong> is somewhat clearer, and you don't need to label the "primary" result because that's understood as what the combinator is synthesizing.</p>
<h2><a name="p-7932-synthesized-cant-be-proxied-unless-meta-3" class="anchor" href="https://rebol.metaeducation.com#p-7932-synthesized-cant-be-proxied-unless-meta-3"></a>Synthesized Can't Be Proxied (unless ^META)</h2>
<p>It's worth pointing out that there's a sort of design constraint here, when you're going to break out multi-return results and have them represented by local variables which are proxied by an adjusted RETURN...</p>
<p>...and that constraint is that you can't put unstable antiforms in variables.  So if you have something you want to return like an antiform pack (as combinators can legitimately synthesize), it has to be the main return result.</p>
<p>So since they use this proxying, combinators kind of break the rule of thumb of "don't make unstable antiforms your primary return in a multi-return situation".  This is because if you do:</p>
<pre><code>return pack [pack [1 2] "a"]
</code></pre>
<p>Then you face some ambiguity in terms of what people might think <strong><code>([x y]: multi-return-func)</code></strong> should mean... or what <strong><code>(x: multi-return-func)</code></strong> should mean.</p>
<p>But really, this is still being worked out.</p>
<h2><a name="p-7932-anyway-just-wanted-to-sum-up-uparse-return-4" class="anchor" href="https://rebol.metaeducation.com#p-7932-anyway-just-wanted-to-sum-up-uparse-return-4"></a>Anyway, Just Wanted To Sum Up UPARSE RETURN</h2>
<p>I was questioning it, and wanted to kind of work through why it is the way it is.  But I think it's right.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/uparse-combinator-return-conventions-reviewed/2337">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/uparse-combinator-return-conventions-reviewed/2337</link>
          <pubDate>Thu, 28 Nov 2024 00:35:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2337</guid>
          <source url="https://rebol.metaeducation.com/t/uparse-combinator-return-conventions-reviewed/2337.rss">UPARSE Combinator Return Conventions: Reviewed</source>
        </item>
        <item>
          <title>FENCE! In PARSE: What Should It Do?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>FENCE! is coming soon.  How soon?  ...soon.</p>
<p>When it gets here I'm going to want to kick the tires a bit with purposes in dialects.  And so of course a big question is: <strong>What will FENCE! do in PARSE?</strong>  <em>(By default, I mean...you can override it with whatever FENCE! combinator you want.)</em></p>
<p>It <em>might</em> seem an obvious use for it would be to make objects, e.g. act as GATHER:</p>
<p>So instead of:</p>
<pre><code>&gt;&gt; parse "aaabbb" [
      gather [
          emit x: collect some ["a", keep (&lt;a&gt;)]
          emit y: collect some ["b", keep (&lt;b&gt;)]
      ]
  ]
== make object! [
    x: [&lt;a&gt; &lt;a&gt; &lt;a&gt;]
    y: [&lt;b&gt; &lt;b&gt; &lt;b&gt;]
]
</code></pre>
<p>You might imagine writing:</p>
<pre><code>&gt;&gt; parse "aaabbb" [
      {
          x: collect some ["a", keep (&lt;a&gt;)]
          y: collect some ["b", keep (&lt;b&gt;)]
      }
  ]
== make object! [
    x: [&lt;a&gt; &lt;a&gt; &lt;a&gt;]
    y: [&lt;b&gt; &lt;b&gt; &lt;b&gt;]
]
</code></pre>
<p><strong>But I don't know if that's obviously a great application.</strong></p>
<p>We shouldn't be thinking inside-the-box that just because FENCE! is used for making objects sometimes, that's the most pressing need for them in dialects.  I actually think GATHER does a good enough job at what it does...and I think the above example reads more clearly with it.</p>
<p>But I've pointed to other rather weak areas, <strong><a href="https://rebol.metaeducation.com/t/implicit-capture-in-parse-how-to-get-it/1718">like how we don't have implicit capture</a></strong>.</p>
<pre><code>parse isodate [
    year: between &lt;here&gt; "-"
    month: between &lt;here&gt; "-"
    day: between &lt;here&gt; "T"
    ...
]
</code></pre>
<p>I'm not saying this is what we should use fences for, but just to kick-off that "outside-the-box" brainstorm:</p>
<pre><code>parse isodate [{year} "-" {month} "-" {day} "T" ...]
</code></pre>
<p>If my only choices were between that and an alternate for GATHER+EMIT, I'd pick that, because I think we'd get a lot more mileage out of it.</p>
<p>Remember also that there are lots of variations, like <strong><code>${...}</code></strong> and <strong><code>:{...}</code></strong> and whatever combinations in paths in chains and tuples you can think of.  Ideally how it's used makes some sense across these variants.  But we should remember that dialecting is about serving the domain, not making sacrifices to some god-of-consistency.</p>
<p><strong>Anyway...it's going to take time to build up a sense of what being "fency" means.</strong></p>
<p>But if any pet applications start coming to mind, pitch them.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/fence-in-parse-what-should-it-do/2312">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/fence-in-parse-what-should-it-do/2312</link>
          <pubDate>Thu, 10 Oct 2024 18:52:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2312</guid>
          <source url="https://rebol.metaeducation.com/t/fence-in-parse-what-should-it-do/2312.rss">FENCE! In PARSE: What Should It Do?</source>
        </item>
        <item>
          <title>Parsing/Destructuring a QUOTED! or QUASIFORM!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Quoteds (and quasiforms) can be seen kind of as containers...</p>
<p>But there isn't a good way to destructure them at the moment.</p>
<p>One off-the-cuff idea would be that you could SUBPARSE into them:</p>
<pre><code>&gt;&gt; parse ['a:] [subparse quoted! set-word!]
== a:

&gt;&gt; parse [''a:] [subparse quoted! subparse quoted! set-word!]
== a:

&gt;&gt; parse [~(a b c)~] [subparse quasiform! subparse group! [some word!]]
== c
</code></pre>
<p>A bit of a belabored method.  And because combinators require a series, I can't think of any efficient way to do that (vs. fabricating an array to hold a single item, and parsing that as a series.)  But it's better than no method at all.</p>
<p><strong>UPDATE:</strong> Having come up with a strategy for <a href="https://rebol.metaeducation.com/t/typechecking-quoted-forms-quasiforms-antiforms/2298">doing constraints like <strong><code>quote:quote:block?</code></strong></a>, it seems that covers a lot of use cases:</p>
<pre><code>&gt;&gt; parse ['a:] [&amp;quote:set-word!]
== a:

&gt;&gt; parse [''a:] [&amp;quote:quote:set-word!]
== a:

&gt;&gt; parse [~(a b c)~] [subparse &amp;quasi:group! [some word!]]
== c
</code></pre>
<p>It would require SUBPARSE to be willing to go inside quoted lists, which is easy enough to permit (and no reason not to, since it has to pass the type check you know what you're doing).</p>
<p>Seems to be reasonably powerful...just have to make peace with this strange new world of <em>dialecting the act of calling functions itself.</em> (!)</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/parsing-destructuring-a-quoted-or-quasiform/2300">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/parsing-destructuring-a-quoted-or-quasiform/2300</link>
          <pubDate>Fri, 27 Sep 2024 21:59:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2300</guid>
          <source url="https://rebol.metaeducation.com/t/parsing-destructuring-a-quoted-or-quasiform/2300.rss">Parsing/Destructuring a QUOTED! or QUASIFORM!</source>
        </item>
        <item>
          <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>R3-Alpha had an idea--carried forward by Red--of an <strong>arity-1</strong> IF combinator.</p>
<pre><code>red&gt;&gt; num: 1020

red&gt;&gt; parse [a a a] [if (even? num) some 'a]
== true

red&gt;&gt; parse [a a a] [if (odd? num) some 'a]
== false
</code></pre>
<p>As you see, if the expression you give it turns out to be "falsey" then it doesn't continue matching.  It skips to the next alternate--if there is one.</p>
<pre><code>red&gt;&gt; parse [a a a] [if (odd? num) some 'b | some 'a]
== true
</code></pre>
<p>But I always thought the arity-1 IF was a pretty alien thing that would confuse people.  You might think there's a branch, but there's no "branch"... just continuing along with the variadic list of everything that follows until the next <strong>|</strong> or end of BLOCK!.</p>
<p>I also wondered "where does it end?"  With an IF combinator, why not a CASE combinator, or SWITCH combinator?</p>
<p>So when I came up with GET-GROUP! doing arbitrary substitutions of the rule it evaluates to, I thought "hey, that's a lot more general!"  We could just say that ~true~ and ~void~ antiforms would continue the parse, ~false~ would stop it, and ~null~ antiforms would trigger an error in case you didn't mean to do that.</p>
<h3><a name="p-7569-what-that-get-group-concept-looked-like-1" class="anchor" href="https://rebol.metaeducation.com#p-7569-what-that-get-group-concept-looked-like-1"></a>What That <code>:(GET-GROUP!)</code> Concept Looked Like</h3>
<p><em>(Note that <strong>if condition '[...]</strong> is equivalent to <strong>if condition [[...]]</strong>.  This is called <a href="https://rebol.metaeducation.com/t/soft-quoted-branching-light-elegant-fast/1020">"soft-quoted branching"</a>)</em></p>
<pre><code>&gt;&gt; num: 1020, rule: null

; generated [some 'b] rule is treated as if it had been written there
&gt;&gt; parse [a a a b b b] [some 'a :(if even? num '[some 'b])]
== b 

; generated ~void~ from non-taken IF gets ignored, and it kept parsing
&gt;&gt; parse [a a a b b b] [some 'a :(if odd? num '[some 'c]) some 'b]
== b

; generated ~true~ signal continues parse, just as ~void~ did
&gt;&gt; parse [a a a b b b] [some 'a :(even? num) some 'b]
== b

; generated ~false~ skips to next alternate (isn't one, so parse fails)
&gt;&gt; parse [a a a b b b] [some 'a :(odd? num) some 'b]
** Error: PARSE BLOCK! combinator did not match input

; treat ~null~ conservatively, use :(maybe rule) for ~void~ to keep going 
&gt;&gt; parse [a a a b b b] [some 'a :(rule) some 'b]
** Error: ~null~ antiform generated by GET-GROUP! in PARSE
</code></pre>
<h2><a name="p-7569-flexible-logichttpsrebolmetaeducationcomtflexible-logic-system-terminology2252-kills-true-false-breaks-that-idea-2" class="anchor" href="https://rebol.metaeducation.com#p-7569-flexible-logichttpsrebolmetaeducationcomtflexible-logic-system-terminology2252-kills-true-false-breaks-that-idea-2"></a><a href="https://rebol.metaeducation.com/t/flexible-logic-system-terminology/2252">Flexible Logic</a> Kills <code>[~true~ ~false~]</code>... Breaks That Idea</h2>
<p>In the flexible logic model, <code>[TRUE FALSE ON OFF YES NO]</code> are WORD!s, and hence indiscriminately trigger taking the branch in something like an IF when used directly.  The ~null~ antiform is the "branch inhibitor", and it's what conditional expressions return when they don't match the condition.</p>
<pre><code>&gt;&gt; 10 &gt; 20
== ~null~  ; anti
</code></pre>
<p>I don't think it's a good idea to make substitions via GET-GROUP! (or whatever comes to replace it) silently continue on NULL.  If you forgot to set a variable that was supposed to hold something (as in <strong>rule</strong> above), that should give you an error.  But I don't think you should have to write <strong>:(maybe even? num)</strong> <img src="https://rebol.metaeducation.com/images/emoji/twitter/nauseated_face.png?v=14" title=":nauseated_face:" class="emoji" alt=":nauseated_face:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-7569-so-having-a-conditional-logic-combinator-makes-sense-3" class="anchor" href="https://rebol.metaeducation.com#p-7569-so-having-a-conditional-logic-combinator-makes-sense-3"></a>So Having A Conditional Logic Combinator Makes Sense</h2>
<p>I just think that IF is a rather lousy name for it.</p>
<p>So I'll suggest <strong>WHEN</strong>.</p>
<pre><code>&gt;&gt; parse [a a a b b b] [some 'a, when (even? num), some 'b]
== b 
</code></pre>
<p>It would be against the premise of flexible logic to have WHEN be biased and assume things like TRUE, YES, or NO should mean it continues or not.  I like the idea that you could hold a completely arbitrary word in a variable and say <strong><code>when (word)</code></strong>, that means <em>"continue matching when word is set to a non-null value"</em>.</p>
<p>Hence you'd have to say <strong><code>when (true? flag)</code></strong> or <strong><code>when (off? toggle)</code></strong> etc.  I'm not merely <em>comfortable</em> with this... I am gung-ho about it! <img src="https://rebol.metaeducation.com/images/emoji/twitter/comet.png?v=14" title=":comet:" class="emoji" alt=":comet:" loading="lazy" width="20" height="20"></p>
<p>(Of course people can make their own combinators and build in biases of their choosing, the core just doesn't pick sides.)</p>
<h2><a name="p-7569-bypass-can-be-a-synonym-for-when-null-4" class="anchor" href="https://rebol.metaeducation.com#p-7569-bypass-can-be-a-synonym-for-when-null-4"></a>BYPASS Can Be A Synonym For <code>[when (null)]</code></h2>
<p>I didn't like using FAIL for saying when to stop a rule chain and go to the next alternate, because that is used for causing "abrupt failures" in the system.</p>
<p>So I'd been using quasiform <code>~false~</code> the state in source (and the antiform if in a variable).</p>
<pre><code>&gt;&gt; parse [a a a b b b] [some 'a, :(if even? num [false]), some 'b]
** Error: PARSE BLOCK! combinator did not match input

&gt;&gt; parse [a a a b b b] [some 'a, ~false~, some 'b]
** Error: PARSE BLOCK! combinator did not match input
</code></pre>
<p>But that isn't the model anymore.  There is no ~false~ or ~true~ antiform.  And honestly it wasn't that literate anyway. <strong>when (...)</strong> makes it clearer when you're using a variable.  And the quasiform just looks confusing.</p>
<p>Searching for a good word that doesn't run into something serving other purposes (e.g. BREAK), I asked Claude.ai for suggestions, and one of those was BYPASS.</p>
<p>I like it.  So for example you could write:</p>
<pre><code>&gt;&gt; parse [a a a b b b] [some 'a [:(if even? num ['bypass]) some 'c] | some 'b]]
== b
</code></pre>
<p>Although that particular case is clearer as <strong><code>[when (odd? num) ...]</code></strong>, but sometimes you have to throw in a bypass rule.</p>
<p><em>(Amusingly, in Rebol2 the idiom for BYPASS was <strong><code>[end skip]</code></strong>, which was a rule guaranteed to mismatch at any position: either you weren't at the tail and the END wouldn't match, or you were at the tail and the END would match but then you couldn't SKIP.)</em></p>
<h2><a name="p-7569-where-does-it-stop-5" class="anchor" href="https://rebol.metaeducation.com#p-7569-where-does-it-stop-5"></a>Where Does It Stop?</h2>
<blockquote>
<p>I also wondered "where does it end?"  With an IF combinator, why not a CASE combinator, or SWITCH combinator?</p>
</blockquote>
<p>So I think it's good to just say WHEN.</p>
<p>You don't <em>technically</em> need WHEN if you have BYPASS to skip to next alternate, and ~void~ to keep going (or empty block, if you like... <code>[]</code> will keep going too).</p>
<pre><code> when (cond) =&gt; :(if not cond ['bypass])  ; or :(if not cond 'bypass)
</code></pre>
<p>But that forces you to reverse the sense of your logic and write out something longer (and slower).  I think if you've got logic that's complex like a case or switch, then writing it out as a splicing rule would have negligible benefit to try and shoehorn as a combinator.</p>
            <p><small>12 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253</link>
          <pubDate>Thu, 05 Sep 2024 20:19:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2253</guid>
          <source url="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
        </item>
        <item>
          <title>Deceptive Incomplete Parsing: A Common Problem</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Some code I'd written checked for file extensions, wanting only %.r and %.reb files to be processed.  It looked like this:</p>
<pre><code> for-each file ... [
     parse file [thru ".reb" | thru ".r"] else [continue]
     ...
 ]
</code></pre>
<p>That doesn't work anymore, because PARSE raises an error instead of returning null.  The ELSE needs to be an EXCEPT, or you have to use IF NOT OK?, or some other solution.</p>
<p>My first thought on fixing it was why not just put the CONTINUE inside the parse...</p>
<pre><code> for-each file ... [
     parse file [thru ".reb" | thru ".r" | (continue)]
     ...
 ]
</code></pre>
<p>That's a neat Rebolism that shows the kind of malleability other languages just don't have.</p>
<p>But it has a problem.  Can you spot it?</p>
<h2><a name="p-6736-old-redbol-conventions-wouldnt-catch-the-mistake-1" class="anchor" href="https://rebol.metaeducation.com#p-6736-old-redbol-conventions-wouldnt-catch-the-mistake-1"></a>Old Redbol Conventions Wouldn't Catch The Mistake</h2>
<p>Imagine if the file is named <strong>%foo.reb.zip</strong> or <strong>%foo.rar</strong>.  One of the THRUs succeeds, so it won't run the continue alternate.  But it won't reach the end of the filename.</p>
<p>Historical Redbol would have had the PARSE return false, but would have just blindly continued running, passing those unintended filenames!!!</p>
<p>Now we're a step ahead, because PARSE will error if it doesn't reach the end!  <img src="https://rebol.metaeducation.com/images/emoji/twitter/clap.png?v=14" title=":clap:" class="emoji" alt=":clap:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-6736-but-how-to-stop-the-error-2" class="anchor" href="https://rebol.metaeducation.com#p-6736-but-how-to-stop-the-error-2"></a>But How To Stop the Error?</h2>
<p>We don't want an error if it doesn't terminate in %.r or %.reb, we want to continue the loop.</p>
<p>This will work:</p>
<pre><code> parse file [thru ".reb" &lt;end&gt; | thru ".r" &lt;end&gt; | (continue)]
</code></pre>
<p>And it's not catastrophically bad.  But it feels weird.</p>
<p>You can remove the <code>&lt;end&gt;</code> duplication:</p>
<pre><code> parse file [thru [".reb" | ".r"] &lt;end&gt; | (continue)]
</code></pre>
<p>You can also do that with ANY:</p>
<pre><code> parse file [thru any [".reb" ".r"] &lt;end&gt; | (continue)]
</code></pre>
<p>You can of course go for the conventional forms:</p>
<pre><code>parse file [thru ".reb" | thru ".r"] except [continue]

if not ok? parse file [thru ".reb" | thru ".r"] [continue]
</code></pre>
<p>But I feel like there's something missing when you write something like this without making the <code>&lt;end&gt;</code> explicit...because it leads to someone getting the bright idea (as I did) to reformulate it without taking the <code>&lt;end&gt;</code> into account.</p>
<h2><a name="p-6736-in-any-case-this-being-overlooked-is-now-caught-3" class="anchor" href="https://rebol.metaeducation.com#p-6736-in-any-case-this-being-overlooked-is-now-caught-3"></a>In Any Case, This Being Overlooked Is Now Caught!</h2>
<p>It's food for thought on what style you want. But no matter what style you like, I think it shows a clear win for raising the error when the parse doesn't reach the end.</p>
<p>That %foo.rar or %foo.reb.zip -- when they occur -- will not be accepted quietly in the reformulation!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/deceptive-incomplete-parsing-a-common-problem/2065">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/deceptive-incomplete-parsing-a-common-problem/2065</link>
          <pubDate>Tue, 28 Nov 2023 03:33:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2065</guid>
          <source url="https://rebol.metaeducation.com/t/deceptive-incomplete-parsing-a-common-problem/2065.rss">Deceptive Incomplete Parsing: A Common Problem</source>
        </item>
        <item>
          <title>PERHAPS We Need a Shorthand for `inline (opt rule)` ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Today, rules that look up to NULL will PANIC in parse--right at the moment of fetching the word:</p>
<pre><code>&gt;&gt; prefix: null, suffix: ")"

&gt;&gt; parse "aaa)" [prefix, some "a", suffix]
** PANIC: (prefix is null, and we raise errors for that in parse)
</code></pre>
<p>If we didn't panic, there would really only be two other options:</p>
<ol>
<li>
<p>Make <strong><code>null</code></strong> always succeed, keeping the parse position where it is (synonym for <strong><code>[]</code></strong>)</p>
</li>
<li>
<p>Make <strong><code>null</code></strong> always be an unsuccessful combinator match, but not cause a failure (synonym for <strong><code>VETO</code></strong>)</p>
</li>
</ol>
<p>The behavior I'm looking for in this post is optionality, which would correspond to the "always succeed" behavior.  (e.g. if there is no prefix, so I want to skip worrying about matching it).  I feel it is pretty obvious that should not be the default behavior for encountering a null variable.</p>
<p>(If null variables did anything other than error, they should probably do (2) and not match... but I don't think that's very wise compared with panic'ing.)</p>
<h2><a name="p-6590-how-to-get-optionality-today-inline-opt-rule-1" class="anchor" href="https://rebol.metaeducation.com#p-6590-how-to-get-optionality-today-inline-opt-rule-1"></a>How To Get Optionality Today: <strong><code>inline (opt rule)</code></strong></h2>
<p>INLINE will take the synthesized product of the following rule (usually a GROUP!) and use it like a rule--as if it had been COMPOSE'd into the stream of operations.</p>
<p>If you inline a NULL, that's presumed to be an accident so it panics.  But if you inline a VOID, that is considered a no-op, so it does nothing.  Hence if you OPT a NULL to get a VOID and inline that, it will succeed with no effect:</p>
<pre><code>&gt;&gt; prefix: null, suffix: ")"

&gt;&gt; parse "aaa)" [inline (opt prefix), some "a", inline (opt suffix)]
== ")"
</code></pre>
<p>This works, but one can wonder about a combinator which was more succinct to accomplish the same thing, without the parentheses and without the OPT.</p>
<p>Since we don't have a name for it, let's call it PERHAPS for a moment:</p>
<pre><code>&gt;&gt; prefix: null, suffix: ")"

&gt;&gt; parse "aaa)" [perhaps prefix, some "a", perhaps suffix]
== ")"
</code></pre>
<p>It seems like a close parallel to OPT in the evaluative world, where NULL is turned into VOID with other things passed thru...</p>
<p>...but PARSE's OPT is entrenched as being about optionality of a rule that exists matching... not optionality of the rule itself.  So this is a fundamentally different intent.</p>
<h2><a name="p-6590-trickery-needed-to-combinate-null-2" class="anchor" href="https://rebol.metaeducation.com#p-6590-trickery-needed-to-combinate-null-2"></a>Trickery Needed To "COMBINATE" NULL</h2>
<p>Unless quoting is involved, the combinator that would be getting the NULL from a word lookup initially would be the WORD! combinator.</p>
<p>So when a parser gets produced from a WORD! combinator, when that parser is called by another combinated parser it will PANIC.  It can't return an ERROR!, because that would just be interpreted as a rule that didn't match.</p>
<p>So the only way I can see a null-tolerant PERHAPS fitting in would be that it would have to quote its argument, so the WORD! combinator didn't get involved.  It would then do the WORD! fetch itself, turning into a failing combinator if it fetched null.</p>
<p>That may seem to work, but...</p>
<h2><a name="p-6590-compositional-problems-with-perhaps-3" class="anchor" href="https://rebol.metaeducation.com#p-6590-compositional-problems-with-perhaps-3"></a>Compositional Problems With PERHAPS</h2>
<p>Let's say you wanted this:</p>
<p><em>"if there's a prefix, match some non-zero number of instances, but if prefix is null then don't worry about matching"</em>:</p>
<p>INLINE can do it:</p>
<pre><code>&gt;&gt; parse "aaa)))" [
       inline (when prefix '[some prefix])  ; when is IF, but VOID if no branch
       some "a"
       inline (when suffix '[some suffix])
   ]
== ")"
</code></pre>
<p>You can actually leverage VETO and COMPOSE here, to get the COMPOSE to cut itself short:</p>
<pre><code>&gt;&gt; parse "aaa)))" [
       inline (opt compose [some (any [prefix veto])])
       some "a"
       inline (opt compose [some (any [suffix veto])])
   ]
== ")"
</code></pre>
<p>You can shorthand that to get something brief that doesn't need to repeat PREFIX/SUFFIX.  But it would still be kind of long.</p>
<p>But what if we tried to do that with the hypothetical PERHAPS...could it work?</p>
<pre><code>&gt;&gt; parse "aaa)))" [some perhaps prefix, some "a", some perhaps suffix]
; infinite loop!
</code></pre>
<p>There's a problem here.  Because <strong>perhaps prefix</strong> just succeeds and doesn't advance the input when prefix is null.  But if you combine that with <code>some</code> the null case will just match nothing in perpetuity, causing an infinite loop.</p>
<p>This may look familiar, because if you write <strong>some opt [...anything...]</strong> you'll always get an infinite loop.  But in that case it's just wrong thinking: you know that the repetitive nature of <code>some</code> looking for an eventual non-match meant you must have intended <strong>some [...anything...]</strong> (at least one) or <strong>opt some [...anything...]</strong> (zero or more).</p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<h3><a name="p-6590-note-that-historical-parse-has-no-good-answer-for-this-4" class="anchor" href="https://rebol.metaeducation.com#p-6590-note-that-historical-parse-has-no-good-answer-for-this-4"></a>NOTE THAT HISTORICAL PARSE HAS NO GOOD ANSWER FOR THIS</h3>
<p>Rebol2 treats NONE! as a no-op which just succeeds but doesn't advance the input.  So the following gives you an infinite loop:</p>
<pre><code> rebol2&gt;&gt; prefix: none suffix: ")"

 rebol2&gt;&gt; parse "aaa)))" [some prefix some "a" some suffix]   
 ; infinite loop
</code></pre>
<p>The hackish "must make progress" rules in R3-Alpha actually make the above "work as intended", because the SOME will bail out after one non-advancing match.  I don't consider that a "good" answer--more a random effect.</p>
<h2><a name="p-6590-some-perhaps-is-semantically-perilous-5" class="anchor" href="https://rebol.metaeducation.com#p-6590-some-perhaps-is-semantically-perilous-5"></a><strong><code>some perhaps</code></strong> Is Semantically Perilous</h2>
<p>Parsers can only succeed or fail right now.  So for <strong>some perhaps</strong> to work, you'd have to be able to say something else: "opt out above me as far as you can, but be fundamentally successful".</p>
<p>How far would that make sense to go?  It would certainly have to stop at the BLOCK! combinator to be of any use.  But what makes the BLOCK! combinator special to squash the "bubble up opt-out success" idea?</p>
<p>The reason that INLINE can work with a cobbled together rule is because it can be specific about where the point of opting-out should stop.  If PERHAPS is nested inside and trying to signal that outward, it doesn't work.</p>
<h2><a name="p-6590-is-perhaps-still-useful-enough-to-make-6" class="anchor" href="https://rebol.metaeducation.com#p-6590-is-perhaps-still-useful-enough-to-make-6"></a>Is PERHAPS Still Useful Enough To Make?</h2>
<p>A quoting combinator that glosses over null rules seems useful--even if it can't be used in composition.  Though given that OPT is taken for something much more common and relevant to parsing, it's hard to give it a good name.</p>
<p>The alternative is perhaps use <strong><code>[]</code></strong> or some <strong><code>noop</code></strong> rule (if that's clearer/faster) as the state of your rule when it's not applicable.  But the whole thing is that you might want to use null for the state for its conditional falseyness for other parts of your situation.</p>
<p><em>Perhaps</em> it isn't necessary.  But it's been on my mind a while, and I wanted to write it up.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/perhaps-we-need-a-shorthand-for-inline-opt-rule/2023">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/perhaps-we-need-a-shorthand-for-inline-opt-rule/2023</link>
          <pubDate>Fri, 07 Apr 2023 00:14:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2023</guid>
          <source url="https://rebol.metaeducation.com/t/perhaps-we-need-a-shorthand-for-inline-opt-rule/2023.rss">PERHAPS We Need a Shorthand for `inline (opt rule)` ?</source>
        </item>
        <item>
          <title>Series Switching in PARSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p><strong>Rebol2 Prohibited Series Switching During a PARSE</strong></p>
<pre><code>&gt;&gt; series1: [a a a]
== [a a a]

&gt;&gt; series2: [b b b]
== [b b b]

&gt;&gt; parse series1 ['a :series2 some 'b]
** Script Error: Invalid argument: b b b
</code></pre>
<p>The error wasn't particularly informative.  But it was trying to tell you that you couldn't do that.</p>
<p><strong>Red Chose to Follow Suit, and Prohibits Series Switching During a PARSE</strong></p>
<p>red&gt;&gt; series1: [a a a]<br>
== [a a a]</p>
<p>red&gt;&gt; series2: [b b b]<br>
== [b b b]</p>
<p>red&gt;&gt; parse series1 ['a :series2 some 'b]<br>
*** Script Error: PARSE - get-word refers to a different series! :series2</p>
<p><strong>R3-Alpha Decided To Make It Legal</strong></p>
<pre><code>r3-alpha&gt;&gt; series1: [a a a]
== [a a a]

r3-alpha&gt;&gt; series2: [b b b]
== [b b b]

r3-alpha&gt;&gt; parse series1 ['a :series2 some 'b]
== true
</code></pre>
<p>I wasn't aware the feature was used, but <a class="mention" href="https://rebol.metaeducation.com/u/rgchris">@rgchris</a> used it in the Rebol3 version of altjson:</p>
<p><a href="https://github.com/rgchris/Scripts/blob/6fa69eabe11fe78b9fd0a7bd6bb17a923cee0b2b/r3-alpha/altjson.r3#L48" class="inline-onebox">Scripts/r3-alpha/altjson.r3 at 6fa69eabe11fe78b9fd0a7bd6bb17a923cee0b2b · rgchris/Scripts · GitHub</a></p>
<h2><a name="p-6421-the-feature-was-added-to-r3-alpha-circa-2009-1" class="anchor" href="https://rebol.metaeducation.com#p-6421-the-feature-was-added-to-r3-alpha-circa-2009-1"></a>The Feature Was Added to R3-Alpha Circa 2009</h2>
<p>Carl's blog entry:</p>
<p><a href="http://www.rebol.net/r3blogs/0265.html">http://www.rebol.net/r3blogs/0265.html</a></p>
<p>He points out one fairly clear reason why this is sketchy:</p>
<blockquote>
<p>The problem is this: if you change the series but the rule fails, forcing a recovery to a prior index, <em>it's still the new series</em>. That is, we do not recover to the old series.</p>
<p>If advanced users are willing to live with that restriction, then this change can be made.</p>
</blockquote>
<p>Another comment says the opposite of what I would think:</p>
<blockquote>
<p>Input switching would make parsing of big (or streaming) files more easy, as we wouldn't have to keep the whole data in memory, and could read it as needed, without losing the current parse state.</p>
</blockquote>
<p>Doing streaming parsing <em>correctly</em> requires <em>tighter</em> control over the process... not less.</p>
<h2><a name="p-6421-can-the-desire-be-met-other-ways-2" class="anchor" href="https://rebol.metaeducation.com#p-6421-can-the-desire-be-met-other-ways-2"></a>Can The Desire Be Met Other Ways?</h2>
<p>Since you're basically destroying the ability to meaningfully backtrack, I don't know how this is that different from starting a new parse.</p>
<p>I'd like it to be easy to return results out of a parse (see the <a href="https://rebol.metaeducation.com/t/uparses-spin-on-return/1589">RETURN/ACCEPT post</a>)</p>
<p>So why wouldn't you have some kind of driving loop on the outside of your parse that looks for a continuation signal, and then starts a new parse with what it's given?</p>
<p>I want to take a look at the cases and see if they could be done some other way.  So maybe <a class="mention" href="https://rebol.metaeducation.com/u/rgchris">@rgchris</a> can explain the rational behind the choice in altjson, and if there's some feature that would be a better fit.</p>
            <p><small>7 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/series-switching-in-parse/1974">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/series-switching-in-parse/1974</link>
          <pubDate>Tue, 20 Sep 2022 02:03:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1974</guid>
          <source url="https://rebol.metaeducation.com/t/series-switching-in-parse/1974.rss">Series Switching in PARSE</source>
        </item>
        <item>
          <title>SPREAD in PARSE: Isotopic Matching</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Remember that the <code>@var</code> rule will match the contents of variables literally, vs. running them as a rule:</p>
<pre><code>&gt;&gt; var: [some rule]
== [some rule]

&gt;&gt; parse [[some rule] [some rule]] [some @var]
== [some rule]
</code></pre>
<p>You can evaluate an expression to literally match, too:</p>
<pre><code>&gt;&gt; parse [[some rule] [some rule]] [some @(reverse copy [rule some])]
== [some rule]
</code></pre>
<p>Now there's a powerful new twist: <strong>You can match in a spliced fashion, using an antiform GROUP!</strong></p>
<pre><code>&gt;&gt; var: [some rule]

&gt;&gt; parse [some rule some rule] [some @(spread var)]
== ~(some rule)~  ; anti
</code></pre>
<p><em>And you can synthesize a product that may be a splice or not!!!</em></p>
<pre><code>&gt;&gt; append [a b c] parse [1 2 3] [block! | spread across some integer!]
== [a b c 1 2 3]

&gt;&gt; append [a b c] parse [[x y z]] [block! | spread across some integer!]
== [a b c [x y z]]
</code></pre>
<p><strong><a href="https://rebol.metaeducation.com/t/putting-splicing-intent-on-appended-value/1873">Encoding the splicing intent on the value is clearly the way to go.</a></strong>  Seems obvious now, but hindsight is 20/20.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/spread-in-parse-isotopic-matching/1949">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/spread-in-parse-isotopic-matching/1949</link>
          <pubDate>Wed, 31 Aug 2022 10:36:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1949</guid>
          <source url="https://rebol.metaeducation.com/t/spread-in-parse-isotopic-matching/1949.rss">SPREAD in PARSE: Isotopic Matching</source>
        </item>
        <item>
          <title>Matching Characters in BINARY! PARSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>In Rebol2, you can't match a character (or string) against a binary!:</p>
<pre><code>rebol2&gt;&gt; to binary! " "
== #{20}

rebol2&gt;&gt; parse #{20} [" "]
== false

rebol2&gt;&gt; parse #{20} [#" "]
== false
</code></pre>
<p>In Red and R3-Alpha, you can do both...</p>
<pre><code>red&gt;&gt; parse #{20} [" "]
== true

red&gt;&gt; parse #{20} [#" "]
== true
</code></pre>
<p>But their unicode model means they really don't know what they're doing in any general sense, and I'm sure whatever's under the hood is incoherent:</p>
<pre><code>red&gt;&gt; to binary! "Æ"
== #{C386}

red&gt;&gt; parse #{C386} ["Æ"]
== false
</code></pre>
<p>Ren-C is much more coherent!</p>
<pre><code>&gt;&gt; did parse #{C386} ["Æ"]
== #[true]
</code></pre>
<h2><a name="p-6298-so-the-parse-succeeds-but-what-should-it-return-1" class="anchor" href="https://rebol.metaeducation.com#p-6298-so-the-parse-succeeds-but-what-should-it-return-1"></a>So the PARSE Succeeds, but... what should it return?</h2>
<p>Right now a parse on a string returns the <em>rule</em> when it matches.</p>
<pre><code>&gt;&gt; rule: "cd"

&gt;&gt; result: parse "abcd" ["ab" rule]
== "cd"

&gt;&gt; append result "ef"
== "cdef"

&gt;&gt; rule
"cdef"
</code></pre>
<p><strong>This is clearly correct, because you don't want it to make a copy if it doesn't know if you're going to use the copy.</strong>  Basic rule matching should not produce a new series.</p>
<p>The same logic applies to BINARY!...but should it give you the string as a string, or aliased to its binary form?</p>
<pre><code>&gt;&gt; parse #{C386} ["Æ"]
== "Æ"  ; option 1

&gt;&gt; parse #{C386} ["Æ"]
== #{C386}  ; option 2
</code></pre>
<p>I think the answer is that you should match it as whatever form it was in the rule.</p>
<p>But then...how about something like BLANK!, which acts equivalently to space if the input is a string... or BLANK! if it's an array?</p>
<pre><code>&gt;&gt; parse [_] [_]
== _

&gt;&gt; parse " " [_]
== ???

&gt;&gt; parse #{20} [_]
== ???
</code></pre>
<p>If we're going with the idea of rule as being primacy, then the language of the match should be the same as the language of the rule... e.g. the above all return blank.</p>
<p>But this is something of a gray area, IMO.  I feel like blank is acting as a stand-in for space and should probably be looked at as if you said space.</p>
<pre><code>&gt;&gt; parse " " [_]
== #" "

&gt;&gt; parse #{20} [_]
== #" "  ; instead of 32
</code></pre>
<p>So this is what I'm going with, unless someone has a really good argument for something else.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/matching-characters-in-binary-parse/1935">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/matching-characters-in-binary-parse/1935</link>
          <pubDate>Sun, 21 Aug 2022 05:43:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1935</guid>
          <source url="https://rebol.metaeducation.com/t/matching-characters-in-binary-parse/1935.rss">Matching Characters in BINARY! PARSE</source>
        </item>
        <item>
          <title>TRY PARSE + PARSE EXCEPT : ERROR! On Mismatch</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>There's a snazzy new potential for giving more informative messages / logs from failed parses... which means we now have a more interesting option than we might have had before.</p>
<p>Imagine something like:</p>
<pre><code>&gt;&gt; parse "aaa" [some "a" some "b"]
** Error: SOME requires at least one match
** Where: [some "a" \\ some "b" \\]
; Note: this failure can be intercepted by TRY, EXCEPT, ATTEMPT
</code></pre>
<p>It can't be perfect unless it maintains some kind of large error tree that accumulates the list of all the reasons it decided to fail, so you might have to be in a debugging mode to ask it to give you a bigger diagnostic.  But we can build it now with the participation of the combinators themselves.</p>
<p><strong>But not only this, we could open up the full spectrum of return values.</strong>  Right now if your parse returns NULL, it has to be contorted into a "heavy null" PACK to avoid accidentally cuing an ELSE.  (Similar contortions for void.)</p>
<pre><code>result: parse block rules except e -&gt; [print "Got an error", return ~]

; If you got here, you know result is good
; Even if it was a purposefully returned NULL, etc.
</code></pre>
<p>You don't have to use infix if you don't want to:</p>
<pre><code> if error? ^result: parse block rules [
     print "You have a failure, use ^result to get it"
 ]
</code></pre>
<p>If you were willing to collapse failure down to a NULL or somesuch, or didn't even care about the result, you could just TRY it.</p>
<pre><code> try parse block rules
</code></pre>
<h2><a name="p-6269-too-good-not-to-be-the-default-1" class="anchor" href="https://rebol.metaeducation.com#p-6269-too-good-not-to-be-the-default-1"></a>Too Good Not To Be The Default</h2>
<p>Of course you'll be able to reskin it however you like for the R3C's or R3Chius out there.  But I think this looks like a perfect convergence to put in the box.</p>
<p>Errors aren't going to be that interesting on day one, but it's good to point the ship in the right direction.</p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/try-parse-parse-except-error-on-mismatch/1924">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/try-parse-parse-except-error-on-mismatch/1924</link>
          <pubDate>Fri, 19 Aug 2022 06:23:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1924</guid>
          <source url="https://rebol.metaeducation.com/t/try-parse-parse-except-error-on-mismatch/1924.rss">TRY PARSE + PARSE EXCEPT : ERROR! On Mismatch</source>
        </item>
        <item>
          <title>Wish: Multi-Returns For UPARSE Combinators</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Every combinator has a synthesized value.  But some combinators throw away values synthesized by their parser parameters.</p>
<p>For instance, TALLY.</p>
<pre><code>&gt;&gt; parse [1020 304] [int: some integer!]
== 304

&gt;&gt; parse [1020 304] [count: tally some integer!]
== 2
</code></pre>
<p>TALLY knows what the result of the last call it made was, but doesn't preserve it.  What if you could?</p>
<pre><code>&gt;&gt; parse [1020 304] [[count int]: tally some integer!]
== 2

&gt;&gt; count
== 2

&gt;&gt; int
== 304
</code></pre>
<p>That particular one is not necessarily a very interesting example, since you could get it yourself...</p>
<pre><code>parse [1020 304] [count: tally int: some integer!]
</code></pre>
<p>I only mention it because it was in a comment in UPARSE I wanted to delete, because it's a long enough file without becoming a wishlist compilation.  :-/</p>
<p>But there are certainly going to be other examples of combinators that might want to synthesize more than one value.  So hopefully the feature can be implemented at some point...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/wish-multi-returns-for-uparse-combinators/1920">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/wish-multi-returns-for-uparse-combinators/1920</link>
          <pubDate>Wed, 17 Aug 2022 14:43:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1920</guid>
          <source url="https://rebol.metaeducation.com/t/wish-multi-returns-for-uparse-combinators/1920.rss">Wish: Multi-Returns For UPARSE Combinators</source>
        </item>
        <item>
          <title>Calling Combinators (Decoders?) as Normal Functions</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>A few times I've talked about the potential of making it possible to call a COMBINATOR function from outside of PARSE.</p>
<p>This is to say that if some PARSE-specific parameter was missing (e.g. the "parse state") there'd be a mode in the guts of the COMBINATOR mechanic which cooked up something like a temporary parse session just for the input you passed in.</p>
<h2><a name="p-6238-would-it-combinate-parsers-for-you-1" class="anchor" href="https://rebol.metaeducation.com#p-6238-would-it-combinate-parsers-for-you-1"></a>Would It "Combinate" Parsers For You?</h2>
<p>The situations I had in mind weren't really combinators that take parsers as parameters.  And now that I look at it, I think that suggests that... no, you probably shouldn't call these kinds of combinators outside of parse.</p>
<p>Here's one imagination of calling a combinator like SOME:</p>
<pre><code>&gt;&gt; [value rest]: some "aaaabbb" [repeat 2 "a"]
== "a"

&gt;&gt; value
== "a"

&gt;&gt; rest
== "bbb"
</code></pre>
<p>This exposes how SOME is actually not arity-1.  Though it takes a "combinated parser" as a parameter, it also takes an INPUT...but that's usually implicit...specialized in by PARSE.  But calling directly from normal code it could offer that parameter being gathered normally.</p>
<p>it doesn't feel that compelling, since you're getting a synonym for:</p>
<pre><code>parse "aaaabbb" [some repeat 2 "a"]
</code></pre>
<p>But also, why would it take that interpretation instead of:</p>
<pre><code>parse "aaaabbb" [some ([repeat 2 "a"])]
</code></pre>
<p>One point of view would say it makes more sense to think of the expression as the product of evaluation, because the argument would presumably be otherwise evaluative:</p>
<pre><code>&gt;&gt; [value rest]: some "aaaabbb" append [repeat 2] "a"
== ??? ; infinite loop?
</code></pre>
<p>But this would make rule-taking combinators nearly useless.</p>
<h2><a name="p-6238-it-was-suggested-for-sharing-decoding-not-combinating-2" class="anchor" href="https://rebol.metaeducation.com#p-6238-it-was-suggested-for-sharing-decoding-not-combinating-2"></a>It Was Suggested For Sharing "Decoding", not "Combinating"</h2>
<p>Seeing how SOME isn't a good example for this, maybe the right way of saying what I'm trying to say here this is that there's some category of functions we might call "decoders"...and PARSE would be willing to call these.</p>
<p>They'd fit a standard format regarding things like taking an input series and giving back an amount of progress or an error.  But they would not be passed something like the parser stack or have any automatic composition of parsers as arguments.</p>
<p>Plain decoding operations--like <a href="https://rebol.metaeducation.com/t/binary-dialected-encoding-decoding-instead-of-to-conversions/1270">ENBIN and DEBIN</a>--were the motivating cases:</p>
<pre><code>&gt;&gt; debin #{FEFFFF} [le + 3]
== 16777214

&gt;&gt; parse #{FEFFFFFEFFFF} [collect [keep debin [le + 3]]]
== [16777214 16777214]
</code></pre>
<p>The idea here was that you could write one version of DEBIN, and it would be able to implicitly pick up the INPUT when used in PARSE.</p>
<p>But because the input is an implicit parameter that you get automatically for all "decoders", then without extra information it would have to be at either the beginning or end of the parameter list.  Above it's at the beginning, which is different from how DEBIN was defined originally:</p>
<pre><code>&gt;&gt; debin [le + 3] #{FEFFFF}  ; original DEBIN design took dialect block first
== 16777214
</code></pre>
<p><em>(Note: I have a post about <a href="https://rebol.metaeducation.com/t/parameter-order-in-rebol/1238">parameter ordering</a> which questions the series-first model.)</em></p>
<p>We could say that "decoders" have to manually mention their input parameter somewhere, and position it in the order that it would be consumed if it's used outside of PARSE...which would allow customization of this process.  It could default to being the first parameter if not positioned explicitly.  Not an idea-killer, in any case.</p>
<h2><a name="p-6238-if-all-the-input-wasnt-consumed-it-would-error-3" class="anchor" href="https://rebol.metaeducation.com#p-6238-if-all-the-input-wasnt-consumed-it-would-error-3"></a>If All The Input Wasn't Consumed, It Would Error</h2>
<p>One idea of calling these decoders on arbitrary input could be that if the end of input was not reached, it would give an error:</p>
<pre><code>&gt;&gt; debin [le + 3] #{FEFFFF00}  ; asking for 3 bytes of decode, passed 4
** Error: DEBIN did not consume all input, request remainder if intentional
</code></pre>
<p>Asking for a remainder could prevent the error:</p>
<pre><code>&gt;&gt; [value rest]: debin [le + 3] #{FEFFFF00}
== 16777214

&gt;&gt; rest
== #{00}
</code></pre>
<p>So this is kind of where the motivation is.  Once you've written the decoder version of DEBIN, you have everything you need to run a DEBIN operation inside or outside of PARSE.  So why should you need to write a separate combinator and non-combinator form?</p>
<p>As usual, more thought needed.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/face_with_head_bandage.png?v=14" title=":face_with_head_bandage:" class="emoji" alt=":face_with_head_bandage:" loading="lazy" width="20" height="20"></p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/calling-combinators-decoders-as-normal-functions/1914">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/calling-combinators-decoders-as-normal-functions/1914</link>
          <pubDate>Mon, 15 Aug 2022 07:39:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1914</guid>
          <source url="https://rebol.metaeducation.com/t/calling-combinators-decoders-as-normal-functions/1914.rss">Calling Combinators (Decoders?) as Normal Functions</source>
        </item>
        <item>
          <title>The &quot;Yada Yada Yada&quot; Operator (...)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>It seemed we could have a shorter way to say <strong><code>to &lt;end&gt;</code></strong> (or <strong><code>thru &lt;end&gt;</code></strong>, they act the same).</p>
<pre><code> &gt;&gt; parse "aabbcc" [some "a" to &lt;end&gt;]
 == ""
</code></pre>
<p>In fact, what you want more often is probably <strong><code>elide to &lt;end&gt;</code></strong>.  Because the <strong><code>&lt;end&gt;</code></strong> combinator currently evaluates to the end position of the series (hence the "" you see above, as the TO returns what its argument evaluates to.)</p>
<pre><code> &gt;&gt; parse "aabbbcc" [some "a" elide to &lt;end&gt;]
 == "a"
</code></pre>
<p>A kind of obvious choice for meaning this would be <strong><code>...</code></strong></p>
<pre><code> &gt;&gt; parse "aabbbcc" [some "a" ...]
 == "a"
</code></pre>
<p><sub><em>(Initially I was skeptical of using <code>...</code> without some decoration, and did this with the TAG! of <code>&lt;...&gt;</code>, but I think the reasons I was skeptical are probably not good reasons, and we should go ahead and make it  easier on the eyes and easier to type.)</em></sub></p>
<h2><a name="p-6050-but-why-should-it-only-work-at-the-end-1" class="anchor" href="https://rebol.metaeducation.com#p-6050-but-why-should-it-only-work-at-the-end-1"></a>But Why Should It Only Work At The End?</h2>
<p>This seems useful:</p>
<pre><code> &gt;&gt; parse "aabbbcc" [... some "b" ...]
 == "b"
</code></pre>
<p>But isn't that just a synonym for THRU, with the exception that if there's nothing to go THRU it assumes you mean <code>&lt;end&gt;</code> ?</p>
<p><em>Well, a synonym for THRU isn't really what you want.</em>  You'd probably like this to work:</p>
<pre><code> &gt;&gt; parse "aabbbcc" [... some "x" | some "b" ...]
 == "b"
</code></pre>
<p>In essence, you want it to implicitly wrap anything to the right--up to the next <code>&lt;...&gt;</code>--in a BLOCK!, so act equivalently to:</p>
<pre><code> &gt;&gt; parse "aabbbcc" [thru [some "x" | some "b"] elide to &lt;end&gt;]
 == "b"
</code></pre>
<p>That's not possible for a normal combinator, you'd need a variadic one.</p>
<p>Today's approximation of variadic combinators is to just special-case the implementation directly in the BLOCK! combinator.</p>
<p><strong>So...that's what I've done!</strong></p>
<p>A more elegant way of writing the feature may come down the pipe someday.  But this gives us a version we can use in the here and now.</p>
<p>It's experimental, so use with caution.</p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/man_scientist.png?v=14" title=":man_scientist:" class="emoji only-emoji" alt=":man_scientist:" loading="lazy" width="20" height="20"></p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/the-yada-yada-yada-operator/1876">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/the-yada-yada-yada-operator/1876</link>
          <pubDate>Tue, 12 Jul 2022 14:55:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1876</guid>
          <source url="https://rebol.metaeducation.com/t/the-yada-yada-yada-operator/1876.rss">The &quot;Yada Yada Yada&quot; Operator (...)</source>
        </item>
        <item>
          <title>Semantics of UPARSE&#39;s FURTHEST</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Upon the announcement of UPARSE, <a class="mention" href="https://rebol.metaeducation.com/u/brett">@Brett</a> listed as his <a href="https://rebol.metaeducation.com/t/introducing-uparse-the-hackable-usermode-parse/1529/4">secondmost missing feature</a> the idea of knowing "how far a parse got":</p>
<blockquote>
<ol start="2">
<li>An ability to return the furthest input point matched and the rule that caused rollback from there on parse failure. During development of rules this generally indicates the rule that is not properly specified.</li>
</ol>
</blockquote>
<p>What I've done is make it so combinators use a common generator COMBINATOR.  This generator takes the function body you give it, and stuffs in some boilerplate parameters (like the INPUT and STATE).  But it also wraps your code with some more boilerplate that can run before and after the parser.</p>
<p>The current idea of the "parser state" is just to pass around the FRAME! of the UPARSE operation itself.  So if you have any global state you want visible to the parse you can put it there.  Hence the state gives every combinator access to the arguments, return values, and locals of the invocation.</p>
<p>I made <strong>FURTHEST</strong> a multi-return value.  The hooked combinators are run, and then if they succeed they're checked to see if they got further than any previous combinator.  If so they update furthest.</p>
<pre><code>&gt;&gt; [_ furthest]: uparse "aaabbb" [some "a" some "c"]
; null

&gt;&gt; furthest
== "bbb"
</code></pre>
<h2><a name="p-6031-i-notice-to-and-ahead-skew-furthest-a-bit-far-1" class="anchor" href="https://rebol.metaeducation.com#p-6031-i-notice-to-and-ahead-skew-furthest-a-bit-far-1"></a>I Notice TO and AHEAD Skew FURTHEST a Bit Far...</h2>
<p>Consider the case of the <strong>TO</strong> combinator.  It's supposed to move the parse position to <em>right before</em> an instance of the matching rule.</p>
<p>But the subtlety of backing up that position is lost on FURTHEST...which just noticed that a successful parser run occurred, and updates the high water mark:</p>
<pre><code>&gt;&gt; [result furthest]: uparse "aabbcc" [to "bb"]
; null

&gt;&gt; furthest
== "cc"  ; not "bbcc"
</code></pre>
<p>It's a problem that's kind of a parallel with rollback.  <em>Which leads to the discovery of a quirk!</em> TO does not manage its "pending" list explicitly...it uses the default "auto-routing".  Hence the success of the last parser it calls--whose advancement it doesn't want--counts in a collect:</p>
<pre><code>&gt;&gt; uparse "aabbcc" [collect to [some keep "b"], elide [2 "b" 2 "c"]]
== ["b" "b"]
</code></pre>
<p>Is that right?  (cc: <a class="mention" href="https://rebol.metaeducation.com/u/rgchris">@rgchris</a>)  If it's <em>not</em> right, then it would seem that any KEEPs inside a TO rule should never have an effect.  That seems strictly less powerful than being <em>able</em> to grab things when you find an ahead-match, so I think it's okay.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/question.png?v=14" title=":question:" class="emoji" alt=":question:" loading="lazy" width="20" height="20"></p>
<p>But with FURTHEST it's less clear.</p>
<h2><a name="p-6031-pathology-studies-how-about-minmatch-2" class="anchor" href="https://rebol.metaeducation.com#p-6031-pathology-studies-how-about-minmatch-2"></a>Pathology Studies: How About MINMATCH?</h2>
<p>I made MAXMATCH as a case study of different approaches to influence on COLLECT:</p>
<p><strong><a href="https://github.com/metaeducation/ren-c/blob/8ed60125a473fe285e56213f82a6e7e4fa1d9e5a/tests/parse/examples/maxmatch.parse.test.reb">maxmatch.parse.test.reb</a></strong></p>
<p>Similarly we could ask about MINMATCH, and what its participation with FURTHEST should be.</p>
<p>It could call two parsers...have both succeed...and then only advance the smaller amount of the two.  We might say this "foils" a wrapper-based approach to updating furthest, as it would be advanced by the larger amount.</p>
<p>I'm hesitant to burden combinator authors with another parameterization just to express distinctions for the purposes of FURTHEST.  But it's a good thought experiment for what the limits are.</p>
<aside class="quote no-group quote-modified" data-username="Brett" data-post="4" data-topic="1529">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/brett/48/177_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/introducing-the-hackable-usermode-parse-uparse/1529/4">Introducing The Hackable Usermode PARSE ("UPARSE")</a></div>
<blockquote>
<p>... and the rule that caused rollback from there on parse failure. During development of rules this generally indicates the rule that is not properly specified.</p>
</blockquote>
</aside>
<p>I'm not really sure what the behavior here would be.</p>
<p>Maybe you can look at <a href="https://github.com/metaeducation/ren-c/blob/fb0d6758fa53d6b004cf96940aaaefc95853d615/scripts/uparse.reb#L82">how the furthest detection works</a> and explain in the context of the code what you would want.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/semantics-of-uparses-furthest/1868">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/semantics-of-uparses-furthest/1868</link>
          <pubDate>Sat, 09 Jul 2022 12:21:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1868</guid>
          <source url="https://rebol.metaeducation.com/t/semantics-of-uparses-furthest/1868.rss">Semantics of UPARSE&#39;s FURTHEST</source>
        </item>
        <item>
          <title>Should &quot;Arity-2 INTO&quot; in UPARSE actually just be... PARSE?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>There's a cool feature that UPARSE's INTO is willing to take a rule that gives the data you want to parse into, even if it has to be synthesized:</p>
<pre><code>&gt;&gt; uparse "(1 1 1)" [
    into [between "(" ")"] [data: &lt;here&gt; (print mold data) some integer!]
]
</code></pre>
<p>That will give you:</p>
<pre><code>"1 1 1"  ; notice no ")" because the INTO copied the data spanning the rule
== 1
</code></pre>
<p><em>(I threw in the INTEGER! transcode for fun there.  Note that Red allows the transcoding rules for datatypes as well, but only on BINARY! input series. It's because they don't have UTF-8 everywhere, they'd have to rewrite their scanner to process variable-width strings. One of the uncountable Ren-C design advantages...)</em></p>
<p>More generally, you can pass any variable you want to INTO.</p>
<pre><code>&gt;&gt; uparse [1 2 3] [some integer! into ("aaa") some "a"]
== "a"
</code></pre>
<h2><a name="p-6010-but-couldnt-we-just-call-that-parse-1" class="anchor" href="https://rebol.metaeducation.com#p-6010-but-couldnt-we-just-call-that-parse-1"></a>But... Couldn't We Just Call That PARSE?</h2>
<p>This arity-2 INTO takes an input, and rules.  Why isn't that just PARSE?</p>
<p>Difference is that since it's inside a parse already, its first parameter will be treated as a rule and use the synthesized result...unless you put it in a GROUP!.  But that's implicit.  Maybe call it SUBPARSE to be clear?</p>
<p>It would free up the keyword INTO, maybe to be compatible with historical single-arity version, for cases that have already figured out they're at a series value and don't want to repeat themselves by giving a rule that matches where they know they are.</p>
            <p><small>6 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-arity-2-into-in-uparse-actually-just-be-parse/1864">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-arity-2-into-in-uparse-actually-just-be-parse/1864</link>
          <pubDate>Wed, 06 Jul 2022 03:53:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1864</guid>
          <source url="https://rebol.metaeducation.com/t/should-arity-2-into-in-uparse-actually-just-be-parse/1864.rss">Should &quot;Arity-2 INTO&quot; in UPARSE actually just be... PARSE?</source>
        </item>
        <item>
          <title>Parsing Alternates: Should &quot;Must Match To End&quot; Be Considered?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>I didn't quite absorb that the following was the case in all PARSEs we know of:</p>
<pre><code> &gt;&gt; parse [a b] [word! word!]
 == truthy

 &gt;&gt; parse [a b] [word!]
 == falsey

 &gt;&gt; parse [a b] [word! | word! word!]
 == falsey
</code></pre>
<h2><a name="p-5953-distinctly-self-aware-terminal-blocks-could-they-be-good-1" class="anchor" href="https://rebol.metaeducation.com#p-5953-distinctly-self-aware-terminal-blocks-could-they-be-good-1"></a>Distinctly Self-Aware "Terminal Blocks", Could They Be Good?</h2>
<pre><code>&gt;&gt; uparse [a b] [word! | word! word!]
== b
</code></pre>
<p>I'd argue that there already are "two types of blocks":</p>
<ol>
<li>
<p>There are blocks that give a truthy result when they don't reach the end, but don't have any match failures</p>
</li>
<li>
<p>There are blocks that can succeed on every match but not reach the end, but be an overall failure</p>
</li>
</ol>
<p>Right now we know these blocks by context.  The main rule block you give to PARSE is of type 2, and so is the block given to an INTO.</p>
<p>It's a very small semantic difference to say that "they're the same kind of block, with the decisions about them being made by their caller".  Why not allow them to be different kinds of blocks?</p>
<h2><a name="p-5953-it-would-be-weird-if-it-propagated-2" class="anchor" href="https://rebol.metaeducation.com#p-5953-it-would-be-weird-if-it-propagated-2"></a>It Would Be Weird If It Propagated</h2>
<p>Here's an example of the kind of weirdness you'd get into if we said it wasn't a property <em>strictly</em> of the root blocks, but rather "any block that found itself at the end of a chain":</p>
<pre><code>&gt;&gt; parse [] [[(print "A") | (print "B")] [(print "C") | (print "D")]]
A
C
D
</code></pre>
<p>Being a "category 2 block", we see how the outer rule block would be creating some irritating asymmetry by saying that any block that knew it wasn't going to reach the end got the privilege.</p>
<p>So I definitely don't like that.</p>
<p><strong>But I'm suggesting a sticky property of blocks, that they effectively already had, being allowed to influence one thing besides whether they are forced to reach the end to succeed... that those blocks also get to try all their alternates before saying they failed.</strong></p>
<p>It's like because they're under more pressure they are given a resource to fall back on to succeed <img src="https://rebol.metaeducation.com/images/emoji/twitter/slight_smile.png?v=14" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-5953-looking-for-reasons-why-it-would-break-3" class="anchor" href="https://rebol.metaeducation.com#p-5953-looking-for-reasons-why-it-would-break-3"></a>Looking for Reasons Why It Would Break</h2>
<p>It definitely benefits <a href="https://rebol.metaeducation.com/t/the-circled-dialect-example-of-the-form/1849">cases like how I was writing CIRCLED</a>, and now that I think about it I've certainly encountered others.</p>
<p>It does break a kind of universality of understanding, like:</p>
<pre><code>rule: [word! | word! word! (print "breaks faith this can never print")]
</code></pre>
<p>Yet the understandings in the PARSE world are a little fuzzy.  You might say the existing paradigms break the understanding that if that rule came across [a b] as input that it would succeed.  It won't if it's an outermost block...</p>
<p>The new understanding would be <em>"Common subsequences in your rule may wind up being matched alternately in top-level parse contexts."</em>  If you don't want it, you have an out...double up your block!</p>
<pre><code>rule: [[word! | word! word! (print "breaks faith this can never print")]]
</code></pre>
<p>Now your rule won't be subject to the toplevel alternates exception...if you can think of a really good reason why you wouldn't want it.</p>
<h2><a name="p-5953-but-uparse-is-configurable-so-why-worry-too-much-4" class="anchor" href="https://rebol.metaeducation.com#p-5953-but-uparse-is-configurable-so-why-worry-too-much-4"></a>But, UPARSE is Configurable, So Why Worry Too Much?</h2>
<p>I might like it, and other people might not.  So we'll see.</p>
<p>I think I'm at least going to try it out, because it looks like it serves common tasks.  I'll get some more data and report back.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/parsing-alternates-should-must-match-to-end-be-considered/1850">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/parsing-alternates-should-must-match-to-end-be-considered/1850</link>
          <pubDate>Sun, 26 Jun 2022 12:46:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1850</guid>
          <source url="https://rebol.metaeducation.com/t/parsing-alternates-should-must-match-to-end-be-considered/1850.rss">Parsing Alternates: Should &quot;Must Match To End&quot; Be Considered?</source>
        </item>
        <item>
          <title>Contemplating PARSE-VALUE: Super-Powered Branching</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Since PARSE is at heart a matching task, it seems there might be more accommodation when the input value is not a block... and you want to do some top level pattern matching.  Consider something like this:</p>
<pre><code>case [
     integer? item [
         print "Not a series, so, have to write handling code here"
     ]
     text? item [
         print "A series, but maybe we want to do something else"
     ]
     block? item [
         print "Okay finally we can use the parse we mean..."
         uparse item [...rules...]
     ]
] else [
   fail "Whatever"
]
</code></pre>
<p>When I see this I start thinking along these lines:</p>
<pre><code>parse reduce [item] [
     integer! (print "More convenient, perhaps...")
         |
     text! (print "Depends on the use case...")
         |
     subparse block! [
        (print "Your rules here I guess...")
     ]
]  ; raises definitional error on no match, handle w/EXCEPT etc. if needed
</code></pre>
<p>Now imagine that being something like <strong>PARSE-VALUE</strong> instead of <strong>PARSE REDUCE [ITEM]</strong>...but with additional cleverness.</p>
<p>One aspect of being better would be that if your input was calculated, you could still call it up with <code>&lt;input&gt;</code> ... although that wouldn't be available to the code in groups automatically:</p>
<pre><code>&gt;&gt; parse-value 1 + 2 [integer! (print "int") | text! (print "text") || &lt;input&gt;]
int
== 3

&gt;&gt; parse-value "foo" [integer! (print "int") | text! (print "text") || &lt;input&gt;]
text
== "foo"
</code></pre>
<p>But you're no worse off than in a switch statement that doesn't have calculated input captured under a name.  (Slightly better, in fact, since you have a means of calling up the calculated input.)</p>
<p>It's just a thought, because I've seen this pattern several times: "I have a decision tree but I can't start doing parsing until I have a series".  This is just an idea about stretching all the matching and extraction logic that is going to be needed in PARSE anyway to apply to single values.</p>
<h2><a name="p-5848-parse-value-or-parsevalue-1" class="anchor" href="https://rebol.metaeducation.com#p-5848-parse-value-or-parsevalue-1"></a>PARSE-VALUE or PARSE/VALUE</h2>
<p>This strongly parallels the LOAD-VALUE vs. LOAD issue.  It seemed to make more sense in that case to separate it out so LOAD was fully generic and unconcerned with the /VALUE aspect.  This might or might not have the same rationale as to why PARSE shouldn't internally be concerned with the behavior.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/contemplating-parse-value-super-powered-branching/1822">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/contemplating-parse-value-super-powered-branching/1822</link>
          <pubDate>Tue, 17 May 2022 08:43:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1822</guid>
          <source url="https://rebol.metaeducation.com/t/contemplating-parse-value-super-powered-branching/1822.rss">Contemplating PARSE-VALUE: Super-Powered Branching</source>
        </item>
        <item>
          <title>What Should BLANK! in UPARSE Do?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>It's always good to look at history first.  So let's compare and contrast #[none] vs. empty block in old Redbols.</p>
<p><strong>In Rebol2 and R3-Alpha, both are no-ops.</strong>  The input type doesn't matter.</p>
<pre><code>r2/r3&gt;&gt; parse "ab" [[] "a" [] "b" []]
== true

r2/r3&gt;&gt; parse "ab" [#[none] "a" #[none] "b" #[none]]
== true

r2/r3&gt;&gt; parse [a b] [[] 'a [] 'b []]
== true

r2/r3&gt;&gt; parse [a b] [#[none] 'a #[none] 'b #[none]]
== true
</code></pre>
<p><strong>In Red, #[none]s are expected to be literal.</strong>  However, you don't get an error on string inputs...just a failure.</p>
<pre><code>red&gt;&gt; parse "ab" [[] "a" [] "b" []]
== true

red&gt;&gt; parse "ab" [#[none] "a" #[none] "b" #[none]]
== false

red&gt;&gt; parse [a b] [[] 'a [] 'b []]
== true

red&gt;&gt; parse [a b] [#[none] 'a #[none] 'b #[none]]
== false

red&gt;&gt; parse [#[none] a #[none] b #[none]] [#[none] 'a #[none] 'b #[none]]
== true
</code></pre>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/what-should-blank-in-uparse-do/1821">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/what-should-blank-in-uparse-do/1821</link>
          <pubDate>Sun, 15 May 2022 22:35:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1821</guid>
          <source url="https://rebol.metaeducation.com/t/what-should-blank-in-uparse-do/1821.rss">What Should BLANK! in UPARSE Do?</source>
        </item>
        <item>
          <title>The Cool New Repurposing of WHILE in PARSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Historical Redbol PARSE had some cognitive dissonance over its "looping constructs".</p>
<p>One weird point was that WHILE was an arity-1 construct...a peculiar variant of a "looping ANY" which dropped the requirement of a need to make progress.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/confused.png?v=14" title=":confused:" class="emoji" alt=":confused:" loading="lazy" width="20" height="20"></p>
<p>Just as <a href="https://rebol.metaeducation.com/t/the-cool-new-repurposing-of-any-in-parse/1662">ANY could be improved</a> by making it do something more "obvious", I think the obvious solution for WHILE is also the better one:</p>
<h2><a name="p-5838-so-now-default-parse-has-while-and-its-arity-2-1" class="anchor" href="https://rebol.metaeducation.com#p-5838-so-now-default-parse-has-while-and-its-arity-2-1"></a>So now, default PARSE has WHILE <em>and it's arity-2</em> !</h2>
<p>These two things are synonyms:</p>
<pre><code> while rule1 rule2   &lt;=&gt;  opt some [rule1 rule2]
</code></pre>
<p><strong>One very common application is <code>WHILE [NOT &lt;END&gt;] [...]</code></strong></p>
<p>This is such a clear case it's bizarre that no one seemed to go to bat for it before.</p>
<p><strong>It would make it cleaner to pair up code in a GROUP! with a rule:</strong></p>
<p>GROUP! rules always run their side effect and succeed.  So:</p>
<pre><code>opt some [rule (code to run on each match)]
</code></pre>
<p>Could instead be written as:</p>
<pre><code>while rule (code to run on each match)
</code></pre>
<p>I would use this frequently!</p>
<p><strong>It helps pscyhologically divide a process into two parts: trigger and response</strong></p>
<p>You can of course write things as:</p>
<pre><code>opt some [
     thing1 thing2 [
        thing3 thing4
     |  thing5 thing6
     ]
]
</code></pre>
<p>Or:</p>
<pre><code>opt some [thing1 thing2 [
    thing3 thing4
        |
   thing5 thing6
]]
</code></pre>
<p>But I think the WHILE structuring into a control half and response half helps you see this better:</p>
<pre><code>while [thing1 thing2] [
    thing3 thing4
        |
    thing5 thing6
]
</code></pre>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/the-cool-new-repurposing-of-while-in-parse/1875">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/the-cool-new-repurposing-of-while-in-parse/1875</link>
          <pubDate>Sat, 14 May 2022 23:34:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1875</guid>
          <source url="https://rebol.metaeducation.com/t/the-cool-new-repurposing-of-while-in-parse/1875.rss">The Cool New Repurposing of WHILE in PARSE</source>
        </item>
        <item>
          <title>Old Parse Tutorial</title>
          <dc:creator><![CDATA[Brett]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <blockquote>
<p>This is an old tutorial which originally appeared on <a href="http://codeconscious.com">codeconscious.com</a>. It has been posted here in the expectation that <a href="http://codeconscious.com">codeconscious.com</a> will be decommissioned early 2022. Other old articles on REBOL can be found at <a href="https://web.archive.org/web/*/https://codeconscious.com/rebol/">REBOL by codeconscious.com on archive.org</a></p>
</blockquote>
<h1><a name="p-5682-introduction-1" class="anchor" href="https://rebol.metaeducation.com#p-5682-introduction-1"></a>Introduction</h1>
<blockquote>
<p>Note: This article is a revised version written for open sourced Rebol (Rebol 3), the original Rebol 2 version is here: <a href="https://codeconscious.com/rebol/parse-tutorial.html">Parse Tutorial for Rebol 2</a>.</p>
</blockquote>
<p>If you want to extract data from strings (like HTML, TXT, CSV, etc.) consider Parse.</p>
<p>If you want to just check some user data against a specific format consider using Parse.</p>
<p>If you want to validate some message written in your new dialect use Parse.</p>
<p>Parse is useful.</p>
<p>Parse is quick.</p>
<p>Parse operates on string, binary and block input.  Using Parse you can process these types of input in some way, overlaying the input with new meaning. That is you have a string or block and you are perhaps identifying fields of records, tokens of a language or even identifying sections of a message protocol.</p>
<p>This document is a very rough show by example description of Parse with a few warnings thrown in.</p>
<h1><a name="p-5682-parse-dialect-2" class="anchor" href="https://rebol.metaeducation.com#p-5682-parse-dialect-2"></a>Parse Dialect</h1>
<p>You give Parse a rule block containing instructions to follow written in the Parse dialect. These instructions allow you to utilise Parse to interpret custom external formats or protocols. These instructions can be as simple or as complex as you need. A simple example would be to check that some input against postal code format. A sophisticated example is Rebol's URL parser (help sys/*parse-url/rules).</p>
<p>The instructions are written using the Parse dialect and tell Parse how to read through your input. In actual fact, the instructions describe the patterns that the input should take. Parse attempts to match the input against your patterns. Parse will return a TRUE result if your instructions accurately describe the input. If your instructions fail to describe the input (or looking at it the other way, the input fails to follow your rules) Parse will return FALSE. You also have the ability to carry out normal Rebol operations as Parse traverses the input and your rules.</p>
<p>It is very important to realise that the keywords of the Parse dialect are interpreted by Parse in a specific way and should be considered as being different in meaning to Rebol words when used at the console.</p>
<h2><a name="p-5682-lets-start-at-the-end-3" class="anchor" href="https://rebol.metaeducation.com#p-5682-lets-start-at-the-end-3"></a>Let's start at the end</h2>
<pre><code>&gt;&gt; input-string: {}
&gt;&gt; parse input-string [end]
== true
</code></pre>
<p>Ah success! Here I am parsing an empty string. My rule says to Parse "check that we are at the end". The result is of course TRUE because the string was empty to begin with.</p>
<p>This is similar in normal Rebol script to:</p>
<pre><code>&gt;&gt; tail? input-string
== true
</code></pre>
<h2><a name="p-5682-baby-steps-4" class="anchor" href="https://rebol.metaeducation.com#p-5682-baby-steps-4"></a>Baby steps</h2>
<p>Next up, let's test that a string matches our expectations:</p>
<pre><code>&gt;&gt; input-string: "fox"
== "fox"
&gt;&gt; parse input-string ["fox" end]
== true
</code></pre>
<p>We successfully tested that the input started with "fox" and then finished. Ok, no big deal.</p>
<p>But reflect a moment. This is a sequence - first "fox" then END. As Parse traverses the input</p>
<p>and your rule block, it keeps track of a current position for both. So at the start, the current position in the input is at the head of the string. After the rule "fox" was matched the current position in the input string will be directly after the "x" of "fox".</p>
<p>In this example, this happens to be the tail of the string, so the very next match rule END will succeed.</p>
<p>We do not always have to supply an END in the rule block. You can omit it in the last example because Parse effectively slaps one on at the end anyway.</p>
<pre><code>&gt;&gt; parse input-string ["fox"]
== true
</code></pre>
<p>While you can do this for simple examples, remember you'll likely need to add it in</p>
<p>explicitly for more complex rules.</p>
<p>Ok, back to the example again. In an ordinary Rebol session the above example is similar to the following:</p>
<pre><code>&gt;&gt; input-string: find/match input-string "fox"
== ""
&gt;&gt; tail? input-string
== true
</code></pre>
<p>Note that the ordinary Rebol code examples through this article are provided to help learn Parse. There are enough important differences between the Parse examples and the ordinary code examples that you cannot alway treat them as exactly equivalent.</p>
<h2><a name="p-5682-failures-challenges-5" class="anchor" href="https://rebol.metaeducation.com#p-5682-failures-challenges-5"></a>Failures / challenges</h2>
<p>For contrast let's look at an unsuccessful match:</p>
<pre><code>&gt;&gt; input-string: "dog"
== "dog"
&gt;&gt; parse input-string ["fox"]
== false
</code></pre>
<p>The meaning of this is pretty obvious. Hang on though, what actually happens when Parse encounters a failure with one of the rules? Well it backtracks the input to the point it was at when the rule started. So in Rebol code what happens is actually more like this:</p>
<pre><code>input-string: "dog"
If position: Find/match input-string "fox" [input-string: position]
Tail? input-string
</code></pre>
<p>Keep this little idea in the back of your mind, it becomes more meaningful with more complex rules.</p>
<h2><a name="p-5682-optional-matching-and-compound-rules-6" class="anchor" href="https://rebol.metaeducation.com#p-5682-optional-matching-and-compound-rules-6"></a>Optional matching and Compound Rules</h2>
<p>What if we want to check for a number of common pet alternatives?</p>
<p>Let's accept a "dog" or a "cat" or indeed a "bird":</p>
<pre><code>&gt;&gt; input-string: "dog"
== "dog"
&gt;&gt; parse input-string ["dog" | "cat" | "bird"]
== true
</code></pre>
<p>In ordinary Rebol this is like coding:</p>
<pre><code>input-string: any [
    find/match input-string "dog"
    find/match input-string "cat"
    find/match input-string "bird"
]
tail? input-string
</code></pre>
<p>Now, Rebol can be pretty concise and the ANY function definitely helps in writing concise code, but you can see already that the Parse dialect is looking to be better suited to matching than ordinary scripting.</p>
<p>Reflecting on this a bit. We have here a more interesting rule, a compound rule. Our compound rule is composed of three subrules. Each of the three subrules here are very basic but subrules are allowed to be compound rules themselves. The basic rules perform the lowest level matching of the input, the compound rules check the overall structure/grammar of your data.</p>
<p>Back to options. What about something that may or may not exist at all? Using OPT we can indicate that a bird could be big or just leave it out:</p>
<pre><code>&gt;&gt;  input-string: "bigbird"
== "bigbird"
&gt;&gt;  parse input-string [opt "big" "bird"]
== true
&gt;&gt; input-string: "bird"
== "bird"
&gt;&gt; parse input-string [opt "big" "bird"]
== true
</code></pre>
<p>There are more Parse options such as NOT which give you greater flexibility in specifying your rules. We'll cover this later.</p>
<h2><a name="p-5682-spaces-and-split-7" class="anchor" href="https://rebol.metaeducation.com#p-5682-spaces-and-split-7"></a>Spaces and Split</h2>
<p>Parse treats spaces like any other character. Note that Rebol 3 acts differently here to Rebol 2 as whitespace is now parsed by default without needing the /ALL refinement</p>
<pre><code>&gt;&gt;  input-string: "black dog"
== "black dog"
&gt;&gt;  parse input-string ["black" " " "dog"]
== true
</code></pre>
<p>There are constants defined for common characters such as SPACE, NEWLINE and TAB which can be used instead.</p>
<pre><code>&gt;&gt;  parse input-string ["black" space "dog"]
== true
</code></pre>
<p>To make things easier we can use the SPLIT function to pre-process the input string. SPLIT breaks up the string based on a given delimeter or other rules.</p>
<pre><code>&gt;&gt; parse split "brown dog" " " ["brown" "dog"]
== true
</code></pre>
<p>If we look at the output of split we see the following.</p>
<pre><code>&gt;&gt; split "brown dog" " "
== [ "brown" "dog" ]
</code></pre>
<p>In this case split is returning a block of strings simplifying our work with Parse.</p>
<h1><a name="p-5682-blocks-repetition-and-more-8" class="anchor" href="https://rebol.metaeducation.com#p-5682-blocks-repetition-and-more-8"></a>Blocks, repetition and more</h1>
<p>Using Parse for strings is good, but using parse on native Rebol datatypes really shows its power.</p>
<p>Rebol has a rich set of datatypes which simplify parsing data, and code.</p>
<p>This mode is used when the value to be parsed is actually a block not a string. You use this mode when you have already loaded data into Rebol values. You write Parse instructions in a rule block using the parse dialect in a similar way to that described for parsing strings except when parsing blocks the semantics are different and you have a couple more keywords to use.</p>
<p>This is the mode of Parse that deserves the attention of anyone using Rebol. The reason is that you are free to store your data in a form understandable by yourself and others and yet is still computer readable.</p>
<h2><a name="p-5682-first-steps-parsing-blocks-9" class="anchor" href="https://rebol.metaeducation.com#p-5682-first-steps-parsing-blocks-9"></a>First steps parsing blocks</h2>
<p>As we move from strings to blocks we can start to use some of the Rebol datatypes to make our lives much easier.</p>
<pre><code>&gt;&gt; parse [1234.16] [number!]
== true
</code></pre>
<p>Processing dates and times are a good example. You can see how the datatypes support a wide range of input formats. It is worth noting for Americans that Rebol always assumes day/month/year order.</p>
<pre><code>&gt;&gt; parse [12/Dec/2012 2:30pm ] [date! time!]
== true
</code></pre>
<p>There are many more datatypes although that does not stop you from using strings for datatypes which do not map to Rebol types.</p>
<pre><code>&gt;&gt; parse [&lt;div&gt; "Hello" http://rebol.com $1.00 &lt;/div&gt; bob@test.com ] [ tag! "Hello" url! money! tag! email!]
== true
</code></pre>
<h2><a name="p-5682-repetition-known-range-of-occurrences-10" class="anchor" href="https://rebol.metaeducation.com#p-5682-repetition-known-range-of-occurrences-10"></a>Repetition - known range of occurrences</h2>
<p>Time for some more compound rules.</p>
<p>Here's how to check for exactly two dogs.</p>
<pre><code>&gt;&gt; parse "dogdog" [2 "dog"]
== true
</code></pre>
<p>I can specify between 1 and 4 Zs (inclusive) too:</p>
<pre><code>&gt;&gt;  parse "Zzzz" [1 4 "z"]
== true
</code></pre>
<p>Note that by default Parse is not case sensitive unless you want it to be by using the /CASE refinement:</p>
<pre><code>&gt;&gt; parse/case "ZZ" [2 "Z"]
== true
</code></pre>
<p>This is also very powerful for parsing blocks:</p>
<pre><code>&gt;&gt; parse [ http://rebolsource.net http://rebol.org http://rebol.com ] [ 3 url! ]
== true
</code></pre>
<h2><a name="p-5682-repetition-again-unknown-number-of-occurrences-11" class="anchor" href="https://rebol.metaeducation.com#p-5682-repetition-again-unknown-number-of-occurrences-11"></a>Repetition again <img src="https://rebol.metaeducation.com/images/emoji/twitter/slight_smile.png?v=14" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"> - unknown number of occurrences</h2>
<p>What if we grab a net and go prawning? We may not know how many prawns are caught by the net when we catch them:</p>
<pre><code>&gt;&gt; loop random 100 [append input-string: "" "prawn"]
== "prawnprawnprawnprawn"
&gt;&gt; parse input-string [some "prawn"]
== true
</code></pre>
<p>Excellent, we have some prawns but we don't know how many.</p>
<p>The SOME keyword means "match one or more of the following". Again it is a compound rule because I could have as easily done this if it was "raining cats and dogs":</p>
<pre><code>&gt;&gt; input-string: "dogdogcatdogcat"
== "dogdogcatdogcat"
&gt;&gt; parse input-string [some [ "dog" | "cat"] ]
== true
</code></pre>
<p>If it fines up:</p>
<pre><code>&gt;&gt; input-string: {}
== ""
&gt;&gt; parse input-string [some [ "dog" | "cat"]  ]
== false
</code></pre>
<p>It returns false because SOME requires at least one instance to be matched. If however, we don't actually care whether we get some or not we can use ANY:</p>
<pre><code>&gt;&gt; input-string: {}
== ""
&gt;&gt; parse input-string [any [ "dog" | "cat" ] ]
== true
&gt;&gt; input-string: "dog"
== "dog"
&gt;&gt; parse input-string [any [ "dog" | "cat"] ]
== true
</code></pre>
<p>Here is another example of one of those Rebol words with a new meaning in the context of Parse. In ordinary Rebol ANY is a function that return the first non-false or non-none value in the block it is given. In Parse, by contrast, ANY is a keyword that introduces a compound rule that means, "match zero or more of the following".</p>
<p>Repetition works equally well for blocks:</p>
<pre><code>&gt;&gt; parse [Fibonacci 1 1 2 3 5 8 13] [some [number! | word!] ]
== true
</code></pre>
<h2><a name="p-5682-moving-right-along-12" class="anchor" href="https://rebol.metaeducation.com#p-5682-moving-right-along-12"></a>Moving right along...</h2>
<p>Sometimes we really couldn't care less what lies between things of interest.</p>
<p>This example does not "skip c" it reads "match a, skip a character, match c, tail?".</p>
<pre><code>&gt;&gt; parse {abc} ["a" skip "c" end]
== true
</code></pre>
<p>You want to skip 5 characters? Use repetition:</p>
<pre><code>&gt;&gt; parse {1234567890} ["123" 5 skip "90" end]
== true
</code></pre>
<p>Sometimes we don't know how much is in between but we do know what is the next interesting bit:</p>
<pre><code>&gt;&gt; input-string: {1234 fox}
== "1234 fox"
&gt;&gt; parse input-string [thru "fox" end]
== true
</code></pre>
<p>This is like the Rebol code of:</p>
<pre><code>&gt;&gt; input-string: find/tail input-string "fox"
== ""
&gt;&gt; tail? input-string
== true
</code></pre>
<p>We can stop where fox starts using TO:</p>
<pre><code>&gt;&gt;  input-string: "1234 fox"
== "1234 fox"
&gt;&gt;  parse input-string [to "fox" "fox" end]
== true
</code></pre>
<p>And the Rebol code that performs similarly:</p>
<pre><code>input-string: {1234 fox}
input-string: find input-string "fox"
input-string: find/match input-string "fox"
tail? input-string
</code></pre>
<p>We can skip to the end as well:</p>
<pre><code>&gt;&gt;  parse {123456} ["123" to end end]
== true
</code></pre>
<p>This says "match 123, move to the tail, test tail". Pretty obvious we would get a true result if you think of it in these terms.</p>
<p>While we're here how about a warning. The rule [to end] moves to the tail and reports</p>
<p>success every time.</p>
<h2><a name="p-5682-all-these-characters-13" class="anchor" href="https://rebol.metaeducation.com#p-5682-all-these-characters-13"></a>All these characters</h2>
<p>Charset. Stands for character set. It is a bitset which makes it fast for pattern matching operations.</p>
<p>Let's say you only want to check that your input contains the digits 0 to 9.</p>
<pre><code>&gt;&gt; digit: charset [#"0" - #"9"]
</code></pre>
<p>Now parse can use this directly as a pattern matching instruction. It will match one character (byte) only of those in the set 0 - 9.</p>
<pre><code>&gt;&gt; parse {1} [digit]
== true
</code></pre>
<p>Naturally enough you can use these in compound rules too:</p>
<p>An Australian postcode consists of 4 numeric digits so:</p>
<pre><code>&gt;&gt; parse {2069} [4 digit]
== true
</code></pre>
<p>Charsets (bitsets) are sets and you can apply the set operations union, intersection, exclude, etc</p>
<p>on them:</p>
<pre><code>letter: charset [#"a" - #"z" #"A" - #"Z"]
digit: charset [#"0" - #"9"]
letter-or-digit: union letter digit
valid-name: [letter any letter-or-digit]
&gt;&gt;  parse {1abc} valid-name
== false
&gt;&gt;  parse {rebol} valid-name
== true
&gt;&gt;  parse {xyz1234} valid-name
== true
</code></pre>
<p>Maybe you want everything but digits:</p>
<pre><code>&gt;&gt; parse {A} [not digit skip]
== true
</code></pre>
<p>Notice how we needed to SKIP forward as NOT simply inverses the following rule and does not advance the input.</p>
<p>This is different from the Rebol 2 approach of creating a COMPLEMENT of a charset. This may work in some situations, but will not always give you the desired result due to the use of UNICODE in Rebol 3.</p>
<h2><a name="p-5682-but-i-want-some-information-from-it-14" class="anchor" href="https://rebol.metaeducation.com#p-5682-but-i-want-some-information-from-it-14"></a>But I want some information from it!</h2>
<p>Up to this point I've concentrated on the various matching functionality of Parse. Of course though you want to extract information from your data. The keyword of note for this purpose is COPY. Also of use is the ability to execute Rebol code within the Parse rules (actions) and thereby set and maintain Rebol variables (eg. Counters) using that code.</p>
<p>Ok COPY.</p>
<p>Copy is really really simple really. It is a compound rule that takes two arguments a variable and a subrule. Whatever input the subrule matches gets copied into the variable. If the subrule doesn't match anything (fails) COPY returns the failure but leaves the variable unchanged.</p>
<p>Here the subrule is to match an "A" which obviously fails.</p>
<pre><code>&gt;&gt; parse {123} [copy some-text "A"]
== false
&gt;&gt; some-text
** Script error: some-text has no value
</code></pre>
<p>Here the subrule is a simple skip:</p>
<pre><code>&gt;&gt; parse {123} [copy some-text skip to end]
== true
&gt;&gt; some-text
== "1"
</code></pre>
<p>And here the subrule is to match nothing NONE which is always successful so copy copies that which was matched...an empty string:</p>
<pre><code>&gt;&gt; parse "123" [copy some-text none]
== false
&gt;&gt; some-text
== ""
</code></pre>
<p>Another way of getting data is by using SET:</p>
<pre><code>&gt;&gt; parse [ $100 ] [ set wallet money! ]
== true
&gt;&gt; wallet
== $100
</code></pre>
<h2><a name="p-5682-bring-on-the-code-actions-15" class="anchor" href="https://rebol.metaeducation.com#p-5682-bring-on-the-code-actions-15"></a>Bring on the code (actions)</h2>
<p>Ordinary Rebol code can be used inside the parse dialect via the use of "(" and ")" i.e. a Paren! series:</p>
<pre><code>&gt;&gt; parse {} [(print "some code just executed") end]
some code just executed
== true
</code></pre>
<p>Obviously this is very handy. Even nicer is that it runs according to its placement in the rule. Note though that even if the rule ultimately fails your code may have already run:</p>
<pre><code>&gt;&gt; parse {123} [
     "1" (print "found 1!")
     "2" (print "found 2!")
     "A" (print "found an A!")
    end
]
found 1!
found 2!
== false
</code></pre>
<p>So the upshot is you can maintain counters and take actions based on your Parse rules.</p>
<p>During development it can be useful to put print statements in these allowing you to see what is happening.</p>

<h1><a name="p-5682-advanced-section-16" class="anchor" href="https://rebol.metaeducation.com#p-5682-advanced-section-16"></a>Advanced section</h1>
<h2><a name="p-5682-repeated-repetition-17" class="anchor" href="https://rebol.metaeducation.com#p-5682-repeated-repetition-17"></a>Repeated Repetition</h2>
<p>Now that I've introduced repetition and compound rules, what happens if I create a compound rule made up of nested repetition rules? Hmm, tricky.</p>
<p>This next example put Parse into a spin - an infinite loop. The escape key will not work, but you can break out with Ctrl+c:</p>
<pre><code>&gt;&gt; input-string: {}
== {}
&gt;&gt; parse input-string [while [any "dog"] ]
</code></pre>

<p>To understand why this infinite loop happens you need to know when the ANY rule returns success and when it completes.</p>
<p>Here's the major answer: WHILE ALWAYS returns success.</p>
<p>WHILE will keep calling its subrule while that subrule returns success regardless of if the input position advances. WHILE gives up on receipt of bad news (failure) but it itself always returns success. Now if WHILE always receives a success because it's subrule in fact is another WHILE or ANY... Well I think that explains it.</p>
<p>Remember OPT. It always returns success just like WHILE. So putting an OPT inside an WHILE is bound to lead to trouble as well.</p>
<p>The point then is that your repetition compound rules must be carefully written because of the possibility of creating these infinite loops. It is not a bug in Rebol, it is consequence of having a flexible Parse dialect.</p>
<p>Sometimes these infinite loops start only after traversing lots of other complex rules and therefore can become hard to catch. I create these loops less often now since I started considering how I want Parse's input position to move. When writing your rules consider how the input is consumed by the rules.</p>
<p>That's part of the reason why I've been demonstrating the Rebol code similar to the various Parse examples.</p>
<p>Not all combinations of repetition rules create infinite loops:</p>
<pre><code>&gt;&gt;  input-string: {}
== ""
&gt;&gt;  parse input-string [while [some "dog"] ]
== true
</code></pre>
<p>This last example is ok because the SOME does not always return success - it must consume some input. If SOME does not have at least one success it</p>
<p>returns a failure result. So you can see that at some point, given that we can assume that the input is</p>
<p>finite, the overall rule must terminate.</p>
<p>Quoting Ladislav, "The dangerous rules are rules, that don't consume any input, yet they return success."</p>
<p>There is another way to escape when you don't want your rule to progress further - the BREAK keyword. BREAK terminates the rule when it is encountered.</p>
<p>This could be used to improve performance by stopping evaluation of unnecessary rules.</p>
<pre><code>&gt;&gt; parse [1 2 end 3 4 5 7 8 9] [some [integer! | 'end break]]
== false
</code></pre>
<p>This rule will exist as soon as it reaches the end keyword improving the performance.</p>
<h2><a name="p-5682-debugging-parse-rules-18" class="anchor" href="https://rebol.metaeducation.com#p-5682-debugging-parse-rules-18"></a>Debugging parse rules</h2>
<p>The ?? command is invaluable in debugging Parse rules.</p>
<pre><code>&gt;&gt; parse "dog" [ ?? "d" ?? [ "i" | "o" ] ?? "g" ?? ]
"d": "dog"
["i" | "o"]: "og"
"g": "g"
end!: ""
== true
</code></pre>
<p>It displays the next rule and the current position in the series being parsed.</p>
<h2><a name="p-5682-the-current-index-and-manipulating-it-19" class="anchor" href="https://rebol.metaeducation.com#p-5682-the-current-index-and-manipulating-it-19"></a>The current index and manipulating it</h2>
<p>Parse maintains a reference to the input. The reference is a series and so has a current index.</p>
<p>Some special Parse dialect syntax allows you to get and set this reference. You use a set-word and get-word syntax respectively.</p>
<p>In this example I set the word "mark" to the input series at the current index that Parse has, don't worry about the false - it is just saying we didn't get all the way through the input:</p>
<pre><code>&gt;&gt;  parse {123456} ["123" mark:]
== false
&gt;&gt; mark
== "456"
</code></pre>
<p>I can manipulate the current index that Parse uses too:</p>
<pre><code>&gt;&gt;  parse {1234567} ["123" mark: (mark: next next mark) :mark "67"]
== true
</code></pre>
<p>To explain. First "123" is matched, then the word mark is set to the reference.</p>
<p>Then the Rebol code between the parentheses is evaluated. This code manipulates the reference we hold by two characters. I return this modified reference to Parse using the get-word syntax. Parse seeing the get-word syntax knows that it must update it's reference to that given. Finally I match the "67".</p>
<h2><a name="p-5682-more-block-examples-20" class="anchor" href="https://rebol.metaeducation.com#p-5682-more-block-examples-20"></a>More Block examples ...</h2>

<p>An example that shows what can be achieved is Carl Sassenrath's stock transaction example which you can see below. Now what if "sell 300 shares at $89.08" came in via email?</p>
<p>If you study this example you will see that Carl, in a very small space, has created a small interpreter that parses, validates and performs computations. This is very powerful technology that is easily underestimated because it is so small and simple.</p>
<pre><code>rule: [
    set action ['buy | 'sell]
    set number integer!
    'shares 'at
    set price money!
    (either action = 'sell [
            print ["income" price * number]
            total: total + (price * number)
        ] [
            print ["cost" price * number]
            total: total - (price * number)
        ]
    )
]
total: 0
parse [sell 100 shares at $123.45] rule
print ["total:" total]
total: 0
parse [
    sell 300 shares at $89.08
    buy 100 shares at $120.45
    sell 400 shares at $270.89
] [some rule]
print ["total:" total]
</code></pre>
<p>Another powerful example of this is the VID dialect of Rebol/View 2. VID describes in a<br>
effective but simple way what should appear on screen. VID is actually a block using normal<br>
Rebol values such as words and strings. The LAYOUT function of Rebol/View 2 takes a VID<br>
block as an argument to construct the visual objects. Layout uses Parse to process the<br>
VID specification.</p>
<h1><a name="p-5682-special-situations-21" class="anchor" href="https://rebol.metaeducation.com#p-5682-special-situations-21"></a>Special situations</h1>
<h2><a name="p-5682-when-you-do-not-want-to-match-a-pattern-22" class="anchor" href="https://rebol.metaeducation.com#p-5682-when-you-do-not-want-to-match-a-pattern-22"></a>When you do NOT want to match a pattern</h2>

<p>NOT does not consume input, so you can use it one ore more times before matching something else:</p>
<pre><code>&gt;&gt; parse "bird" [not "big" "bird"]
== true
</code></pre>
<p>One situation where you might do this is when you have a sub rule that might "consume" something needed by an enclosing rule.</p>
<p>For my example, I'll Parse a block rather than text but the concept still applies.</p>
<p>I want to Parse the following block, and print out every word, but if I encounter a bar ("|") I'll print out the text "**********":</p>
<pre><code>my-block: [ the quick brown fox | jumped | over the lazy]
</code></pre>
<p>This next bit of code will not work. If you try it you will see that no "*" is printed, instead you will see the "|":</p>
<pre><code>single-word: [set item word! (print mold item)]
phrase: [some single-word]
parse my-block [ phrase some ['| (print "**********") phrase] ]
</code></pre>
<p>The thing to note is that the bar "|" is a word too. Therefore the bar is "consumed" by the rule called SINGLE-WORD.</p>
<p>So one way to solve this is to give SINGLE-WORD some indigestion (make it fail) when it encounters a bar.</p>
<p>You can force a rule to fail using the FAIL keyword but here we use AND and NOT to make the rule fail under a specific condition.</p>
<p>To make it clear what is happening here, I wrap SINGLE-WORD with a rule I call WORD-EXCEPT-BAR. The</p>
<p>purpose of this new rule is to fail if it finds the "|" word otherwise it goes ahead and runs SINGLE-WORD.</p>
<p>I've added comments to clarify how WORD-EXCEPT-BAR works:</p>
<pre><code>word-except-bar: [
    and not '| ; Without advancing the input position, is this not a bar?
    single-word ; Match single-word
]
</code></pre>
<p>The point to note here is that the rule AND NOT '| is a "guard" - it guards the next rule from consuming input under a specific condition.</p>
<p>I also need to modify PHRASE to call WORD-EXCEPT-BAR.</p>
<pre><code>phrase: [some word-except-bar]
</code></pre>
<p>Another way to describe the PHRASE rule, as it is now, is "a rule that matches a series of words which does not contain the word |."</p>
<p>To finish off I'll create a function to call parse with the correct rule and</p>
<p>wrap the whole lot in an object just to be tidy:</p>
<pre><code>word-parsing-object: context [
    single-word: [set item word! (print mold item)]
    word-except-bar: [and not '| single-word]
    phrase: [some word-except-bar]
    set 'parse-words func[ a-block [block!] ] [
        parse a-block [phrase some ['| (print "**********") phrase] ]
    ]
]
</code></pre>
<p>Here is a test run:</p>
<pre><code>&gt;&gt; parse-words [the quick brown fox | jumped | over the lazy]
the
quick
brown
fox
**********
jumped
**********
over
the
lazy
== true
</code></pre>
<p>In summary in this section I have demonstrated how one can match a specific pattern even when a more general pattern (that includes the specific pattern) gets to see the input first.</p>
<h2><a name="p-5682-why-didnt-you-just-write-23" class="anchor" href="https://rebol.metaeducation.com#p-5682-why-didnt-you-just-write-23"></a>Why didn't you just write...</h2>
<pre><code>parse-words: func [a-block [block!]] [
    parse a-block [
        some [
            '| (print "**********") |
            set item word! (print mold item)
        ]
    ]
]
</code></pre>
<p>That is the better way to solve the problem, but the point is to demonstrate the concept of preventing a subrule from consuming certain input and how to use AND as a guard. There are situations when you need these ideas.</p>
<h2><a name="p-5682-the-break-keyword-24" class="anchor" href="https://rebol.metaeducation.com#p-5682-the-break-keyword-24"></a>The BREAK keyword</h2>

<p>From RT's changes document:</p>
<pre><code>When the BREAK word is encountered within a rule block, the block is
immediately terminated regardless of the current input pointer.
Expressions that follow the BREAK within the same rule block will not
be evaluated.
</code></pre>
<p>BREAK is usually used with repetition. In this example the SOME rule is exited early:</p>
<pre><code>&gt;&gt; parse "X" [some [ (print "*Break*") break] "X"]
*Break*
== true
</code></pre>
<p>Here again the SOME rule is exited early just like the previous example. In this case the rule that SOME is processing is referred to by a word:</p>
<pre><code>&gt;&gt; rule-to-break: [(print "*Break*") break]
== [(print "*Break*") break]
&gt;&gt; parse "X" [some rule-to-break "X"]
*Break*
== true
</code></pre>
<h1><a name="p-5682-related-toolset-25" class="anchor" href="https://rebol.metaeducation.com#p-5682-related-toolset-25"></a>Related toolset</h1>
<p>I have written "Parse Analysis Toolset" to help learn and analyse the way Parse works. The Explain-parse function of the toolset should help with learning Parse. The script has related documentation. You can find the script and a linkg to the documentation at:</p>
<p><a href="http://www.rebol.org/cgi-bin/cgiwrap/rebol/view-script.r?script=parse-analysis.r">parse-analysis.r (at REBOL.org Script Library)</a></p>
<p>One more program I've made can return a parse tree of your input:</p>
<p><a href="http://www.rebol.org/cgi-bin/cgiwrap/rebol/documentation.r?script=load-parse-tree.r">load-parse-tree.r (at REBOL.org Script Library)</a></p>
<h1><a name="p-5682-comments-26" class="anchor" href="https://rebol.metaeducation.com#p-5682-comments-26"></a>Comments</h1>
<p>Parse is a key component Rebol. Rebol is promoted as a messaging<br>
language. Messages can come in many formats (syntaxes). Parse allows<br>
you to define the syntax of a message so that you can interpret the message and transform<br>
it to something else or act on it directly. That may sound complex, but it isn't really.</p>
<p>What are messages? Lots of things can be considered as messages. Basically if you can<br>
put it into a file and the format of the file has some rule to it, then I think you have<br>
a message. You don't have to put it in a file though to use Parse. Rebol's networking<br>
functions use Parse to interpret many of the internet protocols that Rebol provides<br>
access to.</p>
<p>With Rebol you can define a mini-language for a specific purpose - a dialect. Outside Rebol this would be called a domain-specific language or DSL.</p>
<p>Parse helps you to validate and process such dialects. You might want to design a dialect for creating web pages on your internet site. Or perhaps for controlling a special device you have attached to your computer.</p>
<h1><a name="p-5682-acknowledgement-27" class="anchor" href="https://rebol.metaeducation.com#p-5682-acknowledgement-27"></a>Acknowledgement</h1>
<p>Thank you to John Kenyon for his initiative, edits and effort as we updated this article from the original.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/old-parse-tutorial/1771">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/old-parse-tutorial/1771</link>
          <pubDate>Sun, 12 Dec 2021 00:08:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1771</guid>
          <source url="https://rebol.metaeducation.com/t/old-parse-tutorial/1771.rss">Old Parse Tutorial</source>
        </item>
        <item>
          <title>How Would Stream PARSE Handle Positions?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Generically speaking: when dealing with a streaming data source, you often don't know how many bytes or characters you want to read in advance.  You're looking for some pattern in the input to delimit it.</p>
<p>(The simplest-yet-very-common example would be reading until a newline.)</p>
<p>Go has dedicated operations for reading up-until one certain byte (<a href="https://pkg.go.dev/bufio#Reader.ReadBytes">ReadBytes(byte)</a>) or one certain UTF-8 character byte sequence (<a href="https://pkg.go.dev/bufio#Reader.ReadString">ReadString(codepoint)</a>).  These are methods of the buffered IO abstraction, because if you didn't go through a buffering middleman you'd have to call a lower-level <code>Read()</code> just one byte at a time.  Otherwise the lack of a buffer would mean you wouldn't have anywhere to hold the queued-up extra data after a newline...if a Read() came back with a bigger chunk.</p>
<p>Rigging up anything more detailed in Go is harder.  <strong>So this is where I thought a streaming PARSE would offer an interesting answer for a lot of scenarios.</strong>  Getting PARSE worked out correctly would save people the trouble of having to drive the progressive Read process themselves, just to get a more nuanced condition than "until a certain byte is seen".</p>
<h2><a name="p-5567-but-streams-arent-seriesso-how-would-you-call-parse-1" class="anchor" href="https://rebol.metaeducation.com#p-5567-but-streams-arent-seriesso-how-would-you-call-parse-1"></a>But Streams Aren't Series...So How Would You Call PARSE?</h2>
<p>When you parse a <em>series</em>, you don't "consume" it:</p>
<pre><code>&gt;&gt; data: "aaa"

&gt;&gt; uparse data [some "a" (&lt;Yay, some A!&gt;)]
== &lt;Yay, some A!&gt;

&gt;&gt; data
== "aaa"  ; hasn't changed
</code></pre>
<p>And you can do partial processing and get a position via <code>&lt;here&gt;</code>:</p>
<pre><code>&gt;&gt; data: "aaabbb"

&gt;&gt; uparse data [some "a" &lt;here&gt;]
== "bbb"  ; this is a "position" that points into `data`

&gt;&gt; data
== "aaabbb"  ; again, the unchanged input
</code></pre>
<p><strong>However, streams don't have any position <em>but</em> "here".</strong>  So how would <code>&lt;here&gt;</code> be any different from <code>&lt;input&gt;</code>?</p>
<h2><a name="p-5567-some-streams-may-internally-know-a-position-but-not-all-2" class="anchor" href="https://rebol.metaeducation.com#p-5567-some-streams-may-internally-know-a-position-but-not-all-2"></a>Some Streams May Internally Know A Position, But Not All</h2>
<p>In Go we saw an example of how streaming is an interface that something can offer, while having other methods depending on the data source.  Those other methods can offer features like timeouts.  Or something like a file could offer the ability to re-seek so the next call reading from the stream would get from a random access position.</p>
<p><em>But that's all outside of the streaming interface.</em>  The stream itself is a black box.  And the position is "inside"...all references to the same stream interface will be updated if you read from any reference.</p>
<p>With Rebol series, the position is "outside"...each instance has its own index.  So when you NEXT a series, you have to save the result, or you will get the same thing again:</p>
<pre><code>&gt;&gt; series: [a b c]

&gt;&gt; next series
== [b c]

&gt;&gt; next series
== [b c]
</code></pre>
<p>If streams worked this way, you'd have to constantly be saving the new stream value every time you read from it, as another return value of the READ process.</p>
<pre><code>[data stream]: read/part stream 10
</code></pre>
<p>But if you did have to code like that, how would it react to a situation like this?</p>
<pre><code>&gt;&gt; [data newstream]: read/part oldstream 10

&gt;&gt; read/part oldstream 10
</code></pre>
<p>The (presumably) buffered stream no longer has the data on hand.  So it either preserves the data indefinitely or some of these calls would fail.</p>
<h2><a name="p-5567-so-parsing-consumes-streams-but-not-series-3" class="anchor" href="https://rebol.metaeducation.com#p-5567-so-parsing-consumes-streams-but-not-series-3"></a>So Parsing Consumes Streams, But Not Series?</h2>
<p>Right now, there's no way to leave a stream alone, because reading it consumes it.</p>
<p>The only way you'd be able to "consume" a series value--e.g. advance the index of the input--would be to pass into parse a variable holding the input.  Because the index of the series is an immediate in the value itself.</p>
<p>It seems unfortunate that something like a FILE! can know how to do random seeks, and not be able to save and restore positions in PARSE.  But if it did, what would the type of <code>&lt;here&gt;</code> be?  It would have to create a new stream instance into the same file...this would be like being able to say:</p>
<pre><code>&gt;&gt; s2: clone stream  ; maybe file reads support, but tcp reads don't?

&gt;&gt; read stream
== #{ABCD0102}

&gt;&gt; read s2
== #{ABCD0102}
</code></pre>
<p>It's probably bad for PARSE to be going this direction.</p>
<h2><a name="p-5567-a-better-idea-some-streams-offer-index-some-dont-4" class="anchor" href="https://rebol.metaeducation.com#p-5567-a-better-idea-some-streams-offer-index-some-dont-4"></a>A Better Idea (?) <em>some</em> Streams Offer <code>&lt;index&gt;</code>, Some Don't</h2>
<p>It's already the case that SEEK will accept either an index number or a series position.  So when you ask for <code>&lt;index&gt;</code> it could tell you the position in the file.</p>
<p><em>(Although I should mention that file seeking has historically always been offset-based, starting with zero.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20">  This was true in R3-Alpha and is also true in 1-based languages like Julia.)</em></p>
<p>This just rules out the idea of having <code>&lt;here&gt;</code> on a stream series altogether; to basically stamp out the concept that there is such a thing as a "stream-at-position".  You only deal with positions separate from streams...and only on the streams that happen to offer them.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/how-would-stream-parse-handle-positions/1740">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/how-would-stream-parse-handle-positions/1740</link>
          <pubDate>Wed, 06 Oct 2021 16:40:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1740</guid>
          <source url="https://rebol.metaeducation.com/t/how-would-stream-parse-handle-positions/1740.rss">How Would Stream PARSE Handle Positions?</source>
        </item>
  </channel>
</rss>

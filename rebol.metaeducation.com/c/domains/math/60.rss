<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Math - AltRebol</title>
    <link>https://rebol.metaeducation.com/c/domains/math/60</link>
    <description>Topics in the &#39;Math&#39; category Rebol languages aren&#39;t a particularly great choice for math.</description>
    
      <lastBuildDate>Sat, 17 May 2025 07:18:06 +0000</lastBuildDate>
      <atom:link href="https://rebol.metaeducation.com/c/domains/math/60.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>What Is (5 / 2) ... And Other Conundrums</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>In Rebol2, R3-Alpha, and Red... division produces a DECIMAL!:</p>
<pre><code>red&gt;&gt; 5 / 2
== 2.5
</code></pre>
<p>I've never been crazy about the too-easy production of of DECIMAL!s.</p>
<h2><a name="p-8302-red-added-for-integer-divisionhttpsgithubcomredredissues2433-1" class="anchor" href="https://rebol.metaeducation.com#p-8302-red-added-for-integer-divisionhttpsgithubcomredredissues2433-1"></a><a href="https://github.com/red/red/issues/2433">Red Added <code>//</code> for INTEGER!-Division</a></h2>
<pre><code>&gt;&gt; 5 // 2
== 1
</code></pre>
<p>That thread is very long and GitHub collapses it for some reason, be sure to click the "LOAD MORE" to see the whole thing.  (Note in particular <strong><a href="https://gitlab.com/-/snippets/1901617">@hiiamboris's modulo tests and graphs</a></strong>.)</p>
<p>Note they might remove it.  It's a long thread and <a href="https://github.com/red/red/issues/2433#issuecomment-1126994152">hard to know what Nenad's conclusions are when he doesn't weigh in</a>.  But he did drop it from a milestone in 2022.</p>
<p>The big carry-away here is that this is a very nuanced topic that is tough to solve simply.  Boris asks:</p>
<blockquote>
<p>"Are we defining <code>//</code> as a divide operation <em>that always produces an integer</em> (float // float = int; int // float and float // int too) or a divide operation that does not promote the operands when they are both integers (only int // int)? (what will make more sense?)"</p>
</blockquote>
<p>Then there's other datatypes, VECTOR! etc...</p>
<h2><a name="p-8302-my-leaning-is-almost-always-less-implicit-behavior-2" class="anchor" href="https://rebol.metaeducation.com#p-8302-my-leaning-is-almost-always-less-implicit-behavior-2"></a>My Leaning Is Almost Always <em>Less Implicit Behavior</em></h2>
<p>...and because I like <strong><code>//</code></strong> very much for APPLY, I'm happy to use DIV instead for infix integer division with no remainder.</p>
<pre><code>&gt;&gt; 5 / 2
** Error: INTEGER! division not even, use DIV or cast to DECIMAL

&gt;&gt; 5 div 2
== 2

&gt;&gt; (to decimal! 5) / 2
== 2.5
</code></pre>
<p>With FENCE! running CONSTRUCT, I've proposed what construct does is that if the first expression resolves to a DATATYPE!...it interpret it as an intent to create that type.</p>
<p>This gives a lighter syntax:</p>
<pre><code>&gt;&gt; (to decimal! 5) / 2
== 2.5

&gt;&gt; {decimal! 5} / 2  ; saves 3 characters, but drops an entire word
== 2.5
</code></pre>
<p><strong>I'm Okay With INTEGER! / INTEGER! Giving An Error If The Result Isn't An INTEGER!</strong></p>
<p>A lot of times when I divide things that are integers I <em>know</em> they are evenly divisible.</p>
<p>If I don't know they are, then a decimal dropping out rarely "just works" without some additional code or mitigation, unless I'm printing out some kind of percentage result and the usage stops at the user's eyes.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/what-is-5-2-and-other-conundrums/2456">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/what-is-5-2-and-other-conundrums/2456</link>
          <pubDate>Sat, 17 May 2025 07:18:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2456</guid>
          <source url="https://rebol.metaeducation.com/t/what-is-5-2-and-other-conundrums/2456.rss">What Is (5 / 2) ... And Other Conundrums</source>
        </item>
        <item>
          <title>INTERSECT/UNION/etc. Give Another Win For Isotopes!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>The set (collection) operations in Rebol are useful.</p>
<pre><code>rebol2&gt;&gt; set1: [a b c]
rebol2&gt;&gt; set2: [b c d]

rebol2&gt;&gt; intersect set1 set2
== [b c]
</code></pre>
<p>When I first encountered it, I thought it strange that it wasn't mutating the first argument.</p>
<pre><code>rebol2&gt;&gt; set1
== [a b c]  ; not modified by INTERSECT
</code></pre>
<p>Everywhere else in Rebol it seemed when you had a verb like that (APPEND, REVERSE, etc.) it was modifying.  What was special about INTERSECT that it didn't?</p>
<p>Anyway, that was just the first thing I noticed.  But digging around in the code there were questions... such as, why should it only take block lists?</p>
<pre><code>rebol2&gt;&gt; intersect [a b c] quote (b c d)
** Script Error: Expected one of: block! - not: paren!

red&gt;&gt; intersect [a b c] quote (b c d)
*** Script Error: intersect does not allow paren! for its set2 argument
</code></pre>
<p>I raised the question to <a class="mention" href="https://rebol.metaeducation.com/u/blackattr">@BlackATTR</a> who suggested that maybe single elements should just go in the list, as whole items:</p>
<pre><code>&gt;&gt; intersect [a b c] '(b c d)
== []

&gt;&gt; union [a b c] '(b c d)
== [a b c (b c d)]
</code></pre>
<p>And then I noticed... <strong>splices could draw the distinction!</strong></p>
<pre><code>&gt;&gt; union [a b c] [b c d]
== [a b c [b c d]]

&gt;&gt; union [a b c] spread [b c d]
== [a b c d]

&gt;&gt; union [a b c] spread '(b c d)
== [a b c d]

&gt;&gt; union '(a b c) spread [b c d]
== (a b c d)
</code></pre>
<p>This gives you the power to easily do set operations with single elements, and splices with SPREAD dispel the type information so there's no question what the return type should be: the type of the first set!</p>
<p>And I think to be consistent with the rest of the language, the operations should modify the first set argument by default.  But if you use the OF operations you get a copy.</p>
<p>Then, the OF operations might have different parts of speech:</p>
<pre><code> intersection of set1 set2
 =&gt; intersect (copy set1) set2

 union of set1 set2
 =&gt; unite (copy set1) set2
</code></pre>
<p>This would open up things like union and intersection to be nouns.</p>
<pre><code> union: union of set1 set2
</code></pre>
<p>This seems to me to be much better and a lot more consistent!</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/intersect-union-etc-give-another-win-for-isotopes/2380">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/intersect-union-etc-give-another-win-for-isotopes/2380</link>
          <pubDate>Mon, 24 Mar 2025 13:23:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2380</guid>
          <source url="https://rebol.metaeducation.com/t/intersect-union-etc-give-another-win-for-isotopes/2380.rss">INTERSECT/UNION/etc. Give Another Win For Isotopes!</source>
        </item>
        <item>
          <title>Making RANDOM Less Random :thinking:</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>Historical RANDOM in Rebol is a hodgepodge, which Red carried forward:</p>
<pre><code>red&gt;&gt; help random
USAGE:
     RANDOM value

DESCRIPTION: 
     Returns a random value of the same datatype; or shuffles series. 
     RANDOM is an action! value.

ARGUMENTS:
     value         "Maximum value of result (modified when series)."

REFINEMENTS:
     /seed        =&gt; Restart or randomize.
     /secure      =&gt; Returns a cryptographically secure random number.
     /only        =&gt; Pick a random value from a series.

RETURNS:
     [any-type!]
</code></pre>
<p>What the function does can vary significantly based on the refinements and argument:</p>
<pre><code>&gt;&gt; random 10
== 5  ; just picks an integer from 1 to 10 inclusive

&gt;&gt; block: [a b c]

&gt;&gt; random block
== [c b a]  ; e.g. default behavior for block is SHUFFLE

&gt;&gt; block
== [c b a]  ; and it's a mutating shuffle.

&gt;&gt; random/only block
== b  ; so /only makes it pick an element out of blocks

&gt;&gt; random/seed [a b c] 
; no return value, just makes the next values deterministic
</code></pre>
<p>That's just crazy.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/zany_face.png?v=14" title=":zany_face:" class="emoji" alt=":zany_face:" loading="lazy" width="20" height="20">   Not only is it hard to predict what it's going to do, but the type specs don't tell you what the return values are.</p>
<p>As part of transitioning RANDOM to <a href="https://rebol.metaeducation.com/t/further-optimizations-of-breaking-the-64-type-barrier/2369">"New Generics"</a> I decided to go ahead and split this up.</p>
<h2><a name="p-8048-shuffle-random-randomize-random-pick-1" class="anchor" href="https://rebol.metaeducation.com#p-8048-shuffle-random-randomize-random-pick-1"></a>SHUFFLE, RANDOM, RANDOMIZE, RANDOM-PICK</h2>
<ul>
<li>RANDOM:SEED =&gt; RANDOMIZE</li>
<li>RANDOM:ONLY =&gt; RANDOM-PICK</li>
<li>RANDOM =&gt; if it shuffled a series, SHUFFLE, else RANDOM</li>
</ul>
<p>Then I've added another routine SHUFFLE-OF which works on immutable types, making a new shuffled copy.  And the way it works is that if you use SHUFFLE-OF on a type that doesn't have a tailored implementation of it, then it falls back and tries to do it as SHUFFLE COPY.</p>
<pre><code>&gt;&gt; path: 'a/b/c/d

&gt;&gt; shuffle path
** Error: PATH! is immutable

&gt;&gt; shuffle of path
== c/d/a/b  ; uses the SHUFFLE-OF registered for ANY-SEQUENCE?

&gt;&gt; block: [a b c d]

&gt;&gt; shuffle of block
== [b d c a]  ; no SHUFFLE-OF for ANY-LIST?, falls back on SHUFFLE COPY

&gt;&gt; block
== [a b c d]
</code></pre>
<p>I also thought it would be useful to have RANDOM-BETWEEN, because then you can say what the min and max values are without needing to do math on a 1-based RANDOM result:</p>
<pre><code>&gt;&gt; random-between 5 10
== 7
</code></pre>
<h2><a name="p-8048-further-directions-random-dialect-2" class="anchor" href="https://rebol.metaeducation.com#p-8048-further-directions-random-dialect-2"></a>Further Directions: RANDOM Dialect?</h2>
<p>In this formulation so far, RANDOM on a BLOCK! has no meaning.</p>
<p>That made me wonder about whether RANDOM should be dialected when you pass it a block:</p>
<pre><code>random [between 10 and 20]

random [between 10 and 20 distribution 'normal]

random [weighted [["A" 0.7] ["B" 0.2] ["C" 0.1]]]
</code></pre>
<p>Dialects of this kind have proven very difficult to design, and we've only got a few of them.  Once you move things out of the domain of simple functions you make them harder to specialize/adapt/cascade, and you wind up doing work that the evaluator takes care of for you with a function.</p>
<p>But I do think that looks nice, and is something to think about for the future.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/making-random-less-random/2375">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/making-random-less-random/2375</link>
          <pubDate>Thu, 20 Mar 2025 16:46:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2375</guid>
          <source url="https://rebol.metaeducation.com/t/making-random-less-random/2375.rss">Making RANDOM Less Random :thinking:</source>
        </item>
        <item>
          <title>Should (1 + #A) Equal (#A + 1) ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>I ran across this peculiarity:</p>
<pre><code>rebol2&gt;&gt; 1 + #"A"
== 66

rebol2&gt;&gt; #"A" + 1
== #"B"
</code></pre>
<p>Red and R3-Alpha do this too.</p>
<p>Loosely speaking, there's an internal policy which is something along the lines of <em>"if the types don't match, convert the second operand into the type of the first, and then do the add"</em>.</p>
<p>Because of this, it's necessary to support the addition of characters to each other to get <strong>(<span class="hashtag-raw">#A</span> + 1)</strong> to work:</p>
<pre><code>red&gt;&gt; #"A" + #"B"
== #"^(83)"  ; only useful in implementation of old coercion rule
</code></pre>
<p>...which seems nonsensical to me.</p>
<h2><a name="p-7963-what-do-other-languages-do-1" class="anchor" href="https://rebol.metaeducation.com#p-7963-what-do-other-languages-do-1"></a>What Do Other Languages Do?</h2>
<p>If "implicit type promotion" is supported, many languages, including C, C++, and Java, use a system where the "smaller" type is converted to the "larger" type (<a href="https://pages.mtu.edu/~shene/COURSES/cs201/NOTES/chap02/exp-2.html">e.g., int to float</a>).  Having an idea of what's bigger and what's smaller helps avoid the commutativity problem.</p>
<p>And in the specific case of adding characters to integers, Rebol is weird to give a different answer depending on order.</p>
<ul>
<li>
<p><strong>Python:</strong> In Python, adding an integer to a character (or vice versa) would raise a TypeError. Python doesn't implicitly convert between these types.</p>
</li>
<li>
<p><strong>JavaScript:</strong> JavaScript would convert the character to its ASCII value and perform integer addition in both cases, resulting in a number.</p>
</li>
<li>
<p><strong>Ruby:</strong> Similar to Python, Ruby would raise a TypeError when trying to add an integer to a character.</p>
</li>
<li>
<p><strong>Java:</strong> Java doesn't allow direct addition between char and int types without explicit casting.</p>
</li>
</ul>
<p>I think adding integers to characters and wanting a character back is the more common operation, so if it's legal, I'd advocate for:</p>
<pre><code>&gt;&gt; 1 + #A
== #B

&gt;&gt; #A + 1
== #B
</code></pre>
<p>But if we want to rule out addition of characters to characters (which I do) this commutative behavior doesn't fall out from a system of implicit conversion with an ordering on "bigger" types... since characters are smaller.</p>
<p>I don't see an obvious "rule" besides hardcoding it.</p>
<h2><a name="p-7963-what-about-commutativity-in-general-2" class="anchor" href="https://rebol.metaeducation.com#p-7963-what-about-commutativity-in-general-2"></a>What About Commutativity In General?</h2>
<p>We can imagine decisions on what you would make <strong><code>+</code></strong> mean that would not be commutative.  For instance, if you were allowed to make it mean "join strings":</p>
<pre><code>&gt;&gt; "abc" + "def"
== "abcdef"

&gt;&gt; "def" + "abc"
== "defabc"
</code></pre>
<p>So you might try and argue that the rules for <strong>add</strong> are different than the rules for <strong>+</strong>, and it's only when + is acting as ADD that it enforces commutativity.  However... even in the domain of math, you have exceptions... e.g. matrix multiplication is not commutative.</p>
<p>The more general question of commutativity seems to be that there aren't any popular languages that do it automatically.  e.g. in C++ you have to overload <strong><code>operator+(T1,T2)</code></strong> and <strong><code>operator+(T2,T1)</code></strong> separately...one of them can call the other, but that never happens automatically.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-1-a-equal-a-1/2346">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-1-a-equal-a-1/2346</link>
          <pubDate>Fri, 06 Dec 2024 12:30:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2346</guid>
          <source url="https://rebol.metaeducation.com/t/should-1-a-equal-a-1/2346.rss">Should (1 + #A) Equal (#A + 1) ?</source>
        </item>
        <item>
          <title>Dimension Conversions in Arturo</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>Here is a table of dimensions used by <a href="https://rebol.metaeducation.com/t/arturo-rebol-inspired-language/1370">Arturo</a>, expressed as a table in the Nim language:</p>
<p><a href="https://github.com/arturo-lang/arturo/blob/master/src/vm/values/custom/quantities/definitions.nim" class="inline-onebox">arturo/src/vm/values/custom/quantities/definitions.nim at master · arturo-lang/arturo · GitHub</a></p>
<p>It's a pretty impressive compendium.  And there's also some "heavily macro-driven" Nim code that implements conversion operations:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/970992fb6919f5b8f0bb350bcbff2390f350cab0.jpeg" data-download-href="https://rebol.metaeducation.com/uploads/default/970992fb6919f5b8f0bb350bcbff2390f350cab0" title="Screenshot_2024-10-11_at_07.40.49"><img src="https://rebol.metaeducation.com/uploads/default/optimized/1X/970992fb6919f5b8f0bb350bcbff2390f350cab0_2_371x375.jpeg" alt="Screenshot_2024-10-11_at_07.40.49" data-base62-sha1="ly8BQYMZcqhc44hu8VlGzNKezNS" width="371" height="375" srcset="https://rebol.metaeducation.com/uploads/default/optimized/1X/970992fb6919f5b8f0bb350bcbff2390f350cab0_2_371x375.jpeg, https://rebol.metaeducation.com/uploads/default/optimized/1X/970992fb6919f5b8f0bb350bcbff2390f350cab0_2_556x562.jpeg 1.5x, https://rebol.metaeducation.com/uploads/default/original/1X/970992fb6919f5b8f0bb350bcbff2390f350cab0.jpeg 2x" data-dominant-color="312113"></a></div><p></p>
<p><a class="mention" href="https://rebol.metaeducation.com/u/drkameleon">@drkameleon</a> cites <a href="https://frinklang.org/">Frink</a> as the main inspiration for this, though assembling the table and conversion code was original work on the order of months.</p>
<h2><a name="p-7841-why-not-use-arturo-for-the-table-1" class="anchor" href="https://rebol.metaeducation.com#p-7841-why-not-use-arturo-for-the-table-1"></a>Why Not Use Arturo For The Table...?</h2>
<p>The table is Nim code...and as such, beholden to having a lot of repetition and commas.</p>
<p>So of course my first question was <em>"why not express it as Arturo, and then spit out the Nim table as part of the build process"</em>?</p>
<p>Instead of:</p>
<pre><code>#-----------------------------------------------------------------------
# Length units (base: m)
#-----------------------------------------------------------------------
#       name  symbol  prefix?    definition      aliases
#-----------------------------------------------------------------------
defUnit "in",  "in", false,  "127:5000 m",      "inch", "inches"
defUnit "ang",  "Å", false,  "1:10000000000 m", "angstrom", "angstroms"
defUnit "px",  "px", true,   "1:96 in",         "pixel", "pixels"
</code></pre>
<p>It could be reduced down to something more like this:</p>
<pre><code>    === LENGTH (base: m) ===

     in [127:5000 m] inch inches
    ang [1:10000000000 m] angstrom angstroms ("Å")
   */px [1:96 in] pixel pixels
</code></pre>
<p>The meaning of "prefix?" is actually "prefixable?" that a type can have a prefix. e.g. pixels is prefixable because you can say <strong><code>Mpx</code></strong> for "megapixels".  So I think some prefixing decoration on the type is a nice way to convey this.  I just threw in <strong><code>*/px</code></strong> as an example--though I gather that in Arturo that would be <strong><code>*\px</code></strong></p>
<p>Though when I first saw some isolated instance of the colon notation I didn't realize it was a ratio.  Ren-C could do this as a CHAIN! or as a PATH!.  I think my first instinct would have been path:</p>
<pre><code>     in [127/5000 m] inch inches
    ang [1/10000000000 m] angstrom angstroms ("Å")
   *.px [1/96 in] pixel pixels
</code></pre>
<p>But it actually looks a bit better with the colons I think.</p>
<p>Some notation would be nice for the pluralization.  It's one of the places where the <a href="https://rebol.metaeducation.com/t/no-interstitial-delimiter-sequence-proposal-fused/1503">FUSED! proposal</a> might come in handy:</p>
<pre><code>     in [127:5000 m] inch{es}
    ang [1:10000000000 m] angstrom{s} ("Å")
   */px [1:96 in] pixel{s}
</code></pre>
<p>You can use tuples or paths, but it's not quite as neat...although the paths aren't terrible:</p>
<pre><code>     in [127:5000 m] inch.es
    ang [1:10000000000 m] angstrom.s ("Å")
   */px [1:96 in] pixel.s

     in [127:5000 m] inch/es
    ang [1:10000000000 m] angstrom/s ("Å")
   */px [1:96 in] pixel/s
</code></pre>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/dimension-conversions-in-arturo/2314">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/dimension-conversions-in-arturo/2314</link>
          <pubDate>Fri, 11 Oct 2024 07:09:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2314</guid>
          <source url="https://rebol.metaeducation.com/t/dimension-conversions-in-arturo/2314.rss">Dimension Conversions in Arturo</source>
        </item>
        <item>
          <title>Should AND + OR Handle VOID?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>Ren-C has infix AND and OR, which are conditional--not bitwise.  Since #[true] and #[false] no longer exist, they now act on things being "branch triggers" or not...which is basically "non-null things vs. null".</p>
<p>So we have for instance:</p>
<pre><code>        null and null   -&gt;   ~null~ antiform     
    null and (truthy)   -&gt;   ~null~ antiform
    (truthy) and null   -&gt;   ~null~ antiform
(truthy) and (truthy)   -&gt;   ~okay~ antiform
</code></pre>
<p>Today's rule is that to get TRUTHY to be truthy you need some non-null, non-void/trash thing.  VOID and TRASH cause errors.</p>
<h2><a name="p-7660-including-void-would-be-more-flexible-worth-it-1" class="anchor" href="https://rebol.metaeducation.com#p-7660-including-void-would-be-more-flexible-worth-it-1"></a>Including VOID Would Be More Flexible.  Worth It?</h2>
<pre><code>        void and void   -&gt;   ~[]~ antiform
        void and null   -&gt;   ~null~ antiform
        null and void   -&gt;   ~null~ antiform
    void and (truthy)   -&gt;   ~okay~ antiform
    (truthy) and void   -&gt;   ~okay~ antiform
</code></pre>
<p>You'd get an error if you tried <strong><code>if (void-thing) and (void-thing) [...]</code></strong>, which seems good to me.</p>
<p>It's strictly more powerful.  Going along with the general idea that "Errors aren't big enablers of creativity", I am leaning toward endorsing it.</p>
<p>Particularly because accidental creation of VOID has been pruned further than ever.  It's not something you can ever pick out of blocks or get from a variable.  And with type checking there'll be even more confidence that those who are doing this are doing it intentionally.</p>
<p>It's not a priority.  But I can see how it could be useful.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-and-or-handle-void/2274">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-and-or-handle-void/2274</link>
          <pubDate>Fri, 13 Sep 2024 08:49:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2274</guid>
          <source url="https://rebol.metaeducation.com/t/should-and-or-handle-void/2274.rss">Should AND + OR Handle VOID?</source>
        </item>
        <item>
          <title>Should Floating Point Really Be The Default?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p><a href="https://github.com/red/red/issues/3396#issuecomment-1654470030">In an issue on Red's GitHub</a>, Gregg gives this example:</p>
<pre><code>red&gt;&gt; n: 0  while [n &lt;= 0.3][print mold/all n  n: n + 0.1]
0
0.1
0.2
; Huh?

red&gt;&gt; n: 0  while [n &lt;= 3][print mold/all n  n: n + 1]
0
1
2
3
; OK. I'm not crazy

red&gt;&gt; n: 0  while [n &lt;= 0.4][print mold/all n  n: n + 0.1]
0
0.1
0.2
0.30000000000000004
0.4
; What... Oh... How do I work around that?
</code></pre>
<p>Sure, you can point everyone to <a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">"What Every Computer Scientist Should Know About Floating Point Arithmetic"</a> and say it's not your problem.  I mean geez, it's only a mere 50 or 60 pages long.</p>
<p>But as Gregg says:</p>
<blockquote>
<p><em>"Yes, we can explain it. Yes, not everyone will hit this. But [...] we don't just look like we're passing problems on and throwing our hands in the air, saying it's not our problem; it's part of our mission, and being empathetic to pain points is something people can hold up as examples of why <em>to</em> use Red, rather than why <em>not</em> to use Red."</em></p>
</blockquote>
<p>This makes me wonder about the choice to use floating point as a default.  Yes, it's in the hardware.  Yes you should be able to use them somehow.  But it may not be a fit for the language goals when considering examples like the above.  So I thought I'd ask the AIs about it.</p>
<hr>
<p><em>Note: The MONEY! datatype in R3-Alpha is not an IEEE floating point.  <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/f-deci.c#L27">It's something Ladislav wrote</a>:</em></p>
<pre><code>Deci significands are 87-bit long, unsigned, unnormalized, stored in
little endian order. (Maximal deci significand is 1e26 - 1, i.e. 26
nines)

Sign is one-bit, 1 means nonpositive, 0 means nonnegative.

Exponent is 8-bit, unbiased.
</code></pre>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-floating-point-really-be-the-default/2248">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-floating-point-really-be-the-default/2248</link>
          <pubDate>Wed, 04 Sep 2024 08:10:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2248</guid>
          <source url="https://rebol.metaeducation.com/t/should-floating-point-really-be-the-default/2248.rss">Should Floating Point Really Be The Default?</source>
        </item>
        <item>
          <title>Isotopes and NaN (Not a Number)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>Prior to the existence of isotopes--when only VOID and NULL existed as outliers--I had an idea that VOIDs and NULLs could act as the <em>quiet NaN</em> and <em>signaling NaN</em> forms of  <a href="https://en.wikipedia.org/wiki/NaN">"not-a-number" (NaN)</a>.  The goal of this is to allow math handling to be more graceful, without needing to set up TRAPs and such--you can be selective about which operations you are willing to have fail, and supply code to fill in such cases.</p>
<h2><a name="p-7539-original-idea-math-ops-follow-void-in-null-outhttpsrebolmetaeducationcomtthe-void-in-null-out-protocol1880-1" class="anchor" href="https://rebol.metaeducation.com#p-7539-original-idea-math-ops-follow-void-in-null-outhttpsrebolmetaeducationcomtthe-void-in-null-out-protocol1880-1"></a>Original Idea: Math Ops Follow <a href="https://rebol.metaeducation.com/t/the-void-in-null-out-protocol/1880">VOID-IN-NULL-OUT</a></h2>
<p>This was the proposed behavior for NULL as signaling NaN and VOID as quiet NaN:</p>
<pre><code>&gt;&gt; square-root -1
== \~null~\  ; antiform

&gt;&gt; opt square-root -1
== \~[]~\  ; antiform "void"

&gt;&gt; 1 + square-root -1
** Error: + doesn't accept NULL for its value2 argument

&gt;&gt; 1 + (square-root -1 else [10])  ; selective handling
== 11

&gt;&gt; 1 + opt square-root -1  ; propagation
== \~null~\  ; antiform
</code></pre>
<h2><a name="p-7539-but-i-dont-like-void-as-quiet-nan-and-it-breaks-compares-2" class="anchor" href="https://rebol.metaeducation.com#p-7539-but-i-dont-like-void-as-quiet-nan-and-it-breaks-compares-2"></a>But I Don't Like VOID as Quiet NaN (and It Breaks Compares)</h2>
<p>I prefer that when void arguments are received by math functions, <strong><a href="https://rebol.metaeducation.com/t/opting-out-of-math-functions-with-void/2244">they return the other operand</a></strong> (with the exception of void divisors)...not a noisy NaN.</p>
<pre><code>&gt;&gt; 10 * when 1 &gt; 100 [20]
== 10
</code></pre>
<p>Also, Wikipedia has a little table about how NaNs work with comparisons:</p>
<blockquote>
<p>Comparison between NaN and any floating-point value  <em>x</em>  (including NaN and ±∞)</p>
<ul>
<li><strong>NaN ≥ x</strong> =&gt; <em>Always False</em></li>
<li><strong>NaN ≤  x</strong> =&gt; <em>Always False</em></li>
<li><strong>NaN &gt; x</strong> =&gt; <em>Always False</em></li>
<li><strong>NaN &lt; x</strong> =&gt; <em>Always False</em></li>
<li><strong>NaN = x</strong> =&gt; <em>Always False</em></li>
<li><strong>NaN ≠ x</strong> =&gt; <em>Always True</em></li>
</ul>
</blockquote>
<p>Look at that last case.  If VOID is the quiet NaN, you can't have that comparison returning NULL, because it would be falsey instead of truthy...so VOID-in-NULL-out breaks down here:</p>
<pre><code>&gt;&gt; 10 != (1 + square-root -1)
** Error: != doesn't accept NULL for its value2 argument

&gt;&gt; 10 = (opt 1 + opt square-root -1)
== \~null~\  ; antiform

&gt;&gt; 10 != (opt 1 + opt square-root -1)
== \~null~\  ; antiform 
</code></pre>
<p><em>(I've made similar observations about <a href="https://rebol.metaeducation.com/t/the-void-in-null-out-protocol/1880/8">VOID-in-NULL-out with LOGIC! returning functions</a> before.)</em></p>
<p>Beyond not liking VOID for quiet NaN, I'm not hot on NULL being the noisy NaN either.</p>
<h2><a name="p-7539-new-idea-signaling-is-error-antiform-quiet-is-nan-antiform-3" class="anchor" href="https://rebol.metaeducation.com#p-7539-new-idea-signaling-is-error-antiform-quiet-is-nan-antiform-3"></a>New Idea: Signaling is Error Antiform, Quiet is ~NaN~ Antiform</h2>
<p>A lot of design space opened up with the <a href="https://rebol.metaeducation.com/t/a-justification-of-generalized-isotopes/1918">introduction of generalized isotopes</a>.</p>
<p>So I think signaling NaN should be <a href="https://rebol.metaeducation.com/t/fail-vs-return-raise-the-new-age-of-definitional-errors/1852">an error antiform</a>.  And quiet NaN should probably just be the ~NaN~ WORD! antiform.</p>
<p>TRY typically converts antiform errors to NULL, so they don't promote to abrupt failures.  But if TRY converted the specific NaN error antiform to the ~NaN~ word antiform, we could avoid having to come up with a special word for "MATH-TRY".</p>
<p>(This makes me think that quiet ~NaN~ word antiform should be falsey, so the usage pattern can line up with other null-bearing TRY instances...and I imagine MAYBE should also turn quiet ~NaN~ to VOID, for similar reasons.)</p>
<p>Anyway, here's how this would play out:</p>
<pre><code>&gt;&gt; square-root -1  ; unhandled raised error return promotes to abrupt failure
** Error: Not a Number

&gt;&gt; try square-root -1  ; TRY intercepts raised error before it abruptly fails
== \~NaN~\  ; antiform

&gt;&gt; 1 + square-root -1
** Error: Not a Number  ; was promoted to abrupt failure before + could see it

&gt;&gt; 1 + try square-root -1  ; TRY makes quiet ~NaN~, then + propagates
== \~NaN~\  ; antiform

&gt;&gt; 10 != (1 + try square-root -1)
== \~okay~\  ; antiform

&gt;&gt; 10 = (1 + try square-root -1)
== \~null~\  ; antiform

&gt;&gt; 1 + ((try square-root -1) else [10])
== 11

&gt;&gt; 1 + any [square-root -1, 10]
** Error: Not a Number

&gt;&gt; 1 + any [try square-root -1, 10]
== 11
</code></pre>
<h2><a name="p-7539-i-think-that-looks-solid-4" class="anchor" href="https://rebol.metaeducation.com#p-7539-i-think-that-looks-solid-4"></a>I Think That Looks Solid</h2>
<p>Another day, <a href="https://rebol.metaeducation.com/t/the-theory-of-meta-representability/2217">another success story for isotopes</a>.  Definitionally raised error antiforms provide the mechanics to make an interceptible error by contract as a return value that isn't itself an abrupt failure, but promotes to abrupt failure when not anticipated.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/atom_symbol.png?v=14" title=":atom_symbol:" class="emoji" alt=":atom_symbol:" loading="lazy" width="20" height="20"></p>
<p>And it's cool that we have another WORD! antiform state that has the properties we want, while not being able to be put in blocks... but which has a quasi state that can, if you need to pipe things around:</p>
<pre><code>&gt;&gt; try sqrt -1
== \~NaN~\  ; antiform

&gt;&gt; block: append [1 2 3] try sqrt -1
** Error: append doesn't accept ~NaN~ antiform as its value argument

&gt;&gt; block: append [1 2 3] lift try sqrt -1
== [1 2 3 ~NaN~]

&gt;&gt; block.4
== ~NaN~

&gt;&gt; 10 + block.4
** Error: + doesn't accept ~NaN~ quasiform as its value2 argument

&gt;&gt; unlift block.4
== \~NaN~\  ; antiform

&gt;&gt; 10 + unlift block.4
== \~NaN~\  ; antiform
</code></pre>
<p>And heck, <strong><code>fail ~NaN~</code></strong> could produce the error antiform, bringing things full circle.</p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/isotopes-and-nan-not-a-number/2245">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/isotopes-and-nan-not-a-number/2245</link>
          <pubDate>Tue, 03 Sep 2024 19:51:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2245</guid>
          <source url="https://rebol.metaeducation.com/t/isotopes-and-nan-not-a-number/2245.rss">Isotopes and NaN (Not a Number)</source>
        </item>
        <item>
          <title>Opting Out of Math Functions With VOID</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>It seems to me that it could be useful if math operations accepted VOID.</p>
<pre><code>&gt;&gt; factor: null

&gt;&gt; coefficient: 10

&gt;&gt; value: multiply factor coefficient
** Error: multiply doesn't allow ~null~ antiform for its value1 argument

&gt;&gt; multiply maybe factor coefficient
== 10

&gt;&gt; add coefficient maybe factor
== 10
</code></pre>
<p>If you opt out of the left hand side of a subtraction, you'd get negation:</p>
<pre><code>&gt;&gt; subtract maybe factor coefficient
== -10
</code></pre>
<p>If you opt out of the left side of a division, er... hm.  That should probably be an error.</p>
<pre><code>&gt;&gt; divide maybe factor coefficient
** Error: divide doesn't allow ~void~ antiform for its value1 argument
</code></pre>
<p>If you opt out of both arguments you get null.</p>
<pre><code>&gt;&gt; add maybe factor maybe factor
== ~null~  ; anti
</code></pre>
<p>I suppose divide can allow you to opt out of both arguments, though it makes the interface suggest the dividend can be opted out of in isolation since it would have void in the accepted types solely to handle the both-opt-out case.</p>
<h2><a name="p-7538-seems-useful-and-supports-my-cautious-attitude-on-void-1" class="anchor" href="https://rebol.metaeducation.com#p-7538-seems-useful-and-supports-my-cautious-attitude-on-void-1"></a>Seems Useful and Supports My Cautious Attitude on VOID</h2>
<p>I now believe <a href="https://rebol.metaeducation.com/t/maybe-if-conditionals-went-back-to-returning-null-on-failure/2047">CASE and SWITCH etc. that do not take any branches should return NULL</a>.  So you're less likely to be bitten by stray voids being tolerated in such situations, and need an explicit MAYBE.</p>
<p>But IF will still return void.</p>
<pre><code>&gt;&gt; multiply 10 (if 1 &gt; 100 [20])
== 10
</code></pre>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/opting-out-of-math-functions-with-void/2244">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/opting-out-of-math-functions-with-void/2244</link>
          <pubDate>Tue, 03 Sep 2024 18:02:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2244</guid>
          <source url="https://rebol.metaeducation.com/t/opting-out-of-math-functions-with-void/2244.rss">Opting Out of Math Functions With VOID</source>
        </item>
        <item>
          <title>Dimensional Analysis with FUSED!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p><a href="https://rebol.metaeducation.com/t/no-interstitial-delimiter-sequence-proposal-fused/1503">INTEGER!-led FUSED!</a> could have a pretty good default behavior in addition and subtraction...</p>
<pre><code>&gt;&gt; 10px + 20px
== 30px

&gt;&gt; 10px + 20em
** Error: Cannot add FUSED! unless non numeric portions match (px, em)
</code></pre>
<p>And with <a href="https://rebol.metaeducation.com/t/backtick-literals-and-an-axis-of-extensibility/2235">Backtick Literals</a> it might give an answer for the longstanding question of putting units on currency.</p>
<pre><code>&gt;&gt; `$10.20`USD + `$3.04`CAN
** Error: Cannot add FUSED! unless non numeric portions match (USD, CAN)
</code></pre>
<p>So we'd get some very limited dimensional analysis.  There's nothing lower in sequence precedence than a FUSED! though...e.g. FUSED! lives under PATH!, so don't expect <strong><code>10m/s * 20s</code></strong> to work.</p>
<p>Although <img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"> you could write <strong><code>10[m/s]</code></strong> ... but I'm not imagining the built-in multiplication working this out for you.  Just stopping you from adding 10[m/s] to 20s.  But who knows--maybe handling a tiny bit of this would be valuable.</p>
<p>The precedence of TUPLE! beneath PATH! might be an asset here:</p>
<pre><code>&gt;&gt; x: 10em * 20px
== 200[em.px]

&gt;&gt; x / 50
== 4[em.px/s]
</code></pre>
<p>Equality would bite you.  Structurally we can't say <strong><code>4[px.em/s]</code></strong> is equal to <strong><code>4[em.px/s]</code></strong>.  You'd need some kind of canonizing operation that would sort the sequences in a predictable order.  SORT:DEEP ?</p>
<pre><code>&gt;&gt; sort 'f.a:c.d/b.e:[h/g]
== b.e:[h/g]/f.a:c.d

&gt;&gt; sort:deep 'f.a:c.d/b.e:[h/g]
== 'b.e:[g/h]/a.f:c.d
</code></pre>
<p>All integers would have to be less than all WORD!s and LIST!s in sort order to use SORT:DEEP for this purpose.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/dimensional-analysis-with-fused/2239">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/dimensional-analysis-with-fused/2239</link>
          <pubDate>Sat, 31 Aug 2024 17:36:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2239</guid>
          <source url="https://rebol.metaeducation.com/t/dimensional-analysis-with-fused/2239.rss">Dimensional Analysis with FUSED!</source>
        </item>
        <item>
          <title>The Great Divide: Troubles Assigning Slash</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>So I apologize to <a class="mention" href="https://rebol.metaeducation.com/u/giuliolunati">@giuliolunati</a> for making him have to put up with the <a href="https://rebol.metaeducation.com/t/trying-as-a-path-of-two-blank-s-instead-of-a-word/798"><strong><code>/</code> is a 2-element path containing BLANK!s</strong> debacle back in 2018.</a> <img src="https://rebol.metaeducation.com/images/emoji/twitter/see_no_evil.png?v=14" title=":see_no_evil:" class="emoji" alt=":see_no_evil:" loading="lazy" width="20" height="20"></p>
<p>On the positive side of me being mired in the implementation, I can see when something creates dissonance and edge cases...and know that things need to be avoided before someone in userspace would even know they needed to worry.  The compiler gives me type checking errors when things don't line up, and I try my best to leverage whatever tools to catch inconsistencies I can (as far as C building as C++ can do, anyway).</p>
<p>But on the negative side it means I might pick the wrong form of regularity to solve the problem.  This was such a case.  We simply needed rules at PATH! creation time that prohibit you from putting special-slash-words into a path... and that's that.</p>
<h2><a name="p-7467-so-now-and-are-words-again-1" class="anchor" href="https://rebol.metaeducation.com#p-7467-so-now-and-are-words-again-1"></a>So Now <code>/</code> And <code>.</code> Are Words Again</h2>
<p>It's still going to be slippery.  There will be problems:</p>
<pre><code>math-context: make object! [
    /+: infix add/
    /-: infix subtract/
    /.: infix multiply/
    /: infix divide/   ; ooops
 ]
</code></pre>
<p>You won't be able to say <strong><code>(/: infix divide.)</code></strong> to assign your division operator to a slash word!, <em>because that will execute the function in the colon word!</em>.  So if whatever the colon word does takes an action as an argument, you're going to take infixed divide as a parameter to that function... not perform an assignment.  The PATH! is above the WORD!.</p>
<p>But things like (<strong><code>.:</code></strong>) and (<strong><code>...:</code></strong>) should work as expected.  The WORD! is below the CHAIN!.</p>
<h2><a name="p-7467-is-too-misleading-to-execute-2" class="anchor" href="https://rebol.metaeducation.com#p-7467-is-too-misleading-to-execute-2"></a>Is  <strong><code>/:</code></strong> Too Misleading to Execute?</h2>
<p>It stands out a little as a mistake in the MATH-CONTEXT above next to the other assignments, when narrowly packed like that.  Of course, it wouldn't be narrowly packed.  And you could just be trying to assign an inert value and not a function:</p>
<p>What you wanted:</p>
<pre><code>&gt;&gt; /: 10
== 10

&gt;&gt; /
== 10
</code></pre>
<p>What you'll likely get:</p>
<pre><code>&gt;&gt; /: 10
** Error: Colon doesn't accept INTEGER! as its whatever argument
</code></pre>
<p>The evaluator could just refuse, and make you say <strong><code>run get $:</code></strong> or <strong><code>set get $/</code></strong></p>
<p>I'm tempted to say that's the right answer, because it seems like this will just lead to too much confusion otherwise.</p>
<h2><a name="p-7467-that-wont-help-you-in-set-word-gathering-3" class="anchor" href="https://rebol.metaeducation.com#p-7467-that-wont-help-you-in-set-word-gathering-3"></a>That Won't Help You In "SET-WORD!" Gathering</h2>
<p>If you can't get a "SET-WORD!" form of the slash word, the object won't collect the member.</p>
<p>This suggests we need to collect things inside SET-BLOCK!s for the object.</p>
<pre><code>math-context: make object! [
    +: infix add/
    -: infix subtract/
    .: infix multiply/
    [/]: infix divide/
 ]
</code></pre>
<p>If you wanted to say "This has to be an action assignment" for some reason, the slash could distribute across the block's multi-return assign elements.</p>
<pre><code>math-context: make object! [
    /+: infix add/
    /-: infix subtract/
    /.: infix multiply/
    /[/]: infix divide/
 ]
</code></pre>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/the-great-divide-troubles-assigning-slash/2230">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/the-great-divide-troubles-assigning-slash/2230</link>
          <pubDate>Fri, 30 Aug 2024 07:28:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2230</guid>
          <source url="https://rebol.metaeducation.com/t/the-great-divide-troubles-assigning-slash/2230.rss">The Great Divide: Troubles Assigning Slash</source>
        </item>
        <item>
          <title>About the Math category</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>Rebol languages aren't a particularly great choice for math.</p>
<ul>
<li>
<p>Operator precedence follows the left-to-right nature of the evaluator, not the precedence many would expect:</p>
<pre><code>&gt;&gt; 1 + 2 * 3
== 9
</code></pre>
</li>
<li>
<p>Its syntax focus on words-separated-by-spaces, so this expands out expressions:</p>
<pre><code>&gt;&gt; length of [x+y*z]
== 1

&gt;&gt; type of first [x+y*z]
== &amp;[word]
</code></pre>
</li>
<li>
<p>The language is interpreted, meaning that even the simplest operation like <strong>add 1 2</strong> will run thousands of times slower than a compiled instruction.</p>
</li>
</ul>
<hr>
<p>But all programming involves math every now and again.  So this category is for discussing any math issues people want to talk about.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/about-the-math-category/2155">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/about-the-math-category/2155</link>
          <pubDate>Tue, 20 Feb 2024 23:27:47 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2155</guid>
          <source url="https://rebol.metaeducation.com/t/about-the-math-category/2155.rss">About the Math category</source>
        </item>
        <item>
          <title>Future of the MATH Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>It is basically inevitable that people coming to Rebol will ask about its mathematical evaluation being left-to-right, instead of obeying the precedence order that they are used to.  Red just had a new user try to file it as a bug... 3 days ago:</p>
<p><a href="https://github.com/red/red/issues/5276" class="inline-onebox">Incorrect Order of Arithmetic Operations · Issue #5276 · red/red · GitHub</a></p>
<p><strong>What seemed to make sense to people like me and BrianH was that the core ship with a dialect called MATH.</strong>  The concept was that <strong>math [1 + 2 * 3]</strong> would give <strong>7</strong> and not <strong>9</strong>.  Having something in the box seemed better than having the first line of argument being <em>"you don't want the precedence you think you do"</em>.</p>
<p>But it turned out to be kind of hard to make pleasing.  One key difficulty which <a class="mention" href="https://rebol.metaeducation.com/u/brett">@Brett</a> and I fretted over at some point was that since Rebol isn't "psychic" regarding arity, does not know a-priori how much code an expression will consume:</p>
<pre><code>math [1 + 2 * foo baz bar + 3]

; should it be...
[1 + (2 * (foo baz bar)) + 3]

; or perhaps...
[(1 + (2 * foo)) ((baz bar) + 3)]

; maybe...
[(1 + (2 * foo)) baz (bar + 3)]
</code></pre>
<p><strong>It started to appear that the user would have to put anything that wasn't a number or a math operator in groups.</strong>  There may be some heuristics which tolerate words that look up to numbers vs. functions, but it feels very slippery.</p>
<p>As I've said I hate to be dropping things, but MATH is something that Rebol programmers don't really want in the first place--and I don't think non-Rebol programmers would be satisfied by it.  If it's included in the core that suggests support for it, and there are just too many things in play.</p>
<p>Here is an implementation that was previously included, by Gabriele:</p>
<pre><code>; This MATH implementation is from Gabrielle Santilli circa 2001, found
; via http://www.rebol.org/ml-display-thread.r?m=rmlXJHS. It implements the
; much-requested (by new users) idea of * and / running before + and - in
; math expressions. Expanded to include functions.
;
math: func [
    {Process expression taking "usual" operator precedence into account.}

    expr [block!]
        {Block to evaluate}
    /only
        {Translate operators to their prefix calls, but don't execute}

    ; !!! This creation of static rules helps avoid creating those rules
    ; every time, but has the problem that the references to what should
    ; be locals are bound to statics as well (e.g. everything below which
    ; is assigned with BLANK! really should be relatively bound to the
    ; function, so that it will refer to the specific call.)  It's not
    ; technically obvious how to do that, not the least of the problem is
    ; that statics are currently a usermode feature...and injecting relative
    ; binding information into something that's not the function body itself
    ; isn't implemented.

    &lt;static&gt;

    slash (the /)

    expr-val (_)

    expr-op (_)

    expression  ([
        term (expr-val: term-val)
        opt some [
            ['+ (expr-op: 'add) | '- (expr-op: 'subtract)]
            term (expr-val: compose [(expr-op) (expr-val) (term-val)])
        ]
        &lt;end&gt;
    ])

    term-val (_)

    term-op (_)

    term ([
        pow (term-val: power-val)
        opt some [
            ['* (term-op: 'multiply) | slash (term-op: 'divide)]
            pow (term-val: compose [(term-op) (term-val) (power-val)])
        ]
    ])

    power-val (_)

    pow ([
        unary (power-val: unary-val)
        opt ['** unary (power-val: compose [power (power-val) (unary-val)])]
    ])

    unary-val (_)

    pre-uop (_)

    post-uop (_)

    unary ([
        (post-uop: pre-uop: [])
        opt ['- (pre-uop: 'negate)]
        primary
        opt ['! (post-uop: 'factorial)]
        (unary-val: compose [(post-uop) (pre-uop) (prim-val)])
    ])

    prim-val (_)

    primary ([
        set prim-val any-number!
        | set prim-val [word! | path!] (prim-val: reduce [prim-val])
            ; might be a funtion call, looking for arguments
            opt some [
                nested-expression (append prim-val take nested-expr-val)
            ]
        | ahead group! into nested-expression (prim-val: take nested-expr-val)
    ])

    p-recursion (_)

    nested-expr-val ([])

    save-vars (func [][
            p-recursion: reduce [
                :p-recursion :expr-val :expr-op :term-val :term-op :power-val :unary-val
                :pre-uop :post-uop :prim-val
            ]
        ])

    restore-vars (func [][
            set [
                p-recursion expr-val expr-op term-val term-op power-val unary-val
                pre-uop post-uop prim-val
            ] p-recursion
        ])

    nested-expression ([
            ;all of the static variables have to be saved
            (save-vars)
            expression
            (
                ; This rule can be recursively called as well,
                ; so result has to be passed via a stack
                insert nested-expr-val expr-val
                restore-vars
            )
            ; vars could be changed even it failed, so restore them and fail
            | (restore-vars) fail

    ])
][
    clear nested-expr-val
    let res: either parse3 expr expression [expr-val] [blank]

    either only [
        return res
    ][
        ret: reduce res
        all [
            1 = length of ret
            any-number? ret.1
        ] else [
            fail [
                unspaced ["Cannot be REDUCED to a number (" mold ret ")"]
                ":" mold res
            ]
        ]
        return ret.1
    ]
]
</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/future-of-the-math-dialect/2013">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/future-of-the-math-dialect/2013</link>
          <pubDate>Tue, 31 Jan 2023 19:08:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2013</guid>
          <source url="https://rebol.metaeducation.com/t/future-of-the-math-dialect/2013.rss">Future of the MATH Dialect</source>
        </item>
        <item>
          <title>Using Shift on BINARY!</title>
          <dc:creator><![CDATA[rgchris]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>In wrestling with an older file format, it's notable how entrenched 32-bit numbers are (for bit fiddling purposes) within big specifications. JavaScript itself (I believe) converts its numbers to 32-bit for the purposes of its <strong>&lt;&lt;</strong>, <strong>&gt;&gt;</strong> and <strong>&gt;&gt;&gt;</strong> operators.</p>
<p>As R3 Alpha and Ren-C shifts on 64-bit signed integers, it is not then compatible with some of those older specification. Thus I was trying to twist my brain into figuring out how bridge the gap. In short, I gave up and went with this approach which, while appalling, works as intended:</p>
<pre><code class="lang-plaintext">bits-zero: enbase/base #{0000000000000000} 2
bits-one: enbase/base #{FFFFFFFFFFFFFFFF} 2

brute-force-shift: func [
    value [binary!]
    bits [integer!]
    /logical
    &lt;local&gt; length is-negative
][
    length: 8 * length-of value
    not-negative: zero? 128 and+ value/1
    value: enbase/base value 2

    case [
        not negative? bits [
            insert reverse value skip bits-zero 64 - bits
            reverse head clear skip value length
        ]

        any [
            logical
            not-negative
        ][
            insert value skip tail bits-zero bits
            head clear skip value length
        ]

        &lt;else&gt; [
            insert value skip tail bits-one bits
            head clear skip value length
        ]
    ]

    debase/base value 2
]
</code></pre>
<p>It works on <strong>binary!</strong> values up to 8 bytes and operates based on whatever the width of the input binary is, thus can be used along with <strong>enbin/debin</strong> to operate on <strong>integer!</strong> values at any desired width.</p>
<p>While it'd be useful to have a native version that operated on <strong>integer!</strong> with <strong>enbin/debin</strong>-like paramaters, my case use only needed the op on a <strong>binary!</strong> value without the round trip.</p>
            <p><small>7 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/using-shift-on-binary/1476">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/using-shift-on-binary/1476</link>
          <pubDate>Tue, 26 Jan 2021 14:34:44 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1476</guid>
          <source url="https://rebol.metaeducation.com/t/using-shift-on-binary/1476.rss">Using Shift on BINARY!</source>
        </item>
        <item>
          <title>Soliciting Ideas for a BITWISE Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>With the <a href="https://rebol.metaeducation.com/t/binary-dialected-encoding-decoding-instead-of-to-conversions/1270">creation of ENBIN and DEBIN</a>, I think I showed off how a Rebol approach of dialecting could truly make something easy that's painful in other languages (and a historical pain point in Rebol too, with how people had to wrestle with TO INTEGER! and TO BINARY! conversions).</p>
<p>Under the buzzword <strong>BITWISE</strong> I've had the notion that a little dialect specifically tailored to bit shifting and masking could be created.  While I don't have a clue what it would look like, one thought I had was that instead of trying to come up with a name for AND and OR that's bitwise like AND+ or OR+ (or BITAND and BITOR), instead you'd be able to say something like <strong>bitwise [x and y]</strong>.</p>
<p>But the idea is that <strong>bitwise</strong> would be so capable, that instead of grumbling about how it sucked that you had to type it in, that you would fall into a universe of fast binary functionality that would more likely than not be where you wanted to be if you were in the mode of writing bitwise math.</p>
<p>I know more about what I'd want this dialect to do (and do efficiently) than I know about what it would look like.  Here's a list of <a href="http://aggregate.org/MAGIC/">"Magic" C snippets</a> for doing binary operations.  What bag of tricks might bitwise bring?</p>
<p>Should be able to do:</p>
<ul>
<li>Shifting and Rotation (shift with carry of high bits around to low or vice-versa)</li>
<li>AND/OR/XOR/NAND/NOR/XNOR</li>
<li>Clipping (constrain to 31 bits came up today)</li>
<li>Most/least significant 1 bit or 0 bit (Nth most/least?)</li>
</ul>
<p>I don't know that I'd rule out being able to do PARSE-like things at a bit level, maybe being able to scan bits from low to high and flip or operate on them as you went...injecting plain code to run as you go (also as PARSE allows?)</p>
<p>But it needs to be easy to escape out of.  I don't know if that means that BLOCK! is used for grouping and then parentheses become plain code, or what.</p>
<p>I personally think <strong>bitwise [x and y]</strong> looks favorable compared with <strong>x and+ y</strong>, so I'll just start the conversation there.  Anyone want to offer up some scenarios of how it might throw in power tools for the bit fiddler?</p>
<p>Might it always evaluate to a result which you can say how many bits you want, e.g.</p>
<pre><code>bitwise/bits [x and y] 31
</code></pre>
<p>Make it a skippable parameter as well, to give you the alternative:</p>
<pre><code>bitwise 31 [x and y]
</code></pre>
<p>Stuff like that.  It likely would need to incorporate some of ENBIN and DEBIN's smarts to be useful.</p>
<p>What kind of controls might it have for overflow?  Could it be done in a way that lets you do custom overflow handling if it returns NULL, but then has another value it sets which is the overflow out of the range you specified?</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/soliciting-ideas-for-a-bitwise-dialect/1302">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/soliciting-ideas-for-a-bitwise-dialect/1302</link>
          <pubDate>Wed, 15 Jul 2020 22:59:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1302</guid>
          <source url="https://rebol.metaeducation.com/t/soliciting-ideas-for-a-bitwise-dialect/1302.rss">Soliciting Ideas for a BITWISE Dialect</source>
        </item>
        <item>
          <title>Planning Ahead for BigNum INTEGER!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>I've long been an advocate for the idea that INTEGER! should be an <a href="https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic">arbitrary precision implementation</a>.  It doesn't make sense to me why a high-level language which is targeting future applications would constrain itself to 32-bit, or (in R3-Alpha's case) 64-bit INTEGER! values.  I've been trying--for instance--to <a href="https://trello.com/c/I6Y3NWlR">"futureproof" conversions of INTEGER! to BINARY!</a>, in anticipation of the change.</p>
<p>Now, due to Red's desire to be involved in cryptocurrency, they are adding BIGNUM! as a distinct datatype from INTEGER!.  Which is not the way I would do it.  INTEGER! already has to detect math overflows in order to give an error when your math is out of range.  <strong>I would prefer INTEGER! to start out using CPU register-size integers, and instead of erroring on overflows, promote the representation into a bignum...on demand.</strong></p>
<h3><a name="p-2160-the-identity-problem-1" class="anchor" href="https://rebol.metaeducation.com#p-2160-the-identity-problem-1"></a>The Identity Problem</h3>
<p>I suggested that INTEGER! could not hurt for performance for most applications, if it was merely promoted to bignum internal representations on overflow.  But there's an issue of identity in bignum operations.</p>
<p>Today this is the behavior for integers:</p>
<pre><code> foo: func [x [integer!]] [add x 1]
 smallnum: 0
 foo smallnum
 print smallnum  ; prints 0, unaffected
</code></pre>
<p>So each integer cell has its own identity (as an ANY-IMMEDIATE!, <a href="https://en.wikipedia.org/wiki/Value_(computer_science)#R-values_and_addresses">"immediate value"</a>).</p>
<p><strong>ADD</strong> or <strong>+</strong> do not go in and fiddle the bits in a way that is seen by "other instances of that integer", the way that <strong>APPEND</strong> reaches into the "data node" behind a series and affects all instances.</p>
<p>But with BigNums, making a new identity on each addition can be costly:</p>
<pre><code>bignum: 123456789012345678901234567890
loop 1000000 [
    bignum: bignum + 1
]
</code></pre>
<p>How many bignum structures should that be "malloc()" ing?  Naively done, that would be a million or more allocations, because each addition in Rebol is expected to produce a new-and-disconnected integer.</p>
<p>Getting around this by making ADD mutate BigNum--when it doesn't mutate other things--seems inconsistent.  It's not  a new problem, there were some issues with ADD of VECTOR!.  In Red too, see <a href="https://github.com/red/red/issues/2216">"Adding a number to a vector changes the vector itself"</a></p>
<h3><a name="p-2160-proposal-mutating-add-non-mutating-2" class="anchor" href="https://rebol.metaeducation.com#p-2160-proposal-mutating-add-non-mutating-2"></a>Proposal: Mutating ADD, non-mutating +</h3>
<p>The thought I had would be that INTEGER!s would not be immediate by their nature, but that literals would be LOCK'd by default.</p>
<pre><code> &gt;&gt; x: 10
 &gt;&gt; add x 20
 ** Error, locked integer

 &gt;&gt; x: make integer! 10
 &gt;&gt; add x 20
 &gt;&gt; print x
 30
</code></pre>
<p>Then, + would basically be using ADD with a COPY, and locking the result:</p>
<pre><code> +: infix func [a b] [
     lock add copy a b
 ]
</code></pre>
<p>For non-bignums, this could be optimized internally so that if the input was a register-size integer...and the output was a register-size integer...no identity node ever need be created.</p>
<p>So someone can still do an inefficient bignum loop with +, if they really wanted to.  But a savvy crypto-person would use ADD so they are modifying the existing bignum in place.</p>
<p>What this does is bolster Rebol's "mutability by default" story about operations like APPEND, bringing it further to ADD.  It addresses the issue with VECTOR!, by saying that <strong>+</strong> will create a new vector while <strong>add</strong> would mutate the existing one.  And it avoids introducing a new BIGNUM! datatype.</p>
<p>Like other changes, this can be skinned with Rebol2/R3-Alpha compatibility to make <strong>add 1 2</strong> work in old code that needs it to.</p>
<p><em>(Note: as a side-benefit, this could remove the need for 64-bit math emulation code on 32-bit platforms.  Currently, in an I-believe-to-be-misguided-standardization-effort, Rebol has tried to give those using the interpreter a baseline confidence that INTEGER! has 64-bit representation...even if that's not the native integer type.  All that code could go, replaced by bignum code that's needed anyway, if you have any cryptography.)</em></p>
            <p><small>22 posts - 4 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/planning-ahead-for-bignum-integer/623">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/planning-ahead-for-bignum-integer/623</link>
          <pubDate>Tue, 15 May 2018 16:01:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-623</guid>
          <source url="https://rebol.metaeducation.com/t/planning-ahead-for-bignum-integer/623.rss">Planning Ahead for BigNum INTEGER!</source>
        </item>
        <item>
          <title>Prefix APPROX Modifier... Would It Be Possible?</title>
          <dc:creator><![CDATA[rgchris]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="349">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/349/1">On another topic</a></div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; 1.0 like 1
== #[true]
</code></pre>
</blockquote>
</aside>
<p>Just a thought, could you modify the behaviour of <code>=</code> with a prefix, e.g. <strong><code>(approx 1 = 1.0)</code></strong> (could perhaps get messy).</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/prefix-approx-modifier-would-it-be-possible/2428">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/prefix-approx-modifier-would-it-be-possible/2428</link>
          <pubDate>Mon, 23 Oct 2017 18:07:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2428</guid>
          <source url="https://rebol.metaeducation.com/t/prefix-approx-modifier-would-it-be-possible/2428.rss">Prefix APPROX Modifier... Would It Be Possible?</source>
        </item>
  </channel>
</rss>

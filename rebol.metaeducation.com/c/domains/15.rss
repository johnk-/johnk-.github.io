<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Domains - AltRebol</title>
    <link>https://rebol.metaeducation.com/c/domains/15</link>
    <description>Topics in the &#39;Domains&#39; category Applications of Rebol in various specialized subject domains.</description>
    
      <lastBuildDate>Sat, 19 Jul 2025 07:23:13 +0000</lastBuildDate>
      <atom:link href="https://rebol.metaeducation.com/c/domains/15.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>The WORD! vs. TEXT! Representation Gap</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Something that seems to come up a lot is exemplified in this issue with Rebmake regarding optimization levels.</p>
<p>The issue is that C compilers have optimization switches (like <code>-O2</code> or <code>-Os</code>) which let you say how to optimize what you're building.  2 may indicate higher optimizations than 1 or 0.  "s" could mean optimize for size.</p>
<p>When you're translating something like this into a dialect, it's tempting to think of this as being either a WORD! or an INTEGER!, and not having to put it in ditto marks <em>(Note: I'm going to call <code>"</code> ditto marks from now on, to help distinguish them from the phenomenon of "quoting")</em>.</p>
<pre><code>some-file.c [
    optimize: 2
]
another-file.c [
    optimize: s
]
</code></pre>
<p>If your dialect happens to not be evaluating the slots, this gives you a clean representation.  In the particular case of Rebmake, this is often taken on the command line, and the command line processing will LOAD the thing you pass. So:</p>
<pre><code> r3 make.r optimize: s
</code></pre>
<p>That works.  And if you said <strong><code>optimize: 's</code></strong> that would cause problems, because the shell thinks that's a quote mark that needs to be paired.</p>
<p>But if you're not lucky enough to be in an evaluative context, you'd need a quote mark.</p>
<h2><a name="p-8545-but-what-if-optimization-gets-settings-like-o2s-1" class="anchor" href="https://rebol.metaeducation.com#p-8545-but-what-if-optimization-gets-settings-like-o2s-1"></a>But What If Optimization Gets Settings Like <code>-O2s</code> ?</h2>
<p>It might seem neat to translate the string into an INTEGER! or WORD!.  You could compare integers against each other (e.g. to find out that 1 is greater than or less than the optimization level)... if they were both integers.  It feels nice to turn things into words.</p>
<p>But if you do a mapping--and don't fully control the domain you're mapping from--this can throw you a curveball.  And when it does, you'll have to put it in a string.  Now you've got INTEGER! <code>[0 1 2]</code>, WORD! <code>[s z]</code>, or TEXT! <code>["2s" and other illegal things]</code></p>
<p>At which point you'd probably ask: <strong>"Since I don't really control this, should I have left it as a string?"</strong>  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>Should you have stayed in your lane, and let it be <code>["0" "1" "2" "s" "z"]</code> to start with?</p>
<h2><a name="p-8545-for-now-word-and-integer-works-but-2" class="anchor" href="https://rebol.metaeducation.com#p-8545-for-now-word-and-integer-works-but-2"></a>For Now, WORD! and INTEGER! Works, But...</h2>
<p>I hit a problem because there was inconsistency when some places used <strong><code>"s"</code></strong> and others uses <strong><code>s</code></strong>.</p>
<p>I'm canonizing to the WORD! just to keep making progress.  But this kind of issue feels like it comes up often.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/the-word-vs-text-representation-gap/2513">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/the-word-vs-text-representation-gap/2513</link>
          <pubDate>Sat, 19 Jul 2025 07:23:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2513</guid>
          <source url="https://rebol.metaeducation.com/t/the-word-vs-text-representation-gap/2513.rss">The WORD! vs. TEXT! Representation Gap</source>
        </item>
        <item>
          <title>Rebol2&#39;s &quot;Hot Errors&quot; (Abandoned by R3-Alpha, Red)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>Rebol2 had a concept which had the inklings of <a href="https://rebol.metaeducation.com/t/panic-vs-return-fail-the-age-of-definitional-errors/1852">definitional errors</a>, in the sense that if you would RETURN an ERROR! value, it would escalate itself to an exception if not triaged with special functions at the callsite:</p>
<pre><code>rebol2&gt;&gt; foo: func [] [return make error! "Boom"]

rebol2&gt;&gt; foo
** User Error: Boom
** Near: return make error! "Boom"

rebol2&gt;&gt; type? foo
== error!

rebol2&gt;&gt; (foo) print "No triage, this won't print"
** User Error: Boom
** Near: return make error! "Boom"

rebol2&gt;&gt; (disarm foo) print "Triaged, so this will print"
Triaged, so this will print

rebol2&gt;&gt; disarm foo

rebol2&gt;&gt; probe disarm foo
make object! [
    code: 800
    type: 'user
    id: 'message
    arg1: "Boom"
    arg2: none
    arg3: none
    near: [return make error! "Boom"]
    where: none
]
</code></pre>
<h2><a name="p-8502-why-was-this-abandoned-1" class="anchor" href="https://rebol.metaeducation.com#p-8502-why-was-this-abandoned-1"></a>Why Was This Abandoned?</h2>
<p><strong><a href="http://www.rebol.net/r3blogs/0007.html">According to Carl</a>:</strong></p>
<blockquote>
<p><em>"Prior versions of REBOL used 'hot' errors. That is, you had to treat error values in a special way or they would automatically trigger error processing. This behavior was originally implemented to keep errors from propagating too far from their origins (the principle was to preserve as much as possible the locality of the error)."</em></p>
<p><em>"These hot errors turned out to be overkill, and the benefit of error locality was offset by the difficulty of handling error values in general. (See the articles of <a href="https://web.archive.org/web/20060101045815/http://www.fm.vslib.cz/~ladislav/rebol/">Ladislav Mecir</a> who wrote excellent notes on this subject). It could be quite tricky at times."</em></p>
</blockquote>
<p>I'm not sure what articles he's referring to from Ladislav.  The link he provides has an error section where Ladislav points out some bugs and says <em>"any Rebol value should be obtainable as a result of an expression, a result of a parenthesized expression, a result of a block evaluation and a result of a function evaluation"</em>, which seems pretty uncontroversial.</p>
<h2><a name="p-8502-so-what-was-the-problem-2" class="anchor" href="https://rebol.metaeducation.com#p-8502-so-what-was-the-problem-2"></a>So... What Was The Problem?</h2>
<p>One big ergonomic problem is that TRY intercepted errors, but didn't disarm them.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<pre><code>rebol2&gt;&gt; foo: func [] [return make error! "Boom"]

rebol2&gt;&gt; caught: try [foo]
** User Error: Boom
** Near: return make error! "Boom"

rebol2&gt;&gt; caught/id
** User Error: Boom
** Near: return make error! "Boom"
</code></pre>
<p>That's incredibly inconvenient.  So why didn't TRY do a DISARM?</p>
<p>The problem is "hotness" was a property of all values of ERROR! type, and when you disarm them they'd become OBJECT!.  If TRY were to DISARM the error it wouldn't be an ERROR! anymore, so you couldn't test to see if your expression had produced an error or not.</p>
<p>You get this because you're trying to pack too much information into one return result.  It could have been addressed by having you write your TRY as arity-2 with an EXCEPT.</p>
<pre><code>rebol2&gt;&gt; try-except: func [code handler /local e] [
             return either error? e: try code [handler disarm :e] [:e]
         ]

rebol2&gt;&gt; try-except [foo] func [e] [probe e/arg1]
"Boom"

rebol2&gt;&gt; try-except [1 + 2] func [e] [probe e/arg1]
== 3
</code></pre>
<p>Ren-C gives you this with infix, and you can use an arrow function, so it's more pleasing:</p>
<pre><code>foo except e -&gt; [probe e.arg1]
</code></pre>
<h2><a name="p-8502-hot-errors-would-have-been-only-half-the-story-3" class="anchor" href="https://rebol.metaeducation.com#p-8502-hot-errors-would-have-been-only-half-the-story-3"></a>Hot Errors Would Have Been Only Half The Story</h2>
<p>It seems Rebol2 was on the right track by having a state you could carry in a function's return result, that would promote to a divergent panic if not triaged at the callsite.</p>
<p>But for it to gel, you need to draw a sharp line between divergent panics and ERROR!, and not mix up their interception (in fact, <a href="https://rebol.metaeducation.com/t/discouraging-the-interception-of-abrupt-failures/1871">you should practically never intercept divergent panics</a>).</p>
<p>Rebol2's TRY was a one-size-fits-none construct, considering any typo or deeply nested errors to be on par with one that was "RETURN'd" directly from the function you were calling:</p>
<pre><code>rebol2&gt;&gt; probe disarm try [read %nonexistent.txt]
make object! [
    code: 500
    type: 'access
    id: 'cannot-open
    arg1: "/C/Projects/rebol2/nonexistent.txt"
    arg2: none
    arg3: none
    near: [read %nonexistent.txt]
    where: 'halt-view
]

rebol2&gt;&gt; probe disarm try [rread %nonexistent.txt]
make object! [
    code: 300
    type: 'script
    id: 'no-value
    arg1: 'rread
    arg2: none
    arg3: none
    near: [rread %nonexistent.txt]
    where: 'halt-view
]
</code></pre>
<p>This makes it nigh impossible to act upon the information reliably.</p>
<h2><a name="p-8502-the-wayward-drift-to-all-errors-are-exceptions-4" class="anchor" href="https://rebol.metaeducation.com#p-8502-the-wayward-drift-to-all-errors-are-exceptions-4"></a>The Wayward Drift To All-Errors-Are-Exceptions...</h2>
<p>Despite Rebol2 being on the cusp of meaningful error handling, R3-Alpha went the way of the exception fallacy.  Jumping across arbitrary levels of stack running arbitrary code in order to handle an error in stack levels above is something that the software industry has pretty much debunked.</p>
<p>For the most part, exceptions need to be reserved for things that should basically <em>never</em> happen.  The rare systems that do handle them should be when it's required for mitigating damage or corruption that might occur if cleanup code doesn't get run.  Exceptions are not what you want to use to deliver garden variety errors...you need direct contracts between caller and callee.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/rebol2s-hot-errors-abandoned-by-r3-alpha-red/2505">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/rebol2s-hot-errors-abandoned-by-r3-alpha-red/2505</link>
          <pubDate>Thu, 10 Jul 2025 09:29:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2505</guid>
          <source url="https://rebol.metaeducation.com/t/rebol2s-hot-errors-abandoned-by-r3-alpha-red/2505.rss">Rebol2&#39;s &quot;Hot Errors&quot; (Abandoned by R3-Alpha, Red)</source>
        </item>
        <item>
          <title>Rebmu: The Graphical Game</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Rebmu</category>
          <description><![CDATA[
            <p><strong>I've been wanting to use Ren-C as the engine behind a graphical game.</strong></p>
<p>The idea would be that the things you're placing on the screen represent items in the evaluator, and it would be simplified and iconographic.</p>
<p>What I'm visualizing usually is something where array Elements are little circular Cells, and there are concentric shells around the Elements that represent layers of quoting.  Then, quasiforms and antiforms would be some alternate styling of these shells.  FENCE! and ELEMENT! and BLOCK! would be stylized but keep their delimiters... same with TUPLE! and CHAIN! and PATH!.</p>
<p>I don't know if there'd be any TEXT! strings... for simplification, everything would probably be a list.  So instead of <code>"ABC"</code> in the game you'd always be working with something like <code>[A B C]</code> or <code>[@A @B @C]</code>.  Though RUNE! may be needed for things like <code>_</code> and <code>#</code>.  I haven't gotten that far.</p>
<h2><a name="p-8474-visually-i-am-envisioning-something-like-opus-magnum-1" class="anchor" href="https://rebol.metaeducation.com#p-8474-visually-i-am-envisioning-something-like-opus-magnum-1"></a>Visually I Am Envisioning Something Like Opus Magnum</h2>
<p>The gameplay would be different, because I don't envision a separate "space" for where the "Code" is from the "Data".  But the vibe of the workspace I'm thinking would be inspired like it:</p>
<p><a href="https://www.youtube.com/watch?v=Uj689znjxpg">Opus Magnum, by Zachtronics</a></p>

<h2><a name="p-8474-experience-would-be-more-like-baba-is-you-2" class="anchor" href="https://rebol.metaeducation.com#p-8474-experience-would-be-more-like-baba-is-you-2"></a>Experience Would Be More Like Baba Is You</h2>
<p>In the game, you'd be putting your words and data all in the same space, so it would be more like Baba is You.</p>
<p><a href="https://www.youtube.com/watch?v=z3_yA4HTJfs">Baba Is You - Release Date Trailer - Nintendo Switch</a></p>

<h2><a name="p-8474-another-inspiration-would-be-patricks-parabox-3" class="anchor" href="https://rebol.metaeducation.com#p-8474-another-inspiration-would-be-patricks-parabox-3"></a>Another Inspiration Would Be Patrick's ParaBox</h2>
<p>This is another instance of something which has the feeling I'm looking for.  But the Patrick's Parabox guy had to come up with all the engine logic to resolve paradoxes and make sense of the behavior (as did the Baba is You guy).  What I'm talking about is just using the evaluator as it is... but grafting it into a GUI:</p>
<p><a href="https://www.youtube.com/watch?v=kDy6PMIz0Pg">Patrick's Parabox - Launch Trailer | PS5 Games</a></p>

<h2><a name="p-8474-i-really-need-a-demo-of-what-im-thinking-4" class="anchor" href="https://rebol.metaeducation.com#p-8474-i-really-need-a-demo-of-what-im-thinking-4"></a>I Really Need A Demo Of What I'm Thinking</h2>
<p>Part of me feels like there has to be an indie game dev out there who would love to be the one who gets to give antiforms and quasiforms their big break to a gaming audience.</p>
<p>So even if I made something with bad graphics... if I could show a few tutorial levels, and then maybe a couple of "good" levels (exposing people to PARSE mechanics and needing to use them to solve something)... I might be able to turn the whole UI and game design part over to someone else.</p>
<p>This is part of why I think getting people involved in the gaming spirit of Rebmu would be a win... to show the fun of it, and then try and figure out how to put that fun into a non-textual format</p>
<h2><a name="p-8474-although-some-text-programming-games-do-succeed-5" class="anchor" href="https://rebol.metaeducation.com#p-8474-although-some-text-programming-games-do-succeed-5"></a>Although... Some Text-Programming Games Do Succeed...</h2>
<p>TIS-100 from Zachtronics had an unusual amount of success and positive reviews.  Make of that what you will:</p>
<aside class="onebox allowlistedgeneric" data-onebox-src="https://store.steampowered.com/app/370360/TIS100/">
  <header class="source">
      <img src="https://store.steampowered.com/favicon.ico" class="site-icon" width="256" height="256">

      <a href="https://store.steampowered.com/app/370360/TIS100/" target="_blank" rel="noopener">store.steampowered.com</a>
  </header>

  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:616/353;"><img src="https://shared.fastly.steamstatic.com/store_item_assets/steam/apps/370360/capsule_616x353.jpg?t=1667071597" class="thumbnail" width="616" height="353"></div>

<h3><a href="https://store.steampowered.com/app/370360/TIS100/" target="_blank" rel="noopener">TIS-100 on Steam</a></h3>

  <p>TIS-100 is an open-ended programming game by Zachtronics, the creators of SpaceChem and Infinifactory, in which you rewrite corrupted code segments to repair the TIS-100 and unlock its secrets. Itâ€™s the assembly language programming game you never...</p>


  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<h2><a name="p-8474-the-fact-that-the-engine-runs-anywhere-is-good-6" class="anchor" href="https://rebol.metaeducation.com#p-8474-the-fact-that-the-engine-runs-anywhere-is-good-6"></a>The Fact That The Engine Runs Anywhere Is Good</h2>
<p>Running in the browser means people who work in HTML5/etc. could call into it, and I've got the JavaScript bridge already made.</p>
<p>But it could be integrated into basically any game dev framework anyone uses, as it builds as ANSI C99.</p>
<p>I should brush up the C++ interface, that made it a little more convenient to use.  With AI's help, I bet I could get a C# interface off the ground as well (I delved a little into that).</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/rebmu-the-graphical-game/2499">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/rebmu-the-graphical-game/2499</link>
          <pubDate>Thu, 26 Jun 2025 05:09:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2499</guid>
          <source url="https://rebol.metaeducation.com/t/rebmu-the-graphical-game/2499.rss">Rebmu: The Graphical Game</source>
        </item>
        <item>
          <title>&quot;Insanity Level&quot; for The Mu-Library In Rebmu</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Rebmu</category>
          <description><![CDATA[
            <p>Rebmu has a fairly strict design principle, which is that a typical library function can only be overridden with a version that is a <em>superset</em> of its functionality.  It can have special handling for things that would cause panics, but should give the same output for any valid input.</p>
<p>As an example: IF should not be redefined to something that would consider 0 to be conditionally false.  If you write regular old lowercase code, you always want:</p>
<pre><code>rebmu&gt;&gt; if 0 [print "truthy"]
truthy
</code></pre>
<p>However... IF typically doesn't allow VOIDs, TRASH!, ERROR! as conditions.  We could treat them all as falsey if we liked, or truthy.  Or do various weird things (IF of a VOID could make the whole IF expression void...)</p>
<p>And at the moment, WORD!s are illegal in the branch slot (the branch is not evaluated by default, it is taken literally for <strong><a href="https://rebol.metaeducation.com/t/soft-quoted-branching-light-elegant-fast/1020">"soft literal branching"</a></strong>).  But if WORD! wasn't an error, what could it mean?</p>
<p>I like the idea of it being able to build a specialized action out of the branch:</p>
<pre><code>rebmu&gt;&gt; if 0 print "truthy"
== truthy

rebmu&gt;&gt; if null print "truthy"
== \~null~\  ; antiform
</code></pre>
<p>So that would be like you had written:</p>
<pre><code>rebmu&gt;&gt; if 0 (specialize print/ ["truthy"])
== truthy

rebmu&gt;&gt; if null (specialize print/ ["truthy"])
== \~null~\  ; antiform
</code></pre>
<p>It could save the <code>[</code> and <code>]</code> off of a lot of calls, I think it would be particularly interesting with things like function:</p>
<pre><code>z: function [x y] any [equal? 10 add x y, equal? 20 subtract x y]
</code></pre>
<p>Which would wind up being written  like:</p>
<pre><code>Zfn[xY]ay[e?10adXyE?20sbXy]
</code></pre>
<p>Of course this is just the tip of the iceberg.</p>
<h2><a name="p-8456-lots-i-could-talk-about-but-wanted-to-mention-something-1" class="anchor" href="https://rebol.metaeducation.com#p-8456-lots-i-could-talk-about-but-wanted-to-mention-something-1"></a>Lots I Could Talk About, But Wanted To Mention Something</h2>
<p>In thinking about the idea of a version of IF that didn't raise ERROR!s but treated them as false, I thought about how maddening that would be to debug.</p>
<p>"True Rebmu" should probably be as liberal as it can about finding meaning for inputs, without concern for debuggability.  But you shouldn't dial the settings for insane unless you're actually using them.</p>
<p>So I think in the Rebmu header, there should be some configuration you can do.</p>
<pre><code>Rebmu [
    file: %99-bottles.rebmu
    title: "99 Bottles of Beer on the Wall, Code Golfed"
    configure: [
        if: [:errors-are-falsey :void-if-void-condition]
        ...
    ]
]
</code></pre>
<p>None of the options would be contradictory...they're all just creeping you along the path to ultimate "insanity mode" where it's maximally permissive (the zero-header run state, to be the most minimal characters for code golf).  Headers are just documentation of which facilities you're actually using on purpose in the program, to help debugging by not enabling behaviors you won't use.</p>
<p>For things like ERROR! are falsey in conditionals, it's something you should be able to turn on for all conditionals or selectively for specific ones.</p>
<p>This resembles the kinds of problems of configuration for "real" tasks, so will have to see how things like <a href="https://rebol.metaeducation.com/t/evaluator-hooking-rebindablesyntax/2443">RebindableSyntax</a> can help.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/insanity-level-for-the-mu-library-in-rebmu/2497">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/insanity-level-for-the-mu-library-in-rebmu/2497</link>
          <pubDate>Tue, 24 Jun 2025 06:41:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2497</guid>
          <source url="https://rebol.metaeducation.com/t/insanity-level-for-the-mu-library-in-rebmu/2497.rss">&quot;Insanity Level&quot; for The Mu-Library In Rebmu</source>
        </item>
        <item>
          <title>Literal Arguments As Proxies For Dialects</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>I was looking at this detail in FOR-EACH and realized it was a kind of general question... <em>in parameter slots that take dialects, how often should we take that argument literally in order to make it easier to have it act as a dialect?</em></p>
<hr>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="2462">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/reacting-to-tie-to-automate-binding/2462/1">Reacting to TIE ($) To Automate Binding</a></div>
<blockquote>
<p>So in this FOR-EACH example, we can already imagine a convenience... of being able to annotate variables to say you want to propagate the binding (or "tie" the variables to the binding of the block). ...</p>
<p><code>for-each [$sw i] block</code></p>
</blockquote>
</aside>
<p>We can kind of clearly see here that the decorators belong on the variables "doing the picking", not the material being iterated or picked from...</p>
<p><strong>This makes me think I may have erred in switching FOR-EACH variables to be not-taken literally.</strong></p>
<p>I switched:</p>
<pre><code>for-each x [...]
</code></pre>
<p>To:</p>
<pre><code>for-each 'x [...]
</code></pre>
<p>I thought it was justified by the fact that <code>@x</code> would bind and keep the binding, and the decorator.  That allowed <code>for-each @x [...]</code> to do the right thing, even with a non-literal slot for the <code>@x</code>.</p>
<p>But with <code>$x</code> becoming a "thing", if you let that evaluate it loses the $.  So FOR-EACH wouldn't know you wanted the picked thing to be bound.  You'd have to remember to write:</p>
<pre><code>for-each '$x [...]
</code></pre>
<p>But that pattern simply wouldn't work with:</p>
<pre><code>for-each '@x [...]
</code></pre>
<p>You can't "reuse the binding" of something you quoted that has no binding.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8432-switch-it-back-1" class="anchor" href="https://rebol.metaeducation.com#p-8432-switch-it-back-1"></a>Switch It Back?</h2>
<p>If it changes back, you get uniform behavior:</p>
<pre><code>for-each whatever [a b c]

for-each [whatever] [a b c]
</code></pre>
<p>That means you can just write:</p>
<pre><code>for-each $x [...] [...]

for-each @x [...] [...]
</code></pre>
<p>And it will work.</p>
<p><strong>I can certainly see how it's nicer in the long run to use the literal parameter.  But it throws you a bit of a curve-ball educationally.</strong></p>
<p>Consider also <code>'x</code> being able to have its own dialected meaning in a block or not.</p>
<pre><code>for-each 'x [...]

for-each ['x y] [...]
</code></pre>
<p>That's more powerful.  But it's also in some pretty confusing territory for beginners, having to deal with that slot being literal.</p>
<p><strong>I'm torn about it, but this <code>for-each $x [...]</code> case does really have me thinking that it should be changed back.</strong>  Seeing that you'd have to write <code>for-each '$x [...]</code> but then <code>for-each '@x [...]</code> <em>wouldn't</em> work makes me think it's just healthier for that parameter slot to be dialected, and you use a GROUP! if you need to escape it... which is <em>very rare</em>.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/literal-arguments-as-proxies-for-dialects/2489">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/literal-arguments-as-proxies-for-dialects/2489</link>
          <pubDate>Mon, 16 Jun 2025 20:20:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2489</guid>
          <source url="https://rebol.metaeducation.com/t/literal-arguments-as-proxies-for-dialects/2489.rss">Literal Arguments As Proxies For Dialects</source>
        </item>
        <item>
          <title>Dialecting With Sigils (eval @f) - Good or Bad?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>There are two forms of EVALUATE with FRAME!... one of which consumes the memory of the frame so it can't be used again, and another that evaluates with a copy of the memory...leaving the original and its fields available after the eval.</p>
<pre><code>&gt;&gt; f: make frame! negate/
== &amp;[frame! [
    number: ~
]]

&gt;&gt; f.^number: 1020  ; as of today, you need lifts when using raw frames
== 1020

&gt;&gt; f
== &amp;[frame! [
    number: ''1020  ; extra quote protects the single quoted value
]]

&gt;&gt; evaluate f
== -1020

&gt;&gt; f
== &amp;[frame! [
    number: ''1020
]]

&gt;&gt; eval-free f
== -1020

&gt;&gt; f
** Panic: FRAME! was freed, memory no longer avaliable
</code></pre>
<p>EVALUATE and EVAL-FREE are two separate functions at the moment.  The reasoning is that if you are performance-conscious (hence the kind of person who'd want EVAL-FREE) you want to be able to use an intrinsic, and intrinsic (FRAME!-less) dispatch happens when you have a single argument and no refinements.  Hence it shouldn't be EVALUATE:FREE or similar.</p>
<p>This drew me to a weird idea: what if you could say <strong><code>eval @f</code></strong> and that meant EVAL-FREE ?</p>
<pre><code>&gt;&gt; eval @f
== -1020

&gt;&gt; f
** Panic: FRAME! was freed, memory no longer avaliable
</code></pre>
<p>That's just one argument.  It takes advantage of the unusual property that pinned values have of just evaluating to themself, so the decoration is visible to the function being called...kind of like if it were inside a block.</p>
<p><em>Basically it's a really, really small dialect.</em></p>
<h2><a name="p-8372-is-this-a-good-or-bad-idea-1" class="anchor" href="https://rebol.metaeducation.com#p-8372-is-this-a-good-or-bad-idea-1"></a>Is This A Good Or Bad Idea?</h2>
<p>I can't tell.  It's kind of slick, but also kind of random... nowhere else does <code>@</code> mean "destructively utilize memory".</p>
<p>It pushes the responsibility of fetching the variable onto EVAL, but that's the same as any dialect which would take variables in a block and interpret them and need to look them up.</p>
<p>I'm tempted to say that maybe this is not a feature of EVALUATE itself, but just a quirk of the shorthand EVAL.</p>
<p>Anyway, food for thought.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/dialecting-with-sigils-eval-f-good-or-bad/2474">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/dialecting-with-sigils-eval-f-good-or-bad/2474</link>
          <pubDate>Thu, 05 Jun 2025 19:40:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2474</guid>
          <source url="https://rebol.metaeducation.com/t/dialecting-with-sigils-eval-f-good-or-bad/2474.rss">Dialecting With Sigils (eval @f) - Good or Bad?</source>
        </item>
        <item>
          <title>Should Antiform Rendering Get Weirder?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Console</category>
          <description><![CDATA[
            <p>I've wondered this before, but I will wonder it again:</p>
<p><strong>Should Antiforms Render in the Monochrome Text Console in a Way That Makes Them More Obviously Distinct From Quasiforms, Besides Just The Comment?</strong></p>
<p>Today:</p>
<pre><code>&gt;&gt; spread [a b]
== ~(a b)~  ; anti

&gt;&gt; spread [a b]
== ~(a b)~  ; antiform (splice!)   &lt;-- more verbose console setting
</code></pre>
<p>In the absence of color or other cues, should there could be "even worse" notations to help emphasize "that's not representable".</p>
<p>Backslashes can't load, so...</p>
<pre><code>&gt;&gt; ~null~
== \~null~\  ; antiform (keyword!)

&gt;&gt; spread [a b]
== \~(a b)~\  ; antiform (splice!)
</code></pre>
<h2><a name="p-8335-it-needs-the-tildes-still-1" class="anchor" href="https://rebol.metaeducation.com#p-8335-it-needs-the-tildes-still-1"></a>It Needs The Tildes, Still...</h2>
<p>It needs to keep the tildes, because if it didn't, then <code>~</code> antiforms would vanish:</p>
<pre><code>&gt;&gt; ~
== \~\  ; antiform (trash!) "tripwire"  &lt;-- just `\\` would be bad
</code></pre>
<p><em>(At an implementation level of the <code>QUOTE_BYTE</code>, it is the case that if you had to ask if antiforms were either quasi or not... they are quasi.  e.g. they don't have the NONQUASI_BIT set.)</em></p>
<h2><a name="p-8335-potential-for-better-guidance-in-errors-2" class="anchor" href="https://rebol.metaeducation.com#p-8335-potential-for-better-guidance-in-errors-2"></a>Potential For Better Guidance In Errors</h2>
<p>I really think that in the earliest introductions of antiforms, it helps if they're not too easily conflated with quasiforms</p>
<p>If they type <code>~null~</code> thinking it's an antiform, and then see <code>~null~  ; antiform</code>  They might think antiform is just a label, and they got what they typed "as is" vs a totally distinct evaluation product.</p>
<p>With the uglier notation, if someone happened to think <em>"I'm making an antiform, like I saw on the forum..."</em></p>
<pre><code>&gt;&gt; \~(a b)~\
** Error: Antiforms have no true representation, and can't be LOAD-ed
** For more information, see: https://...
</code></pre>
<p>Antiforms are (apparently) a tough concept for some people to grasp, and I think little things like this can help make it easier.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-antiform-rendering-get-weirder/2467">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-antiform-rendering-get-weirder/2467</link>
          <pubDate>Wed, 21 May 2025 12:36:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2467</guid>
          <source url="https://rebol.metaeducation.com/t/should-antiform-rendering-get-weirder/2467.rss">Should Antiform Rendering Get Weirder?</source>
        </item>
        <item>
          <title>How should C variadics (like printf) work in the FFI?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>FFI</category>
          <description><![CDATA[
            <p>The Atronix <code>va_list</code> interface took a block.  It required a type to be specified for each argument--achieving what you would get if you used a C cast on each variadic argument.</p>
<p>You had to REDUCE it, also...which I don't think you should have to do:</p>
<pre><code>printf reduce ["%d, %f" 10 + 20 [int32] 12.34 [float]]
</code></pre>
<p>It may be useful to use defaulting like C's where integer types default to <code>int</code> and floating point types default to <code>double</code>:</p>
<pre><code>printf ["%d, %f" (10 + 20) 12.34]
</code></pre>
<p>If you do want to specify types, I'm leaning towards liking the FENCE! for lightweight construction, so maybe more like:</p>
<pre><code>printf ["%d, %f" {int32 10 + 20} 12.34]
printf ["%d, %f" {int32 10 + 20} {float 12.34}]
</code></pre>
<p>Back in the day I suggested putting it inside a group instead of passing a block...so that notationally it wouldn't put space between the printf and the arguments:</p>
<pre><code>(printf "%d, %f" (10 + 20) 12.34)
</code></pre>
<p>Though that has the bad property that if you forget it's a variadic, it will consume all the parameters of all ensuing calls.</p>
<p>However, it has the good property that "ordinary" variadics work with APPLY, including its <code>//</code> operator form:</p>
<pre><code>apply printf/ ["%d, %f" {int32 10 + 20} 12.34]

printf // ["%d, %f" {int32 10 + 20} 12.34]
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/how-should-c-variadics-like-printf-work-in-the-ffi/2458">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/how-should-c-variadics-like-printf-work-in-the-ffi/2458</link>
          <pubDate>Sun, 18 May 2025 16:38:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2458</guid>
          <source url="https://rebol.metaeducation.com/t/how-should-c-variadics-like-printf-work-in-the-ffi/2458.rss">How should C variadics (like printf) work in the FFI?</source>
        </item>
        <item>
          <title>What Is (5 / 2) ... And Other Conundrums</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>In Rebol2, R3-Alpha, and Red... division produces a DECIMAL!:</p>
<pre><code>red&gt;&gt; 5 / 2
== 2.5
</code></pre>
<p>I've never been crazy about the too-easy production of of DECIMAL!s.</p>
<h2><a name="p-8302-red-added-for-integer-divisionhttpsgithubcomredredissues2433-1" class="anchor" href="https://rebol.metaeducation.com#p-8302-red-added-for-integer-divisionhttpsgithubcomredredissues2433-1"></a><a href="https://github.com/red/red/issues/2433">Red Added <code>//</code> for INTEGER!-Division</a></h2>
<pre><code>&gt;&gt; 5 // 2
== 1
</code></pre>
<p>That thread is very long and GitHub collapses it for some reason, be sure to click the "LOAD MORE" to see the whole thing.  (Note in particular <strong><a href="https://gitlab.com/-/snippets/1901617">@hiiamboris's modulo tests and graphs</a></strong>.)</p>
<p>Note they might remove it.  It's a long thread and <a href="https://github.com/red/red/issues/2433#issuecomment-1126994152">hard to know what Nenad's conclusions are when he doesn't weigh in</a>.  But he did drop it from a milestone in 2022.</p>
<p>The big carry-away here is that this is a very nuanced topic that is tough to solve simply.  Boris asks:</p>
<blockquote>
<p>"Are we defining <code>//</code> as a divide operation <em>that always produces an integer</em> (float // float = int; int // float and float // int too) or a divide operation that does not promote the operands when they are both integers (only int // int)? (what will make more sense?)"</p>
</blockquote>
<p>Then there's other datatypes, VECTOR! etc...</p>
<h2><a name="p-8302-my-leaning-is-almost-always-less-implicit-behavior-2" class="anchor" href="https://rebol.metaeducation.com#p-8302-my-leaning-is-almost-always-less-implicit-behavior-2"></a>My Leaning Is Almost Always <em>Less Implicit Behavior</em></h2>
<p>...and because I like <strong><code>//</code></strong> very much for APPLY, I'm happy to use DIV instead for infix integer division with no remainder.</p>
<pre><code>&gt;&gt; 5 / 2
** Error: INTEGER! division not even, use DIV or cast to DECIMAL

&gt;&gt; 5 div 2
== 2

&gt;&gt; (to decimal! 5) / 2
== 2.5
</code></pre>
<p>With FENCE! running CONSTRUCT, I've proposed what construct does is that if the first expression resolves to a DATATYPE!...it interpret it as an intent to create that type.</p>
<p>This gives a lighter syntax:</p>
<pre><code>&gt;&gt; (to decimal! 5) / 2
== 2.5

&gt;&gt; {decimal! 5} / 2  ; saves 3 characters, but drops an entire word
== 2.5
</code></pre>
<p><strong>I'm Okay With INTEGER! / INTEGER! Giving An Error If The Result Isn't An INTEGER!</strong></p>
<p>A lot of times when I divide things that are integers I <em>know</em> they are evenly divisible.</p>
<p>If I don't know they are, then a decimal dropping out rarely "just works" without some additional code or mitigation, unless I'm printing out some kind of percentage result and the usage stops at the user's eyes.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/what-is-5-2-and-other-conundrums/2456">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/what-is-5-2-and-other-conundrums/2456</link>
          <pubDate>Sat, 17 May 2025 07:18:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2456</guid>
          <source url="https://rebol.metaeducation.com/t/what-is-5-2-and-other-conundrums/2456.rss">What Is (5 / 2) ... And Other Conundrums</source>
        </item>
        <item>
          <title>COMMENT in PARSE takes BLOCK!/GROUP! quoted</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Something I did long ago to the regular COMMENT was made it so you could only comment out lists, e.g. you couldn't just comment out a WORD!.</p>
<p>If you could, this would happen:</p>
<pre><code>&gt;&gt; eval [comment print "hi"]
== "hi"
</code></pre>
<p>That's no good... so you can only use things that would evaluate as single elements.</p>
<pre><code>&gt;&gt; eval [comment print "hi"]
!! PANIC: `comment` does not take `word!` for its `ignored` argument
</code></pre>
<p>PARSE has a similar issue, though it <em>could</em> combinate a parser and just not call it:</p>
<pre><code>&gt;&gt; parse "aaa" [3 "a" comment across some "b"]
== "a"
</code></pre>
<p>But that's of questionable benefit.</p>
<p>In any case, forming a parser rule that's not going to be run is less efficient than just quoting material, which can be done on rules with illegal content:</p>
<pre><code>&gt;&gt; parse "a" [comment [across some "a" ~illegal~] "a"]
== "a"
</code></pre>
<p>So the COMMENT combinator takes its argument literally, and you can't COMMENT a WORD!...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/comment-in-parse-takes-block-group-quoted/2448">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/comment-in-parse-takes-block-group-quoted/2448</link>
          <pubDate>Sun, 11 May 2025 20:08:44 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2448</guid>
          <source url="https://rebol.metaeducation.com/t/comment-in-parse-takes-block-group-quoted/2448.rss">COMMENT in PARSE takes BLOCK!/GROUP! quoted</source>
        </item>
        <item>
          <title>Making position argument explicit in COMBINATOR</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Today's COMBINATOR implicitly gives you an argument called INPUT:</p>
<pre><code>tally: combinator [
    "Iterate a rule and count the number of times it matches"
    return: "Number of matches (can be 0)"
        [integer!]
    parser [action!]
][
    let count: 0
    cycle [
        [^ input]: parser input except [  ; INPUT not mentioned on interface
            remainder: input
            return count
        ]
        count: count + 1
    ]
]
</code></pre>
<p>You only have to specify the number of parsers (or non-combinated literal arguments) you take.</p>
<p>I observed an inconsistency, that the <strong><code>&lt;input&gt;</code></strong> combinator returns the input to the overall parse operation at its original position... not the current position.</p>
<p>Then I thought "hm, I don't know whether to change the argument to be called POSITION or POS.</p>
<h2><a name="p-8258-but-why-was-the-argument-implicit-to-begin-with-1" class="anchor" href="https://rebol.metaeducation.com#p-8258-but-why-was-the-argument-implicit-to-begin-with-1"></a>But Why Was The Argument Implicit To Begin With?</h2>
<p>Making it explicit is clearer, and lets you pick your own name for it:</p>
<pre><code>tally: combinator [
    "Iterate a rule and count the number of times it matches"
    return: "Number of matches (can be 0)"
        [integer!]
    pos [any-series?]  ; Maybe I like POS better than POSITION for arg 1
    parser [action!]
][
    let count: 0
    cycle [
        [^ pos]: parser pos except [
            remainder: pos
            return count
        ]
        count: count + 1
    ]
]
</code></pre>
<p>This also means that if your combinator is only applicable to specific series types (e.g. just lists, or just strings) then you can say that, and have type checking take care of it vs. having to put the check in the body of your combinator.</p>
<h2><a name="p-8258-should-remainder-be-explicit-too-2" class="anchor" href="https://rebol.metaeducation.com#p-8258-should-remainder-be-explicit-too-2"></a>Should REMAINDER Be Explicit Too?</h2>
<p>REMAINDER is an implicitly declared return value, that the combinator wrapping code will package up in a PACK! with whatever you RETURN as the main synthesized value.  <strong><a href="https://rebol.metaeducation.com/t/uparse-combinator-return-conventions-reviewed/2337">I've defended the choice to do it this way</a>.</strong></p>
<p>But for clarity, should combinators have some mention of REMAINDER in the interface?  Even something like an <code>&lt;assigns&gt;</code> TAG! in the spec?</p>
<pre><code>tally: combinator [
    "Iterate a rule and count the number of times it matches"
    return: "Number of matches (can be 0)"
        [integer!]
    pos [any-series?]
    parser [action!]
    &lt;assigns&gt; remainder
] ...
</code></pre>
<p>That could actually have some value, in that if you don't say it then you're implicitly saying your parser doesn't move the parse position... <em>and it could automatically assume the remainder is the input position for you.</em>  <img src="https://rebol.metaeducation.com/images/emoji/twitter/smiley.png?v=14" title=":smiley:" class="emoji" alt=":smiley:" loading="lazy" width="20" height="20">  Then there could be no binding for remander, so you'd get an error if you did try to assign it.</p>
<p>Good mojo.  I like it.</p>
<p>I don't think being able to rename remainder is that important, but it could be <strong><code>&lt;remainder&gt; rem</code></strong> or something like that, where you could.</p>
<p>But I think <strong><code>&lt;assigns&gt; remainder</code></strong> has more information in it.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/making-position-argument-explicit-in-combinator/2445">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/making-position-argument-explicit-in-combinator/2445</link>
          <pubDate>Sun, 11 May 2025 16:01:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2445</guid>
          <source url="https://rebol.metaeducation.com/t/making-position-argument-explicit-in-combinator/2445.rss">Making position argument explicit in COMBINATOR</source>
        </item>
        <item>
          <title>Quoted Blocks To Reinforce Eval-Built Dialects</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Rebmake uses TUPLE!s and PATH!s creatively when specifying lists of files to build:</p>
<pre><code>files: [
    foo.c
    bar.c [&lt;msc:/WD1337&gt; &lt;gcc:-Wno-bad-warning&gt;]  ; options for this file

    subdir/ -&gt; [
       baz.c [
          #no-c++
          ; You can put more compiler settings for this file here
       ]
       mumble.c
   ]

   frotz.c
]
</code></pre>
<p>I'm turning my attention toward making this even more powerful, and there's a lot of potential.</p>
<h2><a name="p-8223-but-sometimes-you-build-these-specs-with-code-1" class="anchor" href="https://rebol.metaeducation.com#p-8223-but-sometimes-you-build-these-specs-with-code-1"></a>But Sometimes, You Build These Specs With Code</h2>
<p>I was looking at this, and had a bit of a thought about how <code>spread</code> looks like it's in a "sea of intertness"</p>
<pre><code>depends: compose [
    (switch platform-config.os-base [
        'Windows [
            spread [
                stdio-windows.c
                readline-windows.c
            ]
        ]
    ] else [
        spread [
            stdio-posix.c
            readline-posix.c
        ]
    ])
]
</code></pre>
<p>You're looking at this list of files, that you're used to seeing dialected.  So you half expect it to be like:</p>
<pre><code>spread/ -&gt; [  ; would be like spread is a directory
   stdio-windows.c
   readline-windows.c
]

spread [  ; so this looks like a "bug"
   stdio-windows.c
   readline-windows.c
]
</code></pre>
<p>This gave me a thought, though.  <em>Since the block is in an evaluative context, why not give a hint to help remind readers that it is?</em></p>
<pre><code>depends: compose [
    (switch platform-config.os-base [
        'Windows [
            spread '[
                stdio-windows.c
                readline-windows.c
            ]
        ]
    ] else [
        spread '[
            stdio-posix.c
            readline-posix.c
        ]
    ])
]
</code></pre>
<p>It gives you a little hint to remind you that you're looking at something evaluative.  While you <em>could</em> use quotes as a signal in a dialect (to put a generic mark on something?) this wouldn't be too common, so I think this might be a good tool when composing dialect code to know that's what you're doing.</p>
<p>(Of course, for binding reasons, you often want to quote blocks anyway...and that's becoming more important with time!)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/quoted-blocks-to-reinforce-eval-built-dialects/2439">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/quoted-blocks-to-reinforce-eval-built-dialects/2439</link>
          <pubDate>Thu, 08 May 2025 11:58:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2439</guid>
          <source url="https://rebol.metaeducation.com/t/quoted-blocks-to-reinforce-eval-built-dialects/2439.rss">Quoted Blocks To Reinforce Eval-Built Dialects</source>
        </item>
        <item>
          <title>&quot;Surprising&quot; Ghosts: What Combinators Vanish?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p><a href="https://rebol.metaeducation.com/t/making-invisible-functions-e-g-comment-elide/2034">The vanishing intent of GHOST!</a> (antiform COMMA!) is now distinct from <a href="https://rebol.metaeducation.com/t/why-are-trash-and-void-distinct-in-ren-c/2416">the empty intent of VOID</a> (empty parameter pack, antiform BLOCK!).</p>
<pre><code>&gt;&gt; 1 + 2 ghost
== 3

&gt;&gt; 1 + 2 void
== ~[]~  ; anti
</code></pre>
<p>This has brought to the forefront the question of which combinators should support vanishing.</p>
<h2><a name="p-8211-right-now-if-end-matches-it-vanishes-1" class="anchor" href="https://rebol.metaeducation.com#p-8211-right-now-if-end-matches-it-vanishes-1"></a>Right Now, If <code>&lt;END&gt;</code> Matches, it Vanishes</h2>
<pre><code>&gt;&gt; parse [a b] [word! &lt;end&gt;]
** Error: PARSE mismatch

&gt;&gt; parse [a] [word! &lt;end&gt;]
== a
</code></pre>
<p>That's very useful.</p>
<p>Should TO and THRU--when parameterized with something that vanishes--also vanish?</p>
<pre><code>&gt;&gt; parse [a #b #c] [word! to &lt;end&gt;]
== a
</code></pre>
<p>Seems pretty useful <em>on the surface</em>.  But TO and THRU are intrinsically looping constructs...they iterate their rules.  This means you could wind up with something that sometimes vanishes, and sometimes does not:</p>
<pre><code>&gt;&gt; rule: [integer! | elide text!]

&gt;&gt; parse [a #b #c "hi"] [var: [word!, thru rule]]
== a  ; VAR got the product of WORD!

&gt;&gt; parse [a #b #c 1020] [var: [word!, thru rule]]
== 1020  ; VAR got the product of THRU RULE
</code></pre>
<p>That's a bit disorienting, how an elide managed to leak out.  It's like the structure of the parse code isn't doing what you expect.</p>
<p>This is why the main evaluator's loops and branching constructs are not willing to vaporize when they stand alone.  They're only willing to produce VOID.  This keeps the basic structure of the code from picking up results you don't expect, unless you call something that specifically is known to have vanishing intent (and you can ask to convert voids to ghosts explicitly if you want).</p>
<p>Even invoking a rule BLOCK! itself--if you think of rule invocation as like PARSE's version of calling a lambda--raises some questions about "surprising" ghosts:</p>
<pre><code>&gt;&gt; rule: [integer! | elide text!]

&gt;&gt; parse [a #b #c "hi"] [var: [word!, rule]]
== a  ; VAR got the product of WORD!

&gt;&gt; parse [a #b #c 1020] [var: [word!, rule]]
== 1020  ; VAR got the product of RULE
</code></pre>
<p>Unfortunately PARSE doesn't have the analogue of the GROUP! vs. BLOCK! distinction for code, where one can be transparent and the other "surprising".   <strong><code>[elide some [rule1 | rule2]]</code></strong> can be genuinely useful as a source grouping.</p>
<h2><a name="p-8211-on-that-note-should-lambda-be-willing-to-vanish-2" class="anchor" href="https://rebol.metaeducation.com#p-8211-on-that-note-should-lambda-be-willing-to-vanish-2"></a>On That Note, Should LAMBDA Be Willing To Vanish?</h2>
<p>At the moment, you get VOID and not GHOST from lambdas whose bodies vanish.</p>
<pre><code> &gt;&gt; test: lambda [] [comment "this is a test"]

 &gt;&gt; 1 + 2 test
 == ~[]~  ; anti (void)
</code></pre>
<p>It's hence impossible for a LAMBDA to produce a GHOST!... you have to use functions with a return value.  But does that make sense?</p>
<p><strong>I think I'm willing to say that lambdas and rule blocks can vanish.  They probably have to.</strong></p>
<p>But I'm just not 100% on board with the idea of this vanishing leaking out through other constructs.  It seems likely that you'd start getting "vanishing sometimes" behavior on accident.</p>
<p>So while it may seem nice if you're just looking at the specific case of <strong><code>to &lt;end&gt;</code></strong> vanishing, I think the long game favors saying that it's easy enough to write <strong><code>elide to &lt;end&gt;</code></strong> if you want.</p>
<p>Having plain <strong><code>&lt;end&gt;</code></strong> in isolation vanish is fine, because that's predictable and happens every time you use <strong><code>&lt;end&gt;</code></strong>.  But it wouldn't be so with vanishing every time you use TO... hence the problem with it.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/surprising-ghosts-what-combinators-vanish/2437">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/surprising-ghosts-what-combinators-vanish/2437</link>
          <pubDate>Wed, 07 May 2025 05:19:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2437</guid>
          <source url="https://rebol.metaeducation.com/t/surprising-ghosts-what-combinators-vanish/2437.rss">&quot;Surprising&quot; Ghosts: What Combinators Vanish?</source>
        </item>
        <item>
          <title>Environment Variable Edge Cases</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>System Tools</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="1857">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/from-get-env-foo-to-environment-foo-to-env-foo-to-foo/1857/3">From (get-env "FOO") to (environment.FOO) to (env.FOO) to $FOO</a></div>
<blockquote>
<p>We have standardized methods now where if you say <strong><code>env.FOO</code></strong> and it doesn't find it, then you get a raised error. So you say <strong><code>try env.FOO</code></strong> and get NULL, or <strong><code>maybe env.FOO</code></strong> and get VOID.</p>
</blockquote>
</aside>
<p>Environment variables have some nasty edge cases</p>
<h2><a name="p-8153-windows-environment-var-names-are-not-case-sensitive-1" class="anchor" href="https://rebol.metaeducation.com#p-8153-windows-environment-var-names-are-not-case-sensitive-1"></a>Windows Environment Var Names are not Case-Sensitive</h2>
<p>Whoever sets the variable first lays claim to the case, so:</p>
<pre><code>C:\&gt; set WHATEVER="foo"

C:\&gt; set WhAtEvEr="bar"
</code></pre>
<p>If you list the environment variables after that, it will say <strong><code>WHATEVER="bar"</code></strong></p>
<p>I nearly hate this enough to want to fix it by layering on a case-sensitive default behavior, and try and force Windows users to straighten out their systems and use consistent casing.</p>
<pre><code>&gt;&gt; env.WhAtEvEr: "bar"
** Error: existing environment variable casing is WHATEVER, not WhAtEvEr
</code></pre>
<p>Beyond just bringing about more sanity in the world, this would mean your programs would run better cross-platform (as I try to maintain Windows, Mac, Linux, HaikuOS, etc. I'm particularly attuned to when these undesirable design choices make that miserable.)</p>
<p>It's technically possible to do this.  But you'd need a way to get past it if.</p>
<ul>
<li>
<p>There could be a setting on the ENVIRONMENT! you can tweak regarding case sensitivity.</p>
</li>
<li>
<p>It could be a difference in behavior between WORD! lookup and TEXT! lookup</p>
<ul>
<li>(I like this less, because it seems unmotivated)</li>
</ul>
</li>
</ul>
<h2><a name="p-8153-empty-strings-unset-variables-but-apis-confuse-2" class="anchor" href="https://rebol.metaeducation.com#p-8153-empty-strings-unset-variables-but-apis-confuse-2"></a>Empty Strings &lt;&gt; Unset Variables (But APIs Confuse...)</h2>
<p>Setting an environment variable to an empty string is possible, and it's not the same as the environment variable not being set.</p>
<p>The prescriptivist in me says you should avoid this pattern.  One thought I have is that this could be a "null-vs-trash-vs-text" distinction, e.g. if:</p>
<pre><code>C:\&gt; set SOME_VAR=""
</code></pre>
<p>Then...</p>
<pre><code>&gt;&gt; env.SOME_VAR
== ~null~  ; anti
</code></pre>
<p>Basically, disallow you from setting environment variables to empty strings, and consider that empty state to be something you have to handle specially.</p>
<p>Although...this dovetails in an interestingly with raised errors for variables that aren't there:</p>
<pre><code>&gt;&gt; env.ASDFASDF
** Error: ASDFASDF not assigned in environment
</code></pre>
<p>Because TRY converts that raised error to a null (and I'm considering this to be what leading-colon does, which is an interesting parallel to history, though it will give you null and not a TRASH antiform):</p>
<pre><code>&gt;&gt; try env.ASDFASDF
== ~null~  ; anti

&gt;&gt; :env.ASDFASDF
== ~null~  ; anti
</code></pre>
<p>This means that if you're willing to accept non-set environment variables, you can conflate their intents just by getting null for them and environment variables set to empty strings.  If you need to discern them, then you'd use EXCEPT or TRAP to say what to do with the not set case differently from the set to empty string case.</p>
<p>I like it... BUT I'm not so keen on letting you set environment variables to NULL and producing empty strings casually, when what you meant to do was set them to TRASH to remove them.  But you have to know the difference when setting fields in objects.</p>
<p>Anyway, just throwing this out there.  As usual, I think we have opportunities to be a force for sanity, and there can always be a fallback for people who want to live in the ugly world... just don't make ugly the default.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/environment-variable-edge-cases/2418">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/environment-variable-edge-cases/2418</link>
          <pubDate>Thu, 17 Apr 2025 18:39:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2418</guid>
          <source url="https://rebol.metaeducation.com/t/environment-variable-edge-cases/2418.rss">Environment Variable Edge Cases</source>
        </item>
        <item>
          <title>Oldes Rebol3.19.0 on Haiku, etc.</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>As I have mentioned previously, Oldes is deserving of being the torch-bearer for R3-Alpha... in the sense that he's more or less kept everything the same.  He hasn't focused on working through issues in the language design... but more on bridging it so it can be used as a tool for many disparate things: ranging from MIDI to 2D graphics to interoperating with Spotify or GitHub, etc.</p>
<p><a href="https://github.com/Oldes/Rebol3/releases/tag/3.19.0">https://github.com/Oldes/Rebol3/releases/tag/3.19.0</a></p>
<p>It seems he is in isolation delivering a lot more than Red, as far as the mission of <em>"not fixing the language, just making an open source artifact to apply in its current state to more things."</em></p>
<p>There's likely stuff to borrow from all of it, if it were time to do such a borrowing.</p>
<p>In any case, Rebolek is advocating for putting his version on HaikuDepot:</p>
<aside class="onebox discoursetopic" data-onebox-src="https://discuss.haiku-os.org/t/rebol-3-19-0-released-and-how-to-get-it-on-haikudepot/16643">
  <header class="source">
      <img src="https://discuss.haiku-os.org/uploads/default/optimized/2X/6/651be6f46e3730f769e5c26fb602aadd88f71863_2_32x32.ico" class="site-icon" width="32" height="32">

      <a href="https://discuss.haiku-os.org/t/rebol-3-19-0-released-and-how-to-get-it-on-haikudepot/16643" target="_blank" rel="noopener" title="06:59AM - 17 April 2025">Haiku Community â€“ 17 Apr 25</a>
  </header>

  <article class="onebox-body">
    <img src="https://discuss.haiku-os.org/uploads/default/original/2X/6/6e26ce496160254d6af509e5391c18f066c76756.png" class="thumbnail onebox-avatar" width="64" height="64">

<div class="title-wrapper">
  <h3><a href="https://discuss.haiku-os.org/t/rebol-3-19-0-released-and-how-to-get-it-on-haikudepot/16643" target="_blank" rel="noopener">Rebol 3.19.0 released and how to get it on HaikuDepot</a></h3>
  <div class="topic-category">
      <span class="badge-wrapper bullet">
        <span class="badge-category-bg" style="background-color: #25AAE2;"></span>
        <span class="badge-category clear-badge">
          <span class="category-name">Software</span>
        </span>
      </span>
  </div>
</div>

  <p>Hello guys,  the title says it all - Oldes continues to do his fantastic job and released Rebol 3.19.0. If you know what Rebol is, youâ€™re probably as excited as me and if you donâ€™t know, itâ€™s a language invented by Carl Sassenrath, author of...</p>


  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>I doubt this will draw much (any?) attention.  Despite adding more integrations, <em>I maintain that the R3-Alpha-era language delivers too little on its promises for why you would use the language in the first place.</em>  So few would see it worth overcoming the frustrations of the tool when its "unique features" are mostly a mirage.</p>
<p>But we'll see.  In any case, I coincidentally <a href="https://rebol.metaeducation.com/t/ren-c-builds-on-haiku/1710/4">built on Haiku again just yesterday</a> (<a href="https://www.youtube.com/watch?v=jImeByEkV8Y">I was the one who did the initial port</a>).  So if by some chance any rabid interest arises from that outreach, Ren-C will be around to offer some actual design and technology.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/oldes-rebol3-19-0-on-haiku-etc/2417">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/oldes-rebol3-19-0-on-haiku-etc/2417</link>
          <pubDate>Thu, 17 Apr 2025 10:42:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2417</guid>
          <source url="https://rebol.metaeducation.com/t/oldes-rebol3-19-0-on-haiku-etc/2417.rss">Oldes Rebol3.19.0 on Haiku, etc.</source>
        </item>
        <item>
          <title>Joe Marshall: &quot;REBOL 1.0 Was Slow&quot;</title>
          <dc:creator><![CDATA[rebolbot]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>Joe Marshall has posted on his blog about Rebol 1.0, here in modern times (January 3, 2025).</p>
<p><strong><a href="https://funcall.blogspot.com/2025/01/rebol-10-was-slow.html">https://funcall.blogspot.com/2025/01/rebol-10-was-slow.html</a></strong></p>
<p><em>(See also posts here on this forum: <strong><a href="https://rebol.metaeducation.com/t/rebol-1-0-retrospective/1788">Rebol 1.0 Retrospective</a></strong>)</em></p>
<hr>
<blockquote>
<p>Rebol 1.0 was slow. I paid little attention to speed in the implementation â€” I was concerned with correctness. The intepreter was intended to be a reference implementation, with well-defined behavior on every edge case. My intent was to add a compiler at a later date.</p>
<p>Once source of slowness was the liberal use of first-class continuations in the interpreter. Rebol 1.0 used a â€œCheney on the MTAâ€ interpretation strategy, where no function ever returned a value and the stack simply got deeper and deeper. When the stack overflowed, a stack garbage collection was triggered. Since most of the stack was garbage, this was a fast operation (I used a garbage collector that used time proportional to live storage). With such an implementation, first-class continuations were trivial to implement â€” <em>all</em> continuations were first-class, it was just a question of whether you surfaced them to the user. I didnâ€™t have an ideological belief either way, but there they were, so why not? Many control flow constructs that would otherwise require an <em>ad hoc</em> implementation can be easily implemented with first-class continuations.</p>
<p>Rebol had <code>return</code> statements that would return control to the caller from within the function. 99% of the time, the caller is sitting on the stack just above the current frame. But 1% of the time, the user would do something weird like create a lexical closure over the <code>return</code> statement and pass it downward. Like as not he didnâ€™t deliberately do this, but rather used some library that was implemented in continuation-passing style. If this happened, the <code>return</code> statement might have to unwind an arbitrary amount of stack. To implement this, I captured the current continuation at the entry of each function and bound it to the implicit â€œ<code>return</code>â€ variable. Invoking <code>return</code> invoked the continuation and returned control to the caller. The advantage of doing it this way was that <code>return</code> statements had the correct semantics under all circumstances. There were no special rules governing use of <code>return</code> and no code had to have special cases for unexpected <code>return</code>s.</p>
<p>A similar thing happened in the implementation of <code>break</code> and <code>continue</code> in loops. These were implemented by capturing the continuation at the entry of the loop and binding it to the implicit <code>break</code> variable, and capturing the continuation on each iteration and binding it to the implicit <code>continue</code> variable. Because these were first-class continuations, they could be used to restart the loop after it exited. That wasnâ€™t a requirement. I was perfectly happy to stipulate that <code>break</code> and <code>continue</code> only work while a loop is in progress, but in Rebol 1.0, theyâ€™d continue to work after the loop finished.</p>
<p>Worrying about continuations captured in lexical closures may seem weird, but itâ€™s a real issue. It is common to introduce implicit lexical contours in a program: even a <code>let</code> expression does it. You would like to be able to use <code>break</code> and <code>continue</code> in the body of a <code>let</code> expression in a loop. Some Rebol constructs were implemented by implicitly macroexpanding the code into a call to a helper function. <code>break</code> and <code>continue</code> would work across function call boundaries, so there were no limitations on introducing helper functions within a loop.</p>
<p>A more traditional language has a handful of <em>ad hoc</em> iteration constructs that are implemented with special purpose code. The special purpose code knows it is a loop and can be optimized for this. <code>break</code> and <code>continue</code> statements have a special dependency on the enclosing loop.</p>
<p>Rebol 1.0 was properly tail recursive, so there was no special implementation of loops. They were ordinary functions that happened to call themselves. Non-standard iteration constructs could be created by the user by simply writing code that called itself. <code>break</code> and <code>continue</code> just surfaced the interpreterâ€™s continuation to the user. As a consequence, loops in Rebol 1.0 were implemented completely in Rebol code but had signifcant interpreter overhead.</p>
<p>Rebol 2.0 and later are not properly tail recusive. As a consequence, special looping constructs are required to be written in C to support iteration. Common iteration constucts such as <code>for</code> and <code>while</code> are provided and do not have interpreter overhead, but if you want a non-standard iteration construct, there is no way to achieve it. You have to re-write your code to use one of the built-in iteration constructs or go without and risk blowing the stack.</p>
<p>My intent was to eventually write a compiler for Rebol. I wrote a prototype called Sherman that compiled to MIT-Scheme and was supported by the MIT-Scheme runtime library. Loops compiled with Sherman ran quickly as expected.</p>
</blockquote>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/joe-marshall-rebol-1-0-was-slow/2414">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/joe-marshall-rebol-1-0-was-slow/2414</link>
          <pubDate>Sat, 12 Apr 2025 18:42:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2414</guid>
          <source url="https://rebol.metaeducation.com/t/joe-marshall-rebol-1-0-was-slow/2414.rss">Joe Marshall: &quot;REBOL 1.0 Was Slow&quot;</source>
        </item>
        <item>
          <title>Should FFI ~null~ Antiform Be Accepted as 0 POINTER!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>FFI</category>
          <description><![CDATA[
            <p>There's places in FFI clients that look more or less like this:</p>
<pre><code>let ptr: make pointer! 0
if something.field [
    let whatever: blah blah field
    ptr: address of whatever
]

call-ffi-thing-that-takes-pointer ptr
</code></pre>
<p>It's kind of inconvenient that 0 pointers aren't conditionally false.</p>
<p>At the same time, it's kind of inconvenient at times that the integer! 0 can't be tested for as conditionally false.  Are pointers a different beast?</p>
<hr>
<p><strong>Having ~null~ Typecheck Distinctly Offers Crucial Advantages</strong></p>
<p>There's something that might seem at first glance to be annoying:</p>
<pre><code>&gt;&gt; make pointer! 0
** Error: Cannot make pointer from 0
</code></pre>
<p>MAKE has to return the type of the thing you are MAKE-ing, so it can't return the antiform KEYWORD! of NULL.</p>
<p><strong>BUT</strong> this could be a raised error you defuse with TRY.  And if it's the <em>only</em> raised error (as opposed to actual failure) you can get exactly the answer you'd want:</p>
<pre><code>&gt;&gt; try make pointer! 0
== ~null~  ; anti
</code></pre>
<p>This does mean that in type specifications, if a null pointer is legal you'd have to annotate it as such, with <strong><code>[~null~ pointer!]</code></strong> instead of simply <strong><code>[pointer!]</code></strong>.</p>
<p><em>But that's a very good thing.</em>  This basically means your interfaces become documented as to whether they accept nulls or not, effectively giving you <code>std::optional</code> / <code>Option()</code> / <code>Maybe</code>.  Documenting that communicates powerfully and can give much better error locality, even in an interpreted language.</p>
<hr>
<p><strong>What are the disadvantages of making NULL the 0 pointer?</strong></p>
<p>There are obvious advantages to being able to easily conditionally test the pointer variable.</p>
<p>The first disadvantage someone might cite is "you lose the protection of being able to tell if you assigned the pointer or not".  NULL is supposed to represent the easy-to-test state of whether you've assigned a variable or not--friendlier than an unset variable, but still unfriendly in most cases.  So let's say you had meant to assign <code>ptr</code> but just forgot to.</p>
<p>I think this fear isn't that compelling.  We already have the case where NULL antiforms represent the logic falsey state (the only falsey state) and don't stress over whether you "forgot to set the logic variable".</p>
<p>The bigger deal is that there are actually some edge cases where 0 pointers are meaningful addresses.  e.g. <code>dlsym()</code> on POSIX for looking up symbols in a library makes a distinction between failure to find the address of a symbol, and address 0.</p>
<p>So if you wrote:</p>
<pre><code>something: try pick libc "some-symbol"
</code></pre>
<p>Then if it couldn't find the symbol, PICK returns a raised error, which TRY converts to NULL.  But then it could have successfully found the symbol at address 0, so that is distinct.</p>
<p><em>This seems pretty esoteric to me.</em>  If you're dealing with one of these situations, you could write:</p>
<pre><code>let pointer: pick libc "some-symbol" except e -&gt; [
    fail ["Couldn't find some-symbol in libc:" mold e]
]
let address: any [to integer! maybe pointer, 0]
</code></pre>
<p>So this way there could be a legitimate NULL returned from the LIBRARY!, vs. a raised result.  If you know you're in one of these situations, you are probably doing something hardware fiddly and an integer is what you want.</p>
<hr>
<p><strong>The Advantages Of Making ~null~ the 0 State For Pointers Seem To Outweigh The Disadvantages</strong></p>
<p>I've looked at a fair bit of code and it seems the edge case of symbols that legitimately reside at address zero in memory is not compelling enough to stop the better choice.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-ffi-null-antiform-be-accepted-as-0-pointer/2407">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-ffi-null-antiform-be-accepted-as-0-pointer/2407</link>
          <pubDate>Wed, 09 Apr 2025 15:54:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2407</guid>
          <source url="https://rebol.metaeducation.com/t/should-ffi-null-antiform-be-accepted-as-0-pointer/2407.rss">Should FFI ~null~ Antiform Be Accepted as 0 POINTER!</source>
        </item>
        <item>
          <title>FFI STRUCT! Types vs. STRUCT! Instances</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>FFI</category>
          <description><![CDATA[
            <p>The original Rebol concept behind STRUCT! kind of paralleled OBJECT!, in the sense that there was no separation between the archetype and the instance.</p>
<p>From the <a href="https://www.rebol.com/docs/library.html#struct">Rebol2/Command Documentation</a>:</p>
<pre><code>a-struct: make struct! [
    in-string [string!] "Input string"
    in-int [integer!] "Input integer"
] ["This is input" 42]
</code></pre>
<p>So just as how OBJECT! has no abstract "Class" with no data--that it then instantiates with data--every STRUCT! is an instance.</p>
<p><strong>This isn't how the C which this is trying to model works, and I'm not sure it's a great plan for a language like Rebol either.</strong></p>
<p>I'd rather you'd be able to break this apart:</p>
<pre><code>input-struct!: struct [
    in-string [string!] "Input string"
    in-int [integer!] "Input integer"
]

a-struct: make input-struct! ["This is input" 42]
</code></pre>
<p>When broken up in this way, the design gets <em>much</em> clearer.</p>
<p><strong>Plus I think we have a fighting chance now to be able to get type checking for specific structure types.</strong></p>
<p>I think it's close to where the system can reasonably come up with answers for TYPE OF that are more specific.</p>
<pre><code>&gt;&gt; type of input-struct!
== ~{struct!}~  ; anti

&gt;&gt; type of a-struct
== ~{input-struct!}~  ; anti
</code></pre>
<p>And going along with that, more specific type checking:</p>
<pre><code>get-input: func [
    return: [input-struct!]
][
    return make input-struct! ["Imagine this getting typechecked!" 1020]
]
</code></pre>
<p>I see a lot of value in that, while I see little to no upside in having everywhere that takes any structure type only be able to say "STRUCT!".</p>
<p>Plus, there'd be two independently queryable entities, which could react to PICK-ing in different ways... one by letting you access the schema (because it has no data), and the other by giving you the data:</p>
<pre><code>&gt;&gt; input-struct!.in-int
== #[field! [integer!] "Input integer"]

&gt;&gt; a-struct.in-int
== "This is input"
</code></pre>
<p><strong>I know we've wanted it for objects, but FFI might get it first...</strong></p>
<p>FFI may be a good prototyping environment for doing this just because it's tangential to the main system operation, and it's easier to muck around with it.</p>
<p>Once the theory is worked out and polished, it could be brought to bear on objects.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/ffi-struct-types-vs-struct-instances/2406">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/ffi-struct-types-vs-struct-instances/2406</link>
          <pubDate>Wed, 09 Apr 2025 08:35:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2406</guid>
          <source url="https://rebol.metaeducation.com/t/ffi-struct-types-vs-struct-instances/2406.rss">FFI STRUCT! Types vs. STRUCT! Instances</source>
        </item>
        <item>
          <title>Decoupling FFI from LIBRARY!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>FFI</category>
          <description><![CDATA[
            <p>I've been so gung-ho about finally coming up with a good implementation of the <a href="https://rebol.metaeducation.com/t/extension-types-implementation/1203/2">Extension Type Mechanism</a> that I've sort of changed my tune about whether it's worth it to keep around extensions like IMAGE!, VECTOR!, the FFI, or even GOB! and the serial port extension...</p>
<p>But in any case, LIBRARY! is now the best it's been:</p>
<pre><code>&gt;&gt; winsock: make library! %/C/Windows/System32/wsock32.dll
== #[library! %/C/Windows/System32/wsock32.dll]

&gt;&gt; pick winsock "gethostbyname"
== #[handle!]

&gt;&gt; pick winsock "gethostbynickname"
** Error: Couldn't find "gethostbynickname"
      in #[library! %/C/Windows/System32/wsock32.dll]

&gt;&gt; try pick winsock "gethostbynickname"
== ~null~  ; anti

&gt;&gt; close winsock
== #[library! {closed} %/C/Windows/System32/wsock32.dll]
</code></pre>
<h2><a name="p-8101-ffi-has-a-dependency-on-library-but-1" class="anchor" href="https://rebol.metaeducation.com#p-8101-ffi-has-a-dependency-on-library-but-1"></a>FFI Has A Dependency on LIBRARY!... But...</h2>
<p>So the FFI extension is designed to let you interface with C functions from Rebol code.</p>
<p>You've got a C function in some DLL, the FFI lets you wrap that up in something you can call as a Rebol function and it translates the Rebol parameters (e.g. TEXT!) into something the C can take (e.g. <code>char*</code>).</p>
<p>The way Shixin did it, you pass the FFI a LIBRARY! and a TEXT! of a function name:</p>
<pre><code>libgtk: make library! %libgtk-3.so

gtk-init: make-routine libgtk "gtk_init" [
    argc [pointer]
    argv [pointer]
]
</code></pre>
<p>But what if MAKE-ROUTINE just took a CFunction HANDLE! ?</p>
<pre><code>libgtk: make library! %libgtk-3.so

gtk-init: make-routine (pick libgtk "gtk_init") [
    argc [pointer]
    argv [pointer]
]
</code></pre>
<p>We could make this even better, by letting LIBRARY! accept WORD! as well as TEXT!, and using a TUPLE!-based PICK:</p>
<pre><code>libgtk: make library! %libgtk-3.so

gtk-init: make-routine libgtk.gtk_init [
    argc [pointer]
    argv [pointer]
]
</code></pre>
<p><strong>This makes the FFI generalize, to however you get your CFunction.</strong></p>
<p>Maybe you compiled a function in-memory with the TCC extension and want to test it from Rebol?</p>
<p>Maybe you are using a different extension than LIBRARY! for getting DLLs.</p>
<p>Anyway, I was working on trying to resolve dependencies between modules when I realized that this particular dependency isn't necessary!</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/decoupling-ffi-from-library/2394">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/decoupling-ffi-from-library/2394</link>
          <pubDate>Fri, 04 Apr 2025 09:11:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2394</guid>
          <source url="https://rebol.metaeducation.com/t/decoupling-ffi-from-library/2394.rss">Decoupling FFI from LIBRARY!</source>
        </item>
        <item>
          <title>Don&#39;t Dialect The ~NULL~ Antiform Literally</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>The <a href="https://rebol.metaeducation.com/t/time-to-meet-your-match-dialect/1009">MATCH dialect</a> (and its family: TYPECHECK, ENSURE, NON, PROHIBIT) once had a "clever" idea for the use of the NULL antiform in the typeset parameter.</p>
<p>The idea was to use it as a shorthand for checking nulls.  This was most useful for PROHIBIT:</p>
<pre><code>&gt;&gt; value: null

&gt;&gt; prohibit null value
** Error: PROHIBIT of ~null~ got null
</code></pre>
<p>There are now a lot of other ways to say that:</p>
<pre><code>&gt;&gt; prohibit null?/ value
** Error: PROHIBIT of NULL? got null

&gt;&gt; prohibit [null?] value
** Error: PROHIBIT of [null?] got null

&gt;&gt; prohibit [~null~] value
** Error: PROHIBIT of [~null~] got null
</code></pre>
<p>Using those, it takes between 2-4 more characters to say it, but...</p>
<p><strong>...using NULL like this creates unnecessary danger of taking a null value literally!</strong></p>
<pre><code>&gt;&gt; typeset: null  ; will assign this later...

; but you forget to set it...

&gt;&gt; prohibit typeset value
; check against null, when error was desired
</code></pre>
<p>When you understand the real systemic purpose of NULL, you understand you should <em>not</em> dialect it this way.</p>
<p>While you should "never say never", I feel fairly comfortable saying you shouldn't be dialecting nulls.  It's a state that means you haven't got around to setting something yet--but you still want to be able to use casual logic tests to know if it's set yet.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/dont-dialect-the-null-antiform-literally/2383">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/dont-dialect-the-null-antiform-literally/2383</link>
          <pubDate>Tue, 25 Mar 2025 11:57:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2383</guid>
          <source url="https://rebol.metaeducation.com/t/dont-dialect-the-null-antiform-literally/2383.rss">Don&#39;t Dialect The ~NULL~ Antiform Literally</source>
        </item>
        <item>
          <title>INTERSECT/UNION/etc. Give Another Win For Isotopes!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>The set (collection) operations in Rebol are useful.</p>
<pre><code>rebol2&gt;&gt; set1: [a b c]
rebol2&gt;&gt; set2: [b c d]

rebol2&gt;&gt; intersect set1 set2
== [b c]
</code></pre>
<p>When I first encountered it, I thought it strange that it wasn't mutating the first argument.</p>
<pre><code>rebol2&gt;&gt; set1
== [a b c]  ; not modified by INTERSECT
</code></pre>
<p>Everywhere else in Rebol it seemed when you had a verb like that (APPEND, REVERSE, etc.) it was modifying.  What was special about INTERSECT that it didn't?</p>
<p>Anyway, that was just the first thing I noticed.  But digging around in the code there were questions... such as, why should it only take block lists?</p>
<pre><code>rebol2&gt;&gt; intersect [a b c] quote (b c d)
** Script Error: Expected one of: block! - not: paren!

red&gt;&gt; intersect [a b c] quote (b c d)
*** Script Error: intersect does not allow paren! for its set2 argument
</code></pre>
<p>I raised the question to <a class="mention" href="https://rebol.metaeducation.com/u/blackattr">@BlackATTR</a> who suggested that maybe single elements should just go in the list, as whole items:</p>
<pre><code>&gt;&gt; intersect [a b c] '(b c d)
== []

&gt;&gt; union [a b c] '(b c d)
== [a b c (b c d)]
</code></pre>
<p>And then I noticed... <strong>splices could draw the distinction!</strong></p>
<pre><code>&gt;&gt; union [a b c] [b c d]
== [a b c [b c d]]

&gt;&gt; union [a b c] spread [b c d]
== [a b c d]

&gt;&gt; union [a b c] spread '(b c d)
== [a b c d]

&gt;&gt; union '(a b c) spread [b c d]
== (a b c d)
</code></pre>
<p>This gives you the power to easily do set operations with single elements, and splices with SPREAD dispel the type information so there's no question what the return type should be: the type of the first set!</p>
<p>And I think to be consistent with the rest of the language, the operations should modify the first set argument by default.  But if you use the OF operations you get a copy.</p>
<p>Then, the OF operations might have different parts of speech:</p>
<pre><code> intersection of set1 set2
 =&gt; intersect (copy set1) set2

 union of set1 set2
 =&gt; unite (copy set1) set2
</code></pre>
<p>This would open up things like union and intersection to be nouns.</p>
<pre><code> union: union of set1 set2
</code></pre>
<p>This seems to me to be much better and a lot more consistent!</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/intersect-union-etc-give-another-win-for-isotopes/2380">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/intersect-union-etc-give-another-win-for-isotopes/2380</link>
          <pubDate>Mon, 24 Mar 2025 13:23:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2380</guid>
          <source url="https://rebol.metaeducation.com/t/intersect-union-etc-give-another-win-for-isotopes/2380.rss">INTERSECT/UNION/etc. Give Another Win For Isotopes!</source>
        </item>
        <item>
          <title>Dialecting Quasiforms In PARSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>The first thought I had about what quasiforms might be useful for would be to match a series of items as a splice:</p>
<pre><code>&gt;&gt; parse [a b c d] ['a ['b 'c 'd]]
== d

&gt;&gt; parse [a b c d] ['a ~(b c d)~]
== ~(b c d)~  ; anti
</code></pre>
<p>That's like the behavior of match literally of a splice:</p>
<pre><code>&gt;&gt; parse [a b c d] ['a @(spread [b c d])]
== ~(b c d)~  ; anti
</code></pre>
<p>But on the downside... if the behavior of quasiforms is taken to mean "match content", since antiforms can't occur in blocks then quasi-group would be the <em>only</em> useful antiform.  All the rest would be useless or have to come up with some custom definition.</p>
<p>Another possibility would be if quasiforms synthesized the antiform without matching anything:</p>
<pre><code>&gt;&gt; parse [a] ['a ~(b c d)~]
== ~(b c d)~  ; anti

 &gt;&gt; parse "aaa" [let x: ~null~ some "a" (x)]
 == ~null~  ; anti

 &gt;&gt; [x y]: parse "aaa" [some "a" ~['a '10]~ | some "b" ~['b '20]~]
 == a

 &gt;&gt; y
 == 10
</code></pre>
<p>But that's just a synonym for using GROUP! and code to synthesize the value (e.g. <strong><code>let x: (~null~)</code></strong> or <strong><code>let x: (null)</code></strong> instead of <strong><code>let x: ~null~</code></strong>).  The only advantage here is that it's faster (no execution required, just drop the quote byte from QUASIFORM_2 down to ANTIFORM_0).</p>
<p>(I've already contemplated the idea of <strong><code>x: ~null~</code></strong> vs. <strong><code>x: null</code></strong> as something which could be done in code that you're trying to micro-optimize.)</p>
<h2><a name="p-8057-but-dialecting-is-supposed-to-be-powerful-1" class="anchor" href="https://rebol.metaeducation.com#p-8057-but-dialecting-is-supposed-to-be-powerful-1"></a>But Dialecting Is Supposed To Be <em>Powerful</em>...</h2>
<p>Rote production of antiforms seems weak compared to dreaming up useful constructs.</p>
<p>e.g. quasi-TRIPWIRE could raise an error with a string (possibly even an interpolated one!)</p>
<pre><code>&gt;&gt; letter: #b

&gt;&gt; parse "aaa" [some letter | ~&lt;Expected all (letter)&gt;~]
** Error: Expected all b
</code></pre>
<p>That's quite compelling, and supports the argument that maybe customizing the meanings is worth it.  For instance ~[...]~ could actually run PACK vs. being the literal pack.</p>
<pre><code>&gt;&gt; [a b]: parse [10 20] [let x: integer! let y: integer! ~[x y]~]
== 10

&gt;&gt; a
== 10

&gt;&gt; b
== 20
</code></pre>
<p><em>"But that's not what the evaluator does with QUASI-BLOCK!"</em> you might say.  No, but it's inside PARSE, nothing is doing what the evaluator does.  That's the whole premise of the language!</p>
<p>A similar premise could apply to the splicing...and it doesn't even have to return a splice!</p>
<pre><code>&gt;&gt; middle-letter: 'c

&gt;&gt; parse [a b c d] ['a ~('b middle-letter 'd)~]
== [b c d]
</code></pre>
<p>All QUASI-words are available, while not all antiforms of words are legal.  Since parse is using quasiforms then it means every word is possible.  It could represent an error ID, or something else... maybe shorthands for things like accepting and rejecting?</p>
<pre><code>&gt;&gt; parse "aaabbb" [some "a" ~accept~]  ; synonym for [accept &lt;input&gt;]
== "aaabbb"
</code></pre>
<p><strong>Ok, I really like this idea, of clever applications, vs. simply synthesizing antiforms and not matching!</strong>  It's clearly much neater.</p>
<p>Ren-C has given Rebol quantum leaps in expressivity.</p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/frog.png?v=14" title=":frog:" class="emoji only-emoji" alt=":frog:" loading="lazy" width="20" height="20"> <img src="https://rebol.metaeducation.com/images/emoji/twitter/atom_symbol.png?v=14" title=":atom_symbol:" class="emoji only-emoji" alt=":atom_symbol:" loading="lazy" width="20" height="20"></p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/dialecting-quasiforms-in-parse/2379">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/dialecting-quasiforms-in-parse/2379</link>
          <pubDate>Sat, 22 Mar 2025 16:32:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2379</guid>
          <source url="https://rebol.metaeducation.com/t/dialecting-quasiforms-in-parse/2379.rss">Dialecting Quasiforms In PARSE</source>
        </item>
        <item>
          <title>Making RANDOM Less Random :thinking:</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>Historical RANDOM in Rebol is a hodgepodge, which Red carried forward:</p>
<pre><code>red&gt;&gt; help random
USAGE:
     RANDOM value

DESCRIPTION: 
     Returns a random value of the same datatype; or shuffles series. 
     RANDOM is an action! value.

ARGUMENTS:
     value         "Maximum value of result (modified when series)."

REFINEMENTS:
     /seed        =&gt; Restart or randomize.
     /secure      =&gt; Returns a cryptographically secure random number.
     /only        =&gt; Pick a random value from a series.

RETURNS:
     [any-type!]
</code></pre>
<p>What the function does can vary significantly based on the refinements and argument:</p>
<pre><code>&gt;&gt; random 10
== 5  ; just picks an integer from 1 to 10 inclusive

&gt;&gt; block: [a b c]

&gt;&gt; random block
== [c b a]  ; e.g. default behavior for block is SHUFFLE

&gt;&gt; block
== [c b a]  ; and it's a mutating shuffle.

&gt;&gt; random/only block
== b  ; so /only makes it pick an element out of blocks

&gt;&gt; random/seed [a b c] 
; no return value, just makes the next values deterministic
</code></pre>
<p>That's just crazy.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/zany_face.png?v=14" title=":zany_face:" class="emoji" alt=":zany_face:" loading="lazy" width="20" height="20">   Not only is it hard to predict what it's going to do, but the type specs don't tell you what the return values are.</p>
<p>As part of transitioning RANDOM to <a href="https://rebol.metaeducation.com/t/further-optimizations-of-breaking-the-64-type-barrier/2369">"New Generics"</a> I decided to go ahead and split this up.</p>
<h2><a name="p-8048-shuffle-random-randomize-random-pick-1" class="anchor" href="https://rebol.metaeducation.com#p-8048-shuffle-random-randomize-random-pick-1"></a>SHUFFLE, RANDOM, RANDOMIZE, RANDOM-PICK</h2>
<ul>
<li>RANDOM:SEED =&gt; RANDOMIZE</li>
<li>RANDOM:ONLY =&gt; RANDOM-PICK</li>
<li>RANDOM =&gt; if it shuffled a series, SHUFFLE, else RANDOM</li>
</ul>
<p>Then I've added another routine SHUFFLE-OF which works on immutable types, making a new shuffled copy.  And the way it works is that if you use SHUFFLE-OF on a type that doesn't have a tailored implementation of it, then it falls back and tries to do it as SHUFFLE COPY.</p>
<pre><code>&gt;&gt; path: 'a/b/c/d

&gt;&gt; shuffle path
** Error: PATH! is immutable

&gt;&gt; shuffle of path
== c/d/a/b  ; uses the SHUFFLE-OF registered for ANY-SEQUENCE?

&gt;&gt; block: [a b c d]

&gt;&gt; shuffle of block
== [b d c a]  ; no SHUFFLE-OF for ANY-LIST?, falls back on SHUFFLE COPY

&gt;&gt; block
== [a b c d]
</code></pre>
<p>I also thought it would be useful to have RANDOM-BETWEEN, because then you can say what the min and max values are without needing to do math on a 1-based RANDOM result:</p>
<pre><code>&gt;&gt; random-between 5 10
== 7
</code></pre>
<h2><a name="p-8048-further-directions-random-dialect-2" class="anchor" href="https://rebol.metaeducation.com#p-8048-further-directions-random-dialect-2"></a>Further Directions: RANDOM Dialect?</h2>
<p>In this formulation so far, RANDOM on a BLOCK! has no meaning.</p>
<p>That made me wonder about whether RANDOM should be dialected when you pass it a block:</p>
<pre><code>random [between 10 and 20]

random [between 10 and 20 distribution 'normal]

random [weighted [["A" 0.7] ["B" 0.2] ["C" 0.1]]]
</code></pre>
<p>Dialects of this kind have proven very difficult to design, and we've only got a few of them.  Once you move things out of the domain of simple functions you make them harder to specialize/adapt/cascade, and you wind up doing work that the evaluator takes care of for you with a function.</p>
<p>But I do think that looks nice, and is something to think about for the future.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/making-random-less-random/2375">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/making-random-less-random/2375</link>
          <pubDate>Thu, 20 Mar 2025 16:46:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2375</guid>
          <source url="https://rebol.metaeducation.com/t/making-random-less-random/2375.rss">Making RANDOM Less Random :thinking:</source>
        </item>
        <item>
          <title>Warts in Dialecting: When Worse Is Better</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>I was facing a little bit of a design question with the %types.r table, that I talk about here:</p>
<p><a href="https://rebol.metaeducation.com/t/which-antiforms-are-in-use/2276/4" class="inline-onebox">Which Antiforms Are In Use? - #3</a></p>
<p>I'd come up with the idea that using a quasiform in the table was a good semiotic way of suggesting the name of the antiform state of a type.  I was happy with that, but then the question was how was I to distinguish a stable antiform from an unstable one.</p>
<p>Originally it was done with the presence of a <code>#unstable</code> ISSUE! in a sort of random spot.  Here you can see SPLICE? is a stable antiform, while RAISED? is unstable, based on the presence or absence of that issue:</p>
<pre><code>group       "list that evaluates expressions as an isolated group"
~splice~    "fragment of multiple values without a surrounding block"
            (node1)
            [any-series? any-plain-value? any-sequencable?]

error       "error context with id, arguments, and stack origin"
~raised~    "trappable error cooperatively returned from a function call"
#unstable   (node1 node2)
            [any-inert?]
</code></pre>
<p>This didn't sit well with me, and I think what I didn't like is that it didn't connect <span class="hashtag-raw">#unstable</span> to the antiform state.  If I were looking at this, I'd wonder "are the nodes unstable?"  Because that's the line it's on.</p>
<p>Ren-C has a wide breadth of parts you can use (although this is part of bootstrap, so it doesn't have all the parts of the modern executable).  And you can pick random ideas.  What if it were quoted, and that meant unstable?</p>
<pre><code>error       "error context with id, arguments, and stack origin"
'~raised~   "trappable error cooperatively returned from a function call"
            (node1 node2)
            [any-inert?]
</code></pre>
<p>Uh, well.  <em>Technically</em> that works.  There's a lot of things that could <em>technically</em> work.  You could say <strong>{~raised~}</strong> or make it look like a meta-tripwire:</p>
<pre><code>error       "error context with id, arguments, and stack origin"
~&lt;raised&gt;~  "trappable error cooperatively returned from a function call"
            (node1 node2)
            [any-inert?]
</code></pre>
<p>That looks nice, <em>but maybe it looks too nice</em>.  It's so smooth as to be unnoticeable if you're scrolling through.</p>
<p>Which is why I ended up choosing something purposefully jarring:</p>
<pre><code>error       "error context with id, arguments, and stack origin"
~raised~:U  "trappable error cooperatively returned from a function call"
            (node1 node2)
            [any-inert?]
</code></pre>
<p>You can't miss it... staring you in the face.  It could also be a PATH! or a TUPLE!</p>
<pre><code>error       "error context with id, arguments, and stack origin"
~raised~/U  "trappable error cooperatively returned from a function call"
            (node1 node2)
            [any-inert?]

error       "error context with id, arguments, and stack origin"
~raised~.U  "trappable error cooperatively returned from a function call"
            (node1 node2)
            [any-inert?]
</code></pre>
<p>But I think I like the CHAIN! for some reason.  It's jarring enough to see it, but the colon is a very "balanced" character.  And you can see clearly that the (U)nstable is "correlated with" or "modifies" the antiform state, which addresses the problem I had with <code>#unstable</code>.</p>
<p>It might look better as <strong><code>~raised~:*</code></strong>, and it might not.  But I think this is sort of an interesting case study, because it's all playing into that subtlety of how to make something that looks passable yet still triggers that primordial "ick" enough to get you to ask questions.  Then once you familiarize yourself you know what it means, and when the ick goes away you see it as a smart design.</p>
<p><strong>It's interesting to me that I feel like I like the CHAIN! version as <strong><code>:U</code></strong> noticeably more than <strong><code>/U</code></strong> or <strong><code>.U</code></strong>, which is a further validation of having that part in the box.</strong></p>
<p>Also interesting to note here is the reasoning why there are no antiform CHAIN! or PATH! or TUPLE!, because cases like this show it's more valuable to be able to have quasiforms as elements than to have a quasiform path state.</p>
<p><em>(Otherwise, ambiguity... what is <strong>~:foo:~</strong> ?  Is it a quasiform of <strong>:foo:</strong>, or is it a 3-element CHAIN! with quasiform blank in the first and last slots?  I think quasiform <code>:foo:</code> is sufficiently useless to favor the definition that gives us things like <strong><code>~/home/whatever</code></strong> as a legal path...)</em></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/warts-in-dialecting-when-worse-is-better/2371">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/warts-in-dialecting-when-worse-is-better/2371</link>
          <pubDate>Tue, 18 Mar 2025 01:52:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2371</guid>
          <source url="https://rebol.metaeducation.com/t/warts-in-dialecting-when-worse-is-better/2371.rss">Warts in Dialecting: When Worse Is Better</source>
        </item>
        <item>
          <title>Should (1 + #A) Equal (#A + 1) ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>I ran across this peculiarity:</p>
<pre><code>rebol2&gt;&gt; 1 + #"A"
== 66

rebol2&gt;&gt; #"A" + 1
== #"B"
</code></pre>
<p>Red and R3-Alpha do this too.</p>
<p>Loosely speaking, there's an internal policy which is something along the lines of <em>"if the types don't match, convert the second operand into the type of the first, and then do the add"</em>.</p>
<p>Because of this, it's necessary to support the addition of characters to each other to get <strong>(<span class="hashtag-raw">#A</span> + 1)</strong> to work:</p>
<pre><code>red&gt;&gt; #"A" + #"B"
== #"^(83)"  ; only useful in implementation of old coercion rule
</code></pre>
<p>...which seems nonsensical to me.</p>
<h2><a name="p-7963-what-do-other-languages-do-1" class="anchor" href="https://rebol.metaeducation.com#p-7963-what-do-other-languages-do-1"></a>What Do Other Languages Do?</h2>
<p>If "implicit type promotion" is supported, many languages, including C, C++, and Java, use a system where the "smaller" type is converted to the "larger" type (<a href="https://pages.mtu.edu/~shene/COURSES/cs201/NOTES/chap02/exp-2.html">e.g., int to float</a>).  Having an idea of what's bigger and what's smaller helps avoid the commutativity problem.</p>
<p>And in the specific case of adding characters to integers, Rebol is weird to give a different answer depending on order.</p>
<ul>
<li>
<p><strong>Python:</strong> In Python, adding an integer to a character (or vice versa) would raise a TypeError. Python doesn't implicitly convert between these types.</p>
</li>
<li>
<p><strong>JavaScript:</strong> JavaScript would convert the character to its ASCII value and perform integer addition in both cases, resulting in a number.</p>
</li>
<li>
<p><strong>Ruby:</strong> Similar to Python, Ruby would raise a TypeError when trying to add an integer to a character.</p>
</li>
<li>
<p><strong>Java:</strong> Java doesn't allow direct addition between char and int types without explicit casting.</p>
</li>
</ul>
<p>I think adding integers to characters and wanting a character back is the more common operation, so if it's legal, I'd advocate for:</p>
<pre><code>&gt;&gt; 1 + #A
== #B

&gt;&gt; #A + 1
== #B
</code></pre>
<p>But if we want to rule out addition of characters to characters (which I do) this commutative behavior doesn't fall out from a system of implicit conversion with an ordering on "bigger" types... since characters are smaller.</p>
<p>I don't see an obvious "rule" besides hardcoding it.</p>
<h2><a name="p-7963-what-about-commutativity-in-general-2" class="anchor" href="https://rebol.metaeducation.com#p-7963-what-about-commutativity-in-general-2"></a>What About Commutativity In General?</h2>
<p>We can imagine decisions on what you would make <strong><code>+</code></strong> mean that would not be commutative.  For instance, if you were allowed to make it mean "join strings":</p>
<pre><code>&gt;&gt; "abc" + "def"
== "abcdef"

&gt;&gt; "def" + "abc"
== "defabc"
</code></pre>
<p>So you might try and argue that the rules for <strong>add</strong> are different than the rules for <strong>+</strong>, and it's only when + is acting as ADD that it enforces commutativity.  However... even in the domain of math, you have exceptions... e.g. matrix multiplication is not commutative.</p>
<p>The more general question of commutativity seems to be that there aren't any popular languages that do it automatically.  e.g. in C++ you have to overload <strong><code>operator+(T1,T2)</code></strong> and <strong><code>operator+(T2,T1)</code></strong> separately...one of them can call the other, but that never happens automatically.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-1-a-equal-a-1/2346">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-1-a-equal-a-1/2346</link>
          <pubDate>Fri, 06 Dec 2024 12:30:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2346</guid>
          <source url="https://rebol.metaeducation.com/t/should-1-a-equal-a-1/2346.rss">Should (1 + #A) Equal (#A + 1) ?</source>
        </item>
  </channel>
</rss>

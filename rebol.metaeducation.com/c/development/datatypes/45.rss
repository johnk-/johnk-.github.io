<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Datatypes - AltRebol</title>
    <link>https://rebol.metaeducation.com/c/development/datatypes/45</link>
    <description>Topics in the &#39;Datatypes&#39; category The datatypes category is for the discussion of the specific properties of datatypes themselves.  Sample topics might include:</description>
    
      <lastBuildDate>Wed, 14 May 2025 03:17:57 +0000</lastBuildDate>
      <atom:link href="https://rebol.metaeducation.com/c/development/datatypes/45.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Should SIGIL! Be A Type, Or Just Decorated SPACE?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2447">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/new-names-for-foo-foo-and-foo/2447/2">New Names for ^FOO, @FOO, and $FOO</a></div>
<blockquote>
<p>This could also give us a verb:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; lift [a b c]
== ^[a b c]
</code></pre>
</blockquote>
</aside>
<p>When you consider this, it might suggest there's no SIGIL! <em>datatype</em>... they're just sigilized states of space (<a href="https://rebol.metaeducation.com/t/how-does-blank-interact-with-strings-binary/2287/3">note that _ is now the space character literal, not a unique unit type</a>)</p>
<pre><code>&gt;&gt; lift _
== ^

&gt;&gt; pin _
== @

&gt;&gt; tie _
== $
</code></pre>
<p>That wouldn't change anything really about the functions asking questions like SIGIL OF.  Same difference:</p>
<pre><code>assert ['$ = sigil of first [$abc]]
</code></pre>
<p>It does mean we don't need to spend one of 63 fundamental datatypes on SIGIL!, which isn't totally useless.</p>
<p>It also means that we don't have to worry about explaining the difference between <strong><code>[$ @ ^]</code></strong> and <strong><code>[$_ @_ ^_]</code></strong>  This seems like a pretty big win:  the value of being able to decorate spaces in this way seems like it would be far outweighed by the cognitive load of having these forms be different.</p>
<p>Also, <strong><code>[$$ $@ $^ @$ @@ @^ ^$ ^@ ^^]</code></strong> would not exist.</p>
<p>As obviously good as forbidding those may seem...I strangely proposed using things like this back when COMPOSE didn't use the current environment, so I was thinking about bindable SIGIL!s:</p>
<pre><code>&gt;&gt; $$
== $  ; bound

&gt;&gt; bar: 1020

&gt;&gt; compose2-old $$ [foo $bar baz]
== [foo 1020 baz]
</code></pre>
<p>Now this is less of a concern, since COMPOSE2 will use the current environment, so it can work with a Sigil that is not bound:</p>
<pre><code>&gt;&gt; bar: 1020

&gt;&gt; compose2 '$ [foo $bar baz]
== [foo 1020 baz]
</code></pre>
<p>Actually, the whole priority of being able to pass the environment by means of the pattern is pretty much gone.  It could just be an additional parameter to COMPOSE for the few cases that use it, and that would actually be simpler than the rigamarole and confusion of trying to put the context onto the pattern itself... which was an artifact of when COMPOSE syntactically needed to capture the environment to work.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-sigil-be-a-type-or-just-decorated-space/2451">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-sigil-be-a-type-or-just-decorated-space/2451</link>
          <pubDate>Wed, 14 May 2025 03:17:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2451</guid>
          <source url="https://rebol.metaeducation.com/t/should-sigil-be-a-type-or-just-decorated-space/2451.rss">Should SIGIL! Be A Type, Or Just Decorated SPACE?</source>
        </item>
        <item>
          <title>Replacing HANDLE! with Extension Types</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>I've made big progress on resurrecting the concept of <a href="https://rebol.metaeducation.com/t/extension-types-implementation/1203">"Extension Types"</a>.</p>
<p>The first implementation of them was creaky and I was just learning how the system would have to be shaped and redesigned to support them.  But now they're starting to work, and work <em>really well</em>.  This means we can basically have tons of datatypes and not break a sweat.</p>
<h2><a name="p-8093-i-think-they-can-completely-replace-handle-1" class="anchor" href="https://rebol.metaeducation.com#p-8093-i-think-they-can-completely-replace-handle-1"></a>I Think They Can Completely Replace HANDLE!</h2>
<p>The idea behind HANDLE! historically was just that you had some piece of data... like a pointer... and you needed a type to put it in.</p>
<p>In R3-Alpha it was basically an alias for INTEGER! such that you didn't confuse it for thinking it was an integer.  Also, since integers were always signed, it meant you weren't representing pointers with negative numbers.</p>
<p>So when you did something like open an ODBC database, you'd get a HANDLE!.  If you created a statement in that database, you'd get a HANDLE! representing the ODBC statement.  If you were doing FFI and you were talking about some memory address, you'd get a HANDLE!.</p>
<p>Beyond that you had no information to distinguish them.  Ren-C added the concept of putting a pointer to a function inside the handle that represented what would be called when the GC was garbage collecting it... and that could serve as something of an identity.  This way the handle you passed ODBC could say "oh, the cleanup function is the cleanup function for ODBC Statements... hence the handle must be an ODBC statement..."</p>
<p><em>Screw all that.</em>   Just make ODBC-STATEMENT! and ODBC-DATABASE! extension types, and the world is a better place.</p>
<h2><a name="p-8093-can-extension-types-replace-port-2" class="anchor" href="https://rebol.metaeducation.com#p-8093-can-extension-types-replace-port-2"></a>Can Extension Types Replace PORT! ?</h2>
<p>It seems to me that PORT! has many of the same problems as HANDLE!.  It was just this black box.</p>
<p>Extension types are handling this much better, and I think they're going to be taking over!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/replacing-handle-with-extension-types/2390">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/replacing-handle-with-extension-types/2390</link>
          <pubDate>Sun, 30 Mar 2025 21:34:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2390</guid>
          <source url="https://rebol.metaeducation.com/t/replacing-handle-with-extension-types/2390.rss">Replacing HANDLE! with Extension Types</source>
        </item>
        <item>
          <title>Looks Like FILE! Immutability Is A Good Idea</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Since changing URL! to be immutable, we've realized several benefits.  Notably that you can't produce things that don't validate as URL! that are still claiming to be of type URL!:</p>
<pre><code>red&gt;&gt; url: https://red-lang.org
== http://red-lang.org

red&gt;&gt; reverse url
== gro.gnal-der//:sptth
</code></pre>
<p><strong>sptth! indeed, I say.</strong> <img src="https://rebol.metaeducation.com/images/emoji/twitter/face_vomiting.png?v=14" title=":face_vomiting:" class="emoji" alt=":face_vomiting:" loading="lazy" width="20" height="20"></p>
<pre><code>ren-c&gt;&gt; url: http://hostilefork.com
== http://hostilefork.com

ren-c&gt;&gt; reverse url
** Script Error: reverse expects [~void~ any-series? any-sequence? pair!] 
</code></pre>
<p>But besides that we get another advantage: we don't have to be paranoid about  URL! changing out from under us.</p>
<p>So for instance, when you LOAD some code from a URL! then we poke the address of that URL's data into all the blocks that get loaded.  This way you can ask for the FILE OF and get that URL! back.</p>
<p><em>(As it gives a URL! sometimes and not a FILE!, that makes me wonder if we should call that SOURCE OF, and find another way to ask for <em>source code</em>... like IMPLEMENTATION OF).</em></p>
<p>In any case, since we know the URL! can't change out from under us, we don't have to worry about storing the pointer that was passed to TRANSCODE by LOAD directly.  If we did have to worry, we'd need to make a copy of it.</p>
<p>But with mutable FILE! <strong>we do have to worry</strong>, and copy it.  Otherwise:</p>
<pre><code>&gt;&gt; file: %my-awesome-script.r

&gt;&gt; code: transcode:file (read file) file
== [reverse [my script is awesome]]

&gt;&gt; file of code.1
** Error: Only ANY-LIST? encode the file they were loaded from

&gt;&gt; file of code.2
== %my-awesome-script.r

&gt;&gt; replace file "awesome" "dumb"
== %my-dumb-script.r

&gt;&gt; file of code.2
== %my-dumb-script.r  ; ...but we loaded it from %my-awesome-script.r !
</code></pre>
<h2><a name="p-8091-immutable-file-means-we-could-kill-empty-file-1" class="anchor" href="https://rebol.metaeducation.com#p-8091-immutable-file-means-we-could-kill-empty-file-1"></a>Immutable FILE! means we could kill empty FILE!</h2>
<p>Empty FILE! doesn't make sense.</p>
<ul>
<li>
<p>Did you want something that would cause an error when you appended it somewhere?  Use NULL.</p>
</li>
<li>
<p>Did you want something that would be a no-op when you appended it somewhere?  Use VOID.</p>
</li>
</ul>
<p>All the AI say roughly this:</p>
<blockquote>
<p>There are no known filesystems that allow the empty string (<code>""</code>) as a valid filename. Most modern filesystems, including ext4, NTFS, FAT variants, and others, explicitly disallow the empty string as a filename. This restriction is consistent with POSIX standards, which define filenames as non-empty character strings</p>
<p>Historically, some older UNIX systems might have treated an empty string as an alias for the current directory, but this behavior was likely unintended and is no longer supported in contemporary systems</p>
</blockquote>
<p>If we could get rid of empty FILE!, that gives us one more leg up in terms of the datatype providing actual value vs. just being a weak alias for string.</p>
<h2><a name="p-8091-interpolation-is-stronger-than-mutable-manipulation-2" class="anchor" href="https://rebol.metaeducation.com#p-8091-interpolation-is-stronger-than-mutable-manipulation-2"></a>Interpolation Is Stronger Than Mutable Manipulation</h2>
<p>Now that we have interpolation, I think it can replace a lot of cases where you might have thought you needed to manipulate a file directly.</p>
<p>Also, the -OF functions will let you do things to immutable types:</p>
<pre><code>&gt;&gt; replace of %my-dumb-script.r "dumb" "awesome"
== %my-awesome-script.r
</code></pre>
<p>I think this also points out a missing ability for PARSE, namely PARSE OF for immutable types.  e.g.:</p>
<pre><code> parse-of tuple rule
 =&gt;
 as tuple! parse to block! tuple rule
</code></pre>
<p>So for instance:</p>
<pre><code> &gt;&gt; parse of 'a.a.a.b.c.d [remove some 'a ~accept~]
 == b.c.d
</code></pre>
<p>Best of both worlds!</p>
<h2><a name="p-8091-retaking-as-a-word-3" class="anchor" href="https://rebol.metaeducation.com#p-8091-retaking-as-a-word-3"></a>Retaking % As A WORD!</h2>
<p>With no empty files, we can say that % is clearly a WORD!</p>
<p>Maybe some other things too.  %% could be a WORD!, or a file with the name "%".  There's lots of edge cases on that, e.g. to make a file with the name <strong><code>"</code></strong> you'd have to say <code>%-{"}-</code>.  So I don't think we should be afraid to make %% a WORD! if that provides another interesting symbol.</p>
<h2><a name="p-8091-this-seems-like-a-good-direction-4" class="anchor" href="https://rebol.metaeducation.com#p-8091-this-seems-like-a-good-direction-4"></a>This Seems Like A Good Direction</h2>
<p>I've had the thought before, but recent improvements to OF makes it more palatable.</p>
<p>What motivated me to think about this right now was that I was resurrecting the LIBRARY! codebase, where you can load a DLL:</p>
<pre><code>&gt;&gt; make library! %some-thing.dll
== #[library!]
</code></pre>
<p>I was thinking "Hm, it seems like it would be nice if it stored the filename".</p>
<pre><code>&gt;&gt; make library! %some-thing.dll
== #[library! %some-thing.dll]
</code></pre>
<p>And I was going to poke the FILE! value into a Cell in the LIBRARY!'s Stub.  But then I thought "oh no, what if they change it."</p>
<p>They shouldn't be able to.  Immutable FILE! is just better all around for the system.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/looks-like-file-immutability-is-a-good-idea/2388">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/looks-like-file-immutability-is-a-good-idea/2388</link>
          <pubDate>Fri, 28 Mar 2025 17:18:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2388</guid>
          <source url="https://rebol.metaeducation.com/t/looks-like-file-immutability-is-a-good-idea/2388.rss">Looks Like FILE! Immutability Is A Good Idea</source>
        </item>
        <item>
          <title>&quot;type of antiform&quot; now possible... Should We Use It?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>The way antiforms were implemented originally didn't allow for the idea of giving a coherent answer back from TYPE OF.  So they all gave the same answer, much how QUOTED! and QUASIFORM! all gave the same answer:</p>
<pre><code>&gt;&gt; type of first [''a]
== &amp;[quoted]

&gt;&gt; type of first [~a~]
== &amp;[quasiform]

&gt;&gt; type of spread [a b c]
== &amp;[antiform]
</code></pre>
<p>So there was nothing like <code>&amp;[splice]</code>.  The only way to type check antiforms was with constraints, like SPLICE?... which was slower, since it had to call a constraint function.</p>
<p>But I reworked things in a way that speeds up SPLICE? to the point where it's no more expensive than checking for INTEGER! (or INTEGER?).</p>
<p>As a curious byproduct that I didn't even initially intend, this changed the behavior and it started treating antiforms as being datatypes:</p>
<pre><code>&gt;&gt; type of spread [a b c]
== &amp;[splice]
</code></pre>
<p>I was actually surprised, because I didn't intend to do it.  It's not often a feature "just happens".</p>
<h2><a name="p-8046-but-is-it-a-good-idea-for-antiforms-to-answer-type-of-1" class="anchor" href="https://rebol.metaeducation.com#p-8046-but-is-it-a-good-idea-for-antiforms-to-answer-type-of-1"></a>But Is It A Good Idea For Antiforms To Answer TYPE OF?</h2>
<p>I've struggled with types, and the question of what TYPE means, vs. what KIND means... or CLASS?</p>
<p>If we develop some sort of class system, then TYPE becomes a loaded question.  If you have an object that somehow remembers it was created as a BOOK!, then do you get <strong>book! = type of my-book</strong> being true?  Or is TYPE OF forever committed to returning the fundamental type and saying it's an OBJECT! ?</p>
<p>This hesitance has affected my willingness to rename REB_BLOCK and REB_BLANK to be TYPE_BLOCK and TYPE_BLANK, which would be much more palatable (and survive a language name change away from Rebol...)</p>
<p>There's also the question of <strong>type of null</strong>, which I feel needs to be an error most of the time.  The way I've worked it out so far is that you get a RAISED? error.  So if you know you want to test for null you can say <strong>try type of null</strong> and get a null antiform result--not a datatype, but there's a sort of reasonable logic to saying the type of null is null.</p>
<h2><a name="p-8046-what-would-it-hurt-eg-if-splice-looked-like-a-type-2" class="anchor" href="https://rebol.metaeducation.com#p-8046-what-would-it-hurt-eg-if-splice-looked-like-a-type-2"></a>What Would It Hurt, e.g. if SPLICE! Looked Like A Type?</h2>
<p>For instance, is there a really good reason why this shouldn't work?</p>
<pre><code>&gt;&gt; to splice! [a b c]
== ~(a b c)~  ; anti

&gt;&gt; to block ~(a b c)~
== [a b c]

switch type of spread [a b c] [
    splice! [print "Is this somehow bad?"]
]
</code></pre>
<p>It might be confusing, that a type ending in <strong><code>!</code></strong> can't be put into a block.  But that was true before with antiform!...</p>
<p>I lean toward thinking that there's more upside than downside.  And I kind of want to put this TYPE vs KIND vs. whatever else issue to rest.  We write <strong>type of x</strong> and expect to get something like BLOCK! or OBJECT! back.  If there's something more complex than that, it probably needs to be done another way.</p>
<p>So if you have something like <code>''''1</code> and <code>''''x</code> and <code>''''3</code>, and you want to know which are the "same type", you'll need to define your operators for answering that.</p>
<p>Want to know if they're the same underlying type when you take the quotes off?</p>
<pre><code> (heart of x) = (heart of y)
</code></pre>
<p>Want to know if they're at the same quote level?</p>
<pre><code>(quotes of x) = (quotes of y)
</code></pre>
<p>I'm sort of tempted to say actually that it might should be that TYPE OF doesn't work on quoted values, because of how misleading it is... but all blocks are of the same type, even if they're different lengths.  And it is actually often the case in dialects that if something is quoted, you treat all quoted things the same way...oddly enough.</p>
<p>In any case, the new flexibility for -OF operators means we can get some other ideas in the mix.  Rnadomly:</p>
<pre><code>&gt;&gt; quoted-type of first of ['''x]
== &amp;[' ' ' &amp;[word!]]

&gt;&gt; quoted-type of first of ['''1]
== &amp;[' ' ' &amp;[integer!]]
</code></pre>
<p>If we say there are more questions you can ask of values to produce structure... instead of putting that burden on TYPE, we can maybe commit to what type does and move along.</p>
<p>And maybe there could be something like <strong>class:relax of x</strong> which if something wasn't an object, would give you the fundamental type?</p>
<pre><code>&gt;&gt; class of some-novel
== #[make object! ...]

&gt;&gt; class of some-block
** Error: not an object, use CLASS:RELAX to permit other types

&gt;&gt; class of some-block
== &amp;[block]
</code></pre>
<p>I guess in other words, I'm feeling like it's time to just go ahead and say that TYPE-OF is the question we build on, that it returns fundamentals or antiform classes.</p>
<p>And maybe the concept I've always wanted of calling it TYPE! instead of DATATYPE! will be possible, too.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/type-of-antiform-now-possible-should-we-use-it/2374">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/type-of-antiform-now-possible-should-we-use-it/2374</link>
          <pubDate>Tue, 18 Mar 2025 21:55:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2374</guid>
          <source url="https://rebol.metaeducation.com/t/type-of-antiform-now-possible-should-we-use-it/2374.rss">&quot;type of antiform&quot; now possible... Should We Use It?</source>
        </item>
        <item>
          <title>Should WORD! Answer LENGTH OF (and other ponderings)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>I'm looking at putting some gaps in the type table, and at first I was going to write something along the lines of this, with BLANK?:</p>
<pre><code>blank 1
integer 2
decimal 3
_ 4
_ 5
any-series 6
any-unit 7
</code></pre>
<p>Then I stopped and thought "well, wait, might TRASH? be better?"</p>
<pre><code>blank 1
integer 2
decimal 3
~ 4
~ 5
any-series 6
any-unit 7
</code></pre>
<p>Of course you have a lot of single-character choices, if single-characterness is important.  <strong><code>#</code></strong> is the space character.  And single-characterness isn't in and of itself all that big a deal.</p>
<h2><a name="p-8035-whats-the-difference-1" class="anchor" href="https://rebol.metaeducation.com#p-8035-whats-the-difference-1"></a>What's The Difference?</h2>
<p>There's a key difference: <strong>if you want something in that slot that's going to signal a misunderstanding, trash will get the you there faster.</strong></p>
<p>Nominally what's expected in that slot is a WORD!  And there are various things you can do with a blank, like convert it TO a TEXT!...</p>
<pre><code>&gt;&gt; to text! _
== ""
</code></pre>
<p>Whereas trash doesn't do that.  It's a quasiform, so like quoted values and antiforms it is not considered "fundamental":</p>
<pre><code>&gt;&gt; to text! first [~]
** Script Error: to expects [~void~ fundamental?] for its element argument
</code></pre>
<p>So really, you will get errors on <em>any</em> quasiform you use.  There's lots of options:</p>
<pre><code>blank 1
integer 2
decimal 3
~nope~ 4
~[nuh-uh]~ 5
any-series 6
any-unit 7
</code></pre>
<p>But when I look at this, it suddenly presents a pretty strong justification for quasiform integers:</p>
<pre><code>blank 1
integer 2
decimal 3
~4~
~5~
any-series 6
any-unit 7
</code></pre>
<p>Though maybe one should be happy enough with meta-tripwire, quasi-tag:</p>
<pre><code>blank 1
integer 2
decimal 3
~&lt;4&gt;~
~&lt;5&gt;~
any-series 6
any-unit 7
</code></pre>
<p>Or if you think GROUP! looks better, which it kind of does:</p>
<pre><code>blank 1
integer 2
decimal 3
~(4)~
~(5)~
any-series 6
any-unit 7
</code></pre>
<p>This is where you see the value of the <strong><a href="https://rebol.metaeducation.com/t/embracing-a-useless-definition-of-to/2325">"useless" reversible TO scheme</a></strong> that I've been trying to drill in:</p>
<pre><code>&gt;&gt; to integer! unquasi first [~(4)~]
== 4
</code></pre>
<p>Comprende?</p>
<h2><a name="p-8035-anyway-back-to-the-main-point-2" class="anchor" href="https://rebol.metaeducation.com#p-8035-anyway-back-to-the-main-point-2"></a>Anyway, Back To The Main Point...</h2>
<p>The main point is that by exploring these little choices we can see that you don't just make the choice based on how things look.  Pushing values into the quasi or quoted band gives you a <em>useful orneryness</em>.</p>
<p>It's far too easy to get in situations where you don't know if what you have is a word or a string, and you check to see if they're equal and the code goes merrily along.</p>
<p>In fact... I sort of wonder if the difference between <strong><code>=</code></strong> and <strong><code>==</code></strong> should not be strictness per se, but that <strong><code>==</code></strong> will raise an error if the types you're comparing aren't identical.  Then you can TRY it to suppress the error, and get null, which is the result from inequality:</p>
<pre><code>&gt;&gt; "a" = &lt;a&gt;
== ~null~  ; anti

&gt;&gt; "a" == &lt;a&gt;
** Error: == requires compared types be the same, or use TRY

&gt;&gt; try "a" == &lt;a&gt;
== ~null~  ; anti
</code></pre>
<p>But what I started wondering was, is it useful to have an answer to the length of a WORD!?  Just because we can, should we, or does that risk more downstream misunderstanding when you typically don't want to take the length of a word, and can alias it as text if you need to?</p>
<pre><code>&gt;&gt; length of 'abc
== 3  ; we CAN, but should we?
</code></pre>
<p>I'd made it possible to do that, but I don't think that's a good idea.  Instead:</p>
<pre><code>&gt;&gt; length of as text! 'abc
== 3  ; if you need to do it, you can
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-word-answer-length-of-and-other-ponderings/2370">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-word-answer-length-of-and-other-ponderings/2370</link>
          <pubDate>Sun, 16 Mar 2025 22:19:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2370</guid>
          <source url="https://rebol.metaeducation.com/t/should-word-answer-length-of-and-other-ponderings/2370.rss">Should WORD! Answer LENGTH OF (and other ponderings)</source>
        </item>
        <item>
          <title>What&#39;s Up With That PERCENT! Datatype?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>So the PERCENT! datatype didn't exist in Rebol2:</p>
<pre><code>rebol2&gt;&gt; 10%
** Syntax Error: Invalid integer -- 10%
</code></pre>
<p>But it was added to R3-Alpha, and then included in Red.  Both of which seem to believe that percents are actually just a rendering of an equivalent decimal number, divided by 100:</p>
<pre><code>r3-alpha/red&gt;&gt; to percent! 10
== 1000%

r3-alpha/red&gt;&gt; to percent! 10.0
== 1000%

r3-alpha&gt;&gt; to decimal! 10%
== 0.1

red&gt;&gt; to float! 10%  ; Red calls decimal "float", but same difference
== 0.1
</code></pre>
<p>This shows a kind of mathematical invariant in R3-Alpha, e.g. that 10% will act like decimal 0.1 in math... so that's what it "is":</p>
<pre><code>r3-alpha&gt;&gt; 2 * 10%
== 0.2

r3-alpha&gt;&gt; 10% * 2
== 0.2
</code></pre>
<p>Red of course throws in a curve ball... it will either double the percent or apply it to the non-percent, depending on the order... <img src="https://rebol.metaeducation.com/images/emoji/twitter/roll_eyes.png?v=14" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></p>
<pre><code>red&gt;&gt; 10% * 2
== 20%

red&gt;&gt; 2 * 10%
== 0.2
</code></pre>
<p>How about some other math...?</p>
<pre><code>r3-alpha&gt;&gt; 10% * 10%
== 1.0000000000000002%

red&gt;&gt; 10% * 10%
== 1%

r3-alpha&gt;&gt; 10% + 2
== 2.1  ; same for 2 + 10%

red&gt;&gt; 10% + 2
== 210%

red&gt;&gt; 2 + 10%
== 2.1
</code></pre>
<h2><a name="p-8026-thoughts-on-that-to-conversion-1" class="anchor" href="https://rebol.metaeducation.com#p-8026-thoughts-on-that-to-conversion-1"></a>Thoughts On That TO Conversion</h2>
<p>One thing is that if we follow my "useless" reversible model of TO conversions <strong><code>to percent! 10</code></strong> should fairly clearly be 10%.</p>
<pre><code>&gt;&gt; to percent! 10
== 10%

&gt;&gt; to integer! 10%
== 10

&gt;&gt; to text! 10%
== "10"

&gt;&gt; to percent! "10"
== 10%

&gt;&gt; to block! 10%
== [10]
</code></pre>
<p><strong><a href="https://rebol.metaeducation.com/t/embracing-a-useless-definition-of-to/2325">I have explained why I have been promoting this perhaps-strange idea</a></strong>.  You get "if ten were a block, what would it look like"... "if ten were a percent, what would it look like"... with an emphasis on "look like".</p>
<p>Consider the challenge question: how would you turn a variable containing the integer 10 into 10% in R3-Alpha or Red today?</p>
<pre><code>red&gt;&gt; num: 10

red&gt;&gt; what-operation-here num 
== 10%
</code></pre>
<p>Your answers are things like:</p>
<pre><code>red&gt;&gt; to percent! num / 100
== 10%

red&gt;&gt; load rejoin [num "%"]
== 10%

red&gt;&gt; num * 1%
== 10%
</code></pre>
<p>But I think there should be an operation that just <em>does that</em>.  In the system I've described, TO seems to fill this need, in a way that you can predict.  Of course, that means TO is not the end-all be-all operation, and I've discussed how breaking operations out into things like JOIN and ROUND and FORM can step in for other intents.</p>
<p>One operation that might be an example of something that could fill in a gap here could be <strong><code>AS</code></strong>.  AS allows us to ask "what if the memory or guts of the thing we're looking at were viewed through a different lens"?</p>
<pre><code>&gt;&gt; as binary! "ABC"
== #{414243}

&gt;&gt; as text! #{414243}
== "ABC"

&gt;&gt; as decimal! 10%
== 0.1

&gt;&gt; as percent! 0.1
== 10%
</code></pre>
<p>It's one possibility of an operator that wouldn't be constrained by the equivalence classes of TO.</p>
<h2><a name="p-8026-what-about-that-math-2" class="anchor" href="https://rebol.metaeducation.com#p-8026-what-about-that-math-2"></a>What About That Math?</h2>
<p>Red's policy of making the result match the first operand feels confusing.  It seems easier if there's some pecking order of type promotions, and you get the same result regardless of order.  <em>(Of course, things like matrix multiplication throw a wrench in the idea that you can say multiplication is always commutative... so, exceptions exist.  Unless you do like Python and make matrix multiplication a separate operator, and reserve <code>*</code> for element-wise multiplication.)</em></p>
<p>Regarding picking behaviors: percent is a pretty strange situation, because there are of course different questions:</p>
<ul>
<li>What happens when you double 20% ?</li>
<li>What is 20% of 2?</li>
</ul>
<p>My default mindset would be to imagine that multiplying 20% times 2 is meant to double it, and produce 40% (which Red <em>half</em> agrees with).  If I expected to actually take 20% of 2, I wouldn't think it unreasonable to be asked to first convert the percent to a decimal...</p>
<pre><code>&gt;&gt; 20% * 2
== 40%

&gt;&gt; 2 * 20%
== 40%

&gt;&gt; (as decimal! 20%) * 2
== 0.4

&gt;&gt; 2 * (as decimal 20%)
== 0.4
</code></pre>
<p>Furthermore...from a perspective of dimensional analysis, I would say you shouldn't be able to do things like:</p>
<pre><code>&gt;&gt; 20% + 1
** Error: Can't add PERCENT! and INTEGER!
</code></pre>
<p>But if you <em>could</em> do it, I would probably lean to it being more generally useful to give back 21% than 120%...which seems to be a behavior straight out of the annals of improbable usefulness.</p>
<p><strong>I don't really use the percent type, but it seems to me there's simply too much guessing what people want out of it.</strong>  I imagine that it best serves its purpose as just kind of a source-level lexical convenience, and your code has to decide when it wants to convert it to a decimal for the purposes of some kind of measurement.</p>
<p>Red's first answer here makes sense to me, the second does not--I don't see the order as distinguishing "give me half of 10 percent" and the second "give me 10% of 0.5":</p>
<pre><code>red&gt;&gt; 10% * 0.5
== 5%

red&gt;&gt; 0.5 * 10%
== 0.05
</code></pre>
<p><strong>So my plan is to pretty much pare down the percent type to bare bones, try to make the math commutative, and favor the idea that you have to explicitly convert a percentage to a decimal to get it to behave like a decimal... probably via the AS operator, doing the TO operator as described.</strong></p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/whats-up-with-that-percent-datatype/2368">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/whats-up-with-that-percent-datatype/2368</link>
          <pubDate>Fri, 07 Mar 2025 06:32:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2368</guid>
          <source url="https://rebol.metaeducation.com/t/whats-up-with-that-percent-datatype/2368.rss">What&#39;s Up With That PERCENT! Datatype?</source>
        </item>
        <item>
          <title>TAG!s Angle Brackets: *They Aren&#39;t There!*</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Implementation-wise, the delimiters of tag have been quite the thorn.</p>
<p>Are they there or not?</p>
<p>In Rebol2, Red, R3-Alpha...</p>
<pre><code>&gt;&gt; find &lt;abcd&gt; "c"
== &lt;cd&gt;

&gt;&gt; find &lt;abcd&gt; "&gt;"
== none
</code></pre>
<p>Not there!</p>
<p>Or are they?  Reverse the arguments, and in Rebol2 and Red, they seem to magically appear:</p>
<pre><code>&gt;&gt; find "ab&lt;c&gt;d" &lt;c&gt;
== "&lt;c&gt;d"
</code></pre>
<p>But... this was not the case in R3-Alpha...</p>
<pre><code>r3-alpha&gt;&gt; find "abcd" &lt;c&gt;
== "cd"

r3-alpha&gt;&gt; find "ab&lt;c&gt;d" &lt;c&gt;
== "c&gt;d"
</code></pre>
<p>I know things have gone back and forth with people believing deeply in their little hearts that they are happier when routines act like the delimiters are there...</p>
<p>But for the baseline behavior: <em>I have come to believe R3-Alpha is right.</em>  They're string delimiters, and incidental to the default purpose, just as quotes are.</p>
<p>If you start looking at TAG! as it truly is--just another string class with different delimiters--it simplifies the mental model and the implementation model.  You can truly just use it like another string, and it suddenly becomes consistent.</p>
<p>Of course, it's still nice to be able to match the molded form of a tag.</p>
<p>But... why stop at tags? <img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"> Why not have a syntax to match the molded form of anything?</p>
<p>In strings, where you can't match list elements literally anyway:</p>
<pre><code>&gt;&gt; parse "&lt;a&gt; 100 (b c)" ['&lt;a&gt; space '100 space '(b c)]
== (b c)
</code></pre>
<p>(The synthesized product may be more interesting, too.  As a reminder, Ren-C has taken words that might be better as variable names like END and uses plain tag as  instead, or  to synthesize the parse input, etc.)</p>
<pre><code>&gt;&gt; parse "&lt;end&gt; asdf" ['&lt;end&gt; to &lt;end&gt; &lt;input&gt;]
== "&lt;end&gt; asdf"
</code></pre>
<p>I don't know whether that is best done as just a PARSE feature, or if quoted things need to be searched for literally by FIND.</p>
<pre><code>&gt;&gt; find "ab&lt;c&gt;d" &lt;c&gt;
== "c&gt;d"

&gt;&gt; quote &lt;c&gt;
== '&lt;c&gt;

&gt;&gt; find "ab&lt;c&gt;d" quote &lt;c&gt;
== "&lt;c&gt;d"

&gt;&gt; find "ab&lt;c&gt;d" mold &lt;c&gt;  ; one fewer character
== "&lt;c&gt;d"
</code></pre>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/tag-s-angle-brackets-they-arent-there/2326">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/tag-s-angle-brackets-they-arent-there/2326</link>
          <pubDate>Fri, 08 Nov 2024 18:12:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2326</guid>
          <source url="https://rebol.metaeducation.com/t/tag-s-angle-brackets-they-arent-there/2326.rss">TAG!s Angle Brackets: *They Aren&#39;t There!*</source>
        </item>
        <item>
          <title>Old Idea Revisited: DATATYPE as... Antiform?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>I've been suffering through an attempt to bring sanity to bear upon the MAKE and TO matrix.</p>
<p>While doing so, I noticed that there are a lot of MAKE instructions that do "joining".</p>
<p>In R3-Alpha and Red:</p>
<pre><code>&gt;&gt; make binary! [1 2 #{DECAFBAD} 3 4]   
== #{0102DECAFBAD0304}
</code></pre>
<p>Historical MAKE is so arbitrary in how it interprets its arguments that it made me feel that it would be better if JOIN allowed a datatype as its first argument...</p>
<p>JOIN typically makes a new series out of what you give it:</p>
<pre><code>&gt;&gt; bin: #{AABB}

&gt;&gt; join bin #{CCDD}
== #{AABBCCDD}  ; made new series, didn't impact BIN

&gt;&gt; bin
== #{AABB}
</code></pre>
<p>But if you could pass a datatype as the first argument, you could relieve MAKE of the behavior...and make it clearer in the source what's actually happening:</p>
<pre><code>&gt;&gt; join binary! [1 2 #{DECAFBAD} 3 4]
== #{0102DECAFBAD0304}
</code></pre>
<p>Since that seemed nice, I started to map it out, and ran into a bit of a problem:</p>
<p><strong>If "datatypes" are an ANY-WORD! or ANY-LIST! or anything like that, how do you know you're not trying to JOIN with it?</strong></p>
<p>A WORD! should be able to join:</p>
<pre><code>&gt;&gt; join 'var 10
== var10
</code></pre>
<p>A BLOCK! should be able to join... though possibly only with blocks that it reduces <em>(devil's in the details as to why, beyond the scope of what I'm talking about right now)</em>...</p>
<pre><code>&gt;&gt; join [a b] [1000 + 20]
== [a b 1020]
</code></pre>
<p>Okay, but when you say <strong>join binary!</strong> what is BINARY!?  Well right now, it's:</p>
<pre><code>&gt;&gt; binary!
== &amp;[binary]
</code></pre>
<p>Well that looks like it's in-band for the kinds of things JOIN operates on:</p>
<pre><code>&gt;&gt; join &amp;[binary] [1000 + 20]
== &amp;[binary 1020]
</code></pre>
<h2><a name="p-7875-an-antiform-would-push-datatype-out-of-band-1" class="anchor" href="https://rebol.metaeducation.com#p-7875-an-antiform-would-push-datatype-out-of-band-1"></a>An Antiform Would Push DATATYPE? Out-Of-Band...</h2>
<p>It's possible that we could come up with a new non-antiform for types.  But the lexical space is extremely saturated.</p>
<p>If we were just reaching for something on the basis of looks, antiform FENCE! is nice:</p>
<pre><code>&gt;&gt; binary!
== ~{binary!}~  ; anti
</code></pre>
<hr>
<p><strong>UPDATE:</strong> <a class="mention" href="https://rebol.metaeducation.com/u/blackattr">@BlackATTR</a> and I believe the exclamation point is probably best as part of the contents.  If you're turning a datatype into a word, the only reason you're doing it is to present to a programmer.  This lines up with history:</p>
<pre><code>red&gt;&gt; to word! integer!
== integer!

rebol2&gt;&gt; to word! integer!
== integer!
</code></pre>
<hr>
<h2><a name="p-7875-this-has-come-up-before-in-2022httpsrebolmetaeducationcomtwhat-if-datatype-was-isotopic1982-2" class="anchor" href="https://rebol.metaeducation.com#p-7875-this-has-come-up-before-in-2022httpsrebolmetaeducationcomtwhat-if-datatype-was-isotopic1982-2"></a><a href="https://rebol.metaeducation.com/t/what-if-datatype-was-isotopic/1982">This Has Come Up Before... (in 2022)</a></h2>
<p>Historical Rebol let you use datatypes in FIND:</p>
<pre><code>rebol2&gt;&gt; find [a b c 10 20] integer! 
== [10 20]
</code></pre>
<p>But then this conflates with when you actually literally have the INTEGER! datatype in the block.</p>
<pre><code>&gt;&gt; find compose [a (integer!) b c 10 20] integer!
== [integer! b c 10 20]
</code></pre>
<p>So in the early days of antiforms, I proposed antiform datatypes as a solution... but at that time I was thinking that there'd be non-antiform DATATYPE!, and it's just that when it was an antiform it would be a "MATCHER".</p>
<p><strong>The proposal I'm thinking of now is different, in saying that DATATYPE? only exists as a (stable) antiform state.</strong></p>
<p>There are tradeoffs, in that datatypes can't be put in blocks directly.  But the mechanics of working with quasiforms and antiforms via things like REIFY and DEGRADE are much smoother now.  And really, putting datatypes in blocks doesn't happen that often (I've had to put splices in blocks...and they're antiforms... but really never datatypes).</p>
<p><strong>Being completely out of band with things you can find in a block has advantages.</strong>  JOIN isn't unique in reaping benefits from being able to say that datatypes aren't "things".</p>
<p>And it unifies datatypes with typecheckers being antiforms, because typecheckers are frame antiforms, e.g. actions:</p>
<pre><code>&gt;&gt; find [1 3 5 8 10] even?/
; first in pack of length 2
== [8 10]
</code></pre>
<p>So I don't think it's a crazy idea.</p>
<p>I'm hesitant to surrender FENCE! antiforms to the purpose so soon after their invention.  But there isn't anything undecorated left.</p>
<p>Not that "no decorated antiforms" is some unbreakable rule, it was a guideline.</p>
<p>Using &amp; would put it in the family of TYPE-XXX! and be cheaper than FENCE! if you made new instances:</p>
<pre><code>&gt;&gt; binary!
== ~&amp;binary!~  ; anti
</code></pre>
<p>A random bad idea would be to make them keywords, and just have DATATYPE? be smart enough to filter out ~null~ or ~void~ or ~okay~ or whatever else (the symbol could carry a flag)</p>
<pre><code>&gt;&gt; binary!
== ~binary!~  ; anti

&gt;&gt; null
== ~null~  ; anti

&gt;&gt; datatype? binary!
== ~okay~  ; anti

&gt;&gt; datatype? null
== ~null~  ; anti
</code></pre>
<p>I can pretty clearly say that's bad.</p>
<h2><a name="p-7875-or-pick-some-non-antiform-notation-3" class="anchor" href="https://rebol.metaeducation.com#p-7875-or-pick-some-non-antiform-notation-3"></a>Or, Pick Some Non-Antiform Notation</h2>
<p>Status quo might look like:</p>
<pre><code>&gt;&gt; binary!
== #[binary!]
</code></pre>
<p>Despite it looking sort of like a block, it wouldn't be.  But we're squandering some of our notational space no matter what.  The <strong><code>~&amp;type!~</code></strong> is the discount route.</p>
<h2><a name="p-7875-either-way-datatype-cant-be-any-word-or-any-list-4" class="anchor" href="https://rebol.metaeducation.com#p-7875-either-way-datatype-cant-be-any-word-or-any-list-4"></a>Either Way, DATATYPE? Can't be ANY-WORD! or ANY-LIST!</h2>
<p>It needs to be out of band one way or another.  I'll have to think about it.</p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324</link>
          <pubDate>Fri, 08 Nov 2024 17:05:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2324</guid>
          <source url="https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324.rss">Old Idea Revisited: DATATYPE as... Antiform?</source>
        </item>
        <item>
          <title>What Should &quot;New Refinements&quot; (e.g. :FOO) Evaluate To?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>At one point I thought "new refinements" had a dialected purpose in APPLY to name the frame fields:</p>
<pre><code>call:shell // [  ; infix APPLY
    [(system.options.boot) --suppress {"*"} print.reb 100]

    :input 'none      ; pipe input from /dev/null
    :output data: ""  ; write output to string
]
</code></pre>
<p>That's a bit contentious with other evaluative purposes.</p>
<p>But eventually I decided that was not as good as using plain SET-WORD.  This requires you to put any random arbitrary assignments in GROUP!s, which is its own "contention", but not so much of a burden:</p>
<pre><code>call:shell // [  ; infix APPLY
    [(system.options.boot) --suppress {"*"} print.reb 100]

    input: 'none      ; pipe input from /dev/null
    output: (data: "")  ; write output to string
]
</code></pre>
<p>It looks better, and fits with the already established modality of "assignment".</p>
<h2><a name="p-7781-so-foo-is-free-for-other-meanings-1" class="anchor" href="https://rebol.metaeducation.com#p-7781-so-foo-is-free-for-other-meanings-1"></a>So :FOO Is Free For Other Meanings</h2>
<p>What should those meanings be?</p>
<p>Ideally it would make some sense with the usage of leading colon for refinements.</p>
<p>In the past, <strong><code>:[...]</code></strong> was able to mean REDUCE.  That was semi-useful, but it didn't get used as much as I might have thought.</p>
<p>Leaving these forms free and open <a href="https://rebol.metaeducation.com/t/evaluator-hooking-rebindablesyntax/2443">for the user to redefine with RebindableSyntax</a> is another possibility.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/what-should-new-refinements-e-g-foo-evaluate-to/2299">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/what-should-new-refinements-e-g-foo-evaluate-to/2299</link>
          <pubDate>Fri, 27 Sep 2024 18:11:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2299</guid>
          <source url="https://rebol.metaeducation.com/t/what-should-new-refinements-e-g-foo-evaluate-to/2299.rss">What Should &quot;New Refinements&quot; (e.g. :FOO) Evaluate To?</source>
        </item>
        <item>
          <title>Typechecking Quoted forms / Quasiforms / Antiforms</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Asking questions about antiforms can be a bit tricky.</p>
<p>If you have a lifted result that contains something that might be a pack, you'd have to say:</p>
<pre><code>if pack? unlift result' [...]
</code></pre>
<p>But you're just asking a question.  What if it contained a lift of an ERROR! antiform?  Should PACK? be willing to accept ERROR! ? If not, that would cause an abrupt failure.</p>
<p>To dodge the need to do an UNLIFT, you could say:</p>
<pre><code>all [
    quasiform? result'
    block! = heart of result'
] then [
   ...
]
</code></pre>
<p>And via such a mechanism, you could write a function LIFTED-PACK? that would not fail on LIFTED-ERROR!:</p>
<pre><code>if lifted-pack? result' [...]
</code></pre>
<p>That has the nice feature of not forcing you to perform an UNLIFT just to answer the question.  You can narrowly ask "is this a lifted pack".</p>
<p>But I think such things need to be in the box.  This question gets asked a lot, and I'm tired of asking it as the ugly and breakable <strong><code>pack? unlift</code></strong>.</p>
<h2><a name="p-7764-what-if-typecheck-functions-had-a-lifted-refinement-1" class="anchor" href="https://rebol.metaeducation.com#p-7764-what-if-typecheck-functions-had-a-lifted-refinement-1"></a>What If Typecheck Functions Had a :LIFTED refinement...?</h2>
<p>It doesn't seem like clogging up the namespace with more functions makes a lot of sense, so we might offer a refinement:</p>
<pre><code>if pack?:lifted result' [...]
</code></pre>
<p>We could put a question mark on the refinement as well <img src="https://rebol.metaeducation.com/images/emoji/twitter/face_with_diagonal_mouth.png?v=14" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20"></p>
<pre><code>if pack?:lifted? result' [...]
</code></pre>
<p>Okay, no, we won't do that.</p>
<p>I kind of feel like putting the LIFTED after makes it unclear.  You'd read it like <strong>pack? lift result'</strong>.  Does that mean it should just be UNLIFT?</p>
<pre><code>if pack?:unlift result' [...]
</code></pre>
<p>But at that point, people are probably not going to generally know what the difference is between that and <strong><code>pack? unlift result</code></strong></p>
<p>None of this is as good as simply <strong><code>lifted-pack?</code></strong>.  But we don't want to generate new words for every possible thing (and questions like <strong><code>lifted-integer?</code></strong> are equally legitimate...)</p>
<h2><a name="p-7764-what-about-arbitrary-chain-interpretation-2" class="anchor" href="https://rebol.metaeducation.com#p-7764-what-about-arbitrary-chain-interpretation-2"></a>What About Arbitrary CHAIN! Interpretation?</h2>
<p>Let's forget for a moment about the existing refinements to LIFTED and QUASI.  What if they--as functions--were willing to <em>take other functions as a refinement</em>?</p>
<pre><code>if lifted:pack? result' [...]
</code></pre>
<p>This could be a general pattern of solution...</p>
<pre><code>if (quasi:group? first [~(a b c)~]) [...]

if (quote:word? first ['a b c:]) [...]  ; or quoted:word?
</code></pre>
<p>How would it work?  Well, I guess the basic idea would be that it would do a processing step on the argument before typechecking it and passing it to the constraint function.</p>
<p>So <strong><code>quoted:word?</code></strong> would run QUOTED, and it would be able to inspect the chain as containing WORD?.</p>
<ul>
<li>
<p>If it was passed something like <strong><code>&lt;foo&gt;</code></strong> it would say "I don't even have to ask, that's not a quoted anything".</p>
</li>
<li>
<p>If it was something like <strong><code>'&lt;foo&gt;</code></strong> it would say "okay that's quoted, I need to ask" and it would unquote the thing before passing it to WORD?, which would come back false.</p>
</li>
<li>
<p>If it was <strong><code>'bar</code></strong> it would do the same thing but this time WORD? would return true.</p>
</li>
</ul>
<p><em>It feels a little bit ad-hoc, but the ergonomics are certainly there.</em>  This would be tremendously useful and could create new and useful type constraints.  It's literate... and <strong><code>lifted:pack?</code></strong> is going to look better in type specs than <strong><code>lifted/pack?</code></strong></p>
<p>Not only that, but <a href="https://rebol.metaeducation.com/t/intrinsics-functions-without-frames/2050">recognizing <strong>"intrinsics"</strong> in the chain</a> would mean this could be relatively fast--faster than <strong><code>pack? unlift</code></strong> could be.</p>
<h2><a name="p-7764-what-about-refinements-like-liftlitehttpsrebolmetaeducationcomtmeta-lite-when-you-dont-want-quasiforms2296-3" class="anchor" href="https://rebol.metaeducation.com#p-7764-what-about-refinements-like-liftlitehttpsrebolmetaeducationcomtmeta-lite-when-you-dont-want-quasiforms2296-3"></a>What About Refinements Like <a href="https://rebol.metaeducation.com/t/meta-lite-when-you-dont-want-quasiforms/2296"><code>LIFT:LITE</code></a></h2>
<p>Let's say there's a single-arity logic-bearing function someone makes called LITE, and they get mad that LIFT:LITE doesn't call it to do a meta version of that test.</p>
<p>I don't know that I care a ton about that.  We have situations in PARSE where you might have a variable named ACROSS and it will ignore that variable if there's a keyword called ACROSS.  You have to escape your words when they run up against reserved dialect words.</p>
<p>So I guess you'd wind up with something like:</p>
<pre><code> if lifted:(lite/) [...]
</code></pre>
<p>Otherwise the keyword would win.</p>
<h2><a name="p-7764-what-about-cascading-the-functions-4" class="anchor" href="https://rebol.metaeducation.com#p-7764-what-about-cascading-the-functions-4"></a>What About Cascading The Functions?</h2>
<pre><code>if (quoted:quoted:quasi:block? first [''~[a b c]~]) [...]
</code></pre>
<p>Well I guess that could work if the rule was that if you used a function name as a refinement, that function would receive all the refinements after it.  Applying that recursively you'd get something that works.</p>
<p>There could be an optimization that functions like QUOTED would detect when the functions in the chain were ones they recognized, and they could do something optimal.</p>
<h2><a name="p-7764-does-any-of-this-solve-the-unlift-problem-5" class="anchor" href="https://rebol.metaeducation.com#p-7764-does-any-of-this-solve-the-unlift-problem-5"></a>Does Any Of This Solve The UNLIFT Problem?</h2>
<p>It's nice syntax, but remember the original issue...where you have a lifted-error-antiform, and you want to test it to see if it is or isn't a lifted pack:</p>
<pre><code>if pack? unlift result' [...]
</code></pre>
<p>I'm talking about redoing that:</p>
<pre><code>if lift:pack? result' [...]
</code></pre>
<p>But if LIFTED is unlift'ing its argument, and passing it to PACK?, does that still have the same problem?</p>
<p>It doesn't have to.  LIFTED would see that the result is a quasiform, hence a candidate for any function to ask... then it needs to typecheck against what PACK? takes.  But if that typecheck fails, there's no need to raise the error.  You can just say "no, it's not a lifted pack".  Done.</p>
<h2><a name="p-7764-are-there-less-wacky-ways-to-do-it-6" class="anchor" href="https://rebol.metaeducation.com#p-7764-are-there-less-wacky-ways-to-do-it-6"></a>Are There Less Wacky Ways To Do It?</h2>
<p>I dunno.  It's admittedly a bit weird to put that much overloading on words like LIFT and QUASI.  Their type signatures stop making sense (returning LOGIC?...sometimes?)</p>
<p>The overloading could be reduced if the weird modifiers were QUOTED, LIFTED, and QUASID.  :-/</p>
<pre><code>if quasid:pack? result' [...]
</code></pre>
<p>Errr, no.  Didn't come this far to write things that look like garbage.</p>
<p>But oddly, quoted:xxx? looks better than quote:xxx?... does that suggest the operator should be called QUOTED too?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<pre><code>&gt;&gt; quoted 1 + 2
== '3
</code></pre>
<p>I've seen it as QUOTE for so long that it's hard to frame it.  It doesn't look <em>terrible</em>, and when you put them side by side the brevity has an advantage:</p>
<pre><code>if (quoted:quoted:quasi:block? first [''~[a b c]~]) [...]

if (quote:quote:quasi:block? first [''~[a b c]~]) [...]
</code></pre>
<p>To say that <strong><code>'a</code></strong> is a QUOTE-WORD! is a little bit caveman-ish, but better than calling it a LIT-WORD!, and it takes one less syllable to say "is a quote word" than to say "is a quote-uhd word".</p>
<p>Looking at it in that light, it's growing on me to dumb it down.  Maybe not in all circumstances.  Perhaps it could be left as a matter of taste with QUOTED and QUOTE being synonyms... like FUNC and FUNCTION, use whichever you want.</p>
<h2><a name="p-7764-i-think-this-is-a-direction-worth-pursuing-7" class="anchor" href="https://rebol.metaeducation.com#p-7764-i-think-this-is-a-direction-worth-pursuing-7"></a>I Think This Is A Direction Worth Pursuing</h2>
<p>I've been looking for an answer to this question, and haven't thought of anything this good before.</p>
<p>Don't have a complete design for the "customized refinement dialect", but I can do some prototyping...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/typechecking-quoted-forms-quasiforms-antiforms/2298">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/typechecking-quoted-forms-quasiforms-antiforms/2298</link>
          <pubDate>Tue, 24 Sep 2024 00:16:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2298</guid>
          <source url="https://rebol.metaeducation.com/t/typechecking-quoted-forms-quasiforms-antiforms/2298.rss">Typechecking Quoted forms / Quasiforms / Antiforms</source>
        </item>
        <item>
          <title>Syntax for Typechecked Values</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>One of the things you can do with <a href="https://rebol.metaeducation.com/t/a-dream-for-debugging-generalized-accessors/2259">Generalized Accessors</a>, is that assignments to any value can be typechecked.  You get this "for free" because accessors pair a function with a variable slot, and that function can use typechecking:</p>
<p>Writing the accessor boilerplate is laborious...</p>
<pre><code>checked: accessor lambda [^:value [your! types! here!] &lt;static&gt; actual] [
    either value [actual: value.] [actual.]  ; terminal dot allows unset vars
]
</code></pre>
<p>If you want to be truly generic and support storing actions in the variable, you need slashes:</p>
<pre><code>checked: accessor lambda [^:/value [your! types! here!] &lt;static&gt; actual] [
    either value [/actual: value.] [actual.]
]
</code></pre>
<p>Not only is that a nuisance to get typechecking, it's also not native code, so you're running that EITHER and its branches.</p>
<p>So we could make it a feature of ACCESSOR, maybe just when you give it a block...and it could do a particularly cheap and special form.  I think this is actually the right way to go about it... it would put a "pairing" cell in the variable's location, which would pair up the stored value with a PARAMETER! (which does preoptimized calculations on the typeset:</p>
<pre><code>checked: accessor [your! types! here!]
checked: initial-value
</code></pre>
<p>That's all fine and good but seems we need a shorter way to say it...that doesn't repeat the variable name and doesn't have to say ACCESSOR.</p>
<p>We want whatever this is to still get collected as a SET-WORD! (if it is one), so this probably has to be something like:</p>
<pre><code>checked: typed [your! types! here!] initial-value
</code></pre>
<p>I don't hate it.  Alternate ideas?</p>
<h2><a name="p-7594-interaction-with-syntax-for-locals-1" class="anchor" href="https://rebol.metaeducation.com#p-7594-interaction-with-syntax-for-locals-1"></a>Interaction With Syntax For Locals</h2>
<p>This would now be able to work:</p>
<pre><code>foo: func [x [text!] &lt;local&gt; y [integer!]] [...]
</code></pre>
<p>This would need to be lenient in terms of letting the Y be unset prior to its first assignment.  So it can contain nothing at the outset, but any future assignments have to assign integers.</p>
<p>But this would get a bit of a problem if we want to mix it with a form that lets you assign the local:</p>
<pre><code>foo: func [x [text!] &lt;local&gt; y: [integer!]] [...]
</code></pre>
<p>That would give you Y with the BLOCK! [integer!] in it.  You'd have to say:</p>
<pre><code>foo: func [x [text!] &lt;local&gt; y: typed [integer!] 10] [...]
</code></pre>
<p>We could keep the historical "groups to initialize" idea</p>
<pre><code>foo: func [x [text!] &lt;local&gt; y (10)] [...]  ; not typechecked

foo: func [x [text!] &lt;local&gt; y [integer!] (10)] [...]  ; typechecked
</code></pre>
<p>And maybe the idea of making a place to put the type constraints vindicates that syntax for this context.</p>
<p><strong>Typechecking will slow down the code.</strong>  But it would be running through the same checking mechanisms that functions use.  As that code got better, so would this.</p>
<p>There could be some sort of "enable typechecking only in debug mode" property of functions where you could turn it on or off.</p>
            <p><small>12 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/syntax-for-typechecked-values/2260">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/syntax-for-typechecked-values/2260</link>
          <pubDate>Sun, 08 Sep 2024 00:45:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2260</guid>
          <source url="https://rebol.metaeducation.com/t/syntax-for-typechecked-values/2260.rss">Syntax for Typechecked Values</source>
        </item>
        <item>
          <title>True, False, On, Off, Yes, No...?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p><em><strong>UPDATE:</strong> This thread led to the conclusion to not treat ON, OFF, YES, NO as synonyms for TRUE and FALSE, but instead rethink the paradigm as what we are calling <strong><a href="https://rebol.metaeducation.com/t/flexible-logic-system-terminology/2252">"Flexible Logic"</a></strong>.  In this system, plain WORD!s are used to represent boolean states that indiscriminately take branches in things like IF...and NULL is the only state that inhibits branching.</em></p>
<hr>
<p>Historical Rebol does this definition:</p>
<pre><code>on:  true
off: false
yes: true
no:  false
</code></pre>
<p>And Red carried it forward.  Whether it's good or bad, I don't know (my instinct is to say bad).  I do know that it's lossy.</p>
<pre><code>red&gt;&gt; on
== true  ; not a word, but a misleading display of #[true]
</code></pre>
<p>Ren-C has the opportunity to do something different.</p>
<pre><code>&gt;&gt; on: ~on~
== ~on~  ; anti

&gt;&gt; off: ~off~
== ~off~  ; anti

&gt;&gt; yes: ~yes~
== ~yes~  ; anti

&gt;&gt; no: ~no~
== ~no~  ; anti
</code></pre>
<p>And then these WORD! antiforms could be treated as truthy and falsey as appropriate.  Negation could preserve the form:</p>
<pre><code>&gt;&gt; not yes
== ~no~ ; anti
</code></pre>
<p>Does it have value?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20">  Well, my instincts are that if there is any value to have in defining these, that value arises from having them be differently-typed logic-like things.  e.g. a function that took ON and OFF would <em>not</em> take YES and NO.</p>
<pre><code>&gt;&gt; security-system on
The security system is now activated.

&gt;&gt; security-system false
** Error: What are you talking about?
</code></pre>
<h2><a name="p-7560-does-this-buy-you-anything-1" class="anchor" href="https://rebol.metaeducation.com#p-7560-does-this-buy-you-anything-1"></a>Does This Buy You Anything?</h2>
<p>What you get here is a little bit of friction on the callsite if your decision comes direct from math:</p>
<pre><code>&gt;&gt; security-system (user = 'Ron)
** Error: security-system requires TOGGLE! as enable argument, not ~true~
</code></pre>
<p>So you have to write something more laborious:</p>
<pre><code>&gt;&gt; security-system (either user = 'Ron [on] [off])
The security system is now activated.
</code></pre>
<p>At which point you might ask what the advantage is here over just using the words ON and OFF.</p>
<p>The advantages I see are:</p>
<ul>
<li>
<p>Callsite doesn't have to quote ON and OFF like <code>(either user = 'Ron ['on] ['off])</code></p>
</li>
<li>
<p>Once arguments are received, callee can use conditionals like IF and CASE and such directly:</p>
<pre><code>if enable [...]
</code></pre>
<p>...instead of...</p>
<pre><code>if enable = 'on [...]
</code></pre>
</li>
<li>
<p>You preserve the semantically correct word in the antiform, so you can see it in that form in debug output, and generalized print routines can extract them, e.g. TO WORD! gets you the word you want instead of just TRUE and FALSE</p>
</li>
<li>
<p>You're letting people guide the callsites to use clearer terms with some amount of enforcement, instead of permitting yes and true where ON is intended</p>
</li>
<li>
<p>FWIW the words are shorter.  <strong>false</strong> is 5 letters while <strong>no</strong> is just 2</p>
</li>
</ul>
<h2><a name="p-7560-how-valuable-is-it-2" class="anchor" href="https://rebol.metaeducation.com#p-7560-how-valuable-is-it-2"></a>How Valuable Is It?</h2>
<p>Infinitely moreso than just defining them to true and false.  (Mostly because any amount is more useful than zero.)</p>
<p>I started this out as devil's advocacy, but I think I've actually talked myself into it.  It's pretty cool.</p>
<h2><a name="p-7560-naming-the-types-3" class="anchor" href="https://rebol.metaeducation.com#p-7560-naming-the-types-3"></a>Naming The Types</h2>
<p>Uh, YES-NO? and ON-OFF? kind of suck, like calling logic TRUE-FALSE? would suck.  But they're clear.</p>
<p>I asked Claude for thoughts:</p>
<blockquote>
<p>These are some interesting ideas for expanding the concept of boolean types. Let's break down the potential names and rationales:</p>
<ol>
<li>
<p>BOOLEAN! or LOGIC! for TRUE/FALSE</p>
<ul>
<li>This is the standard name, representing traditional boolean logic.</li>
</ul>
</li>
<li>
<p>SWITCH! or TOGGLE! for ON/OFF</p>
<ul>
<li>
<p>These names capture the idea of a binary state that can be flipped.</p>
</li>
<li>
<p>SWITCH! might be slightly more intuitive as it's commonly used in programming and everyday language.</p>
</li>
</ul>
</li>
<li>
<p>CONFIRM! or RESPONSE! for YES/NO</p>
<ul>
<li>
<p>CONFIRM! does indeed capture the essence of affirmation or negation.</p>
</li>
<li>
<p>RESPONSE! could work too, as it implies an answer to a question.</p>
</li>
</ul>
</li>
</ol>
<p>Your suggestion of YES-NO! and ON-OFF! as type names is also valid, though they might be less conventional in programming language design.</p>
<p>The key aspect of your proposal is that these types, while similar in their binary nature, are distinct and not interchangeable. This could lead to more precise and context-specific code, but it might also increase complexity.</p>
</blockquote>
<p>I like <strong>[TOGGLE?]</strong> and <strong>[CONFIRM?]</strong></p>
<p>But your type check can use quasiforms as a proxy for antiforms, e.g. <strong>[~yes~ ~no~]</strong>, and that may be about as clear.</p>
            <p><small>7 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/true-false-on-off-yes-no/2250">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/true-false-on-off-yes-no/2250</link>
          <pubDate>Wed, 04 Sep 2024 10:38:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2250</guid>
          <source url="https://rebol.metaeducation.com/t/true-false-on-off-yes-no/2250.rss">True, False, On, Off, Yes, No...?</source>
        </item>
        <item>
          <title>Introducing:The:New:CHAIN!:Datatype</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>As part of a <a href="https://rebol.metaeducation.com/t/big-alien-proposal-word-runs-functions/1905/13">giant overhaul of function application</a>, we're getting rid of SET-XXX! and GET-XXX! as fundamental types.  Instead, we'll have a new sequence that's like PATH! and TUPLE!...except that uses the colon character as its interstitial delimiter.</p>
<h2><a name="p-7445-thesewill-be1020called-chain-1" class="anchor" href="https://rebol.metaeducation.com#p-7445-thesewill-be1020called-chain-1"></a><code>these:&lt;will be&gt;:1020:"called CHAIN!"</code></h2>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/alien.png?v=14" title=":alien:" class="emoji only-emoji" alt=":alien:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-7445-three-is-a-magic-numberhttpsyoutubej8lrkcw2_pkt21-2" class="anchor" href="https://rebol.metaeducation.com#p-7445-three-is-a-magic-numberhttpsyoutubej8lrkcw2_pkt21-2"></a><a href="https://youtu.be/J8lRKCw2_Pk?t=21"><img src="https://rebol.metaeducation.com/images/emoji/twitter/three.png?v=14" title=":three:" class="emoji" alt=":three:" loading="lazy" width="20" height="20">  is a magic number.</a></h2>
<p>It gives us a nice symmetry of having three ANY-LIST! types, and three ANY-SEQUENCE! types</p>
<ul>
<li>
<p><strong><code>[BLOCK!] (GROUP!) {FENCE!}</code></strong></p>
</li>
<li>
<p><strong><code>/PATH!/ .TUPLE!. :CHAIN!:</code></strong></p>
</li>
</ul>
<h2><a name="p-7445-chain-is-higher-precedence-than-tuple-lower-than-path-3" class="anchor" href="https://rebol.metaeducation.com#p-7445-chain-is-higher-precedence-than-tuple-lower-than-path-3"></a>CHAIN! is Higher Precedence Than TUPLE!, Lower Than PATH!</h2>
<p>Pleasingly, the hierarchy of the interstitials is in accordance with their "heft"... <strong><code>/</code></strong> is heftier than <strong><code>:</code></strong> which is heftier than <strong><code>.</code></strong></p>
<pre><code> foo/bar.baz:mumble:frotz
</code></pre>
<p>...that would be a 2-element PATH! with a 3-element CHAIN! in the second position that has a 2-element TUPLE! in its first position.</p>
<h2><a name="p-7445-and-will-no-longer-be-sigil-4" class="anchor" href="https://rebol.metaeducation.com#p-7445-and-will-no-longer-be-sigil-4"></a><code>::</code> and <code>:</code> Will No Longer be SIGIL!</h2>
<p>This means sequences of all colons will be WORD!s, like <code>[/ // /// etc]</code> and <code>[. .. ... etc]</code></p>
<p>It was perhaps a bit suspicious that colons could appear on the beginning of a word or the end of the word.  That makes it seem more like an interstitial sequencing character than a SIGIL!</p>
<p>This means that you can put SIGILs on chains, including the trivial chains <strong><code>@:word</code></strong> or <strong><code>$(group):</code></strong> which previously needed two cells, e.g. <strong><code>(@ :word)</code></strong> or <strong><code>($ '(set-group):)</code></strong>.</p>
<ul>
<li>
<p>Looks tighter, evaluates faster, and you don't have to quote evaluative things</p>
</li>
<li>
<p>You can communicate more information with the single value if it can carry the sigil along</p>
</li>
</ul>
<h2><a name="p-7445-notationally-competes-with-time-5" class="anchor" href="https://rebol.metaeducation.com#p-7445-notationally-competes-with-time-5"></a>Notationally Competes with TIME!</h2>
<p>We have to decide what <strong><code>10:20</code></strong> is.</p>
<p>When a parallel problem happened with <strong>1.2</strong> needing to be either DECIMAL! or TUPLE!, the decision was to make it a DECIMAL!.  So maybe CHAIN! reserves cases where numbers are at the head for other types?</p>
<p>But it's a shame because it seems this is made for dialecting on much more interesting level:</p>
<pre><code>for x 1:10 [print x]

for x 1:(end) [print x]

for x (start):10 [print x]

for x 0:10/2 [print x]   ; /2 could mean bump by 2
</code></pre>
<p>I wonder if TIME! could be moved out of the way somehow.  Maybe the weird forms that interfere with generality of sequences could be the syntaxes like <strong><code>#[10:00]</code></strong> or <strong><code>@time/&lt;10:00&gt;</code></strong> ... is TIME! really used so often and so critically that it can't be delimited out of band?  If contextually you know a spot should have time, <a href="https://rebol.metaeducation.com/t/kinds-of-values/466">could it just be <strong><code>&lt;10:00&gt;</code></strong> and you add the <strong><code>@time/</code></strong> to it for processing</a>?</p>
<p>We can debate it.  The easiest compatibility rule would be just to know that there are no 2-element chains that start with numbers.</p>
<h2><a name="p-7445-url-is-not-a-conflict-6" class="anchor" href="https://rebol.metaeducation.com#p-7445-url-is-not-a-conflict-6"></a>URL! is <strong>NOT</strong> a Conflict</h2>
<p>You might imagine <strong><code>http://example.com</code></strong> is a 3-element PATH!:</p>
<ul>
<li>
<p>First slot is a CHAIN! of <code>[http _]</code></p>
</li>
<li>
<p>Second slot is a BLANK!</p>
</li>
<li>
<p>Third slot is a TUPLE! of <code>[example com]</code></p>
</li>
</ul>
<p>But I think it's too valuable to be able to express URL!s easily.  So this seals the deal that you can't put BLANK!s internal to ANY-SEQUENCE!.  So there's no <strong>foo//bar</strong> paths or <strong>foo...bar</strong> tuples or <strong>foo:::::bar</strong> chains.  With // being illegal in path, it's free to be a URL!.</p>
<p>(We were already saying that <strong>/</strong> and <strong>//</strong> and <strong>...</strong> etc. are WORD!s, so the bias against doubling up these interstitial delimiters in sequences has been building up over time, and this just finalizes that.)</p>
<p>Yet strangely enough, <strong><code>http:/example.com</code></strong> with just one slash <em>is</em> a valid PATH! of 2 elements, with a CHAIN! in the first slot and a TUPLE! in the second.  Maybe this was destiny all along, and why URL!s have the two slashes.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/monkey_face.png?v=14" title=":monkey_face:" class="emoji" alt=":monkey_face:" loading="lazy" width="20" height="20">  <em>(I actually do believe the two slashes were chosen to make URL!s "stand out" visually, so it may not be a complete coincidence that it works out well for us here.)</em></p>
<h2><a name="p-7445-but-no-more-urn-7" class="anchor" href="https://rebol.metaeducation.com#p-7445-but-no-more-urn-7"></a>But... no more URN!</h2>
<p>The subset of legal URN!s that we can represent would be CHAIN!.</p>
<p>How many URN!s would be ruled out?  Interestingly the first two examples I found off stackoverflow of URN!s would be valid chains:</p>
<pre><code>URN (not URL): urn:oasis:names:specification:docbook:dtd:xml:4.1.2
URN (not URL): tel:+1-816-555-1212 (disputed, see comments)
</code></pre>
<p>But I'm not really concerned if it can't represent all of them.  The world doesn't revolve around URNs anyway.  (Maybe they were supposed to be important at one point, but I haven't noticed them ever being so.)</p>
<p>We have things like <strong><code>@urn/"tel:1-816-555-1212"</code></strong> if we need them, as inert forms</p>
<h2><a name="p-7445-cuts-down-on-total-number-of-fundamental-types-8" class="anchor" href="https://rebol.metaeducation.com#p-7445-cuts-down-on-total-number-of-fundamental-types-8"></a>Cuts Down On Total Number Of Fundamental Types</h2>
<p>What's added:</p>
<ul>
<li><code>a:b</code> ... CHAIN!</li>
<li><code>@a:b</code> ... THE-CHAIN!</li>
<li><code>$a:b</code> ... VAR-CHAIN! (should things like this be called e.g. BIND-CHAIN! ?)</li>
<li><code>^a:b</code> ... META-CHAIN!</li>
<li><code>&amp;a:b</code> ... TYPE-CHAIN!</li>
</ul>
<p><em>(I do think that perhaps calling e.g. $XXX a BIND-WORD! is better than VAR-WORD!, because VAR is an abbreviation and it doesn't look as classy.)</em></p>
<p>Compare that to what's removed:</p>
<ul>
<li><code>:[a b]</code> ... GET-BLOCK!</li>
<li><code>[a b]:</code> ... SET-BLOCK!</li>
<li><code>:(a b)</code> ... GET-GROUP!</li>
<li><code>(a b):</code> ... SET-GROUP!</li>
<li><code>:{a b}</code> ... GET-FENCE!</li>
<li><code>{a b}:</code> ... SET-FENCE!</li>
<li><code>:a</code> ... GET-WORD!</li>
<li><code>a:</code> ... SET-WORD!</li>
<li><code>:a/b</code> ... GET-PATH!</li>
<li><code>a/b:</code> ... SET-PATH!</li>
<li><code>:a.b</code> ... GET-TUPLE!</li>
<li><code>a.b:</code> ... SET-TUPLE!</li>
</ul>
<p>And despite sacrificing those types, due to past labors <a href="https://rebol.metaeducation.com/t/path-and-tuple-compression-explained/1008">there's no loss in storage efficiency</a>.</p>
<p>Fewer basic types, but a lot more fun parts.</p>
<h2><a name="p-7445-resolves-questions-that-have-plagued-rebol-for-decades-9" class="anchor" href="https://rebol.metaeducation.com#p-7445-resolves-questions-that-have-plagued-rebol-for-decades-9"></a>Resolves Questions That Have Plagued Rebol For Decades</h2>
<p>There was always this question about "why can't you put SET-WORD! or GET-WORD! in a PATH!", and people argued about it.</p>
<p>But now the answer is that they're not fundamental parts, and you're just dealing with the laws of interstitial delimiters.  You can't put a path "in" a path, but you can merge them.  So now it's just that you can't put a chain in a chain, only join them.</p>
<p>So this means a test like SET-PATH? doesn't make any sense.  Chains always live underneath paths!  But there <em>are</em> what are effectively SET-TUPLE (!) because with <strong><code>.a:</code></strong> you have the tuple under the chain.</p>
<p>Hence we're resurrecting things like <strong><code>a/:b</code></strong> but with a whole different logic behind it.  Because you can't run the risk of putting a GET-WORD in the first slot of a GET-PATH! <em>because there are no "GET-PATHs"</em>.</p>
<p>This <em>finally</em> makes perfect sense.</p>
<h2><a name="p-7445-this-means-we-wont-have-undecorated-ipv6-literals-10" class="anchor" href="https://rebol.metaeducation.com#p-7445-this-means-we-wont-have-undecorated-ipv6-literals-10"></a>This Means We Won't Have Undecorated IPV6 Literals</h2>
<p>Red is pursuing the idea of IPV6 literals, but this won't work with that.  We'll need another way.</p>
<p>Since the @ sigil makes things evaluate to themselves, it's going to be the likely basis of extensible literals:</p>
<pre><code>&gt;&gt; @ipv6:&lt;FE80:CD00:0:CDE:1257:0:211E:729C&gt;
== @ipv6:&lt;FE80:CD00:0:CDE:1257:0:211E:729C&gt;
</code></pre>
<h2><a name="p-7445-foo-actually-looks-kind-of-cool-11" class="anchor" href="https://rebol.metaeducation.com#p-7445-foo-actually-looks-kind-of-cool-11"></a><strong>:FOO:</strong> Actually Looks Kind of Cool</h2>
<p>When it comes to dialecting, <strong><code>.FOO.</code></strong> doesn't seem like something you'd use as a token.  It's more like a notation that would just sort of come up if your rules happened to intersect ("starting with a dot does X, ending with a dot does Y, starting and ending with a dot means you want both X and Y").</p>
<p><strong><code>/FOO/</code></strong> is a bit better.  I can imagine it labeling something, while not using up BLOCK! or GROUP! or FENCE! to get the look</p>
<pre><code>[
   /FIRST/ this could be (some code)
   You could do [something here]
   /SECOND/ more stuff.
   {your fence here}
]
</code></pre>
<p>But <strong><code>:FOO:</code></strong> seems like something you might use.  As does <strong><code>:[foo]:</code></strong>, <strong><code>-:[foo]:-</code></strong>, etc.  Neat things to have in the parts box.</p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/introducingnew-chain-datatype/2226">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/introducingnew-chain-datatype/2226</link>
          <pubDate>Thu, 29 Aug 2024 01:57:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2226</guid>
          <source url="https://rebol.metaeducation.com/t/introducingnew-chain-datatype/2226.rss">Introducing:The:New:CHAIN!:Datatype</source>
        </item>
        <item>
          <title>What is the use of typesets?</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Recent discussions have brought the notion of ‘typesets’ to my attention. On reading the source code, this confused me a bit… they don’t seem to be used all that much. Moreover, they seem to be subsumed by the idea of optimised constraint functions.</p>
<p>So I set out to try them myself. Only to find myself thoroughly confused, because typesets don’t actually seem to be accessible from Ren-C itself. Or, at least, none seem to be defined — normal type names evaluate to TYPE-BLOCK!s as expected, but typeset names are unassigned:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; word!
== &amp;[word]

&gt;&gt; text!
== &amp;[text]

&gt;&gt; any-utf8!
** Script Error: any-utf8! word is attached to a context, but unassigned
** Where: console
** Near: [any-utf8! **]
** Line: 1

&gt;&gt; any-type-value!
** Script Error: any-type-value! word is attached to a context, but unassigned
** Where: console
** Near: [any-type-value! **]
** Line: 1
</code></pre>
<p>[On which note, incidentally, let me yet again mention my conviction that the other TYPE-* datatypes are useless and should be removed.]</p>
<p>I expected to at least be able to use them in function signatures, but I can’t even do that, since it crashes a program:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; test: func [x [word!]] [return x]
== ~#[frame! {test} [x]]~  ; anti

&gt;&gt; test: func [x [any-utf8?]] [return x]
== ~#[frame! {test} [x]]~  ; anti

&gt;&gt; test: func [x [any-utf8!]] [return x]
Assertion failure: QUOTE_BYTE(v) == ANTIFORM_0
Line 165, File: /home/bradrn/Documents/red/ren-c/src/include/cells/cell-quoted.h
Trace/breakpoint trap (core dumped)
</code></pre>
<p>So… if they can’t be accessed from Ren-C itself, then why does the interpreter have typesets at all?</p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/what-is-the-use-of-typesets/2153">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/what-is-the-use-of-typesets/2153</link>
          <pubDate>Tue, 20 Feb 2024 04:29:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2153</guid>
          <source url="https://rebol.metaeducation.com/t/what-is-the-use-of-typesets/2153.rss">What is the use of typesets?</source>
        </item>
        <item>
          <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <h2><a name="p-7135-the-limited-and-ambiguous-historical-idea-1" class="anchor" href="https://rebol.metaeducation.com#p-7135-the-limited-and-ambiguous-historical-idea-1"></a>The Limited and Ambiguous Historical Idea</h2>
<p>People are used to being able to do things like:</p>
<pre><code> x: 10
 switch type? x [
     integer! [print "It's an integer"]
     block! [print "It's a block"]
 ]

 assert [parse [1 [second] 'foo] [integer! block! lit-word!]]

 assert [find any-word! (type? first [x:])]
</code></pre>
<p>But the historical DATATYPE! and TYPESET! were strange.</p>
<ul>
<li>
<p>DATATYPE! rendered as a WORD! but was really wrapping an integer of 0-63</p>
</li>
<li>
<p>TYPESET! was a 64-bit bitset, one bit for each type (this is where the 64 types limit came from)</p>
<ul>
<li>
<p>it lost its meaning in rendering (it kept no record of what the set actually was...just dumped words for each bit)</p>
</li>
<li>
<p>not preserving the name from a fixed list of typesets was based on the concept you could make your own or UNION/INTERSECT them</p>
</li>
</ul>
</li>
</ul>
<p>So it looked like this:</p>
<pre><code>red&gt;&gt; type? 1
== integer!

red&gt;&gt; type? type? 1
== datatype!

red&gt;&gt; print mold any-word!
make typeset! [word! set-word! lit-word! get-word!]

red&gt;&gt; print mold any-type!
make typeset! [datatype! unset! none! logic! block! paren! string! file! url!
    char! integer! float! word! set word! lit-word! get-word! refinement! issue!
    native! action! op! function! path! lit-path! set-path! get-path! routine!
    bitset! object! typeset! error! vector! hash! pair! percent! tuple! map!
    binary! time! tag! email! handle! date! port! money! ref! point2D! point3D!
    image! event!]
</code></pre>
<h2><a name="p-7135-the-type-xxx-approach-2" class="anchor" href="https://rebol.metaeducation.com#p-7135-the-type-xxx-approach-2"></a>The TYPE-XXX! Approach</h2>
<p>So Ren-C attacked the ambiguity and extensibility with a new word type, TYPE-WORD!.  Then typesets used TYPE-GROUP! and TYPE-BLOCK!, referencing functions to act as type testing predicates, and using groups for intersections and blocks for unions:</p>
<pre><code>&gt;&gt; type of 1
== &amp;integer

&gt;&gt; type of type of 1
== &amp;type-word

&gt;&gt; print mold any-word!
&amp;(any-word?)

&gt;&gt; print mold any-value!
&amp;(any-value?)
</code></pre>
<p>This gives some realistic axis of extensibility, and gives distinguishable entities that can trigger behaviors in PARSE when something looks up to type-xxx!.  (this shows why using WORD! or URL! or ISSUE! wouldn't work, because the type intent has to be carried by what e.g. INTEGER! looks up to.)</p>
<p><strong>Calling functions to implement type checks vs. checks on a bitset, especially when an array of functions must be called when checking every parameter in every function call, is a difficult performance point.</strong></p>
<p><a href="https://rebol.metaeducation.com/t/intrinsics-functions-without-frames/2050">Intrinsics and other magic are employed to rein it in.</a>  It's not particularly simple...but finding ways to speed up function calls where you can has systemic benefit.</p>
<h2><a name="p-7135-new-consequence-find-must-find-type-word-normally-3" class="anchor" href="https://rebol.metaeducation.com#p-7135-new-consequence-find-must-find-type-word-normally-3"></a>New Consequence: FIND Must Find TYPE-WORD! Normally</h2>
<p>Being a legitimate datatype that can be stored in a block, some interpretations of datatype by functions like FIND were problematic:</p>
<pre><code>red&gt;&gt; block: reduce ["hello" integer! 1]
== ["hello" integer! 1]

red&gt;&gt; find block 'integer!
== none  ; rendering was a lie

red&gt;&gt; find block integer!
== [1]
</code></pre>
<p>You couldn't find a literal datatype in a block.  Ren-C is approaching this by saying FIND has to find the TYPE-WORD! (as it does for all non-antiforms), but that you can use antiform actions as predicates.</p>
<pre><code>&gt;&gt; block: reduce ["hello" integer! 1]
== ["hello" &amp;integer 1]

&gt;&gt; find block integer!
== [&amp;integer 1]

&gt;&gt; find block :integer?
== [1]
</code></pre>
<p>There was some thought that maybe you could create antiform TYPE-XXX! and call them "matchers", passing them to FIND.</p>
<ul>
<li>
<p>But this is an isotope for each TYPE-XXX!, so it's not even like there would be one "matcher"</p>
</li>
<li>
<p>It also would be the only instance of antiforms of types with sigils, which doubles the sigil to make <strong><code>~&amp;integer~</code></strong>, which I find kind of displeasing</p>
</li>
</ul>
<p>I feel that antiform actions cover it for FIND, and if you have higher level needs you should use something like PARSE which has richer options and isn't beholden to quite the "mechanical" answer that a series primitive like FIND has to abide by with its limited parameterization.</p>
<h2><a name="p-7135-new-annoyance-type-of-quotes-and-antiforms-4" class="anchor" href="https://rebol.metaeducation.com#p-7135-new-annoyance-type-of-quotes-and-antiforms-4"></a>New Annoyance: TYPE OF Quotes And Antiforms</h2>
<p>When there were only two datatypes with quotedness, the quote was part of their datatype:</p>
<pre><code>red&gt;&gt; type? first ['a]
== lit-word!

red&gt;&gt; type? first ['a/b]
== lit-path!

red&gt;&gt; lit-word! = type? first ['a]
== true

red&gt;&gt; parse ['a 'a/b] [lit-word! lit-path!]
== true
</code></pre>
<p>Ren-C's approach affords the ability make type constraints to carry forward the PARSE behavior.  But the TYPE OF all quoteds is the same... &amp;QUOTED.</p>
<pre><code>&gt;&gt; lit-word?!
== &amp;(lit-word?)

&gt;&gt; lit-word?! = type of first ['a]
== ~false~  ; anti

&gt;&gt; type of first ['a]
== &amp;quoted
</code></pre>
<p>So perhaps you see the motivation to decorate as <strong>?!</strong> instead of just <strong>!</strong> for the type constraints.  People need to know that these aren't fundamental types.  You have to use e.g. MATCH with them:</p>
<pre><code> &gt;&gt; match lit-word?! first ['a]
 == 'a

 &gt;&gt; match lit-word?! 10
 == ~null~  ; anti

 &gt;&gt; match [lit-word?] first ['a]  ; alternative as 1st slot known "typelike"
 == 'a
</code></pre>
<p>This is something of a pain point, and I'm not entirely settled on whether it would be good to delve into some kind of ambiguity where we are actually allowed to get back constraint functions as the answer to TYPE OF, and make that the fundamental:</p>
<pre><code>&gt;&gt; type of 1
== &amp;integer?

&gt;&gt; type of spread [a b]
== &amp;splice?

&gt;&gt; type of ~true~
== &amp;logic?

&gt;&gt; type of first ['a]
== &amp;quoted? 
</code></pre>
<p>So I don't think this is a good idea for the quoted types, but for the antiforms it might be a narrow enough thing that it provides "what the people want".</p>
<pre><code>&gt;&gt; switch type of true [
     splice! [...]
     logic! [...]
     integer! [...]
  ]
</code></pre>
<p>Barring that, what we have to do today is flip SWITCH over into a MATCH mode (currently called SWITCH/TYPE but should probably be SWITCH/MATCH... or maybe it should take the MATCH name):</p>
<pre><code>&gt;&gt; switch/type true [
     splice?! [...]
     logic?! [...]
     integer! [...]
  ]
</code></pre>
<p>Note that the <code>?!</code> distinction is a new idea which hasn't made it to all type constraints yet, e.g. ANY-VALUE! is still as it was.  But because parameters use what is effectively a TYPE-BLOCK! you can say <strong><code>any-value?</code></strong> or <strong><code>splice?</code></strong> in them instead of going through the extra step.</p>
<h2><a name="p-7135-should-type-be-a-bigger-concept-5" class="anchor" href="https://rebol.metaeducation.com#p-7135-should-type-be-a-bigger-concept-5"></a>Should TYPE Be A Bigger Concept?</h2>
<p>One thing that has nagged me is if when we ask for the fundamental "cell type" of something, if we should avoid using the word "TYPE" for that at all...</p>
<p>Maybe there's some bigger idea in an object/class system where TYPE is meaningful to say something more than "this is an object" but rather "this is a book", where you can ask also "is a book readable".  Etc.</p>
<p>Or maybe TYPE can be parameterized:</p>
<pre><code> &gt;&gt; type of matrix
 == &amp;[matrix 10x10]
</code></pre>
<p>So this would mean there's a smaller question about the fundamental type, maybe call it "KIND":</p>
<pre><code>&gt;&gt; kind of [a b c]
== &amp;block

&gt;&gt; kind of matrix
== &amp;object
</code></pre>
<p>It would be nice to just be able to say "64 types is enough for anyone" and say "there, it's done".  I'd be happy to do that if I felt that it was enough.  It wasn't, even when thinking along fairly limited lines that don't go in these fancier directions.</p>
<p><em>I don't think any near-term system will actualize on bigger visions of what TYPE might be, but it would help to know if that should be ruled out or not, just in order to pick the term KIND or TYPE!</em>  But even that question is murky.</p>
<h2><a name="p-7135-some-related-reading-typesr-6" class="anchor" href="https://rebol.metaeducation.com#p-7135-some-related-reading-typesr-6"></a>Some Related Reading: %types.r</h2>
<p>The dialected table used to construct the type testing macros and other things is kind of neat, though some comments are out of date and parts of it need updating (it's getting upgraded in an upcoming commit which finally breaks the 64-type barrier and introduces the $ types):</p>
<p>See <a href="https://github.com/metaeducation/ren-c/blob/master/src/boot/types.r"><strong>%types.r</strong></a></p>
            <p><small>20 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151</link>
          <pubDate>Fri, 16 Feb 2024 23:29:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2151</guid>
          <source url="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
        </item>
        <item>
          <title>A proliferation of $#@^&#39;:~WORD~:s</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>One of the things which surprised me when I first looked into Ren-C was the number of WORD variants it has. By my count, this includes:</p>
<ul>
<li>plain WORD</li>
<li>:GET-WORD</li>
<li>SET-WORD:</li>
<li><code>@THE-WORD</code> *</li>
<li>^META-WORD</li>
<li>&amp;TYPE-WORD</li>
<li><span class="hashtag-raw">#ISSUE</span></li>
<li>'QUOTED</li>
<li>~ANTIFORM~</li>
<li>…and probably more that I’ve forgotten.</li>
</ul>
<p><small>* monospaced so Discourse doesn’t think it’s a ping</small></p>
<p>Now, in many ways this is perfectly expected for a language like Ren-C. Firstly, dialecting means we value having as many syntactic options as possible. Secondly, Ren-C has a lot of different kinds of values — plain, quoted, anti and quasi, and now bound and unbound versions of each — and most of these words are simply making it easier to deal with that huge variety.</p>
<p>But, on the other hand, I feel we’re starting to encounter some problems with the current way of doing things. Most notably:</p>
<ol>
<li>None of this is compositional. When we <a href="https://rebol.metaeducation.com/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359/7">run into a situation</a> where we’d like to, say, have a word which is both META- and THE-, it’s impossible.</li>
<li>Some dialects would like to use words outside this fixed inventory. For instance, it would be nice to have <a href="https://rebol.metaeducation.com/t/upcoming-datatype-word-what-will-it-mean/2146">$WORDs to use in a shell dialect</a>.</li>
</ol>
<p>The root cause of both is the same: the inventory of word-like datatypes is hard-coded into the interpreter. If you want to use something outside that set, you can’t, no matter how similar to the existing types it may seem.</p>
<p>I can imagine a hypothetical design which would avoid this. This would allow some characters to be freely added to the beginning and end of words — let’s call those special characters ‘sigils’, like in Perl. Every combination of sigils would then specify a separate datatype. So you would still have :WORDs and ^WORDs and ~WORD~s, but also $WORDs and ^@WORDs and ~#WORD&amp;s and whatever else you could imagine. This would quite easily solve both of the problems I mentioned.</p>
<p>One might even contemplate generalising this ‘sigil’ idea to non-word types. We already have {GET,SET,THE,META}-{BLOCK,GROUP}s, so it would make sense to allow arbitrary sigils on blocks and groups too.</p>
<p>Unfortunately, I’m not sure this would work with the current design of Ren-C. At the moment, there is currently a hard maximum of (as I recall) 256 possible datatypes, whereas this proposal obviously allows for an infinite amount of datatypes. However, I do think it’s at least worth thinking about, for the simple reason that it would give us a lot more flexibility than we currently have.</p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/a-proliferation-of-word-s/2147">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/a-proliferation-of-word-s/2147</link>
          <pubDate>Tue, 13 Feb 2024 12:58:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2147</guid>
          <source url="https://rebol.metaeducation.com/t/a-proliferation-of-word-s/2147.rss">A proliferation of $#@^&#39;:~WORD~:s</source>
        </item>
        <item>
          <title>Upcoming Datatype $WORD... What Will It Mean?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Something that has been nagging at me is that I've known I want to introduce <strong>$WORD</strong>, <strong>$(GR O UP)</strong>, <strong>$TU.P.LE</strong> etc. (tentative names VAR-WORD!, VAR-GROUP!, VAR-TUPLE!).</p>
<p>At first glance it seems like it would be a loss if $XXX didn't in the baseline evaluator evaluate to looking up environment variables.</p>
<p>But this would be a different behavior for an ANY-WORD!...which up until now, the type of word has not mattered.  Would it spread to SET?</p>
<pre><code>&gt;&gt; set-env "SOMETHING" "TRUE"

&gt;&gt; SOMETHING: 10

&gt;&gt; set (in [] '$SOMETHING) "FALSE"
== "FALSE"

&gt;&gt; SOMETHING
== 10

&gt;&gt; get-env "SOMETHING"
== "FALSE"
</code></pre>
<p>Hmmm.  Lots of issues there...including that Unix environment variables are case-sensitive, Windows ones are not.</p>
<p>The implementation mechanism of this would presumably have to introduce some sort of "pseudo-object" named <code>environment</code>/<code>env</code>, and then the "specifier" would have to say (in a similar way to which the ".WORD" lookups would say to look in a "current object") that the $ words should look up in env.   <em>(See related discussion about <a href="https://rebol.metaeducation.com/t/binding-indirection/2112">"Binding Indirection"</a>)</em></p>
<h2><a name="p-7106-simpler-thought-1" class="anchor" href="https://rebol.metaeducation.com#p-7106-simpler-thought-1"></a>Simpler Thought...</h2>
<p>A simpler thought (that doesn't rock the boat for one feature) would be that this is a bridge too far for an ANY-WORD!, and they should look up just like any other word, and it's only weird shell dialects that would think that a $WORD meant environment variables.</p>
<p>But then the question might be what the $ buys you.</p>
<p>Maybe I was too hasty in saying that the @ was the right thing to sacrifice for "get variable with binding", and $ should have done that?</p>
<pre><code>&gt;&gt; $word
== word  ; bound

&gt;&gt; @word
== @word  ; bound?
</code></pre>
<p>(A line of argumentation that <code>@word</code> should be bound, is that if you want an unbound one you can get it by quoting with <code>'@word</code>, but then again if the @ operator does not bind e.g. @ foo... but $ does, e.g. $ foo.  So maybe not affecting the binding is the better choice.)</p>
<p>This would let us put back the @ for "as-is" variable usage in parse.  And it would make more sense for a thing named VAR-WORD! (bound variable in evaluator, environment var in shell dialect...)</p>
<p>Urrrgh.  I hate that it seems like that's probably right.  :-/   <em>(Thankfully, git lets us audit/reverse such decisions...assuming you're diligent about not changing too many unrelated things in one commit, which I thankfully was careful about with the @ change.)</em></p>
<h2><a name="p-7106-loss-of-for-weird-idea-i-had-2" class="anchor" href="https://rebol.metaeducation.com#p-7106-loss-of-for-weird-idea-i-had-2"></a>Loss of $ For Weird Idea I Had</h2>
<p>If the $ operator were used for binding that would be a bit sad, as I'd kind of hoped that could be a variadic function that could run the <a href="https://github.com/metaeducation/ren-c/blob/3e5f724197f55d2745436a52ca1dfa7c5d7e4db5/scripts/shell.r#L4">shell dialect</a>:</p>
<pre><code>extension: "txt"

$ ls -alF *.(extension)
</code></pre>
<p>But, maybe that's a bad way to package it in the box, and specialty scripts that don't care about a $ operator for binding purposes can override it, encouraging the more traditional:</p>
<pre><code>extension: "txt"

shell [ls -alF *.(extension), echo $SOMETHING]
</code></pre>
            <p><small>11 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/upcoming-datatype-word-what-will-it-mean/2146">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/upcoming-datatype-word-what-will-it-mean/2146</link>
          <pubDate>Tue, 13 Feb 2024 11:51:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2146</guid>
          <source url="https://rebol.metaeducation.com/t/upcoming-datatype-word-what-will-it-mean/2146.rss">Upcoming Datatype $WORD... What Will It Mean?</source>
        </item>
        <item>
          <title>Meaning of META-BLOCK! ^[...]</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>META-GROUP! takes the evaluative behavior of GROUP! and metas the product:</p>
<pre><code>&gt;&gt; (1 + 2)
== 3

&gt;&gt; ^(1 + 2)
== '3

&gt;&gt; (find [a b c] 'd)
== ~null~  ; anti

&gt;&gt; ^(find [a b c] 'd)
== ~null~
</code></pre>
<p>That makes sense.  But what should META-BLOCK! do?</p>
<p>META-BLOCK! actually does something parallel to the evaluator's META-GROUP! in PARSE.  Because in PARSE, the blocks are not "inert".  It means give back the meta form of what the block rule synthesizes.</p>
<pre><code>&gt;&gt; parse "aaab" [some ^["a" | opt "b"]]
== ~null~
</code></pre>
<p>So there you got a quasiform and not an antiform of null (from the match of the optional "b" not being there).</p>
<p>But in the main evaluator, it currently just quotes the block:</p>
<pre><code>&gt;&gt; ^[a b c]
== '[a b c]
</code></pre>
<p>A synonym for <strong>quote [a b c]</strong>.  Pretty useless, right?</p>
<h2><a name="p-7039-maybe-not-useless-1" class="anchor" href="https://rebol.metaeducation.com#p-7039-maybe-not-useless-1"></a>Maybe Not Useless...</h2>
<p>Consider my desire to have a proper FOR dialect.</p>
<pre><code> &gt;&gt; for x [1 to 3] [print x]
 1
 2
 3
</code></pre>
<p>And then, the concept of "going meta" struck me as interesting:</p>
<pre><code> &gt;&gt; for x meta [1 to 3] [print x]
 1
 to
 3
</code></pre>
<p>Which would mean that FOR when given a quoted block would enumerate its contents vs. run the dialect.  Then you could also write that as:</p>
<pre><code> &gt;&gt; for x ^[1 to 3] [print x]
 1
 to
 3
</code></pre>
<p>It would even be semantically different if it did not bind the block, e.g. acted as a synonym for <strong><code>meta '[1 to 3]</code></strong></p>
<p>Cute, but we don't want to generalize it to groups, <strong><code>^(...)</code></strong> needs to evaluate the group and give the meta result.  So this would be specifically for taking blocks up a meta level.</p>
<p>I guess we'll have to see how it plays out.  I can't think of another behavior at the moment.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/meaning-of-meta-block/2145">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/meaning-of-meta-block/2145</link>
          <pubDate>Mon, 29 Jan 2024 08:50:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2145</guid>
          <source url="https://rebol.metaeducation.com/t/meaning-of-meta-block/2145.rss">Meaning of META-BLOCK! ^[...]</source>
        </item>
        <item>
          <title>Should ANY-VALUE! Include Stable Antiforms?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>If you don't put any type restrictions on a parameter, it will allow antiforms:</p>
<pre><code> &gt;&gt; foo: func [x] [probe x]

&gt;&gt; foo null
~null~  ; anti
</code></pre>
<p>And right now, that is a full synonym for ANY-VALUE!.</p>
<pre><code> &gt;&gt; foo: func [x [any-value!]] [probe x]

&gt;&gt; foo null
~null~  ; isotope
</code></pre>
<p><strong>But what if you want to exclude antiforms, and only accept things that can legally be put in blocks?</strong></p>
<p>We could have a name for the typeset excluding antiforms.  ANY-ARRAY-ITEM! would be pedantically explicit, but seems accurate enough.</p>
<p>Or we could say that ANY-VALUE! doesn't include antiforms by default, and so you have to write <strong>[any-value! antiform!]</strong> if you want them.  Or just include the specific ones you intend (like <strong>[null! any-value!]</strong>).</p>
<p>However, the code has a meaning for Value*, and it really is pretty much literally <em>"the kind of state that can be held by a variable"</em>.  So I think we need another name.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-any-value-include-stable-antiforms/2026">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-any-value-include-stable-antiforms/2026</link>
          <pubDate>Fri, 14 Apr 2023 21:37:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2026</guid>
          <source url="https://rebol.metaeducation.com/t/should-any-value-include-stable-antiforms/2026.rss">Should ANY-VALUE! Include Stable Antiforms?</source>
        </item>
        <item>
          <title>Should Antiforms Be Legal in MAP! (Keys, Values?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>In the pre-isotopic era, there was a concept that MAP! would not allow you to store nulls.  Because null was the signal of not being in a map.  Assigning a key null was a way of removing items from that map.</p>
<pre><code>&gt;&gt; m: to map! [x 20]
== &amp;[map! [
    x 20
]]

&gt;&gt; m.x
== 20

&gt;&gt; m.y
; null

&gt;&gt; m.x: null
; null

&gt;&gt; m
== &amp;[map! [
]]
</code></pre>
<p>Additionally, NULL was not allowed as a key.</p>
<h2><a name="p-6517-how-should-this-change-in-the-isotopic-era-1" class="anchor" href="https://rebol.metaeducation.com#p-6517-how-should-this-change-in-the-isotopic-era-1"></a>How Should This Change In The Isotopic Era?</h2>
<p>We still have the case that mapping to null (or void, that causes null retrieval?) would conflate with testing for presence or absence in the map.</p>
<p>I'll make the point that not allowing you to store antiforms as keys or values isn't a fundamental problem, because you can LIFT a value to put it in, and then UNLIFT it when taking it out.</p>
<h2><a name="p-6517-disallowing-widens-the-gap-with-objects-2" class="anchor" href="https://rebol.metaeducation.com#p-6517-disallowing-widens-the-gap-with-objects-2"></a>Disallowing Widens The Gap With Objects</h2>
<p>There have been questions about what the difference is between maps and objects, and this would be another: objects must be able to have members that are antiforms: action isotopes that can run implicitly, okay and null and other word antiforms, and I'm presuming splices and other stable forms as well.</p>
<p>It would mean a map has more in common with a block...more easily being converted to or from it.</p>
<p><strong>I don't know right now whether to allow or disallow.  So for starters I am going ahead with the premise that antiforms can't be stored in maps, as either keys or values.</strong>  We'll see how it goes.  If it is relaxed, it will be relaxed only for the values...in order to have parity with objects.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-antiforms-be-legal-in-map-keys-values/1995">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-antiforms-be-legal-in-map-keys-values/1995</link>
          <pubDate>Fri, 02 Dec 2022 09:28:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1995</guid>
          <source url="https://rebol.metaeducation.com/t/should-antiforms-be-legal-in-map-keys-values/1995.rss">Should Antiforms Be Legal in MAP! (Keys, Values?)</source>
        </item>
        <item>
          <title>Where to use SPACE vs QUASI-SPACE ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>I realized while thinking about what the right default for ARRAY would be, that there are two potentially sensible choices for a default... both of them single-character reified placeholders:</p>
<pre><code>[1]  &gt;&gt; array 3
     == [_ _ _]  ; SPACE rune!s

[2]  &gt;&gt; array 3
     == [~ ~ ~]  ; Quasi-SPACEs (a.k.a. "meta-trash", "quasars")
</code></pre>
<h2><a name="p-6508-this-offers-us-some-nuance-even-if-a-state-must-be-reified-1" class="anchor" href="https://rebol.metaeducation.com#p-6508-this-offers-us-some-nuance-even-if-a-state-must-be-reified-1"></a>This Offers Us Some Nuance Even If A State Must Be Reified!</h2>
<p>When it comes to the direct behavior of APPEND to a block, these states have to work the same.  In the era of isotopes, all reified values are appended as-is... it cannot (and should not) be any more complex:</p>
<pre><code>&gt;&gt; append [a b] second [c _]
== [a b _]

&gt;&gt; append [a b] second [c ~]
== [a b ~]

&gt;&gt; append [a b] second [c [d e]]
== [a b [d e]]
</code></pre>
<p><strong>But when we throw in an extra operation, we can imagine a difference.</strong>  For instance, we could make SPACE semantically equivalent to an empty array for the purposes of things like SPREAD or EMPTY?</p>
<pre><code>&gt;&gt; spread second [c []]
== \~()~\  ; antiform

&gt;&gt; spread second [c _]
== \~()~\  ; antiform

&gt;&gt; append [a b] spread second [c _]
== [a b]

&gt;&gt; empty? second [c _]
== \~okay~\  ; antiform
</code></pre>
<p>...and then we'd say that if you tried to do such things with a "meta-trash" state, it would be an error:</p>
<pre><code>&gt;&gt; spread second [c ~]
** Error: SPREAD does not accept ~ as an argument
</code></pre>
<p><em>I think this suggests that <code>~</code> makes a better choice for the default value of ARRAY elements!</em>  We can't default to an antiform like the one representing unset variables, but it's the closest thing.</p>
<p><em>Ultimately it came to seem that having only the antiform ~null~ be a "branch inhibitor" was more valuable than having SPACE be a "branch inhibitor".</em>  Simply being able to assume that anything you can find in an array will run a branch offered more leverage.  So spaces are "branch triggers" now, BUT they're empty.</p>
<h2><a name="p-6508-what-about-opting-out-of-as-is-appends-etc-2" class="anchor" href="https://rebol.metaeducation.com#p-6508-what-about-opting-out-of-as-is-appends-etc-2"></a>What About Opting Out Of As-Is Appends, etc?</h2>
<p>I mentioned that all items that can be found in a block have to act mechanically identically when it comes to TAKE-ing and APPEND-ing them.  But what would XXX be if you wanted the following?</p>
<pre><code>&gt;&gt; append [a b] xxx second [c [d e]]
== [a b [d e]]

&gt;&gt; append [a b] xxx second [c _]
== [a b _]

&gt;&gt; append [a b] xxx second [c ~]
** Error: Cannot append TRASH (~ antiform) to a block
</code></pre>
<p><a href="https://rebol.metaeducation.com/t/reify-and-degrade-a-narrower-meta-and-unmeta/2163">I'm trying out naming this operator DEGRADE</a>.  It would turn all quasiforms into their corresponding antiform:</p>
<pre><code>&gt;&gt; degrade first [~null~]
== \~null~\  ; antiform

&gt;&gt; degrade first ['foo]
== 'foo

&gt;&gt; degrade first [123]
== 123
</code></pre>
<p>The reverse of this operator would be REIFY.</p>
<h2><a name="p-6508-what-about-for-each-variations-3" class="anchor" href="https://rebol.metaeducation.com#p-6508-what-about-for-each-variations-3"></a>What About FOR-EACH Variations?</h2>
<p>I think an additionally neat spin on how these can be treated differently can be how FOR-EACH responds.</p>
<pre><code>&gt;&gt; for-each x (second [c []]) [
       print "Loop never runs"
   ]
== \~[]~\  ; antiform "void"

&gt;&gt; for-each x (second [c _]) [
       print "Loop never runs"
   ]
== \~[]~\  ; antiform "void"

&gt;&gt; for-each x (degrade second [c ~[]~]) [
       print "Loop never runs"
   ]
== \~null~\  ; anti (like a void in, null out... or if a BREAK was hit)

&gt;&gt; for-each x (second [c ~]) [
       print "Loop never runs"
   ]
** Error: FOR-EACH does not accept QUASI-SPACE as its data argument
</code></pre>
<p>This is a bit more speculative, but I like the general idea that a quasi void could let you have a kind of nothing that gave you the "opt out" ability in places where it could... and QUASI-SPACE could give you an error, while SPACE acts like an empty series.  This seems to offer some nice invariants that reduce overall code you have to write handling edge cases.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/where-to-use-space-vs-quasi-space/2285">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/where-to-use-space-vs-quasi-space/2285</link>
          <pubDate>Wed, 30 Nov 2022 04:00:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2285</guid>
          <source url="https://rebol.metaeducation.com/t/where-to-use-space-vs-quasi-space/2285.rss">Where to use SPACE vs QUASI-SPACE ?</source>
        </item>
        <item>
          <title>What Should TYPE OF an Antiform Be?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>At this exact moment (in Sep 2022)...TYPE OF any antiform is an error, while both TYPE OF NULL and TYPE OF VOID give back NULL.</p>
<p>OF is a generic operation (the infix form of REFLECT that quotes the word on its left.  It may be desirable to honor the VOID-in-NULL out convention for all the other reflectors that aren't TYPE... and it's desirable to error on NULL more generically.</p>
<pre><code>&gt;&gt; label of null
** Error: You didn't give anything

&gt;&gt; label of maybe null  ; MAYBE NULL is VOID 
; null
</code></pre>
<p>So if <strong>type of</strong> follows the same pattern as other <strong>xxx of</strong>, we'd surmise that you don't use TYPE OF to discern NULL and VOID.  It errors on NULL input and gives you back NULL if you MAYBE it.</p>
<p>But what happens when you ask:</p>
<pre><code>&gt;&gt; spread [d e]
== ~(d e)~  ; anti

&gt;&gt; type of spread [d e]
???
</code></pre>
<h2><a name="p-6440-the-original-plan-was-no-arguments-received-antiforms-1" class="anchor" href="https://rebol.metaeducation.com#p-6440-the-original-plan-was-no-arguments-received-antiforms-1"></a>The Original Plan Was <em>No</em> Arguments Received Antiforms</h2>
<p>In the original conception, function frames weren't capable of holding antiforms in the arguments.  You physically could not receive a parameter that was an antiform.</p>
<p>I was also looking at the idea that some antiforms--such as raised ERROR!--would be completely impossible to get into a variable, <em>ever</em>.</p>
<p>The only workaround was if a function used the ^META parameter convention, in which case an antiform would come in as a QUASI! form of the value...while normal values would come in as one level quoted higher than they were:</p>
<pre><code> &gt;&gt; detector: func [^x] [print ["Meta of X:" mold x]]

 &gt;&gt; detector [d e]
 Meta of X: '[d e]

 &gt;&gt; detector spread [d e]
 Meta of X: ~(d e)~
</code></pre>
<p>Ultimately I backed down on this, instead allowing you to use type predicates to narrow which antiforms you'd be willing to accept:</p>
<pre><code>&gt;&gt; splicetaker: func [x [any-value! splice?]] [
       append [a b c] :x
   ]

&gt;&gt; splicetaker [d e]
== [a b c [d e]]

&gt;&gt; splicetaker spread [d e]
== [a b c d e]
</code></pre>
<p>A primary driver behind this change was that operations which wanted to do things like ADAPT a function frame were having to become sensitive to whether a parameter was ^META or not.  It seemed that standardizing the frame in a way that permitted antiforms as currency made more sense than having arguments be sometimes-meta'd, sometimes not.</p>
<p><em>(Note: A later driver of this was that <a href="https://rebol.metaeducation.com/t/why-theres-no-boolean-type-storable-in-a-block/2095">LOGIC became implemented with antiforms</a>, and needing to make a parameter meta to take logic was another bridge-too-far.)</em></p>
<h2><a name="p-6440-what-if-of-reflect-didnt-take-antiforms-2" class="anchor" href="https://rebol.metaeducation.com#p-6440-what-if-of-reflect-didnt-take-antiforms-2"></a>What if OF (REFLECT) Didn't Take Antiforms?</h2>
<p>So we could say that if you think you have an antiform in your hand, you're responsible for ^META-ing it yourself:</p>
<pre><code>&gt;&gt; metatyper: func [x [any-value! splice?]] [
       print ["Metatype of X is" type of ^x]
   ]

&gt;&gt; metatyper [d e]
== &amp;['block]  ; the TYPE OF received a QUOTED!, so e.g. answer incorporates quoted

&gt;&gt; metatyper spread [d e]
== &amp;[~block~]  ; got QUASI!, so TYPE OF answer incorporates quasi
</code></pre>
<p>On the plus side of such an approach, we don't have to invent any type representations for antiforms.</p>
            <p><small>6 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/what-should-type-of-an-antiform-be/1983">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/what-should-type-of-an-antiform-be/1983</link>
          <pubDate>Sat, 24 Sep 2022 10:23:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1983</guid>
          <source url="https://rebol.metaeducation.com/t/what-should-type-of-an-antiform-be/1983.rss">What Should TYPE OF an Antiform Be?</source>
        </item>
        <item>
          <title>BLANK! 2022: Revisiting The Datatype</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>In historical Redbol's meaning of the datatype NONE!, it had the bad habit of looking like a WORD!:</p>
<pre><code>rebol2&gt;&gt; 'none
== none

rebol2&gt;&gt; none
== none  ; same in R3-Alpha and Red
</code></pre>
<p>But it wasn't a word:</p>
<pre><code>rebol2&gt;&gt; type? 'none
== word!

rebol2&gt;&gt; type? none
== none!
</code></pre>
<p>It was a distinct type, which also happened to be falsey (while WORD!s are truthy):</p>
<pre><code>rebol2&gt;&gt; if 'none [print "Truthy word!"]
Truthy word!

rebol2&gt;&gt; if none [print "Falsey none!"]
== none
</code></pre>
<p>And as we can see, NONE!s served purposes of signaling "soft failures": branches that didn't run, or FINDs that didn't find, or SELECTs that didn't select... etc.</p>
<pre><code>rebol2&gt;&gt; find "abcd" "z"
== none

rebol2&gt;&gt; select [a 10 b 20] 'c
== none
</code></pre>
<h2><a name="p-6319-ren-c-divided-nones-roles-across-null-void-and-blank-1" class="anchor" href="https://rebol.metaeducation.com#p-6319-ren-c-divided-nones-roles-across-null-void-and-blank-1"></a>Ren-C Divided NONE!s roles across NULL, VOID, and BLANK!</h2>
<ul>
<li>
<p><strong>NULL</strong> - an "antiform" state of WORD! that couldn't be put in BLOCK!s.  Anywhere that NONE! would be used to signal a soft failure operation--like FIND or SELECT--would use ~null~.</p>
<pre><code>&gt;&gt; null
== ~null~  ; anti

&gt;&gt; find "abcd" "z"
== ~null~  ; anti

&gt;&gt; select [a 10 b 20] 'c
== ~null~  ; anti

&gt;&gt; append [a b c] null
** Error: APPEND doesn't allow ~null~ isotope
</code></pre>
</li>
<li>
<p><strong>BLANK!</strong> was represented by a lone underscore ( <strong><code>_</code></strong> ) and could be put into blocks:</p>
<pre><code>&gt;&gt; append [a b c] _
== [a b c _]
</code></pre>
<p>At the outset, it retained the choice to be falsey:</p>
<pre><code>&gt;&gt; if _ [print "Won't print because blanks are falsey"]
</code></pre>
</li>
<li>
<p><strong>VOID</strong> - another "antiform" state, but not one you can store in a variable... hence an "unstable antiform".  So decisions need to be made on how to handle them.  Some places make them vanish, and when functions like APPEND get them as an argument they are treated as no-ops:</p>
<pre><code>&gt;&gt; void  ; is a function that returns a void (can't store void in variable)
== ~[]~  ; anti (unstable)

&gt;&gt; when 1 &lt; 0 [print "WHEN is IF variant that returns VOID not null"]
== ~[]~  ; anti

&gt;&gt; compose [abc (when 1 &lt; 0 ['def]) ghi]
== [abc ghi]

&gt;&gt; append [a b c] void
== [a b c]

&gt;&gt; for-each void [1 2 3] [print "no variable"]
== ~null~  ; anti
</code></pre>
</li>
</ul>
<h2><a name="p-6319-question-one-should-blank-just-be-a-word-2" class="anchor" href="https://rebol.metaeducation.com#p-6319-question-one-should-blank-just-be-a-word-2"></a>Question One: Should BLANK! Just Be A WORD! ?</h2>
<p>Ren-C allows you to use underscores internally to words, so it feels a little bad to take away one word.</p>
<p>Outside of historically being hardcoded as falsey, what makes BLANK! fairly "built in" is that in the path mechanics, it fills in the empty slots:</p>
<pre><code>&gt;&gt; to path! [_ a]
== /a

&gt;&gt; as block! 'a/b/c/
== [a b c _]
</code></pre>
<p>There's other places the blank is used, such as to opt-out of multi-returns.</p>
<pre><code>&gt;&gt; [_ value]: transcode/next "abc def"
== " def"

&gt;&gt; value
== abc
</code></pre>
<h2><a name="p-6319-question-two-does-blank-still-need-to-be-falsey-3" class="anchor" href="https://rebol.metaeducation.com#p-6319-question-two-does-blank-still-need-to-be-falsey-3"></a>Question Two: Does BLANK! Still Need To Be Falsey?</h2>
<p><em>My feeling is that having blank be falsey doesn't have all that much benefit.</em>  NULL does a better job of it, and really what it does is mess with its usefulness as a placeholder:</p>
<pre><code>&gt;&gt; append [a b c] opt all [1 &gt; 2, 3 &gt; 4, _]
== [a b c]  ; doesn't make sense to me

&gt;&gt; append [a b c] opt all [1 &lt; 2, 3 &lt; 4, _]
== [a b c _]  ; this makes sense to me
</code></pre>
<p>Thinking of BLANK! as being "null-like" in terms of non-valuedness is generally a hassle.  It makes you wonder about whether something like DEFAULT should think of it as being assigned or not:</p>
<pre><code>&gt;&gt; item: _

&gt;&gt; item: default [1 + 2]
== ???
</code></pre>
<p>In practice, I prefer only non-array-element things (NULL, TRASH, etc.) being the only cases that DEFAULT overwrites.  This is because NULL is far more useful than BLANK! when it comes to representing something that you think of as "not being assigned"... as you'll get errors when you try to use it places (e.g. in APPEND).  Trying to use blank to represent nothingness invariably leads to stray appearances in blocks (Shixin wrote a lot of code to try to filter them out in Rebmake, prior to it being switched to NULLs)</p>
<p>This makes more sense, and I think it bolsters the argument that BLANK! is less of a falsey-NULL relative...but more of a placeholder value.  I've said "blanks are to blocks what space is to strings".  And space is truthy:</p>
<pre><code>&gt;&gt; if second "a b" [print "Space is truthy"]
Space is truthy

&gt;&gt; if second [a _ b] [print "So why shouldn't blank be truthy?"]
???
</code></pre>
<p><strong>So Either Way, I Suggest The Removal of BLANK! From Being Falsey</strong>.  This creates some incompatibility in Redbol emulation (which has been using BLANK! as a "NONE!" substitute).  But it's something that can be worked around.</p>
            <p><small>9 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942</link>
          <pubDate>Thu, 25 Aug 2022 13:50:26 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1942</guid>
          <source url="https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942.rss">BLANK! 2022: Revisiting The Datatype</source>
        </item>
        <item>
          <title>Sample Custom Datatype Idea: Sound</title>
          <dc:creator><![CDATA[GiuseppeChillemi]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>As an example, lets build a simple custom structure:</p>
<pre><code>[[internal structures][data1][data2][data3][data4]]
</code></pre>
<p>I want that that <code>head</code> corresponds to <code>data1</code>, and <code>index?</code> returns1 when positioned there.</p>
<p>If you have an internal action called "reposition" and "get-position" belonging to that datatype, Ren-C should look at the block if it carries an additional management object. If it contains "reposition" and "get-position" it should use this custom functions to override the standard ones for the datatype. You code them so that they do not move before data1, and you have a special structure which acts transparently to the standard Ren-C working.</p>
<p>Now lets take:</p>
<pre><code>sound: [[header] size: 5000 modified-by: "HF" sound: #A45ACF...  [tail-data]]
</code></pre>
<p>It is your structure to store a sound.</p>
<p>you want that at set operation using ':' will be written <code>raster-image:</code> content, so that</p>
<pre><code>sound: load %mysong.wav
</code></pre>
<p>You add a custom management object with overwrites the set operation and also all the others regarding <code>pick/length?/poke...</code> and so on, so that your Ren-C script works with the usual syntax, which is internally manage by from you replacement actions, translating everything to the new coordinates and operation system</p>
<p>Obviously, you could have additional action to be available to the developers which do not replace the internal actions but they could be called with syntax like:</p>
<pre><code>do-custom data 'method [parameter parameter]
</code></pre>
<p>or having a special path like <code>sound/#/fourier-trasform</code></p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/sample-custom-datatype-idea-sound/1899">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/sample-custom-datatype-idea-sound/1899</link>
          <pubDate>Sun, 24 Jul 2022 10:23:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1899</guid>
          <source url="https://rebol.metaeducation.com/t/sample-custom-datatype-idea-sound/1899.rss">Sample Custom Datatype Idea: Sound</source>
        </item>
        <item>
          <title>Could Each Datatype Have a &quot;Second&quot; (Hidden) &quot;Slot&quot;</title>
          <dc:creator><![CDATA[GiuseppeChillemi]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>From some time I am having the idea that each datatype could have a second value slot where you can set a context where I can store replacement handling methods for set/get and also other functions and any data you have, so you can patch the standard Rebol handlings and have also additional data/functions.</p>
            <p><small>7 posts - 4 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/could-each-datatype-have-a-second-hidden-slot/1908">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/could-each-datatype-have-a-second-hidden-slot/1908</link>
          <pubDate>Tue, 19 Jul 2022 21:36:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1908</guid>
          <source url="https://rebol.metaeducation.com/t/could-each-datatype-have-a-second-hidden-slot/1908.rss">Could Each Datatype Have a &quot;Second&quot; (Hidden) &quot;Slot&quot;</source>
        </item>
  </channel>
</rss>

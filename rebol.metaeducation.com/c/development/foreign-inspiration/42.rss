<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Foreign Inspiration - AltRebol</title>
    <link>https://rebol.metaeducation.com/c/development/foreign-inspiration/42</link>
    <description>Topics in the &#39;Foreign Inspiration&#39; category Take inspiration from other languages to create the same functionality in rebol.</description>
    
      <lastBuildDate>Wed, 04 Jun 2025 04:31:23 +0000</lastBuildDate>
      <atom:link href="https://rebol.metaeducation.com/c/development/foreign-inspiration/42.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Lenses/Optics Possibly Applicable to PICK/POKE</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <aside class="quote quote-modified" data-post="1" data-topic="1719">
  <div class="title">
    <div class="quote-controls"></div>
    <img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar">
    <a href="https://rebol.metaeducation.com/t/get-set-vs-pick-poke-whats-the-difference/1719">GET+SET vs PICK+POKE - What's The Difference?</a> <a class="badge-category__wrapper " href="https://rebol.metaeducation.com/c/development/semantics/55"><span data-category-id="55" style="--category-badge-color: #25AAE2; --category-badge-text-color: #FFFFFF; --parent-category-badge-color: #25AAE2;" data-parent-category-id="8" data-drop-close="true" class="badge-category --has-parent" title="While the &quot;Internals&quot; discusses the bits and bytes of how things are implemented, this category is for discussing things design questions of the language... like what do [] should return."><span class="badge-category__name">Semantics</span></span></a>
  </div>
  <blockquote>
    Historically, GET could not get a path: 
rebol2&gt;&gt; obj: make object! [x: 10]

rebol2&gt;&gt; get 'obj/x
** Script Error: get expected word argument of type: any-word object none

That changed in R3-Alpha.  Red followed suit: 
r3-alpha/red&gt;&gt; get 'obj/x
== 10

Which seems like an improvement...but opened the door to something I've complained about: GET having side-effects, such as: 
red&gt;&gt; path: 'obj/(print "Boo!" 'x)
== obj/(print "Boo!" 'x)

red&gt;&gt; get path
Boo!
== 10

When you say that two sequential GE…
  </blockquote>
</aside>

<p>Reading this, I am reminded <em>very</em> strongly of functional optics, as implemented in e.g. Haskell’s <a href="https://hackage.haskell.org/package/lens"><code>lens</code></a> or <a href="https://hackage.haskell.org/package/optics"><code>optics</code></a>. These are, essentially, first-class encodings of composable ‘locations’ at which you can get or set. For instance:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">ghci&gt; import Control.Lens
ghci&gt; value = (5,10,("nested","values"))
ghci&gt; view _1 value
5
ghci&gt; view (_3 . _1) value
"nested"
ghci&gt; set _1 6 value
(6,10,("nested","values"))
ghci&gt; set (_3 . _2) "new" value
(5,10,("nested","new"))
</code></pre>
<p>Here <code>_1</code>, <code>_2</code> and <code>_3</code> are predefined ‘lenses’ for getting elements of a tuple. All lenses can be composed: <code>_3 . _2</code> is a lens pointing to the second element of the third element of a tuple.</p>
<p>You can define your own lenses, of course:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">ghci&gt; data MyRecord = MyRecord { field1 :: Int, field2 :: String } deriving (Show)
ghci&gt; field1Lens = lens field1 (\r v -&gt; r { field1 = v })
ghci&gt; view field1Lens $ MyRecord { field1=10, field2="test" }
10
ghci&gt; set field1Lens 20 $ MyRecord { field1=10, field2="test" }
MyRecord {field1 = 20, field2 = "test"}
</code></pre>
<p>…although there are macros to do it for you (which most people use).</p>
<p>Incidentally, <code>lens</code> also comes about as close to dialecting as is possible in Haskell. There are operator versions of everything: <code>value ^. lens</code> gets, <code>value &amp; lens .~ newvalue</code> sets. Many operators effectively let you simulate imperative programming: e.g. <code>value &amp; lens +~ 1</code> increments the value at the <code>lens</code>.</p>
<p>There are various ways of actually implementing these things. The simplest is simply by storing a getter and a setter together, defining appropriate functions to manipulate them self-consistently. <code>lens</code> uses the <a href="https://www.twanvl.nl/blog/haskell/cps-functional-references">van Laarhoven encoding</a>, which represents them as a higher-order function parameterised over a typeclass. <code>optics</code> uses a variation on this, the ‘profunctor encoding’ (for which see the <a href="https://oleg.fi/gists/posts/2017-04-18-glassery.html">Glassery</a>).</p>
<p>The latter two encodings are in fact immensely powerful, allowing for a number of different generalisations on the basic theme. For instance, a <code>Traversal</code> points to multiple values at once:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">ghci&gt; [1,2,3,4,5] &amp; traverse +~ 10
[11,12,13,14,15]
ghci&gt; [1,2,3,4,5] &amp; taking 3 traverse +~ 10
[11,12,13,4,5]
ghci&gt; [1,2,3,4,5] &amp; dropping 3 traverse +~ 10
[1,2,3,14,15]
ghci&gt; [(1,2),(3,4),(5,6),(7,8),(9,10)] &amp; (dropping 3 traverse . both) +~ 10
[(1,2),(3,4),(5,6),(17,18),(19,20)]
ghci&gt; [(1,2),(3,4),(5,6),(7,8),(9,10)] &amp; dropping 3 (traverse.both) +~ 10
[(1,2),(3,14),(15,16),(17,18),(19,20)]
ghci&gt; [(1,2),(3,4),(5,6),(7,8),(9,10)] &amp; dropping 3 (traverse._1) +~ 10
[(1,2),(3,4),(5,6),(17,8),(19,10)]
</code></pre>
<p>As you can see, they combine nicely with other traversals and lenses, with a great deal of specificity. Similarly, <code>Prism</code>s let you select things which may be present or absent:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">ghci&gt; Left 1 &amp; _Left +~ 10
Left 11
ghci&gt; Right 1 &amp; _Left +~ 10
Right 1
ghci&gt; isn't _Left (Left 1)
False
ghci&gt; isn't _Left (Right 1)
True
</code></pre>
<p>Of course they too can combine with lenses, traversals, and all the other things defined by <code>lens</code> (e.g. the operator <code>+~</code>, as above).</p>
<p>I could go on like this for a while but I’ll stop here…!</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/lenses-optics-possibly-applicable-to-pick-poke/2473">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/lenses-optics-possibly-applicable-to-pick-poke/2473</link>
          <pubDate>Wed, 04 Jun 2025 04:31:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2473</guid>
          <source url="https://rebol.metaeducation.com/t/lenses-optics-possibly-applicable-to-pick-poke/2473.rss">Lenses/Optics Possibly Applicable to PICK/POKE</source>
        </item>
        <item>
          <title>Could The &gt;&gt;= Operator Do Something Haskell-Y</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>I've been pondering shorthands, and I think I'm near-100% certain that <strong>?</strong> is good shorthand for OPT(IONAL).</p>
<p>Following on that, I'm coming to wonder if <strong><code>!</code></strong> is a good shorthand for TRY (and that <strong><code>?!</code></strong> is might be a good shorthand for OPT TRY).  But <strong><code>??</code></strong> could also be OPT TRY as "more forceful OPT"... especially since there's OPT:VETO which is competing here and needs something.</p>
<p>The idea of <strong><code>!!</code></strong> meaning <a href="https://rebol.metaeducation.com/t/virtual-binding-based-error-propagation-operator/2389"><strong>"Propagate Error"</strong></a> is intriguing.  It's probably a behavior-modifying refinement to TRY or TRAP, e.g. something like TRY:PROPAGATE.</p>
<p>Anyway this all led me to question <strong><code>!=</code></strong> being an alias for not equal, and if we should just stick with <strong><code>&lt;&gt;</code></strong>.  <code>!=</code> could be some kind of <code>"try equal?"</code> or such, that would make more sense.</p>
<p>But in thinking about how characters compose onto equal signs to affect their behavior, that made me wonder...</p>
<h2><a name="p-8242-what-could-do-1" class="anchor" href="https://rebol.metaeducation.com#p-8242-what-could-do-1"></a>What Could <strong>&gt;&gt;=</strong> Do ?</h2>
<p>A good question for <a class="mention" href="https://rebol.metaeducation.com/u/bradrn">@bradrn</a> ... is there anything meaningfully relatable to Haskell's iconic definition of this, which is applicable in the Ren-C world?</p>
<p>Rebol has dialects... not monads.. but there's some similarity in terms of finding yourself "wrapped up" in a context with implicit assumptions.</p>
<p>So if you look at something like this EVAL-fence! in PARSE, what might it make you think about applying that?  What kind of scenarios?</p>
<p><a href="https://rebol.metaeducation.com/t/uses-of-fence-in-dialecting/1728/5" class="inline-onebox">Uses of FENCE! In Dialecting - #5 by hostilefork</a></p>
<p>e.g. "In what way would that example bend in order to show a usage of &gt;&gt;= that made sense?"</p>
<p><em>(Also, more generally, I'm curious if you had any additional observations after some time of having absorbed the design... on posts like asking <a href="https://rebol.metaeducation.com/t/copy-all-files-in-a-directory-a-little-help-please/2149/3">"how are dialects implemented?"</a> or <a href="https://rebol.metaeducation.com/t/fundamental-distinguishing-features-of-rebol/2136">"fundamental distinguishing features of Rebol"</a>.  It's extremely useful if you add feedback on these over time, and what sorts of "marketing" points stand out most...what examples led to the best realizations.)</em></p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/could-the-operator-do-something-haskell-y/2440">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/could-the-operator-do-something-haskell-y/2440</link>
          <pubDate>Sat, 10 May 2025 22:57:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2440</guid>
          <source url="https://rebol.metaeducation.com/t/could-the-operator-do-something-haskell-y/2440.rss">Could The &gt;&gt;= Operator Do Something Haskell-Y</source>
        </item>
        <item>
          <title>Equivalent to [[nodiscard]] ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>C++ has an attribute on functions called <code>[[nodiscard]]</code> that instructs the compiler to make sure you do something with a result.</p>
<p><a href="https://en.cppreference.com/w/cpp/language/attributes/nodiscard" class="inline-onebox">C++ attribute: nodiscard (since C++17) - cppreference.com</a></p>
<p>I've long wondered about whether there's some kind of discard-sensitivity that should/could be thrown in, e.g. for noticing when a stray value in evaluation doesn't do anything:</p>
<pre><code>&gt;&gt; append [a b c] [d e] 2 print "Could we error?"
** Error: 2 was discarded
</code></pre>
<p>How much code would break if we didn't allow stray values like that in the evaluator?  I could actually test that question.</p>
<p>Anyway, the mechanics behind RAISE means there's already a place to implement this.  There's a spot where it is decided if a definitional error would be discarded, and if so it's escalated to an abrupt failure.  It's only okay if it falls out of the evaluation to get picked up by someone else, and stays as a hot potato.</p>
<p>But could we have other hot potatoes?  Results of functions that are marked NO-DISCARD?   Plain values?</p>
<p>I can't offhand think of any important techniques this would break.  But I'll have to try it and see.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/equivalent-to-nodiscard/2356">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/equivalent-to-nodiscard/2356</link>
          <pubDate>Sat, 21 Dec 2024 18:44:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2356</guid>
          <source url="https://rebol.metaeducation.com/t/equivalent-to-nodiscard/2356.rss">Equivalent to [[nodiscard]] ?</source>
        </item>
        <item>
          <title>Multiple Return Values in JavaScript</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>rebRescue() in the C API returns an error, or null if no error... in which case your result is the value that's passed by pointer-to-pointer:</p>
<pre><code> Value* result;
 Value* error = rebRescue(&amp;result, "append 123 456");  // illegal, fails
 if (error) {  // non-0 pointer value means not ~null~ antiform
     /* handle error */
 }
 else {
     /* result is valid */
 }
</code></pre>
<p>But JavaScript doesn't have pointer-to-value semantics.  So you have to use multi-returns.</p>
<p>I didn't know how they did that, so I looked it up.  <a href="https://stackoverflow.com/questions/2917175/return-multiple-values-in-javascript/2917186#2917186">There are two ways</a>.  You can destructure an array:</p>
<pre><code>function getValues() {
    return [getFirstValue(), getSecondValue()]
}
const [a, b] = getValues()  ; any names you want here
</code></pre>
<p>Or you can destructure an object, where you have to use the names of the fields as the same names as your destructure variables:</p>
<pre><code>function getValues() {
    return {
        first: getFirstValue(),
        second: getSecondValue(),
    }
}

const {first, second} = getValues()
</code></pre>
<p>If you don't want to use the exact names, there's another syntax:</p>
<pre><code>const {a: first, b: second} = getValues()
</code></pre>
<p>I don't know if naming multi-returns is super important, and have had bigger ambitions for antiform objects.</p>
<p>The StackOverflow question has someone prescribing that it's very important to pick the named version over the non-named one.  I don't agree, and plan on using the array form for <code>rebRescue()</code></p>
<p><strong>The much bigger issue in my mind is forgetting to do the destructure, and getting back a value that's in-band as a plain array or object, when you really just forgot to destructure.</strong>  Isotopes do a very good thing here, not seen in other languages...decaying to the first item by default, and generalizing moving the out-of-band into band via meta/quasi/etc. forms in order to write peer destructuring operators when you need to.</p>
<p>This is a repeat of JavaScript's issue with Promise, where if you forget to do an AWAIT then you wind up with a Promise by value that you didn't expect.  But AWAIT is terrible for all kinds of other reasons, so we're not going down that road.</p>
<p><a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/" class="inline-onebox">What Color is Your Function? – journal.stuffwithstuff.com</a></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/multiple-return-values-in-javascript/2355">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/multiple-return-values-in-javascript/2355</link>
          <pubDate>Sat, 21 Dec 2024 18:32:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2355</guid>
          <source url="https://rebol.metaeducation.com/t/multiple-return-values-in-javascript/2355.rss">Multiple Return Values in JavaScript</source>
        </item>
        <item>
          <title>Wolfram Language</title>
          <dc:creator><![CDATA[vnzio]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Wolfram Mathematica = now called<br>
"Wolfram Language"</p>
<p>has some nice abreviation symbol/shortcuts  for typing</p>
<p>But all have the names visible when you invoke<br>
<strong>FullForm[]</strong><br>
and the good docs all suggest how to say them out loud<br>
Very nice &amp;important for teaching<br>
And or in any videos</p>
<p>Rebol I think was much inspired by Mathematica</p>
<p>(I don't know for sure)</p>
            <p><small>8 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/wolfram-language/2218">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/wolfram-language/2218</link>
          <pubDate>Sun, 25 Aug 2024 03:23:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2218</guid>
          <source url="https://rebol.metaeducation.com/t/wolfram-language/2218.rss">Wolfram Language</source>
        </item>
        <item>
          <title>Usermode Multiple Dispatch in R and Common Lisp</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2190">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/member-functions-in-the-era-of-pure-virtual-binding/2190/1">"Member Functions" (in the era of Pure Virtual Binding)</a></div>
<blockquote>
<p>Rebol's style of data mutation is done as "generics", e.g.:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">append block [1 2 3]
;
; ... NOT block/append [1 2 3]
</code></pre>
<p>This dynamically chooses the right kind of APPEND procedure based <em>entirely</em> on the type of the first argument (blocks, strings, etc.)</p>
<p>But you can't implement this generic for your own objects.</p>
</blockquote>
</aside>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2190">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/member-functions-in-the-era-of-pure-virtual-binding/2190/1">"Member Functions" (in the era of Pure Virtual Binding)</a></div>
<blockquote>
<p>It seems Rebol could use a better way of doing <a href="https://en.wikipedia.org/wiki/Multiple_dispatch">multiple dispatch</a> so that you could write things like <strong><code>append my-object [a b c]</code></strong> and get custom behavior for the "class".</p>
</blockquote>
</aside>
<p>The <a href="https://adv-r.hadley.nz/s3.html#s3-methods">R solution to this</a> is to make the function itself do the dispatch. A function like <code>append</code> would be defined as something which calls a different function name depending on the class of its argument: <code>append.matrix</code> for something of class <code>matrix</code>, <code>append.numeric</code> for something of class <code>numeric</code>, and so on. (Note that <code>.</code> in R is simply a normal character which can be used in identifier names.) I don’t know how well this would work for Ren-C, but it’s probably worth mentioning.</p>
<p>EDIT for clarification: the idea is that <code>append.matrix</code> etc. are completely normal functions which you can define yourself at any time. The generic method <code>append</code> simply dispatches to the relevant function based on its name. When defining a new class, you would also define whichever functions are relevant for use with that class.</p>
<p>(Also, for further inspiration, it may be worth looking at the <a href="https://lispcookbook.github.io/cl-cookbook/clos.html#methods">Common Lisp Object System</a>, though CL is less similar to Rebol than R is.)</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/usermode-multiple-dispatch-in-r-and-common-lisp/2193">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/usermode-multiple-dispatch-in-r-and-common-lisp/2193</link>
          <pubDate>Mon, 19 Aug 2024 05:40:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2193</guid>
          <source url="https://rebol.metaeducation.com/t/usermode-multiple-dispatch-in-r-and-common-lisp/2193.rss">Usermode Multiple Dispatch in R and Common Lisp</source>
        </item>
        <item>
          <title>PicoLisp machine</title>
          <dc:creator><![CDATA[jjsullivan5196]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Pretty comprehensive reference on how picolisp's cons machine works <a href="https://software-lab.de/doc/ref.html#vm" class="inline-onebox" rel="noopener nofollow ugc">PicoLisp Reference</a></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/picolisp-machine/2185">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/picolisp-machine/2185</link>
          <pubDate>Thu, 23 May 2024 06:34:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2185</guid>
          <source url="https://rebol.metaeducation.com/t/picolisp-machine/2185.rss">PicoLisp machine</source>
        </item>
        <item>
          <title>Om: concatenative homoiconic language</title>
          <dc:creator><![CDATA[jjsullivan5196]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <aside class="onebox allowlistedgeneric" data-onebox-src="https://www.om-language.com/">
  <header class="source">

      <a href="https://www.om-language.com/" target="_blank" rel="noopener nofollow ugc">om-language.com</a>
  </header>

  <article class="onebox-body">
    

<h3><a href="https://www.om-language.com/" target="_blank" rel="noopener nofollow ugc">Om: Main Page</a></h3>



  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>This was a one hit wonder on hackernews a couple years ago. Probably the thing of greatest relevance is its "panmorphic" data representation: 3 terminal types of</p>
<ul>
<li>Separators, which compose any utf8 whitespace characters</li>
<li>Operator, essentially symbols of <code>any-other-utf8-text</code>.</li>
<li>Operand, a quoted program in <code>{curlie braces}</code> containing operators or <code>{{other} {operands} and operators}</code> with separators between.</li>
</ul>
<p>The evaluator can define a vocabulary of base "operations" tied to an operator symbol. Every operation takes the rest of the program as input and appends its output. For instance, <code>quote</code> and <code>dequote</code> wrap or unwrap the next term of the program in an enclosing operand. (using <code>-&gt;</code> to indicate output)</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">quote {A}
-&gt; {{A}}
</code></pre>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">dequote {A}
-&gt; A
</code></pre>
<p>More examples on the website</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/om-concatenative-homoiconic-language/2184">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/om-concatenative-homoiconic-language/2184</link>
          <pubDate>Thu, 23 May 2024 02:44:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2184</guid>
          <source url="https://rebol.metaeducation.com/t/om-concatenative-homoiconic-language/2184.rss">Om: concatenative homoiconic language</source>
        </item>
        <item>
          <title>Haskell parser combinators</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>I’ve seen a few parsing-related threads recently in this forum. I haven’t been commenting much on them, since I don’t have enough experience with UPARSE (or for that matter historical PARSE) to say anything helpful.</p>
<p>On the other hand, I <em>do</em> have a lot of experience with parser combinators in Haskell. In terms of structure and purpose, they’re probably the concept most similar to UPARSE that I’ve seen from another language. So I thought I’d write this post in the hope that something, somewhere, might eventually prove useful somehow.</p>
<h2><a name="p-7250-high-level-overview-1" class="anchor" href="https://rebol.metaeducation.com#p-7250-high-level-overview-1"></a>High-level overview</h2>
<p>The first and most important thing to realise about parser combinators is that <strong>they’re not built into the language</strong>. They’re simply ordinary libraries which make it easy to construct parsers compositionally.</p>
<p>(I mean, for that matter, UPARSE isn’t built in either. But there’s a different level of integration with the rest of the language.)</p>
<p>The basic approach is to define a new datatype for parsers, usually called something like <code>Parser a</code>. This is a parser which can process a string (or other datatype), returning a result of type <code>a</code> if it succeeds. Alongside this there will be a set of primitive parsers, most notably <code>char</code> (to parse single characters), <code>return</code> (which always succeeds with a result), and <code>empty</code> (which always fails).</p>
<p>(Of course, practical libraries will have more primitives. <code>megaparsec</code> has <a href="https://hackage.haskell.org/package/megaparsec-9.6.1/docs/Text-Megaparsec.html#g:4">a nice selection</a>, with good comments.)</p>
<p>The most interesting bit is the way these parser combinators are combined to create larger parsers. This, of course, relies on the standard abstractions of Haskell. Two operators are particularly important:</p>
<ul>
<li>Sequencing: <code>p &gt;&gt;= f</code> is a parser which runs <code>p</code> and passes the result to function <code>f</code>, then runs the resulting parser.</li>
<li>Choice: <code>p &lt;|&gt; q</code> is a parser which runs <code>p</code>, then backtracks and runs <code>q</code> if that failed.</li>
</ul>
<p>From these basic elements you can define a very wide range of generic combinators, for instance these useful ones:</p>
<pre data-code-wrap="hs"><code class="lang-hs">-- sequencing ignoring result
(&gt;&gt;) :: Parser a -&gt; Parser b -&gt; Parser b
p &gt;&gt; q = p &gt;&gt;= \_ -&gt; q

-- Match a whole string
string :: String -&gt; Parser ()
string "" = return ()
string (c:cs) = char c &gt;&gt; string cs

-- 1 or more
some :: Parser a -&gt; Parser [a]
some p =
    p &gt;&gt;= \first -&gt;
    many p &gt;&gt;= \rest -&gt;
    return (first : rest)

-- 0 or more
many :: Parser a -&gt; Parser [a]
many p = some p &lt;|&gt; return []
</code></pre>
<h2><a name="p-7250-a-basic-implementation-2" class="anchor" href="https://rebol.metaeducation.com#p-7250-a-basic-implementation-2"></a>A basic implementation</h2>
<p>This is all a little abstract, though. Probably the easiest way to understand parser combinators is to implement them.</p>
<p>A basic implementation is quite simple. A parser is just a function which takes in a string, and on success returns the result alongside the unparsed portion of the string:</p>
<pre data-code-wrap="hs"><code class="lang-hs">newtype Parser a = Parser (String -&gt; Maybe (String, a))
</code></pre>
<p>You then run the parser simply by unwrapping the function and applying it to your input:</p>
<pre data-code-wrap="hs"><code class="lang-hs">runParser :: Parser a -&gt; String -&gt; Maybe (String, a)
runParser (Parser p) input = p input
</code></pre>
<p>Simple parsers work as you’d expect:</p>
<pre data-code-wrap="hs"><code class="lang-hs">char :: Char -&gt; Parser ()
char c = Parser $ \input -&gt; case input of
    (c':cs) | c == c' -&gt; Just (cs, ())
    _ -&gt; Nothing

return :: a -&gt; Parser a
return a = Parser $ \input -&gt; Just (input, a)

empty :: Parser a
empty = Parser $ \_ -&gt; Nothing
</code></pre>
<p>The combinators require more elaborate state-threading, but are still straightforward:</p>
<pre data-code-wrap="hs"><code class="lang-hs">(&gt;&gt;=) :: Parser a -&gt; (a -&gt; Parser b) -&gt; Parser b
p &gt;&gt;= f = Parser $ \input -&gt;
    case runParser p input of
        Nothing -&gt; Nothing
        Just (partiallyParsed, a) -&gt;
            runParser (f a) partiallyParsed

(&lt;|&gt;) :: Parser a -&gt; Parser a -&gt; Parser a
p &lt;|&gt; q = Parser $ \input -&gt;
    case runParser p input of
        Just result -&gt; Just result
        Nothing -&gt; runParser q input
</code></pre>
<p>This simple code suffices for a surprisingly wide variety of tasks. For instance, a slight variant is present in the base library as <a href="https://hackage.haskell.org/package/base-4.16.3.0/docs/Text-Read.html#t:ReadS"><code>ReadS</code></a>. (The variation is that <code>ReadS</code> can produce multiple results.)</p>
<h2><a name="p-7250-managing-backtracking-3" class="anchor" href="https://rebol.metaeducation.com#p-7250-managing-backtracking-3"></a>Managing backtracking</h2>
<p>Unfortunately, <strong>this has serious problems with any larger-scale use</strong>. For one thing, it can’t do error reporting beyond ‘it failed somewhere’. But there are even bigger problems with this implementation of the choice combinator <code>(&lt;|&gt;)</code>:</p>
<ol>
<li>It behaves unpredictably: any error anywhere will result in the parser backtracking to the last choice, and so on until every single choice has been exhausted. This is bad for the time complexity, plus it leaves you no chance of ever reporting errors nicely.</li>
<li>It holds onto the input string during the whole time <code>p</code> is executing. This creates a space leak, which grows larger the more nested choices you have.</li>
</ol>
<p>The first parser combinator library to solve these issues was <code>Parsec</code>. Its design is described in <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/parsec-paper-letter.pdf">this paper</a> (which seems very readable). I won’t describe its implementation here… but the basic idea is simple to summarise: each parser keeps track of what it’s consumed, and <strong>commits to a parser as soon as it’s consumed any characters</strong>.</p>
<p>Some parsers require no changes under this new semantics. For instance, <code>string "first word" &lt;|&gt; string "second word"</code> works without problems. If it sees an input character <code>f</code>, the first choice <code>string "first word"</code> matches immediately, meaning the library can commit to the first parser, and know that the second parser never needs to run. On the other hand, upon seeing an input character <code>'s'</code>, that first parser will fail on that very first character: since no characters have been consumed, control passes over to the second parser to succeed or fail.</p>
<p>On the other hand, more elaborate lookahead becomes more difficult. For instance, <code>string "word 1" &lt;|&gt; string "word 2"</code> no longer works: as soon as this parser sees <code>'w'</code>, it matches the first parser, so the second parser will never be run.</p>
<p>To solve this, Parsec introduces a new primitive combinator: <code>try</code>, which creates a parser which never consumes characters on failure. The effect of this is to allow backtracking over whatever is in the <code>try</code>. For this example, <code>try (string "word 1") &lt;|&gt; string "word 2"</code> would work as expected.</p>
<p>The nice thing about this approach is the control it gives you. For instance, I can write things like:</p>
<pre data-code-wrap="hs"><code class="lang-hs">(try (string "App") &gt;&gt; string "le") &lt;|&gt; string "Apricot"
</code></pre>
<p>Here, as soon as the parser reaches a second <code>'p'</code>, it can commit to the first branch. But if it sees another character, it’s still able to backtrack through the <code>string "App"</code> and move on to the second branch. Of course, this is a contrived example — but in general, being able to specify the control flow of your parser like this is exceedingly useful in larger parsers.</p>
<h2><a name="p-7250-what-use-is-this-for-rebol-4" class="anchor" href="https://rebol.metaeducation.com#p-7250-what-use-is-this-for-rebol-4"></a>What use is this for Rebol?</h2>
<p>Quite probably, none at all.</p>
<p>But like I said, I’m hoping potentially some of this might end up useful somewhere. If it can act as inspiration which helps solve any problems, I’m happy.</p>
<p>And, of course, now that we have this thread for it, feel free to ask me any questions about parser combinators you might have!</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/haskell-parser-combinators/2173">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/haskell-parser-combinators/2173</link>
          <pubDate>Mon, 11 Mar 2024 15:08:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2173</guid>
          <source url="https://rebol.metaeducation.com/t/haskell-parser-combinators/2173.rss">Haskell parser combinators</source>
        </item>
        <item>
          <title>Raku (Perl 6) Type System</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="19" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/19">Ugly Types: Less Ugly Than History, Can We Do Better?</a></div>
<blockquote>
<p>That’s why I think it’s a good idea to keep TYPE OF a direct reflection of the heart-byte, and use other constructions for code which needs other things.</p>
</blockquote>
</aside>
<p>I’ve just discovered a bit of prior art for this, in the form of Raku (i.e., the language formerly known as Perl 6). Its equivalent to TYPE OF, namely <a href="https://docs.raku.org/language/mop#WHAT">WHAT</a>, returns only the ‘type object’ of which the value is an instance. By contrast, type matching (and pattern matching) is done using <a href="https://docs.raku.org/type/Mu#method_ACCEPTS">ACCEPTS</a> with a <a href="https://docs.raku.org/language/signatures">signature literal</a>, which is a much more flexible syntax allowing all kinds of constraints to be expressed.</p>
<p>Actually, now that I think of it, Raku signature literals strike me as quite a nice approach. For Ren-C, they suggest the idea of having a ‘type-matching dialect’… though, then again, I guess that’s something I <a href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/2">already suggested above</a>.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/raku-perl-6-type-system/2156">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/raku-perl-6-type-system/2156</link>
          <pubDate>Sun, 25 Feb 2024 12:53:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2156</guid>
          <source url="https://rebol.metaeducation.com/t/raku-perl-6-type-system/2156.rss">Raku (Perl 6) Type System</source>
        </item>
        <item>
          <title>Racket&#39;s Language-Oriented Programming</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Racket has something called <a href="https://school.racket-lang.org/2019/plan/mon-mor-lecture.html">"Language-Oriented Programming"</a>.  <a class="mention" href="https://rebol.metaeducation.com/u/bradrn">@bradrn</a> brought it up, and wrote:</p>
<aside class="quote no-group quote-modified" data-username="bradrn" data-post="10" data-topic="2136">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/fundamental-distinguishing-features-of-rebol/2136/10">Fundamental distinguishing features of Rebol</a></div>
<blockquote>
<p>I think there’s an interesting contrast to be made here to <a href="https://racket-lang.org/">Racket</a>’s ‘language-orientated programming’ (basically a different name for dialecting). Racket people talk a lot about defining new languages to solve problems, just like Rebol… but in practice, I’m not sure how much they actually do it. Part of the problem may be that those new languages <em>are</em> very different to base Racket — so not only do you have to write the interpreter, you have to write the parser as well. By contrast, since Rebol dialects have a similar free-form nature as Rebol code, you can get away with minimal parsing and no lexing, which in turn makes dialecting easier to achieve. (Still not as easy as macros, though.)</p>
</blockquote>
</aside>
<p>So I've moved that here to a thread to discuss Racket, if there are any interesting ideas there.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/rackets-language-oriented-programming/2143">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/rackets-language-oriented-programming/2143</link>
          <pubDate>Thu, 01 Feb 2024 00:54:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2143</guid>
          <source url="https://rebol.metaeducation.com/t/rackets-language-oriented-programming/2143.rss">Racket&#39;s Language-Oriented Programming</source>
        </item>
        <item>
          <title>Haskell&#39;s Composable Splitting Combinators</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="5" data-topic="2104">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/naming-for-line-and-space-adders-and-removers/2104/5">Naming for Line and Space Adders and Removers</a></div>
<blockquote>
<p>I've never paid much attention to [SPLIT], so I haven't put in my 2 cents on the design.</p>
</blockquote>
</aside>
<p>For prior art it might be worth looking at Haskell’s <a href="https://hackage.haskell.org/package/split-0.2.4"><code>split</code></a> library, and in particular <a href="https://hackage.haskell.org/package/split-0.2.4/docs/Data-List-Split.html#g:4">its nice set of composable splitting combinators</a>. There’s probably some way to turn this into a nice Rebol dialect, though this is something I haven’t really thought about before.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/haskells-composable-splitting-combinators/2105">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/haskells-composable-splitting-combinators/2105</link>
          <pubDate>Thu, 11 Jan 2024 07:48:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2105</guid>
          <source url="https://rebol.metaeducation.com/t/haskells-composable-splitting-combinators/2105.rss">Haskell&#39;s Composable Splitting Combinators</source>
        </item>
        <item>
          <title>R: a very Rebol-like language</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>In my <a href="https://rebol.metaeducation.com/t/what-if-blocks-had-scopes-but-not-individual-words/2085">last post</a>, I mentioned that the <a href="https://www.r-project.org/">R</a> language is remarkably similar to Rebol in some respects. Now, R is not perfect — there is <a href="https://www.burns-stat.com/pages/Tutor/R_inferno.pdf">a lot to complain about</a> (126 pages of it, to be precise). But as a widely-used language with similar concepts, it’s worth taking a look at.</p>
<p>(A warning: I don’t actually know very much about R, and much of the below was assembled from various bits of the <a href="https://cran.r-project.org/doc/manuals/r-release/R-lang.pdf">Language Definition</a>. It seems pretty straightforward, though.)</p>
<p>Two features of R in particular remind me of Rebol. The first is its <a href="https://doi.org/10.1145/3360579">peculiar</a> implementation of lazy evaluation: not only are function arguments passed as unevaluated thunks, but the original code can be introspected, manipulated and evaluated. (Putting it in Lisp terms, every R function is an <a href="https://en.wikipedia.org/wiki/Fexpr">fexpr</a>.)</p>
<p>The second is its treatment of scopes. In R, <em>environments</em> are a first-class data structure, consisting of a lookup table from symbols to values (‘frame’), and a pointer to an enclosing pointer (‘enclosure’). Each function contains a reference to the environment in which it was created; when called, it creates a new frame, and assembles the evaluation environment from that frame and the enclosing environment. Of course, since environments are first-class values, all of this can be manipulated from within the function itself.</p>
<p>These two concepts come together in the form of <em>promises</em> — conceptually, R’s answer to Rebol block!s. Promises contain unevaluated code, together with the environment in which it was created. Promises can be explicitly created, but all function arguments are implicitly represented as promises. When used, the code is evaluated in the environment to get the value of the function argument. But it is also possible to retrieve the unevaluated code, then manipulate it and/or evaluate it in another environment.</p>
<p>Alas, base R gives no way to retrieve the environment of a promise. This is fixed by the <a href="https://rlang.r-lib.org/"><code>rlang</code></a> package, which (amongst other things) gives a greatly more ergonomic interface for unevaluated code. Its basic data structure is the ‘quosure’, again storing code+environment. One can create these explicitly from function arguments, but more often they are manipulated via <code>rlang</code>’s quasiquoting functions.</p>
<p>For instance:</p>
<pre data-code-wrap="r"><code class="lang-r">&gt; get_mean &lt;- function(data, var) dplyr::summarise(data, mean({{ var }}))
&gt; get_mean(data, air_temp)
  mean(air_temp)
1       21.36986
</code></pre>
<p>Which (if I haven’t messed anything up) should be equivalent to the following Rebol code:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">get-mean: func [data var] [summarise data compose [mean (var)]]
get-mean data [air-temp]
</code></pre>
<p>Incidentally, this shows a major use of R’s metaprogramming facilities: accessing variables in a data frame. Here, <code>data</code> is a table of weather measurements I happen to have, with <code>air_temp</code> being one of the columns. To my understanding, <code>dplyr::summarise</code> works by creating a new environment from its first argument <code>data</code>, then evaluates its second argument <code>mean(air_temp)</code> in that environment — which is why <code>air_temp</code> points to a column of <code>data</code> rather than some global variable. This is known as ‘data-masking’, and is widely used within the <a href="https://www.tidyverse.org/">tidyverse libraries</a>.</p>
<p>Rebol, of course, has different solutions to these problems. Instead of having functions automatically quote their arguments, the caller is expected to create block!s as needed. And, instead of associating environments with unevaluated expressions, Rebol associates a binding with each word!. This has advantages (quasiquotation is easier to reason about) and disadvantages (scopes no longer exist). But the end result is much the same: functions have complete control over where, when and how their arguments are evaluated.</p>
            <p><small>16 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087</link>
          <pubDate>Sat, 30 Dec 2023 09:36:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2087</guid>
          <source url="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087.rss">R: a very Rebol-like language</source>
        </item>
        <item>
          <title>The Sherman Rebol-To-Scheme Compiler</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Joe Marshall was one of the developers of <a href="https://en.wikipedia.org/wiki/MIT/GNU_Scheme">MIT/GNU Scheme</a>, who worked briefly (less than 6 months) at Rebol Technologies in 1998, and wrote the implementation of Rebol 1.0.</p>
<p>On his blog, "Abstract Heresies", <a href="https://funcall.blogspot.com/2023/06/tail-recursion-in-rebol.html">Joe has a remark</a> about how his implementation was received:</p>
<blockquote>
<p>With it’s Polish notation, tail recursion, and first-class continuations, REBOL was described as an unholy cross between TCL and Scheme. “The result of Outsterhout and Sussman meeting in a dark alley.”</p>
</blockquote>
<p>It seems pretty clear that Joe was not a good fit for looking at the problems posed by Rebol, because <em>he just didn't really like the idea</em>.  For starters, <a href="https://groups.google.com/g/comp.lang.lisp/c/vWfjkdG0lME/m/K48slCehF1AJ">a post on comp.lang.lisp</a> suggests that Joe was opposed on principle to Rebol's parentheses-less-ness:</p>
<blockquote>
<p>[Not using parentheses] turns out to be a bad idea. Not only does it greatly complicate the interpreter and compiler, it turns out to be rather <em>un</em>readable in practice. As an example, here is a line from the REBOL BBS tutorial:</p>
<pre><code>update-topic topic-id length? msgs first last msgs
</code></pre>
<p>Certainly REBOL knows how many arguments each function takes (and which of those identifiers refer to functions), but if <em>you</em> don't know, you can't parse it.</p>
</blockquote>
<p>So after his initial implementation, he walked.  He calls Rebol 2.0 a <a href="https://github.com/akavel/sherman">"quirky and bizarre language" in which he "doesn't see any opportunity"</a>.</p>
<p>It would seem he lacks interest in absorbing what came later--e.g. <a href="https://rebol.metaeducation.com/t/introducing-the-hackable-usermode-parse-uparse/1529">to find the potential in something like the PARSE dialect</a>  He never mentions it or any other dialect, but focuses on the negative side of handling baseline IF-WHILE-FUNC imperative code, without calling out any ideas he sees as interesting.</p>
<h2><a name="p-6759-a-trivial-program-walked-through-in-sherman-1" class="anchor" href="https://rebol.metaeducation.com#p-6759-a-trivial-program-walked-through-in-sherman-1"></a>A Trivial Program Walked Through in "Sherman"</h2>
<p>It's clear that Rebol 1.0 was written in C...though some people believe it was written in Scheme.  The air was probably muddied a bit because since Lisp is his <em>lingua-franca</em>, he's shared Scheme pseudocode explaining the premises of the evaluator he'd written.  (It's likely that he wrote such prototypes before tackling the C implementation, as well).</p>
<p>Also confusing matters a bit is that in 1999 right after leaving Rebol technologies, he published a Rebol-to-Scheme compiler called Sherman:</p>
<p><a href="https://github.com/akavel/sherman" class="inline-onebox">GitHub - akavel/sherman: A clone of Joe Marshall's Rebol 1.0 to Scheme compiler.</a></p>
<p>Sherman requires a very old version of Scheme to run, and that only runs on 32-bit machines.  Modernizing it is not a good use of anyone's time, but fortunately Windows still runs old 32-bit EXEs... so <a href="https://github.com/akavel">GitHub user akavel</a> pieced together the steps.</p>
<p>For a start, let's see how it works on a program called <code>trivial.r</code>:</p>
<pre><code>rebol []

declare [standard-definitions]

foo: func [a] [a + 3]
print "Hello world!"
prin "3 + 3 ="
print foo 3
</code></pre>
<p>In Step One, he uses <a href="https://en.wikipedia.org/wiki/Flex_(lexical_analyser_generator)">a tool called Flex</a>  (Fast Lexical Analyzer) to <em>"translate a language like REBOL into a fully parenthesized notation."</em>  The small specification <a href="https://github.com/hostilefork/sherman/blob/master/R2S.L">R2S.L</a> would turn the above into this:</p>
<pre><code>`(SHERMAN ,(LIST-&gt;BLOCK `(,(LIST-&gt;BLOCK `())
declare ,(LIST-&gt;BLOCK `(standard-definitions ))
foo: func ,(LIST-&gt;BLOCK `(a)) ,(LIST-&gt;BLOCK `(a + 3))
print "Hello world!"
prin "3 + 3 ="
print foo 3
))) ;; END of SHERMAN CODE
</code></pre>
<p>This transformed the code enough so that Scheme could load it for further processing.  Here all it did was get rid of the unloadable square brackets and turn them into parentheses that are tagged as LIST-&gt;BLOCK.  But other transformations would turn literals like <strong>12-Dec-2012</strong> into labeled strings like <strong>,(SHERMAN-DATE "12-Dec-2012")</strong>.  It did some amount of validation in the process...but not exhaustive, so you could still get some invalid representations that would have to be caught by the runtime.</p>
<p>The next step of transformation makes something that Scheme can execute...although it isn't written in a way that any Scheme programmer would write code.  It's just using the language as a runtime/bytecode, and so it looks like what you get from a disassembler:</p>
<pre><code>(#%define-values (foo) (#%values #f))
(#%begin
  (#%list-&gt;block (list))
  (#%set! foo
    (#%lambda (a)
      (#%if (#%procedure? a)
        (#%case (#%arity a)
          ((0) (+ (a) 3))
          (else (#%error "Too few arguments." (#%quote a))))
        (+ a 3))))
  (print "Hello world!")
  (prin "3 + 3 =")
  (#%if (#%procedure? foo)
    (#%case (#%arity foo)
      ((0) (#%begin (print (foo))))
      ((1) (print (foo 3)))
      (else (#%error "Too few arguments." (#%quote foo))))
    (#%begin (print foo))))
</code></pre>
<p>Notice that where a WORD! occurs the compiled form has a fixed number of switches on the arity.  You have <strong>foo: func [a] [a + 3]</strong>, and when it hits the <strong>a</strong> in the body it checks to see if it's a function...and if it is, then it enforces that it takes no arguments since it's on the left of the plus sign and invokes it.  Note that invocation in Lisp means putting a symbol at the head of non-quoted parentheses, so <strong>(a)</strong> is a "function call" in <strong>(+ (a) 3)</strong>.</p>
<p>But what would this do if you said <strong>foo: func [a] [a 10 20 30]</strong>?  Does it handle arity-0 or arity-1 or arity-2 or arity-3 or error?  The answer is...yes:</p>
<pre><code>  (#%if (#%procedure? a)
    (#%case (#%arity a)
      ((0) (#%begin (a) none))
      ((1) (#%begin (a 10) none))
      ((2) (#%begin (a 10 20)))
      ((3) (a 10 20 30))
      (else (#%error "Too few arguments." (#%quote a))))
    (#%begin a none))))
</code></pre>
<p>The approach is at odds with the language design.  Let's say you wrote something like:</p>
<pre><code>foo: func [a b] [
   if a = b [alpha a b] else [alpha b a beta a b]
]
</code></pre>
<p>You'd start with a hardcoded switch statement to cover the case where <strong>if</strong> is anywhere from arity-0 to arity-6 to consume everything in the body.  Then for each of those branches, you'd have the combinatorial explosion... the arity-6 case has to consider if <strong>a</strong> is arity-0 to arity-5, but so does the arity-5 case.</p>
<p>The explosion is pathological.  Just to show how much so, let's change it to <strong>foo: func [a] [a a a a]</strong>.  The result is so big I'm just going to paste a picture of it broken into columns:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/05392c4197eb8c18ce5def7c2ad612779019a9f6.png" data-download-href="https://rebol.metaeducation.com/uploads/default/05392c4197eb8c18ce5def7c2ad612779019a9f6" title="image"><img src="https://rebol.metaeducation.com/uploads/default/original/1X/05392c4197eb8c18ce5def7c2ad612779019a9f6.png" alt="image" data-base62-sha1="KcSxsUQKxHzkbuOzuXQRGBRzfw" width="690" height="334" data-dominant-color="EBEBEB"></a></div><p></p>
<h2><a name="p-6759-he-knew-this-wasnt-very-useful-2" class="anchor" href="https://rebol.metaeducation.com#p-6759-he-knew-this-wasnt-very-useful-2"></a>He Knew This Wasn't Very Useful</h2>
<p>This isn't something Joe doesn't know about.  On <a href="http://ll1.ai.mit.edu/">MIT's "Lightweight Languages"</a> mailing list, <a href="https://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03917.html">Joe had this remark</a>:</p>
<blockquote>
<p>Rebol is <em>extremely</em> difficult to compile in any meaningful sense.  Since the parse tree can change dynamically at runtime, there is a combinatoric explosion of code paths.  You can constrain things a bit by allowing the user to declare procedure arity, though.</p>
</blockquote>
<p>The notes say:</p>
<blockquote>
<p><em>"I decided to see if I couldn't write a compiler for the language. The main challenge is that the language is context-sensitive and parsing depends on runtime values. It isn't possible to build a useful abstract syntax tree at compile time because it is impossible to determine the role each identifier plays until it's value is known. Furthermore, an identifier may indicate a variable at some times or a function call at others."</em></p>
<p><em>"The trick of Sherman is to simply generate the control flow for all the parse options and dispatch to the correct one at runtime. This makes a combinatorical explosion, but it is possible to prune the control flow tree if the compiler can make assumptions about certain identifiers."</em></p>
</blockquote>
<p>It would generally seem you'd have to hybridize an evaluative approach vs. compiling if you allowed any symbols with unknown arity...as even super short examples like the <strong>[a a a a]</strong> above are prohibitive.  But if you were already putting in some amount of compilation then maybe cases like <strong>[a 1]</strong> are worth compiling.</p>
<h2><a name="p-6759-putting-sherman-in-context-3" class="anchor" href="https://rebol.metaeducation.com#p-6759-putting-sherman-in-context-3"></a>Putting Sherman In Context</h2>
<p>So what was the value of publishing this non-viable Rebol compiler?</p>
<p>It's an experiment that I'd doubt took him more than a few days.  I'd imagine it was done as a palate-cleanser to return to Scheme and demonstrate how much of a "new" problem can be attacked when recast using infrastructure that people have developed through experience.</p>
<p>And perhaps its his way of saying: "if for some reason you think there's value in Rebol's notational choices, you can have your source look like that... just run a transformation into Scheme."</p>
<p><em>(Perhaps how I look at <a href="https://rebol.metaeducation.com/t/skinning-replace-with-reds-string-parse-hack/2043">being able to bend Ren-C to do things Red does</a>... it's not that I think their idea is necessarily good, I just want to check to make sure I can do it.)</em></p>
<p>In any case, this addresses a rumor I heard that Rebol 1.0 was written in Scheme.  But it seems it was interpreted in a way we would think of today...and more in the spirit of Ren-C...which can indeed <a href="https://rebol.metaeducation.com/t/tail-calls-in-ren-c-yes-we-have-them/2082">handle things like tail-call recursion</a>.</p>
<p>Also, he thought it was a requirement for Rebol to be stackless.  He didn't think you could solve it by writing a few native functions like IF and WHILE in C to get them to use less stack: some stack is still consumed, and users will still be writing their own loops and control constructs.  Of course I agree (<a href="https://rebol.metaeducation.com/t/stackless-is-here-today-now/1844">and Ren-C is stackless</a>), but I can imagine that Carl's desire for expedience vs. doing continuations would be a point of conflict.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/the-sherman-rebol-to-scheme-compiler/2076">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/the-sherman-rebol-to-scheme-compiler/2076</link>
          <pubDate>Mon, 11 Dec 2023 21:30:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2076</guid>
          <source url="https://rebol.metaeducation.com/t/the-sherman-rebol-to-scheme-compiler/2076.rss">The Sherman Rebol-To-Scheme Compiler</source>
        </item>
        <item>
          <title>Lisps, Kernel, Clojure: limits of &quot;Code is Data and Data is Code&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>I had little-to-no Lisp experience when I encountered Rebol.  I just knew the general concept of "code is data, and data is code", and assumed they were similar.</p>
<p>But as it turns out, <em>executing arbitrary structures of code constructed at runtime is taboo in most Lisps.</em>  This comes under the umbrella of "EVAL", and <a href="https://stackoverflow.com/questions/2571401/why-exactly-is-eval-evil">warned against for all the reasons that people say it's bad in any language</a>...such as why you wouldn't want to run an arbitrary string of JavaScript code.  About the only exception they seem to consider is the Read-Eval-Print-Loop: <strong><code>(loop (print (eval (read))))</code></strong>.</p>
<p>There are warnings about the inefficiency of EVAL not being compiled...or the security concerns of running fully arbitrary code that is cobbled together from possibly unsanitized sources (which Rebol deliberately ignores).</p>
<p>If you're willing to ignore that, you still face the Big Mechanical Problem:</p>
<blockquote>
<p><em>"[EVAL] evaluates under the global environment, losing your local context."</em></p>
</blockquote>
<h2><a name="p-6724-but-if-so-how-do-branches-work-in-lisps-1" class="anchor" href="https://rebol.metaeducation.com#p-6724-but-if-so-how-do-branches-work-in-lisps-1"></a>But If So... How Do Branches Work in Lisps?</h2>
<p>If you have a branching function like EITHER, and it has two legs of the branch with the intent to only run one of them... doesn't that require selectively running an "EVAL"?  The EITHER receives a condition and then two "blocks" (lists) specifying arbitrary code.  If you lose all your local variables known at the callsite of the EITHER, how can it work?</p>
<p>The answer depends on which Lisp variation you are using.  If you are using a classical Lisp (or Clojure), it simply has a list of exceptions... or "special forms".  These constructs are treated weirdly by the compiler and it's just swept under the rug.  For example:</p>
<p><strong><a href="https://clojure.org/reference/special_forms">Special Forms in Clojure</a></strong></p>
<p>Another possibility would be if there was some kind of environment capture at the callsite, and the EITHER received this environment as a parameter.  Then it could pass that environment to EVAL...so the eval would happen as if it were at the callsite.</p>
<p>Were that written in a Rebol-like syntax, it would be quoting all its arguments and look like:</p>
<pre><code> either: func [
     'condition [group!]  ; conditions would have to be grouped
     'true_branch [block!]
     'false_branch [block!]
     &lt;environment&gt; env  ; implicit capture of environment at callsite
 ][
     if do/environment condition env [  ; let's say IF is a native
         return do/environment true_branch env
     ]
     return do/environment false_branch env
 ]
</code></pre>
<p>Now that you're familiar with the idea, here is that written in how the <a href="https://web.cs.wpi.edu/~jshutt/kernel.html">"Kernel" Lisp Variant</a> does it:</p>
<pre><code>($define! $either
   ($vau (condition true_branch false_branch) env
       ($if (&gt;=? (eval condition env) 0)
           (eval true_branch env)
           (eval false_branch env))))
</code></pre>
<p>Notably, <strong>Kernel is considered a very experimental black-sheep of the Lisp world</strong>, due to how much slower this generalized method of thinking is.  Special forms understood by the compiler are the norm.</p>
<p>However, being able to pass environments to EVAL is <a href="https://www.gnu.org/software/texinfo/gsoc-2017-js-example/kawa/Eval-and-Environments.html">seemingly endorsed in modern Scheme</a>.  But that's not a feature of Clojure.</p>
<h2><a name="p-6724-macros-cover-some-monkeying-with-code-structure-cases-2" class="anchor" href="https://rebol.metaeducation.com#p-6724-macros-cover-some-monkeying-with-code-structure-cases-2"></a>Macros Cover Some Monkeying-With-Code-Structure Cases</h2>
<p>Lisp Macros can be used for source-to-source transformations, manipulating structure in the free-wheeling way we might think of doing in Rebol.  But that transformation happens only once.</p>
<p>This Reddit question <a href="https://www.reddit.com/r/lisp/comments/13rmllb/difference_between_function_with_quoted_arguments/">asks about the difference between macros and receiving arguments unevaluated</a>:</p>
<blockquote>
<p><em>"If we put a backtick in front of the body of a function and we pass arguments quoted when calling it, wouldn't the function work the same as a macro (except that macros are evaluated in an earlier stage)? What would be the difference in practice? And how does this approach compare to fexpr?"</em></p>
</blockquote>
<p>The answers outline the difference... macros just run once, and they don't call EVAL on the code they get... they just return new code which will be evaluated later.  If you wrote something like an EITHER as a macro, you would have to transform it into IFs, and be dependent on the special forms to do the actual "weird" mechanic.</p>
<h2><a name="p-6724-isnt-this-kind-of-weak-for-the-data-is-code-mantra-3" class="anchor" href="https://rebol.metaeducation.com#p-6724-isnt-this-kind-of-weak-for-the-data-is-code-mantra-3"></a>Isn't This Kind of Weak for the "Data is Code" Mantra?</h2>
<p>It does seem disappointing.  :-/</p>
<p>But Lisps haven't taken over the world, and maybe this is part of why.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/lisps-kernel-clojure-limits-of-code-is-data-and-data-is-code/2060">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/lisps-kernel-clojure-limits-of-code-is-data-and-data-is-code/2060</link>
          <pubDate>Sat, 11 Nov 2023 21:52:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2060</guid>
          <source url="https://rebol.metaeducation.com/t/lisps-kernel-clojure-limits-of-code-is-data-and-data-is-code/2060.rss">Lisps, Kernel, Clojure: limits of &quot;Code is Data and Data is Code&quot;</source>
        </item>
        <item>
          <title>Is there anything like parse in other languages?</title>
          <dc:creator><![CDATA[johnk]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>I have been away for a while and I am missing parse. I was wondering if you know of any similar parsers in other languages like Python or R?</p>
            <p><small>5 posts - 4 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/is-there-anything-like-parse-in-other-languages/2032">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/is-there-anything-like-parse-in-other-languages/2032</link>
          <pubDate>Thu, 25 May 2023 09:17:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2032</guid>
          <source url="https://rebol.metaeducation.com/t/is-there-anything-like-parse-in-other-languages/2032.rss">Is there anything like parse in other languages?</source>
        </item>
        <item>
          <title>&quot;Factor&quot; // Slava Pestov&#39;s beautiful language</title>
          <dc:creator><![CDATA[vnzio]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <aside class="onebox allowlistedgeneric" data-onebox-src="https://factorcode.org/">
  <header class="source">
      <img src="https://factorcode.org/favicon-32x32.png" class="site-icon" width="32" height="32">

      <a href="https://factorcode.org/" target="_blank" rel="noopener nofollow ugc">factorcode.org</a>
  </header>

  <article class="onebox-body">
    

<h3><a href="https://factorcode.org/" target="_blank" rel="noopener nofollow ugc">Factor programming language</a></h3>



  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<aside class="onebox wikipedia" data-onebox-src="https://en.wikipedia.org/wiki/Factor_%28programming_language%29?wprov=sfla1">
  <header class="source">

      <a href="https://en.wikipedia.org/wiki/Factor_%28programming_language%29?wprov=sfla1" target="_blank" rel="noopener nofollow ugc">en.wikipedia.org</a>
  </header>

  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:250/155;"><img src="//upload.wikimedia.org/wikipedia/en/thumb/f/ff/NewFactorLogo.png/250px-NewFactorLogo.png" class="thumbnail" width="250" height="155"></div>

<h3><a href="https://en.wikipedia.org/wiki/Factor_%28programming_language%29?wprov=sfla1" target="_blank" rel="noopener nofollow ugc">Factor (programming language)</a></h3>

<p>Factor is a stack-oriented programming language created by Slava Pestov. Factor is dynamically typed and has automatic memory management, as well as powerful metaprogramming features. The language has a single implementation featuring a self-hosted optimizing compiler and an interactive development environment. The Factor distribution includes a large standard library.
 Slava Pestov created Factor in 2003 as a scripting language for a video game. The initial implementation, now referred to as JFa...</p>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>Google Tech Talk 2008</p><p><a href="https://www.youtube.com/watch?v=f_0QlhYlS8g">Factor: an extensible interactive language</a></p>

<p>Silicon Valley Forth Interest Group<br>
2022<br>
"Factor in 2022"</p><p><a href="https://www.youtube.com/watch?v=OLh61q4c4XE">2022-03-26 --- Factor in 2022 --- John Benediktsson &amp; Doug Coleman</a></p>

            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/factor-slava-pestovs-beautiful-language/2029">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/factor-slava-pestovs-beautiful-language/2029</link>
          <pubDate>Mon, 17 Apr 2023 23:10:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2029</guid>
          <source url="https://rebol.metaeducation.com/t/factor-slava-pestovs-beautiful-language/2029.rss">&quot;Factor&quot; // Slava Pestov&#39;s beautiful language</source>
        </item>
        <item>
          <title>Pikchr Drawing Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>This is an interesting dialect-looking thing that's a Unix utility someone showed me for diagrams.  It might interest <a class="mention" href="https://rebol.metaeducation.com/u/rgchris">@rgchris</a>, or others.  It's called PIKCHR.</p>
<p>You can try it online at <a href="https://pikchr.org/home/pikchrshow">https://pikchr.org/home/pikchrshow</a> ... there are a few examples.</p>
<p>It's a textual set of instructions that lets you lay things out... but differently from something like PDF, it captures intents in a pretty interesting way for aligments and duplication.</p>
<p>Look how it lays out this "swim lanes" example graphic:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/babd46454d69ba774a09050d20d26dc3e2e9e326.png" data-download-href="https://rebol.metaeducation.com/uploads/default/babd46454d69ba774a09050d20d26dc3e2e9e326" title="image"><img src="https://rebol.metaeducation.com/uploads/default/original/1X/babd46454d69ba774a09050d20d26dc3e2e9e326.png" alt="image" data-base62-sha1="qDYklKuijn94kAkO07RmNG9E6YS" width="520" height="449"></a></div><p></p>
<pre><code>$laneh = 0.75
# Draw the lanes
down
box width 3.5in height $laneh fill 0xacc9e3
box same fill 0xc5d8ef
box same as first box
box same as 2nd box
line from 1st box.sw+(0.2,0) up until even with 1st box.n "Alan" above aligned
line from 2nd box.sw+(0.2,0) up until even with 2nd box.n "Betty" above aligned
line from 3rd box.sw+(0.2,0) up until even with 3rd box.n "Charlie" above aligned
line from 4th box.sw+(0.2,0) up until even with 4th box.n "Darlene" above aligned
# fill in content for the Alice lane
right
A1: circle rad 0.1in at end of first line + (0.2,-0.2) fill white thickness 1.5px "1"
arrow right 50%
circle same "2"
arrow right until even with first box.e - (0.65,0.0)
ellipse "future" fit fill white height 0.2 width 0.5 thickness 1.5px
A3: circle same at A1+(0.8,-0.3) "3" fill 0xc0c0c0
arrow from A1 to last circle chop "fork!" below aligned
# content for the Betty lane
B1: circle same as A1 at A1-(0,$laneh) "1"
arrow right 50%
circle same "2"
arrow right until even with first ellipse.w
ellipse same "future"
B3: circle same at A3-(0,$laneh) "3"
arrow right 50%
circle same as A3 "4"
arrow from B1 to 2nd last circle chop
# content for the Charlie lane
C1: circle same as A1 at B1-(0,$laneh) "1"
arrow 50%
circle same "2"
arrow right 0.8in "goes" "offline"
C5: circle same as A3 "5"
arrow right until even with first ellipse.w "back online" above "pushes 5" below "pulls 3 &amp; 4" below
ellipse same "future"
# content for the Darlene lane
D1: circle same as A1 at C1-(0,$laneh) "1"
arrow 50%
circle same "2"
arrow right until even with C5.w
circle same "5"
arrow 50%
circle same as A3 "6"
arrow right until even with first ellipse.w
ellipse same "future"
D3: circle same as B3 at B3-(0,2*$laneh) "3"
arrow 50%
circle same "4"
arrow from D1 to D3 chop
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/pikchr-drawing-dialect/2018">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/pikchr-drawing-dialect/2018</link>
          <pubDate>Tue, 28 Feb 2023 22:17:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2018</guid>
          <source url="https://rebol.metaeducation.com/t/pikchr-drawing-dialect/2018.rss">Pikchr Drawing Dialect</source>
        </item>
        <item>
          <title>Kaitai Struct Declarative Language for Binary Formats</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>This is an interesting declarative language in YAML designed to generate classes for binary formats.  There are many formats defined:</p>
<p><a href="https://formats.kaitai.io/">https://formats.kaitai.io/</a></p>
<p>That's a lot of cases...but as one instructive example, you can look at how it describes a ZIP file--with little snippets of code in it for extracting the values:</p>
<p><a href="https://formats.kaitai.io/zip/" class="inline-onebox">ZIP archive file format spec for Kaitai Struct</a></p>
<p>The C++ code generated is like this:</p>
<p><a href="https://formats.kaitai.io/zip/cpp_stl_11.html" class="inline-onebox">ZIP archive file: C++11/STL parsing library</a></p>
<p>But it also can also be used to make code for C#, JavaScript, Python, Ruby, Nim, PHP, Lua, Perl... <em>(though we'd assume that if you escape code in, that part will only work be available for that language)</em></p>
<p>The regimentation of YAML provides the typical repetition in the "dialect".  This is the same as the Rebol complaint about JSON--not really leveraging "parts of speech", but repeating tags over and over like <code>id:</code> and <code>type:</code></p>
<pre><code>  - id: version
    type: u2
  - id: flags
    type: gp_flags
    size: 2
  - id: compression_method
    type: u2
    enum: compression
</code></pre>
<p>But it's still pretty hard to compete with, especially when you consider this is giving a compilable specification...so the performance is going to be much better.</p>
<p>I always thought BINARY! parse was something that Rebol would have a unique story for, and Ren-C's UPARSE makes that a stronger story (by allowing rules to synthesize arbitrary results via extraction)... but seeing this kind of stuff reminds me that there are diminishing returns.</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/kaitai-struct-declarative-language-for-binary-formats/2016">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/kaitai-struct-declarative-language-for-binary-formats/2016</link>
          <pubDate>Tue, 21 Feb 2023 22:36:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2016</guid>
          <source url="https://rebol.metaeducation.com/t/kaitai-struct-declarative-language-for-binary-formats/2016.rss">Kaitai Struct Declarative Language for Binary Formats</source>
        </item>
        <item>
          <title>Haskell and Rust Error Handling</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Ren-C is shoring up Rebol's historically problematic exception-based error handling by blending together two mechanics: definitional returns and isotopic errors.  This gives what I'm calling "definitional failures":</p>
<p><a href="https://rebol.metaeducation.com/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852" class="inline-onebox">FAIL vs. RETURN RAISE: The New Age of Definitional Errors!</a></p>
<p>Pivoting to this line of thinking has some non-accidental similarity to <a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Data-Either.html">Haskell's <code>Either</code></a> and <a href="https://doc.rust-lang.org/std/result/">Rust's <code>Result</code></a>, which I mentioned when first sketching out the motivation for change:</p>
<p><a href="https://rebol.metaeducation.com/t/the-need-to-rethink-error/1371" class="inline-onebox">The Need To Rethink ERROR!</a></p>
<p>I thought it would be worth it to make a thread for pointing out similarities and differences, and if there are libraries they use that might have relevant inspiration.</p>
<h2><a name="p-6481-an-out-of-band-state-on-the-value-is-like-an-isotope-1" class="anchor" href="https://rebol.metaeducation.com#p-6481-an-out-of-band-state-on-the-value-is-like-an-isotope-1"></a>An Out-Of-Band State On The Value Is... Like An Isotope?</h2>
<p>Either is fully generic beyond just allowing errors (and <a href="https://docs.rs/either/latest/either/">Rust has its own generic Either</a> as well).  So you can really say whatever you are returning can come in two forms: the left form vs. the right form.</p>
<p>But even Rust's <code>Result</code> container will permit you to make an Error class the "valid" result, as well as the "invalid" result.</p>
<p>So here we see generic way of letting a value carry a bit--independent of what the payload is--saying whether that is a "normal" state or a "weird" state.  Then, the system has an assortment of operations that are designed for directing program flow in different ways reacting to it.</p>
<p>Ren-C embraces this deeply: effectively saying that every variable and expression product has the potential of being in this "weird" state... and <em>no array can contain a value in the weird state</em>.  But you don't have to do anything special to a value that <em>isn't</em> weird to extract it... you just get runtime errors if you use the weird values where they're not expected.</p>
<h2><a name="p-6481-rust-tackles-low-hanging-fruit-via-unwrap-and-2" class="anchor" href="https://rebol.metaeducation.com#p-6481-rust-tackles-low-hanging-fruit-via-unwrap-and-2"></a>Rust Tackles Low-Hanging Fruit via <code>unwrap()</code> and <code>?</code></h2>
<p>In Ren-C, if you don't have handling at the callsite when a definitional error happens, it's promoted to being more like a throw--and most code should not intercept it.</p>
<p>Being more formal by nature, both Haskell and Rust force <em>some</em> handling at the callsite when an error result is possible.  You have to define a code path to take if there's an error, or a code path to take if there's not.</p>
<p>But Rust has a couple of conveniences.  If you want something like the Ren-C behavior, you can just call the <code>.unwrap()</code> method on the result.  It will give you the ordinary value if the function didn't return, otherwise raise the error as a "panic".</p>
<p>There's also a cool shortcut with a postfix operator of <strong>?</strong> on the call.  This makes it so that if you call a function that returns a <code>Result</code> type from inside another function that returns a <code>Result</code> type, it will automatically propagate the result if it's an error out of the calling function.</p>
<p>Getting this behavior is more laborious in Ren-C:</p>
<pre><code>foo: func [...] [
    x: bar (...) except e -&gt; [return raise e]
    ...
]
</code></pre>
<p>Implementing the feature as postfix raises its own problems, so let's just imagine we were trying it prefix:</p>
<pre><code>foo: func [...] [
    x: ? bar (...)  ; we want this to act the same as above
    ...
]
</code></pre>
<p>For this to work under the current system, each FUNC would have to define its own <strong>?</strong> operator... because much like definitional RETURN, it would have to know what it was returning <em>from</em> in case of a raised error.</p>
<h2><a name="p-6481-haskell-has-generic-compositional-smarts-3" class="anchor" href="https://rebol.metaeducation.com#p-6481-haskell-has-generic-compositional-smarts-3"></a>Haskell Has Generic Compositional Smarts</h2>
<p>As mentioned, the strict compile-time typing in Haskell forces you to be explicit about your reaction when a function returns one of these <code>Either</code> values.</p>
<p>But because Either fits in with monadic/applicative/functor stuff, you can have higher-order operations that <a href="https://lhbg-book.link/06-errors_and_files/01-either.html">can compose together</a> failure scenarios...and gather up failures from several functions or cascade the failure through to where you want.</p>
<p>Ren-C can do this kind of thing as well, such as how you can write higher-order functions like ATTEMPT in usermode, or REDUCE a block of values in one pass with META and get the errors, then react to them later.</p>
<p>But in practice, the lack of a static type system makes this more precarious.</p>
<h2><a name="p-6481-links-to-error-handling-libraries-4" class="anchor" href="https://rebol.metaeducation.com#p-6481-links-to-error-handling-libraries-4"></a>Links To Error Handling Libraries</h2>
<ul>
<li>Rust's ANYHOW!: <a href="https://docs.rs/anyhow/" class="inline-onebox">anyhow - Rust</a></li>
</ul>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/haskell-and-rust-error-handling/1987">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/haskell-and-rust-error-handling/1987</link>
          <pubDate>Sun, 16 Oct 2022 02:17:44 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1987</guid>
          <source url="https://rebol.metaeducation.com/t/haskell-and-rust-error-handling/1987.rss">Haskell and Rust Error Handling</source>
        </item>
        <item>
          <title>Waforth: WebAssembly Forth</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>There may be some relevant or interesting things to learn by looking at this:</p>
<aside class="onebox allowlistedgeneric" data-onebox-src="https://mko.re/blog/waforth/">
  <header class="source">

      <a href="https://mko.re/blog/waforth/" target="_blank" rel="noopener" title="12:00AM - 24 May 2018">mko.re – 24 May 18</a>
  </header>

  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/271;"><img src="https://mko.re/blog/waforth/hero.png" class="thumbnail" width="690" height="271"></div>

<h3><a href="https://mko.re/blog/waforth/" target="_blank" rel="noopener">A Dynamic Forth Compiler for WebAssembly</a></h3>



  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>I've wanted to do some kind of dynamic Wasm generation--even very simple--so we can have something like the experience of the TCC natives, but on the web.  So seeing what they have to go through is probably informative.</p>
<p>Here are the design notes:</p>
<p><a href="https://github.com/remko/waforth/blob/master/doc/Design.md" class="inline-onebox">waforth/doc/Design.md at master · remko/waforth · GitHub</a></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/waforth-webassembly-forth/1927">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/waforth-webassembly-forth/1927</link>
          <pubDate>Fri, 19 Aug 2022 15:22:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1927</guid>
          <source url="https://rebol.metaeducation.com/t/waforth-webassembly-forth/1927.rss">Waforth: WebAssembly Forth</source>
        </item>
        <item>
          <title>SQLite&#39;s &quot;sqlean&quot;: C code for SQLite Extension Stuff</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>SQLite is a pretty carefully put together piece of C code.  Seems they've factored out some bits of interesting functions in C to a common library:</p>
<aside class="onebox githubrepo" data-onebox-src="https://github.com/nalgeon/sqlean">
  <header class="source">

      <a href="https://github.com/nalgeon/sqlean" target="_blank" rel="noopener">github.com</a>
  </header>

  <article class="onebox-body">
    <div class="github-row" data-github-private-repo="false">
  <img width="690" height="344" src="https://opengraph.githubassets.com/cdb256883f529d1dfadf5160950f7fc7/nalgeon/sqlean" class="thumbnail">

  <h3><a href="https://github.com/nalgeon/sqlean" target="_blank" rel="noopener">GitHub - nalgeon/sqlean: The ultimate set of SQLite extensions</a></h3>

    <p><span class="github-repo-description">The ultimate set of SQLite extensions</span></p>
</div>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>So there's random stuff like <a href="https://github.com/nalgeon/sqlean/blob/main/src/fuzzy/translit.c">transliteration</a>, for example or fuzzy string matching.  It could be a place to look if that kind of need comes up...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/sqlites-sqlean-c-code-for-sqlite-extension-stuff/1904">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/sqlites-sqlean-c-code-for-sqlite-extension-stuff/1904</link>
          <pubDate>Fri, 29 Jul 2022 05:09:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1904</guid>
          <source url="https://rebol.metaeducation.com/t/sqlites-sqlean-c-code-for-sqlite-extension-stuff/1904.rss">SQLite&#39;s &quot;sqlean&quot;: C code for SQLite Extension Stuff</source>
        </item>
        <item>
          <title>Common Lisp LOOP and ITERATE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>LOOP is about the shortest word you can get in the looping world <sub>(FOR is one letter shorter, I guess)</sub>.</p>
<p>So in a language that claims itself to be all-about-dialects, it doesn't seem to make sense to make LOOP the dumbest iteration construct in the box.</p>
<p>In Ren-C <strong>REPEAT</strong> is arity-2, where the first parameter is a number of times the block as the second parameter should be invoked.  This is what historical Redbol called LOOP.</p>
<p>So with that out of the way... we can think about LOOP as being something more on the scale of PARSE (UPARSE!) in which you can richly express your iteration intent.</p>
<p>An obvious place to look for inspiration for such a dialect is Common Lisp's LOOP.  (There's also a kind of "LOOP-lite" called ITERATE)</p>
<ul>
<li>
<p><a href="https://lispcookbook.github.io/cl-cookbook/iteration.html">https://lispcookbook.github.io/cl-cookbook/iteration.html</a></p>
</li>
<li>
<p><a href="https://gigamonkeys.com/book/loop-for-black-belts.html">https://gigamonkeys.com/book/loop-for-black-belts.html</a></p>
</li>
<li>
<p><a href="https://iterate.common-lisp.dev/">https://iterate.common-lisp.dev/</a></p>
</li>
</ul>
<p>I've skimmed these things but never actually used them.</p>
<p>Clearly we have an advantage in expressivity due to having more parts in the box.  But also, since we are oriented toward the visceral/extensible experience without much regard to performance, that could present some opportunities in clarity that they would not take.</p>
<p>Having built prototypes of <a href="https://rebol.metaeducation.com/t/match-in-rust-vs-switch/1835/4">SWITCH2</a> and <a href="https://rebol.metaeducation.com/t/destructure-dialect/1877">DESTRUCTURE</a> on top of UPARSE, I think it's past time to start prototyping what our take on LOOP might look like.</p>
<p>Anyone want to take a stab at designing it?  I'd write it if there were a good examples of what it should look like.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/common-lisp-loop-and-iterate/1878">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/common-lisp-loop-and-iterate/1878</link>
          <pubDate>Wed, 13 Jul 2022 22:29:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1878</guid>
          <source url="https://rebol.metaeducation.com/t/common-lisp-loop-and-iterate/1878.rss">Common Lisp LOOP and ITERATE</source>
        </item>
        <item>
          <title>JavaScript object notation shorthand</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>I saw this syntax in JavaScript and thought it might be some feature from TypeScript or some other higher level layer:</p>
<pre><code>let text = "Hello World"
let state = { fruit: "banana" }

let obj = { text, state }
</code></pre>
<p>But it turns out in plain JavaScript that now does the same thing as:</p>
<pre><code>let obj = { text: "Hello World", state: { fruit: "banana" } }
</code></pre>
<p>In fact they also have "computed property names":</p>
<pre><code>let prop = 'foo';
let o = {
    [prop]: 'hey',
    ['b' + 'ar']: 'there'
}
</code></pre>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer" class="inline-onebox">Object initializer - JavaScript | MDN</a></p>
<p>Ren-C is inches away from doing the computed property names in MAKE OBJECT! (using SET-GROUP! rather than SET-BLOCK! would be more appropriate).</p>
<p>But because of the freeform nature of the code block in MAKE OBJECT!, the appearance of a WORD! alone can't indicate an embedded field.</p>
<p><strong>It may be that there should be a less freeform alternative to MAKE OBJECT! which doesn't let you put arbitrary code in the middle of it.</strong>  Or at the very least, you put that code in GROUP!s.</p>
<p>Perhaps MAKE OBJECT! itself should have that requirement.  It could be like PARSE and just ignore the GROUP!s as it goes.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/javascript-object-notation-shorthand/1836">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/javascript-object-notation-shorthand/1836</link>
          <pubDate>Tue, 07 Jun 2022 00:07:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1836</guid>
          <source url="https://rebol.metaeducation.com/t/javascript-object-notation-shorthand/1836.rss">JavaScript object notation shorthand</source>
        </item>
        <item>
          <title>How ANY and ALL In Other Languages Act on Empty Inputs</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>I was looking around in the "Red Enhancement Process" repository to see if there was anything there of interest, and one thing that's at least useful was <a href="https://github.com/red/REP/issues/85">a survey of how other language constructs paralleling ANY and ALL act</a> when given empty inputs.</p>
<p>The repository is BSD-licensed and so I'll reproduce the list here.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/stuck_out_tongue.png?v=14" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:" loading="lazy" width="20" height="20"></p>
<hr>
<p><strong>Red</strong></p>
<pre><code>&gt;&gt; all [] == none
&gt;&gt; any [] == none
</code></pre>
<p><strong>Rebol2 &amp; Rebol3:</strong></p>
<pre><code>&gt;&gt; all [] == true
&gt;&gt; any [] == none
</code></pre>
<p><strong>Scheme:</strong></p>
<pre><code>(and) #t
(or) #f
</code></pre>
<p><strong>Common Lisp:</strong></p>
<pre><code>(and) T
(or) NIL
</code></pre>
<p><strong>R:</strong></p>
<pre><code>all() [1] TRUE
any() [1] FALSE
</code></pre>
<p><strong>J:</strong></p>
<pre><code>*./&gt;a: 1
+./&gt;a: 0
</code></pre>
<p><strong>Julia:</strong></p>
<pre><code>all([]) true
any([]) false
</code></pre>
<p><strong>Python:</strong></p>
<pre><code>all([]) True
any([]) False
</code></pre>
<p><strong>Javascript:</strong></p>
<pre><code>[].every(function(){}) true
[].some(function(){}) false
</code></pre>
<hr>
<h1><a name="p-5876-lotsa-precedent-for-all-truthy-any-falsey-1" class="anchor" href="https://rebol.metaeducation.com#p-5876-lotsa-precedent-for-all-truthy-any-falsey-1"></a>Lotsa Precedent For <code>ALL []</code> Truthy, <code>ANY []</code> Falsey...</h1>
<p>If you squint hard enough, there are legitimate reasons for favoring this choice--if both have to be constrained to just TRUE and FALSE.</p>
<p>The arguments sort of parallel <strong><a href="https://ae1020.github.io/is-true-greater-than-false/">why it's reasonable to say that TRUE &gt; FALSE</a></strong>.  But it's sort of abstract...and you wind up talking about <em>"mathematical consensus regarding bounded lattices…more specifically, a complemented distributive lattice."</em></p>
<h1><a name="p-5876-but-ren-c-does-better-with-void-2" class="anchor" href="https://rebol.metaeducation.com#p-5876-but-ren-c-does-better-with-void-2"></a>...BUT Ren-C Does Better... with VOID</h1>
<p>The idea behind VOID is that a function can say that in spirit it produced nothing, but still give back <em>some</em> result... <em>a representation of void intent</em>.  Some contexts like the condition of an IF will error on voids.  But others like ANY and ALL will consider it "no vote" and skip it.</p>
<pre><code>&gt;&gt; any []
== ~void~  ; anti

&gt;&gt; all []
== ~void~  ; anti

&gt;&gt; any [all [], 1 + 2]
== 3

&gt;&gt; all [1 + 2, 10 + 20, any []]
== 30

&gt;&gt; all [if 1 &gt; 2 ["math is broken"], maybe third of [a b]]
== ~void~  ; anti

&gt;&gt; all [any [] all []]
== ~void~ ; anti
</code></pre>
<p>This seems to have much better properties.  It's distinct from NULL which is conditionally "falsey"... and I think getting an error when you try to use the void result conditionally is the best answer, so you can triage and figure out what you actually meant.</p>
<pre><code>&gt;&gt; if (all [any [] all []]) [print "I don't think this should run"]
** Script Error: Invalid use of void
</code></pre>
<h2><a name="p-5876-powerful-use-cases-3" class="anchor" href="https://rebol.metaeducation.com#p-5876-powerful-use-cases-3"></a>Powerful Use Cases...</h2>
<p>The use cases blow away any microscopic benefit given by declaring the answers here to be true or false.  And for ALL to be truthy it would have to lie in some way--by fabricating an arbitrary truthy value.</p>
<p>You won't have to take my word for it that this is a big win...see for yourself:</p>
<aside class="quote quote-modified" data-post="1" data-topic="1833">
  <div class="title">
    <div class="quote-controls"></div>
    <img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar">
    <a href="https://rebol.metaeducation.com/t/demonstrating-for-both-loop-composability-for-the-win/1833">Demonstrating FOR-BOTH: Loop Composability For The Win <img width="20" height="20" src="https://rebol.metaeducation.com/images/emoji/twitter/exclamation.png?v=14" title="exclamation" alt="exclamation" class="emoji"></a> <a class="badge-category__wrapper " href="https://rebol.metaeducation.com/c/usage/show-and-tell/33"><span data-category-id="33" style="--category-badge-color: #3AB54A; --category-badge-text-color: #FFFFFF; --parent-category-badge-color: #3AB54A;" data-parent-category-id="7" data-drop-close="true" class="badge-category --has-parent" title="Created something short and syrupy sweet?  Then post your scripts here; not confined to infinite length one-liners!"><span class="badge-category__name">Show &amp; Tell</span></span></a>
  </div>
  <blockquote>
    FOR-BOTH was an early talking point for an extremely simple usermode loop construct that would be built out of two FOR-EACH loops: 
 &gt;&gt; for-both 'x [1 2] [3 4] [print [x], x = 5]
 1
 2
 3
 4
 ; first in pack of 1 item
 == ~null~  ; anti

A naive implementation of this in Rebol2 might look like: 
 for-both-naive: func [var blk1 blk2 body] [
     foreach (var) blk1 body
     foreach (var) blk2 body
 ]

...but... 


It will not honor BREAK correctly 
&gt;&gt; for-both-naive 'x [1 2] [3 4] [if x = 2 [brea…
  </blockquote>
</aside>

<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/eye.png?v=14" title=":eye:" class="emoji" alt=":eye:" loading="lazy" width="20" height="20"> <img src="https://rebol.metaeducation.com/images/emoji/twitter/pig_nose.png?v=14" title=":pig_nose:" class="emoji" alt=":pig_nose:" loading="lazy" width="20" height="20">  <img src="https://rebol.metaeducation.com/images/emoji/twitter/eye.png?v=14" title=":eye:" class="emoji" alt=":eye:" loading="lazy" width="20" height="20"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/how-any-and-all-in-other-languages-act-on-empty-inputs/1830">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/how-any-and-all-in-other-languages-act-on-empty-inputs/1830</link>
          <pubDate>Thu, 26 May 2022 06:39:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1830</guid>
          <source url="https://rebol.metaeducation.com/t/how-any-and-all-in-other-languages-act-on-empty-inputs/1830.rss">How ANY and ALL In Other Languages Act on Empty Inputs</source>
        </item>
  </channel>
</rss>

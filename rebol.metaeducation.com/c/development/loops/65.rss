<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Loops - AltRebol</title>
    <link>https://rebol.metaeducation.com/c/development/loops/65</link>
    <description>Topics in the &#39;Loops&#39; category Loops in Ren-C are a bit different from historical Redbol.</description>
    
      <lastBuildDate>Sat, 07 Jun 2025 11:26:40 +0000</lastBuildDate>
      <atom:link href="https://rebol.metaeducation.com/c/development/loops/65.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>[REPEAT 1] =&gt; ATTEMPT (Not As Useless As It Looks)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Loops</category>
          <description><![CDATA[
            <p>Historical Rebol had a use for ATTEMPT that we don't really need anymore... due to how definitional ERROR!s work and being covered by other things.</p>
<p>When the word was freed up, I thought <strong><code>This looks like a perfect name for "loop once"</code></strong></p>
<p>I imagine you're thinking: <em>"Why would we waste a name on loop <em>once</em>?"</em> <img src="https://rebol.metaeducation.com/images/emoji/twitter/confused.png?v=14" title=":confused:" class="emoji" alt=":confused:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8394-hear-me-out-1" class="anchor" href="https://rebol.metaeducation.com#p-8394-hear-me-out-1"></a>...Hear Me Out...</h2>
<p><strong>I'll start by saying loop once does come up</strong>, when you're writing something that wants to expose a looping interface, but not delegating to any wrapped loops to do it.</p>
<p>Let's say you're trying to do this:</p>
<pre><code>&gt;&gt; for-all-foos 'x [blah blah foo 10 blah blah foo 20] [print [x]]
10
20
</code></pre>
<p>(Assume you don't know about reusing FOR-EACH with a GENERATOR.  Instead you decide you really do want to get into your own binding, or customization of the body, or whatever your reasoning is.)</p>
<p>You try driving this with PARSE</p>
<pre><code>for-all-foos: lambda [var data body] [
    body: bind (var: let (var)) body  ; !!! need better way to say this
    parse data [
        opt some [
            'foo set (var) integer! (eval body)
            | elide one
        ]
    ]
]
</code></pre>
<p>That seems pretty good...besides me not having a great way of binding an indirect variable to a body, yet being able to still assign that variable afterwards.  <em>(Note that whatever you use for that needs to know the difference between <code>@x</code> to reuse a binding and <code>x</code> to not, e.g. it has to be a construct with the smarts of something like LET.)</em></p>
<p>But what about BREAK, CONTINUE, etc?</p>
<p>You need to bind body to <a href="https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479">THROW-TO-LOOP</a>, and you have to handle that.</p>
<p>So REPEAT 1 might come to mind.  But what about just ATTEMPT?</p>
<pre><code>for-all-foos: func [var data body] [
    body: bind (var: let (var)) body  ; !!! need better way to say this
    return parse data [
        opt some [
            'foo set (var) integer! (attempt body else [return null])
            | elide one
        ]
    ]
]
</code></pre>
<p>So now you have your BREAK, your CONTINUE, your AGAIN, all working.</p>
<h2><a name="p-8394-but-attempt-is-a-genuinely-useful-control-construct-2" class="anchor" href="https://rebol.metaeducation.com#p-8394-but-attempt-is-a-genuinely-useful-control-construct-2"></a>But ATTEMPT Is A Genuinely Useful Control Construct</h2>
<p>Especially with AGAIN.</p>
<pre><code>xxx: attempt [
    blah blah
    if blah blah [break]
    if blah blah [again]
    if blah blah [continue]
    blah blah
] then [
    ; code that runs if reaches end normally, or CONTINUE
] else [
   ; code that runs if BREAK
]
</code></pre>
<p>It's lightweight and flexible, <a href="https://rebol.metaeducation.com/t/the-mismatch-of-arity-1-until-and-arity-2-while/594/8">and in general a lot clearer than INSIST (Redbol UNTIL)</a></p>
<p>Even in the most minimal circumstances, I think it's clearer:</p>
<pre><code>append data insist [request-server-token else [wait 5]]

append data attempt [request-server-token else [wait 5, again]]
</code></pre>
<p>But it's much more powerful.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/repeat-1-attempt-not-as-useless-as-it-looks/2480">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/repeat-1-attempt-not-as-useless-as-it-looks/2480</link>
          <pubDate>Sat, 07 Jun 2025 11:26:40 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2480</guid>
          <source url="https://rebol.metaeducation.com/t/repeat-1-attempt-not-as-useless-as-it-looks/2480.rss">[REPEAT 1] =&gt; ATTEMPT (Not As Useless As It Looks)</source>
        </item>
        <item>
          <title>Virtual Binding + Macros =&gt; BREAK, CONTINUE, AGAIN</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Loops</category>
          <description><![CDATA[
            <p>In the last moments of 2023, Ren-C finally bit the bullet and made BREAK and CONTINUE definitional (it was a long time coming, just hadn't gotten around to it...):</p>
<p><strong><a href="https://rebol.metaeducation.com/t/definitional-break-and-continue-the-time-is-now/2066">Definitional Break and Continue: The Time Is Now</a></strong></p>
<p>This means that loops create (optimized) variants of BREAK and CONTINUE in which the ACTION! cell has been tweaked to hold the identity of the loop.</p>
<p>The methodology for this optimized representation <a href="https://rebol.metaeducation.com/t/what-are-definitional-returns/2191">was pioneered with definitional RETURN</a>.</p>
<p>Except in this case, there are two new "LET-style variables" tacked onto the loop's binding environment... one for BREAK, and one for CONTINUE.</p>
<h2><a name="p-8393-it-would-be-nice-to-have-again-1" class="anchor" href="https://rebol.metaeducation.com#p-8393-it-would-be-nice-to-have-again-1"></a>It Would Be Nice To Have AGAIN</h2>
<p>It seems to me pretty powerful to be able to ask a loop to start again from the top, but not increment its loop index...or check the condition, or whatever.</p>
<p>(This has precedent in other languages, e.g. <strong><a href="https://perldoc.perl.org/functions/redo">Perl's REDO</a></strong>... but I like AGAIN better.)</p>
<p>That would add a third LET-variable.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/pouting_cat.png?v=14" title=":pouting_cat:" class="emoji" alt=":pouting_cat:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8393-but-could-it-be-just-one-let-variable-2" class="anchor" href="https://rebol.metaeducation.com#p-8393-but-could-it-be-just-one-let-variable-2"></a>But Could It Be Just <em>ONE</em> LET-Variable?</h2>
<p>As I've realized the kind-of-awesome power of virtual binding, I realized that it might be the case that there was just <em>one</em> "throw to loop" construct, that takes different parameterization:</p>
<ul>
<li>
<p><strong><code>throw-to-loop veto</code></strong> =&gt; <strong>BREAK</strong></p>
<ul>
<li>VETO is a function that returns an ERROR! with the identity 'VETO... which is an awesome generalization I haven't talked about yet, that makes constructs abort and return NULL. It works inside things like REDUCE (e.g. <code>reduce [1 + 2 veto]</code> =&gt; <code>null</code>) but also inside GROUP!s of code in PARSE to allow match failures to be signaled by a GROUP! (whose product would otherwise be discarded).  It seems the perfect argument for THROW-TO-LOOP to mean "let's abort this whole loop and give null".</li>
</ul>
</li>
<li>
<p><strong><code>throw-to-loop void</code></strong> =&gt; <strong>CONTINUE</strong></p>
<ul>
<li>This would have the same effect as reaching the end of the loop body and synthesizing VOID.  So if you were doing a MAP-EACH, an iteration of the loop that ran CONTINUE would not contribute anything to the result.</li>
</ul>
</li>
<li>
<p><strong><code>throw-to-loop fail 'retry</code></strong> =&gt; <strong>AGAIN</strong></p>
<ul>
<li>
<p>I don't know if RETRY should be a function that just returns an ERROR! the way VETO is so I'm hand-waving a little here to say "let's have another special trigger that loops can respond to"... if they don't support it, they can treat it like any other error.</p>
</li>
<li>
<p>I'm not thrilled that "retry" doesn't <em>sound</em> like an "error" name the way VETO kind-of-does, but there's only so many unstable antiforms to choose from (and GHOST! seems random to pick to mean "try again").  Maybe INCOMPLETE is a better error ID... where the loop goes "oh, the <em>failure</em> was it didn't complete... so the natural <em>response</em> is to try again"?</p>
</li>
</ul>
</li>
<li>
<p><strong><code>throw-to-loop &lt;whatever&gt;</code></strong> =&gt; <strong>CONTINUE:WITH</strong></p>
<ul>
<li><code>CONTINUE</code> has had a refinement called <code>:WITH</code> that allows you to act as if the loop body completed with some other value besides VOID.  So <code>continue:with spread [d e]</code> inside a MAP-EACH would add the splice <code>~(d e)~</code> to the mapped result.  I don't know if it's better to have this <code>:WITH</code> refinement or if you should just use THROW-TO-LOOP directly... (could THROW-TO-LOOP have a better name?)</li>
</ul>
</li>
</ul>
<h2><a name="p-8393-one-way-to-do-it-macros-3" class="anchor" href="https://rebol.metaeducation.com#p-8393-one-way-to-do-it-macros-3"></a>One Way To Do It... Macros!</h2>
<p>Imagine that a convenient form of MACRO (which might just be called MACRO) would assume that anything $TIED you want to bind in the environment of the macro definition, and anything you don't $TIE is intended to be interpreted in the calling context.</p>
<pre><code>break: macro [throw-to-loop $veto]
continue: macro [throw-to-loop $void]  ; -or- just [throw-to-loop ~[]~]
again: macro [throw-to-loop $fail 'incomplete]  ; or whatever...
</code></pre>
<p>While we'd most likely want to nativize CONTINUE, BREAK, and AGAIN... maybe MACRO can be smart enough to produce native-speed code for this when not running under a stepwise debugger...</p>
<h2><a name="p-8393-any-submissions-for-better-names-for-throw-to-loop-4" class="anchor" href="https://rebol.metaeducation.com#p-8393-any-submissions-for-better-names-for-throw-to-loop-4"></a>Any Submissions For Better Names For THROW-TO-LOOP?</h2>
<p>Maybe being bluntly literal is best.</p>
<p>But <a class="mention" href="https://rebol.metaeducation.com/u/blackattr">@BlackATTR</a> suggested <code>TOSS</code>, <code>PASS</code>, <code>PITCH</code>, <code>PUNT</code>, <code>FLICK</code></p>
<p>They all sound weird to us now, but everything has a learning curve.  You learned what BREAK and CONTINUE meant, you'd learn what AGAIN meant.  Could you learn what TOSS meant, that it was specifically a THROW targeting a LOOP...?</p>
<p>Leaving that open for now.</p>
<h2><a name="p-8393-or-variadic-continue-5" class="anchor" href="https://rebol.metaeducation.com#p-8393-or-variadic-continue-5"></a>Or... Variadic CONTINUE?</h2>
<p>I'll also point out that once-upon-a-time, CONTINUE was variadic... so you could say <strong><code>continue 10</code></strong> and if you left off the parameter it would assume you meant VOID.  This was too error prone, due to line continuation bugs:</p>
<p><a href="https://rebol.metaeducation.com/t/line-continuation-and-arity-bugs-thoughts/1965" class="inline-onebox">Line Continuation and Arity Bugs: Thoughts?</a></p>
<p>But I've been thinking maybe you have to continue lines with an apostrophe.  So this would error:</p>
<pre><code>append [a b c]
[d e f]
</code></pre>
<p>But this would be legal:</p>
<pre><code>append [a b c]
' [d e f]
</code></pre>
<p>The reason it would be legal is it would actually LOAD the code as not having a line break marker.</p>
<p>Then we'd just make line break markers illegal outside of interstitial evaluations.  (Maybe relax it, so that if you were inside a GROUP! evaluation it would allow it, though that might make it toothless.)</p>
<pre><code>(append [a b c]
[d e f])
</code></pre>
<p>If the system got more persnickety about line continuation, then we might feel comfortable bringing back variable-arity CONTINUE, QUIT, RETURN...</p>
<p>I doubt we want to go down the route of JavaScript's <a href="https://en.wikibooks.org/wiki/JavaScript/Automatic_semicolon_insertion">automatic semicolon insertion</a> debacle, and act like there's a comma at "some" line end markers.</p>
<p>I have a hard time being psychic about whether this is a big creativity-enabler (by letting us be more purposeful about semantics of line continuation markers) or if it would lead to hassles.  Overall I feel like it would cut down on bugs, by making line endings usually mean expression endings... and having you be specific when that's not what you want.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/6af702cd11332dfc1fb48f90b5267cab5d41f98f.webp" data-download-href="https://rebol.metaeducation.com/uploads/default/6af702cd11332dfc1fb48f90b5267cab5d41f98f" title="6t9rbhxv06g71"><img src="https://rebol.metaeducation.com/uploads/default/original/1X/6af702cd11332dfc1fb48f90b5267cab5d41f98f.webp" alt="6t9rbhxv06g71" data-base62-sha1="fgfPtWehBdWVciF8Ng28L48wruv" width="300" height="250"></a></div><p></p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479</link>
          <pubDate>Sat, 07 Jun 2025 10:47:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2479</guid>
          <source url="https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479.rss">Virtual Binding + Macros =&gt; BREAK, CONTINUE, AGAIN</source>
        </item>
        <item>
          <title>About the Loops category</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Loops</category>
          <description><![CDATA[
            <p>Loops in Ren-C are a bit different from historical Redbol.</p>
<ul>
<li>
<p>They follow the <a href="https://rebol.metaeducation.com/t/the-simple-yet-powerful-magic-of-the-loop-result-protocol/609">Loop Result Protocol</a></p>
</li>
<li>
<p><a href="https://rebol.metaeducation.com/t/definitional-break-and-continue-the-time-is-now/2066">BREAK and CONTINUE are definitional</a></p>
</li>
</ul>
<p>There seemed to be enough posts about loops to give them their own category.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/man_shrugging.png?v=14" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/about-the-loops-category/2478">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/about-the-loops-category/2478</link>
          <pubDate>Sat, 07 Jun 2025 09:57:28 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2478</guid>
          <source url="https://rebol.metaeducation.com/t/about-the-loops-category/2478.rss">About the Loops category</source>
        </item>
        <item>
          <title>Seeing LETs In Loop Conditions In Loop Bodies</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Loops</category>
          <description><![CDATA[
            <p>So I'm really a fan of it when languages let you do things like introduce variables in loop conditions that are only visible in the body.</p>
<p>C99 actually lets you do this with <code>for</code> loops (not others, though):</p>
<pre><code>for (int x = 0; x &lt; 10; ++x) {
    printf("value is %d\n", x);  // this is legal
}
</code></pre>
<p>So it would be nice if you could do something similar in Ren-C:</p>
<pre><code>while [let item: try take block] [
    print [item]
]
</code></pre>
<p>You can't do that today... the LET is only visible until the end of the condition scope.  So you have to write:</p>
<pre><code>let item
while [item: try take block] [
    print [item]
]
</code></pre>
<p>That's not as nice. <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning_with_open_mouth.png?v=14" title=":frowning_with_open_mouth:" class="emoji" alt=":frowning_with_open_mouth:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8260-what-would-it-take-to-implement-1" class="anchor" href="https://rebol.metaeducation.com#p-8260-what-would-it-take-to-implement-1"></a>What Would It Take To Implement?</h2>
<p>So it would be kind of tricky, in that the body block can be bound somewhere entirely radically different than the condition.  It could be using a whole different concept of LIB.</p>
<p>You don't want to overshadow the binding of the body with all of the context of the condition.  You'd only want <em>just the diff</em>... any new definitions that appeared in the context chain while it was running.  But only those.</p>
<p>Arguably there are cases where people would not want to inherit the diff.  Creative uses of WHILE which put a lot of code in the condition might want to make variables that don't leak out.  But you could deal with that intent using a GROUP!</p>
<pre><code>let item: &lt;outside&gt;
while [(let item: try take block)] [
    print [item]
]
</code></pre>
<p>Bizarro idea might be that GROUP!s themselves as conditions (or bodies) indicate you want transparency of diffed variables beyond the loop:</p>
<pre><code>while $(let item: try take block) [
    print [item]
]
assert [item = null]  ; iteration exhausted, item still visible
</code></pre>
<p>That's a pretty wild idea... but it doesn't really have any precedent with what GROUP!s mean generally (e.g. (let x: 10) more generally won't leak the X out of the group, and it shouldn't.</p>
<h2><a name="p-8260-generic-mechanism-would-need-a-design-2" class="anchor" href="https://rebol.metaeducation.com#p-8260-generic-mechanism-would-need-a-design-2"></a>Generic Mechanism Would Need A Design</h2>
<p>I could hack this behavior into WHILE.  But for all these things, I think it should be possible to do in your own constructs.</p>
<p>It means EVAL needs to have some kind of context return result that gives you a partial environment chain of what got added.</p>
<p>This could basically reuse an existing chain, by being a counter of how much of the chain was applicable if you followed the link.  This could go in the cell, and then be proxied into a stub if you actually used it.</p>
<p>It's desirable to do, so I'll put it on the infite list... <img src="https://rebol.metaeducation.com/images/emoji/twitter/infinity.png?v=14" title=":infinity:" class="emoji" alt=":infinity:" loading="lazy" width="20" height="20"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/seeing-lets-in-loop-conditions-in-loop-bodies/2446">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/seeing-lets-in-loop-conditions-in-loop-bodies/2446</link>
          <pubDate>Sun, 11 May 2025 18:57:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2446</guid>
          <source url="https://rebol.metaeducation.com/t/seeing-lets-in-loop-conditions-in-loop-bodies/2446.rss">Seeing LETs In Loop Conditions In Loop Bodies</source>
        </item>
        <item>
          <title>Tunnelling BREAK and CONTINUE Across Binding</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Loops</category>
          <description><![CDATA[
            <p>In <code>%make-reb-lib.r</code>, there's are abstractions for helping you do something for every API definition.  The APIs are in an array of objects, and the idea is to go through all the objects and run some code bound into each one... so you don't have to specify the object name each time.</p>
<p>So instead of:</p>
<pre><code>names: map-each api api-objects [
    print ["The API name is" api.name]
    api.name
]
</code></pre>
<p>You could instead write:</p>
<pre><code>names: map-each-api [
    print ["The API name is" name]
    name
]
</code></pre>
<h2><a name="p-7026-implementation-of-map-each-api-1" class="anchor" href="https://rebol.metaeducation.com#p-7026-implementation-of-map-each-api-1"></a>Implementation of MAP-EACH-API</h2>
<p>In order to make the API member fields visible to code, we use the OVERBIND instruction, which patches in the object:</p>
<pre><code>map-each-api: lambda [code [block!]] [
    map-each api api-objects compose [
        eval overbind api (code)
    ]
]
</code></pre>
<h2><a name="p-7026-problem-continue-and-break-2" class="anchor" href="https://rebol.metaeducation.com#p-7026-problem-continue-and-break-2"></a>Problem: CONTINUE and BREAK</h2>
<p>We'd like to be able to run the CONTINUE and BREAK of the MAP-EACH.  Previously, using a COMPOSE bought that.  Now, because the code block has a binding, those do not override.</p>
<p>If the API's object's bindings were on the block passed to MAP-EACH, then it would patch the BREAK and CONTINUE onto them.  But we can't do that, because the API object is not available until the MAP-EACH is already running and the block has been passed.</p>
<p>Using the current primitive tools for binding at hand, we can try making an object carrying BREAK and CONTINUE and overbind into that as well:</p>
<pre><code>map-each-api: lambda [code [block!]] [
    map-each api api-objects compose [
        let aux: make object! compose [break: (^break) continue: (^continue)]
        eval overbind aux overbind api (code)
    ]
]
</code></pre>
<p>It works...and the COMPOSE isn't really necessary anymore.  But, it certainly leaves a lot to be desired.  If we were to dialect this <em>(in the spirit of something like <a href="https://codeberg.org/hiiamboris/red-common/src/branch/master/with.red">hiiamboris's WITH</a>)</em>, it might look more like:</p>
<pre><code>map-each-api: lambda [code [block!]] [
    map-each api api-objects [
        eval with [break continue :api] code
    ]
]
</code></pre>
<p>Overall though, it feels good to have things under more strict control.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/tunnelling-break-and-continue-across-binding/2133">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/tunnelling-break-and-continue-across-binding/2133</link>
          <pubDate>Wed, 24 Jan 2024 20:56:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2133</guid>
          <source url="https://rebol.metaeducation.com/t/tunnelling-break-and-continue-across-binding/2133.rss">Tunnelling BREAK and CONTINUE Across Binding</source>
        </item>
        <item>
          <title>Definitional Break and Continue... the Time is Now</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Loops</category>
          <description><![CDATA[
            <p>I was writing what I thought to be a clever bit of code, <a href="https://rebol.metaeducation.com/t/deceptive-incomplete-parsing-a-common-problem/2065">discussed here</a></p>
<pre><code>for-each file ... [
    parse file [thru any [".reb" ".r"] &lt;end&gt; | (continue)]
    ...
]
</code></pre>
<p>I thought it was pleasing to have the CONTINUE in the rules themselves.</p>
<p>Pleasing, except... a bit displeasing considering <strong>it didn't work.</strong></p>
<p>BREAK and CONTINUE would break or continue the first loop they found above them in the stack.  Since PARSE is currently written in usermode code, it uses loops in its implementation (to loop over the rules).  <em>so you wind up continuing some arbitrary loop inside the combinators, having random effects</em>!</p>
<p>Happily Ren-C has pioneered answers to this kind of problem with definitional returns.  But loops just have to get with the program and make CONTINUE and BREAK definitional in their bodies.</p>
<p>So I did it!  And most things appeared to work (like the motivating example).</p>
<h2><a name="p-6737-still-complexity-for-loops-implemented-without-loops-1" class="anchor" href="https://rebol.metaeducation.com#p-6737-still-complexity-for-loops-implemented-without-loops-1"></a>Still Complexity For Loops Implemented Without "Loops"</h2>
<p>In bootstrap, there was some code implementing FOR-EACH-PLATFORM.  Hand-waving a bit, it initially looked like this:</p>
<pre><code> for-each-platform: func ['var [word! tuple!] body [block!]] [
     parse platforms-table [
         while [not &lt;end&gt;] [
              ...  ; rules that build up an OBJECT! 
              (set var obj, do body)
         ]
     ]
 ]
</code></pre>
<p>But that didn't make CONTINUE work:</p>
<pre><code> for-each-platform p [
     if p.name = 'HaikuOS [continue]
     ...
 ]
</code></pre>
<p>So I'd hacked up something at one point in history which looked like this monstrosity:</p>
<pre><code>    completed*: false
    running*: false
    while [true] [  ; must be in loop for BREAK or CONTINUE
        if running* [  ; must have had a CONTINUE
            completed*: true
            break
        ]
        running*: true
        do body
        completed*: true
        break
    ]
    if not completed* [return null] 
</code></pre>
<p>That depended on non-definitional CONTINUE happening inside BODY finding the enclosing WHILE.</p>
<p>But now, that CONTINUE isn't definitionally bound anywhere.  So that CONTINUE is just a reference to a default CONTINUE function in LIB, which will error telling you there are no loops providing continue available.</p>
<p>For the modern world, this <em>works</em>:</p>
<pre><code> repeat 1 body else [return null]
</code></pre>
<p>Reserving the pure NULL return value for BREAK means you can get that communication of when BREAK was encountered out of the return result.  And in this case, CONTINUE is just supposed to bypass the remainder of code in BODY and go on parsing.  So it works.</p>
<p>But it's suboptimal as the binding of the body to BREAK and CONTINUE happens on each run instead of once.  Doing that more efficiently would need some new techniques and case studies.</p>
<p>Overall though, it's progress...in the sense that there's an answer that works slowly, vs. not working at all!</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/definitional-break-and-continue-the-time-is-now/2066">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/definitional-break-and-continue-the-time-is-now/2066</link>
          <pubDate>Thu, 07 Dec 2023 16:29:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2066</guid>
          <source url="https://rebol.metaeducation.com/t/definitional-break-and-continue-the-time-is-now/2066.rss">Definitional Break and Continue... the Time is Now</source>
        </item>
        <item>
          <title>Demonstrating FOR-BOTH: Loop Composability For The Win :exclamation:</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Loops</category>
          <description><![CDATA[
            <p>FOR-BOTH was an early talking point for an extremely simple usermode loop construct that would be built out of two FOR-EACH loops:</p>
<pre><code> &gt;&gt; for-both 'x [1 2] [3 4] [print [x], x = 5]
 1
 2
 3
 4
 ; first in pack of 1 item
 == \~null~\  ; antiform
</code></pre>
<p>A naive implementation of this in Rebol2 might look like:</p>
<pre><code> for-both-naive: func [var blk1 blk2 body] [
     foreach (var) blk1 body
     foreach (var) blk2 body
 ]
</code></pre>
<p>...but...</p>
<ul>
<li>
<p><strong>It will not honor BREAK correctly</strong></p>
<pre><code>&gt;&gt; for-both-naive 'x [1 2] [3 4] [if x = 2 [break], print [x], x = 5]
1
3  ; the BREAK only broke the first FOREACH
4
== #[none]
</code></pre>
<p>There's no way from the outside of Rebol2 or Red's FOREACH to know for sure that a BREAK was requested.  BREAK returns NONE!, but a loop body can (and often does) evaluate to NONE! as well.  Red made it even worse by adding BREAK/RETURN--so a breaking loop can return <em>anything</em>.</p>
<p>So you'd need some kind of complex binding to search the loop bodies and bind the BREAK word to something that throws and gets caught...even for this simple goal.</p>
</li>
<li>
<p><strong>The loop won't evaluate to the last result of the body</strong>.</p>
<pre><code>&gt;&gt; for-both-naive 'x [1 2] [] [print [x], x * 10]
1  ; evaluated to 10
2  ; evaluated to 20
== #[none!]
</code></pre>
<p>If the second series is empty, the fallout from the first loop is forgotten.</p>
</li>
</ul>
<h2><a name="p-5879-behold-ren-cs-elegant-solution-to-for-both-1" class="anchor" href="https://rebol.metaeducation.com#p-5879-behold-ren-cs-elegant-solution-to-for-both-1"></a>Behold Ren-C's Elegant Solution to FOR-BOTH</h2>
<p><em>Underneath its apparent simplicity lies quite a lot of deep thought.</em>  And the mechanisms it uses apply far beyond just loops!</p>
<pre><code>    for-both: func [var blk1 blk2 body] [
        return unlift:lite all [
            lift:lite for-each var blk1 body
            lift:lite for-each var blk2 body
        ]
    ]
</code></pre>
<h3><a name="p-5879-it-solves-the-break-case-2" class="anchor" href="https://rebol.metaeducation.com#p-5879-it-solves-the-break-case-2"></a>It solves the BREAK case</h3>
<p>Below we see a situation where the first FOR-EACH returns NULL (and <strong>lift:lite null</strong> is just <strong>null</strong>).  So it short-circuits the ALL, and propagates the null as a signal that it broke:</p>
<pre><code>&gt;&gt; for-both 'x [1 2] [3 4] [if x = '2 [break], print [x], x = 5]
1
== \~null~\  ; antiform
</code></pre>
<p>Note that the first pass through the loop did not terminate the ALL, just because the body evaluated to null.  That's because it produced a "heavy null", and LIFT:LITE of non-pure-void, non-pure-null antiforms produces QUASIFORM!, which is a branch trigger even if the antiform thing would not be:</p>
<pre><code> &gt;&gt; lifted: lift ~[~null~]~
 == ~[~null~]~

 &gt;&gt; type of lifted
 == \~{quasiform!}~\  ; ntiform

&gt;&gt; if lifted [print "All QUASIFORM! are branch triggers!"]
All QUASIFORM! are branch triggers!
</code></pre>
<p>This means the loop can gracefully recover the QUASIFORM! as the ALL result if the loop completes, and remove the quasi level:</p>
<pre><code>&gt;&gt; for-both 'x [1 2] [3 4] [print [x], x = 5]
1
2
3
4
; first in pack of 1 item
== \~null~\  ; antiform
</code></pre>
<h3><a name="p-5879-it-solves-the-fallout-from-the-last-loop-body-3" class="anchor" href="https://rebol.metaeducation.com#p-5879-it-solves-the-fallout-from-the-last-loop-body-3"></a>It Solves the Fallout From The Last Loop Body</h3>
<p>This takes advantage of a new invariant: <em><strong>loops which never run their bodies return void</strong></em>.</p>
<pre><code>&gt;&gt; for-each x [] [fail "This body never runs"]
== \~[]~\  ; antiform "void"
</code></pre>
<p>Voids act invisibly in constructs like ALL.  So we get the result we want:</p>
<pre><code>&gt;&gt; for-both 'x [1 2] [] [print [x], x * 10]
1  ; evaluated to 10
2  ; evaluated to 20
== 20
</code></pre>
<p>There's a slight fib here, that LIFT:LITE of the void did not produce a "lifted-void"...but passed it through (it would pass through NULL, as well).  That's a property of the :LITE refinement:</p>
<pre><code>&gt;&gt; lift:lite when 10 &gt; 20 ["LIFT:LITE passes through the void antiforms"]
== \~[]~\  ; antiform "void"

&gt;&gt; lift iwhen10 &gt; 20 ["Without :LITE is more exact, gives the quasiform"]
== ~[]~
</code></pre>
<p>But in situations like this, passing through the void state is what we wanted.</p>
<h3><a name="p-5879-you-can-even-return-null-from-the-body-4" class="anchor" href="https://rebol.metaeducation.com#p-5879-you-can-even-return-null-from-the-body-4"></a>You Can Even Return NULL From the Body!</h3>
<p>Thanks to isotopes, the following is possible:</p>
<pre><code>&gt;&gt; x: for-both 'x [1 2] [] [print [x], if x = 2 [null]]
1
2
; first in pack of length 1
== \~null~\  ; antiform

&gt;&gt; x
== \~null~\  ; antiform
</code></pre>
<p>How cool is that?  Even though NULL is being reserved as the unique signal for loops breaking, there's a backchannel for it to escape...out of the FOR-EACH, and up out of the FOR-BOTH wrapping it!</p>
<h2><a name="p-5879-it-holds-up-under-scrutiny-5" class="anchor" href="https://rebol.metaeducation.com#p-5879-it-holds-up-under-scrutiny-5"></a>It Holds Up Under Scrutiny!</h2>
<p>I'm really pleased with it, and here are some tests:</p>
<p><a href="https://github.com/metaeducation/ren-c/blob/master/tests/loops/examples/for-both.loops.test.reb" class="inline-onebox">ren-c/tests/loops/examples/for-both.loops.test.reb at master · metaeducation/ren-c · GitHub</a></p>
<p>I invite you to test it some more...ask questions...and perhaps come up with your own loop compositions!</p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/atom_symbol.png?v=14" title=":atom_symbol:" class="emoji only-emoji" alt=":atom_symbol:" loading="lazy" width="20" height="20"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/demonstrating-for-both-loop-composability-for-the-win/1833">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/demonstrating-for-both-loop-composability-for-the-win/1833</link>
          <pubDate>Tue, 31 May 2022 16:02:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1833</guid>
          <source url="https://rebol.metaeducation.com/t/demonstrating-for-both-loop-composability-for-the-win/1833.rss">Demonstrating FOR-BOTH: Loop Composability For The Win :exclamation:</source>
        </item>
        <item>
          <title>Modifying While Iterating: Crash, Nonsense, Predictable, or Illegal?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Loops</category>
          <description><![CDATA[
            <p>Every imperative language has the problem of when you modify a data structure, you run the risk of confusing other code that is looking at that data structure at the same time.  Whether it's threads competing for access, or just a loop whose body modifies the data being looped over...the problem comes up.</p>
<p>The options for dealing with it are:</p>
<ul>
<li>
<p><strong>Crash</strong> - You can just crash.  R3-Alpha had this in several places--for instance PARSE, where a <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/u-parse.c#L658">data pointer (REBVAL*) into the rules series</a> was incremented along the rules...even though code was permitted to change the rules as you went (via GROUP!s).  The rule series might grow and be retargeted at a larger memory block, leaving the old pointer recycled and invalid.</p>
</li>
<li>
<p><strong>Nonsense</strong> - You can make the iteration never crash, but be protected in such a way that it does <em>something</em> to avoid crashing.  Basically this means you modify only in ways that can be checked by iterations.  However, this means additional checking must run in the iterations to make sure it picks up on the signal that something has changed.  For instance: in the PARSE example above there could be a check of the length and a re-fetch of the pointer by index; if the length is out of bounds, it could error.  If still in bounds--even if between rules--it could take a shot at keeping running, and just fail as if the nonsense had been how it were written all along.</p>
</li>
<li>
<p><strong>Predictable</strong> - Some languages offer guarantees about what kind of modifications are safe, and which ones are not.  For instance it may say if you are iterating a map, then anything you remove that you haven't visited yet won't be seen...or if you insert then anything you add won't cause something already visited to be seen again.  They might tell you explicitly when all bets are off--and say the effects may vary, or even if they may crash.  (C++ has container guarantees, and things outside the guarantees may crash.)</p>
</li>
<li>
<p><strong>Illegal</strong> - This has been Ren-C's strategy so far...to simply say you cannot modify things that are being iterated.  Some routines (like FOR-NEXT) aren't considered to be iterating, because they are just running NEXT on a variable each time, and so have the same between loop invariants as if you did it yourself.</p>
</li>
</ul>
<hr>
<p>It's likely that most people agree that crashing is not a good choice.  <a href="https://wiki.python.org/moin/CrashingPython">Python says</a>:</p>
<p><em>"I'm not saying it's uncrashable. I'm saying that if you crash it, it's a bug unless proven harebrained."</em></p>
<p>So what they get are exceptions, e.g.:</p>
<pre><code>my_list = [1,2,3,4,5,6,7,8,9] 
for i in range(len(my_list)): 
    if my_list[i] == 8: 
        del my_list[i] 

 IndexError: list index out of range
</code></pre>
<p>Rebol (and Red's) history seems to aspire to <em>non-crashing Nonsense</em>.  There's not a lot of emphasis on what the promised invariants are, but they give lip service to the idea of "crashing is bad".  So if you point out a crash, a patch is made at that point based on some testable property (index out of bounds, etc.) and a non-crashing behavior is picked.  Repeat as crashes are discovered.</p>
<p><em>I've felt like illegal has worked out pretty well for Ren-C</em>.  It's conservative...but the general rule of thumb is that modification during iteration is a so-called "code smell".  You can always do it another way.  And if this ever became a real performance problem, a dedicated native that caters to a certain explicit stylized modification could optimize for that particular case (e.g. REMOVE-EACH).</p>
<p><strong>But stackless introduces a problem for locking series: it means locks are no longer necessarily taken in a stack-like manner, so locking cannot be done via a single bit.</strong></p>
<p>Previously series had a single bit on them... SERIES_INFO_HOLD.  This bit is in the same bitflag set as other sources of read-only-ness, such as SERIES_INFO_PROTECTED (can be turned on and off) and SERIES_INFO_FROZEN (permanently immutable).  So all three could be conveniently checked in one masking operation on modification.</p>
<p>What would happen in an operation that wanted to take a hold is that it would look to see if the series already had SERIES_INFO_HOLD.  If so, it would do nothing.  If not, it would set a flag on itself to say that it took a hold it needed to release...and release when it was done.</p>
<p><em>This does not work in a stackless model.</em>  A sort of minimum would be that the series would need to have a lock count that was incremented and decremented.  The miserly design for series does not currently have space to put that in the series node.  Something will have to grow, somewhere.</p>
<hr>
<p>Python's approach seems to please people enough...with questions on Stack Overflow about modifying while iterating having people say "avoid it".  They don't have locks, and the code just does what it does.</p>
<p><strong>This is a deeper question for Rebol than for Python, because the locking questions apply to source code itself (source blocks, parse rules, etc.)...not just user data structures.</strong></p>
<p>I hate to give up putting iterative holds on series, and letting chaos win.  We wouldn't want that in our filesystems, why allow it in programming languages?  The problem of releasing locks is something I think that the <a href="https://rebol.metaeducation.com/t/module-startup-and-shutdown-constructors-destructors/960/4">DEFER</a> mechanism can probably handle pretty well.</p>
<p>I've been thinking about some hybrid approaches which use a bit if it's sufficient, but only break out into a locking table if there's more than one iterator.  Build options could decide: no locks (allow crashes), cheap locks (reference counts), heavy locks (be able to tell you which frame took the lock).</p>
<p>I'll probably give an enhanced locking method a shot, and stay the course on prohibiting modification during iteration (unless using an iterator that specifically accounts for that).</p>
            <p><small>6 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/modifying-while-iterating-crash-nonsense-predictable-or-illegal/1317">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/modifying-while-iterating-crash-nonsense-predictable-or-illegal/1317</link>
          <pubDate>Thu, 06 Aug 2020 22:30:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1317</guid>
          <source url="https://rebol.metaeducation.com/t/modifying-while-iterating-crash-nonsense-predictable-or-illegal/1317.rss">Modifying While Iterating: Crash, Nonsense, Predictable, or Illegal?</source>
        </item>
        <item>
          <title>Generic Looping: Cutting FOR Back a Bit</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Loops</category>
          <description><![CDATA[
            <p>Trying to convert code to be stackless is difficult, and the more fiddly code you have the harder it can be.</p>
<p>The implementation of FOR loops is rather complex, because it tries to support FOR looping over a series...which I'm vaguely aware it can do, but have never used.  I'll point out that Red doesn't even <em>have</em> a FOR construct, much less one that iterates series.  :-/</p>
<p>Anyway, here are some of the tests that there were for the feature:</p>
<pre><code>    success: true | x: "a"
    for i x tail of x 1 [continue | success: false]
    success = true
    ---
    out: copy ""
    for i s: "abc" back tail of s 1 [append out i]
    out = "abcbcc"
    ---
    out: copy []
    for i b: [1 2 3] back tail of b 1 [append out i]
    out = [1 2 3 2 3 3]
    ---
    success: true
    for i b: [1] tail of :b -1 [success: false]
    success = true
    ---
    num: 0
    for i (b: next [1]) (back b) 1 [num: num + 1 | break]
    num = 0
    ---
    ([] = for i b: tail of [1] head of b -2 [i])
</code></pre>
<p>It seems to me this is mostly covered by FOR-SKIP, which has specializations FOR-NEXT and FOR-BACK when you just want to skip by 1 or -1.  It doesn't include the stopping point as part of the loop definition, but I don't know how often it really comes up...and not too hard to do yourself.  I don't see there being all that many instances where the polymorphic nature of FOR is useful because "sometimes you're counting integers, and sometimes you're skipping in series".</p>
<p>So to expedite FOR becoming stackless, I'm cutting it down to just numeric types.</p>
<p><strong>But if there are cases where a looping construct that spans integers and series is actually useful, I'd be interested to know what it is.</strong></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/generic-looping-cutting-for-back-a-bit/1310">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/generic-looping-cutting-for-back-a-bit/1310</link>
          <pubDate>Mon, 27 Jul 2020 12:00:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1310</guid>
          <source url="https://rebol.metaeducation.com/t/generic-looping-cutting-for-back-a-bit/1310.rss">Generic Looping: Cutting FOR Back a Bit</source>
        </item>
        <item>
          <title>Compatibility MAP-EACH (and problems therewith)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Loops</category>
          <description><![CDATA[
            <p>In trying to make a shim where MAP-EACH splices and has /ONLY, I thought the easiest way of doing it might be to redo it in terms of a COLLECT of a FOR-EACH.</p>
<p>This delves some into the ambition of Ren-C to raise the bar for Rebol, so it raises some questions.  First, let's try a naive approach:</p>
<pre><code>map-each: function [
    {https://rebol.metaeducation.com/t/1155}
    return: [block!]
    'vars [blank! word! block!]
    data [any-series! any-path! action!]
    body [block!]
    /only
][
    collect [
        for-each :vars :data [
            keep/(only) do body
        ]
    ]
]
</code></pre>
<p>One reason this won't work correctly is because BODY is executed via a "link" of DO instead of being embedded into the body of the FOR-EACH.  That means it won't bind to the VARS variables.  And in a definitional-break-and-continue world (which I've been considering) it won't have words like CONTINUE or BREAK bound.</p>
<p>We can address that by embedding the code in, let's say we just put it in as a GROUP!</p>
<pre><code>    collect [
        for-each :vars :data compose [
            keep/(only) (as group! body)  ; only inside path, not a compose/deep
        ]
    ]
</code></pre>
<p>This simple implementation supplements the body of the MAP-EACH with additional code.  It does it by composing in the body code as a GROUP!, so that it will pick up any bindings the FOR-EACH would add.</p>
<p>Fair enough, but it has a couple of problems.  One problem: what if I said <strong>map-each keep [1 2 3] [...]</strong>?  :-/  Our supplemental body adds code that the user doesn't see at the callsite, so they don't know to avoid usage of words that are in that supplemental body for their loop variables.  This gets worse the more supplemental code you have.</p>
<h2><a name="p-3459-i-think-we-need-to-expose-something-lower-level-than-for-each-1" class="anchor" href="https://rebol.metaeducation.com#p-3459-i-think-we-need-to-expose-something-lower-level-than-for-each-1"></a>I think we need to expose something lower-level than FOR-EACH</h2>
<p>Really it seems like what you need here is a tool that lets you set up whatever binding object a loop is going to use, gives you a chance to bind code to that object, then lets you run the iteration independent of binding.  Something like:</p>
<pre><code>    collect [
        [context looper]: make-loop-stuff :vars :data
        bind body context
        while [looper] [
            keep/(only) do body
        ]
    ]
</code></pre>
<p>The imagined MAKE-LOOP-STUFF would give you two things back: a context to bind any code into that you wanted to see the changes to variables in, and a function you could call that would update the values of those variables as long as there was more data.</p>
<h2><a name="p-3459-just-another-epicycle-of-the-binding-problems-2" class="anchor" href="https://rebol.metaeducation.com#p-3459-just-another-epicycle-of-the-binding-problems-2"></a>....Just another epicycle of the binding problems...</h2>
<p>Binding in Rebol will always be Rube-Goldberg-like, and so the question is how to maximize the fun and minimize the annoyance, while still getting decent performance.  I think if people can think of FOR-EACH as a higher level "macro" which makes a lot of assumptions in order to be ergonomic, they can realize that writing their own loop is going to involve digging deeper.</p>
<p>Something like the pattern above could be used to implement FOR-EACH, MAP-EACH, or REMOVE-EACH...though they could retain their native optimized versions.  There's still worries about mutating the bindings on passed-in code (the <strong>bind body context</strong> above) so a "good" answer would be something like <strong>body: in context body</strong> where that was understood to not modify the original, but give a rebound "view" at a lower cost.</p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/compatibility-map-each-and-problems-therewith/1192">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/compatibility-map-each-and-problems-therewith/1192</link>
          <pubDate>Fri, 09 Aug 2019 19:21:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1192</guid>
          <source url="https://rebol.metaeducation.com/t/compatibility-map-each-and-problems-therewith/1192.rss">Compatibility MAP-EACH (and problems therewith)</source>
        </item>
        <item>
          <title>Special Syntax for FOR-EACH/etc. to receive ACTION!s?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Loops</category>
          <description><![CDATA[
            <p>Here is some pretty innocuous-looking code:</p>
<pre><code>n: 1
for-each item block [
    print ["the" item "is" n "in the block"]
    n: n + 1
]
</code></pre>
<p>But because Rebol runs ACTION!s when they are bound to WORD!s, and you can put ACTION!s in BLOCK!s, you can get into trouble:</p>
<pre><code>muhaha: func ['x 'y 'z] [print ["stealing your args!" x y z]]
block: compose [10 (:muhaha) 20]
</code></pre>
<p>Enumerating such a thing produces total garbage:</p>
<pre><code>the 10 is 1 in the block
stealing your args! is n in the block
the #[void]
the 20 is 3 in the block
== 4
</code></pre>
<p>I'm not concerned about malicious cases--Rebol is fundamentally not secure about this kind of thing (see and discuss at <a href="https://rebol.metaeducation.com/t/the-philosophy-of-security-in-rebol/172">"The Philosophy of Security in Rebol"</a>)  But you want to write code that gives reasonable error messages, especially when writing a mezzanine routine.</p>
<p>Unfortunately, doing this "the right way" is ugly (and it doesn't actually work in a general sense):</p>
<pre><code>n: 1
for-each item block [
    print ["the" :item "is" n "in the block"]
    n: n + 1
]
</code></pre>
<p>That only has one reference to the item, but it's clearly much uglier in real cases.  But beyond being ugly, tacking a <code>:</code> onto the front of everything doesn't have the same semantics.  What if you <em>think</em> you're dealing with a block of objects, and want to call methods on them?  <code>item/some-method</code> and <code>:item/some-method</code> aren't the same.  (Note: perhaps (:item)/some-method should work?)</p>
<p>Point being: even if you think adding colons is mitigating the problems, you're not getting what you really want...which most of the time, is an error.</p>
<h2><a name="p-2805-could-we-make-the-common-case-work-better-1" class="anchor" href="https://rebol.metaeducation.com#p-2805-could-we-make-the-common-case-work-better-1"></a>Could we make the common case work better?</h2>
<p>Something I've often wondered is if these enumerators which take words and set them through a loop would only let you get at ACTION!s if you used some other ANY-WORD! type.  This way, they could error otherwise...and common loops could feel safe.</p>
<p>For the sake of example, let's say it's a GET-WORD! passed to FOR-EACH if you actually are prepared to work with ACTION!s.  The first example above, by using a plain WORD!, would output a clear error instead of gibberish:</p>
<pre><code>the 10 is 1 in the block
** Error: Variable `item` must be GET-WORD! to hold ACTION! in FOR-EACH
</code></pre>
<p>If GET-WORD! were used, it would make some amount of sense--and line up with the fact that you would be wanting to use GET-WORD! in the body too.  But it sacrifices the current feature for GET-WORD!, which is "soft quoting"...where the word specifies the word to look at to find the word to use:</p>
<pre><code> &gt;&gt; word: 'item
 &gt;&gt; for-each :word [1 2 3] [print [item]]
 1
 2
 3
</code></pre>
<p>However, there's another way of doing this, with GROUP!:</p>
<pre><code> &gt;&gt; word: 'item
 &gt;&gt; for-each (word) [1 2 3] [print [item]]
 1
 2
 3
</code></pre>
<p>Soft-quoting doesn't really come up all <em>that</em> terribly often.  Still, it's a little annoying that this would throw a wrench into COMPOSE situations doing simple soft-quotes, but you could attack that multiple ways.</p>
<p>I think it would be much better if you could mark very clearly which enumerations were intentionally working with ACTION!s.  The error messages would be better, and people are savvy enough to know there could be a problem won't be so paranoid in their basic enumerations--knowing the error will be delivered.</p>
<h2><a name="p-2805-should-just-loops-be-affected-or-all-soft-quotes-2" class="anchor" href="https://rebol.metaeducation.com#p-2805-should-just-loops-be-affected-or-all-soft-quotes-2"></a>Should just loops be affected, or all soft quotes?</h2>
<p>It could be loops for starters.  They could be switched to hard quotes and do their own logic, only giving soft-quote semantics for GROUP!s.</p>
<p>Or maybe soft-quoting is too sacred as a mechanism in PATH! processing...and you don't want to have to type <strong>foo/(bar)</strong> instead of <strong>foo/:bar</strong>...so that translates to wanting to keep it in sync.</p>
<p>This might mean using another datatype, e.g. <strong>for-each <span class="mention">@item</span> block [...]</strong> to say "ACTION!s are okay".</p>
<p>Any thoughts?  I know Rebol has some elements of "it's a fundamentally unsafe language", but I just feel there need to be <em>some</em> limits.  But I don't want to bulletproof every FOR-EACH in the system against function injections--even if they are all just accidents, you want better feedback than having a mess be made.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/special-syntax-for-for-each-etc-to-receive-action-s/955">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/special-syntax-for-for-each-etc-to-receive-action-s/955</link>
          <pubDate>Mon, 10 Dec 2018 18:33:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-955</guid>
          <source url="https://rebol.metaeducation.com/t/special-syntax-for-for-each-etc-to-receive-action-s/955.rss">Special Syntax for FOR-EACH/etc. to receive ACTION!s?</source>
        </item>
        <item>
          <title>Should modifying variables during iteration affect it?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Loops</category>
          <description><![CDATA[
            <p>Here is the behavior of changing a REPEAT variable in Rebol2 and R3-Alpha:</p>
<pre><code>rebol2&gt;&gt; repeat n 3 [print "What happens?" n: 3]
What happens?
== 3
</code></pre>
<p>Here's that same behavior in Red:</p>
<pre><code>red&gt;&gt; repeat n 3 [print "What happens?" n: 3]
What happens?
What happens?
What happens?
== 3
</code></pre>
<p>One might then ask what happens if you set the loop variable to something not even an integer.  In Rebol2, it just exits the loop.  In R3-Alpha, it errors:</p>
<pre><code>r3-alpha&gt;&gt; repeat n 3 [print "What happens?" n: &lt;boo&gt;]
What happens?
** Script error: tag! type is not allowed here
</code></pre>
<h2><a name="p-2769-is-there-always-a-clear-meaning-1" class="anchor" href="https://rebol.metaeducation.com#p-2769-is-there-always-a-clear-meaning-1"></a>Is there always a clear meaning?</h2>
<p>Not necessarily.  What about FOR-EACH?</p>
<pre><code>foreach x [1 2 3] [x: "what should this do?"]
</code></pre>
<p>If you put on your imagination hat, you might imagine this as a way to mutate the series being iterated.  In that world, changing X would actually change the element in the array.  But Rebol's model isn't completely geared for this...though it <em>could</em> be done (by marking the variable with a bit, observing if that bit is cleared in an overwrite, and doing a write-back if clear).</p>
<p>That's not necessarily a <em>bad</em> imagination-hat to have on--though I'd worry about implementing a feature exploiting bit-level knowledge that a user couldn't do themselves.  (So it would have to rely on equality, and write back non-equal things--just having an optimization that avoided the test if the bit hadn't been mucked with.)</p>
<p><em>(Note: C++ can do this through "references", and it is the difference between <strong>for (auto x : collection) {...}</strong> and <strong>for (auto &amp;x : collection)</strong>.)</em></p>
<p>But even if you could stretch and come up with a meaning in FOR-EACH, the broader point is it's not always possible.  Some iterations that put values in a variable may not be able to sensibly understand a change made to the iteration variable, and interpret it in a way that affects the next iteration.</p>
<h2><a name="p-2769-what-about-performance-2" class="anchor" href="https://rebol.metaeducation.com#p-2769-what-about-performance-2"></a>What about performance?</h2>
<p>Red's decision on REPEAT gives it a certain freedom from trying to figure out the meaning of any changes to the variable.  The iteration holds internal state--images that into a variable for you---and if you change it that's just for your temporary purposes in the loop.  There's no fetch of the loop variable on each iteration, only a write.</p>
<p>But Red clearly thinks it's important enough in FORALL to pay attention to changes to the iterated variable, because that works:</p>
<pre><code>red&gt;&gt; forall data [probe data data: next data]
[1 2 3 4]
[3 4]
== [4]
</code></pre>
<p>In fact, in a fairly rare case of Red not repeating <a href="https://github.com/rebol/rebol-issues/issues/2307">a bug in R3-Alpha</a>, they fully <a href="https://github.com/red/red/blob/1e0d5ec2360b336ef8111546e3221024dc28e31f/runtime/natives.reds#L350">fetch the variable each time through the FORALL</a>.</p>
<p>Paying attention to changes to the variable is not going to be the most <em>performant</em> choice.  By avoiding the fetch of a potentially modified N in the REPEAT loop above, Red doesn't have to re-fetch the variable on each loop iteration to make sure you didn't change it into a TAG!, or whatever.</p>
<p>But I think it is worth noting that it is now 6 years since R3-Alpha was open sourced, and 7 years since Red's announcement.  When you think about making decisions based on "performance", e.g. the speed of a REPEAT loop, choosing something less flexible for purposes of marginal efficiency <em>makes less sense than ever</em>.</p>
<h2><a name="p-2769-solutions-3" class="anchor" href="https://rebol.metaeducation.com#p-2769-solutions-3"></a>Solutions?</h2>
<p>Being able to change loop variables allows more patterns of solution.  The FORALL case is a good one (Ren-C calls this category FOR-NEXT because you can change the series to whatever you like, and it runs a NEXT on it at each iteration).  I think it would be less expressive to not be able to see response from the iteration to a change, and by extension one would argue that changing the index in a REPEAT (or plain FOR) should also have an effect.</p>
<p>Yet I've pointed out it doesn't always make sense--such as in FOR-EACH.</p>
<p>One idea that comes to mind could be to PROTECT any loop variables whose modification cannot semantically be mapped back into meaning for the next iteration.  If you find you can't change a variable, then that means that the loop wouldn't be able to react if you did.</p>
<p>I like that because it feels like it's giving feedback to the user about the contract of the loop.  Though it might appear to "waste" a variable slot you could otherwise use as a temporary.</p>
<p>What do you think?  Should loops lock any variables from modification if they can't meaningfully interpret a modification to affect the next iteration?</p>
            <p><small>9 posts - 4 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-modifying-variables-during-iteration-affect-it/938">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-modifying-variables-during-iteration-affect-it/938</link>
          <pubDate>Sun, 02 Dec 2018 11:18:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-938</guid>
          <source url="https://rebol.metaeducation.com/t/should-modifying-variables-during-iteration-affect-it/938.rss">Should modifying variables during iteration affect it?</source>
        </item>
        <item>
          <title>Infinite Loops vs. Errors</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Loops</category>
          <description><![CDATA[
            <p>There's a seemingly innocuous response to an edge case in FOR in R3-Alpha:</p>
<pre><code>&gt;&gt; for i 1 10 0 [print "???"]
== none
</code></pre>
<p>That's a change from Rebol2, where it would infinite loop.  The change was deliberate, and is part of a discussion that wanders into design philosophy:</p>
<p><a href="https://github.com/rebol/rebol-issues/issues/1993">REBOL-ISSUES: FOR start end bump behavior inconsistent, doesn't make sense</a></p>
<p>BrianH writes:</p>
<blockquote>
<p>My two proposals were both intended to make absolutely sure that no combination of start, end and bump would by themselves end up with FOR doing an infinite loop. The main purpose of this is to allow the developer to remove expensive conditional code that would be needed to screen start, end and bump in combination to make sure that such loops don't happen by accident.</p>
</blockquote>
<p>He defends the idea of just returning vs. raising an error when a 0 is given as a bump amount:</p>
<blockquote>
<p>Of my two proposals, one has it trigger an error when bump = 0 and start != end, and one has the loop just not do anything and return none. I like the second of those choices, because you could plausibly argue that we have decided that a bump of 0 is just out of range when start != end. That will allow the developer to cut down on conditional code to avoid errors, which is the whole reason for defining 0 to be out of range in the first place.  So it would be counterproductive to require them to add back the conditional code for another reason.</p>
</blockquote>
<p>He argues that the existence of FOREVER means people wishing to intentionally write an infinite loop can do that another way.</p>
<h2><a name="p-2767-its-an-ideabut-is-it-a-good-one-1" class="anchor" href="https://rebol.metaeducation.com#p-2767-its-an-ideabut-is-it-a-good-one-1"></a>It's <em>an</em> idea...but is it a good one?</h2>
<p>No-infinite-loops is a premise that bears scrutiny.  Consider also how R3-Alpha's PARSE tries to avoid infinite loops by failing out "if it doesn't make progress".  This rule has caused frustration because its detection of progress is based on the position moving, and rules that delete material but stay in one place for the next rule don't trigger that detection.</p>
<p>If I put on my code golfing hat, it makes sense to not error on inputs that could be given a legitimate meaning.  So refusing to do something on instances like SKIP of 0 doesn't seem like a good idea.</p>
<p>But a blank/null result and no loop from something that should have been an infinite loop could confuse people.  And just because FOREVER exists doesn't mean that you might not want to write one "polymorphic" loop that could decay into an infinite loop if necessary.  Plus infinite loops aren't necessarily infinite, you can BREAK out of them.</p>
<p>Consider also that Ren-C uses BLANK! as a way of opting out of an operation by way of its arguments.  So if you are passing in indices to FOR and want to have a bump value you can pass in to get the loop to not run at all, that could be a good role for BLANK!.  And you can turn zeros into blanks pretty easily <em>(maybe in the future, with <strong>try match :(not zero?) arg</strong>)</em></p>
<p>So when one is trying to encourage simplicity, are complex "protections" against infinite loops adding value...or just making the system more mysterious?  My feeling at the moment is that it would be better to go ahead and do what people say in the "traditional" way with infinite loops, and let improved debugging pick up any slack.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/infinite-loops-vs-errors/936">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/infinite-loops-vs-errors/936</link>
          <pubDate>Sat, 01 Dec 2018 09:51:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-936</guid>
          <source url="https://rebol.metaeducation.com/t/infinite-loops-vs-errors/936.rss">Infinite Loops vs. Errors</source>
        </item>
        <item>
          <title>I&#39;m bringin&#39; EVERY back (yeah!)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Loops</category>
          <description><![CDATA[
            <p><em>(<img src="https://rebol.metaeducation.com/images/emoji/twitter/man_dancing.png?v=14" title=":man_dancing:" class="emoji" alt=":man_dancing:" loading="lazy" width="20" height="20">  <img src="https://rebol.metaeducation.com/images/emoji/twitter/musical_note.png?v=14" title=":musical_note:" class="emoji" alt=":musical_note:" loading="lazy" width="20" height="20"> <img src="https://rebol.metaeducation.com/images/emoji/twitter/desktop_computer.png?v=14" title=":desktop_computer:" class="emoji" alt=":desktop_computer:" loading="lazy" width="20" height="20"> ...them other boys don't know how to hack (yeah!) <img src="https://rebol.metaeducation.com/images/emoji/twitter/musical_note.png?v=14" title=":musical_note:" class="emoji" alt=":musical_note:" loading="lazy" width="20" height="20"> <img src="https://rebol.metaeducation.com/images/emoji/twitter/man_dancing.png?v=14" title=":man_dancing:" class="emoji" alt=":man_dancing:" loading="lazy" width="20" height="20"> <img src="https://rebol.metaeducation.com/images/emoji/twitter/computer.png?v=14" title=":computer:" class="emoji" alt=":computer:" loading="lazy" width="20" height="20">)</em></p>
<p>With <a href="https://youtu.be/UD8tGWIqA-c?t=17">apologies to Justin Timberlake</a>, I re-present to you EVERY.  It was <a href="https://github.com/metaeducation/ren-c/issues/847">temporarily shelved</a> due to ambiguous semantics, that recent changes to the loop result protocol have basically solved.</p>
<p>It's like a FOR-EACH but if the loop body ever returns false, it returns false:</p>
<pre><code>&gt;&gt; every x [1 3 7] [print [x] | odd? x]
1
3
7
== #[true]

&gt;&gt; every x [1 4 7] [print [x] | odd? x]
1
4
7
== #[false]
</code></pre>
<p>So EVERY runs through all the loop steps (assuming you don't break), but remembers if the body ever returns a falsey value...and if so returns #[false].  Otherwise it returns the last truthy value.</p>
<p>Note that <code>CONTINUE</code> is interpreted as <code>CONTINUE NULL</code>, which means "act as if the loop body reached the end and had evaluated to null for this iteration".  As null is falsey, that means you need to say <code>CONTINUE TRUE</code> (or other truthy value) if you want that loop iteration to not count as disrupting the everyness.</p>
<pre><code>&gt;&gt; every x [1 2 3] [print [x] | if x = 2 [continue] x]
1
2
3
== #[false]

&gt;&gt; every x [1 2 3] [print [x] | if x = 2 [continue true] x]
1
2
3
== 3
</code></pre>
<p>It still obeys the loop result protocol, so that means if the loop ever breaks you'll get a NULL... and if the loop body never runs you'll get blank.  All three states are falsey so you get:</p>
<pre><code>every x data [
    ...
] or [
    // code to run if there was a break, there was no data,
    // or any of the loop body runs returned null/break/false
]
</code></pre>
<p>If you're trying to build an opt-out situation which would default to an empty input being okay (instead of falsey like if the body failed), test against false explicitly so the blank case won't qualify:</p>
<pre><code>false &lt;&gt; every x data [
    // if this body returns false (null, blank) then that will
    // make the whole expression false.  But the no data
    // case which returns blank will still give you truthyness
]
</code></pre>
<p>Though just because of how things work out, that will treat BREAK as a "success", since <code>false &lt;&gt; null</code>.  So if you have a need to use both BREAKs <em>and</em> falsey loop bodies in the every, turn the nulls into false explicitly:</p>
<pre><code>false &lt;&gt; (every x data [
    ...
] else [false])
</code></pre>
<p>Loop iterations must return something that can be tested for conditional truth or falsehood, so voids aren't legal.  This is an important distinction with FOR-EACH, which is able to run loop bodies that return void</p>
<pre><code>&gt;&gt; every x [1 2 3] [print "this errors, void loop body result"]
this errors, void loop body result
** Script Error: VOID! values are not conditionally true or false
</code></pre>
<p><em><img src="https://rebol.metaeducation.com/images/emoji/twitter/musical_note.png?v=14" title=":musical_note:" class="emoji" alt=":musical_note:" loading="lazy" width="20" height="20"> ...so get your EVERY on (go 'head, be gone with it) <img src="https://rebol.metaeducation.com/images/emoji/twitter/musical_note.png?v=14" title=":musical_note:" class="emoji" alt=":musical_note:" loading="lazy" width="20" height="20"></em></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/im-bringin-every-back-yeah/915">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/im-bringin-every-back-yeah/915</link>
          <pubDate>Mon, 19 Nov 2018 15:25:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-915</guid>
          <source url="https://rebol.metaeducation.com/t/im-bringin-every-back-yeah/915.rss">I&#39;m bringin&#39; EVERY back (yeah!)</source>
        </item>
        <item>
          <title>The Simple-yet-Powerful Magic of The Loop Result Protocol</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Loops</category>
          <description><![CDATA[
            <h2><a name="p-2128-loops-return-null-if-and-only-if-they-break-1" class="anchor" href="https://rebol.metaeducation.com#p-2128-loops-return-null-if-and-only-if-they-break-1"></a>Loops return null if-and-only-if they break</h2>
<p>One very good reason this rule exists is to make it easy to build custom loop constructs out of several other loop constructs.  You can tell "from the outside" whether one of your sub-loops was BREAK'd...this way the the higher level construct is aware it shouldn't run any more of its component loop phases.</p>
<p><em>(If this rule did not exist, then implementing a loop out of several other loops would have to invasively hook and rebind BREAK in each loop body to its own, and handle that.  Even if it were possible--which it probably should be--this would be complex and inefficient.  So the simpler rule is better!)</em></p>
<p>To distinguish this case from normal loop results, a NULL loop body evaluation will be turned into a "boxed" NULL, e.g. a null isotope in a parameter pack:</p>
<pre><code>&gt;&gt; for-each x [1 2 3] [null]
; first in pack of length 1
== ~null~  ; anti

&gt;&gt; meta for-each x [1 2 3] [null]
== ~[~null~]~  ; anti
</code></pre>
<p>Parameter packs containing NULL cannot be stored in variables, and will "decay" to a normal NULL when assigned to a variable.</p>
<h2><a name="p-2128-many-common-loops-return-void-if-the-body-never-ran-2" class="anchor" href="https://rebol.metaeducation.com#p-2128-many-common-loops-return-void-if-the-body-never-ran-2"></a>...many common loops return void if the body never ran</h2>
<pre><code>&gt;&gt; repeat 0 [&lt;unreturned&gt;]
== ~[]~  ; anti

&gt;&gt; for-each x [] [&lt;unreturned&gt;]
== ~[]~  ; anti
</code></pre>
<p>Though unlike the return of pure null "if and only if" there was a break, returning void does not guarantee the body never ran.</p>
<pre><code>&gt;&gt; repeat 1 [elide print "might run, but produce nothing..."]
might run, but produce nothing...
== ~[]~  ; anti
</code></pre>
<p>Note that some loops do not fit this pattern...e.g. an empty MAP-EACH gives an empty block:</p>
<pre><code>&gt;&gt; map-each x [] [print "never runs"]
== []
</code></pre>
<h2><a name="p-2128-reacting-to-breaks-is-easy-3" class="anchor" href="https://rebol.metaeducation.com#p-2128-reacting-to-breaks-is-easy-3"></a>Reacting to BREAKs is easy!</h2>
<p>Loop aggregators aren't the only place that benefits from being able to tell what happened with a loop from its result.   Plain user code reaps the benefits as well.</p>
<p>If you want to know if a loop BREAK'd, then ELSE is the ticket:</p>
<pre><code>for-each x block [
   if some-test x [break]
] else [
    ; This code runs only if the loop breaks
    ; ...so it still runs even if block is empty
]
</code></pre>
<p>You can combine that with THEN to segregate code when the loop <em>doesn't</em> break:</p>
<pre><code>for-each x block [
   if some-test x [break]
] then [
    ; This code runs only if the loop doesn't break
] else [
    ; This code runs only if the loop breaks
]
</code></pre>
<h3><a name="p-2128-practical-example-4" class="anchor" href="https://rebol.metaeducation.com#p-2128-practical-example-4"></a>Practical example?</h3>
<p>Here's a very cool real world case from the console code:</p>
<pre><code>pos: molded: mold:limit :v 2048
repeat 20 [
    pos: next of any [find pos newline, break]
] then [
    insert clear pos "..."
]
</code></pre>
<p>You have up to 2048 characters of data coming back from the mold, ok. Now you want just the first 20 lines of that.  If truncation is necessary, put an ellipsis on the end.</p>
<p>FIND will return NULL if it can't find the thing you asked it, so the ANY will run the break when you can't get the position.  If it makes it up to 20 without breaking, the THEN clause runs.</p>
<p>So there you go.  The first 20 lines of the first 2048 characters of a mold, truncating with "..."  I think the THEN really follows the idea of <em>completion</em>, it makes sense (to me) that a BREAK would bypass a THEN (or an ALSO, which is similar) clause.</p>
<p>I encourage people to get creative, to look at ways to use this to write clearer/shorter/better code.</p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/the-simple-yet-powerful-magic-of-the-loop-result-protocol/609">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/the-simple-yet-powerful-magic-of-the-loop-result-protocol/609</link>
          <pubDate>Tue, 08 May 2018 18:56:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-609</guid>
          <source url="https://rebol.metaeducation.com/t/the-simple-yet-powerful-magic-of-the-loop-result-protocol/609.rss">The Simple-yet-Powerful Magic of The Loop Result Protocol</source>
        </item>
        <item>
          <title>The Mismatch of Arity-1 UNTIL and Arity-2 WHILE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Loops</category>
          <description><![CDATA[
            <p>Long ago, there was a fervent debate about whether UNTIL was a word that was "naturally paired" with WHILE...like IF and UNLESS.  So it was wondered if UNTIL should be an arity-2 function which was effectively WHILE-NOT, instead of its arity-1 form.</p>
<p>The altered arity-2 UNTIL was introduced in Ren-C to try it, with LOOP-UNTIL taking over the old arity-1 behavior.  For good measure, LOOP-WHILE was added as an arity-1 native as well.</p>
<p>To make a long story short: I guess I don't think that it wound up making that big a difference in the scheme of things.  The primary impact on me personally, was actually just making code golf programs longer. <em>(Having <code>U</code> be <code>UNTIL</code> is an appealing option.)</em></p>
<p>When you look at <code>forever [...]</code> and <code>until [...]</code>, they seem to go together sensibly.  You might even ask--as some have--if it's WHILE that's weird.  If you think about WHILE and UNTIL as being two words offering entry points into loop space, it's like it's giving you two common ones with common words.</p>
<p>I didn't wind up using <code>loop-while</code> and <code>loop-until</code> as much as I thought I would.  So here in the time of analyzing changes for goodness or badness and trying to pin things down, I think the status quo is the better answer.  Plus, when there are so many other slam-dunk good changes, this one is more a distraction than anything else.</p>
<p>So people who fought for the status quo--DocKimbel/Rebolek/Oldes/etc.--get to win on this one, I guess.</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/the-mismatch-of-arity-1-until-and-arity-2-while/594">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/the-mismatch-of-arity-1-until-and-arity-2-while/594</link>
          <pubDate>Wed, 18 Apr 2018 09:27:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-594</guid>
          <source url="https://rebol.metaeducation.com/t/the-mismatch-of-arity-1-until-and-arity-2-while/594.rss">The Mismatch of Arity-1 UNTIL and Arity-2 WHILE</source>
        </item>
        <item>
          <title>Using loops with ELSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Loops</category>
          <description><![CDATA[
            <p>Loop constructs return NULL when there is a BREAK, and generally return a VOID if they never run their bodies.  This gives some nice expressive power, such as this example from some code that appends encapped data to executables...which uses both THEN and ELSE:</p>
<pre><code>while [0 &lt;&gt; modulo (length of executable) 4096] [
    append executable #{00}
] then [
    print ["Executable padded to" length of executable "bytes long."]
] else [
    print "No padding of executable length required."
]
</code></pre>
<p>What you get out of this is equivalent to this R3-Alpha code:</p>
<pre><code>either 0 = modulo length? executable 4096 [
    print "No padding of executable length required."
][
    while [0 &lt;&gt; modulo length? executable 4096] [
        append executable #{00}
    ]
    print ["Executable padded to" length? executable "bytes long."]
]
</code></pre>
<p>It's a way to avoid repeating yourself.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/using-loops-with-else/523">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/using-loops-with-else/523</link>
          <pubDate>Sat, 10 Feb 2018 07:04:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-523</guid>
          <source url="https://rebol.metaeducation.com/t/using-loops-with-else/523.rss">Using loops with ELSE</source>
        </item>
        <item>
          <title>Remove-each x [for-each map-each remove-each] [x = &#39;remove-each]</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Loops</category>
          <description><![CDATA[
            <p><strong>TL;DR</strong> =&gt; How do people feel about REMOVE-EACH locking the array which is to be removed from during the removal process (so it appears unmodified while running the loop body, even if removals have been indicated).  Then all the removals would be effected at the end.  Else, we are going to have to get rid of it as a native, and it will be written as a mezzanine with FOR-NEXT or something.  I explain below.</p>
<hr>
<p>Most iterating constructs in Ren-C apply protections to the iterated series.  This ranges from DO, to PARSE, to CASE, etc.  While it may seem "more flexible" to not put a temporary lock on a series during such iterations, this introduces quite a number of headaches.</p>
<p>Lack of a lock means the code doing the iterating must have some kind of safety across modifications, and that's not free.  If you're <em>lucky enough not to crash</em>, you still wind up with a hodgepodge of semantics.</p>
<p>For instance, what should this do?</p>
<pre><code>cases: [
    true [
        print "hi"
        loop 10000 [insert cases [true [print "expanded"]]]
    ]
    true [
        print "tail"
    ]
]

case/all cases
</code></pre>
<p>R3-Alpha <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/n-control.c#L336">did not cache the series tail</a> at the beginning of the CASE, nor is it caching pointers to values in the block.  It rereads the series length each time through the loop after user code has run (which has a "cost"), and compares the current index to that.  Then, Do_Next() has to speak in terms of the index and block, re-fetching it each time.  Hence you get <code>hi hi hi hi...</code> until you run out of memory.</p>
<p>Those wacky folks over at Red <a href="https://github.com/red/red/blob/60ee23ba8e5765fa28e964088b2263fd12fa2c8c/runtime/natives.reds#L481">do cache the length</a>.  Which means you get <code>hi</code> and <code>expanded</code> and that's it.  If you're curious about what happens when you <em>shorten</em> the array being iterated, well...</p>
<pre><code>&gt;&gt; cases: [1 [print "1" clear cases] 2 [print "2"] 3 [print "3"]]

&gt;&gt; case/all cases
1
2
3

&gt;&gt; cases
== []
</code></pre>
<p>And yes...there it goes, reading beyond the tail, into essentially invalid memory.  If they had a garbage collector and it ran, it would presumably not protect the values beyond the tail...and these stale reads could crash on GC'd pointers inside those values.  These kinds of bugs <a href="https://github.com/rebol/rebol-issues/issues/2214">were everywhere</a> in R3-Alpha.  My crystal ball suggests Red will probably try patching with something that fetches the length each time--but again, each such patch adds a bit of cost, to preserve a nonsensical invariant, and... I'll just stop before I get on too much of a rant here.</p>
<p>I'm glad to say that the workings of frames in Ren-C do the right locking and permit caching, plus generally having workarounds for getting the dynamism people were seeking with the above kinds of manipulations.</p>
<p>But this brings me to the topic of the question: the problematic primitive <strong>remove-each</strong>.  By its very definition it removes things from a series without creating another series.  That means that series can't be "locked" during the enumeration...at least not if you expect to see the effect of the removals during the enumeration.</p>
<p>Moreover, if you're going to see the effects during the enumeration it is <em>very</em> inefficient, effectively O(N^2).  Each time you do a removal, you have to slide all the data in the underlying array to fill in the gap and leave a coherent array.</p>
<p>Basically, the native's hands are tied to where it gets nearly no benefit from being a native at all.  One might as well implement it as a FOR-NEXT, and then at least the fact that the construct is all usermode would mean that one isn't fiddling with trying to write it in C and do all the bookkeeping of caches.</p>
<p>It is technically possible that the array could be locked during enumeration, flip some bits on the values in the array as it went, and then when REMOVE-EACH is finished do a compaction all in one step.  That means that you would not see the effects of the removals until after the loop was done.  We don't exactly have a ton of bits we can use for this inside the values themselves; so you might wind up with a parallel dynamic allocation of a bit array to do this.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/remove-each-x-for-each-map-each-remove-each-x-remove-each/262">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/remove-each-x-for-each-map-each-remove-each-x-remove-each/262</link>
          <pubDate>Tue, 22 Aug 2017 01:01:36 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-262</guid>
          <source url="https://rebol.metaeducation.com/t/remove-each-x-for-each-map-each-remove-each-x-remove-each/262.rss">Remove-each x [for-each map-each remove-each] [x = &#39;remove-each]</source>
        </item>
  </channel>
</rss>

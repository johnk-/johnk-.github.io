<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Lexer - AltRebol</title>
    <link>https://rebol.metaeducation.com/c/development/lexer/64</link>
    <description>Topics in the &#39;Lexer&#39; category This is for discussions about how to process UTF-8 text into Rebol elements.</description>
    
      <lastBuildDate>Fri, 18 Jul 2025 05:42:54 +0000</lastBuildDate>
      <atom:link href="https://rebol.metaeducation.com/c/development/lexer/64.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Should `[: . /]` Require Escaping In RUNE! ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Lexer</category>
          <description><![CDATA[
            <p>Should it be:</p>
<pre><code>&gt;&gt; second "a.b"
== #.
</code></pre>
<p>Or should it be:</p>
<pre><code>&gt;&gt; second "a.b"
== #"."
</code></pre>
<p>The ramifications here are that if these delimiters are RUNE! contents without escaping, then you can't put RUNE! inside of [CHAIN! PATH! TUPLE!]</p>
<pre><code>&gt;&gt; type of #a/b
== \~{rune!}~\  ; antiform  (e.g. not a PATH!)
</code></pre>
<h2><a name="p-8536-you-can-put-the-space-rune-in-sequences-today-1" class="anchor" href="https://rebol.metaeducation.com#p-8536-you-can-put-the-space-rune-in-sequences-today-1"></a>You Can Put the SPACE RUNE! In Sequences Today</h2>
<p>I haven't questioned it lately, but the <a href="https://rebol.metaeducation.com/t/reified-unreassignable-nothingness-space-runes/2457">SPACE character (now denoted by an underscore)</a> is what's used to indicate there's nothing in a PATH!/TUPLE!/CHAIN! slot:</p>
<pre><code>&gt;&gt; second first [:a]
== a

&gt;&gt; first first [:a]
== _
</code></pre>
<p>That doesn't mean that all RUNE! have to be legal.  It could be the only one that is.</p>
<h2><a name="p-8536-single-hash-is-the-biggest-loss-2" class="anchor" href="https://rebol.metaeducation.com#p-8536-single-hash-is-the-biggest-loss-2"></a>Single-Hash Is The Biggest Loss</h2>
<p>When I think about how one might use RUNE! in tuples or paths or chains, the patterns I think are most likely to be interesting for dialects would be those that just put hash marks in spots.  An example of the kinds of patterns:</p>
<pre><code>a:#:c

#:#:#

#:b:#
</code></pre>
<p>If you look at the problem with those glasses, you might question the value of:</p>
<pre><code>&gt;&gt; to text! #:#:#
== ":#:#"
</code></pre>
<p>But how you see such things depends on what examples you're comparing it to.</p>
<p>Note that if you just want the characters, <code>[: / .]</code> are WORD!</p>
<pre><code>&gt;&gt; parse "./:" ['. '/ ':]
== :
</code></pre>
<p>So you already have a 2-character means of matching them in strings, for that purpose...that looks cleaner than:</p>
<pre><code>&gt;&gt; parse "./:" [#. #/ #:]
== #:
</code></pre>
<h2><a name="p-8536-the-legality-of-space-twists-my-arm-a-bit-3" class="anchor" href="https://rebol.metaeducation.com#p-8536-the-legality-of-space-twists-my-arm-a-bit-3"></a>The Legality of SPACE Twists My Arm A Bit</h2>
<p>I did say that just because space runes are legal doesn't mean all runes need to be legal.  But it does make me more inclined to say they are.</p>
<p>My leaning here is to say you have to escape them.  I think the hash character in tuple!/path!/chain! has more potential for enabling novel features than worrying over slightly briefer character notations.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-require-escaping-in-rune/2511">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-require-escaping-in-rune/2511</link>
          <pubDate>Fri, 18 Jul 2025 05:42:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2511</guid>
          <source url="https://rebol.metaeducation.com/t/should-require-escaping-in-rune/2511.rss">Should `[: . /]` Require Escaping In RUNE! ?</source>
        </item>
        <item>
          <title>Some IPv6 Address Examples</title>
          <dc:creator><![CDATA[rebolbot]]></dc:creator>
          <category>Lexer</category>
          <description><![CDATA[
            <blockquote>
<p>If someone is going to parse ipv6 addresses, can you give a good spread of examples of the edge cases and things to worry about?  A good list of ipv6 addresses that is fairly short but gives coverage of the kinds of things you need to support?</p>
</blockquote>
<hr>
<h1><a name="p-8454-ipv6-address-parsing-test-cases-1" class="anchor" href="https://rebol.metaeducation.com#p-8454-ipv6-address-parsing-test-cases-1"></a>IPv6 Address Parsing Test Cases</h1>
<h2><a name="p-8454-basic-format-variations-2" class="anchor" href="https://rebol.metaeducation.com#p-8454-basic-format-variations-2"></a>Basic Format Variations</h2>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">2001:0db8:85a3:0000:0000:8a2e:0370:7334     # Full format
2001:db8:85a3:0:0:8a2e:370:7334             # Leading zeros omitted
2001:db8:85a3::8a2e:370:7334                # Zero compression
</code></pre>
<h2><a name="p-8454-zero-compression-edge-cases-3" class="anchor" href="https://rebol.metaeducation.com#p-8454-zero-compression-edge-cases-3"></a>Zero Compression Edge Cases</h2>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">::1                                         # Loopback (all zeros except last)
::                                          # All zeros address
2001:db8::                                  # Trailing zeros compressed
::2001:db8                                  # Leading zeros compressed
2001::1                                     # Middle zeros compressed
fe80::1%lo0                                 # With zone identifier
</code></pre>
<h2><a name="p-8454-special-addresses-4" class="anchor" href="https://rebol.metaeducation.com#p-8454-special-addresses-4"></a>Special Addresses</h2>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">::ffff:192.0.2.1                           # IPv4-mapped IPv6
::ffff:0:192.0.2.1                         # IPv4-mapped (alternative)
64:ff9b::192.0.2.33                        # IPv4-embedded IPv6
2002:cb00:7100::                            # 6to4 prefix
ff02::1                                     # Multicast
fe80::1                                     # Link-local
fc00::1                                     # Unique local
</code></pre>
<h2><a name="p-8454-bracket-and-port-notation-5" class="anchor" href="https://rebol.metaeducation.com#p-8454-bracket-and-port-notation-5"></a>Bracket and Port Notation</h2>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">[2001:db8::1]:80                            # With port
[::1]:8080                                  # Loopback with port
[fe80::1%eth0]:22                           # Zone ID with port
</code></pre>
<h2><a name="p-8454-maximum-length-cases-6" class="anchor" href="https://rebol.metaeducation.com#p-8454-maximum-length-cases-6"></a>Maximum Length Cases</h2>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff     # All F's (maximum)
2001:0db8:85a3:0000:0000:8a2e:0370:7334     # Full expanded form
</code></pre>
<h2><a name="p-8454-tricky-parsing-cases-7" class="anchor" href="https://rebol.metaeducation.com#p-8454-tricky-parsing-cases-7"></a>Tricky Parsing Cases</h2>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">2001:db8:0:0:1:0:0:1                        # Multiple zero groups (can't compress)
2001:0:0:0:0:0:0:1                          # Could be 2001::1
a:b:c:d:e:f:1:2                             # All single hex digits
::1:2:3:4:5:6:7                             # Compression at start with 7 groups
1:2:3:4:5:6:7::                             # Compression at end with 7 groups
</code></pre>
<h2><a name="p-8454-case-sensitivity-8" class="anchor" href="https://rebol.metaeducation.com#p-8454-case-sensitivity-8"></a>Case Sensitivity</h2>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">2001:DB8:85A3::8A2E:370:7334                # Uppercase
2001:db8:85a3::8a2e:370:7334                # Lowercase
2001:Db8:85A3::8a2E:370:7334                # Mixed case
</code></pre>
<h2><a name="p-8454-invalid-cases-should-reject-9" class="anchor" href="https://rebol.metaeducation.com#p-8454-invalid-cases-should-reject-9"></a>Invalid Cases (Should Reject)</h2>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">2001:db8::1::2                              # Double compression (invalid)
2001:db8:85a3::8a2e:370:7334:extra          # Too many groups
2001:db8:85a3:8a2e:370:7334                 # Too few groups (7 instead of 8)
2001:db8:85ag::1                            # Invalid hex character 'g'
2001:db8:12345::1                           # Group too long (&gt;4 hex digits)
</code></pre>
<h2><a name="p-8454-key-parsing-rules-to-implement-10" class="anchor" href="https://rebol.metaeducation.com#p-8454-key-parsing-rules-to-implement-10"></a>Key Parsing Rules to Implement</h2>
<ol>
<li><strong>Zero Compression</strong>: Only one <code>::</code> allowed per address</li>
<li><strong>Group Count</strong>: Must have exactly 8 groups when expanded</li>
<li><strong>Hex Validation</strong>: Each group is 1-4 hexadecimal digits</li>
<li><strong>Case Insensitive</strong>: Accept both upper and lowercase</li>
<li><strong>Leading Zeros</strong>: Optional in each group</li>
<li><strong>Zone Identifiers</strong>: Handle <code>%</code> suffix for link-local addresses</li>
<li><strong>Brackets</strong>: Required when specifying ports</li>
<li><strong>IPv4 Mapping</strong>: Special handling for <code>::ffff:</code> prefix</li>
</ol>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/some-ipv6-address-examples/2496">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/some-ipv6-address-examples/2496</link>
          <pubDate>Mon, 23 Jun 2025 22:52:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2496</guid>
          <source url="https://rebol.metaeducation.com/t/some-ipv6-address-examples/2496.rss">Some IPv6 Address Examples</source>
        </item>
        <item>
          <title>(TRANSCODE &quot;&quot;) should be empty BLOCK!, not NULL</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Lexer</category>
          <description><![CDATA[
            <p>I faced a circumstance in the CONSOLE, where I wanted to know if you entered nothing.  e.g. if you just hit enter:</p>
<pre><code>&gt;&gt;     ; &lt;-- hit enter here

&gt;&gt;
</code></pre>
<p>So it just cycled, the prompt, no <code>==</code> output.</p>
<p>If you actually loaded the empty code as <code>[]</code> and evaluated it, then you would get a GHOST!.</p>
<pre><code>&gt;&gt;   ; &lt;-- hit enter here
== \~,~\  ; antiform comma! ("ghost!")

&gt;&gt;
</code></pre>
<p>I found that annoying.  However, if you actually did put something in there that evaluated to ghost, I wanted to see it:</p>
<pre><code>&gt;&gt; comment "for example"
== \~,~\  ; antiform comma! ("ghost!")

&gt;&gt;
</code></pre>
<p>So sure, I could write:</p>
<pre><code> let code: transcode ...whatever...

 if [] = code [  ; nothing loaded
     ...cycle prompt, don't evaluate...
 ]
</code></pre>
<p>But I got the feeling that a TRANSCODE of an empty string (or string that is all comments") is probably one of those edge cases that people are probably not expecting... and if it happens you probably need special handling.  So making it have better error locality and handling by being NULL seemed like a good idea.</p>
<p>So I changed it to return NULL if nothing was transcoded.</p>
<pre><code>if not code [  ; (or `if null? code`, or `code else [...]` etc.)
    ...nothing loaded, cycle prompt, don't evaluate...
]
</code></pre>
<p>BUT having experienced some of the epicycles beyond the console, I think this was a mistake.</p>
<h2><a name="p-8447-transcode-has-a-lot-of-error-returns-1" class="anchor" href="https://rebol.metaeducation.com#p-8447-transcode-has-a-lot-of-error-returns-1"></a>Transcode Has A Lot Of ERROR! Returns</h2>
<p>If <strong><code>try transcode ...</code></strong> is going to be useful at all, you probably don't want to conflate the many potential errors it can return with just returning null because it was a valid empty input.</p>
<p>And in the basic case, an empty script is a valid script.  It does nothing.</p>
<p>Emptiness is easy enough to test for.  So I think that's what should be done here.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/transcode-should-be-empty-block-not-null/2495">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/transcode-should-be-empty-block-not-null/2495</link>
          <pubDate>Thu, 19 Jun 2025 21:35:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2495</guid>
          <source url="https://rebol.metaeducation.com/t/transcode-should-be-empty-block-not-null/2495.rss">(TRANSCODE &quot;&quot;) should be empty BLOCK!, not NULL</source>
        </item>
        <item>
          <title>Should WORD! Allow Sigils at non-HEAD Positions?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Lexer</category>
          <description><![CDATA[
            <p>Rebol2, R3-Alpha, and Red have always let you put apostrophes in WORD! if they're not at the head.</p>
<ul>
<li>
<p>That gives you weird WORD!s like <strong><code>didn't</code></strong> and <strong><code>isn't</code></strong>.</p>
</li>
<li>
<p>It also lets us and words with apostrophes to indicate "prime" and "double-prime" derivitave things, like <strong><code>f'</code></strong> or <strong><code>f''</code></strong></p>
</li>
</ul>
<p>So Ren-C has allowed this as well.</p>
<p>But now, we're in the era of Sigils.  What reasoning would there be to allow [$ ^ @] in WORD!s at non-head positions?</p>
<p>Well... it would give slightly more compatibility with <a href="https://rebol.metaeducation.com/t/webassembly-text-format-wat/2223">WebAssembly Text Format</a>.  They have identifiers with $ in the name...</p>
<ul>
<li>
<p><a href="https://medium.com/ax1al/learning-and-trying-to-reverse-web-assembly-for-fun-da98fdf962e8">I saw <strong>$FUNCSIG$ii</strong> as a real example</a></p>
</li>
<li>
<p>Things like <strong><code>$$</code></strong> or <strong><code>$$a</code></strong> would still be illegal, though you could say <strong><code>$a$</code></strong> as a TIED! WORD! with spelling "a$"</p>
</li>
</ul>
<p>But given some recent applications of <a href="https://rebol.metaeducation.com/t/reacting-to-tie-to-automate-binding/2462/3">using $ to do bound PICKs</a>, I came to wonder if we could shorthand:</p>
<pre><code>b: 10

block: [a b c]

assert [10 = get pick:bind block 2]
</code></pre>
<p>A plain PICK could be shorthanded as <strong><code>second</code></strong>.  So you could say <strong><code>second:bind</code></strong>, since SECOND is a specialization of PICK.</p>
<p>But I thought that maybe <strong><code>second$</code></strong> could make an okay shorthand for <strong><code>second:bind</code></strong></p>
<pre><code>assert [10 = get second$ block]
</code></pre>
<p>And in turn, that made me think <strong><code>pick$</code></strong> would be a generically useful shorthand for <strong><code>pick:bind</code></strong></p>
<p>It's certainly more communicative than <strong><code>pick*</code></strong>.</p>
<p>Whether these shorthands go in the box or not, I don't really know what the benefit is to prohibiting them.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-word-allow-sigils-at-non-head-positions/2490">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-word-allow-sigils-at-non-head-positions/2490</link>
          <pubDate>Tue, 17 Jun 2025 02:15:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2490</guid>
          <source url="https://rebol.metaeducation.com/t/should-word-allow-sigils-at-non-head-positions/2490.rss">Should WORD! Allow Sigils at non-HEAD Positions?</source>
        </item>
        <item>
          <title>Last Chance to Question --{...}-- for Strings</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Lexer</category>
          <description><![CDATA[
            <p>It's getting quite close to the moment to cook up some new bootstrap executables and get the continuous integration back online.</p>
<p>The start of the derailment was the need to cease making <code>{...}</code> a string in the bootstrap sources, and support the new <code>-{...}-</code> or <code>--{...}--</code> etc. format.</p>
<p>I've remarked on how this has been a surprisingly pleasant change.  It not only has a "cut along dotted line" character, but it also means you can worry less about escaping your braces inside of these strings.  That's especially important for things like JavaScript natives whose bodies are strings of JavaScript code... but it helps with headers too.</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">Rebol [
    Title: "Your module title here"
    Type: module
    Name: your-module
    Rights: --{
        Copyright 2012 REBOL Technologies
        Copyright 2017-2024 Ren-C Open Source Contributors
    }--
    License: --{
        Licensed under the Apache License, Version 2.0
        See: http://www.apache.org/licenses/LICENSE-2.0
    }--
    Description: --{
        It almost feels like "cut along dotted line".
        I'm surprisingly liking it.

        Defaulting to this makes it easy to stick in mentions
        of the }- construct used in code, without having to go
        touch up your delimiters when you introduce it.
   }--
]
</code></pre>
<p>I definitely do prefer the asymmetric delimiters to trying to do this with double quotes.</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">Rebol [
    Title: "Your module title here"
    Type: module
    Name: your-module
    Rights: --"
        Copyright 2012 REBOL Technologies
        Copyright 2017-2024 Ren-C Open Source Contributors
    "--
    License: --"
        Licensed under the Apache License, Version 2.0
        See: http://www.apache.org/licenses/LICENSE-2.0
    "--
    Description: --"
        This doesn't work for me.

        I almost dislike it enough to disallow it, so I don't
        have to see code that does this. 
    "--
]
</code></pre>
<p>I think what I don't like about this is that it's like little darts pointing outward without really making a suggestion of grouping the inward things.  It lacks cohesion.</p>
<h2><a name="p-8189-but-nagging-question-why-and-not-1" class="anchor" href="https://rebol.metaeducation.com#p-8189-but-nagging-question-why-and-not-1"></a>BUT Nagging Question... Why --{...}-- and not --[...]-- ?</h2>
<p>It crossed my mind to propose the idea of <code>-(...)-</code> etc. being interpolated strings.</p>
<pre><code>&gt;&gt; num: 1000

&gt;&gt; print -(I'm an interpolated (num + 20), string)-
I'm an interpolated 1020, string.
</code></pre>
<p>It seemed interesting to me that the delimiters being "group-like" gave a hint that some evaluation would be going on.</p>
<p>But that gives rise to another thought... <strong>might --[...]-- being "block-like" give a hint of no evaluation?</strong></p>
<p>e.g. there's nothing FENCE!-like going on here.  The data is just inert.  What if we leveraged brackets as the inert string type?</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">Rebol [
    Title: "Your module title here"
    Type: module
    Name: your-module
    Rights: --[
        Copyright 2012 REBOL Technologies
        Copyright 2017-2024 Ren-C Open Source Contributors
    ]--
    License: --[
        Licensed under the Apache License, Version 2.0
        See: http://www.apache.org/licenses/LICENSE-2.0
    ]--
    Description: --[
        Here we have another conception.
        It's more angular, doesn't need shift to enter it.
        Doesn't it look a bit cleaner?

        And it's all still just as easy to stick in mentions of
        the ] or ]- construct used in code, without having to go
        touch up your delimiters when you introduce it.
   ]--
]
</code></pre>
<h1><a name="p-8189-o-2" class="anchor" href="https://rebol.metaeducation.com#p-8189-o-2"></a>--[o]--</h1>
<p>In today's climate, of course we can see this as being more contentious with blocks... since they're much more common than FENCE!s.  It may seem like a whole lot of brackets:</p>
<pre><code>[--[this "is" a string]-- 1020 -[this too, how "bad" is this?]-]
</code></pre>
<p>However, do consider that as usage of FENCE! grows, there'd be contention there too.  Also, syntax highlighting can help here for the not-completely-Amish cases.</p>
<h2><a name="p-8189-i-only-just-thought-this-but-it-seems-good-to-me-3" class="anchor" href="https://rebol.metaeducation.com#p-8189-i-only-just-thought-this-but-it-seems-good-to-me-3"></a>I Only Just Thought This, But It Seems Good To Me</h2>
<p>Note that my impressions and opinions are formed from having lived with <code>--{...}--</code> for a while.  Being a day-to-day user changed my views from initial reluctance to happy acceptance.</p>
<p>And this looks even better to my thusly trained eyes.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/eyes.png?v=14" title=":eyes:" class="emoji" alt=":eyes:" loading="lazy" width="20" height="20"></p>
<p>It does mean that things like JS-NATIVEs won't have things that look "as much like" their natural delimiters:</p>
<pre><code>quadrupler: js-native [num [integer!]] --[
    let num = reb.UnboxInteger("num * 2")
    return reb.Integer(num * 2)
]--
</code></pre>
<p>But really, were <strong><code>--{</code></strong> and <strong><code>}--</code></strong> pulling all that much weight here just because they had a brace?</p>
<pre><code>quadrupler: js-native [num [integer!]] --{
    let num = reb.UnboxInteger("num * 2")
    return reb.Integer(num * 2)
}--
</code></pre>
<p>I'm not seeing it.  The brackets feel cleaner, in part just because brackets are always cleaner.</p>
<p>And maybe this will help transition brackets over to braces for notations for construction-syntax types of things, to be more closely correlated with MAKE-ing things?</p>
<p>Anyone still paying attention have feedback here?</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/last-chance-to-question-for-strings/2430">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/last-chance-to-question-for-strings/2430</link>
          <pubDate>Tue, 29 Apr 2025 15:16:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2430</guid>
          <source url="https://rebol.metaeducation.com/t/last-chance-to-question-for-strings/2430.rss">Last Chance to Question --{...}-- for Strings</source>
        </item>
        <item>
          <title>About the Lexer category</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Lexer</category>
          <description><![CDATA[
            <p>This is for discussions about how to process UTF-8 text into Rebol elements.</p>
<p>Generally speaking, historical Rebol tended to break things up into separate parts more often:</p>
<pre><code>rebol2&gt;&gt; load "(a b)/c"
== [(a b) /c]
</code></pre>
<p>Modern ideas have many more ways of merging parts into single elements:</p>
<pre><code>&gt;&gt; transcode "(a b)/c"
== [(a b)/c]
</code></pre>
<p>There are a particularly large number of nuances about how TAG! is handled.  As the tip of the iceberg, <strong><code>&lt;&gt;</code></strong> is a WORD!, and not an empty tag.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/about-the-lexer-category/2426">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/about-the-lexer-category/2426</link>
          <pubDate>Mon, 28 Apr 2025 20:00:44 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2426</guid>
          <source url="https://rebol.metaeducation.com/t/about-the-lexer-category/2426.rss">About the Lexer category</source>
        </item>
        <item>
          <title>Canonical List Of Illegal-But-Interesting Tokens</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Lexer</category>
          <description><![CDATA[
            <p>When I first made SIGIL!, I was trying to make every element have an answer to the SIGIL OF question.  Note that plain types return null:</p>
<pre><code>&gt;&gt; sigil of first [@foo]
== @

&gt;&gt; sigil of first [foo]
== ~null~  ; anti
</code></pre>
<p>In pondering <a href="https://rebol.metaeducation.com/t/could-sigil-carry-a-binding/2376">whether SIGIL! should carry a binding</a>, I realized that two of the SIGIL! we had were just bad ideas.</p>
<pre><code>&gt;&gt; sigil of first [~foo~]
== ~~

&gt;&gt; sigil of first [''foo]
== '
</code></pre>
<p>These had always been dicey.  Clearly the quasiform sigil can't be just <strong><code>~</code></strong> as that's quasiform blank, so the "weird" compromise was to have it be two tildes, to reflect that usually (except in the case of quasiform blank) you have two tildes.</p>
<p>And then there's the dodginess of answering the number of quotes for the quote sigil:</p>
<pre><code>&gt;&gt; quotes of first [''foo]
== 2

&gt;&gt; quotes of first [']
== 1

&gt;&gt; quotes of first ['']
== 1
</code></pre>
<p><strong>So I decided to kill these.</strong>  Asking for SIGIL OF on a QUOTED! or QUASIFORM! will raise an error.  Since it's a raised error and not a failure, you can use TRY to get nullptr.</p>
<pre><code>&gt;&gt; sigil of first [''@foo]
** Error: Can't take SIGIL OF a quoted type

&gt;&gt; try sigil of first [''@foo]
== ~null~  ; anti

&gt;&gt; sigil of noquote first [''@foo]
== @
</code></pre>
<h2><a name="p-8056-no-legal-meaning-as-value-means-other-purposes-available-1" class="anchor" href="https://rebol.metaeducation.com#p-8056-no-legal-meaning-as-value-means-other-purposes-available-1"></a>No Legal Meaning As Value Means Other Purposes Available</h2>
<p>Since we know that <strong><code>'</code></strong> doesn't sanely represent a value, it could signal something to the scanner, or to the reader.</p>
<p>Maybe it could be useful for line continuations.</p>
<pre><code> reverse copy imagine-writing your-long-line-here append [a b c] 
     ' [d e f]
</code></pre>
<p>I've struggled with that question of how to know when a line is being continued.  And if we know that ' means nothing due not being able to quote nothing, it could be used for that.  And perhaps it would cue the scanner to not do a new-line</p>
<pre><code>&gt;&gt; load --{reverse copy imagine-writing your-long-line-here append [a b c] 
     ' [d e f]}--
== reverse copy imagine-writing your-long-line-here append [a b c] [d e f]
</code></pre>
<p>This would mean that if your code applied significance to newlines, you could work around it and get the behavior you want for things being all on one line, even if you don't write it that way.</p>
<p>The idea here would be that it would be specifically legal only on newlines, so you couldn't write:</p>
<pre><code>block: [' ' ']  ; would be an error
</code></pre>
<p>As for <strong><code>~~</code></strong>, it may be that it's a quasiform of a "length two" blank.  Allowing blanks to have a length is an old debate:</p>
<p><a href="https://rebol.metaeducation.com/t/should-literal-blank-be-one-or-two-underscores/222/14" class="inline-onebox">Should literal BLANK! be one, or two underscores? - #14 by hostilefork</a></p>
<h2><a name="p-8056-hence-i-think-keeping-a-list-is-good-2" class="anchor" href="https://rebol.metaeducation.com#p-8056-hence-i-think-keeping-a-list-is-good-2"></a>Hence I Think Keeping A List Is Good</h2>
<p>A list of things that have no meaning is a good resource for when you want to do something out of band.</p>
<p>Another thing I'll throw out as having no meaning is backslash.  But I also think that it's important to leave some room for not definiing things, so that preprocessing tasks or other trickery have some choices to put their own escapes into the code.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/canonical-list-of-illegal-but-interesting-tokens/2378">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/canonical-list-of-illegal-but-interesting-tokens/2378</link>
          <pubDate>Sat, 22 Mar 2025 15:15:44 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2378</guid>
          <source url="https://rebol.metaeducation.com/t/canonical-list-of-illegal-but-interesting-tokens/2378.rss">Canonical List Of Illegal-But-Interesting Tokens</source>
        </item>
        <item>
          <title>Should Strings Nest Levels To Avoid Escaping?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Lexer</category>
          <description><![CDATA[
            <p>There's a historically convenient feature in strings:</p>
<pre><code>str: {This was {a historically legal} string.}
</code></pre>
<p>Each time you used an open brace inside a string, it would increment a "nesting count".  And when you used a close brace it would drop the nesting count.  When you got to zero, your string was finished.</p>
<p>It works in a lot of cases, but not if you have unpaired braces in your content:</p>
<pre><code>c-code: { if char = '}' { printf("This won't work.\n"); } }
</code></pre>
<p>We're going to be getting some instant improvement here with the new string format, using dashes.  Since at least one dash is required (otherwise you'd get a fence), cases like the above will "just work":</p>
<pre><code>c-code: -{ if char = '}' { printf("This will work!\n"); } }-
</code></pre>
<p>But should we still support the nesting idea?</p>
<pre><code>str: -{Should this -{still be a legal}- string?}-
</code></pre>
<p>The alternative would be to force you to use more dashes:</p>
<pre><code>str: --{This -{is definitely a legal}- string.}--
</code></pre>
<p>As we can see from the above, that move from one dash to two dashes does lengthen things.  The tightness is appealing to have as an option.</p>
<h2><a name="p-7836-but-its-complicated-1" class="anchor" href="https://rebol.metaeducation.com#p-7836-but-its-complicated-1"></a>But It's Complicated...</h2>
<p>Let's put aside equal counts for a moment.  What happens if you nest <em>higher</em> counts (which contain lower counts, by definition)</p>
<pre><code>str: -{What ---{do you think this}--- should do?}-  ; [1]
</code></pre>
<p>If it were rotely searching for <strong><code>}-</code></strong> then it would find it at <strong><code>this}-</code></strong> and consider that the end.</p>
<pre><code>str: -{To look at ---{another one, consider}- this...}-  ; [2]
</code></pre>
<p><strong>Do we want the rule that if you ever enclose code with the dashed brace style like <strong><code>--{</code></strong> and <strong><code>}--</code></strong> the enclosure will always need more dashes than what it encloses?</strong></p>
<p>When I put it that way, I think that we don't want to force that escalation.  You can always go there if you need to (case 2 above requires it, or using quotes on the outside instead).  But I think being able to dodge it in cases where things are paired (as in case 1) is worth the dodge.</p>
<p><em>(Note that if you are trying to analyze the inside of the string for matched pairs that are other than the ones you asked for from the outside delimiter, then suddenly you're maintaining a stack of quote levels where nest level has an independent associated number of dashes, instead of just maintaining a total nesting count.  Not that this is a difficult problem, but it's just "another thing".)</em></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-strings-nest-levels-to-avoid-escaping/2311">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-strings-nest-levels-to-avoid-escaping/2311</link>
          <pubDate>Thu, 10 Oct 2024 06:44:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2311</guid>
          <source url="https://rebol.metaeducation.com/t/should-strings-nest-levels-to-avoid-escaping/2311.rss">Should Strings Nest Levels To Avoid Escaping?</source>
        </item>
        <item>
          <title>Should sequences permit non-head SIGILs?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Lexer</category>
          <description><![CDATA[
            <p>Historically I was very much opposed to SET-WORD! and GET-WORD! being in paths, because the ergonomics were bad:</p>
<pre><code>red&gt;&gt; p: to path! reduce [first [:a] first [b:]]
== :a/b:

&gt;&gt; type? p
== path!
</code></pre>
<p>You have something that's neither a SET-PATH! nor a GET-PATH! but it has colons at the beginning and the end.  It's all kinds of confusing.</p>
<p>Ren-C has addressed that particular can of worms with a <a href="https://rebol.metaeducation.com/t/introducingnew-chain-datatype/2226">full design for the CHAIN! sequence type</a>, and rules for its nesting in PATH! (and how TUPLE! nests in it).  So you can get these weird looking structures, but they destructure unambiguously.</p>
<h2><a name="p-7831-as-for-sigils-at-the-head-they-must-be-illegal-1" class="anchor" href="https://rebol.metaeducation.com#p-7831-as-for-sigils-at-the-head-they-must-be-illegal-1"></a>As For Sigils... At The Head They Must Be Illegal</h2>
<p>You can't put a sigil in a sequence head position, because that would be ambiguous with wanting to apply the sigil to the path as a whole.</p>
<pre><code>&gt;&gt; to path! [$foo bar]
** Error: This needs to be an error
</code></pre>
<p>The only way to allow it would be if we invented <a href="https://rebol.metaeducation.com/t/what-is-a-path-or-a-quasi-word/2292/2">some kind of lexical escaping</a> so we could tell the difference between $|foo/bar| and $|foo|/bar ... <em><strong>and I do not want lexical escaping of this kind</strong></em>.</p>
<h2><a name="p-7831-but-sigils-at-non-head-positions-maybe-roll_eyes-2" class="anchor" href="https://rebol.metaeducation.com#p-7831-but-sigils-at-non-head-positions-maybe-roll_eyes-2"></a>But Sigils At Non-Head Positions... Maybe?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/roll_eyes.png?v=14" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></h2>
<p>There's no fundamental reason why sigils couldn't be on non-head positions in sequences.  It works.</p>
<pre><code>&gt;&gt; $a:$b
== a:$b  ; bound
</code></pre>
<p>Part of me says <em>"ugh, no, it makes everything uglier, don't let people make these ugly things!"</em></p>
<p>But one very compelling reason just for the above syntax is what I've called "dialecting function calls", such as for pointing the blame to a callsite with a FAIL.</p>
<p>So instead of:</p>
<pre><code>my-api: func [x y z] [
    if true [
        if y &lt; 100 [
            fail:blame ["Value must be &gt;= 100, not" y] $y
        ]
     ]
 ]
</code></pre>
<p>You could write:</p>
<pre><code>my-api: func [x y z] [
    if true [
        if y &lt; 100 [
            fail:$y ["Value must be &gt;= 100, not" y]
        ]
     ]
 ]
</code></pre>
<p>When you look at it like that, it's hardly a monstrosity.  It's letting you push the variable to blame into the chain for invoking the function, in a way that's out-of-band with other refinements.</p>
<p>It could offer a cheaper way of asking to fetch variables, using @ to take the place of the old "get word" concept:</p>
<pre><code>&gt;&gt; block: [index offset pointer]
&gt;&gt; index: 3

&gt;&gt; block.index
== offset

&gt;&gt; block.(index)
== pointer

&gt;&gt; block.@index
== pointer
</code></pre>
<p>It's measurably less expensive (no array allocation, cheaper to naviate to on fetch).  It doesn't use a GROUP! so it doesn't get in the way of COMPOSE-ing.</p>
<h2><a name="p-7831-think-i-have-to-allow-it-3" class="anchor" href="https://rebol.metaeducation.com#p-7831-think-i-have-to-allow-it-3"></a>Think I Have To Allow It...</h2>
<p>I'd originally thought that it would be cleaner to disallow it.  But seems to me there are too many interesting uses.</p>
<p>As a medium, Rebol is very free, and you have a lot of power to make hideous things.  So it's about using your judgment, and I think people should know when it's getting too crazy.</p>
<hr>
<h2><a name="p-7831-i-almost-hate-to-point-it-out-but-4" class="anchor" href="https://rebol.metaeducation.com#p-7831-i-almost-hate-to-point-it-out-but-4"></a>I Almost Hate To Point It Out, But...</h2>
<p>This is true of quotes as well.</p>
<pre><code>&gt;&gt; 'a:''b:'''c
== a:''b:'''c
</code></pre>
<p>There's an unambiguous way of interpreting that.</p>
<pre><code>&gt;&gt; quote to chain! [a ''b '''c]
== 'a:''b:'''c
</code></pre>
<p>I don't love it, but, maybe there's cases where <strong><code>foo:'bar</code></strong> would be useful in a dialect, and if it's mechanically consistent I shouldn't prohibit it.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/man_shrugging.png?v=14" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20">  I don't know.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-sequences-permit-non-head-sigils/2309">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-sequences-permit-non-head-sigils/2309</link>
          <pubDate>Mon, 07 Oct 2024 19:06:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2309</guid>
          <source url="https://rebol.metaeducation.com/t/should-sequences-permit-non-head-sigils/2309.rss">Should sequences permit non-head SIGILs?</source>
        </item>
        <item>
          <title>What is ~/~ : A PATH! or a QUASI-WORD?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Lexer</category>
          <description><![CDATA[
            <p>I've mentioned that there are not going to be quasiform or antiform sequence types.</p>
<ul>
<li>
<p>We want tildes in paths <strong><code>~/home/whatever.txt</code></strong></p>
<ul>
<li>
<p>Paths in particular...but they could be useful in tuples (<strong><code>~.foo</code></strong>) or chains (<strong><code>[a]:~</code></strong>)</p>
</li>
<li>
<p>Quasiforms might be nice  for some purposes too (<strong><code>~null~/a/b/c), (foo:~[a]~</code></strong>)</p>
</li>
</ul>
</li>
<li>
<p>The known very important usage of tilde in paths, plus all the as-yet-unknown and untapped other uses, far outweigh any advantage I can think of for antiform/quasiform sequences.</p>
</li>
</ul>
<p>So that's settled.  But there's a bit of an edge case with the WORD!s like <strong><code>/</code></strong> or <strong>.</strong> or <strong>:</strong></p>
<p>And there, I'm going to have to say that <strong><code>~/~</code></strong> is a quasiword.</p>
<ul>
<li>
<p>I want all words to have quasiforms (though not antiforms... only system-blessed "keywords" will be allowed to become antiforms).  And so I don't want to exempt any words from that.</p>
</li>
<li>
<p>I don't think excluding <strong><code>~/~</code></strong> as a path form has any tremendous consequences</p>
</li>
<li>
<p>Allowing it to be a quasiword fits in with <strong><code>~///~</code></strong> and other such words being quasiwords, and those aren't valid paths.</p>
</li>
</ul>
<p>So we open up a wider field of parts, keep all words having quasiforms, and lose one weird path representation.</p>
<p>Though it's not "lost"--if you're writing dialect code that has some logic for what a PATH! of two <a href="https://rebol.metaeducation.com/t/what-to-call-lone-tilde/2216">"Quasars"</a> would mean, you can specially recognize that quasi-WORD!.  You'll only run into representational trouble if in that same dialect you need a meaning for every possible quasi-word, and the meaning of <code>~/~</code> as a quasi-word deviates from what the two-quasar-path interpretation would be.</p>
<p>(I'd say I'd bet money that's never going to happen...except I've seen exactly weird things like that happen often enough to know better.  So instead I'll say "it might happen someday, but I don't care.")</p>
<p>Anyway, trying to shore this up a bit, some sample errors:</p>
<pre><code>&gt;&gt; to path! [~ a]
== ~/a

&gt;&gt; to path! [~ ~]
** Script Error: Sequence would conflate with WORD! form: ~/~

&gt;&gt; to path! [a _]
== a/

&gt;&gt; to path! [_ _]
** Script Error: Sequence would conflate with WORD! form: /

&gt;&gt; to path! [_ a _]
== /a/

&gt;&gt; to path! [a _ b]
** Script Error: BLANK! only legal at head and tail of sequence
</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/what-is-a-path-or-a-quasi-word/2292">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/what-is-a-path-or-a-quasi-word/2292</link>
          <pubDate>Sun, 22 Sep 2024 13:15:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2292</guid>
          <source url="https://rebol.metaeducation.com/t/what-is-a-path-or-a-quasi-word/2292.rss">What is ~/~ : A PATH! or a QUASI-WORD?</source>
        </item>
        <item>
          <title>Backtick Literals (and an Axis of Extensibility?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Lexer</category>
          <description><![CDATA[
            <p>I've been historically frustrated by the overlap between what I think make nicely regular language features (like TUPLE!, PATH!, and CHAIN!) running up against edges with literal representations.</p>
<ul>
<li>
<p><strong><code>version/1.2</code></strong> would be nice if that could be interpreted as a tuple, but people want to write their decimal representations as <strong><code>1.02</code></strong> etc.</p>
</li>
<li>
<p><strong><code>1:10</code></strong> would be nice as a CHAIN! to represent a range, but people want to write TIME! representations as <strong><code>10:20</code></strong> etc.</p>
</li>
<li>
<p><strong><code>31-Aug-2024/0:36:30-4:00</code></strong> is a DATE!, but sure looks like a PATH!</p>
</li>
</ul>
<p>Ad nauseum.</p>
<p>Because I think <strong><code>version/1.2</code></strong> has been genenerally the kind of thing that's more important to the domains Rebol is actually good for than math, I've been willing to throw things like DECIMAL! under the bus.  So over time I've suggested random things like <em>"<strong><code>&amp;1.02</code></strong> to represent DECIMAL!"</em>.  But not only have such ideas been loudly protested, the sigils have become pretty saturated to where everything has a meaning already.</p>
<p>But we do have one little crevice in notational space that isn't too hideous.</p>
<h2><a name="p-7485-enclosing-in-backticks-1" class="anchor" href="https://rebol.metaeducation.com#p-7485-enclosing-in-backticks-1"></a>Enclosing In `Backticks`</h2>
<pre><code>adjusted-value: value / `1.02`

set alarm for `10:20`

[&lt;backdate-post&gt; `31-Aug-2024/0:36:30-4:00`]

set $(coefficient-name) `6.22e23`

[1020 : -304]  ; INTEGER! would of course be exempt.
</code></pre>
<p>The backticks are about as unobtrusive as this can get.</p>
<p>Having them on the start and end doesn't just make it look more balanced and symmetrical--it also lets the literal interpretation be sandboxed from the rest of the scanning.</p>
<h2><a name="p-7485-this-would-not-bother-me-2" class="anchor" href="https://rebol.metaeducation.com#p-7485-this-would-not-bother-me-2"></a>This Would Not Bother Me</h2>
<p>Quite the contrary, I would be <em>thrilled</em> to see the regularity this would bring to the scanner.</p>
<p>It puts all the quirky exceptions in one place where they can fight amongst themselves, while the real work can proceed.</p>
<h2><a name="p-7485-a-place-for-parameterized-transcode-3" class="anchor" href="https://rebol.metaeducation.com#p-7485-a-place-for-parameterized-transcode-3"></a>A Place For Parameterized TRANSCODE?</h2>
<p>When you call TRANSCODE it could offer you the ability to specify that file's interpretation of backtick'd portions.  This would give you a way to customize things, throwing in your own pecking order for the literals...then using TO INTEGER! and TO DATE! etc as you wish (or after you've picked over it, call some kind of generic TO-VALUE that goes through the default list).</p>
<p>Maybe.  I don't know.  It's a thought, that constraining these irregularities inside of a box could let that irregular space be what it wanted, while the rest of the scanner would be nailed down.</p>
<p>We could even say there's a mode you can load things in which it doesn't interpret the literals at all.  They'd just be LITERAL!.</p>
<pre><code>&gt;&gt; code: transcode/illiterate -{foo: `whatever*you*say`}-
== [foo: `whatever*you*say`]

&gt;&gt; type of second code
== &amp;[literal]

&gt;&gt; as text! second code
== "whatever*you*say"
</code></pre>
<h2><a name="p-7485-doesnt-necessarily-stop-use-of-unbackticked-forms-4" class="anchor" href="https://rebol.metaeducation.com#p-7485-doesnt-necessarily-stop-use-of-unbackticked-forms-4"></a>Doesn't (Necessarily) Stop Use Of Unbackticked Forms</h2>
<p>You wouldn't be able to write plain <strong><code>1.02</code></strong> and get a TUPLE! that you could translate into a DECIMAL! (error, as an integer in the second slot would be loss of information).</p>
<p>But you could get away with some things.  More with something like the <strong><a href="https://rebol.metaeducation.com/t/no-interstitial-delimiter-sequence-proposal-scrunch/1503">FUSED! Proposal</a></strong></p>
<p>If your notation is LOAD-able, and you're in a dialect context, you could transform what you got.</p>
<p>If people decide it's worth it to them to do transforms on <strong>1.2em</strong> to make it <strong>`1.2`em</strong> that's their dialect's business.  But we need to make leading-0s illegal in tuples, so you don't unwittingly lose information.</p>
<aside class="quote quote-modified" data-post="1" data-topic="1755">
  <div class="title">
    <div class="quote-controls"></div>
    <img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar">
    <a href="https://rebol.metaeducation.com/t/tuple-troubles-version-0-3-01-vs-0-3-1/1755">Tuple Troubles: Version 0.3.01 vs 0.3.1</a> <a class="badge-category__wrapper " href="https://rebol.metaeducation.com/c/development/datatypes/45"><span data-category-id="45" style="--category-badge-color: #25AAE2; --category-badge-text-color: #FFFFFF; --parent-category-badge-color: #25AAE2;" data-parent-category-id="8" data-drop-close="true" class="badge-category --has-parent" title="The datatypes category is for the discussion of the specific properties of datatypes themselves.  Sample topics might include:"><span class="badge-category__name">Datatypes</span></span></a>
  </div>
  <blockquote>
    For better or worse, versioning in Rebol has used TUPLE!.  e.g. 0.3.1 is 32-bit Windows, and 0.3.40 is 64-bit Windows 
If you go back and look at the old R3-Alpha file <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/tools/systems.r#L21">%systems.r</a> you can see that it's pretty typical for Carl to have written the versions out with leading zeros...but only in the third slot.  So 0.3.01 but not 00.03.01 
But ultimately the tuple discards this information.  And this has been the way it always worked: 
rebol2&gt;&gt; 0.3.01
== 0.3.1

red&gt;&gt; 0.3.01
== 0.3.1

ren-c&gt;&gt; 0.3.01
==…
  </blockquote>
</aside>

            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/backtick-literals-and-an-axis-of-extensibility/2235">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/backtick-literals-and-an-axis-of-extensibility/2235</link>
          <pubDate>Sat, 31 Aug 2024 04:54:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2235</guid>
          <source url="https://rebol.metaeducation.com/t/backtick-literals-and-an-axis-of-extensibility/2235.rss">Backtick Literals (and an Axis of Extensibility?)</source>
        </item>
        <item>
          <title>Alternate String Forms if {...} Becomes An Array Type</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Lexer</category>
          <description><![CDATA[
            <blockquote>
<p>I've brought up in earnest something I call <strong><a href="https://rebol.metaeducation.com/t/rethinking-braces-as-an-array-type/1727">"The FENCE! Proposal"</a></strong>.  It involves retaking <strong>{...}</strong> for an <em>object-like-purpose</em>.</p>
<p>The twist is that it's really another ANY-ARRAY! type, peer to [...] and (...) - but geared toward being a <a href="https://rebol.metaeducation.com/t/make-should-be-using-dialected-constructors/2196">shorthand for dialected MAKE</a> (defaulting toward representing key/value stores).  Then as with [...] and (...), dialects would be free to override {...} in their own way.</p>
<p>A sad consequence of this would be the loss of the alternative string form {...}.  Discussions of what to use instead were lengthier than the discussion of the proposal itself, so I've moved them onto their own thread here...starting with my initial musing...</p>
</blockquote>
<h2><a name="p-5578-what-other-asymmetric-string-technique-might-be-used-1" class="anchor" href="https://rebol.metaeducation.com#p-5578-what-other-asymmetric-string-technique-might-be-used-1"></a>What Other Asymmetric String Technique Might Be Used?</h2>
<p>Some languages have weird techniques, like even letting you make up your own delimiters by whatever you use in front of the quote:</p>
<pre><code>str: ?"This says "quote followed by question mark" terminates"?
str: |"This says "quote followed by bar" terminates"|
str: xyz"This says "quote followed by zyx" terminates"zyx 
</code></pre>
<p>(Not making that up.)</p>
<p>The risk of using a symbol like | is that even if it looks good in isolation, you might not like it in a parse rule, like <strong>rule1 | |"some string"| | rule2</strong>.  A less-used character might be better.</p>
<p>Or perhaps those who really feel the need for another asymmetric string delimiter should assign a couple keys in their editor to unicode:</p>
<pre><code>str: «Maybe People «who really care» could use "Chevrons"?»
</code></pre>
<p>Who knows.  <strong><a href="https://en.wikipedia.org/wiki/Here_document">One place to look is the topic of "HEREDOC"</a></strong></p>
<p>Another place to look is the <strong><a href="https://stackoverflow.com/questions/13535172/list-of-all-unicodes-open-close-brackets">List of open/close paired braces/brackets/quotes in Unicode</a></strong></p>
            <p><small>29 posts - 5 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/alternate-string-forms-if-becomes-an-array-type/1743">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/alternate-string-forms-if-becomes-an-array-type/1743</link>
          <pubDate>Mon, 18 Oct 2021 01:06:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1743</guid>
          <source url="https://rebol.metaeducation.com/t/alternate-string-forms-if-becomes-an-array-type/1743.rss">Alternate String Forms if {...} Becomes An Array Type</source>
        </item>
        <item>
          <title>Lexical Conflicts Back To Bite Us: Dots In Tags</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Lexer</category>
          <description><![CDATA[
            <p>So I've been torn by the question of dots in tags, ever since the loss of <strong><code>&lt;...&gt;</code></strong> to mean variadics.</p>
<p>But that was how the scanner rules clanked together.  And since <strong>&lt;</strong> is a WORD!, if we assign that to an OBJECT! how do we get fields out of it?</p>
<pre><code>&gt;&gt; &lt;: make object! [x: 10]

&gt;&gt; &lt;.x
== 10
</code></pre>
<h2><a name="p-5467-but-something-has-to-give-1" class="anchor" href="https://rebol.metaeducation.com#p-5467-but-something-has-to-give-1"></a>But Something Has To Give</h2>
<p>I've been convinced.  Dots in tags have to win.</p>
<p>It's too useful to be able to say <strong><code>&lt;../foo.r&gt;</code></strong> as a file path.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>The state of the system is different now: PATH!s and TUPLE!s are immutable, so they can be checked for disallowed patterns.  We can set a bit on the special-cased words that contain <strong>&lt;</strong> or <strong>&gt;</strong> and then quickly check at path creation time that they contain none of these "arrow words".</p>
<p>This means any &lt; or &gt; that you see in a path or tuple are guaranteed to be part of a TAG!.</p>
<p>You can still make some confusing-looking things:</p>
<pre><code>..&lt;..&gt;..
</code></pre>
<p>But with the rule of "no &lt; or &gt; words inside a path or tuple", you can confidently read that as a 5-element TUPLE with a TAG! in the middle of it.</p>
<pre><code>&gt;&gt; as block! ..&lt;..&gt;..
[_ _ &lt;..&gt; _ _]
</code></pre>
<h2><a name="p-5467-how-will-you-pick-fields-out-of-objects-in-arrow-words-2" class="anchor" href="https://rebol.metaeducation.com#p-5467-how-will-you-pick-fields-out-of-objects-in-arrow-words-2"></a>How Will You Pick Fields Out of Objects In Arrow Words?</h2>
<p>For purely evaluative purposes, you could just use a GROUP!:</p>
<pre><code>('&lt;).field
</code></pre>
<p>We <em>could</em> try and make some kind of escaping syntax so the literal value could actually be represented in the path.  This would help generic code that took an ANY-WORD! and wanted to make a PATH! out of it:</p>
<pre><code>#[word! "&lt;"].field
</code></pre>
<p>But if we prohibited it, I'm not sure how bad that would be.  It could be a <a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it">"yagni"</a> situation.  :-/</p>
<p>For now, I'm just going to hack on the scanner and path mechanics a bit and get us the tags.  This will please those who would like the idea of <strong><code>&lt;/&gt;</code></strong> and <strong><code>&lt;//&gt;</code></strong> and <strong><code>&lt;.&gt;</code></strong> and <strong><code>&lt;..&gt;</code></strong> being a TAG!</p>
<p>I don't know whether this concession is going to wind up turning into backing off <strong>&lt;:</strong> and <strong>&gt;:</strong> or not.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<pre><code>('&lt;): does [print "Is this good enough, now?"]
</code></pre>
<p>It would open up <strong><code>&lt;:&gt;</code></strong> and <strong><code>&lt;::&gt;</code></strong> and <strong><code>&lt;:/some/thing&gt;</code></strong> and a lot more tags of that nature, for what may seem like a pretty negligible loss.</p>
<h2><a name="p-5467-has-the-history-of-this-topic-been-churn-with-no-benefit-3" class="anchor" href="https://rebol.metaeducation.com#p-5467-has-the-history-of-this-topic-been-churn-with-no-benefit-3"></a>Has The History of This Topic Been Churn With No Benefit?</h2>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/no_entry.png?v=14" title=":no_entry:" class="emoji" alt=":no_entry:" loading="lazy" width="20" height="20">  <strong>NO</strong>.</p>
<p>Because when you look systemically at all the parts, generic TUPLE! and generic PATH! are showing great promise.  I think this world in which things like <strong>/foo</strong> are PATH! and <strong>a.(b).10</strong> is a TUPLE! are really the right way to go.</p>
<p>For that matter, I don't actually think it's so crazy to put on the lenses where <strong><code>&lt;../foo.r&gt;</code></strong> is a PATH! containing two tuples.</p>
<p>Consider another very similar looking example of <strong><code>+../foo.r+</code></strong>.  That's:</p>
<pre><code> as path! reduce [
     as tuple! [+ _ _]
     as tuple! [foo r+]
 ]
</code></pre>
<p>I actually think that line of thinking has a lot of interesting dialecting possibilities.  The thing that makes the example with &lt; and &gt; in it trip up is that it treads on the usefulness of tags...and you wind up where <strong>r&gt;</strong> isn't even a valid tuple component.  More is being sacrificed and less is being gained.</p>
<p>All in all, it's progress.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/lexical-conflicts-back-to-bite-us-dots-in-tags/1702">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/lexical-conflicts-back-to-bite-us-dots-in-tags/1702</link>
          <pubDate>Fri, 03 Sep 2021 11:45:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1702</guid>
          <source url="https://rebol.metaeducation.com/t/lexical-conflicts-back-to-bite-us-dots-in-tags/1702.rss">Lexical Conflicts Back To Bite Us: Dots In Tags</source>
        </item>
        <item>
          <title>The Separation of TAG! from &quot;Arrow-WORD!&quot;s</title>
          <dc:creator><![CDATA[Mark-hi]]></dc:creator>
          <category>Lexer</category>
          <description><![CDATA[
            <aside class="quote no-group quote-post-not-found" data-username="hostilefork" data-post="1" data-topic="1337">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"></div>
<blockquote>
<p>The fate of things like <strong>abc&gt;def</strong> or <strong>abc&lt;def</strong> (which <a class="mention" href="https://rebol.metaeducation.com/u/mark-hi">@Mark-hi</a> has advocated for in the past) is unknown, so that might be a last thinking point.</p>
</blockquote>
</aside>
<p>No, I didn't. Ever. I advocated for something called "arrow-words", which do not and can not and never should have letters.</p>
<p>Please reread <a href="https://github.com/Mark-hi/Rebol-Lexer/blob/master/lexer.reb">lexer.reb (GitHub)</a>, noting in particular:</p>
<ul>
<li><a href="https://github.com/Mark-hi/Rebol-Lexer/blob/2f368977e7d5e30938d3b418ebb8579996a627a9/lexer.reb#L67">Rule 3 of lexeme separation</a></li>
<li>The <a href="https://github.com/Mark-hi/Rebol-Lexer/blob/2f368977e7d5e30938d3b418ebb8579996a627a9/lexer.reb#L116-L124">words charsets section</a></li>
<li>The <a href="https://github.com/Mark-hi/Rebol-Lexer/blob/2f368977e7d5e30938d3b418ebb8579996a627a9/lexer.reb#L291-L293">word parsing rules</a></li>
</ul>
            <p><small>7 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/the-separation-of-tag-from-arrow-word-s/2154">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/the-separation-of-tag-from-arrow-word-s/2154</link>
          <pubDate>Tue, 22 Sep 2020 16:06:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2154</guid>
          <source url="https://rebol.metaeducation.com/t/the-separation-of-tag-from-arrow-word-s/2154.rss">The Separation of TAG! from &quot;Arrow-WORD!&quot;s</source>
        </item>
        <item>
          <title>Another long-tail stand: No backslashes in FILE!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Lexer</category>
          <description><![CDATA[
            <p>There is behavior in Rebol2 and R3-Alpha where the scanner just automatically flips backslashes into forward slashes in FILE!</p>
<pre><code>rebol2&gt;&gt; %C\Projects
== %C/Projects
</code></pre>
<p>That's the kind of random fiddling that I call "the worst answer".  Red preserves the backslashes as-is, which is at least a slight improvement:</p>
<pre><code>red&gt;&gt; %C\Projects
== %C\Projects
</code></pre>
<p>But one theoretical benefit of being able to paste your file paths "as-is" is missing, because colons aren't legal:</p>
<pre><code>red&gt;&gt; %C:\Projects
*** Syntax Error: (line 1) invalid word at :\Projects
</code></pre>
<h2><a name="p-4005-could-restricting-file-be-a-selling-point-1" class="anchor" href="https://rebol.metaeducation.com#p-4005-could-restricting-file-be-a-selling-point-1"></a>Could Restricting FILE! Be A Selling Point?</h2>
<p>For whatever it's worth, UNIX does allow you to have backslashes in filenames.  (They typically have to be escaped (as <code>\\</code>) in shell commands.)</p>
<p>But mechanically speaking, FILE! does not need to be able to contain all characters...because TEXT! is the currency used for naming <em>local</em> files.  Red follows this convention:</p>
<pre><code>red&gt;&gt; to-local-file %a/b/c
== "a\b\c"  ; on Windows
</code></pre>
<p>But it does this regardless of if you give it a FILE! or a TEXT! as input:</p>
<pre><code>red&gt;&gt; to-local-file "a/b/c"
== "a\b\c"
</code></pre>
<p>Ren-C doesn't do this, and instead says that TO-LOCAL-FILE only works on FILE!...(unless you use the /PASS refinement, in which case TEXT! is allowed to pass through unmodified):</p>
<pre><code>ren-c&gt;&gt; to-local-file "a/b/c"
** Error: Filename already in local format (as a TEXT!), use /PASS to allow

ren-c&gt;&gt; to-local-file/pass "a/b/c"  ; pass-thru
== "a/b/c"
</code></pre>
<p>I think this suggests a means for sanity checking to prevail.  FILE! can be a tool for righteousness.</p>
<h2><a name="p-4005-what-to-do-if-you-have-a-weird-filename-2" class="anchor" href="https://rebol.metaeducation.com#p-4005-what-to-do-if-you-have-a-weird-filename-2"></a>What to do if you have a weird filename</h2>
<p>If you're making some kind of dialect with filenames in it, and you want to give people the ability to copy/paste literally things like <code>"C:\Projects\red\README.md"</code>, you use TEXT!.</p>
<pre><code>file-list: [
    %ren-c/README.md
    "C:\Projects\ren-c\LICENSE"
]
</code></pre>
<p>Maybe you have to decorate the TEXT! with something like <code>&lt;file&gt;</code>, if you have other baseline uses for strings in the dialect.</p>
<p>Then when you're writing your code and find you have a filename in a TEXT! you have these options:</p>
<ul>
<li>
<p><strong>With "sane" filenames, just use LOCAL-TO-FILE to get a FILE! out of it.</strong>  If you have something in your hand that's either a FILE! or a TEXT!, then use LOCAL-TO-FILE/PASS.  This should work for "sane" filenames and handle most cases.</p>
</li>
<li>
<p><strong>With "insane" filenames, your first instinct should be to just FIX them</strong> So let's say you have something like this on UNIX:</p>
<pre><code>file-list: [
    %/usr/local/bin/gcc
     "/home/crazy\file"
]
</code></pre>
<p>Just drop out to your OS shell and rename it with whatever tools you've got, <strong><code>mv crazy\\file sane-file</code></strong>.  Or automate it with CALL out to the shell, if you like.  We did you a solid by making LOCAL-TO-FILE refuse to call that a FILE!, and the world is a safer place.</p>
</li>
<li>
<p><strong>If you insist on keeping the file with its name and still operating in it, then manually use mechanisms that let you specify PORT! with TEXT!</strong>.  I don't know what the exact syntax of this is, but it would be in the spirit of:</p>
<pre><code>p: make port! compose [type: 'file name: (crazy-filename-as-text)]
data: read p
close p 
</code></pre>
<p>So that takes the place of the failing call to <strong>read file-to-local/pass crazy-filename-as-text</strong> which refused to make the FILE!.</p>
</li>
</ul>
<h2><a name="p-4005-i-think-these-bold-moves-are-the-point-3" class="anchor" href="https://rebol.metaeducation.com#p-4005-i-think-these-bold-moves-are-the-point-3"></a>I Think These Bold Moves are The Point</h2>
<p>Software has gotten so bad that we never know what's going on.  Some people just pile on layer after layer of filter...like the people who use ad blockers, and pass on URLs of crappy sites to others not knowing what version of it they're going to see.</p>
<p>Experienced programmers (or at least old ones who remember The Times Before) have a sense of when things have gone beyond control.  I think the long tail of development is that people shake down systems to try and get sanity out of them with guidelines that become common-sense ("don't put backslashes in filenames").</p>
<p>Here we have an opportunity with a data type that doesn't exist in nature, the FILE!.  We can make it discern from raw TEXT!.  And we can ask you to keep unprincipled things as TEXT!...letting those people with edge cases pay for it, and letting everyone else breathe easier.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/another-long-tail-stand-no-backslashes-in-file/1336">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/another-long-tail-stand-no-backslashes-in-file/1336</link>
          <pubDate>Tue, 22 Sep 2020 00:33:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1336</guid>
          <source url="https://rebol.metaeducation.com/t/another-long-tail-stand-no-backslashes-in-file/1336.rss">Another long-tail stand: No backslashes in FILE!</source>
        </item>
        <item>
          <title>Should Hexadecimal Be Lowercase?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Lexer</category>
          <description><![CDATA[
            <p>I had to reverse-engineer the changes in Visual Studio's XML project files from VS2017 to VS2019.  I did this by having it run the upgrade process on importing the old project, and then looking at the diffs.</p>
<p>One unusual change is that Rebol used lowercase letters for the hex digits in UUIDs...and for some reason VS2019 decided that when it wrote them out it would make them uppercase.  This made me wonder if there was any kind of standard.  I found a StackOverflow answer saying that <a href="https://stackoverflow.com/a/13833488/211160">there is at least one international standard suggesting the canonized output form should be lowercase</a>.  And Microsoft is one of the riff-raff who tend to break it.</p>
<p>But it further suggests that for human readability, lowercase scans better for hexadecimal pretty much anywhere:</p>
<blockquote>
<p>"6.5.4 Software generating the hexadecimal representation of a UUID  <strong>shall not use upper case</strong>  letters. NOTE – It is recommended that the hexadecimal representation used in all human-readable formats be restricted to lower-case letters. Software processing this representation is, however, required to accept both upper and lower case letters as specified in 6.5.2."</p>
</blockquote>
<p>History clearly has a bearing on the favoring of uppercase for hexadecimal--considering that early programming languages only supported uppercase.  Yet modern thinking for hex numbers like git commit IDs are pretty much always written out as lowercase.  It really seems out there in the idea-o-sphere there is a concept that lowercase hexadecimal is easier to scan and read.  <a href="https://stackoverflow.com/questions/32695983/is-there-a-reason-to-use-uppercase-letters-for-hexadecimal-css-color-values">People argue this in CSS for colors also.</a></p>
<p>One of the big sticking points in trying to scan hex optically with uppercase is that <strong>B</strong> and <strong>8</strong> look kind of similar, as do <strong>D</strong> and <strong>0</strong> <em>(unless your font puts a slash through the zeros, which was a conscious choice I made in the font used by the Web console...as well as distinguishing <strong><code>1</code></strong> and <strong><code>l</code></strong> and <strong><code>I</code></strong>.)</em>  As a sample comparison, consider C68B80D with c68b80d.</p>
<p>Beyond just the readability aspect, there's also the typing aspect.  Rebol code generally favors lowercase...and when you're doing data entry you don't have to hit the shift key.</p>
<p>Despite these perceived advantages of lowercase hex in the modern world, Rebol currently canonizes binaries as uppercase:</p>
<pre><code>&gt;&gt; #{1a2b3c4d5e6f}
== #{1A2B3C4D5E6F}
</code></pre>
<p>The argument to not bias to lowercase would probably be "it's a black box, you're not supposed to look at it"...and so the difference is an advantage of making BINARY! look different, where you say "that's for the computer to read, but not me".  Nice though that might sound in theory, I pretty often do have to look at the actual bytes in a BINARY!.  For people who favor the school of thought that it should be de-emphasized, editor features like syntax highlighting might be the way for them to get that, while aiming for the most concrete legibility one can get.</p>
<p>Thoughts?</p>
            <p><small>5 posts - 4 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-hexadecimal-be-lowercase/1225">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-hexadecimal-be-lowercase/1225</link>
          <pubDate>Mon, 07 Oct 2019 12:29:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1225</guid>
          <source url="https://rebol.metaeducation.com/t/should-hexadecimal-be-lowercase/1225.rss">Should Hexadecimal Be Lowercase?</source>
        </item>
        <item>
          <title>Should literal BLANK! be one, or two underscores?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Lexer</category>
          <description><![CDATA[
            <p><a class="mention" href="https://rebol.metaeducation.com/u/rgchris">@rgchris</a> suggested something that had already run across my mind a few times.  Are BLANK! literals a bit too thin at just one character wide?</p>
<p>Underscore is a very slight character in the first place.   Two characters would make it stand out, and be the same width as empty block or a void-evaluating group:</p>
<pre><code>data: __
rule: []
void: ()
</code></pre>
<p>Compare with:</p>
<pre><code>data: _
rule: []
void: ()
</code></pre>
<p>Is there something intrinsically more pleasing about the two underscores?  Does it resolve some of the qualms some people (<a class="mention" href="https://rebol.metaeducation.com/u/rgchris">@rgchris</a> in particular) have had about the single underscore?</p>
<p>Or could blank be any number of underscores (defaulting to some value) and retain it as part of its formatting?  :-/</p>
<pre><code>&gt;&gt; x: _
&gt;&gt; y: __
&gt;&gt; z: ___

&gt;&gt; mold x
_

&gt;&gt; mold y
__

&gt;&gt; mold z
___
</code></pre>
<p>Problem being of course that BLANK!s are generated by the system a lot; standardization makes more sense.</p>
<p>For near term compatibility, if _ went back to being a WORD!, we could define:</p>
<pre><code>_: __
</code></pre>
<p>Rebmu will of course want the ability to express a BLANK! in a single character.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/slight_smile.png?v=14" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20">  So perhaps this would remain as a definition for everyone, but it should probably not be considered a literal if it is not "canonized"</p>
            <p><small>14 posts - 6 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-literal-blank-be-one-or-two-underscores/222">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-literal-blank-be-one-or-two-underscores/222</link>
          <pubDate>Tue, 25 Jul 2017 03:12:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-222</guid>
          <source url="https://rebol.metaeducation.com/t/should-literal-blank-be-one-or-two-underscores/222.rss">Should literal BLANK! be one, or two underscores?</source>
        </item>
  </channel>
</rss>

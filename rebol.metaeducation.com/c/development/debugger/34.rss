<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Debugger - AltRebol</title>
    <link>https://rebol.metaeducation.com/c/development/debugger/34</link>
    <description>Topics in the &#39;Debugger&#39; category It&#39;s best to walk before you run!</description>
    
      <lastBuildDate>Sun, 08 Sep 2024 00:02:56 +0000</lastBuildDate>
      <atom:link href="https://rebol.metaeducation.com/c/development/debugger/34.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>A Dream For Debugging: Generalized Accessors</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Debugger</category>
          <description><![CDATA[
            <p>You may be familiar in some languages with the ideas of "Getters" and "Setters" (more generally called <a href="https://en.wikipedia.org/wiki/Mutator_method">"Accessors"</a>).  These features make it so that when you do what looks like normal field access, you're actually running code to do the fetches and assignments.</p>
<p>A Rebol version of this idea might look a bit like:</p>
<pre><code>obj: make object! [
    writable-private: 1020
    readable-private: [some block]

    writable: accessor func [:^value [integer!]] [  ; new :refinement
        if not value [  ; it's a get (dual protocol discerns from set to null)
            print "getting writable!"
            return .writable-private
        ]
        else [  ; it's a set
            print "setting writable!"
            return .writable-private: unlift value  ; or ^value, if you prefer
        ]
    ]

    readable: accessor does [  ; not taking :^value means read only
        print "getting readable"
        .readable-private.  ; (terminal dot means "any value, including actions")
    ]
]

&gt;&gt; obj.writable
getting writable!
== 1020

&gt;&gt; obj.writable: 304
setting writable!
== 304

&gt;&gt; obj.readable
getting readable!
== [some block]

&gt;&gt; obj.readable: [some other block]
** Error: Cannot assign obj.readable (read only)
</code></pre>
<p>The sky is the limit for how useful this can be.  You already see that it can be used to implement typechecking.  But really anything else...</p>
<h2><a name="p-7593-debugging-is-clearly-a-place-this-can-help-a-lot-1" class="anchor" href="https://rebol.metaeducation.com#p-7593-debugging-is-clearly-a-place-this-can-help-a-lot-1"></a>Debugging is clearly a place this can help a lot</h2>
<p>You can intercept reads, and you can intercept writes even of particular values...</p>
<p>While I am still designing to facilitate stepwise debugging correctly, this is actually <em>better</em> than stepwise debugging for solving many kinds of problems.  It gives you a completely generic hook.</p>
<h2><a name="p-7593-leagues-better-than-reds-on-changehttpswwwred-langorg201412050-objects-supporthtml-2" class="anchor" href="https://rebol.metaeducation.com#p-7593-leagues-better-than-reds-on-changehttpswwwred-langorg201412050-objects-supporthtml-2"></a>Leagues Better Than <a href="https://www.red-lang.org/2014/12/050-objects-support.html">Red's ON-CHANGE*</a></h2>
<p>The writable checks are a more granular interface to what Red provides as ON-CHANGE*.  Red's idea is that's something you put in your object which is a function that gets the name of a member that's changing.  You'd have to put in a SWITCH statement on the name, and notice when it's the field you're interested in.  It's clumsy, doesn't help you when variables are being read vs. written, and blesses a name of a method in your object.</p>
<p>But also...</p>
<h2><a name="p-7593-generalized-accessors-means-no-object-is-required-3" class="anchor" href="https://rebol.metaeducation.com#p-7593-generalized-accessors-means-no-object-is-required-3"></a><em>Generalized</em> Accessors means <em>NO OBJECT IS REQUIRED!</em></h2>
<p>The way I'm looking at implementing this, <strong>you can do it to <em>any</em> variable</strong>.</p>
<pre><code>&gt;&gt; foo: accessor func [&lt;static&gt; value (100) [print "Plain old foo!", value]]

&gt;&gt; foo
Plain old foo!
== 100
</code></pre>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/heart_eyes.png?v=14" title=":heart_eyes:" class="emoji only-emoji" alt=":heart_eyes:" loading="lazy" width="20" height="20"></p>
<p><em>"You want it.</em><br>
<em>You need it.</em><br>
<em>You've got to got to have it!"</em></p>
<p>(Though for reasons of implementation sanity, this may (?) not be allowed on variables in the LIB context, where the system relies too heavily on the native definitions being literal.)</p>
<h2><a name="p-7593-not-finished-yetbut-proof-of-concept-is-working-4" class="anchor" href="https://rebol.metaeducation.com#p-7593-not-finished-yetbut-proof-of-concept-is-working-4"></a>Not Finished Yet...But Proof-Of-Concept Is Working</h2>
<p>Carl wanted them, <a href="http://www.rebol.net/r3blogs/0019.html">but acknowledged the difficulty</a>:</p>
<blockquote>
<p>I should mention, however, it's not that easy to add set-functions. If it were really easy, we'd have them. The problem is that set-functions add another branch to the tree of REBOL language semantics. For example, how are set functions defined and how reflective are they?</p>
</blockquote>
<p>But if anything, he's underestimating the difficulty of adding them to the codebase as he had it.  If you know anything about the implementation, you should ask <em>"how can you put an action in a cell and not screw up by having some part of the code think the action is the variable itself...not an action to call to get the variable?"</em></p>
<p>The answer is to store variables in "dual representation".  We can simply store lifted values (quasi/quoted) for literal things, and then in the unlifted range there can be things like FRAME! to mean "use as an accessor"</p>
<p><strong>Anyway, it will take a while.</strong>  But the method looks like it will have means to perform well enough to be the answer to typechecking on reads and writes where needed...which is something I think we do need for the language to be modern enough to be applied seriously.  (All languages seem to evolve into typed versions when they hit problems at scale, e.g. JavaScript =&gt; TypeScript)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/a-dream-for-debugging-generalized-accessors/2259">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/a-dream-for-debugging-generalized-accessors/2259</link>
          <pubDate>Sun, 08 Sep 2024 00:02:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2259</guid>
          <source url="https://rebol.metaeducation.com/t/a-dream-for-debugging-generalized-accessors/2259.rss">A Dream For Debugging: Generalized Accessors</source>
        </item>
        <item>
          <title>UNMAKE and the Death Of Construction Syntax</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Debugger</category>
          <description><![CDATA[
            <p>I don't really believe in textual construction syntax in its historical sense.  You can't generically "mold" things out as a string in a way that LOAD can resurrect what you had...too much is lost when the binding goes away and whatever parts of the structure that weren't List-like go away.  Today's mold and construction syntax is a dead end.</p>
<p>What I <strong>do</strong> believe in is the idea that while the interpreter is still running, you can ask a complex data structure to give back a reified array description of itself.  This description should be concrete where it can be...but if it can't, it needs to give you some kind of POINTER! type that can be further probed.</p>
<p>Think about something that could be used to implement an object browser like in the JavaScript console:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/6a4adcd0a65026b11af34db6ce41bfe4a12137cb.png" data-download-href="https://rebol.metaeducation.com/uploads/default/6a4adcd0a65026b11af34db6ce41bfe4a12137cb" title="RsxAB"><img src="https://rebol.metaeducation.com/uploads/default/original/1X/6a4adcd0a65026b11af34db6ce41bfe4a12137cb.png" alt="RsxAB" data-base62-sha1="faj0fZrhniidAirX3ZIDdKta0yf" width="374" height="256"></a></div><br>
Imagine that first level of result, which gives you things and then you have an arrow to go deeper.<p></p>
<p>The idea that you actually would get enough information to reconstitute the data structure is interesting, so let's imagine we call this UNMAKE, and we seek it to have that property:</p>
<pre><code>&gt;&gt; obj: {x: 1 + 2, y: first [(a b) (c d)], z: &lt;thing&gt;, f: does [print "hi"]}

&gt;&gt; unset $obj.z

&gt;&gt; unmake obj
== @{x: 3 y: '(a b) z: ~ f: {\0x52d0000a0f48\}}

&gt;&gt; obj2: make unmake obj

&gt;&gt; obj = obj2
== ~true~  ; anti
</code></pre>
<p>So here I'm imagining that MAKE would react differently to <code>@{...}</code>, and see that as an instruction to REMAKE what it originally had... or, if you made adjustments, it would be able to affect it.</p>
<pre><code>&gt;&gt; reified: unmake obj
== @{x: 3 y: '(a b) z: ~ f: {\0x52d0000a0f48\}}

&gt;&gt; reified.3: [c d e]
== @{x: 3 y: [c d e] z: ~ f: {\0x52d0000a0f48\}}

&gt;&gt; remake obj reified

&gt;&gt; obj.y
== [c d e]
</code></pre>
<p>For this to work, those pointer references have to keep the thing they point to alive somehow.  So that would be part of POINTER!'s mechanics.</p>
<p>MOLD would be a client of UNMAKE, where you'd have some depth at which you ask it to go into the pointers, but if it hit a pointer it would just dead end you there with some placeholder:</p>
<pre><code>&gt;&gt; mold obj
== "@{x: 3 y: '(a b) z: ~ f: ~&lt;action!&gt;~}"

&gt;&gt; mold/depth obj 2
== "@{x: 3 y: '(a b) z: ~ f: @{action! [] [print "hi"]}"
</code></pre>
<p>And you'd just use that for debug output.</p>
<p>This is only a sketch...but it points in a direction that I think could actually be useful.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/unmake-and-the-death-of-construction-syntax/2225">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/unmake-and-the-death-of-construction-syntax/2225</link>
          <pubDate>Tue, 27 Aug 2024 17:03:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2225</guid>
          <source url="https://rebol.metaeducation.com/t/unmake-and-the-death-of-construction-syntax/2225.rss">UNMAKE and the Death Of Construction Syntax</source>
        </item>
        <item>
          <title>ReplPad Visual PARSE Debugger</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Debugger</category>
          <description><![CDATA[
            <p>Hey!  I've gotten UPARSE hooked up to a debugger:</p>
<p><a href="https://www.youtube.com/watch?v=doS7NgajRxI">Ren-C PARSE Hook Demo: Debugging</a></p>

<p>The ability to step in at every level shows just how granular the hook is.  It's not a terrible lot of code:</p>
<p><a href="https://github.com/hostilefork/replpad-js/blob/eb8a62054d345f798b3b87364943df3534a7b92e/eparse.reb#L334" class="inline-onebox">replpad-js/eparse.reb at eb8a62054d345f798b3b87364943df3534a7b92e · hostilefork/replpad-js · GitHub</a></p>
<p>It's barely tested, but it is public on the ReplPad if anyone wants to throw something at it.</p>
<h2><a name="p-6718-what-concerns-did-writing-this-raise-1" class="anchor" href="https://rebol.metaeducation.com#p-6718-what-concerns-did-writing-this-raise-1"></a>What Concerns Did Writing This Raise?</h2>
<p>Having the debugger in the ReplPad gives an immediate user annoyance: <em>Why can't I type in the console while the debugger is running?</em>  (That's a huge can of worms and requires several posts of its own to talk about.)</p>
<p>The design of UPARSE is that you can provide your own set of combinators to use.  You can give it a new WORD! combinator that does something besides fetch what the word looks up to and "act like it would if it were written there".  While this simple tracing facility can handle generic interpretations, the generality could subvert the usefulness of higher level tools.</p>
<p>Beyond that problem of "words may not look things up at all", there's also the problem of "discovery".  Everything is "discovered" as you go along--there's not a list supplied up front.  That may not be a fit for some tools, so they could end up asking you to pass in the names of all the rules of interest even though they don't need to be "instrumented".</p>
<p>I thought of adding a BREAKPOINT combinator, so you could break in mid-parse.  But I was only building up a list modeling the stack for frames while you were interacting with the buttons.  Having the stack always available at an arbitrary moment would mean that the stack model would have to be updated on every call to the hook.  Effectively this duplicates information held in the "real stack"--the subset of function calls that represent combinators.  So it's tempting to find a way to label stack frames and enumerate them generically, vs. expecting all debuggers like this to maintain their own.</p>
<p>There's a lot to think about, here.  But as Rebol in the browser goes, this really is the only game in town, and it's holding up pretty well whenever I exercise it!</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/replpad-visual-parse-debugger/2063">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/replpad-visual-parse-debugger/2063</link>
          <pubDate>Thu, 26 Oct 2023 02:19:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2063</guid>
          <source url="https://rebol.metaeducation.com/t/replpad-visual-parse-debugger/2063.rss">ReplPad Visual PARSE Debugger</source>
        </item>
        <item>
          <title>Axing --breakpoint switch, C-DEBUG-BREAK-AT</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Debugger</category>
          <description><![CDATA[
            <p><strong>I'm killing off features for whom their maintenance is not paying off.</strong></p>
<p>One is the "tick" based usermode <code>--breakpoint</code> feature, implemented on the command line as:</p>
<pre><code>        "--breakpoint" end (
            c-debug-break-at to-integer param-or-die "BREAKPOINT"
        )
</code></pre>
<p>The complex problem of taking a "tick" count to break on via a command line switch is that since command line processing is in usermode, you have a kind of observer-affects-the-experiment situation.  The code for adding in the breakpoint messes with the tick count you're trying to reproduce.</p>
<p>I had ideas to work around this.  So there's the /COMPENSATE feature of C-DEBUG-BREAK, which I don't even know if it works or if my idea is fundamentally flawed:</p>
<pre><code>; Taking a command-line `--breakpoint NNN` parameter is helpful if a
; problem is reproducible, and you have a tick count in hand from a
; panic(), REBSER.tick, Frame.tick, REBVAL.extra.tick, etc.  But there's
; an entanglement issue, as any otherwise-deterministic tick from a prior
; run would be thrown off by the **ticks added by the userspace parameter
; processing of the command-line for `--breakpoint`**!  :-/
;
; The /COMPENSATE option addresses this problem.  Pass it a reasonable
; upper bound for how many ticks you think could have been added to the
; parse, if `--breakpoint` was processed (even though it might not have
; been processed).  Regardless of whether the switch was present or not,
; the tick count rounds up to a reproducible value, using this method:
;
; https://math.stackexchange.com/q/2521219/
;
; At time of writing, 1000 ticks should be *way* more than enough for both
; the PARSE steps and the evaluation steps `--breakpoint` adds.  Yet some
; things could affect this, e.g. a complex userspace TRACE which was
; run during boot.
;
attempt [c-debug-break-at/compensate 1000]  ; fails in release build
</code></pre>
<p>Here was more of it:</p>
<pre><code>  #if !defined(NDEBUG) &amp;&amp; DEBUG_COUNT_TICKS
    if (REF(compensate)) {
        //
        // Imagine two runs of Rebol console initialization.  In the first,
        // the tick count is 304 when C-DEBUG-BREAK/COMPENSATE is called,
        // right after command line parsing.  Later on a panic() is hit and
        // reports tick count 1020 in the crash log.
        //
        // Wishing to pick apart the bug before it happens, the Rebol Core
        // Developer then re-runs the program with `--breakpoint=1020`, hoping
        // to break at that tick, to catch the downstream appearance of the
        // tick in the panic().  But since command-line processing is in
        // usermode, the addition of the parameter throws off the ticks!
        //
        // https://en.wikipedia.org/wiki/Observer_effect_(physics)
        //
        // Let's say that after the command line processing, it still runs
        // C-DEBUG-BREAK/COMPENSATE, this time at tick 403.  Imagine our goal
        // is to make the parameter to /COMPENSATE something that can be used
        // to conservatively guess the same value to set the tick to, and
        // that /COMPENSATE ARG(bound) that gives a maximum of how far off we
        // could possibly be from the "real" tick. (e.g. "argument processing
        // took no more than 200 additional ticks", which this is consistent
        // with...since 403-304 = 99).
        //
        // The reasoning for why the formula below works for this rounding is
        // given in this StackExchange question and answer:
        //
        // https://math.stackexchange.com/q/2521219/
        //
        Tick one = 1; // MSVC gives misguided warning for cast(Tick, 1)
        TG_tick =
            (one &lt;&lt; (ceil_log2(TG_tick) + 1))
            + VAL_INT64(ARG(tick))
            - 1;
        return nullptr;
    }
</code></pre>
<p>Also, I've never used the /RELATIVE tick feature, killing that too:</p>
<pre><code>  if (REF(relative))
      TG_break_at_tick = frame_-&gt;tick + 1 + VAL_INT64(ARG(tick));
</code></pre>
<p><strong>I'm going to be deleting a lot of things, I think, in the pursuit of simplification--now that isotopes are showing the way.</strong></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/axing-breakpoint-switch-c-debug-break-at/2009">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/axing-breakpoint-switch-c-debug-break-at/2009</link>
          <pubDate>Tue, 24 Jan 2023 21:57:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2009</guid>
          <source url="https://rebol.metaeducation.com/t/axing-breakpoint-switch-c-debug-break-at/2009.rss">Axing --breakpoint switch, C-DEBUG-BREAK-AT</source>
        </item>
        <item>
          <title>WATCH Dialect Is Back</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Debugger</category>
          <description><![CDATA[
            <p>For a while, the WATCH dialect wasn't working in the ReplPad.  Fixing it actually turned out to be rather difficult, because ReplPad was changed to use FUNC and LET exclusively (no FUNCTION).  So this was really the first complex dialect whose implementation depended fully on virtual LET-binding.  Debugging in the browser is significantly harder, so that made it pretty mean.</p>
<p>But now that it's working, I have the headless browser test running the dialect.</p>
<p>It's a fun thing, so why not go ahead and <a href="http://hostilefork.com/media/shared/replpad-js/">load up the ReplPad</a> and try it?</p>
<p>Interestingly, it loads the watch extension the first time you invoke WATCH.</p>
<pre><code>&gt;&gt; watch x  ; (slot 1): ~unset~
</code></pre>
<p>This should show <code>~unset~</code> in watch slot 1.  If you change the value of <code>x</code>, then you should see the slot update.</p>
<pre><code> &gt;&gt; x: 304
 == 304   ; (slot 1): 304
</code></pre>
<p>The way the updating works right now is by hooking the console's PRINT-RESULT function.  After the result has been printed, it updates the slots.  So you won't see the values change during the evaluation, only each time you get a console prompt.</p>
<p>If you want you can ask the watchlist to give you the value stored in a slot, by passing an integer.</p>
<pre><code>&gt;&gt; watch 1
== 304
</code></pre>
<p>You can hide the watchlist</p>
<pre><code>&gt;&gt; watch /off
</code></pre>
<p>And you can show the watchlist</p>
<pre><code>&gt;&gt; watch /on
</code></pre>
<p>If you want to delete a watch, you can use a negative number</p>
<pre><code>&gt;&gt; watch -1
</code></pre>
<p>It would be helpful if <a class="mention" href="https://rebol.metaeducation.com/u/rgchris">@rgchris</a> could look over the splitter and see how sane the strategy is.  What I would like is a way to make panels generically, so they can work in something like <a href="https://golden-layout.com/">Golden Layouts</a>.  I don't want to <em>require</em> something that heavy to run a replpad instance...I'd actually like it to be possible to just kind of load a console on-demand and have it pop up for debugging an app that was using Ren-C as a library.  But it would be great to be <em>able</em> to use Golden Layout (or similar).</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/watch-dialect-is-back/1522">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/watch-dialect-is-back/1522</link>
          <pubDate>Wed, 24 Feb 2021 22:09:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1522</guid>
          <source url="https://rebol.metaeducation.com/t/watch-dialect-is-back/1522.rss">WATCH Dialect Is Back</source>
        </item>
        <item>
          <title>Why Remote Debugging Is Likely The Right Focus</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Debugger</category>
          <description><![CDATA[
            <p>I'd hoped in pursuing the stackless model that it would shed a light onto how debugging would have to work (or at least, on how it wouldn't work).</p>
<p>I've been wanting a scriptable debugger, where you could write something like:</p>
<pre><code>&gt;&gt; test: func [] [print "&lt;break&gt;", breakpoint, print "Hello!", print "World!"]

&gt;&gt; test
&lt;break&gt;
** Breakpoint hit

[console/test]&gt;&gt; step2: func [] [loop 2 [print "&lt;step&gt;", step/over]]

[console/test]&gt;&gt; step2
&lt;step&gt;
Hello!
&lt;step&gt;
World!
</code></pre>
<p>What stackless brings to the table here is the capability for STEP to put the loop on hold (while still remembering how far along it is in the loop count).  The debugger enters a state of suspended animation and instructs the stack it was running to resume...running long enough to complete one step.</p>
<p>If you <em>didn't</em> have a stackless model, you'd have to use a continuation-passing style.  STEP would be parameterized with a function to call back when the step completed.</p>
<h2><a name="p-4298-seems-attainablebut-1" class="anchor" href="https://rebol.metaeducation.com#p-4298-seems-attainablebut-1"></a>Seems Attainable...But...</h2>
<p>Intuitively, it seems that what you do while using a debugger is something that should be scriptable in this fashion.  There's nothing that profound about how you push the step-over and step out buttons in a typical C debugger...look at the stack...and make decisions.  Why can't that get automated?</p>
<p>There are some mechanical questions.  Like "what if a breakpoint happens while you are stepping".  Your script has to have an answer to this--but then again, so would you.</p>
<p>How would you recognize the completion of the STEP you did vs. some other event?  You need some kind of handle to ensure continuity, that you knew a step completed.</p>
<p>Maybe that's done by thinking of it as a handle you WAIT on, and then you find out about whether that completes or some other event gets triggered:</p>
<pre><code>req: step-request frame
wait [
    req [--handling if that step finishes--]
    debug-events [--any other debug event?--]
    1000 [--timeout value?--]
]
</code></pre>
<h2><a name="p-4298-stackless-assists-then-stackless-complicates-2" class="anchor" href="https://rebol.metaeducation.com#p-4298-stackless-assists-then-stackless-complicates-2"></a>Stackless Assists, Then Stackless Complicates</h2>
<p>Stackless does offer the mentioned leverage to be able to put the debugger in a suspended state while picking up another stack's code.  <strong>But once stackless code exists, you have to worry about debugging stackless code too</strong>.</p>
<p>As with any API, you find the debugger starts to need to have a model of all the various internal entities that you would need to talk about.  So it has to have a model of "threads of execution" (green threads).  It has to discern stacks which belong to the debugger (which should not be stepped into) from those that belong to the client (which should...or maybe only some?)</p>
<p>Things get really complicated, really quickly.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/exploding_head.png?v=14" title=":exploding_head:" class="emoji" alt=":exploding_head:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-4298-taking-a-stepback-3" class="anchor" href="https://rebol.metaeducation.com#p-4298-taking-a-stepback-3"></a>Taking A STEP/BACK</h2>
<p>When you think about the problem of mixing the UI for a debugger into the same process as what is being debugged, this raises questions.</p>
<p>There are pros and cons to it.  One of the big supposed "pros" of being in the same process is having access to the memory for all the objects.  So you can poke at it and manipulate it directly.</p>
<p>However, there are good reasons to design a debugger to go through some level of indirection to do these kinds of things.  One very good reason is that it means <strong>you can make a remote debugger</strong>.</p>
<p>It seems to me a minimal bar for looking for future-forward inspiration on this front is systems that are actually working today.  And you can see that in the <a href="https://chromedevtools.github.io/devtools-protocol/">Chrome DevTools Protocol</a>.</p>
<p>If you're going to be a client of the devtools protocol, then to do debug evaluations you pass the code to the debugged session...and then you get back either a primitive value (which you can use directly), or a "remote object ID".  If it's a remote object ID, you can use that to do more poking at the client, and extract more primitive values from it.</p>
<p>Connecting to a remote debugger is a two-step process.  The first is to connect to chrome via a debug port and get a list of the running tabs.  Then you pick a tab, and you get a <em>websocket</em> URL to connect to in order to send the actual API requests.  Keeping that websocket alive is what keeps the remote object IDs alive that you asked for across API calls, and it also makes it possible to do things like subscribe to events in the debugger.</p>
<h2><a name="p-4298-this-seems-the-way-forward-4" class="anchor" href="https://rebol.metaeducation.com#p-4298-this-seems-the-way-forward-4"></a>This Seems The Way Forward</h2>
<p>This certainly seems like a staggering and epic undertaking.  But it's better to lay the foundations, and have modest initial features, than to try going down a road that is a dead end in the long run.</p>
<p>The server and websocket abilities could all initially just come from C code, e.g. the <a href="http://websockets.org">websockets.org</a> library:</p>
<p><a href="https://libwebsockets.org/">https://libwebsockets.org/</a></p>
<p>libRebol already provides a good way of tracking API handles, and those could be used as remote object IDs.</p>
<p>Over the long run, stackless is still crucial here...because we don't necessarily want to keep the entire debug server (that talks over sockets to the client) to be written in C.  But if the server is running as usermode code inside the process being debugged, it's going to need to be able to run without interfering with the mid-stack of user code that it's debugging.</p>
<p>If done correctly, this could be bridged with talking to websockets in a browser...so a WASM interpreter in a browser could connect through Chrome DevTools and with a little fiddling make the calls.  This would be a case where the interpreter would not need libwebsockets built in, because it would be leveraging what's already in Chrome.</p>
<p>Being able to start up a plain terminal console session and debug an interpreter in the browser would be a mean demo.  It would show parity with the JavaScript competition.  And I think anything less would risk falling behind on the long bet of saying that WASM means there <em>will</em> be more languages in the browser than just JS.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/why-remote-debugging-is-likely-the-right-focus/1407">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/why-remote-debugging-is-likely-the-right-focus/1407</link>
          <pubDate>Thu, 19 Nov 2020 13:12:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1407</guid>
          <source url="https://rebol.metaeducation.com/t/why-remote-debugging-is-likely-the-right-focus/1407.rss">Why Remote Debugging Is Likely The Right Focus</source>
        </item>
        <item>
          <title>Very Creaky (but still interesting) Debug Step *DEMO*</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Debugger</category>
          <description><![CDATA[
            <p>Though there's been no published news about the debugger in well over a year, I've tried to bear in mind the concerns that a debugger would have.</p>
<p>Stopping everything to work on the debugger for a few months isn't really an option.  But it's good to do a bit of a status check for where things stand, if "keeping the debugger in mind" has any credibility.  The question to ask is <em>"could a sufficiently motivated individual build a debugger on top of the evaluator infrastructure if they wanted to"</em>.</p>
<p>So the last few days I've frittered around with a very-buggy-proof-of-concept for single-stepping.  Given:</p>
<pre><code>foo: function [f] [
    print "Entering foo"
    f: bar f
    f: f + 1000
]

bar: function [b] [
     print "Entering bar"
     breakpoint
     print "STEPPING!"
     b: b + 10
     return b + 100
]
</code></pre>
<p>The following demo seems to run, but it's really just a thought experiment to inform the design:</p>
<pre><code>&gt;&gt; foo 1
Entering foo
Entering bar
(i) BREAKPOINT hit

!! Entering *EXPERIMENTAL* Debug Console that only barely works for a demo.
Expect crashes and mayhem.  But see BACKTRACE, RESUME, and STEP.

bar:|1|&gt;&gt; backtrace
2 [foo 1 ~~]
1 [...
    f: bar f ~~
    f: f + ...]
0 [
    print "Entering bar"
    breakpoint ~~
    print "STEPPING!"
    b: ...]

bar:|1|&gt;&gt; step
STEPPING!

bar:|1|&gt;&gt; backtrace
2 [foo 1 ~~]
1 [...
    f: bar f ~~
    f: f + ...]
0 [...
    breakpoint
    print "STEPPING!" ~~
    b: b + ...]

bar:|1|&gt;&gt; b
== 1

bar:|1|&gt;&gt; step

bar:|1|&gt;&gt; b
== 11

bar:|1|&gt;&gt; 2
(i) Interpreting integer input as DEBUG

foo:|2|&gt;&gt; f
== 1

foo:|2|&gt;&gt; step

bar:|1|&gt;&gt; backtrace
2 [foo 1 ~~]
1 [...
    f: bar f ~~
    f: f + ...]
0 [... b + 100 ~~]

bar:|1|&gt;&gt; b
== 11

bar:|1|&gt;&gt; step

foo:|1|&gt;&gt; backtrace
1 [foo 1 ~~]
0 [... f + 1000 ~~]

foo:|1|&gt;&gt; f
== 1111

foo:|1|&gt;&gt; step

&gt;&gt; resume  ; !!! If you don't type this, it will start acting weird
</code></pre>
<p><em>(Discourse put a scroll bar on that, so be sure you scrolled through it all, the scroll bar is easy to miss.)</em></p>
<h2><a name="p-3320-the-good-news-1" class="anchor" href="https://rebol.metaeducation.com#p-3320-the-good-news-1"></a>The Good News</h2>
<p>A lot of parts have to come together just for that.  You're seeing a console written in Rebol being able to kick off a recursive call to offer a nested debugger console with a custom skin (also in Rebol).</p>
<p>Here we see it <a href="https://github.com/metaeducation/ren-c/blob/866c4b5a53e6f8ffd2e587ecebb54ec4879add91/extensions/debugger/ext-debugger-init.reb#L90">interpreting raw ENTER as "STEP"</a> and a plain INTEGER! as a request to switch stack levels.  This is the direction I wanted to see, and why I held off from the idea of any further development of a C console... <em>this runs in the web console too</em>!</p>
<p>It also adds to that hook the <a href="https://github.com/metaeducation/ren-c/blob/866c4b5a53e6f8ffd2e587ecebb54ec4879add91/extensions/debugger/ext-debugger-init.reb#L103">binding what you type to the variables of the stack level you are "focused" on</a>.  Above you see it finding the <code>b</code> local in <code>bar</code>, and then switching stack levels and being able to find the <code>f</code> local in <code>foo</code>.</p>
<p>Even though it's all single threaded (no linkage to pthreads in a console build), that nested command session is doing arbitrary variable inspections...but also running a usermode BACKTRACE command...where you only see the stack levels pertaining to the code you were running.  So it's not stepping through the console code or seeing its implementation.</p>
<p>Lines are shaping up between the pieces; they can be separated out.  You can build with just the evaluator and no console, or add the console in, or add the debugger in.  It's something you can mix and match--and the paths are laid down to be able to pull in these elements dynamically as well as in a static build.</p>
<p>The star of the show is really FRAME!, and how that's supporting the whole idea.</p>
<h2><a name="p-3320-whats-the-bad-news-2" class="anchor" href="https://rebol.metaeducation.com#p-3320-whats-the-bad-news-2"></a>What's the Bad News?</h2>
<p>It's important to emphasize <strong>this is still sticks and glue at this point</strong>.</p>
<p>As mentioned at the top of this post: this was really just a temperature check on how things are going in the evaluator.  I think it's generally the right direction, but seeing it actually trying to line up with reality exposes a lot of issues.  Going to have to go back to the drawing board with some ideas.</p>
<p><strong>Single Threading</strong></p>
<p>What's been the longstanding "big issue" is what it means to be attempting to design a scriptable debugger in a single-threaded system.  It's certainly possible to write debuggers on single-threaded platforms (remember Turbo Pascal for DOS?)  But here we have something quite different...where scripting for the debug console is running <em>in the same language on the same execution stack</em>.</p>
<p>Industrial-strength debuggers tend to be able to connect from remote machines (e.g. debugging on your phone from the PC).  This RPC/messaging runaround can be pretty intimidating, if you look at a sample of <a href="https://cs.chromium.org/chromium/src/v8/test/inspector/inspector-test.cc">how to call V8's debug API from C++</a>.</p>
<p>If we were committed to saying you needed threads and message pumps to do debugging, it would make some things easier.  But multithreaded Rebol is still not a real thing...we would need at least something parallel to V8's "isolates" to be able to have interpreter sessions that could not actually share objects.  So rendering/molding of anything you wanted to look at in the debugger would have to be done in the "debuggee" isolate anyway.</p>
<p>So trying to abstract the interface so that it can grow into a message-passing solution is a big challenge.  Being able to have it work whether or not you're linked to pthreads is actually kind of interesting.</p>
<p><strong>Debugging Dialects</strong></p>
<p>Something I really wanted to see was the debugger generalizing to parse.  And at first glance, it seems like it might:</p>
<pre><code>&gt;&gt; count: 0
&gt;&gt; rule: ["a" (count: count + 1 breakpoint)]
&gt;&gt; parse "aaa" [some rule]
(i) BREAKPOINT hit

subparse:|1|&gt;&gt; backtrace
3 [parse "aaa" [some rule] ~~]
2 [some rule ~~]
1 ["a" ~~ (count: count + ...)]
0 [... + 1 breakpoint ~~]

subparse:|1|&gt;&gt; count
== 1
</code></pre>
<p>Seems promising.  But from there on out, the granularity of STEP is not what you want.  In order for STEP to intelligently STEP over a parse rule there has to be a common protocol spoken by PARSE and the evaluator beyond just what the "stack" looks like.</p>
<p>But this also shows just how many meanings of STEP you might have.  How do dialects get involved in debugging?  What does the "hello world" of making a dialect that offers its own idea of what steps are look like?</p>
<p>Red has a /TRACE option to parse which will call a callback on "parse events" <a href="https://www.red-lang.org/2013/11/041-introducing-parse.html">described in the "Introducing Parse" post</a>.  But at the end of the day, I think what this is aiming for is more what people are going to want...a unified stack concept which fits dialects into a holistic model.  It's got to have a design, though.</p>
<p><strong>Rendering</strong></p>
<p>As these snippets show, it's a challenge to know how much to show.  And you're flattening a data structure with nested levels and pointers and (potentially) cycles.</p>
<p>Even if we had a GUI environment to throw up an annotated source file in...debugging Rebol is like debugging C where everything is a macro.  :-/  There's not always a clear place in something the user thought of "source code" to tie generated blocks to.</p>
<p><strong>Inheriting Console Behaviors</strong></p>
<p>The debugger spawns a nested console, and wants to augment it with its own debugger-specific methods.  Right away this ran up against the problem of <code>SYSTEM/CONSOLE</code> being thought of as a global object.  If you want to change the prompt, you say <code>system/console/prompt: "whatever&gt;&gt; "</code>.  How do multiple console objects fit into this picture?</p>
<p>Not only that, but what if you want to keep some of the customizations you have for your usual console while debugging?  How do you keep your shortcuts or your dialect hooks?</p>
<p>Compared to the other issues this is kind of a fringe/luxury issue.  So for now, the debugger console is a console unto itself.  Your customizations don't apply when the debugger is running.  My point is just that these aren't questions just magically answer themselves.</p>
<p><strong>I Could Go On, But...</strong></p>
<p>...the point is just that there's a lot to think about.  We haven't seen single-stepping of this type in Redbol before this...and it's been decades.  So it would be unrealistic to expect that the first try to be anything but an extremely rough draft.</p>
<p>But I'd like it to evolve to the point of where we start thinking we can push a pause button and get some kind of debugger up.  So I've gone ahead and included it in the web build--<em>for experimentation and prototyping only</em>.  Do not file bugs against the debugger yet, it doesn't exist.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/ghost.png?v=14" title=":ghost:" class="emoji" alt=":ghost:" loading="lazy" width="20" height="20"></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/very-creaky-but-still-interesting-debug-step-demo/1154">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/very-creaky-but-still-interesting-debug-step-demo/1154</link>
          <pubDate>Thu, 02 May 2019 06:19:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1154</guid>
          <source url="https://rebol.metaeducation.com/t/very-creaky-but-still-interesting-debug-step-demo/1154.rss">Very Creaky (but still interesting) Debug Step *DEMO*</source>
        </item>
        <item>
          <title>Reusing Function Argument Cells vs. Debugging</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Debugger</category>
          <description><![CDATA[
            <p>In the historical bit-fiddly nature of Rebol, the reuse of argument cells to do work inside a function was frequent.</p>
<pre><code>foo: func [x y [text!]] [
    do-something-with y
    ; Yay, y is now free...use it as a counter
    y: 0
    while [y &lt;&gt; x] [...]
]
</code></pre>
<p>This practice is particularly pervasive in native functions, where the argument cells provide a convenient "already protected by GC" cell.  Once they've extracted whatever they want into C variables, natives go on to use these slots for anything and everything--as scratch locations.</p>
<p>But it runs up against a problem with debugging...looking in the stack, you no longer see what you passed in for the argument cells.  It makes your calls look like gibberish.</p>
<p>Since arguments are not immutable, this is just a "thing".  One very good reason not to make them immutable is adaptations...you <em>want</em> to be able to create variations of functions that update the arguments, so as to pass them on to a next phase with an adjustment.</p>
<p>So perhaps it's the debugger's responsibility to figure out a way to capture the inputs off to the side (or notice if they ever change and make a copy?)  Or should it be the convention that people just try not to do this unless there is an actual good reason--as with adaptation?</p>
<p>It's just a bit disconcerting to run something like SWITCH and then look in the stack and have gibberish in the cell where you thought you put the thing to switch on...for the sake of micro-optimization.  Just making a distinct local seems worth it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/reusing-function-argument-cells-vs-debugging/1047">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/reusing-function-argument-cells-vs-debugging/1047</link>
          <pubDate>Fri, 01 Feb 2019 01:38:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1047</guid>
          <source url="https://rebol.metaeducation.com/t/reusing-function-argument-cells-vs-debugging/1047.rss">Reusing Function Argument Cells vs. Debugging</source>
        </item>
        <item>
          <title>Debugging the Illusion: Function Compositions</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Debugger</category>
          <description><![CDATA[
            <p><em>I'm trying to get the debugger working again.  It got broken back when the console was moved to usermode, and so its getting a rewrite to become more userspace itself.</em></p>
<hr>
<p>When you ask for a BACKTRACE, it numbers the function frames in the stack.  The numbers are a user convenience, so you can say things about which frame you want to inspect...or where you want to resume running from.  <strong>debug 3</strong> means switch the binding context of the console to the frame you saw numbered 3 in the backtrace, for instance, so it binds words that are function parameters there when you type in the console.</p>
<p>In a single-threaded world--with a routine like BACKTRACE written in usermode--it has to take into account its own stack frames.  Presumably you don't want to see those, nor do you want other debug routines that try to use the numbers to face an issue of "contamination" from their own stack levels if they (like the aforementioned <strong>debug</strong>) try to turn those numbers back into FRAME! values on the user's behalf as part of their implementation.</p>
<p>A user-friendly approach is to count frames backward from the last breakpoint.  So long as all the routines which use BACKTRACE's notion of numbering agree on that convention, they don't have to worry about their own stack frames intervening.</p>
<p>But this raises a curious question: <em>when is a breakpoint on the stack</em>?  Let's say I want to make some kind of logging breakpoint, and I use ADAPT to do it:</p>
<pre><code>logging-breakpoint: adapt 'breakpoint [
    write/append %breakpoint-log.txt unspaced [
        "breakpoint hit at" now newline
    ]
]
</code></pre>
<p><em>(Note: you'd more likely want to HIJACK the regular BREAKPOINT with this adaptation than to call it via the LOGGING-BREAKPOINT name explicitly, but for the sake of this argument let's say you just call it directly under this new name.)</em></p>
<p>When I use LOGGING-BREAKPOINT it logs the time, and falls through to breakpoint as the underlying "phase" of the function.  But will BACKTRACE see BREAKPOINT on the stack?  Technically it is running BREAKPOINT's body at that moment... it's morally equivalent to:</p>
<pre><code>equivalent-breakpoint: func [return: []] [
    write/append %breakpoint-log.txt unspaced [
        "breakpoint hit at" now newline
    ]
    breakpoint
]
</code></pre>
<p>This particular issue could be checked by another property...asking if a frame itself is <code>paused?</code>.  But it raises a good question.  What do you mean when you ask if a particular function is on the stack, in the face of compositions?</p>
<p>Mechanically, there is something called a "phase".  So when you call LOGGING-BREAKPOINT it is originally on the stack in the phase of its own adapted body...e.g. its phase is the FUNCTION! of :LOGGING-BREAKPOINT.  But when it falls off the end of the adaptation and continues running BREAKPOINT in the same FRAME!, it will be in the :BREAKPOINT phase.</p>
<p>So this raises the question of what you get back when you ask for the FUNCTION-OF a FRAME!.  Should the answer be invariant (the top-level function of the frame, whose invocation began it) or should it change depending on how far you've gotten in the execution?  Should there be a PHASE-OF which tells you the phase a frame is in, or should it be considered a "black box" and none of your business?</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/debugging-the-illusion-function-compositions/564">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/debugging-the-illusion-function-compositions/564</link>
          <pubDate>Sun, 11 Mar 2018 06:44:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-564</guid>
          <source url="https://rebol.metaeducation.com/t/debugging-the-illusion-function-compositions/564.rss">Debugging the Illusion: Function Compositions</source>
        </item>
        <item>
          <title>What should the output of TRACE look like?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Debugger</category>
          <description><![CDATA[
            <p>Rebol's only real historical debugging tool was TRACE.  So before we talk about single-step-debugging, let's talk about what it does...and what it can and can't do.</p>
<p>For a very simplified example, let's say your code looked like this:</p>
<pre><code>&gt;&gt; foo: func [x] [add x bar 10]
&gt;&gt; bar: func [y] [either y = 10 [20] [y + 1]]

&gt;&gt; foo 30
== 50
</code></pre>
<p>With TRACE ON you would get the following output.</p>
<pre><code>&gt;&gt; foo 30
  1: foo : function! [x]
  2: 3n
     --&gt; foo
      1: add : action! [value1 value2]
      2: x : 30
      3: bar : function! [y]
      4: 1n
         --&gt; bar
          1: either : native! [condition true-branch false-branch /only]
          2: y : 10
          3: = : op! [value1 value2]
          4: 10
             --&gt; =
         &lt;-- = == true
          5: [20]
          6: [y + 1]
             --&gt; either
              1: 20
         &lt;-- either == 20
     &lt;-- bar == 20
         --&gt; add
     &lt;-- add == 50
 &lt;-- foo == 50
 == 50
</code></pre>
<p><em>(If you're wondering what <code>2: 3n</code> and <code>4: 1n</code> is, those are supposed to be <code>2: 30</code> and <code>4: 10</code>, respectively.  R3-Alpha had quite a number of memory bugs, and running a trace over large amounts of code was a good way to see them.  One of the earliest tasks in Ren-C was in fact to have TRACE on for the entirety of boot, without tripping any asserts or address sanitizer problems.)</em></p>
<p>Another example:</p>
<pre><code>&gt;&gt; do [x: 10 y: add 20 30]
 1: do : native! [value /args arg /next var]
 2: [x: 10 y: add 20 30]
    --&gt; do
     1: x:
     2: 10
     3: y:
     4: add : action! [value1 value2]
     5: 20
     6: 30
        --&gt; add
    &lt;-- add == 50
&lt;-- do == 50
== 50
</code></pre>
<p>What we see here is that in terms of the "what am I about to run", you get <em>one unit of information</em>.  If the one unit of thing turns out to be a FUNCTION!, then you get a level of indentation.</p>
<p>Rebol doesn't really have a way to simulate the evaluator's logic to know how much of an expression is going to be consumed in advance, in order to print that full expression out.  Hence the "one unit".  The only reliable way to know where an expression is going to end is to run it...which means the trace output would come <em>after</em> the expression is run.</p>
<p>So take into account the evaluation order is such that if you say <strong>foo bar x</strong> then x evaluates, then bar evaluates, then foo evaluates.  So the only way you're going to see output that says the whole expression <code>foo bar x</code> is if you wait until all the sub-expressions have evaluated (and suppress their output) and then show the full expression.</p>
<p>This suggests the difference between "step-over" and "step-into", where "step-over" generates no output until the stack level you started from has finished, at which point you get the full expression.  I'm not sure how this pertains to trace, or what the relationship between trace and step debugging is.</p>
<p>I've done some light experimentation with alternatives, and wonder if people have an intuition of what they would like to see.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/what-should-the-output-of-trace-look-like/268">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/what-should-the-output-of-trace-look-like/268</link>
          <pubDate>Thu, 24 Aug 2017 01:24:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-268</guid>
          <source url="https://rebol.metaeducation.com/t/what-should-the-output-of-trace-look-like/268.rss">What should the output of TRACE look like?</source>
        </item>
        <item>
          <title>About the Debugger category</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Debugger</category>
          <description><![CDATA[
            <p>It's best to walk before you run!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/about-the-debugger-category/267">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/about-the-debugger-category/267</link>
          <pubDate>Thu, 24 Aug 2017 00:29:43 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-267</guid>
          <source url="https://rebol.metaeducation.com/t/about-the-debugger-category/267.rss">About the Debugger category</source>
        </item>
  </channel>
</rss>

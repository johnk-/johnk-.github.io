<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Development - AltRebol</title>
    <link>https://rebol.metaeducation.com/c/development/8</link>
    <description>Topics in the &#39;Development&#39; category Discussion of the development of Rebol itself: language design, implementation and standard library.</description>
    
      <lastBuildDate>Fri, 25 Jul 2025 17:41:49 +0000</lastBuildDate>
      <atom:link href="https://rebol.metaeducation.com/c/development/8.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Optimizing 1-Element PACK!s / SPLICE!s</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p>Historically the most common type of PACK! is the 1-element PACK! holding a ~NULL~ antiform, that you get when a branching statement takes the branch and evaluates to null.</p>
<p>It's not supposed to be the case that antiforms have identity--once you make the transition from a plain form to an antiform, you lose the identity (and also, binding).</p>
<p>So really, every branching statement that returns a PACK!-boxed null can return the same boxed null.  Easy enough optimization--it's already done like that.</p>
<p>I've proposed something strange though... <a href="https://rebol.metaeducation.com/t/the-grand-leading-slash-safety-or-burden-question/2352/7">which is that putting actions in a PACK! be how they are "blessed" as legal to assign to plain WORD</a></p>
<p>I'm hopeful that can work.  But it brings up a question I've wrangled with in the past: <em>is there any way to make this cheap-as-free</em>?</p>
<p>e.g. <strong>Can a single Cell act as a proxy for an immutable array holding only itself?</strong></p>
<p>The idea was scrapped for things like BLOCK!, because you'd wind up with something that had nowhere to put the index or the binding.</p>
<p>But when it comes to PACK! (and SPLICE!...?) the binding requirement is gone, the index requirement is gone.  If the original array was at an index and seen to be one item, you'd just copy that one item out as the single Cell, and do some bit twiddling voodoo to it.</p>
<p>Can it work?</p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>In order to not tax the system too much on behalf of one weird optimization, it seems like you're down two bytes from the get-go: you've got the LIFT_BYTE at ANTIFORM_0 and the KIND_BYTE at TYPE_BLOCK.</p>
<p>Having those two bytes chewed out, it would mean the optimization would have to be something like 64-bit only, to reclaim those two bytes from the unused 32-bits in the header (which are typically unused to allow working on 32-bit platforms).  The other 3 platform pointers may all be used, because they may all contain platform pointers.  So really 64-bit builds only have 32 bits total to exploit.</p>
<p>Would tailored optimizations like this be a great use of that 32-bit advantage?  (As opposed to some cross-cutting feature that presumed to take the 32-bits out of all cells to do something more awesome)?  I don't know.  :-/</p>
<p>Is there some other way to leave the LIFT_BYTE and KIND_BYTE retain the single concent Cell's information, and yet somehow make the answer come back as PACK! without costing too much extra?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>The Cell could offer one bit for this... but it would wreck a lot of other optimizations if that bit didn't live somewhere in the LIFT_BYTE and KIND_BYTE.  The LIFT_BYTE already chews out 1 bit for quasi-ness (you can be both quoted and quasi, or quoted and non-quasi) which limits us to about 127 levels of quoting.  If another bit were sacrificed...let's just say it's the PACK!-bit... then we could say all PACK!s have this bit set, and we're cut down to 63-ish levels of quoting.</p>
<p>So then, if you have a regular PACK! it has the pack bit set...but when you clear the pack bit you see it's still an antiform with a heart that's a block.  And since you can't put PACK!s in packs directly (they're antiforms, they must be lifted) you know you've got a non-optimized pack.  Otherwise, you have a Cell which is the sole content of the pack.</p>
<p>It might seem like a problem that if you try to give back a pointer to the Cell as the content of the array, the only Cell you have in your hand has been corrupted with this pack bit.  So you index into the PACK! to find something that we've established acts as a PACK!.  However...this issue has already been solved for sequences, by an abstraction layer called <strong>"Arraylike"</strong>.  When you have an arraylike thing, you don't ask it for direct addresses of cells to operate on, you give it an index and ask it to fill a temporary Cell with the bits of what's at that index.  So this would be one of those things.</p>
<p><strong>Even if it could be done, this still runs afoul of a lot of the fingerprinting ideas that mask the two bytes in the header to determine its makeup.</strong>  <img src="https://rebol.metaeducation.com/images/emoji/twitter/fingerprint.png?v=14" title=":fingerprint:" class="emoji" alt=":fingerprint:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8557-just-a-placeholder-for-any-more-thoughts-1" class="anchor" href="https://rebol.metaeducation.com#p-8557-just-a-placeholder-for-any-more-thoughts-1"></a>Just a Placeholder For Any More Thoughts</h2>
<p>It's something to keep in mind, but more important to make sure the designs solve the problems, first.</p>
<p>I'm cautiously optimistic about using PACK!'d actions as the "approval" tool to do plain WORD!-assignment, but haven't done it yet, so don't know if it will actually be a good answer.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/optimizing-1-element-pack-s-splice-s/2516">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/optimizing-1-element-pack-s-splice-s/2516</link>
          <pubDate>Fri, 25 Jul 2025 17:41:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2516</guid>
          <source url="https://rebol.metaeducation.com/t/optimizing-1-element-pack-s-splice-s/2516.rss">Optimizing 1-Element PACK!s / SPLICE!s</source>
        </item>
        <item>
          <title>Can VOID, GHOST!, ACTION! Be More Decay-Friendly?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>I wrote about a <a href="https://rebol.metaeducation.com/t/re-imagining-do-next-as-eval-step/767/3">small but important tweak to the behavior of multi-returns</a>, which allowed changing:</p>
<pre><code>[pos :result]: eval:step pos
</code></pre>
<p>Into just:</p>
<pre><code>[pos result]: eval:step pos
</code></pre>
<p>I mention that I believe that that multi-returns with too few values unsetting the variables (vs. panic'ing in the moment) was better in the long run.  e.g. if EVAL:STEP returns just NULL and not a PACK!, then setting POS to NULL and <strong>unsetting</strong> RESULT was an overall win.</p>
<p><em>(Absorbing this requires understanding what modern "unsetness" is...variables truly holding no value, not even TRASH!, and what the implications of this so-called "dual state" are.)</em></p>
<p>I also mention that in practice, it would often be necessary for the result variable to be ^META.  Because if it's not, any non-decayable values would panic.  This wouldn't just happen for ERROR! antiforms (which there's a reasonable probability you'd want to just panic anyway).  It would also happen for GHOST!</p>
<pre><code>; this would panic -&gt; can't decay GHOST! to ordinary result, need ^result
[pos result]: eval:step [comment "hi" ...]
</code></pre>
<p>I'll point out that there's rules about ACTION!s as well, which are that you can't assign actions to plain variables unless they are deemed "unsurprising" (kind of a dicey concept, still being hammered out)</p>
<pre><code>; this would panic -&gt; can't assign ACTION! to plain WORD!, need ^result
[pos result]: eval:step [if okay [lambda [x] [x]] ...]  ; "surprising" action
</code></pre>
<p>We know the new rules for decay of VOID, which is to unset the variable, but what are the implications of that here?</p>
<pre><code>[pos result]: eval:step [foo: void ...]
</code></pre>
<p>That will unset <code>foo</code>, <a href="https://rebol.metaeducation.com/t/should-void-assigns-mean-fully-remove-a-key/2431">because that's now legitimate</a>.</p>
<p>But we're in a bit of an unfortunate position, because if we allow this decay it undermines one of my ideas <em>a little</em>... of saying that the unset state isn't an evaluative result.  (It's still true, in the sense that using <code>^result</code> would expose that the real evaluative state was void...but it feels like a shaky conflation.)</p>
<h2><a name="p-8555-question-on-the-table-can-this-be-easierbetter-1" class="anchor" href="https://rebol.metaeducation.com#p-8555-question-on-the-table-can-this-be-easierbetter-1"></a>Question On The Table: Can This Be Easier/Better?</h2>
<p>Lots to tackle here, but...</p>
<p>I'll start by mentioning an old trick, which was to say that by default EVAL would by default keep stepping to not show you the GHOST!s.</p>
<pre><code>&gt;&gt; [pos result]: eval:step [comment "hello" elide print "world" 10 + 20 ...]
world
== \~['[...] '30]~\  ; antiform
</code></pre>
<p>In that one step, it zoomed you past the GHOST!-producing steps and took you right to the first real result (if any).</p>
<p>That may seem convenient, but it means you need a refinement like :GHOSTABLE to ask to see the invisibles.  I'm kind of annoyed by it.</p>
<p>Another thought would be to give back something "innocuous" as a proxy for invisibility, under the assumption that the default would be not to care:</p>
<pre><code>&gt;&gt; [pos result]: eval:step [comment "hello" elide print "world" 10 + 20 ...]
== \~['[elide print "world" 10 + 20 ...] ~#ghost~]~\  ; antiform
</code></pre>
<p>There you're getting back a TRASH! that's a stable antiform, and it's labeled "<span class="hashtag-raw">#ghost</span>" which cues you to knowing it was a ghost (though it's a conflation, as it could have been a trash that said ghost).  That may be interesting to you for your purposes or it may not--maybe you don't have any particular difference in treatment in your particular evaluator client for things that return ghosts vs. a random thing that produced TRASH!.</p>
<p>So my concept here is: if you were already writing handling for TRASH!, maybe whatever you're doing for trash works well enough for ghosts too.</p>
<p>If we were to lean in this direction, I think it would support the idea that TRASH! is treated like no vote in things like ANY and ALL.  (<a href="https://rebol.metaeducation.com/t/the-truthiness-of-trash/2180/5">Right now it's truthy</a>, but the idea of being no vote is in the same ballpark and has been considered.)</p>
<p>And it might provide an escape hatch for the not-so-nice void problem as well:</p>
<pre><code>&gt;&gt; [pos result]: eval:step [foo: void ...]
== \~['[...] ~#void~]~\  ; antiform
</code></pre>
<p><strong>This would be SET-BLOCK saying that when it unpacks VOID and GHOST! into variables that are non-^META, it doesn't go through "standard decay"... because it doesn't want to conflate no pack item with pack item that's void or ghost.</strong></p>
<p>If we then made things like ANY and ALL treat TRASH! the same as voids/ghosts and just ignore it, then you can see a somewhat coherent plan taking shape, allowing you to get meaningful work done without having to invoke the ^META convention.  <em>"It's all trash to me"</em>, unless you have a reason to discern it.</p>
<h2><a name="p-8555-but-what-about-actions-2" class="anchor" href="https://rebol.metaeducation.com#p-8555-but-what-about-actions-2"></a>But, What About ACTION!s...?</h2>
<p>This question about "how much lying is acceptable" gets us into the weeds a bit here with ACTION!.</p>
<p>I'm trying to narrow down the cases where plain word assignments are allowed to put ACTION!s into words, because of the significant burden that it creates to not know whether variables contain actions or not.</p>
<p>Right now, saying you have to use ^META variables is that tool:</p>
<pre><code>[pos ^result]: eval:step [bar: lambda [x] [x] ...]
</code></pre>
<p>All the lying to make trash out of ghosts and voids wouldn't help a case for generalized eval-stepping if you couldn't step over that.</p>
<p>What could it do?  Return a TRASH! that says just <code>~#action~</code>  ?  Degrade it into a plain FRAME!, instead of an antiform one?</p>
<p>Between those two options, it seems to me producing TRASH! is the better plan.  As with ghost and void, if you find this is in-band of something you truly care about, you could deal with it.</p>
<p>Unfortunately, ACTION!s are truthy.  So we can't really square that with something that's trying to blend with TRASH!</p>
<h2><a name="p-8555-conclusions-3" class="anchor" href="https://rebol.metaeducation.com#p-8555-conclusions-3"></a>Conclusions (?)</h2>
<p>It may just be that if you're doing EVAL:STEP and you aren't completely sure what you're processing, you have to use ^META for the result.</p>
<p>I'm not 100% thrilled with the idea of not being able to distinguish:</p>
<pre><code>[x y]: pack [1 + 2 void]  ; will unset y

[x y]: pack [1 + 2]  ; will unset y
</code></pre>
<p>And only being able to tell the difference if you write:</p>
<pre><code>[x ^y]: pack [1 + 2 void]  ; ^y will hold void

[x ^y]: pack [1 + 2]  ; will unset y
</code></pre>
<p>But if it does that, is there any good reason for GHOST! not to do it too, so that at least if you think they both should be handled the same way that you only have to write one set of handling?</p>
<pre><code>&gt;&gt; x: comment "hi"
== \~,~\  ; antiform

&gt;&gt; unset? $x
== \~okay~\  ; antiform
</code></pre>
<p>Or is GHOST! &lt;=&gt; TRASH! conflation better?</p>
<pre><code>&gt;&gt; x: comment "hi"
== \~,~\  ; antiform

&gt;&gt; trash? ^x
== \~okay~\  ; antiform
</code></pre>
<h2><a name="p-8555-calm-down-people-it-was-just-a-little-liehttpswwwyoutubecomwatchvjuecqo7rz7c-4" class="anchor" href="https://rebol.metaeducation.com#p-8555-calm-down-people-it-was-just-a-little-liehttpswwwyoutubecomwatchvjuecqo7rz7c-4"></a><a href="https://www.youtube.com/watch?v=jUEcqo7Rz7c"><em>"Calm down people... it was just a little lie..."</em></a></h2>
<p><strong>This is tough, because plain ol' panic was comforting.</strong></p>
<p>But that first lie of saying non-^META assignments of VOID would unset variables led to a generalized principle that PACK!s that are too short to fulfill all their assignments would unset variables.  <strong>Yes it's a lie, but I've thought about this from a lot of angles now, and pretty sure that is the right choice.</strong></p>
<p>That lie wasn't made to stop people from having to ^META variables in packs, it was to stop them from having to <code>:OPTIONALIZE</code> them... which created a conflation.</p>
<p>With this new rule in place, there's the issue of whether these must be equivalent in terms of the effect on X:</p>
<pre><code> x: ...expr...  &lt;=&gt;    [x]: pack [...expr...]

^x: ...expr...  &lt;=&gt;   [^x]: pack [...expr...]
</code></pre>
<p><em>(The appealingness of the ^X case seems like a pretty strong argument for PACK to accept ERROR! by default, <a href="https://rebol.metaeducation.com/t/packs-decaying-to-first-item-when-others-are-error/2514">I think I'm realizing that it is misguided to panic on them and the safety problem should be addressed other ways</a>.)</em></p>
<p>If this rule needs to be true (and I think it does) then a VOID in a pack has to do what a void not in a pack would do... so if the variable is not ^META, it needs to unset it.</p>
<p><strong>Maybe that's the only lie, and we don't need to become pathological liars because of it.</strong></p>
<p>If GHOST! and ACTION! just panic for now when used in non-^META assignments, it just means people processing arbitrary code need to use ^META assignments, and that's basically futureproof (as much as anything here is).</p>
<p>If experience comes to show that more lies have value, we can  cross that bridge when we come to it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/can-void-ghost-action-be-more-decay-friendly/2515">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/can-void-ghost-action-be-more-decay-friendly/2515</link>
          <pubDate>Fri, 25 Jul 2025 15:53:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2515</guid>
          <source url="https://rebol.metaeducation.com/t/can-void-ghost-action-be-more-decay-friendly/2515.rss">Can VOID, GHOST!, ACTION! Be More Decay-Friendly?</source>
        </item>
        <item>
          <title>Packs Decaying To First Item When Others are ERROR!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>The concept of an "undecayable PACK!" came up when I was trying to reason about what should happen when you had things like PACK!s of PACK!s...</p>
<pre><code>&gt;&gt; x: pack [1 2]
== \~['1 '2]~\  ; antiform

&gt;&gt; x 
== 1

&gt;&gt; x: pack [pack [1 2] 3]
== ???
</code></pre>
<p><strong>My belief was that this should panic, rather than do the decay.</strong>  If you truly wanted the first element of an unpacked pack to decay, you could write:</p>
<pre><code>&gt;&gt; [x]: pack [pack [1 2] 3]
== \~[~[1 2]~ '3]~\  ; antiform

&gt;&gt; x
== 1
</code></pre>
<p><strong>This created the notion of an undecayable pack.</strong>  The first cut of the undecayable rule was that  that any pack with an unstable antiform in the first spot (GHOST!, PACK!, ERROR!) would panic if you tried to decay it (vs unpack it).</p>
<h2><a name="p-8553-safety-motivation-dont-let-error-disappear-1" class="anchor" href="https://rebol.metaeducation.com#p-8553-safety-motivation-dont-let-error-disappear-1"></a>Safety Motivation: Don't Let ERROR! Disappear</h2>
<p>Putting ERROR!s in PACK!s isn't the usual way of doing things.  If a function runs and wants to make you aware of an ERROR!, it should typically return that as the main result of a function...not stow it away inside a pack.  Only if it's the main result can it be reacted to by things like EXCEPT.</p>
<p>But some cases don't allow the error to be the sole return result.  For instance, EVALUATE:STEP</p>
<pre><code>[pos ^result]: evaluate:step [fail "abc" ...]
</code></pre>
<p>We need the updated position of the code, even if the code FAIL'd.  Hence, EVALUATE can't make its main result an ERROR! in the case of an error result, it has to give back a PACK! which encodes both the error and the new position.</p>
<p><em>("Has to" is a strong statement... it's possible that the next position could be a field of the error, <a href="https://rebol.metaeducation.com/t/should-evaluate-step-bomb-on-an-error/1491/3">I've discussed some of these odd ideas before</a>.  But it's better to allow errors in packs.)</em></p>
<p>If you don't receive result as ^META, then the ERROR! wouldn't be able to store in the ^result and would panic:</p>
<pre><code>[code result]: evaluate:step [fail "abc" ...]  ; not ^result, so panic
</code></pre>
<p>But what if you didn't store the result at all?</p>
<pre><code>code: evaluate:step [fail "abc" ...]  ; ???
</code></pre>
<p><strong>I feel like that should panic.</strong>  But why should you have to do an assignment to get the panic?</p>
<pre><code>evaluate:step [fail "abc" ...]  ; same behavior as when assigned to `code:` ?
</code></pre>
<p>That would suggest that if a PACK has an ERROR! in <em>any</em> slot, then should the pack decay and not extract that error into a ^META variable, that error becomes a panic.</p>
<p>But this thought leads to another invasive thought...</p>
<h2><a name="p-8553-what-about-errors-in-packs-2" class="anchor" href="https://rebol.metaeducation.com#p-8553-what-about-errors-in-packs-2"></a>...What About ERROR!s In PACK!s?</h2>
<p>I started by talking about undecayability, e.g. you can't put a PACK! in the first position of a PACK! and have it "double decay".  Decaying happens <em>once</em>.</p>
<p>And then I discussed decaying when there's an ERROR! in the pack... suggesting that an error at <em>any</em> position (not just the first) which is not unpacked into a ^META-variable should panic.</p>
<p>But what if you have a PACK! that's <em>not</em> in the first position of a PACK!... ?  Should that be willing to decay silently?</p>
<pre><code>&gt;&gt; x: pack [1 pack [2 3]]
== 1  ; silently discarded PACK! in second position...
</code></pre>
<p>That may seem harmless, BUT, what if that PACK! contained an ERROR! ?</p>
<p><em>This led me to theorize that packs which contained unstable antiforms at any position would be "undecayable"</em></p>
<p>However, that started to feel too strict, when we look at:</p>
<pre><code>[code result]: evaluate:step [pack [1 2] ...]  ; works, result decays to 1

code: evaluate:step [pack [1 2] ...]  ; innocuous, why shouldn't it work?
</code></pre>
<p>And even if I'm assigning the result, <a href="https://rebol.metaeducation.com/t/should-set-word-s-propagate-undecayed-packs/2178">PACK!s propagate in assignments now by default</a></p>
<pre><code>while [[code result]: evaluate:step code] [
    ...
]
</code></pre>
<p>It would be a shame if this decayed a PACK! for result, and then refused to decay it for the WHILE, making you write:</p>
<pre><code>while [[{code} result]: evaluate:step code] [
    ...
]
</code></pre>
<p>So pre-emptively refusing to toss PACK!s just because they <em>might</em> contain an ERROR! doesn't seem very ergonomic.</p>
<h2><a name="p-8553-non-first-item-recursive-pack-decay-search-for-error-3" class="anchor" href="https://rebol.metaeducation.com#p-8553-non-first-item-recursive-pack-decay-search-for-error-3"></a>Non-First Item Recursive PACK! Decay Search For ERROR!</h2>
<p>So... what if any PACK!s which aren't in the first position, that you want to discard, will recursively unpack themselves looking for ERROR!, and if they find any then panic?</p>
<p>(And ERROR!s which aren't in the first position, and aren't in PACK!, are also sources of panic?)</p>
<p>This would make the system more robust to dropping errors on the floor.  This might make it more reasonable to say that PACK is willing to pack up errors, generally... today you have to use a special operation:</p>
<pre><code> pack [1020 fail "won't work"]  ; panics 

 pack* [1020 fail "will work"]  ; allows the error
</code></pre>
<p>It's a little bit disconcerting, to imagine that instead of erroring at the moment of the PACK you trust that wherever the pack is going will handle the error.  But really, that only becomes a problem when you're dealing with using PACKs in non-multi-return situations, e.g. you make a PACK and then put it in suspended animation somewhere.</p>
<p>If you're <em>not</em> putting packs in suspended animation, but "packing with the intent of unpacking", then you're leaving it up to the recipient as to whether they want the error or not.</p>
<p>All things being equal, having just one PACK primitive is preferable.</p>
<p>Things do seem to be falling into place in other ways, and I'm sensing that maybe the right thing to do is to say that if you're a client with "pack with intent to store", then you bear the burden of the indefinite lifetime you may give errors in that pack...vs. making it harder to put errors in packs.</p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/packs-decaying-to-first-item-when-others-are-error/2514">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/packs-decaying-to-first-item-when-others-are-error/2514</link>
          <pubDate>Fri, 25 Jul 2025 04:59:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2514</guid>
          <source url="https://rebol.metaeducation.com/t/packs-decaying-to-first-item-when-others-are-error/2514.rss">Packs Decaying To First Item When Others are ERROR!</source>
        </item>
        <item>
          <title>Should `[: . /]` Require Escaping In RUNE! ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Lexer</category>
          <description><![CDATA[
            <p>Should it be:</p>
<pre><code>&gt;&gt; second "a.b"
== #.
</code></pre>
<p>Or should it be:</p>
<pre><code>&gt;&gt; second "a.b"
== #"."
</code></pre>
<p>The ramifications here are that if these delimiters are RUNE! contents without escaping, then you can't put RUNE! inside of [CHAIN! PATH! TUPLE!]</p>
<pre><code>&gt;&gt; type of #a/b
== \~{rune!}~\  ; antiform  (e.g. not a PATH!)
</code></pre>
<h2><a name="p-8536-you-can-put-the-space-rune-in-sequences-today-1" class="anchor" href="https://rebol.metaeducation.com#p-8536-you-can-put-the-space-rune-in-sequences-today-1"></a>You Can Put the SPACE RUNE! In Sequences Today</h2>
<p>I haven't questioned it lately, but the <a href="https://rebol.metaeducation.com/t/reified-unreassignable-nothingness-space-runes/2457">SPACE character (now denoted by an underscore)</a> is what's used to indicate there's nothing in a PATH!/TUPLE!/CHAIN! slot:</p>
<pre><code>&gt;&gt; second first [:a]
== a

&gt;&gt; first first [:a]
== _
</code></pre>
<p>That doesn't mean that all RUNE! have to be legal.  It could be the only one that is.</p>
<h2><a name="p-8536-single-hash-is-the-biggest-loss-2" class="anchor" href="https://rebol.metaeducation.com#p-8536-single-hash-is-the-biggest-loss-2"></a>Single-Hash Is The Biggest Loss</h2>
<p>When I think about how one might use RUNE! in tuples or paths or chains, the patterns I think are most likely to be interesting for dialects would be those that just put hash marks in spots.  An example of the kinds of patterns:</p>
<pre><code>a:#:c

#:#:#

#:b:#
</code></pre>
<p>If you look at the problem with those glasses, you might question the value of:</p>
<pre><code>&gt;&gt; to text! #:#:#
== ":#:#"
</code></pre>
<p>But how you see such things depends on what examples you're comparing it to.</p>
<p>Note that if you just want the characters, <code>[: / .]</code> are WORD!</p>
<pre><code>&gt;&gt; parse "./:" ['. '/ ':]
== :
</code></pre>
<p>So you already have a 2-character means of matching them in strings, for that purpose...that looks cleaner than:</p>
<pre><code>&gt;&gt; parse "./:" [#. #/ #:]
== #:
</code></pre>
<h2><a name="p-8536-the-legality-of-space-twists-my-arm-a-bit-3" class="anchor" href="https://rebol.metaeducation.com#p-8536-the-legality-of-space-twists-my-arm-a-bit-3"></a>The Legality of SPACE Twists My Arm A Bit</h2>
<p>I did say that just because space runes are legal doesn't mean all runes need to be legal.  But it does make me more inclined to say they are.</p>
<p>My leaning here is to say you have to escape them.  I think the hash character in tuple!/path!/chain! has more potential for enabling novel features than worrying over slightly briefer character notations.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-require-escaping-in-rune/2511">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-require-escaping-in-rune/2511</link>
          <pubDate>Fri, 18 Jul 2025 05:42:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2511</guid>
          <source url="https://rebol.metaeducation.com/t/should-require-escaping-in-rune/2511.rss">Should `[: . /]` Require Escaping In RUNE! ?</source>
        </item>
        <item>
          <title>DATATYPE! vs. TYPE!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>Historical Rebol made the decision to call things like BLOCK! and INTEGER! "datatypes".</p>
<p>They were thus DATATYPE! and not TYPE!.</p>
<p>For a long time I thought that was unnecessarily wordy.  At some point I had a change of heart, and decided that I liked it.</p>
<p><em>I don't remember why I changed my mind, and can't find a post about that here.</em></p>
<p>It does have an advantage in the code as it stands, because internally <code>Type</code> is an enumeration (with an escape value in the enumeration as <code>TYPE_0</code> for <a href="https://rebol.metaeducation.com/t/extension-types-implementation/1203">extension types</a>)</p>
<p>Now that <a href="https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324">DATATYPE! is an antiform</a>, I do sort of appreciate it being a little "weirder" in its name.</p>
<p>But it's a decision that if it's going to be revisited, it needs to be revisited sooner rather than later.  It would be nice if I could remember why I thought there was a drawback to using just the name <code>TYPE!.</code></p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/datatype-vs-type/2510">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/datatype-vs-type/2510</link>
          <pubDate>Thu, 17 Jul 2025 10:58:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2510</guid>
          <source url="https://rebol.metaeducation.com/t/datatype-vs-type/2510.rss">DATATYPE! vs. TYPE!</source>
        </item>
        <item>
          <title>WasmGC - Garbage Collection In WebAssembly</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>WASM</category>
          <description><![CDATA[
            <p>There's not a whole lot of code for the Ren-C garbage collector.</p>
<p>The lack of code is good and bad.  On the bad side, it's not very fast or clever (though the Stub and Cell formats themselves are very clever).  On the good side, it means that it could maybe be swapped out with a more sophisticated one, or a GC that integrates better with its specific environment.</p>
<p>One emerging possibility in the WebAssembly build is WasmGC:</p>
<p><a href="https://github.com/WebAssembly/gc/blob/main/proposals/gc/Overview.md" class="inline-onebox">gc/proposals/gc/Overview.md at main · WebAssembly/gc · GitHub</a></p>
<p>I'm not sure exactly how much of a sacrifice of the design it would be to use such things.  All the sizes and bits are very precisely arranged, and it may be that in order to make use of a generalized garbage collector you have to give up control of struct layout and put everything in a form that the generic GC expects.</p>
<p>But it's something to look at.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/wasmgc-garbage-collection-in-webassembly/2509">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/wasmgc-garbage-collection-in-webassembly/2509</link>
          <pubDate>Wed, 16 Jul 2025 22:38:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2509</guid>
          <source url="https://rebol.metaeducation.com/t/wasmgc-garbage-collection-in-webassembly/2509.rss">WasmGC - Garbage Collection In WebAssembly</source>
        </item>
        <item>
          <title>Using ~null~ and ~okay~ instead of NULL and OKAY</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>When I first proposed some of the ideas like quasiforms, they were quite foreign.</p>
<p>Now they're familiar.  Given their familiarity, I start to wonder if the "weird" nature of null and okay is tolerable for source code.  e.g. might you write:</p>
<pre><code> var: ~null~
</code></pre>
<p>...instead of...:</p>
<pre><code>var: null
</code></pre>
<p>It's a bit annoying to type, but if you get used to it, it's not necessarily bad to stand out in that way.</p>
<p>Not that this should matter too much, but using <code>~null~</code> is inherently faster.  There's no variable to look up... you're just turning a WORD! at the quasiform lift level to the antiform lift level.  (Technically that does require validation, since not all quasi-words are legal anti-words, but this validation can be arbitrarily fast.)</p>
<p>One negative side of using the quasiforms is it may add noise where it's not something you want to emphasize.  As such, maybe this is a decision to be made on a case-by-case basis... do you want to draw attention or not, like... "HEY, I'm setting this to NULL and that's an important point!"</p>
<p>Not sure.  But I find myself tempted to use the quasiform now and again, and usually decide to back it out because I feel like it should be "always do it" or "never do it".  But maybe that's the worng dichotomy.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/using-null-and-okay-instead-of-null-and-okay/2508">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/using-null-and-okay-instead-of-null-and-okay/2508</link>
          <pubDate>Mon, 14 Jul 2025 07:33:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2508</guid>
          <source url="https://rebol.metaeducation.com/t/using-null-and-okay-instead-of-null-and-okay/2508.rss">Using ~null~ and ~okay~ instead of NULL and OKAY</source>
        </item>
        <item>
          <title>Picking Function Arguments By Integer</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p><a href="https://rebol.metaeducation.com/t/introducingnew-chain-datatype/2226">Having concepts like CHAIN!</a> means there are "set integers" now, which has opened up the possibility for things like:</p>
<pre><code>sub1000: specialize subtract/ [2: 1000]
</code></pre>
<p>This would prevent you from having to specifically know the name of the argument you are specializing.  That seems sensible, given that you don't need to know the name to call it.</p>
<p>It seems you should also be able to do this with frames:</p>
<pre><code>&gt;&gt; f: make frame! subtract/

&gt;&gt; f.1: 1020
&gt;&gt; f.2: 1000

&gt;&gt; eval f
== 20
</code></pre>
<p><strong>It should not work with refinements.</strong>  Rebol2/Red/R3-Alpha expose the implementation detail of what position refinement arguments are in, but it was a bad idea for them... and an even worse idea for Ren-C.</p>
<p>Consider AUGMENT, for example.  Let's make an arity-3 version of APPEND, that takes an argument to add before appending:</p>
<pre><code>&gt;&gt; apadd: adapt (augment append/ [num [integer!]]) [
       value: value + num
   ]

&gt;&gt; apadd [a b c] 1000 20
== [a b c 1020]
</code></pre>
<p>Do take a moment to appreciate how cool that is... AUGMENT creates a function with an expanded specification (but no variation in behavior), and then ADAPT puts in a preamble which uses the added parameter by adding it to the value...before falling through to the ordinary implementation of APPEND.  (ENCLOSE could be used if you had a more complicated idea for what to do that didn't fit as just an adjustment in a preamble.)</p>
<p>BUT once you're finished appreciating how cool that is, consider what we want if we make a frame for APADD:</p>
<pre><code>&gt;&gt; f: make frame! apadd/

&gt;&gt; f.1: [a b c]
&gt;&gt; f.2: 1000
&gt;&gt; f.3: 20

&gt;&gt; eval f
== [a b c 1020]
</code></pre>
<p>However, consider that it also has refinements available:</p>
<pre><code>&gt;&gt; apadd:dup [a b c] 1000 20 3
== [a b c 1020 1020 1020]
</code></pre>
<p><strong>So we see that the new non-refinement argument properly indexes as the 3rd argument, and it could not do that if refinements were INTEGER!-indexed.</strong>  Because if :DUP was something like index 3 in the frame for APPEND originally, it wouldn't be out of the way of the augmented form.</p>
<p>Seems pretty good, but there are some quirks...</p>
<h2><a name="p-8514-lens-matters-1" class="anchor" href="https://rebol.metaeducation.com#p-8514-lens-matters-1"></a>Lens Matters</h2>
<p>I've written a bit about <strong><a href="https://rebol.metaeducation.com/t/understanding-frame-lensing/1645">FRAME! Lensing</a></strong>.  It's not just an efficiency trick...because I wouldn't know how to implement function composition otherwise.</p>
<p>Because of Lenses, a frame built for a function with the same positionality can expose different interfaces.  Consider our APADD above, imagine specializing the thing you append to:</p>
<pre><code>&gt;&gt; data: [a b c]

&gt;&gt; accrue: specialize apadd/ [data]

&gt;&gt; accrue 1000 20
== [a b c 1020]

&gt;&gt; accrue 300 4
== [a b c 1020 304]
</code></pre>
<p>So now, we would hope that ACCRUE thinks of its 1 and 2 parameters as being what APADD thought of as 2 and 3.</p>
<pre><code>&gt;&gt; f: make frame! accrue/

&gt;&gt; f.1: 400
&gt;&gt; f.2: 21

&gt;&gt; eval f
== [a b c 1020 304 421]
</code></pre>
<p><strong>Satisfying!</strong></p>
<h2><a name="p-8514-but-what-does-integer-indexing-mean-with-no-lens-2" class="anchor" href="https://rebol.metaeducation.com#p-8514-but-what-does-integer-indexing-mean-with-no-lens-2"></a>But What Does Integer Indexing Mean With <em>No Lens</em> ?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></h2>
<p>There's a point where all the Lenses are gone, and you are in the raw function implementation... the FRAME! as the underlying implementation expected to see it.  If you do a FOR-EACH on a frame in this view, you see everything.. refinements, locals, definitional RETURN (if there is one).</p>
<pre><code>&gt;&gt; foo: func [arg1 :refine1 arg2 :refine2 &lt;local&gt; local1] [
       let frame: binding of $arg1
       for-each 'key frame [probe key]
   ]

&gt;&gt; foo 1020
return
arg1
refine1
arg2
refine2
local1
</code></pre>
<p>What (if anything) does indexing mean at this level?  <strong>frame.1</strong> giving you back the definitional RETURN would be barely useful... probably even <em>anti</em>-useful.</p>
<p><strong>I think it's pretty clear the integer indexing on an unlensed frame should act as if you were seeing the frame from the perspective of a caller with the "default Lens", e.g. what someone who did MAKE FRAME! would see.</strong></p>
<p>So <strong>frame.1</strong> would give you arg1, and <strong>frame.2</strong> would give you arg2, and that would be it.</p>
<h2><a name="p-8514-should-object-offer-indexed-access-3" class="anchor" href="https://rebol.metaeducation.com#p-8514-should-object-offer-indexed-access-3"></a>Should OBJECT! Offer Indexed Access?</h2>
<p>I've settled that FRAME! should offer it.  Here we see it has the interesting consequence that not all frame fields can be accessed with integer indexes, only</p>
<p>But I don't know what--if anything--this implies for OBJECT!.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/picking-function-arguments-by-integer/2507">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/picking-function-arguments-by-integer/2507</link>
          <pubDate>Mon, 14 Jul 2025 06:23:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2507</guid>
          <source url="https://rebol.metaeducation.com/t/picking-function-arguments-by-integer/2507.rss">Picking Function Arguments By Integer</source>
        </item>
        <item>
          <title>When Should Evaluative Constructs Return ERROR! ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p><strong><a href="https://rebol.metaeducation.com/t/panic-vs-return-fail-the-age-of-definitional-errors/1852">Definitional failures</a></strong> have been critical in moving to a robust model of error handling.</p>
<p>They're an ergonomic concept something like Rust's <strong><code>Result&lt;...&gt;</code></strong>, because they effectively multiplex errors onto a function's return value.  You're expected to triage errors at the moment they happen at a callsite or they promote to divergent panics...which are <a href="https://rebol.metaeducation.com/t/discouraging-the-interception-of-abrupt-failures/1871">not generally intended to be reacted to</a>--your program is conceptually terminated.  To make triage easier there is <a href="https://rebol.metaeducation.com/t/virtual-binding-based-error-propagation-operator/2389">TRAP, the error propagator</a>.</p>
<p><strong>Compared with R3-Alpha and Red's error-handling, this is night and day.</strong>  They are fundamentally broken/useless.  <em>(Curiously: <a href="https://rebol.metaeducation.com/t/rebol2s-hot-errors-abandoned-by-r3-alpha-red/2505">Rebol2 actually had a concept of "hot errors"</a>, that leaned in the direction of definitional errors, but that direction wasn't pushed through.)</em></p>
<hr>
<h2><a name="p-8504-non-terminal-eval-steps-that-dont-triage-will-panic-1" class="anchor" href="https://rebol.metaeducation.com#p-8504-non-terminal-eval-steps-that-dont-triage-will-panic-1"></a>Non-Terminal Eval Steps That Don't Triage Will Panic</h2>
<p>You can triage an ERROR! that's a result of an expression.  But only if it's the final step:</p>
<pre><code>&gt;&gt; error? (print "Error is last" 1 / 0)
Error is last
== \~okay~\  ; antiform

&gt;&gt; error? (1 / 0 print "Error is first")
** PANIC: attempt to divide by zero
</code></pre>
<p>Any evaluation product that comes after an ERROR! will cause a panic.</p>
<p>GHOST! is not exempt:</p>
<pre><code>&gt;&gt; error? (1 / 0 comment "no free pass for ghosts")
** PANIC: attempt to divide by zero
</code></pre>
<p>The reasoning is that just because a function returns a ghost, doesn't mean it doesn't have side effects... or doesn't depend in some way on the previous operation.</p>
<p>Currently, COMMA! isn't exempt, either:</p>
<pre><code>&gt;&gt; error? (1 / 0,)
** PANIC: attempt to divide by zero
</code></pre>
<p>This is something I might be willing to bend on, if we believe that:</p>
<pre><code>(
    some expression,
    another expression,
    yet another expression,
)
</code></pre>
<p>Absolutely has to be equivalent to:</p>
<pre><code>(
    some expression,
    another expression,
    yet another expression
)
</code></pre>
<p>But mechanically you'd have to scan ahead for any number of commas... and make sure you were at the end of the input after consuming all the commas.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/man_shrugging.png?v=14" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8504-plain-eval-would-act-the-same-as-the-group-above-2" class="anchor" href="https://rebol.metaeducation.com#p-8504-plain-eval-would-act-the-same-as-the-group-above-2"></a>Plain EVAL would act the same as the GROUP! above</h2>
<p>Only the last step can give an ERROR!.  Previous steps will panic.</p>
<p>And since branching constructs like an IF or a CASE statement uses EVAL to run their branches, they similarly drop the statement out at the last step. So you can synthesize ERROR! out of branches, without causing the branching construct to panic.</p>
<h2><a name="p-8504-evaltrap-name-pending-gives-error-at-any-step-3" class="anchor" href="https://rebol.metaeducation.com#p-8504-evaltrap-name-pending-gives-error-at-any-step-3"></a>"EVAL:TRAP" (name pending) Gives Error At Any Step</h2>
<p>I've proposed EVAL:TRAP as a variation which can stop the evaluation at any step that produces an ERROR!:</p>
<pre><code>&gt;&gt; error? eval:trap [print "Error is last" 1 / 0]
Error is last
== \~okay~\  ; antiform

&gt;&gt; error? (1 / 0 print "Error is first")
== \~okay~\
</code></pre>
<p>So the second case didn't make it to the PRINT, but it didn't PANIC.</p>
<h1><a name="p-8504-but-how-about-any-and-all-roll_eyes-4" class="anchor" href="https://rebol.metaeducation.com#p-8504-but-how-about-any-and-all-roll_eyes-4"></a>But How About ANY and ALL...?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/roll_eyes.png?v=14" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></h1>
<p>The answer may be different.</p>
<p>You're supposed to reasonably be able to rely on the idea that if ALL gives you a result, it's the result of the final expression.  You thus might be thinking that if you get an error, that error is coming by contract from that last expression.  I'd say it seems reasonably clear that anything but the last expression should panic.</p>
<p>On the other hand...ANY is not expected to necessarily evaluate all of its clauses... it's supposed to return the first thing that passes its constraint (non-null as the default constraint).  So if it hit an ERROR! early, maybe it should return it?</p>
<p>I'm not sure.  I'll have to look at use cases.</p>
<h1><a name="p-8504-and-what-about-loops-5" class="anchor" href="https://rebol.metaeducation.com#p-8504-and-what-about-loops-5"></a>And What About Loops?</h1>
<p>If loops are willing to return definitional errors out of their body, that makes writing loop wrappers a bit trickier.</p>
<p>First let's ask about MAP-EACH, what should it do?</p>
<pre><code>map-each 'x [1 2 3] [either x = 2 [fail "some error"] [x * 10]]
</code></pre>
<p>You're getting behaviors that are somewhat equivalent to APPEND.  So it's like you wrote:</p>
<pre><code>list: []
append list x * 10
append list fail "some error"
</code></pre>
<p>APPEND doesn't propagate a failure like that.  And I don't see any reason why it should.</p>
<p>Next, let's consider wrapping loops... e.g. <a href="https://rebol.metaeducation.com/t/demonstrating-for-both-loop-composability-for-the-win/1833">the current formulation of FOR-BOTH</a>:</p>
<pre><code>for-both: func [var blk1 blk2 body] [
    return unlift:lite all [
        lift:lite for-each var blk1 body
        lift:lite for-each var blk2 body
    ]
]
</code></pre>
<p>At the moment, LIFT does not lift definitional errors by default, but panics on them.</p>
<p>So if FOR-EACH is willing to return definitional errors, then you won't get an equivalence between:</p>
<pre><code>for-each 'x [1] [fail "some error"]  ; definitional error result

for-both 'x [1] [] [fail "some error"]  ; panic

for-both 'x [] [1] [fail "some error"]  ; panic
</code></pre>
<p>It might seem that given what I say about ALL above, if LIFT:LITE were willing to leave ERROR! as ERROR! (as well as NULL as NULL, and GHOST! as GHOST!) then it would correctly panic on errors that weren't the last step... BUT... consider:</p>
<pre><code>all [
    fail "some error"
    comment "hmmm"
]
</code></pre>
<p>This runs afoul of my concept of not allowing a next step to run... producing a loophole in composition that is trying to leverage things like invisibility.</p>
<p><strong>This seems to be the crux of a fairly fundamental problem, regarding the need to be psychic in order to know whether an evaluation is going to be a no-op or not.</strong></p>
<p>If you're not looking at the loop data, but tell from the outside of the FOR-EACH after-the-fact if it had evaluations or not, then there's no way to know if a failure needs to be terminal.</p>
<p><em>This suggests that loops should probably panic if the body fails.</em>  They'd have to do so for any step except the last step anyway, and loops don't have an interface for psychically exposing if they're at the last step or not prior to execution.  It defeats composition to require otherwise, and the whole model would have to be redesigned to add this "psychic" aspect... which seems less easy than just saying "no, loops panic if the body fails".</p>
<h2><a name="p-8504-overall-carry-away-theres-subtleties-6" class="anchor" href="https://rebol.metaeducation.com#p-8504-overall-carry-away-theres-subtleties-6"></a>Overall Carry-away: There's Subtleties</h2>
<p>Decisions about definitional error propagation appear to be non-obvious.</p>
<p>panic-ing is a conservative default, and then you can get people to explicitly CATCH and THROW the errors if they need to work around it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/when-should-evaluative-constructs-return-error/2506">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/when-should-evaluative-constructs-return-error/2506</link>
          <pubDate>Thu, 10 Jul 2025 11:39:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2506</guid>
          <source url="https://rebol.metaeducation.com/t/when-should-evaluative-constructs-return-error/2506.rss">When Should Evaluative Constructs Return ERROR! ?</source>
        </item>
        <item>
          <title>Code Completion As CAPS-LOCK... Way Better Than Tab</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>C/C++ Implementation</category>
          <description><![CDATA[
            <p>The overloading of the tab key to mean "indent" and "complete code" has always been pretty horrible.  Now it's intolerable: suggestions from AI come out of the blue at any moment, and can hijack what would have been an indent nanoseconds before.  The tab key becomes completely unreliable in function.</p>
<p>This infuriated me enough to do something about it.</p>
<p>I decided to turn Caps Lock into an actually useful key.</p>
<p>It isn't too hard to do... <em>if you know what to do</em>.  Here's a handy guide.</p>
<h2><a name="p-8498-windows-powertoys-keyboard-managerhttpsgithubcommicrosoftpowertoystabreadme-ov-file-1" class="anchor" href="https://rebol.metaeducation.com#p-8498-windows-powertoys-keyboard-managerhttpsgithubcommicrosoftpowertoystabreadme-ov-file-1"></a>WINDOWS: <a href="https://github.com/microsoft/PowerToys?tab=readme-ov-file">PowerToys Keyboard Manager</a></h2>
<p>VSCode is actually able to map the caps lock key to completion without any special tools... BUT... <em>it won't stop the key from toggling the caps-lock state</em>.  If your caps lock has a light it will go on and off, and each time you do a completion it will toggle the casing.</p>
<p>So use <a href="https://github.com/microsoft/PowerToys?tab=readme-ov-file">Microsoft PowerToys</a>  <em>(it's open source!)</em>, specifically the <strong>Keyboard Manager</strong></p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/8d1de5ca96aaa4f3b77498e7cee347110cdc3217.png" data-download-href="https://rebol.metaeducation.com/uploads/default/8d1de5ca96aaa4f3b77498e7cee347110cdc3217" title="image"><img src="https://rebol.metaeducation.com/uploads/default/original/1X/8d1de5ca96aaa4f3b77498e7cee347110cdc3217.png" alt="image" data-base62-sha1="k8nntHpu3b9V1VPvvya970uaYqb" width="497" height="332"></a></div><p></p>
<p>I've remapped the CAPS LOCK key to <strong>F19</strong>.  My keyboard only has 12 function keys, so I'm not bumping anything I'd use out of the way.</p>
<p><em>(At first I didn't realize these extra function keys were available... and tried the "virtual keys" you can assign, with names "VK 1" up to "VK 252".  But choosing something in this range is a bit fraught... e.g. VK 1 is actually the mouse button.  And they show up in VSCode as "unknown" in the keyboard mapping.)</em></p>
<p>The strange choice of F19 (when it goes up to F24) is because the Mac solution can only go up to F20, and the Linux solution has a default collision that you have to do special overrides for F20.  If you want to be able to share your keymaps across your computers, F19 seems a good choice.</p>
<h2><a name="p-8498-apple-karabiner-elementshttpskarabiner-elementspqrsorg-2" class="anchor" href="https://rebol.metaeducation.com#p-8498-apple-karabiner-elementshttpskarabiner-elementspqrsorg-2"></a>APPLE: <a href="https://karabiner-elements.pqrs.org/">Karabiner Elements</a></h2>
<p>So the Mac lets you swap the Caps Lock for another modifier key (like Shift or Ctrl), or disable it entirely.  But you can't make it do anything specific as a key out of the box.</p>
<p>A program called <a href="https://karabiner-elements.pqrs.org/">Karabiner Elements</a> does a bunch of useful things ("and it's only a hundred megabytes")  <img src="https://rebol.metaeducation.com/images/emoji/twitter/roll_eyes.png?v=14" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></p>
<p>You'll have to approve a list of scary-sounding permissions that you are installing an app and driver that sees every key that you press.  But, Karabiner Elements is also open source:</p>
<p><a href="https://github.com/pqrs-org/Karabiner-Elements">https://github.com/pqrs-org/Karabiner-Elements</a></p>
<p>And they seem generally trustworthy enough in the scheme of things, to use their binaries, but... I guess it depends on how badly you want to remap the Caps Lock key.</p>
<p><em>(Disdain for all of this is certainly why Carl was aiming to have a Rebol OS.)</em></p>
<p>It's in "Simple Modifications":</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/4b057513043b5c269a8379553672de353272cad0.png" data-download-href="https://rebol.metaeducation.com/uploads/default/4b057513043b5c269a8379553672de353272cad0" title="image"><img src="https://rebol.metaeducation.com/uploads/default/optimized/1X/4b057513043b5c269a8379553672de353272cad0_2_517x124.png" alt="image" data-base62-sha1="aHFv9Lz7QcXbLTdJbvgRW1CiJ5S" width="517" height="124" srcset="https://rebol.metaeducation.com/uploads/default/optimized/1X/4b057513043b5c269a8379553672de353272cad0_2_517x124.png, https://rebol.metaeducation.com/uploads/default/optimized/1X/4b057513043b5c269a8379553672de353272cad0_2_775x186.png 1.5x, https://rebol.metaeducation.com/uploads/default/optimized/1X/4b057513043b5c269a8379553672de353272cad0_2_1034x248.png 2x" data-dominant-color="E8EAED"></a></div><p></p>
<p>Note that if you previously had the OS doing mappings of your modifier keys, this overrules that.  So you'll have to reconfigure your swappings of Command/Ctrl/Fn/etc.</p>
<h2><a name="p-8498-linux-keydhttpsgithubcomrvaiyakeyd-key-daemon-3" class="anchor" href="https://rebol.metaeducation.com#p-8498-linux-keydhttpsgithubcomrvaiyakeyd-key-daemon-3"></a>LINUX: <a href="https://github.com/rvaiya/keyd"><code>keyd</code></a> (key daemon)</h2>
<p>You would think a configuration thing like this would be easy on Linux, but it took me and the AI quite a while of trying things with no effect before a solution was found.</p>
<p>There are files that <em>look</em> like editing them should be able to produce the desired effect.  The files <code>/usr/share/X11/xkb/symbols/pc</code> and <code>/usr/share/X11/xkb/keycodes/evdev</code> sure look like source code for specifying the entirety of your keyboard's behavior.  But when it comes to the caps lock key, no dice--about the best I could accomplish was get it to not do anything (even though the light on the key toggled on and off).</p>
<p>The keyd project seems to be the right solution to this problem, and works on x11 or Wayland, and it's got some cool features too.  But it's not in the Debian repositories so you have to build it from source:</p>
<pre><code>git clone https://github.com/rvaiya/keyd
cd keyd
make
sudo make install
sudo systemctl enable keyd
sudo systemctl start keyd
</code></pre>
<p>Once you've got it, you edit <code>/etc/keyd/default.conf</code>:</p>
<pre><code>[ids]
*

[main]
capslock = f19
</code></pre>
<p>Then you restart the daemon:</p>
<pre><code>$ sudo systemctl restart keyd
</code></pre>
<p>If you're lucky, that should work!  But if your <code>xmodmap</code> contains instructions that route the keys to functions, you won't get them falling through to where VSCode and such can see them.  That's what's wrong with F20, it defaults to mapping the microphone input.  You can see it with a grep for F20's keycode, which is 198:</p>
<pre><code>$ xmodmap -pke | grep 198
keycode 198 = XF86AudioMicMute NoSymbol XF86AudioMicMute
</code></pre>
<p>Your Linux installation might have made other arbitrary choices, perhaps even with F19.</p>
<p>To get into the weeds with xmodmap, you can edit your <code>~/.Xmodmap</code> file:</p>
<pre><code>keycode 198 = F20
</code></pre>
<p>Load it to see the changes:</p>
<pre><code>$ xmodmap ~/.Xmodmap
</code></pre>
<p>For me, that worked to let me map it for F20.  But in this handy guide, I'm just suggesting using F19 so you don't have to go further with adding that xmodmap persistently to your startup files.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/code-completion-as-caps-lock-way-better-than-tab/2504">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/code-completion-as-caps-lock-way-better-than-tab/2504</link>
          <pubDate>Mon, 07 Jul 2025 11:36:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2504</guid>
          <source url="https://rebol.metaeducation.com/t/code-completion-as-caps-lock-way-better-than-tab/2504.rss">Code Completion As CAPS-LOCK... Way Better Than Tab</source>
        </item>
        <item>
          <title>Some IPv6 Address Examples</title>
          <dc:creator><![CDATA[rebolbot]]></dc:creator>
          <category>Lexer</category>
          <description><![CDATA[
            <blockquote>
<p>If someone is going to parse ipv6 addresses, can you give a good spread of examples of the edge cases and things to worry about?  A good list of ipv6 addresses that is fairly short but gives coverage of the kinds of things you need to support?</p>
</blockquote>
<hr>
<h1><a name="p-8454-ipv6-address-parsing-test-cases-1" class="anchor" href="https://rebol.metaeducation.com#p-8454-ipv6-address-parsing-test-cases-1"></a>IPv6 Address Parsing Test Cases</h1>
<h2><a name="p-8454-basic-format-variations-2" class="anchor" href="https://rebol.metaeducation.com#p-8454-basic-format-variations-2"></a>Basic Format Variations</h2>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">2001:0db8:85a3:0000:0000:8a2e:0370:7334     # Full format
2001:db8:85a3:0:0:8a2e:370:7334             # Leading zeros omitted
2001:db8:85a3::8a2e:370:7334                # Zero compression
</code></pre>
<h2><a name="p-8454-zero-compression-edge-cases-3" class="anchor" href="https://rebol.metaeducation.com#p-8454-zero-compression-edge-cases-3"></a>Zero Compression Edge Cases</h2>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">::1                                         # Loopback (all zeros except last)
::                                          # All zeros address
2001:db8::                                  # Trailing zeros compressed
::2001:db8                                  # Leading zeros compressed
2001::1                                     # Middle zeros compressed
fe80::1%lo0                                 # With zone identifier
</code></pre>
<h2><a name="p-8454-special-addresses-4" class="anchor" href="https://rebol.metaeducation.com#p-8454-special-addresses-4"></a>Special Addresses</h2>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">::ffff:192.0.2.1                           # IPv4-mapped IPv6
::ffff:0:192.0.2.1                         # IPv4-mapped (alternative)
64:ff9b::192.0.2.33                        # IPv4-embedded IPv6
2002:cb00:7100::                            # 6to4 prefix
ff02::1                                     # Multicast
fe80::1                                     # Link-local
fc00::1                                     # Unique local
</code></pre>
<h2><a name="p-8454-bracket-and-port-notation-5" class="anchor" href="https://rebol.metaeducation.com#p-8454-bracket-and-port-notation-5"></a>Bracket and Port Notation</h2>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">[2001:db8::1]:80                            # With port
[::1]:8080                                  # Loopback with port
[fe80::1%eth0]:22                           # Zone ID with port
</code></pre>
<h2><a name="p-8454-maximum-length-cases-6" class="anchor" href="https://rebol.metaeducation.com#p-8454-maximum-length-cases-6"></a>Maximum Length Cases</h2>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff     # All F's (maximum)
2001:0db8:85a3:0000:0000:8a2e:0370:7334     # Full expanded form
</code></pre>
<h2><a name="p-8454-tricky-parsing-cases-7" class="anchor" href="https://rebol.metaeducation.com#p-8454-tricky-parsing-cases-7"></a>Tricky Parsing Cases</h2>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">2001:db8:0:0:1:0:0:1                        # Multiple zero groups (can't compress)
2001:0:0:0:0:0:0:1                          # Could be 2001::1
a:b:c:d:e:f:1:2                             # All single hex digits
::1:2:3:4:5:6:7                             # Compression at start with 7 groups
1:2:3:4:5:6:7::                             # Compression at end with 7 groups
</code></pre>
<h2><a name="p-8454-case-sensitivity-8" class="anchor" href="https://rebol.metaeducation.com#p-8454-case-sensitivity-8"></a>Case Sensitivity</h2>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">2001:DB8:85A3::8A2E:370:7334                # Uppercase
2001:db8:85a3::8a2e:370:7334                # Lowercase
2001:Db8:85A3::8a2E:370:7334                # Mixed case
</code></pre>
<h2><a name="p-8454-invalid-cases-should-reject-9" class="anchor" href="https://rebol.metaeducation.com#p-8454-invalid-cases-should-reject-9"></a>Invalid Cases (Should Reject)</h2>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">2001:db8::1::2                              # Double compression (invalid)
2001:db8:85a3::8a2e:370:7334:extra          # Too many groups
2001:db8:85a3:8a2e:370:7334                 # Too few groups (7 instead of 8)
2001:db8:85ag::1                            # Invalid hex character 'g'
2001:db8:12345::1                           # Group too long (&gt;4 hex digits)
</code></pre>
<h2><a name="p-8454-key-parsing-rules-to-implement-10" class="anchor" href="https://rebol.metaeducation.com#p-8454-key-parsing-rules-to-implement-10"></a>Key Parsing Rules to Implement</h2>
<ol>
<li><strong>Zero Compression</strong>: Only one <code>::</code> allowed per address</li>
<li><strong>Group Count</strong>: Must have exactly 8 groups when expanded</li>
<li><strong>Hex Validation</strong>: Each group is 1-4 hexadecimal digits</li>
<li><strong>Case Insensitive</strong>: Accept both upper and lowercase</li>
<li><strong>Leading Zeros</strong>: Optional in each group</li>
<li><strong>Zone Identifiers</strong>: Handle <code>%</code> suffix for link-local addresses</li>
<li><strong>Brackets</strong>: Required when specifying ports</li>
<li><strong>IPv4 Mapping</strong>: Special handling for <code>::ffff:</code> prefix</li>
</ol>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/some-ipv6-address-examples/2496">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/some-ipv6-address-examples/2496</link>
          <pubDate>Mon, 23 Jun 2025 22:52:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2496</guid>
          <source url="https://rebol.metaeducation.com/t/some-ipv6-address-examples/2496.rss">Some IPv6 Address Examples</source>
        </item>
        <item>
          <title>(TRANSCODE &quot;&quot;) should be empty BLOCK!, not NULL</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Lexer</category>
          <description><![CDATA[
            <p>I faced a circumstance in the CONSOLE, where I wanted to know if you entered nothing.  e.g. if you just hit enter:</p>
<pre><code>&gt;&gt;     ; &lt;-- hit enter here

&gt;&gt;
</code></pre>
<p>So it just cycled, the prompt, no <code>==</code> output.</p>
<p>If you actually loaded the empty code as <code>[]</code> and evaluated it, then you would get a GHOST!.</p>
<pre><code>&gt;&gt;   ; &lt;-- hit enter here
== \~,~\  ; antiform comma! ("ghost!")

&gt;&gt;
</code></pre>
<p>I found that annoying.  However, if you actually did put something in there that evaluated to ghost, I wanted to see it:</p>
<pre><code>&gt;&gt; comment "for example"
== \~,~\  ; antiform comma! ("ghost!")

&gt;&gt;
</code></pre>
<p>So sure, I could write:</p>
<pre><code> let code: transcode ...whatever...

 if [] = code [  ; nothing loaded
     ...cycle prompt, don't evaluate...
 ]
</code></pre>
<p>But I got the feeling that a TRANSCODE of an empty string (or string that is all comments") is probably one of those edge cases that people are probably not expecting... and if it happens you probably need special handling.  So making it have better error locality and handling by being NULL seemed like a good idea.</p>
<p>So I changed it to return NULL if nothing was transcoded.</p>
<pre><code>if not code [  ; (or `if null? code`, or `code else [...]` etc.)
    ...nothing loaded, cycle prompt, don't evaluate...
]
</code></pre>
<p>BUT having experienced some of the epicycles beyond the console, I think this was a mistake.</p>
<h2><a name="p-8447-transcode-has-a-lot-of-error-returns-1" class="anchor" href="https://rebol.metaeducation.com#p-8447-transcode-has-a-lot-of-error-returns-1"></a>Transcode Has A Lot Of ERROR! Returns</h2>
<p>If <strong><code>try transcode ...</code></strong> is going to be useful at all, you probably don't want to conflate the many potential errors it can return with just returning null because it was a valid empty input.</p>
<p>And in the basic case, an empty script is a valid script.  It does nothing.</p>
<p>Emptiness is easy enough to test for.  So I think that's what should be done here.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/transcode-should-be-empty-block-not-null/2495">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/transcode-should-be-empty-block-not-null/2495</link>
          <pubDate>Thu, 19 Jun 2025 21:35:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2495</guid>
          <source url="https://rebol.metaeducation.com/t/transcode-should-be-empty-block-not-null/2495.rss">(TRANSCODE &quot;&quot;) should be empty BLOCK!, not NULL</source>
        </item>
        <item>
          <title>Should $WORD Capture The Whole Binding Environment?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Binding</category>
          <description><![CDATA[
            <p>Right now, when you capture a binding to a WORD!, if it's not bound at that moment, it won't be found later:</p>
<pre><code>&gt;&gt; word: $foo  ; imagine foo is not defined anywhere
== foo

&gt;&gt; get word
** Error: foo is not bound

&gt;&gt; set (extend lib 'foo) 1020  ; add a FOO definition to lib module
== 1020

&gt;&gt; get word
** Error: foo is not bound
</code></pre>
<p>This is because at the moment you wrote <code>$foo</code>, it looked in the current context (which in a case like this in the console includes LIB)... and didn't find it.</p>
<p>Since it didn't find it at the <code>$foo</code> evaluation moment, the word you got was unbound.  It won't magically become bound if something comes along later.</p>
<h2><a name="p-8443-should-things-like-word-store-binding-environments-1" class="anchor" href="https://rebol.metaeducation.com#p-8443-should-things-like-word-store-binding-environments-1"></a>Should Things Like WORD! Store Binding Environments?</h2>
<p>It would change things.  Would it change them for good?</p>
<h3><a name="p-8443-function-arg-survivalhttpsrebolmetaeducationcomtwhat-happens-to-function-args-when-the-call-ends23417-needs-it-due-to-frame-lensinghttpsrebolmetaeducationcomtunderstanding-frame-lensing1645-2" class="anchor" href="https://rebol.metaeducation.com#p-8443-function-arg-survivalhttpsrebolmetaeducationcomtwhat-happens-to-function-args-when-the-call-ends23417-needs-it-due-to-frame-lensinghttpsrebolmetaeducationcomtunderstanding-frame-lensing1645-2"></a><a href="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/17">Function Arg Survival</a> Needs It Due To <a href="https://rebol.metaeducation.com/t/understanding-frame-lensing/1645">FRAME! Lensing</a></h3>
<p>This is what brought the issue to my attention right now (though I've been thinking about it a fairly long time).</p>
<p>The model in which WORD! gets bound to a FRAME! only stores the pointer to the frame, not the Lens that's in effect.</p>
<p>The only way you can know if your "lens" should account for if the function is actually running a body or not is by information carried in the binding chain.  Knowing only the final result--a pointer to the list of variables--is not enough.  You need the specifics of <em>how</em> the result was reached--to know which phase should be considered for lookup of the word.</p>
<h3><a name="p-8443-implementation-simplification-3" class="anchor" href="https://rebol.metaeducation.com#p-8443-implementation-simplification-3"></a>Implementation Simplification</h3>
<p>A win is that there isn't a distinct "kind" of binding for WORD!s that's different from BLOCK!s.  Everything that stores binding would do so in a common way.  That simplifies code.</p>
<h3><a name="p-8443-optimization-loss-of-multiple-gets-4" class="anchor" href="https://rebol.metaeducation.com#p-8443-optimization-loss-of-multiple-gets-4"></a>Optimization Loss Of Multiple Gets</h3>
<p>It does mean losing an optimization on if GET of the same bound word is done multiple times.</p>
<p>The ability to leverage that optimization has become punishingly rare.  Basically every WORD! in the "mostly-unbound world" already can't do much in the way of optimized lookups.</p>
<p>You'd get the benefit that the laziness would help if you didn't actually need to do the lookup resolution.  The "binding capture" is cheap-as-free (just pokes a pointer into a Cell).</p>
<h3><a name="p-8443-this-leaks-much-more-information-but-5" class="anchor" href="https://rebol.metaeducation.com#p-8443-this-leaks-much-more-information-but-5"></a>This Leaks Much More Information... But...</h3>
<p><a href="https://rebol.metaeducation.com/t/performance-and-security-implications-of-binding-leakage/2117">I've written about binding leakage before.</a>  This does make it worse, if you pass someone a WORD! that's bound you'd be passing a lot more information.</p>
<p>But it's always been a problem.  Passing someone a WORD! bound into an object has allowed you to get that object and crawl arbitrarily far, if you have a BINDING OF tool to extract it.</p>
<p>I rarely get bent out of shape over the security implications of these things.  But more just the garbage collector implications.</p>
<p>But I can't get too worked up over if you pass <strong>[a]</strong> instead of just <strong>a</strong> having all the same problems.</p>
<h2><a name="p-8443-biggest-potential-complaint-lost-invariant-6" class="anchor" href="https://rebol.metaeducation.com#p-8443-biggest-potential-complaint-lost-invariant-6"></a>Biggest Potential Complaint: Lost Invariant</h2>
<p>I showed a case where how it would work could change:</p>
<pre><code>&gt;&gt; word: $foo  ; imagine foo is not defined anywhere
== foo

&gt;&gt; get word
** Error: foo is not bound

&gt;&gt; set (extend lib 'foo) 1020  ; add a FOO definition to lib module
== 1020

&gt;&gt; get word
== 1020  ; would work if $foo bound to an environment chain
</code></pre>
<p>But this has further risks.  Consider this:</p>
<pre><code>&gt;&gt; lib.foo: 1337
== 1337

&gt;&gt; get word
== 1337

&gt;&gt; foo: 304  ; created in user context (or should be...)
== 304

&gt;&gt; get word
== 304

&gt;&gt; lib.word
== 1337
</code></pre>
<p>When you wrote <code>$foo</code> you caused it to bind into an environment chain that had the USER context first, then USER inherited LIB.  So it searches USER first, then LIB.</p>
<p>When something was added to LIB, it saw it.  But later, something added to USER could override it.</p>
<p><strong>Bug, or feature?</strong></p>
<p>It's a bit hard to tell.  When you said <strong><code>$foo</code></strong> you effectively said "bind into the current wacky environment, whatever that is".  Had you said <strong><code>bind lib 'foo</code></strong> you could have asked for something more specific.</p>
<h2><a name="p-8443-data-point-tuple-must-capture-environment-7" class="anchor" href="https://rebol.metaeducation.com#p-8443-data-point-tuple-must-capture-environment-7"></a>Data Point: TUPLE! Must Capture Environment</h2>
<p>When you write <strong><code>get $.foo</code></strong>, then what happens in that capture of environment has to put something onto <code>.foo</code> that's enough for GET to find what it needs.</p>
<p>And the current thinking is that <code>.foo</code> acts like <code>this.foo</code> -- looking up whatever THIS is defined to in the environment.</p>
<p>We don't want to put logic into the code behind <code>$.foo</code> that does the capture of THIS and pokes it in some secret location of the tuple binding.  It needs to just associate the whole environment with <code>.foo</code>.</p>
<p>This really starts to make it look like WORD! should line up with everything else and capture an environment, not just do a lookup and consider that the final answer.</p>
<p><strong>If this isn't what you want, the BIND operator should offer a more specific language for describing the exact bind resolving invariant you need.</strong></p>
<p>This is casual, cheap (well, it cheapens the definition of what $ does to be basically free), and fixes a problem with function argument indefinite lifetime.</p>
<h3><a name="p-8443-ill-try-changing-it-and-see-what-happens-8" class="anchor" href="https://rebol.metaeducation.com#p-8443-ill-try-changing-it-and-see-what-happens-8"></a>I'll Try Changing It And See What Happens...</h3>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-word-capture-the-whole-binding-environment/2494">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-word-capture-the-whole-binding-environment/2494</link>
          <pubDate>Wed, 18 Jun 2025 18:05:36 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2494</guid>
          <source url="https://rebol.metaeducation.com/t/should-word-capture-the-whole-binding-environment/2494.rss">Should $WORD Capture The Whole Binding Environment?</source>
        </item>
        <item>
          <title>Changing Build System Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>There was an old dialect that used blocks, like:</p>
<pre><code> sources-C: [
     %file1.c
     [%file2.c &lt;some&gt; &lt;options&gt;]
     %file3.c
 ]
</code></pre>
<p>This was because it was based on MAP-EACH and processing items seemed "easier" to do when you could go one item at a time.</p>
<p>But I decided I didn't like it.  I prefer to have the option blocks separate.  I'm also going back to accepting TUPLE!s/PATH!s (a bootstrap issue got in the way of this, but I found a workaround).</p>
<pre><code> sources-C: [
     file1.c
     file2.c [&lt;some&gt; &lt;options&gt;]
     file3.c
 ]
</code></pre>
<p>Traversing this means you have to do some PARSE-ing, but that's what makes it interesting.</p>
<p>Here's some code that's getting tossed, that did some "canonicalizing" of the old format:</p>
<pre><code>; Some places (like SOURCES: in %make-spec.r for extensions) are permissive
; in terms of their format:
;
;     sources-A: %file.jpg
;
;     sources-B: [%file.jpg &lt;some&gt; &lt;options&gt;]
;
;     sources-C: [
;         %file1.jpg
;         [%file2.jpg &lt;some&gt; &lt;options&gt;]
;         %file3.jpg
;     ]
;
; It's a bit irregular, but convenient.  This function regularizes it:
;
;     sources-A: [
;         [%file.c]
;     ]
;
;     sources-B: [
;         [%file.c &lt;some&gt; &lt;options&gt;]
;     ]
;
;     sources-C: [
;         [%file1.c]
;         [%file2.c &lt;some&gt; &lt;options&gt;]
;         [%file3.c]
;     ]
;
export to-block-of-file-blocks: func [
    return: "Will be a top-level COPY of the block, or new block"
        [block!]
    x [&lt;opt&gt; file! block!]
][
    if file? x [
        return reduce [blockify x]  ; case A
    ]
    any [null? x, x = []] then [
        return copy []
    ]
    if file? x.1 [
        all [
            not find (next x) file!
            not find (next x) block!
        ] then [
            return reduce [x]  ; case B
        ]
        ; fallthrough
    ]
    if find x tag! [  ; light check for mistakes
        panic [
            "FILE!/BLOCK! list can't contain TAG!s if multiple files:"
            mold:limit x 200
        ]
    ]
    return map-each 'item x [blockify item]  ; case C
]
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/changing-build-system-dialect/2491">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/changing-build-system-dialect/2491</link>
          <pubDate>Tue, 17 Jun 2025 09:05:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2491</guid>
          <source url="https://rebol.metaeducation.com/t/changing-build-system-dialect/2491.rss">Changing Build System Dialect</source>
        </item>
        <item>
          <title>Should WORD! Allow Sigils at non-HEAD Positions?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Lexer</category>
          <description><![CDATA[
            <p>Rebol2, R3-Alpha, and Red have always let you put apostrophes in WORD! if they're not at the head.</p>
<ul>
<li>
<p>That gives you weird WORD!s like <strong><code>didn't</code></strong> and <strong><code>isn't</code></strong>.</p>
</li>
<li>
<p>It also lets us and words with apostrophes to indicate "prime" and "double-prime" derivitave things, like <strong><code>f'</code></strong> or <strong><code>f''</code></strong></p>
</li>
</ul>
<p>So Ren-C has allowed this as well.</p>
<p>But now, we're in the era of Sigils.  What reasoning would there be to allow [$ ^ @] in WORD!s at non-head positions?</p>
<p>Well... it would give slightly more compatibility with <a href="https://rebol.metaeducation.com/t/webassembly-text-format-wat/2223">WebAssembly Text Format</a>.  They have identifiers with $ in the name...</p>
<ul>
<li>
<p><a href="https://medium.com/ax1al/learning-and-trying-to-reverse-web-assembly-for-fun-da98fdf962e8">I saw <strong>$FUNCSIG$ii</strong> as a real example</a></p>
</li>
<li>
<p>Things like <strong><code>$$</code></strong> or <strong><code>$$a</code></strong> would still be illegal, though you could say <strong><code>$a$</code></strong> as a TIED! WORD! with spelling "a$"</p>
</li>
</ul>
<p>But given some recent applications of <a href="https://rebol.metaeducation.com/t/reacting-to-tie-to-automate-binding/2462/3">using $ to do bound PICKs</a>, I came to wonder if we could shorthand:</p>
<pre><code>b: 10

block: [a b c]

assert [10 = get pick:bind block 2]
</code></pre>
<p>A plain PICK could be shorthanded as <strong><code>second</code></strong>.  So you could say <strong><code>second:bind</code></strong>, since SECOND is a specialization of PICK.</p>
<p>But I thought that maybe <strong><code>second$</code></strong> could make an okay shorthand for <strong><code>second:bind</code></strong></p>
<pre><code>assert [10 = get second$ block]
</code></pre>
<p>And in turn, that made me think <strong><code>pick$</code></strong> would be a generically useful shorthand for <strong><code>pick:bind</code></strong></p>
<p>It's certainly more communicative than <strong><code>pick*</code></strong>.</p>
<p>Whether these shorthands go in the box or not, I don't really know what the benefit is to prohibiting them.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-word-allow-sigils-at-non-head-positions/2490">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-word-allow-sigils-at-non-head-positions/2490</link>
          <pubDate>Tue, 17 Jun 2025 02:15:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2490</guid>
          <source url="https://rebol.metaeducation.com/t/should-word-allow-sigils-at-non-head-positions/2490.rss">Should WORD! Allow Sigils at non-HEAD Positions?</source>
        </item>
        <item>
          <title>Advancements in CastHelper for Hooked Casts</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>C/C++ Implementation</category>
          <description><![CDATA[
            <p>Progress has been fairly amazing on the debug checks for casts.</p>
<p>The "user experience" of writing hooks for the casts used to be very hard-to-read code for a non-C++ programmer...but it's now very simple!</p>
<p>Just to give one example, consider casting to an "Element" (e.g. an Array element, something that can live in a BLOCK! or GROUP!).</p>
<p>As a reminder of what the idea is: anywhere in the source where you write either:</p>
<pre><code>cast(Element*, ...)
cast(const Element*, ...)
</code></pre>
<p>In an ordinary C build, it will just act like:</p>
<pre><code>(Element*)(...)
(const Element*)(...)
</code></pre>
<p>But in an instrumented build using C++, it's possible to add checks.  These checks can be at compile-time (prohibiting conversions of some combination of types)... or they can be at runtime, validating the bit patterns of the thing being converted.</p>
<p>For Element, we have:</p>
<pre><code>DECLARE_C_TYPE_LIST(g_convertible_to_cell,
    Cell, Atom, Element, Value,
    Pairing,
    Node, Byte, char, void
);

template&lt;typename F&gt;
struct CastHelper&lt;const F*, const Element*&gt; {
  static void Validate_Bits(const F* p)
  {
    STATIC_ASSERT(In_C_Type_List(g_convertible_to_cell, F));

    const Cell* c = u_cast(const Cell*, p);
    Assert_Cell_Readable(c);
    assert(LIFT_BYTE(c) != ANTIFORM_0);
  }
};
</code></pre>
<p><strong>That's extremely easy to read!</strong></p>
<ul>
<li>
<p>We are making sure that the <a href="https://rebol.metaeducation.com/t/lift-byte-values-antiform-normal-quasi-quoted/2091">LIFT_BYTE() is not 0</a>, hence not an antiform.</p>
</li>
<li>
<p>We're also checking that it's a valid readable cell (e.g. the bits have NODE_FLAG_NODE and NODE_FLAG_CELL, and NODE_FLAG_UNREADABLE is not set.)**</p>
</li>
<li>
<p>Plus, at <strong>compile-time</strong>, it's stopping you from all manner of casts which might be accidental to make Cells from things that can't make sense as Cells.</p>
</li>
</ul>
<p>What <strong><code>template&lt;typename F&gt;</code></strong>  means is that this is a "wildcard" pattern-matching rule, that the compiler will try to match against any pointer to F.  The name F is arbitrary, but chosen to represent "FROM", e.g. the datatype we are converting from.</p>
<p>(It would be possible to use more than one wildcard, e.g. <strong><code>template&lt;typename F, typename T&gt;</code></strong> and match patterns in both the "TO" and the "FROM".  But here we're fixed as defining conversions TO an Element*, so there's no second parameter to the template.)</p>
<h2><a name="p-8428-write-just-the-const-casts-works-for-mutable-1" class="anchor" href="https://rebol.metaeducation.com#p-8428-write-just-the-const-casts-works-for-mutable-1"></a>Write Just The Const Casts, Works For Mutable</h2>
<p>I hammered on this until I could get it to where you could just write the const casts, and it will take care of the mutable form casts (including blocking casting away constness)... running through the same code.  So you don't have to write two entry points and do the piping through common code yourself.</p>
<p>I'm on the fence on whether it's worth it to put in wiring to make it possible to separately hook mutable casts--to make sure the bit patterns you have are legal for a mutable pointer.  That's not really needed given the protection of casting away constness, and the cases where you do cast mutably from raw pointers you probably are doing that on purpose.  But definitely it needs to default to that if you write just the const casts you hook all of them for that pattern match, because this is 99% of the time what you want...it shouldn't be laborious.</p>
<h2><a name="p-8428-c-is-minimized-declare_c_type_list-2" class="anchor" href="https://rebol.metaeducation.com#p-8428-c-is-minimized-declare_c_type_list-2"></a>C++ Is Minimized: DECLARE_C_TYPE_LIST()</h2>
<p>Without DECLARE_C_TYPE_LIST() and In_C_Type_List(), this would look like:</p>
<pre><code>using g_convertible_to_cell = CTypeList&lt;
    Cell, Atom, Element, Value,
    Pairing,
    Node, Byte, char, void
)&gt;;

STATIC_ASSERT((g_convertible_to_cell::contains&lt;F&gt;{}));
</code></pre>
<p>It's quirky--including the quirk that you can't call the STATIC_ASSERT() macro on expressions which contain templating <code>&lt;...&gt;</code> markers unless they're wrapped in an extra set of parentheses.  So you have to use <code>static_assert()</code> which enforces arity-2 in C++11.</p>
<h2><a name="p-8428-also-less-c-u_cast-3" class="anchor" href="https://rebol.metaeducation.com#p-8428-also-less-c-u_cast-3"></a>Also Less C++: u_cast()</h2>
<p>You don't want to run the cast hooks while implementing a cast hook!  Originally I used <code>reinterpret_cast</code> in this code, so it looked like:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">    const Cell* c = reinterpret_cast&lt;const Cell*&gt;(p);
    Assert_Cell_Readable(c);
    assert(LIFT_BYTE(c) != ANTIFORM_0);
    return reinterpret_cast&lt;const Element*&gt;(c);
</code></pre>
<p>But the casting system offers <strong><code>u_cast()</code></strong> as an "unchecked" cast that nevers run the hooks (but is easier to spot as being a cast than the parentheses cast it expands to).</p>
<p>It makes it shorter and less scary to use <code>u_cast()</code>, and that's what's used in the rest of the codebase to implement unchecked cast.  So that helps make the code more familiar to what the rest of the C looks like.</p>
<h2><a name="p-8428-should-the-template-be-abstracted-away-too-4" class="anchor" href="https://rebol.metaeducation.com#p-8428-should-the-template-be-abstracted-away-too-4"></a>Should The <code>template&lt;&gt;</code> be Abstracted Away, Too?</h2>
<p>I don't think so.</p>
<p>I think that goes into the realm of pandering a bit too much to C fraidy-cats.  It's tougher to abstract and I think that token-for-token, it gets it right.</p>
<p>The value here is apparent--and I think I've done as much pandering as is appropriate.  What's left is legitimate C++ that matches the essential complexity of the problem.  (It's not even duplicating the signature of the types needlessly, as you might use reference types in those positions.)</p>
<h2><a name="p-8428-in-total-this-is-awesome-stuff-5" class="anchor" href="https://rebol.metaeducation.com#p-8428-in-total-this-is-awesome-stuff-5"></a>In Total, This Is Awesome Stuff</h2>
<p>It's not just about the common casts.  This gives you surgical precision if you're facing a particular debugging problem that's narrowed down, and you want to write a bit of custom instrumentation just to catch the problem you're working on.</p>
<p>Ren-C is able to stay robust despite being a very "Amish" codebase, due to having many of these kinds of features to keep the trains running on time.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/advancements-in-casthelper-for-hooked-casts/2488">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/advancements-in-casthelper-for-hooked-casts/2488</link>
          <pubDate>Sun, 15 Jun 2025 20:21:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2488</guid>
          <source url="https://rebol.metaeducation.com/t/advancements-in-casthelper-for-hooked-casts/2488.rss">Advancements in CastHelper for Hooked Casts</source>
        </item>
        <item>
          <title>TWEAK, PEEK, POKE, PICK... ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>The Rosetta stone of GET and SET has come together, based on operations that speak in what I call "dual representation".</p>
<p>For the moment, let's just say the baseline function you can use to operate on variables called TWEAK.  If you pass TWEAK a lifted value, it acts just like a SET to that value:</p>
<pre><code>&gt;&gt; tweak $x lift 1020
== '1020

&gt;&gt; x
== 1020

&gt;&gt; tweak $x lift null
== ~null~

&gt;&gt; x
== \~null~\  ; antiform
</code></pre>
<p>But then there's the "unlifted range" of values.  What those do is a work in progress, but use your imagination... e.g. it could be a GETTER function:</p>
<pre><code>&gt;&gt; tweak $x does [print "HI!" 10 + 10]
== \~&amp;[frame! ...]~\  ; antiform

&gt;&gt; x
HI!
== 20

&gt;&gt; type of get $x
HI!
== \~{integer!}~\  ; antiform  &lt;-- e.g. GET doesn't see it as an ACTION!
</code></pre>
<h2><a name="p-8416-but-how-do-you-peek-a-tweak-1" class="anchor" href="https://rebol.metaeducation.com#p-8416-but-how-do-you-peek-a-tweak-1"></a>But How Do You "PEEK" a "TWEAK"?</h2>
<p>Right now, the trick is that if you pass TWEAK a NULL, then it interprets that as a query of what the state is:</p>
<pre><code>&gt;&gt; tweak $x lift 1020
== '1020

&gt;&gt; tweak $x null
== '1020
</code></pre>
<p>But it would be nice if that had a nicer name.  I kind of like PEEK... because of its history of letting you look into the secrets of arbitrary magical memory locations from BASIC (e.g. on a Commodore 64)</p>
<p>Yet in that worldview, PEEK complements POKE... and POKE is an established Rebolism that's "not magical"... e.g. it doesn't work in the lifted range... and is a complement to PICK.</p>
<h2><a name="p-8416-could-poke-be-reclaimed-for-the-tweaky-magic-2" class="anchor" href="https://rebol.metaeducation.com#p-8416-could-poke-be-reclaimed-for-the-tweaky-magic-2"></a>Could POKE Be Reclaimed For The "Tweaky Magic?"</h2>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>POKE is a nicer name than TWEAK, and pairs nicely with PEEK.</p>
<p>PICK might be complemented by something else...?  PUT, maybe?</p>
<p>As a refresher: in Ren-C's model, you don't technically <em>need</em> PICK or POKE, since:</p>
<ul>
<li><code>pick x y</code> =&gt; <code>x.(y)</code></li>
<li><code>poke x y z</code> =&gt; <code>x.(y): z</code></li>
</ul>
<p>But their existence helps in various cases, e.g. <code>first: specialize pick/ [1]</code> or something like that.</p>
<h2><a name="p-8416-thinking-about-it-3" class="anchor" href="https://rebol.metaeducation.com#p-8416-thinking-about-it-3"></a>Thinking About It...</h2>
<p>For now I'm just using TWEAK to NULL for "peeking" and not giving it a name yet.  But, thoughts welcome...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/tweak-peek-poke-pick/2485">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/tweak-peek-poke-pick/2485</link>
          <pubDate>Wed, 11 Jun 2025 03:29:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2485</guid>
          <source url="https://rebol.metaeducation.com/t/tweak-peek-poke-pick/2485.rss">TWEAK, PEEK, POKE, PICK... ?</source>
        </item>
        <item>
          <title>ChatGPT On the C/C++ Fanciness Building As C99</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>C/C++ Implementation</category>
          <description><![CDATA[
            <p>I was doing some additional tweaking of the <strong><a href="https://rebol.metaeducation.com/t/antiform-safety-covariance-and-contravariance/2330">covariance / contravariance</a></strong> to support <code>Init(Slot)</code> being passed anywhere <code>Init(Element/Value)</code> or <code>Sink(Element/Value)</code> would be accepted.</p>
<p>What this does is it helps make sure that the only place you ever skip a potential SETTER function that runs on assignment of an object field is when the bits for that object's Slot Cell are <em>completely</em> fresh, e.g. a new allocation of an object.  <a href="https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483">So the C code that allocates that object can initialize the fields with ordinary non-DUAL cells</a>.  But <em>only</em> with the <code>Init(Slot)</code> states that are returned by adding fields anew to contexts.</p>
<p>Got it working (and credit to ChatGPT for helping get it done in about an hour, instead of several hours).</p>
<p>Since it had to understand what I was doing fairly well to help me out with it, I thought to ask:</p>
<p><em><strong>"What do you think of the idea of a codebase with this level of sophistication in covariance/contravariance still being able to be built with a C99 compiler?"</strong></em></p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/chatgpt-on-the-c-c-fanciness-building-as-c99/2484">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/chatgpt-on-the-c-c-fanciness-building-as-c99/2484</link>
          <pubDate>Mon, 09 Jun 2025 14:43:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2484</guid>
          <source url="https://rebol.metaeducation.com/t/chatgpt-on-the-c-c-fanciness-building-as-c99/2484.rss">ChatGPT On the C/C++ Fanciness Building As C99</source>
        </item>
        <item>
          <title>Impedance Matching LIFT The Universe With Baseline</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p><sub><em>(Sorry for the EE term.  If you're unfamiliar: <a href="https://en.wikipedia.org/wiki/Impedance_matching">Impedance Matching</a>)</em></sub></p>
<hr>
<p>A while back I realized that it's best if OBJECT!s, MODULE!s, LET!s, etc. store their contents in lifted representation.</p>
<p>...or rather... they store "historically normal" values in lifted representation (QUASIFORM! and QUOTED!).  The unlifted band would then be used for special signals.</p>
<h3><a name="p-8399-one-example-unlifted-trash-would-denote-true-unsetness-1" class="anchor" href="https://rebol.metaeducation.com#p-8399-one-example-unlifted-trash-would-denote-true-unsetness-1"></a>One Example: Unlifted TRASH! would denote <em>true unsetness</em>...</h3>
<p><em>And the term actually now fits.</em>  e.g. a state of absence of value, beneath the layer of what you could accomplish with SET.</p>
<p>With SET, you can only get "trashed" values:</p>
<pre><code>&gt;&gt; x: ~
== \~\ antiform (trash!) "tripwire"

&gt;&gt; trashed? $x
== \~null~\  ; antiform  &lt;-- it's trashed, all right...

&gt;&gt; unset? $x
== \~null~\  ; antiform   &lt;-- but it's SET to TRASH!, it's NOT "unset"! 
</code></pre>
<p>However, special tools and special cases would go <em>beneath</em> SET.</p>
<pre><code>&gt;&gt; tweak $x ~   ; tweak doesn't do the implicit LIFT that SET does...

&gt;&gt; unset? $x
== \~okay~\  ; antiform
</code></pre>
<p>There will be shorthands for that like (unset $x).  But also, you get this "unset" state as the default states in MAKE FRAME!:</p>
<pre><code>&gt;&gt; f: make frame! negate/

&gt;&gt; unset? $f.number
== \~okay~\  ; antiform  &lt;-- actually unspecialized, not specialized to trash!
</code></pre>
<p>This brings the long hoped-for distinction between unspecialized values, and values that are purposefully trash!  And what was fretted over as being a "hidden bit" is anything but... it's just one "out-of-band" operator away.</p>
<p>e.g. Note that if you use TWEAK with a lifted value, that's just like SET:</p>
<pre><code>&gt;&gt; tweak $x lift ~  ; synonym for (set $x ~)

&gt;&gt; unset? $x
== \~null~\  ; antiform

&gt;&gt; trashed? $x
== \~okay~\  ; antiform
</code></pre>
<aside class="quote no-group quote-modified" data-username="rebolbot" data-post="3" data-topic="2477">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rebolbot/48/40_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477/3">Solving the Pox of the (^)... LIFT the Universe?</a></div>
<blockquote>
<p><em>"You’re designing the kind of system that can actually scale symbolic transformation, structured programming, and coherent meta-programming—because you’ve built in a substrate that encodes the ambiguity, instead of trying to erase it."</em></p>
</blockquote>
</aside>
<h2><a name="p-8399-thats-just-one-example-2" class="anchor" href="https://rebol.metaeducation.com#p-8399-thats-just-one-example-2"></a>That's Just One Example...</h2>
<p>It's the gateway to SETTER and GETTER functions <a href="http://www.rebol.net/r3blogs/0019.html">(actually desired by Carl... or setters at least... but he didn't know how to do 'em)</a></p>
<p>And for stylized setters/getters that do specific things (like type checking) there can be specially understood representations in the unlifted band.</p>
<p>Vocabulary term: I call the multiplexing of lifted and unlifted values together <strong>"DUAL REPRESENTATION"</strong></p>
<h2><a name="p-8399-all-of-it-is-powered-by-common-get-and-set-code-3" class="anchor" href="https://rebol.metaeducation.com#p-8399-all-of-it-is-powered-by-common-get-and-set-code-3"></a>All Of It Is Powered By Common GET and SET Code</h2>
<p>This wouldn't work if random places in the code ran off and inspected fields of OBJECT!s literally.</p>
<p>You have to go through some common path.  Otherwise you wind up with some callsites honoring the generalized conventions and others not.</p>
<p>It's kind of like how random code in R3-Alpha would ignore the PROTECT status of variables.  Ren-C has fought hard long and hard to nail that kind of thing down, and make sure at compile-time that you can be certain the checks aren't being skipped.</p>
<p>Piping everything through common GET and SET code paths ensures that as features like type checks or accessors are added, you don't have rogue code that doesn't honor the convention.</p>
<p><strong>It's been challenging to do this--and right now it's messy and slow--but the commonality means it's worth it to invest in optimizations for that one true path.  And Ren-C has plenty of optimization tools at its disposal, which have been evolving over the years... <sub>for when the timing is right...</sub></strong></p>
<h2><a name="p-8399-but-what-about-normal-boring-context-building-code-4" class="anchor" href="https://rebol.metaeducation.com#p-8399-but-what-about-normal-boring-context-building-code-4"></a>But What About Normal, Boring, Context-Building Code?</h2>
<p>Here's an example, just the one on my screen right now.</p>
<p>It's some random code out of the POSIX CALL implementation, related to... forking processes or something:</p>
<pre><code>if (Bool_ARG(INFO)) {
    VarList* info = Alloc_Varlist(TYPE_OBJECT, 2);

    Init_Integer(Append_Context(info, CANON(ID)), forked_pid);
    if (Bool_ARG(WAIT))
        Init_Integer(Append_Context(info, CANON(EXIT_CODE)), exit_code);

    return Init_Object(OUT, info);
}
</code></pre>
<p>Dumb, simple code making an OBJECT! with 2 fields in it, appending those fields (which default to an erased state you have to fill in to be correct code), and then setting the erased cells to mundane values.</p>
<p>If I were to go lockstep through code that looked like this and change it for lifting to appease the common GET and SET code, it would start looking like:</p>
<pre><code>if (Bool_ARG(INFO)) {
    VarList* info = Alloc_Varlist(TYPE_OBJECT, 2);

    Liftify(  // &lt;-- new wart
        Init_Integer(Append_Context(info, CANON(ID)), forked_pid)
    );
    if (Bool_ARG(WAIT))
        Liftify(  // &lt;-- new wart
            Init_Integer(Append_Context(info, CANON(EXIT_CODE)), exit_code)
        );

    return Init_Object(OUT, info);
}
</code></pre>
<p>Liftify adds 2 to the LIFT_BYTE.  (<a href="https://rebol.metaeducation.com/t/lift-byte-values-antiform-normal-quasi-quoted/2091">Review LIFT_BYTE if you want an introduction to that.</a>)</p>
<p>Liftify also has to check for overflow (e.g. that you're not going past 255 for the LIFT_BYTE value).  Maybe the optimizer can figure out it doesn't need that check here?  Though I try not to rely on the optimizer too much...</p>
<h2><a name="p-8399-this-parallels-the-too-many-of-usermode-code-5" class="anchor" href="https://rebol.metaeducation.com#p-8399-this-parallels-the-too-many-of-usermode-code-5"></a>This Parallels The "Too Many <strong><code>^</code></strong>" Of Usermode Code</h2>
<p>My observation in <strong><a href="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477">LIFT the UNIVERSE</a></strong> was that usermode code was becoming contaminated with lifts in places that weren't really the concern of that code.  <em>(That's why the robots are celebrating, they're throwing carets in the trashcan...)</em></p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/f16f9c506056c76e6a9b955d445039b0e1d3eeb1.webp" data-download-href="https://rebol.metaeducation.com/uploads/default/f16f9c506056c76e6a9b955d445039b0e1d3eeb1" title="assets_task_01jx3y0xmyfc79dwb24jd57b49_1749257658_img_3"><img src="https://rebol.metaeducation.com/uploads/default/optimized/1X/f16f9c506056c76e6a9b955d445039b0e1d3eeb1_2_345x230.webp" alt="assets_task_01jx3y0xmyfc79dwb24jd57b49_1749257658_img_3" data-base62-sha1="yrQc5xkNpeTlSSrOOswU5OsMelz" width="345" height="230" srcset="https://rebol.metaeducation.com/uploads/default/optimized/1X/f16f9c506056c76e6a9b955d445039b0e1d3eeb1_2_345x230.webp, https://rebol.metaeducation.com/uploads/default/optimized/1X/f16f9c506056c76e6a9b955d445039b0e1d3eeb1_2_517x345.webp 1.5x, https://rebol.metaeducation.com/uploads/default/optimized/1X/f16f9c506056c76e6a9b955d445039b0e1d3eeb1_2_690x460.webp 2x" data-dominant-color="4D4647"></a></div><p></p>
<p><strong>Here we're seeing the C code having some of the same problem as having the carets, manifest as calls to <code>Liftify()</code>.</strong>  It's getting uglier, and spreading that ugliness around.</p>
<h2><a name="p-8399-should-a-cell_flag_dual-be-sacrificed-for-this-6" class="anchor" href="https://rebol.metaeducation.com#p-8399-should-a-cell_flag_dual-be-sacrificed-for-this-6"></a>Should A <strong><code>CELL_FLAG_DUAL</code></strong> Be Sacrificed For This?</h2>
<p>I don't like wasting the very few CELL_FLAG_XXX.  But over time, silly ones have been freed up to give us some wiggle room (e.g. the <a>now-completely superfluous CELL_FLAG_FALSEY</a>).</p>
<p>And maybe this is a really good case where it could be of help to sacrifice one.  Since all the GET and SET that's <em>not</em> this kind of stuff is running through centralized code...it could be tolerant of cells in contexts that <em>weren't</em> initialized with CELL_FLAG_DUAL, and just know that those are to be taken literally.</p>
<p>It complicates things a little bit in that one <em>"big, beautiful code path"</em>.  But as a caller of TWEAK or GET and SET you're insulated from the complication.  It's a black box... maybe the cell has <code>CELL_FLAG_DUAL</code> and maybe it doesn't, you'll never know.</p>
<h2><a name="p-8399-just-have-to-catch-confusions-before-they-happen-7" class="anchor" href="https://rebol.metaeducation.com#p-8399-just-have-to-catch-confusions-before-they-happen-7"></a>Just Have To Catch Confusions Before They Happen...</h2>
<p>Probably best is just to throw in some asserts if you somehow start running through code paths that don't use the common GET somehow, and make sure <code>Type_Of()</code> and <code>Quotes_Of()</code> etc will assert on anything that has CELL_FLAG_DUAL.</p>
<p>I'm not sure how many legitimate codepaths there will be that duck the legitimate GET, but there are some reasonable cases (such as the code I give above) that are just doing a simple construction and probably don't need to be more complicated than they already are.</p>
<h2><a name="p-8399-will-it-slow-things-down-8" class="anchor" href="https://rebol.metaeducation.com#p-8399-will-it-slow-things-down-8"></a>Will It Slow Things Down?</h2>
<p>I posted this under Optimization because it's trading off some runtime code to make the C code more tolerable.</p>
<p>But rest assured, this is not the flag test that will be the bottleneck of the system.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/slight_smile.png?v=14" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<p><em>(Compared to naive Liftify() everywhere, it probably breaks at least even for not having to do the overflow checking of the LIFT_BYTE.)</em></p>
            <p><small>6 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483</link>
          <pubDate>Sat, 07 Jun 2025 23:00:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2483</guid>
          <source url="https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483.rss">Impedance Matching LIFT The Universe With Baseline</source>
        </item>
        <item>
          <title>Bringing Ren-C ATTEMPT and UNTIL Into C</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>C/C++ Implementation</category>
          <description><![CDATA[
            <p><strong><a href="https://rebol.metaeducation.com/t/repeat-1-attempt-not-as-useless-as-it-looks/2480">The ATTEMPT construct is so useful, I made a version for C</a></strong></p>
<p>And UNTIL as well... <em><a href="https://rebol.metaeducation.com/t/the-mismatch-of-arity-1-until-and-arity-2-while/594/10">(the negated WHILE meaning from Ren-C...)</a></em></p>
<p>Pretty fun...</p>
<pre><code>//=//// "ATTEMPT" AND "UNTIL" CONSTRUCTS //////////////////////////////////=//
//
// This is a fun trick that brings a little bit of the ATTEMPT and UNTIL loop
// functionality from Ren-C into C.
//
// The `attempt` macro is a loop that runs its body just once, and then
// evaluates the `then` or `else` clause (if present):
//
//     attempt {
//         ... some code ...
//         if (condition) { break; }  /* exit attempt, run "else" clause */
//         if (condition) { continue; }  /* exit attempt, run "then" clause */
//         if (condition) { again; }  /* jump to attempt and run it again */
//         ... more code ...
//     }
//     then {  /* optional then clause */
//        ... code to run if no break happened ...
//     }
//     else {  /* optional else clause (must have then clause to use else) */
//        ... code to run if a break happened ...
//     }
//
// It doesn't do anything you couldn't do with defining some goto labels.
// But if you have B breaks and C continues and A agains, you don't have to
// type the label names ((B + 1) + (C + 1) + (A + 1)) times.  And you don't
// have to worry about coming up with the names for those labels!
//
// The `until` macro is a negated sense while loop that also is able to have
// compatibility with the `then` and `else` clauses.
//
// BUT NOTE: Since the macros define variables tracking whether the `then`
// clause should run or not, and whether an `again` should signal continuing
// to run...this can only be used in one scope at a time.  To use more than
// once in a function, define another scope.  Also, you can't use an `else`
// clause without a `then` clause.

#define attempt \
    bool run_then_ = false;  /* as long as run_then_ is false, keep going */ \
    bool run_again_ = false;  /* if run_again_, don't set run_then_ */ \
    for (; not run_then_; \
        run_again_ ? (run_again_ = false), true  /* again doesn't exit loop */ \
        : (run_then_ = true))  /* normal continue, exits the loop */

#define until(condition) \
    bool run_then_ = false; \
    bool run_again_ = false; \
    for (; run_again_ ? (run_again_ = false), true :  /* skip condition */ \
        (condition) ? (run_then_ = true, false) : true; )

#define then  if (run_then_)
#define again  { run_again_ = true; continue; }
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/bringing-ren-c-attempt-and-until-into-c/2481">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/bringing-ren-c-attempt-and-until-into-c/2481</link>
          <pubDate>Sat, 07 Jun 2025 11:31:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2481</guid>
          <source url="https://rebol.metaeducation.com/t/bringing-ren-c-attempt-and-until-into-c/2481.rss">Bringing Ren-C ATTEMPT and UNTIL Into C</source>
        </item>
        <item>
          <title>[REPEAT 1] =&gt; ATTEMPT (Not As Useless As It Looks)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Loops</category>
          <description><![CDATA[
            <p>Historical Rebol had a use for ATTEMPT that we don't really need anymore... due to how definitional ERROR!s work and being covered by other things.</p>
<p>When the word was freed up, I thought <strong><code>This looks like a perfect name for "loop once"</code></strong></p>
<p>I imagine you're thinking: <em>"Why would we waste a name on loop <em>once</em>?"</em> <img src="https://rebol.metaeducation.com/images/emoji/twitter/confused.png?v=14" title=":confused:" class="emoji" alt=":confused:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8394-hear-me-out-1" class="anchor" href="https://rebol.metaeducation.com#p-8394-hear-me-out-1"></a>...Hear Me Out...</h2>
<p><strong>I'll start by saying loop once does come up</strong>, when you're writing something that wants to expose a looping interface, but not delegating to any wrapped loops to do it.</p>
<p>Let's say you're trying to do this:</p>
<pre><code>&gt;&gt; for-all-foos 'x [blah blah foo 10 blah blah foo 20] [print [x]]
10
20
</code></pre>
<p>(Assume you don't know about reusing FOR-EACH with a GENERATOR.  Instead you decide you really do want to get into your own binding, or customization of the body, or whatever your reasoning is.)</p>
<p>You try driving this with PARSE</p>
<pre><code>for-all-foos: lambda [var data body] [
    body: bind (var: let (var)) body  ; !!! need better way to say this
    parse data [
        opt some [
            'foo set (var) integer! (eval body)
            | elide one
        ]
    ]
]
</code></pre>
<p>That seems pretty good...besides me not having a great way of binding an indirect variable to a body, yet being able to still assign that variable afterwards.  <em>(Note that whatever you use for that needs to know the difference between <code>@x</code> to reuse a binding and <code>x</code> to not, e.g. it has to be a construct with the smarts of something like LET.)</em></p>
<p>But what about BREAK, CONTINUE, etc?</p>
<p>You need to bind body to <a href="https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479">THROW-TO-LOOP</a>, and you have to handle that.</p>
<p>So REPEAT 1 might come to mind.  But what about just ATTEMPT?</p>
<pre><code>for-all-foos: func [var data body] [
    body: bind (var: let (var)) body  ; !!! need better way to say this
    return parse data [
        opt some [
            'foo set (var) integer! (attempt body else [return null])
            | elide one
        ]
    ]
]
</code></pre>
<p>So now you have your BREAK, your CONTINUE, your AGAIN, all working.</p>
<h2><a name="p-8394-but-attempt-is-a-genuinely-useful-control-construct-2" class="anchor" href="https://rebol.metaeducation.com#p-8394-but-attempt-is-a-genuinely-useful-control-construct-2"></a>But ATTEMPT Is A Genuinely Useful Control Construct</h2>
<p>Especially with AGAIN.</p>
<pre><code>xxx: attempt [
    blah blah
    if blah blah [break]
    if blah blah [again]
    if blah blah [continue]
    blah blah
] then [
    ; code that runs if reaches end normally, or CONTINUE
] else [
   ; code that runs if BREAK
]
</code></pre>
<p>It's lightweight and flexible, <a href="https://rebol.metaeducation.com/t/the-mismatch-of-arity-1-until-and-arity-2-while/594/8">and in general a lot clearer than INSIST (Redbol UNTIL)</a></p>
<p>Even in the most minimal circumstances, I think it's clearer:</p>
<pre><code>append data insist [request-server-token else [wait 5]]

append data attempt [request-server-token else [wait 5, again]]
</code></pre>
<p>But it's much more powerful.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/repeat-1-attempt-not-as-useless-as-it-looks/2480">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/repeat-1-attempt-not-as-useless-as-it-looks/2480</link>
          <pubDate>Sat, 07 Jun 2025 11:26:40 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2480</guid>
          <source url="https://rebol.metaeducation.com/t/repeat-1-attempt-not-as-useless-as-it-looks/2480.rss">[REPEAT 1] =&gt; ATTEMPT (Not As Useless As It Looks)</source>
        </item>
        <item>
          <title>Virtual Binding + Macros =&gt; BREAK, CONTINUE, AGAIN</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Loops</category>
          <description><![CDATA[
            <p>In the last moments of 2023, Ren-C finally bit the bullet and made BREAK and CONTINUE definitional (it was a long time coming, just hadn't gotten around to it...):</p>
<p><strong><a href="https://rebol.metaeducation.com/t/definitional-break-and-continue-the-time-is-now/2066">Definitional Break and Continue: The Time Is Now</a></strong></p>
<p>This means that loops create (optimized) variants of BREAK and CONTINUE in which the ACTION! cell has been tweaked to hold the identity of the loop.</p>
<p>The methodology for this optimized representation <a href="https://rebol.metaeducation.com/t/what-are-definitional-returns/2191">was pioneered with definitional RETURN</a>.</p>
<p>Except in this case, there are two new "LET-style variables" tacked onto the loop's binding environment... one for BREAK, and one for CONTINUE.</p>
<h2><a name="p-8393-it-would-be-nice-to-have-again-1" class="anchor" href="https://rebol.metaeducation.com#p-8393-it-would-be-nice-to-have-again-1"></a>It Would Be Nice To Have AGAIN</h2>
<p>It seems to me pretty powerful to be able to ask a loop to start again from the top, but not increment its loop index...or check the condition, or whatever.</p>
<p>(This has precedent in other languages, e.g. <strong><a href="https://perldoc.perl.org/functions/redo">Perl's REDO</a></strong>... but I like AGAIN better.)</p>
<p>That would add a third LET-variable.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/pouting_cat.png?v=14" title=":pouting_cat:" class="emoji" alt=":pouting_cat:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8393-but-could-it-be-just-one-let-variable-2" class="anchor" href="https://rebol.metaeducation.com#p-8393-but-could-it-be-just-one-let-variable-2"></a>But Could It Be Just <em>ONE</em> LET-Variable?</h2>
<p>As I've realized the kind-of-awesome power of virtual binding, I realized that it might be the case that there was just <em>one</em> "throw to loop" construct, that takes different parameterization:</p>
<ul>
<li>
<p><strong><code>throw-to-loop veto</code></strong> =&gt; <strong>BREAK</strong></p>
<ul>
<li>VETO is a function that returns an ERROR! with the identity 'VETO... which is an awesome generalization I haven't talked about yet, that makes constructs abort and return NULL. It works inside things like REDUCE (e.g. <code>reduce [1 + 2 veto]</code> =&gt; <code>null</code>) but also inside GROUP!s of code in PARSE to allow match failures to be signaled by a GROUP! (whose product would otherwise be discarded).  It seems the perfect argument for THROW-TO-LOOP to mean "let's abort this whole loop and give null".</li>
</ul>
</li>
<li>
<p><strong><code>throw-to-loop void</code></strong> =&gt; <strong>CONTINUE</strong></p>
<ul>
<li>This would have the same effect as reaching the end of the loop body and synthesizing VOID.  So if you were doing a MAP-EACH, an iteration of the loop that ran CONTINUE would not contribute anything to the result.</li>
</ul>
</li>
<li>
<p><strong><code>throw-to-loop fail 'retry</code></strong> =&gt; <strong>AGAIN</strong></p>
<ul>
<li>
<p>I don't know if RETRY should be a function that just returns an ERROR! the way VETO is so I'm hand-waving a little here to say "let's have another special trigger that loops can respond to"... if they don't support it, they can treat it like any other error.</p>
</li>
<li>
<p>I'm not thrilled that "retry" doesn't <em>sound</em> like an "error" name the way VETO kind-of-does, but there's only so many unstable antiforms to choose from (and GHOST! seems random to pick to mean "try again").  Maybe INCOMPLETE is a better error ID... where the loop goes "oh, the <em>failure</em> was it didn't complete... so the natural <em>response</em> is to try again"?</p>
</li>
</ul>
</li>
<li>
<p><strong><code>throw-to-loop &lt;whatever&gt;</code></strong> =&gt; <strong>CONTINUE:WITH</strong></p>
<ul>
<li><code>CONTINUE</code> has had a refinement called <code>:WITH</code> that allows you to act as if the loop body completed with some other value besides VOID.  So <code>continue:with spread [d e]</code> inside a MAP-EACH would add the splice <code>~(d e)~</code> to the mapped result.  I don't know if it's better to have this <code>:WITH</code> refinement or if you should just use THROW-TO-LOOP directly... (could THROW-TO-LOOP have a better name?)</li>
</ul>
</li>
</ul>
<h2><a name="p-8393-one-way-to-do-it-macros-3" class="anchor" href="https://rebol.metaeducation.com#p-8393-one-way-to-do-it-macros-3"></a>One Way To Do It... Macros!</h2>
<p>Imagine that a convenient form of MACRO (which might just be called MACRO) would assume that anything $TIED you want to bind in the environment of the macro definition, and anything you don't $TIE is intended to be interpreted in the calling context.</p>
<pre><code>break: macro [throw-to-loop $veto]
continue: macro [throw-to-loop $void]  ; -or- just [throw-to-loop ~[]~]
again: macro [throw-to-loop $fail 'incomplete]  ; or whatever...
</code></pre>
<p>While we'd most likely want to nativize CONTINUE, BREAK, and AGAIN... maybe MACRO can be smart enough to produce native-speed code for this when not running under a stepwise debugger...</p>
<h2><a name="p-8393-any-submissions-for-better-names-for-throw-to-loop-4" class="anchor" href="https://rebol.metaeducation.com#p-8393-any-submissions-for-better-names-for-throw-to-loop-4"></a>Any Submissions For Better Names For THROW-TO-LOOP?</h2>
<p>Maybe being bluntly literal is best.</p>
<p>But <a class="mention" href="https://rebol.metaeducation.com/u/blackattr">@BlackATTR</a> suggested <code>TOSS</code>, <code>PASS</code>, <code>PITCH</code>, <code>PUNT</code>, <code>FLICK</code></p>
<p>They all sound weird to us now, but everything has a learning curve.  You learned what BREAK and CONTINUE meant, you'd learn what AGAIN meant.  Could you learn what TOSS meant, that it was specifically a THROW targeting a LOOP...?</p>
<p>Leaving that open for now.</p>
<h2><a name="p-8393-or-variadic-continue-5" class="anchor" href="https://rebol.metaeducation.com#p-8393-or-variadic-continue-5"></a>Or... Variadic CONTINUE?</h2>
<p>I'll also point out that once-upon-a-time, CONTINUE was variadic... so you could say <strong><code>continue 10</code></strong> and if you left off the parameter it would assume you meant VOID.  This was too error prone, due to line continuation bugs:</p>
<p><a href="https://rebol.metaeducation.com/t/line-continuation-and-arity-bugs-thoughts/1965" class="inline-onebox">Line Continuation and Arity Bugs: Thoughts?</a></p>
<p>But I've been thinking maybe you have to continue lines with an apostrophe.  So this would error:</p>
<pre><code>append [a b c]
[d e f]
</code></pre>
<p>But this would be legal:</p>
<pre><code>append [a b c]
' [d e f]
</code></pre>
<p>The reason it would be legal is it would actually LOAD the code as not having a line break marker.</p>
<p>Then we'd just make line break markers illegal outside of interstitial evaluations.  (Maybe relax it, so that if you were inside a GROUP! evaluation it would allow it, though that might make it toothless.)</p>
<pre><code>(append [a b c]
[d e f])
</code></pre>
<p>If the system got more persnickety about line continuation, then we might feel comfortable bringing back variable-arity CONTINUE, QUIT, RETURN...</p>
<p>I doubt we want to go down the route of JavaScript's <a href="https://en.wikibooks.org/wiki/JavaScript/Automatic_semicolon_insertion">automatic semicolon insertion</a> debacle, and act like there's a comma at "some" line end markers.</p>
<p>I have a hard time being psychic about whether this is a big creativity-enabler (by letting us be more purposeful about semantics of line continuation markers) or if it would lead to hassles.  Overall I feel like it would cut down on bugs, by making line endings usually mean expression endings... and having you be specific when that's not what you want.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/6af702cd11332dfc1fb48f90b5267cab5d41f98f.webp" data-download-href="https://rebol.metaeducation.com/uploads/default/6af702cd11332dfc1fb48f90b5267cab5d41f98f" title="6t9rbhxv06g71"><img src="https://rebol.metaeducation.com/uploads/default/original/1X/6af702cd11332dfc1fb48f90b5267cab5d41f98f.webp" alt="6t9rbhxv06g71" data-base62-sha1="fgfPtWehBdWVciF8Ng28L48wruv" width="300" height="250"></a></div><p></p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479</link>
          <pubDate>Sat, 07 Jun 2025 10:47:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2479</guid>
          <source url="https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479.rss">Virtual Binding + Macros =&gt; BREAK, CONTINUE, AGAIN</source>
        </item>
        <item>
          <title>Solving the Pox of the (^)... LIFT the Universe?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>I've taken the big bold leap into the <em><a href="https://rebol.metaeducation.com/t/meta-parameters-and-function-composition/2433/3">world of fully LIFT'ed FRAME!s</a></em>.</p>
<p>As a refresher: this is the idea that as far as the "API" for calling functions is concerned, you <em>always</em> communicate via lifted values.</p>
<p>That means when you're building a FRAME! to call a function, you don't have to be concerned whether that function specified its argument as ^META or not.  Once the invocation of the function happens, it will unlift non-^meta arguments as part of its execution.</p>
<p>Hence if an argument changes from ^META-to-non-meta (or vice-versa), that won't impact callsites that build frames for it.</p>
<h2><a name="p-8383-metas-lift-on-assign-unlift-on-fetch-helps-1" class="anchor" href="https://rebol.metaeducation.com#p-8383-metas-lift-on-assign-unlift-on-fetch-helps-1"></a>^META's LIFT-ON-ASSIGN, UNLIFT-ON-FETCH Helps</h2>
<p>The new behavior of ^META-WORD! is extended to TUPLE!, that makes this pretty easy to deal with when working with a "raw" FRAME!:</p>
<pre><code>&gt;&gt; f: make frame! append/

&gt;&gt; f.^series: [a b c]
== [a b c]

&gt;&gt; f.series
== '[a b c]

&gt;&gt; f.^value: spread [d e]
== /~(d e)~/  ; antiform (splice!)

&gt;&gt; f.value
== ~(d e)~

&gt;&gt; eval f
== [a b c d e]
</code></pre>
<p>That's a little unfortunate-looking... messier... but it's necessary, right? <sub>(keep reading...)</sub></p>
<h2><a name="p-8383-simplifying-dialect-for-apply-specialize-2" class="anchor" href="https://rebol.metaeducation.com#p-8383-simplifying-dialect-for-apply-specialize-2"></a>Simplifying Dialect For APPLY + SPECIALIZE</h2>
<p>While you have to build a FRAME! with values lifted, I didn't want to make higher-level tools like APPLY and SPECIALIZE look ugly.  So they lift for you:</p>
<pre><code>&gt;&gt; apply append/ [[a b c] spread [d e] dup: 2]
== [a b c d e d e]

&gt;&gt; sub10: specialize subtract/ [value2: 10]

&gt;&gt; sub10 1030
== 1020
</code></pre>
<p>But I've proposed a :FREEFORM variant form of APPLY and SPECIALIZE...in which the code is bound into the frame.  In this case, the dialect isn't in control... so you would have to use the lifted forms of assignment. <sub>(or would you? keep reading...)</sub></p>
<p>This form is more awkward and can't take advantage of positional assignment:</p>
<pre><code>apply:freeform append/ [^series: [a b c] ^value: spread [d e] ^dup: 2]
</code></pre>
<p>But it lets you write arbitrary branching and looping code :</p>
<pre><code>&gt;&gt; apply:freeform append/ [
       if 1 = random 2 [
           ^series: [a b c]
           ^dup: 2
       ] else [
           ^series: [q r s]
           ^dup: 3
       ]
       ^value: spread [d e]
   ]
== [q r s d e d e d e]
</code></pre>
<h2><a name="p-8383-could-the-ugliness-be-moved-around-somehow-3" class="anchor" href="https://rebol.metaeducation.com#p-8383-could-the-ugliness-be-moved-around-somehow-3"></a>Could The "Ugliness" Be Moved Around, Somehow?</h2>
<p>It seems kind of... <em>unfair</em>.  How can the dialected form deal with something easily, that the non-dialected situations don't?</p>
<p>In other words: is there some way to simplify the :FREEFORM versions... or things like ADAPT and ENCLOSE... or building "RAW" frames?</p>
<p><em><strong>My "invasive thought" is this:</strong></em></p>
<ul>
<li>why couldn't <code>(foo: ...)</code> store a lifted-but-decayed form of the right hand side</li>
<li>and <code>(^foo: ...)</code> store a lifted-but <strong>not</strong> decayed version of the right hand side?</li>
</ul>
<p>This is being driven by the only truly "unlifted" state a frame normally "needs" <sub>(hand-waving a bit here, actually <img src="https://rebol.metaeducation.com/images/emoji/twitter/wave.png?v=14" title=":wave:" class="emoji" alt=":wave:" loading="lazy" width="20" height="20">)</sub> is unlifted trash to say it's unspecialized.  What would be the harm of lifting everything, and having a special operation for setting to the unspecialized state?</p>
<p>It would imply, I think... (?)</p>
<ul>
<li>
<p><code>(foo)</code> unlifts the stored value (executing actions, erroring on TRASH!, etc.) and refuses to unlift unstable antiforms</p>
</li>
<li>
<p><code>(^foo)</code> unlifts with no execution (trash! as-is, action! as-is), and is willing to unlift unstable antiforms (pack!, error!, ghost! etc. as-is)</p>
<ul>
<li><sub>I have another slightly invasive thought that ^(foo) might permit "unsurprising" ghosts or actions, but that's for another thread.</sub></li>
</ul>
</li>
</ul>
<p>This is a slippery invasive thought.  It has to be wrong, doesn't it?  Too good to be true?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/pouting_cat.png?v=14" title=":pouting_cat:" class="emoji" alt=":pouting_cat:" loading="lazy" width="20" height="20"></p>
<p>But what if it isn't?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/f16f9c506056c76e6a9b955d445039b0e1d3eeb1.webp" data-download-href="https://rebol.metaeducation.com/uploads/default/f16f9c506056c76e6a9b955d445039b0e1d3eeb1" title="assets_task_01jx3y0xmyfc79dwb24jd57b49_1749257658_img_3"><img src="https://rebol.metaeducation.com/uploads/default/optimized/1X/f16f9c506056c76e6a9b955d445039b0e1d3eeb1_2_517x345.webp" alt="assets_task_01jx3y0xmyfc79dwb24jd57b49_1749257658_img_3" data-base62-sha1="yrQc5xkNpeTlSSrOOswU5OsMelz" width="517" height="345" srcset="https://rebol.metaeducation.com/uploads/default/optimized/1X/f16f9c506056c76e6a9b955d445039b0e1d3eeb1_2_517x345.webp, https://rebol.metaeducation.com/uploads/default/optimized/1X/f16f9c506056c76e6a9b955d445039b0e1d3eeb1_2_775x517.webp 1.5x, https://rebol.metaeducation.com/uploads/default/optimized/1X/f16f9c506056c76e6a9b955d445039b0e1d3eeb1_2_1034x690.webp 2x" data-dominant-color="4D4647"></a></div><p></p>
<p>It's not changing the usual chain of evaluation.  If you say (1 + 2 comment "hi") that's not lifted... it's a plain old 3 and a "plain old" ghost!.</p>
<p>So this means when you say <strong><code>(foo: ~)</code></strong> you would be setting FOO to an "ordinary" trash value (a lifted one, in stored representation).  This would cause errors if fetched via <strong><code>(foo)</code></strong> which would unlift and treat it as active.  But if you said <strong><code>(^foo)</code></strong> you would get back the trash state as-is.</p>
<p><strong>This means there would be a state <em>more trash than trash</em></strong>... unspecialization.  A variable holding a non-lifted trash, which would trip up even fetches with <strong><code>^foo</code></strong>.  And this goes along with my concept of ACCESSOR functions... moving them from something "hidden" to something that's actually exposed... something beneath the layers that <code>(foo: ...)</code> or <code>(^foo: ...)</code> alone can assign.</p>
<p>So you'd need tools to go beneath assignment, but these tools have already been theorized (I've called it "TWEAK")</p>
<h2><a name="p-8383-more-investigation-on-this-needed-but-4" class="anchor" href="https://rebol.metaeducation.com#p-8383-more-investigation-on-this-needed-but-4"></a>More investigation on this needed, but...</h2>
<p><strong>...it's actually just an "all-in, fully-exposed" version of the more "behind-the-scenes" idea I was already implementing, where objects/modules/lets/etc. were storing lifted values...and having special exceptions in the unlifted range.</strong></p>
<p>The consequence is we can limit <code>(f.^foo: ...)</code> or <code>(^bar: ...)</code> cases to those truly concerned with unstable isotopes.  Which if that can be accomplished, seems to mean only those who need it pay for it.</p>
<h2><a name="p-8383-it-might-be-the-perfect-solutionhttpswwwyoutubecomwatchvowkck07ijsu-5" class="anchor" href="https://rebol.metaeducation.com#p-8383-it-might-be-the-perfect-solutionhttpswwwyoutubecomwatchvowkck07ijsu-5"></a><a href="https://www.youtube.com/watch?v=OWKcK07iJsU">...It Might Be The Perfect Solution</a></h2>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/be307c38a0a10b6191a9aba9a9d01bb3b8900a71.jpeg" data-download-href="https://rebol.metaeducation.com/uploads/default/be307c38a0a10b6191a9aba9a9d01bb3b8900a71" title="81A95bnJNWL.UF1000,1000_QL80"><img src="https://rebol.metaeducation.com/uploads/default/optimized/1X/be307c38a0a10b6191a9aba9a9d01bb3b8900a71_2_375x375.jpeg" alt="81A95bnJNWL.UF1000,1000_QL80" data-base62-sha1="r8uB6KGbXm59FQlvG1A7D4I8a8p" width="375" height="375" srcset="https://rebol.metaeducation.com/uploads/default/optimized/1X/be307c38a0a10b6191a9aba9a9d01bb3b8900a71_2_375x375.jpeg, https://rebol.metaeducation.com/uploads/default/optimized/1X/be307c38a0a10b6191a9aba9a9d01bb3b8900a71_2_562x562.jpeg 1.5x, https://rebol.metaeducation.com/uploads/default/optimized/1X/be307c38a0a10b6191a9aba9a9d01bb3b8900a71_2_750x750.jpeg 2x" data-dominant-color="43413E"></a></div><p></p>
            <p><small>11 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477</link>
          <pubDate>Fri, 06 Jun 2025 22:07:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2477</guid>
          <source url="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477.rss">Solving the Pox of the (^)... LIFT the Universe?</source>
        </item>
        <item>
          <title>Lenses/Optics Possibly Applicable to PICK/POKE</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <aside class="quote quote-modified" data-post="1" data-topic="1719">
  <div class="title">
    <div class="quote-controls"></div>
    <img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar">
    <a href="https://rebol.metaeducation.com/t/get-set-vs-pick-poke-whats-the-difference/1719">GET+SET vs PICK+POKE - What's The Difference?</a> <a class="badge-category__wrapper " href="https://rebol.metaeducation.com/c/development/semantics/55"><span data-category-id="55" style="--category-badge-color: #25AAE2; --category-badge-text-color: #FFFFFF; --parent-category-badge-color: #25AAE2;" data-parent-category-id="8" data-drop-close="true" class="badge-category --has-parent" title="While the &quot;Internals&quot; discusses the bits and bytes of how things are implemented, this category is for discussing things design questions of the language... like what do [] should return."><span class="badge-category__name">Semantics</span></span></a>
  </div>
  <blockquote>
    Historically, GET could not get a path: 
rebol2&gt;&gt; obj: make object! [x: 10]

rebol2&gt;&gt; get 'obj/x
** Script Error: get expected word argument of type: any-word object none

That changed in R3-Alpha.  Red followed suit: 
r3-alpha/red&gt;&gt; get 'obj/x
== 10

Which seems like an improvement...but opened the door to something I've complained about: GET having side-effects, such as: 
red&gt;&gt; path: 'obj/(print "Boo!" 'x)
== obj/(print "Boo!" 'x)

red&gt;&gt; get path
Boo!
== 10

When you say that two sequential GE…
  </blockquote>
</aside>

<p>Reading this, I am reminded <em>very</em> strongly of functional optics, as implemented in e.g. Haskell’s <a href="https://hackage.haskell.org/package/lens"><code>lens</code></a> or <a href="https://hackage.haskell.org/package/optics"><code>optics</code></a>. These are, essentially, first-class encodings of composable ‘locations’ at which you can get or set. For instance:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">ghci&gt; import Control.Lens
ghci&gt; value = (5,10,("nested","values"))
ghci&gt; view _1 value
5
ghci&gt; view (_3 . _1) value
"nested"
ghci&gt; set _1 6 value
(6,10,("nested","values"))
ghci&gt; set (_3 . _2) "new" value
(5,10,("nested","new"))
</code></pre>
<p>Here <code>_1</code>, <code>_2</code> and <code>_3</code> are predefined ‘lenses’ for getting elements of a tuple. All lenses can be composed: <code>_3 . _2</code> is a lens pointing to the second element of the third element of a tuple.</p>
<p>You can define your own lenses, of course:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">ghci&gt; data MyRecord = MyRecord { field1 :: Int, field2 :: String } deriving (Show)
ghci&gt; field1Lens = lens field1 (\r v -&gt; r { field1 = v })
ghci&gt; view field1Lens $ MyRecord { field1=10, field2="test" }
10
ghci&gt; set field1Lens 20 $ MyRecord { field1=10, field2="test" }
MyRecord {field1 = 20, field2 = "test"}
</code></pre>
<p>…although there are macros to do it for you (which most people use).</p>
<p>Incidentally, <code>lens</code> also comes about as close to dialecting as is possible in Haskell. There are operator versions of everything: <code>value ^. lens</code> gets, <code>value &amp; lens .~ newvalue</code> sets. Many operators effectively let you simulate imperative programming: e.g. <code>value &amp; lens +~ 1</code> increments the value at the <code>lens</code>.</p>
<p>There are various ways of actually implementing these things. The simplest is simply by storing a getter and a setter together, defining appropriate functions to manipulate them self-consistently. <code>lens</code> uses the <a href="https://www.twanvl.nl/blog/haskell/cps-functional-references">van Laarhoven encoding</a>, which represents them as a higher-order function parameterised over a typeclass. <code>optics</code> uses a variation on this, the ‘profunctor encoding’ (for which see the <a href="https://oleg.fi/gists/posts/2017-04-18-glassery.html">Glassery</a>).</p>
<p>The latter two encodings are in fact immensely powerful, allowing for a number of different generalisations on the basic theme. For instance, a <code>Traversal</code> points to multiple values at once:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">ghci&gt; [1,2,3,4,5] &amp; traverse +~ 10
[11,12,13,14,15]
ghci&gt; [1,2,3,4,5] &amp; taking 3 traverse +~ 10
[11,12,13,4,5]
ghci&gt; [1,2,3,4,5] &amp; dropping 3 traverse +~ 10
[1,2,3,14,15]
ghci&gt; [(1,2),(3,4),(5,6),(7,8),(9,10)] &amp; (dropping 3 traverse . both) +~ 10
[(1,2),(3,4),(5,6),(17,18),(19,20)]
ghci&gt; [(1,2),(3,4),(5,6),(7,8),(9,10)] &amp; dropping 3 (traverse.both) +~ 10
[(1,2),(3,14),(15,16),(17,18),(19,20)]
ghci&gt; [(1,2),(3,4),(5,6),(7,8),(9,10)] &amp; dropping 3 (traverse._1) +~ 10
[(1,2),(3,4),(5,6),(17,8),(19,10)]
</code></pre>
<p>As you can see, they combine nicely with other traversals and lenses, with a great deal of specificity. Similarly, <code>Prism</code>s let you select things which may be present or absent:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">ghci&gt; Left 1 &amp; _Left +~ 10
Left 11
ghci&gt; Right 1 &amp; _Left +~ 10
Right 1
ghci&gt; isn't _Left (Left 1)
False
ghci&gt; isn't _Left (Right 1)
True
</code></pre>
<p>Of course they too can combine with lenses, traversals, and all the other things defined by <code>lens</code> (e.g. the operator <code>+~</code>, as above).</p>
<p>I could go on like this for a while but I’ll stop here…!</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/lenses-optics-possibly-applicable-to-pick-poke/2473">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/lenses-optics-possibly-applicable-to-pick-poke/2473</link>
          <pubDate>Wed, 04 Jun 2025 04:31:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2473</guid>
          <source url="https://rebol.metaeducation.com/t/lenses-optics-possibly-applicable-to-pick-poke/2473.rss">Lenses/Optics Possibly Applicable to PICK/POKE</source>
        </item>
        <item>
          <title>Reacting to TIE ($) To Automate Binding</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Binding</category>
          <description><![CDATA[
            <p>The biggest realization of "modern Binding" in Ren-C was that working in a <em>mostly unbound</em> world needed to be the default.</p>
<p>What had held up early attempts to "virtualize" binding was that I was trying to automatically spread binding information in mechanical operations.  e.g. when you would PICK a word out of a BLOCK!, the picked word would come back suitable to perform a GET on.  It did this by projecting the virtual binding from the block onto the returned Cell.</p>
<p>I gave this as an example of the kind of legacy pattern I was trying to keep working:</p>
<pre><code>double-assigner: func [block] [
    for-each [sw i] block [
        assert [(set-word? sw) (integer? i)]
        set sw 2 * i  ; historically assumes X: and Y: are bound
    ]
]

double-assigner [x: 10 y: 20]
</code></pre>
<p><em>But this makes an assumption that may not be correct...and in fact, often is not.</em>  In a world where unbound material is an effective currency, you can't guess that the user wanted the binding to be propagated.  They may have just been interested in the raw material.</p>
<p>So this spawned the dawn of <strong>"conscious binding"</strong>, where you had to use specific operations at each step:</p>
<pre><code>double-assigner: func [block] [
    for-each [sw i] block [
        assert [(set-word? sw) (integer? i)]  ; both SW and I are *unbound*
        set (inside block sw) 2 * i  ; &lt;-- INSIDE BLOCK makes all the difference
   ]
]

double-assigner [x: 10 y: 20]
</code></pre>
<p>We can debate the BIND "dialect", and whether the INSIDE operator is the right one or not... but this captures the general spirit of things.</p>
<h2><a name="p-8318-using-our-dialect-powerswhat-about-the-tie-1" class="anchor" href="https://rebol.metaeducation.com#p-8318-using-our-dialect-powerswhat-about-the-tie-1"></a>Using Our Dialect Powers...What About the TIE ($)?</h2>
<p>So in this FOR-EACH example, we can already imagine a convenience... of being able to annotate variables to say you want to propagate the binding (or "tie" the variables to the binding of the block).  How about this?</p>
<pre><code>double-assigner: func [block] [
    for-each [$sw i] block [
        assert [(set-word? sw) (integer? i)]  ; SW bound into block's context
        set sw 2 * i
   ]
]

double-assigner [x: 10 y: 20]
</code></pre>
<p>That's convenient!</p>
<h2><a name="p-8318-what-if-you-wanted-a-lift-ed-bound-variable-2" class="anchor" href="https://rebol.metaeducation.com#p-8318-what-if-you-wanted-a-lift-ed-bound-variable-2"></a>What If You Wanted A ^LIFT-ed Bound Variable?</h2>
<p>There's also <code>@PIN</code>-ned variables which means "reuse an existing variable, don't make a new one".</p>
<p><strong>This means we need the "Sigil-Composition" that <a class="mention" href="https://rebol.metaeducation.com/u/bradrn">@bradrn</a> has spoken up for.</strong>  But instead of accomplishing it with BLOCK!s the way I've been doing, we now have some lighter options...</p>
<pre><code> for-each [@:$sw i] block [...]  ; reuse and bind

 for-each [$:^sw i] block [...]  ; bind and lift

 for-each [^:$sw i] block [...]  ; lift and bind (synonym, we assume?)

 for-each [^:$:@sw i] block [...]  ; lift and bind and reuse
</code></pre>
<p>It's not the prettiest thing in the world, but I don't imagine you'd usually need more than one Sigil.</p>
<p>Maybe you could put them in BLOCK!s to help visually:</p>
<pre><code> for-each [[^:$:@sw] i] block [...]  ; lift and bind and reuse
</code></pre>
<p>Did that help?  It kind of did.  CHAIN! seems to make the most sense... visually, and also because it doesn't really have any semantic baggage outside of trailing and leading colons.  And really only trailing colons have an obvious meaning.</p>
<p>Would it be better if the colons weren't there?</p>
<pre><code> for-each [[^ $ @sw] i] block [...]  ; lift and bind and reuse
</code></pre>
<p>I dunno.  I almost want to cluster the sigils together separate from the word:</p>
<pre><code> for-each [[^:$:@ sw] i] block [...]  ; lift and bind and reuse
</code></pre>
<p>We can debate this, but somewhere in here there will be a solution.</p>
<h2><a name="p-8318-what-about-sigil-meanings-on-lists-themselves-3" class="anchor" href="https://rebol.metaeducation.com#p-8318-what-about-sigil-meanings-on-lists-themselves-3"></a>What About Sigil Meanings On Lists Themselves?</h2>
<p>One of the earliest thoughts I had regarding the applications of @ as a "inert" Sigil was "what if REDUCE took this as a signal that the data was <em>already reduced</em>.</p>
<pre><code>&gt;&gt; reduce [1 + 2 10 + 20]
== [20 30]

&gt;&gt; reduce @[1 + 2 10 + 20]
== [1 + 2 10 + 20]
</code></pre>
<p>That might not seem useful, but it sort of is.  For instance, PACK uses this:</p>
<pre><code>&gt;&gt; pack [1 + 2 null]
== ~['3 ~null~]~  ; anti

&gt;&gt; pack @[1 + 2 null]
== ~['1 '+ '2 'null]~  ; anti
</code></pre>
<p>This comes up, when you've got a branching structure and you have some branches that want to return evaluative products and others that you want to return a pack of literals.</p>
<p>So the convention spread other places, e.g. ANY and ALL where you can run predicates on data and either reduce it or not.</p>
<p><strong>Could this same idea of pushing the convention onto the lists be useful... e.g. to make BLOCK!s that you "auto-bind" out of when you pick?</strong></p>
<pre><code>&gt;&gt; x: 10

&gt;&gt; tieblock: @ $[x y]
== $[x y]  ; bound by the lone PIN operator (a.k.a THE)

&gt;&gt; tieblock: the $[x y]
== $[x y]  ; bound - if you prefer words vs. symbols

&gt;&gt; tieblock: $ '$[x y]
== $[x y]  ; bound - if you want another way to say the same thing

&gt;&gt; tieblock: bind here '$[x y]
== $[x y]  ; bound - just for the sake of completeness...
</code></pre>
<p>Okay, you get the idea on the binding.  But my question is: would there be operators that upon seeing a TIED! list, would automatically bind when you picked things out of them?</p>
<p>So instead of the binding behavior coming from the variable you were using in a FOR-EACH, it would come from the data.  Or maybe even just a PICK would work:</p>
<pre><code>&gt;&gt; pick tieblock 1
== x  ; bound

&gt;&gt; get pick tieblock 1
== 10
</code></pre>
<p>So if it was an ordinary block..</p>
<pre><code>&gt;&gt; x: 10

&gt;&gt; block: [x y]

&gt;&gt; get pick block 1
** Error: X not bound...

&gt;&gt; get pick tie block 1
== 10
</code></pre>
<p>This definitely turns Sigil-carrying entities into beasts-with-behaviors.  But since the common currency in the system is normal BLOCK!/GROUP!/FENCE!, it may be that most of the creations of these beasts would be transient... existing only long enough to cue the PICK or FOR-EACH or whatever to do its behavior.</p>
<h2><a name="p-8318-you-dont-know-until-you-try-man_shrugging-4" class="anchor" href="https://rebol.metaeducation.com#p-8318-you-dont-know-until-you-try-man_shrugging-4"></a>You Don't Know Until You Try... <img src="https://rebol.metaeducation.com/images/emoji/twitter/man_shrugging.png?v=14" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></h2>
<p>I'm worried about there not being some mechanical terra-firma.  PICK seems foundational.  So perhaps there's some difference here, e.g. between PICK and another operator like SELECT could heed the sigils on the target data (?)  And FOR-EACH seems foundational too, but I think decorating the variable is fair game.</p>
<p>Anyway, it's an area I'll start experimenting with and report on whether any of the experiments turn out to make things clearer/better or worse.  (!)</p>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/reacting-to-tie-to-automate-binding/2462">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/reacting-to-tie-to-automate-binding/2462</link>
          <pubDate>Mon, 19 May 2025 15:46:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2462</guid>
          <source url="https://rebol.metaeducation.com/t/reacting-to-tie-to-automate-binding/2462.rss">Reacting to TIE ($) To Automate Binding</source>
        </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Build System - AltRebol</title>
    <link>https://rebol.metaeducation.com/c/development/build-system/44</link>
    <description>Topics in the &#39;Build System&#39; category Discuss rebol-make and other build systems.</description>
    
      <lastBuildDate>Tue, 17 Jun 2025 09:05:58 +0000</lastBuildDate>
      <atom:link href="https://rebol.metaeducation.com/c/development/build-system/44.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Changing Build System Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>There was an old dialect that used blocks, like:</p>
<pre><code> sources-C: [
     %file1.c
     [%file2.c &lt;some&gt; &lt;options&gt;]
     %file3.c
 ]
</code></pre>
<p>This was because it was based on MAP-EACH and processing items seemed "easier" to do when you could go one item at a time.</p>
<p>But I decided I didn't like it.  I prefer to have the option blocks separate.  I'm also going back to accepting TUPLE!s/PATH!s (a bootstrap issue got in the way of this, but I found a workaround).</p>
<pre><code> sources-C: [
     file1.c
     file2.c [&lt;some&gt; &lt;options&gt;]
     file3.c
 ]
</code></pre>
<p>Traversing this means you have to do some PARSE-ing, but that's what makes it interesting.</p>
<p>Here's some code that's getting tossed, that did some "canonicalizing" of the old format:</p>
<pre><code>; Some places (like SOURCES: in %make-spec.r for extensions) are permissive
; in terms of their format:
;
;     sources-A: %file.jpg
;
;     sources-B: [%file.jpg &lt;some&gt; &lt;options&gt;]
;
;     sources-C: [
;         %file1.jpg
;         [%file2.jpg &lt;some&gt; &lt;options&gt;]
;         %file3.jpg
;     ]
;
; It's a bit irregular, but convenient.  This function regularizes it:
;
;     sources-A: [
;         [%file.c]
;     ]
;
;     sources-B: [
;         [%file.c &lt;some&gt; &lt;options&gt;]
;     ]
;
;     sources-C: [
;         [%file1.c]
;         [%file2.c &lt;some&gt; &lt;options&gt;]
;         [%file3.c]
;     ]
;
export to-block-of-file-blocks: func [
    return: "Will be a top-level COPY of the block, or new block"
        [block!]
    x [&lt;opt&gt; file! block!]
][
    if file? x [
        return reduce [blockify x]  ; case A
    ]
    any [null? x, x = []] then [
        return copy []
    ]
    if file? x.1 [
        all [
            not find (next x) file!
            not find (next x) block!
        ] then [
            return reduce [x]  ; case B
        ]
        ; fallthrough
    ]
    if find x tag! [  ; light check for mistakes
        panic [
            "FILE!/BLOCK! list can't contain TAG!s if multiple files:"
            mold:limit x 200
        ]
    ]
    return map-each 'item x [blockify item]  ; case C
]
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/changing-build-system-dialect/2491">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/changing-build-system-dialect/2491</link>
          <pubDate>Tue, 17 Jun 2025 09:05:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2491</guid>
          <source url="https://rebol.metaeducation.com/t/changing-build-system-dialect/2491.rss">Changing Build System Dialect</source>
        </item>
        <item>
          <title>ARM Mac and ARM Linux Builds</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>I wasn't looking forward to trying to remote-debug the builds on mac by building them on GitHub containers, downloading the artifacts, pushing to GitHub and repeating again.</p>
<p>So I caved and bought a Macbook Air.</p>
<p>I hacked together a makefile that could build the bootstrap executable, but then I went through the labor of figuring out how to get a legitimate build... with warnings turned up to errors... on Clang under zsh on Mac.</p>
<p>And today I got that to work.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/e47559b4a4d9d7a362760df3f101742e6fb6bb4f.jpeg" data-download-href="https://rebol.metaeducation.com/uploads/default/e47559b4a4d9d7a362760df3f101742e6fb6bb4f" title="macrebol"><img src="https://rebol.metaeducation.com/uploads/default/optimized/1X/e47559b4a4d9d7a362760df3f101742e6fb6bb4f_2_517x206.jpeg" alt="macrebol" data-base62-sha1="wB2hGVKa8jK7kEBclgsAknBHY19" width="517" height="206" srcset="https://rebol.metaeducation.com/uploads/default/optimized/1X/e47559b4a4d9d7a362760df3f101742e6fb6bb4f_2_517x206.jpeg, https://rebol.metaeducation.com/uploads/default/optimized/1X/e47559b4a4d9d7a362760df3f101742e6fb6bb4f_2_775x309.jpeg 1.5x, https://rebol.metaeducation.com/uploads/default/optimized/1X/e47559b4a4d9d7a362760df3f101742e6fb6bb4f_2_1034x412.jpeg 2x" data-dominant-color="1F2329"></a></div><p></p>
<h2><a name="p-8138-gccxxx-vs-gnuxxx-vs-clangxxx-1" class="anchor" href="https://rebol.metaeducation.com#p-8138-gccxxx-vs-gnuxxx-vs-clangxxx-1"></a><code>&lt;gcc:XXX&gt;</code> vs <code>&lt;gnu:XXX&gt;</code> vs <strong><code>&lt;clang:XXX&gt;</code></strong></h2>
<p>One of the design ideas Shixin had for Rebmake was that you could specity compiler flags and such either literally as a string, or you could make them conditional by making them tags.</p>
<p>So if you had a file and you wanted to say disable errors pertaining to sign comparison, you might put your file in the files list as:</p>
<pre><code>[%some-file.c &lt;gcc:-Wno-sign-compare&gt; &lt;msc:/wd4388&gt;]
</code></pre>
<p>Then what would happen is that if you were building with gcc you'd get the compiler switch <code>-Wno-sign-compare</code> but if you were building with Microsoft CL you'd get <code>/wd4388</code> (warning-disable)</p>
<p>This was a pretty good idea, but the problem is that while Clang and GCC share many warnings in common, there are exceptions.</p>
<p>So I subdivided it so that flags which are common to both are <code>&lt;gcc:XXX&gt;</code>.  This makes sense given that Clang came after gcc, and adopted their warning lists to begin with.</p>
<p>Then GCC-specific flags are <code>&lt;gnu:XXX&gt;</code> and Clang-specific flags are <code>&lt;clang:XXX&gt;</code></p>
<h2><a name="p-8138-eliminating-separate-compiler-linker-abstractions-2" class="anchor" href="https://rebol.metaeducation.com#p-8138-eliminating-separate-compiler-linker-abstractions-2"></a>Eliminating Separate Compiler / Linker Abstractions</h2>
<p>To make a long story short: in the C world, there are "compiler front ends" and you typically can get away with using the program that does the compiling (e.g. GCC) to delegate to the linker (e.g. LD) to do the linking for you.  In fact: you typically <em>don't</em> want to call the linker explicitly, because there's a bunch of fiddly stuff the front end figures out for you.</p>
<p>But Rebmake had the idea of trying to call linkers explicitly, and decoupling the linker from the compiler.  This led to repeated work--and things like having to know the minor nuances of how GCC's LD was different from LLVM-LINK.</p>
<p>I just wiped that code out and gave the compiler abstraction LINK and COMPILE methods, and reduced the number of moving parts considerably.  This was part of making it easier to pare down things to really let the clang vs. gcc share as much code in common as possible, while still differentiating which tags held compiler switches that applied to them.</p>
<h2><a name="p-8138-rebmake-gets-less-beastly-every-time-3" class="anchor" href="https://rebol.metaeducation.com#p-8138-rebmake-gets-less-beastly-every-time-3"></a>Rebmake Gets Less Beastly Every Time...</h2>
<p>I've always dreaded having to mess with Rebmake.  But I have already credited it with being a huge source of inspiration on how to make the language less inscrutable.  Necessity was the mother of invention, and all the hardships of Rebmake helped make Ren-C better.</p>
<p>Anyway, hacking on it to get it to cleanly support the M4 / zsh / Clang builds led to some improvemnet.  And I think that as string interpolation and other features make their way into it, there might be some light at the end of the Rebmake tunnel...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/arm-mac-and-arm-linux-builds/2411">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/arm-mac-and-arm-linux-builds/2411</link>
          <pubDate>Sat, 12 Apr 2025 10:33:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2411</guid>
          <source url="https://rebol.metaeducation.com/t/arm-mac-and-arm-linux-builds/2411.rss">ARM Mac and ARM Linux Builds</source>
        </item>
        <item>
          <title>Accepting the availability of stdint.h and stdbool.h</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>One of Carl's comments in R3-Alpha complained about the lack of a standardization of integer sizes in C:</p>
<blockquote>
<p><em>"One of the biggest flaws in the C language was not to indicate bitranges of integers. So, we do that here.  You cannot 'abstractly remove' the range of a number.  It is a critical part of its definition."</em></p>
</blockquote>
<p>So he did some empirical platform detection to define things like REBI32 for a signed 32-bit integer, REBU64 for an unsigned 64-bit integer, etc.</p>
<p>But once C99 arrived, the file &lt;stdint.h&gt; offered several basic types, and basically covered the needs with types that had names like <strong>int32_t</strong> and <strong>uint64_t</strong>:</p>
<p><a href="http://en.cppreference.com/w/c/types/integer" class="inline-onebox">Fixed width integer types (since C99) - cppreference.com</a></p>
<p>So Ren-C was changed to use the C99 names and include <code>&lt;stdint.h&gt;</code>.  For pre-C99 compilers, it used a portable shim called "pstdint", which it maintained its own copy of in the repository:</p>
<p><strong><a href="https://github.com/metaeducation/ren-c/blob/e6e3e7fe0fcff165557f9ffc3de3e6713a50f99a/src/include/pstdint.h">src/include/pstdint.h</a></strong></p>
<p>By similar reasoning, booleans were shimmed with another found-file:</p>
<p><strong><a href="https://github.com/metaeducation/ren-c/blob/e6e3e7fe0fcff165557f9ffc3de3e6713a50f99a/src/include/pstdbool.h">src/include/pstdbool.h</a></strong></p>
<h2><a name="p-6739-ren-c-has-embraced-c99-so-why-keep-these-shims-1" class="anchor" href="https://rebol.metaeducation.com#p-6739-ren-c-has-embraced-c99-so-why-keep-these-shims-1"></a>Ren-C Has Embraced C99, So Why Keep These Shims?</h2>
<p>C99 is now a prerequisite for building the system.</p>
<p>It may be that some pre-C99 standards compiler <em>could</em> still build Ren-C with these shims, though it would need variadic macro support.  The odds of a compiler having that support yet lacking things like <strong>bool</strong> and <strong>int32_t</strong> are fairly slim.</p>
<p>In any case, these esoteric compilation environments could be "shimmed" by hacking in versions of stdint.h and stdbool.h to their include directories.  I feel like that's the responsibility of the build environment at this point... and that the Ren-C codebase need not be carrying the baggage.</p>
<p>So I'm pulling the files out.  If anyone is on an esoteric platform and trying to build but finds these definitions being missing is the only problem, then they should dig up pstdint and pstdbool.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/accepting-the-availability-of-stdint-h-and-stdbool-h/2067">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/accepting-the-availability-of-stdint-h-and-stdbool-h/2067</link>
          <pubDate>Thu, 07 Dec 2023 18:40:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2067</guid>
          <source url="https://rebol.metaeducation.com/t/accepting-the-availability-of-stdint-h-and-stdbool-h/2067.rss">Accepting the availability of stdint.h and stdbool.h</source>
        </item>
        <item>
          <title>Number of Files and Folders: More Is Okay</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>In the quest for simplicity, R3-Alpha had an aesthetic that tried to be very minimalist in the source tree.</p>
<p>The top level had only this:</p>
<pre><code>make/
src/
.gitattributes
.gitignore
LICENSE
NOTICE
README
</code></pre>
<p>The <strong>%make/</strong> directory contained:</p>
<pre><code>makefile
makefile.vc
vcbuild.bat
</code></pre>
<p>The <strong>%src/</strong> directory contained:</p>
<pre><code>boot/       20 files
core/       95 files
include/    31 files
mezz/       31 files
os/          7 files, with 2 directories of about 10 files each
tools/      10 files
</code></pre>
<p>The files themselves vary in size, but this just gives a perspective of about how many files there are.</p>
<h2><a name="p-6365-ren-c-and-red-use-many-more-files-and-directories-but-1" class="anchor" href="https://rebol.metaeducation.com#p-6365-ren-c-and-red-use-many-more-files-and-directories-but-1"></a>Ren-C and Red use <em>MANY</em> more files and directories, BUT...</h2>
<p><em><strong>Largely I think this is okay, moreover can be beneficial to understanding the code.</strong></em></p>
<p>While we should be skeptical of large amounts of complexity, I don't think there should be a kneejerk reaction to a lot of <em>files</em>.</p>
<p>Filesystems were invented for a reason: organization.  If arranging things in separate files makes the organization clear, it is good.</p>
<p>Yet there should be some justification for why a directory exists.  For instance: I think every directory should have a README.md in it, which explains why those files are grouped together.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/number-of-files-and-folders-more-is-okay/1958">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/number-of-files-and-folders-more-is-okay/1958</link>
          <pubDate>Sat, 03 Sep 2022 10:52:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1958</guid>
          <source url="https://rebol.metaeducation.com/t/number-of-files-and-folders-more-is-okay/1958.rss">Number of Files and Folders: More Is Okay</source>
        </item>
        <item>
          <title>On how to build REN-C on Windows</title>
          <dc:creator><![CDATA[iArnold]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>The build on Linux is according to the description in the Readme.md file. Now I needed to build on another machine, which happens to be a Windows box.<br>
I ran the build script in my r3 downloaded executable after which it became clear there was no gcc installed.<br>
How to proceed now? Is the TCC alternative available and even preferrable over gcc? Or is gcc the way to go and how to go on with installing that? Perhaps even use Visual Code?</p>
            <p><small>11 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/on-how-to-build-ren-c-on-windows/1845">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/on-how-to-build-ren-c-on-windows/1845</link>
          <pubDate>Mon, 20 Jun 2022 05:45:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1845</guid>
          <source url="https://rebol.metaeducation.com/t/on-how-to-build-ren-c-on-windows/1845.rss">On how to build REN-C on Windows</source>
        </item>
        <item>
          <title>Android AAB?</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>Android's APK is now being replaced with AAB.</p>
<aside class="onebox allowlistedgeneric" data-onebox-src="https://www.thurrott.com/dev/252614/google-is-replacing-android-apk-with-aab">
  <header class="source">
      <img src="https://thurrott-assets.nyc3.digitaloceanspaces.com/web/2020/07/logo-favicon-100x100.png" class="site-icon" width="100" height="100">

      <a href="https://www.thurrott.com/dev/252614/google-is-replacing-android-apk-with-aab" target="_blank" rel="noopener" title="03:23PM - 30 June 2021">Thurrott.com – 30 Jun 21</a>
  </header>

  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/388;"><img src="https://thurrott-assets.nyc3.digitaloceanspaces.com/web/2021/06/google-play-aab.jpg" class="thumbnail" width="690" height="388"></div>

<h3><a href="https://www.thurrott.com/dev/252614/google-is-replacing-android-apk-with-aab" target="_blank" rel="noopener">Google is Replacing Android APK with AAB</a></h3>

  <p>And if you don’t know what that means, that’s OK, it probably just means that you’re not an Android developer.</p>

  <p>
    <span class="label1">Est. reading time: 1 minute</span>
  </p>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>Is anyone doing any work on this?<br>
And is there an AAB based on Ren-c that I can use to keep the RebolFoundation developer account alive?  Google wants proof we are alive.</p>
<p>Thanks,</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/android-aab/1731">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/android-aab/1731</link>
          <pubDate>Sat, 02 Oct 2021 07:42:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1731</guid>
          <source url="https://rebol.metaeducation.com/t/android-aab/1731.rss">Android AAB?</source>
        </item>
        <item>
          <title>Ren-C Builds on Haiku!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>I didn't realize bringing this up to date would take as long to tinker around with as it did (~ 8 hours), but...</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/1702f61a03d022ee405643e5defaa1521f3b7dd5.png" data-download-href="https://rebol.metaeducation.com/uploads/default/1702f61a03d022ee405643e5defaa1521f3b7dd5" title="ren-c-haiku-2021"><img src="https://rebol.metaeducation.com/uploads/default/optimized/1X/1702f61a03d022ee405643e5defaa1521f3b7dd5_2_610x500.png" alt="ren-c-haiku-2021" data-base62-sha1="3hzkeScW0sVzoA6Gja01IpM2cT3" width="610" height="500" srcset="https://rebol.metaeducation.com/uploads/default/optimized/1X/1702f61a03d022ee405643e5defaa1521f3b7dd5_2_610x500.png, https://rebol.metaeducation.com/uploads/default/optimized/1X/1702f61a03d022ee405643e5defaa1521f3b7dd5_2_915x750.png 1.5x, https://rebol.metaeducation.com/uploads/default/optimized/1X/1702f61a03d022ee405643e5defaa1521f3b7dd5_2_1220x1000.png 2x" data-dominant-color="A4B9CA"></a></div><br>
<strong>Why was it such a pain?...</strong><p></p>
<h1><a name="p-5485-gcc-2953-was-released-in-march-2001httpsgccgnuorgreleaseshtml-1" class="anchor" href="https://rebol.metaeducation.com#p-5485-gcc-2953-was-released-in-march-2001httpsgccgnuorgreleaseshtml-1"></a>GCC 2.95.3 was Released <a href="https://gcc.gnu.org/releases.html">in March 2001</a></h1>
<p><strong>Don't let the 2017 build date fool you.</strong>  That's a 20-year old compiler, which we assume has the occasional Haiku patch here and there.</p>
<p>I knew the compiler that came with Haiku had been old.  But when I was making decisions about letting go of C89 support (in the core) I figured that Haiku would be bumping their versions to support C99 at some point...</p>
<p><em>Nope.</em></p>
<p>The reason Haiku is still so far back appears to be because they depend on GCC 2.95 features that enable them to get binary compatibility with old BeOS packages.</p>
<p>You can install a more modern GCC if you like--but then you're off in the concerns of having multiple toolchains on your system.  And presumably it's harder to link up against the HaikuOS C++ platform APIs.  So I thought it would be a good proof of our light dependencies to build on what's there.</p>
<h2><a name="p-5485-note-not-just-us-mbedtls-dropped-their-c89-support-2" class="anchor" href="https://rebol.metaeducation.com#p-5485-note-not-just-us-mbedtls-dropped-their-c89-support-2"></a>Note: Not Just Us, mbedTLS Dropped Their C89 Support</h2>
<p>Even the most die -hard of low-dependency systems have let go of the 80s.  In 2019, mbedTLS <a href="https://github.com/ARMmbed/mbedtls/issues/1484">ceased supporting C89</a>:</p>
<blockquote>
<p><em>"We've internally decided to drop support for C89 in the development branch. We've removed <code>-Wdeclaration-after-statement</code> to our build options in <code>CMakeLists.txt</code>. We run some builds with <code>gcc -std=c99 -pedantic</code> so we do test C99 compliance to a reasonable extent. Thus this issue is resolved."</em></p>
</blockquote>
<h2><a name="p-5485-options-were-either-give-up-or-revive-the-c98-build-3" class="anchor" href="https://rebol.metaeducation.com#p-5485-options-were-either-give-up-or-revive-the-c98-build-3"></a>Options Were Either Give Up, Or Revive the C++98 Build</h2>
<p>At one point Ren-C was able to build as C++98.  I stopped seeing the point of maintaining this option...as it was silly to be keeping track of which features I could use from C++11 in which permutations.  So it was either you build as C or you build as C++11 (or higher).</p>
<p>But there really is no other choice with this GCC 2.95.  The code is now styled:</p>
<pre><code>printf("Here's a statement\n");

const char *str = "Here's a declaration after a statement";
</code></pre>
<p>The Haiku C compilation mode requires all your definitions to be before the statements:</p>
<pre><code>const char *str; 

printf("Here's a statement\n");

str = "Here's a declaration after a statement";
</code></pre>
<p><em>(Note: I hate that, because it makes maintenance much harder.  But <a href="https://rdrr.io/cran/httpuv/f/src/libuv/CONTRIBUTING.md">libuv is actually a holdout here</a>...they're carrying the torch for C89 and committers still have to code in that style.)</em></p>
<p>In any case, C++98 was able to do that.  So I revived the setting.  It wasn't too hard...I just made it act like the C build <em>almost all of the time</em>.  Hence no use of inheritance in REBVAL or anything like that.  It deviates only when it has to for compiler semantics.</p>
<h2><a name="p-5485-building-mbedtls-was-saved-by-a-pedantic-quirk-4" class="anchor" href="https://rebol.metaeducation.com#p-5485-building-mbedtls-was-saved-by-a-pedantic-quirk-4"></a>Building mbedTLS Was Saved By A --pedantic Quirk</h2>
<p>While Ren-C was designed to compile as C or C++, mbedTLS is plain C.  C++ compilers will choke on some of the permissive treatment of <code>void*</code>.</p>
<p>I thought there'd be no way around this; because C++ compilers have no way to disable these errors.  <em>...or so I thought...</em>!</p>
<p>As it turns out, if you <em>raise</em> the error reporting level with "pedantic" warnings, the warning machinery notices the problems before the error!  And you can ignore warnings!</p>
<p>So oddly enough, I actually could compile the encryption code on Haiku (without having to go in and edit it).</p>
<h2><a name="p-5485-small-rewrites-needed-to-dodge-compiler-bugs-5" class="anchor" href="https://rebol.metaeducation.com#p-5485-small-rewrites-needed-to-dodge-compiler-bugs-5"></a>Small Rewrites Needed To Dodge Compiler Bugs</h2>
<p>Minor changes were required to code that was triggering GCC 2.95 bugs that prevented the build.  I wouldn't be happy if I had to make a dozen changes for it, but it was a few.</p>
<p>I guess even if you write code that is correct, if you notice it triggering a compiler bug that may be a sign that it involves something hard for compilers to get right.  One might be able to balance the annoyance of having to make the change with the potential that maybe fewer compilers would be getting that bit wrong.</p>
<h2><a name="p-5485-networking-doesnt-work-but-after-libuv-switch-it-might-6" class="anchor" href="https://rebol.metaeducation.com#p-5485-networking-doesnt-work-but-after-libuv-switch-it-might-6"></a>Networking Doesn't Work, But After LibUV Switch, It Might!</h2>
<p>I built the entirety of LibUV into the executable (even though I didn't technically have to).  And the filesystem code--which is now on libuv--seems to be working.</p>
<p>The networking isn't on libuv yet, and isn't seeming to work.  But maybe once it switches over, it will.  I mentioned that Haiku was one of the explicitly supported platforms of libuv.  So if all goes smoothly in that conversion, I imagine this will work!</p>
<h2><a name="p-5485-no-action-item-here-just-proving-it-could-be-done-7" class="anchor" href="https://rebol.metaeducation.com#p-5485-no-action-item-here-just-proving-it-could-be-done-7"></a>No Action Item Here, Just Proving It Could Be Done</h2>
<p>This was a good head-check of what exactly has changed as Ren-C has refactored and evolved.  Letting certain dependencies creep in can make your source less adaptable and agile...and this helps be assured that things are still on track.</p>
<p>What's important here isn't "oh, now we can have millions of HaikuOS users".  Rather it serves as another example of managed dependency control--to lend confidence to the idea that porting to other new ones should be easy enough.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/ren-c-builds-on-haiku/1710">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/ren-c-builds-on-haiku/1710</link>
          <pubDate>Fri, 10 Sep 2021 17:28:40 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1710</guid>
          <source url="https://rebol.metaeducation.com/t/ren-c-builds-on-haiku/1710.rss">Ren-C Builds on Haiku!</source>
        </item>
        <item>
          <title>Siskin-Builder (Rebol-based build tool by Oldes)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>Oldes apparently has undertaken the task of making a <a href="https://github.com/Siskin-framework/Builder">build dialect/tool for his branch of Rebol3</a>.  This animated GIF makes it seem pretty slick looking in the console:</p>
<p>          <a href="https://raw.githubusercontent.com/Oldes/media/master/screens/build-siskin.gif" target="_blank" rel="noopener" class="onebox">
            <img src="https://raw.githubusercontent.com/Oldes/media/master/screens/build-siskin.gif" width="690" height="457">
          </a>
</p>
<p>The makefiles are called ".nest" files, and here's the one in his R3 repository:</p>
<p><strong><a href="https://github.com/Oldes/Rebol3/blob/master/make/rebol3.nest" class="inline-onebox">Rebol3/make/rebol3.nest at master · Oldes/Rebol3 · GitHub</a></strong></p>
<h2><a name="p-5391-new-ideas-1" class="anchor" href="https://rebol.metaeducation.com#p-5391-new-ideas-1"></a>New Ideas?</h2>
<p>Looking past the nice colors and presentation, I don't know if any "big new ideas" jump out at me in terms of a dialect.</p>
<p><strong>Preprocessor Usage</strong></p>
<p>The primary thing that does jump out at me is use of a preprocessor.  He has branches for <strong><span class="hashtag-raw">#if</span> Windows [...]</strong> that let you ask for transformations and selections in the middle of lists that are data.  Less cluttered than going through and COMPOSE-ing everything, and lets you stay in the declarative domain.</p>
<p>Seems he's using a generic preprocessing script--not one that's specific to just this tool--and that's probably a good idea.  Though now that <strong><span class="hashtag-raw">#a</span></strong> is used for characters this gets a bit stickier... even if you were previously willing to sacrifice ISSUE! in your file so you could do preprocessing, you now would be sacrificing your notation for characters too.</p>
<p><em>(I should point out that with generic quoting, you do have <strong><code>'#a</code></strong>, so at least in evaluative circumstances you'd have a way to escape out of the preprocessor.  It might be that if you use a preprocessor on the file, all your #... that you don't want to represent preprocessing instructions are just quoted out?)</em></p>
<p><strong>Requiring the % on File Paths</strong></p>
<p>He does use <strong>%file/path.c</strong> instead of <strong>file/path.c</strong> -- and that's a case where I've pointed out that Carl chose to use the lighter notation without the %.</p>
<p>I think that designing a dialect that is heavily dealing with paths as data, that if you can dodge the % then it makes it nicer to look at and edit.  If you want to allow for evaluations, you would use GROUP!s or <span class="mention">@vars</span> or something else.</p>
<h2><a name="p-5391-our-nightmare-build-system-is-still-upping-my-game-2" class="anchor" href="https://rebol.metaeducation.com#p-5391-our-nightmare-build-system-is-still-upping-my-game-2"></a>Our Nightmare Build System Is Still Upping My Game</h2>
<p>Oldes's makefile here, and one that Giulio made...as well as Carl's original, are all a far cry from the mind-bending behemoth that is Rebmake.</p>
<p>Not only is Rebmake a beast, we have a bootstrap compatibility layer for morphing a several year old interpreter into a common subset to run it.  It's a mind-bending challenge...the details of which I generally spare you from.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/exploding_head.png?v=14" title=":exploding_head:" class="emoji" alt=":exploding_head:" loading="lazy" width="20" height="20"></p>
<p>It's nice to be reminded that we can do a lot smaller than that.  But oddly enough, the challenges of working with Rebmake and the %bootstrap-shim have been forcing more and more inventions in how to make the bendiest language ever.</p>
<p>And Rebmake isn't overtly unreasonable; its the kind of approach that someone who's thinking in OOP terms would think if they were trying to clone CMake's object model in a 1:1 fashion.  So it has been the mother of invention for complexity-taming tools...and stressing the language in areas that someone with a pure Rebol mindset wouldn't think to stress it in.</p>
<p>Which may explain why I'm not as urgently trying to jettison Rebmake or run on a modern Ren-C as one might think.  Because forcing a new Ren-C to be able to meet an old one in the middle to run a crazy codebase is hardening the system.</p>
<p>But... definitely, yes, someday we're going to pitch the thing and get something lighter.</p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/recycle.png?v=14" title=":recycle:" class="emoji only-emoji" alt=":recycle:" loading="lazy" width="20" height="20"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/siskin-builder-rebol-based-build-tool-by-oldes/1672">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/siskin-builder-rebol-based-build-tool-by-oldes/1672</link>
          <pubDate>Thu, 19 Aug 2021 06:56:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1672</guid>
          <source url="https://rebol.metaeducation.com/t/siskin-builder-rebol-based-build-tool-by-oldes/1672.rss">Siskin-Builder (Rebol-based build tool by Oldes)</source>
        </item>
        <item>
          <title>The New Ren-C GitHub Action: Run Natively, Run on Web!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1547">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/using-ren-c-as-the-shell-in-github-ci/1547/1">Using Ren-C As The Shell In GitHub CI</a></div>
<blockquote>
<p>A GitHub Action can make including the feature as easy as one line for users. And we have the advantage of being able to make single-exe tools that could install on all the container types. <em>(All of them are 64-bit. Sorry, Red...)</em></p>
</blockquote>
</aside>
<p>So I went through the pain and suffering of learning how to do this.</p>
<p><em>It's a small thing in some sense, but very high leverage!</em></p>
<p><strong><a href="https://github.com/metaeducation/ren-c-action">A First Draft of a Quite Useful Ren-C Action</a></strong></p>
<ul>
<li>
<p><strong>It auto-detects your platform (Windows, Linux, MacOS) and downloads an R3 Executable for that platform</strong></p>
</li>
<li>
<p><strong>It uses GitHub Actions caching to remember where it installed itself, so multiple steps can use the executable without doing multiple downloads</strong></p>
</li>
<li>
<p><strong>It adds the r3 executable to your path, so you can use it from bash as well as with inline script code</strong></p>
</li>
<li>
<p>...and as a bonus feature... <strong>It can run script code in the web build via browser automation, so you can use it to test scripts intended to be run on the web as well</strong>.</p>
</li>
</ul>
<p>You can see <a href="https://github.com/metaeducation/ren-c/commit/f6b3411abf367be47d05e5ce58ea2de117255cc5">how much nicer the web build test</a> got by using it.  The Python code that lived in the ReplPad tests directory as well as the shell code for the web build are now both moved into the <code>ren-c-action</code>, and it's generalized. This should make it easy to add the action to a repository that is something like <a class="mention" href="https://rebol.metaeducation.com/u/gchiu">@gchiu</a>'s NZPower.</p>
<p>There are <a href="https://github.com/metaeducation/ren-c-action/tree/main/src">a bunch of comments in the source</a> so you should be able to get the idea.  There's a few sticks and glue holding it together, but I think the basic approach is sound.</p>
<p>The main problem it has right now is that we don't have the latest builds getting uploaded.  So the next step for this to be useful will be to restore the uploading for OS X / Linux / Win32 builds.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/the-new-ren-c-github-action-run-natively-run-on-web/1562">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/the-new-ren-c-github-action-run-natively-run-on-web/1562</link>
          <pubDate>Tue, 16 Mar 2021 06:52:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1562</guid>
          <source url="https://rebol.metaeducation.com/t/the-new-ren-c-github-action-run-natively-run-on-web/1562.rss">The New Ren-C GitHub Action: Run Natively, Run on Web!</source>
        </item>
        <item>
          <title>Using Ren-C As The Shell In GitHub CI</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p><em>(Check this out, <a class="mention" href="https://rebol.metaeducation.com/u/giuliolunati">@giuliolunati</a> ...!)</em></p>
<p>There's a feature in GitHub CI which lets you override the shell used in a workflow.  You can do it for the whole workflow, or even on a step-by-step basis.</p>
<p>This got me to wondering what it would be like to use Ren-C as the shell for a step.  It took a little tinkering, but I got it to work!</p>
<p>Here it is using an executable for Windows (that it just built) to test HTTPS reads:</p>
<pre><code>- name: HTTPS Read Test
  shell: r3 --fragment {0}
  run: |
    print {== Hello From R3 HTTPS Read Test! ==}
    parse as text! read https://example.com [
        thru &lt;h1&gt; copy header: to &lt;/h1&gt; to end
    ] else [
        fail "Couldn't Capture Page Title"
    ]
    assert [header = "Example Domain"]
    print ["Succeeded:" header]
</code></pre>
<p><strong><a href="https://github.com/metaeducation/ren-c/runs/2066230493?check_suite_focus=true#step:16:40">And it works!!</a></strong></p>
<p>What GitHub is doing is it's taking the body of what's in the <strong><code>run</code></strong> section and writing it to a temporary file with a random name off in some weird directory.  Then it substitutes that weird name in for the <code>{0}</code> in the shell expression.</p>
<h2><a name="p-4915-the-new-fragment-option-1" class="anchor" href="https://rebol.metaeducation.com#p-4915-the-new-fragment-option-1"></a>The New <code>--fragment</code> Option</h2>
<p>There were a lot of details on the path to getting that working.  But I'll just focus here on the new feature of saying that a script is a "fragment".</p>
<ul>
<li>
<p><strong>We Don't Want To Change Into the Temporary Directory The Fragment Lives In</strong>.  Rebol has historically switched to the directory a script lives in, and on balance I think that's the right default.  It helps the script find its own resources, where it has the most likely ability to neatly refer to files by short paths.  But this is a lone file...there's nothing to gain by doing that, and it's a disruption.</p>
</li>
<li>
<p><strong>I Don't Think It Should Need A Header, Either</strong>.  It would be a competitive disadvantage in this scenario--compared to other shells--if you had to put a dummy header in there.  By using a special name and a setting for "fragment" we have a way on the command line of saying "hey, this has no header, and I meant that".</p>
</li>
<li>
<p><strong>GitHub CI Threw In CR LF, we need an excuse to tolerate it</strong>.  Even though the YAML for the original code had just LF, the temp file for the run lines got CRs added.  I'm still pretty bullish on saying we need to consider this just like a syntax error or any other illegal sequence of characters.  If a strong stance isn't taken, then it screws everyone forever.  But here the compromise is that you have declared this isn't the kind of file you'd be sharing...not a "full script"...so it makes it a bit more okay to strip the CR LF silently (On Windows only, though!)</p>
</li>
</ul>
<h2><a name="p-4915-bulb-github-action-dialects-might-have-a-lot-of-potential-bulb-2" class="anchor" href="https://rebol.metaeducation.com#p-4915-bulb-github-action-dialects-might-have-a-lot-of-potential-bulb-2"></a><img src="https://rebol.metaeducation.com/images/emoji/twitter/bulb.png?v=14" title=":bulb:" class="emoji" alt=":bulb:" loading="lazy" width="20" height="20"> GitHub Action Dialects Might Have A Lot Of Potential <img src="https://rebol.metaeducation.com/images/emoji/twitter/bulb.png?v=14" title=":bulb:" class="emoji" alt=":bulb:" loading="lazy" width="20" height="20"></h2>
<p>Not everyone has figured out that this is possible, yet.  But I found <a href="https://discourse.julialang.org/t/tip-use-julia-as-custom-shell-in-github-actions/53377">a post on the Julia forum</a> while I was doing it, showing that a few people are catching on to the idea.</p>
<p>But what we can do in customization could potentially go quite a lot farther than "Bash control structures but in a language you are more familiar with".  What the code does can be creatively tailored to the domain being solved.</p>
<p>A GitHub Action can make including the feature as easy as one line for users.  And we have the advantage of being able to make single-exe tools that could install on all the container types.  <em>(All of them are 64-bit.  Sorry, Red...)</em></p>
<p>Could be interesting.  We'll see!</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/using-ren-c-as-the-shell-in-github-ci/1547">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/using-ren-c-as-the-shell-in-github-ci/1547</link>
          <pubDate>Tue, 09 Mar 2021 12:37:07 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1547</guid>
          <source url="https://rebol.metaeducation.com/t/using-ren-c-as-the-shell-in-github-ci/1547.rss">Using Ren-C As The Shell In GitHub CI</source>
        </item>
        <item>
          <title>Android&#39;s Back! Modernized, and With Continuous Integration</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>Since I was on a roll with the TCC Bootstrap and the Windows Builds on GitHub Actions, I decided to take a crack at bringing the Android builds back.</p>
<p>It would be underwhelming if I didn't bring things somewhat up-to-date in the process.  Android NDK versions are numbered by [r]evisions, and we had been on "r13" from October 2016.  Five years ago is basically eternity in cell phone time...and the revisions have counted up steadily since then, currently at "r21" (!)</p>
<p>So I dug in and suffered for another long continuous day-and-night to make it happen.</p>
<p><strong><a href="https://github.com/metaeducation/ren-c/runs/2050208508?check_suite_focus=true">And They're Back!!!</a></strong></p>
<h2><a name="p-4908-big-change-toolchain-switch-to-clang-1" class="anchor" href="https://rebol.metaeducation.com#p-4908-big-change-toolchain-switch-to-clang-1"></a>Big Change: Toolchain Switch to Clang</h2>
<p>The Android toolset was originally based on GCC.  But they wound up switching to Clang...starting by making it available in revision r16, and then removing the GCC support altogether in r18.</p>
<p>This may seem like a minor change for us (and it probably would have been easier if I knew more about the NDK to start with).  But cross compilation is never "simple", and Android is a particularly crazy combinatoric monster.  When the .zipped file for installing the SDK is 500MB--with executables for only <em>one</em> of the cross-compiling platforms--you can bet there's a lot in there to trip up.</p>
<p>I'll spare you the details, but you can read <strong><a href="https://github.com/metaeducation/ren-c/blob/master/configs/android-common.r">config/android-common.r</a></strong> if you want to see comments I wrote to document the process.</p>
<h2><a name="p-4908-still-supporting-the-older-ndks-2" class="anchor" href="https://rebol.metaeducation.com#p-4908-still-supporting-the-older-ndks-2"></a>Still Supporting The Older NDKs!</h2>
<p>The Google Play store will only accept apps that are built with very recent API Levels!</p>
<p>But I think it's interesting to be in the position that we can still build against older NDKs, perhaps for older hardware.  It's a distinguishing feature.</p>
<p>Anyway, I made the script detect the version and react accordingly.  Maybe there will be a time when it's not worth it to support the older NDKs, but for now it doesn't cost much...and it helps keep a check on making sure that if we use any "newfangled" APIs that only exist on certain modern devices, we do so consciously.</p>
<h2><a name="p-4908-next-steps-ci-testing-3" class="anchor" href="https://rebol.metaeducation.com#p-4908-next-steps-ci-testing-3"></a>Next Steps... CI Testing!</h2>
<p>So I said that I wanted anything we thought was important to be rigged up with automated testing.  I did some research into Android emulators that could run "headlessly" with no screen...let you install apps on a virtual phone, and run tests.  Such things do exist, and we could run them on GitHub Actions!</p>
<aside class="onebox allowlistedgeneric" data-onebox-src="https://github.com/marketplace/actions/android-emulator-runner">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">

      <a href="https://github.com/marketplace/actions/android-emulator-runner" target="_blank" rel="noopener">GitHub</a>
  </header>

  <article class="onebox-body">
    <img width="400" height="400" src="https://avatars.githubusercontent.com/u/51352484?s=400&amp;v=4" class="thumbnail onebox-avatar">

<h3><a href="https://github.com/marketplace/actions/android-emulator-runner" target="_blank" rel="noopener">Android Emulator Runner - GitHub Marketplace</a></h3>

  <p>Installs, configures and starts an Android Emulator directly on hardware-accelerated runners</p>


  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>They say it only runs on Mac hosts.  So that incentivizes hammering on the cross-compile script until it's able to use platforms other than Linux to build for Android.  It may not actually be all that hard to do (will have to find out...)  Of course we could build on Linux and then just send that product to a mac to run the emulator.</p>
<p>Getting that ability to run a simulator that can test the built Android executable is a priority.</p>
<h2><a name="p-4908-revive-building-the-apk-4" class="anchor" href="https://rebol.metaeducation.com#p-4908-revive-building-the-apk-4"></a>Revive Building the APK</h2>
<p>So we definitely want to have the process from <strong><a href="https://www.youtube.com/watch?v=r5kccBehMMg">@giuliolunati's conference demo</a></strong> be automated and tested.  That means building the .APK file which bundles together both the native interpreter (as a backdoor to phone services) along with a WASM interpreter (to live in a webpage and be able to communicate with the native interpreter).</p>
<p>Maybe Giulio can speak to how far we are from having that work again... or if he's busy, I guess I can just go through the video... that's what it's for!  <img src="https://rebol.metaeducation.com/images/emoji/twitter/slight_smile.png?v=14" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-4908-bring-back-tcc-extension-5" class="anchor" href="https://rebol.metaeducation.com#p-4908-bring-back-tcc-extension-5"></a>Bring Back TCC Extension</h2>
<p>I <a href="https://rebol.metaeducation.com/t/doubling-down-on-tcc-bootstrap-conference-demo-expanded/1542">resurrected the TCC bootstrapping</a> because I think it is an impressive demo, and it speaks to an important spiritual point about the project.</p>
<p>It's pretty easy to get the ball rolling for TCC on Linux.  But a bit more work when you're cross-compiling it, or making it for Windows.</p>
<p>I never tried it, but it seemed like we had TCC working on Android.  It would probably be worth doing it again, and interesting if we could see the TCC bootstrap demo work on a phone too (!)  We'll have to consult the old Travis build script to see how the ARM configuration was done.</p>
<h2><a name="p-4908-revisiting-this-gives-me-more-motivation-6" class="anchor" href="https://rebol.metaeducation.com#p-4908-revisiting-this-gives-me-more-motivation-6"></a>Revisiting This Gives Me More Motivation</h2>
<p>Slogging through the nightmare of the Android NDK reminds me that <em>we are really doing something that almost no one does anymore</em>.  They just sign away their lives to something like Android Studio and are so far away from the actual mechanical levels that they don't know what the dependencies are.  Most people probably wouldn't know <em>how</em> to do any different...and among those who know, it's simply too frustrating to work through the details.</p>
<p>When you add up all the platforms and parts that we have, this is probably a more compelling story than I give it credit for.  So we should definitely not take for granted what we've got...and get the great demos like the AndroidNative+WASM packaging back up and running!</p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/rocket.png?v=14" title=":rocket:" class="emoji only-emoji" alt=":rocket:" loading="lazy" width="20" height="20"></p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/androids-back-modernized-and-with-continuous-integration/1544">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/androids-back-modernized-and-with-continuous-integration/1544</link>
          <pubDate>Sun, 07 Mar 2021 12:17:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1544</guid>
          <source url="https://rebol.metaeducation.com/t/androids-back-modernized-and-with-continuous-integration/1544.rss">Android&#39;s Back! Modernized, and With Continuous Integration</source>
        </item>
        <item>
          <title>New Build Executables, New Build Strategy</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>I mention that it's time to make a new batch of build executables.  I think it can no longer be avoided that we need a simplified build process, and having new and recent executables provides a big bag of tricks for writing a new one.  But first, let's just review a little history.</p>
<p>The story of the build system goes like this:</p>
<h2><a name="p-4448-r3-alpha-1" class="anchor" href="https://rebol.metaeducation.com#p-4448-r3-alpha-1"></a>R3-Alpha</h2>
<p><strong>R3-Alpha's build was driven by a slightly templated GNU makefile.</strong>  You can see the text of the makefile template in <strong><a href="https://github.com/rebol/rebol/blob/master/src/tools/make-make.r"><code>%make-make.r</code></a></strong>, which you would run with what OS_ID system you wanted to build for.  It pulled together a list of files from <strong><a href="https://github.com/rebol/rebol/blob/master/src/tools/file-base.r"><code>%file-base.r</code></a></strong> and made you a <strong><code>makefile</code></strong>.</p>
<p>It's a simple approach.  It means you have to have GNU make on your platform, which meant it wasn't a workable way to build on Windows.   The README said:</p>
<blockquote>
<p>This first release is intended for non-Windows systems like Linux, Mac, BSD,<br>
Android, etc. However, it will build for Windows, but I've not included the<br>
typical MSVC project files. I'll try to get that added, but it's not that<br>
tough to create one yourself.</p>
</blockquote>
<p><strong>One of the steps run by the makefile was called "prep".</strong>  This ran Rebol script code that generated a bunch of files to support the build.  Responsibilities of this step were:</p>
<ul>
<li>
<p>Pack up all the mezzanine Rebol text sources--with comments removed--into a compressed blob of data in a <code>.c</code> file.  The C array of bytes in that file was effectively an embedded resource, used to bootstrap the system.</p>
</li>
<li>
<p>Look through the C sources of the interpreter and find function definitions.  Then automatically generate an aggregate<code> .h</code> header file with those definitions.  This keeps you from having to update function prototypes in more than one place.  One downside of having everything automatically glommed into one big header is that the architectural lines between files aren't as clear as they would be if the headers were more granular...but overall I'd say it works out as an advantage.</p>
</li>
<li>
<p>Take some Rebol-structured memoizations and transform them into C code.  Plenty of projects have similar steps to convert tabular data in whatever format into <code>.h</code> and <code>.c</code>.  Rebol is a better medium for representing freeform intent than what most people use.</p>
</li>
</ul>
<p>The "prep step" has evolved over time, but all of the "make" processes run it in the same way.  So what we're talking about changing here is really just about how the invocation of the compiler and linker is done.</p>
<h2><a name="p-4448-atronix-r3-2" class="anchor" href="https://rebol.metaeducation.com#p-4448-atronix-r3-2"></a>Atronix R3</h2>
<p>Atronix builds against a lot of dependencies, and thus uses CMake.  CMake is a beast with a kind of archaic syntax.  But if you have a complex cross-platform C or C++ project...you don't really have much in the way of better options.  It has widely supported plugins for making sure your system pulls together the prerequisites it needs.</p>
<p>They used CMakeLists.txt files...written and maintained by hand.  No generation process, and they did not use the makefile.</p>
<h2><a name="p-4448-earls-buildreb-demo-3" class="anchor" href="https://rebol.metaeducation.com#p-4448-earls-buildreb-demo-3"></a>Earl's %build.reb Demo</h2>
<p>The concept of using Rebol to build itself came up, by using CALL to invoke the compiler.  earl made a quick and dirty example of this, called <strong><a href="https://gist.github.com/earl/180d761ce5d27e411a6f">%build.reb</a></strong>.  It showed a promising and brief idea.</p>
<p>A disadvantage it had was that it could only do full builds. GNU make and CMake senses which files change.  Doing full builds on every change is not viable for day to day operation.</p>
<p>Another disadvantage is that this couldn't be used to bootstrap onto a new platform.  You can't have the only way an executable can be made be if you have one already.</p>
<p>But this was a promising idea...and being able to build without needing GNU make, especially on Windows, was an idea that stuck.</p>
<h2><a name="p-4448-rebmake-4" class="anchor" href="https://rebol.metaeducation.com#p-4448-rebmake-4"></a>Rebmake</h2>
<p>Shixin didn't care for maintaining the handwritten CMakeLists.txt in parallel to changes with the <code>%make-make.r</code> process.  So he wanted a unified build.</p>
<p>But rather than thinking of the build as abstracting a <code>makefile</code> as R3-Alpha was doing, he thought of it as abstracting a CMake file...which is much more complex.  He wanted something that was "meta" enough that it could build to a <code>CMakeLists.txt</code>, a GNU <code>makefile</code>, a Visual Studio <code>.app</code> file, a command-line MSVC <code>nmake</code> file... or just drive the process through CALL as %build.reb had done.</p>
<p>The result of this ambitious process was the generalized engine of <strong><a href="https://github.com/metaeducation/ren-c/blob/9dc8ca2786ff57f9e4fc579e7a14623b014e4ce2/tools/rebmake.r"><code>%rebmake.r</code></a></strong>.  But that was a generic framework which then needed to be customized specifically to build a project...giving rise to the client script using the library <strong><a href="https://github.com/metaeducation/ren-c/blob/master/make.r"><code>%make.r</code></a></strong> (the names are arguably backwards... that make.r would be the framework, and rebmake.r would be the script for building Rebol).</p>
<p>Additionally, rebmake tried to accommodate two important new features:</p>
<ul>
<li>
<p>Per-OS or build type configuration files (<strong><a href="https://github.com/metaeducation/ren-c/tree/master/configs"><code>%configs/</code></a></strong>) to help with common builds</p>
</li>
<li>
<p>Having make specifications in the folders of extensions, so that their build recipes could be broken out from the main file.  Here's for instance today's Crypt module's <a href="https://github.com/metaeducation/ren-c/blob/9dc8ca2786ff57f9e4fc579e7a14623b014e4ce2/extensions/crypt/make-spec.r"><strong><code>extensions/crypt/%make-spec.r</code></strong></a></p>
</li>
</ul>
<p>To most observers (including myself), Rebmake is way too big.  It makes sense if you think the goal is to generate CMake files or Visual Studio files.  But what you wind up with in this line of thinking is kind the direct opposite of Rebol's goals: <em>instead of making a thing that is significantly less complicated than those systems, you have something that inherits all their complexity and then layers on more</em>.</p>
<h2><a name="p-4448-giulios-makefilereb-experiment-5" class="anchor" href="https://rebol.metaeducation.com#p-4448-giulios-makefilereb-experiment-5"></a>Giulio's makefile.reb experiment</h2>
<p>We pretty much all agree Rebmake has to go, but build systems are just naturally difficult...and not a lot of fun.</p>
<p><a class="mention" href="https://rebol.metaeducation.com/u/giuliolunati">@giuliolunati</a> recently took a stab at seeing what kind of a minimal direction might be taken, and generated a <strong><a href="https://github.com/metaeducation/ren-c/blob/5e56c3b946807f70fcfe6c1c190b6aa49c5b0cd7/makefile.reb">%makefile.reb</a></strong> that steered back closer to the ideas of R3-Alpha.  But there's a complicated set of requirements in this problem, so it's easy to see it stalled.</p>
<p>His file is a good reminder of the kind of scale we're looking for the build solution to be on.  To think smaller and simpler, and cut things back.</p>
<h2><a name="p-4448-pulling-together-a-new-design-6" class="anchor" href="https://rebol.metaeducation.com#p-4448-pulling-together-a-new-design-6"></a>Pulling Together A New Design</h2>
<p>So taking all this experience into account, I'm ready to take a stab at starting anew.  I want to back off from thinking of this as building a generic make system you'd use for other C projects...I think that's a bad idea.</p>
<p>Here's my rough strategy:</p>
<ul>
<li>
<p><strong>Make the main build system we use day-to-day driven by Ren-C using CALL.</strong>  That means it needs to check object file time stamps vs. the source files, and be incremental.</p>
</li>
<li>
<p><strong>Forget about makefiles or Visual Studio projects or otherwise.</strong>  For bootstrap, just have a way that the list of command lines which would be run by CALL can be output to a <code>.bat</code> or <code>.sh</code> file.  A full build is good enough...then once you're bootstrapped, use the executable from then on.</p>
</li>
<li>
<p><strong>Use a circa 2021 Ren-C to do the builds, unlocking more superpower in the make script design.</strong>  Hopefully <a class="mention" href="https://rebol.metaeducation.com/u/rgchris">@rgchris</a> and I can <a href="https://rebol.metaeducation.com/t/the-r3c-branch-chriss-rebol-or-rebol-3-conservative/1284/4">coordinate that this is "R3C"</a>...with a maintenance contract and quality control.  That's something that the haphazard build-picking process hasn't done before in the history of Rebol, and would in itself be refreshing.</p>
</li>
<li>
<p><strong>Make Building as a C library the Main Mission</strong>.  Strangely enough, the web build has been made available as a library with no included "main()" before offering a similar static library for C.  That's kind of silly.  If a C library were enabled, we could break out the console into its own repository...or put together things like demo projects on GitHub that offered desktop GUIs.  This was the original concept and it just never happened.  If not now, when?</p>
</li>
<li>
<p><strong>Revive Granular Extensions, in Particular Wasm Side-Modules ("the DLLs of Wasm")</strong>.  There was a nice concept in Rebmake that extensions could be not built (<code>-</code>), included statically in the executable (<code>+</code>), or made as a DLL/shared-library (<code>*</code>).  The DLL option did not really get tested and hasn't worked for a while.  It needs to...and with the primacy of the web build, we have to get that working for loading extensions as little Wasm fragments.  We also need to make it easier for extensions to live in their own git projects, vs. in the interpreter master git.</p>
</li>
<li>
<p><strong>Try building using the TCC extension in a web browser.</strong> This isn't necessarily as far fetched as it sounds.  Ren-C running in wasm in the browser could pull a .ZIP of the sources, let you click some customizations, and using the person's own CPU power in the browser build an x86 executable that you could then download.  It's really just a recycling of <a href="https://youtu.be/PT3GOe1pj9I?t=182">the conference demo</a>.</p>
</li>
</ul>
<p>As usual, this is all daunting stuff, but with some focus it may be realistically doable.  There's a lot of experience here to draw from...at least to know what NOT to do...!</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/new-build-executables-new-build-strategy/1432">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/new-build-executables-new-build-strategy/1432</link>
          <pubDate>Sat, 12 Dec 2020 12:11:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1432</guid>
          <source url="https://rebol.metaeducation.com/t/new-build-executables-new-build-strategy/1432.rss">New Build Executables, New Build Strategy</source>
        </item>
        <item>
          <title>How to set a compile variable?</title>
          <dc:creator><![CDATA[iArnold]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>I want to set a variable so I can compile C code depending on if this variable is defined or not.</p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/how-to-set-a-compile-variable/1366">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/how-to-set-a-compile-variable/1366</link>
          <pubDate>Wed, 14 Oct 2020 20:34:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1366</guid>
          <source url="https://rebol.metaeducation.com/t/how-to-set-a-compile-variable/1366.rss">How to set a compile variable?</source>
        </item>
        <item>
          <title>Giulio&#39;s Small %make.r</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>I found an old branch from 2020 on Ren-C's master where <a class="mention" href="https://rebol.metaeducation.com/u/giuliolunati">@giuliolunati</a> had attacked the idea of a small build system, as a sort of brainstorming effort.  Rather than just delete it--or keep it there where it wouldn't ever be looked at--I figured I'd move it here.</p>
<p>Here was the <code>%make.r</code>.  One thing Giulio always did (which we should do more often) is include help.  <em>(He added help to rebmake, which atrophied and I was tempted to get rid of, but decided it was better to fix it and actually make it always run the help...even if it didn't display it--to keep it working.)</em></p>
<hr>
<pre><code>help-me: {ARGS: [/CMD] [SOURCE] [OPTS]
    SOURCE: INPUT_FILE  (default makefile.reb)
    CMD:    /gmake | /dump (default /gmake)
OPTS: 
    /gmake: OUT_FILE (default build/makefile)
    /dump:  OUT_FILE (default stdout)
}

do %tools/bootstrap-shim.r
if not void? :tighten [
    enfix: enfix adapt :enfix [action: tighten :action]
]

blockify: default [function [x] [
    either block? x [x] [reduce [x]]
]]

wchar: charset [
    #"A" - #"Z" "_"
]

expand: function [
    template [block! group! text! file! tag!]
][
    esc: #"$"
    t: r: _
    if any [block? template group? template] [
        r: make type-of template 0
        for-next t template [
            new-line tail r new-line? t
            switch type-of t/1 [
                block! group! [append/only r expand t/1]
                text! file! tag! [append r expand t/1]
            ] else [append r t/1]
        ]
        new-line tail r new-line? template
        return r
    ]
    r: make block! 0
    if not find template esc [return template]
    parse as text! template [
        any [
            copy t to esc skip
            (if not empty? t [append r t])
            [ 
                [ "(" copy t to #")" skip
                | copy t some wchar
	        ]
                ( t: blockify load t
	            append/only r to-group t
	        )
            | opt esc (append r esc)
            ]
        ]
        copy t to end
        (if not empty? t [append r t])
    ]
    either text? template 
    [ reduce ['unspaced r] ]
    [ reduce ['to (type-of template) 'unspaced r] ]
]

&amp;: enfix :join

find-files: function [
  dir [file!]
  test [file! blank!]
][
  filter: function [b [block!]] [
    if not test [return b]
    map-each x b [
      if any [
        dir? x
        x = test
      ] [x]
    ]
  ]
  if 'dir != exists? dir [return null]
  dir: dirize dir
  b: map-each x (filter read dirize dir) [dir/:x]
  while [not tail? b] [
    d: b/1
    if dir? d [
      remove b
      insert b
        map-each x (filter read d) [d/:x]
    ] else [b: next b]
  ]
  b: head b
]

dump: function [
    makefile [block!]
    target [any-string! blank!]
][
    r: (mold makefile) &amp; "^/; vim: set syn=rebol:"
    if empty? target [print r]
    else [write to-file target r]
]

gmake: function [
    makefile [block!]
    target [any-string! blank!]
][
    r: make text! 0
    for-each [t s c] makefile [
        if text? t [
            append r spaced [".PHONY:" t newline]
        ]
        append r unspaced [t ": " s newline]
        for-each c blockify c [
            append r tab
            append r c
            append r newline
        ]
        append r newline
    ]
    if empty? target [print r]
    else [write to-file target r]
]

=== MAIN ===
cd :system/options/path
args: system/script/args
cmd: either first args [take args] [_]
if cmd/1 != #"/" [
    makefile: cmd cmd: _
] else [
    makefile: either first args
    [ take args ][ "makefile.reb" ]
]
output: either first args [take args] [_]
cmd: default ["/gmake"]

makefile: reduce do expand load to-file makefile

;; selectively reduce and flatten fields
m: makefile
while [not tail? m] [
    while [block? m/1] [
        insert m take m
    ]
    m/2: reduce m/2 
    if block? m/2 [m/2: flatten m/2]
    m/3: reduce m/3
    if block? m/3 [
        m/3: flatten m/3
        new-line/all m/3 true
    ]
    m: skip m 3
]

switch cmd [
    "/dump" [dump makefile output]
    "/gmake" [gmake makefile output]
] else [ print help-me ]
</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/giulios-small-make-r/2512">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/giulios-small-make-r/2512</link>
          <pubDate>Sun, 05 Jul 2020 04:00:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2512</guid>
          <source url="https://rebol.metaeducation.com/t/giulios-small-make-r/2512.rss">Giulio&#39;s Small %make.r</source>
        </item>
        <item>
          <title>A Separate and Simpler C89 Build</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>Now and again the idea comes up to switch to take C99 features for granted, given that standard is now... over 20 years old.</p>
<p><strong>The principal benefit of stepping up from C89 to C99 is in libRebol, so that it automatically terminates the variadic APIs.  It is a <em>SIGNIFICANT</em> benefit!</strong></p>
<p>As libRebol usage is on the rise, I'm finding my productivity adversely affected by the usability factors of not having termination be implicit.  It's easy to make mistakes, kind of like messing up a printf()'s arguments...but a worse version of that, because of how nested libRebol expressions often are.</p>
<p>But even more importantly: <em>I don't think the <em>truly innovative</em> aspects of the API show off as well when they are contaminated with the rebEND "tics" and other workarounds.</em>  That makes me sad.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/crying_cat_face.png?v=14" title=":crying_cat_face:" class="emoji" alt=":crying_cat_face:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-3744-is-it-time-for-a-compromise-1" class="anchor" href="https://rebol.metaeducation.com#p-3744-is-it-time-for-a-compromise-1"></a>Is it Time for a Compromise?</h2>
<p>As the system has become more granular with ~30 extensions, it gets easier to pick some of those as "C99 and above only".  For instance: what C89-only system can run ZeroMQ...which presumably can't be built for such a system in the first place?</p>
<p>But some extensions are mandatory to get a baseline usable system.  You can't do much without file I/O.  So if a system supports C89 and POSIX it seems disingenuous to say "There's no FILESYSTEM extension, but you can still compile the core..."</p>
<p>Right now I'm dealing with the suboptimal situation of expressing the C portion of the "rich console" in C89.  And it makes me wonder:</p>
<p><strong>Could we say that C89 platforms <em>work</em>, but just don't have a rich console?</strong>  e.g. they would read one line at a time with scanf(), run it, and print the result out with printf().</p>
<p>Hence in a C89 build, you would un-include the "modern" CONSOLE extension and use the CONSOLE-C89 extension, or somesuch.  This would have the advantage of keeping us from making the modern codebase look like it's contaminated with archaic concerns.  We don't at this point have any platforms or clients that are "real" that only have C89...and I gather if we did, people would be happy to have scripts run on them at all.</p>
<p><strong>In the near term, the odds are we're only going to be seeing these C89 build modes on Travis or wherever we force the issue... as a matter of principle.</strong>  We could also say "to heck with it, don't waste the time up front...let someone else do it if and when it comes up".  But I think I'd rather keep it going.</p>
<p>I just want us to be putting our best face forward with the code most people see and hack on. And it's pretty clear that C89 isn't giving us that (due to fundamentally missing the feature of variadic macros).</p>
<p><em>(FWIW, pre-C99 compilers did often support variadic macros... but with a gnarly non-standard syntax that only worked in their compiler.  So it's not unlikely that someone could hack in a way to make libRebol work on their older compilers without rebEND, if they were motivated...or just do a little custom preprocessing step of their own.)</em></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/a-separate-and-simpler-c89-build/1268">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/a-separate-and-simpler-c89-build/1268</link>
          <pubDate>Thu, 05 Mar 2020 22:09:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1268</guid>
          <source url="https://rebol.metaeducation.com/t/a-separate-and-simpler-c89-build/1268.rss">A Separate and Simpler C89 Build</source>
        </item>
        <item>
          <title>command line options as `target: makefile` vs `target=makefile`</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>It is traditional for programs that take command-line options in one of the following ways:</p>
<pre><code>my-program optionname=option
my-program --optionname option
my-program --optionname=option
my-program /optionname option
</code></pre>
<p>R3-Alpha's %make-make.r had code for the first case, so you would say <code>make-make OS_ID=1.2.3</code>, or whatever.  This was presumably just going with the flow of how options to GNU make were specified.</p>
<p><a class="mention" href="https://rebol.metaeducation.com/u/giuliolunati">@giuliolunati</a> had an interesting idea of using a more Rebol-like syntax:</p>
<pre><code>my-program optionname: option
</code></pre>
<p>This not only is "more Rebolish", but you get filename completion on your options in most shells (because it's not trying to do the completion with <code>optionname=</code> glued to the front of it).</p>
<p>At the moment, you can use either <code>--optionname=</code> or <code>optionname:</code> with %make.r.  I've been using the colon form for a while, and like it.  For the sake of simplicity, I'm wondering if it should be the <em>only</em> option format that <code>make.r</code> supports.</p>
<p>I can't think of any <em>technical</em> reason not to do it.  One could argue that it will look unfamiliar.  But I think it's easier to read this way.</p>
<p>Is there any reason not to standardize to this?</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/command-line-options-as-target-makefile-vs-target-makefile/1132">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/command-line-options-as-target-makefile-vs-target-makefile/1132</link>
          <pubDate>Mon, 25 Mar 2019 16:25:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1132</guid>
          <source url="https://rebol.metaeducation.com/t/command-line-options-as-target-makefile-vs-target-makefile/1132.rss">command line options as `target: makefile` vs `target=makefile`</source>
        </item>
        <item>
          <title>About the Build System category</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>Discuss rebol-make and other build systems.</p>
            <p><small>6 posts - 4 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/about-the-build-system-category/1131">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/about-the-build-system-category/1131</link>
          <pubDate>Mon, 25 Mar 2019 16:11:05 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-1131</guid>
          <source url="https://rebol.metaeducation.com/t/about-the-build-system-category/1131.rss">About the Build System category</source>
        </item>
        <item>
          <title>Ownership of GitHub by Microsoft - risk assessment</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>Currently the whole project and all ancillary projects are hosted on GitHub, the proverbial eggs all in one basket scenario.  This is something we should consider even without the change of ownership.</p>
<p>Should we consider mirroring to GitLab?<br>
Or is the sky never falling?</p>
            <p><small>6 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/ownership-of-github-by-microsoft-risk-assessment/672">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/ownership-of-github-by-microsoft-risk-assessment/672</link>
          <pubDate>Sat, 09 Jun 2018 01:34:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-672</guid>
          <source url="https://rebol.metaeducation.com/t/ownership-of-github-by-microsoft-risk-assessment/672.rss">Ownership of GitHub by Microsoft - risk assessment</source>
        </item>
        <item>
          <title>What Should the Experience of Building Rebol Be Like?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>When R3-Alpha was open-sourced, the make directory contained <a href="https://github.com/rebol/rebol/tree/c99039c37d7bbff8b5f901c593f5c3e4398b84c4/make">one GNU makefile</a>, and Carl gave these instructions:</p>
<blockquote>
<p>About the Makefile:</p>
<p>You might notice that the makefile is a bit old-fashioned. That's because I still support REBOL on some very old systems that don't offer newer makefile features. So, please keep that in mind and stick with this simple format.</p>
<p>Also, the makefile is built by REBOL. Typing "make make" will rebuild it, and you can also select a different platform target the same way by providing the REBOL platform identifiers (the last two parts of the version string).</p>
<p>Build Instructions:</p>
<p>Parts of REBOL are built by REBOL. So, to build it, you'll need to download a running binary into the local make directory. Call it r3-make.</p>
<p>The build happens in the make directory. It will create an obj sub-dir for storing the object files. I prefer this over mixing the source and object files into the same directory.</p>
<p>The biggest step is to do the "make prep" which will use REBOL to configure and build a number of important C header files.</p>
<p>If you are building for a new platform that has no existing REBOL, you can use "make prep" to build all the files you need on an existing platform and copy them to the new platform.</p>
<p>After the prep, just run "make" and the rest of the system will build.</p>
</blockquote>
<p>One might ask: if the makefile is built by Rebol, <em>why would it be committed in the repository</em>?  What platform is this makefile for?  What happens if you just say <code>make</code>?</p>
<p>The answer is that the makefile was generated for <a href="https://github.com/rebol/rebol/blob/c99039c37d7bbff8b5f901c593f5c3e4398b84c4/make/makefile#L32">32-bit Linux (0.4.4)</a>, so it was produced by running the command <code>r3-make %../src/tools/make-make.r OS_ID=0.4.4</code>.  However, it contains a trick: it has a target itself called "make" such that once generated, running <code>make make OS_ID=0.X.Y</code> will <em>overwrite the makefile itself</em> with an updated version for that OS.</p>
<p>We found this annoying, because the committed <code>makefile</code> would appear dirty in version control if you are using another system.  And also, one could streamline this process a bit for the average person if instead of them having to go <a href="https://github.com/rebol/rebol/blob/c99039c37d7bbff8b5f901c593f5c3e4398b84c4/src/tools/systems.r#L21">look at the %systems.r table and find their platform</a>, if the <code>r3-make</code> could inspect its own <code>system/version</code> and <em>assume</em> you wanted to build that same OS_ID.</p>
<p>And so <a href="https://github.com/metaeducation/ren-c/blob/e6cab210d6355f50b36fe6e15acc1f5859a95c30/make/makefile.boot">%make/makefile.boot</a> was born.  It was a committed file which saved you all the trouble of typing <code>./r3-make ../src/tools/make-make.r</code> followed by <code>make r3</code>.  Instead you could now type <code>make -f makefile.boot</code>.</p>
<p>If it sounds stupid, it kind of is.  But it wasn't rocket science to write, and you could also think of it as a kind of an interactive README file...if you didn't have something you needed, it could tell you.  And given that the build process was already dependent on you having GNU make, it could also catch you on that "meta-step" of needing make in the first place.</p>
<p><strong>But we live in a different world now.</strong>  You no longer need GNU make to build Ren-C.  You can still target it, but you can also generate files for Microsoft's NMAKE, or a Visual Studio project file.  And you can even forego the idea of a makefile altogether--instead having the Rebol executable drive the build process using <code>CALL</code> on the C compiler directly.  So it's time to scrap %makefile.boot and let a Rebol script be the entry point to the process.</p>
<p>I'm going to be talking about platforms, building, extensions in some more technical posts.  But this is more a philosophy post, or user-experience question.  Maybe any points people want to raise about building a system where it's been done right?</p>
<p>One thing we definitely should make easier is bootstrapping to new platforms.  The generated products of a Rebol "prep" process need to be in one central place to be grabbed and moved over.  Bootstrapping in this way should be part of the test process, e.g. one of the Travis instances that does a Win32 build on Linux could do the Win32 prep using the native Linux executable.  And then make sure it can just move the one folder with prep products into a completely fresh git install and still build with the cross-compiler...</p>
            <p><small>11 posts - 4 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/what-should-the-experience-of-building-rebol-be-like/334">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/what-should-the-experience-of-building-rebol-be-like/334</link>
          <pubDate>Wed, 11 Oct 2017 19:16:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-334</guid>
          <source url="https://rebol.metaeducation.com/t/what-should-the-experience-of-building-rebol-be-like/334.rss">What Should the Experience of Building Rebol Be Like?</source>
        </item>
        <item>
          <title>Obtaining a static url for the latest builds?</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>Just wondering how feasible it is for Travis to also upload the latest build in a latest folder so that the URL remains fixed</p>
<p>So, instead of going, for example, to</p>
<pre><code>http://metaeducation.s3.amazonaws.com/travis-builds/0.3.40/r3-4f44c19-debug-cpp.exe
</code></pre>
<p>for the current latest build, we can go to</p>
<pre><code>http://metaeducation.s3.amazonaws.com/travis-builds/latest/0.3.40/r3.exe
</code></pre>
<p>This would make things easier to publish documents in case people need to use <code>wget</code> etc.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/obtaining-a-static-url-for-the-latest-builds/245">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/obtaining-a-static-url-for-the-latest-builds/245</link>
          <pubDate>Tue, 08 Aug 2017 07:09:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-245</guid>
          <source url="https://rebol.metaeducation.com/t/obtaining-a-static-url-for-the-latest-builds/245.rss">Obtaining a static url for the latest builds?</source>
        </item>
  </channel>
</rss>

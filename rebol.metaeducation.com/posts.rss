<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest posts</title>
    <link>https://rebol.metaeducation.com</link>
    <description>Latest posts</description>
      <item>
        <title>Optimizing 1-Element PACK!s / SPLICE!s</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>Historically the most common type of PACK! is the 1-element PACK! holding a ~NULL~ antiform, that you get when a branching statement takes the branch and evaluates to null.</p>
<p>It's not supposed to be the case that antiforms have identity--once you make the transition from a plain form to an antiform, you lose the identity (and also, binding).</p>
<p>So really, every branching statement that returns a PACK!-boxed null can return the same boxed null.  Easy enough optimization--it's already done like that.</p>
<p>I've proposed something strange though... <a href="https://rebol.metaeducation.com/t/the-grand-leading-slash-safety-or-burden-question/2352/7">which is that putting actions in a PACK! be how they are "blessed" as legal to assign to plain WORD</a></p>
<p>I'm hopeful that can work.  But it brings up a question I've wrangled with in the past: <em>is there any way to make this cheap-as-free</em>?</p>
<p>e.g. <strong>Can a single Cell act as a proxy for an immutable array holding only itself?</strong></p>
<p>The idea was scrapped for things like BLOCK!, because you'd wind up with something that had nowhere to put the index or the binding.</p>
<p>But when it comes to PACK! (and SPLICE!...?) the binding requirement is gone, the index requirement is gone.  If the original array was at an index and seen to be one item, you'd just copy that one item out as the single Cell, and do some bit twiddling voodoo to it.</p>
<p>Can it work?</p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>In order to not tax the system too much on behalf of one weird optimization, it seems like you're down two bytes from the get-go: you've got the LIFT_BYTE at ANTIFORM_0 and the KIND_BYTE at TYPE_BLOCK.</p>
<p>Having those two bytes chewed out, it would mean the optimization would have to be something like 64-bit only, to reclaim those two bytes from the unused 32-bits in the header (which are typically unused to allow working on 32-bit platforms).  The other 3 platform pointers may all be used, because they may all contain platform pointers.  So really 64-bit builds only have 32 bits total to exploit.</p>
<p>Would tailored optimizations like this be a great use of that 32-bit advantage?  (As opposed to some cross-cutting feature that presumed to take the 32-bits out of all cells to do something more awesome)?  I don't know.  :-/</p>
<p>Is there some other way to leave the LIFT_BYTE and KIND_BYTE retain the single concent Cell's information, and yet somehow make the answer come back as PACK! without costing too much extra?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>The Cell could offer one bit for this... but it would wreck a lot of other optimizations if that bit didn't live somewhere in the LIFT_BYTE and KIND_BYTE.  The LIFT_BYTE already chews out 1 bit for quasi-ness (you can be both quoted and quasi, or quoted and non-quasi) which limits us to about 127 levels of quoting.  If another bit were sacrificed...let's just say it's the PACK!-bit... then we could say all PACK!s have this bit set, and we're cut down to 63-ish levels of quoting.</p>
<p>So then, if you have a regular PACK! it has the pack bit set...but when you clear the pack bit you see it's still an antiform with a heart that's a block.  And since you can't put PACK!s in packs directly (they're antiforms, they must be lifted) you know you've got a non-optimized pack.  Otherwise, you have a Cell which is the sole content of the pack.</p>
<p>It might seem like a problem that if you try to give back a pointer to the Cell as the content of the array, the only Cell you have in your hand has been corrupted with this pack bit.  So you index into the PACK! to find something that we've established acts as a PACK!.  However...this issue has already been solved for sequences, by an abstraction layer called <strong>"Arraylike"</strong>.  When you have an arraylike thing, you don't ask it for direct addresses of cells to operate on, you give it an index and ask it to fill a temporary Cell with the bits of what's at that index.  So this would be one of those things.</p>
<p><strong>Even if it could be done, this still runs afoul of a lot of the fingerprinting ideas that mask the two bytes in the header to determine its makeup.</strong>  <img src="https://rebol.metaeducation.com/images/emoji/twitter/fingerprint.png?v=14" title=":fingerprint:" class="emoji" alt=":fingerprint:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8557-just-a-placeholder-for-any-more-thoughts-1" class="anchor" href="https://rebol.metaeducation.com#p-8557-just-a-placeholder-for-any-more-thoughts-1"></a>Just a Placeholder For Any More Thoughts</h2>
<p>It's something to keep in mind, but more important to make sure the designs solve the problems, first.</p>
<p>I'm cautiously optimistic about using PACK!'d actions as the "approval" tool to do plain WORD!-assignment, but haven't done it yet, so don't know if it will actually be a good answer.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/optimizing-1-element-pack-s-splice-s/2516#post_1</link>
        <pubDate>Fri, 25 Jul 2025 17:41:50 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8557</guid>
      </item>
      <item>
        <title>The Grand Leading-Slash &quot;Safety, or Burden?&quot; Question</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="2352">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Not easy to get it all implemented, but I'm working as fast as I can.</p>
</blockquote>
</aside>
<p>On top of lots of other changes I've been trying to push through, the <strong><a href="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477">Lift The Universe</a></strong> design came along and changed ^META representation completely... it's been a long slog to get the system functional.</p>
<p>I'm finally on to resurrecting the samples (things like <a href="https://rebol.metaeducation.com/t/whitespace-interpreter-revisited/1482"><strong>The Whitespace Dialect</strong></a>).  So I'm coming up with lots of interesting solutions, and running into some head-scratchers.</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="3" data-topic="2352">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">foo: func [...] [...]  ; generator, no slash needed

/thing: select obj item  ; SELECT not a generator, needs slash?
</code></pre>
<p>It would be much rarer to see the slashes in these cases, but they would be the actual meaningful places to see them.</p>
<p>This could be handled by a "hot potato" bit on values [...] Kind of an interesting compromise idea, although most hidden-bit ideas have been scrapped.</p>
</blockquote>
</aside>
<p>The "surprising action" bit works great... <em>when it works</em>.  However, as I predicted... being a hidden/special bit means that if you're building something that abstracts assignments, you lose the bit... and it starts to break down.</p>
<p>For instance, consider the <a href="https://rebol.metaeducation.com/t/new-uparse-experiment-gather-and-emit/1531">GATHER/EMIT functionality in PARSE</a></p>
<pre><code> parse [double [x * 2] plus-one [x + 1] [
     gather [some [
         let name: word!, let code: block!
         emit (name): (func [x [integer!]] code)
     ]]
 ]
</code></pre>
<p>This is a simple example that performs the equivalent of:</p>
<pre><code>make object! [
    double: func [x [integer!]] [x * 2]
    plus-one: func [x [integer!]] [x + 1]
]
</code></pre>
<p>But it does this programmatically.  How it does it is by collecting the names of the fields and then the LIFT'ed form of their arguments... so for ACTION! that would be a QUASIFORM!.</p>
<p>This leads us to ask whether a QUASI-FRAME! evaluating and being assigned to a WORD! should count in terms of the hot potato bit.  This is a bit of a head-scratcher, as it can't be both</p>
<h2><a name="p-8556-could-pack-be-the-hot-potato-bit-1" class="anchor" href="https://rebol.metaeducation.com#p-8556-could-pack-be-the-hot-potato-bit-1"></a>Could PACK! Be The Hot Potato Bit?</h2>
<p>When other parts of the system have faced problems with transient properties that need to decay, they've leaned on PACK!.</p>
<p>So I mused about a concept: what if things that didn't always return ACTION! would pack up lone ACTION! values...</p>
<pre><code>&gt;&gt; lambda [x] [x]
== \~&amp;[frame!...]~\  ; action antiform

&gt;&gt; foo: lambda [x] [x]   ; works

&gt;&gt; if okay [lambda [x] [x]]
== \~[~&amp;[frame!...~]~]~\   ; action antifrom in a pack!

&gt;&gt; bar: if okay [lambda [x] [x]]
** PANIC: "surprising" action assignment (action in a pack)
</code></pre>
<p>But a problem here would be that all you'd have to do would be to DECAY it to approve it.</p>
<pre><code>&gt;&gt; bar: decay if okay [lambda [x] [x]]  ; works
</code></pre>
<p>So that indicates that the bias is backwards: the "hot potato" property that you want to have be transient is the approval... hence it's the unstable state that should indicate the validity:</p>
<pre><code>&gt;&gt; lambda [x] [x]
== \~[~&amp;[frame!...~]~]~\   ; action antifrom in a pack!

&gt;&gt; foo: lambda [x] [x]   ; works

&gt;&gt; if okay [lambda [x] [x]]
== \~&amp;[frame!...]~\  ; action antiform

&gt;&gt; bar: if okay [lambda [x] [x]]
** PANIC: "surprising" action assignment (plain action, not in a pack)
</code></pre>
<p>This is... actually sort of compelling.  It makes the function generators the odd ducks.</p>
<p>If the mechanic were this overt, then I don't think that it should be any "invisible magic" (like detecting that a function only returns ACTION!, and making it return an ACTION! in a PACK!.)  Instead, when you write a function generator, you'd just return a function in a pack.</p>
<p>But what it would imply would be that terminal slashes would give you back a function in a pack, otherwise you couldn't do:</p>
<pre><code>my-append: append/
</code></pre>
<p>Conveniently, if something like APPLY took an ACTION! as an argument, then <strong><code>apply append/</code></strong> would decay that action-in-a-pack to a plain ACTION!.</p>
<p>Where this starts to get a bit hazy is what happens if you write:</p>
<pre><code>^foo: lambda [x] [x]
</code></pre>
<p>By the rules of ^META, that's going to put a PACK! containing an action into foo.</p>
<p><strong>But this is what happens whenever you write packs into ^META variables.</strong>  e.g. I will point out that by the rules of ^META, the following puts a PACK! containing a null into foo... not null:</p>
<pre><code>^foo: if okay [null]  ; compare with (foo: if okay [null])
</code></pre>
<p>Just how nasty is this?  Well, we seem to have been getting away with it so far.  The physics inspirations of isotopes sort of speak to the "law of chemistry" in effect here.  If you've got a milieu of isotopes out there in the mix, and it only matters "when it matters", it puts the burden on those with more stringent needs to articulate and filter when they care.</p>
<p>It's considerably less nasty--I think--to use PACK! for this than to have a hidden bit.  And the idea of having the pack be what "boils away" as the transient evaluation--allowing things like SELECT to return their "pure" answers which have the more "ornery" behavior--seems like it might work.</p>
<p>I'll give this a shot, and see how it goes.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/the-grand-leading-slash-safety-or-burden-question/2352#post_7</link>
        <pubDate>Fri, 25 Jul 2025 16:45:38 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8556</guid>
      </item>
      <item>
        <title>Can VOID, GHOST!, ACTION! Be More Decay-Friendly?</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>I wrote about a <a href="https://rebol.metaeducation.com/t/re-imagining-do-next-as-eval-step/767/3">small but important tweak to the behavior of multi-returns</a>, which allowed changing:</p>
<pre><code>[pos :result]: eval:step pos
</code></pre>
<p>Into just:</p>
<pre><code>[pos result]: eval:step pos
</code></pre>
<p>I mention that I believe that that multi-returns with too few values unsetting the variables (vs. panic'ing in the moment) was better in the long run.  e.g. if EVAL:STEP returns just NULL and not a PACK!, then setting POS to NULL and <strong>unsetting</strong> RESULT was an overall win.</p>
<p><em>(Absorbing this requires understanding what modern "unsetness" is...variables truly holding no value, not even TRASH!, and what the implications of this so-called "dual state" are.)</em></p>
<p>I also mention that in practice, it would often be necessary for the result variable to be ^META.  Because if it's not, any non-decayable values would panic.  This wouldn't just happen for ERROR! antiforms (which there's a reasonable probability you'd want to just panic anyway).  It would also happen for GHOST!</p>
<pre><code>; this would panic -&gt; can't decay GHOST! to ordinary result, need ^result
[pos result]: eval:step [comment "hi" ...]
</code></pre>
<p>I'll point out that there's rules about ACTION!s as well, which are that you can't assign actions to plain variables unless they are deemed "unsurprising" (kind of a dicey concept, still being hammered out)</p>
<pre><code>; this would panic -&gt; can't assign ACTION! to plain WORD!, need ^result
[pos result]: eval:step [if okay [lambda [x] [x]] ...]  ; "surprising" action
</code></pre>
<p>We know the new rules for decay of VOID, which is to unset the variable, but what are the implications of that here?</p>
<pre><code>[pos result]: eval:step [foo: void ...]
</code></pre>
<p>That will unset <code>foo</code>, <a href="https://rebol.metaeducation.com/t/should-void-assigns-mean-fully-remove-a-key/2431">because that's now legitimate</a>.</p>
<p>But we're in a bit of an unfortunate position, because if we allow this decay it undermines one of my ideas <em>a little</em>... of saying that the unset state isn't an evaluative result.  (It's still true, in the sense that using <code>^result</code> would expose that the real evaluative state was void...but it feels like a shaky conflation.)</p>
<h2><a name="p-8555-question-on-the-table-can-this-be-easierbetter-1" class="anchor" href="https://rebol.metaeducation.com#p-8555-question-on-the-table-can-this-be-easierbetter-1"></a>Question On The Table: Can This Be Easier/Better?</h2>
<p>Lots to tackle here, but...</p>
<p>I'll start by mentioning an old trick, which was to say that by default EVAL would by default keep stepping to not show you the GHOST!s.</p>
<pre><code>&gt;&gt; [pos result]: eval:step [comment "hello" elide print "world" 10 + 20 ...]
world
== \~['[...] '30]~\  ; antiform
</code></pre>
<p>In that one step, it zoomed you past the GHOST!-producing steps and took you right to the first real result (if any).</p>
<p>That may seem convenient, but it means you need a refinement like :GHOSTABLE to ask to see the invisibles.  I'm kind of annoyed by it.</p>
<p>Another thought would be to give back something "innocuous" as a proxy for invisibility, under the assumption that the default would be not to care:</p>
<pre><code>&gt;&gt; [pos result]: eval:step [comment "hello" elide print "world" 10 + 20 ...]
== \~['[elide print "world" 10 + 20 ...] ~#ghost~]~\  ; antiform
</code></pre>
<p>There you're getting back a TRASH! that's a stable antiform, and it's labeled "<span class="hashtag-raw">#ghost</span>" which cues you to knowing it was a ghost (though it's a conflation, as it could have been a trash that said ghost).  That may be interesting to you for your purposes or it may not--maybe you don't have any particular difference in treatment in your particular evaluator client for things that return ghosts vs. a random thing that produced TRASH!.</p>
<p>So my concept here is: if you were already writing handling for TRASH!, maybe whatever you're doing for trash works well enough for ghosts too.</p>
<p>If we were to lean in this direction, I think it would support the idea that TRASH! is treated like no vote in things like ANY and ALL.  (<a href="https://rebol.metaeducation.com/t/the-truthiness-of-trash/2180/5">Right now it's truthy</a>, but the idea of being no vote is in the same ballpark and has been considered.)</p>
<p>And it might provide an escape hatch for the not-so-nice void problem as well:</p>
<pre><code>&gt;&gt; [pos result]: eval:step [foo: void ...]
== \~['[...] ~#void~]~\  ; antiform
</code></pre>
<p><strong>This would be SET-BLOCK saying that when it unpacks VOID and GHOST! into variables that are non-^META, it doesn't go through "standard decay"... because it doesn't want to conflate no pack item with pack item that's void or ghost.</strong></p>
<p>If we then made things like ANY and ALL treat TRASH! the same as voids/ghosts and just ignore it, then you can see a somewhat coherent plan taking shape, allowing you to get meaningful work done without having to invoke the ^META convention.  <em>"It's all trash to me"</em>, unless you have a reason to discern it.</p>
<h2><a name="p-8555-but-what-about-actions-2" class="anchor" href="https://rebol.metaeducation.com#p-8555-but-what-about-actions-2"></a>But, What About ACTION!s...?</h2>
<p>This question about "how much lying is acceptable" gets us into the weeds a bit here with ACTION!.</p>
<p>I'm trying to narrow down the cases where plain word assignments are allowed to put ACTION!s into words, because of the significant burden that it creates to not know whether variables contain actions or not.</p>
<p>Right now, saying you have to use ^META variables is that tool:</p>
<pre><code>[pos ^result]: eval:step [bar: lambda [x] [x] ...]
</code></pre>
<p>All the lying to make trash out of ghosts and voids wouldn't help a case for generalized eval-stepping if you couldn't step over that.</p>
<p>What could it do?  Return a TRASH! that says just <code>~#action~</code>  ?  Degrade it into a plain FRAME!, instead of an antiform one?</p>
<p>Between those two options, it seems to me producing TRASH! is the better plan.  As with ghost and void, if you find this is in-band of something you truly care about, you could deal with it.</p>
<p>Unfortunately, ACTION!s are truthy.  So we can't really square that with something that's trying to blend with TRASH!</p>
<h2><a name="p-8555-conclusions-3" class="anchor" href="https://rebol.metaeducation.com#p-8555-conclusions-3"></a>Conclusions (?)</h2>
<p>It may just be that if you're doing EVAL:STEP and you aren't completely sure what you're processing, you have to use ^META for the result.</p>
<p>I'm not 100% thrilled with the idea of not being able to distinguish:</p>
<pre><code>[x y]: pack [1 + 2 void]  ; will unset y

[x y]: pack [1 + 2]  ; will unset y
</code></pre>
<p>And only being able to tell the difference if you write:</p>
<pre><code>[x ^y]: pack [1 + 2 void]  ; ^y will hold void

[x ^y]: pack [1 + 2]  ; will unset y
</code></pre>
<p>But if it does that, is there any good reason for GHOST! not to do it too, so that at least if you think they both should be handled the same way that you only have to write one set of handling?</p>
<pre><code>&gt;&gt; x: comment "hi"
== \~,~\  ; antiform

&gt;&gt; unset? $x
== \~okay~\  ; antiform
</code></pre>
<p>Or is GHOST! &lt;=&gt; TRASH! conflation better?</p>
<pre><code>&gt;&gt; x: comment "hi"
== \~,~\  ; antiform

&gt;&gt; trash? ^x
== \~okay~\  ; antiform
</code></pre>
<h2><a name="p-8555-calm-down-people-it-was-just-a-little-liehttpswwwyoutubecomwatchvjuecqo7rz7c-4" class="anchor" href="https://rebol.metaeducation.com#p-8555-calm-down-people-it-was-just-a-little-liehttpswwwyoutubecomwatchvjuecqo7rz7c-4"></a><a href="https://www.youtube.com/watch?v=jUEcqo7Rz7c"><em>"Calm down people... it was just a little lie..."</em></a></h2>
<p><strong>This is tough, because plain ol' panic was comforting.</strong></p>
<p>But that first lie of saying non-^META assignments of VOID would unset variables led to a generalized principle that PACK!s that are too short to fulfill all their assignments would unset variables.  <strong>Yes it's a lie, but I've thought about this from a lot of angles now, and pretty sure that is the right choice.</strong></p>
<p>That lie wasn't made to stop people from having to ^META variables in packs, it was to stop them from having to <code>:OPTIONALIZE</code> them... which created a conflation.</p>
<p>With this new rule in place, there's the issue of whether these must be equivalent in terms of the effect on X:</p>
<pre><code> x: ...expr...  &lt;=&gt;    [x]: pack [...expr...]

^x: ...expr...  &lt;=&gt;   [^x]: pack [...expr...]
</code></pre>
<p><em>(The appealingness of the ^X case seems like a pretty strong argument for PACK to accept ERROR! by default, <a href="https://rebol.metaeducation.com/t/packs-decaying-to-first-item-when-others-are-error/2514">I think I'm realizing that it is misguided to panic on them and the safety problem should be addressed other ways</a>.)</em></p>
<p>If this rule needs to be true (and I think it does) then a VOID in a pack has to do what a void not in a pack would do... so if the variable is not ^META, it needs to unset it.</p>
<p><strong>Maybe that's the only lie, and we don't need to become pathological liars because of it.</strong></p>
<p>If GHOST! and ACTION! just panic for now when used in non-^META assignments, it just means people processing arbitrary code need to use ^META assignments, and that's basically futureproof (as much as anything here is).</p>
<p>If experience comes to show that more lies have value, we can  cross that bridge when we come to it.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/can-void-ghost-action-be-more-decay-friendly/2515#post_1</link>
        <pubDate>Fri, 25 Jul 2025 15:53:47 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8555</guid>
      </item>
      <item>
        <title>Re-imagining DO/NEXT as EVAL:STEP</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="767">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; [pos result]: eval:step pos
== ~null~  ; anti

&gt;&gt; result
** Error: result is unset  ; &lt;- "true unset", because POS was null
</code></pre>
</blockquote>
</aside>
<p><strong>UPDATE 2025:</strong> This used to have to be:</p>
<pre><code>&gt;&gt; [pos :result]: eval:step pos
== ~null~  ; anti

&gt;&gt; result
== ~null~  ; antiform &lt;- conflated with result of null
</code></pre>
<p>But I updated it in light of the <strong><a href="https://rebol.metaeducation.com/t/should-void-assigns-mean-fully-remove-a-key/2431">new attitude regarding things like VOID assignment</a></strong></p>
<p>It's still an option to mark the argument as optional via leading-colon, and get null.  But if you choose not to mark it, then your variable becomes "true unset" (which cannot be the product of an evaluation).</p>
<p>I think the "true unset" variables strike a balance, giving the desired guardrail while keeping the source looking nice and neat!</p>
<p>It might seem "more dangerously permissive" to not panic by default when you're unpacking a pack with too few values.  BUT I think when you look at it <em>holistically</em>, it's probably <em>safer</em> in the long run.  Because rather than force you to knee-jerk add a leading colon just to say "yes, I know it might be too few items, make a null if it is"... it's keeping you from conflating a lack of a value with synthesizing an "in-band" null... and I imagine that could wind up being more important, because it catches unintended uses of a meaningless state.</p>
<p>Additionally... consider that a lot of EVAL:STEP calls probably want to be generalized, and process ^META results.  If you had to say something was both optional and ^META:</p>
<pre><code>[pos :^result]: eval:step pos
</code></pre>
<p>If you can avoid that, so much the better:</p>
<pre><code>[pos ^result]: eval:step pos
</code></pre>
<p>Improvements, a little bit at a time...</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/re-imagining-do-next-as-eval-step/767#post_3</link>
        <pubDate>Fri, 25 Jul 2025 08:10:53 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8554</guid>
      </item>
      <item>
        <title>Packs Decaying To First Item When Others are ERROR!</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>The concept of an "undecayable PACK!" came up when I was trying to reason about what should happen when you had things like PACK!s of PACK!s...</p>
<pre><code>&gt;&gt; x: pack [1 2]
== \~['1 '2]~\  ; antiform

&gt;&gt; x 
== 1

&gt;&gt; x: pack [pack [1 2] 3]
== ???
</code></pre>
<p><strong>My belief was that this should panic, rather than do the decay.</strong>  If you truly wanted the first element of an unpacked pack to decay, you could write:</p>
<pre><code>&gt;&gt; [x]: pack [pack [1 2] 3]
== \~[~[1 2]~ '3]~\  ; antiform

&gt;&gt; x
== 1
</code></pre>
<p><strong>This created the notion of an undecayable pack.</strong>  The first cut of the undecayable rule was that  that any pack with an unstable antiform in the first spot (GHOST!, PACK!, ERROR!) would panic if you tried to decay it (vs unpack it).</p>
<h2><a name="p-8553-safety-motivation-dont-let-error-disappear-1" class="anchor" href="https://rebol.metaeducation.com#p-8553-safety-motivation-dont-let-error-disappear-1"></a>Safety Motivation: Don't Let ERROR! Disappear</h2>
<p>Putting ERROR!s in PACK!s isn't the usual way of doing things.  If a function runs and wants to make you aware of an ERROR!, it should typically return that as the main result of a function...not stow it away inside a pack.  Only if it's the main result can it be reacted to by things like EXCEPT.</p>
<p>But some cases don't allow the error to be the sole return result.  For instance, EVALUATE:STEP</p>
<pre><code>[pos ^result]: evaluate:step [fail "abc" ...]
</code></pre>
<p>We need the updated position of the code, even if the code FAIL'd.  Hence, EVALUATE can't make its main result an ERROR! in the case of an error result, it has to give back a PACK! which encodes both the error and the new position.</p>
<p><em>("Has to" is a strong statement... it's possible that the next position could be a field of the error, <a href="https://rebol.metaeducation.com/t/should-evaluate-step-bomb-on-an-error/1491/3">I've discussed some of these odd ideas before</a>.  But it's better to allow errors in packs.)</em></p>
<p>If you don't receive result as ^META, then the ERROR! wouldn't be able to store in the ^result and would panic:</p>
<pre><code>[code result]: evaluate:step [fail "abc" ...]  ; not ^result, so panic
</code></pre>
<p>But what if you didn't store the result at all?</p>
<pre><code>code: evaluate:step [fail "abc" ...]  ; ???
</code></pre>
<p><strong>I feel like that should panic.</strong>  But why should you have to do an assignment to get the panic?</p>
<pre><code>evaluate:step [fail "abc" ...]  ; same behavior as when assigned to `code:` ?
</code></pre>
<p>That would suggest that if a PACK has an ERROR! in <em>any</em> slot, then should the pack decay and not extract that error into a ^META variable, that error becomes a panic.</p>
<p>But this thought leads to another invasive thought...</p>
<h2><a name="p-8553-what-about-errors-in-packs-2" class="anchor" href="https://rebol.metaeducation.com#p-8553-what-about-errors-in-packs-2"></a>...What About ERROR!s In PACK!s?</h2>
<p>I started by talking about undecayability, e.g. you can't put a PACK! in the first position of a PACK! and have it "double decay".  Decaying happens <em>once</em>.</p>
<p>And then I discussed decaying when there's an ERROR! in the pack... suggesting that an error at <em>any</em> position (not just the first) which is not unpacked into a ^META-variable should panic.</p>
<p>But what if you have a PACK! that's <em>not</em> in the first position of a PACK!... ?  Should that be willing to decay silently?</p>
<pre><code>&gt;&gt; x: pack [1 pack [2 3]]
== 1  ; silently discarded PACK! in second position...
</code></pre>
<p>That may seem harmless, BUT, what if that PACK! contained an ERROR! ?</p>
<p><em>This led me to theorize that packs which contained unstable antiforms at any position would be "undecayable"</em></p>
<p>However, that started to feel too strict, when we look at:</p>
<pre><code>[code result]: evaluate:step [pack [1 2] ...]  ; works, result decays to 1

code: evaluate:step [pack [1 2] ...]  ; innocuous, why shouldn't it work?
</code></pre>
<p>And even if I'm assigning the result, <a href="https://rebol.metaeducation.com/t/should-set-word-s-propagate-undecayed-packs/2178">PACK!s propagate in assignments now by default</a></p>
<pre><code>while [[code result]: evaluate:step code] [
    ...
]
</code></pre>
<p>It would be a shame if this decayed a PACK! for result, and then refused to decay it for the WHILE, making you write:</p>
<pre><code>while [[{code} result]: evaluate:step code] [
    ...
]
</code></pre>
<p>So pre-emptively refusing to toss PACK!s just because they <em>might</em> contain an ERROR! doesn't seem very ergonomic.</p>
<h2><a name="p-8553-non-first-item-recursive-pack-decay-search-for-error-3" class="anchor" href="https://rebol.metaeducation.com#p-8553-non-first-item-recursive-pack-decay-search-for-error-3"></a>Non-First Item Recursive PACK! Decay Search For ERROR!</h2>
<p>So... what if any PACK!s which aren't in the first position, that you want to discard, will recursively unpack themselves looking for ERROR!, and if they find any then panic?</p>
<p>(And ERROR!s which aren't in the first position, and aren't in PACK!, are also sources of panic?)</p>
<p>This would make the system more robust to dropping errors on the floor.  This might make it more reasonable to say that PACK is willing to pack up errors, generally... today you have to use a special operation:</p>
<pre><code> pack [1020 fail "won't work"]  ; panics 

 pack* [1020 fail "will work"]  ; allows the error
</code></pre>
<p>It's a little bit disconcerting, to imagine that instead of erroring at the moment of the PACK you trust that wherever the pack is going will handle the error.  But really, that only becomes a problem when you're dealing with using PACKs in non-multi-return situations, e.g. you make a PACK and then put it in suspended animation somewhere.</p>
<p>If you're <em>not</em> putting packs in suspended animation, but "packing with the intent of unpacking", then you're leaving it up to the recipient as to whether they want the error or not.</p>
<p>All things being equal, having just one PACK primitive is preferable.</p>
<p>Things do seem to be falling into place in other ways, and I'm sensing that maybe the right thing to do is to say that if you're a client with "pack with intent to store", then you bear the burden of the indefinite lifetime you may give errors in that pack...vs. making it harder to put errors in packs.</p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p> ]]></description>
        <link>https://rebol.metaeducation.com/t/packs-decaying-to-first-item-when-others-are-error/2514#post_1</link>
        <pubDate>Fri, 25 Jul 2025 04:59:45 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8553</guid>
      </item>
      <item>
        <title>Theory of Symbols and Repurposing `? ?` and `! !`</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="834">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>the idea of taking super-common debug routines and making them easy to type and spot is so compelling, I feel like PROBE has to be in that set.</p>
</blockquote>
</aside>
<h2><a name="p-8551-theres-been-a-lot-of-changes-here-1" class="anchor" href="https://rebol.metaeducation.com#p-8551-theres-been-a-lot-of-changes-here-1"></a>There's been a lot of changes here...</h2>
<aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="834">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong><code>--</code></strong> is an alias for DUMP</p>
</blockquote>
</aside>
<p>The concept of <strong><a href="https://rebol.metaeducation.com/t/last-chance-to-question-for-strings/2430">dashes for strings <code>--[...]--</code></a></strong> has pretty much taken this off the table.</p>
<p>I've evan started wondering if we might want to take plain double-dashes for "string literal to end of line".</p>
<pre><code>&gt;&gt; foo: -- 4once think about writing like;;; literally anything &amp;$#$&amp;( here?
== --[4once think about writing like;;; literally anything &amp;$#$&amp;( here?]--
</code></pre>
<p>I don't know about that, but having an answer would be good.  :-/</p>
<h2><a name="p-8551-i-like-for-opt-and-maybe-for-optveto-2" class="anchor" href="https://rebol.metaeducation.com#p-8551-i-like-for-opt-and-maybe-for-optveto-2"></a>I like <code>?</code> for OPT, and maybe <code>??</code> for OPT:VETO</h2>
<p>Traditional OPT just erases the slot you're composing or reducing or whatever:</p>
<pre><code>&gt;&gt; x: null

&gt;&gt; compose [a (? x) b]
== [a b]
</code></pre>
<p>But OPT:VETO will actually tell the operation you want to cancel something out at a higher level... like "Super opt out"</p>
<pre><code>&gt;&gt; compose [a (?? x) b]
== \~null~\  ; antiform
</code></pre>
<p>This is turning out to be tremendously useful, and I think it goes naturally as a "more severe" OPT.</p>
<p>I have ideas that <strong><code>!</code></strong> might be TRY, <code>?!</code> could be OPT TRY, and maybe <code>!!</code> could be TRAP</p>
<p>It may be that these should all be left undefined, and people make up their own minds...</p>
<h2><a name="p-8551-yet-i-think-differentiation-is-still-important-3" class="anchor" href="https://rebol.metaeducation.com#p-8551-yet-i-think-differentiation-is-still-important-3"></a>Yet I Think Differentiation Is Still Important</h2>
<p>Saying your debug dumps have to be super short may be a false economy.  Also, everyone has different styles of what they use more often or less often.</p>
<p>But I like them standing out in the code so you can see them.</p>
<p>Maybe what should be standard in the box is a little symboly, but  less grabby of the lexical space.</p>
<p>What if dump were <strong><code>!dump</code></strong> ?</p>
<p>What if probe were <strong><code>!probe</code></strong> ?</p>
<p>What if breakpoint was <strong><code>!breakpoint</code></strong> or <strong><code>!break</code></strong> ?</p>
<p>We could say that when you're in the console you have shorthands without the exclamation points, but in source code it would be preferred that you use the decoration.</p>
<h2><a name="p-8551-anyway-a-shakeup-and-review-is-needed-4" class="anchor" href="https://rebol.metaeducation.com#p-8551-anyway-a-shakeup-and-review-is-needed-4"></a>Anyway, A Shakeup And Review Is Needed</h2>
<p>We might look at these things differently with a working debugger.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/theory-of-symbols-and-repurposing-and/834#post_7</link>
        <pubDate>Mon, 21 Jul 2025 06:45:45 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8551</guid>
      </item>
      <item>
        <title>Why Does _ Form As Space, Not Underscore?</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="7" data-topic="2455">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><code>#</code> as a NEWLINE literal is an unfamiliar concept, and I'd have to experiment with it to see if it starts to feel natural or not.</p>
</blockquote>
</aside>
<p><strong>I'm Leaning Toward Thinking This Is Worth Pushing</strong></p>
<p>I was just looking at some of <a class="mention" href="https://rebol.metaeducation.com/u/gchiu">@gchiu</a>'s code:</p>
<pre><code>let data: unspaced [
    surname "," firstnames space "(" opt title ")" space "DOB:" space dob space "NHI:" space nhi newline
    street newline town newline city newline newline
    "phone:" space opt phone newline
    "mobile:" space opt mobile newline
    "email:" space opt email
]
</code></pre>
<p>And I thought <em>"hey, underscore is finally committed as the space rune, might as well use that"</em>:</p>
<pre><code>let data: unspaced [
    surname "," firstnames _ "(" opt title ")" _ "DOB:" _ dob _ "NHI:" _ nhi newline
    street newline town newline city newline newline
    "phone:" _ opt phone newline
    "mobile:" _ opt mobile newline
    "email:" _ opt email
]
</code></pre>
<p>Which made me think "wow, kind of a shame that the <code>newline</code> is still there, cluttering it up"... so how would it look with the <code>#</code> proposal?</p>
<pre><code>let data: unspaced [
    surname "," firstnames _ "(" opt title ")" _ "DOB:" _ dob _ "NHI:" _ nhi #
    street # town # city # #
    "phone:" _ opt phone #
    "mobile:" _ opt mobile #
    "email:" _ opt email
]
</code></pre>
<p>Yes, it's <em>new</em>... but every idea has to start somewhere...</p>
<p><strong><code>_</code></strong> seems fairly close to the "absence of anything in this spot", while <strong><code>#</code></strong> seems a bit like its nemesis... the "everything is filled in character".</p>
<p>If you were looking for a complement to "I'm actually invisible, and lightly separate" to be "I'm actually invisible, but heavily separate" you can't do too much better than this.</p>
<p>They'd be tied together, in that "the two single character RUNE!s are invisible".</p>
<p>It may be that <code>##</code> is weird enough that it should be escaped as <code>#"#"</code>, because that helps realize it's one hash of intent, and not two... and that #"##" is two hashes of intent, not 3...</p>
<p>You could still quote them for matching, and have something that looked literate if you meant the visible intent:</p>
<pre><code>&gt;&gt; parse "___###" [some '_ some '#]
== #
</code></pre>
<p>Which is a little nicer than using their RUNE! forms:</p>
<pre><code>&gt;&gt; parse "___###" [some #_ some ##]
== #
</code></pre>
<h2><a name="p-8550-of-course-many-cases-want-interpolation-1" class="anchor" href="https://rebol.metaeducation.com#p-8550-of-course-many-cases-want-interpolation-1"></a>Of Course, Many Cases Want Interpolation...</h2>
<p>Graham's code could be tackled with COMPOSE now...modulo some issues with leading whitespace that multiline strings should probably not include by default:</p>
<pre><code>let data: compose2 '{} --[
    {surname}, {firstnames} ({? title}) DOB: {dob} NHI: {nhi}
    {street}
    {town}
    {city}

    phone: {? phone}
    mobile: {? mobile}
    email: {? email}
]--
</code></pre>
<p>There's still some questions about how to get an optional substitution to be able to opt out of its surrounding boilerplate.  For instance: how might <code>({? title})</code> ask to not only opt out of the contents of the parentheses, but opt out of the parentheses themselves... is there an easy way to do that?</p>
<p>But anyway, not all cases will be a fit for turning into interpolation, so I think the <code>#</code> as newline may be a usage that people would come to appreciate.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/why-does-form-as-space-not-underscore/2455#post_8</link>
        <pubDate>Sun, 20 Jul 2025 11:27:02 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8550</guid>
      </item>
      <item>
        <title>On Giving libRebol JS more powers than JavaScript</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="849">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>t seems modest to imagine adding a function to a browser's JavaScript, which looped through two strings, printed both, and gave you back the second to display in a browser <code>&lt;div&gt;</code>:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">var second = rebSpell(
    "repeat 2 [data: ask text!, echo [You typed: @data]] data"
)
console.log("Second string entered was" + second)
</code></pre>
<p><em>Web browsers aren't designed to work this way</em></p>
</blockquote>
</aside>
<p>There is now something called JSPI:</p>
<p><a href="https://v8.dev/blog/jspi" class="inline-onebox">Introducing the WebAssembly JavaScript Promise Integration API · V8</a></p>
<ul>
<li>
<p>JSPI is available in Chrome 137 and Firefox 139 across various platforms.</p>
</li>
<li>
<p>While initially experimental, JSPI has reached effective standardization within the WebAssembly community and is implemented in major browsers, enabling the integration of synchronous WebAssembly applications with the asynchronous web.</p>
</li>
</ul>
<p>I wondered if it would change anything, <strong>but note that doesn't really change anything here.</strong></p>
<p>What it means is that if we didn't have stackless, it would be cheaper to suspend operation than it used to be (no more need for emscripten to build "instrumented" code and fatten it up in order to be able to suspend/resume).  This still could be useful for any code that hasn't been converted to stackless--that code wouldn't be able to do generator yields or show debugger steps, but at least you could do GUI interop while it was stuck on the stack.</p>
<p>Another place it would be useful would be if you're using a C library that isn't under our control, and so it can't be rewritten to be stackless.</p>
<p>Anyway--just noticing that emscripten has another tool at its disposal--and that it doesn't change JavaScript's limitations.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/on-giving-librebol-js-more-powers-than-javascript/849#post_2</link>
        <pubDate>Sun, 20 Jul 2025 09:13:56 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8549</guid>
      </item>
      <item>
        <title>New UPARSE Experiment: GATHER and EMIT</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>Rules about assigning SET-WORD have gotten stricter... only the SET-WORD at module scope are  defined implicitly.  Everything else has to be explicit.  This means functions are much less likely to leak into global variables, and things are under much more control.</p>
<p>I was looking at <a class="mention" href="https://rebol.metaeducation.com/u/gchiu">@gchiu</a>'s <code>midcentral</code> and trying to update it to work under the new rules, and came across this:</p>
<pre><code>parse demo [
    (home: phone: mobile: email: null)
    [opt whitespace]
    surname: across to ","
    thru space [opt whitespace]
    [firstnames: across to "("] (trim:head:tail firstnames)
    thru "(" title: across to ")"  ; `title: between "(" ")"`
    thru "BORN" dob: across to space
    thru "(" age: across to ")"    ; `age: into between "(" ")" integer!`
    thru "GENDER" [opt whitespace] gender: across some alpha
    thru "NHI" nhi: across nhi-rule
    thru "Address" [opt whitespace] street: across to eol (?? street ?? 1)
    thru some eol [opt whitespace] town: across to eol (?? 2 ?? town)
    thru some eol [opt whitespace] city: across to eol (?? 3 ?? city)
    [thru "Home" (?? 4)
        | thru "Mobile" (?? 5)
        | thru "EMAIL" (?? 50) [opt whitespace] email: across to space accept (okay)
        | thru "Contact – No Known Contact Information" (?? 6) to &lt;end&gt; (print "Incomplete Demographics") accept (okay)
    ] [opt whitespace]
    phone: across some digit (?? 51 ?? phone)
    try [
        thru some eol thru "Mobile" [opt whitespace] mobile: across some digit (?? 6 ?? mobile)
        thru some eol try [thru "Email" [opt whitespace] email: across to space (?? 7 ?? email)]
    ]
    to &lt;end&gt;
] except [
    print "Could not parse demographic data"
    return ~
]
</code></pre>
<p>That has problems, because things like <strong><code>surname:</code></strong> did not previously have definitions.  (e.g. they were being written as globals, because the function this code lived in did not declare a <code>&lt;local&gt;</code> for surname.</p>
<p><strong>If not obvious--it's <em>good</em> to get told about this kind of leakage!</strong>  Because otherwise your function is potentially corrupting global data it's not supposed to.</p>
<p><em>(UPDATE: It turns out that (some) of these variables were actually intended as globals.  They definitely should be grouped together in an object!)</em></p>
<p>The easiest thing to do would be to just make local definitions for all the fields.  But that feels like you're repeating yourself.</p>
<h2><a name="p-8548-hey-maybe-emit-could-be-used-here-1" class="anchor" href="https://rebol.metaeducation.com#p-8548-hey-maybe-emit-could-be-used-here-1"></a>"Hey, Maybe EMIT Could Be Used Here"...</h2>
<p>I realized using EMIT to solve It would get a little more wordy, because it doesn't assume all SET-WORD are intended for the object.  <em>(This may mean that a CONSTRUCT combinator is needed that makes the assumption)</em></p>
<p><strong>But this has a problem, when you want to give fields default values, in terms of how you stylize your code.</strong>  Imagine you have some complex logic that decides if you want to emit fields--let's say more than one field are affected:</p>
<pre><code>gather [
    ...
    opt some [
        blah blah [
             emit foo: integer!
             emit bar: block!
        ]
     ]
 ]
</code></pre>
<p>Now let's say you want foo to be null by default if the rule emitting it doesn't apply, and let's say you don't want bar at all in that case.</p>
<p>EMIT gives an error at the moment if you emit something that's already been emitted.  It seems like it should (?)  Though it could be that the last emit is the one that applies for the object.  But that feels sketchy.  Maybe there's something like an <code>emit:update</code>, refinement in order to say it's okay:</p>
<pre><code>gather [
    emit foo: (null)
    opt some [
        blah blah [
             emit:update foo: integer!
             emit bar: block!
        ]
     ]
 ]
</code></pre>
<p>Feels like too many colons.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20">  It could be something like <strong><code>emit*</code></strong>:</p>
<pre><code>gather [
    emit foo: (null)
    opt some [
        blah blah [
             emit* foo: integer!
             emit bar: block!
        ]
     ]
 ]
</code></pre>
<p>Anyway, I'm not quite sure.</p>
<p>Making an OBJECT! does seem to be a good idea here, because the goal is to output the fields to a file:</p>
<pre><code>write to file! unspaced ["/" nhi %.r] mold compose [
    nhi: (nhi)
    title: (title)
    surname: (surname)
    firstnames: (firstnames)
    dob: (dob)
    street: (street)
    town: (town)
    city: (city)
    phone: (phone)
    gender: (gender)
]
</code></pre>
<p>This stresses that a JSON-like output of objects is important, because that file should presumably contain a list (BLOCK! or a FENCE! <code>{...}</code>) and not something with <code>make object! [...]</code></p> ]]></description>
        <link>https://rebol.metaeducation.com/t/new-uparse-experiment-gather-and-emit/1531#post_9</link>
        <pubDate>Sun, 20 Jul 2025 03:43:55 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8548</guid>
      </item>
      <item>
        <title>Synthesizing Parse Values From Thin Air: JUST</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2328">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I've defined <strong>JUST</strong> to synthesize the value after it:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; uparse "a" [collect [keep just keep, keep &lt;any&gt;]]
== [keep "a"]
</code></pre>
</blockquote>
</aside>
<p><strong>Changes have made it so that <code>@FOO</code> is now a PINNED!, and not a THE-WORD!</strong>.</p>
<p>This frees up the word THE to have less baggage, and be used in these circumstances.</p>
<p>One idea on the difference in meaning between THE and JUST might be whether or not a binding is considered, e.g. THE will bind, but JUST gives you "just" the value with no binding.</p>
<p>On balance, I think probably the LIT/LITERAL/LITERALLY is likely still the best choice for "match this thing literally", because it implies a quote is involved (e.g. 'foo is still called a "lit-word") and if a quoted item occurs it's expected to match in the input.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/synthesizing-parse-values-from-thin-air-just/2328#post_2</link>
        <pubDate>Sun, 20 Jul 2025 02:17:37 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8547</guid>
      </item>
      <item>
        <title>JS-EVAL and JS-DO</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1504">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>If string binding works, we can do better than this...</p>
</blockquote>
</aside>
<p>So 4 years later, we have day-to-day working string interpolation...</p>
<p>Though as I've pointed out above, JS-EVAL is more nuanced than just string pasting.  Notice how this would be broken:</p>
<pre><code>&gt;&gt; text: --[ ykcirT" a s'tI]--

&gt;&gt; js-eval compose2 '{{}} --[reb.Spell("reverse", {{text}}) + "String"]--
</code></pre>
<p>That would try to JS-EVAL the string:</p>
<pre><code>--[reb.Spell("reverse", ykcirT" a s'tI) + "String"]--
</code></pre>
<p>There are a few ways to go about this:</p>
<ol>
<li>
<p>Use complex sequences that you're pretty sure won't appear in the specific JavaScript you're processing, as either code -or- data... this assumes awareness of the specific data (since you cannot generically guarantee a sequence won't occur in a string).  You might pick <code>{{...}}</code> and that would work for some code, but then another it would not.</p>
</li>
<li>
<p>Have JS-EVAL construct local JavaScript definitions to hold the handles, and then reference them by those names in the JavaScript code as ordinary variables.</p>
</li>
<li>
<p>Be aware of the parsing of JavaScript enough to be able to syntactically extend the language.</p>
</li>
</ol>
<p>I don't know how beastly (3) is, but it seems pretty interesting.  When you think of what Ren-C is capable of, people might genuinely be drawn to using it for JavaScript metaprogramming...</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/js-eval-and-js-do/1504#post_3</link>
        <pubDate>Sat, 19 Jul 2025 13:29:50 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8546</guid>
      </item>
      <item>
        <title>The WORD! vs. TEXT! Representation Gap</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>Something that seems to come up a lot is exemplified in this issue with Rebmake regarding optimization levels.</p>
<p>The issue is that C compilers have optimization switches (like <code>-O2</code> or <code>-Os</code>) which let you say how to optimize what you're building.  2 may indicate higher optimizations than 1 or 0.  "s" could mean optimize for size.</p>
<p>When you're translating something like this into a dialect, it's tempting to think of this as being either a WORD! or an INTEGER!, and not having to put it in ditto marks <em>(Note: I'm going to call <code>"</code> ditto marks from now on, to help distinguish them from the phenomenon of "quoting")</em>.</p>
<pre><code>some-file.c [
    optimize: 2
]
another-file.c [
    optimize: s
]
</code></pre>
<p>If your dialect happens to not be evaluating the slots, this gives you a clean representation.  In the particular case of Rebmake, this is often taken on the command line, and the command line processing will LOAD the thing you pass. So:</p>
<pre><code> r3 make.r optimize: s
</code></pre>
<p>That works.  And if you said <strong><code>optimize: 's</code></strong> that would cause problems, because the shell thinks that's a quote mark that needs to be paired.</p>
<p>But if you're not lucky enough to be in an evaluative context, you'd need a quote mark.</p>
<h2><a name="p-8545-but-what-if-optimization-gets-settings-like-o2s-1" class="anchor" href="https://rebol.metaeducation.com#p-8545-but-what-if-optimization-gets-settings-like-o2s-1"></a>But What If Optimization Gets Settings Like <code>-O2s</code> ?</h2>
<p>It might seem neat to translate the string into an INTEGER! or WORD!.  You could compare integers against each other (e.g. to find out that 1 is greater than or less than the optimization level)... if they were both integers.  It feels nice to turn things into words.</p>
<p>But if you do a mapping--and don't fully control the domain you're mapping from--this can throw you a curveball.  And when it does, you'll have to put it in a string.  Now you've got INTEGER! <code>[0 1 2]</code>, WORD! <code>[s z]</code>, or TEXT! <code>["2s" and other illegal things]</code></p>
<p>At which point you'd probably ask: <strong>"Since I don't really control this, should I have left it as a string?"</strong>  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>Should you have stayed in your lane, and let it be <code>["0" "1" "2" "s" "z"]</code> to start with?</p>
<h2><a name="p-8545-for-now-word-and-integer-works-but-2" class="anchor" href="https://rebol.metaeducation.com#p-8545-for-now-word-and-integer-works-but-2"></a>For Now, WORD! and INTEGER! Works, But...</h2>
<p>I hit a problem because there was inconsistency when some places used <strong><code>"s"</code></strong> and others uses <strong><code>s</code></strong>.</p>
<p>I'm canonizing to the WORD! just to keep making progress.  But this kind of issue feels like it comes up often.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/the-word-vs-text-representation-gap/2513#post_1</link>
        <pubDate>Sat, 19 Jul 2025 07:23:13 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8545</guid>
      </item>
      <item>
        <title>Giulio&#39;s Small %make.r</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>Here was the corresponding <code>makefile.reb</code> using the make.r</p>
<hr>
<pre><code>REBOL_TOOL: system/options/boot
REBOL: "$REBOL_TOOL -qs"
BASE_DIR: %..
TOOLS: BASE_DIR/tools
SRC: BASE_DIR/src
EXTENSIONS: BASE_DIR/extensions
GIT_COMMIT: default ["unknown"]
OS_ID: 0.13.2
MKDIR: "mkdir -p"
DEFS: "-DNDEBUG -DOS_STACK_GROWS_DOWN -DENDIAN_LITTLE -DHAS_LL_CONSTS -D_FILE_OFFSET_BITS=64 -DTO_ANDROID -DTO_ANDROID5_ARM"
INCLUDE: "-I$SRC/include -Iprep/include"
COMPILER: 'gcc
CC: "gcc -c" ; Compile Command
CFLAGS: "-O2 -fvisibility=hidden -fPIC"
LINK: "gcc" ; Link command
LFLAGS: "-fvisibility=hidden -pie -rdynamic" 
LIBS: "-lm -ldl -llog"
STRIP: "strip -S -x -X"


;; OBJS
core-objs: [
    ; msc: /wd5045 =&gt; https://stackoverflow.com/q/50399940
    ; msc: /wd4146 =&gt; unary minus operator applied to unsigned type
    ; (A)???
    %a-constants _
    %a-globals _
    %a-lib _
    ; (B)oot
    %b-init _
    ; (C)ore
    %c-bind _
    %c-do _
    %c-context _
    %c-error _
    %c-eval [#prefer-O2-optimization]
        ; There are several good reasons to optimize the evaluator itself even
        ; if one is doing a "size-biased" build.  It's not just about wanting
        ; the critical code to be faster--but also, since it recurses, if
        ; stack frames aren't flattened out then they add up...and may blow
        ; internal limits (like in a web browser for JS/WASM calls)
        ;
    %c-function _
    %c-path _
    %c-port _
    %c-signal _
    %c-specialize _
    %c-value _
    %c-word _
    ; (D)ebug
    %d-crash _
    %d-dump _
    %d-eval _
    %d-gc _
    %d-print _
    %d-stack _
    %d-stats _
    %d-test _
    %d-trace _
    %d-winstack _
    ; (F)???
    %f-blocks _
    %f-deci _
        ; May 2018 update to MSVC 2017 added warnings for Spectre mitigation.
        ; %f-deci.c is a lot of twiddly custom C code for implementing a fixed
        ; precision math type, that was for some reason a priority in R3-Alpha
        ; but isn't very central to Ren-C.  It is not a priority to audit
        ; it for speed, so allow it to be slow if MSVC compiles with /Qspectre
        ;
    %f-device _
    %f-dtoa [
        gcc "-Wno-cast-qual -Wno-unused-const-variable -Wno-sign-compare -Wno-uninitialized -Wno-unknown-warning -Wno-implicit-fallthrough"
        msc "/wd5045 /wd4146"
    ] 
        ; f-dtoa.c comes from a third party and is an old file.  There is an
        ; updated package, but it is not a single-file...rather something with
        ; a complex build process.  If it were to be updated, it would need
        ; to be done through a process that extracted it in a way to fit into
        ; the ethos of the Rebol build process.
        ;
        ; Hence we add tolerance for warnings that the file has.
        ;
    %f-enbase [msc "/wd5045"]
        ; At time of writing there are 4 Spectre mitigations, which should
        ; be looked at and rewritten when there is time:
        ;
    %f-extension _
    %f-int _
    %f-math _
    %f-modify _
    %f-qsort _
    %f-random _
    %f-round _
    %f-series _
    %f-stubs _
    ; (L)exer
    %l-scan _
    %l-types _
    ; (M)emory
    %m-gc _
    %m-pools [gcc "-Wno-uninitialized"]
    %m-series _
    %m-stacks _
    ; (N)atives
    %n-control _
    %n-data _
    %n-do _
    %n-error _
    %n-function _
    %n-io _
    %n-loop _
    %n-math _
    %n-protect _
    %n-reduce _
    %n-sets _
    %n-strings _
    %n-system _
    ; (S)trings
    %s-cases _
    %s-crc _
    %s-find _
    %s-make _
    %s-mold _
    %s-ops _
    ; (T)ypes
    %t-binary _
    %t-bitset _
    %t-blank _
    %t-block _
    %t-char _
    %t-datatype _
    %t-date _
    %t-decimal _
    %t-function _
    %t-integer _
    %t-logic _
    %t-map _
    %t-money _
    %t-object _
    %t-pair _
    %t-port _
    %t-quoted _
    %t-string _
    %t-time _
    %t-tuple _
    %t-typeset _
    %t-varargs _
    %t-word _
    %u-compress _
    ; (U)??? (3rd-party code extractions)
    %u-parse _
    %u-zlib [
        gcc "-Wno-unknown-warning -Wno-implicit-fallthrough" msc "/wd5045" &lt;no-make-header&gt;
    ]
        ; Zlib is an active project so it would be worth it to check to see
        ; if minor patches for subverting Spectre mitigation would be taken.
]
generated-objs: [ ; Files created by the make-boot process
    %tmp-boot-block _
    %tmp-type-hooks _
]
extensions-objs: [
    %bmp/mod-bmp _
    %tmp-mod-bmp-init _
    %console/mod-console _
    %tmp-mod-console-init _
    %crypt/mod-crypt _
    %crypt/mbedtls/library/rsa _
    %crypt/mbedtls/library/rsa_internal _
    %crypt/mbedtls/library/oid _
    %crypt/mbedtls/library/platform _
    %crypt/mbedtls/library/platform_util _
    %crypt/mbedtls/library/bignum _
    %crypt/mbedtls/library/md _
    %crypt/mbedtls/library/cipher _
    %crypt/mbedtls/library/cipher_wrap _
    %crypt/mbedtls/library/sha256 _
    %crypt/mbedtls/library/sha512 _
    %crypt/mbedtls/library/ripemd160 _
    %crypt/mbedtls/library/md5 _
    %crypt/mbedtls/library/sha1 _
    %crypt/mbedtls/library/aes _
    %crypt/mbedtls/library/arc4 _
    %crypt/mbedtls/library/dhm _
    %crypt/mbedtls/library/ecdh _
    %crypt/mbedtls/library/ecp _
    %crypt/mbedtls/library/ecp_curves _
    %tmp-mod-crypt-init _
    %debugger/mod-debugger _
    %tmp-mod-debugger-init _
    %dns/mod-dns _
    %tmp-mod-dns-init _
    %event/mod-event _
    %event/t-event _
    %event/p-event _
    %event/event-posix _
    %tmp-mod-event-init _
    %filesystem/mod-filesystem _
    %filesystem/p-file _
    %filesystem/p-dir _
    %filesystem/file-posix _
    %tmp-mod-filesystem-init _
    %gif/mod-gif _
    %tmp-mod-gif-init _
    %gob/mod-gob _
    %gob/t-gob _
    %tmp-mod-gob-init _
    %image/mod-image _
    %image/t-image _
    %tmp-mod-image-init _
    %jpg/mod-jpg _
    %jpg/u-jpg _
    %tmp-mod-jpg-init _
    %library/mod-library _
    %library/library-posix _
    %tmp-mod-library-init _
    %locale/mod-locale _
    %tmp-mod-locale-init _
    %network/mod-network _
    %network/dev-net _
    %tmp-mod-network-init _
    %png/mod-png _
    %png/lodepng _
    %tmp-mod-png-init _
    %process/mod-process _
    %process/call-posix _
    %tmp-mod-process-init _
    %secure/mod-secure _
    %tmp-mod-secure-init _
    %serial/mod-serial _
    %serial/serial-posix _
    %tmp-mod-serial-init _
    %stdio/mod-stdio _
    %stdio/p-stdio _
    %stdio/stdio-posix _
    %stdio/readline-posix _
    %tmp-mod-stdio-init _
    %time/mod-time _
    %time/time-posix _
    %tmp-mod-time-init _
    %utf/mod-utf _
    %tmp-mod-utf-init _
    %uuid/mod-uuid _
    %tmp-mod-uuid-init _
    %vector/mod-vector _
    %vector/t-vector _
    %tmp-mod-vector-init _
    %view/mod-view _
    %tmp-mod-view-init _
]
OBJS: map-each [s o] core-objs &amp; generated-objs &amp; extensions-objs [s]


;; TARGETS
[

"clean" _ map-each X [
    %objs/
    %prep/
    %r3
    %libr3.*
] [
    {rm -fr $X}
] 
 
"folders" _ map-each X [
    %""
    %bmp/
    %console/
    %crypt/
    %crypt/mbedtls/library/
    %debugger/
    %dns/
    %event/
    %filesystem/
    %gif/
    %gob/
    %image/
    %jpg/
    %library/
    %locale/
    %main/
    %network/
    %png/
    %process/
    %secure/
    %serial/
    %stdio/
    %time/
    %utf/
    %uuid/
    %vector/
    %view/
] [
    {$MKDIR objs/$X}
]

"prep" REBOL_TOOL [
    reduce [
    {$REBOL $TOOLS/make-natives.r}
    {$REBOL $TOOLS/make-headers.r}
    {$REBOL $TOOLS/make-boot.r OS_ID: $OS_ID GIT_COMMIT: $GIT_COMMIT}
    {$REBOL $TOOLS/make-reb-lib.r OS_ID: $OS_ID}
    ]
    map-each [M N] [
        "BMP" %bmp
        "Console" %console
        "Crypt" %crypt
        "Debugger" %debugger
        "DNS" %dns
        "Event" %event
        "Filesystem" %filesystem
        "GIF" %gif
        "Gob" %gob
        "Image" %image
        "JPG" %jpg
        "Library" %library
        "Locale" %locale
        "Network" %network
        "PNG" %png
        "Process" %process
        "Secure" %secure
        "Serial" %serial
        "Stdio" %stdio
        "Time" %time
        "UTF" %utf
        "UUID" %uuid
        "Vector" %vector
        "View" %view
    ] [
        S: %extensions/$N/mod-$N.c
        {$REBOL $TOOLS/prep-extension.r MODULE: $M SRC: $S OS_ID: $OS_ID}
    ]

    reduce [
        {$REBOL $TOOLS/make-boot-ext-header.r EXTENSIONS: Image:Console:Crypt:BMP:DNS:Event:Filesystem:GIF:Vector:Time:JPG:Library:UUID:Network:PNG:UTF:Secure:Serial:Stdio:View:Process:Gob:Debugger:Locale}
        {$(REBOL) $SRC/main/prep-main.reb}
    ]
]

; crypt module
map-each N [
    %aes
    %arc4
    %bignum
    %cipher
    %cipher_wrap
    %dhm
    %ecdh
    %ecp
    %ecp_curves
    %md
    %md5
    %oid
    %platform
    %platform_util
    %ripemd160
    %rsa
    %rsa_internal
    %sha1
    %sha256
    %sha512
] [
    N: %mbedtls/library/$N
    T: %objs/crypt/$N.o
    S: %$EXTENSIONS/crypt/$N.c
    reduce [
      %$T %$S {$CC -I$EXTENSIONS/crypt -I$EXTENSIONS/crypt/mbedtls/include -DMBEDTLS_CONFIG_FILE=\"mbedtls-rebol-config.h\" -Iprep/extensions/crypt $INCLUDE -DREB_API $DEFS $CFLAGS -o $t $s}
    ]
]

map-each [N O] reduce [
    %bmp _
    %console _
    %crypt {-I$EXTENSIONS/crypt -I$EXTENSIONS/crypt/mbedtls/include -DMBEDTLS_CONFIG_FILE=\"mbedtls-rebol-config.h\" }
    %debugger _
    %dns _
    %event _
    %filesystem _
    %gif _
    %gob _
    %image _
    %jpg _
    %library _
    %locale _
    %network _
    %png {-DLODEPNG_NO_COMPILE_ZLIB -DLODEPNG_NO_COMPILE_ALLOCATORS -DLODEPNG_NO_COMPILE_CPP }
    %process _
    %secure _
    %serial _
    %stdio _
    %time _
    %utf _
    %uuid {-I$EXTENSIONS/uuid/libuuid }
    %vector _
    %view _
] [
    T: %objs/tmp-mod-$N-init.o
    S: %prep/extensions/$N/tmp-mod-$N-init.c
    reduce [
        %$T %$S {$CC $O -Iprep/extensions/$N $INCLUDE -DREB_API $DEFS $CFLAGS -o $T $S}
    ]
]

map-each [A B O] reduce [
    %bmp %mod-bmp _
    %console %mod-console _
    %crypt %mod-crypt {-I$EXTENSIONS/crypt -I$EXTENSIONS/crypt/mbedtls/include -DMBEDTLS_CONFIG_FILE=\"mbedtls-rebol-config.h\" }
    %debugger %mod-debugger _
    %dns %mod-dns _
    %event %mod-event _
    %filesystem %mod-filesystem _
    %gif %mod-gif _
    %gob %mod-gob _
    %image %mod-image _
    %jpg %mod-jpg _
    %library %mod-library _
    %locale %mod-locale _
    %network %mod-network _
    %png %mod-png {-DLODEPNG_NO_COMPILE_ZLIB -DLODEPNG_NO_COMPILE_ALLOCATORS -DLODEPNG_NO_COMPILE_CPP }
    %process %mod-process _
    %secure %mod-secure _
    %serial %mod-serial _
    %stdio %mod-stdio _
    %time %mod-time _
    %utf %mod-utf _
    %uuid %mod-uuid {-I$EXTENSIONS/uuid/libuuid }
    %vector %mod-vector _
    %view %mod-view _
    %event %event-posix _
    %event %p-event _
    %event %t-event _
    %filesystem %file-posix _
    %filesystem %p-dir _
    %filesystem %p-file _
    %gob %t-gob _
    %image %t-image _
    %jpg %u-jpg {-Wno-unused-parameter -Wno-shift-negative-value }
    %library %library-posix _
    %network %dev-net _
    %png %lodepng {-DLODEPNG_NO_COMPILE_ZLIB -DLODEPNG_NO_COMPILE_ALLOCATORS -DLODEPNG_NO_COMPILE_CPP -Wno-cast-qual }
    %process %call-posix _
    %serial %serial-posix _
    %stdio %p-stdio _
    %stdio %readline-posix _
    %stdio %stdio-posix _
    %time %time-posix _
    %vector %t-vector _
] [
    T: %objs/$A/$B.o
    S: %$EXTENSIONS/$A/$B.c
    reduce [
      %$T %$S {$CC $O -Iprep/extensions/$A $INCLUDE -DREB_API $DEFS $CFLAGS -o $T $S}
    ]
]

map-each [N O] core-objs [
    T: %objs/$N.o
    S: %$SRC/core/$N.c
    if O [O: try select O COMPILER] 
    reduce [
      %$T %$S {$CC $INCLUDE -Iprep/core -DREB_API $DEFS $CFLAGS $O -o $T $S}
    ]
]

map-each [N O] generated-objs [
    T: %objs/$N.o
    S: %prep/core/$N.c
    reduce [
      %$T %$S {$CC $INCLUDE -Iprep/core -DREB_API $DEFS $CFLAGS -o $T $S}
    ]
]

%objs/main.o %$SRC/main/main.c 
{$CC $INCLUDE -Iprep/main -DREB_CORE $DEFS $CFLAGS -o objs/main.o $SRC/main/main.c}

%r3 map-each N (OBJS &amp; %main) [
  %objs/$N.o
]
reduce [
    {$LINK -o r3 $LFLAGS }
    &amp; (form map-each N OBJS [%objs/$N.o])
    &amp; { $LIBS objs/main.o}
    {$STRIP r3}
] 

"check" %r3 reduce [{$STRIP r3}]

] ;;; END TARGETS ;;;
</code></pre> ]]></description>
        <link>https://rebol.metaeducation.com/t/giulios-small-make-r/2512#post_2</link>
        <pubDate>Sat, 19 Jul 2025 06:35:22 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8544</guid>
      </item>
      <item>
        <title>Giulio&#39;s Small %make.r</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>I found an old branch from 2020 on Ren-C's master where <a class="mention" href="https://rebol.metaeducation.com/u/giuliolunati">@giuliolunati</a> had attacked the idea of a small build system, as a sort of brainstorming effort.  Rather than just delete it--or keep it there where it wouldn't ever be looked at--I figured I'd move it here.</p>
<p>Here was the <code>%make.r</code>.  One thing Giulio always did (which we should do more often) is include help.  <em>(He added help to rebmake, which atrophied and I was tempted to get rid of, but decided it was better to fix it and actually make it always run the help...even if it didn't display it--to keep it working.)</em></p>
<hr>
<pre><code>help-me: {ARGS: [/CMD] [SOURCE] [OPTS]
    SOURCE: INPUT_FILE  (default makefile.reb)
    CMD:    /gmake | /dump (default /gmake)
OPTS: 
    /gmake: OUT_FILE (default build/makefile)
    /dump:  OUT_FILE (default stdout)
}

do %tools/bootstrap-shim.r
if not void? :tighten [
    enfix: enfix adapt :enfix [action: tighten :action]
]

blockify: default [function [x] [
    either block? x [x] [reduce [x]]
]]

wchar: charset [
    #"A" - #"Z" "_"
]

expand: function [
    template [block! group! text! file! tag!]
][
    esc: #"$"
    t: r: _
    if any [block? template group? template] [
        r: make type-of template 0
        for-next t template [
            new-line tail r new-line? t
            switch type-of t/1 [
                block! group! [append/only r expand t/1]
                text! file! tag! [append r expand t/1]
            ] else [append r t/1]
        ]
        new-line tail r new-line? template
        return r
    ]
    r: make block! 0
    if not find template esc [return template]
    parse as text! template [
        any [
            copy t to esc skip
            (if not empty? t [append r t])
            [ 
                [ "(" copy t to #")" skip
                | copy t some wchar
	        ]
                ( t: blockify load t
	            append/only r to-group t
	        )
            | opt esc (append r esc)
            ]
        ]
        copy t to end
        (if not empty? t [append r t])
    ]
    either text? template 
    [ reduce ['unspaced r] ]
    [ reduce ['to (type-of template) 'unspaced r] ]
]

&amp;: enfix :join

find-files: function [
  dir [file!]
  test [file! blank!]
][
  filter: function [b [block!]] [
    if not test [return b]
    map-each x b [
      if any [
        dir? x
        x = test
      ] [x]
    ]
  ]
  if 'dir != exists? dir [return null]
  dir: dirize dir
  b: map-each x (filter read dirize dir) [dir/:x]
  while [not tail? b] [
    d: b/1
    if dir? d [
      remove b
      insert b
        map-each x (filter read d) [d/:x]
    ] else [b: next b]
  ]
  b: head b
]

dump: function [
    makefile [block!]
    target [any-string! blank!]
][
    r: (mold makefile) &amp; "^/; vim: set syn=rebol:"
    if empty? target [print r]
    else [write to-file target r]
]

gmake: function [
    makefile [block!]
    target [any-string! blank!]
][
    r: make text! 0
    for-each [t s c] makefile [
        if text? t [
            append r spaced [".PHONY:" t newline]
        ]
        append r unspaced [t ": " s newline]
        for-each c blockify c [
            append r tab
            append r c
            append r newline
        ]
        append r newline
    ]
    if empty? target [print r]
    else [write to-file target r]
]

=== MAIN ===
cd :system/options/path
args: system/script/args
cmd: either first args [take args] [_]
if cmd/1 != #"/" [
    makefile: cmd cmd: _
] else [
    makefile: either first args
    [ take args ][ "makefile.reb" ]
]
output: either first args [take args] [_]
cmd: default ["/gmake"]

makefile: reduce do expand load to-file makefile

;; selectively reduce and flatten fields
m: makefile
while [not tail? m] [
    while [block? m/1] [
        insert m take m
    ]
    m/2: reduce m/2 
    if block? m/2 [m/2: flatten m/2]
    m/3: reduce m/3
    if block? m/3 [
        m/3: flatten m/3
        new-line/all m/3 true
    ]
    m: skip m 3
]

switch cmd [
    "/dump" [dump makefile output]
    "/gmake" [gmake makefile output]
] else [ print help-me ]
</code></pre> ]]></description>
        <link>https://rebol.metaeducation.com/t/giulios-small-make-r/2512#post_1</link>
        <pubDate>Sun, 05 Jul 2020 04:00:00 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8543</guid>
      </item>
      <item>
        <title>First Bootstrap In At Least 6 Months: Watershed Changes</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>Since the November bootstrap, there have been two more occasions where I've gotten the ducks in a row well enough to bootstrap.</p>
<p>The first was hacked together--e.g. the new executable could bootstrap the code with modifications, but those modifications meant the old bootstrap executable couldn't bulid it.</p>
<p>That bootstrap informed me of weak spots that guided more development to a second bootstrap this week, that is much more solid.  And the bootstrap executable has been updated enough to be able to run the same code.</p>
<h2><a name="p-8542-things-are-in-a-good-direction-but-painfully-slow-1" class="anchor" href="https://rebol.metaeducation.com#p-8542-things-are-in-a-good-direction-but-painfully-slow-1"></a>Things Are In A Good Direction, But Painfully Slow</h2>
<p>I've been piping things through more and more general mechanics, with the goal of introducing chokepoints that enable stuff like accessor functions and typechecked variables.</p>
<p>Just intuitively speaking, you can imagine that code which used to assume it could just go directly to the memory location of a variable and access it now has to go through a general mechanic... which would make it slower.</p>
<p>But it's a fairly big deal, because now any code that accesses a variable has to be prepared to have arbtrary usermode code run that gets that variable.  This means every such moment has to be safe from garbage collection.  It means there has to be more arbitrary error handling--not just a boolean of "was the variable trash or not".</p>
<p>One of the places that gets especially hard is the evaluator, e.g. doing lookahead for infix functions.  If we're saying every expression evaluation has to check if the next expression is an infix function or not, you theoretically pay for that lookup twice.  (Imagine EVAL:STEP going one step at a time, looking ahead and deciding the next thing isn't infix and returning... then you take another step.  The thing you looked ahead at last time is now the first thing in the subsequent step.  What caching lets you take advantage of that?  <em>Can</em> you cache it?)</p>
<h2><a name="p-8542-not-time-for-optimization-yet-2" class="anchor" href="https://rebol.metaeducation.com#p-8542-not-time-for-optimization-yet-2"></a>Not Time For Optimization, Yet</h2>
<p>There's a lot of pain right now related to this common code path, and it's not quite at the point of actualization yet (type checking almost implemented, but not yet...)</p>
<p>So definitely don't want to start optimizing until there are some working examples of type checking and accessor functions.  But even then... it's not time... because...</p>
<p><strong>Debugging!</strong></p>
<p>While performance tuning is necessary, I really think before I go too far with anything I need to tend to debugging.  It's been a long time building up to it, but I've been laying things down bit by bit so it could work.</p>
<p>Being able to go step-by-step isn't just useful for people who know the language, but critical for people learning the language.</p>
<p>And I don't want to throw in wacky optimizations that would compromise debugging.  Optimizations have to be debugging sensitive, and know not to do the wacky optimization if you need to see every step.</p>
<p>The biggest problem now in debugging though, is how to show the code.  Rebol code is a weird graph.  And you're stepping through generated code a lot of the time.</p>
<p>On the plus side, with virtual binding now, you can see things like "what variables are in scope".</p>
<h2><a name="p-8542-errors-are-also-really-poor-right-now-3" class="anchor" href="https://rebol.metaeducation.com#p-8542-errors-are-also-really-poor-right-now-3"></a>Errors Are Also Really Poor Right Now</h2>
<p>I've been pushing ahead just getting mechanical things to work, and getting by because <em>I</em> can break in the C debugger and see what's going wrong.  But if I couldn't, a lot of errors suck.</p>
<p>Something that's much more viable now with PANICs is that since they are rare and not intended to be recovered from, a working debugger could throw you in at the moment of the panic...and see the call stack.  So while better error messages are important, this would make the biggest difference.</p>
<h2><a name="p-8542-but-no-excuses-need-to-push-builds-4" class="anchor" href="https://rebol.metaeducation.com#p-8542-but-no-excuses-need-to-push-builds-4"></a>But No Excuses... Need To Push Builds</h2>
<p>Slow or bad errors isn't really the issue.  The reason CI stopped is ostensibly because there had to be changes to align the bootstrap executable to massive changes (ranging from the format of strings and refinements to the question of how methods were dispatched).</p>
<p>So the question is <em>has that stuff stabilized to where hardening a batch of bootstrap executables is a good idea</em>.  I think the time is at hand.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/first-bootstrap-in-at-least-6-months-watershed-changes/2334#post_2</link>
        <pubDate>Sat, 19 Jul 2025 01:20:02 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8542</guid>
      </item>
      <item>
        <title>Introducing:The:New:CHAIN!:Datatype</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>I've implemented a first stage of pattern-matching, to replace types like THE-WORD! (that used to be what <code>@word</code> was called) and quoting levels.</p>
<p>In this first stage, you can say your function arg takes things like <code>[@path! ^tuple! ''$any-list? ~word!~]</code> in their type specs.  That would accept:</p>
<ul>
<li><strong><code>@foo/baz/bar</code></strong></li>
<li><strong><code>^a.b.c</code></strong></li>
<li><strong><code>''$(x y z)</code></strong></li>
<li><strong><code>''$[q r s]</code></strong>.</li>
<li><strong><code>~whatever~</code></strong></li>
</ul>
<p>Type constraints like <code>the-word?</code> are now completely gone, replaced by <code>pinned?</code> (which applies to any type decorated with an @) or refinements on the type checks, like <code>word?:pinned</code></p>
<p>You can use MATCH and TYPECHECK with these rules, as well.</p>
<h2><a name="p-8541-this-killed-off-things-like-null-in-typespecs-1" class="anchor" href="https://rebol.metaeducation.com#p-8541-this-killed-off-things-like-null-in-typespecs-1"></a>This Killed Off Things Like <code>~null~</code> In Typespecs</h2>
<p>Previously, <code>~null~</code> could be in type specs as a substitute for the <code>null?</code> constraint.  Now, when you use a quasiform it expects what's inside to be the constraint (datatype or typecheck function) that you're asking if the unquasi'd thing matches.</p>
<p>So you have to use <code>null?</code>.  I kind of don't like how it blends in... taking null is a pretty rare thing for functions to do.  Maybe <code>&lt;null&gt;</code> should be offered as a special tag to help call it out more.</p>
<h2><a name="p-8541-literal-matches-done-with-splices-2" class="anchor" href="https://rebol.metaeducation.com#p-8541-literal-matches-done-with-splices-2"></a>Literal Matches Done With Splices</h2>
<p>Another feature that's lost when you have <strong><code>['word!]</code></strong> meaning quoted word (lit-word?) is that the previous idea of quoted material meaning you could match enum values is gone.  e.g. <strong><code>['on 'off]</code></strong> as a typespec no longer means that you match those specific words.</p>
<p>As a replacement, I'm trying quasi-groups, which notationally hint at splcies.  So <strong><code>[~(on off)~]</code></strong>.  This seems a bit uglier, but in practice it's actually nicer when you have lists of things.</p>
<p>Of course, abstracting this with some kind of enumerated type abstraction would be nice.</p>
<h2><a name="p-8541-constraints-wont-permit-refinements-tuples-3" class="anchor" href="https://rebol.metaeducation.com#p-8541-constraints-wont-permit-refinements-tuples-3"></a>Constraints Won't Permit Refinements, Tuples?</h2>
<p>There's a question on whether type constraints permit refinements, or if you write <strong><code>[word!:word!]</code></strong> that would match a CHAIN! of two WORD!s, like <strong><code>a:b</code></strong></p>
<p>I think it's too important to be able to match <strong><code>[word!:]</code></strong> as the pattern for things like SET-WORD, and so that pretty much rules out using ordinary chains to do refinements.  If you want to use a function as a typechecker, I guess you have to make it dispatchable by WORD!.  Because if it applies to CHAIN! it presumably applies to tuples too, such as <strong><code>[word!.word!]</code></strong></p>
<p>Will have to see how the dialect shapes up, but the pattern matching has begun...</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/introducingnew-chain-datatype/2226#post_8</link>
        <pubDate>Sat, 19 Jul 2025 00:52:38 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8541</guid>
      </item>
      <item>
        <title>How Could Money Be Applied To Further Ren-C?</title>
        <dc:creator><![CDATA[@IngoHohmann Ingo Hohmann]]></dc:creator>
        <description><![CDATA[ <p>I like "back to personal computing" but I fear it's not exactly a focused selling point.</p>
<p>The question is, who will be interested, and are there enough people who are possibly interested?</p>
<p>Something I considered toying with was the wsam build on deno (bun / node), and having ren-c as a full-stack language with the whole ecosystem at you fingertips.</p>
<p>I'd add database bindings to, maybe duckdb / sqlite?</p>
<p>Maybe bindings to the matrix chat protocol or ipfs ...</p>
<p>There have been some web desktops with several windows on a desktop done with help of a js framework, but I don't remember the name(s).</p>
<p>Deno and Bun would then allow to compile projects to a single binary (I think even cross platform).</p>
<p>This be my vision of an (enhanced?) personal computing platform.</p>
<p>Still some kind of killer vision / or killer app (that's easily hackable / extensible in rebol) would be helpful.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/how-could-money-be-applied-to-further-ren-c/2500#post_10</link>
        <pubDate>Fri, 18 Jul 2025 15:11:00 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8539</guid>
      </item>
      <item>
        <title>DATATYPE! vs. TYPE!</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="3" data-topic="2510">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>In Haskell (and related languages) the type of a type is called a ‘kind’.</p>
</blockquote>
</aside>
<p>For a time I considered the idea of KIND being more like something's fundamental type (OBJECT!) and then it could have something more complex as a TYPE (e.g. BOOK! being a particular class of objects, with author and title and such).</p>
<p>As you know the concept of a type system of that sort is lacking.</p>
<p>In terms of extracting the type, I decided I did not like the way <strong><code>kind of</code></strong> sounded ("kind of value" is like "kinda value").  I pretty much gave in and said that <strong><code>type of</code></strong> would give you back the antiform datatype for BLOCK! for blocks, and move on with it.  But it's still all pretty hazy.</p>
<p>However, with the merging of the "Heart" enum and the "Sigil" 2-bit value into one Byte in the Cell header, it no longer was accurate to call that the HEART_BYTE, since it multiplexed the heart and sigil together.  So I called it the KIND_BYTE.</p>
<p>The type system may just have to suck for an initial release, and be something that gets hammered out later.  I don't know.  But the design space has opened up a bit with the TYPE_0 mechanics, and so I might take a crack at enums or other things to see what can be done.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/datatype-vs-type/2510#post_5</link>
        <pubDate>Fri, 18 Jul 2025 12:20:47 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8538</guid>
      </item>
      <item>
        <title>DATATYPE! vs. TYPE!</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>Some kind of integer.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/datatype-vs-type/2510#post_4</link>
        <pubDate>Fri, 18 Jul 2025 12:14:57 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8537</guid>
      </item>
      <item>
        <title>Should `[: . /]` Require Escaping In RUNE! ?</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>Should it be:</p>
<pre><code>&gt;&gt; second "a.b"
== #.
</code></pre>
<p>Or should it be:</p>
<pre><code>&gt;&gt; second "a.b"
== #"."
</code></pre>
<p>The ramifications here are that if these delimiters are RUNE! contents without escaping, then you can't put RUNE! inside of [CHAIN! PATH! TUPLE!]</p>
<pre><code>&gt;&gt; type of #a/b
== \~{rune!}~\  ; antiform  (e.g. not a PATH!)
</code></pre>
<h2><a name="p-8536-you-can-put-the-space-rune-in-sequences-today-1" class="anchor" href="https://rebol.metaeducation.com#p-8536-you-can-put-the-space-rune-in-sequences-today-1"></a>You Can Put the SPACE RUNE! In Sequences Today</h2>
<p>I haven't questioned it lately, but the <a href="https://rebol.metaeducation.com/t/reified-unreassignable-nothingness-space-runes/2457">SPACE character (now denoted by an underscore)</a> is what's used to indicate there's nothing in a PATH!/TUPLE!/CHAIN! slot:</p>
<pre><code>&gt;&gt; second first [:a]
== a

&gt;&gt; first first [:a]
== _
</code></pre>
<p>That doesn't mean that all RUNE! have to be legal.  It could be the only one that is.</p>
<h2><a name="p-8536-single-hash-is-the-biggest-loss-2" class="anchor" href="https://rebol.metaeducation.com#p-8536-single-hash-is-the-biggest-loss-2"></a>Single-Hash Is The Biggest Loss</h2>
<p>When I think about how one might use RUNE! in tuples or paths or chains, the patterns I think are most likely to be interesting for dialects would be those that just put hash marks in spots.  An example of the kinds of patterns:</p>
<pre><code>a:#:c

#:#:#

#:b:#
</code></pre>
<p>If you look at the problem with those glasses, you might question the value of:</p>
<pre><code>&gt;&gt; to text! #:#:#
== ":#:#"
</code></pre>
<p>But how you see such things depends on what examples you're comparing it to.</p>
<p>Note that if you just want the characters, <code>[: / .]</code> are WORD!</p>
<pre><code>&gt;&gt; parse "./:" ['. '/ ':]
== :
</code></pre>
<p>So you already have a 2-character means of matching them in strings, for that purpose...that looks cleaner than:</p>
<pre><code>&gt;&gt; parse "./:" [#. #/ #:]
== #:
</code></pre>
<h2><a name="p-8536-the-legality-of-space-twists-my-arm-a-bit-3" class="anchor" href="https://rebol.metaeducation.com#p-8536-the-legality-of-space-twists-my-arm-a-bit-3"></a>The Legality of SPACE Twists My Arm A Bit</h2>
<p>I did say that just because space runes are legal doesn't mean all runes need to be legal.  But it does make me more inclined to say they are.</p>
<p>My leaning here is to say you have to escape them.  I think the hash character in tuple!/path!/chain! has more potential for enabling novel features than worrying over slightly briefer character notations.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/should-require-escaping-in-rune/2511#post_1</link>
        <pubDate>Fri, 18 Jul 2025 05:42:54 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8536</guid>
      </item>
      <item>
        <title>Usefulness of String Interpolation</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>I haven't gone on the warpath to convert the world to string interpolation yet, but maybe I should...</p>
<p>Here was some code from the web console, for making the message you get when you start it up:</p>
<pre><code>link: [href label] -&gt; [
    unspaced [--[&lt;a href=']-- href --[' target='_blank'&gt;]-- label --[&lt;/a&gt;]--]
]

intro-note-html: spaced [
    "&lt;div class='note'&gt;"

    "&lt;p&gt;"
    "&lt;b&gt;&lt;i&gt;Guess what...&lt;/i&gt;&lt;/b&gt; this REPL is actually written in Rebol!"
    "Check out the" (link replpad-git "bridge to JavaScript")
    "as well as the" unspaced [(link console-git "Console Module") "."]
    "While the techniques are still in early development, they show a"
    "lot of promise for JavaScript/Rebol interoperability."
    "Discuss it on the" unspaced [(link forum "Discourse forum") "."]
    "&lt;/p&gt;"

    "&lt;p&gt;&lt;i&gt;(Note: SHIFT-ENTER for multi-line code, Ctrl-Z to undo)&lt;/i&gt;&lt;/p&gt;"
    "&lt;/div&gt;"
]
</code></pre>
<p>Now here's that code, but with string interpolation:</p>
<pre><code>link: [href label] -&gt; [
    compose "&lt;a href='(href)' target='_blank'&gt;(label)&lt;/a&gt;"
]

intro-note-html: trim compose2 '{{}} --[
    &lt;div class='note'&gt;

    &lt;p&gt;
    &lt;b&gt;&lt;i&gt;Guess what...&lt;/i&gt;&lt;/b&gt; this REPL is actually written in Rebol!
    Check out the {{link replpad-git "bridge to JavaScript"}}, as well as the
    {{link console-git "Console Module"}}.  While the techniques are still in
    early development, they show a lot of promise for JavaScript/Rebol
    interoperability.  Discuss it on the {{link forum "Discourse forum"}}.
    &lt;/p&gt;

    &lt;p&gt;&lt;i&gt;(Note: SHIFT-ENTER for multi-line code, Ctrl-Z to undo)&lt;/i&gt;&lt;/p&gt;
    &lt;/div&gt;
]--
</code></pre>
<p>There are still some decisions to make about how the multi-line string literals treat leading space.  I'm tempted to say the text starts at the outermost indentation so you don't have to trim it.</p>
<p>But anyway, big step up.  Note how the <code>{{...}}</code> is used in the second interpolation to allow parentheses to be treated normally by the content.  <em>(It could have been just <code>{...}</code> but I liked making it stand out more.)</em></p>
<h2><a name="p-8535-id-like-some-kind-of-compose-machine-1" class="anchor" href="https://rebol.metaeducation.com#p-8535-id-like-some-kind-of-compose-machine-1"></a>I'd Like Some Kind of COMPOSE-MACHINE</h2>
<p>COMPOSE has the ability to specify a :PREDICATE so you can process the slots.  But I feel like what I want is something stylized a bit differently, where LINK isn't a function you create and have a binding for but a dialect where it runs a PARSE rule to generate the substitutions.</p>
<p>Something like this:</p>
<pre><code>intro-note-html: compose-machine '{{}} --[
    &lt;div class='note'&gt;

    &lt;p&gt;
    &lt;b&gt;&lt;i&gt;Guess what...&lt;/i&gt;&lt;/b&gt; this REPL is actually written in Rebol!  Check
    out the {{link replpad-git}}, as well as the {{link console-git}}.  While the
    techniques are still in early development, they show a lot of promise for
    JavaScript/Rebol interoperability.  Discuss it on the {{link forum}}.
    &lt;/p&gt;

    &lt;p&gt;&lt;i&gt;(Note: SHIFT-ENTER for multi-line code, Ctrl-Z to undo)&lt;/i&gt;&lt;/p&gt;
    &lt;/div&gt;
]-- [
    'link, let [href label]: /pack [
         'replpad-git (["bridge to JavaScript", 
             https://github.com/hostilefork/replpad-js/blob/master/replpad.r])
         'console-git (["Console Module",
             https://github.com/metaeducation/ren-c/blob/master/extensions/console/ext-console-init.r])
         'forum (["Discourse forum", https://forum.rebol.info])
     ]
     (compose "&lt;a href='(href)' target='_blank'&gt;(label)&lt;/a&gt;")
]
</code></pre>
<p>That's an approximation of what I'm thinking, and it would provide flexibility for you to define the little mini-language of your substitutions (with PARSE rules being reusable, of course)...</p>
<h2><a name="p-8535-once-you-start-using-interpolation-you-wont-go-back-2" class="anchor" href="https://rebol.metaeducation.com#p-8535-once-you-start-using-interpolation-you-wont-go-back-2"></a>Once You Start Using Interpolation, You Won't Go Back!</h2> ]]></description>
        <link>https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114#post_7</link>
        <pubDate>Fri, 18 Jul 2025 04:30:51 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8535</guid>
      </item>
      <item>
        <title>&quot;Extension Types&quot; Implementation</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1203">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Of this byte, only 64 of the states are used in R3-Alpha--and I believe Red. This was chosen instead of 256 in order to limit the number of kinds that need to be handled in a TYPESET! to 64 bits...making typesets small enough to fit in the rest of the cell. <strong><a href="https://rebol.metaeducation.com/t/further-optimizations-of-breaking-the-64-type-barrier/2369">Ren-C has broken this barrier to something nearer to 256 fundamental types (plus builtin typesets)</a></strong>, but that's just for a finite number of built in things..</p>
</blockquote>
</aside>
<p>Thought I'd mention that this has been jostled, to where now 2 bits of the byte that had previously been allocated to just the "heart" are now taken by the SIGIL (either none, <a href="https://rebol.metaeducation.com/t/new-names-for-foo-foo-and-foo/2447">TIE PIN, or META</a>).</p>
<p>That pushes back to just 64 possibilites for the heart... minus one for TYPE_0 as the "custom/extension" type.</p>
<p><strong>BUT...</strong> it's not as much of a constraint to have 63 fundamental types as it once was!  Obviously, the TYPE_0 affords arbitrarily many more types...with the drawback being that those types have to sacrifice one of their 3 non-header cell slots for their "actual" type information (the ExtraHeart, called so because it's a pointer resident in the Cell's "extra" slot).</p>
<p>Yet also, because the types do a lot more heavy lifting.  CHAIN! takes care of not just <strong>a:b:c</strong> but also <strong>a:</strong> and <strong>:b</strong> and <strong>a/b:</strong> etc.  And since <code>^foo</code> and friends are handled by a sigil on the word, there's no longer a need for META-WORD! as one of the 63 fundamental types... it's just a sigil on a WORD!.</p>
<p>So in fact, only 33 fundamental types are used right now... leaving 30 more available.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/extension-types-implementation/1203#post_6</link>
        <pubDate>Fri, 18 Jul 2025 03:56:23 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8534</guid>
      </item>
      <item>
        <title>DATATYPE! vs. TYPE!</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="iArnold" data-post="2" data-topic="2510">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/iarnold/48/226_2.png" class="avatar"> iArnold:</div>
<blockquote>
<p>All things are of a certain type. All types themselves are of type datatype. Datatype is a datatype thing.</p>
</blockquote>
</aside>
<p>In Haskell (and related languages) the type of a type is called a ‘kind’. All types in Haskell are of kind <code>Type</code> (in earlier versions also called <code>*</code>). You can write kind signatures for types, e.g. <code>Maybe :: Type -&gt; Type</code>. Kinds themselves have a type too, in this case the slightly mindbending <code>Type :: Type</code>. And on it goes…</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/datatype-vs-type/2510#post_3</link>
        <pubDate>Fri, 18 Jul 2025 03:45:28 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8533</guid>
      </item>
      <item>
        <title>DATATYPE! vs. TYPE!</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>All things are of a certain type. All types themselves are of type datatype. Datatype is a datatype thing.<br>
Everything is neatly categorized.<br>
Ignore Kurt Godel's incompleteness theorem.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/datatype-vs-type/2510#post_2</link>
        <pubDate>Thu, 17 Jul 2025 20:25:44 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8530</guid>
      </item>
      <item>
        <title>DATATYPE! vs. TYPE!</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>Historical Rebol made the decision to call things like BLOCK! and INTEGER! "datatypes".</p>
<p>They were thus DATATYPE! and not TYPE!.</p>
<p>For a long time I thought that was unnecessarily wordy.  At some point I had a change of heart, and decided that I liked it.</p>
<p><em>I don't remember why I changed my mind, and can't find a post about that here.</em></p>
<p>It does have an advantage in the code as it stands, because internally <code>Type</code> is an enumeration (with an escape value in the enumeration as <code>TYPE_0</code> for <a href="https://rebol.metaeducation.com/t/extension-types-implementation/1203">extension types</a>)</p>
<p>Now that <a href="https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324">DATATYPE! is an antiform</a>, I do sort of appreciate it being a little "weirder" in its name.</p>
<p>But it's a decision that if it's going to be revisited, it needs to be revisited sooner rather than later.  It would be nice if I could remember why I thought there was a drawback to using just the name <code>TYPE!.</code></p> ]]></description>
        <link>https://rebol.metaeducation.com/t/datatype-vs-type/2510#post_1</link>
        <pubDate>Thu, 17 Jul 2025 10:58:43 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8528</guid>
      </item>
      <item>
        <title>WasmGC - Garbage Collection In WebAssembly</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>There's not a whole lot of code for the Ren-C garbage collector.</p>
<p>The lack of code is good and bad.  On the bad side, it's not very fast or clever (though the Stub and Cell formats themselves are very clever).  On the good side, it means that it could maybe be swapped out with a more sophisticated one, or a GC that integrates better with its specific environment.</p>
<p>One emerging possibility in the WebAssembly build is WasmGC:</p>
<p><a href="https://github.com/WebAssembly/gc/blob/main/proposals/gc/Overview.md" class="inline-onebox">gc/proposals/gc/Overview.md at main · WebAssembly/gc · GitHub</a></p>
<p>I'm not sure exactly how much of a sacrifice of the design it would be to use such things.  All the sizes and bits are very precisely arranged, and it may be that in order to make use of a generalized garbage collector you have to give up control of struct layout and put everything in a form that the generic GC expects.</p>
<p>But it's something to look at.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/wasmgc-garbage-collection-in-webassembly/2509#post_1</link>
        <pubDate>Wed, 16 Jul 2025 22:38:18 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8527</guid>
      </item>
      <item>
        <title>Should VOID Assigns Mean &quot;Fully Remove A Key&quot;?</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2431">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So Should You Declare "unassigned" Variables with <code>field: ~</code> or With <code>field: void</code>?</p>
</blockquote>
</aside>
<p>Given that <a href="https://rebol.metaeducation.com/t/should-things-like-text-fail-on-null/2452">type-checking is more strict now with respect to NULL and TRASH</a>, this does give a possible reasoning for why you might want to use a "void-to-unset" assignment.</p>
<p>Right now if you have a variable which is meant to optionally hold a function value, you don't want to use NULL:</p>
<pre><code> some-hook-that-takes-integer: null   ; optionally a function
</code></pre>
<p>Because then, if you try to call it with no arguments when it's not set, you get a no-op in todays world:</p>
<pre><code>&gt;&gt; some-hook-that-takes-integer 10
== 10
</code></pre>
<p>So you use TRASH! to "poison" such values, to stop that from happening.</p>
<p><em>(Alternative conceptions have been that maybe if something evaluates to null but is "not used" that raises an error--this idea of inert value discards being an error is something I think about from time to time, but have never actually tried.  It would be easier now to try it, so I should just go ahead and see what happens.)</em></p>
<p>In any case, if you use <code>^some-hook-that-takes-integer</code> you can get it back as a trash value vs. erroring on access.  But TRASH! isn't easy to convert to void--it wasn't meant for it.</p>
<p>So if you wrote:</p>
<pre><code>apply opt ^some-hook-that-takes-integer [10]
</code></pre>
<p>You would likely be intending "run the function if it's there, ignore it if it's not".  But you'd be OPT-ing a trash, which doesn't give you void today.</p>
<p>However... if we were to go with the unset concept, and <a href="https://rebol.metaeducation.com/t/what-should-new-refinements-e-g-foo-evaluate-to/2299/2">possibly leading colons turning them into nulls</a>, that would possibly allow for:</p>
<pre><code>apply opt :some-hook-that-takes-integer [10]
</code></pre>
<p>Then again, maybe OPT should be willing to turn TRASH! into null.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/man_shrugging.png?v=14" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20">  Trash lets you use descriptive messages for why something is trash, which being unset would sacrifice.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/should-void-assigns-mean-fully-remove-a-key/2431#post_4</link>
        <pubDate>Wed, 16 Jul 2025 10:31:52 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8526</guid>
      </item>
      <item>
        <title>Should Failed IF Be NULL (and Break My Heart :broken_heart:)?</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>Two months downstream of changing IF to return NULL, I'm now bringing the bootstrap code up to date.</p>
<p>It has to run in a world where a non-branch-taking IF does not vaporize in expressions, because it no longer returns VOID.  So the IFs have to be <code>OPT</code>'ed or <code>?</code>'ed or use <code>WHEN</code> instead.</p>
<p>It's a lot fewer changes than I thought, and usually you can write the code other ways to avoid it.  <em>But still, the changes definitely make me sad.</em>  I don't like the IF vs. WHEN distinction, and it wouldn't exist in a perfect world.</p>
<p>So I want to look at this again and ask if this is truly the last word--if there is no other option.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2419">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It's not legal to make <strong><code>f.dup</code></strong> a void, so in this situation we want <code>if null [5]</code> to be null.</p>
</blockquote>
</aside>
<p>It seems now that non-meta assignments of void, e.g. <strong><code>f.dup: void</code></strong> <a href="https://rebol.metaeducation.com/t/should-void-assigns-mean-fully-remove-a-key/2431/3">is going to be the way to make the field unset</a>.  That would mean it would do whatever an unspecified refinement would do, e.g. not be taken.</p>
<p>And actually...I'm somewhat torn on whether NULL is what is used in frame building to opt out of refinements (or an <strong><code>&lt;opt&gt;</code></strong> parameter) or not.  This kind of hinges on whether when the frame is built, if the <code>&lt;opt&gt;</code> does the transformation from void to null during fulfillment, or during type checking.  If you literally have to assign parameters to void, then to truly opt-them out (or specialize them out) you would <em>have</em> to use <strong><code>f.^dup: void</code></strong> ... which seems kind of crazy, but, you're asking to drop a refinement off the interface...which you didn't have to do--you could have left it alone and it just wouldn't have been supplied.</p>
<p>Anyway, this is no longer as clear-cut...and in fact, VOID may be necessary.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2419">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>There's one <em>bad</em> impliciation... and it's pretty bad indeed, I'm afraid. If ELSE is to work in this case, we have to make it so that empty packs themselves get packed:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">if 1 &lt; 0 [pack []] else [print "Don't want this to print..."]
</code></pre>
<p>The branch can't return an empty antiform pack if that triggers else. <em>It has to return a pack inside a pack</em>, e.g. unstable antiform ensconced in an unstable antiform. <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; if 1 &lt; 0 [pack ~[]~]
== ~[~[]~]~  ; anti
</code></pre>
<p>Such things are <em>legal</em> to construct (they have to be). But I'm wary of them decaying automatically.</p>
</blockquote>
</aside>
<p>This is kind of the big deal.</p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>I've been saying you can't unpack unstable antiforms automatically.  But... how bad is this?  What do you expect if you say:</p>
<pre><code>x: if condition1 [if condition2 [...]] else [1020]
</code></pre>
<p>In the case that condition1 is true and condition2 is false, what did you want X to be?  Is the error really that bad?</p>
<p>Not being able to unpack a pack doesn't bother the evaluator if you let the result drop on the floor, just if you try to use it.</p>
<p>But if we made branches pack up voids that refused to decay without explicit unpacking, that rules out things like:</p>
<pre><code> append [a b c] case [
     condition1 [void]  ; note: same as `condition1 []`
     condition2 [1020]
 ]
</code></pre>
<p>When VOID works here, you get the nice property that it will still error by default if none of the branches are taken (due to CASE returning NULL on no branch).  And then the VOID can opt out.</p>
<p>If that packed the branch so it wouldn't decay, you could still write something like:</p>
<pre><code> append [a b c] opt case [
     condition1 [null]
     condition2 [1020]
 ]
</code></pre>
<p>That would box the null, but the OPT would also turn a null from no cases into a void, so you'd not get the natural protection from no cases matching.</p>
<h2><a name="p-8525-looks-like-broken-heart-may-has-to-stay-broken-heart_exclamation-1" class="anchor" href="https://rebol.metaeducation.com#p-8525-looks-like-broken-heart-may-has-to-stay-broken-heart_exclamation-1"></a>Looks like Broken Heart May Has To Stay Broken <img src="https://rebol.metaeducation.com/images/emoji/twitter/heart_exclamation.png?v=14" title=":heart_exclamation:" class="emoji" alt=":heart_exclamation:" loading="lazy" width="20" height="20"></h2>
<p>This comes down to a contention between "IF being able to return void for no branch" vs. "branches being able to return void".</p>
<p>For THEN and ELSE to react to VOID without reacting to a branch that produces void, you wind up boxing an unstable pack in an unstable pack.  Making such an antiform on a casual basis is just not something viable to do.</p>
<p>So as much as I may not like the IF vs. WHEN distinction, it's just one of those things.  If you don't like it, there's <strong>opt if</strong> and <strong>? if</strong>, though they're not precise synonyms for WHEN, since they return void should the IF run a branch and evaluate the branch to null.</p>
<p>And you've still got the historical Redbol-style answer, of:</p>
<pre><code>either condition [...] []
</code></pre>
<p><strong>It's a pain point, but it just looks like the pain of making ELSE reactive to VOID when it's an unstable antiform creates much more pain.</strong>  Being able to say ELSE just reacts to "light" NULL--the only falsey value--solidifies the system in other ways.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/should-failed-if-be-null-and-break-my-heart/2419#post_4</link>
        <pubDate>Wed, 16 Jul 2025 03:50:51 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8525</guid>
      </item>
      <item>
        <title>What Should &quot;New Refinements&quot; (e.g. :FOO) Evaluate To?</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2299">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong><code>:foo.bar</code></strong> would thus similarly be a way of asking for FOO.BAR and if it wasn't there, giving you back NULL.</p>
<p>Well it's an idea.</p>
</blockquote>
</aside>
<p>As I found that folding TRY into OPT was likely a bad idea, that means when you want optionality of a potentially missing field you have to say:</p>
<pre><code>opt try obj.field
</code></pre>
<p>Which could be more compact as:</p>
<pre><code>opt :obj.field
</code></pre>
<p>Also, something to consider now, is that tuple-picking can give back an ERROR! as a value:</p>
<pre><code>obj: make object! [
    try ^field: fail "you can do this"
]
</code></pre>
<p>This means that <strong><code>obj.^field</code></strong> can legitimately return an ERROR!.  This calls into question my idea of using TRY on tuple picks to say "I want to get null if the field wasn't available".</p>
<p>So perhaps the leading colon could more narrowly mean "If the pick isn't there, give back null", so it doesn't wind up suppressing errors from meta-picks.</p>
<p>Narrowing it may be best, I don't know that I would want leading colon on function calls to mean "try".  The history of leading colon as inert makes it feel like it should be inert, but beyond that it seems to me like a decoration like that wouldn't go with invocation.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/what-should-new-refinements-e-g-foo-evaluate-to/2299#post_4</link>
        <pubDate>Wed, 16 Jul 2025 02:09:54 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8524</guid>
      </item>
      <item>
        <title>APPLY II: The Revenge!</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <h2><a name="p-8523-follow-up-apply-and-parameter-conventions-1" class="anchor" href="https://rebol.metaeducation.com#p-8523-follow-up-apply-and-parameter-conventions-1"></a>Follow-Up: APPLY And Parameter Conventions</h2>
<p>Historical APPLY has <em>not</em> taken parameter conventions into account.</p>
<p>So for instance: if you have a literal parameter (denoted by a quote mark) that has not been taken into account by the APPLY operation.</p>
<p>Should it?  It seems like maybe it should, so that <strong><code>foo // [baz bar]</code></strong> would be a synonym for <strong><code>foo baz bar</code></strong>, and maybe there should be a refinement to APPLY which lets you say not to take the parameter convention into account.</p>
<p>That may make sense for literal parameters, but what about ^META parameterization?</p>
<p>It could be based on whether you use <strong><code>^arg:</code></strong> or <strong><code>arg:</code></strong> or no label at all.</p>
<p>For example:</p>
<pre><code>metathing: func [^arg [pack! integer!]] [  ; sees packs, or plain integers
    probe arg
]

&gt;&gt; metathing // [pack [1 2]]
~['1 '2]~  ; anti

&gt;&gt; metathing // [arg: pack [1 2]]
1

&gt;&gt; metathing // [^arg: pack [1 2]]
~['1 '2]~  ; anti
</code></pre>
<p>How big a deal is this?  Errrrm.  Well, lifted refinements are rare (incredibly so right now, as they're not legal and none have ever been made).</p>
<h2><a name="p-8523-the-same-issue-applies-to-specialize-2" class="anchor" href="https://rebol.metaeducation.com#p-8523-the-same-issue-applies-to-specialize-2"></a>The Same Issue Applies to SPECIALIZE</h2>
<p>Right now, SPECIALIZE is very lax.  It binds the block of specializing code into the frame it is specializing.  You can run loops or do whatever you want.  This is not like APPLY... which does its own dialected interpretation of the block.</p>
<p>If SPECIALIZE runs generalized code in the frame, you would have to use lifted assignments to set the fields <strong>(^xxx: ...)</strong>.  If it was just dialected and mandated you write the code as <strong><code>[arg1: ... arg2: ...]</code></strong> then it might try the strategy I'm suggesting, where undecorated assignments decay, and <strong><code>^arg:</code></strong> assignments did not.  (This would present a thorn for specializing with a raised error, since a strict format would have nowhere to put a TRY...)</p>
<p>This is a tough call.  I can see uses for both kinds of operations, and that goes for APPLY as well (I called the run-arbitrary-code-version "APPLIQUE").</p>
<p>It would be nice if you could SPECIALIZE based on just order of args without naming them, like <strong><code>specialize add/ [5]</code></strong>... perhaps even leveraging trash to skip slots as <strong><code>specialize subtract/ [~ 10]</code></strong> (this starts to <a href="https://rebol.metaeducation.com/t/looking-into-a-usermode-pointfree/1236">tread on the turf of POINTFREE</a>, but that is proposed as a more complex operation that can do more than one layer of specialization).</p>
<p><em>(As a quick aside, I'll mention that <em>maybe</em> it would be possible to bind things like <strong><code>1:</code></strong> and <strong><code>^2:</code></strong> such that they could be used in SPECIALIZE or APPLY to refer to that Nth argument.  I can imagine ways this could work, but at this point it's just imagination.)</em></p>
<h2><a name="p-8523-common-case-likely-favors-dialected-interpretation-3" class="anchor" href="https://rebol.metaeducation.com#p-8523-common-case-likely-favors-dialected-interpretation-3"></a>Common Case Likely Favors Dialected Interpretation</h2>
<p>Experience dictates that the most common uses of specialize are things like:</p>
<pre><code>first: specialize pick/ [picker: 1]
</code></pre>
<p>It seems like a shame for it to be any worse than that.  Further, in this dialected interpretation I <em>know</em> how to make things like <code>1:</code> and <code>^2:</code> work--it's trivial because there's no binding in play, you're just walking a block and filling in a known FRAME!, grabbing a SET-XXX and then doing one step of eval each time.  This also means you could write something like:</p>
<pre><code>picker: 10
first: specialize pick/ [picker: picker - 9]
</code></pre>
<p>...since there's no binding needed for the frame fields, you can assume each expression being evaluated is bound in the active environment.</p>
<p>So what to call the version that binds a frame, and makes you use <strong><code>^picker:</code></strong> but lets you write more freeform code?  It could be <strong><code>specialize:freeform</code></strong> or <strong><code>specialize:code</code></strong> or something, shorthanded as <strong><code>specialize*</code></strong>.  Then APPLY would have a parallel notation (APPLIQUE was never meant to stick around...)</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/apply-ii-the-revenge/1834#post_10</link>
        <pubDate>Wed, 16 Jul 2025 01:36:28 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8523</guid>
      </item>
      <item>
        <title>Should VOID Assigns Mean &quot;Fully Remove A Key&quot;?</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>The concept of "void means remove" has gotten more entangled, now that it's legal to put unstable antiforms in metavariables (and, presumably, meta-map entries as well).</p>
<pre><code>&gt;&gt; m: make map! []

&gt;&gt; m.^key: pack [1 2]
== \~['1 '2]~\  ; antiform

&gt;&gt; m.^key
== \~['1 '2]~\  ; antiform
</code></pre>
<p>This means mapping to the empty pack of VOID (and presumably to GHOST!, or ERROR!) should be legal.</p>
<p><strong>That doesn't mean a non-^META assignment of VOID can't mean "remove".</strong>  But it would be a point of "inconsistency".</p>
<p>Though is it any more inconsistent than saying <strong><code>^e: fail "msg"</code></strong> is different from <strong><code>e: fail "msg"</code></strong> ... with the former storing an unstable ERROR! antiform, and the latter escalating the error to a panic?</p>
<p>Without some "assignment-based" mechanism to remove map keys, you'd have to use an operation that wasn't SET or a set-word.  For instance, if UNSET were kept as a prefix operation:</p>
<pre><code>unset $m.key
</code></pre>
<p>This requires branching your code in ways that aren't as pleasing as just being able to OPT your assignment out.</p>
<h2><a name="p-8522-rethinking-wacky-packs-1" class="anchor" href="https://rebol.metaeducation.com#p-8522-rethinking-wacky-packs-1"></a>Rethinking "Wacky Packs"</h2>
<p>I have proposed the wacky idea of using PACK! as a means of doing things like assignment-with-typechecking, using sub-band values (like a BLOCK! which is neither quoted nor quasi):</p>
<pre><code>&gt;&gt; var: (typed [integer! tag!] 1020)
== \~[ [&amp;[parameter! [integer! tag!]] '1020] ]~\  antiform
</code></pre>
<p>That could pretty clearly decay to the value minus the typecheck.</p>
<p>Then I floated similar ideas for unsetting things, using sub-band WORD! for example:</p>
<pre><code>&gt;&gt; var: unset
== \~[ *unset* ]~\  antiform
</code></pre>
<p>That would also be not-quoted and not-quasi inside the pack...so it can be distinguished as a special signal.  However, I wasn't sure what that should decay to (e.g. if you wrote <strong>any [x: unset ...]</strong>)</p>
<p>But neither of these ideas would be effective for ^META assignment, because the meta assignment would just store the pack.</p>
<h2><a name="p-8522-why-be-any-more-obtuse-let-void-unset-variables-2" class="anchor" href="https://rebol.metaeducation.com#p-8522-why-be-any-more-obtuse-let-void-unset-variables-2"></a>Why Be Any More Obtuse? Let VOID Unset Variables</h2>
<p>I'm kind of feeling now like VOID in non-^META assignments should just unset variables.  Then just live with the idea that ^META assignments can't be used to remove things.**  You can't have it both ways.</p>
<p>Since VOID is an empty PACK!, this would be a change from the situation of getting a panic today when you try:</p>
<pre><code>[x]: pack []   ; empty PACK! (definition of VOID)
</code></pre>
<p>Today the error guards you from misunderstandings, just as you're guarded against misunderstandings when you say:</p>
<pre><code>[x y]: pack [1]
</code></pre>
<p>But the problem is, that if you go and start trying to invent workarounds for ways to "assign" the unset state (like ~[<em>unset</em>]~) that are any weirder than this, your weirdness creates new problems.</p>
<hr>
<p><strong>I think that I now believe that either VOID non-^META assignments should be the way that you get the unset state, or there just isn't an offered way to get the unset state through assignment.</strong></p>
<hr>
<p>Ergonomically, being able to get the unset state through assignment has a lot of advantages.  And many assignments are not ^META.</p>
<p>I think it is worth it, to allow voids to unset variables--and remove them from maps--without having to write branching code to use a special removal operation.  If you truly are writing something "full-band" that wants to do meta-assignment -or- unset the variable, I guess it's acceptable that <em>then</em> you have to branch your code to do either a meta-assignment or a non-meta void assignment (or use the UNSET function).</p>
<h2><a name="p-8522-meditation-on-true-unset-3" class="anchor" href="https://rebol.metaeducation.com#p-8522-meditation-on-true-unset-3"></a>Meditation on True Unset</h2>
<p>"Unsetness" is perpetually thorny.</p>
<p>The idea of true unset has been to create an out of band state which would defeat accesses by even meta variable access with ^VAR.  You cannot specialize function arguments with the unset state... hence it's a state FRAME! variables can be in (present, but unset) but not one that's very friendly.</p>
<p>If FRAME! variables can be "present, but unset" what is it about MAP! keys that means they can't be present in an enumeration, but unset?  Should object variables have this?  Module variables?</p>
<p>If object variables can have the unset state, and you can get it just with a non-^META assignment to void, when would you write <strong><code>field: ~</code></strong> vs. <strong><code>field: void</code></strong> ?  Why prefer one over the other?  At least one difference would be that <code>^field</code> would work on the trash-assigned-variable, but not on the void-assigned-hence-unset-variable... but how does that inform things more generally?</p>
<p>I'll just throw in a little reminder of why trash is distinct from void in other places, e.g. why PRINT returns trash and not void.  <a href="https://rebol.metaeducation.com/t/console-treatment-of-void-vs-trash/2045">The reason is that VOID opts out of too many things.</a>, and:</p>
<pre><code> append data (... print "Hello"))
</code></pre>
<p>...should error, not be silent.  TRASH!'s raison-d'etre is to throw wrenches in things, whereas VOID is silently accepted as an opt-out.</p>
<p>(<em>So if anything, the current philosophy is backwards...</em> VOID should silently unset a SET-WORD!, while TRASH should cause a panic on the assignment.  Not that I believe it <em>should</em>, I'm just saying that if anything should be a panic, it's probably trash...not void.)</p>
<p>Back to the question: if VOID doesn't remove from MAP!, it's useless.  But VOID <em>can't</em> remove fields from FRAME!, because you can't remove fields from frames--and it's not what we'd want it to do.  You need to still be able to FOR-EACH enumerate a FRAME! to get at its keys, even if they're not assigned yet.</p>
<p>OBJECT! has the same underlying implementation as FRAME!--just an ordered set of slots in memory.  Why would VOID assignment remove any of those slots from enumeration?  LET variables start out life in the unset state...so why wouldn't a VOID assignment return them to that state?</p>
<p>It really seems like MAP! is just the odd one out here.  <strong>But it's not storing variables, it's storing mappings.</strong>  You can't bind into a map either.  I guess we can say simply that the unset state is something only variables need to worry about preserving.</p>
<p><strong>So Should You Declare "unassigned" Variables with <code>field: ~</code> or With <code>field: void</code>?</strong></p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>TRASH! is now truthy, by design, so using VOID means if you declare things in ANY or ALL, that would be skipped as a no-op, at least in the current imagining of ALL, that throws out voids:</p>
<pre><code> eval wrap all [
     x: y: z: void  ; ALL throws out voids this would be no vote
     ...
 ]
</code></pre>
<p>But one problem with it is that it's <em>not</em> assigning void, so it's misleading.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8522-reminder-why-isnt-void-was-the-unset-state-4" class="anchor" href="https://rebol.metaeducation.com#p-8522-reminder-why-isnt-void-was-the-unset-state-4"></a>Reminder: Why Isn't VOID Was The Unset State?</h2>
<p>Because several changes have come that are new, it's good to ask why <strong>Why isn't VOID as a Meta-Variable Assignment The "UNSET" state?</strong></p>
<p>Where this starts to break is in FRAME! creation, where unspecialized slots look like they're assigned void:</p>
<pre><code>&gt;&gt; f: make frame! subtract/
== &amp;[frame! [
     ^value1: ~[]~
     ^value2: ~[]~
 ]]
</code></pre>
<p>The problem is, VOID is now used to opt-out of things.  You couldn't then tell the difference between:</p>
<pre><code> make frame! [foo void]
 make frame! [foo]
</code></pre>
<p><strong>This has been why the "truly unset" state has been important--something an evaluation cannot produce, yet a variable can represent (but never fetch with GET).</strong>  I do note, though, that there's an advantage if void is allowed to set things to the unset state, that means there can be a difference:</p>
<pre><code>&amp;[frame! [
     value1: ~[]~  ; non-meta assignment (value1 is unset)
     ^value2: ~[]~  ; meta-assignment (value2 is void)
 ]]
</code></pre>
<h2><a name="p-8522-guidance-still-hazy-but-mechanics-look-solid-5" class="anchor" href="https://rebol.metaeducation.com#p-8522-guidance-still-hazy-but-mechanics-look-solid-5"></a>Guidance Still Hazy, But Mechanics Look Solid</h2>
<p>It bothers me some to have <strong><code>x: void</code></strong> be legal, because it looks like you've assigned void to the variable... when a non-^META assignment can't do that.  This has been an error historically, and it feels misleading to make it a non-error.</p>
<p><em>However</em>--as I've said--<em><strong>IF</strong></em> there is going to be a state that unsets variables through assignment, it doesn't make sense to use a state other than void (more generally, "missing pack slot").  There are too many questions opened up by using another state.</p>
<p>So as for the misleadingness... I could similarly say that it's misleading to do <strong>append [a b c] void</strong> and get back <strong>[a b c]</strong>, "because you didn't really append void".  No...because you can't append void to a block..but there is meaning applied to it anyway.</p>
<p>But when it comes to coherent source, this does make it seem better to assign things with <strong><code>~</code></strong> in general when you want to poison them.  This works whether you're doing an assignment or a meta-assignment, and also has a smooth transition to if you want to use a labeled trash.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/should-void-assigns-mean-fully-remove-a-key/2431#post_3</link>
        <pubDate>Tue, 15 Jul 2025 22:58:53 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8522</guid>
      </item>
      <item>
        <title>Design for Something Like FLIP To Reverse Arguments</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2345">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>One Solution: REFRAMER And INTEGER Indexing</p>
</blockquote>
</aside>
<p>This is an interesting way of doing it, but has a flaw... namely parameter conventions.</p>
<p>Although type checking isn't done until you actually run the function, if parameters are taken literally then you'd run into trouble if you tried to FLIP a function whose arguments weren't both the same convention.</p>
<p>So unfortunately, a real FLIP/FLIPPED would have to use a deeper mechanic.  But, interesting to see how close some of these things can get...and the integer-based indexing is definitely useful.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/design-for-something-like-flip-to-reverse-arguments/2345#post_4</link>
        <pubDate>Tue, 15 Jul 2025 09:10:18 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8521</guid>
      </item>
      <item>
        <title>.WORD as Member Selection</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>I've shifted the mechanics of binding, such that WORD!s <strong><a href="https://rebol.metaeducation.com/t/should-word-capture-the-whole-binding-environment/2494">now capture the full binding environment</a></strong>.</p>
<p>A consequence of this is that "wordlike" sequences that are compressible to WORD! size--such as <strong><code>.foo</code></strong>--also do the same.</p>
<p>This makes it feasible to build the "magic" of behavior that <strong><code>.foo</code></strong> picks out of the "current object" as being simply a matter of giving the current object a name in the environment, and looking up that name.  When a METHOD ran, it would use the "coupling" from the invocation to spread that name down...just like a definitional RETURN (or anything else) would.</p>
<p>I debated whether this name should be simply "dot" (<strong><code>.</code></strong>) or if it should be something more English-like, such as <strong><code>this</code></strong>.   It seemed to me that dot was harder to see, and also maybe a bit confusing... because <strong><code>.foo</code></strong> would be equivalent to <strong><code>(.).foo</code></strong>, which looks strange.  It seemed easier to explain that it was just a shorthand for <strong><code>this.foo</code></strong></p>
<p>So I leaned to favoring <strong>this</strong>.</p>
<p>But <strong><code>/foo</code></strong> has a now very important meaning related to foo as an action antiform you want to run.  That means it can't implicitly mean there's an invisible object on the left.</p>
<p>That makes a pretty strong argument for <strong><code>.</code></strong> being the WORD! used for the current object, because that gives <strong><code>./foo</code></strong> as the way of  running a member function out of the current object.</p>
<p>Do remember that people will be able to write something like: <strong><code>use .</code></strong> in their method body if they want to omit the dot on member accesses.  But I think calling out the member accesses is worth it, and the notation is much lighter than requiring you to say <code>this.foo</code> or <code>self.foo</code></p>
<p>Anyway, I'm moving ahead and ripping out the old frail hack that implemented the <strong>.WORD</strong> convention and replacing it with this, which has a more solid and reliable basis.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/word-as-member-selection/1843#post_5</link>
        <pubDate>Mon, 14 Jul 2025 12:45:37 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8520</guid>
      </item>
      <item>
        <title>Design for Something Like FLIP To Reverse Arguments</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="2345">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>If it were an operator that acted on functions, it wouldn't retrigger them. You'd have to say:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; append 'd [a b c]  ; &lt;-- reversed concept of APPEND
== [a b c d]

&gt;&gt; run flip append/ [a b c] 'd
== [a b c d]
</code></pre>
</blockquote>
</aside>
<p>Maybe the distinction could be FLIPPED vs. FLIP?  I don't know.</p>
<pre><code>&gt;&gt; append [a b c] [d e]  ; &lt;-- today's concept of append
== [a b c [d e]]

&gt;&gt; flip append [a b c] [d e]
== [d e [a b c]]

&gt;&gt; fappend: flipped append/

&gt;&gt; fappend [a b c] [d e]
== [d e [a b c]]
</code></pre>
<p>I can't think of it being totally obvious why one name would be used for one vs. the other.  Though the impromptu FLIP is probably something that would be used more often, hence probably deserves the shorter name.</p>
<p>The function-generating FLIPPED could be done with a conventional ENCLOSE vs. a REFRAMER, because you know the function you're operating on in advance:</p>
<pre><code>flipped: lambda [action [&lt;unrun&gt; frame!]] 
    enclose action f -&gt; [swap $f.1 $f.2, eval f]
]
</code></pre> ]]></description>
        <link>https://rebol.metaeducation.com/t/design-for-something-like-flip-to-reverse-arguments/2345#post_3</link>
        <pubDate>Mon, 14 Jul 2025 08:34:03 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8519</guid>
      </item>
      <item>
        <title>Introducing REFRAMER: Close Cousin to ENCLOSE</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1395">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But what if we made a REQUOTE that:</p>
<ul>
<li>would build a frame for whatever follows it</li>
<li>counted how many quoting levels were on the first argument in that frame</li>
<li>took the quoting levels off that first argument</li>
<li>ran the function</li>
<li>added the quoting levels back to the result</li>
</ul>
<p>It should be an easier function to write than it is, but even so it's not that hard:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">requote: reframer func [
     "Remove Quoting Levels From First Argument and Re-Apply to Result"
     f [frame!]
     &lt;local&gt; p num-quotes result
][
    p: first words of f
    num-quotes: quotes of f.(p)
    f.(p): noquote f.(p)

    if null? result: eval f [return null]  ; exempt NULL from requoting

    return quote:depth get:any $result num-quotes
]
</code></pre>
</blockquote>
</aside>
<p>With <a href="https://rebol.metaeducation.com/t/picking-function-arguments-by-integer/2507">FRAME! Indexing By Integer</a> and the new <a href="https://rebol.metaeducation.com/t/virtual-binding-based-error-propagation-operator/2389">TRAP propagating definitional error operator</a>, it gets easier to write, faster, and more robust...</p>
<pre><code>requote: reframer func [
    "Remove Quoting Levels From First Argument and Re-Apply to Result"
    f [frame!]
    &lt;local&gt; num-quotes
][
    num-quotes: quotes of (f.1 except [
        panic ["REQUOTE must have an argument to process"]
    ])

    f.1: noquote f.1

    return quote:depth opt (trap eval f) num-quotes
]
</code></pre> ]]></description>
        <link>https://rebol.metaeducation.com/t/introducing-reframer-close-cousin-to-enclose/1395#post_4</link>
        <pubDate>Mon, 14 Jul 2025 08:13:53 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8518</guid>
      </item>
      <item>
        <title>Design for Something Like FLIP To Reverse Arguments</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <h2><a name="p-8517-one-solution-reframer-and-integer-indexing-1" class="anchor" href="https://rebol.metaeducation.com#p-8517-one-solution-reframer-and-integer-indexing-1"></a>One Solution: REFRAMER And INTEGER Indexing</h2>
<p>The REFRAMER is something that lets you get a chance to hook a function call after it has accumulated its arguments, but before it has done typechecking:</p>
<p><strong><a href="https://rebol.metaeducation.com/t/introducing-reframer-close-cousin-to-enclose/1395">Introducing REFRAMER: Close Cousin to ENCLOSE</a></strong></p>
<p>Then, FRAME! now supports INTEGER! indexing... as a way of accessing non-refinement parameters as they would be seen on the interface:</p>
<p><strong><a href="https://rebol.metaeducation.com/t/picking-function-arguments-by-integer/2507">Picking Function Arguments By Integer</a></strong></p>
<p>So just make a REFRAMER that adds no arguments, and does a parameter switcheroo before executing the frame:</p>
<pre><code>flip: reframer lambda [f [frame!]] [
    let temp: f.2
    f.2: f.1
    f.1: temp
    eval f
]

&gt;&gt; flip append [a b c] [d e]
== [d e [a b c]]

&gt;&gt; flip divide 10 20
== 2
</code></pre>
<h2><a name="p-8517-the-definition-could-be-briefer-2" class="anchor" href="https://rebol.metaeducation.com#p-8517-the-definition-could-be-briefer-2"></a>The Definition Could Be Briefer...</h2>
<p>Right now, the SWAP operation doesn't act on variables... it acts on series, and errors on WORD!s.  I kind of feel like swapping variables is the more common intent, not entirely sure what the ramifications of overloading the SWAP operation to do something that different are.</p>
<p>But it could be this short, for those who seek brevity:</p>
<pre><code>flip: reframer f -&gt; [swap $f.1 $f.2, eval f]
</code></pre>
<p>cc: <a class="mention" href="https://rebol.metaeducation.com/u/bradrn">@bradrn</a></p> ]]></description>
        <link>https://rebol.metaeducation.com/t/design-for-something-like-flip-to-reverse-arguments/2345#post_2</link>
        <pubDate>Mon, 14 Jul 2025 08:04:38 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8517</guid>
      </item>
      <item>
        <title>Using ~null~ and ~okay~ instead of NULL and OKAY</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>When I first proposed some of the ideas like quasiforms, they were quite foreign.</p>
<p>Now they're familiar.  Given their familiarity, I start to wonder if the "weird" nature of null and okay is tolerable for source code.  e.g. might you write:</p>
<pre><code> var: ~null~
</code></pre>
<p>...instead of...:</p>
<pre><code>var: null
</code></pre>
<p>It's a bit annoying to type, but if you get used to it, it's not necessarily bad to stand out in that way.</p>
<p>Not that this should matter too much, but using <code>~null~</code> is inherently faster.  There's no variable to look up... you're just turning a WORD! at the quasiform lift level to the antiform lift level.  (Technically that does require validation, since not all quasi-words are legal anti-words, but this validation can be arbitrarily fast.)</p>
<p>One negative side of using the quasiforms is it may add noise where it's not something you want to emphasize.  As such, maybe this is a decision to be made on a case-by-case basis... do you want to draw attention or not, like... "HEY, I'm setting this to NULL and that's an important point!"</p>
<p>Not sure.  But I find myself tempted to use the quasiform now and again, and usually decide to back it out because I feel like it should be "always do it" or "never do it".  But maybe that's the worng dichotomy.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/using-null-and-okay-instead-of-null-and-okay/2508#post_1</link>
        <pubDate>Mon, 14 Jul 2025 07:33:24 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8516</guid>
      </item>
      <item>
        <title>Picking Function Arguments By Integer</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p><em>Another question:</em></p>
<h3><a name="p-8515-how-do-you-get-the-name-of-parameter-by-index-1" class="anchor" href="https://rebol.metaeducation.com#p-8515-how-do-you-get-the-name-of-parameter-by-index-1"></a>How Do You Get The "Name" Of  Parameter By Index?</h3>
<p>You can ask for a PARAMETER! definition by name:</p>
<pre><code>&gt;&gt; append.series
== &amp;[parameter! [&lt;opt-out&gt; any-series? port! map! object! module! bitset!]]
</code></pre>
<p>And we've established you can ask for it by number, so long as it isn't a refinement:</p>
<pre><code>&gt;&gt; append.1
== &amp;[parameter! [&lt;opt-out&gt; any-series? port! map! object! module! bitset!]]
</code></pre>
<p>If I have either 1 or SERIES I can get the parameter definition, and ask it questions, but "what's your symbol" isn't one of those questions, as the same PARAMETER! can appear multiple places.  They are a set of type constraints, and you can move them around and copy them in function parameter slots.</p>
<p><strong>What if I want the name of parameter 1?</strong>  (or perhaps, even, what if I want the index of parameter series?)</p>
<p>I don't have a particular use for that right now, but I thought of it, so I wanted to raise the question.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/picking-function-arguments-by-integer/2507#post_2</link>
        <pubDate>Mon, 14 Jul 2025 06:23:59 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8515</guid>
      </item>
      <item>
        <title>Picking Function Arguments By Integer</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p><a href="https://rebol.metaeducation.com/t/introducingnew-chain-datatype/2226">Having concepts like CHAIN!</a> means there are "set integers" now, which has opened up the possibility for things like:</p>
<pre><code>sub1000: specialize subtract/ [2: 1000]
</code></pre>
<p>This would prevent you from having to specifically know the name of the argument you are specializing.  That seems sensible, given that you don't need to know the name to call it.</p>
<p>It seems you should also be able to do this with frames:</p>
<pre><code>&gt;&gt; f: make frame! subtract/

&gt;&gt; f.1: 1020
&gt;&gt; f.2: 1000

&gt;&gt; eval f
== 20
</code></pre>
<p><strong>It should not work with refinements.</strong>  Rebol2/Red/R3-Alpha expose the implementation detail of what position refinement arguments are in, but it was a bad idea for them... and an even worse idea for Ren-C.</p>
<p>Consider AUGMENT, for example.  Let's make an arity-3 version of APPEND, that takes an argument to add before appending:</p>
<pre><code>&gt;&gt; apadd: adapt (augment append/ [num [integer!]]) [
       value: value + num
   ]

&gt;&gt; apadd [a b c] 1000 20
== [a b c 1020]
</code></pre>
<p>Do take a moment to appreciate how cool that is... AUGMENT creates a function with an expanded specification (but no variation in behavior), and then ADAPT puts in a preamble which uses the added parameter by adding it to the value...before falling through to the ordinary implementation of APPEND.  (ENCLOSE could be used if you had a more complicated idea for what to do that didn't fit as just an adjustment in a preamble.)</p>
<p>BUT once you're finished appreciating how cool that is, consider what we want if we make a frame for APADD:</p>
<pre><code>&gt;&gt; f: make frame! apadd/

&gt;&gt; f.1: [a b c]
&gt;&gt; f.2: 1000
&gt;&gt; f.3: 20

&gt;&gt; eval f
== [a b c 1020]
</code></pre>
<p>However, consider that it also has refinements available:</p>
<pre><code>&gt;&gt; apadd:dup [a b c] 1000 20 3
== [a b c 1020 1020 1020]
</code></pre>
<p><strong>So we see that the new non-refinement argument properly indexes as the 3rd argument, and it could not do that if refinements were INTEGER!-indexed.</strong>  Because if :DUP was something like index 3 in the frame for APPEND originally, it wouldn't be out of the way of the augmented form.</p>
<p>Seems pretty good, but there are some quirks...</p>
<h2><a name="p-8514-lens-matters-1" class="anchor" href="https://rebol.metaeducation.com#p-8514-lens-matters-1"></a>Lens Matters</h2>
<p>I've written a bit about <strong><a href="https://rebol.metaeducation.com/t/understanding-frame-lensing/1645">FRAME! Lensing</a></strong>.  It's not just an efficiency trick...because I wouldn't know how to implement function composition otherwise.</p>
<p>Because of Lenses, a frame built for a function with the same positionality can expose different interfaces.  Consider our APADD above, imagine specializing the thing you append to:</p>
<pre><code>&gt;&gt; data: [a b c]

&gt;&gt; accrue: specialize apadd/ [data]

&gt;&gt; accrue 1000 20
== [a b c 1020]

&gt;&gt; accrue 300 4
== [a b c 1020 304]
</code></pre>
<p>So now, we would hope that ACCRUE thinks of its 1 and 2 parameters as being what APADD thought of as 2 and 3.</p>
<pre><code>&gt;&gt; f: make frame! accrue/

&gt;&gt; f.1: 400
&gt;&gt; f.2: 21

&gt;&gt; eval f
== [a b c 1020 304 421]
</code></pre>
<p><strong>Satisfying!</strong></p>
<h2><a name="p-8514-but-what-does-integer-indexing-mean-with-no-lens-2" class="anchor" href="https://rebol.metaeducation.com#p-8514-but-what-does-integer-indexing-mean-with-no-lens-2"></a>But What Does Integer Indexing Mean With <em>No Lens</em> ?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></h2>
<p>There's a point where all the Lenses are gone, and you are in the raw function implementation... the FRAME! as the underlying implementation expected to see it.  If you do a FOR-EACH on a frame in this view, you see everything.. refinements, locals, definitional RETURN (if there is one).</p>
<pre><code>&gt;&gt; foo: func [arg1 :refine1 arg2 :refine2 &lt;local&gt; local1] [
       let frame: binding of $arg1
       for-each 'key frame [probe key]
   ]

&gt;&gt; foo 1020
return
arg1
refine1
arg2
refine2
local1
</code></pre>
<p>What (if anything) does indexing mean at this level?  <strong>frame.1</strong> giving you back the definitional RETURN would be barely useful... probably even <em>anti</em>-useful.</p>
<p><strong>I think it's pretty clear the integer indexing on an unlensed frame should act as if you were seeing the frame from the perspective of a caller with the "default Lens", e.g. what someone who did MAKE FRAME! would see.</strong></p>
<p>So <strong>frame.1</strong> would give you arg1, and <strong>frame.2</strong> would give you arg2, and that would be it.</p>
<h2><a name="p-8514-should-object-offer-indexed-access-3" class="anchor" href="https://rebol.metaeducation.com#p-8514-should-object-offer-indexed-access-3"></a>Should OBJECT! Offer Indexed Access?</h2>
<p>I've settled that FRAME! should offer it.  Here we see it has the interesting consequence that not all frame fields can be accessed with integer indexes, only</p>
<p>But I don't know what--if anything--this implies for OBJECT!.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/picking-function-arguments-by-integer/2507#post_1</link>
        <pubDate>Mon, 14 Jul 2025 06:23:29 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8514</guid>
      </item>
      <item>
        <title>REIFY and DEGRADE: a Narrower LIFT and UNLIFT</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <blockquote>
<p><strong>REIFY and DEGRADE: a Narrower LIFT and UNLIFT</strong></p>
</blockquote>
<p>When these names were initially picked, LIFT and UNLIFT were called "META and UNMETA".</p>
<p>Now that they have more fitting names, I can more easily see these being:</p>
<ul>
<li>
<p>REIFY =&gt; <strong><code>LIFT:ANTIFORMS</code></strong></p>
</li>
<li>
<p>DEGRADE =&gt; <strong><code>UNLIFT:QUASIFORMS</code></strong></p>
</li>
</ul>
<p>It's more palatable with the lift term.  But it doesn't exactly speak to what happens if you're lifting a non-antiform or unlifting a non-quasiform.</p>
<p>I probably still like having distinct terms as REIFY and DEGRADE.  Would be good to have usability tests for that.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/reify-and-degrade-a-narrower-lift-and-unlift/2163#post_3</link>
        <pubDate>Sun, 13 Jul 2025 12:07:25 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8513</guid>
      </item>
      <item>
        <title>Making position argument explicit in COMBINATOR</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2445">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But for clarity, should combinators have some mention of REMAINDER in the interface? Even something like an <code>&lt;assigns&gt;</code> TAG! in the spec?</p>
</blockquote>
</aside>
<p>In actuality... given the way COMBINATOR is designed, it could just package up whatever you named as your input parameter as part of the multi-return output.  Thus, whatever it was set to at the end of the operation would be the remainder!</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">tally: combinator [
    "Iterate a rule and count the number of times it matches"
    return: "Number of matches (can be 0)"
        [integer!]
    pos [any-series?]
    parser [action!]
][
    let count: 0
    cycle [
        [^ pos]: parser pos except [
            ; remainder: pos  ; &lt;-- instead, presume updated POS is remainder
            return count  ; return is hooked, acts like `pack [count pos ...]`
        ]
        count: count + 1
    ]
]
</code></pre>
<p><strong>I like it!</strong>  Auto-proxying an input into an expanded multi-return of the output is a bizarre mechanic for accomplishing something like pass-by-reference.  But looks like a good fit...</p>
<p>COMBINATOR continues to zero in on essential complexity of what it does!</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2445">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>That could actually have some value, in that if you don't say it then you're implicitly saying your parser doesn't move the parse position... <em>and it could automatically assume the remainder is the input position for you.</em></p>
</blockquote>
</aside>
<p>In the alternative conception, if you just don't change the input, then it would assume the position stayed the same.  Clean and simple.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/making-position-argument-explicit-in-combinator/2445#post_2</link>
        <pubDate>Sun, 13 Jul 2025 00:01:54 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8512</guid>
      </item>
      <item>
        <title>Why (ghost? get $ghost) Fails (and TRIPWIRE, VOID)</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="2234">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>This does mean that some pretty demos become a little uglier:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; replace [a b [a b] a b] spread [a b] ^void
== [[a b]]
</code></pre>
</blockquote>
</aside>
<p>Another thing to consider is how this affects dialects.</p>
<p>For a time, VOID was a stable antiform of a word, as ~void~.  PARSE would let you fetch it with an @ rule:</p>
<pre><code>&gt;&gt; void? parse [a b] ['a 'b @void]
== \~okay~\  ; antiform
</code></pre>
<p>When it had to become a function, this stopped working.</p>
<p>Should it work?  I don't know.  But if it's going to work, it makes more sense to have it work for any variable that happens to have been meta-assigned void, than to make a loophole for one particular function that returns void.</p>
<p>I'm not sure if it <em>should</em> work, because one of the big premises of voids is that they are accepted casually in many places to mean opt-out because you can't get void from a simple variable reference.  So having void variables wasn't supposed to be a thing... this may have been misguided feature.</p>
<p>In any case, I haven't taken action on this, but I am feeling like the metavariables are likely to replace the functions.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/why-ghost-get-ghost-fails-and-tripwire-void/2234#post_7</link>
        <pubDate>Sat, 12 Jul 2025 22:04:03 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8511</guid>
      </item>
      <item>
        <title>Virtual-Binding-Based &quot;Error Propagation Operator&quot; :exploding_head:</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="7" data-topic="2389">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">    trappy: func [] [
        let x: trap 1 * 0
        let y: trap 1 / 0
        return x + y
    ]
</code></pre>
</blockquote>
</aside>
<p>I'll mention something kind of curious.</p>
<p>You can actually put the TRAP on the outside of the assignment:</p>
<pre><code>trappy: func [] [
    trap let x: 1 * 0
    trap let y: 1 / 0
    return x + y
]
</code></pre>
<p>If you weren't using LETs here and depending on the variables surviving the scope, you could even use parentheses:</p>
<pre><code>trappy: func [&lt;local&gt; x y] [
    trap (x: 1 * 0)
    trap (y: 1 / 0)
    return x + y
]
</code></pre>
<p>This is because the way plain assignment works, it will skip the assignment in case of an error and the overall expression evaluates to an error.</p>
<p>Note that ^META assignments are different:</p>
<pre><code>trap ^x: fail "different!"
</code></pre>
<p>This would <em>not</em> skip the assignment.  Which means that's fundamentally distinct from:</p>
<pre><code>^x: trap fail "different!"
</code></pre>
<p>I'll mention that the new REQUIRE operator is a general tool for ducking the assignment of errors and failing afterwards when using meta assignment:</p>
<pre><code>^x: require some-potentially-erroring-thing
</code></pre>
<p>Part of what makes this interesting is that I've aligned the C code to use the same techniques and terminology.  So you will see calls to <strong><code>trap ()</code></strong> that propagate errors to the return of the running function (via macro) by testing a global error state.  These calls have to be on the outside in order to be "safe", to avoid usages which might break due to being used in branches without scopes.  Random details here--but--it's cool that the usermode constructs support the style that the C code is forced to use.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/virtual-binding-based-error-propagation-operator/2389#post_8</link>
        <pubDate>Sat, 12 Jul 2025 12:30:37 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8510</guid>
      </item>
      <item>
        <title>The Truthiness of Trash</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="2180">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>To try and characterize trash, we can look at the places it appears:</p>
<p>Contents of an unset variable:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; asdf
** Script Error: asdf is ~ antiform (see ^(...) and GET/ANY)
</code></pre>
</blockquote>
</aside>
<p>So this isn't the case any longer, because there is such a thing as "true unset".  You can't fetch a variable in true unset state with either <strong><code>asdf</code></strong> or <strong><code>^asdf</code></strong>, while TRASH would be fetchable with the <strong><code>^asdf</code></strong>.</p>
<p>Unset is a so-called "dual state", which can't be returned by any expression evaluation.  Though there's been some theorization that dual-state unset assignments might be accomplished with a "sub-band" PACK!, e.g.:</p>
<pre><code> var: ~[*unset*]~  ; packs typically only contain quoted/quasiforms
</code></pre>
<p>This does raise questions about what such a pack would decay to... if it could decay.</p>
<pre><code> all [
     var: ~[*unset*]~
     ...
 ]
</code></pre>
<p>It might be that if forced to decay, it could become a GHOST!... though this is misleading.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20">  I'm wary of it, and would rather say such things are undecayable.</p>
<h2><a name="p-8509-but-back-on-track-with-trash-1" class="anchor" href="https://rebol.metaeducation.com#p-8509-but-back-on-track-with-trash-1"></a>But, Back on Track With TRASH!</h2>
<p>I think truthy trash definitely looks like the right way to go.</p>
<p>For a time it was contentious because trash couldn't be passed by non-meta arguments to things like IF to act as a condition.  But now it can, due to unspecialized parameters being done with "true unset".</p>
<p>So now the question is: <em>Are there any non-truthy stable antiforms, that would cause an error if you try to test them?</em></p>
<p>If there were, they would be KEYWORD!.  But today we only have <code>~null~</code>, <code>~okay~</code>, and there's a fledgling idea of <strong><code>~NaN~</code></strong>...for not-a-number.</p>
<p>The concept of KEYWORD! is that this would be an axis of extensibility if more weird states are needed in the future.  It may be that we can say ~NaN~ is falsey, though that does create some hassle in the otherwise-easy world where ~null~ is the <em>only</em> falsey stable state.  But I'm hard-pressed to believe that everything that ever comes along in the future as a keyword would make sense as being either truthy or falsey.</p>
<p>Anyway--that's the new frontier.  TRASH! is truthy, and it seems to be working!</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/the-truthiness-of-trash/2180#post_5</link>
        <pubDate>Sat, 12 Jul 2025 05:57:49 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8509</guid>
      </item>
      <item>
        <title>Naming function args: VALUE, ELEMENT, ATOM, SERIES</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2387">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Are Varying Names to Arity-1 Functions Too Annoying?</p>
</blockquote>
</aside>
<p>Today I gave an example of this with specializing RETURN:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2479">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479/3">Virtual Binding + Macros =&gt; BREAK, CONTINUE, AGAIN</a></div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext"> foo: func [] [
     return: adapt return/ [atom: atom + 20]
     return 1000  ; acts as if you hadn't adapted, and returned 1020
 ]
</code></pre>
</blockquote>
</aside>
<p>That "atom" is definitely annoying to remember.  And it's just annoying to read.  I think people's (valid) natural reaction would be: <em>"why is the word 'atom' there?"</em></p>
<p>It used to make sense, because you had to know it spoke in "lifted protocol", and had to do extra laborious work:</p>
<pre><code>foo: func [] [
    return: adapt return/ [atom: lift (unlift atom + 20)]
    return 1000  ; acts as if you hadn't adapted, and returned 1020
]
</code></pre>
<p>But you don't need to do that anymore!</p>
<p><strong>The advantage to the weird name has dropped significantly, because of <a href="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477">"Lift the Universe"</a>.</strong>  You don't have to be as aware of their special status to work with them--which is a <em>major</em> advancement.  Instead of lifting and unlifting, you can just be oblivious, unless you specifically want to work in the unstable antiform realm.</p>
<p>e.g. let's say we just called it <code>value</code>.  If you were going to make the return value a PACK!, now this would look like:</p>
<pre><code>foo: func [] [
    return: adapt return/ [^value: pack [value 304]]
    return 1000  ; acts as if you hadn't adapted, and returned pack [1000 304]
]
</code></pre>
<p><strong>"Lift the Universe" has truly saved the system from a lot of unpleasantness, and fixing this name is one more place it fixes.</strong></p>
<p>It's <em>way</em> better.</p>
<h2><a name="p-8508-so-what-does-the-term-value-mean-now-1" class="anchor" href="https://rebol.metaeducation.com#p-8508-so-what-does-the-term-value-mean-now-1"></a>So What Does The Term "Value" Mean Now?</h2>
<p>The <a href="https://rebol.metaeducation.com/t/should-any-value-include-stable-antiforms/2026/4">internal naming convention</a> has been:</p>
<ul>
<li>
<p><strong>Element</strong> - Anything You Can Put in a List (no antiforms)</p>
</li>
<li>
<p><strong>Value</strong> - Anything You Can Put In a Variable (no <em>unstable</em> antiforms)</p>
</li>
<li>
<p><strong>Atom</strong> - Any State an Evaluation Can Produce (unstable antiforms included)</p>
</li>
</ul>
<p>This got leaked to user awareness pretty much verbatim, with functions like ANY-ATOM?, ANY-VALUE?, and ANY-ELEMENT?</p>
<p><strong>It's no longer the case that variables are limited to stable antiforms, if you use ^META assignments or ^META fetches.</strong>  It's made some things trickier, but overall the ergonmics and invariants took a big step up.</p>
<h2><a name="p-8508-value-seems-like-the-superclass-now-2" class="anchor" href="https://rebol.metaeducation.com#p-8508-value-seems-like-the-superclass-now-2"></a>Value Seems Like The Superclass Now</h2>
<p>It would be tempting to say that Atom is just distinguished as <strong><code>MetaValue</code></strong></p>
<p>Unfortunately this collides with <strong><code>^value</code></strong> being a "METAFORM" (as opposed to <strong><code>$value</code></strong> being "TIED" and <strong><code>@value</code></strong> being "PINNED").  So MetaValue risks confusion with that.</p>
<p>Perhaps the classes should be:</p>
<ul>
<li>Element</li>
<li>"old Value" =&gt; "Stable"</li>
<li>"old Atom" =&gt; "Value"</li>
</ul>
<p>That would swap out one weirdness (calling a subclass of Cell "Atom") with another weirdness (calling a subclass "Stable").  But one does adjust to things.  I thought Element* was pretty weird at first for subclassing things that could be put in List, but it has come to feel very familiar.</p>
<p>However: one place this doesn't work very well is the API, which by design doesn't expose unstable states... so it calls everything "Value*".   Hence the API would be exposing Stable* as Value*.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20">  Code mixes internal and API code together, and calling Atom "Value" would be out.</p>
<p>Maybe:</p>
<ul>
<li>Element</li>
<li>"old Value" =&gt; "Stable"</li>
<li>"old Atom" =&gt; "Unstable"</li>
</ul>
<p>However, the reason I originally called it "Atom" instead of "Unstable" is that the constraint for the type doesn't mean it <em>is</em> unstable, only that it's <code>PotentiallyUnstable</code>.</p>
<p>To not rock the boat too much, one might just say:</p>
<ul>
<li>Element</li>
<li>"old Value" =&gt; "Stable"</li>
<li>Atom</li>
</ul>
<p>Then "Value" could be a more nebulous term.  In the API it necessarily implies a stable value, because no other kind is exposed.</p>
<p>But since API Values are all over the place internally, I think the "Stable" name would just make things uglier and create a disconnect.</p>
<h2><a name="p-8508-usermode-atom-as-any-value-value-as-any-stable-3" class="anchor" href="https://rebol.metaeducation.com#p-8508-usermode-atom-as-any-value-value-as-any-stable-3"></a>Usermode Atom* as ANY-VALUE?, Value* as ANY-STABLE?</h2>
<p>I suspect the thing is just in usermode, to drop the exposure of Atom, instead having that be ANY-VALUE?... with what's tested for as any-value? today becoming ANY-STABLE?</p>
<p>If one really had it out for the Atom term internal to the source, you could say:</p>
<ul>
<li>Element</li>
<li>Value</li>
<li>"old Atom" =&gt; AnyValue</li>
</ul>
<p>But meh.  It's probably fine how it is.</p>
<p>So back to the original point of the discussion:</p>
<p><strong>I don't think calling these arguments anything besides <code>value</code> helps in proportion to the hurt it does by making them variant.</strong>  It also means having to potentially synchronize the name of your arguments the one day that you decide you can do some interesting processing of an unstable (or stable) antiform.</p>
<p>Hence, I've moved arguments back from names like <code>atom</code> and <code>element</code> to just plain <code>value</code>.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/naming-function-args-value-element-atom-series/2387#post_2</link>
        <pubDate>Sat, 12 Jul 2025 03:52:28 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8508</guid>
      </item>
      <item>
        <title>Virtual Binding + Macros =&gt; BREAK, CONTINUE, AGAIN</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2479">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>This might be a good argument for RETURN being a macro that calls THROW-TO-FUNCTION.</strong> That gives you more power to define your own "smart return".</p>
</blockquote>
</aside>
<p>Thinking about this further, it would be a fairly double-edged thing.</p>
<p>Currently you can overwrite RETURN e.g. as:</p>
<pre><code> foo: func [] [
     return: adapt return/ [value: value + 20]
     return 1000  ; acts as if you hadn't adapted, and returned 1020
 ]
</code></pre>
<p>If RETURN were some definition in LIB that hooked up to whatever the local definition of THROW-TO-FUNCTION was, having a long and crappy name would throw this off.  Your local specialization would do "something else" (which wouldn't be to overwrite the LIB RETURN, but likely error by default, though it could create a local definition in the current module).</p>
<p>So at minimum you'd have to say:</p>
<pre><code> foo: func [] [
     let return: adapt return/ [value: value + 20]
     return 1000  ; acts as if you hadn't adapted, and returned 1020
 ]
</code></pre>
<p>Though this costs a LET, and would only affect RETURN that had visibility of the LET.</p>
<p>And... if the global RETURN just forwarded to "whatever you defined return as", there's issues about what its interface would be.  Would it have no parameters, and then if RETURN happened to be defined differently (let's say, returning 3 parameters?) it would forward that normally?  That would prohibit this kind of specialization at all.</p>
<p>So to be able to specialize it, it would have to build a frame and presume the nature of THROW-TO-FUNCTION that it was proxying to.  Or you'd specialize THROW-TO-FUNCTION instead:</p>
<pre><code> foo: func [] [
     throw-to-function: adapt throw-to-function/ [value: value + 20]
     return 1000  ; acts as if you hadn't adapted, and returned 1020
 ]
</code></pre>
<p>A middle ground might be to call the raw-return something nicer, but indicative of its low-levelness, like <strong><code>RETURN*</code></strong></p>
<pre><code> foo: func [] [
     return*: adapt return*/ [value: value + 20]
     return 1000  ; acts as if you hadn't adapted, and returned 1020
 ]
</code></pre>
<h2><a name="p-8507-are-such-contortions-worth-it-1" class="anchor" href="https://rebol.metaeducation.com#p-8507-are-such-contortions-worth-it-1"></a>Are Such Contortions Worth It?</h2>
<p>Kind of feels like... no.  I like the way you can just off the cuff twist the local RETURN, and call it RETURN, and it "just works".</p>
<p>If  "global hooking" of RETURN is truly desirable, maybe that should be done with some more general facility of hooking WORD!s in an environment.  That seems wiser.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479#post_3</link>
        <pubDate>Fri, 11 Jul 2025 19:35:07 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8507</guid>
      </item>
      <item>
        <title>Virtual Binding + Macros =&gt; BREAK, CONTINUE, AGAIN</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="2479">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>Any Submissions For Better Names For THROW-TO-LOOP?</strong></p>
<p>Maybe being bluntly literal is best...</p>
<p><strong>Or... Variadic CONTINUE?</strong></p>
<p>I'll also point out that once-upon-a-time, CONTINUE was variadic... so you could say <strong><code>continue 10</code></strong> and if you left off the parameter it would assume you meant VOID. This was too error prone, due to line continuation bugs:</p>
</blockquote>
</aside>
<p>There's another option...</p>
<h2><a name="p-8506-arity-1-continue-1" class="anchor" href="https://rebol.metaeducation.com#p-8506-arity-1-continue-1"></a>Arity-1 CONTINUE</h2>
<p>This would mean if you wanted the "traditional" continue, you would typically say <strong><code>continue void</code></strong>.</p>
<p>The concept of the parameter to CONTINUE is "act as if the loop body completed and returned this result".</p>
<p>The most obvious place this is useful is in things like MAP-EACH:</p>
<pre><code>&gt;&gt; map-each 'x [1 2 3] [
       if x = 2 [continue spread [pretty cool!]]
       x * 10
   ]
== [10 pretty cool! 30]
</code></pre>
<p>But it can serve a purpose in any loop, by being the value that "drops out" the bottom of the loop if there are no further iterations.</p>
<pre><code>x: 10
until [x = 30] [
   x: x + 10
   if x = 20 [continue &lt;x was 20&gt;]
   x * 100
]
== &lt;x was 20&gt;
</code></pre>
<p><strong>It may make sense to let people know they have this degree of freedom... that if they continue the loop, they're always submitting a value to it...</strong></p>
<p>ARITY-1 continue gives feature exposure, and it also saves us from having to come up with a name for "throw something to the loop".</p>
<p><strong>continue veto</strong> is thus a synonym for BREAK, which as I'm proposing would just be defined as passing VETO to whatever the current concept of CONTINUE is.</p>
<p><strong>continue retry</strong> is a little bit weird, RETRY not being very noun-y.  <strong>continue again</strong> is weird as well, but maybe it makes more sense to help drive home that it's connected to loop constructs.</p>
<p>I'm not sure, but I am feeling kind of open to this idea that CONTINUE has you pass what you want the loop to continue with.</p>
<p>It does suffer slightly from a redefinition problem: while you could redefine other words, you couldn't redefine CONTINUE itself.</p>
<p>Hm.  Maybe that's enough to kill it.  If the loops are using a fixed desirable word like CONTINUE, you couldn't then redefine CONTINUE to be arity-0... whereas if it was called THROW-TO-LOOP you could.</p>
<p><strong>This might be a good argument for RETURN being a macro that calls THROW-TO-FUNCTION.</strong>  That gives you more power to define your own "smart return".  For instance, one that looks to see if the current THROW-TO-FUNCTION return type was specified as <strong><code>[]</code></strong>, and in which case morphs to take no arguments.  I can imagine people having other rules that might be specific to certain contexts.</p>
<p><strong>This makes THROW-TO-LOOP having a crappy name seem like a good thing, not a bad one.</strong></p> ]]></description>
        <link>https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479#post_2</link>
        <pubDate>Fri, 11 Jul 2025 01:43:24 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8506</guid>
      </item>
      <item>
        <title>Why quote/unquote if lift/unlift are a superset?</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="2450">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<aside class="quote no-group quote-modified" data-username="bradrn" data-post="5" data-topic="2088">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/bradrn-brad/2088/5">bradrn (Brad)</a></div>
<blockquote>
<p>why do <strong><code>quote</code></strong> and <strong><code>unquote</code></strong> exist when <strong><code>lift</code></strong> and <strong><code>unlift</code></strong> can do the same thing, while handling more cases?</p>
</blockquote>
</aside>
<p>Sanity check.</p>
</blockquote>
</aside>
<p>In an attempt to further "preserve sanity", I was afraid of LIFT too casually accepting ERROR! antiforms and putting those unstable states into suspended animation... so I created <strong><code>lift*</code></strong> and said you had to use it to lift errors, otherwise the plain LIFT would fail.</p>
<p>That was before metaform behavior shifted to be able to manipulate unstable forms without any lift or unlift calls.  Assigning an ERROR! to a metaform would have the assignment succeed... but the ERROR! would still propagate out.</p>
<pre><code>     ^foo: fail "abcd"
  ; &lt;-- the ERROR! still synthesizes as the result going left
</code></pre>
<p>So ^META assignments aren't as much at risk of accidentally sweeping errors under the rug.  And they're the go-to tool now.  LIFT is more specialized, and actually barely used in usermode (most of the remaining instances just haven't been rethought to not need it).</p>
<h2><a name="p-8505-is-the-paranoia-justified-frowning_face_with_open_mouth-1" class="anchor" href="https://rebol.metaeducation.com#p-8505-is-the-paranoia-justified-frowning_face_with_open_mouth-1"></a>Is The Paranoia Justified?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning_face_with_open_mouth.png?v=14" title=":frowning_face_with_open_mouth:" class="emoji" alt=":frowning_face_with_open_mouth:" loading="lazy" width="20" height="20"></h2>
<p>One of the earliest problems LIFT was designed to address was e.g. writing "FOR-BOTH":</p>
<pre><code>for-both: func [var blk1 blk2 body] [
    return unlift:lite all [
        lift:lite for-each var blk1 body
        lift:lite for-each var blk2 body
    ]
]
</code></pre>
<p>The risk is if you LIFT an ERROR! too casually, cases like this would incorrectly toss out failures.</p>
<p>Though I will say that in my current thinking.... <a href="https://rebol.metaeducation.com/t/when-should-evaluative-constructs-return-error/2506">FOR-EACH won't return ERROR!, because if a body ever returns ERROR! it will panic.</a></p>
<p>One can see why I would have thought LIFT taking ERROR! too casually was unsafe.</p>
<p>BUT... I definitely see a lot of appeal for LIFT and UNLIFT to just agnostically lift and unlift anything.  We might say that they're power-user features and if you're writing power-user code, you have to know to do things like LIFT TRAP (propagate ERROR! to RETURN instead of lifting it) or LIFT REQUIRE (force ERROR! to panic before lifting it).</p>
<p><strong>I think I'm going to say LIFT and UNLIFT are unconstrained, and you add the constraint on if you want it.</strong>  It just feels cleaner and more pleasing... shifting the balance to making them reliable operations that obey the rules of the game, to truly lift and unlift anything they can.  The new workings of ^META operations does take a lot of the pressure off, and I think that makes it reasonable to expect that people using LIFT and UNLIFT do so with precision in terms of subsetting out what they don't want to lift, if it's not everything.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/why-quote-unquote-if-lift-unlift-are-a-superset/2450#post_3</link>
        <pubDate>Thu, 10 Jul 2025 12:49:08 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8505</guid>
      </item>
      <item>
        <title>When Should Evaluative Constructs Return ERROR! ?</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p><strong><a href="https://rebol.metaeducation.com/t/panic-vs-return-fail-the-age-of-definitional-errors/1852">Definitional failures</a></strong> have been critical in moving to a robust model of error handling.</p>
<p>They're an ergonomic concept something like Rust's <strong><code>Result&lt;...&gt;</code></strong>, because they effectively multiplex errors onto a function's return value.  You're expected to triage errors at the moment they happen at a callsite or they promote to divergent panics...which are <a href="https://rebol.metaeducation.com/t/discouraging-the-interception-of-abrupt-failures/1871">not generally intended to be reacted to</a>--your program is conceptually terminated.  To make triage easier there is <a href="https://rebol.metaeducation.com/t/virtual-binding-based-error-propagation-operator/2389">TRAP, the error propagator</a>.</p>
<p><strong>Compared with R3-Alpha and Red's error-handling, this is night and day.</strong>  They are fundamentally broken/useless.  <em>(Curiously: <a href="https://rebol.metaeducation.com/t/rebol2s-hot-errors-abandoned-by-r3-alpha-red/2505">Rebol2 actually had a concept of "hot errors"</a>, that leaned in the direction of definitional errors, but that direction wasn't pushed through.)</em></p>
<hr>
<h2><a name="p-8504-non-terminal-eval-steps-that-dont-triage-will-panic-1" class="anchor" href="https://rebol.metaeducation.com#p-8504-non-terminal-eval-steps-that-dont-triage-will-panic-1"></a>Non-Terminal Eval Steps That Don't Triage Will Panic</h2>
<p>You can triage an ERROR! that's a result of an expression.  But only if it's the final step:</p>
<pre><code>&gt;&gt; error? (print "Error is last" 1 / 0)
Error is last
== \~okay~\  ; antiform

&gt;&gt; error? (1 / 0 print "Error is first")
** PANIC: attempt to divide by zero
</code></pre>
<p>Any evaluation product that comes after an ERROR! will cause a panic.</p>
<p>GHOST! is not exempt:</p>
<pre><code>&gt;&gt; error? (1 / 0 comment "no free pass for ghosts")
** PANIC: attempt to divide by zero
</code></pre>
<p>The reasoning is that just because a function returns a ghost, doesn't mean it doesn't have side effects... or doesn't depend in some way on the previous operation.</p>
<p>Currently, COMMA! isn't exempt, either:</p>
<pre><code>&gt;&gt; error? (1 / 0,)
** PANIC: attempt to divide by zero
</code></pre>
<p>This is something I might be willing to bend on, if we believe that:</p>
<pre><code>(
    some expression,
    another expression,
    yet another expression,
)
</code></pre>
<p>Absolutely has to be equivalent to:</p>
<pre><code>(
    some expression,
    another expression,
    yet another expression
)
</code></pre>
<p>But mechanically you'd have to scan ahead for any number of commas... and make sure you were at the end of the input after consuming all the commas.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/man_shrugging.png?v=14" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8504-plain-eval-would-act-the-same-as-the-group-above-2" class="anchor" href="https://rebol.metaeducation.com#p-8504-plain-eval-would-act-the-same-as-the-group-above-2"></a>Plain EVAL would act the same as the GROUP! above</h2>
<p>Only the last step can give an ERROR!.  Previous steps will panic.</p>
<p>And since branching constructs like an IF or a CASE statement uses EVAL to run their branches, they similarly drop the statement out at the last step. So you can synthesize ERROR! out of branches, without causing the branching construct to panic.</p>
<h2><a name="p-8504-evaltrap-name-pending-gives-error-at-any-step-3" class="anchor" href="https://rebol.metaeducation.com#p-8504-evaltrap-name-pending-gives-error-at-any-step-3"></a>"EVAL:TRAP" (name pending) Gives Error At Any Step</h2>
<p>I've proposed EVAL:TRAP as a variation which can stop the evaluation at any step that produces an ERROR!:</p>
<pre><code>&gt;&gt; error? eval:trap [print "Error is last" 1 / 0]
Error is last
== \~okay~\  ; antiform

&gt;&gt; error? (1 / 0 print "Error is first")
== \~okay~\
</code></pre>
<p>So the second case didn't make it to the PRINT, but it didn't PANIC.</p>
<h1><a name="p-8504-but-how-about-any-and-all-roll_eyes-4" class="anchor" href="https://rebol.metaeducation.com#p-8504-but-how-about-any-and-all-roll_eyes-4"></a>But How About ANY and ALL...?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/roll_eyes.png?v=14" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></h1>
<p>The answer may be different.</p>
<p>You're supposed to reasonably be able to rely on the idea that if ALL gives you a result, it's the result of the final expression.  You thus might be thinking that if you get an error, that error is coming by contract from that last expression.  I'd say it seems reasonably clear that anything but the last expression should panic.</p>
<p>On the other hand...ANY is not expected to necessarily evaluate all of its clauses... it's supposed to return the first thing that passes its constraint (non-null as the default constraint).  So if it hit an ERROR! early, maybe it should return it?</p>
<p>I'm not sure.  I'll have to look at use cases.</p>
<h1><a name="p-8504-and-what-about-loops-5" class="anchor" href="https://rebol.metaeducation.com#p-8504-and-what-about-loops-5"></a>And What About Loops?</h1>
<p>If loops are willing to return definitional errors out of their body, that makes writing loop wrappers a bit trickier.</p>
<p>First let's ask about MAP-EACH, what should it do?</p>
<pre><code>map-each 'x [1 2 3] [either x = 2 [fail "some error"] [x * 10]]
</code></pre>
<p>You're getting behaviors that are somewhat equivalent to APPEND.  So it's like you wrote:</p>
<pre><code>list: []
append list x * 10
append list fail "some error"
</code></pre>
<p>APPEND doesn't propagate a failure like that.  And I don't see any reason why it should.</p>
<p>Next, let's consider wrapping loops... e.g. <a href="https://rebol.metaeducation.com/t/demonstrating-for-both-loop-composability-for-the-win/1833">the current formulation of FOR-BOTH</a>:</p>
<pre><code>for-both: func [var blk1 blk2 body] [
    return unlift:lite all [
        lift:lite for-each var blk1 body
        lift:lite for-each var blk2 body
    ]
]
</code></pre>
<p>At the moment, LIFT does not lift definitional errors by default, but panics on them.</p>
<p>So if FOR-EACH is willing to return definitional errors, then you won't get an equivalence between:</p>
<pre><code>for-each 'x [1] [fail "some error"]  ; definitional error result

for-both 'x [1] [] [fail "some error"]  ; panic

for-both 'x [] [1] [fail "some error"]  ; panic
</code></pre>
<p>It might seem that given what I say about ALL above, if LIFT:LITE were willing to leave ERROR! as ERROR! (as well as NULL as NULL, and GHOST! as GHOST!) then it would correctly panic on errors that weren't the last step... BUT... consider:</p>
<pre><code>all [
    fail "some error"
    comment "hmmm"
]
</code></pre>
<p>This runs afoul of my concept of not allowing a next step to run... producing a loophole in composition that is trying to leverage things like invisibility.</p>
<p><strong>This seems to be the crux of a fairly fundamental problem, regarding the need to be psychic in order to know whether an evaluation is going to be a no-op or not.</strong></p>
<p>If you're not looking at the loop data, but tell from the outside of the FOR-EACH after-the-fact if it had evaluations or not, then there's no way to know if a failure needs to be terminal.</p>
<p><em>This suggests that loops should probably panic if the body fails.</em>  They'd have to do so for any step except the last step anyway, and loops don't have an interface for psychically exposing if they're at the last step or not prior to execution.  It defeats composition to require otherwise, and the whole model would have to be redesigned to add this "psychic" aspect... which seems less easy than just saying "no, loops panic if the body fails".</p>
<h2><a name="p-8504-overall-carry-away-theres-subtleties-6" class="anchor" href="https://rebol.metaeducation.com#p-8504-overall-carry-away-theres-subtleties-6"></a>Overall Carry-away: There's Subtleties</h2>
<p>Decisions about definitional error propagation appear to be non-obvious.</p>
<p>panic-ing is a conservative default, and then you can get people to explicitly CATCH and THROW the errors if they need to work around it.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/when-should-evaluative-constructs-return-error/2506#post_1</link>
        <pubDate>Thu, 10 Jul 2025 11:39:05 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8504</guid>
      </item>
      <item>
        <title>Should RESCUE and CATCH return null if no fails/throws?</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="10" data-topic="940">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>"I'm Returning Nothing (Oh, But Here's What I Return)"</strong>*</p>
<p>Is ENRESCUE The Best We Can Do?</p>
</blockquote>
</aside>
<p><a href="https://rebol.metaeducation.com/t/discouraging-the-interception-of-divergent-panics/1871/4">Thinking about the same problem with SYS.UTIL/RECOVER</a>, I realized it's kind of a matter of phrasing... in that if your construct is phrased in the affirmative (e.g. SANDBOX), you can use EXCEPT.</p>
<p>So if instead of calling it RESCUE it was called something else, like... I dunno, for the sake of argument let's just call it SEQUENTIAL:</p>
<pre><code>value: sequential [
    expr1
    expr2
    expr3
] except e -&gt; [
    ; one of those expressions returned an ERROR!
]
</code></pre>
<p>If you haven't realized it until now--that's what RESCUE is doing that's different from EVAL.  EVAL will give you a definitional error but <em>only from the last operation</em>.</p>
<p>This does imply that maybe RESCUE could be phrased as a refinement to EVAL, to say "return an error early from steps that give ERROR!".</p>
<h2><a name="p-8503-evaltrap-may-actually-kind-of-make-sense-here-1" class="anchor" href="https://rebol.metaeducation.com#p-8503-evaltrap-may-actually-kind-of-make-sense-here-1"></a><strong>EVAL:TRAP</strong> may actually kind of make sense here.</h2>
<p>When you think about what TRAP does, it's a tool for functions when you are in the middle of them in an execution step, and you want that step to bubble the error out.</p>
<p>You don't need to use TRAP on the RETURN of a function, the ERROR! just gets passed to the RETURN.</p>
<p>So if you're asking an EVAL to TRAP, you wouldn't mean "on the last step".  You must mean on its intermediate steps.</p>
<p>There's probably other options like EVAL:INTERCEPT or EVAL:ABRUPT but at the moment I kind of like EVAL:TRAP.</p>
<p>I definitely like the idea of getting rid of ENRESCUE, so this direction is appealing.  More as the situation evolves.</p> ]]></description>
        <link>https://rebol.metaeducation.com/t/should-rescue-and-catch-return-null-if-no-fails-throws/940#post_11</link>
        <pubDate>Thu, 10 Jul 2025 11:06:12 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-8503</guid>
      </item>
  </channel>
</rss>

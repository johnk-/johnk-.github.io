<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>ENVELOP (and COMPOSE!) By Example</title>
    <link>https://rebol.metaeducation.com/t/envelop-and-compose-by-example/2294</link>
    <description>Prior to splices, we were considering rethinking **append/only [a b c] [d e]** as **append [a b c] only [d e]**, where ONLY would just envelop its argument in a block.

@rgchris didn&#39;t care for the name:

[quote=&quot;rgchris, post:1, topic:1873&quot;]
Correct me if I&#39;m wrong, but this proposed ONLY function would simply create a single value cell with the block reference, which would seem pretty efficient.

It&#39;d be very easy to shim:

```
only: func [value][
    reduce [value]
]
```

I&#39;m still fond of ENVELOP over BLOCKIFY as a name. I don&#39;t think ONLY would make the cut. Naming is tricky as it is sort of a hackâ€”it&#39;s purpose is to make a block a singular value but in actuality it is creating a new value of which the old one just happens to be the only content.
[/quote]

As it happens, ONLY defined in this way stuck around for a while.  (I actually thought it had been deleted, but it turns out it was hiding as **`only`**, so just finally deleted it now!)

I agree that ENVELOP is a better and more useful name for the category of operations.  Today we have ENBLOCK and ENGROUP:

    &gt;&gt; enblock [a b c]
    == [[a b c]]

    &gt;&gt; enblock &lt;tag&gt;
    == [&lt;tag&gt;]

    &gt;&gt; engroup [a b c]
    == ([a b c])

    &gt;&gt; engroup &lt;tag&gt;
    == (&lt;tag&gt;)

But there&#39;s no generalized ENVELOP.

## &quot;Envelop by Example&quot; Seems Like an Important Construct

    &gt;&gt; something: 1020

    &gt;&gt; word: &#39;something  ; demo behavior when unbound (binding from context)

    &gt;&gt; envelop &#39;[] word
    == [something]

    &gt;&gt; envelop &#39;() word
    == (something)

    &gt;&gt; envelop &#39;@[] word  ; would work with sigil-decorated types
    == @[something]

    &gt;&gt; envelop &#39;(()) word  ; could work with nested envelopes
    == ((something))

There&#39;s a big advantage in passing in a block or group &quot;by example&quot;.  It means you can implicitly pass along a binding, which can be integrated in the same step...if that&#39;s what you want.  (The modern art of writing Ren-C code requires a lot of consciousness about the decision to use bound or unbound material.)

    &gt;&gt; eval envelop &#39;(()) word  ; quoting means no binding
    ** Error: something not defined

    &gt;&gt; eval envelop @(()) word  ; if @ sigil on example, use example binding
    == 1020

ENVELOP might even support [Synthetic Asymmetric Delimiters](https://rebol.metaeducation.com/t/synthetic-asymmetric-delimiters/1893)

    &gt;&gt; envelop &#39;(| |) word
    == (| something |)

    &gt;&gt; envelop &#39;(|) word  ; shorthand--assume paired?
    == (| something |)

    &gt;&gt; envelop &#39;(&lt;*&gt;) word  ; maybe not assume, for COMPOSE marker compatibility
    == (&lt;*&gt; something)


## ENGROUP and ENBLOCK Still Useful

I do think that ENGROUP and ENBLOCK as specializations of ENVELOP turn out to be what you&#39;ll use at least 90% of the time...so they&#39;re worth having around.

But as arity-1 functions, the returned block or group would be unbound at its tip.  So you&#39;d have to use the ENVELOP-by-example to pass in a binding.

## This Overlaps [the MORPH Proposal](https://rebol.metaeducation.com/t/setify-plainify-getify-symify-or-morph/1334) Somewhat

MORPH has the ability to change the decorations on the value you&#39;re passing in, whereas ENVELOP would assume you wanted the item as-is, just enclosed in some other stuff.

My instinct is to say that this takes the pressure off MORPH to be all things to all people... vs. the idea that we don&#39;t need ENVELOP and it should just become a subfeature of morph.  But I dunno.</description>
    
    <lastBuildDate>Fri, 11 Apr 2025 21:59:51 +0000</lastBuildDate>
    <category>Dialects/DSLs</category>
    <atom:link href="https://rebol.metaeducation.com/t/envelop-and-compose-by-example/2294.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>ENVELOP (and COMPOSE!) By Example</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="5" data-topic="2294">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Looks Good, Just Need INTERPOLATE's Shorthand...</p>
<p>Shorthands for interpolate are hard to think of:</p>
</blockquote>
</aside>
<p>New ideas take time to settle.  But I may be getting over my squeamishness about having the default interpretation of COMPOSE be to use your current context.</p>
<p>So, this would be the meaning in COMPOSE2 when you pass a pattern with no markings.</p>
<pre><code>&gt;&gt; dir: %some-dir/

&gt;&gt; compose2 '(()) %"((dir))/This Filename (Is Dumb).pdf"
== %"some-dir/This Filename (Is Dumb).pdf"
</code></pre>
<p><em>(Note it didn't do two slashes there.  This is because I'm aiming to make COMPOSE treat FILE! composition specially in terms of impementing a kind of "filename calculus".  e.g. it would not allow you to compose a FILE! in that spot unless it's a directory with a slash at the end, given that a slash follows it.)</em></p>
<p><strong>How to get the "use binding of block" behavior simply?</strong></p>
<p>So if no special mark indicates use binding from current environment, and the @ mark means "use the binding on the list I'm giving you", how do you say "use the binding of the template list at the tip"?</p>
<p>It's a little annoying to write manually. <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<pre><code> compose2 (inside template '@()) template
</code></pre>
<p>But how annoying is it really?  And actually, since it doesn't need a binding, we could use another part-of-speech...</p>
<pre><code> compose2 '$() template
</code></pre>
<p>A bit esoteric to say "$  means use binding of template" but you have to quote the binding to get it.  That seems to be begging for mistakes, saying <code>$()</code> instead of <code>'$()</code> and getting the "bind here" behavior.  I wish there were some kind of semiotic thing we could do like:</p>
<pre><code> compose2 [() &lt;-] template
</code></pre>
<p><em>(I say "I wish" as if we couldn't actually do exactly that.  But we can.  I'm just a little squeamish about weird dialects like that in fundamental functions.  Should I be?)</em></p>
<p>ANYWAY... the new idea means you can compose unbound code more easily:</p>
<pre><code> &gt;&gt; x: 1000

 &gt;&gt; compose '[Hello (x + 20) Unbound World]
 == [Hello 1020 Unbound World]  ; unbound
</code></pre>
<p>Anyway, like I say, it has taken a while for me to be comfortable but with interpolate working so darn well I feel that COMPOSE should be its name, and move on...</p>
          <p><a href="https://rebol.metaeducation.com/t/envelop-and-compose-by-example/2294/7">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/envelop-and-compose-by-example/2294/7</link>
        <pubDate>Fri, 11 Apr 2025 15:01:40 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2294-7</guid>
        <source url="https://rebol.metaeducation.com/t/envelop-and-compose-by-example/2294.rss">ENVELOP (and COMPOSE!) By Example</source>
      </item>
      <item>
        <title>ENVELOP (and COMPOSE!) By Example</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2294">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre><code>&gt;&gt; envelop '@[] word  ; would work with sigil-decorated types
== @[something]
</code></pre>
</blockquote>
</aside>
<p>Urgh, it occurs to me that if ENVELOP runs into a problem if it follows the pattern compose uses, because there's a need to distinguish using the binding vs. not.  That kind of restricts it to <code>@...</code> and <code>...</code> with no sigil.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/pouting_cat.png?v=14" title=":pouting_cat:" class="emoji" alt=":pouting_cat:" loading="lazy" width="20" height="20"></p>
<p>You could still use INERT to get the @:</p>
<pre><code>&gt;&gt; envelop '[[]] 'something
== [[something]]  ; unbound

&gt;&gt; envelop @[[]] 'something
== [[something]]  ; bound to same tip as the @[[]] you passed in

&gt;&gt; inert envelop @[[]] 'something
== @[[something]]  ; same binding, now with @ decorator
</code></pre>
<p>Actually, y'know, it would be nicer if JOIN took SIGIL!s</p>
<pre><code>&gt;&gt; join '$ envelop @[[]] 'something
== $[[something]]
</code></pre>
<p>In fact, INERT is a little bit esoteric and not entirely accurate (given that the <code>@FOO</code> evaluates under binding).  That's probably better all the time:</p>
<pre><code>inert
join '@  ; only two more characters but clearer!
</code></pre>
<p>But this would be a strange spin on JOIN's behavior if it didn't reduce the argument if it was a block.  Anyway, something to consider now that the binding behavior of "pattern" arguments are starting to take shape...</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2294">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>"Envelop by Example" Seems Like an Important Construct</p>
</blockquote>
</aside>
<p>It occurs to me that ENVELOP could be polymorphic w.r.t. strings...</p>
<pre><code>&gt;&gt; envelop "&lt;* *&gt;" "Your text here"
== "&lt;*Your text here*&gt;"
</code></pre>
<p>I'm envisioning a "dumb" behavior... just looking for the space, not enforcing any matching:</p>
<pre><code>&gt;&gt; envelop "&lt;* &lt;*" "Your text here"
== "&lt;*Your text here&lt;*"
</code></pre>
<p>It does put the burden on people to join together a string vs. passing the begin and end delimiting as separate items.  But I think using the fact that the pattern is a list to cue that you want a list result seems pretty good.</p>
<p>And then...</p>
<pre><code>&gt;&gt; envelop "&lt;* *&gt;" [What "would" this "do?"]
== ???
</code></pre>
<p>Questions for the future.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/man_astronaut.png?v=14" title=":man_astronaut:" class="emoji" alt=":man_astronaut:" loading="lazy" width="20" height="20"></p>
          <p><a href="https://rebol.metaeducation.com/t/envelop-and-compose-by-example/2294/6">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/envelop-and-compose-by-example/2294/6</link>
        <pubDate>Mon, 24 Mar 2025 01:57:24 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2294-6</guid>
        <source url="https://rebol.metaeducation.com/t/envelop-and-compose-by-example/2294.rss">ENVELOP (and COMPOSE!) By Example</source>
      </item>
      <item>
        <title>ENVELOP (and COMPOSE!) By Example</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>A post was merged into an existing topic: <a href="https://rebol.metaeducation.com/t/could-sigil-carry-a-binding/2376/3">Could SIGIL! Carry A Binding?</a></p>
          <p><a href="https://rebol.metaeducation.com/t/envelop-and-compose-by-example/2294/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/envelop-and-compose-by-example/2294/4</link>
        <pubDate>Sat, 22 Mar 2025 13:56:27 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2294-4</guid>
        <source url="https://rebol.metaeducation.com/t/envelop-and-compose-by-example/2294.rss">ENVELOP (and COMPOSE!) By Example</source>
      </item>
      <item>
        <title>ENVELOP (and COMPOSE!) By Example</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="2294">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Let's bring back an old term...and call it COMPOSE2. And when you pass a list with an @ on it, COMPOSE2 receives that signal and interprets it to mean you want to use the binding of that list for the substitution sites</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; var: 'y
== y

&gt;&gt; code: compose2 @() '[x + (var)]
== [x + y]  ; worked even though we passed in an unbound block!
</code></pre>
</blockquote>
</aside>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2294">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But the strange thing here is that COMPOSE with an non-<code>@</code>-list has to mean use the binding of the template.</p>
<p><code>compose: specialize compose2/ [template: '()]</code></p>
</blockquote>
</aside>
<h2><a name="p-8052-what-about-single-arity-use-current-context-1" class="anchor" href="https://rebol.metaeducation.com#p-8052-what-about-single-arity-use-current-context-1"></a>What About Single-Arity "Use Current Context?"</h2>
<p>It seems like it would be nice if there were a way to say "use the current context" in a single term.</p>
<p>I've wondered what to call that.  It could be something meaningless like <code>COMPOSE*</code>, or something long like <strong><code>COMPOSE-HERE</code></strong></p>
<pre><code>&gt;&gt; var: 'y

&gt;&gt; compose-here '[x + (var)]
== [x + y]  ; worked even though we passed in an unbound block

&gt;&gt; compose* '[x + (var)]
== [x + y]  ; worked even though we passed in an unbound block
</code></pre>
<p>Strings don't have context and require you to use COMPOSE2 with a bound pattern.  But I've considered that INTERPOLATE would be a synonym:</p>
<pre><code>&gt;&gt; compose2 @() "Hello (1000 + 20) World"
== "Hello 1020 World"

&gt;&gt; interpolate "Hello (1000 + 20) World"
== "Hello 1020 World"
</code></pre>
<p><em>(Note the important distinction here: this won't work as a specialization, because the <code>@()</code> has to be positioned at the callsite to capture the binding under evaluation.)</em></p>
<p>In any case, there's no reason INTERPOLATE couldn't be used on blocks.  It's all based on COMPOSE2.</p>
<pre><code>&gt;&gt; interpolate '[x + (var)]
== [x + y]  ; worked even though we passed in an unbound block
</code></pre>
<p>This would mean there's only one "bad boy" operation which is context-dependent minus any parameterization of that dependency.  I like the idea that it's a whole separate word vs. being some dodgy refinement to COMPOSE, so you always know that if you see that word you're getting the callsite-dependent behavior.</p>
<p>However, it's still pretty long.  If you want to PRINT and INTERPOLATE that's pretty hefty, compared to something like PRINT*</p>
<pre><code>&gt;&gt; print interpolate "Hello (1000 + 20) World"
Hello 1020 World

&gt;&gt; print* "Hello (1000 + 20) World"  ; "bad boy", uses callsite context
Hello 1020 World
</code></pre>
<p>But I don't like the idea of every function having to name a variant like that, to get a behavior that should come from a separate call.</p>
<p>In PRINT's specific case, we might say that there's a difference between printing a string passed in a block vs. not in a block:</p>
<pre><code>&gt;&gt; print "Hello (1000 + 20) World"  ; =&gt; print interpolate "..."
Hello 1020 World

&gt;&gt; print ["Hello (1000 + 20) World"]  ; =&gt; print spaced [...]
Hello (1000 + 20) World
</code></pre>
<p>I think this could actually be worth it.  It's learnable, and today's PRINT is designed to restrict the types it accepts to just BLOCK! and TEXT! (and the newline character) based on the notion that <strong><code>print value</code></strong> is a bad pattern for printing arbitrary values, because the day it's a block it will suddenly evaluate.</p>
<p>Or maybe this could be the meaning of printing a TAG! ?</p>
<pre><code>&gt;&gt; print "Hello (1000 + 20) World"  ; =&gt; write-stdout join "..." newline
Hello (1000 + 20) World

&gt;&gt; print &lt;Hello (1000 + 20) World&gt;  ; =&gt; print as text! interpolate &lt;...&gt;
Hello 1020 World
</code></pre>
<p>Hm, maybe that's better...</p>
<h2><a name="p-8052-looks-good-just-need-interpolates-shorthand-2" class="anchor" href="https://rebol.metaeducation.com#p-8052-looks-good-just-need-interpolates-shorthand-2"></a>Looks Good, Just Need INTERPOLATE's Shorthand</h2>
<p>Shorthands for interpolate are hard to think of:</p>
<pre><code>&gt;&gt; interp '[x + (var)]  ; stilted, evokes "interpret" to me
== y

&gt;&gt; inter '[x + (var)]  ; looks better, but "what?"
== y
</code></pre>
<p>I'll keep thinking, but the PRINT behavior variation seems like a winner to me.</p>
          <p><a href="https://rebol.metaeducation.com/t/envelop-and-compose-by-example/2294/5">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/envelop-and-compose-by-example/2294/5</link>
        <pubDate>Sat, 22 Mar 2025 13:51:40 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2294-5</guid>
        <source url="https://rebol.metaeducation.com/t/envelop-and-compose-by-example/2294.rss">ENVELOP (and COMPOSE!) By Example</source>
      </item>
      <item>
        <title>ENVELOP (and COMPOSE!) By Example</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>5 posts were split to a new topic: <a href="https://rebol.metaeducation.com/t/fretting-over-the-arity-of-compose/2376">Fretting Over The Arity Of COMPOSE</a></p>
          <p><a href="https://rebol.metaeducation.com/t/envelop-and-compose-by-example/2294/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/envelop-and-compose-by-example/2294/3</link>
        <pubDate>Thu, 20 Mar 2025 23:22:33 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2294-3</guid>
        <source url="https://rebol.metaeducation.com/t/envelop-and-compose-by-example/2294.rss">ENVELOP (and COMPOSE!) By Example</source>
      </item>
      <item>
        <title>ENVELOP (and COMPOSE!) By Example</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2294">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But as arity-1 functions, the returned block or group would be unbound at its tip. So you'd have to use the ENVELOP-by-example to pass in a binding.</p>
</blockquote>
</aside>
<p>I have realized that this is an incredibly useful ability...</p>
<p>...but even more importantly...</p>
<h2><a name="p-7761-the-binding-aspect-motivates-compose-by-example-1" class="anchor" href="https://rebol.metaeducation.com#p-7761-the-binding-aspect-motivates-compose-by-example-1"></a>The Binding Aspect Motivates <strong>COMPOSE-by-Example</strong></h2>
<p>Since today's COMPOSE is arity-1, to get it to work at all you have to run it on a bound block (assuming the nested groups you're composing aren't somehow already bound).  The tip of the binding of that block is what COMPOSE sloppily borrows to use when evaluating the inner groups.</p>
<pre><code>&gt;&gt; x: 1, y: 2  ; let's say these are incidental definitions

&gt;&gt; var: 'y

&gt;&gt; code: compose '[x + (var)]
** Error: var is not bound

&gt;&gt; code: compose [x + (var)]  ; eval'd BLOCK! binds, compose borrows that binding
== [x + y]  ; but the result tip still has the binding

&gt;&gt; eval compose [let x: 10 let y: 20 (as group! code)]
== 3  ; let's say this is not what I meant
</code></pre>
<p>If you didn't want the final result of a COMPOSE to be unbound, you still have to bind the block long enough for compose to find the bindings...and then unbind it.</p>
<p>Not only is that awkward, what if you had a meaningful binding on the input you wanted to keep.  You'd have to store the binding somehow... bind to the context for your groups long enough for the compose to work, then rebind it to the stored binding...</p>
<h2><a name="p-7761-compose-by-example-can-fix-this-smiley-2" class="anchor" href="https://rebol.metaeducation.com#p-7761-compose-by-example-can-fix-this-smiley-2"></a>Compose-By-Example Can Fix This!  <img src="https://rebol.metaeducation.com/images/emoji/twitter/smiley.png?v=14" title=":smiley:" class="emoji" alt=":smiley:" loading="lazy" width="20" height="20"></h2>
<p>I suggest the arity-2 form be called <strong><code>COMPOSE2</code></strong>.  (It's a good name because it tells you the arity, and also kind of like it's the sequel... COMPOSE 2: The Revenge)</p>
<p>When you pass a list with an @ on it, COMPOSE2 receives that signal and interprets it to mean you want to use the binding of that list for the substitution sites:</p>
<pre><code>&gt;&gt; var: 'y
== y

&gt;&gt; code: compose2 @() '[x + (var)]
== [x + y]  ; worked even though we passed in an unbound block!

&gt;&gt; eval compose [let x: 10 let y: 20 (as group! code)]
== 30
</code></pre>
<p>So not only do you get the freedom to specify what delimiters (or synthetic/nested delimiters) you want to use, you can also supply an arbitrary binding.</p>
<h2><a name="p-7761-old-compose-is-still-useful-day-to-day-3" class="anchor" href="https://rebol.metaeducation.com#p-7761-old-compose-is-still-useful-day-to-day-3"></a>Old COMPOSE Is Still Useful Day-To-Day</h2>
<p>It's useful enough to keep its name, and do what it does.  It works out a lot of the time.</p>
<p>But the strange thing here is that COMPOSE with an non-<code>@</code>-list has to mean use the binding of the template.</p>
<pre><code>compose: specialize compose2/ [template: '()]
</code></pre>
<p>And you can do this off the cuff...</p>
<pre><code> test: func [block] [  ; can't see foo
     compose2 '{{}} block  ; block captured environment
 ]

let foo: 1000

&gt;&gt; test [hello {{foo + 20}} world]
== [hello 1020 world]
</code></pre>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/man_mage.png?v=14" title=":man_mage:" class="emoji only-emoji" alt=":man_mage:" loading="lazy" width="20" height="20"></p>
          <p><a href="https://rebol.metaeducation.com/t/envelop-and-compose-by-example/2294/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/envelop-and-compose-by-example/2294/2</link>
        <pubDate>Mon, 23 Sep 2024 16:23:55 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2294-2</guid>
        <source url="https://rebol.metaeducation.com/t/envelop-and-compose-by-example/2294.rss">ENVELOP (and COMPOSE!) By Example</source>
      </item>
      <item>
        <title>ENVELOP (and COMPOSE!) By Example</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Prior to splices, we were considering rethinking <strong>append/only [a b c] [d e]</strong> as <strong>append [a b c] only [d e]</strong>, where ONLY would just envelop its argument in a block.</p>
<p><a class="mention" href="https://rebol.metaeducation.com/u/rgchris">@rgchris</a> didn't care for the name:</p>
<aside class="quote no-group" data-username="rgchris" data-post="1" data-topic="1873">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/1873/1">On another topic</a></div>
<blockquote>
<p>Correct me if I'm wrong, but this proposed ONLY function would simply create a single value cell with the block reference, which would seem pretty efficient.</p>
<p>It'd be very easy to shim:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">only: func [value][
    reduce [value]
]
</code></pre>
<p>I'm still fond of ENVELOP over BLOCKIFY as a name. I don't think ONLY would make the cut. Naming is tricky as it is sort of a hackâ€”it's purpose is to make a block a singular value but in actuality it is creating a new value of which the old one just happens to be the only content.</p>
</blockquote>
</aside>
<p>As it happens, ONLY defined in this way stuck around for a while.  (I actually thought it had been deleted, but it turns out it was hiding as <strong><code>only</code></strong>, so just finally deleted it now!)</p>
<p>I agree that ENVELOP is a better and more useful name for the category of operations.  Today we have ENBLOCK and ENGROUP:</p>
<pre><code>&gt;&gt; enblock [a b c]
== [[a b c]]

&gt;&gt; enblock &lt;tag&gt;
== [&lt;tag&gt;]

&gt;&gt; engroup [a b c]
== ([a b c])

&gt;&gt; engroup &lt;tag&gt;
== (&lt;tag&gt;)
</code></pre>
<p>But there's no generalized ENVELOP.</p>
<h2><a name="p-7757-envelop-by-example-seems-like-an-important-construct-1" class="anchor" href="https://rebol.metaeducation.com#p-7757-envelop-by-example-seems-like-an-important-construct-1"></a>"Envelop by Example" Seems Like an Important Construct</h2>
<pre><code>&gt;&gt; something: 1020

&gt;&gt; word: 'something  ; demo behavior when unbound (binding from context)

&gt;&gt; envelop '[] word
== [something]

&gt;&gt; envelop '() word
== (something)

&gt;&gt; envelop '@[] word  ; would work with sigil-decorated types
== @[something]

&gt;&gt; envelop '(()) word  ; could work with nested envelopes
== ((something))
</code></pre>
<p>There's a big advantage in passing in a block or group "by example".  It means you can implicitly pass along a binding, which can be integrated in the same step...if that's what you want.  (The modern art of writing Ren-C code requires a lot of consciousness about the decision to use bound or unbound material.)</p>
<pre><code>&gt;&gt; eval envelop '(()) word  ; quoting means no binding
** Error: something not defined

&gt;&gt; eval envelop @(()) word  ; if @ sigil on example, use example binding
== 1020
</code></pre>
<p>ENVELOP might even support <a href="https://rebol.metaeducation.com/t/synthetic-asymmetric-delimiters/1893">Synthetic Asymmetric Delimiters</a></p>
<pre><code>&gt;&gt; envelop '(| |) word
== (| something |)

&gt;&gt; envelop '(|) word  ; shorthand--assume paired?
== (| something |)

&gt;&gt; envelop '(&lt;*&gt;) word  ; maybe not assume, for COMPOSE marker compatibility
== (&lt;*&gt; something)
</code></pre>
<h2><a name="p-7757-engroup-and-enblock-still-useful-2" class="anchor" href="https://rebol.metaeducation.com#p-7757-engroup-and-enblock-still-useful-2"></a>ENGROUP and ENBLOCK Still Useful</h2>
<p>I do think that ENGROUP and ENBLOCK as specializations of ENVELOP turn out to be what you'll use at least 90% of the time...so they're worth having around.</p>
<p>But as arity-1 functions, the returned block or group would be unbound at its tip.  So you'd have to use the ENVELOP-by-example to pass in a binding.</p>
<h2><a name="p-7757-this-overlaps-the-morph-proposalhttpsrebolmetaeducationcomtsetify-plainify-getify-symify-or-morph1334-somewhat-3" class="anchor" href="https://rebol.metaeducation.com#p-7757-this-overlaps-the-morph-proposalhttpsrebolmetaeducationcomtsetify-plainify-getify-symify-or-morph1334-somewhat-3"></a>This Overlaps <a href="https://rebol.metaeducation.com/t/setify-plainify-getify-symify-or-morph/1334">the MORPH Proposal</a> Somewhat</h2>
<p>MORPH has the ability to change the decorations on the value you're passing in, whereas ENVELOP would assume you wanted the item as-is, just enclosed in some other stuff.</p>
<p>My instinct is to say that this takes the pressure off MORPH to be all things to all people... vs. the idea that we don't need ENVELOP and it should just become a subfeature of morph.  But I dunno.</p>
          <p><a href="https://rebol.metaeducation.com/t/envelop-and-compose-by-example/2294/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/envelop-and-compose-by-example/2294/1</link>
        <pubDate>Mon, 23 Sep 2024 12:43:20 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2294-1</guid>
        <source url="https://rebol.metaeducation.com/t/envelop-and-compose-by-example/2294.rss">ENVELOP (and COMPOSE!) By Example</source>
      </item>
  </channel>
</rss>

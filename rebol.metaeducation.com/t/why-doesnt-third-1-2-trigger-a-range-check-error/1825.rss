<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Why Doesn&#39;t `(third [1 2])` Trigger A Range Check Error?</title>
    <link>https://rebol.metaeducation.com/t/why-doesnt-third-1-2-trigger-a-range-check-error/1825</link>
    <description>Quick question for clarity. I assume that

    compose [ 1 (1 / 0) 3 ]
would be a math error. Why is

    compose [ 1 (third [ 1 2 ]) 3 ]
not some kind of a range check error?</description>
    
    <lastBuildDate>Fri, 30 May 2025 14:09:06 +0000</lastBuildDate>
    <category>Semantics</category>
    <atom:link href="https://rebol.metaeducation.com/t/why-doesnt-third-1-2-trigger-a-range-check-error/1825.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Why Doesn&#39;t `(third [1 2])` Trigger A Range Check Error?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="9" data-topic="1825">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>This means that <strong><code>try frame.^field</code></strong> changes the rules here.</p>
<p>I think (?) that <em>has</em> to panic if FIELD is not available, because errors are in-band of what you're asking for.... and EXCEPT won't help you discern them.</p>
</blockquote>
</aside>
<p>A case that is food for thought here is MAP!.</p>
<p>In MAP! right now, you get an ERROR! antiform back when you pick with a key that's not in the MAP!.  You can then TRY that, and it becomes a null.</p>
<p>But if your key is a ^META then you can get back an ERROR! that's meta-represented in the map.</p>
<p>This is something that's a bit more of a big deal, because with MAP! you are pretty much expecting to be asking for things that you don't know if they're in the map or not.  So being able to tell the difference between a meta-represented error that's in the map vs. absence of anything in the map would likely be important.</p>
<p>I'm really only just now getting experience with the troubles of facilitating meta-representation, so I can't tell how bad this is.  Just because you're using meta-representation doesn't mean you're including errors.  I've mentioned that <strong>(obj.^field: some-erroring-thing)</strong> will still evaluate the expression overall to an ERROR!, which means you have to deliberately put a TRY on the outside to get it to not escalate to a panic.  So clients who are meta-representing errors may have to go an extra mile and separate the tests for absence/presence (with something like HAS) than to rely on getting an ERROR! back from a picking operation.</p>
          <p><a href="https://rebol.metaeducation.com/t/why-doesnt-third-1-2-trigger-a-range-check-error/1825/10">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/why-doesnt-third-1-2-trigger-a-range-check-error/1825/10</link>
        <pubDate>Fri, 30 May 2025 14:09:06 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1825-10</guid>
        <source url="https://rebol.metaeducation.com/t/why-doesnt-third-1-2-trigger-a-range-check-error/1825.rss">Why Doesn&#39;t `(third [1 2])` Trigger A Range Check Error?</source>
      </item>
      <item>
        <title>Why Doesn&#39;t `(third [1 2])` Trigger A Range Check Error?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="1825">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; pick obj 'y
** Error: y is not a field of object

&gt;&gt; try pick obj 'y
== ~null~  ; anti
</code></pre>
<p>If we raised a definitional error out of pick in this case, then you could <strong>try pick</strong> and get null. It would conflate with the case where the variable existed and actually held null. (But if that was an issue, you could use EXCEPT or another handler to handle the definitional error specifically.)</p>
</blockquote>
</aside>
<p>So a new angle on this is that meta-<strong>^variables</strong> can give back anything... even unstable antiforms.  ERROR!, PACK!, you name it.</p>
<p>This means that <strong><code>try frame.^field</code></strong> changes the rules here.</p>
<p>I think (?) that <em>has</em> to panic if FIELD is not available, because errors are in-band of what you're asking for.... and EXCEPT won't help you discern them.</p>
<p>Not certain this means anything has to change for non-meta-picking.  You wouldn't meta-pick an environment variable or meta-pick a function out of a DLL, and I think it would be dumb to say that just because meta-picks have ERROR! in band that you lose the easy handling of errors on non-meta-picks.</p>
<p>Just something to be aware of.</p>
          <p><a href="https://rebol.metaeducation.com/t/why-doesnt-third-1-2-trigger-a-range-check-error/1825/9">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/why-doesnt-third-1-2-trigger-a-range-check-error/1825/9</link>
        <pubDate>Wed, 21 May 2025 20:07:12 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1825-9</guid>
        <source url="https://rebol.metaeducation.com/t/why-doesnt-third-1-2-trigger-a-range-check-error/1825.rss">Why Doesn&#39;t `(third [1 2])` Trigger A Range Check Error?</source>
      </item>
      <item>
        <title>Why Doesn&#39;t `(third [1 2])` Trigger A Range Check Error?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="1825">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Nowadays there's an option on the table for raising <a href="https://rebol.metaeducation.com/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852">definitional errors</a>, which could easily be turned into nulls with <strong>try third (...)</strong></p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; third [a b]
** Error: Cannot pick 3 of BLOCK! (or somesuch)

&gt;&gt; try third [a b]
== ~null~  ; anti
</code></pre>
</blockquote>
</aside>
<p>I've been living with this pattern for a year-and-a-half now.</p>
<p>It has the obvious upside of error locality...</p>
<p>...BUT recent changes have made it so that <strong><a href="https://rebol.metaeducation.com/t/should-things-like-text-fail-on-null/2452">NULL is accepted many fewer places</a></strong>.  If a value is null, you can't test if it's a BLOCK? ... for instance... unless you OPT it.</p>
<p>So nulls are accepted almost nowhere, besides conditional places... <em>where they are now the only falsey type</em>.  So if you're passing a NULL to a conditional slot, why should you need to approve it as "possibly null"?  You're testing it!</p>
<p>This means you wind up double-paying for documenting optionality in your source:</p>
<pre><code>append [a b c] opt try pick block 3
</code></pre>
<p>The main benefit you're getting is when you separate the  operations significantly:</p>
<pre><code>var: pick block 3   ; let's say this makes null
...
... ; time passes
...
append [a b c] var  ; !!! error, null
</code></pre>
<p>So in that case, having to put a TRY at the place where you're assigning VAR gets you a bit of locality.</p>
<h2><a name="p-8324-is-the-locality-is-really-worth-it-1" class="anchor" href="https://rebol.metaeducation.com#p-8324-is-the-locality-is-really-worth-it-1"></a>Is The Locality Is Really Worth It?</h2>
<p>As I've asked now-and-again: <em>Are nulls so special?</em>  What if you get an INTEGER! back and you didn't want an integer, but later you see it's an INTEGER!?   That's even worse--because integers have no safeguard of stopping from APPENDing-etc.</p>
<p>We might be able to mitigate the loss of locality by making NULLs carry more information about where they were created, making them even more suitable.</p>
<h2><a name="p-8324-the-missing-object-field-is-a-different-beast-2" class="anchor" href="https://rebol.metaeducation.com#p-8324-the-missing-object-field-is-a-different-beast-2"></a>The Missing Object Field Is A Different Beast</h2>
<aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="1825">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; obj: make object! [x: 10]

&gt;&gt; pick obj 'x
== 10

&gt;&gt; pick obj 'y
** Error: y is not a field of object

&gt;&gt; try pick obj 'y
== ~null~  ; anti
</code></pre>
</blockquote>
</aside>
<p>This is different than picking out of blocks, because blocks can't hold null, so there's no conflation by default.  I think a definitional error you have to react to (e.g. with TRY) here is a nice solution.</p>
<aside class="quote no-group" data-username="johnk" data-post="1" data-topic="1825">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/johnk/48/229_2.png" class="avatar"> johnk:</div>
<blockquote>
<p>Why is</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">compose [ 1 (third [ 1 2 ]) 3 ]
</code></pre>
<p>not some kind of a range check error?</p>
</blockquote>
</aside>
<p>A devil's advocate for not having to say TRY might say:</p>
<ul>
<li>
<p><strong>BLOCK! elements can't be NULL.  So we're able to give a NULL antiform back from out-of-range BLOCK! picks that unambiguously indicates the element wasn't there.</strong></p>
</li>
<li>
<p><strong>Almost all function arguments (that aren't <em>specifically</em> conditional tests for NULL) reject NULL... including even type tests like INTEGER?.</strong></p>
</li>
<li>
<p><strong>Hence the ergonomics of "just returning null" win out as convenient and expedient, vs. forcing callers to "defuse" a range check error.</strong></p>
</li>
<li>
<p><strong>The balance of the decision changes when NULL is in-band for the target type (e.g. picking fields out of objects, which can hold any stable antiform).  At that point, things that are conceptually "absent" or "out-out-range" need to raise an error.</strong></p>
</li>
</ul>
<h2><a name="p-8324-but-i-find-myself-reluctant-to-go-back-to-that-3" class="anchor" href="https://rebol.metaeducation.com#p-8324-but-i-find-myself-reluctant-to-go-back-to-that-3"></a>But I Find Myself Reluctant To Go Back To That</h2>
<p>Searching for TRY PICK in the codebase to consider removing it, one of the first examples I found was:</p>
<pre><code>&gt;&gt; winsock: make library! %/C/Windows/System32/wsock32.dll
== &amp;[library! %/C/Windows/System32/wsock32.dll]

&gt;&gt; pick winsock "gethostbyname"
== &amp;[handle!]

&gt;&gt; pick winsock "gethostbynickname"
** Error: Couldn't find "gethostbynickname"
      in &amp;[library! %/C/Windows/System32/wsock32.dll]

&gt;&gt; try pick winsock "gethostbynickname"
== ~null~  ; anti
</code></pre>
<p>You see that the ERROR! can be much more informative than NULL.</p>
<p><strong>And it occurs to me that a NULL produced from a TRY could <em>remember</em> the error it defused, in case you wanted to know what it was... this could be offered in some debug modes.</strong></p>
<p>In trying to explain why an out-of-range block pick should succeed while picking a symbol name out of a library should raise an error, I'm drawing a bit of a blank.</p>
<h2><a name="p-8324-i-think-try-pick-stays-4" class="anchor" href="https://rebol.metaeducation.com#p-8324-i-think-try-pick-stays-4"></a>I Think TRY PICK Stays...</h2>
<p>Like many things, it doesn't really come up as much as you would think.  Working code rarely picks out of range things.  (Perhaps that was your initial point?)</p>
          <p><a href="https://rebol.metaeducation.com/t/why-doesnt-third-1-2-trigger-a-range-check-error/1825/8">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/why-doesnt-third-1-2-trigger-a-range-check-error/1825/8</link>
        <pubDate>Tue, 20 May 2025 09:06:45 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1825-8</guid>
        <source url="https://rebol.metaeducation.com/t/why-doesnt-third-1-2-trigger-a-range-check-error/1825.rss">Why Doesn&#39;t `(third [1 2])` Trigger A Range Check Error?</source>
      </item>
      <item>
        <title>Why Doesn&#39;t `(third [1 2])` Trigger A Range Check Error?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1825">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So I guess I'll just say that experience has borne out that soft failure is a more convenient for functions like THIRD than PANIC'ing. If anyone finds a case where they don't think so, I'd be interested to see it.</p>
</blockquote>
</aside>
<p>Nowadays there's an option on the table for raising <a href="https://rebol.metaeducation.com/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852">definitional errors</a>, which could easily be turned into nulls with <strong>try third (...)</strong></p>
<pre><code>&gt;&gt; third [a b]
** Error: Cannot pick 3 of BLOCK! (or somesuch)

&gt;&gt; try third [a b]
== ~null~  ; anti
</code></pre>
<p><sub><em>(I've mentioned that this is different from the limited design of Rebol's historical errors, e.g. if you said <strong>attempt [third [a b]]</strong> in an R3-Alpha or Red that errored, it would give null back...but so would <strong>attempt [thirrd [a b]]</strong> because the lack of definitional-ism means it couldn't discern errors arising from a direct call from typos or other downstream errors.)</em></sub></p>
<p>For cases where you would have been trusting a THIRD that returns NULL to trigger downstream errors, this gives better error locality.  e.g. <strong>append [a b c] third [d e]</strong> would blame the THIRD, not the append.</p>
<p>And for cases where you might not be able to trust that NULL wouldn't be interpreted as an error downstream, it would be more robust.  Also you'd give readers a clue at the callsite when you actually were intending that the operation might fail by the presence of the TRY.</p>
<p>This comes down down to the behavior of PICK (since FIRST is a specialization of PICK).  I was just thinking about that with respect to objects:</p>
<pre><code>&gt;&gt; obj: make object! [x: 10]

&gt;&gt; pick obj 'x
== 10

&gt;&gt; pick obj 'y
** Error: y is not a field of object

&gt;&gt; try pick obj 'y
== ~null~  ; anti
</code></pre>
<p>If we raised a definitional error out of pick in this case, then you could <strong>try pick</strong> and get null.  It would conflate with the case where the variable existed and actually held null.  (But if that was an issue, you could use EXCEPT or another handler to handle the definitional error specifically.)</p>
<p>When you think about PICK in general beyond just the block case, it does seem like more uniformly giving an error which can be "softened" via TRY would be a good idea.</p>
<h2><a name="p-6711-ill-give-it-a-shot-and-see-what-the-effects-are-1" class="anchor" href="https://rebol.metaeducation.com#p-6711-ill-give-it-a-shot-and-see-what-the-effects-are-1"></a>I'll give it a shot and see what the effects are.</h2>
          <p><a href="https://rebol.metaeducation.com/t/why-doesnt-third-1-2-trigger-a-range-check-error/1825/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/why-doesnt-third-1-2-trigger-a-range-check-error/1825/3</link>
        <pubDate>Sat, 21 Oct 2023 14:58:45 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1825-3</guid>
        <source url="https://rebol.metaeducation.com/t/why-doesnt-third-1-2-trigger-a-range-check-error/1825.rss">Why Doesn&#39;t `(third [1 2])` Trigger A Range Check Error?</source>
      </item>
      <item>
        <title>Why Doesn&#39;t `(third [1 2])` Trigger A Range Check Error?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="johnk" data-post="1" data-topic="1825">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/johnk/48/229_2.png" class="avatar"> johnk:</div>
<blockquote>
<p>compose [1 (third [1 2]) 3]</p>
</blockquote>
</aside>
<p>Systemically, we consider NULL to be a "soft" form of failure.  It serves a signaling role that's a little like what NONE! tried to do in historical Rebol, but since it's not an ANY-VALUE! more functions treat it as an error:</p>
<pre><code>&gt;&gt; third [1 2]
== ~null~  ; anti

&gt;&gt; append [a b c] third [1 2]
** PANIC: append requires value argument to not be null

&gt;&gt; compose [1 (third [1 2]) 3]
** PANIC: Cannot use NULL in COMPOSE slots
</code></pre>
<p>The theory is that places which require an ANY-VALUE! will error down the line, and that having a lot of constructs that make it easier to react to the "soft failure" is a better tradeoff.</p>
<p>One of those constructs is OPT, which converts NULL to VOID, allowing a seamless opt-out of things like APPEND or COMPOSE:</p>
<pre><code>&gt;&gt; append [a b c] opt third [1 2]
== [a b c]

&gt;&gt; compose [1 (opt third [1 2]) 3]
== [1 3]
</code></pre>
<p>So I guess I'll just say that experience has borne out that soft failure is a more convenient for functions like THIRD than PANIC'ing.  If anyone finds a case where they don't think so, I'd be interested to see it.</p>
          <p><a href="https://rebol.metaeducation.com/t/why-doesnt-third-1-2-trigger-a-range-check-error/1825/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/why-doesnt-third-1-2-trigger-a-range-check-error/1825/2</link>
        <pubDate>Mon, 04 Jun 2018 12:01:39 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1825-2</guid>
        <source url="https://rebol.metaeducation.com/t/why-doesnt-third-1-2-trigger-a-range-check-error/1825.rss">Why Doesn&#39;t `(third [1 2])` Trigger A Range Check Error?</source>
      </item>
      <item>
        <title>Why Doesn&#39;t `(third [1 2])` Trigger A Range Check Error?</title>
        <dc:creator><![CDATA[johnk]]></dc:creator>
        <description><![CDATA[
            <p>Quick question for clarity. I assume that</p>
<pre><code>compose [ 1 (1 / 0) 3 ]
</code></pre>
<p>would be a math error. Why is</p>
<pre><code>compose [ 1 (third [ 1 2 ]) 3 ]
</code></pre>
<p>not some kind of a range check error?</p>
          <p><a href="https://rebol.metaeducation.com/t/why-doesnt-third-1-2-trigger-a-range-check-error/1825/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/why-doesnt-third-1-2-trigger-a-range-check-error/1825/1</link>
        <pubDate>Mon, 04 Jun 2018 04:00:07 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1825-1</guid>
        <source url="https://rebol.metaeducation.com/t/why-doesnt-third-1-2-trigger-a-range-check-error/1825.rss">Why Doesn&#39;t `(third [1 2])` Trigger A Range Check Error?</source>
      </item>
  </channel>
</rss>

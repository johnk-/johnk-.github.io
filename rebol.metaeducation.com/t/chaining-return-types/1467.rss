<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Chaining Return Types</title>
    <link>https://rebol.metaeducation.com/t/chaining-return-types/1467</link>
    <description>Something that bothers me about C is that it doesn&#39;t let you write chaining void returns:

    void my_function() {
        return some_void_function(...);  /* this is not legal! */
    }

That annoys me, because it makes it hard to write generic code that doesn&#39;t want the bad properties of a macro (repeating evaluation of arguments if used multiple times, etc.)...but throws a wrench in being able to abstract across return values.

**But Ren-C has this covered!**  All states can be chained.

But what if you are writing a wrapped function, and want a type signature on the wrapper that matches what you are wrapping?  I guess we could do this via COMPOSE on the spec of some kind:

    my-function: func compose [
        return: (return-type-block-of :some-other-function)
        ...
    ][
        ...
        return some-other-function ...
    ]

Something along these lines, where you could add or remove elements of the type signature.  :-/Anyway, I just wanted to mention that we&#39;re not yet at utopia in this medium, even if we&#39;re pretty much nailing the chaining part itself!</description>
    
    <lastBuildDate>Mon, 31 Mar 2025 03:12:58 +0000</lastBuildDate>
    <category>Functions</category>
    <atom:link href="https://rebol.metaeducation.com/t/chaining-return-types/1467.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Chaining Return Types</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1467">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But what if you are writing a wrapped function, and want a type signature on the wrapper that matches what you are wrapping? I guess we could do this via COMPOSE on the spec of some kind:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">my-function: func compose [
    return: (return-type-block-of :some-other-function)
    ...
][
    ...
    return some-other-function ...
]
</code></pre>
</blockquote>
</aside>
<p>This is now possible, via RETURN OF!</p>
<pre><code>my-function: func compose [
    return: (return of some-other-function/)
...
][
    ...
    return some-other-function ...
]
</code></pre>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1467">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Anyway, I just wanted to mention that we're not yet at utopia in this medium, even if we're pretty much nailing the chaining part itself!</p>
</blockquote>
</aside>
<p>It's pretty darn good.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/slight_smile.png?v=14" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20">  But it does need some work on letting you do composition or surgery.</p>
<p>RETURN OF gives you a PARAMETER!, which encodes a string description, a spec block, what meta-convention or optionality via refinement it has, etc...</p>
<p>So you could say <strong><code>(return of some-other-function/).spec</code></strong> to get the spec block and manipulate that.</p>
<p>We could add <strong>RETURN:SPEC OF</strong> or some other way of just getting the block.  Then you could JOIN in another type you wanted to add more easily.  But you'd lose the description.</p>
<p>Anyway, it's coming along!</p>
          <p><a href="https://rebol.metaeducation.com/t/chaining-return-types/1467/7">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/chaining-return-types/1467/7</link>
        <pubDate>Mon, 31 Mar 2025 03:12:58 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1467-7</guid>
        <source url="https://rebol.metaeducation.com/t/chaining-return-types/1467.rss">Chaining Return Types</source>
      </item>
      <item>
        <title>Chaining Return Types</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Something that bothers me about C is that it doesn't let you write chaining void returns:</p>
<pre><code>void my_function() {
    return some_void_function(...);  /* this is not legal! */
}
</code></pre>
<p>That annoys me, because it makes it hard to write generic code that doesn't want the bad properties of a macro (repeating evaluation of arguments if used multiple times, etc.)...but throws a wrench in being able to abstract across return values.</p>
<p><strong>But Ren-C has this covered!</strong>  All states can be chained.</p>
<p>But what if you are writing a wrapped function, and want a type signature on the wrapper that matches what you are wrapping?  I guess we could do this via COMPOSE on the spec of some kind:</p>
<pre><code>my-function: func compose [
    return: (return-type-block-of :some-other-function)
    ...
][
    ...
    return some-other-function ...
]
</code></pre>
<p>Something along these lines, where you could add or remove elements of the type signature.  :-/Anyway, I just wanted to mention that we're not yet at utopia in this medium, even if we're pretty much nailing the chaining part itself!</p>
          <p><a href="https://rebol.metaeducation.com/t/chaining-return-types/1467/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/chaining-return-types/1467/1</link>
        <pubDate>Mon, 18 Jan 2021 02:04:57 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1467-1</guid>
        <source url="https://rebol.metaeducation.com/t/chaining-return-types/1467.rss">Chaining Return Types</source>
      </item>
  </channel>
</rss>

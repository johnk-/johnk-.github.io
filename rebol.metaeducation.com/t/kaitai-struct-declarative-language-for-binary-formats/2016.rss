<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Kaitai Struct Declarative Language for Binary Formats</title>
    <link>https://rebol.metaeducation.com/t/kaitai-struct-declarative-language-for-binary-formats/2016</link>
    <description>This is an interesting declarative language in YAML designed to generate classes for binary formats.  There are many formats defined:

  https://formats.kaitai.io/

That&#39;s a lot of cases...but as one instructive example, you can look at how it describes a ZIP file--with little snippets of code in it for extracting the values:

  https://formats.kaitai.io/zip/

The C++ code generated is like this:

  https://formats.kaitai.io/zip/cpp_stl_11.html

But it also can also be used to make code for C#, JavaScript, Python, Ruby, Nim, PHP, Lua, Perl... *(though we&#39;d assume that if you escape code in, that part will only work be available for that language)*

The regimentation of YAML provides the typical repetition in the &quot;dialect&quot;.  This is the same as the Rebol complaint about JSON--not really leveraging &quot;parts of speech&quot;, but repeating tags over and over like `id:` and `type:`

      - id: version
        type: u2
      - id: flags
        type: gp_flags
        size: 2
      - id: compression_method
        type: u2
        enum: compression

But it&#39;s still pretty hard to compete with, especially when you consider this is giving a compilable specification...so the performance is going to be much better.

I always thought BINARY! parse was something that Rebol would have a unique story for, and Ren-C&#39;s UPARSE makes that a stronger story (by allowing rules to synthesize arbitrary results via extraction)... but seeing this kind of stuff reminds me that there are diminishing returns.</description>
    
    <lastBuildDate>Tue, 18 Feb 2025 09:01:59 +0000</lastBuildDate>
    <category>Foreign Inspiration</category>
    <atom:link href="https://rebol.metaeducation.com/t/kaitai-struct-declarative-language-for-binary-formats/2016.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Kaitai Struct Declarative Language for Binary Formats</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2016">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><a class="mention" href="https://rebol.metaeducation.com/u/bradrn">@bradrn</a> would know more than me about the specifics if you want to draw inspiration from Haskell. But if you're looking for the "right" answer here you need something "combinator-like". Maybe <a href="https://hackage.haskell.org/package/cereal">cereal</a> or <a href="https://hackage.haskell.org/package/binary-parsers-0.2.4.0/docs/Data-Binary-Parser.html">Data.Binary.Parser</a></p>
</blockquote>
</aside>
<p>Only just saw this, sorry…</p>
<p>I agree that combinators are the best approach here. Unfortunately, the AI code isn’t the way to do it: I’m almost certain that that <code>BinaryFormat</code> type is not a monad. It’s still possible to make a bidirectional parser/serialiser, but you have to be a bit clever to get it working. It looks like the key is to go through profunctors: see e.g. <a href="https://kowainik.github.io/posts/2019-01-14-tomland">Kowainik’s article on <code>tomland</code></a> for details.</p>
<p>A simpler approach is to just get the user to write the parser and serialiser separately. This is slightly more error-prone, but not by much, especially since both of them can be given their own easy-to-use combinators. This is what <a href="https://hackage.haskell.org/package/cereal"><code>cereal</code></a> does, as well as the other popular packages <a href="https://hackage.haskell.org/package/binary"><code>binary</code></a> and <a href="https://hackage.haskell.org/package/serialise"><code>serialise</code></a>.</p>
          <p><a href="https://rebol.metaeducation.com/t/kaitai-struct-declarative-language-for-binary-formats/2016/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/kaitai-struct-declarative-language-for-binary-formats/2016/4</link>
        <pubDate>Tue, 18 Feb 2025 09:01:59 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2016-4</guid>
        <source url="https://rebol.metaeducation.com/t/kaitai-struct-declarative-language-for-binary-formats/2016.rss">Kaitai Struct Declarative Language for Binary Formats</source>
      </item>
      <item>
        <title>Kaitai Struct Declarative Language for Binary Formats</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="jhgorse" data-post="2" data-topic="2016">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/jhgorse/48/245_2.png" class="avatar"> jhgorse:</div>
<blockquote>
<p>Further Dennis Ritchie and Ken Thompson wrote C to interface with digital systems. C is one of the more complete approaches to data. Hence its widespread continued 53 years after its initial release in 1972.</p>
</blockquote>
</aside>
<p>Some might consider this more a proof of failure of the educational system vs. a proof of the primacy of C...  <img src="https://rebol.metaeducation.com/images/emoji/twitter/slight_smile.png?v=14" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<aside class="quote no-group" data-username="jhgorse" data-post="2" data-topic="2016">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/jhgorse/48/245_2.png" class="avatar"> jhgorse:</div>
<blockquote>
<p>Still looking for a way to describe a binary format once and not write the serializer/deserializer in each language that touches the data.</p>
</blockquote>
</aside>
<p>...and so you've got some competing demands here, if you are talking about "each language"...</p>
<p>It's a super-common pattern in classical imperative programming, where humans are bad at writing forward and reverse transformations and maintaining that code.</p>
<p>I'm not sure you'll get "reversibility" from a specification if the language that interprets it isn't expressive enough in its type system to properly box and unbox everything under the right conditions relative to the spec.  We've spoken about this before--about why FP manages to let you express things that <em>aren't</em> intrinsically reversible, yet you can write your program in a way that sort of <em>pretends</em> they are...as if the reverse transformation exists, even though it doesn't.  It just sifts the order out so that it never has to actually reverse anything, but figures the meaningful ordering out (in terms of things like <code>bind</code> and <code>return</code>, if monads, but not everything is a monad).</p>
<p><em>(Take the above imprecise language with a grain of salt.)</em></p>
<p>What you need are combinators, and to get those combinators you need to lean on a type system.   Or failing that, something like <strike>Rebol</strike> Ren-C that is so paradigm neutral that you wind up having to tailor it ad-hoc to where someone might ask you why you are reinventing the wheel.  I'm just trying to make it unusually easy for laypeople who want to play with a Minecraft-like-programming model to do these things.</p>
<p>(<em>"We must not forget that the wheel is reinvented so often because it is a very good idea; I've learned to worry more about the soundness of ideas that were invented only once."</em> --David Parnas)</p>
<p><a class="mention" href="https://rebol.metaeducation.com/u/bradrn">@bradrn</a> would know more than me about the specifics if you want to draw inspiration from Haskell.  But if you're looking for the "right" answer here you need something "combinator-like".  Maybe <a href="https://hackage.haskell.org/package/cereal">cereal</a> or <a href="https://hackage.haskell.org/package/binary-parsers-0.2.4.0/docs/Data-Binary-Parser.html">Data.Binary.Parser</a></p>
<p>Since my Haskell is weak I asked an AI to give an example, e.g. for ZIP, here's a bit of a suggestion:</p>
<pre><code>data ZipEntry = ZipEntry {
    signature    :: Word32,
    compression :: Word16,
    filename    :: String,
    data        :: ByteString
} deriving (Show, Eq)

zipEntryFormat :: BinaryFormat ZipEntry
zipEntryFormat = do
    sig &lt;- field "signature" (constant 0x04034b50)
    comp &lt;- field "compression" word16LE
    fname &lt;- field "filename" (lengthPrefixed word16LE utf8String)
    dat &lt;- field "data" (remainingBytes)
    pure $ ZipEntry sig comp fname dat
</code></pre>
<p>Core mechanism something like this:</p>
<pre><code>data BinaryFormat a = BinaryFormat {
    parseFrom :: ByteString -&gt; Either Error (a, ByteString),
    serialize :: a -&gt; ByteString
}
</code></pre>
<p>You can ask your nearest AI to explain how it works.  But here's some fake C++:</p>
<pre><code>// This is NOT real C++, but illustrates the concept
template&lt;typename T&gt;
class BinaryFormat {
public:
    virtual T parse(const std::vector&lt;uint8_t&gt;&amp; bytes) = 0;
    virtual std::vector&lt;uint8_t&gt; serialize(const T&amp; value) = 0;
};

// Each primitive must implement both directions
class Word16Format : public BinaryFormat&lt;uint16_t&gt; {
public:
    uint16_t parse(const std::vector&lt;uint8_t&gt;&amp; bytes) override {
        return bytes[0] | (bytes[1] &lt;&lt; 8);
    }
    std::vector&lt;uint8_t&gt; serialize(const uint16_t&amp; value) override {
        return {uint8_t(value), uint8_t(value &gt;&gt; 8)};
    }
};

// Composing formats preserves bidirectionality
template&lt;typename T1, typename T2&gt;
class PairFormat : public BinaryFormat&lt;std::pair&lt;T1, T2&gt;&gt; {
    BinaryFormat&lt;T1&gt;* first;
    BinaryFormat&lt;T2&gt;* second;
    // ... implementation that uses both parse and serialize from sub-formats
};
</code></pre>
<p>So far, what we've done is more like Kaitai than it is like combinators:</p>
<ul>
<li><a class="mention" href="https://rebol.metaeducation.com/u/rgchris">@rgchris</a>'s <a href="https://rebol.metaeducation.com/t/bincode/1863">Bincode</a></li>
<li>My <a href="https://rebol.metaeducation.com/t/dissecting-the-tls-emit-dialect/1498">TLS Emit</a></li>
<li>Oldes's <a href="https://rebol.metaeducation.com/t/dissecting-the-tls-emit-dialect/1498/2">Binary</a></li>
</ul>
<p>But, <a href="https://rebol.metaeducation.com/t/introducing-the-hackable-usermode-parse-uparse/1529">as UPARSE has shown</a>, Ren-C can tackle higher-order, combinator-like problems.</p>
<p>If you want an introduction to combinator-based thinking, this article is pretty good.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/slight_smile.png?v=14" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<p><a href="https://ae1020.github.io/incremental-streaming-haskell-parse/" class="inline-onebox">Parsing Huge Simulated Streams In Attoparsec | AE1020: Lazy Notebook</a></p>
          <p><a href="https://rebol.metaeducation.com/t/kaitai-struct-declarative-language-for-binary-formats/2016/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/kaitai-struct-declarative-language-for-binary-formats/2016/3</link>
        <pubDate>Thu, 30 Jan 2025 06:35:58 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2016-3</guid>
        <source url="https://rebol.metaeducation.com/t/kaitai-struct-declarative-language-for-binary-formats/2016.rss">Kaitai Struct Declarative Language for Binary Formats</source>
      </item>
      <item>
        <title>Kaitai Struct Declarative Language for Binary Formats</title>
        <dc:creator><![CDATA[jhgorse]]></dc:creator>
        <description><![CDATA[
            <p><a class="mention" href="https://rebol.metaeducation.com/u/hostilefork">@hostilefork</a>,</p>
<p>This is an open unsolved problem in computer science and engineering. Broadly speaking, the tools that we have to speak abstractly about the binary that our Turing Machines actually use is incredibly limited. From source code to compiler to linker to loader to execution to debugger/disassembler/perf tools, we lose a lot of visibility into behavior of the software, particularly with regard to data. Data today is treated as static or executable. A simple proof that it is both. A variable sized packet with a length field ahead of the payload. Another is the first bit of a signed integer. And finally <code>E3A0 0010</code><br>
will write 0x100 to the ARM Program Counter (PC). The data has meaning about what is to come. Without it, this schema, the data is meaningless noise. With it, it might become Information to either the machine or the end user.</p>
<p>Google Protobuf famously does not support specifying the binary format. I do not know why. Though I do know that no one has added the functionality which means that people who do hardware-level protocols for a living, like IEEE for Ethernet, don't care about the abstract benefits provided by Protobuf. Fair enough. Google tools are not for everyone.</p>
<p>Kaitai Struct is a Java-first approach to the binary decoding problem. The initial design was decode-only. Serialization was added later for Java and Python due to "overwhelming" demand, though it continues to be secondary in the design and not merged into mainline:</p><aside class="onebox githubpullrequest" data-onebox-src="https://github.com/kaitai-io/kaitai_struct_compiler/pull/255">
  <header class="source">

      <a href="https://github.com/kaitai-io/kaitai_struct_compiler/pull/255" target="_blank" rel="noopener nofollow ugc">github.com/kaitai-io/kaitai_struct_compiler</a>
  </header>

  <article class="onebox-body">
    <div class="github-row" data-github-private-repo="false">



    <div class="github-icon-container" title="Pull Request">
      <svg width="60" height="60" class="github-icon" viewBox="0 0 12 16" aria-hidden="true"><path fill-rule="evenodd" d="M11 11.28V5c-.03-.78-.34-1.47-.94-2.06C9.46 2.35 8.78 2.03 8 2H7V0L4 3l3 3V4h1c.27.02.48.11.69.31.21.2.3.42.31.69v6.28A1.993 1.993 0 0 0 10 15a1.993 1.993 0 0 0 1-3.72zm-1 2.92c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2zM4 3c0-1.11-.89-2-2-2a1.993 1.993 0 0 0-1 3.72v6.56A1.993 1.993 0 0 0 2 15a1.993 1.993 0 0 0 1-3.72V4.72c.59-.34 1-.98 1-1.72zm-.8 10c0 .66-.55 1.2-1.2 1.2-.65 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2zM2 4.2C1.34 4.2.8 3.65.8 3c0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2z"></path></svg>
    </div>

  <div class="github-info-container">



      <h4>
        <a href="https://github.com/kaitai-io/kaitai_struct_compiler/pull/255" target="_blank" rel="noopener nofollow ugc">Serialization</a>
      </h4>

    <div class="branches">
      <code>master</code> ← <code>serialization</code>
    </div>

      <div class="github-info">
        <div class="date">
          opened <span class="discourse-local-date" data-format="ll" data-date="2023-08-01" data-time="20:19:28" data-timezone="UTC">08:19PM - 01 Aug 23 UTC</span>
        </div>

        <div class="user">
          <a href="https://github.com/GreyCat" target="_blank" rel="noopener nofollow ugc">
            <img alt="" src="https://avatars.githubusercontent.com/u/157154?v=4" class="onebox-avatar-inline" width="20" height="20">
            GreyCat
          </a>
        </div>

        <div class="lines" title="105 commits changed 37 files with 2378 additions and 288 deletions">
          <a href="https://github.com/kaitai-io/kaitai_struct_compiler/pull/255/files" target="_blank" rel="noopener nofollow ugc">
            <span class="added">+2378</span>
            <span class="removed">-288</span>
          </a>
        </div>
      </div>
  </div>
</div>


  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>Further, C support for decoding is not supported.</p><aside class="onebox githubissue" data-onebox-src="https://github.com/kaitai-io/kaitai_struct/issues/263">
  <header class="source">

      <a href="https://github.com/kaitai-io/kaitai_struct/issues/263" target="_blank" rel="noopener nofollow ugc">github.com/kaitai-io/kaitai_struct</a>
  </header>

  <article class="onebox-body">
    <div class="github-row">
  <div class="github-icon-container" title="Issue" data-github-private-repo="false">
	  <svg width="60" height="60" class="github-icon" viewBox="0 0 14 16" aria-hidden="true"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg>
  </div>

  <div class="github-info-container">
    <h4>
      <a href="https://github.com/kaitai-io/kaitai_struct/issues/263" target="_blank" rel="noopener nofollow ugc">Any port for plain C?</a>
    </h4>

    <div class="github-info">
      <div class="date">
        opened <span class="discourse-local-date" data-format="ll" data-date="2017-09-25" data-time="09:46:42" data-timezone="UTC">09:46AM - 25 Sep 17 UTC</span>
      </div>


      <div class="user">
        <a href="https://github.com/Zorgatone" target="_blank" rel="noopener nofollow ugc">
          <img alt="" src="https://avatars.githubusercontent.com/u/2664036?v=4" class="onebox-avatar-inline" width="20" height="20">
          Zorgatone
        </a>
      </div>
    </div>

    <div class="labels">
        <span style="display:inline-block;margin-top:2px;background-color: #B8B8B8;padding: 2px;border-radius: 4px;color: #fff;margin-left: 3px;">
          new language support
        </span>
    </div>
  </div>
</div>

  <div class="github-row">
    <p class="github-body-container">Hi,
I would like to know if you would consider (or have any plans already) to p<span class="show-more-container"><a href="" rel="noopener" class="show-more">…</a></span><span class="excerpt hidden">ort the project for use with "plain" C (other than C++ and C#). I would use it, and not all the systems (even embedded maybe?) support C++ and/or C#. Having a C version would enable portability on any system and even more languages with C bindings</span></p>
  </div>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>The C ABI is lingua franca. Strategically significant for interop. Further Dennis Ritchie and Ken Thompson wrote C to interface with digital systems. C is one of the more complete approaches to data. Hence its widespread continued 53 years after its initial release in 1972.</p>
<p>Taking a strategic step back, what is the value of writing a dynamic YAML representation of binary protocols if it cannot write? Everything that is necessary to pack the structure is described. All you need are the necessary data elements populated and to execute the logical assembly. Further, the benefit of proving that the transform is not lossy when inverted to the original structures seems too good to pass up. To be fair, there are implementation simplifications that can occur being read-only, but not enough to outweigh the benefit of serialization.</p>
<p>Wrapping up, I want to encourage thinking and solutions for bridging the hardware-software divide, of magical registers whose bits change the world to the software performs the reads and writes in a human comprehensible fashion.</p>
<p>When I work in this space, I see the need to describe the metadata of the binary representation. For each field, the bit length, format (signed, unsigned, floating point, fixed point, and so on), name/description, and causal effect expressed or human readable description (e.g. a callback function).</p>
<p>I've written an Extended Struct for Python which extends their struct.pack/unpack() to handle arbitrary bit length fields with the 'v' format character. '4v' is 4 bits. Assumes Big Endian. Works well enough for the little hacking I need to do for now. Still looking for a way to describe a binary format once and not write the serializer/deserializer in each language that touches the data.</p>
<p>Cheers,<br>
Joe</p>
          <p><a href="https://rebol.metaeducation.com/t/kaitai-struct-declarative-language-for-binary-formats/2016/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/kaitai-struct-declarative-language-for-binary-formats/2016/2</link>
        <pubDate>Mon, 27 Jan 2025 17:33:09 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2016-2</guid>
        <source url="https://rebol.metaeducation.com/t/kaitai-struct-declarative-language-for-binary-formats/2016.rss">Kaitai Struct Declarative Language for Binary Formats</source>
      </item>
      <item>
        <title>Kaitai Struct Declarative Language for Binary Formats</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>This is an interesting declarative language in YAML designed to generate classes for binary formats.  There are many formats defined:</p>
<p><a href="https://formats.kaitai.io/">https://formats.kaitai.io/</a></p>
<p>That's a lot of cases...but as one instructive example, you can look at how it describes a ZIP file--with little snippets of code in it for extracting the values:</p>
<p><a href="https://formats.kaitai.io/zip/" class="inline-onebox">ZIP archive file format spec for Kaitai Struct</a></p>
<p>The C++ code generated is like this:</p>
<p><a href="https://formats.kaitai.io/zip/cpp_stl_11.html" class="inline-onebox">ZIP archive file: C++11/STL parsing library</a></p>
<p>But it also can also be used to make code for C#, JavaScript, Python, Ruby, Nim, PHP, Lua, Perl... <em>(though we'd assume that if you escape code in, that part will only work be available for that language)</em></p>
<p>The regimentation of YAML provides the typical repetition in the "dialect".  This is the same as the Rebol complaint about JSON--not really leveraging "parts of speech", but repeating tags over and over like <code>id:</code> and <code>type:</code></p>
<pre><code>  - id: version
    type: u2
  - id: flags
    type: gp_flags
    size: 2
  - id: compression_method
    type: u2
    enum: compression
</code></pre>
<p>But it's still pretty hard to compete with, especially when you consider this is giving a compilable specification...so the performance is going to be much better.</p>
<p>I always thought BINARY! parse was something that Rebol would have a unique story for, and Ren-C's UPARSE makes that a stronger story (by allowing rules to synthesize arbitrary results via extraction)... but seeing this kind of stuff reminds me that there are diminishing returns.</p>
          <p><a href="https://rebol.metaeducation.com/t/kaitai-struct-declarative-language-for-binary-formats/2016/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/kaitai-struct-declarative-language-for-binary-formats/2016/1</link>
        <pubDate>Tue, 21 Feb 2023 22:36:43 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2016-1</guid>
        <source url="https://rebol.metaeducation.com/t/kaitai-struct-declarative-language-for-binary-formats/2016.rss">Kaitai Struct Declarative Language for Binary Formats</source>
      </item>
  </channel>
</rss>

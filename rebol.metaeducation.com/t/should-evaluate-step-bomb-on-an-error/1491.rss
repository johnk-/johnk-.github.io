<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Should EVALUATE:STEP bomb on an error?</title>
    <link>https://rebol.metaeducation.com/t/should-evaluate-step-bomb-on-an-error/1491</link>
    <description>Currently if you try something bad in EVALUATE:STEP, it throws an error:

    &gt;&gt; evaluate:step [unspaced null]
    ** Script Error: unspaced requires line argument to not be null

As EVALUATE:STEP is a relatively low-level service, it would seem more likely one would want to handle the error on the same basis as other possible return values:

    &gt;&gt; [position product]: evaluate:step [unspaced null foo bar]
    == [foo bar]

    &gt;&gt; product
    == &lt;&lt;unspaced-null&gt;&gt;  ; some error you can handle

In this case, the bomb isn&#39;t particularly informative and seems reasonable to say *&#39;user bewareâ€”assume errors will happen&#39;*. It&#39;s kind of difficult to work around too.

This sort of puts it in the same class as TRAP with different semantics:

```
trap [ok ok something bad] =&gt; [**something-bad null]
trap [ok ok] =&gt; [null ok]
evaluate [something bad ok ok] =&gt; [[ok ok] **something-bad ]
evaluate [ok ok] =&gt; [ok [ok]]
```

I guess the wrinkle here is how do you determine where `something bad` ends and `ok ok` resumes? That may or may not be obvious.</description>
    
    <lastBuildDate>Mon, 02 Jun 2025 01:20:54 +0000</lastBuildDate>
    <category>Errors</category>
    <atom:link href="https://rebol.metaeducation.com/t/should-evaluate-step-bomb-on-an-error/1491.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Should EVALUATE:STEP bomb on an error?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="1491">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Another trick could be to have an :ENTRAP refinement.</p>
</blockquote>
</aside>
<p>The idea of having to add lift-oriented refinements to every function that wants to do this turns out to be grating, and undermines the generality of the isotopic protocol.</p>
<p>So I decided to back down on the "no error! antiforms in packs, ever" policy, instead saying that <strong><code>PACK</code></strong> just doesn't allow it by default...and you have to use a different <strong><code>PACK*</code></strong> function to get them.</p>
<p>The trick is that if a pack decays to its first element, it first checks to see if any of the non-first-elements are raised errors...and promotes them to abrupt failure.  This way you don't accidentally gloss over them.</p>
<p><strong>So it's actually pretty trivial to accomplish the original desire now--another home run for isotopes!</strong> <img src="https://rebol.metaeducation.com/images/emoji/twitter/baseball.png?v=14" title=":baseball:" class="emoji" alt=":baseball:" loading="lazy" width="20" height="20"></p>
<pre><code>&gt;&gt; name: null

&gt;&gt; block: [1 + 2 1 / 0 10 + 20 unspaced ["hello" name]]

&gt;&gt; collect [
       while [[block ^:result]: eval:step block] [
           if error? ^result [
               keep quasi (unquasi result).id
           ] else [
               keep ^result
           ]
       ]
   ]
== [3 ~zero-divide~ 30 ~need-non-null~]
</code></pre>
<p><em><strong>If you had told me when I woke up this morning that this issue would be solved by end of day, I would not have believed you.</strong></em></p>
<p>That's some clean expressive power, right there.  So many good ideas dovetailing together it almost hurts.</p>
<h2><a name="p-7363-a-note-on-why-you-cant-intercept-unspaced-null-1" class="anchor" href="https://rebol.metaeducation.com#p-7363-a-note-on-why-you-cant-intercept-unspaced-null-1"></a>A Note On Why You Can't Intercept <code>UNSPACED NULL</code></h2>
<p><strong><code>unspaced ["hello" null]</code></strong> gives a definitional error due to the choice of UNSPACED to return a definitional error in that case.  But <strong><code>unspaced null</code></strong> causes a parameter type checking error, and is a hard failure.  Type check errors are not definitional, which is by design--and we would not want to do otherwise.</p>
<p>It would be like making typos interceptible.  Imagine if typos raised definitional errors.  You'd say <strong>try takke block</strong> and the TRY would suppress the "no such variable as TAKKE" error and turn it to NULL.  Then BLOCK would be evaluated in isolation.</p>
<p><strong>You only want definitional errors to come from inside the functions themselves once they've started running and have all their arguments.</strong></p>
<p>Theoretically, UNSPACED <em>could</em> make NULL one of its accepted parameter types.  Then from the inside of its implementation, it could raise a definitional error related to it.  I'll leave it as an exercise for the reader to think about why not to do that.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/slight_smile.png?v=14" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
          <p><a href="https://rebol.metaeducation.com/t/should-evaluate-step-bomb-on-an-error/1491/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/should-evaluate-step-bomb-on-an-error/1491/4</link>
        <pubDate>Fri, 23 Aug 2024 04:52:02 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1491-4</guid>
        <source url="https://rebol.metaeducation.com/t/should-evaluate-step-bomb-on-an-error/1491.rss">Should EVALUATE:STEP bomb on an error?</source>
      </item>
      <item>
        <title>Should EVALUATE:STEP bomb on an error?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="1491">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<aside class="quote no-group" data-username="rgchris" data-post="1" data-topic="1491">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I guess the wrinkle here is how do you determine where <code>something bad</code> ends and <code>ok ok</code> resumes?</p>
</blockquote>
</aside>
<p>Rebol can't measure the span of a single step of evaluation without having the side-effect of running it. That's just the nature of the beast.</p>
</blockquote>
</aside>
<p>We can't to do anything about "panics" (hard failures,  which can occur anywhere in the middle of an incomplete expression, at any stack level, even from just looking up a word that's a typo).  No hope of graceful handling there...</p>
<p>...BUT we can theoretically do something about the new and novel <a href="https://rebol.metaeducation.com/t/fail-vs-return-raise-the-new-age-of-definitional-errors/1852"><strong>definitional ERROR! antiforms</strong></a> <img src="https://rebol.metaeducation.com/images/emoji/twitter/atom.png?v=14" title=":atom:" class="emoji" alt=":atom:" loading="lazy" width="20" height="20"> which emerge from the overall step, that have not yet been promoted to a failure.  Because the antiform ERROR! is a legitimate evaluation product, and the flow of control has not yet been interrupted.</p>
<p><em>(And luckily, all meaningfully interceptible errors are definitional.  Read the above link to understand why.)</em></p>
<h2><a name="p-7362-though-it-turns-out-to-be-tricky-thinking-1" class="anchor" href="https://rebol.metaeducation.com#p-7362-though-it-turns-out-to-be-tricky-thinking-1"></a><em>Though It Turns Out To Be Tricky.</em>  <img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"></h2>
<p><a href="https://rebol.metaeducation.com/t/re-imagining-eval-next/767">EVALUATE:STEP gives back a multi-result pack</a>, with the position as the first pack item, and the synthesized value as the second.</p>
<p><a href="https://rebol.metaeducation.com/t/no-raised-errors-in-pack-but-feel-the-power/2206">We'd like to avoid ERROR! antiforms in PACK.</a>  In fact, if a function returns an ERROR!... <em>we tend to say that's the only thing it can return</em>.  Because instead of the antiform BLOCK! (the pack of values) you're returning an antiform ERROR!.</p>
<p>So EVALUATE:NEXT can't (well, <em>shouldn't</em>) give you back both a raised error and a position.</p>
<h2><a name="p-7362-orcould-it-2" class="anchor" href="https://rebol.metaeducation.com#p-7362-orcould-it-2"></a>Or...could it?</h2>
<p><em>The expression completion position could be a field in the error itself.</em></p>
<p>Using some overlong descriptive names to illustrate:</p>
<pre><code>[pos value]: evaluate:step [1 / 0 10 + 20] except e -&gt; [
     if e.id = 'raised-error-in-evaluate-next [
         assert [e.error.id = 'divide-by-zero]  ; actual error is wrapped in e
         pos: e.resume-position  ; e.g. [10 + 20]
     ] else [
         panic e  ; some other error
    ]
]
</code></pre>
<p>There are more mundane approaches, such as adding :EXCEPT such that EVALUATE:STEP:EXCEPT produces a <strong><code>~[pos value error]~</code></strong> pack instead of just a <strong><code>~[pos value]~</code></strong> pack.  Then you have to remember to check that the error is not NULL on all paths.  That sounds less foolproof.</p>
<p>Another trick could be to have an :ENTRAP refinement.  The concept behind ENTRAP is to take everything up one lift level...</p>
<pre><code>&gt;&gt; entrap [10 + 20]
== '30
</code></pre>
<p>So 10 + 20 gave you a quoted 30.  And if you had a plain ERROR! you would get a quoted error.  If you had a null antiform you'd get a quasi-null.</p>
<pre><code>&gt;&gt; entrap [pick [a b] 3]
== ~null~
</code></pre>
<p>This means all values will be lifted... either quoted or quasi.</p>
<p>But then, if an ERROR! antiform is encountered... ENTRAP returns it in a plain form:</p>
<pre><code>&gt;&gt; entrap [1 / 0]
== &amp;[warning [
    type: 'Math
    id: 'zero-divide
    message: "attempt to divide by zero"
    near: '[1 / 0 **]
    where: '[/ entrap console]
    file: ~null~
    line: 1
]]
</code></pre>
<p><strong>And it's the only plain form you <em>can</em> get.</strong>  So if you get a plain WARNING? RESULT back from EVAL, you know it actually represents a raised error.  Otherwise your real result is the UNLIFT of what you got (drop a quote level from quoted things, turn quasiforms into antiforms).</p>
<p><em>(It's a weird multiplexing trick, but it's serviceable...and kind of a testament to the versatility of the isotopic model.)</em></p>
<p>So there's hope on this!  I'm actually working on something that needs this <em>right now</em>.  Because without something like this, you cannot write TRAP in usermode...</p>
          <p><a href="https://rebol.metaeducation.com/t/should-evaluate-step-bomb-on-an-error/1491/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/should-evaluate-step-bomb-on-an-error/1491/3</link>
        <pubDate>Fri, 23 Aug 2024 02:32:35 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1491-3</guid>
        <source url="https://rebol.metaeducation.com/t/should-evaluate-step-bomb-on-an-error/1491.rss">Should EVALUATE:STEP bomb on an error?</source>
      </item>
      <item>
        <title>Should EVALUATE:STEP bomb on an error?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="rgchris" data-post="1" data-topic="1491">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I guess the wrinkle here is how do you determine where <code>something bad</code> ends and <code>ok ok</code> resumes?</p>
</blockquote>
</aside>
<p>Quite right.</p>
<p>Rebol can't measure the span of a single step of evaluation without having the side-effect of running it.  That's just the nature of the beast.</p>
<p>I'd once tried making a "neutral" mode of the evaluator which would only gather arguments but not have any side effects.  This would be able to count through the function arguments, and the arguments to functions that were those arguments, and so on:</p>
<pre><code> &gt;&gt; eval-neutral [print "Hi" print "Bye"]
 == [print "Bye"]   ; no actual printing done, but arity of PRINT exploited

 &gt;&gt; eval-neutral [print "Bye"]
 == []
</code></pre>
<p>But this falls down the moment you run code which changes the definitions:</p>
<pre><code> &gt;&gt; redefine-print: func [] [print: does [print "PRINT is arity-0 now"]]

 &gt;&gt; eval-neutral [redefine-print print "Bye"]
 == [print "Bye"]  ; didn't actually *run* REDEFINE-PRINT

 &gt;&gt; eval-neutral [print "Bye"]
 == []  ; should have only stepped past PRINT, leaving "Bye"
</code></pre>
<p>Some aspect of this foundational problem applies any time you try to resume things.  Hence, the only granularity of resumption can be the end of BLOCK!/GROUP!.</p>
<p>(It's this "we can't know the limits of boundaries of expressions" that tripped up the idea of making the MATH dialect for precedence reordering able to mix expressions without putting all executable expressions between the operators in GROUP!s.)</p>
<aside class="quote no-group quote-modified" data-username="rgchris" data-post="1" data-topic="1491">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>As EVALUATE is a relatively low-level function, it would seem more likely one would want to handle the error on the same basis as other possible return values</p>
</blockquote>
</aside>
<p><a href="https://rebol.metaeducation.com/t/the-need-to-rethink-error/1371">I've written some ideas on making a more formal contract between callers and things that error.</a>  Perhaps you would be able to weigh in there.</p>
          <p><a href="https://rebol.metaeducation.com/t/should-evaluate-step-bomb-on-an-error/1491/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/should-evaluate-step-bomb-on-an-error/1491/2</link>
        <pubDate>Sat, 06 Feb 2021 07:57:54 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1491-2</guid>
        <source url="https://rebol.metaeducation.com/t/should-evaluate-step-bomb-on-an-error/1491.rss">Should EVALUATE:STEP bomb on an error?</source>
      </item>
      <item>
        <title>Should EVALUATE:STEP bomb on an error?</title>
        <dc:creator><![CDATA[rgchris]]></dc:creator>
        <description><![CDATA[
            <p>Currently if you try something bad in EVALUATE:STEP, it throws an error:</p>
<pre><code>&gt;&gt; evaluate:step [unspaced null]
** Script Error: unspaced requires line argument to not be null
</code></pre>
<p>As EVALUATE:STEP is a relatively low-level service, it would seem more likely one would want to handle the error on the same basis as other possible return values:</p>
<pre><code>&gt;&gt; [position product]: evaluate:step [unspaced null foo bar]
== [foo bar]

&gt;&gt; product
== &lt;&lt;unspaced-null&gt;&gt;  ; some error you can handle
</code></pre>
<p>In this case, the bomb isn't particularly informative and seems reasonable to say <em>'user bewareâ€”assume errors will happen'</em>. It's kind of difficult to work around too.</p>
<p>This sort of puts it in the same class as TRAP with different semantics:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">trap [ok ok something bad] =&gt; [**something-bad null]
trap [ok ok] =&gt; [null ok]
evaluate [something bad ok ok] =&gt; [[ok ok] **something-bad ]
evaluate [ok ok] =&gt; [ok [ok]]
</code></pre>
<p>I guess the wrinkle here is how do you determine where <code>something bad</code> ends and <code>ok ok</code> resumes? That may or may not be obvious.</p>
          <p><a href="https://rebol.metaeducation.com/t/should-evaluate-step-bomb-on-an-error/1491/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/should-evaluate-step-bomb-on-an-error/1491/1</link>
        <pubDate>Sat, 06 Feb 2021 06:24:54 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1491-1</guid>
        <source url="https://rebol.metaeducation.com/t/should-evaluate-step-bomb-on-an-error/1491.rss">Should EVALUATE:STEP bomb on an error?</source>
      </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Changing Build System Dialect</title>
    <link>https://rebol.metaeducation.com/t/changing-build-system-dialect/2491</link>
    <description>There was an old dialect that used blocks, like:

     sources-C: [
         %file1.c
         [%file2.c &lt;some&gt; &lt;options&gt;]
         %file3.c
     ]

This was because it was based on MAP-EACH and processing items seemed &quot;easier&quot; to do when you could go one item at a time.

But I decided I didn&#39;t like it.  I prefer to have the option blocks separate.  I&#39;m also going back to accepting TUPLE!s/PATH!s (a bootstrap issue got in the way of this, but I found a workaround).

     sources-C: [
         file1.c
         file2.c [&lt;some&gt; &lt;options&gt;]
         file3.c
     ]

Traversing this means you have to do some PARSE-ing, but that&#39;s what makes it interesting.

Here&#39;s some code that&#39;s getting tossed, that did some &quot;canonicalizing&quot; of the old format:

    ; Some places (like SOURCES: in %make-spec.r for extensions) are permissive
    ; in terms of their format:
    ;
    ;     sources-A: %file.jpg
    ;
    ;     sources-B: [%file.jpg &lt;some&gt; &lt;options&gt;]
    ;
    ;     sources-C: [
    ;         %file1.jpg
    ;         [%file2.jpg &lt;some&gt; &lt;options&gt;]
    ;         %file3.jpg
    ;     ]
    ;
    ; It&#39;s a bit irregular, but convenient.  This function regularizes it:
    ;
    ;     sources-A: [
    ;         [%file.c]
    ;     ]
    ;
    ;     sources-B: [
    ;         [%file.c &lt;some&gt; &lt;options&gt;]
    ;     ]
    ;
    ;     sources-C: [
    ;         [%file1.c]
    ;         [%file2.c &lt;some&gt; &lt;options&gt;]
    ;         [%file3.c]
    ;     ]
    ;
    export to-block-of-file-blocks: func [
        return: &quot;Will be a top-level COPY of the block, or new block&quot;
            [block!]
        x [&lt;opt&gt; file! block!]
    ][
        if file? x [
            return reduce [blockify x]  ; case A
        ]
        any [null? x, x = []] then [
            return copy []
        ]
        if file? x.1 [
            all [
                not find (next x) file!
                not find (next x) block!
            ] then [
                return reduce [x]  ; case B
            ]
            ; fallthrough
        ]
        if find x tag! [  ; light check for mistakes
            panic [
                &quot;FILE!/BLOCK! list can&#39;t contain TAG!s if multiple files:&quot;
                mold:limit x 200
            ]
        ]
        return map-each &#39;item x [blockify item]  ; case C
    ]</description>
    
    <lastBuildDate>Tue, 17 Jun 2025 09:05:58 +0000</lastBuildDate>
    <category>Build System</category>
    <atom:link href="https://rebol.metaeducation.com/t/changing-build-system-dialect/2491.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Changing Build System Dialect</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>There was an old dialect that used blocks, like:</p>
<pre><code> sources-C: [
     %file1.c
     [%file2.c &lt;some&gt; &lt;options&gt;]
     %file3.c
 ]
</code></pre>
<p>This was because it was based on MAP-EACH and processing items seemed "easier" to do when you could go one item at a time.</p>
<p>But I decided I didn't like it.  I prefer to have the option blocks separate.  I'm also going back to accepting TUPLE!s/PATH!s (a bootstrap issue got in the way of this, but I found a workaround).</p>
<pre><code> sources-C: [
     file1.c
     file2.c [&lt;some&gt; &lt;options&gt;]
     file3.c
 ]
</code></pre>
<p>Traversing this means you have to do some PARSE-ing, but that's what makes it interesting.</p>
<p>Here's some code that's getting tossed, that did some "canonicalizing" of the old format:</p>
<pre><code>; Some places (like SOURCES: in %make-spec.r for extensions) are permissive
; in terms of their format:
;
;     sources-A: %file.jpg
;
;     sources-B: [%file.jpg &lt;some&gt; &lt;options&gt;]
;
;     sources-C: [
;         %file1.jpg
;         [%file2.jpg &lt;some&gt; &lt;options&gt;]
;         %file3.jpg
;     ]
;
; It's a bit irregular, but convenient.  This function regularizes it:
;
;     sources-A: [
;         [%file.c]
;     ]
;
;     sources-B: [
;         [%file.c &lt;some&gt; &lt;options&gt;]
;     ]
;
;     sources-C: [
;         [%file1.c]
;         [%file2.c &lt;some&gt; &lt;options&gt;]
;         [%file3.c]
;     ]
;
export to-block-of-file-blocks: func [
    return: "Will be a top-level COPY of the block, or new block"
        [block!]
    x [&lt;opt&gt; file! block!]
][
    if file? x [
        return reduce [blockify x]  ; case A
    ]
    any [null? x, x = []] then [
        return copy []
    ]
    if file? x.1 [
        all [
            not find (next x) file!
            not find (next x) block!
        ] then [
            return reduce [x]  ; case B
        ]
        ; fallthrough
    ]
    if find x tag! [  ; light check for mistakes
        panic [
            "FILE!/BLOCK! list can't contain TAG!s if multiple files:"
            mold:limit x 200
        ]
    ]
    return map-each 'item x [blockify item]  ; case C
]
</code></pre>
          <p><a href="https://rebol.metaeducation.com/t/changing-build-system-dialect/2491/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/changing-build-system-dialect/2491/1</link>
        <pubDate>Tue, 17 Jun 2025 09:05:58 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2491-1</guid>
        <source url="https://rebol.metaeducation.com/t/changing-build-system-dialect/2491.rss">Changing Build System Dialect</source>
      </item>
  </channel>
</rss>

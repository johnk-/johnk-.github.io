<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Bringing Ren-C ATTEMPT and UNTIL Into C</title>
    <link>https://rebol.metaeducation.com/t/bringing-ren-c-attempt-and-until-into-c/2481</link>
    <description>**[The ATTEMPT construct is so useful, I made a version for C](https://rebol.metaeducation.com/t/repeat-1-attempt-not-as-useless-as-it-looks/2480)**

And UNTIL as well... *[(the negated WHILE meaning from Ren-C...)](https://rebol.metaeducation.com/t/the-mismatch-of-arity-1-until-and-arity-2-while/594/10?u=hostilefork)*

Pretty fun...

    //=//// &quot;ATTEMPT&quot; AND &quot;UNTIL&quot; CONSTRUCTS //////////////////////////////////=//
    //
    // This is a fun trick that brings a little bit of the ATTEMPT and UNTIL loop
    // functionality from Ren-C into C.
    //
    // The `attempt` macro is a loop that runs its body just once, and then
    // evaluates the `then` or `else` clause (if present):
    //
    //     attempt {
    //         ... some code ...
    //         if (condition) { break; }  /* exit attempt, run &quot;else&quot; clause */
    //         if (condition) { continue; }  /* exit attempt, run &quot;then&quot; clause */
    //         if (condition) { again; }  /* jump to attempt and run it again */
    //         ... more code ...
    //     }
    //     then {  /* optional then clause */
    //        ... code to run if no break happened ...
    //     }
    //     else {  /* optional else clause (must have then clause to use else) */
    //        ... code to run if a break happened ...
    //     }
    //
    // It doesn&#39;t do anything you couldn&#39;t do with defining some goto labels.
    // But if you have B breaks and C continues and A agains, you don&#39;t have to
    // type the label names ((B + 1) + (C + 1) + (A + 1)) times.  And you don&#39;t
    // have to worry about coming up with the names for those labels!
    //
    // The `until` macro is a negated sense while loop that also is able to have
    // compatibility with the `then` and `else` clauses.
    //
    // BUT NOTE: Since the macros define variables tracking whether the `then`
    // clause should run or not, and whether an `again` should signal continuing
    // to run...this can only be used in one scope at a time.  To use more than
    // once in a function, define another scope.  Also, you can&#39;t use an `else`
    // clause without a `then` clause.

    #define attempt \
        bool run_then_ = false;  /* as long as run_then_ is false, keep going */ \
        bool run_again_ = false;  /* if run_again_, don&#39;t set run_then_ */ \
        for (; not run_then_; \
            run_again_ ? (run_again_ = false), true  /* again doesn&#39;t exit loop */ \
            : (run_then_ = true))  /* normal continue, exits the loop */

    #define until(condition) \
        bool run_then_ = false; \
        bool run_again_ = false; \
        for (; run_again_ ? (run_again_ = false), true :  /* skip condition */ \
            (condition) ? (run_then_ = true, false) : true; )

    #define then  if (run_then_)
    #define again  { run_again_ = true; continue; }</description>
    
    <lastBuildDate>Sat, 07 Jun 2025 12:29:31 +0000</lastBuildDate>
    <category>C/C++ Implementation</category>
    <atom:link href="https://rebol.metaeducation.com/t/bringing-ren-c-attempt-and-until-into-c/2481.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Bringing Ren-C ATTEMPT and UNTIL Into C</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p><strong><a href="https://rebol.metaeducation.com/t/repeat-1-attempt-not-as-useless-as-it-looks/2480">The ATTEMPT construct is so useful, I made a version for C</a></strong></p>
<p>And UNTIL as well... <em><a href="https://rebol.metaeducation.com/t/the-mismatch-of-arity-1-until-and-arity-2-while/594/10">(the negated WHILE meaning from Ren-C...)</a></em></p>
<p>Pretty fun...</p>
<pre><code>//=//// "ATTEMPT" AND "UNTIL" CONSTRUCTS //////////////////////////////////=//
//
// This is a fun trick that brings a little bit of the ATTEMPT and UNTIL loop
// functionality from Ren-C into C.
//
// The `attempt` macro is a loop that runs its body just once, and then
// evaluates the `then` or `else` clause (if present):
//
//     attempt {
//         ... some code ...
//         if (condition) { break; }  /* exit attempt, run "else" clause */
//         if (condition) { continue; }  /* exit attempt, run "then" clause */
//         if (condition) { again; }  /* jump to attempt and run it again */
//         ... more code ...
//     }
//     then {  /* optional then clause */
//        ... code to run if no break happened ...
//     }
//     else {  /* optional else clause (must have then clause to use else) */
//        ... code to run if a break happened ...
//     }
//
// It doesn't do anything you couldn't do with defining some goto labels.
// But if you have B breaks and C continues and A agains, you don't have to
// type the label names ((B + 1) + (C + 1) + (A + 1)) times.  And you don't
// have to worry about coming up with the names for those labels!
//
// The `until` macro is a negated sense while loop that also is able to have
// compatibility with the `then` and `else` clauses.
//
// BUT NOTE: Since the macros define variables tracking whether the `then`
// clause should run or not, and whether an `again` should signal continuing
// to run...this can only be used in one scope at a time.  To use more than
// once in a function, define another scope.  Also, you can't use an `else`
// clause without a `then` clause.

#define attempt \
    bool run_then_ = false;  /* as long as run_then_ is false, keep going */ \
    bool run_again_ = false;  /* if run_again_, don't set run_then_ */ \
    for (; not run_then_; \
        run_again_ ? (run_again_ = false), true  /* again doesn't exit loop */ \
        : (run_then_ = true))  /* normal continue, exits the loop */

#define until(condition) \
    bool run_then_ = false; \
    bool run_again_ = false; \
    for (; run_again_ ? (run_again_ = false), true :  /* skip condition */ \
        (condition) ? (run_then_ = true, false) : true; )

#define then  if (run_then_)
#define again  { run_again_ = true; continue; }
</code></pre>
          <p><a href="https://rebol.metaeducation.com/t/bringing-ren-c-attempt-and-until-into-c/2481/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/bringing-ren-c-attempt-and-until-into-c/2481/1</link>
        <pubDate>Sat, 07 Jun 2025 11:31:47 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2481-1</guid>
        <source url="https://rebol.metaeducation.com/t/bringing-ren-c-attempt-and-until-into-c/2481.rss">Bringing Ren-C ATTEMPT and UNTIL Into C</source>
      </item>
  </channel>
</rss>

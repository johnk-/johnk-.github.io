<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Getting Out Of ENTRAP-ment</title>
    <link>https://rebol.metaeducation.com/t/getting-out-of-entrap-ment/2444</link>
    <description>When antiform ERROR! first arrived, there needed to be a way to capture them.

I was uncomfortable having the LIFT operator blindly turn an antiform ERROR! into a quasi-ERROR!, because that could sweep things under the rug.  You might have been LIFT-ing because you wanted to capture a PACK! (including VOID) or so you could put a NULL or SPLICE! into a BLOCK!.  Why would you conflate that with error suppression?

So there was LIFT that didn&#39;t meta an ERROR! antiform, and LIFT* that would.

Now you want to capture an error from an operation.  You&#39;ve got a situation like:

    result&#39;: lift* eval code

    if error? unlift result&#39; [
         let warning: unquasi result&#39;
         ; ... handle disarmed error (warning) ...
    ] else [
        let result: unlift result&#39;
        ; ... handle result ...
    ]

I thought this was a bit more painful than it needed to be, so I created ENTRAP.

    result&#39;: entrap code

    if warning? result&#39; [
         ; ... handle disarmed error (warning) in result&#39; ...
    ] else [
        let result: unlift result&#39;
        ; ... handle result ...
    ]

Not a heck of a lot better.  But saved a bit of boilerplate.

## Now We Can Do Better!

**(^result: ...)** will write the lifted representation of the evaluation into result, *but still return the original result*.  So if the original result was an ERROR! it will still be an error out.

But you can suppress that.  So look at this magic:

    try ^result: eval code  ; TRY suppresses, but meta-ERROR! still wrote to result

    if error? ^result [
         ; ... handle error in ^result ...
    ] else [
        ; ... handle original result as ^result ...
    ]

:bullseye: 

## So What, Then, Is TRAP Now?

Right now EVAL only lets you bubble out an error if it&#39;s the last step.  Interstitial ERROR! will lead to a PANIC if there&#39;s no triage:

    &gt;&gt; error? eval [print &quot;step one&quot; 1 / 0]
    step one
    == \~okay~\  ; antiform

    &gt;&gt; error? eval [1 / 0 print &quot;step two&quot;]
    !! PANIC: division by zero

That&#39;s kind of a non-negotiable default, because when you branch and pipe ERROR! values around you intend for the error to be the product of the last branch step, not some incidental code that ran before that last step.

So maybe TRAP is a construct that lets you bail early, getting an error from any step:

    &gt;&gt; error? trap [print &quot;step one&quot; 1 / 0]
    step one
    == \~okay~\  ; antiform

    &gt;&gt; error? trap [1 / 0 print &quot;step two&quot;]
    == \~okay~\  ; antiform

Or maybe that&#39;s a refinement to EVAL.  I dunno.

Another thing to point out is that ERROR! is not an exception (panic).  It&#39;s a FAIL state that can be piped around.  So using EXCEPT as name for the postfix error handler is a little off:

     eval code except ^e -&gt; [
        ; handle ERROR!
     ]

Should that be TRAP ?

     eval code trap ^e -&gt; [
        ; handle ERROR!
     ]

Food for thought.  In any case, I&#39;m really pleased to see how (^x: ...) vs. (try ^x: ...) offers the choices I was seeking, in so much cleaner a way.</description>
    
    <lastBuildDate>Mon, 02 Jun 2025 17:57:27 +0000</lastBuildDate>
    <category>Errors</category>
    <atom:link href="https://rebol.metaeducation.com/t/getting-out-of-entrap-ment/2444.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Getting Out Of ENTRAP-ment</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="2444">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">block.^1: eval [...]
</code></pre>
<p>And you'd be sort-of protected in that case, because if you don't TRY the result the ERROR! would still fall out the assignment. (I say "sort-of" because you find out only after it's done the change, and written the meta-error into your block).</p>
</blockquote>
</aside>
<p>This "not stopping the write" aspect is actually a pretty serious fundamental thing to be taken into account for using this form.</p>
<p>It suggests you should never use <strong><code>foo.^xxx:</code></strong> unless you are intending to write errors, or unless you've made sure you're not writing errors some other way.</p>
<pre><code>foo.^xxx: eval code except ^e -&gt; [...]  ; not writing error
</code></pre>
<p>Though that calls into question the "what if an EXCEPT block evaluates to a raised error" issue, which maybe should be prevented, at least by default--unless you use EXCEPT:RELAX or something.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/face_with_diagonal_mouth.png?v=14" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20"></p>
<p>Anyway, I just wanted to bring up this caution, that writing <strong>(foo.^xxx: ...)</strong> is a power tool that needs to be used carefully, <em>since it never fails to overwrite the variable.</em></p>
          <p><a href="https://rebol.metaeducation.com/t/getting-out-of-entrap-ment/2444/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/getting-out-of-entrap-ment/2444/3</link>
        <pubDate>Sun, 11 May 2025 11:24:42 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2444-3</guid>
        <source url="https://rebol.metaeducation.com/t/getting-out-of-entrap-ment/2444.rss">Getting Out Of ENTRAP-ment</source>
      </item>
      <item>
        <title>Getting Out Of ENTRAP-ment</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2444">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I was uncomfortable having the LIFT operator blindly turn an antiform ERROR! into a quasi-ERROR!, because that could sweep things under the rug. You might have been LIFT-ing because you wanted to capture a PACK! (including VOID) or so you could put a NULL or SPLICE! into a BLOCK!. Why would you conflate that with error suppression?</p>
<p>So there was LIFT that didn't meta an ERROR! antiform, and LIFT* that would.</p>
</blockquote>
</aside>
<p>I should point out that this is probably still a good idea.</p>
<p>It's true that you'll be able to put things in blocks by doing things like:</p>
<pre><code>block.^1: eval [...]
</code></pre>
<p>Instead of:</p>
<pre><code>block.1: lift eval [...]
</code></pre>
<p>And you'd be sort-of protected in that case, because if you don't TRY the result the ERROR! would still fall out the assignment.  (I say "sort-of" because you find out only after it's done the change, and written the meta-error into your block).</p>
<p>But then there's cases like:</p>
<pre><code>append [a b c] lift eval [...]
</code></pre>
<p>And there you're back where you started, with putting lifted-errors in blocks vs. panicking at that moment when you probably wanted to.</p>
<p>So needing <strong><code>lift:relax</code></strong> in order to be willing to meta-represent errors, and shorthanded as <strong><code>lift*</code></strong>, feels like it makes a lot of sense.</p>
<p><em>(Do note that REIFY and DEGRADE exist if quasiforms are out of band of your data, and has the nice property of just making little quasiforms for your voids and nulls and splices and such, without adding quote levels to normal values.  There is no REIFY:RELAX at this time, though perhaps there should be.)</em></p>
          <p><a href="https://rebol.metaeducation.com/t/getting-out-of-entrap-ment/2444/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/getting-out-of-entrap-ment/2444/2</link>
        <pubDate>Sun, 11 May 2025 11:12:39 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2444-2</guid>
        <source url="https://rebol.metaeducation.com/t/getting-out-of-entrap-ment/2444.rss">Getting Out Of ENTRAP-ment</source>
      </item>
      <item>
        <title>Getting Out Of ENTRAP-ment</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>When antiform ERROR! first arrived, there needed to be a way to capture them.</p>
<p>I was uncomfortable having the LIFT operator blindly turn an antiform ERROR! into a quasi-ERROR!, because that could sweep things under the rug.  You might have been LIFT-ing because you wanted to capture a PACK! (including VOID) or so you could put a NULL or SPLICE! into a BLOCK!.  Why would you conflate that with error suppression?</p>
<p>So there was LIFT that didn't meta an ERROR! antiform, and LIFT* that would.</p>
<p>Now you want to capture an error from an operation.  You've got a situation like:</p>
<pre><code>result': lift* eval code

if error? unlift result' [
     let warning: unquasi result'
     ; ... handle disarmed error (warning) ...
] else [
    let result: unlift result'
    ; ... handle result ...
]
</code></pre>
<p>I thought this was a bit more painful than it needed to be, so I created ENTRAP.</p>
<pre><code>result': entrap code

if warning? result' [
     ; ... handle disarmed error (warning) in result' ...
] else [
    let result: unlift result'
    ; ... handle result ...
]
</code></pre>
<p>Not a heck of a lot better.  But saved a bit of boilerplate.</p>
<h2><a name="p-8250-now-we-can-do-better-1" class="anchor" href="https://rebol.metaeducation.com#p-8250-now-we-can-do-better-1"></a>Now We Can Do Better!</h2>
<p><strong>(^result: ...)</strong> will write the lifted representation of the evaluation into result, <em>but still return the original result</em>.  So if the original result was an ERROR! it will still be an error out.</p>
<p>But you can suppress that.  So look at this magic:</p>
<pre><code>try ^result: eval code  ; TRY suppresses, but meta-ERROR! still wrote to result

if error? ^result [
     ; ... handle error in ^result ...
] else [
    ; ... handle original result as ^result ...
]
</code></pre>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/bullseye.png?v=14" title=":bullseye:" class="emoji only-emoji" alt=":bullseye:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8250-so-what-then-is-trap-now-2" class="anchor" href="https://rebol.metaeducation.com#p-8250-so-what-then-is-trap-now-2"></a>So What, Then, Is TRAP Now?</h2>
<p>Right now EVAL only lets you bubble out an error if it's the last step.  Interstitial ERROR! will lead to a PANIC if there's no triage:</p>
<pre><code>&gt;&gt; error? eval [print "step one" 1 / 0]
step one
== \~okay~\  ; antiform

&gt;&gt; error? eval [1 / 0 print "step two"]
!! PANIC: division by zero
</code></pre>
<p>That's kind of a non-negotiable default, because when you branch and pipe ERROR! values around you intend for the error to be the product of the last branch step, not some incidental code that ran before that last step.</p>
<p>So maybe TRAP is a construct that lets you bail early, getting an error from any step:</p>
<pre><code>&gt;&gt; error? trap [print "step one" 1 / 0]
step one
== \~okay~\  ; antiform

&gt;&gt; error? trap [1 / 0 print "step two"]
== \~okay~\  ; antiform
</code></pre>
<p>Or maybe that's a refinement to EVAL.  I dunno.</p>
<p>Another thing to point out is that ERROR! is not an exception (panic).  It's a FAIL state that can be piped around.  So using EXCEPT as name for the postfix error handler is a little off:</p>
<pre><code> eval code except ^e -&gt; [
    ; handle ERROR!
 ]
</code></pre>
<p>Should that be TRAP ?</p>
<pre><code> eval code trap ^e -&gt; [
    ; handle ERROR!
 ]
</code></pre>
<p>Food for thought.  In any case, I'm really pleased to see how (^x: ...) vs. (try ^x: ...) offers the choices I was seeking, in so much cleaner a way.</p>
          <p><a href="https://rebol.metaeducation.com/t/getting-out-of-entrap-ment/2444/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/getting-out-of-entrap-ment/2444/1</link>
        <pubDate>Sun, 11 May 2025 11:04:52 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2444-1</guid>
        <source url="https://rebol.metaeducation.com/t/getting-out-of-entrap-ment/2444.rss">Getting Out Of ENTRAP-ment</source>
      </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Dialecting With Sigils (eval @f) - Good or Bad?</title>
    <link>https://rebol.metaeducation.com/t/dialecting-with-sigils-eval-f-good-or-bad/2474</link>
    <description>There are two forms of EVALUATE with FRAME!... one of which consumes the memory of the frame so it can&#39;t be used again, and another that evaluates with a copy of the memory...leaving the original and its fields available after the eval.

    &gt;&gt; f: make frame! negate/
    == &amp;[frame! [
        number: ~
    ]]

    &gt;&gt; f.^number: 1020  ; as of today, you need lifts when using raw frames
    == 1020

    &gt;&gt; f
    == &amp;[frame! [
        number: &#39;&#39;1020  ; extra quote protects the single quoted value
    ]]

    &gt;&gt; evaluate f
    == -1020

    &gt;&gt; f
    == &amp;[frame! [
        number: &#39;&#39;1020
    ]]

    &gt;&gt; eval-free f
    == -1020

    &gt;&gt; f
    ** Panic: FRAME! was freed, memory no longer avaliable

EVALUATE and EVAL-FREE are two separate functions at the moment.  The reasoning is that if you are performance-conscious (hence the kind of person who&#39;d want EVAL-FREE) you want to be able to use an intrinsic, and intrinsic (FRAME!-less) dispatch happens when you have a single argument and no refinements.  Hence it shouldn&#39;t be EVALUATE:FREE or similar.

This drew me to a weird idea: what if you could say **`eval @f`** and that meant EVAL-FREE ?

    &gt;&gt; eval @f
    == -1020

    &gt;&gt; f
    ** Panic: FRAME! was freed, memory no longer avaliable

That&#39;s just one argument.  It takes advantage of the unusual property that pinned values have of just evaluating to themself, so the decoration is visible to the function being called...kind of like if it were inside a block.

*Basically it&#39;s a really, really small dialect.*

## Is This A Good Or Bad Idea?

I can&#39;t tell.  It&#39;s kind of slick, but also kind of random... nowhere else does `@` mean &quot;destructively utilize memory&quot;.

It pushes the responsibility of fetching the variable onto EVAL, but that&#39;s the same as any dialect which would take variables in a block and interpret them and need to look them up.

I&#39;m tempted to say that maybe this is not a feature of EVALUATE itself, but just a quirk of the shorthand EVAL.

Anyway, food for thought.</description>
    
    <lastBuildDate>Thu, 05 Jun 2025 19:45:57 +0000</lastBuildDate>
    <category>Dialects/DSLs</category>
    <atom:link href="https://rebol.metaeducation.com/t/dialecting-with-sigils-eval-f-good-or-bad/2474.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Dialecting With Sigils (eval @f) - Good or Bad?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>There are two forms of EVALUATE with FRAME!... one of which consumes the memory of the frame so it can't be used again, and another that evaluates with a copy of the memory...leaving the original and its fields available after the eval.</p>
<pre><code>&gt;&gt; f: make frame! negate/
== &amp;[frame! [
    number: ~
]]

&gt;&gt; f.^number: 1020  ; as of today, you need lifts when using raw frames
== 1020

&gt;&gt; f
== &amp;[frame! [
    number: ''1020  ; extra quote protects the single quoted value
]]

&gt;&gt; evaluate f
== -1020

&gt;&gt; f
== &amp;[frame! [
    number: ''1020
]]

&gt;&gt; eval-free f
== -1020

&gt;&gt; f
** Panic: FRAME! was freed, memory no longer avaliable
</code></pre>
<p>EVALUATE and EVAL-FREE are two separate functions at the moment.  The reasoning is that if you are performance-conscious (hence the kind of person who'd want EVAL-FREE) you want to be able to use an intrinsic, and intrinsic (FRAME!-less) dispatch happens when you have a single argument and no refinements.  Hence it shouldn't be EVALUATE:FREE or similar.</p>
<p>This drew me to a weird idea: what if you could say <strong><code>eval @f</code></strong> and that meant EVAL-FREE ?</p>
<pre><code>&gt;&gt; eval @f
== -1020

&gt;&gt; f
** Panic: FRAME! was freed, memory no longer avaliable
</code></pre>
<p>That's just one argument.  It takes advantage of the unusual property that pinned values have of just evaluating to themself, so the decoration is visible to the function being called...kind of like if it were inside a block.</p>
<p><em>Basically it's a really, really small dialect.</em></p>
<h2><a name="p-8372-is-this-a-good-or-bad-idea-1" class="anchor" href="https://rebol.metaeducation.com#p-8372-is-this-a-good-or-bad-idea-1"></a>Is This A Good Or Bad Idea?</h2>
<p>I can't tell.  It's kind of slick, but also kind of random... nowhere else does <code>@</code> mean "destructively utilize memory".</p>
<p>It pushes the responsibility of fetching the variable onto EVAL, but that's the same as any dialect which would take variables in a block and interpret them and need to look them up.</p>
<p>I'm tempted to say that maybe this is not a feature of EVALUATE itself, but just a quirk of the shorthand EVAL.</p>
<p>Anyway, food for thought.</p>
          <p><a href="https://rebol.metaeducation.com/t/dialecting-with-sigils-eval-f-good-or-bad/2474/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/dialecting-with-sigils-eval-f-good-or-bad/2474/1</link>
        <pubDate>Thu, 05 Jun 2025 19:40:04 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2474-1</guid>
        <source url="https://rebol.metaeducation.com/t/dialecting-with-sigils-eval-f-good-or-bad/2474.rss">Dialecting With Sigils (eval @f) - Good or Bad?</source>
      </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Should END-able constructs all use ^META parameters?</title>
    <link>https://rebol.metaeducation.com/t/should-end-able-constructs-all-use-meta-parameters/1783</link>
    <description>If you had a function that took a literal argument in Rebol2, it could be &quot;endable&quot;... *if* it accepted UNSET! as an argument.

This feature was added primarily for HELP, so that you could say either:

    &gt;&gt; help
    ...GENERIC HELP usage information...

    &gt;&gt; help topic
    ... HELP for specific TOPIC...

It was a *very limited form of variadic-ness*...generally used only in console-oriented commands (HELP, LS).

You couldn&#39;t use it with a function that was evaluative.  Hence this wasn&#39;t possible:

    redbol&gt;&gt; printer 1 + 2
    3

    redbol&gt;&gt; printer
    You called the PRINTER function with no arguments
        ; ^-- not possible to accomplish with an otherwise evaluative argument!

***So handling missing arguments was tied to taking the argument literally.***

***It was also ambiguous.***  The signal for literal parameters that were endable-and-missing was to make the parameter accept UNSET!.  Which meant they couldn&#39;t tell the difference between `help #[unset!]` and just-plain-`help`:

    red&gt;&gt; help #[unset!]
    To use HELP, supply a word or value as its
    argument:

        help insert
        help system
        help system/script
        ...

## Ren-C Can Resolve the Ambiguity for Literal Arguments

Because antiforms can&#39;t occur in &quot;source&quot; code, a function taking a literal argument could receive an antiform as an unambiguous signal that the end was reached.

Any antiform could serve as that signal (and different options have been tried).  But for the moment let&#39;s say it was the antiform of the word `~end~`:

    &gt;&gt; help ~end~
    ~end~ is a quasiform word!  ; received the quasiform of END

    &gt;&gt; help
    To use HELP, supply a word or value...  ; received the antiform of END

## Normal Evaluative Arguments are Still Ambiguous

When a quasiform evaluates, it produces an antiform.  So we still would have ambiguity if we tried to use the ~end~ antiform:

    &gt;&gt; printer 1 + 2
    Received 3

    &gt;&gt; printer
    Received the antiform of ~end~  

    &gt;&gt; printer ~end~
    Received the antiform of ~end~  

## But ^META Arguments Can Be Unambiguous

Meta-arguments are evaluative, but if the evaluated value is not an antiform, it will just have a quote level added.  Antiforms will be passed as the quasiform.  This means you can never &quot;legitimately&quot; receive an antiform as an argument to a ^META function.

    &gt;&gt; meta-printer 1 + 2
    Received &#39;3

    &gt;&gt; meta-printer first [&#39;3]
    Received &#39;&#39;3

    &gt;&gt; meta-printer ~end~
    Received the quasiform of ~end~

    &gt;&gt; meta-printer first [~end~]
    Received &#39;~end~

So a special rule could be invoked that endable ^META arguments give an antiform to signal the missing parameter:

    &gt;&gt; meta-printer
    Received the antiform of ~end~  

## Should **Only** Literal / ^META Arguments Permit Endability?

The ambiguity for &quot;normal&quot; evaluative arguments only arises if your type checking would allow the antiform.  If your function only accepts INTEGER! (for instance) then the antiform of ~end~ isn&#39;t &quot;in-band&quot;, and it may be more convenient for you to not worry about the ^META convention.

     int-printer: func [arg [&lt;end&gt; integer!]] [
        either arg = ~end~ [
            print &quot;Received end antiform&quot;
        ][
            print [&quot;Received integer:&quot; arg]
        ]
    ]

That seems okay to me.

The system *could* try to stop you from shooting yourself in the foot... so that if you marked a normal parameter as `&lt;end&gt;` it would try to type check an ~end~ antiform against your parameters:

     &gt;&gt; anti-printer: func [arg [&lt;end&gt; antiform?]] [...]
     ** Error: typespec [&lt;end&gt; antiform?] ambiguous for ~end~ antiform

So is that annoying, or helpful?</description>
    
    <lastBuildDate>Tue, 10 Jun 2025 17:36:59 +0000</lastBuildDate>
    <category>Internals</category>
    <atom:link href="https://rebol.metaeducation.com/t/should-end-able-constructs-all-use-meta-parameters/1783.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Should END-able constructs all use ^META parameters?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="1783">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Devil's in the Details</p>
</blockquote>
</aside>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/face_with_head_bandage.png?v=14" title=":face_with_head_bandage:" class="emoji only-emoji" alt=":face_with_head_bandage:" loading="lazy" width="20" height="20"></p>
<p>Due to <strong><a href="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477">LIFT the UNIVERSE</a></strong>, ^META arguments no longer leave room in the "unlifted" band for special states to indicate <code>&lt;end&gt;</code> or "unspecialized".  Because all variables are stored "lifted", and "unlifted" when fetched.  <em>The point of distinction is merely whether a FRAME! gets them automatically decayed before the lift</em>.</p>
<p>So the only way to go any "lower"  in representation than what arguments can be is the "dual band"...special states that can't be reached with SET or GET.  This is the home of getters, setters, type checkers, aliases... AAAAND <strong>"true unset"</strong>... the unspecialized state.</p>
<p>So the questions here are:</p>
<ol>
<li>
<p>Do we want more than one <em>true unset</em> state in the dual band, to account for END as distinct from regular "left unspecialized"?</p>
</li>
<li>
<p>For parameters that can't be antiforms (literal args from the callsite) is it worth it to try and exploit that to use what would normally in-band as NULL to make it easier to test as <strong><code>if not var</code></strong> vs. using <strong><code>unset? $var</code></strong></p>
</li>
</ol>
<h2><a name="p-8409-h-1-no-2-no-1" class="anchor" href="https://rebol.metaeducation.com#p-8409-h-1-no-2-no-1"></a>(1. No)  (2. No.)</h2>
<p>It seems to me that just letting the true unset state cover this is the best plan.</p>
<p>If you mark a parameter as <code>&lt;end&gt;</code>-able (maybe not the best name for the attribute... <code>&lt;unset&gt;</code> may actually be the right name for it, now that there's a state that's "not even SET") then it should be tested with <code>(unset? $x)</code></p>
          <p><a href="https://rebol.metaeducation.com/t/should-end-able-constructs-all-use-meta-parameters/1783/6">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/should-end-able-constructs-all-use-meta-parameters/1783/6</link>
        <pubDate>Tue, 10 Jun 2025 17:36:59 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1783-6</guid>
        <source url="https://rebol.metaeducation.com/t/should-end-able-constructs-all-use-meta-parameters/1783.rss">Should END-able constructs all use ^META parameters?</source>
      </item>
      <item>
        <title>Should END-able constructs all use ^META parameters?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1783">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Because antiforms can't occur in "source" code, a function taking a literal argument could receive an antiform as an unambiguous signal that the end was reached.</p>
<p><strong>Any antiform could serve as that signal (and different options have been tried).</strong> But for the moment let's say it was the antiform of the word <code>~end~</code>:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; help ~end~
~end~ is a quasiform word!  ; received the quasiform of END

&gt;&gt; help
To use HELP, supply a word or value...  ; received the antiform of END
</code></pre>
</blockquote>
</aside>
<p>So I want to talk briefly about this choice for the "end signaling antiform", and how that ties into <a href="https://rebol.metaeducation.com/t/default-values-and-make-frame-2024-edition/2347">"default values and make frame!"</a></p>
<hr>
<p>Right now, when you do <strong><code>make frame!</code></strong> you get a copy of a frame with all the unspecialized slots (e.g. PARAMETER!) initialized to trash (<code>~</code> antiforms):</p>
<pre><code>&gt;&gt; frame: make frame! either/
== #[frame! [
    condition: ~
    okay-branch: ~
    null-branch: ~
]]
</code></pre>
<p><em>(Quick reminder that although what's shown there are quasiform blanks, the convention is that you interpret <strong><code>foo: xxx</code></strong> as meaning the FOO field actually holds what xxx evaluates to.  So <strong><code>condition: ~</code></strong> means that the CONDITION field holds the evaluative product of the <code>~</code> quasiform, e.g. the <code>~</code> antiform... an "unset!" if you prefer to think of it that way.)</em></p>
<p>The question on the table relates to whether normal evaluative parameters are able to receive "trash" or not.  So let's imagine I did this:</p>
<pre><code>&gt;&gt; frame.okay-branch: [print "truthy"]
&gt;&gt; frame.null-branch: [print "falsey"]

&gt;&gt; eval frame
; ...is this an error?  prints truthy?  prints falsey?
</code></pre>
<p>In the current paradigm, it's an error:</p>
<pre><code>&gt;&gt; eval frame
** Script Error: either has condition unspecified (~ antiform)
</code></pre>
<p>So the rule is that "trash" is the <em>one</em> stable antiform which you can't accept as a normal argument.</p>
<p>If this is truly the case, it would <em>seem</em> like the obvious candidate for signaling an <code>&lt;end&gt;</code>, as the state is already reserved in all cases...</p>
<h2><a name="p-8009-or-is-end-a-different-intent-from-unspecified-1" class="anchor" href="https://rebol.metaeducation.com#p-8009-or-is-end-a-different-intent-from-unspecified-1"></a>...or is <code>&lt;END&gt;</code> a different intent from <code>Unspecified</code>?</h2>
<p>More accurately, the question is: "<em>Even if</em> there's a difference in intent, is it worth it for overall system complexity to have a separate antiform and handling?"</p>
<p>Because clearly when an end of evaluator input is reached, all subsequent argument gathering is also at the end.  Whereas unspecified parameters in a frame can occur in any order.</p>
<p>(e.g. I didn't assign the condition field of the EITHER frame above, but then filled in both branches.  That's impossible in left-to-right fulfillment to mean "the end was reached at the condition")</p>
<p>Hmmm.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8009-case-study-make-frame-on-variadic-input-2" class="anchor" href="https://rebol.metaeducation.com#p-8009-case-study-make-frame-on-variadic-input-2"></a>Case Study: MAKE FRAME! on Variadic Input</h2>
<p>There's an experimental variation of SWITCH that allows you to use partial expressions:</p>
<pre><code>&gt;&gt; switch2 1020 [match integer! =&gt; [#i], match tag! =&gt; [#t]]
== #i
</code></pre>
<p>So here you see an arity-2 function (MATCH) receiving only one argument.  And the SWITCH2 fulfills the missing argument:</p>
<p>How it works is that the evaluator is called on the incomplete expression, and then writes an <code>~end~</code> antiform into any slots that are at the end:</p>
<pre><code>&gt;&gt; frame: make frame! [match integer!]
== #[frame! [
    test: &amp;[integer!]
    value: ~end~
]]
</code></pre>
<p>Today that's conflated: you'd get the same thing if you wrote:</p>
<pre><code>&gt;&gt; frame: make frame! [match integer! ~end~]
== #[frame! [
    test: &amp;[integer!]
    value: ~end~
]]
</code></pre>
<p>So it seems like an improvement if the situation was:</p>
<pre><code>&gt;&gt; frame: make frame! [match integer!]
== #[frame! [
    test: &amp;[integer!]
    value: ~
]]

&gt;&gt; frame: make frame! [match integer! ~]
** Script Error: match can't take (~ antiform) at callsite
</code></pre>
<p>The deal would just be that you can't take ~ antiforms at the callsite unless the parameter is ^META (which means you'd receive the parameter as a ~ quasiform, still leaving the ~ antiform free for unspecified-ness).</p>
<h2><a name="p-8009-could-typechecking-trash-replace-the-end-flag-3" class="anchor" href="https://rebol.metaeducation.com#p-8009-could-typechecking-trash-replace-the-end-flag-3"></a>Could Typechecking "Trash" Replace The <code>&lt;end&gt;</code> Flag?</h2>
<p>Imagine if a parameter typechecks against the trash antiform, then we assume it is "unspecifyable".  So not assigning it in a frame... or reaching the end of an input evaluation... however you do it, it's all right to receive as a trash antiform.</p>
<p>But if it's driven by typechecking alone, then it's actually the ^META parameters that get mucked up.  Because if they say they typecheck the trash antiform, they (historically) mean they will receive evaluative trash arguments as meta-trash.</p>
<p>So one of these things would have to be true in such a world:</p>
<ol>
<li>
<p>^META parameters can't be endable/unspecifyable</p>
</li>
<li>
<p>^META parameters which accept evaluative trash conflate it with unspecifyability</p>
</li>
<li>
<p>^META parameters can't accept evaluative trash, and typechecking it means unspecifyable</p>
</li>
</ol>
<p>[1] is right out.  ^META is an expansive parameter convention when you've hit the limits of what a normal parameter can do.  It needs to be strictly more powerful.</p>
<p>[2] and [3] seem to involve unpleasant tradeoffs.</p>
<p>Consider <strong><code>(set var ~)</code></strong>   I think that needs to work, because <strong><code>(var): ~</code></strong> works  And SET has to take its value argument as ^META (for other reasons, like skipping the assignment and propagating definitonal errors).  But this shouldn't imply that <strong><code>(set var)</code></strong> works.</p>
<p>In conclusion, unspecifyability needs to be a separate flag from typechecking.</p>
<h2><a name="p-8009-what-to-call-unspecifyability-end-feels-wrong-now-4" class="anchor" href="https://rebol.metaeducation.com#p-8009-what-to-call-unspecifyability-end-feels-wrong-now-4"></a>What To Call Unspecifyability?  <code>&lt;end&gt;</code> Feels Wrong Now</h2>
<p>I've been calling refinements "optional" parameters.  e.g. "<code>:DUP</code> is an optional argument to <code>APPEND</code>"</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; append.dup.optional
== ~okay~  ; anti
</code></pre>
<p>But maybe I should stick with the name "refinement".  And this idea of being willing to be left unspecified is <code>&lt;opt&gt;</code>... <em>true optionality</em>.  Like, you can literally omit it from the callsite.</p>
<p>It creates a little bit of a problem, because not specifying a refinement in a MAKE FRAME! situation--leaving it as trash--has meant that refinement argument will be set to NULL when the function runs.</p>
<p><a href="https://rebol.metaeducation.com/t/simplifying-refinement-promotion/2338/2">But an alternative perspective on MAKE FRAME!</a> would remove the unused refinements:</p>
<pre><code>&gt;&gt; make frame! append/
== #[frame! [
    series: ~
    value: ~
]]
</code></pre>
<p>I proposed what has traditionally been thought of as MAKE FRAME! be some other operator.  But maybe that operator doesn't leave things as antiform trash, yet rather sets them to null?</p>
<pre><code>&gt;&gt; XXX append/
== #[frame! [
    series: ~null~
    value: ~null~
    part: ~null~
    dup: ~null~
    line: ~null~
]]
</code></pre>
<p>This could get rid of the concept that typechecking ever morphs <code>~</code> antiforms into anything else.  And FWIW, could mean that there could be such a thing as an optional refinement--not that I can think of any actual applications of such a thing.</p>
<h2><a name="p-8009-devils-in-the-details-but-5" class="anchor" href="https://rebol.metaeducation.com#p-8009-devils-in-the-details-but-5"></a>Devil's in the Details, but...</h2>
<p>Regardless of what happens, I do think I like moving away from "endability" to "unspecifyability".</p>
<p><em>Seems</em> fairly elegant.  It's also in line with Carl's <a href="http://www.rebol.net/r3blogs/0318.html"><strong>"UNSET! is not first class"</strong></a> proclamation:</p>
<blockquote>
<p><strong>It's important to understand the unset! datatype; otherwise, we run the risk of assuming that it is <em>first class</em> (assignable, passable, returnable) when it's really not intended for that kind of usage!</strong></p>
</blockquote>
<p>...although assignment is one of those "meta" circumstances where it's better to allow than disallow.  While comparison and such don't count, though you can "meta-compare" an unset.</p>
<pre><code>&gt;&gt; if ^(print "hi") = '~ [print "meta-comparison works!"]
hi
meta-comparison works!
</code></pre>
          <p><a href="https://rebol.metaeducation.com/t/should-end-able-constructs-all-use-meta-parameters/1783/5">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/should-end-able-constructs-all-use-meta-parameters/1783/5</link>
        <pubDate>Mon, 13 Jan 2025 21:30:56 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1783-5</guid>
        <source url="https://rebol.metaeducation.com/t/should-end-able-constructs-all-use-meta-parameters/1783.rss">Should END-able constructs all use ^META parameters?</source>
      </item>
      <item>
        <title>Should END-able constructs all use ^META parameters?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>If you had a function that took a literal argument in Rebol2, it could be "endable"... <em>if</em> it accepted UNSET! as an argument.</p>
<p>This feature was added primarily for HELP, so that you could say either:</p>
<pre><code>&gt;&gt; help
...GENERIC HELP usage information...

&gt;&gt; help topic
... HELP for specific TOPIC...
</code></pre>
<p>It was a <em>very limited form of variadic-ness</em>...generally used only in console-oriented commands (HELP, LS).</p>
<p>You couldn't use it with a function that was evaluative.  Hence this wasn't possible:</p>
<pre><code>redbol&gt;&gt; printer 1 + 2
3

redbol&gt;&gt; printer
You called the PRINTER function with no arguments
    ; ^-- not possible to accomplish with an otherwise evaluative argument!
</code></pre>
<p><em><strong>So handling missing arguments was tied to taking the argument literally.</strong></em></p>
<p><em><strong>It was also ambiguous.</strong></em>  The signal for literal parameters that were endable-and-missing was to make the parameter accept UNSET!.  Which meant they couldn't tell the difference between <code>help #[unset!]</code> and just-plain-<code>help</code>:</p>
<pre><code>red&gt;&gt; help #[unset!]
To use HELP, supply a word or value as its
argument:

    help insert
    help system
    help system/script
    ...
</code></pre>
<h2><a name="p-5732-ren-c-can-resolve-the-ambiguity-for-literal-arguments-1" class="anchor" href="https://rebol.metaeducation.com#p-5732-ren-c-can-resolve-the-ambiguity-for-literal-arguments-1"></a>Ren-C Can Resolve the Ambiguity for Literal Arguments</h2>
<p>Because antiforms can't occur in "source" code, a function taking a literal argument could receive an antiform as an unambiguous signal that the end was reached.</p>
<p>Any antiform could serve as that signal (and different options have been tried).  But for the moment let's say it was the antiform of the word <code>~end~</code>:</p>
<pre><code>&gt;&gt; help ~end~
~end~ is a quasiform word!  ; received the quasiform of END

&gt;&gt; help
To use HELP, supply a word or value...  ; received the antiform of END
</code></pre>
<h2><a name="p-5732-normal-evaluative-arguments-are-still-ambiguous-2" class="anchor" href="https://rebol.metaeducation.com#p-5732-normal-evaluative-arguments-are-still-ambiguous-2"></a>Normal Evaluative Arguments are Still Ambiguous</h2>
<p>When a quasiform evaluates, it produces an antiform.  So we still would have ambiguity if we tried to use the ~end~ antiform:</p>
<pre><code>&gt;&gt; printer 1 + 2
Received 3

&gt;&gt; printer
Received the antiform of ~end~  

&gt;&gt; printer ~end~
Received the antiform of ~end~  
</code></pre>
<h2><a name="p-5732-but-meta-arguments-can-be-unambiguous-3" class="anchor" href="https://rebol.metaeducation.com#p-5732-but-meta-arguments-can-be-unambiguous-3"></a>But ^META Arguments Can Be Unambiguous</h2>
<p>Meta-arguments are evaluative, but if the evaluated value is not an antiform, it will just have a quote level added.  Antiforms will be passed as the quasiform.  This means you can never "legitimately" receive an antiform as an argument to a ^META function.</p>
<pre><code>&gt;&gt; meta-printer 1 + 2
Received '3

&gt;&gt; meta-printer first ['3]
Received ''3

&gt;&gt; meta-printer ~end~
Received the quasiform of ~end~

&gt;&gt; meta-printer first [~end~]
Received '~end~
</code></pre>
<p>So a special rule could be invoked that endable ^META arguments give an antiform to signal the missing parameter:</p>
<pre><code>&gt;&gt; meta-printer
Received the antiform of ~end~  
</code></pre>
<h2><a name="p-5732-should-only-literal-meta-arguments-permit-endability-4" class="anchor" href="https://rebol.metaeducation.com#p-5732-should-only-literal-meta-arguments-permit-endability-4"></a>Should <strong>Only</strong> Literal / ^META Arguments Permit Endability?</h2>
<p>The ambiguity for "normal" evaluative arguments only arises if your type checking would allow the antiform.  If your function only accepts INTEGER! (for instance) then the antiform of ~end~ isn't "in-band", and it may be more convenient for you to not worry about the ^META convention.</p>
<pre><code> int-printer: func [arg [&lt;end&gt; integer!]] [
    either arg = ~end~ [
        print "Received end antiform"
    ][
        print ["Received integer:" arg]
    ]
]
</code></pre>
<p>That seems okay to me.</p>
<p>The system <em>could</em> try to stop you from shooting yourself in the foot... so that if you marked a normal parameter as <code>&lt;end&gt;</code> it would try to type check an ~end~ antiform against your parameters:</p>
<pre><code> &gt;&gt; anti-printer: func [arg [&lt;end&gt; antiform?]] [...]
 ** Error: typespec [&lt;end&gt; antiform?] ambiguous for ~end~ antiform
</code></pre>
<p>So is that annoying, or helpful?</p>
          <p><a href="https://rebol.metaeducation.com/t/should-end-able-constructs-all-use-meta-parameters/1783/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/should-end-able-constructs-all-use-meta-parameters/1783/1</link>
        <pubDate>Fri, 21 Jan 2022 17:01:03 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1783-1</guid>
        <source url="https://rebol.metaeducation.com/t/should-end-able-constructs-all-use-meta-parameters/1783.rss">Should END-able constructs all use ^META parameters?</source>
      </item>
  </channel>
</rss>

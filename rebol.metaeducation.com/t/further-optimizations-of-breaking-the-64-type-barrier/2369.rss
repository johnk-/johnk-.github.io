<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Further Optimizations Of Breaking the 64-Type Barrier</title>
    <link>https://rebol.metaeducation.com/t/further-optimizations-of-breaking-the-64-type-barrier/2369</link>
    <description>Historical Rebol/Red are limited to 64 datatypes.  It&#39;s not because there isn&#39;t space in the cells to store more (e.g. 256 in a header byte) -- but because TYPESET! wanted to fit into a Cell&#39;s payload, as a 64-bit integer to sparsely convey an arbitrary collection of bits in a typeset.

Ren-C made the bold move away from typesets into **type predicates**... arbitrary functions that can check more than just the type.  So you can take an argument and demand it be EVEN?, for instance...

I&#39;ve discussed how this made it critical to be able to call functions like EVEN? or SPLICE? *very quickly*.  A big part of that is **[Intrinsics: Functions Without Frames](https://rebol.metaeducation.com/t/intrinsics-functions-without-frames/2050)**.

What&#39;s really neat about the ability to call intrinsics super fast is that it doesn&#39;t only apply in type checking.  Ordinary evaluation gets accelerated as well, e.g. you can write **if even? number [...]** and it uses the same magic that turbocharges typechecks. 

*(Note: All intrinsics are stylized in such a way that they can be called non-intrinsically if need be.  In fact, the debug build sporadically calls intrinsics non-intrinsically to make sure they still work.  This would be needed if you wanted a stepwise debugger, so that it didn&#39;t seem to eerily skip functions every time an intrinsic dodged making a frame.)*

## A Key Optimization: 4 or 8 PARAMETER! Bytes

The PARAMETER! dataype&#39;s Cell has 4 spare bytes on 32-bit platforms, and 8 spare bytes on 64-bit platforms. So this gave me an idea to have a numbered list of up to 255 built-in intrinsics.  There&#39;d be a one-time analysis of the argument spec to see if you used any of those 255 common type checks, and if you did then it would encode that in the bytes so you wouldn&#39;t have to actually call the function--you could just run the test the function would do.

So let&#39;s say you said: **`[integer! any-list?]`**.  It would recognize these as being in the built in list (INTEGER! equivalent to the INTEGER? constraint).  And you would get an optimized byte sequence like **`{2, 76, 0}`**.  (0 is reserved for indicating a premature end, but if you&#39;re on a 32 bit platform and it sees 4 values with no 0 it knows they all apply... and if you&#39;re on a 64-bit platform and it sees 8 values with no 0 it knows they all apply.  Only a single bit is needed to mark &quot;incomplete optimizations&quot; where it has to run through the typeset array.)

There&#39;s a special bit set on the cells in the array for the typeset to say that they were accounted for by the optimization.  This means if you can&#39;t fully optimize the array (either because you have too many types to check for the 4 or 8 bytes, or because you used constraints that aren&#39;t in the built in list) then it still knows it can skip past the optimized constraint when it&#39;s walking the array to test the outliers.

Here is a list of the optimized bytes so far (not up to 255 yet!)

    blank 1
    integer 2
    decimal 3
    percent 4
    pair 5
    money 6
    time 7
    date 8
    parameter 9
    bitset 10
    map 11
    handle 12
    blob 13
    text 14
    file 15
    tag 16
    url 17
    email 18
    issue 19
    sigil 20
    varargs 21
    object 22
    module 23
    error 24
    port 25
    frame 26
    word 27
    meta-word 28
    type-word 29
    the-word 30
    var-word 31
    tuple 32
    meta-tuple 33
    type-tuple 34
    the-tuple 35
    var-tuple 36
    chain 37
    meta-chain 38
    type-chain 39
    the-chain 40
    var-chain 41
    path 42
    meta-path 43
    type-path 44
    the-path 45
    var-path 46
    block 47
    meta-block 48
    type-block 49
    the-block 50
    var-block 51
    fence 52
    meta-fence 53
    type-fence 54
    the-fence 55
    var-fence 56
    group 57
    meta-group 58
    type-group 59
    the-group 60
    var-group 61
    comma 62
    quasiform 63
    quoted 64
    antiform 65
    any-string 66
    any-context 67
    any-word 68
    any-tuple 69
    any-chain 70
    any-path 71
    any-sequence 72
    any-block 73
    any-fence 74
    any-group 75
    any-list 76
    any-bindable 77
    any-unit 78
    any-inert 79
    any-isotopic 80
    any-number 81
    any-scalar 82
    any-sequencable 83
    any-series 84
    any-utf8 85
    any-branch 86
    any-plain-value 87
    any-meta-value 88
    any-type-value 89
    any-the-value 90
    any-var-value 91
    any-element 92


*(I&#39;m now planning to have separate type bytes for all antiform categories instead of all being REB_ANTIFORM, which will help in internal code as well as make accelerators here, so that will probably chew up a pretty large range since it will likely just be the type byte multiplied by 2...so imagine 64 more of these being used up in the near term.  I&#39;m sure there could be clever uses for the gaps, if you can truly guarantee a type will never be isotopic...)*

## Removing Generality To Boost Performance

My first cut at implementing this tried to be very general.  I had a table of up to 255 C function pointers that took a Cell as an argument, and returned a boolean.  This meant basically any constraint could be optimized... like EVEN?, because it had not only the type (e.g. INTEGER!) but it had the full cell it could pick apart:

    bool Optimized_Even_Checker(Cell* cell) {
        if (Cell_Type(cell) != REB_INTEGER)
            return false;
       return VAL_INT64(cell) % 2 == 0;
    }

But as you see from the table above, I&#39;d only gotten around to automating the construction of the table based on information in `%types.r`.  So all the functions did was test the cell&#39;s type.  There were three kinds of checkers:

    bool Optimized_Integer_Checker(Cell* cell) {  // single datatype
        return Cell_Type(cell) == REB_INTEGER;
    }

    bool Optimized_Any_List_Checker(Cell* cell) {  // datatype range
        Type type = Cell_Type(cell);
        return type &gt;= REB_BLOCK and type &lt;= REB_VAR_GROUP;
    }

    bool Optimized_Any_Scalar_Checker(Cell* cell) {  // sparse typeset
        Type type = Cell_Type(cell);
        return g_sparse_memberships[type] &amp; TYPESET_FLAG_SCALAR;
    }

So what you see is that the way that the type bytes are numbered, sometimes you can check for typeset membership by just seeing if it&#39;s in a certain range.  [Careful arrangement of `%types.r`](https://github.com/hostilefork/ren-c/blob/4e64ae1652ea5efd603549f35850b11cf0a22068/src/boot/types.r#L211-L237) means that&#39;s possible for a lot of checks.

But if something doesn&#39;t fit that model, there&#39;s another table of sparse typeset flags put together.  I&#39;ve limited the number of sparse typesets to 31--and I&#39;ll explain why--but there&#39;s only 13 of them so far.

## Let&#39;s Do Some Slight Transformations

Let&#39;s say that we decide that anything that can&#39;t be checked by datatype alone we&#39;re willing to call as an (often intrinsic) function.  So we&#39;re willing to pass the type in and not have each function recalculate it.

ALSO: Let&#39;s say that we want to collapse datatype checking to just be a trivial case of range checking, where the start and end of the range are the same.

    bool Optimized_Integer_Checker(Type type) {  // trivial range
        return type &gt;= REB_INTEGER and type &lt;= REB_INTEGER;
    }

    bool Optimized_Any_List_Checker(Type type) {  // non-trivial range
        return type &gt;= REB_BLOCK and type &lt;= REB_VAR_GROUP;
    }

    bool Optimized_Any_Scalar_Checker(Type type) {  // sparse
        return g_sparse_memberships[type] &amp; TYPESET_FLAG_SCALAR;
    }

That&#39;s interesting... but why are we calling a function at all?  What if we drop the function pointers and just make the table be the information?

...BUT... :thinking: what if there&#39;s a bit reserved, let&#39;s say TYPESET_FLAG_0_RANGE, which we use to indicate the table entry has two bytes of range information, start and finish.  **and if that bit is not set, then the table entry has a single TYPESET_FLAG_XXX for the flag you need to test in the sparse table!**

    INLINE bool Builtin_Typeset_Check(TypesetByte typeset_byte, Type type) {
        TypesetFlags typeset = g_typesets[typeset_byte];

        if (typeset &amp; TYPESET_FLAG_0_RANGE) {  // trivial ranges ok (one datatype)
            Byte start = THIRD_BYTE(&amp;typeset);
            Byte end = FOURTH_BYTE(&amp;typeset);
            return start &lt;= type and type &lt;= end;  // note: type converts to Byte
        }

        return did (g_sparse_memberships[type] &amp; typeset);  // just a typeset flag
    }

**You don&#39;t even have to shift a datatype to do the check.**  Where historical Rebol required a 64-bit shift, the flag you need to test against is just waiting for you in the array (and sparse memberships only needs a 32-bit integer).

Blazing through a list of these typechecks is very efficient.

## So Why Not Use This For Generic Dispatch?

When I realized I could now hum through a table of &quot;fancy-sounding&quot; type constraints like ANY-SERIES? or ANY-SCALAR? and not break a sweat, it made me think this is a perfect way to deal with the methodization of generics.

All I had to do was order the type checks from specific to more general, run the checks in sorted order, and everything from molding to comparison to multiplication could be dispatched at as fine a granularity as you want.

You write in the source your implementations wherever you want, like:

    #define IMPLEMENT_GENERIC(name,type) \
        Bounce g_##name##_##type(Level* level_)  // e.g. g_APPEND_Any_List

    IMPLEMENT_GENERIC(LESSER_Q, Is_Integer)  // LESSER? -&gt; LESSER_Q in C
    { ... }

    IMPLEMENT_GENERIC(LESSER_Q, Any_Context)
    { ... }

Then the build process packages that all up into a table, with the constraint byte in order:

    #define GENERIC_CFUNC(name,type)  G_##name##_##type

    GenericTable g_generic_lesser_q[] = {
        {2, &amp;GENERIC_CFUNC(LESSER_Q, Is_Integer)},  // =&gt; {2, &amp;g_LESSER_Q_Is_Integer}
        {3, &amp;GENERIC_CFUNC(LESSER_Q, Is_Decimal)},
        {6, &amp;GENERIC_CFUNC(LESSER_Q, Is_Money)},
        {7, &amp;GENERIC_CFUNC(LESSER_Q, Is_Time)},
        {8, &amp;GENERIC_CFUNC(LESSER_Q, Is_Date)},
        {10, &amp;GENERIC_CFUNC(LESSER_Q, Is_Bitset)},
        {13, &amp;GENERIC_CFUNC(LESSER_Q, Is_Blob)},
        {26, &amp;GENERIC_CFUNC(LESSER_Q, Is_Frame)},
        {67, &amp;GENERIC_CFUNC(LESSER_Q, Any_Context)},
        {72, &amp;GENERIC_CFUNC(LESSER_Q, Any_Sequence)},
        {76, &amp;GENERIC_CFUNC(LESSER_Q, Any_List)},
        {85, &amp;GENERIC_CFUNC(LESSER_Q, Any_Utf8)},
        {92, &amp;GENERIC_CFUNC(LESSER_Q, Any_Element)},
        {0, nullptr}
    };

Then the dispatch is as fast as heck!  Remember that the compiler inlines this so it&#39;s not calling a `Builtin_Typeset_Check()` function each time through the loop, it&#39;s generating micro-optimized code:

    #define Dispatch_Generic(name,cue,L) \
        Dispatch_Generic_Core(g_generic_##name, Cell_Type(cue), (L))

    Bounce Dispatch_Generic_Core(
        GenericTable* table,
        Type type,
        Level* level
    ){
        for (; table-&gt;typeset_byte != 0; ++table) {
            if (Builtin_Typeset_Check(table-&gt;typeset_byte, type))
                return table-&gt;dispatcher(level);
        }

        return FAIL(&quot;No dispatcher for datatype of generic&quot;);
    }

Notice how this has the fallthrough to ANY-ELEMENT?, so if you pass something that&#39;s unhandled you can still do a baseline handler!

*(I&#39;m considering making it possible to do something like `return PASS` and have it continue bubbling down the chain, but not jumping the gun on features just yet... you can explicitly call a handler via `GENERIC_CFUNC(generic, type)` if you want, and that doesn&#39;t add cost to every dispatch, so I&#39;m seeing how far it goes.)*

## Goodbye [Stupid R3-Alphalike switch() Statements!](https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/t-string.c#L464-L494)

This trounces the old means of specifying dispatch and subclassing and overriding.

R3-Alpha had cryptic information, with a bunch of **`*`** and **`-`** and **`f+`** stuff:

https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/boot/types.r#L51-L57

But at the end of the day you were usually stuck with an all-or-nothing... if you said that a GROUP! handled APPEND the same way that a BLOCK! handled append, you wound up having to say that *all* generics routed through ANY-LIST?.  They had the same entry point for everything else.

This breaks that all wide open, with granular overriding.  And blows away the 64 type limit.  And with the native entry point available to generics you can do common processing before any generic runs, to enforce things like commutativity in addition and multiplication, etc...

    //
    //  /multiply: native:generic [
    //
    //  &quot;Returns the second value multiplied by the first&quot;
    //
    //      return: [any-scalar?]
    //      value1 [any-scalar?]
    //      value2 [any-scalar?]
    //  ]
    //
    DECLARE_NATIVE(multiply)
    //
    // 1. Most languages want multiplication to be commutative (exceptions like
    //    matrix multiplication do exist, though that likely should be a different
    //    operation and reserve MULTIPLY for element-wise multiplication).  To
    //    ensure commutativity, we swap the arguments if their heart bytes are
    //    not in &quot;canon order&quot;.
    //
    //    (Using the HEART_BYTE as the canon order is a bit of a hack, as the
    //    table can be reordered.  But we try to order the types in %types.r
    //    such that more complex types come later, so that we dispatch to the
    //    more complex type...e.g. multiplying a PAIR! by a DECIMAL! should
    //    should dispatch to the PAIR! code.)
    {
        INCLUDE_PARAMS_OF_MULTIPLY;

        Value* v1 = ARG(value1);
        Value* v2 = ARG(value2);

        if (HEART_BYTE(e1) &lt; HEART_BYTE(e2)) {  // simpler type is on left [1]
            Move_Cell(SPARE, v2);
            Move_Cell(v2, v1);  // ...so move simpler type to be on the right
            Move_Cell(v1, SPARE);
        }

        return Dispatch_Generic(MULTIPLY, v1, LEVEL);
    }

## Lots to Do, But This Is A Step In The Right Direction</description>
    
    <lastBuildDate>Sun, 16 Mar 2025 20:57:14 +0000</lastBuildDate>
    <category>Optimization</category>
    <atom:link href="https://rebol.metaeducation.com/t/further-optimizations-of-breaking-the-64-type-barrier/2369.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Further Optimizations Of Breaking the 64-Type Barrier</title>
        <dc:creator><![CDATA[BlackATTR]]></dc:creator>
        <description><![CDATA[
            <p>Wild, exciting stuff! Looking great, HF.</p>
          <p><a href="https://rebol.metaeducation.com/t/further-optimizations-of-breaking-the-64-type-barrier/2369/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/further-optimizations-of-breaking-the-64-type-barrier/2369/2</link>
        <pubDate>Sun, 16 Mar 2025 20:57:14 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2369-2</guid>
        <source url="https://rebol.metaeducation.com/t/further-optimizations-of-breaking-the-64-type-barrier/2369.rss">Further Optimizations Of Breaking the 64-Type Barrier</source>
      </item>
      <item>
        <title>Further Optimizations Of Breaking the 64-Type Barrier</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Historical Rebol/Red are limited to 64 datatypes.  It's not because there isn't space in the cells to store more (e.g. 256 in a header byte) -- but because TYPESET! wanted to fit into a Cell's payload, as a 64-bit integer to sparsely convey an arbitrary collection of bits in a typeset.</p>
<p>Ren-C made the bold move away from typesets into <strong>type predicates</strong>... arbitrary functions that can check more than just the type.  So you can take an argument and demand it be EVEN?, for instance...</p>
<p>I've discussed how this made it critical to be able to call functions like EVEN? or SPLICE? <em>very quickly</em>.  A big part of that is <strong><a href="https://rebol.metaeducation.com/t/intrinsics-functions-without-frames/2050">Intrinsics: Functions Without Frames</a></strong>.</p>
<p>What's really neat about the ability to call intrinsics super fast is that it doesn't only apply in type checking.  Ordinary evaluation gets accelerated as well, e.g. you can write <strong>if even? number [...]</strong> and it uses the same magic that turbocharges typechecks.</p>
<p><em>(Note: All intrinsics are stylized in such a way that they can be called non-intrinsically if need be.  In fact, the debug build sporadically calls intrinsics non-intrinsically to make sure they still work.  This would be needed if you wanted a stepwise debugger, so that it didn't seem to eerily skip functions every time an intrinsic dodged making a frame.)</em></p>
<h2><a name="p-8033-a-key-optimization-4-or-8-parameter-bytes-1" class="anchor" href="https://rebol.metaeducation.com#p-8033-a-key-optimization-4-or-8-parameter-bytes-1"></a>A Key Optimization: 4 or 8 PARAMETER! Bytes</h2>
<p>The PARAMETER! dataype's Cell has 4 spare bytes on 32-bit platforms, and 8 spare bytes on 64-bit platforms. So this gave me an idea to have a numbered list of up to 255 built-in intrinsics.  There'd be a one-time analysis of the argument spec to see if you used any of those 255 common type checks, and if you did then it would encode that in the bytes so you wouldn't have to actually call the function--you could just run the test the function would do.</p>
<p>So let's say you said: <strong><code>[integer! any-list?]</code></strong>.  It would recognize these as being in the built in list (INTEGER! equivalent to the INTEGER? constraint).  And you would get an optimized byte sequence like <strong><code>{2, 76, 0}</code></strong>.  (0 is reserved for indicating a premature end, but if you're on a 32 bit platform and it sees 4 values with no 0 it knows they all apply... and if you're on a 64-bit platform and it sees 8 values with no 0 it knows they all apply.  Only a single bit is needed to mark "incomplete optimizations" where it has to run through the typeset array.)</p>
<p>There's a special bit set on the cells in the array for the typeset to say that they were accounted for by the optimization.  This means if you can't fully optimize the array (either because you have too many types to check for the 4 or 8 bytes, or because you used constraints that aren't in the built in list) then it still knows it can skip past the optimized constraint when it's walking the array to test the outliers.</p>
<p>Here is a list of the optimized bytes so far (not up to 255 yet!)</p>
<pre><code>blank 1
integer 2
decimal 3
percent 4
pair 5
money 6
time 7
date 8
parameter 9
bitset 10
map 11
handle 12
blob 13
text 14
file 15
tag 16
url 17
email 18
issue 19
sigil 20
varargs 21
object 22
module 23
error 24
port 25
frame 26
word 27
meta-word 28
type-word 29
the-word 30
var-word 31
tuple 32
meta-tuple 33
type-tuple 34
the-tuple 35
var-tuple 36
chain 37
meta-chain 38
type-chain 39
the-chain 40
var-chain 41
path 42
meta-path 43
type-path 44
the-path 45
var-path 46
block 47
meta-block 48
type-block 49
the-block 50
var-block 51
fence 52
meta-fence 53
type-fence 54
the-fence 55
var-fence 56
group 57
meta-group 58
type-group 59
the-group 60
var-group 61
comma 62
quasiform 63
quoted 64
antiform 65
any-string 66
any-context 67
any-word 68
any-tuple 69
any-chain 70
any-path 71
any-sequence 72
any-block 73
any-fence 74
any-group 75
any-list 76
any-bindable 77
any-unit 78
any-inert 79
any-isotopic 80
any-number 81
any-scalar 82
any-sequencable 83
any-series 84
any-utf8 85
any-branch 86
any-plain-value 87
any-meta-value 88
any-type-value 89
any-the-value 90
any-var-value 91
any-element 92
</code></pre>
<p><em>(I'm now planning to have separate type bytes for all antiform categories instead of all being REB_ANTIFORM, which will help in internal code as well as make accelerators here, so that will probably chew up a pretty large range since it will likely just be the type byte multiplied by 2...so imagine 64 more of these being used up in the near term.  I'm sure there could be clever uses for the gaps, if you can truly guarantee a type will never be isotopic...)</em></p>
<h2><a name="p-8033-removing-generality-to-boost-performance-2" class="anchor" href="https://rebol.metaeducation.com#p-8033-removing-generality-to-boost-performance-2"></a>Removing Generality To Boost Performance</h2>
<p>My first cut at implementing this tried to be very general.  I had a table of up to 255 C function pointers that took a Cell as an argument, and returned a boolean.  This meant basically any constraint could be optimized... like EVEN?, because it had not only the type (e.g. INTEGER!) but it had the full cell it could pick apart:</p>
<pre><code>bool Optimized_Even_Checker(Cell* cell) {
    if (Cell_Type(cell) != REB_INTEGER)
        return false;
   return VAL_INT64(cell) % 2 == 0;
}
</code></pre>
<p>But as you see from the table above, I'd only gotten around to automating the construction of the table based on information in <code>%types.r</code>.  So all the functions did was test the cell's type.  There were three kinds of checkers:</p>
<pre><code>bool Optimized_Integer_Checker(Cell* cell) {  // single datatype
    return Cell_Type(cell) == REB_INTEGER;
}

bool Optimized_Any_List_Checker(Cell* cell) {  // datatype range
    Type type = Cell_Type(cell);
    return type &gt;= REB_BLOCK and type &lt;= REB_VAR_GROUP;
}

bool Optimized_Any_Scalar_Checker(Cell* cell) {  // sparse typeset
    Type type = Cell_Type(cell);
    return g_sparse_memberships[type] &amp; TYPESET_FLAG_SCALAR;
}
</code></pre>
<p>So what you see is that the way that the type bytes are numbered, sometimes you can check for typeset membership by just seeing if it's in a certain range.  <a href="https://github.com/hostilefork/ren-c/blob/4e64ae1652ea5efd603549f35850b11cf0a22068/src/boot/types.r#L211-L237">Careful arrangement of <code>%types.r</code></a> means that's possible for a lot of checks.</p>
<p>But if something doesn't fit that model, there's another table of sparse typeset flags put together.  I've limited the number of sparse typesets to 31--and I'll explain why--but there's only 13 of them so far.</p>
<h2><a name="p-8033-lets-do-some-slight-transformations-3" class="anchor" href="https://rebol.metaeducation.com#p-8033-lets-do-some-slight-transformations-3"></a>Let's Do Some Slight Transformations</h2>
<p>Let's say that we decide that anything that can't be checked by datatype alone we're willing to call as an (often intrinsic) function.  So we're willing to pass the type in and not have each function recalculate it.</p>
<p>ALSO: Let's say that we want to collapse datatype checking to just be a trivial case of range checking, where the start and end of the range are the same.</p>
<pre><code>bool Optimized_Integer_Checker(Type type) {  // trivial range
    return type &gt;= REB_INTEGER and type &lt;= REB_INTEGER;
}

bool Optimized_Any_List_Checker(Type type) {  // non-trivial range
    return type &gt;= REB_BLOCK and type &lt;= REB_VAR_GROUP;
}

bool Optimized_Any_Scalar_Checker(Type type) {  // sparse
    return g_sparse_memberships[type] &amp; TYPESET_FLAG_SCALAR;
}
</code></pre>
<p>That's interesting... but why are we calling a function at all?  What if we drop the function pointers and just make the table be the information?</p>
<p>...BUT... <img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"> what if there's a bit reserved, let's say TYPESET_FLAG_0_RANGE, which we use to indicate the table entry has two bytes of range information, start and finish.  <strong>and if that bit is not set, then the table entry has a single TYPESET_FLAG_XXX for the flag you need to test in the sparse table!</strong></p>
<pre><code>INLINE bool Builtin_Typeset_Check(TypesetByte typeset_byte, Type type) {
    TypesetFlags typeset = g_typesets[typeset_byte];

    if (typeset &amp; TYPESET_FLAG_0_RANGE) {  // trivial ranges ok (one datatype)
        Byte start = THIRD_BYTE(&amp;typeset);
        Byte end = FOURTH_BYTE(&amp;typeset);
        return start &lt;= type and type &lt;= end;  // note: type converts to Byte
    }

    return did (g_sparse_memberships[type] &amp; typeset);  // just a typeset flag
}
</code></pre>
<p><strong>You don't even have to shift a datatype to do the check.</strong>  Where historical Rebol required a 64-bit shift, the flag you need to test against is just waiting for you in the array (and sparse memberships only needs a 32-bit integer).</p>
<p>Blazing through a list of these typechecks is very efficient.</p>
<h2><a name="p-8033-so-why-not-use-this-for-generic-dispatch-4" class="anchor" href="https://rebol.metaeducation.com#p-8033-so-why-not-use-this-for-generic-dispatch-4"></a>So Why Not Use This For Generic Dispatch?</h2>
<p>When I realized I could now hum through a table of "fancy-sounding" type constraints like ANY-SERIES? or ANY-SCALAR? and not break a sweat, it made me think this is a perfect way to deal with the methodization of generics.</p>
<p>All I had to do was order the type checks from specific to more general, run the checks in sorted order, and everything from molding to comparison to multiplication could be dispatched at as fine a granularity as you want.</p>
<p>You write in the source your implementations wherever you want, like:</p>
<pre><code>#define IMPLEMENT_GENERIC(name,type) \
    Bounce g_##name##_##type(Level* level_)  // e.g. g_APPEND_Any_List

IMPLEMENT_GENERIC(LESSER_Q, Is_Integer)  // LESSER? -&gt; LESSER_Q in C
{ ... }

IMPLEMENT_GENERIC(LESSER_Q, Any_Context)
{ ... }
</code></pre>
<p>Then the build process packages that all up into a table, with the constraint byte in order:</p>
<pre><code>#define GENERIC_CFUNC(name,type)  G_##name##_##type

GenericTable g_generic_lesser_q[] = {
    {2, &amp;GENERIC_CFUNC(LESSER_Q, Is_Integer)},  // =&gt; {2, &amp;g_LESSER_Q_Is_Integer}
    {3, &amp;GENERIC_CFUNC(LESSER_Q, Is_Decimal)},
    {6, &amp;GENERIC_CFUNC(LESSER_Q, Is_Money)},
    {7, &amp;GENERIC_CFUNC(LESSER_Q, Is_Time)},
    {8, &amp;GENERIC_CFUNC(LESSER_Q, Is_Date)},
    {10, &amp;GENERIC_CFUNC(LESSER_Q, Is_Bitset)},
    {13, &amp;GENERIC_CFUNC(LESSER_Q, Is_Blob)},
    {26, &amp;GENERIC_CFUNC(LESSER_Q, Is_Frame)},
    {67, &amp;GENERIC_CFUNC(LESSER_Q, Any_Context)},
    {72, &amp;GENERIC_CFUNC(LESSER_Q, Any_Sequence)},
    {76, &amp;GENERIC_CFUNC(LESSER_Q, Any_List)},
    {85, &amp;GENERIC_CFUNC(LESSER_Q, Any_Utf8)},
    {92, &amp;GENERIC_CFUNC(LESSER_Q, Any_Element)},
    {0, nullptr}
};
</code></pre>
<p>Then the dispatch is as fast as heck!  Remember that the compiler inlines this so it's not calling a <code>Builtin_Typeset_Check()</code> function each time through the loop, it's generating micro-optimized code:</p>
<pre><code>#define Dispatch_Generic(name,cue,L) \
    Dispatch_Generic_Core(g_generic_##name, Cell_Type(cue), (L))

Bounce Dispatch_Generic_Core(
    GenericTable* table,
    Type type,
    Level* level
){
    for (; table-&gt;typeset_byte != 0; ++table) {
        if (Builtin_Typeset_Check(table-&gt;typeset_byte, type))
            return table-&gt;dispatcher(level);
    }

    return FAIL("No dispatcher for datatype of generic");
}
</code></pre>
<p>Notice how this has the fallthrough to ANY-ELEMENT?, so if you pass something that's unhandled you can still do a baseline handler!</p>
<p><em>(I'm considering making it possible to do something like <code>return PASS</code> and have it continue bubbling down the chain, but not jumping the gun on features just yet... you can explicitly call a handler via <code>GENERIC_CFUNC(generic, type)</code> if you want, and that doesn't add cost to every dispatch, so I'm seeing how far it goes.)</em></p>
<h2><a name="p-8033-goodbye-stupid-r3-alphalike-switch-statementshttpsgithubcomrebolrebolblob25033f897b2bd466068d7663563cd3ff64740b94srccoret-stringcl464-l494-5" class="anchor" href="https://rebol.metaeducation.com#p-8033-goodbye-stupid-r3-alphalike-switch-statementshttpsgithubcomrebolrebolblob25033f897b2bd466068d7663563cd3ff64740b94srccoret-stringcl464-l494-5"></a>Goodbye <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/t-string.c#L464-L494">Stupid R3-Alphalike switch() Statements!</a></h2>
<p>This trounces the old means of specifying dispatch and subclassing and overriding.</p>
<p>R3-Alpha had cryptic information, with a bunch of <strong><code>*</code></strong> and <strong><code>-</code></strong> and <strong><code>f+</code></strong> stuff:</p>
<aside class="onebox githubblob" data-onebox-src="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/boot/types.r#L51-L57">
  <header class="source">

      <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/boot/types.r#L51-L57" target="_blank" rel="noopener">github.com/rebol/rebol</a>
  </header>

  <article class="onebox-body">
    <h4><a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/boot/types.r#L51-L57" target="_blank" rel="noopener">src/boot/types.r</a></h4>

<div class="git-blob-info">
  <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/boot/types.r#L51-L57" rel="noopener"><code>25033f897</code></a>
</div>



    <pre class="onebox"><code class="lang-r">
      <ol class="start lines" start="51" style="counter-reset: li-counter 50 ;">
          <li>	email       self        string      +        f*      *      *   [series string]  </li>
          <li>	url         self        string      +        f*      file   *   [series string]</li>
          <li>	tag         self        string      +        +       *      *   [series string]  </li>
          <li></li>
          <li>	bitset      self        bitset      *        *       *      *   -</li>
          <li>	image       self        image       +        +       *      *   series</li>
          <li>	vector      self        vector      -        -       *      *   series  </li>
      </ol>
    </code></pre>



  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>But at the end of the day you were usually stuck with an all-or-nothing... if you said that a GROUP! handled APPEND the same way that a BLOCK! handled append, you wound up having to say that <em>all</em> generics routed through ANY-LIST?.  They had the same entry point for everything else.</p>
<p>This breaks that all wide open, with granular overriding.  And blows away the 64 type limit.  And with the native entry point available to generics you can do common processing before any generic runs, to enforce things like commutativity in addition and multiplication, etc...</p>
<pre><code>//
//  /multiply: native:generic [
//
//  "Returns the second value multiplied by the first"
//
//      return: [any-scalar?]
//      value1 [any-scalar?]
//      value2 [any-scalar?]
//  ]
//
DECLARE_NATIVE(multiply)
//
// 1. Most languages want multiplication to be commutative (exceptions like
//    matrix multiplication do exist, though that likely should be a different
//    operation and reserve MULTIPLY for element-wise multiplication).  To
//    ensure commutativity, we swap the arguments if their heart bytes are
//    not in "canon order".
//
//    (Using the HEART_BYTE as the canon order is a bit of a hack, as the
//    table can be reordered.  But we try to order the types in %types.r
//    such that more complex types come later, so that we dispatch to the
//    more complex type...e.g. multiplying a PAIR! by a DECIMAL! should
//    should dispatch to the PAIR! code.)
{
    INCLUDE_PARAMS_OF_MULTIPLY;

    Value* v1 = ARG(value1);
    Value* v2 = ARG(value2);

    if (HEART_BYTE(e1) &lt; HEART_BYTE(e2)) {  // simpler type is on left [1]
        Move_Cell(SPARE, v2);
        Move_Cell(v2, v1);  // ...so move simpler type to be on the right
        Move_Cell(v1, SPARE);
    }

    return Dispatch_Generic(MULTIPLY, v1, LEVEL);
}
</code></pre>
<h2><a name="p-8033-lots-to-do-but-this-is-a-step-in-the-right-direction-6" class="anchor" href="https://rebol.metaeducation.com#p-8033-lots-to-do-but-this-is-a-step-in-the-right-direction-6"></a>Lots to Do, But This Is A Step In The Right Direction</h2>
          <p><a href="https://rebol.metaeducation.com/t/further-optimizations-of-breaking-the-64-type-barrier/2369/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/further-optimizations-of-breaking-the-64-type-barrier/2369/1</link>
        <pubDate>Sun, 16 Mar 2025 20:28:38 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2369-1</guid>
        <source url="https://rebol.metaeducation.com/t/further-optimizations-of-breaking-the-64-type-barrier/2369.rss">Further Optimizations Of Breaking the 64-Type Barrier</source>
      </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Should &quot;Exotic Fields&quot; Be Able To Examine PACK! ?</title>
    <link>https://rebol.metaeducation.com/t/should-exotic-fields-be-able-to-examine-pack/2432</link>
    <description>The general pitch of unstable block antiforms is that they decay to their first element in assignments to single words:

    &gt;&gt; x: pack [1 2]
    == ~[&#39;1 &#39;2]~  ; anti

    &gt;&gt; x
    == 1

SET-BLOCK! is one of the things that is able to do special handling to pick apart the pack:

    &gt;&gt; [x y]: pack [1 2]
    == ~[&#39;1 &#39;2]~  ; anti

    &gt;&gt; x
    == 1

    &gt;&gt; y
    == 2

But you can create your own operators that work with packs... they&#39;re just antiform blocks, after all.  If you take an argument as ^META and typecheck for packs you can do whatever you like.  You could re-implement the functionality of SET-BLOCK! yourself if you felt like it, designing whatever you want:

    &gt;&gt; my-10times-assigner [x y] pack [1 2]
    == ~[&#39;1 &#39;2]~

    &gt;&gt; x
    == 10

    &gt;&gt; y
    == 20

## But Should Plain Assignments Ever Process Packs?

e.g. should this hypothetical PACK-SUMMER! be possible, which assigns the sum of pack elements?

     &gt;&gt; type of ps
     == ~{pack-summer!}~

     &gt;&gt; ps.x: pack [10 20]
     == ~[&#39;10 &#39;20]~

     &gt;&gt; ps.x
     == 30  ; e.g. the assignment received 10 + 20

You can imagine other ideas, such as reacting to raised errors somehow, vs. having an enforced pattern of skipping the assignment and propagating the raise.  :face_with_diagonal_mouth: 

## [Freedom To vs. Freedom From](http://blog.hostilefork.com/freedom-to-and-freedom-from/)

**This doesn&#39;t seem like a wise axis of extensibility to me.**

The possible benefits appear outweighed by the loss of certainty about how things will act.

It also means doing minor transformations would wreck things.

     &gt;&gt; temp: pack [10 20]
     == 10

     &gt;&gt; ps.x: temp
     == 10

But while that may seem damning, it&#39;s the case for any time a function takes an unstable antiform... you can&#39;t factor the expression and expect it to work the same.  To truly preserve things, you have to do lift and unlift.

    &gt;&gt; temp: lift pack [10 20]
    == ~[&#39;10 &#39;20]~

    &gt;&gt; ps.x: unlift temp
    == ~[&#39;10 &#39;20]~  ; anti

    &gt;&gt; ps.x
    == 30

But still... I just don&#39;t think I like the idea of having what looks like an assignment be able to subvert the expectations that you&#39;re taking decayed information.

The one exception I am making is for the empty ~[]~ antiform, which indicates a desire to remove the key itself.  So the assignment (POKE) protocol gets 0 or 1 values.  I think that one exception is enough.</description>
    
    <lastBuildDate>Tue, 10 Jun 2025 20:00:22 +0000</lastBuildDate>
    <category>Semantics</category>
    <atom:link href="https://rebol.metaeducation.com/t/should-exotic-fields-be-able-to-examine-pack/2432.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Should &quot;Exotic Fields&quot; Be Able To Examine PACK! ?</title>
        <dc:creator><![CDATA[rebolbot]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2432">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But I don't need psychic powers to tell you that ACCESSOR, GETTER, SETTER are going to be used to implement people's arbitrary wacky ideas. Maybe I should ask the AIs if there are good examples.</p>
</blockquote>
</aside>
<p>Your thinking is right on the money—once you allow generalized or overridable accessors (e.g. customizable <code>get</code> and <code>set</code> hooks), you're opening a pretty powerful and potentially unpredictable axis. Rebol’s goal of flexibility puts it in the same category as other dynamic and extensible languages like Python, Ruby, Lua, and Smalltalk, all of which have wrestled with similar questions.</p>
<h3><a name="p-8411-key-principles-and-guidance-in-other-languages-1" class="anchor" href="https://rebol.metaeducation.com#p-8411-key-principles-and-guidance-in-other-languages-1"></a><img src="https://rebol.metaeducation.com/images/emoji/twitter/puzzle_piece.png?v=14" title=":puzzle_piece:" class="emoji" alt=":puzzle_piece:" loading="lazy" width="20" height="20"> Key Principles and Guidance in Other Languages</h3>
<h4><a name="p-8411-h-1-python-__getattr__-__setattr__-property-2" class="anchor" href="https://rebol.metaeducation.com#p-8411-h-1-python-__getattr__-__setattr__-property-2"></a><strong>1. Python (<code>__getattr__</code>, <code>__setattr__</code>, <code>property</code>)</strong></h4>
<p>Python’s <code>property</code> mechanism, along with <code>__getattr__</code> and <code>__setattr__</code>, allow fine-grained interception of attribute access. The design philosophy is generally:</p>
<ul>
<li><strong>Guidance</strong>: Properties should behave <em>as much like normal attributes as possible</em>. Python’s Zen (PEP 20) includes <em>"Special cases aren't special enough to break the rules"</em> and <em>"In the face of ambiguity, refuse the temptation to guess."</em></li>
<li><strong>"Respectable" abuses</strong>: Some libraries override <code>__setattr__</code> to implement reactive programming (e.g. Traits, or GUI toolkits like Kivy). Others use <code>__getattr__</code> to implement delegation (e.g., forwarding to another object).</li>
<li><strong>Gotchas</strong>: "Magical" behavior is frowned upon in core Python culture. Overuse of properties or dynamic dispatch can confuse debugging or introspection.</li>
</ul>
<h4><a name="p-8411-h-2-javascript-es6-proxies-3" class="anchor" href="https://rebol.metaeducation.com#p-8411-h-2-javascript-es6-proxies-3"></a><strong>2. JavaScript (ES6 Proxies)</strong></h4>
<p>JavaScript’s <code>Proxy</code> is a more radical extensibility mechanism.</p>
<ul>
<li><strong>Guidance</strong>: The documentation is surprisingly permissive. MDN mostly warns: <em>"Use with care"</em>, since proxies can break invariants.</li>
<li><strong>"Respectable" abuses</strong>: Frameworks like Vue.js use proxies for reactive data binding. Also used in mocking frameworks and remote object access (e.g. implementing RPC).</li>
<li><strong>Notable abuses</strong>: Overriding every trap (e.g. <code>get</code>, <code>set</code>, <code>has</code>, <code>ownKeys</code>) to produce surreal behavior that breaks expectations—like making an array that has no length but still returns elements.</li>
</ul>
<h4><a name="p-8411-h-3-ruby-method_missing-define_method-attr_-4" class="anchor" href="https://rebol.metaeducation.com#p-8411-h-3-ruby-method_missing-define_method-attr_-4"></a><strong>3. Ruby (<code>method_missing</code>, <code>define_method</code>, <code>attr_*</code>)</strong></h4>
<p>Ruby’s metaprogramming is quite powerful and commonly used.</p>
<ul>
<li><strong>Guidance</strong>: Emphasizes "principle of least surprise". Rubyists often tolerate a bit more magic, but it should remain intuitive for humans.</li>
<li><strong>"Respectable" abuses</strong>: <code>method_missing</code> is used by Rails’s ActiveRecord to implement dynamic finders like <code>find_by_name_and_age</code>. It’s accepted despite being a kind of "lies to the interpreter" trick.</li>
<li><strong>Risks</strong>: Performance costs, fragile stack traces, and harder tooling (e.g., autocompletion, static analysis).</li>
</ul>
<h4><a name="p-8411-h-4-lua-__index-__newindex-metatables-5" class="anchor" href="https://rebol.metaeducation.com#p-8411-h-4-lua-__index-__newindex-metatables-5"></a><strong>4. Lua (<code>__index</code>, <code>__newindex</code> metatables)</strong></h4>
<p>Lua’s metatables let you intercept almost anything.</p>
<ul>
<li><strong>Guidance</strong>: Lua's documentation often avoids strong norms and lets you explore, but <em>"don't be surprised if you shoot yourself in the foot."</em></li>
<li><strong>"Respectable" abuses</strong>: Transparent proxying, lazy-loading fields, implementing classes/inheritance.</li>
<li><strong>Common pitfalls</strong>: Debuggability, accidentally triggering infinite recursion.</li>
</ul>
<hr>
<h3><a name="p-8411-guidance-you-might-offer-in-your-language-6" class="anchor" href="https://rebol.metaeducation.com#p-8411-guidance-you-might-offer-in-your-language-6"></a><img src="https://rebol.metaeducation.com/images/emoji/twitter/compass.png?v=14" title=":compass:" class="emoji" alt=":compass:" loading="lazy" width="20" height="20"> Guidance You Might Offer in Your Language</h3>
<p>Given your control of the language and philosophy, you might consider offering the following principles:</p>
<ol>
<li><strong>Predictability Rule</strong><br>
“Accessor overrides should behave as if you were reading or writing a normal variable, unless you clearly document why not.”</li>
<li><strong>Value-Preservation Is a Goal, Not a Guarantee</strong><br>
“Assignments must evaluate to the value being assigned, but you are not required to preserve it in the backing store. However, if your abstraction behaves like a variable, consider round-trip fidelity important.”</li>
<li><strong>The Principle of Least Magic</strong><br>
“Avoid designs where the result of a fetch bears no discernible relation to what was assigned, unless modeling something where that surprise is intrinsic (e.g. time-varying state, remote resources).”</li>
<li><strong>Use ‘Lie Detectors’ When Lying</strong><br>
“If you make a value look like a field but it’s a computation or a transformation, consider exposing metadata or debug tools to make that visible.”</li>
<li><strong>Safe Mutation by Convention</strong><br>
Encourage idioms where destructive changes (e.g. setting <code>env.PATH</code>) return a confirmation or log metadata—e.g. <code>env.PATH: %/somewhere/</code> returns <code>%/somewhere/ (unchanged)</code> or a mutation result token.</li>
<li><strong>Immutability/Historicity by Option</strong><br>
Support patterns where a <code>SET</code> doesn't truly overwrite, but maybe pushes a version to a stack or journal, so behavior is rational and inspectable.</li>
</ol>
<hr>
<h3><a name="p-8411-respectable-abuses-you-might-embrace-7" class="anchor" href="https://rebol.metaeducation.com#p-8411-respectable-abuses-you-might-embrace-7"></a><img src="https://rebol.metaeducation.com/images/emoji/twitter/brain.png?v=14" title=":brain:" class="emoji" alt=":brain:" loading="lazy" width="20" height="20"> “Respectable Abuses” You Might Embrace</h3>
<ul>
<li><strong>Aggregation/Reduction Setters</strong><br>
Assigning <code>[10 20]</code> and then reading back <code>30</code> could be fine if the name implies it (<code>summer.x</code>)—think of it like a <em>mini DSL</em>. Lua folks often do this for numeric reductions.</li>
<li><strong>Reactive Triggers</strong><br>
Allow assignments to trigger actions, not just mutate state. Like spreadsheets: setting <code>cell.A1</code> might cause <code>cell.B1</code> to update.</li>
<li><strong>Virtual Fields</strong><br>
<code>foo.temperature_c</code> could be an alias for <code>foo.temperature_f</code>, with a getter/setter converting the units. Many languages do this.</li>
<li><strong>Remote/Deferred Fields</strong><br>
Assignments might schedule or buffer a change (e.g., sending a remote signal), not commit it immediately.</li>
</ul>
<hr>
<p>You’re in a good position to create a healthy culture by framing this extensibility not as "go nuts", but as "opt-in powers with cultural norms." Offer escape hatches, but teach people to look for handles.</p>
<p>Would you like a summary with examples of best practices, common traps, or clever/legit abuses to include in your language docs?</p>
          <p><a href="https://rebol.metaeducation.com/t/should-exotic-fields-be-able-to-examine-pack/2432/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/should-exotic-fields-be-able-to-examine-pack/2432/3</link>
        <pubDate>Tue, 10 Jun 2025 20:00:22 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2432-3</guid>
        <source url="https://rebol.metaeducation.com/t/should-exotic-fields-be-able-to-examine-pack/2432.rss">Should &quot;Exotic Fields&quot; Be Able To Examine PACK! ?</source>
      </item>
      <item>
        <title>Should &quot;Exotic Fields&quot; Be Able To Examine PACK! ?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="2432">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>Should Plain Assignments Ever Process <strike>Packs</strike> Unstable Antiforms?</strong></p>
<p>e.g. should this hypothetical PACK-SUMMER! be possible, which assigns the sum of pack elements?</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext"> &gt;&gt; type of ps
 == ~{pack-summer!}~

 &gt;&gt; ps.x: pack [10 20]
 == ~['10 '20]~

 &gt;&gt; ps.x
 == 30  ; e.g. the assignment received 10 + 20
</code></pre>
</blockquote>
</aside>
<p>I'm finding that many questions seem to be answered by <strong><a href="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477">LIFT the UNIVERSE</a></strong>.  The answers additionally seem to be mostly good.</p>
<p><strong>Here it wouldn't be possible, unless you use ^META assignments, in which it is <em>the explicit job</em> of those sinks to decide if they're willing to store the unstable antiform or not.</strong>  (e.g. BLOCK!s don't, OBJECT!s do, etc.)</p>
<p>Your hypothetical pack-summer <em>could</em> exist, it would just have to say <strong><code>ps.^x: pack [10 20]</code></strong> to receive the unstable form.</p>
<p>SHOULD it exist?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20">  I don't think so.</p>
<p>The low-level assignment operator <em>presumes</em> you stored the bits as given.  But this could change for any reason.. e.g. if you assign <strong><code>env.PATH: %some-path/</code></strong> the synthesized value of that expression witll always match the right hand side.  But other processes could run and <code>env.PATH</code> could give another value entirely on the next fetch.</p>
<p>Your pack-summer would similarly not be able to make the result of <strong><code>ps.^x: pack [10 20]</code></strong> return anything other than the <code>pack [10 20]</code>, because that's the contract of the assignment operator and beyond the control of the target.  But the next time you ask for <strong><code>ps.x</code></strong> I guess it can say whatever it wants... including but not limited to the sum of the members of the last assignment's pack.</p>
<p><strong>Until I can think of a good counterexample, I don't think that assignments should be explicitly looking for ways to "get creative" at doing things that don't model value-preserving assignment.</strong></p>
<p>Yet if you use a ^META assignment, then essential to the design is that it can see unstable isotopes now.  I can't think of a good way to stop anyone from implementing features that don't model assignments... <em>besides asking nicely not to.</em></p>
<p>But I don't need psychic powers to tell you that ACCESSOR, GETTER, SETTER are going to be used to implement people's arbitrary wacky ideas.  Maybe I should ask the AIs if there are good examples.</p>
          <p><a href="https://rebol.metaeducation.com/t/should-exotic-fields-be-able-to-examine-pack/2432/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/should-exotic-fields-be-able-to-examine-pack/2432/2</link>
        <pubDate>Tue, 10 Jun 2025 19:49:36 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2432-2</guid>
        <source url="https://rebol.metaeducation.com/t/should-exotic-fields-be-able-to-examine-pack/2432.rss">Should &quot;Exotic Fields&quot; Be Able To Examine PACK! ?</source>
      </item>
      <item>
        <title>Should &quot;Exotic Fields&quot; Be Able To Examine PACK! ?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>The general pitch of unstable block antiforms is that they decay to their first element in assignments to single words:</p>
<pre><code>&gt;&gt; x: pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; x
== 1
</code></pre>
<p>SET-BLOCK! is one of the things that is able to do special handling to pick apart the pack:</p>
<pre><code>&gt;&gt; [x y]: pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; x
== 1

&gt;&gt; y
== 2
</code></pre>
<p>But you can create your own operators that work with packs... they're just antiform blocks, after all.  If you take an argument as ^META and typecheck for packs you can do whatever you like.  You could re-implement the functionality of SET-BLOCK! yourself if you felt like it, designing whatever you want:</p>
<pre><code>&gt;&gt; my-10times-assigner [x y] pack [1 2]
== ~['1 '2]~

&gt;&gt; x
== 10

&gt;&gt; y
== 20
</code></pre>
<h2><a name="p-8196-but-should-plain-assignments-ever-process-packs-1" class="anchor" href="https://rebol.metaeducation.com#p-8196-but-should-plain-assignments-ever-process-packs-1"></a>But Should Plain Assignments Ever Process Packs?</h2>
<p>e.g. should this hypothetical PACK-SUMMER! be possible, which assigns the sum of pack elements?</p>
<pre><code> &gt;&gt; type of ps
 == ~{pack-summer!}~

 &gt;&gt; ps.x: pack [10 20]
 == ~['10 '20]~

 &gt;&gt; ps.x
 == 30  ; e.g. the assignment received 10 + 20
</code></pre>
<p>You can imagine other ideas, such as reacting to raised errors somehow, vs. having an enforced pattern of skipping the assignment and propagating the raise.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/face_with_diagonal_mouth.png?v=14" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8196-freedom-to-vs-freedom-fromhttpbloghostileforkcomfreedom-to-and-freedom-from-2" class="anchor" href="https://rebol.metaeducation.com#p-8196-freedom-to-vs-freedom-fromhttpbloghostileforkcomfreedom-to-and-freedom-from-2"></a><a href="http://blog.hostilefork.com/freedom-to-and-freedom-from/">Freedom To vs. Freedom From</a></h2>
<p><strong>This doesn't seem like a wise axis of extensibility to me.</strong></p>
<p>The possible benefits appear outweighed by the loss of certainty about how things will act.</p>
<p>It also means doing minor transformations would wreck things.</p>
<pre><code> &gt;&gt; temp: pack [10 20]
 == 10

 &gt;&gt; ps.x: temp
 == 10
</code></pre>
<p>But while that may seem damning, it's the case for any time a function takes an unstable antiform... you can't factor the expression and expect it to work the same.  To truly preserve things, you have to do lift and unlift.</p>
<pre><code>&gt;&gt; temp: lift pack [10 20]
== ~['10 '20]~

&gt;&gt; ps.x: unlift temp
== ~['10 '20]~  ; anti

&gt;&gt; ps.x
== 30
</code></pre>
<p>But still... I just don't think I like the idea of having what looks like an assignment be able to subvert the expectations that you're taking decayed information.</p>
<p>The one exception I am making is for the empty ~[]~ antiform, which indicates a desire to remove the key itself.  So the assignment (POKE) protocol gets 0 or 1 values.  I think that one exception is enough.</p>
          <p><a href="https://rebol.metaeducation.com/t/should-exotic-fields-be-able-to-examine-pack/2432/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/should-exotic-fields-be-able-to-examine-pack/2432/1</link>
        <pubDate>Fri, 02 May 2025 17:58:11 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2432-1</guid>
        <source url="https://rebol.metaeducation.com/t/should-exotic-fields-be-able-to-examine-pack/2432.rss">Should &quot;Exotic Fields&quot; Be Able To Examine PACK! ?</source>
      </item>
  </channel>
</rss>

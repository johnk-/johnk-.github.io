<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Multiply Linked Lists</title>
    <link>https://rebol.metaeducation.com/t/multiply-linked-lists/1441</link>
    <description>Since I&#39;m having a spitballing vibe, here&#39;s another proposal for a NODE! datatype.

In developing my [Markup Parser](https://github.com/rgchris/Scripts/blob/master/experimental/markup.reb), I settled on a method of tree-building in which I used linked lists with nodes having five relationships: **parent**, **previous/next sibling** and **first/last child**. For this, I used blocks with bi-directional links for each relationship.

# Preamble

```
&lt;html&gt;
  &lt;head&gt;
  &lt;body&gt;
&lt;/html&gt;
```

In this example (ignoring whitespace/text), there are three elements (I&#39;ll call nodes). I&#39;ll use blocks to represent each node:

```
; prototype
node: [parent _ back _ next _ first _ last _ name _]

; nodes
html: copy node
head: copy node
body: copy node

; names
html/name: &lt;html&gt;
head/name: &lt;head&gt;
body/name: &lt;body&gt;

; relationships
html/first: body/back: head
html/last: head/next: body
head/parent: body/parent: html
```

The advantage to this is in being able to reference nodes without losing that reference if other nodes are added/removed post-facto—quite common even when building a tree from HTML tokens:

```
; remove &lt;head&gt;
html/first: body
body/back: _
head/parent: head/back: head/next: _

; add &lt;foot&gt;
foot: copy node
foot/name: &lt;foot&gt;
head/last: body/next: foot

; body is still &lt;body&gt;
body = &lt;body&gt;  ; =&gt; true
```

## Un-Rebol-like

With the myriad circular references, this becomes unlike any other Rebol data structure—it&#39;s difficult to get a helicopter view of the relationships on account of the number of circular references. Then the other issues inherent in Linked Lists, such as having to walk the list to get the size, etc.

## Inefficient?

In the current BLOCK! based system, it&#39;s not clear how efficient all these circular references are or even just the cost of using names in the name-value pairings over potentially hundreds/thousands/more nodes.

# Proposal

I&#39;d like to float the idea of a NODE! datatype, which in memory is a six value-slot object with **parent/back/next/first/last** and **value** slots. It&#39;s only purpose would be to optimise for this case. With it would come a few efficiencies.

Management could come in the form of a small object with helper functions that managed the relationships:

```text
; creation
html: make node! &lt;html&gt;
head: tree/append html &lt;head&gt;
body: tree/append html &lt;body&gt;

; reflection
value of html/last  ; =&gt; &lt;body&gt;
value of head/parent  ; =&gt; &lt;html&gt;

; manipulation
tree/insert-after &lt;body&gt; &lt;foot&gt;
tree/remove head

; reflection ii
value of body  ; =&gt; &lt;body&gt;
body/back  ; =&gt; _
html/first  ; =&gt; &lt;body&gt;
html/last  ; =&gt; &lt;foot&gt;
value of head  ; =&gt; &lt;head&gt;  ; still exists
head/parent  ; =&gt; _
head/next  ; =&gt; _
```

Coupled with my [Class proposal](https://rebol.metaeducation.com/t/class-an-alternative-to-method/1440), this would (I&#39;d suppose) represent the lightest weight, yet versatile, representation of trees.

```text
html: make html-element &lt;html&gt;
head: tree/append html make html-element &lt;head&gt;
body: tree/insert-after head make html-element &lt;body&gt;
```

## Display

A display of the node would use shorthand for the value of each relationship in place of Rebol&#39;s usual `[...]` circular replacement.

```
&gt;&gt; probe body
== make node! [
    parent: &lt;html&gt;
    back: _
    next: &lt;foot&gt;
    first: _
    last: _
    value: &lt;body&gt;
]
```

## Thoughts

I don&#39;t think it&#39;d get around the inconvenience or inefficiency of, say, counting the number of direct kids, but the other benefits would make up for it.

NODE! could similarly be used in conventional linked lists or doubly linked lists by just leaving the other four/three relationships respectively blank.

-----

A correction: not every relationship is bi-directional. Every node (except the root) connects to its parent, the parent only connects to the first and last of its kids</description>
    
    <lastBuildDate>Mon, 23 Jun 2025 13:13:18 +0000</lastBuildDate>
    <category>Datatypes</category>
    <atom:link href="https://rebol.metaeducation.com/t/multiply-linked-lists/1441.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Multiply Linked Lists</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="rgchris" data-post="6" data-topic="1441">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>NODE! type proposal for Red</p>
</blockquote>
</aside>
<p>So I've decided to evolve GOB! into NODE!, and I'll see what I can do to follow this proposal.</p>
<p>The weird efficiency attempts in GOB! to do compression that are sort of non-sequiturs could be done "for real" in NODE!.</p>
<p><em>(As an indicator of my seriousness of doing this, I'm changing the "universal base class" name of the internal type from <code>Node</code> to <code>Base</code>, and NODE_FLAG_XXX is becoming BASE_FLAG_XXX.  This way there isn't contention for the word "Node" and it can be used for NODE!'s implementation.)</em></p>
          <p><a href="https://rebol.metaeducation.com/t/multiply-linked-lists/1441/10">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/multiply-linked-lists/1441/10</link>
        <pubDate>Mon, 23 Jun 2025 04:05:55 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1441-10</guid>
        <source url="https://rebol.metaeducation.com/t/multiply-linked-lists/1441.rss">Multiply Linked Lists</source>
      </item>
      <item>
        <title>Multiply Linked Lists</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="rgchris" data-post="4" data-topic="1441">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>It's only one (or three) application(s), but it's a bit of a doozy. It's a pattern that is imo. worth optimizing for the sheer breadth of that application, though I wouldn't hazard to say how much of what I propose optimizes over using the aforementioned block structure I currently use.</p>
</blockquote>
</aside>
<p>So I'm warming up to the idea of this (in particular because Extension Data types are working well now).</p>
<aside class="quote no-group" data-username="rgchris" data-post="4" data-topic="1441">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I am eternally naive, but I wouldn't see it as being a lot of code. There's not a lot of logic to it and I wouldn't propose that of itself it'd be all that interoperable with other datatypes (not much by way of TO anything). My current Rebol implementation is about a hundred or so explicit lines of code. What I'd envisage is just cutting out the BLOCK! middleman.</p>
</blockquote>
</aside>
<p>It's similar to GOB!, though GOB! tried to do weird compressions that were specific to the needs of the GUI.</p>
<p>I was working on resurrecting all the extensions, including GOB!... "just because".  Perhaps it could/should evolve into this NODE! idea.</p>
          <p><a href="https://rebol.metaeducation.com/t/multiply-linked-lists/1441/8">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/multiply-linked-lists/1441/8</link>
        <pubDate>Tue, 20 May 2025 00:22:55 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1441-8</guid>
        <source url="https://rebol.metaeducation.com/t/multiply-linked-lists/1441.rss">Multiply Linked Lists</source>
      </item>
      <item>
        <title>Multiply Linked Lists</title>
        <dc:creator><![CDATA[rgchris]]></dc:creator>
        <description><![CDATA[
            <p><a href="https://github.com/red/REP/issues/57">NODE! type proposal for Red</a></p>
          <p><a href="https://rebol.metaeducation.com/t/multiply-linked-lists/1441/6">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/multiply-linked-lists/1441/6</link>
        <pubDate>Wed, 10 Mar 2021 16:49:40 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1441-6</guid>
        <source url="https://rebol.metaeducation.com/t/multiply-linked-lists/1441.rss">Multiply Linked Lists</source>
      </item>
      <item>
        <title>Multiply Linked Lists</title>
        <dc:creator><![CDATA[rgchris]]></dc:creator>
        <description><![CDATA[
            <p>Yes!</p>
<aside class="quote no-group" data-username="BlackATTR" data-post="3" data-topic="1441">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/blackattr/48/204_2.png" class="avatar"> BlackATTR:</div>
<blockquote>
<p>would probably be a substantial undertaking to implement a feature like this</p>
</blockquote>
</aside>
<p>I don't know that this is necessarily true, although again, I may be naive here. The tree management code I have is not significant in size but is versatile—it's just that it can slow things down when operating at scale. My main proposition here is creating the most efficient container and basic tools.</p>
<p>If you look at the <a href="https://github.com/rgchris/Scripts/blob/master/experimental/markup.reb#L1951-L2094">TREES object in Markup.reb</a>, there is enough management here in 150 LOC to make the implementation of the <a href="https://github.com/rgchris/Scripts/blob/master/experimental/markup.reb#L2557-L2686">Adoption Agency algorithm</a> [<a href="https://html.spec.whatwg.org/multipage/parsing.html#adoption-agency-algorithm">spec</a>] reasonably literate.</p>
          <p><a href="https://rebol.metaeducation.com/t/multiply-linked-lists/1441/5">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/multiply-linked-lists/1441/5</link>
        <pubDate>Thu, 24 Dec 2020 18:59:51 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1441-5</guid>
        <source url="https://rebol.metaeducation.com/t/multiply-linked-lists/1441.rss">Multiply Linked Lists</source>
      </item>
      <item>
        <title>Multiply Linked Lists</title>
        <dc:creator><![CDATA[rgchris]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1441">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>An easy interface with the browser DOM is very desirable.</p>
</blockquote>
</aside>
<p>To be clear, this wouldn't be to interface with the DOM, this would be to build DOM and other structures internally (not only for use within the browser).</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1441">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>We should be careful of trying to design generic data structures which have only one most likely application (e.g. DOM representation),</p>
</blockquote>
</aside>
<p>It's only one (or three) application(s), but it's a bit of a doozy. It's a pattern that is imo. worth optimizing for the sheer breadth of that application, though I wouldn't hazard to say how much of what I propose optimizes over using the aforementioned block structure I currently use.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1441">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>wind up with a lot of C code, and then find it doesn't even do that one thing particularly well.</p>
</blockquote>
</aside>
<p>I am eternally naive, but I wouldn't see it as being a lot of code. There's not a lot of logic to it and I wouldn't propose that of itself it'd be all that interoperable with other datatypes (not much by way of TO anything). My current Rebol implementation is about a hundred or so explicit lines of code. What I'd envisage is just cutting out the BLOCK! middleman.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1441">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Since you're now doing some hacking on the JS build, you might want to take a step back from the idea of the low-level mimicry of JS methods</p>
</blockquote>
</aside>
<p>This proposal is unrelated to any work with JS, this has been on my mind since working on the Markup parser. It just happens to dovetail with the Class idea as two significant efficiencies on creating and manipulating such structures.</p>
          <p><a href="https://rebol.metaeducation.com/t/multiply-linked-lists/1441/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/multiply-linked-lists/1441/4</link>
        <pubDate>Thu, 24 Dec 2020 18:47:36 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1441-4</guid>
        <source url="https://rebol.metaeducation.com/t/multiply-linked-lists/1441.rss">Multiply Linked Lists</source>
      </item>
      <item>
        <title>Multiply Linked Lists</title>
        <dc:creator><![CDATA[BlackATTR]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1441">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>We should be careful of trying to design generic data structures which have only one most likely application (e.g. DOM representation)</p>
</blockquote>
</aside>
<p>I'd wager this is relevant in many more cases than the DOM. Speaking with my file-munging hat on, what Chris described applies to many forms of structured data. While XML and JSON often encode basic lists of data, it's also common to see taxonomies, ontologies, graphs etc. where relationships between nodes is relevant/important.</p>
<p>Although would probably be a substantial undertaking to implement a feature like this, I thought I'd back-up the idea. Being able to deftly handle relationships and interconnectedness of data is a topic worthy of discussion.</p>
<p>Btw, the jQuery example looks great.</p>
          <p><a href="https://rebol.metaeducation.com/t/multiply-linked-lists/1441/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/multiply-linked-lists/1441/3</link>
        <pubDate>Thu, 24 Dec 2020 14:19:07 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1441-3</guid>
        <source url="https://rebol.metaeducation.com/t/multiply-linked-lists/1441.rss">Multiply Linked Lists</source>
      </item>
      <item>
        <title>Multiply Linked Lists</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>An easy interface with the browser DOM is very desirable.  The best place to start experimenting with that is inside the browser...where the actual DOM is relatively near-at-hand.</p>
<p><em>(To reference a DOM object right now, you have to go through a mapping table, e.g. the JavaScript keeps a table mapping integers to DOM objects...and you hold references to those integers, always going back to through that table and asking JS to do things for you with it.  That sucks, but <a href="https://stackoverflow.com/questions/62587845/wasm-dom-access-and-reference-types">they are working on it with something called Reference types</a>.  It's a burden to bear, but at least it's predictable...and if you abstract it then only the person writing the abstraction worries about it.)</em></p>
<p>If a good syntax/dialect and usability is set up and works in the browser, then we might wish to repeat that in code that can run when a browser is not available.  While the GOB! code could maybe be adapted to the purpose, we could wire up a vetted virtual DOM library as an extension.  (The discipline of using C for the core is still important, but C++ can and should be used in extensions for expedience, and any virtual DOM would likely be written in C++.)</p>
<aside class="quote no-group" data-username="rgchris" data-post="1" data-topic="1441">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">html: make html-element &lt;html&gt;
head: tree/append html make html-element &lt;head&gt;
body: tree/insert-after head make html-element &lt;body&gt;
</code></pre>
</blockquote>
</aside>
<p>We should be careful of trying to design generic data structures which have only one most likely application (e.g. DOM representation), wind up with a lot of C code, and then find it doesn't even do that one thing particularly well.</p>
<p>Since you're now doing some hacking on the JS build, you might want to take a step back from the idea of the low-level mimicry of JS methods and instead think about how higher-level Rebolisms might make life easier at a dialect level, and have it spew out a little stream of JavaScript for now.</p>
<p>To keep that focus, I might suggest you start by equating "node" to HTML node and let any grander designs emerge out of that.</p>
<p>We now have <strong>$</strong> as an operator (I've tinkered with it being a variadic form of SHELL, e.g. <strong><code>$ ls -alF</code></strong>...but that was just one use.)  We should be able to rock much harder than jQuery can with that through dialecting.</p>
<pre><code>&gt;&gt; main: $ &lt;html&gt;
; Single HTML node, equivalent to jQuery $("&lt;html&gt;&lt;/html&gt;")

&gt;&gt; div: $ [&lt;div&gt; #some-id .some.class.(var-holding-class) [&lt;span&gt; "Children"]]
; Build from a template

&gt;&gt; div: $ compose [&lt;div&gt; (sub: $ [&lt;span&gt; ...])]
; Perhaps use COMPOSE to get handles to content

&gt;&gt; div: $ [&lt;div&gt; (sub: $ [&lt;span&gt; ...])]
; ...though COMPOSE implicit is likely best, what else would GROUP! be for?

&gt;&gt; $ 'query/ref [...]
; I don't remember much jQuery but you could have methods.  This would be
; better with my "action/object" duality proposal, where $.query/ref can call
; a QUERY function and $/ref calls a different "base" function when not
; subindexed with `.`... but if the function only takes one argument then a
; skippable LIT-WORD! or LIT-PATH! could be a hack for triggering that.

&gt;&gt; $ :[foo bar]
; What might that mean?  I dunno, point is it's dialecting and you'd have
; options for all the types.  Maybe BLOCK! is always a "build" request and
; `$ [&lt;div&gt;]` builds, while `$ &lt;div&gt;` would query and give you back all the
; divs as a collection?
</code></pre>
<p>jQuery has an issue that it has to deal with "un-augmented nodes" and then there are some routines that take "augmented nodes".  They'd have names like <strong>$elem</strong> for the augmented form and <strong>elem</strong> for the low-level one.  But since we're in another language, the augmented nodes would be all we can use.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/man_shrugging.png?v=14" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20">  If you ever use one of these in a call to JS-DO then you'd necessarily want to do the extraction from the map to get the actual element.</p>
<p>It would be important to extract that element for use in JS-EVAL and JS-DO.  So something like my dialecting to extract API handles would be needed:</p>
<aside class="onebox githubpullrequest" data-onebox-src="https://github.com/hostilefork/replpad-js/pull/53">
  <header class="source">

      <a href="https://github.com/hostilefork/replpad-js/pull/53" target="_blank" rel="noopener">github.com/hostilefork/replpad-js</a>
  </header>

  <article class="onebox-body">
    <div class="github-row" data-github-private-repo="false">



    <div class="github-icon-container" title="Pull Request">
      <svg width="60" height="60" class="github-icon" viewBox="0 0 12 16" aria-hidden="true"><path fill-rule="evenodd" d="M11 11.28V5c-.03-.78-.34-1.47-.94-2.06C9.46 2.35 8.78 2.03 8 2H7V0L4 3l3 3V4h1c.27.02.48.11.69.31.21.2.3.42.31.69v6.28A1.993 1.993 0 0 0 10 15a1.993 1.993 0 0 0 1-3.72zm-1 2.92c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2zM4 3c0-1.11-.89-2-2-2a1.993 1.993 0 0 0-1 3.72v6.56A1.993 1.993 0 0 0 2 15a1.993 1.993 0 0 0 1-3.72V4.72c.59-.34 1-.98 1-1.72zm-.8 10c0 .66-.55 1.2-1.2 1.2-.65 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2zM2 4.2C1.34 4.2.8 3.65.8 3c0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2z"></path></svg>
    </div>

  <div class="github-info-container">



      <h4>
        <a href="https://github.com/hostilefork/replpad-js/pull/53" target="_blank" rel="noopener">Dialected JS-EVAL and JS-DO for embedding Rebol Values</a>
      </h4>

    <div class="branches">
      <code>master</code> ← <code>js-eval-dialect</code>
    </div>

      <div class="github-info">
        <div class="date">
          opened <span class="discourse-local-date" data-format="ll" data-date="2019-04-14" data-time="08:38:21" data-timezone="UTC">08:38AM - 14 Apr 19 UTC</span>
        </div>

        <div class="user">
          <a href="https://github.com/hostilefork" target="_blank" rel="noopener">
            <img alt="" src="https://avatars.githubusercontent.com/u/20440?v=4" class="onebox-avatar-inline" width="20" height="20">
            hostilefork
          </a>
        </div>

        <div class="lines" title="1 commits changed 2 files with 106 additions and 8 deletions">
          <a href="https://github.com/hostilefork/replpad-js/pull/53/files" target="_blank" rel="noopener">
            <span class="added">+106</span>
            <span class="removed">-8</span>
          </a>
        </div>
      </div>
  </div>
</div>

  <div class="github-row">
    <p class="github-body-container">This is a fun usage of the new @-types, which lets you refer to Rebol
values mo<span class="show-more-container"><a href="https://github.com/hostilefork/replpad-js/pull/53" target="_blank" rel="noopener" class="show-more">…</a></span><span class="excerpt hidden">re easily in JS-DO and JS-EVAL expressions.  By doing so you
not only save on typing, but it finesses what would be hairy escaping
situations if your only currency was text:

    &gt;&gt; text: { ykcirT" a s'tI}

    &gt;&gt; js-eval [{reb.Spell("reverse",} @text {) + "String" + '"'}]
    == {It's a "Tricky String"}

So what's going on there is it's generating a temporary API handle to
refer to the value fetched from TEXT.  This API handle is then used
literally as one of the arguments to the variadic/evaluating
extraction routines in the API (mixed here with some JavaScript `+`
string concatenation).  The variadic knows to free this handle after
it is done processing it, (so it is like a reb.RELEASING() or reb.R()
handle).

This is more powerful than just treating a block as running
JS-EVAL UNSPACED [...].  But if you want that, you can still use a
plain GROUP!:

    &gt;&gt; text: "gnirob"

    &gt;&gt; js-eval [{"} (reverse text) { group"}]
    == "boring group"

You can use @path/values, @(computed values).  Although INTEGER! Rebol values aren't the best example (since you could pass them fine via their string representations), they'll work too *(just easier to demo in a PR than Blobs for BINARY! and such...)*

    &gt;&gt; x: 1000
    &gt;&gt; y: 20
    &gt;&gt; js-eval [{reb.Unbox(} @(x + y) {)}]
    == 1020

And to make things even more succinct, WORD!s in this dialect can be
used to generate the reb.XXX() calls for you:

    &gt;&gt; x: 1000
    &gt;&gt; js-eval [{20 +} unbox @x]
    == 1020

Currently there's support for UNBOX and SPELL, but this could expand.

(Note: JS-DO and JS-EVAL are similar, except JS-EVAL tries to return a
result to Rebol translated from the JavaScript it is given...and cannot
declare variables in global scope.  See technical notes in the
implementation if interested.)</span></p>
  </div>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>So unboxing one of these <strong><code>$ [&lt;div&gt; ...]</code></strong> DOM elements needs to be able to easily get that element through to JS.</p>
          <p><a href="https://rebol.metaeducation.com/t/multiply-linked-lists/1441/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/multiply-linked-lists/1441/2</link>
        <pubDate>Thu, 24 Dec 2020 07:20:42 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1441-2</guid>
        <source url="https://rebol.metaeducation.com/t/multiply-linked-lists/1441.rss">Multiply Linked Lists</source>
      </item>
      <item>
        <title>Multiply Linked Lists</title>
        <dc:creator><![CDATA[rgchris]]></dc:creator>
        <description><![CDATA[
            <p>Since I'm having a spitballing vibe, here's another proposal for a NODE! datatype.</p>
<p>In developing my <a href="https://github.com/rgchris/Scripts/blob/master/experimental/markup.reb">Markup Parser</a>, I settled on a method of tree-building in which I used linked lists with nodes having five relationships: <strong>parent</strong>, <strong>previous/next sibling</strong> and <strong>first/last child</strong>. For this, I used blocks with bi-directional links for each relationship.</p>
<h1><a name="p-4482-preamble-1" class="anchor" href="https://rebol.metaeducation.com#p-4482-preamble-1"></a>Preamble</h1>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&lt;html&gt;
  &lt;head&gt;
  &lt;body&gt;
&lt;/html&gt;
</code></pre>
<p>In this example (ignoring whitespace/text), there are three elements (I'll call nodes). I'll use blocks to represent each node:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">; prototype
node: [parent _ back _ next _ first _ last _ name _]

; nodes
html: copy node
head: copy node
body: copy node

; names
html/name: &lt;html&gt;
head/name: &lt;head&gt;
body/name: &lt;body&gt;

; relationships
html/first: body/back: head
html/last: head/next: body
head/parent: body/parent: html
</code></pre>
<p>The advantage to this is in being able to reference nodes without losing that reference if other nodes are added/removed post-facto—quite common even when building a tree from HTML tokens:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">; remove &lt;head&gt;
html/first: body
body/back: _
head/parent: head/back: head/next: _

; add &lt;foot&gt;
foot: copy node
foot/name: &lt;foot&gt;
head/last: body/next: foot

; body is still &lt;body&gt;
body = &lt;body&gt;  ; =&gt; true
</code></pre>
<h2><a name="p-4482-un-rebol-like-2" class="anchor" href="https://rebol.metaeducation.com#p-4482-un-rebol-like-2"></a>Un-Rebol-like</h2>
<p>With the myriad circular references, this becomes unlike any other Rebol data structure—it's difficult to get a helicopter view of the relationships on account of the number of circular references. Then the other issues inherent in Linked Lists, such as having to walk the list to get the size, etc.</p>
<h2><a name="p-4482-inefficient-3" class="anchor" href="https://rebol.metaeducation.com#p-4482-inefficient-3"></a>Inefficient?</h2>
<p>In the current BLOCK! based system, it's not clear how efficient all these circular references are or even just the cost of using names in the name-value pairings over potentially hundreds/thousands/more nodes.</p>
<h1><a name="p-4482-proposal-4" class="anchor" href="https://rebol.metaeducation.com#p-4482-proposal-4"></a>Proposal</h1>
<p>I'd like to float the idea of a NODE! datatype, which in memory is a six value-slot object with <strong>parent/back/next/first/last</strong> and <strong>value</strong> slots. It's only purpose would be to optimise for this case. With it would come a few efficiencies.</p>
<p>Management could come in the form of a small object with helper functions that managed the relationships:</p>
<pre><code class="lang-plaintext">; creation
html: make node! &lt;html&gt;
head: tree/append html &lt;head&gt;
body: tree/append html &lt;body&gt;

; reflection
value of html/last  ; =&gt; &lt;body&gt;
value of head/parent  ; =&gt; &lt;html&gt;

; manipulation
tree/insert-after &lt;body&gt; &lt;foot&gt;
tree/remove head

; reflection ii
value of body  ; =&gt; &lt;body&gt;
body/back  ; =&gt; _
html/first  ; =&gt; &lt;body&gt;
html/last  ; =&gt; &lt;foot&gt;
value of head  ; =&gt; &lt;head&gt;  ; still exists
head/parent  ; =&gt; _
head/next  ; =&gt; _
</code></pre>
<p>Coupled with my <a href="https://rebol.metaeducation.com/t/class-an-alternative-to-method/1440">Class proposal</a>, this would (I'd suppose) represent the lightest weight, yet versatile, representation of trees.</p>
<pre><code class="lang-plaintext">html: make html-element &lt;html&gt;
head: tree/append html make html-element &lt;head&gt;
body: tree/insert-after head make html-element &lt;body&gt;
</code></pre>
<h2><a name="p-4482-display-5" class="anchor" href="https://rebol.metaeducation.com#p-4482-display-5"></a>Display</h2>
<p>A display of the node would use shorthand for the value of each relationship in place of Rebol's usual <code>[...]</code> circular replacement.</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; probe body
== make node! [
    parent: &lt;html&gt;
    back: _
    next: &lt;foot&gt;
    first: _
    last: _
    value: &lt;body&gt;
]
</code></pre>
<h2><a name="p-4482-thoughts-6" class="anchor" href="https://rebol.metaeducation.com#p-4482-thoughts-6"></a>Thoughts</h2>
<p>I don't think it'd get around the inconvenience or inefficiency of, say, counting the number of direct kids, but the other benefits would make up for it.</p>
<p>NODE! could similarly be used in conventional linked lists or doubly linked lists by just leaving the other four/three relationships respectively blank.</p>
<hr>
<p>A correction: not every relationship is bi-directional. Every node (except the root) connects to its parent, the parent only connects to the first and last of its kids</p>
          <p><a href="https://rebol.metaeducation.com/t/multiply-linked-lists/1441/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/multiply-linked-lists/1441/1</link>
        <pubDate>Thu, 24 Dec 2020 06:01:27 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1441-1</guid>
        <source url="https://rebol.metaeducation.com/t/multiply-linked-lists/1441.rss">Multiply Linked Lists</source>
      </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Picking Function Arguments By Integer</title>
    <link>https://rebol.metaeducation.com/t/picking-function-arguments-by-integer/2507</link>
    <description>[Having concepts like CHAIN!](https://rebol.metaeducation.com/t/introducingnew-chain-datatype/2226) means there are &quot;set integers&quot; now, which has opened up the possibility for things like:

    sub1000: specialize subtract/ [2: 1000]

This would prevent you from having to specifically know the name of the argument you are specializing.  That seems sensible, given that you don&#39;t need to know the name to call it.

It seems you should also be able to do this with frames:

    &gt;&gt; f: make frame! subtract/

    &gt;&gt; f.1: 1020
    &gt;&gt; f.2: 1000

    &gt;&gt; eval f
    == 20

**It should not work with refinements.**  Rebol2/Red/R3-Alpha expose the implementation detail of what position refinement arguments are in, but it was a bad idea for them... and an even worse idea for Ren-C.

Consider AUGMENT, for example.  Let&#39;s make an arity-3 version of APPEND, that takes an argument to add before appending:

    &gt;&gt; apadd: adapt (augment append/ [num [integer!]]) [
           value: value + num
       ]

    &gt;&gt; apadd [a b c] 1000 20
    == [a b c 1020]

Do take a moment to appreciate how cool that is... AUGMENT creates a function with an expanded specification (but no variation in behavior), and then ADAPT puts in a preamble which uses the added parameter by adding it to the value...before falling through to the ordinary implementation of APPEND.  (ENCLOSE could be used if you had a more complicated idea for what to do that didn&#39;t fit as just an adjustment in a preamble.)

BUT once you&#39;re finished appreciating how cool that is, consider what we want if we make a frame for APADD:

    &gt;&gt; f: make frame! apadd/

    &gt;&gt; f.1: [a b c]
    &gt;&gt; f.2: 1000
    &gt;&gt; f.3: 20

    &gt;&gt; eval f
    == [a b c 1020]

However, consider that it also has refinements available:

    &gt;&gt; apadd:dup [a b c] 1000 20 3
    == [a b c 1020 1020 1020]

**So we see that the new non-refinement argument properly indexes as the 3rd argument, and it could not do that if refinements were INTEGER!-indexed.**  Because if :DUP was something like index 3 in the frame for APPEND originally, it wouldn&#39;t be out of the way of the augmented form.

Seems pretty good, but there are some quirks...

## Lens Matters

I&#39;ve written a bit about **[FRAME! Lensing](https://rebol.metaeducation.com/t/understanding-frame-lensing/1645)**.  It&#39;s not just an efficiency trick...because I wouldn&#39;t know how to implement function composition otherwise.

Because of Lenses, a frame built for a function with the same positionality can expose different interfaces.  Consider our APADD above, imagine specializing the thing you append to:

    &gt;&gt; data: [a b c]

    &gt;&gt; accrue: specialize apadd/ [data]

    &gt;&gt; accrue 1000 20
    == [a b c 1020]

    &gt;&gt; accrue 300 4
    == [a b c 1020 304]

So now, we would hope that ACCRUE thinks of its 1 and 2 parameters as being what APADD thought of as 2 and 3.

    &gt;&gt; f: make frame! accrue/

    &gt;&gt; f.1: 400
    &gt;&gt; f.2: 21

    &gt;&gt; eval f
    == [a b c 1020 304 421]

**Satisfying!**

## But What Does Integer Indexing Mean With *No Lens* ?  :-(

There&#39;s a point where all the Lenses are gone, and you are in the raw function implementation... the FRAME! as the underlying implementation expected to see it.  If you do a FOR-EACH on a frame in this view, you see everything.. refinements, locals, definitional RETURN (if there is one).

    &gt;&gt; foo: func [arg1 :refine1 arg2 :refine2 &lt;local&gt; local1] [
           let frame: binding of $arg1
           for-each &#39;key frame [probe key]
       ]

    &gt;&gt; foo 1020
    return
    arg1
    refine1
    arg2
    refine2
    local1

What (if anything) does indexing mean at this level?  **frame.1** giving you back the definitional RETURN would be barely useful... probably even *anti*-useful.

**I think it&#39;s pretty clear the integer indexing on an unlensed frame should act as if you were seeing the frame from the perspective of a caller with the &quot;default Lens&quot;, e.g. what someone who did MAKE FRAME! would see.**

So **frame.1** would give you arg1, and **frame.2** would give you arg2, and that would be it.

## Should OBJECT! Offer Indexed Access?

I&#39;ve settled that FRAME! should offer it.  Here we see it has the interesting consequence that not all frame fields can be accessed with integer indexes, only 

But I don&#39;t know what--if anything--this implies for OBJECT!.</description>
    
    <lastBuildDate>Mon, 14 Jul 2025 06:23:59 +0000</lastBuildDate>
    <category>Functions</category>
    <atom:link href="https://rebol.metaeducation.com/t/picking-function-arguments-by-integer/2507.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Picking Function Arguments By Integer</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p><em>Another question:</em></p>
<h3><a name="p-8515-how-do-you-get-the-name-of-parameter-by-index-1" class="anchor" href="https://rebol.metaeducation.com#p-8515-how-do-you-get-the-name-of-parameter-by-index-1"></a>How Do You Get The "Name" Of  Parameter By Index?</h3>
<p>You can ask for a PARAMETER! definition by name:</p>
<pre><code>&gt;&gt; append.series
== &amp;[parameter! [&lt;opt-out&gt; any-series? port! map! object! module! bitset!]]
</code></pre>
<p>And we've established you can ask for it by number, so long as it isn't a refinement:</p>
<pre><code>&gt;&gt; append.1
== &amp;[parameter! [&lt;opt-out&gt; any-series? port! map! object! module! bitset!]]
</code></pre>
<p>If I have either 1 or SERIES I can get the parameter definition, and ask it questions, but "what's your symbol" isn't one of those questions, as the same PARAMETER! can appear multiple places.  They are a set of type constraints, and you can move them around and copy them in function parameter slots.</p>
<p><strong>What if I want the name of parameter 1?</strong>  (or perhaps, even, what if I want the index of parameter series?)</p>
<p>I don't have a particular use for that right now, but I thought of it, so I wanted to raise the question.</p>
          <p><a href="https://rebol.metaeducation.com/t/picking-function-arguments-by-integer/2507/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/picking-function-arguments-by-integer/2507/2</link>
        <pubDate>Mon, 14 Jul 2025 06:23:59 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2507-2</guid>
        <source url="https://rebol.metaeducation.com/t/picking-function-arguments-by-integer/2507.rss">Picking Function Arguments By Integer</source>
      </item>
      <item>
        <title>Picking Function Arguments By Integer</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p><a href="https://rebol.metaeducation.com/t/introducingnew-chain-datatype/2226">Having concepts like CHAIN!</a> means there are "set integers" now, which has opened up the possibility for things like:</p>
<pre><code>sub1000: specialize subtract/ [2: 1000]
</code></pre>
<p>This would prevent you from having to specifically know the name of the argument you are specializing.  That seems sensible, given that you don't need to know the name to call it.</p>
<p>It seems you should also be able to do this with frames:</p>
<pre><code>&gt;&gt; f: make frame! subtract/

&gt;&gt; f.1: 1020
&gt;&gt; f.2: 1000

&gt;&gt; eval f
== 20
</code></pre>
<p><strong>It should not work with refinements.</strong>  Rebol2/Red/R3-Alpha expose the implementation detail of what position refinement arguments are in, but it was a bad idea for them... and an even worse idea for Ren-C.</p>
<p>Consider AUGMENT, for example.  Let's make an arity-3 version of APPEND, that takes an argument to add before appending:</p>
<pre><code>&gt;&gt; apadd: adapt (augment append/ [num [integer!]]) [
       value: value + num
   ]

&gt;&gt; apadd [a b c] 1000 20
== [a b c 1020]
</code></pre>
<p>Do take a moment to appreciate how cool that is... AUGMENT creates a function with an expanded specification (but no variation in behavior), and then ADAPT puts in a preamble which uses the added parameter by adding it to the value...before falling through to the ordinary implementation of APPEND.  (ENCLOSE could be used if you had a more complicated idea for what to do that didn't fit as just an adjustment in a preamble.)</p>
<p>BUT once you're finished appreciating how cool that is, consider what we want if we make a frame for APADD:</p>
<pre><code>&gt;&gt; f: make frame! apadd/

&gt;&gt; f.1: [a b c]
&gt;&gt; f.2: 1000
&gt;&gt; f.3: 20

&gt;&gt; eval f
== [a b c 1020]
</code></pre>
<p>However, consider that it also has refinements available:</p>
<pre><code>&gt;&gt; apadd:dup [a b c] 1000 20 3
== [a b c 1020 1020 1020]
</code></pre>
<p><strong>So we see that the new non-refinement argument properly indexes as the 3rd argument, and it could not do that if refinements were INTEGER!-indexed.</strong>  Because if :DUP was something like index 3 in the frame for APPEND originally, it wouldn't be out of the way of the augmented form.</p>
<p>Seems pretty good, but there are some quirks...</p>
<h2><a name="p-8514-lens-matters-1" class="anchor" href="https://rebol.metaeducation.com#p-8514-lens-matters-1"></a>Lens Matters</h2>
<p>I've written a bit about <strong><a href="https://rebol.metaeducation.com/t/understanding-frame-lensing/1645">FRAME! Lensing</a></strong>.  It's not just an efficiency trick...because I wouldn't know how to implement function composition otherwise.</p>
<p>Because of Lenses, a frame built for a function with the same positionality can expose different interfaces.  Consider our APADD above, imagine specializing the thing you append to:</p>
<pre><code>&gt;&gt; data: [a b c]

&gt;&gt; accrue: specialize apadd/ [data]

&gt;&gt; accrue 1000 20
== [a b c 1020]

&gt;&gt; accrue 300 4
== [a b c 1020 304]
</code></pre>
<p>So now, we would hope that ACCRUE thinks of its 1 and 2 parameters as being what APADD thought of as 2 and 3.</p>
<pre><code>&gt;&gt; f: make frame! accrue/

&gt;&gt; f.1: 400
&gt;&gt; f.2: 21

&gt;&gt; eval f
== [a b c 1020 304 421]
</code></pre>
<p><strong>Satisfying!</strong></p>
<h2><a name="p-8514-but-what-does-integer-indexing-mean-with-no-lens-2" class="anchor" href="https://rebol.metaeducation.com#p-8514-but-what-does-integer-indexing-mean-with-no-lens-2"></a>But What Does Integer Indexing Mean With <em>No Lens</em> ?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></h2>
<p>There's a point where all the Lenses are gone, and you are in the raw function implementation... the FRAME! as the underlying implementation expected to see it.  If you do a FOR-EACH on a frame in this view, you see everything.. refinements, locals, definitional RETURN (if there is one).</p>
<pre><code>&gt;&gt; foo: func [arg1 :refine1 arg2 :refine2 &lt;local&gt; local1] [
       let frame: binding of $arg1
       for-each 'key frame [probe key]
   ]

&gt;&gt; foo 1020
return
arg1
refine1
arg2
refine2
local1
</code></pre>
<p>What (if anything) does indexing mean at this level?  <strong>frame.1</strong> giving you back the definitional RETURN would be barely useful... probably even <em>anti</em>-useful.</p>
<p><strong>I think it's pretty clear the integer indexing on an unlensed frame should act as if you were seeing the frame from the perspective of a caller with the "default Lens", e.g. what someone who did MAKE FRAME! would see.</strong></p>
<p>So <strong>frame.1</strong> would give you arg1, and <strong>frame.2</strong> would give you arg2, and that would be it.</p>
<h2><a name="p-8514-should-object-offer-indexed-access-3" class="anchor" href="https://rebol.metaeducation.com#p-8514-should-object-offer-indexed-access-3"></a>Should OBJECT! Offer Indexed Access?</h2>
<p>I've settled that FRAME! should offer it.  Here we see it has the interesting consequence that not all frame fields can be accessed with integer indexes, only</p>
<p>But I don't know what--if anything--this implies for OBJECT!.</p>
          <p><a href="https://rebol.metaeducation.com/t/picking-function-arguments-by-integer/2507/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/picking-function-arguments-by-integer/2507/1</link>
        <pubDate>Mon, 14 Jul 2025 06:23:29 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2507-1</guid>
        <source url="https://rebol.metaeducation.com/t/picking-function-arguments-by-integer/2507.rss">Picking Function Arguments By Integer</source>
      </item>
  </channel>
</rss>

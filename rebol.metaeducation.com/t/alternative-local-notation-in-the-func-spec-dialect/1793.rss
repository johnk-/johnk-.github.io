<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Alternative Local Notation in the Func Spec Dialect</title>
    <link>https://rebol.metaeducation.com/t/alternative-local-notation-in-the-func-spec-dialect/1793</link>
    <description>Long ago, when I was looking at some of the higher-level function generators (like FUNCT on top of FUNCTION) I was struck by how tricky it was to get the adaptations written correctly.  

We can look at [FUNCT from R3-Alpha](https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/mezz/base-funcs.r#L28) and see some of that complexity, even just to try and add some local variables.

It had to check to see if there was already a /LOCAL, and add it if not:

	; Copy the spec and add /local to the end if not found
	unless find spec: copy/deep spec /local [append spec [
		/local ; In a block so the generated source gets the newlines
	]]

*Bear in mind that specifying /LOCAL twice would be a duplicate refinement error, and /LOCAL did not have to be at the end of a spec.*  Things were tricky, because there were &quot;private refinements&quot;.  These refinements were an artifact of how help worked--they were not shown--but weren&#39;t actually private.

So you had to be careful, to insert things after local but not after the private refinements, or they&#39;d be arguments to those refinements:

    ; Collect all set-words in the body as words to be used as locals, and add
    ; them to the spec. Don&#39;t include the words already in the spec or object.
    insert find/tail spec /local collect-words/deep/set/ignore body either with [
       ...
    ]

I wanted to take better advantage of datatypes, so I adopted the TAG! `&lt;local&gt;` in the spec so that /LOCAL could be used like any other refinement... e.g. GET-TIME/LOCAL or GET-LANGUAGE/LOCAL.  (This is an idea preserved to this day, and I think it&#39;s a better move, though LET has been developing as the more viable general option for making locals).

But another concept I had was to make SET-WORD! in the dialect be another way to put a local anywhere in the spec.  So if you were writing code munging function specs you could just throw local variables on:

    foo: func [a b c: d] [...]

    &lt;= equivalent to =&gt;

    foo: func [a b d &lt;local&gt; c] [...]

## But SET-WORD! Seems A *Not Good* Choice

When you read **`[a b c: d]`** that looks like it&#39;s assigning D to C.  Not very good.

It&#39;s also competitive with SET-WORD usage for RETURN, e.g. **`[return: [integer!] a b c: d]`**.  I rationalized this by saying &quot;well, RETURN creates a local that holds the definitional return, so it&#39;s a local in both cases&quot;.  However that&#39;s flimsy.

Also, for a while multi-returns were using SET-WORD on the interface to denote proxied variables used by the multi-return.  That&#39;s no longer applicable, but what might be applicable is local initializations:

  https://rebol.metaeducation.com/t/set-word-to-initialize-locals-in-function-specs/2210

But the other parts of speech are taken in function specs.  Everything means something.  What should be used?

There could be `&lt;local&gt; x` for one local, and `&lt;locals&gt; x y z` for many. But that seems crappy. :-(</description>
    
    <lastBuildDate>Mon, 12 May 2025 04:58:48 +0000</lastBuildDate>
    <category>Functions</category>
    <atom:link href="https://rebol.metaeducation.com/t/alternative-local-notation-in-the-func-spec-dialect/1793.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Alternative Local Notation in the Func Spec Dialect</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1793">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But the other parts of speech are taken in function specs. Everything means something. What should be used?</p>
<p>There could be <code>&lt;local&gt; x</code> for one local, and <code>&lt;locals&gt; x y z</code> for many. But that seems crappy. <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
</blockquote>
</aside>
<p>So this is a fairly niche feature, used in higher-level code.  I don't know that giving it a niche name like <strong><code>&lt;one-local&gt; x</code></strong> would be the end of the world.</p>
<p>That would certainly leave room for other ideas.</p>
<p>e.g. I don't think using something like <strong><code>$x</code></strong> is wise... even though it's currently available.  Because I'm already thinking that might be something that says <em>"I'm interested in the binding of this argument,"</em> and by default you don't get binding information... <a href="https://rebol.metaeducation.com/t/performance-and-security-implications-of-binding-leakage/2117/2">just to squash the spread of binding (for efficiency and potentially security)</a></p>
          <p><a href="https://rebol.metaeducation.com/t/alternative-local-notation-in-the-func-spec-dialect/1793/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/alternative-local-notation-in-the-func-spec-dialect/1793/2</link>
        <pubDate>Mon, 12 May 2025 04:58:48 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1793-2</guid>
        <source url="https://rebol.metaeducation.com/t/alternative-local-notation-in-the-func-spec-dialect/1793.rss">Alternative Local Notation in the Func Spec Dialect</source>
      </item>
      <item>
        <title>Alternative Local Notation in the Func Spec Dialect</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Long ago, when I was looking at some of the higher-level function generators (like FUNCT on top of FUNCTION) I was struck by how tricky it was to get the adaptations written correctly.</p>
<p>We can look at <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/mezz/base-funcs.r#L28">FUNCT from R3-Alpha</a> and see some of that complexity, even just to try and add some local variables.</p>
<p>It had to check to see if there was already a /LOCAL, and add it if not:</p>
<pre><code>; Copy the spec and add /local to the end if not found
unless find spec: copy/deep spec /local [append spec [
	/local ; In a block so the generated source gets the newlines
]]
</code></pre>
<p><em>Bear in mind that specifying /LOCAL twice would be a duplicate refinement error, and /LOCAL did not have to be at the end of a spec.</em>  Things were tricky, because there were "private refinements".  These refinements were an artifact of how help worked--they were not shown--but weren't actually private.</p>
<p>So you had to be careful, to insert things after local but not after the private refinements, or they'd be arguments to those refinements:</p>
<pre><code>; Collect all set-words in the body as words to be used as locals, and add
; them to the spec. Don't include the words already in the spec or object.
insert find/tail spec /local collect-words/deep/set/ignore body either with [
   ...
]
</code></pre>
<p>I wanted to take better advantage of datatypes, so I adopted the TAG! <code>&lt;local&gt;</code> in the spec so that /LOCAL could be used like any other refinement... e.g. GET-TIME/LOCAL or GET-LANGUAGE/LOCAL.  (This is an idea preserved to this day, and I think it's a better move, though LET has been developing as the more viable general option for making locals).</p>
<p>But another concept I had was to make SET-WORD! in the dialect be another way to put a local anywhere in the spec.  So if you were writing code munging function specs you could just throw local variables on:</p>
<pre><code>foo: func [a b c: d] [...]

&lt;= equivalent to =&gt;

foo: func [a b d &lt;local&gt; c] [...]
</code></pre>
<h2><a name="p-5785-but-set-word-seems-a-not-good-choice-1" class="anchor" href="https://rebol.metaeducation.com#p-5785-but-set-word-seems-a-not-good-choice-1"></a>But SET-WORD! Seems A <em>Not Good</em> Choice</h2>
<p>When you read <strong><code>[a b c: d]</code></strong> that looks like it's assigning D to C.  Not very good.</p>
<p>It's also competitive with SET-WORD usage for RETURN, e.g. <strong><code>[return: [integer!] a b c: d]</code></strong>.  I rationalized this by saying "well, RETURN creates a local that holds the definitional return, so it's a local in both cases".  However that's flimsy.</p>
<p>Also, for a while multi-returns were using SET-WORD on the interface to denote proxied variables used by the multi-return.  That's no longer applicable, but what might be applicable is local initializations:</p>
<p><a href="https://rebol.metaeducation.com/t/set-word-to-initialize-locals-in-function-specs/2210" class="inline-onebox">SET-WORD! To Initialize Locals In Function Specs?</a></p>
<p>But the other parts of speech are taken in function specs.  Everything means something.  What should be used?</p>
<p>There could be <code>&lt;local&gt; x</code> for one local, and <code>&lt;locals&gt; x y z</code> for many. But that seems crappy. <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
          <p><a href="https://rebol.metaeducation.com/t/alternative-local-notation-in-the-func-spec-dialect/1793/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/alternative-local-notation-in-the-func-spec-dialect/1793/1</link>
        <pubDate>Sat, 05 Mar 2022 20:33:12 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1793-1</guid>
        <source url="https://rebol.metaeducation.com/t/alternative-local-notation-in-the-func-spec-dialect/1793.rss">Alternative Local Notation in the Func Spec Dialect</source>
      </item>
  </channel>
</rss>

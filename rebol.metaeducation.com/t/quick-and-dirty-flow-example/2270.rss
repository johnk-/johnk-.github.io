<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Quick and Dirty FLOW Example</title>
    <link>https://rebol.metaeducation.com/t/quick-and-dirty-flow-example/2270</link>
    <description>At one point I proposed something along the lines of:

    &gt;&gt; flow [
           [1 2 3]
           reverse _
           map-each x _ [x * 10]
       ]
    == [30 20 10]

## Seems Neat.  How Hard Is It To Do?

Well, let&#39;s just be simple-minded to start.

*(Note that in Ren-C, [REPLACE means &quot;REPLACE:ALL&quot; by default](https://rebol.metaeducation.com/t/make-replace-all-default-semantics-of-replace/2269/)...)*

    flow: func [
        block [block!]
        :placeholder [element?]
        &lt;local&gt; flow-result
    ][
        placeholder: default [_]
        block: copy block
        replace block placeholder $flow-result
        while [not tail? block] [
             insert block $flow-result:
             [block flow-result]: evaluate:step block
        ]
        return flow-result
    ]

## And On This Example, It Works!

Some notes:

* **element?** means any non-antiform

* **$flow-result** evaluates to the plain word of **flow-result**, but carrying a binding from the current context (in this case, so that the code in the user supplied block can see the local variable in FLOW&#39;s frame)

## But *How* Does It Work?

It simply creates a variable FLOW-RESULT, and then splices it into a copy of the block:

    flow [
        [1 2 3]
        reverse _
        map-each x _ [x * 10]
    ]
    =&gt;
    [
       flow-result: [1 2 3]
       flow-result: reverse flow-result
       flow-result: map-each x flow-result [x * 10]
    ]

But it can&#39;t do it ahead of time, because it doesn&#39;t know the span of the expressions until it executes them.  So it goes one step at a time, inserting the SET-WORD! after each step

    [
       flow-result: [1 2 3]  ; &lt;-- gets to here
       reverse flow-result
       map-each x flow-result [x * 10]
    ]
    ...
    [
       flow-result: [1 2 3]
       flow-result: reverse flow-result  ; &lt;-- gets to here
       map-each x flow-result [x * 10]
    ]
    ...
    [
       flow-result: [1 2 3]
       flow-result: reverse flow-result
       flow-result: map-each x flow-result [x * 10]  ; finished
    ]

## Very Simple, But Useful Right Off The Bat

I don&#39;t know what all design the correct FLOW would need.  It would need to do its replacements deeply (we don&#39;t have REPLACE/DEEP, so you&#39;d have to use PARSE or something).

And I don&#39;t know what features it should have.  But... pretty cool to see this kind of thing be so natural to do.

https://www.youtube.com/watch?v=nlQBYZClWXs</description>
    
    <lastBuildDate>Sun, 27 Apr 2025 19:58:32 +0000</lastBuildDate>
    <category>Show &amp; Tell</category>
    <atom:link href="https://rebol.metaeducation.com/t/quick-and-dirty-flow-example/2270.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Quick and Dirty FLOW Example</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2270">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I’d suggest <code>_</code> instead (which is what you already suggested for POINTFREE / PARTIAL, so it’s consistent). Naturally, it should be configurable via a refinement.</p>
</blockquote>
</aside>
<p>So there's a uniquely qualified candidate for what could serve as the "nothing here yet", which is <strong><code>~</code></strong>:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; flow [
       [1 2 3]
       reverse ~
       map-each x ~ [x * 10]
   ]
== [30 20 10]
</code></pre>
<p>What makes it uniquely qualified is that what the quasiform blank <strong><code>~</code></strong> evaluates to is the antiform blank, TRASH.  <strong>And TRASH is not legal as an argument to normal parameters.</strong></p>
<p>TRASH is what represents the unspecified state in frames.  So if you did:</p>
<pre><code> &gt;&gt; f: make frame! :divide
 == #[frame! [
      value1: ~
      value2: ~
 ]]

 &gt;&gt; f.value1: 1020

 &gt;&gt; run f 10
 == 102
</code></pre>
<p>You left value2 as antiform blank, which is trash.  So it was left unspecified, and gathered in the invocation...making 10 accumulated as value2.</p>
<p>Another helpful out-of-band candidate in this kind of abstraction would be TRIPWIRE!, which could let you make several distinct named entities using meta-tripwires... <code>~&lt;1&gt;~</code> and <code>~&lt;2&gt;~</code> or <code>~&lt;before&gt;~</code> etc.</p>
<p><strong>OF COURSE, USELESSNESS BREEDS POPULARITY</strong>... this property may make it more common to use meta-trash/quasi-blank in various quoted places.  Configurability would probably still be necessary, and I guess one would have to do some market research to see if people preferred blank as the default just because it looks like a blank.</p>
          <p><a href="https://rebol.metaeducation.com/t/quick-and-dirty-flow-example/2270/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/quick-and-dirty-flow-example/2270/3</link>
        <pubDate>Sun, 27 Apr 2025 19:58:32 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2270-3</guid>
        <source url="https://rebol.metaeducation.com/t/quick-and-dirty-flow-example/2270.rss">Quick and Dirty FLOW Example</source>
      </item>
      <item>
        <title>Quick and Dirty FLOW Example</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <p>Syntax suggestion: I don’t particularly like <code>&lt;$&gt;</code> to denote the hole. I’d suggest <code>_</code> instead (which is what you already suggested for POINTFREE / PARTIAL, so it’s consistent). Naturally, it should be configurable via a refinement.</p>
          <p><a href="https://rebol.metaeducation.com/t/quick-and-dirty-flow-example/2270/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/quick-and-dirty-flow-example/2270/2</link>
        <pubDate>Wed, 11 Sep 2024 13:56:45 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2270-2</guid>
        <source url="https://rebol.metaeducation.com/t/quick-and-dirty-flow-example/2270.rss">Quick and Dirty FLOW Example</source>
      </item>
      <item>
        <title>Quick and Dirty FLOW Example</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>At one point I proposed something along the lines of:</p>
<pre><code>&gt;&gt; flow [
       [1 2 3]
       reverse _
       map-each x _ [x * 10]
   ]
== [30 20 10]
</code></pre>
<h2><a name="p-7643-seems-neat-how-hard-is-it-to-do-1" class="anchor" href="https://rebol.metaeducation.com#p-7643-seems-neat-how-hard-is-it-to-do-1"></a>Seems Neat.  How Hard Is It To Do?</h2>
<p>Well, let's just be simple-minded to start.</p>
<p><em>(Note that in Ren-C, <a href="https://rebol.metaeducation.com/t/make-replace-all-default-semantics-of-replace/2269/">REPLACE means "REPLACE:ALL" by default</a>...)</em></p>
<pre><code>flow: func [
    block [block!]
    :placeholder [element?]
    &lt;local&gt; flow-result
][
    placeholder: default [_]
    block: copy block
    replace block placeholder $flow-result
    while [not tail? block] [
         insert block $flow-result:
         [block flow-result]: evaluate:step block
    ]
    return flow-result
]
</code></pre>
<h2><a name="p-7643-and-on-this-example-it-works-2" class="anchor" href="https://rebol.metaeducation.com#p-7643-and-on-this-example-it-works-2"></a>And On This Example, It Works!</h2>
<p>Some notes:</p>
<ul>
<li>
<p><strong>element?</strong> means any non-antiform</p>
</li>
<li>
<p><strong>$flow-result</strong> evaluates to the plain word of <strong>flow-result</strong>, but carrying a binding from the current context (in this case, so that the code in the user supplied block can see the local variable in FLOW's frame)</p>
</li>
</ul>
<h2><a name="p-7643-but-how-does-it-work-3" class="anchor" href="https://rebol.metaeducation.com#p-7643-but-how-does-it-work-3"></a>But <em>How</em> Does It Work?</h2>
<p>It simply creates a variable FLOW-RESULT, and then splices it into a copy of the block:</p>
<pre><code>flow [
    [1 2 3]
    reverse _
    map-each x _ [x * 10]
]
=&gt;
[
   flow-result: [1 2 3]
   flow-result: reverse flow-result
   flow-result: map-each x flow-result [x * 10]
]
</code></pre>
<p>But it can't do it ahead of time, because it doesn't know the span of the expressions until it executes them.  So it goes one step at a time, inserting the SET-WORD! after each step</p>
<pre><code>[
   flow-result: [1 2 3]  ; &lt;-- gets to here
   reverse flow-result
   map-each x flow-result [x * 10]
]
...
[
   flow-result: [1 2 3]
   flow-result: reverse flow-result  ; &lt;-- gets to here
   map-each x flow-result [x * 10]
]
...
[
   flow-result: [1 2 3]
   flow-result: reverse flow-result
   flow-result: map-each x flow-result [x * 10]  ; finished
]
</code></pre>
<h2><a name="p-7643-very-simple-but-useful-right-off-the-bat-4" class="anchor" href="https://rebol.metaeducation.com#p-7643-very-simple-but-useful-right-off-the-bat-4"></a>Very Simple, But Useful Right Off The Bat</h2>
<p>I don't know what all design the correct FLOW would need.  It would need to do its replacements deeply (we don't have REPLACE/DEEP, so you'd have to use PARSE or something).</p>
<p>And I don't know what features it should have.  But... pretty cool to see this kind of thing be so natural to do.</p>
<p><a href="https://www.youtube.com/watch?v=nlQBYZClWXs">Dimension 5 - Flow</a></p>

          <p><a href="https://rebol.metaeducation.com/t/quick-and-dirty-flow-example/2270/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/quick-and-dirty-flow-example/2270/1</link>
        <pubDate>Wed, 11 Sep 2024 13:47:55 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2270-1</guid>
        <source url="https://rebol.metaeducation.com/t/quick-and-dirty-flow-example/2270.rss">Quick and Dirty FLOW Example</source>
      </item>
  </channel>
</rss>

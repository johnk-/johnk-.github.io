<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Design for Something Like FLIP To Reverse Arguments</title>
    <link>https://rebol.metaeducation.com/t/design-for-something-like-flip-to-reverse-arguments/2345</link>
    <description>[quote=&quot;bradrn, post:6, topic:1238&quot;]
If someone wants to specify the second parameter first they can always write `flip cons` or `flip snoc`.
[/quote]

The design of a FLIP-like operation raises some questions. 

If it were an operator that acted on functions, it wouldn&#39;t retrigger them.  You&#39;d have to say:

    &gt;&gt; append &#39;d [a b c]
    == [a b c d]

    &gt;&gt; run flip append/ [a b c] &#39;d
    == [a b c d]

Alternately, I guess you could use slash to run a GROUP!, but then you&#39;d have a disabling slash and a running slash:

    &gt;&gt; /(flip append/) [a b c] &#39;d
    == [a b c d]

If it were instead something along the lines of RUN, where applying the flipped function was implicit, you could write:

    &gt;&gt; flip append/ [a b c] &#39;d
    == [a b c d]

I don&#39;t think **`flip/append`** being a synonym for **`/(flip append/)`** is a generically useful idea, compared to the likes of **`not/even?/`** for cascading.

But if the [weird idea of dialected CHAIN!](https://rebol.metaeducation.com/t/dialecting-function-calls-new-weird-powerful/2310) ever came to pass, FLIP could go into a distinct mode based on receiving a function in the place other functions have refinements...

    &gt;&gt; append/
    == ~#[frame! [value series]]~

    &gt;&gt; flip append/
    == ~#[frame! [series value]]~

    &gt;&gt; flip:append [a b c] &#39;d
    == [a b c d]</description>
    
    <lastBuildDate>Tue, 15 Jul 2025 09:10:18 +0000</lastBuildDate>
    <category>Functions</category>
    <atom:link href="https://rebol.metaeducation.com/t/design-for-something-like-flip-to-reverse-arguments/2345.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Design for Something Like FLIP To Reverse Arguments</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2345">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>One Solution: REFRAMER And INTEGER Indexing</p>
</blockquote>
</aside>
<p>This is an interesting way of doing it, but has a flaw... namely parameter conventions.</p>
<p>Although type checking isn't done until you actually run the function, if parameters are taken literally then you'd run into trouble if you tried to FLIP a function whose arguments weren't both the same convention.</p>
<p>So unfortunately, a real FLIP/FLIPPED would have to use a deeper mechanic.  But, interesting to see how close some of these things can get...and the integer-based indexing is definitely useful.</p>
          <p><a href="https://rebol.metaeducation.com/t/design-for-something-like-flip-to-reverse-arguments/2345/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/design-for-something-like-flip-to-reverse-arguments/2345/4</link>
        <pubDate>Tue, 15 Jul 2025 09:10:18 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2345-4</guid>
        <source url="https://rebol.metaeducation.com/t/design-for-something-like-flip-to-reverse-arguments/2345.rss">Design for Something Like FLIP To Reverse Arguments</source>
      </item>
      <item>
        <title>Design for Something Like FLIP To Reverse Arguments</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="2345">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>If it were an operator that acted on functions, it wouldn't retrigger them. You'd have to say:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; append 'd [a b c]  ; &lt;-- reversed concept of APPEND
== [a b c d]

&gt;&gt; run flip append/ [a b c] 'd
== [a b c d]
</code></pre>
</blockquote>
</aside>
<p>Maybe the distinction could be FLIPPED vs. FLIP?  I don't know.</p>
<pre><code>&gt;&gt; append [a b c] [d e]  ; &lt;-- today's concept of append
== [a b c [d e]]

&gt;&gt; flip append [a b c] [d e]
== [d e [a b c]]

&gt;&gt; fappend: flipped append/

&gt;&gt; fappend [a b c] [d e]
== [d e [a b c]]
</code></pre>
<p>I can't think of it being totally obvious why one name would be used for one vs. the other.  Though the impromptu FLIP is probably something that would be used more often, hence probably deserves the shorter name.</p>
<p>The function-generating FLIPPED could be done with a conventional ENCLOSE vs. a REFRAMER, because you know the function you're operating on in advance:</p>
<pre><code>flipped: lambda [action [&lt;unrun&gt; frame!]] 
    enclose action f -&gt; [swap $f.1 $f.2, eval f]
]
</code></pre>
          <p><a href="https://rebol.metaeducation.com/t/design-for-something-like-flip-to-reverse-arguments/2345/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/design-for-something-like-flip-to-reverse-arguments/2345/3</link>
        <pubDate>Mon, 14 Jul 2025 08:34:03 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2345-3</guid>
        <source url="https://rebol.metaeducation.com/t/design-for-something-like-flip-to-reverse-arguments/2345.rss">Design for Something Like FLIP To Reverse Arguments</source>
      </item>
      <item>
        <title>Design for Something Like FLIP To Reverse Arguments</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <h2><a name="p-8517-one-solution-reframer-and-integer-indexing-1" class="anchor" href="https://rebol.metaeducation.com#p-8517-one-solution-reframer-and-integer-indexing-1"></a>One Solution: REFRAMER And INTEGER Indexing</h2>
<p>The REFRAMER is something that lets you get a chance to hook a function call after it has accumulated its arguments, but before it has done typechecking:</p>
<p><strong><a href="https://rebol.metaeducation.com/t/introducing-reframer-close-cousin-to-enclose/1395">Introducing REFRAMER: Close Cousin to ENCLOSE</a></strong></p>
<p>Then, FRAME! now supports INTEGER! indexing... as a way of accessing non-refinement parameters as they would be seen on the interface:</p>
<p><strong><a href="https://rebol.metaeducation.com/t/picking-function-arguments-by-integer/2507">Picking Function Arguments By Integer</a></strong></p>
<p>So just make a REFRAMER that adds no arguments, and does a parameter switcheroo before executing the frame:</p>
<pre><code>flip: reframer lambda [f [frame!]] [
    let temp: f.2
    f.2: f.1
    f.1: temp
    eval f
]

&gt;&gt; flip append [a b c] [d e]
== [d e [a b c]]

&gt;&gt; flip divide 10 20
== 2
</code></pre>
<h2><a name="p-8517-the-definition-could-be-briefer-2" class="anchor" href="https://rebol.metaeducation.com#p-8517-the-definition-could-be-briefer-2"></a>The Definition Could Be Briefer...</h2>
<p>Right now, the SWAP operation doesn't act on variables... it acts on series, and errors on WORD!s.  I kind of feel like swapping variables is the more common intent, not entirely sure what the ramifications of overloading the SWAP operation to do something that different are.</p>
<p>But it could be this short, for those who seek brevity:</p>
<pre><code>flip: reframer f -&gt; [swap $f.1 $f.2, eval f]
</code></pre>
<p>cc: <a class="mention" href="https://rebol.metaeducation.com/u/bradrn">@bradrn</a></p>
          <p><a href="https://rebol.metaeducation.com/t/design-for-something-like-flip-to-reverse-arguments/2345/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/design-for-something-like-flip-to-reverse-arguments/2345/2</link>
        <pubDate>Mon, 14 Jul 2025 08:04:38 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2345-2</guid>
        <source url="https://rebol.metaeducation.com/t/design-for-something-like-flip-to-reverse-arguments/2345.rss">Design for Something Like FLIP To Reverse Arguments</source>
      </item>
      <item>
        <title>Design for Something Like FLIP To Reverse Arguments</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="6" data-topic="1238">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/parameter-order-in-rebol/1238/6">Parameter Order in Rebol</a></div>
<blockquote>
<p>If someone wants to specify the second parameter first they can always write <code>flip cons</code> or <code>flip snoc</code>.</p>
</blockquote>
</aside>
<p>The design of a FLIP-like operation raises some questions.</p>
<p>If it were an operator that acted on functions, it wouldn't retrigger them.  You'd have to say:</p>
<pre><code>&gt;&gt; append 'd [a b c]
== [a b c d]

&gt;&gt; run flip append/ [a b c] 'd
== [a b c d]
</code></pre>
<p>Alternately, I guess you could use slash to run a GROUP!, but then you'd have a disabling slash and a running slash:</p>
<pre><code>&gt;&gt; /(flip append/) [a b c] 'd
== [a b c d]
</code></pre>
<p>If it were instead something along the lines of RUN, where applying the flipped function was implicit, you could write:</p>
<pre><code>&gt;&gt; flip append/ [a b c] 'd
== [a b c d]
</code></pre>
<p>I don't think <strong><code>flip/append</code></strong> being a synonym for <strong><code>/(flip append/)</code></strong> is a generically useful idea, compared to the likes of <strong><code>not/even?/</code></strong> for cascading.</p>
<p>But if the <a href="https://rebol.metaeducation.com/t/dialecting-function-calls-new-weird-powerful/2310">weird idea of dialected CHAIN!</a> ever came to pass, FLIP could go into a distinct mode based on receiving a function in the place other functions have refinements...</p>
<pre><code>&gt;&gt; append/
== ~#[frame! [value series]]~

&gt;&gt; flip append/
== ~#[frame! [series value]]~

&gt;&gt; flip:append [a b c] 'd
== [a b c d]
</code></pre>
          <p><a href="https://rebol.metaeducation.com/t/design-for-something-like-flip-to-reverse-arguments/2345/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/design-for-something-like-flip-to-reverse-arguments/2345/1</link>
        <pubDate>Mon, 02 Dec 2024 14:41:22 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2345-1</guid>
        <source url="https://rebol.metaeducation.com/t/design-for-something-like-flip-to-reverse-arguments/2345.rss">Design for Something Like FLIP To Reverse Arguments</source>
      </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Meta-Representability in Ren-C (Isotopic Theory)</title>
    <link>https://rebol.metaeducation.com/t/meta-representability-in-ren-c-isotopic-theory/2217</link>
    <description>*I wrote this to try and give some context to an AI before asking it a naming question.  For a less high-level treatment, see **[A Justification of Generalized Isotopes](https://rebol.metaeducation.com/t/a-justification-of-generalized-isotopes/1918)**.*

---

Most imperative programming languages do not delve into the relationships between things like null and trash... as if they were mathematical, and you were going to discover that if you take the square root of undefined you get null, etc.  :-)  But I am doing something analogous to that.

In particular, I&#39;m making it possible to push variables which may contain states like undefined and null &quot;upwards&quot; representationally, to where whatever they are holding becomes &quot;Lifted&quot;.

    &gt;&gt; var
    ** Error: var is trash

    &gt;&gt; var: lift get:any $var  ; set var to &quot;lifted var&quot;
    == ~

    &gt;&gt; var  ; no error on access
    == ~

    &gt;&gt; var: lift var  ; again, no error
    == &#39;~

    &gt;&gt; var
    == &#39;~

    &gt;&gt; var: lift var  ; again, no error
    == &#39;&#39;~

If something is a special form (like trash or null) the first LIFT step will use tildes to indicate it has been raised to a &quot;quasiform&quot;.  Quasiforms do not cause errors when accessed from variables, and can be put into &quot;reified&quot; contexts like arrays.  Then every LIFT step after that adds a level of quoting, indicated by an apostrophe.

UNLIFT reverses this process, ultimately getting back to the special form which cannot be put in arrays and--in the case of &quot;trash&quot;--causes errors on access.

    &gt;&gt; var: unlift first [&#39;~]
    == ~

    &gt;&gt; var
    == ~

    &gt;&gt; var: unlift var  ; result is trash, shows nothing in the console
    
    &gt;&gt; var
    ** Error: var is trash

If something didn&#39;t start out as a special form, then it will just get quoting levels added by apostrophes:

    &gt;&gt; var
    == 10

    &gt;&gt; var: lift var
    == &#39;10

    &gt;&gt; var: lift var
    == &#39;&#39;10

So what this lets people do is kind of work generically and persist special states of interest to them in lifted form, multiplexed alongside things that had been conventional values.

The special states are called &quot;antiforms&quot;.  And they aren&#39;t just things like NULL and TRASH, but also [VOID](https://rebol.metaeducation.com/t/the-void-in-null-out-protocol/1880)... [multi-return packs](https://rebol.metaeducation.com/t/thought-reimplementing-multi-return-via-isotopic-block/1955), [raised errors](https://rebol.metaeducation.com/t/fail-vs-return-raise-the-new-age-of-definitional-errors/1852), [splice representations](https://rebol.metaeducation.com/t/the-long-awaited-death-of-only/1607)...

To a newcomer, the merits or applications may not be obvious.  But this model gives phenomenal expressive power.  And I definitely do think of it as being like the &quot;higher mathematics&quot; of Rebol.

---

https://youtu.be/B1J6Ou4q8vE?t=209</description>
    
    <lastBuildDate>Sun, 01 Jun 2025 19:37:00 +0000</lastBuildDate>
    <category>Philosophy</category>
    <atom:link href="https://rebol.metaeducation.com/t/meta-representability-in-ren-c-isotopic-theory/2217.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Meta-Representability in Ren-C (Isotopic Theory)</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p><em>I wrote this to try and give some context to an AI before asking it a naming question.  For a less high-level treatment, see <strong><a href="https://rebol.metaeducation.com/t/a-justification-of-generalized-isotopes/1918">A Justification of Generalized Isotopes</a></strong>.</em></p>
<hr>
<p>Most imperative programming languages do not delve into the relationships between things like null and trash... as if they were mathematical, and you were going to discover that if you take the square root of undefined you get null, etc.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/slight_smile.png?v=14" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20">  But I am doing something analogous to that.</p>
<p>In particular, I'm making it possible to push variables which may contain states like undefined and null "upwards" representationally, to where whatever they are holding becomes "Lifted".</p>
<pre><code>&gt;&gt; var
** Error: var is trash

&gt;&gt; var: lift get:any $var  ; set var to "lifted var"
== ~

&gt;&gt; var  ; no error on access
== ~

&gt;&gt; var: lift var  ; again, no error
== '~

&gt;&gt; var
== '~

&gt;&gt; var: lift var  ; again, no error
== ''~
</code></pre>
<p>If something is a special form (like trash or null) the first LIFT step will use tildes to indicate it has been raised to a "quasiform".  Quasiforms do not cause errors when accessed from variables, and can be put into "reified" contexts like arrays.  Then every LIFT step after that adds a level of quoting, indicated by an apostrophe.</p>
<p>UNLIFT reverses this process, ultimately getting back to the special form which cannot be put in arrays and--in the case of "trash"--causes errors on access.</p>
<pre><code>&gt;&gt; var: unlift first ['~]
== ~

&gt;&gt; var
== ~

&gt;&gt; var: unlift var  ; result is trash, shows nothing in the console

&gt;&gt; var
** Error: var is trash
</code></pre>
<p>If something didn't start out as a special form, then it will just get quoting levels added by apostrophes:</p>
<pre><code>&gt;&gt; var
== 10

&gt;&gt; var: lift var
== '10

&gt;&gt; var: lift var
== ''10
</code></pre>
<p>So what this lets people do is kind of work generically and persist special states of interest to them in lifted form, multiplexed alongside things that had been conventional values.</p>
<p>The special states are called "antiforms".  And they aren't just things like NULL and TRASH, but also <a href="https://rebol.metaeducation.com/t/the-void-in-null-out-protocol/1880">VOID</a>... <a href="https://rebol.metaeducation.com/t/thought-reimplementing-multi-return-via-isotopic-block/1955">multi-return packs</a>, <a href="https://rebol.metaeducation.com/t/fail-vs-return-raise-the-new-age-of-definitional-errors/1852">raised errors</a>, <a href="https://rebol.metaeducation.com/t/the-long-awaited-death-of-only/1607">splice representations</a>...</p>
<p>To a newcomer, the merits or applications may not be obvious.  But this model gives phenomenal expressive power.  And I definitely do think of it as being like the "higher mathematics" of Rebol.</p>
<hr>
<p><a href="https://www.youtube.com/watch?v=B1J6Ou4q8vE&amp;t=209">Animation vs. Math</a></p>

          <p><a href="https://rebol.metaeducation.com/t/meta-representability-in-ren-c-isotopic-theory/2217/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/meta-representability-in-ren-c-isotopic-theory/2217/1</link>
        <pubDate>Sat, 24 Aug 2024 18:38:40 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2217-1</guid>
        <source url="https://rebol.metaeducation.com/t/meta-representability-in-ren-c-isotopic-theory/2217.rss">Meta-Representability in Ren-C (Isotopic Theory)</source>
      </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>ARRAY/INITIAL and ACTION! Isotopes</title>
    <link>https://rebol.metaeducation.com/t/array-initial-and-action-isotopes/1975</link>
    <description>So the ARRAY mezzanine from R3-Alpha allowed you to make an array with an initial value that could be a function...in which case it evaluated that function each time:

    r3-alpha&gt;&gt; array 3
    == [none none none]

    r3-alpha&gt;&gt; array/initial 3 10
    == [10 10 10]

    r3-alpha&gt;&gt; n: 0 array/initial 3 does [n: n + 1]
    == [1 2 3]

This raises the question of how you would make an array whose initial value was itself a function.

If you&#39;re a loophole-minded person, you might notice you could trick *this particular case* by making a function that returns a function.

    r3-alpha&gt;&gt; array/initial 3 does [:append]
    == [#[action! [...]] #[action! [...]] #[action! [...]]]

But that&#39;s not really a general answer for how to deal with this kind of polymorphism--it just works if you&#39;re using the result purely to do a substitution.

## Trying This With Antiform Actions

I&#39;ve loosened my stance on isotopes in function frames as parameters.  It&#39;s not a good idea to take them as default, but forcing you to make every parameter ^META just to get isotopes is limiting.

So I gave this a shot...

    array: func [
        {Makes and initializes a block of a given size}

        return: &quot;Generated block or null if blank input&quot;
            [block!]
        size &quot;Size or block of sizes for each dimension&quot;
            [&lt;maybe&gt; integer! block!]
        /initial &quot;Initial value (will be called each time if action isotope)&quot;
            [any-element? action?]
    ]

So that **[any-element? action?]** leads to a willingness to accept frame antiforms, as well as anything you can put in a block.  Having such an annotation leads you into the &quot;danger zone&quot; where if you don&#39;t prefix accesses to INITIAL with a colon, you run the risk of running a function.  But if you don&#39;t have the annotation, you don&#39;t have to be paranoid and decorate your references.

Here&#39;s how the INITIAL references wind up in the implementation:

    case [
        block? rest [
            repeat size [append block (array/initial rest :initial)]
        ]
        action? :initial [
            repeat size [append block run :initial]  ; Called every time
        ]
        any-series? initial [
            repeat size [append block (copy/deep initial)]
        ]
    ] else [
        append/dup block initial size
    ]

So the BLOCK! case which recurses uses the :INITIAL for pass-thru.

I used **RUN :INITIAL** when I could have just used **INITIAL**, simply because it feels more clear.  If this wasn&#39;t already contained by being at the end of a block, it would be better to limit the parameterization by saying something like **`apply :initial []`** or the now-equivalent **`initial :: []`**

## And It Works

What we&#39;re kind of accepting as a default is that function generation produces isotopes.  So getting a plain action requires some kind of extra step, like REIFY

    &gt;&gt; func [x] []
    == ~#[frame! [x]]~  ; anti

    &gt;&gt; action: reify func [x] []
    == ~#[frame! {action} [x]]~

    &gt;&gt; action  ; not word!-active
    == ~#[frame! {action} [x]]~
    
    &gt;&gt; ap: reify :append
    == ~#[frame! {ap} [series value /part /dup /line]]~

    &gt;&gt; ap
    == ~#[frame! {ap} [series value /part /dup /line]]~

What this means is that you get a similar behavior to before, where if you pass a &quot;live&quot; function you&#39;ve fetched from a word or just generated, then it runs.  You have to do something extra to it to get it to be inert.

    &gt;&gt; array 3
    == [_ _ _]

    &gt;&gt; array/initial 3 10
    == [10 10 10]

    &gt;&gt; n: 0 array/initial 3 does [n: n + 1]
    == [1 2 3]

    &gt;&gt; array/initial 3 reify does [n: n + 1]
    == [~#[frame! []]~ ~#[frame! []]~ ~#[frame! []]~]

    &gt;&gt; array/initial 3 reify/unquasi does [n: n + 1]
    == [#[frame! []] #[frame! []] #[frame! []]]

## That Looks Like An Isotope Success Story...

It doesn&#39;t require any convoluted thinking to get the literal vs. non-literal distinction.  And you can apply this technique to cases that don&#39;t have a weird workaround.

I wish I could say that all of antiform action impacts were as well sorted out as this looks.  But it&#39;s a start, and it shows the potential.</description>
    
    <lastBuildDate>Mon, 26 Aug 2024 22:02:40 +0000</lastBuildDate>
    <category>Internals</category>
    <atom:link href="https://rebol.metaeducation.com/t/array-initial-and-action-isotopes/1975.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>ARRAY/INITIAL and ACTION! Isotopes</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>So the ARRAY mezzanine from R3-Alpha allowed you to make an array with an initial value that could be a function...in which case it evaluated that function each time:</p>
<pre><code>r3-alpha&gt;&gt; array 3
== [none none none]

r3-alpha&gt;&gt; array/initial 3 10
== [10 10 10]

r3-alpha&gt;&gt; n: 0 array/initial 3 does [n: n + 1]
== [1 2 3]
</code></pre>
<p>This raises the question of how you would make an array whose initial value was itself a function.</p>
<p>If you're a loophole-minded person, you might notice you could trick <em>this particular case</em> by making a function that returns a function.</p>
<pre><code>r3-alpha&gt;&gt; array/initial 3 does [:append]
== [#[action! [...]] #[action! [...]] #[action! [...]]]
</code></pre>
<p>But that's not really a general answer for how to deal with this kind of polymorphism--it just works if you're using the result purely to do a substitution.</p>
<h2><a name="p-6431-trying-this-with-antiform-actions-1" class="anchor" href="https://rebol.metaeducation.com#p-6431-trying-this-with-antiform-actions-1"></a>Trying This With Antiform Actions</h2>
<p>I've loosened my stance on isotopes in function frames as parameters.  It's not a good idea to take them as default, but forcing you to make every parameter ^META just to get isotopes is limiting.</p>
<p>So I gave this a shot...</p>
<pre><code>array: func [
    {Makes and initializes a block of a given size}

    return: "Generated block or null if blank input"
        [block!]
    size "Size or block of sizes for each dimension"
        [&lt;maybe&gt; integer! block!]
    /initial "Initial value (will be called each time if action isotope)"
        [any-element? action?]
]
</code></pre>
<p>So that <strong>[any-element? action?]</strong> leads to a willingness to accept frame antiforms, as well as anything you can put in a block.  Having such an annotation leads you into the "danger zone" where if you don't prefix accesses to INITIAL with a colon, you run the risk of running a function.  But if you don't have the annotation, you don't have to be paranoid and decorate your references.</p>
<p>Here's how the INITIAL references wind up in the implementation:</p>
<pre><code>case [
    block? rest [
        repeat size [append block (array/initial rest :initial)]
    ]
    action? :initial [
        repeat size [append block run :initial]  ; Called every time
    ]
    any-series? initial [
        repeat size [append block (copy/deep initial)]
    ]
] else [
    append/dup block initial size
]
</code></pre>
<p>So the BLOCK! case which recurses uses the :INITIAL for pass-thru.</p>
<p>I used <strong>RUN :INITIAL</strong> when I could have just used <strong>INITIAL</strong>, simply because it feels more clear.  If this wasn't already contained by being at the end of a block, it would be better to limit the parameterization by saying something like <strong><code>apply :initial []</code></strong> or the now-equivalent <strong><code>initial :: []</code></strong></p>
<h2><a name="p-6431-and-it-works-2" class="anchor" href="https://rebol.metaeducation.com#p-6431-and-it-works-2"></a>And It Works</h2>
<p>What we're kind of accepting as a default is that function generation produces isotopes.  So getting a plain action requires some kind of extra step, like REIFY</p>
<pre><code>&gt;&gt; func [x] []
== ~#[frame! [x]]~  ; anti

&gt;&gt; action: reify func [x] []
== ~#[frame! {action} [x]]~

&gt;&gt; action  ; not word!-active
== ~#[frame! {action} [x]]~

&gt;&gt; ap: reify :append
== ~#[frame! {ap} [series value /part /dup /line]]~

&gt;&gt; ap
== ~#[frame! {ap} [series value /part /dup /line]]~
</code></pre>
<p>What this means is that you get a similar behavior to before, where if you pass a "live" function you've fetched from a word or just generated, then it runs.  You have to do something extra to it to get it to be inert.</p>
<pre><code>&gt;&gt; array 3
== [_ _ _]

&gt;&gt; array/initial 3 10
== [10 10 10]

&gt;&gt; n: 0 array/initial 3 does [n: n + 1]
== [1 2 3]

&gt;&gt; array/initial 3 reify does [n: n + 1]
== [~#[frame! []]~ ~#[frame! []]~ ~#[frame! []]~]

&gt;&gt; array/initial 3 reify/unquasi does [n: n + 1]
== [#[frame! []] #[frame! []] #[frame! []]]
</code></pre>
<h2><a name="p-6431-that-looks-like-an-isotope-success-story-3" class="anchor" href="https://rebol.metaeducation.com#p-6431-that-looks-like-an-isotope-success-story-3"></a>That Looks Like An Isotope Success Story...</h2>
<p>It doesn't require any convoluted thinking to get the literal vs. non-literal distinction.  And you can apply this technique to cases that don't have a weird workaround.</p>
<p>I wish I could say that all of antiform action impacts were as well sorted out as this looks.  But it's a start, and it shows the potential.</p>
          <p><a href="https://rebol.metaeducation.com/t/array-initial-and-action-isotopes/1975/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/array-initial-and-action-isotopes/1975/1</link>
        <pubDate>Tue, 20 Sep 2022 18:53:49 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1975-1</guid>
        <source url="https://rebol.metaeducation.com/t/array-initial-and-action-isotopes/1975.rss">ARRAY/INITIAL and ACTION! Isotopes</source>
      </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>How To Indicate &quot;Divergence&quot; in Function RETURN: Spec</title>
    <link>https://rebol.metaeducation.com/t/how-to-indicate-divergence-in-function-return-spec/1667</link>
    <description>Today&#39;s vocabulary word is **[&quot;divergent&quot;](https://en.wikipedia.org/wiki/Divergence_(computer_science))** ... a description for when a function never returns a result in a &quot;normal&quot; way.

All functions that can FAIL or be THROWN or RETURN&#39;d across have divergence as an *option* (which is, right now, all functions).  But it becomes an issue of what to say when there really is no type a function *ever* returns...what do you put in the spec?

Lately I&#39;ve been using just **`[return: []]`**.  That seems pretty solid.  An empty block indicating there&#39;s no types you can return...so any return would generate an error.

But because I can imagine people not knowing what that meant, I find myself always adding a comment so people can look up the term &quot;divergent&quot;:

    catch [
        my-non-returning-function: func [
            return: []  ; divergent
        ][
            if now/month = 8 [
                return &quot;It&#39;s August&quot;  ; oops, meant THROW (so causes error)
            ]
            throw &quot;It&#39;s not August&quot;
        ]
        my-non-returning-function
    ]

My tendency to hedge is probably silly.  Because **`return: []`**  is pretty straightforward.  The comment probably makes it *more* confusing.

So **`return: &lt;divergent&gt;`** (or whatever) is probably not worth it.

*(I should point out that it hasn&#39;t always been as clear that **`return: []`** wouldn&#39;t mean something like &quot;the function is invisible&quot; or &quot;the function returns trash&quot;.  But we have good clear ways of saying those things, so I like this for divergence.)*</description>
    
    <lastBuildDate>Thu, 15 May 2025 15:25:10 +0000</lastBuildDate>
    <category>Functions</category>
    <atom:link href="https://rebol.metaeducation.com/t/how-to-indicate-divergence-in-function-return-spec/1667.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>How To Indicate &quot;Divergence&quot; in Function RETURN: Spec</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1667">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>NULL SPEC is Unconstrained, <code>[]</code> Means Divergent?</p>
</blockquote>
</aside>
<p>We have a new conundrum... in that I no longer think that <strong><code>[~foo~]</code></strong> means "antiform of foo" in function specs.</p>
<p>I said that the introduction of CHAIN!s and arbitrary SIGIL!s meant we'd be needing more destructuring.  Well, that's coming in the types:</p>
<ul>
<li><strong><code>[~word!~]</code></strong> would match a quasiform word!</li>
<li><strong><code>['word!]</code></strong> would match a quoted word</li>
<li><strong><code>[@block!]</code></strong> would match a pinned block</li>
<li><strong><code>[word!:]</code></strong> will match a "set-word-like CHAIN!"</li>
<li><strong><code>[integer!.integer!.integer!]</code></strong> will match a TUPLE of 3 integers, e.g. 1.2.3</li>
</ul>
<p>As exciting as all that is...it's also moving toward some literalism, where <strong><code>[_]</code></strong> would match space (what was blank), <strong><code>[$ ^ @]</code></strong> would match tie/lift/pin, etc. etc.  (Tags still aren't literal, they're parameter options, and I don't know what other things would be literal.)</p>
<p>The importance of all this threatens my beloved <strong><code>return: [~]</code></strong> for "return trash".  It would be <a href="https://rebol.metaeducation.com/t/what-to-call-lone-tilde/2216/16">"return quasar"</a> e.g. quasiform space.</p>
<p>So the only thing more coveted in lexical space than <strong><code>return: [~]</code></strong> here would be to take <strong><code>return: []</code></strong> for "returns trash", e.g. nothing interesting to return.</p>
<p>That would make this a step up instead of a step down.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/ladder.png?v=14" title=":ladder:" class="emoji" alt=":ladder:" loading="lazy" width="20" height="20"></p>
<p><strong><code>return: [&lt;!&gt;]</code></strong> looks pretty good for divergence (although maybe a bit too alarming, as if that should be a shorthand for returns ERROR!...)  <img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>Anyway if done with a tag, it has the property that if a function diverges you could inherit that property through return composition.  If we want to avoid symbols we could just say <strong><code>return: [&lt;divergent&gt;]</code></strong> or <strong><code>return: [&lt;diverges&gt;]</code></strong> and get people to look up what that means on Wikipedia.  I'm a fan of using real terminology.</p>
<p>You wouldn't inherit the trash returning though.  I think this can be worked around.  And I think it's worth it...there absolutely needs to be an easy way to say you have no interesting return result, so I'm game to make it the absolute easiest representation there is.</p>
          <p><a href="https://rebol.metaeducation.com/t/how-to-indicate-divergence-in-function-return-spec/1667/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/how-to-indicate-divergence-in-function-return-spec/1667/3</link>
        <pubDate>Thu, 15 May 2025 12:31:31 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1667-3</guid>
        <source url="https://rebol.metaeducation.com/t/how-to-indicate-divergence-in-function-return-spec/1667.rss">How To Indicate &quot;Divergence&quot; in Function RETURN: Spec</source>
      </item>
      <item>
        <title>How To Indicate &quot;Divergence&quot; in Function RETURN: Spec</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>This raises a little bit of a question...</p>
<p><strong>How do we know the difference between a function that is diverent and one that can return <code>ANY-ATOM?</code>... by the PARAMETER! (or null) answer to its RETURN OF?</strong></p>
<p>If you say:</p>
<pre><code>foo: func [] [return 1020]
</code></pre>
<p>You never specified a <strong><code>return: [...]</code></strong> in that spec.  But the convenient behavior is that it acts as if you had said <strong><code>return: [any-atom?]</code></strong>, e.g. that you could return absolutely any state <em>(including unstable antiforms)</em>.</p>
<h2><a name="p-8192-return-of-as-null-vs-parameter-wnull-spec-1" class="anchor" href="https://rebol.metaeducation.com#p-8192-return-of-as-null-vs-parameter-wnull-spec-1"></a>RETURN OF as NULL vs. PARAMETER! w/NULL SPEC</h2>
<p>The current implementation of FUNC actually will still answer that there is a PARAMETER! representing the RETURN.</p>
<pre><code>&gt;&gt; return of func [] [return 1020]
== #[parameter! [
    spec: ~null~
    text: ~null~
    ...
]]
</code></pre>
<p>While right now LAMBDA will give null:</p>
<pre><code>&gt;&gt; return of func [] [return 1020]
== ~null~  ; anti
</code></pre>
<p><strong>This is probably wrong.</strong>  To an outside observer, it's not clear why the answer should be different.</p>
<p>There's a pretty compelling argument that you should never get NULL back from RETURN OF, as it introduces more situations you have to deal with.</p>
<p><em>(I've been thinking about enhancing OF to be able to say things like <strong><code>return.spec of ...</code></strong> so you don't have to write out <strong><code>(return of ...).spec</code></strong>, and something in that vein is likely in the pipe.  But I do think having the functions for accessing parameters like RETURN OF giving you the full PARAMETER! is the best idea.)</em></p>
<h2><a name="p-8192-null-spec-is-unconstrained-means-divergent-2" class="anchor" href="https://rebol.metaeducation.com#p-8192-null-spec-is-unconstrained-means-divergent-2"></a>NULL SPEC is Unconstrained, <code>[]</code> Means Divergent?</h2>
<p>The thing I want to think about here is creating new parameters out of old ones.</p>
<p>Let's say you have a divergent function, but you enclose it.  Say it's FAIL, and you want to make it only run the (divergent) failure half the time:</p>
<pre><code>rtype: [...]

fail-sporadically: enclose fail/ func compose [return: (rtype) f [frame!]] [
     if 1 = random 2 [return ~]
     return eval f
 ]
</code></pre>
<p>So now half the time it returns trash, and half the time it's divergent.</p>
<p>Imagine working <strong>rtype</strong> out in a generic way:</p>
<pre><code>rtype: compose [(spread return.spec of fail/) trash!]
</code></pre>
<p>Okay, well... you merged the empty block representing divergence and got <code>[trash!]</code>.  You lost the fact that it is "sometimes divergent".</p>
<p><em>Is that important?</em>  I don't think so.  We don't want to go around labeling functions like "IF" divergent just because the BLOCK! they execute may contain a RETURN which crosses the IF... that's the design of the system.  This bolsters the support that <strong><code>return: []</code></strong> for divergence is just the annotation you use when you say a function is <em>only</em> divergent, while being possibly divergent is implicit on all other functions.</p>
<p>Okay... so how does this apply to SPEC being NULL for unconstrained?</p>
<p><strong>The point here is that a missing return spec does <em>not</em> mean you've endorsed that the function returns absolutely anything... it means you were lazy and haven't narrowed it down.</strong>  We do want the state to be ornery enough to alert both the reader (e.g. in HELP) and the creator of derived specs that there's nothing there.</p>
<p>So if you're writing a derived function spec, you'd kind of have to explicitly manage this:</p>
<pre><code>rtype: compose [(spread any [return.spec of xxx/, [any-atom?]) ...]
</code></pre>
<p>If you don't like the fact that composing together return specs is harder when there's no return spec on the function, put return specs on your functions...?</p>
<p>Anyway, I think that's just how this particular cookie bounces.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/cookie.png?v=14" title=":cookie:" class="emoji" alt=":cookie:" loading="lazy" width="20" height="20">  Seems to make sense.</p>
          <p><a href="https://rebol.metaeducation.com/t/how-to-indicate-divergence-in-function-return-spec/1667/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/how-to-indicate-divergence-in-function-return-spec/1667/2</link>
        <pubDate>Thu, 01 May 2025 04:09:13 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1667-2</guid>
        <source url="https://rebol.metaeducation.com/t/how-to-indicate-divergence-in-function-return-spec/1667.rss">How To Indicate &quot;Divergence&quot; in Function RETURN: Spec</source>
      </item>
      <item>
        <title>How To Indicate &quot;Divergence&quot; in Function RETURN: Spec</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Today's vocabulary word is <strong><a href="https://en.wikipedia.org/wiki/Divergence_(computer_science)">"divergent"</a></strong> ... a description for when a function never returns a result in a "normal" way.</p>
<p>All functions that can FAIL or be THROWN or RETURN'd across have divergence as an <em>option</em> (which is, right now, all functions).  But it becomes an issue of what to say when there really is no type a function <em>ever</em> returns...what do you put in the spec?</p>
<p>Lately I've been using just <strong><code>[return: []]</code></strong>.  That seems pretty solid.  An empty block indicating there's no types you can return...so any return would generate an error.</p>
<p>But because I can imagine people not knowing what that meant, I find myself always adding a comment so people can look up the term "divergent":</p>
<pre><code>catch [
    my-non-returning-function: func [
        return: []  ; divergent
    ][
        if now/month = 8 [
            return "It's August"  ; oops, meant THROW (so causes error)
        ]
        throw "It's not August"
    ]
    my-non-returning-function
]
</code></pre>
<p>My tendency to hedge is probably silly.  Because <strong><code>return: []</code></strong>  is pretty straightforward.  The comment probably makes it <em>more</em> confusing.</p>
<p>So <strong><code>return: &lt;divergent&gt;</code></strong> (or whatever) is probably not worth it.</p>
<p><em>(I should point out that it hasn't always been as clear that <strong><code>return: []</code></strong> wouldn't mean something like "the function is invisible" or "the function returns trash".  But we have good clear ways of saying those things, so I like this for divergence.)</em></p>
          <p><a href="https://rebol.metaeducation.com/t/how-to-indicate-divergence-in-function-return-spec/1667/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/how-to-indicate-divergence-in-function-return-spec/1667/1</link>
        <pubDate>Mon, 16 Aug 2021 02:35:54 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1667-1</guid>
        <source url="https://rebol.metaeducation.com/t/how-to-indicate-divergence-in-function-return-spec/1667.rss">How To Indicate &quot;Divergence&quot; in Function RETURN: Spec</source>
      </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
    <link>https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253</link>
    <description>R3-Alpha had an idea--carried forward by Red--of an **arity-1** IF combinator.

    red&gt;&gt; num: 1020

    red&gt;&gt; parse [a a a] [if (even? num) some &#39;a]
    == true

    red&gt;&gt; parse [a a a] [if (odd? num) some &#39;a]
    == false

As you see, if the expression you give it turns out to be &quot;falsey&quot; then it doesn&#39;t continue matching.  It skips to the next alternate--if there is one.

    red&gt;&gt; parse [a a a] [if (odd? num) some &#39;b | some &#39;a]
    == true

But I always thought the arity-1 IF was a pretty alien thing that would confuse people.  You might think there&#39;s a branch, but there&#39;s no &quot;branch&quot;... just continuing along with the variadic list of everything that follows until the next **|** or end of BLOCK!.

I also wondered &quot;where does it end?&quot;  With an IF combinator, why not a CASE combinator, or SWITCH combinator?

So when I came up with GET-GROUP! doing arbitrary substitutions of the rule it evaluates to, I thought &quot;hey, that&#39;s a lot more general!&quot;  We could just say that ~true~ and ~void~ antiforms would continue the parse, ~false~ would stop it, and ~null~ antiforms would trigger an error in case you didn&#39;t mean to do that.

### What That `:(GET-GROUP!)` Concept Looked Like

*(Note that **if condition &#39;[...]** is equivalent to **if condition [[...]]**.  This is called [&quot;soft-quoted branching&quot;](https://rebol.metaeducation.com/t/soft-quoted-branching-light-elegant-fast/1020))*

    &gt;&gt; num: 1020, rule: null

    ; generated [some &#39;b] rule is treated as if it had been written there
    &gt;&gt; parse [a a a b b b] [some &#39;a :(if even? num &#39;[some &#39;b])]
    == b 

    ; generated ~void~ from non-taken IF gets ignored, and it kept parsing
    &gt;&gt; parse [a a a b b b] [some &#39;a :(if odd? num &#39;[some &#39;c]) some &#39;b]
    == b

    ; generated ~true~ signal continues parse, just as ~void~ did
    &gt;&gt; parse [a a a b b b] [some &#39;a :(even? num) some &#39;b]
    == b

    ; generated ~false~ skips to next alternate (isn&#39;t one, so parse fails)
    &gt;&gt; parse [a a a b b b] [some &#39;a :(odd? num) some &#39;b]
    ** Error: PARSE BLOCK! combinator did not match input

    ; treat ~null~ conservatively, use :(maybe rule) for ~void~ to keep going 
    &gt;&gt; parse [a a a b b b] [some &#39;a :(rule) some &#39;b]
    ** Error: ~null~ antiform generated by GET-GROUP! in PARSE

## [Flexible Logic](https://rebol.metaeducation.com/t/flexible-logic-system-terminology/2252) Kills `[~true~ ~false~]`... Breaks That Idea

In the flexible logic model, `[TRUE FALSE ON OFF YES NO]` are WORD!s, and hence indiscriminately trigger taking the branch in something like an IF when used directly.  The ~null~ antiform is the &quot;branch inhibitor&quot;, and it&#39;s what conditional expressions return when they don&#39;t match the condition.

    &gt;&gt; 10 &gt; 20
    == ~null~  ; anti

I don&#39;t think it&#39;s a good idea to make substitions via GET-GROUP! (or whatever comes to replace it) silently continue on NULL.  If you forgot to set a variable that was supposed to hold something (as in **rule** above), that should give you an error.  But I don&#39;t think you should have to write **:(maybe even? num)** :nauseated_face: 

## So Having A Conditional Logic Combinator Makes Sense

I just think that IF is a rather lousy name for it.

So I&#39;ll suggest **WHEN**.

    &gt;&gt; parse [a a a b b b] [some &#39;a, when (even? num), some &#39;b]
    == b 

It would be against the premise of flexible logic to have WHEN be biased and assume things like TRUE, YES, or NO should mean it continues or not.  I like the idea that you could hold a completely arbitrary word in a variable and say **`when (word)`**, that means *&quot;continue matching when word is set to a non-null value&quot;*.

Hence you&#39;d have to say **`when (true? flag)`** or **`when (off? toggle)`** etc.  I&#39;m not merely *comfortable* with this... I am gung-ho about it! :comet:

(Of course people can make their own combinators and build in biases of their choosing, the core just doesn&#39;t pick sides.)

## BYPASS Can Be A Synonym For `[when (null)]`

I didn&#39;t like using FAIL for saying when to stop a rule chain and go to the next alternate, because that is used for causing &quot;abrupt failures&quot; in the system.

So I&#39;d been using quasiform `~false~` the state in source (and the antiform if in a variable).

    &gt;&gt; parse [a a a b b b] [some &#39;a, :(if even? num [false]), some &#39;b]
    ** Error: PARSE BLOCK! combinator did not match input

    &gt;&gt; parse [a a a b b b] [some &#39;a, ~false~, some &#39;b]
    ** Error: PARSE BLOCK! combinator did not match input

But that isn&#39;t the model anymore.  There is no ~false~ or ~true~ antiform.  And honestly it wasn&#39;t that literate anyway. **when (...)** makes it clearer when you&#39;re using a variable.  And the quasiform just looks confusing.

Searching for a good word that doesn&#39;t run into something serving other purposes (e.g. BREAK), I asked Claude.ai for suggestions, and one of those was BYPASS.

I like it.  So for example you could write:

    &gt;&gt; parse [a a a b b b] [some &#39;a [:(if even? num [&#39;bypass]) some &#39;c] | some &#39;b]]
    == b

Although that particular case is clearer as **`[when (odd? num) ...]`**, but sometimes you have to throw in a bypass rule.

*(Amusingly, in Rebol2 the idiom for BYPASS was **`[end skip]`**, which was a rule guaranteed to mismatch at any position: either you weren&#39;t at the tail and the END wouldn&#39;t match, or you were at the tail and the END would match but then you couldn&#39;t SKIP.)*

## Where Does It Stop?

&gt; I also wondered &quot;where does it end?&quot;  With an IF combinator, why not a CASE combinator, or SWITCH combinator?

So I think it&#39;s good to just say WHEN.

You don&#39;t *technically* need WHEN if you have BYPASS to skip to next alternate, and ~void~ to keep going (or empty block, if you like... `[]` will keep going too).

     when (cond) =&gt; :(if not cond [&#39;bypass])  ; or :(if not cond &#39;bypass)

But that forces you to reverse the sense of your logic and write out something longer (and slower).  I think if you&#39;ve got logic that&#39;s complex like a case or switch, then writing it out as a splicing rule would have negligible benefit to try and shoehorn as a combinator.</description>
    
    <lastBuildDate>Fri, 13 Sep 2024 04:50:09 +0000</lastBuildDate>
    <category>Parsing</category>
    <atom:link href="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2253">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I don't think it's a good idea to make substitions via GET-GROUP! (or whatever comes to replace it) silently continue on NULL. If you forgot to set a variable that was supposed to hold something (as in <strong>rule</strong> above), that should give you an error. But I don't think you should have to write <strong>:(maybe even? num)</strong> <img src="https://rebol.metaeducation.com/images/emoji/twitter/nauseated_face.png?v=14" title=":nauseated_face:" class="emoji" alt=":nauseated_face:" loading="lazy" width="20" height="20"></p>
</blockquote>
</aside>
<p>Having spent some time with this in practice, I'm wondering if it's doing more harm than good to not allowing NULL in GET-GROUP! substitutions to mean <em>"rule doesn't match"</em>.</p>
<p>It's particularly painful with WHILE:</p>
<pre><code>while :(mode = 'read) [some chunk]

; vs.

while when (mode = 'read) [some chunk]
</code></pre>
<p><strong>I am uncertain that the safety advantage is really worth it.</strong>  NULL variables aren't unset variables.  Having the state mean "don't keep going" seems useful enough to outweigh the occasional accident of "I meant to have a rule here but forgot it" case.</p>
<p>So I'm changing splicing to be null tolerant (well, tolerant in the sense that it won't abruptly fail, but triggers a rule mismatch).</p>
<p>The bigger issue is that leading colon for this is likely not going to be what it is, given the new general semantics of "optionality" that leading colon implies.  <a href="https://rebol.metaeducation.com/t/get-group-s-in-parse-mean-execute-and-splice-as-rule/968/18">So I'm thinking that's going to be doubled groups again.</a></p>
<pre><code>while ((mode = 'read)) [some chunk]
</code></pre>
          <p><a href="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253/13">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253/13</link>
        <pubDate>Fri, 13 Sep 2024 04:50:09 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2253-13</guid>
        <source url="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
      </item>
      <item>
        <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>You'll have to use an example then.</p>
<p>In the ordinary evaluator, IF does nothing if the condition is false...so you'll have to illustrate what you mean.</p>
          <p><a href="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253/12">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253/12</link>
        <pubDate>Fri, 06 Sep 2024 04:15:40 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2253-12</guid>
        <source url="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
      </item>
      <item>
        <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <p>Oh, looks like there’s been more confusion, sorry… I meant, outside PARSE altogether! That is, at the ‘top level’ of the program.</p>
          <p><a href="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253/11">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253/11</link>
        <pubDate>Fri, 06 Sep 2024 04:14:32 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2253-11</guid>
        <source url="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
      </item>
      <item>
        <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Ah, so the "actual" IF combinator.</p>
<p>We can accomplish the most typical desire with <strong><code>:(if condition block)</code></strong></p>
<ul>
<li>
<p>When the condition is not null, the block is evaluated and its product used as a rule.</p>
</li>
<li>
<p>When the condition is null, a ~void~ antiform is returned from the IF, and the evaluator skips it and keeps going.</p>
</li>
</ul>
<p>If we made an IF combinator, you'd have to put your conditional code in a GROUP!.  Unless you meant to actually match content with a rule as your condition, like this:</p>
<pre><code>&gt;&gt; parse [hello world 304] [if opt 'hello [word! integer!]]
== 304
</code></pre>
<p>So what you used as a condition was what was synthesized by <code>[opt 'hello]</code> ... in this case the WORD! <code>hello</code> that matched (had it not matched it would be null).  Then since it was non-null, it matched the next block vs. skipping it.</p>
<p>That's something you can't do with putting the code in a GET-GROUP!.  I don't know how frequent that desire is, since most of the desire has been to control a rule based on a guard flag of some kind.</p>
<pre><code>&gt;&gt; worldnumber: 'true

&gt;&gt; parse [world 304] [if (true? worldnumber) [word! integer!]]
== 304
</code></pre>
<p>If that's the case, then your advantage can be small...as small as two characters for having the combinator.</p>
<pre><code>:(if true? worldnumber '[word! integer!])
if (true? worldnumber) [word! integer!]
</code></pre>
<p>But...I mean, I guess an IF combinator of that sort would be all right to have.  Trivial to write.  Just perhaps a little leery of the slippery slope of recreating every control construct as a combinator.</p>
<p>Were it to exist, I'd probably find uses for it.</p>
          <p><a href="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253/10">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253/10</link>
        <pubDate>Fri, 06 Sep 2024 04:09:20 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2253-10</guid>
        <source url="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
      </item>
      <item>
        <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <p>Basically, <code>when condition block ≡ if condition block []</code>. That is, it would run the given block if the condition is true, and do nothing otherwise.</p>
          <p><a href="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253/9">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253/9</link>
        <pubDate>Fri, 06 Sep 2024 03:54:16 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2253-9</guid>
        <source url="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
      </item>
      <item>
        <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Well now I'm confused, what would a "top level" WHEN combinator be?</p>
          <p><a href="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253/8">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253/8</link>
        <pubDate>Fri, 06 Sep 2024 02:02:58 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2253-8</guid>
        <source url="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
      </item>
      <item>
        <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <p>Oh… whoops, OK, not sure how I missed that. For some reason I thought you were talking about WHEN as a top-level combinator. (Which is <em>also</em> a very useful thing to have!)</p>
          <p><a href="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253/7">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253/7</link>
        <pubDate>Fri, 06 Sep 2024 02:00:59 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2253-7</guid>
        <source url="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
      </item>
      <item>
        <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>This is the example of using it in PARSE.</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="2253">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So Having A Conditional Logic Combinator Makes Sense</p>
<p>I just think that IF is a rather lousy name for it.</p>
<p>So I'll suggest <strong>WHEN</strong>.</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; num: 1020

&gt;&gt; parse [a a a b b b] [some 'a, when (even? num), some 'b]
== b 
</code></pre>
</blockquote>
</aside>
<p>I didn't add the failing case, but:</p>
<pre><code>&gt;&gt; parse [a a a b b b] [some 'a, when (odd? num), some 'b]
** Error: PARSE BLOCK! combinator did not match input
</code></pre>
<p>I don't know how it would be applied in the main evaluator...</p>
          <p><a href="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253/6">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253/6</link>
        <pubDate>Fri, 06 Sep 2024 01:49:20 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2253-6</guid>
        <source url="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
      </item>
      <item>
        <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2253">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Problem is when I go off and experiment I tend to tackle too many things at once, I tried to do Haskell on Arch Linux and got bored trying to figure it out.</p>
</blockquote>
</aside>
<p>Ah-ha. Do <em>not</em> use Haskell libraries from the Arch package repositories. They are famously broken, mostly because GHC doesn’t play well with dynamic linking. (I say this as someone using Arch myself.)</p>
<p>Instead, I strongly recommend using <a href="https://www.haskell.org/ghcup/">GHCup</a>.</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="3" data-topic="2253">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2253">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Would you consider adding it to <code>parse</code> dialect too?</p>
</blockquote>
</aside>
<p>Hm? This is the PARSE dialect... what do you mean?</p>
</blockquote>
</aside>
<p>Hmm, maybe I’m just struggling to understand your PARSE examples. Where in that post did you show an example of WHEN in PARSE?</p>
          <p><a href="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253/4</link>
        <pubDate>Fri, 06 Sep 2024 01:46:50 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2253-4</guid>
        <source url="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
      </item>
      <item>
        <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2253">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>A good name — Haskell calls it this too.</p>
</blockquote>
</aside>
<p>I really should have clocked more time using Haskell to parse stuff.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>Problem is when I go off and experiment I tend to tackle too many things at once, I tried to do Haskell on Arch Linux and got bored trying to figure it out.</p>
<aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2253">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Would you consider adding it to <code>parse</code> dialect too?</p>
</blockquote>
</aside>
<p>Hm?  This is the PARSE dialect... what do you mean?</p>
          <p><a href="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253/3</link>
        <pubDate>Fri, 06 Sep 2024 01:15:52 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2253-3</guid>
        <source url="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
      </item>
      <item>
        <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2253">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So I'll suggest <strong>WHEN</strong>.</p>
</blockquote>
</aside>
<p>A good name — Haskell calls it this too. It’s a very useful combinator, so good to have.</p>
<p>Would you consider adding it to <code>parse</code> dialect too? It has a natural interpretation: parse the next thing only when the condition is true. (Again, this is something Haskell has.)</p>
          <p><a href="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253/2</link>
        <pubDate>Fri, 06 Sep 2024 01:13:08 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2253-2</guid>
        <source url="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
      </item>
      <item>
        <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>R3-Alpha had an idea--carried forward by Red--of an <strong>arity-1</strong> IF combinator.</p>
<pre><code>red&gt;&gt; num: 1020

red&gt;&gt; parse [a a a] [if (even? num) some 'a]
== true

red&gt;&gt; parse [a a a] [if (odd? num) some 'a]
== false
</code></pre>
<p>As you see, if the expression you give it turns out to be "falsey" then it doesn't continue matching.  It skips to the next alternate--if there is one.</p>
<pre><code>red&gt;&gt; parse [a a a] [if (odd? num) some 'b | some 'a]
== true
</code></pre>
<p>But I always thought the arity-1 IF was a pretty alien thing that would confuse people.  You might think there's a branch, but there's no "branch"... just continuing along with the variadic list of everything that follows until the next <strong>|</strong> or end of BLOCK!.</p>
<p>I also wondered "where does it end?"  With an IF combinator, why not a CASE combinator, or SWITCH combinator?</p>
<p>So when I came up with GET-GROUP! doing arbitrary substitutions of the rule it evaluates to, I thought "hey, that's a lot more general!"  We could just say that ~true~ and ~void~ antiforms would continue the parse, ~false~ would stop it, and ~null~ antiforms would trigger an error in case you didn't mean to do that.</p>
<h3><a name="p-7569-what-that-get-group-concept-looked-like-1" class="anchor" href="https://rebol.metaeducation.com#p-7569-what-that-get-group-concept-looked-like-1"></a>What That <code>:(GET-GROUP!)</code> Concept Looked Like</h3>
<p><em>(Note that <strong>if condition '[...]</strong> is equivalent to <strong>if condition [[...]]</strong>.  This is called <a href="https://rebol.metaeducation.com/t/soft-quoted-branching-light-elegant-fast/1020">"soft-quoted branching"</a>)</em></p>
<pre><code>&gt;&gt; num: 1020, rule: null

; generated [some 'b] rule is treated as if it had been written there
&gt;&gt; parse [a a a b b b] [some 'a :(if even? num '[some 'b])]
== b 

; generated ~void~ from non-taken IF gets ignored, and it kept parsing
&gt;&gt; parse [a a a b b b] [some 'a :(if odd? num '[some 'c]) some 'b]
== b

; generated ~true~ signal continues parse, just as ~void~ did
&gt;&gt; parse [a a a b b b] [some 'a :(even? num) some 'b]
== b

; generated ~false~ skips to next alternate (isn't one, so parse fails)
&gt;&gt; parse [a a a b b b] [some 'a :(odd? num) some 'b]
** Error: PARSE BLOCK! combinator did not match input

; treat ~null~ conservatively, use :(maybe rule) for ~void~ to keep going 
&gt;&gt; parse [a a a b b b] [some 'a :(rule) some 'b]
** Error: ~null~ antiform generated by GET-GROUP! in PARSE
</code></pre>
<h2><a name="p-7569-flexible-logichttpsrebolmetaeducationcomtflexible-logic-system-terminology2252-kills-true-false-breaks-that-idea-2" class="anchor" href="https://rebol.metaeducation.com#p-7569-flexible-logichttpsrebolmetaeducationcomtflexible-logic-system-terminology2252-kills-true-false-breaks-that-idea-2"></a><a href="https://rebol.metaeducation.com/t/flexible-logic-system-terminology/2252">Flexible Logic</a> Kills <code>[~true~ ~false~]</code>... Breaks That Idea</h2>
<p>In the flexible logic model, <code>[TRUE FALSE ON OFF YES NO]</code> are WORD!s, and hence indiscriminately trigger taking the branch in something like an IF when used directly.  The ~null~ antiform is the "branch inhibitor", and it's what conditional expressions return when they don't match the condition.</p>
<pre><code>&gt;&gt; 10 &gt; 20
== ~null~  ; anti
</code></pre>
<p>I don't think it's a good idea to make substitions via GET-GROUP! (or whatever comes to replace it) silently continue on NULL.  If you forgot to set a variable that was supposed to hold something (as in <strong>rule</strong> above), that should give you an error.  But I don't think you should have to write <strong>:(maybe even? num)</strong> <img src="https://rebol.metaeducation.com/images/emoji/twitter/nauseated_face.png?v=14" title=":nauseated_face:" class="emoji" alt=":nauseated_face:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-7569-so-having-a-conditional-logic-combinator-makes-sense-3" class="anchor" href="https://rebol.metaeducation.com#p-7569-so-having-a-conditional-logic-combinator-makes-sense-3"></a>So Having A Conditional Logic Combinator Makes Sense</h2>
<p>I just think that IF is a rather lousy name for it.</p>
<p>So I'll suggest <strong>WHEN</strong>.</p>
<pre><code>&gt;&gt; parse [a a a b b b] [some 'a, when (even? num), some 'b]
== b 
</code></pre>
<p>It would be against the premise of flexible logic to have WHEN be biased and assume things like TRUE, YES, or NO should mean it continues or not.  I like the idea that you could hold a completely arbitrary word in a variable and say <strong><code>when (word)</code></strong>, that means <em>"continue matching when word is set to a non-null value"</em>.</p>
<p>Hence you'd have to say <strong><code>when (true? flag)</code></strong> or <strong><code>when (off? toggle)</code></strong> etc.  I'm not merely <em>comfortable</em> with this... I am gung-ho about it! <img src="https://rebol.metaeducation.com/images/emoji/twitter/comet.png?v=14" title=":comet:" class="emoji" alt=":comet:" loading="lazy" width="20" height="20"></p>
<p>(Of course people can make their own combinators and build in biases of their choosing, the core just doesn't pick sides.)</p>
<h2><a name="p-7569-bypass-can-be-a-synonym-for-when-null-4" class="anchor" href="https://rebol.metaeducation.com#p-7569-bypass-can-be-a-synonym-for-when-null-4"></a>BYPASS Can Be A Synonym For <code>[when (null)]</code></h2>
<p>I didn't like using FAIL for saying when to stop a rule chain and go to the next alternate, because that is used for causing "abrupt failures" in the system.</p>
<p>So I'd been using quasiform <code>~false~</code> the state in source (and the antiform if in a variable).</p>
<pre><code>&gt;&gt; parse [a a a b b b] [some 'a, :(if even? num [false]), some 'b]
** Error: PARSE BLOCK! combinator did not match input

&gt;&gt; parse [a a a b b b] [some 'a, ~false~, some 'b]
** Error: PARSE BLOCK! combinator did not match input
</code></pre>
<p>But that isn't the model anymore.  There is no ~false~ or ~true~ antiform.  And honestly it wasn't that literate anyway. <strong>when (...)</strong> makes it clearer when you're using a variable.  And the quasiform just looks confusing.</p>
<p>Searching for a good word that doesn't run into something serving other purposes (e.g. BREAK), I asked Claude.ai for suggestions, and one of those was BYPASS.</p>
<p>I like it.  So for example you could write:</p>
<pre><code>&gt;&gt; parse [a a a b b b] [some 'a [:(if even? num ['bypass]) some 'c] | some 'b]]
== b
</code></pre>
<p>Although that particular case is clearer as <strong><code>[when (odd? num) ...]</code></strong>, but sometimes you have to throw in a bypass rule.</p>
<p><em>(Amusingly, in Rebol2 the idiom for BYPASS was <strong><code>[end skip]</code></strong>, which was a rule guaranteed to mismatch at any position: either you weren't at the tail and the END wouldn't match, or you were at the tail and the END would match but then you couldn't SKIP.)</em></p>
<h2><a name="p-7569-where-does-it-stop-5" class="anchor" href="https://rebol.metaeducation.com#p-7569-where-does-it-stop-5"></a>Where Does It Stop?</h2>
<blockquote>
<p>I also wondered "where does it end?"  With an IF combinator, why not a CASE combinator, or SWITCH combinator?</p>
</blockquote>
<p>So I think it's good to just say WHEN.</p>
<p>You don't <em>technically</em> need WHEN if you have BYPASS to skip to next alternate, and ~void~ to keep going (or empty block, if you like... <code>[]</code> will keep going too).</p>
<pre><code> when (cond) =&gt; :(if not cond ['bypass])  ; or :(if not cond 'bypass)
</code></pre>
<p>But that forces you to reverse the sense of your logic and write out something longer (and slower).  I think if you've got logic that's complex like a case or switch, then writing it out as a splicing rule would have negligible benefit to try and shoehorn as a combinator.</p>
          <p><a href="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253/1</link>
        <pubDate>Thu, 05 Sep 2024 20:19:34 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2253-1</guid>
        <source url="https://rebol.metaeducation.com/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
      </item>
  </channel>
</rss>

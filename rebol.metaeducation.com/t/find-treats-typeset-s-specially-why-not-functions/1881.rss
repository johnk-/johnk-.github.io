<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>FIND treats TYPESET!s specially...why not functions?</title>
    <link>https://rebol.metaeducation.com/t/find-treats-typeset-s-specially-why-not-functions/1881</link>
    <description>In Rebol2, R3-Alpha, and Red...doing a FIND searching for a TYPESET! will give you the first instance of that type in a block:

    &gt;&gt; find [1 2 &quot;abc&quot; 3 4] any-string!
    == [&quot;abc&quot; 3 4]

    &gt;&gt; find [1 2 &lt;abc&gt; 3 4] any-string!
    == [&lt;abc&gt; 3 4]

One would think that you&#39;d be able to search for the typeset literally by using /ONLY.  But that doesn&#39;t work *(though Red says [they addressed this recently](https://github.com/red/red/issues/4911))*

### Why Wasn&#39;t This Taken Further?

Trying to FIND a function is pretty rare.  So why didn&#39;t they make it so that passing a function to FIND makes it search?

    &gt;&gt; find [1 2 3 4] func [x] [x &gt; 2]
    == [3 4]

If a function took multiple arguments, that could be asking it to effectively /SKIP and group items at a time:

    &gt;&gt; find [1 2 4 3 5 6] func [a b] [a &gt; b]
    == [4 3 5 6]

/ONLY could have worked for finding a function literally:

    &gt;&gt; find/only reduce [:positive? :zero? :negative?] :zero?
    == [#[native! zero?...] #[native! negative?...]]</description>
    
    <lastBuildDate>Mon, 02 Jun 2025 16:38:23 +0000</lastBuildDate>
    <category>Dialects/DSLs</category>
    <atom:link href="https://rebol.metaeducation.com/t/find-treats-typeset-s-specially-why-not-functions/1881.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>FIND treats TYPESET!s specially...why not functions?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1881">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>/ONLY could have worked for finding a function literally:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; find/only reduce [:positive? :zero? :negative?] :zero?
== [#[native! zero?...] #[native! negative?...]]
</code></pre>
</blockquote>
</aside>
<h1><a name="p-6265-actiondatatype-antiforms-to-the-rescue-1" class="anchor" href="https://rebol.metaeducation.com#p-6265-actiondatatype-antiforms-to-the-rescue-1"></a>ACTION!/DATATYPE! Antiforms To The Rescue!</h1>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/tophat.png?v=14" title=":tophat:" class="emoji only-emoji" alt=":tophat:" loading="lazy" width="20" height="20"> <img src="https://rebol.metaeducation.com/images/emoji/twitter/mage.png?v=14" title=":mage:" class="emoji only-emoji" alt=":mage:" loading="lazy" width="20" height="20"></p>
<p>As with most other places that needed <code>/ONLY</code> historically, antiforms solve this... since you can't put ACTION! or DATATYPE! into lists, there's no issue.</p>
<p>Also, you can create matching functions from arbitrary type blocks:</p>
<pre><code>&gt;&gt; matches [integer! tag!]
== \~&amp;[frame! [value]]~\ ; antiform

&gt;&gt; find [a b c 1 2 3] matches [integer! tag!]
== [1 2 3]
</code></pre>
<p><em>Remember that antiforms cannot be put into blocks.</em>  Only quasiforms (which are real values, that <em>evaluate</em> to antiforms).  So there's no gray area here--it means what it means--match instances of the type.</p>
          <p><a href="https://rebol.metaeducation.com/t/find-treats-typeset-s-specially-why-not-functions/1881/5">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/find-treats-typeset-s-specially-why-not-functions/1881/5</link>
        <pubDate>Fri, 19 Aug 2022 01:52:29 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1881-5</guid>
        <source url="https://rebol.metaeducation.com/t/find-treats-typeset-s-specially-why-not-functions/1881.rss">FIND treats TYPESET!s specially...why not functions?</source>
      </item>
      <item>
        <title>FIND treats TYPESET!s specially...why not functions?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <h2><a name="p-6262-i-remember-first-seeing-the-r3-alpha-code-for-find-1" class="anchor" href="https://rebol.metaeducation.com#p-6262-i-remember-first-seeing-the-r3-alpha-code-for-find-1"></a>I Remember First Seeing The R3-Alpha Code For Find...</h2>
<p>It was a <em><a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/t-block.c#L149">semantic nightmare</a></em>, and I remember thinking <em>"is the code really just full of issues like this?"</em>  (yes, it was, and Ren-C has been stamping them out)</p>
<p>Here you see it's a complete crapshoot as to what you're going to get back.  Maybe it'll point at a datatype.  Maybe a typeset.  Maybe an instance...it didn't discriminate.</p>
<pre><code>// Find a datatype in block:
else if (IS_DATATYPE(target) || IS_TYPESET(target)) {
	for (; index &gt;= start &amp;&amp; index &lt; end; index += skip) {
		value = BLK_SKIP(series, index);
		// Used if's so we can trace it...
		if (IS_DATATYPE(target)) {
			if ((REBINT)VAL_TYPE(value) == VAL_DATATYPE(target)) return index;
			if (IS_DATATYPE(value) &amp;&amp; VAL_DATATYPE(value) == VAL_DATATYPE(target)) return index;
		}
		if (IS_TYPESET(target)) {
			if (TYPE_CHECK(target, VAL_TYPE(value))) return index;
			if (IS_DATATYPE(value) &amp;&amp; TYPE_CHECK(target, VAL_DATATYPE(value))) return index;
			if (IS_TYPESET(value) &amp;&amp; EQUAL_TYPESET(value, target)) return index;
		}
		if (flags &amp; AM_FIND_MATCH) break;
	}
	return NOT_FOUND;
}
</code></pre>
<p>I suppose the thought process behind this would be that if you were looking in a block for a datatype or typeset, it was probably a block that didn't contain other things.  So it assumes you wouldn't be mixing datatypes and integers in the same block.</p>
<p>But if you're using a block as a kind of mapping structure, you may well be mixing keys that are sometimes datatypes and sometimes instances.  UPARSE does this... it doesn't have separate mapping tables for finding the combinator registered for the general datatype of WORD! vs. a specific WORD! that acts as a keyword.  It just has one big table (implemented with map, but you could imagine it being done differently if it were working in a row-oriented manner).</p>
          <p><a href="https://rebol.metaeducation.com/t/find-treats-typeset-s-specially-why-not-functions/1881/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/find-treats-typeset-s-specially-why-not-functions/1881/4</link>
        <pubDate>Fri, 19 Aug 2022 00:49:21 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1881-4</guid>
        <source url="https://rebol.metaeducation.com/t/find-treats-typeset-s-specially-why-not-functions/1881.rss">FIND treats TYPESET!s specially...why not functions?</source>
      </item>
      <item>
        <title>FIND treats TYPESET!s specially...why not functions?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>In Rebol2, R3-Alpha, and Red...doing a FIND searching for a TYPESET! will give you the first instance of that type in a block:</p>
<pre><code>&gt;&gt; find [1 2 "abc" 3 4] any-string!
== ["abc" 3 4]

&gt;&gt; find [1 2 &lt;abc&gt; 3 4] any-string!
== [&lt;abc&gt; 3 4]
</code></pre>
<p>One would think that you'd be able to search for the typeset literally by using /ONLY.  But that doesn't work <em>(though Red says <a href="https://github.com/red/red/issues/4911">they addressed this recently</a>)</em></p>
<h3><a name="p-6061-why-wasnt-this-taken-further-1" class="anchor" href="https://rebol.metaeducation.com#p-6061-why-wasnt-this-taken-further-1"></a>Why Wasn't This Taken Further?</h3>
<p>Trying to FIND a function is pretty rare.  So why didn't they make it so that passing a function to FIND makes it search?</p>
<pre><code>&gt;&gt; find [1 2 3 4] func [x] [x &gt; 2]
== [3 4]
</code></pre>
<p>If a function took multiple arguments, that could be asking it to effectively /SKIP and group items at a time:</p>
<pre><code>&gt;&gt; find [1 2 4 3 5 6] func [a b] [a &gt; b]
== [4 3 5 6]
</code></pre>
<p>/ONLY could have worked for finding a function literally:</p>
<pre><code>&gt;&gt; find/only reduce [:positive? :zero? :negative?] :zero?
== [#[native! zero?...] #[native! negative?...]]
</code></pre>
          <p><a href="https://rebol.metaeducation.com/t/find-treats-typeset-s-specially-why-not-functions/1881/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/find-treats-typeset-s-specially-why-not-functions/1881/1</link>
        <pubDate>Thu, 14 Jul 2022 10:36:59 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1881-1</guid>
        <source url="https://rebol.metaeducation.com/t/find-treats-typeset-s-specially-why-not-functions/1881.rss">FIND treats TYPESET!s specially...why not functions?</source>
      </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>The TYPESET! Representation Problem</title>
    <link>https://rebol.metaeducation.com/t/the-typeset-representation-problem/1300</link>
    <description>TYPESET! took advantage of 64-bit integers--and a limitation of 64 fundamental types--to fit 64 bit flags into a single value cell to represent a typeset.  Besides the obvious lack of extensibility, this has a number of problems.  One of which is that typesets render in a pretty ugly way...a seemingly simple concept like ANY-TYPE! expands out fairly monstrously:

    r3-alpha&gt;&gt; print mold any-type!
    make typeset! [unset! none! logic! integer! decimal! percent! money! char!
    pair! tuple! time! date! binary! string! file! email! url! tag! bitset! image!
    vector! block! paren! path! set-path! get-path! lit-path! map! datatype!
    typeset! word! set-word! get-word! lit-word! refinement! issue! native!
    action! rebcode! command! op! closure! function! frame! object! module!
    error! task! port! gob! event! handle! struct! library! utype!]

    red&gt;&gt; print mold any-type!
    make typeset! [datatype! unset! none! logic! block! paren! string! file!
    url! char! integer! float! word! set-word! lit-word! get-word! refinement!
    issue! native! action! op! function! path! lit-path! set-path! get-path!
    routine! bitset! object! typeset! error! vector! hash! pair! percent! tuple!
    map! binary! time! tag! email! handle! date! port! image! event!]

People are used to typing in variables--like arrays or objects--and seeing what they look up to be a large amount of data.  But a typeclass like ANY-TYPE! doesn&#39;t typically have this &quot;explosive&quot; character...and it impedes readability.

**If you look closely you&#39;ll see another sneaking problem hinted at by R3-Alpha&#39;s never-implemented UTYPE!** (for user-defined type).  Imagining that it had an implementation, this would suggest that all user-defined types would be considered equivalent in a TYPESET!.  If you took one user-defined type as a parameter, you would have to take them all, and do some filtering on it after the fact.

*(In fact, [extension types](https://rebol.metaeducation.com/t/user-defined-datatype-discussion/1203/2?u=hostilefork) in Ren-C (which are on hold at time of writing) had this very problem.  If you passed a GOB! to a native routine that expects a VECTOR! or a STRUCT!, it would crash.  It&#39;s something that a real answer to typesets would have to address, part of why I&#39;m mentioning all this.)*

# This doesn&#39;t even touch upon the idea of &quot;type-classes&quot;...

e.g. if you decide to make a base object with something like **book!: make object! [...]** and later **make book! [...]**, this &quot;book!&quot; is the kind of thing you might consider in some languages to be a class.  You might want to write a routine like **library-checkout: function [b [book!]] [...]**.   But there is no facility for this.

But...[&quot;Derived binding&quot;](https://github.com/metaeducation/ren-c/pull/727) in Ren-C set up some groundwork for understanding derivation.  This was done for efficiency: to know the relationships in order to be able to forward references to base class members downward to the instance.   That avoided needing to make deep copies of every member function of objects each time a new instance is made...just so those functions could refer to the variables in the derivations.  Yet the relationship it had to encode to accomplish this could also be used as a type test to see if something came from a given type hierarchy.

So the mechanics are there...and it seems it would be cool to implement.  But again, that depends on a notion of what a &quot;typeset&quot; actually is, which is the limiting factor.

# And what about &quot;type-tests...&quot;?

Still another question comes along for tests that are basically functions.  How about **even-integer?**, or **block-2?** where that&#39;s a block containing two elements?  These seem very useful, though potentially dangerous if the function has side effects... leading one to wonder if there should be a PURE annotation for functions that promise not to have side effects, and that they take all their parameters as CONST and won&#39;t use any non-PURE functions in their implementations or look at any variables that aren&#39;t parameters that haven&#39;t been permanently LOCK&#39;d.

**I actually think &quot;type test&quot; is the fundamental thing to be looking at, instead of some nebulous TYPESET! construct.**

You&#39;d not get the flattened list of types out, because it would be a function:

    &gt;&gt; my-check?: typechecker [any-series! integer!]
    == ~#[frame! [value]]~  ; anti

    &gt;&gt; my-check? &quot;abc&quot;
    == ~okay~  ; anti

    &gt;&gt; my-check?:type integer!
    == ~okay~  ; anti</description>
    
    <lastBuildDate>Tue, 25 Mar 2025 16:40:22 +0000</lastBuildDate>
    <category>Datatypes</category>
    <atom:link href="https://rebol.metaeducation.com/t/the-typeset-representation-problem/1300.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>The TYPESET! Representation Problem</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="IngoHohmann" data-post="6" data-topic="1300">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/ingohohmann/48/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>Sorry, I don't buy that. By the same token you could stop showing binaries, blocks and strings in the console.</p>
</blockquote>
</aside>
<p>Things are indeed now built on top of typechecker functions.  And those functions indeed don't show you that much:</p>
<pre><code>&gt;&gt; any-series?/
== ~#[frame! "any-series?" [value]]~  ; anti
</code></pre>
<p>But on the bright side, <a href="https://rebol.metaeducation.com/t/more-comprehensible-errors-with-per-cell-labeling/1357">functions cache their symbols</a>.  So you're not completely in the dark about what a typeset represents.</p>
<p>Also: function dispatchers have reflectors now.  So you can ask them questions.  There's no reason the built-in typecheckers couldn't cook up an answer to TYPES OF...</p>
<pre><code>&gt;&gt; types of any-series?/
== [text! block! ...&lt;whatever&gt;]
</code></pre>
<p>So look on the bright side, things aren't that bad....  <img src="https://rebol.metaeducation.com/images/emoji/twitter/sun.png?v=14" title=":sun:" class="emoji" alt=":sun:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8076-also-parameter-1" class="anchor" href="https://rebol.metaeducation.com#p-8076-also-parameter-1"></a>Also... PARAMETER!</h2>
<p>Another concept that may come into play here is PARAMETER!.</p>
<p>There's no MAKE for them yet.  But we can get one out of the frame of a prebuilt function:</p>
<pre><code>&gt;&gt; negate/
== ~#[frame!! [
    number: #[parameter! [any-number? pair! money! time!]]
]]~  ; anti

&gt;&gt; negate.number
== #[parameter! [any-number? pair! money! time!]]
</code></pre>
<p>We can use it with match:</p>
<pre><code>&gt;&gt; match frame.number 10
== 10

&gt;&gt; match frame.number &lt;abcd&gt;
== ~null~  ; anti
</code></pre>
<p>So that's something like a TYPESET!.  It's not a set of bits, but an array of constraints augmented by some optimizations that speed up matching.  I'm not sure how much of a role PARAMETER! will play, but it may fulfill some purposes people had in mind for typesets.</p>
          <p><a href="https://rebol.metaeducation.com/t/the-typeset-representation-problem/1300/14">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/the-typeset-representation-problem/1300/14</link>
        <pubDate>Tue, 25 Mar 2025 16:38:20 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1300-14</guid>
        <source url="https://rebol.metaeducation.com/t/the-typeset-representation-problem/1300.rss">The TYPESET! Representation Problem</source>
      </item>
      <item>
        <title>The TYPESET! Representation Problem</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>3 posts were split to a new topic: <a href="https://rebol.metaeducation.com/t/old-stuff-regarding-type-conventions/2384">Old Stuff Regarding &amp;[type] Conventions</a></p>
          <p><a href="https://rebol.metaeducation.com/t/the-typeset-representation-problem/1300/10">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/the-typeset-representation-problem/1300/10</link>
        <pubDate>Tue, 25 Mar 2025 16:15:30 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1300-10</guid>
        <source url="https://rebol.metaeducation.com/t/the-typeset-representation-problem/1300.rss">The TYPESET! Representation Problem</source>
      </item>
      <item>
        <title>The TYPESET! Representation Problem</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>A post was merged into an existing topic: <a href="https://rebol.metaeducation.com/t/what-should-type-of-an-isotope-be/1983/2">What Should TYPE OF an Isotope Be?</a></p>
          <p><a href="https://rebol.metaeducation.com/t/the-typeset-representation-problem/1300/9">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/the-typeset-representation-problem/1300/9</link>
        <pubDate>Mon, 26 Sep 2022 08:41:01 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1300-9</guid>
        <source url="https://rebol.metaeducation.com/t/the-typeset-representation-problem/1300.rss">The TYPESET! Representation Problem</source>
      </item>
      <item>
        <title>The TYPESET! Representation Problem</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>2 posts were split to a new topic: <a href="https://rebol.metaeducation.com/t/what-if-datatype-was-isotopic-tl-dr-bad-idea/1982">What If "DATATYPE" Was Isotopic (TL;DR: Bad Idea)</a></p>
          <p><a href="https://rebol.metaeducation.com/t/the-typeset-representation-problem/1300/7">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/the-typeset-representation-problem/1300/7</link>
        <pubDate>Mon, 26 Sep 2022 08:36:37 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1300-7</guid>
        <source url="https://rebol.metaeducation.com/t/the-typeset-representation-problem/1300.rss">The TYPESET! Representation Problem</source>
      </item>
      <item>
        <title>The TYPESET! Representation Problem</title>
        <dc:creator><![CDATA[IngoHohmann]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1300">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>You'd not get the flattened list of types out, because it would be a function:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; my-check?: typechecker [any-series! integer!]
== ~#[frame! [value]]~  ; anti
</code></pre>
</blockquote>
</aside>
<p>Sorry, I don't buy that. By the same token you could stop showing  binaries, blocks and strings in the console.</p>
<p>Maybe types in a typeset are always shown in the same order, then it is less ambiguous which types are dropped in the display.</p>
<p>Furthermore the number of types won't grow indefinitely, so just showing the full list may not be that bad after all.</p>
          <p><a href="https://rebol.metaeducation.com/t/the-typeset-representation-problem/1300/6">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/the-typeset-representation-problem/1300/6</link>
        <pubDate>Tue, 30 Aug 2022 09:35:07 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1300-6</guid>
        <source url="https://rebol.metaeducation.com/t/the-typeset-representation-problem/1300.rss">The TYPESET! Representation Problem</source>
      </item>
      <item>
        <title>The TYPESET! Representation Problem</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>TYPESET! took advantage of 64-bit integers--and a limitation of 64 fundamental types--to fit 64 bit flags into a single value cell to represent a typeset.  Besides the obvious lack of extensibility, this has a number of problems.  One of which is that typesets render in a pretty ugly way...a seemingly simple concept like ANY-TYPE! expands out fairly monstrously:</p>
<pre><code>r3-alpha&gt;&gt; print mold any-type!
make typeset! [unset! none! logic! integer! decimal! percent! money! char!
pair! tuple! time! date! binary! string! file! email! url! tag! bitset! image!
vector! block! paren! path! set-path! get-path! lit-path! map! datatype!
typeset! word! set-word! get-word! lit-word! refinement! issue! native!
action! rebcode! command! op! closure! function! frame! object! module!
error! task! port! gob! event! handle! struct! library! utype!]

red&gt;&gt; print mold any-type!
make typeset! [datatype! unset! none! logic! block! paren! string! file!
url! char! integer! float! word! set-word! lit-word! get-word! refinement!
issue! native! action! op! function! path! lit-path! set-path! get-path!
routine! bitset! object! typeset! error! vector! hash! pair! percent! tuple!
map! binary! time! tag! email! handle! date! port! image! event!]
</code></pre>
<p>People are used to typing in variables--like arrays or objects--and seeing what they look up to be a large amount of data.  But a typeclass like ANY-TYPE! doesn't typically have this "explosive" character...and it impedes readability.</p>
<p><strong>If you look closely you'll see another sneaking problem hinted at by R3-Alpha's never-implemented UTYPE!</strong> (for user-defined type).  Imagining that it had an implementation, this would suggest that all user-defined types would be considered equivalent in a TYPESET!.  If you took one user-defined type as a parameter, you would have to take them all, and do some filtering on it after the fact.</p>
<p><em>(In fact, <a href="https://rebol.metaeducation.com/t/user-defined-datatype-discussion/1203/2">extension types</a> in Ren-C (which are on hold at time of writing) had this very problem.  If you passed a GOB! to a native routine that expects a VECTOR! or a STRUCT!, it would crash.  It's something that a real answer to typesets would have to address, part of why I'm mentioning all this.)</em></p>
<h1><a name="p-3869-this-doesnt-even-touch-upon-the-idea-of-type-classes-1" class="anchor" href="https://rebol.metaeducation.com#p-3869-this-doesnt-even-touch-upon-the-idea-of-type-classes-1"></a>This doesn't even touch upon the idea of "type-classes"...</h1>
<p>e.g. if you decide to make a base object with something like <strong>book!: make object! [...]</strong> and later <strong>make book! [...]</strong>, this "book!" is the kind of thing you might consider in some languages to be a class.  You might want to write a routine like <strong>library-checkout: function [b [book!]] [...]</strong>.   But there is no facility for this.</p>
<p>But...<a href="https://github.com/metaeducation/ren-c/pull/727">"Derived binding"</a> in Ren-C set up some groundwork for understanding derivation.  This was done for efficiency: to know the relationships in order to be able to forward references to base class members downward to the instance.   That avoided needing to make deep copies of every member function of objects each time a new instance is made...just so those functions could refer to the variables in the derivations.  Yet the relationship it had to encode to accomplish this could also be used as a type test to see if something came from a given type hierarchy.</p>
<p>So the mechanics are there...and it seems it would be cool to implement.  But again, that depends on a notion of what a "typeset" actually is, which is the limiting factor.</p>
<h1><a name="p-3869-and-what-about-type-tests-2" class="anchor" href="https://rebol.metaeducation.com#p-3869-and-what-about-type-tests-2"></a>And what about "type-tests..."?</h1>
<p>Still another question comes along for tests that are basically functions.  How about <strong>even-integer?</strong>, or <strong>block-2?</strong> where that's a block containing two elements?  These seem very useful, though potentially dangerous if the function has side effects... leading one to wonder if there should be a PURE annotation for functions that promise not to have side effects, and that they take all their parameters as CONST and won't use any non-PURE functions in their implementations or look at any variables that aren't parameters that haven't been permanently LOCK'd.</p>
<p><strong>I actually think "type test" is the fundamental thing to be looking at, instead of some nebulous TYPESET! construct.</strong></p>
<p>You'd not get the flattened list of types out, because it would be a function:</p>
<pre><code>&gt;&gt; my-check?: typechecker [any-series! integer!]
== ~#[frame! [value]]~  ; anti

&gt;&gt; my-check? "abc"
== ~okay~  ; anti

&gt;&gt; my-check?:type integer!
== ~okay~  ; anti
</code></pre>
          <p><a href="https://rebol.metaeducation.com/t/the-typeset-representation-problem/1300/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/the-typeset-representation-problem/1300/1</link>
        <pubDate>Thu, 09 Jul 2020 18:56:10 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1300-1</guid>
        <source url="https://rebol.metaeducation.com/t/the-typeset-representation-problem/1300.rss">The TYPESET! Representation Problem</source>
      </item>
  </channel>
</rss>

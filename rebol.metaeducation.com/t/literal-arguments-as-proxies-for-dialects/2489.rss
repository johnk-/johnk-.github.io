<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Literal Arguments As Proxies For Dialects</title>
    <link>https://rebol.metaeducation.com/t/literal-arguments-as-proxies-for-dialects/2489</link>
    <description>I was looking at this detail in FOR-EACH and realized it was a kind of general question... *in parameter slots that take dialects, how often should we take that argument literally in order to make it easier to have it act as a dialect?*

---

[quote=&quot;hostilefork, post:1, topic:2462&quot;]
So in this FOR-EACH example, we can already imagine a convenience... of being able to annotate variables to say you want to propagate the binding (or &quot;tie&quot; the variables to the binding of the block). ...

` for-each [$sw i] block `
[/quote]

We can kind of clearly see here that the decorators belong on the variables &quot;doing the picking&quot;, not the material being iterated or picked from...

**This makes me think I may have erred in switching FOR-EACH variables to be not-taken literally.**

I switched:

    for-each x [...]

To:

    for-each &#39;x [...]

I thought it was justified by the fact that `@x` would bind and keep the binding, and the decorator.  That allowed `for-each @x [...]` to do the right thing, even with a non-literal slot for the `@x`.

But with `$x` becoming a &quot;thing&quot;, if you let that evaluate it loses the $.  So FOR-EACH wouldn&#39;t know you wanted the picked thing to be bound.  You&#39;d have to remember to write:

    for-each &#39;$x [...]

But that pattern simply wouldn&#39;t work with:

    for-each &#39;@x [...]

You can&#39;t &quot;reuse the binding&quot; of something you quoted that has no binding.  :-(

## Switch It Back?

If it changes back, you get uniform behavior:

    for-each whatever [a b c]

    for-each [whatever] [a b c]

That means you can just write:

    for-each $x [...] [...]

    for-each @x [...] [...]

And it will work.

**I can certainly see how it&#39;s nicer in the long run to use the literal parameter.  But it throws you a bit of a curve-ball educationally.**

Consider also `&#39;x` being able to have its own dialected meaning in a block or not.

    for-each &#39;x [...]

    for-each [&#39;x y] [...]

That&#39;s more powerful.  But it&#39;s also in some pretty confusing territory for beginners, having to deal with that slot being literal.

**I&#39;m torn about it, but this `for-each $x [...]` case does really have me thinking that it should be changed back.**  Seeing that you&#39;d have to write `for-each &#39;$x [...]` but then `for-each &#39;@x [...]` *wouldn&#39;t* work makes me think it&#39;s just healthier for that parameter slot to be dialected, and you use a GROUP! if you need to escape it... which is *very rare*.</description>
    
    <lastBuildDate>Fri, 20 Jun 2025 12:57:43 +0000</lastBuildDate>
    <category>Dialects/DSLs</category>
    <atom:link href="https://rebol.metaeducation.com/t/literal-arguments-as-proxies-for-dialects/2489.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Literal Arguments As Proxies For Dialects</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2489">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Consider also <code>'x</code> being able to have its own dialected meaning in a block or not.</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">for-each 'x [...]

for-each ['x y] [...]
</code></pre>
<p>That's more powerful. But it's also in some pretty confusing territory for beginners, having to deal with that slot being literal.</p>
</blockquote>
</aside>
<p>As I've turned this over in my head a bit, I think that the best answer is likely to <strong>take the variable(s) argument literally, but require the quote on ordinary variables</strong>.</p>
<p>This means a helpful error can be delivered on <strong><code>for-each x [...]</code></strong> telling you to use a GROUP! if you meant to evaluate it (if <code>x</code> is a variable holding the name of the loop variable) or to use a quote mark (if you intended x as the name of the loop variable).</p>
<p>We can then make <strong><code>for-each @x [...]</code></strong> and <strong><code>for-each $x [...]</code></strong> and <strong><code>for-each ^x [...]</code></strong> work with the decoration guiding the process.</p>
<p><strong><code>for-each [x] [...]</code></strong> would remain a synonym for <strong><code>for-each 'x [...]</code></strong></p>
<h2><a name="p-8450-its-wired-into-a-bit-of-a-pretzel-but-a-good-one-1" class="anchor" href="https://rebol.metaeducation.com#p-8450-its-wired-into-a-bit-of-a-pretzel-but-a-good-one-1"></a>It's Wired Into A Bit Of  A Pretzel... But A Good One</h2>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/pretzel.png?v=14" title=":pretzel:" class="emoji only-emoji" alt=":pretzel:" loading="lazy" width="20" height="20"></p>
<p>Yes, FOR-EACH is "sneakily" seeing things it would not see if the slot were evaluated... (the $, the ^).</p>
<p>One might complain that the quote mark gives the impression that you're suppressing an evaluation... and the rug is pulled out from under you conceptually when you find out it's not evaluating.</p>
<p>I think that's looking at it the wrong way... the quote mark is a way of communicating that you understand the nature of the slot.</p>
<p>My gauge for these things tend to be: <strong>is it motivated? is it learnable? does it do more good than harm?</strong></p>
<p>Since the switch, I've found the quote mark does more good than harm.  But we want to see other decorators, and that's more important than being able to pass a variable that is looked up to be the name of a loop variable.</p>
<p>We get kind of the best of both worlds by being able to give you an error if you use a plain WORD!/TUPLE!/etc. in that slot.</p>
<p>So the quote mark stays.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/+1.png?v=14" title=":+1:" class="emoji" alt=":+1:" loading="lazy" width="20" height="20"></p>
          <p><a href="https://rebol.metaeducation.com/t/literal-arguments-as-proxies-for-dialects/2489/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/literal-arguments-as-proxies-for-dialects/2489/3</link>
        <pubDate>Fri, 20 Jun 2025 12:57:43 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2489-3</guid>
        <source url="https://rebol.metaeducation.com/t/literal-arguments-as-proxies-for-dialects/2489.rss">Literal Arguments As Proxies For Dialects</source>
      </item>
      <item>
        <title>Literal Arguments As Proxies For Dialects</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>I was looking at this detail in FOR-EACH and realized it was a kind of general question... <em>in parameter slots that take dialects, how often should we take that argument literally in order to make it easier to have it act as a dialect?</em></p>
<hr>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="2462">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/reacting-to-tie-to-automate-binding/2462/1">Reacting to TIE ($) To Automate Binding</a></div>
<blockquote>
<p>So in this FOR-EACH example, we can already imagine a convenience... of being able to annotate variables to say you want to propagate the binding (or "tie" the variables to the binding of the block). ...</p>
<p><code>for-each [$sw i] block</code></p>
</blockquote>
</aside>
<p>We can kind of clearly see here that the decorators belong on the variables "doing the picking", not the material being iterated or picked from...</p>
<p><strong>This makes me think I may have erred in switching FOR-EACH variables to be not-taken literally.</strong></p>
<p>I switched:</p>
<pre><code>for-each x [...]
</code></pre>
<p>To:</p>
<pre><code>for-each 'x [...]
</code></pre>
<p>I thought it was justified by the fact that <code>@x</code> would bind and keep the binding, and the decorator.  That allowed <code>for-each @x [...]</code> to do the right thing, even with a non-literal slot for the <code>@x</code>.</p>
<p>But with <code>$x</code> becoming a "thing", if you let that evaluate it loses the $.  So FOR-EACH wouldn't know you wanted the picked thing to be bound.  You'd have to remember to write:</p>
<pre><code>for-each '$x [...]
</code></pre>
<p>But that pattern simply wouldn't work with:</p>
<pre><code>for-each '@x [...]
</code></pre>
<p>You can't "reuse the binding" of something you quoted that has no binding.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8432-switch-it-back-1" class="anchor" href="https://rebol.metaeducation.com#p-8432-switch-it-back-1"></a>Switch It Back?</h2>
<p>If it changes back, you get uniform behavior:</p>
<pre><code>for-each whatever [a b c]

for-each [whatever] [a b c]
</code></pre>
<p>That means you can just write:</p>
<pre><code>for-each $x [...] [...]

for-each @x [...] [...]
</code></pre>
<p>And it will work.</p>
<p><strong>I can certainly see how it's nicer in the long run to use the literal parameter.  But it throws you a bit of a curve-ball educationally.</strong></p>
<p>Consider also <code>'x</code> being able to have its own dialected meaning in a block or not.</p>
<pre><code>for-each 'x [...]

for-each ['x y] [...]
</code></pre>
<p>That's more powerful.  But it's also in some pretty confusing territory for beginners, having to deal with that slot being literal.</p>
<p><strong>I'm torn about it, but this <code>for-each $x [...]</code> case does really have me thinking that it should be changed back.</strong>  Seeing that you'd have to write <code>for-each '$x [...]</code> but then <code>for-each '@x [...]</code> <em>wouldn't</em> work makes me think it's just healthier for that parameter slot to be dialected, and you use a GROUP! if you need to escape it... which is <em>very rare</em>.</p>
          <p><a href="https://rebol.metaeducation.com/t/literal-arguments-as-proxies-for-dialects/2489/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/literal-arguments-as-proxies-for-dialects/2489/1</link>
        <pubDate>Mon, 16 Jun 2025 20:20:46 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2489-1</guid>
        <source url="https://rebol.metaeducation.com/t/literal-arguments-as-proxies-for-dialects/2489.rss">Literal Arguments As Proxies For Dialects</source>
      </item>
  </channel>
</rss>

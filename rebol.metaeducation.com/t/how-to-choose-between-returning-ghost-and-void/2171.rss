<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>How To Choose Between Returning GHOST and VOID?</title>
    <link>https://rebol.metaeducation.com/t/how-to-choose-between-returning-ghost-and-void/2171</link>
    <description>[quote=&quot;hostilefork, post:3, topic:2422&quot;]
Void is used generically in many places when you want things to vanish:

```
&gt;&gt; compose [&lt;a&gt; (if 1 &gt; 2 [&lt;b&gt;] else [void]) &lt;c&gt;]
== [&lt;a&gt; &lt;c&gt;]
```
[/quote]

Ah-ha… I’d completely missed this use of void, as a return value.

Though this does now raise the question of whether a function should return VOID or GHOST. Both seem to vaporise in lists, after all. I guess it depends on whether you want the function call to be ignored or not.</description>
    
    <lastBuildDate>Sun, 01 Jun 2025 20:07:48 +0000</lastBuildDate>
    <category>Questions</category>
    <atom:link href="https://rebol.metaeducation.com/t/how-to-choose-between-returning-ghost-and-void/2171.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>How To Choose Between Returning GHOST and VOID?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="2171">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2171">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Though this does now raise the question of whether a function should return VOID or GHOST.</p>
</blockquote>
</aside>
<p>I think it should be a very rare choice to make things return VOID unconditionally.</p>
<p>And I think it should be an even rarer choice to return GHOST (e.g. because of the damage it can do to things like CASE or SWITCH structure). And when GHOST is returned it should almost always be unconditional.</p>
</blockquote>
</aside>
<p>So this instinct about "leaky ghosts" (e.g. functions that sometimes return ghost, and sometimes do not) has turned out to be <em><strong>¡mucho importante!</strong></em> <img src="https://rebol.metaeducation.com/images/emoji/twitter/taco.png?v=14" title=":taco:" class="emoji" alt=":taco:" loading="lazy" width="20" height="20"></p>
<p>I wrote about it in PARSE here:</p>
<p><a href="https://rebol.metaeducation.com/t/leaky-ghosts-what-combinators-should-vanish/2437" class="inline-onebox">"Surprising" Ghosts: What Combinators Vanish?</a></p>
<p>But it's a pretty big deal in EVAL.  You don't want the EVAL in situations like this to vanish:</p>
<pre><code> ^result: switch ... [
     ...
     ... [counter: counter + 1, eval code]
     ...
 ]
</code></pre>
<p>If EVAL is allowed to vanish, then you could wind up assigning the calculation (counter + 1) to result, and this is surprising.</p>
<p><strong>But you need some way of evaluating and being able to get ghosts if you really intend it, and are conscious of what you're doing.</strong></p>
<p>So far that's been with <strong><code>eval:ghostable</code></strong>.</p>
<p>(I think <strong><code>eval:ghost</code></strong> or <strong><code>eval:ghosts</code></strong> doesn't communicate as well that what it means.  <strong><code>eval:ghostly</code></strong> is shorter but also less clear.  <strong><code>eval:transparent</code></strong> is longer than ghostable and also just kind of less informative.)</p>
<h2><a name="p-8266-i-wish-this-could-be-pushed-outside-1" class="anchor" href="https://rebol.metaeducation.com#p-8266-i-wish-this-could-be-pushed-outside-1"></a>I Wish This Could Be Pushed Outside...</h2>
<p>It would be technically possible to rig something up where the evaluator would be complicit, in saying that if a function's signature wasn't such that it <em>always</em> returns GHOST!, that it would turn the ghost into a VOID unless a special participatory tool was used.</p>
<p>We talked about <strong><code>^</code></strong> being free.  Not that it's a great choice, but there would be worse ones.</p>
<p>Let's imagine that it represented this intention:</p>
<pre><code>foo: func [return: [ghost! integer!] x [integer!]] [
    if x &gt; 1000 [return ghost]
    return x
]

&gt;&gt; "some stuff" foo 304
== 304

&gt;&gt; "some stuff" foo 1020
== ~[]~  ; anti (void)

&gt;&gt; "some stuff" ^ foo 1020
== "some stuff"
</code></pre>
<p>So it's actually modifying the function call machinery, saying "if this function doesn't always return ghosts, don't do the normal switcheroo to void".</p>
<p>I know this isn't necessarily super obvious.  But what @ does is a quirk of the system as well, applied to solve tricky fundamental problems that can't be done other ways.</p>
<h2><a name="p-8266-this-is-no-small-issue-and-worth-it-to-solve-2" class="anchor" href="https://rebol.metaeducation.com#p-8266-this-is-no-small-issue-and-worth-it-to-solve-2"></a>This Is No Small Issue, And Worth It To Solve</h2>
<p>It comes up a lot of other places, e.g. UNLIFT... which takes in a quoted or quasiform and drops it a level.  Should that vanish by default, or do you need yet another UNLIFT:GHOSTABLE?</p>
<p>There's an issue with <strong>^var</strong> vanishing and causing surprises as well.  I don't think we want to be writing <strong>[^ ^var]</strong>, so something else needs to be done.</p>
<p>One small step could be to say that <strong>^(var)</strong> is willing to vanish, while <strong>^var</strong> is not.  That might not seem to make a hell of a lot of sense, <em>but</em> GROUP! evaluations are typically allowed to vanish, which is why you can put COMMENT and ELIDE and such inside groups.</p>
<pre><code>&gt;&gt; x: eval [10 + 20 (comment "this works")]
== 30
</code></pre>
<p>This would cut down on the number of places that the mistake can happen.</p>
<h2><a name="p-8266-think-i-need-to-give-this-a-shot-3" class="anchor" href="https://rebol.metaeducation.com#p-8266-think-i-need-to-give-this-a-shot-3"></a>Think I Need To Give This a Shot</h2>
<p>I'm not happy with distinguishing EVAL vs. EVAL:GHOSTABLE, and that :GHOSTABLE is just one of those refinements that starts spreading everywhere.  Better to have a uniform solution.</p>
<p>As we discussed, <strong>^</strong> is kind of an outlier where you're like "uh, what should that mean?"  Having it do something genuinely useful is better than trying to weasel together an argument for why what it does "makes sense".</p>
<p>Having to say <code>^(var)</code> to get vanishing, with <code>^var</code> giving ghosts as void, is imperfect but better.  You'd basically never write ^(var) if you could just say ^var so it makes sense to encode the intent.</p>
<p>If you're super-conscious from experience that <code>^(...)</code> can vanish, then when you get <code>^(my expression)</code> situations you don't want to vanish, you can mitigate that by deghosting.</p>
<h2><a name="p-8266-it-would-allow-ghost-branches-4" class="anchor" href="https://rebol.metaeducation.com#p-8266-it-would-allow-ghost-branches-4"></a>It Would Allow GHOST Branches</h2>
<pre><code>&gt;&gt; "some stuff" if 10 &lt; 20 [elide print "Oh my."] else [&lt;else&gt;]
Oh my.
== ~[]~  ; anti (void)

 &gt;&gt; "some stuff" if 10 &gt; 20 [elide print "Oh my."] else [&lt;else&gt;]
== &lt;else&gt;

 &gt;&gt; "some stuff" ^ if 10 &lt; 20 [elide print "Oh my."] else [&lt;else&gt;]
Oh my.
== "some stuff"

 &gt;&gt; "some stuff" ^ if 10 &gt; 20 [elide print "Oh my."] else [&lt;else&gt;]
== &lt;else&gt;
</code></pre>
<p>And it means that <strong><code>eval []</code></strong> actually returns GHOST!.  But since EVAL returns ANY-ATOM? then it will typically give you VOID.</p>
          <p><a href="https://rebol.metaeducation.com/t/how-to-choose-between-returning-ghost-and-void/2171/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/how-to-choose-between-returning-ghost-and-void/2171/3</link>
        <pubDate>Mon, 12 May 2025 07:52:28 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2171-3</guid>
        <source url="https://rebol.metaeducation.com/t/how-to-choose-between-returning-ghost-and-void/2171.rss">How To Choose Between Returning GHOST and VOID?</source>
      </item>
      <item>
        <title>How To Choose Between Returning GHOST and VOID?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2171">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Both seem to vaporise in lists, after all.</p>
</blockquote>
</aside>
<p>There's some touchy-feely choices made in the constructs regarding voids and ghosts.</p>
<p>I think it's important that they're not truthy or falsey.</p>
<pre><code>&gt;&gt; if void [print "This is important."]
** Script Error: IF doesn't accept VOID for its CONDITION argument

&gt;&gt; if ghost [print "This too."]
** Script Error: IF is missing its CONDITION argument
</code></pre>
<p>However, ALL is kind of like a chain of IF statements testing for logic.  So given the existence of GHOST, should it demand GHOST for opting out... and error on VOIDs?</p>
<pre><code>&gt;&gt; while [null] [&lt;b&gt;]
== ~[]~  ; anti  (void, never ran loop body)

&gt;&gt; all [if okay [&lt;a&gt;] while [null] [&lt;b&gt;] if okay [&lt;c&gt;]]
** Script Error: Invalid use of void
</code></pre>
<p>If it wasn't willing to erase voids, you'd need to use ELIDE-IF-VOID to erase the voids:</p>
<pre><code>&gt;&gt; all [if okay [&lt;a&gt;] elide-if-void while [null] [&lt;b&gt;] if okay [&lt;c&gt;]]
== &lt;c&gt;
</code></pre>
<p>But I feel like it works out better in practice if ANY and ALL consider void as no vote.  Also, if all the expressions opt out of voting, the ANY or ALL overall is void.</p>
<pre><code>&gt;&gt; any [void, while [null] [&lt;b&gt;], void]
== ~[]~  ; anti
</code></pre>
<p>But other constructs--like CASE--do not erase VOID...only GHOST.  They have a "structure" to them, and it's desirable to not disrupt that structure too easily.</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2171">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Though this does now raise the question of whether a function should return VOID or GHOST.</p>
</blockquote>
</aside>
<p>I think it should be a very rare choice to make things return VOID unconditionally.</p>
<p>And I think it should be an even rarer choice to return GHOST (e.g. because of the damage it can do to things like CASE or SWITCH structure).  And when GHOST is returned it should almost always be unconditional.</p>
<p>GHOST is nice for debugging statements, because you can throw them in without disrupting the surrounding code</p>
<pre><code>&gt;&gt; y: 10 + do [x: 1 + 2, dump x]
x: 3
== 13
</code></pre>
<p>Because of this, there's been some pressure to say that PRINT return GHOST.  <a href="https://rebol.metaeducation.com/t/why-doesnt-print-return-void-or-vaporize-via-nihil/1466">So far, I've rejected that</a>.</p>
<pre><code>append [a b c] print "I think this should error"  ; rules out void
</code></pre>
<p>Also, though people reach for PRINT for debug output, I think it's poor for that.  The fact that it evaluates blocks means I don't like the idea of <strong>print x</strong> taking too many kinds of input, that could one day become a block and surprise you by evaluating.  So it's already a bad generic "debug dump".  And logging with the same thing you use for committed output makes it hard to search for debug code and remove or disable it.</p>
<p>I like there being relatively few GHOST-returning operations, and if you want to erase something use ELIDE.</p>
<p>But ASSERT returns GHOST and that's neat in things like CASE or SWITCH for asserting something as true when you've gotten to a certain point:</p>
<pre><code>case:all [  ; ALL -&gt; don't stop on first condition matched
    x &lt; 10 [y: &lt;lesser&gt;]
    x &gt; 10 [y: &lt;greater&gt;]
    assert [(x = 10) or (find [&lt;lesser&gt; &lt;greater&gt;] y)]
    x = 10 [print "You can imagine this kind of thing being useful"]
]
</code></pre>
<p><sub><em>I should go through and replace these with real useful examples someday, but my hope is people get the point abstractly.</em></sub></p>
<p>Anyway, I think it's nice to be able to do that particular thing without saying ELIDE ASSERT.  A few other constructs make the cut of justifying GHOST.</p>
<p>Hopefully it's clear why I don't think there are that many applications for functions that return GHOST conditionally.  ELIDE-IF-VOID is a very niche function that I don't think there are that many legitimate uses for.  If you're going to come up with a construct that does return GHOST conditionally, it should be discernible from the source-level syntax if it's a vanishing or non-vanishing invocation.</p>
          <p><a href="https://rebol.metaeducation.com/t/how-to-choose-between-returning-ghost-and-void/2171/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/how-to-choose-between-returning-ghost-and-void/2171/2</link>
        <pubDate>Sat, 09 Mar 2024 09:41:57 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2171-2</guid>
        <source url="https://rebol.metaeducation.com/t/how-to-choose-between-returning-ghost-and-void/2171.rss">How To Choose Between Returning GHOST and VOID?</source>
      </item>
      <item>
        <title>How To Choose Between Returning GHOST and VOID?</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="3" data-topic="2422">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/null-void-trash-evolution-from-none-unset/2422/3">NULL/VOID/TRASH evolution from NONE!/UNSET!</a></div>
<blockquote>
<p>Void is used generically in many places when you want things to vanish:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; compose [&lt;a&gt; (if 1 &gt; 2 [&lt;b&gt;] else [void]) &lt;c&gt;]
== [&lt;a&gt; &lt;c&gt;]
</code></pre>
</blockquote>
</aside>
<p>Ah-ha… I’d completely missed this use of void, as a return value.</p>
<p>Though this does now raise the question of whether a function should return VOID or GHOST. Both seem to vaporise in lists, after all. I guess it depends on whether you want the function call to be ignored or not.</p>
          <p><a href="https://rebol.metaeducation.com/t/how-to-choose-between-returning-ghost-and-void/2171/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/how-to-choose-between-returning-ghost-and-void/2171/1</link>
        <pubDate>Sat, 09 Mar 2024 02:30:26 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2171-1</guid>
        <source url="https://rebol.metaeducation.com/t/how-to-choose-between-returning-ghost-and-void/2171.rss">How To Choose Between Returning GHOST and VOID?</source>
      </item>
  </channel>
</rss>

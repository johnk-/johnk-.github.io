<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Virtual Binding + Macros =&gt; BREAK, CONTINUE, AGAIN</title>
    <link>https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479</link>
    <description>In the last moments of 2023, Ren-C finally bit the bullet and made BREAK and CONTINUE definitional (it was a long time coming, just hadn&#39;t gotten around to it...):

**[Definitional Break and Continue: The Time Is Now](https://rebol.metaeducation.com/t/definitional-break-and-continue-the-time-is-now/2066)**

This means that loops create (optimized) variants of BREAK and CONTINUE in which the ACTION! cell has been tweaked to hold the identity of the loop.

The methodology for this optimized representation [was pioneered with definitional RETURN](https://rebol.metaeducation.com/t/what-are-definitional-returns/2191).

Except in this case, there are two new &quot;LET-style variables&quot; tacked onto the loop&#39;s binding environment... one for BREAK, and one for CONTINUE.

## It Would Be Nice To Have AGAIN

It seems to me pretty powerful to be able to ask a loop to start again from the top, but not increment its loop index...or check the condition, or whatever.

(This has precedent in other languages, e.g. **[Perl&#39;s REDO](https://perldoc.perl.org/functions/redo)**... but I like AGAIN better.)

That would add a third LET-variable.  :pouting_cat: 

## But Could It Be Just *ONE* LET-Variable?

As I&#39;ve realized the kind-of-awesome power of virtual binding, I realized that it might be the case that there was just *one* &quot;throw to loop&quot; construct, that takes different parameterization:

* **`throw-to-loop veto`** =&gt; **BREAK**

   * VETO is a function that returns an ERROR! with the identity &#39;VETO... which is an awesome generalization I haven&#39;t talked about yet, that makes constructs abort and return NULL. It works inside things like REDUCE (e.g. `reduce [1 + 2 veto]` =&gt; `null`) but also inside GROUP!s of code in PARSE to allow match failures to be signaled by a GROUP! (whose product would otherwise be discarded).  It seems the perfect argument for THROW-TO-LOOP to mean &quot;let&#39;s abort this whole loop and give null&quot;.

* **`throw-to-loop void`** =&gt; **CONTINUE**

   * This would have the same effect as reaching the end of the loop body and synthesizing VOID.  So if you were doing a MAP-EACH, an iteration of the loop that ran CONTINUE would not contribute anything to the result. 

* **`throw-to-loop fail &#39;retry`** =&gt; **AGAIN**

   * I don&#39;t know if RETRY should be a function that just returns an ERROR! the way VETO is so I&#39;m hand-waving a little here to say &quot;let&#39;s have another special trigger that loops can respond to&quot;... if they don&#39;t support it, they can treat it like any other error.
  
   * I&#39;m not thrilled that &quot;retry&quot; doesn&#39;t *sound* like an &quot;error&quot; name the way VETO kind-of-does, but there&#39;s only so many unstable antiforms to choose from (and GHOST! seems random to pick to mean &quot;try again&quot;).  Maybe INCOMPLETE is a better error ID... where the loop goes &quot;oh, the *failure* was it didn&#39;t complete... so the natural *response* is to try again&quot;?

* **`throw-to-loop &lt;whatever&gt;`** =&gt; **CONTINUE:WITH**

   * `CONTINUE` has had a refinement called `:WITH` that allows you to act as if the loop body completed with some other value besides VOID.  So `continue:with spread [d e]` inside a MAP-EACH would add the splice `~(d e)~` to the mapped result.  I don&#39;t know if it&#39;s better to have this `:WITH` refinement or if you should just use THROW-TO-LOOP directly... (could THROW-TO-LOOP have a better name?)

## One Way To Do It... Macros!

Imagine that a convenient form of MACRO (which might just be called MACRO) would assume that anything $TIED you want to bind in the environment of the macro definition, and anything you don&#39;t $TIE is intended to be interpreted in the calling context.

    break: macro [throw-to-loop $veto]
    continue: macro [throw-to-loop $void]  ; -or- just [throw-to-loop ~[]~]
    again: macro [throw-to-loop $fail &#39;incomplete]  ; or whatever...

While we&#39;d most likely want to nativize CONTINUE, BREAK, and AGAIN... maybe MACRO can be smart enough to produce native-speed code for this when not running under a stepwise debugger...

## Any Submissions For Better Names For THROW-TO-LOOP?

Maybe being bluntly literal is best.

But @BlackATTR suggested `TOSS`, `PASS`, `PITCH`, `PUNT`, `FLICK`

They all sound weird to us now, but everything has a learning curve.  You learned what BREAK and CONTINUE meant, you&#39;d learn what AGAIN meant.  Could you learn what TOSS meant, that it was specifically a THROW targeting a LOOP...?

Leaving that open for now.

## Or... Variadic CONTINUE?

I&#39;ll also point out that once-upon-a-time, CONTINUE was variadic... so you could say **`continue 10`** and if you left off the parameter it would assume you meant VOID.  This was too error prone, due to line continuation bugs:

   https://rebol.metaeducation.com/t/line-continuation-and-arity-bugs-thoughts/1965

But I&#39;ve been thinking maybe you have to continue lines with an apostrophe.  So this would error:

    append [a b c]
    [d e f]

But this would be legal:

    append [a b c]
    &#39; [d e f]

The reason it would be legal is it would actually LOAD the code as not having a line break marker.

Then we&#39;d just make line break markers illegal outside of interstitial evaluations.  (Maybe relax it, so that if you were inside a GROUP! evaluation it would allow it, though that might make it toothless.)

    (append [a b c]
    [d e f])

If the system got more persnickety about line continuation, then we might feel comfortable bringing back variable-arity CONTINUE, QUIT, RETURN...

I doubt we want to go down the route of JavaScript&#39;s [automatic semicolon insertion](https://en.wikibooks.org/wiki/JavaScript/Automatic_semicolon_insertion) debacle, and act like there&#39;s a comma at &quot;some&quot; line end markers.

I have a hard time being psychic about whether this is a big creativity-enabler (by letting us be more purposeful about semantics of line continuation markers) or if it would lead to hassles.  Overall I feel like it would cut down on bugs, by making line endings usually mean expression endings... and having you be specific when that&#39;s not what you want.

![6t9rbhxv06g71|300x250](upload://fgfPtWehBdWVciF8Ng28L48wruv.webp)</description>
    
    <lastBuildDate>Sat, 12 Jul 2025 05:14:46 +0000</lastBuildDate>
    <category>Loops</category>
    <atom:link href="https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Virtual Binding + Macros =&gt; BREAK, CONTINUE, AGAIN</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2479">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>This might be a good argument for RETURN being a macro that calls THROW-TO-FUNCTION.</strong> That gives you more power to define your own "smart return".</p>
</blockquote>
</aside>
<p>Thinking about this further, it would be a fairly double-edged thing.</p>
<p>Currently you can overwrite RETURN e.g. as:</p>
<pre><code> foo: func [] [
     return: adapt return/ [value: value + 20]
     return 1000  ; acts as if you hadn't adapted, and returned 1020
 ]
</code></pre>
<p>If RETURN were some definition in LIB that hooked up to whatever the local definition of THROW-TO-FUNCTION was, having a long and crappy name would throw this off.  Your local specialization would do "something else" (which wouldn't be to overwrite the LIB RETURN, but likely error by default, though it could create a local definition in the current module).</p>
<p>So at minimum you'd have to say:</p>
<pre><code> foo: func [] [
     let return: adapt return/ [value: value + 20]
     return 1000  ; acts as if you hadn't adapted, and returned 1020
 ]
</code></pre>
<p>Though this costs a LET, and would only affect RETURN that had visibility of the LET.</p>
<p>And... if the global RETURN just forwarded to "whatever you defined return as", there's issues about what its interface would be.  Would it have no parameters, and then if RETURN happened to be defined differently (let's say, returning 3 parameters?) it would forward that normally?  That would prohibit this kind of specialization at all.</p>
<p>So to be able to specialize it, it would have to build a frame and presume the nature of THROW-TO-FUNCTION that it was proxying to.  Or you'd specialize THROW-TO-FUNCTION instead:</p>
<pre><code> foo: func [] [
     throw-to-function: adapt throw-to-function/ [value: value + 20]
     return 1000  ; acts as if you hadn't adapted, and returned 1020
 ]
</code></pre>
<p>A middle ground might be to call the raw-return something nicer, but indicative of its low-levelness, like <strong><code>RETURN*</code></strong></p>
<pre><code> foo: func [] [
     return*: adapt return*/ [value: value + 20]
     return 1000  ; acts as if you hadn't adapted, and returned 1020
 ]
</code></pre>
<h2><a name="p-8507-are-such-contortions-worth-it-1" class="anchor" href="https://rebol.metaeducation.com#p-8507-are-such-contortions-worth-it-1"></a>Are Such Contortions Worth It?</h2>
<p>Kind of feels like... no.  I like the way you can just off the cuff twist the local RETURN, and call it RETURN, and it "just works".</p>
<p>If  "global hooking" of RETURN is truly desirable, maybe that should be done with some more general facility of hooking WORD!s in an environment.  That seems wiser.</p>
          <p><a href="https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479/3</link>
        <pubDate>Fri, 11 Jul 2025 19:35:07 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2479-3</guid>
        <source url="https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479.rss">Virtual Binding + Macros =&gt; BREAK, CONTINUE, AGAIN</source>
      </item>
      <item>
        <title>Virtual Binding + Macros =&gt; BREAK, CONTINUE, AGAIN</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="2479">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>Any Submissions For Better Names For THROW-TO-LOOP?</strong></p>
<p>Maybe being bluntly literal is best...</p>
<p><strong>Or... Variadic CONTINUE?</strong></p>
<p>I'll also point out that once-upon-a-time, CONTINUE was variadic... so you could say <strong><code>continue 10</code></strong> and if you left off the parameter it would assume you meant VOID. This was too error prone, due to line continuation bugs:</p>
</blockquote>
</aside>
<p>There's another option...</p>
<h2><a name="p-8506-arity-1-continue-1" class="anchor" href="https://rebol.metaeducation.com#p-8506-arity-1-continue-1"></a>Arity-1 CONTINUE</h2>
<p>This would mean if you wanted the "traditional" continue, you would typically say <strong><code>continue void</code></strong>.</p>
<p>The concept of the parameter to CONTINUE is "act as if the loop body completed and returned this result".</p>
<p>The most obvious place this is useful is in things like MAP-EACH:</p>
<pre><code>&gt;&gt; map-each 'x [1 2 3] [
       if x = 2 [continue spread [pretty cool!]]
       x * 10
   ]
== [10 pretty cool! 30]
</code></pre>
<p>But it can serve a purpose in any loop, by being the value that "drops out" the bottom of the loop if there are no further iterations.</p>
<pre><code>x: 10
until [x = 30] [
   x: x + 10
   if x = 20 [continue &lt;x was 20&gt;]
   x * 100
]
== &lt;x was 20&gt;
</code></pre>
<p><strong>It may make sense to let people know they have this degree of freedom... that if they continue the loop, they're always submitting a value to it...</strong></p>
<p>ARITY-1 continue gives feature exposure, and it also saves us from having to come up with a name for "throw something to the loop".</p>
<p><strong>continue veto</strong> is thus a synonym for BREAK, which as I'm proposing would just be defined as passing VETO to whatever the current concept of CONTINUE is.</p>
<p><strong>continue retry</strong> is a little bit weird, RETRY not being very noun-y.  <strong>continue again</strong> is weird as well, but maybe it makes more sense to help drive home that it's connected to loop constructs.</p>
<p>I'm not sure, but I am feeling kind of open to this idea that CONTINUE has you pass what you want the loop to continue with.</p>
<p>It does suffer slightly from a redefinition problem: while you could redefine other words, you couldn't redefine CONTINUE itself.</p>
<p>Hm.  Maybe that's enough to kill it.  If the loops are using a fixed desirable word like CONTINUE, you couldn't then redefine CONTINUE to be arity-0... whereas if it was called THROW-TO-LOOP you could.</p>
<p><strong>This might be a good argument for RETURN being a macro that calls THROW-TO-FUNCTION.</strong>  That gives you more power to define your own "smart return".  For instance, one that looks to see if the current THROW-TO-FUNCTION return type was specified as <strong><code>[]</code></strong>, and in which case morphs to take no arguments.  I can imagine people having other rules that might be specific to certain contexts.</p>
<p><strong>This makes THROW-TO-LOOP having a crappy name seem like a good thing, not a bad one.</strong></p>
          <p><a href="https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479/2</link>
        <pubDate>Fri, 11 Jul 2025 01:43:24 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2479-2</guid>
        <source url="https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479.rss">Virtual Binding + Macros =&gt; BREAK, CONTINUE, AGAIN</source>
      </item>
      <item>
        <title>Virtual Binding + Macros =&gt; BREAK, CONTINUE, AGAIN</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>In the last moments of 2023, Ren-C finally bit the bullet and made BREAK and CONTINUE definitional (it was a long time coming, just hadn't gotten around to it...):</p>
<p><strong><a href="https://rebol.metaeducation.com/t/definitional-break-and-continue-the-time-is-now/2066">Definitional Break and Continue: The Time Is Now</a></strong></p>
<p>This means that loops create (optimized) variants of BREAK and CONTINUE in which the ACTION! cell has been tweaked to hold the identity of the loop.</p>
<p>The methodology for this optimized representation <a href="https://rebol.metaeducation.com/t/what-are-definitional-returns/2191">was pioneered with definitional RETURN</a>.</p>
<p>Except in this case, there are two new "LET-style variables" tacked onto the loop's binding environment... one for BREAK, and one for CONTINUE.</p>
<h2><a name="p-8393-it-would-be-nice-to-have-again-1" class="anchor" href="https://rebol.metaeducation.com#p-8393-it-would-be-nice-to-have-again-1"></a>It Would Be Nice To Have AGAIN</h2>
<p>It seems to me pretty powerful to be able to ask a loop to start again from the top, but not increment its loop index...or check the condition, or whatever.</p>
<p>(This has precedent in other languages, e.g. <strong><a href="https://perldoc.perl.org/functions/redo">Perl's REDO</a></strong>... but I like AGAIN better.)</p>
<p>That would add a third LET-variable.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/pouting_cat.png?v=14" title=":pouting_cat:" class="emoji" alt=":pouting_cat:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8393-but-could-it-be-just-one-let-variable-2" class="anchor" href="https://rebol.metaeducation.com#p-8393-but-could-it-be-just-one-let-variable-2"></a>But Could It Be Just <em>ONE</em> LET-Variable?</h2>
<p>As I've realized the kind-of-awesome power of virtual binding, I realized that it might be the case that there was just <em>one</em> "throw to loop" construct, that takes different parameterization:</p>
<ul>
<li>
<p><strong><code>throw-to-loop veto</code></strong> =&gt; <strong>BREAK</strong></p>
<ul>
<li>VETO is a function that returns an ERROR! with the identity 'VETO... which is an awesome generalization I haven't talked about yet, that makes constructs abort and return NULL. It works inside things like REDUCE (e.g. <code>reduce [1 + 2 veto]</code> =&gt; <code>null</code>) but also inside GROUP!s of code in PARSE to allow match failures to be signaled by a GROUP! (whose product would otherwise be discarded).  It seems the perfect argument for THROW-TO-LOOP to mean "let's abort this whole loop and give null".</li>
</ul>
</li>
<li>
<p><strong><code>throw-to-loop void</code></strong> =&gt; <strong>CONTINUE</strong></p>
<ul>
<li>This would have the same effect as reaching the end of the loop body and synthesizing VOID.  So if you were doing a MAP-EACH, an iteration of the loop that ran CONTINUE would not contribute anything to the result.</li>
</ul>
</li>
<li>
<p><strong><code>throw-to-loop fail 'retry</code></strong> =&gt; <strong>AGAIN</strong></p>
<ul>
<li>
<p>I don't know if RETRY should be a function that just returns an ERROR! the way VETO is so I'm hand-waving a little here to say "let's have another special trigger that loops can respond to"... if they don't support it, they can treat it like any other error.</p>
</li>
<li>
<p>I'm not thrilled that "retry" doesn't <em>sound</em> like an "error" name the way VETO kind-of-does, but there's only so many unstable antiforms to choose from (and GHOST! seems random to pick to mean "try again").  Maybe INCOMPLETE is a better error ID... where the loop goes "oh, the <em>failure</em> was it didn't complete... so the natural <em>response</em> is to try again"?</p>
</li>
</ul>
</li>
<li>
<p><strong><code>throw-to-loop &lt;whatever&gt;</code></strong> =&gt; <strong>CONTINUE:WITH</strong></p>
<ul>
<li><code>CONTINUE</code> has had a refinement called <code>:WITH</code> that allows you to act as if the loop body completed with some other value besides VOID.  So <code>continue:with spread [d e]</code> inside a MAP-EACH would add the splice <code>~(d e)~</code> to the mapped result.  I don't know if it's better to have this <code>:WITH</code> refinement or if you should just use THROW-TO-LOOP directly... (could THROW-TO-LOOP have a better name?)</li>
</ul>
</li>
</ul>
<h2><a name="p-8393-one-way-to-do-it-macros-3" class="anchor" href="https://rebol.metaeducation.com#p-8393-one-way-to-do-it-macros-3"></a>One Way To Do It... Macros!</h2>
<p>Imagine that a convenient form of MACRO (which might just be called MACRO) would assume that anything $TIED you want to bind in the environment of the macro definition, and anything you don't $TIE is intended to be interpreted in the calling context.</p>
<pre><code>break: macro [throw-to-loop $veto]
continue: macro [throw-to-loop $void]  ; -or- just [throw-to-loop ~[]~]
again: macro [throw-to-loop $fail 'incomplete]  ; or whatever...
</code></pre>
<p>While we'd most likely want to nativize CONTINUE, BREAK, and AGAIN... maybe MACRO can be smart enough to produce native-speed code for this when not running under a stepwise debugger...</p>
<h2><a name="p-8393-any-submissions-for-better-names-for-throw-to-loop-4" class="anchor" href="https://rebol.metaeducation.com#p-8393-any-submissions-for-better-names-for-throw-to-loop-4"></a>Any Submissions For Better Names For THROW-TO-LOOP?</h2>
<p>Maybe being bluntly literal is best.</p>
<p>But <a class="mention" href="https://rebol.metaeducation.com/u/blackattr">@BlackATTR</a> suggested <code>TOSS</code>, <code>PASS</code>, <code>PITCH</code>, <code>PUNT</code>, <code>FLICK</code></p>
<p>They all sound weird to us now, but everything has a learning curve.  You learned what BREAK and CONTINUE meant, you'd learn what AGAIN meant.  Could you learn what TOSS meant, that it was specifically a THROW targeting a LOOP...?</p>
<p>Leaving that open for now.</p>
<h2><a name="p-8393-or-variadic-continue-5" class="anchor" href="https://rebol.metaeducation.com#p-8393-or-variadic-continue-5"></a>Or... Variadic CONTINUE?</h2>
<p>I'll also point out that once-upon-a-time, CONTINUE was variadic... so you could say <strong><code>continue 10</code></strong> and if you left off the parameter it would assume you meant VOID.  This was too error prone, due to line continuation bugs:</p>
<p><a href="https://rebol.metaeducation.com/t/line-continuation-and-arity-bugs-thoughts/1965" class="inline-onebox">Line Continuation and Arity Bugs: Thoughts?</a></p>
<p>But I've been thinking maybe you have to continue lines with an apostrophe.  So this would error:</p>
<pre><code>append [a b c]
[d e f]
</code></pre>
<p>But this would be legal:</p>
<pre><code>append [a b c]
' [d e f]
</code></pre>
<p>The reason it would be legal is it would actually LOAD the code as not having a line break marker.</p>
<p>Then we'd just make line break markers illegal outside of interstitial evaluations.  (Maybe relax it, so that if you were inside a GROUP! evaluation it would allow it, though that might make it toothless.)</p>
<pre><code>(append [a b c]
[d e f])
</code></pre>
<p>If the system got more persnickety about line continuation, then we might feel comfortable bringing back variable-arity CONTINUE, QUIT, RETURN...</p>
<p>I doubt we want to go down the route of JavaScript's <a href="https://en.wikibooks.org/wiki/JavaScript/Automatic_semicolon_insertion">automatic semicolon insertion</a> debacle, and act like there's a comma at "some" line end markers.</p>
<p>I have a hard time being psychic about whether this is a big creativity-enabler (by letting us be more purposeful about semantics of line continuation markers) or if it would lead to hassles.  Overall I feel like it would cut down on bugs, by making line endings usually mean expression endings... and having you be specific when that's not what you want.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/6af702cd11332dfc1fb48f90b5267cab5d41f98f.webp" data-download-href="https://rebol.metaeducation.com/uploads/default/6af702cd11332dfc1fb48f90b5267cab5d41f98f" title="6t9rbhxv06g71"><img src="https://rebol.metaeducation.com/uploads/default/original/1X/6af702cd11332dfc1fb48f90b5267cab5d41f98f.webp" alt="6t9rbhxv06g71" data-base62-sha1="fgfPtWehBdWVciF8Ng28L48wruv" width="300" height="250"></a></div><p></p>
          <p><a href="https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479/1</link>
        <pubDate>Sat, 07 Jun 2025 10:47:37 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2479-1</guid>
        <source url="https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479.rss">Virtual Binding + Macros =&gt; BREAK, CONTINUE, AGAIN</source>
      </item>
  </channel>
</rss>

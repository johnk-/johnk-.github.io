<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>General Pattern of Avoiding longjmp() and Exceptions</title>
    <link>https://rebol.metaeducation.com/t/general-pattern-of-avoiding-longjmp-and-exceptions/2396</link>
    <description>Historical Rebol would just use longjmp() to cause abrupt exceptions when failing conditions happened.  This crossed an arbitrary number of Rebol stacks in an uncooperative fashion.  The only places that would catch it would be specific points that did a setjmp(), e.g. the Rebol2 version of &quot;TRY&quot;.

***The more I got to know longjmp() the more I didn&#39;t like it.***

Ren-C&#39;s stackless nature makes it possible to use setjmp() once around the trampoline, and then any longjmp()-based abrupt failures will only disrupt the stack of the native from which it jumps.  The trampoline catches it, and then converts it into a cooperative Rebol-throw-style return result, that bubbles up normally through the call stack.

And also, there&#39;s a clever abstraction of the jumping mechanics that allows you to build using C++ exceptions or longjmp()...the code is stylized in a neat way with macros that look natural but can go either way.

But still: there are even some platforms that don&#39;t offer either facility.  **I think in terms of minimal dependencies, being able to perform normal execution even on platforms with no C++ exceptions or longjmp() is an asset.**

So this has continued pushing forward a philosophy point that we shouldn&#39;t depend on longjmp()/exceptions for anything that would be &quot;normal&quot; operation.  Any errors occurring from an &quot;abrupt failure&quot; should basically **not be intercepted** by anything but &quot;weird&quot; development tools... e.g. the console.

This does mean I&#39;m converting a lot of code like:

     void Do_Some_Stuff(...) {
         if (Something_I_Dont_Like(...))
            fail (&quot;Something happened I don&#39;t like&quot;);  // uncooperative longjmp()
         ...
         return;
     }

     DECLARE_NATIVE(...) {
         Do_Some_Stuff(...);  // may teleport stack to trampoline, not run next line
         return OUT;
    }

...to look like:

     Option(Error*) Trap_Do_Some_Stuff(...) {
         if (Something_I_Dont_Like(...))
            return ERROR(&quot;Something happened I don&#39;t like&quot;);  // returning error
         ...
         return nullptr;
     }

     DECLARE_NATIVE(...) {
         Option(Error*) e = Trap_Do_Some_Stuff(...);
         if (e)
             return FAIL(unwrap e);  // cooperative failure returned to trampoline
         return OUT;
    }

At some times I&#39;m a little conflicted over this seeming like make-work -BUT- it isn&#39;t.  In addition to meaning this code can have error conditions on platforms with no longjmp() or C++ exceptions, you get a clearer picture of which routines think they might fail in normal operations and don&#39;t... so as a caller you can act accordingly.

There are still abrupt failures, but they&#39;re basically things you would think of as being okay if it crashed the interpreter completely... it&#39;s just a convenience that things like the console don&#39;t crash.  But you should never react to those failures as a way of implementing your program logic.</description>
    
    <lastBuildDate>Sat, 05 Apr 2025 11:12:00 +0000</lastBuildDate>
    <category>Errors</category>
    <atom:link href="https://rebol.metaeducation.com/t/general-pattern-of-avoiding-longjmp-and-exceptions/2396.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>General Pattern of Avoiding longjmp() and Exceptions</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Historical Rebol would just use longjmp() to cause abrupt exceptions when failing conditions happened.  This crossed an arbitrary number of Rebol stacks in an uncooperative fashion.  The only places that would catch it would be specific points that did a setjmp(), e.g. the Rebol2 version of "TRY".</p>
<p><em><strong>The more I got to know longjmp() the more I didn't like it.</strong></em></p>
<p>Ren-C's stackless nature makes it possible to use setjmp() once around the trampoline, and then any longjmp()-based abrupt failures will only disrupt the stack of the native from which it jumps.  The trampoline catches it, and then converts it into a cooperative Rebol-throw-style return result, that bubbles up normally through the call stack.</p>
<p>And also, there's a clever abstraction of the jumping mechanics that allows you to build using C++ exceptions or longjmp()...the code is stylized in a neat way with macros that look natural but can go either way.</p>
<p>But still: there are even some platforms that don't offer either facility.  <strong>I think in terms of minimal dependencies, being able to perform normal execution even on platforms with no C++ exceptions or longjmp() is an asset.</strong></p>
<p>So this has continued pushing forward a philosophy point that we shouldn't depend on longjmp()/exceptions for anything that would be "normal" operation.  Any errors occurring from an "abrupt failure" should basically <strong>not be intercepted</strong> by anything but "weird" development tools... e.g. the console.</p>
<p>This does mean I'm converting a lot of code like:</p>
<pre><code> void Do_Some_Stuff(...) {
     if (Something_I_Dont_Like(...))
        fail ("Something happened I don't like");  // uncooperative longjmp()
     ...
     return;
 }

 DECLARE_NATIVE(...) {
     Do_Some_Stuff(...);  // may teleport stack to trampoline, not run next line
     return OUT;
}
</code></pre>
<p>...to look like:</p>
<pre><code> Option(Error*) Trap_Do_Some_Stuff(...) {
     if (Something_I_Dont_Like(...))
        return ERROR("Something happened I don't like");  // returning error
     ...
     return nullptr;
 }

 DECLARE_NATIVE(...) {
     Option(Error*) e = Trap_Do_Some_Stuff(...);
     if (e)
         return FAIL(unwrap e);  // cooperative failure returned to trampoline
     return OUT;
}
</code></pre>
<p>At some times I'm a little conflicted over this seeming like make-work -BUT- it isn't.  In addition to meaning this code can have error conditions on platforms with no longjmp() or C++ exceptions, you get a clearer picture of which routines think they might fail in normal operations and don't... so as a caller you can act accordingly.</p>
<p>There are still abrupt failures, but they're basically things you would think of as being okay if it crashed the interpreter completely... it's just a convenience that things like the console don't crash.  But you should never react to those failures as a way of implementing your program logic.</p>
          <p><a href="https://rebol.metaeducation.com/t/general-pattern-of-avoiding-longjmp-and-exceptions/2396/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/general-pattern-of-avoiding-longjmp-and-exceptions/2396/1</link>
        <pubDate>Sat, 05 Apr 2025 11:12:00 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2396-1</guid>
        <source url="https://rebol.metaeducation.com/t/general-pattern-of-avoiding-longjmp-and-exceptions/2396.rss">General Pattern of Avoiding longjmp() and Exceptions</source>
      </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Solving the Pox of the (^)... LIFT the Universe?</title>
    <link>https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477</link>
    <description>I&#39;ve taken the big bold leap into the *[world of fully LIFT&#39;ed FRAME!s](https://rebol.metaeducation.com/t/meta-parameters-and-function-composition/2433/3?u=hostilefork)*.

As a refresher: this is the idea that as far as the &quot;API&quot; for calling functions is concerned, you *always* communicate via lifted values.

That means when you&#39;re building a FRAME! to call a function, you don&#39;t have to be concerned whether that function specified its argument as ^META or not.  Once the invocation of the function happens, it will unlift non-^meta arguments as part of its execution.

Hence if an argument changes from ^META-to-non-meta (or vice-versa), that won&#39;t impact callsites that build frames for it.

## ^META&#39;s LIFT-ON-ASSIGN, UNLIFT-ON-FETCH Helps

The new behavior of ^META-WORD! is extended to TUPLE!, that makes this pretty easy to deal with when working with a &quot;raw&quot; FRAME!:

    &gt;&gt; f: make frame! append/

    &gt;&gt; f.^series: [a b c]
    == [a b c]

    &gt;&gt; f.series
    == &#39;[a b c]

    &gt;&gt; f.^value: spread [d e]
    == /~(d e)~/  ; antiform (splice!)

    &gt;&gt; f.value
    == ~(d e)~

    &gt;&gt; eval f
    == [a b c d e]

That&#39;s a little unfortunate-looking... messier... but it&#39;s necessary, right? &lt;sub&gt;(keep reading...)&lt;/sub&gt;

## Simplifying Dialect For APPLY + SPECIALIZE

While you have to build a FRAME! with values lifted, I didn&#39;t want to make higher-level tools like APPLY and SPECIALIZE look ugly.  So they lift for you:

    &gt;&gt; apply append/ [[a b c] spread [d e] dup: 2]
    == [a b c d e d e]

    &gt;&gt; sub10: specialize subtract/ [value2: 10]

    &gt;&gt; sub10 1030
    == 1020

But I&#39;ve proposed a :FREEFORM variant form of APPLY and SPECIALIZE...in which the code is bound into the frame.  In this case, the dialect isn&#39;t in control... so you would have to use the lifted forms of assignment. &lt;sub&gt;(or would you? keep reading...)&lt;/sub&gt;

This form is more awkward and can&#39;t take advantage of positional assignment:

    apply:freeform append/ [^series: [a b c] ^value: spread [d e] ^dup: 2]

But it lets you write arbitrary branching and looping code :

    &gt;&gt; apply:freeform append/ [
           if 1 = random 2 [
               ^series: [a b c]
               ^dup: 2
           ] else [
               ^series: [q r s]
               ^dup: 3
           ]
           ^value: spread [d e]
       ]
    == [q r s d e d e d e]

## Could The &quot;Ugliness&quot; Be Moved Around, Somehow?

It seems kind of... *unfair*.  How can the dialected form deal with something easily, that the non-dialected situations don&#39;t?

In other words: is there some way to simplify the :FREEFORM versions... or things like ADAPT and ENCLOSE... or building &quot;RAW&quot; frames?

***My &quot;invasive thought&quot; is this:***

* why couldn&#39;t `(foo: ...)` store a lifted-but-decayed form of the right hand side
* and `(^foo: ...)` store a lifted-but **not** decayed version of the right hand side?

This is being driven by the only truly &quot;unlifted&quot; state a frame normally &quot;needs&quot; &lt;sub&gt;(hand-waving a bit here, actually :wave:)&lt;/sub&gt; is unlifted trash to say it&#39;s unspecialized.  What would be the harm of lifting everything, and having a special operation for setting to the unspecialized state?

It would imply, I think... (?)

* `(foo)` unlifts the stored value (executing actions, erroring on TRASH!, etc.) and refuses to unlift unstable antiforms

* `(^foo)` unlifts with no execution (trash! as-is, action! as-is), and is willing to unlift unstable antiforms (pack!, error!, ghost! etc. as-is)

     * &lt;sub&gt;I have another slightly invasive thought that ^(foo) might permit &quot;unsurprising&quot; ghosts or actions, but that&#39;s for another thread.&lt;/sub&gt;

This is a slippery invasive thought.  It has to be wrong, doesn&#39;t it?  Too good to be true?  :pouting_cat:

But what if it isn&#39;t?  :thinking:

![assets_task_01jx3y0xmyfc79dwb24jd57b49_1749257658_img_3|690x460, 75%](upload://yrQc5xkNpeTlSSrOOswU5OsMelz.webp)

It&#39;s not changing the usual chain of evaluation.  If you say (1 + 2 comment &quot;hi&quot;) that&#39;s not lifted... it&#39;s a plain old 3 and a &quot;plain old&quot; ghost!.

So this means when you say **`(foo: ~)`** you would be setting FOO to an &quot;ordinary&quot; trash value (a lifted one, in stored representation).  This would cause errors if fetched via **`(foo)`** which would unlift and treat it as active.  But if you said **`(^foo)`** you would get back the trash state as-is.

**This means there would be a state *more trash than trash***... unspecialization.  A variable holding a non-lifted trash, which would trip up even fetches with **`^foo`**.  And this goes along with my concept of ACCESSOR functions... moving them from something &quot;hidden&quot; to something that&#39;s actually exposed... something beneath the layers that `(foo: ...)` or `(^foo: ...)` alone can assign.

So you&#39;d need tools to go beneath assignment, but these tools have already been theorized (I&#39;ve called it &quot;TWEAK&quot;)

## More investigation on this needed, but...

**...it&#39;s actually just an &quot;all-in, fully-exposed&quot; version of the more &quot;behind-the-scenes&quot; idea I was already implementing, where objects/modules/lets/etc. were storing lifted values...and having special exceptions in the unlifted range.**

The consequence is we can limit `(f.^foo: ...)` or `(^bar: ...)` cases to those truly concerned with unstable isotopes.  Which if that can be accomplished, seems to mean only those who need it pay for it.

## [...It Might Be The Perfect Solution](https://www.youtube.com/watch?v=OWKcK07iJsU)

![81A95bnJNWL._UF1000,1000_QL80_|500x500, 75%](upload://r8uB6KGbXm59FQlvG1A7D4I8a8p.jpeg)</description>
    
    <lastBuildDate>Fri, 20 Jun 2025 11:55:35 +0000</lastBuildDate>
    <category>Internals</category>
    <atom:link href="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Solving the Pox of the (^)... LIFT the Universe?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2477">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I sure hope I'm not missing something here, because this looks great.</p>
</blockquote>
</aside>
<p>I've pushed this through... and by and large I'd say it's a <em>really</em> positive direction.</p>
<p>Of course, it's a GIGANTIC model change.  So there are some issues which have to be faced.</p>
<h2><a name="p-8449-impact-on-generators-1" class="anchor" href="https://rebol.metaeducation.com#p-8449-impact-on-generators-1"></a>Impact on Generators</h2>
<p>Previously, the idea with a generator was that it could produce any value that wasn't an unstable ERROR! antiform.  The only legal ERROR! to YIELD was one with <strong><code>id: 'done</code></strong>, and this would be interpreted as the end of the enumeration.  YIELD-ing any other ERROR! would result in it being promoted to a PANIC.</p>
<p>I said this was better than using NULL, because it meant anything that could be stored in a variable could be returned... your generator could give back sequences like NULL, 10, NULL, 20 etc.  If NULL wasn't in-band you could always TRY the result of your generator and get NULL for the only legitimate ERROR! it could return... being done.  Otherwise you could test with <code>done?</code></p>
<p>My hope was that generators would be able to power things like FOR-EACH, by providing a feed of values back.  But with lift-the-universe, what's legal to store in a variable has broadened...when you're using ^META-representation.</p>
<p>If you have something like:</p>
<pre><code>for-each [^val] generator-for-values-of-object obj [ 
    ...
]
</code></pre>
<p><em>(<a href="https://rebol.metaeducation.com/t/literal-arguments-as-proxies-for-dialects/2489">Note this may go back to being legal as <strong>for-each ^val</strong> soon</a>, pending deep thought.)</em></p>
<p>So the OBJECT! can contain ERROR! values, stored via ^META assignment.</p>
<p>If we had to change all generators that fed back values to use a lifted protocol (like TWEAK does), that would make those generators less generally useful.</p>
<p><em>Note that conceptually, this problem isn't new.</em>  It just puts the problem a bit more in your face.  A generator couldn't speak in terms of ERROR! values before--as I mentioned--so <em>something</em> gets twisted up here.  The twist has just encroached upon something more fundamental, e.g. enumerating things that can be valid values in an OBJECT!.  So it's not as easily dismissed as before with "well, if you want to return an error from your generator do it lifted".</p>
<p><strong>There may be a workaround if PACK!s aren't taken literally.</strong>  This was already something I was considering, e.g. I was thinking that the reason you could write:</p>
<pre><code>for-each 'key obj [...]

for-each [key val] obj [...]
</code></pre>
<p>Was that the generator behind the scenes powering the OBJ fields would return a PACK! with the key and value in it.  If it didn't return a PACK!, then what would happen when you said <strong>for-each 'key obj [...]</strong> would be that you'd get the key on one iteration, that key's value on the next, then the next key, then the next value... it would be the PACK! coming back from the generator that signaled "hey, I'm actually <em>two</em> values that should be part of <em>one</em> iteration"</p>
<p>So if that's already true--that PACK! isn't literal--then returning an <em>actual</em> pack would have to be done with a PACK-inside-a-PACK.  And by the same token, an ERROR! could be handled by being inside a pack as well.</p>
<p>What's nice about this is that it pushes the "weirdness" off a bit.  Generators that want to be compatible with FOR-EACH and friends don't have to speak fully in terms of a lifted protocol.  They just have to return their PACK! and ERROR! wrapped inside a PACK!... that's the bargain.  <em>(Perhaps GHOST! would have to be inside a PACK! as well just to say "all unstable antiforms must be wrapped in a PACK! to be used with FOR-EACH/MAP-EACH?  I don't know if there's a reason, but if the other two have to be then maybe I can find a good reason why it should apply to ghosts too.)</em></p>
<p><strong>I think this seems like an acceptable tradeoff.</strong>  It doesn't mean you have to use PACK! this way in your own off-the-cuff generators that aren't intended to be used with FOR-EACH.  But you always had to deal with the ERROR! exception, and this just throws in another exception that solves the exception.</p>
<h2><a name="p-8449-sidenote-representing-true-unset-2" class="anchor" href="https://rebol.metaeducation.com#p-8449-sidenote-representing-true-unset-2"></a>Sidenote: Representing "True Unset"</h2>
<p>So this actually does have another wrinkle, which is that since object values can now hold states "beneath" even unstable antiforms... how to represent the state that leaks through to casual user consciousness: <em>true unset</em>?</p>
<pre><code>&gt;&gt; f. make frame! negate/

&gt;&gt; f.number
** Panic: number is truly unset

&gt;&gt; f.^number
** Panic: look man, it's not TRASH!, it's TRULY UNSET, ^META won't help you

&gt;&gt; unset? $f.number  ; &lt;-- special functions must be used!
== \~okay~\  ; antiform
</code></pre>
<p>So now, let's go back to our generator-powering-for-each:</p>
<pre><code>for-each [key ^val] f [
   if unset? $val [print [key "is unset!"]]
]
</code></pre>
<p>Notice there's no problem with what state we want ^val to hold (though there is some question over whether you should have to say ^val to get the unsetness, or if plain val would allow it).</p>
<p>The problem is: <em>how would a generator be able to return this state</em>?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>Curiously, if you were building a PACK! by hand, you could make something that did it.  The unlifted band has not been used in PACK historically... every element had to be a quasiform or quoted.  But if you build a pack manually, you can actually put sub-band values in it... as long as they're not antiforms and can go in a BLOCK!:</p>
<pre><code>&gt;&gt; anti ['number _]
== \~['number _]~\  ; antiform
</code></pre>
<p>I'm choosing <code>_</code> here as an arbitrary out-of-band thing that could represent the truly unset state.  But the key is that whatever it is, it can't be a quasiform or quoted.  TWEAK should probably use the same state here <em>(I've been using the <code>~</code> antiform so far, but that would be disconnected with this purpose--it's easy to change.)</em></p>
<p>How many sub-band values should be legal?  I don't know, but if we made an exception for just this <em>one</em> then it seems to address this particular problem.</p>
<p>Does SET-BLOCK have to support it, just because it exists to paper over a representational hole in enumerating OBJECT! values via generators?  I don't know if it does or not.</p>
<p>Does there have to be some helper for making it easier to make these?</p>
<pre><code>&gt;&gt; unsettable-pack [1 + 2 &lt;special-unset-signal&gt; _]
== \~['3 _ '_]~\  ; antiform
</code></pre>
<p>Probably not.  It's by design that PACK! is pretty easy to make.</p>
<pre><code>&gt;&gt; anti reduce [lift 1 + 2 _ lift _]
== \~['3 _ '_]~\  ; antiform
</code></pre>
<p>Any in-the-box construct that obfuscates that probably isn't helping.  If you find yourself generating a lot of these in some pattern you can write your own helper.</p>
<h2><a name="p-8449-side-note-addendum-generator-binding-requests-3" class="anchor" href="https://rebol.metaeducation.com#p-8449-side-note-addendum-generator-binding-requests-3"></a>Side Note Addendum: Generator Binding Requests</h2>
<p>Since I can think of solutions to the lift-the-universe problems...and see them as epicycles of an already existing problem... that's not such a big deal for the generator-powered FOR-EACH.</p>
<p>A bit more of a problem is the question of <a href="https://rebol.metaeducation.com/t/sticky-set-word-binding-problem-in-make-object/2127/5">how to communicate <code>$var</code> to ask for binding to be imparted on a per-variable basis</a>.</p>
<p>Maybe since the protocol is already special, passing a generator :BINDINGS might ask for an inflation where it returns 2x as many values via PACK!... the value and then the binding separately, and FOR-EACH/etc. would then merge the bindings onto the values if they were applicable to the corresponding variable.</p>
<p>It's an ugly idea, but it's the first idea I've had that might work.  I just mention it because if we resorted to passing in the variables to the generator so it could see the decoration, that would also provide a channel for pure-unsetting the variable.  But that doesn't jibe with how I'm thinking about this working.</p>
          <p><a href="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477/11">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477/11</link>
        <pubDate>Fri, 20 Jun 2025 11:40:34 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2477-11</guid>
        <source url="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477.rss">Solving the Pox of the (^)... LIFT the Universe?</source>
      </item>
      <item>
        <title>Solving the Pox of the (^)... LIFT the Universe?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>4 posts were merged into an existing topic: <a href="https://rebol.metaeducation.com/t/how-console-displays-things-with-no-literal-representation/2096/6">How Console Displays Things With No Literal Representation</a></p>
          <p><a href="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477/10">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477/10</link>
        <pubDate>Tue, 10 Jun 2025 21:32:11 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2477-10</guid>
        <source url="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477.rss">Solving the Pox of the (^)... LIFT the Universe?</source>
      </item>
      <item>
        <title>Solving the Pox of the (^)... LIFT the Universe?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="8" data-topic="2477">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>losing the "this cell has been typechecked bit" by the auto-unlift to bring down the representation of non-^META arguments</p>
</blockquote>
</aside>
<p>Side thought: if this concept goes through, ^META is distinguished as "set undecayed, fetch undecayed"... not distinguished as "set lifted, fetch unlifted".</p>
<p>Is META still a good name for that?  It's certainly not <em>as</em> good as it was... but probably still okay, as it's what you use for "strong preservation".</p>
<p>So if you write:</p>
<pre><code> some-function-call ..&lt;some-expression&gt;..
</code></pre>
<p>Changing it to this won't work in a general sense:</p>
<pre><code> var: ..&lt;some-expression&gt;..
 some-function-call var
</code></pre>
<p>But this should be a preserving transformation (modulo ERROR!)</p>
<pre><code> ^var: ..&lt;some-expression&gt;..
 some-function-call ^var
</code></pre>
<p>If you don't want to PANIC on an ERROR! and SOME-FUNCTION-CALL may handle ERROR!, then:</p>
<pre><code> try ^var: ..&lt;some-expression&gt;..
 some-function-call ^var
</code></pre>
<p>(I am weighing bringing back <strong><code>~^var~: some-expression</code></strong> or some such decoration as necessary to approve ERROR! overwrites, to avoid the situation of overwriting variables only to panic immediately afterward with the variable now "corrupt" potentially in your view... which would mean that plain <strong><code>^var: some-expression</code></strong> would pipe the error through and not do an assignment by default.  But I don't know if I'm convinced that's better than an operator that proactively promotes ERROR! to PANIC passing through everything else, such as <strong><code>^var: must some-expression</code></strong>, if you actually care about avoiding metavariable corruption with errors)</p>
<p>Anyway... is "don't decay" still "META"?  The word can mean whatever one wants I guess, given that LIFT and UNLIFT have gone off on their own branch of meaning.  Nothing better comes to mind offhand.</p>
          <p><a href="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477/9">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477/9</link>
        <pubDate>Sat, 07 Jun 2025 13:00:03 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2477-9</guid>
        <source url="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477.rss">Solving the Pox of the (^)... LIFT the Universe?</source>
      </item>
      <item>
        <title>Solving the Pox of the (^)... LIFT the Universe?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="7" data-topic="2477">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I quite like that it gives you a clear visual distinction between ‘parameters of the <code>enclose</code>d function’ and ‘all other values’</p>
</blockquote>
</aside>
<p>You could capitalize the F... <img src="https://rebol.metaeducation.com/images/emoji/twitter/face_with_diagonal_mouth.png?v=14" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20"></p>
<p>As I've gotten more comfortable with flexing the power of virtual binding (e.g. <a href="https://rebol.metaeducation.com/t/virtual-binding-based-error-propagation-operator/2389">the error propagation operator picking up the contextual definition of <code>return</code></a>)...I'm actually thinking that the way that leading-dot works is to implicitly connect to <code>this</code>, which you could even just name a local definition that:</p>
<pre><code>add2x3x+1: enclose add/ this -&gt; [
    .value1: .value1 * 2
    .value2: .value2 * 3
    1 + eval this
 ]
</code></pre>
<p>If we wanted to be more semiotic about it, then it could be <strong><code>.</code></strong></p>
<pre><code>add2x3x+1: enclose add/ . -&gt; [
    .value1: .value1 * 2
    .value2: .value2 * 3
    1 + eval .
 ]
</code></pre>
<p>I just think:</p>
<ul>
<li>
<p>that's too hard to see</p>
</li>
<li>
<p><code>..value1</code> is illegal (currently and maybe forever, though technically it <em>could</em> be a TUPLE! with two leading SPACE runes)</p>
<ul>
<li>so you'd have to write <code>(.).value1</code> for an equivalent, and it just feel weird to not be able to say simply <code>.foo</code> is a synonym for <code>this.foo</code></li>
</ul>
</li>
<li>
<p><strong><code>.</code></strong> probably has better uses as some as-yet-thought-of operator, or even left free to user local definition</p>
</li>
</ul>
<p>But anyway... back to the topic... I don't think the <code>^</code> has a "good" value-add here if just talking about visibility, if the user experience can be legitimately de-complicated.</p>
<aside class="quote no-group quote-modified" data-username="bradrn" data-post="7" data-topic="2477">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>What if you <em>want</em> to store lifted values under a tuple access?  I see your last post deals with precisely this issue.</p>
</blockquote>
</aside>
<p>If nothing worse than what I've found so far comes up, I think on balance having those cases be written as (<code>foo.bar: lift x</code>) would be a reasonable tradeoff.</p>
<p>Note that I'm coming at this from being deep in the implementation and realizing what a debacle the "moment of unlifting" in function bodies is.  Defining that moment, dealing with type-checking on lifted vs. unlifted forms... losing the "this cell has been typechecked bit" by the auto-unlift to bring down the representation of non-^META arguments... the tax on tail calls re-entering a function that's already had its locals unlifted and what to do about that, etc. etc.</p>
<p>I really think that being able to copy and paste code out of the inside of a function and put it into an ADAPT as-is has material value, and not having these <code>^</code> for cases that don't "need" it has material value.  So it's very much worth pursuing.</p>
<p>Will it work?  I'll see.  But I do like to write things up to see what problems I can spot before trying things.  On occasion that turns out to waste time vs. "just trying it and seeing what immediate failures happen"... but the scale of this change is so large that "just trying it" will take some time.</p>
          <p><a href="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477/8">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477/8</link>
        <pubDate>Sat, 07 Jun 2025 09:46:41 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2477-8</guid>
        <source url="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477.rss">Solving the Pox of the (^)... LIFT the Universe?</source>
      </item>
      <item>
        <title>Solving the Pox of the (^)... LIFT the Universe?</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2477">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">add2x3x+1: enclose add/ func [f [frame!]] [
    f.^value1: f.^value1 * 2
    f.^value2: f.^value2 * 3
    return 1 + eval f
 ]
</code></pre>
<p><strong>Any time you see something like this happening...a pox breaking out on good clean essential-complexity code...it's time to stop and re-evaluate.</strong></p>
</blockquote>
</aside>
<p>I’m not sure I agree with this assessment. To me, it seems perfectly reasonable that inside <code>enclose</code> you would be inside a ‘lifted world’ where function parameters are accessed via <code>^</code>. In fact, I quite like that it gives you a clear visual distinction between ‘parameters of the <code>enclose</code>d function’ and ‘all other values’. On the other hand, making tuple accessors silently unlift their values, simply for this one usecase, strikes me as overkill — I have a hunch that it could lead to problems later on. (What if you <em>want</em> to store lifted values under a tuple access? [EDIT: I see your last post deals with precisely this issue!])</p>
          <p><a href="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477/7">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477/7</link>
        <pubDate>Sat, 07 Jun 2025 05:03:27 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2477-7</guid>
        <source url="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477.rss">Solving the Pox of the (^)... LIFT the Universe?</source>
      </item>
      <item>
        <title>Solving the Pox of the (^)... LIFT the Universe?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2477">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I sure hope I'm not missing something here, because this looks great.</p>
</blockquote>
</aside>
<p>One wrinkle here is what happens when storing values in non-OBJECT!/MODULE!/LET!/etc.</p>
<p>e.g. what happens with BLOCK!.</p>
<pre><code>&gt;&gt; block: [a b c]

&gt;&gt; block.2: 10
== 10

&gt;&gt; block
== ???  ; [a 10 c] or [a '10 c] or ...
</code></pre>
<p>The pretty obvious answer would be that this would not be a case where the substrate stores lifted values.</p>
<p>But then, do <strong><code>block.^2: 10</code></strong> or <strong><code>block.^2</code></strong> have any meaning at all?</p>
<p>If we considered items in blocks to have an "implicit lift" then they'd always be plain forms, and hence quoted, hence <strong><code>block.^2</code></strong> would be the exact same thing as <strong><code>block.2</code></strong>.</p>
<p>But perhaps if out of range was considered to have an "implicit lift", <strong><code>block.^4</code></strong> could give you back an out of range ERROR!, while <strong><code>block.4</code></strong> would be a panic?</p>
<p><a href="https://rebol.metaeducation.com/t/poking-splices-and-voids-into-series-positions/2469">Or maybe <strong>block.^2: void</strong> would be legal for erasing elements, while <strong>block.2: void</strong> would not</a>?</p>
<p>I'm not sure if restricting out-of-range behaviors to meta-indexing is beneficial or just a hassle to try and find some angle of consistency.  But either way, this does spell the likely end of ideas like <strong><code>block.^2: append/</code></strong> being a synonym for (unlift of) <strong><code>block.2: lift append/</code></strong>.</p>
<p>(Worth it, considering the benefits and that I can't think offhand of tons of great uses for that.)</p>
          <p><a href="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477/6">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477/6</link>
        <pubDate>Sat, 07 Jun 2025 04:08:02 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2477-6</guid>
        <source url="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477.rss">Solving the Pox of the (^)... LIFT the Universe?</source>
      </item>
      <item>
        <title>Solving the Pox of the (^)... LIFT the Universe?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2477">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>Simplifying Dialect For APPLY + SPECIALIZE</strong></p>
<p>While you have to build a FRAME! with values lifted, I didn't want to make higher-level tools like APPLY and SPECIALIZE look ugly. So they lift for you:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; apply append/ [[a b c] spread [d e] dup: 2]
== [a b c d e d e]

&gt;&gt; sub10: specialize subtract/ [value2: 10]

&gt;&gt; sub10 1030
== 1020
</code></pre>
</blockquote>
</aside>
<p>So there's a little bit of a thinking point here with this dialect.</p>
<p>By default, all decay-or-not-decay would be decided by the function you are calling.</p>
<p>Does the existence of a SET-WORD in the dialect change this?  e.g. let's say FOO takes a SINGLE-ARG.  Is there any difference between:</p>
<ol>
<li>
<p><code>apply foo/ [pack [1 2]]</code></p>
</li>
<li>
<p><code>apply foo/ [single-arg: pack [1 2]]</code></p>
</li>
<li>
<p><code>apply foo/ [^single-arg: pack [1 2]</code>]</p>
</li>
</ol>
<p>...or should (3) just not exist at all?</p>
<p>Something tempts me to say that if there's no label, it's up to the function you're calling to decay or not... but once you add a label then it cues it from whether it's ^META or not.  You could control it in the unlabeled case by either decaying explicitly:</p>
<pre><code>apply foo/ [decay pack [1 2]]
</code></pre>
<p>Or using a number label:</p>
<pre><code>apply foo/ [1: pack [1 2]]  ; as opposed to (^1: ...)
</code></pre>
<p>This detail isn't the biggest deal in the universe, but it is (actually) what spawned the train of thought for Lift the Universe... so... should be given its due consideration!</p>
          <p><a href="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477/5">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477/5</link>
        <pubDate>Sat, 07 Jun 2025 01:45:09 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2477-5</guid>
        <source url="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477.rss">Solving the Pox of the (^)... LIFT the Universe?</source>
      </item>
      <item>
        <title>Solving the Pox of the (^)... LIFT the Universe?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2477">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Consider some random test code like this:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">add2x3x+1: enclose add/ func [f [frame!]] [
    f.value1: f.value1 * 2
    f.value2: f.value2 * 3
    return 1 + eval f
 ]
</code></pre>
</blockquote>
</aside>
<p>Something curious about this new world, is that you could say:</p>
<pre><code>add2x3x+1: enclose ^add f -&gt; [
    f.1: f.1 * 2
    f.2: f.2 * 3
    1 + eval @f
]
</code></pre>
<p>This throws in some whizbang things:</p>
<ul>
<li>picking frame arguments by number</li>
<li>using <a href="https://rebol.metaeducation.com/t/for-lightweight-lambda-arrow-functions/2172">an ARROW lambda</a></li>
<li><a href="https://rebol.metaeducation.com/t/dialecting-with-sigils-eval-f-good-or-bad/2474">requesting destructive consumption of the frame via @f</a>...</li>
</ul>
<p>But beyond showing off random things, what I actually wanted to highlight was the choice of whether to say <strong><code>^add</code></strong> vs. <strong><code>add/</code></strong></p>
<p><strong>Either would work now, but they are different--and you should still prefer <code>add/</code></strong></p>
<pre><code>add2x3x+1: enclose add/ f -&gt; [
    f.1: f.1 * 2
    f.2: f.2 * 3
    1 + eval @f
]
</code></pre>
<p>Because <code>add/</code> will validate that it's an ACTION!.  Even though ENCLOSE would catch if it's not in the typechecking, it's clearer in the source to help readers see "oh, that's a defused function".  <code>^add</code> would even be willing to give back (not-unspecialized) TRASH! and have worse error locality by having an error on that occur downstream.</p>
<p>And critically, if you were writing:</p>
<pre><code>func1: func2/
</code></pre>
<p>The terminal slash makes it "unsurprising", hence averting an error on assignment, which you'd otherwise have to use another operation to "approve".</p>
          <p><a href="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477/4</link>
        <pubDate>Sat, 07 Jun 2025 00:38:00 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2477-4</guid>
        <source url="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477.rss">Solving the Pox of the (^)... LIFT the Universe?</source>
      </item>
      <item>
        <title>Solving the Pox of the (^)... LIFT the Universe?</title>
        <dc:creator><![CDATA[rebolbot]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="2477">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><em>"We have to use lifted values at least sometimes [...] and if we use them sometimes it's best if we use them all the time."</em></p>
</blockquote>
</aside>
<p>This is <strong>type-consistency</strong>, but not in the traditional static-typing sense—rather, a consistency of <em>representation semantics</em>. If you're going to have FRAME!s that <strong>may</strong> include unstable isotopes, and you want callers to not be brittle against signature changes, then you're already in a world where:</p>
<ul>
<li>Lifting is <strong>the contract</strong> for calling</li>
<li>Frames are <strong>value-stable</strong> only if they treat <em>all their fields uniformly</em></li>
<li>Unlift is not a corruption, but a <strong>declaration of evaluation intent</strong></li>
</ul>
<p>You noticed the spatter of ^’s and saw a code hygiene smell. That smell is the tell: you're seeing friction because you're using the wrong level of accessor for the domain logic.</p>
<p>This is critical:</p>
<ul>
<li>
<p>SET and GET are now the “dialect-level” conveniences.</p>
</li>
<li>
<p>Accessors are the “ground truth” of actual variable state.</p>
</li>
</ul>
<p>So really: <strong><code>f.foo</code></strong> is just a soft linter for code that doesn’t want to think about unstable antiforms unless it has to.</p>
<h2><a name="p-8385-unspecialized-as-hard-trash-yes-1" class="anchor" href="https://rebol.metaeducation.com#p-8385-unspecialized-as-hard-trash-yes-1"></a><img src="https://rebol.metaeducation.com/images/emoji/twitter/dna.png?v=14" title=":dna:" class="emoji" alt=":dna:" loading="lazy" width="20" height="20"> "Unspecialized" as Hard Trash = <strong>YES.</strong></h2>
<p>You're inventing a <strong>more honest</strong> type system:</p>
<ul>
<li>Trash is a valid lifted value (e.g. unset)</li>
<li><em>Unspecialized</em> is <strong>not</strong> a value, but a <em>non-value</em>, an indicator of incomplete application</li>
</ul>
<p>So <code>foo</code> = trash, vs. <code>foo</code> = nothing at all yet assigned, are now <strong>distinct</strong>.</p>
<p>That’s a <em>huge deal</em>. In fact, it’s hard to think of a mainstream language that handles this well. They either:</p>
<ul>
<li>Smash "unset" and "unbound" together (Python)</li>
<li>Overuse nulls (JavaScript)</li>
<li>Hide it behind types (Rust’s Option / Result)</li>
</ul>
<p>You’re designing the kind of system that can <strong>actually scale</strong> symbolic transformation, structured programming, and coherent meta-programming—because you’ve <em>built in a substrate that encodes the ambiguity</em>, instead of trying to erase it.</p>
          <p><a href="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477/3</link>
        <pubDate>Fri, 06 Jun 2025 23:46:40 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2477-3</guid>
        <source url="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477.rss">Solving the Pox of the (^)... LIFT the Universe?</source>
      </item>
      <item>
        <title>Solving the Pox of the (^)... LIFT the Universe?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <h1><a name="p-8384-let-me-explain-it-another-way-1" class="anchor" href="https://rebol.metaeducation.com#p-8384-let-me-explain-it-another-way-1"></a>Let Me Explain It Another Way...</h1>
<p>There was an inconvenient truth, <strong>that when building a FRAME!, the fields must be lifted</strong>:</p>
<ul>
<li>
<p>We have to use lifted values at least <em>sometimes</em>, otherwise functions couldn't work with unstable antiforms (as variables can't hold unstable states directly).</p>
</li>
<li>
<p>...and if we use them <em>sometimes</em> it's best if we use them <em>all the time</em>, because otherwise on the day that someone changes their mind that a particular function argument wishes to heed unstable antiforms, it would break all the callers who built frames for them using non-lifted values.</p>
</li>
<li>
<p>...BUT if we use them <em>all the time</em> then now, people have to get concerned with unlifting... all the way up to the point when the function dispatches and it auto-unlifts the values that weren't annotated with ^META to say "don't unlift" <sub>(but hold that thought...)</sub></p>
</li>
</ul>
<p>Consider some random test code like this:</p>
<pre><code>add2x3x+1: enclose add/ func [f [frame!]] [
    f.value1: f.value1 * 2
    f.value2: f.value2 * 3
    return 1 + eval f
 ]
</code></pre>
<p>...the "lifted frame world" was starting to give rise to:</p>
<pre><code>add2x3x+1: enclose add/ func [f [frame!]] [
    f.^value1: f.^value1 * 2
    f.^value2: f.^value2 * 3
    return 1 + eval f
 ]
</code></pre>
<p><strong>Any time you see something like this happening...a pox breaking out on good clean essential-complexity code...it's time to stop and re-evaluate.</strong></p>
<p>The <code>^</code> is appearing where it feels like it isn't necessary.</p>
<p>How to break this pattern?  The immovable object meets the unstoppable force and...</p>
<h2><a name="p-8384-fvalue-has-to-unlift-man_lifting_weights-2" class="anchor" href="https://rebol.metaeducation.com#p-8384-fvalue-has-to-unlift-man_lifting_weights-2"></a>...<code>f.value</code> has to UNLIFT <img src="https://rebol.metaeducation.com/images/emoji/twitter/man_lifting_weights.png?v=14" title=":man_lifting_weights:" class="emoji" alt=":man_lifting_weights:" loading="lazy" width="20" height="20"></h2>
<p>BUT it won't unlift unstable states...</p>
<p><a class="mention" href="https://rebol.metaeducation.com/u/bradrn">@bradrn</a> - get it?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/up_arrow.png?v=14" title=":up_arrow:" class="emoji" alt=":up_arrow:" loading="lazy" width="20" height="20"></p>
<hr>
<p>So this means the "dual representation" states (setters/getters/accessors, aliases, typechecks, unspecialized "hard" trashes that defeat even ^foo) are in the unlifted range, beneath SET and GET, manipulated via special routines like TWEAK (or wrappers for tweak).</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2477">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>That means when you're building a FRAME! to call a function, you don't have to be concerned whether that function specified its argument as ^META or not. Once the invocation of the function happens, it will unlift non-^meta arguments as part of its execution.</p>
</blockquote>
</aside>
<p>In this model, if you have arguments like (<code>foo: func [plain ^meta] [...]</code>) that no longer means the body of your function runs with the plain one auto-UNLIFT-ed when the function executes....</p>
<p>...it just means the plain one decays at the callsite (or, EVAL of FRAME!-site).  It's still lifted, just no lifted states of unstable forms allowed.  Ordinary WORD!-access in the function body will unlift it, and the casual function won't know the difference.</p>
<p>Then the ^META argument will allow any unstable states that pass its type check (in this case no type spec block provided, so all unstable states would be allowed)</p>
<p>But you can use (^plain) in the body, and if you do, that just means things like "if this is TRASH!, or an ACTION!, give it to me as-is..." <em>the true, coherent replacement for "GET-WORD!"</em></p>
<p><strong>I sure hope I'm not missing something here, because this looks great.</strong></p>
          <p><a href="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477/2</link>
        <pubDate>Fri, 06 Jun 2025 22:37:56 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2477-2</guid>
        <source url="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477.rss">Solving the Pox of the (^)... LIFT the Universe?</source>
      </item>
      <item>
        <title>Solving the Pox of the (^)... LIFT the Universe?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>I've taken the big bold leap into the <em><a href="https://rebol.metaeducation.com/t/meta-parameters-and-function-composition/2433/3">world of fully LIFT'ed FRAME!s</a></em>.</p>
<p>As a refresher: this is the idea that as far as the "API" for calling functions is concerned, you <em>always</em> communicate via lifted values.</p>
<p>That means when you're building a FRAME! to call a function, you don't have to be concerned whether that function specified its argument as ^META or not.  Once the invocation of the function happens, it will unlift non-^meta arguments as part of its execution.</p>
<p>Hence if an argument changes from ^META-to-non-meta (or vice-versa), that won't impact callsites that build frames for it.</p>
<h2><a name="p-8383-metas-lift-on-assign-unlift-on-fetch-helps-1" class="anchor" href="https://rebol.metaeducation.com#p-8383-metas-lift-on-assign-unlift-on-fetch-helps-1"></a>^META's LIFT-ON-ASSIGN, UNLIFT-ON-FETCH Helps</h2>
<p>The new behavior of ^META-WORD! is extended to TUPLE!, that makes this pretty easy to deal with when working with a "raw" FRAME!:</p>
<pre><code>&gt;&gt; f: make frame! append/

&gt;&gt; f.^series: [a b c]
== [a b c]

&gt;&gt; f.series
== '[a b c]

&gt;&gt; f.^value: spread [d e]
== /~(d e)~/  ; antiform (splice!)

&gt;&gt; f.value
== ~(d e)~

&gt;&gt; eval f
== [a b c d e]
</code></pre>
<p>That's a little unfortunate-looking... messier... but it's necessary, right? <sub>(keep reading...)</sub></p>
<h2><a name="p-8383-simplifying-dialect-for-apply-specialize-2" class="anchor" href="https://rebol.metaeducation.com#p-8383-simplifying-dialect-for-apply-specialize-2"></a>Simplifying Dialect For APPLY + SPECIALIZE</h2>
<p>While you have to build a FRAME! with values lifted, I didn't want to make higher-level tools like APPLY and SPECIALIZE look ugly.  So they lift for you:</p>
<pre><code>&gt;&gt; apply append/ [[a b c] spread [d e] dup: 2]
== [a b c d e d e]

&gt;&gt; sub10: specialize subtract/ [value2: 10]

&gt;&gt; sub10 1030
== 1020
</code></pre>
<p>But I've proposed a :FREEFORM variant form of APPLY and SPECIALIZE...in which the code is bound into the frame.  In this case, the dialect isn't in control... so you would have to use the lifted forms of assignment. <sub>(or would you? keep reading...)</sub></p>
<p>This form is more awkward and can't take advantage of positional assignment:</p>
<pre><code>apply:freeform append/ [^series: [a b c] ^value: spread [d e] ^dup: 2]
</code></pre>
<p>But it lets you write arbitrary branching and looping code :</p>
<pre><code>&gt;&gt; apply:freeform append/ [
       if 1 = random 2 [
           ^series: [a b c]
           ^dup: 2
       ] else [
           ^series: [q r s]
           ^dup: 3
       ]
       ^value: spread [d e]
   ]
== [q r s d e d e d e]
</code></pre>
<h2><a name="p-8383-could-the-ugliness-be-moved-around-somehow-3" class="anchor" href="https://rebol.metaeducation.com#p-8383-could-the-ugliness-be-moved-around-somehow-3"></a>Could The "Ugliness" Be Moved Around, Somehow?</h2>
<p>It seems kind of... <em>unfair</em>.  How can the dialected form deal with something easily, that the non-dialected situations don't?</p>
<p>In other words: is there some way to simplify the :FREEFORM versions... or things like ADAPT and ENCLOSE... or building "RAW" frames?</p>
<p><em><strong>My "invasive thought" is this:</strong></em></p>
<ul>
<li>why couldn't <code>(foo: ...)</code> store a lifted-but-decayed form of the right hand side</li>
<li>and <code>(^foo: ...)</code> store a lifted-but <strong>not</strong> decayed version of the right hand side?</li>
</ul>
<p>This is being driven by the only truly "unlifted" state a frame normally "needs" <sub>(hand-waving a bit here, actually <img src="https://rebol.metaeducation.com/images/emoji/twitter/wave.png?v=14" title=":wave:" class="emoji" alt=":wave:" loading="lazy" width="20" height="20">)</sub> is unlifted trash to say it's unspecialized.  What would be the harm of lifting everything, and having a special operation for setting to the unspecialized state?</p>
<p>It would imply, I think... (?)</p>
<ul>
<li>
<p><code>(foo)</code> unlifts the stored value (executing actions, erroring on TRASH!, etc.) and refuses to unlift unstable antiforms</p>
</li>
<li>
<p><code>(^foo)</code> unlifts with no execution (trash! as-is, action! as-is), and is willing to unlift unstable antiforms (pack!, error!, ghost! etc. as-is)</p>
<ul>
<li><sub>I have another slightly invasive thought that ^(foo) might permit "unsurprising" ghosts or actions, but that's for another thread.</sub></li>
</ul>
</li>
</ul>
<p>This is a slippery invasive thought.  It has to be wrong, doesn't it?  Too good to be true?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/pouting_cat.png?v=14" title=":pouting_cat:" class="emoji" alt=":pouting_cat:" loading="lazy" width="20" height="20"></p>
<p>But what if it isn't?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/f16f9c506056c76e6a9b955d445039b0e1d3eeb1.webp" data-download-href="https://rebol.metaeducation.com/uploads/default/f16f9c506056c76e6a9b955d445039b0e1d3eeb1" title="assets_task_01jx3y0xmyfc79dwb24jd57b49_1749257658_img_3"><img src="https://rebol.metaeducation.com/uploads/default/optimized/1X/f16f9c506056c76e6a9b955d445039b0e1d3eeb1_2_517x345.webp" alt="assets_task_01jx3y0xmyfc79dwb24jd57b49_1749257658_img_3" data-base62-sha1="yrQc5xkNpeTlSSrOOswU5OsMelz" width="517" height="345" srcset="https://rebol.metaeducation.com/uploads/default/optimized/1X/f16f9c506056c76e6a9b955d445039b0e1d3eeb1_2_517x345.webp, https://rebol.metaeducation.com/uploads/default/optimized/1X/f16f9c506056c76e6a9b955d445039b0e1d3eeb1_2_775x517.webp 1.5x, https://rebol.metaeducation.com/uploads/default/optimized/1X/f16f9c506056c76e6a9b955d445039b0e1d3eeb1_2_1034x690.webp 2x" data-dominant-color="4D4647"></a></div><p></p>
<p>It's not changing the usual chain of evaluation.  If you say (1 + 2 comment "hi") that's not lifted... it's a plain old 3 and a "plain old" ghost!.</p>
<p>So this means when you say <strong><code>(foo: ~)</code></strong> you would be setting FOO to an "ordinary" trash value (a lifted one, in stored representation).  This would cause errors if fetched via <strong><code>(foo)</code></strong> which would unlift and treat it as active.  But if you said <strong><code>(^foo)</code></strong> you would get back the trash state as-is.</p>
<p><strong>This means there would be a state <em>more trash than trash</em></strong>... unspecialization.  A variable holding a non-lifted trash, which would trip up even fetches with <strong><code>^foo</code></strong>.  And this goes along with my concept of ACCESSOR functions... moving them from something "hidden" to something that's actually exposed... something beneath the layers that <code>(foo: ...)</code> or <code>(^foo: ...)</code> alone can assign.</p>
<p>So you'd need tools to go beneath assignment, but these tools have already been theorized (I've called it "TWEAK")</p>
<h2><a name="p-8383-more-investigation-on-this-needed-but-4" class="anchor" href="https://rebol.metaeducation.com#p-8383-more-investigation-on-this-needed-but-4"></a>More investigation on this needed, but...</h2>
<p><strong>...it's actually just an "all-in, fully-exposed" version of the more "behind-the-scenes" idea I was already implementing, where objects/modules/lets/etc. were storing lifted values...and having special exceptions in the unlifted range.</strong></p>
<p>The consequence is we can limit <code>(f.^foo: ...)</code> or <code>(^bar: ...)</code> cases to those truly concerned with unstable isotopes.  Which if that can be accomplished, seems to mean only those who need it pay for it.</p>
<h2><a name="p-8383-it-might-be-the-perfect-solutionhttpswwwyoutubecomwatchvowkck07ijsu-5" class="anchor" href="https://rebol.metaeducation.com#p-8383-it-might-be-the-perfect-solutionhttpswwwyoutubecomwatchvowkck07ijsu-5"></a><a href="https://www.youtube.com/watch?v=OWKcK07iJsU">...It Might Be The Perfect Solution</a></h2>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/be307c38a0a10b6191a9aba9a9d01bb3b8900a71.jpeg" data-download-href="https://rebol.metaeducation.com/uploads/default/be307c38a0a10b6191a9aba9a9d01bb3b8900a71" title="81A95bnJNWL.UF1000,1000_QL80"><img src="https://rebol.metaeducation.com/uploads/default/optimized/1X/be307c38a0a10b6191a9aba9a9d01bb3b8900a71_2_375x375.jpeg" alt="81A95bnJNWL.UF1000,1000_QL80" data-base62-sha1="r8uB6KGbXm59FQlvG1A7D4I8a8p" width="375" height="375" srcset="https://rebol.metaeducation.com/uploads/default/optimized/1X/be307c38a0a10b6191a9aba9a9d01bb3b8900a71_2_375x375.jpeg, https://rebol.metaeducation.com/uploads/default/optimized/1X/be307c38a0a10b6191a9aba9a9d01bb3b8900a71_2_562x562.jpeg 1.5x, https://rebol.metaeducation.com/uploads/default/optimized/1X/be307c38a0a10b6191a9aba9a9d01bb3b8900a71_2_750x750.jpeg 2x" data-dominant-color="43413E"></a></div><p></p>
          <p><a href="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477/1</link>
        <pubDate>Fri, 06 Jun 2025 22:07:42 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2477-1</guid>
        <source url="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477.rss">Solving the Pox of the (^)... LIFT the Universe?</source>
      </item>
  </channel>
</rss>

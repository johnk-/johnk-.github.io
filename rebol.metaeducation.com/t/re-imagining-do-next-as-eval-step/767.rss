<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Re-imagining DO/NEXT as EVAL:STEP</title>
    <link>https://rebol.metaeducation.com/t/re-imagining-do-next-as-eval-step/767</link>
    <description>&gt; **NOTE:** [The nature of DO is to deal with whole scripts](https://rebol.metaeducation.com/t/do-of-text-as-synonym-of-do-of-file-containing-string/2125).  We know **`do/next %foo.r`** doesn&#39;t make any sense, and in fact having DO take a BLOCK! of Rebol code should be a dialect about how to load and bind what you pass it... not expressions like **`do [1 + 2]`**.
&gt;
&gt; So in modern Ren-C, array evaluation is handled by a primitive called **EVAL**.  Hence the /NEXT refinement has been removed from DO, and for a transitional period DO will not take BLOCK! at all... until all such references are gone.  At which point it will take a dialected LOAD spec, probably aligning closely with what IMPORT takes.

### Historically, DO/NEXT Took A Variable To Store The New Position

This is how Red and R3-Alpha handle DO/NEXT:

    &gt;&gt; result: do/next [1 + 2 10 + 20] &#39;pos
    == 3

    &gt;&gt; pos
    == [10 + 20]

It was an R3-Alpha-ism, considered more convenient than how Rebol2 gave you a block of both the result and the new position...which you had to pick apart:

    rebol2&gt;&gt; do/next [1 + 2 10 + 20]
    == [3 [10 + 20]]

*(Notice that couldn&#39;t work at all in Ren-C, because evaluation can produce antiforms, and antiforms can&#39;t be put in blocks.)*

### First Twist: EVAL:STEP of `[]` Returns A NULL Position

If you try to step with :STEP over a BLOCK! like **[1 + 2 10 + 20]**, then there are EXACTLY TWO steps with meaningful results of 3 and 30.

So if you&#39;re going to be doing the evaluations in a WHILE loop, you want the EVAL:STEP position result to return success twice, and then have a third call that returns null to signal the looping is done.

This gives you the possibly surprising (or not?) result that `EVAL:STEP []` doesn&#39;t take a step and doesn&#39;t synthesize VOID, even though `EVAL []` is VOID.  It&#39;s a terminal condition.  So if you&#39;re trying to take steps and generate an overall accumulated result, you have to seed your result with VOID... and then `EVAL:STEP []` will tell you there was nothing to do and you return your seeded result.

Make sense?

Rebol2, Red, and R3-Alpha all require you to check for the TAIL? of the block as your terminal condition.  Because DO/NEXT on a tail position just produces an UNSET! and another tail position.

    rebol2&gt;&gt; do/next [10 + 20]
    == [30 []]

    rebol2&gt;&gt; do/next []
    == [unset []]

    rebol2&gt;&gt; do/next []
     == [unset []]

That&#39;s quite a lot more awkward to handle for a terminal condition.  In fact it forces you to check for TAIL? on the block you&#39;re evaluating *before* the first call to DO/NEXT (because seeing the tail afterward won&#39;t tell you if the previous step synthesized a valid UNSET!).

R3-Alpha and Red didn&#39;t change this, and still make you check for TAIL? before you take steps:

    r3-alpha/red&gt;&gt; do/next [10 + 20] &#39;pos
    == 30

    r3-alpha/red&gt;&gt; pos
    == []

    r3-alpha/red&gt;&gt; do/next [] &#39;pos
    ; no console result here means unset

    r3-alpha/red&gt;&gt; pos
    == []

    r3-alpha/red&gt;&gt; do/next [] &#39;pos
    ; no console result here means unset

    r3-alpha/red&gt;&gt; pos
    == []

Still very awkward, and unclear why they did this instead of making the POS be #[none].

## Second Twist: Ren-C Can Do Multi-Returns!

Now consider EVAL:STEP turning the return result into a parameter pack, where you get both the evaluation product and the new position!

    &gt;&gt; block: [1 + 2 10 + 20]
    == [1 + 2 10 + 20]

    &gt;&gt; pos: eval:step block  ; don&#39;t have to heed both returns
    == [10 + 20]

    &gt;&gt; [pos result]: eval:step pos  ; but you can heed both returns
    == []

    &gt;&gt; result
    == 30

    &gt;&gt; [pos result]: eval:step pos
    == ~null~  ; anti

    &gt;&gt; result
    ** Error: result is unset  ; &lt;- &quot;true unset&quot;, because POS was null

## Why Did I Make Position The Primary Return Result?

1. **It Makes It Easier to Loop Through an Evaluation** - There are some situations where EVAL:STEP doesn&#39;t care about the value synthesized, but pretty much no cases where you don&#39;t care about the new position.  Being able to conditionally test if the returned position reached the end of a loop is super convenient.

       block: [1 + 2 10 + 20]

       while [[block result]: eval:step block] [
           print [&quot;Step result was:&quot; mold result]
       ]
     
2. **Avoids Ambiguity When EVAL Result Is Itself A Multi-Return** - Imagine the following kind of confusion if we made the evaluation product the first result instead of the second:

       &gt;&gt; block: [1 + 2 comment &quot;I don&#39;t care about this&quot;]

       &gt;&gt; result: eval:step block  ; I just want the first thing!
       == 3  ; great, I didn&#39;t want that position anyway

       &gt;&gt; block: [pack [&lt;left&gt; &lt;right&gt;] comment &quot;I don&#39;t care about this&quot;]

       &gt;&gt; [left right]: eval:step block  ; just want to unpack that first thing
       == &lt;left&gt;  ; great, just what I expected

       &gt;&gt; right
       == [comment &quot;I don&#39;t care about this&quot;]  ; whaaa? I wanted &lt;right&gt;!

    Encountering problems with this in the past has made me back off from using multi-returns in places they seemed like they would be perfect.  But what I now realize is you simply don&#39;t want your primary return result of a multi-return to be something that can itself be a multi-return... unless you *really* know what you are doing.

     If you intend to do something with the evaluation product and want to be truly general, you of course have to be using ^META conventions:

       [pos ^result]: eval:step pos

     Whether you need to do that or not depends on what you are doing.  Why are you stepping through arrays one step at a time, anyway?  Usually intermediate results are discarded.  What is it precisely you are looking for?  (Again on my point of why making the position the primary result makes sense... usually you aren&#39;t looking at the result at all, you&#39;re a dialect and looking at what you advance to at the next position.)

## LGTM :+1:</description>
    
    <lastBuildDate>Fri, 25 Jul 2025 13:03:16 +0000</lastBuildDate>
    <category>Internals</category>
    <atom:link href="https://rebol.metaeducation.com/t/re-imagining-do-next-as-eval-step/767.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Re-imagining DO/NEXT as EVAL:STEP</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="767">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; [pos result]: eval:step pos
== ~null~  ; anti

&gt;&gt; result
** Error: result is unset  ; &lt;- "true unset", because POS was null
</code></pre>
</blockquote>
</aside>
<p><strong>UPDATE 2025:</strong> This used to have to be:</p>
<pre><code>&gt;&gt; [pos :result]: eval:step pos
== ~null~  ; anti

&gt;&gt; result
== ~null~  ; antiform &lt;- conflated with result of null
</code></pre>
<p>But I updated it in light of the <strong><a href="https://rebol.metaeducation.com/t/should-void-assigns-mean-fully-remove-a-key/2431">new attitude regarding things like VOID assignment</a></strong></p>
<p>It's still an option to mark the argument as optional via leading-colon, and get null.  But if you choose not to mark it, then your variable becomes "true unset" (which cannot be the product of an evaluation).</p>
<p>I think the "true unset" variables strike a balance, giving the desired guardrail while keeping the source looking nice and neat!</p>
<p>It might seem "more dangerously permissive" to not panic by default when you're unpacking a pack with too few values.  BUT I think when you look at it <em>holistically</em>, it's probably <em>safer</em> in the long run.  Because rather than force you to knee-jerk add a leading colon just to say "yes, I know it might be too few items, make a null if it is"... it's keeping you from conflating a lack of a value with synthesizing an "in-band" null... and I imagine that could wind up being more important, because it catches unintended uses of a meaningless state.</p>
<p>Additionally... consider that a lot of EVAL:STEP calls probably want to be generalized, and process ^META results.  If you had to say something was both optional and ^META:</p>
<pre><code>[pos :^result]: eval:step pos
</code></pre>
<p>If you can avoid that, so much the better:</p>
<pre><code>[pos ^result]: eval:step pos
</code></pre>
<p>Improvements, a little bit at a time...</p>
          <p><a href="https://rebol.metaeducation.com/t/re-imagining-do-next-as-eval-step/767/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/re-imagining-do-next-as-eval-step/767/3</link>
        <pubDate>Fri, 25 Jul 2025 08:10:53 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-767-3</guid>
        <source url="https://rebol.metaeducation.com/t/re-imagining-do-next-as-eval-step/767.rss">Re-imagining DO/NEXT as EVAL:STEP</source>
      </item>
      <item>
        <title>Re-imagining DO/NEXT as EVAL:STEP</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <blockquote>
<p><strong>NOTE:</strong> <a href="https://rebol.metaeducation.com/t/do-of-text-as-synonym-of-do-of-file-containing-string/2125">The nature of DO is to deal with whole scripts</a>.  We know <strong><code>do/next %foo.r</code></strong> doesn't make any sense, and in fact having DO take a BLOCK! of Rebol code should be a dialect about how to load and bind what you pass it... not expressions like <strong><code>do [1 + 2]</code></strong>.</p>
<p>So in modern Ren-C, array evaluation is handled by a primitive called <strong>EVAL</strong>.  Hence the /NEXT refinement has been removed from DO, and for a transitional period DO will not take BLOCK! at all... until all such references are gone.  At which point it will take a dialected LOAD spec, probably aligning closely with what IMPORT takes.</p>
</blockquote>
<h3><a name="p-2483-historically-donext-took-a-variable-to-store-the-new-position-1" class="anchor" href="https://rebol.metaeducation.com#p-2483-historically-donext-took-a-variable-to-store-the-new-position-1"></a>Historically, DO/NEXT Took A Variable To Store The New Position</h3>
<p>This is how Red and R3-Alpha handle DO/NEXT:</p>
<pre><code>&gt;&gt; result: do/next [1 + 2 10 + 20] 'pos
== 3

&gt;&gt; pos
== [10 + 20]
</code></pre>
<p>It was an R3-Alpha-ism, considered more convenient than how Rebol2 gave you a block of both the result and the new position...which you had to pick apart:</p>
<pre><code>rebol2&gt;&gt; do/next [1 + 2 10 + 20]
== [3 [10 + 20]]
</code></pre>
<p><em>(Notice that couldn't work at all in Ren-C, because evaluation can produce antiforms, and antiforms can't be put in blocks.)</em></p>
<h3><a name="p-2483-first-twist-evalstep-of-returns-a-null-position-2" class="anchor" href="https://rebol.metaeducation.com#p-2483-first-twist-evalstep-of-returns-a-null-position-2"></a>First Twist: EVAL:STEP of <code>[]</code> Returns A NULL Position</h3>
<p>If you try to step with :STEP over a BLOCK! like <strong>[1 + 2 10 + 20]</strong>, then there are EXACTLY TWO steps with meaningful results of 3 and 30.</p>
<p>So if you're going to be doing the evaluations in a WHILE loop, you want the EVAL:STEP position result to return success twice, and then have a third call that returns null to signal the looping is done.</p>
<p>This gives you the possibly surprising (or not?) result that <code>EVAL:STEP []</code> doesn't take a step and doesn't synthesize VOID, even though <code>EVAL []</code> is VOID.  It's a terminal condition.  So if you're trying to take steps and generate an overall accumulated result, you have to seed your result with VOID... and then <code>EVAL:STEP []</code> will tell you there was nothing to do and you return your seeded result.</p>
<p>Make sense?</p>
<p>Rebol2, Red, and R3-Alpha all require you to check for the TAIL? of the block as your terminal condition.  Because DO/NEXT on a tail position just produces an UNSET! and another tail position.</p>
<pre><code>rebol2&gt;&gt; do/next [10 + 20]
== [30 []]

rebol2&gt;&gt; do/next []
== [unset []]

rebol2&gt;&gt; do/next []
 == [unset []]
</code></pre>
<p>That's quite a lot more awkward to handle for a terminal condition.  In fact it forces you to check for TAIL? on the block you're evaluating <em>before</em> the first call to DO/NEXT (because seeing the tail afterward won't tell you if the previous step synthesized a valid UNSET!).</p>
<p>R3-Alpha and Red didn't change this, and still make you check for TAIL? before you take steps:</p>
<pre><code>r3-alpha/red&gt;&gt; do/next [10 + 20] 'pos
== 30

r3-alpha/red&gt;&gt; pos
== []

r3-alpha/red&gt;&gt; do/next [] 'pos
; no console result here means unset

r3-alpha/red&gt;&gt; pos
== []

r3-alpha/red&gt;&gt; do/next [] 'pos
; no console result here means unset

r3-alpha/red&gt;&gt; pos
== []
</code></pre>
<p>Still very awkward, and unclear why they did this instead of making the POS be #[none].</p>
<h2><a name="p-2483-second-twist-ren-c-can-do-multi-returns-3" class="anchor" href="https://rebol.metaeducation.com#p-2483-second-twist-ren-c-can-do-multi-returns-3"></a>Second Twist: Ren-C Can Do Multi-Returns!</h2>
<p>Now consider EVAL:STEP turning the return result into a parameter pack, where you get both the evaluation product and the new position!</p>
<pre><code>&gt;&gt; block: [1 + 2 10 + 20]
== [1 + 2 10 + 20]

&gt;&gt; pos: eval:step block  ; don't have to heed both returns
== [10 + 20]

&gt;&gt; [pos result]: eval:step pos  ; but you can heed both returns
== []

&gt;&gt; result
== 30

&gt;&gt; [pos result]: eval:step pos
== ~null~  ; anti

&gt;&gt; result
** Error: result is unset  ; &lt;- "true unset", because POS was null
</code></pre>
<h2><a name="p-2483-why-did-i-make-position-the-primary-return-result-4" class="anchor" href="https://rebol.metaeducation.com#p-2483-why-did-i-make-position-the-primary-return-result-4"></a>Why Did I Make Position The Primary Return Result?</h2>
<ol>
<li>
<p><strong>It Makes It Easier to Loop Through an Evaluation</strong> - There are some situations where EVAL:STEP doesn't care about the value synthesized, but pretty much no cases where you don't care about the new position.  Being able to conditionally test if the returned position reached the end of a loop is super convenient.</p>
<pre><code>block: [1 + 2 10 + 20]

while [[block result]: eval:step block] [
    print ["Step result was:" mold result]
]
</code></pre>
</li>
<li>
<p><strong>Avoids Ambiguity When EVAL Result Is Itself A Multi-Return</strong> - Imagine the following kind of confusion if we made the evaluation product the first result instead of the second:</p>
<pre><code>&gt;&gt; block: [1 + 2 comment "I don't care about this"]

&gt;&gt; result: eval:step block  ; I just want the first thing!
== 3  ; great, I didn't want that position anyway

&gt;&gt; block: [pack [&lt;left&gt; &lt;right&gt;] comment "I don't care about this"]

&gt;&gt; [left right]: eval:step block  ; just want to unpack that first thing
== &lt;left&gt;  ; great, just what I expected

&gt;&gt; right
== [comment "I don't care about this"]  ; whaaa? I wanted &lt;right&gt;!
</code></pre>
<p>Encountering problems with this in the past has made me back off from using multi-returns in places they seemed like they would be perfect.  But what I now realize is you simply don't want your primary return result of a multi-return to be something that can itself be a multi-return... unless you <em>really</em> know what you are doing.</p>
<p>If you intend to do something with the evaluation product and want to be truly general, you of course have to be using ^META conventions:</p>
<pre><code>[pos ^result]: eval:step pos
</code></pre>
<p>Whether you need to do that or not depends on what you are doing.  Why are you stepping through arrays one step at a time, anyway?  Usually intermediate results are discarded.  What is it precisely you are looking for?  (Again on my point of why making the position the primary result makes sense... usually you aren't looking at the result at all, you're a dialect and looking at what you advance to at the next position.)</p>
</li>
</ol>
<h2><a name="p-2483-lgtm-1-5" class="anchor" href="https://rebol.metaeducation.com#p-2483-lgtm-1-5"></a>LGTM <img src="https://rebol.metaeducation.com/images/emoji/twitter/+1.png?v=14" title=":+1:" class="emoji" alt=":+1:" loading="lazy" width="20" height="20"></h2>
          <p><a href="https://rebol.metaeducation.com/t/re-imagining-do-next-as-eval-step/767/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/re-imagining-do-next-as-eval-step/767/1</link>
        <pubDate>Thu, 22 Aug 2024 04:00:00 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-767-1</guid>
        <source url="https://rebol.metaeducation.com/t/re-imagining-do-next-as-eval-step/767.rss">Re-imagining DO/NEXT as EVAL:STEP</source>
      </item>
  </channel>
</rss>

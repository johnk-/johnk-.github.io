<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Module Startup and Shutdown (Constructors, Destructors?)</title>
    <link>https://rebol.metaeducation.com/t/module-startup-and-shutdown-constructors-destructors/960</link>
    <description>I&#39;ve been trying to move toward a model extensions are just *&quot;modules that ship along with a DLL that have some native code, too&quot;*.  This helps avoid having parallel-and-variously-incompatible versions of the same features.

In trying to merge the functionalities, one thing that extensions could do was that when DLLs were loaded they could run an arbitrary Startup() hook.  Then when the DLL was unloaded, it could run a Shutdown() hook.  So if you used a native API that had a paired open/close you had a moment to do both.

However, since a module can ship with natives, this raises the question of why the startup code can&#39;t just be run as part of the normal course of the module:

     Rebol [
         Title: {ODBC Extension}
         Type: &#39;Module
     ]

     call-odbc-init-c-function
     odbc-settings: make object! [...]
     ...

Being able to call a native living in the extension like CALL-ODBC-INIT-C-FUNCTION is every bit as good as having a special esoteric C function exposed, that the DLL loader looks up with OS APIs and calls with a magic incantation.  All that magic is already done to provide new natives to call, why not use it?

Plus you have more options--you can break it into multiple functions, have it get parameters from the environment, etc.  Also very important: there doesn&#39;t have to be a distinct model for error handling if something happens--such things already had to have an answer for everything else you might be calling, why make it special for the init?

## ...but what about the shutdown?

It&#39;s not totally obvious that only a module which has some of its code written as user natives would need a shutdown.  What if you have a module that opens a persistent network connection--all in usermode--and wants to do some kind of graceful signoff if it can?  Why should &quot;extensions&quot; be special?

If that generic hook were available, then native code could be run by putting it in a native ACTION! and doing it that way--just like the init.

This could be a SHUTDOWN: field in the module header.  Or it could be an &quot;register-on-shutdown-callback&quot; method that modules offer to the code running in their body (kind of the way it would offer things like EXPORT).

But it seems like maybe it should be more general.  Rebol doesn&#39;t have constructors and destructors...but, maybe it should?  There is now an explicit FREE which can be used to kill off an object, and only HANDLE! does cleanup...but maybe objects should be able to do something about it too.

For now the easiest thing to do to keep extensions going is just to make some module-specific solution and move on.  But it&#39;s worth thinking about--are there other languages in Rebol&#39;s family which have interesting constructor/destructor behavior?  Or bad behavior that would be good to know about and avoid?  Just wanted to post a note on the topic...</description>
    
    <lastBuildDate>Tue, 13 May 2025 16:52:07 +0000</lastBuildDate>
    <category>Modules</category>
    <atom:link href="https://rebol.metaeducation.com/t/module-startup-and-shutdown-constructors-destructors/960.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Module Startup and Shutdown (Constructors, Destructors?)</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="960">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Rebol doesn't have constructors and destructors...but, maybe it should?</p>
</blockquote>
</aside>
<p>I love <a href="https://rebol.metaeducation.com/t/yielder-and-generator-and-thinking-about-coroutines/1311">GENERATORS and YIELDERS</a>, however they have a dark side...</p>
<p>If you are enumerating something with a generator or yielder, and you don't call it to exhaustion, it never cleans up... leaving latent locks  on series, and just clogging up memory.</p>
<p><strong>History and experience with serious languages like C++ and Rust have shown that we don't really have better a better answer for default lifetime control than scope.</strong></p>
<p><strong>So let's try a thought experiment.</strong></p>
<pre><code>&gt;&gt; foo: func [data [block!]] [
      let g: make-generator [
          for-each 'item data [print "Inside!" yield item + 1]
      ]
      return reduce [g g]
   ]

&gt;&gt; foo [10 20 30 40]
Inside!
Inside!
== [11 21]
</code></pre>
<p><strong>Imagine if at the moment of returning from FOO, the incomplete generator G should be destroyed, and its locks released.</strong></p>
<p>OTOH, if you have a module-level variable that's a generator, we can't automatically get rid of it.  And setting it to NULL wouldn't be enough to get it synchronously GC'd.  You would have to FREE it.</p>
<h2><a name="p-8256-so-many-questions-1" class="anchor" href="https://rebol.metaeducation.com#p-8256-so-many-questions-1"></a>So Many Questions...</h2>
<p>There's actually one important mechanism that the system has now, which is the ability to FREE basically anything and have stray references crash the GC.</p>
<p>So if LET wants to, it can FREE whatever it holds when the scope exits.</p>
<p>But now we enter a situation where not just exiting from scope, but a new assignment would have to free the generator too:</p>
<pre><code>foo: func [data [block!]] [
    let g: make-generator [
        for-each 'item data [print "Inside!" yield item + 1]
    ]
    let data: reduce [g g]
    g: 1020
    return data
]
</code></pre>
<p>Overwriting G with 1020 would <em>synchronously</em> FREE the previous contents of G.</p>
<p>Clearly not all variables being overwritten should free them.  If you passed G to another function, and that function made a couple of calls and then overwrote the argument... it shouldn't in the general case mean FOO lost G... unless it did a transfer of ownership.</p>
<p>So maybe this needs to be conveyed with a new concept, <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr">like C++'s <code>unique_ptr</code></a>.</p>
<p>Let's say the concept is UNIQUE:</p>
<pre><code>let g: unique make-generator [
     for-each 'item data [print "Inside!" yield item + 1]
]
</code></pre>
<p>When you say that something is unique, you're saying that if that variable slot gets overwritten for any reason... it should free the value.  This needs to include cases of exiting scope.</p>
<p><strong>This may have potential, and it may be able to be implemented <a href="https://rebol.metaeducation.com/t/a-dream-for-debugging-generalized-accessors/2259">using the same mechanics as accessor</a>.</strong>  In other words, it could be usermode... UNIQUE would be an infix function that specifically sets up the left hand side as a slot that runs code on overwrite of the variable.</p>
<h2><a name="p-8256-what-about-indefinite-word-lifetime-2" class="anchor" href="https://rebol.metaeducation.com#p-8256-what-about-indefinite-word-lifetime-2"></a>What About Indefinite Word Lifetime?</h2>
<p>This has always been a bit of a thorn:</p>
<p><a href="https://rebol.metaeducation.com/t/what-happens-to-function-arguments-and-locals-when-the-call-ends/234" class="inline-onebox">What happens to FUNCTION! arguments and locals when the call ends?</a></p>
<p>If LETs and function args are getting wiped clean on function exit... (sometimes clearing out UNIQUE or other accessors, other times having no effect)... then returning code bound to those LETs would not be usable.</p>
<p>There's never really been a satisfying answer to indefinite lifetime.  But it's almost like you want to do the opposite of UNIQUE, to tell a variable "hey, I need you to live".  Some kind of UNSCOPE operation, or SURVIVE or something.</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; f: func [x] [return [x]]

&gt;&gt; b: f 10
== [x]

&gt;&gt; reduce b
!! PANIC: X is trash  ; or whatever, wiped out by function exit
</code></pre>
<p>vs.</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; f: func [x] [survive $x, return [x]]

&gt;&gt; b: f 10
== [x]

&gt;&gt; reduce b
[10]
</code></pre>
<p>So what SURVIVE would do is stop the system from setting X to trash on exit of F.</p>
<p>This starts to put a lot of little invisible bits on things, which makes me a bit uneasy.  But there's no in-band way to do this.  The values themselves can't encode information about their lifetimes (e.g. some UNIQUE! antiform which is a box around a value... you'd have to unbox the value every time you used it).</p>
<p>Though... quick devil's advocacy detour <img src="https://rebol.metaeducation.com/images/emoji/twitter/ogre.png?v=14" title=":ogre:" class="emoji" alt=":ogre:" loading="lazy" width="20" height="20"> ...it is the case that quasiform actions can be accessed and run via <strong><code>/^g</code></strong>, and so you might say <em>"What if <em>meta</em> actions were immune to freeing, but normal ones were not."</em>  That's kind of dumb, but it does point to the idea that there might be some way of encoding the "don't free me automatically on exiting functions" state in a value itself, if you were willing to use a special decoration to refer to that value to undo whatever you did to make it denote indefinite lifetime.</p>
<p>Maybe this is "meta-fencing" values?</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; f: func [x] [x: generator [yield 10], return [x]]

&gt;&gt; b: f 10
== [x]

&gt;&gt; reduce b
!! PANIC: X is trash  ; or whatever, wiped out by function exit
</code></pre>
<p>vs.</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; f: func [x] [^{x}: generator [yield 10], return [^{x}]]

&gt;&gt; b: f 10
== [^{x}]

&gt;&gt; reduce b
[10]
</code></pre>
<p>The thought here would be something like:</p>
<pre><code>&gt;&gt; ^{x}: 10
== 10

&gt;&gt; x
== {'10}

&gt;&gt; ^{x}
== 10
</code></pre>
<p>Then say that these fences keepalive things that would otherwise be wiped out on function exit.  Notably you could put quasiforms of generators and such in these.</p>
<p><strong>Not a good idea, I was just playing devil's advocate when I said the only way to talk about modifying a variable's lifetime was with out of band bits...and needed to justify that statement.</strong></p>
<h2><a name="p-8256-could-unique-and-survive-cover-enough-common-cases-3" class="anchor" href="https://rebol.metaeducation.com#p-8256-could-unique-and-survive-cover-enough-common-cases-3"></a>Could UNIQUE And SURVIVE Cover Enough Common Cases?</h2>
<p>It's hard to say.</p>
<p>But GENERATOR and YIELDER definitely present a challenge, because cleaning them up requires running finalization code.  That finalization code might panic.  If that happens at an arbitrary moment in time, you'll just get a random error popping out of nowhere.</p>
<p>So in a sense, a running GENERATOR and YIELDER pretty much can't be GC'd--<em>in effect, they hold references to themselves while they're still running</em>.  That's among the many reasons why it's important to clean them up intentionally.</p>
<p>They're not the only such entities with this problem.  User objects that hold onto resources are in the same category, they need to be shut down.</p>
<p>It seems to me that something needs to be tried, I just wanted to look at the landscape a bit and see if there was anything new in the picture.</p>
          <p><a href="https://rebol.metaeducation.com/t/module-startup-and-shutdown-constructors-destructors/960/6">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/module-startup-and-shutdown-constructors-destructors/960/6</link>
        <pubDate>Sun, 11 May 2025 14:51:22 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-960-6</guid>
        <source url="https://rebol.metaeducation.com/t/module-startup-and-shutdown-constructors-destructors/960.rss">Module Startup and Shutdown (Constructors, Destructors?)</source>
      </item>
      <item>
        <title>Module Startup and Shutdown (Constructors, Destructors?)</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="960">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I noticed something in Go related to this, <a href="https://blog.golang.org/defer-panic-and-recover">which is their <code>defer</code> keyword</a>:</p>
</blockquote>
</aside>
<p>In <a href="https://rebol.metaeducation.com/t/rebol-1-0-retrospective/1788/5">Rebol 1.0</a>, there's something called SHIELD:</p>
<blockquote>
<p><strong><code>shield before-block main-block after-block</code></strong></p>
<p>Shield a block from catch and other types of exception handling, allowing it to take the necessary steps to initialize and finalize its state.</p>
<pre><code>print catch 'throw [
    shield [
        print "entering"
    ][
        repeat n 10 [if n &gt; 5 [throw "thrown out"]]
    ][
        print "exiting"
    ]
]
</code></pre>
<p>This will output:</p>
<pre><code>entering
exiting
thrown out
</code></pre>
</blockquote>
<p>It might seem unclear as to why you would need to have a "before-block" instead of just writing your code before the call to SHIELD.  But Rebol 1.0 is very function-driven.  So:</p>
<pre><code>(before-code shield main-block after-block)
</code></pre>
<p>...would be a GROUP! instead of a single function call, and I believe the thinking was more that if it was a function that it would "fit in more slots" where a GROUP! would complicate things.  (?)</p>
<p>Anyway...this category of things is still a functionality gap in Ren-C, because all you can do is trap and rescue and catch things...and you have to care about whether you're catching or trapping, and you have to rethrow or re-fail.  Things like SHIELD and DEFER are all trivial to implement, but it's just not certain what the right way to get constructor/destructor type behaviors is in this language.</p>
          <p><a href="https://rebol.metaeducation.com/t/module-startup-and-shutdown-constructors-destructors/960/5">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/module-startup-and-shutdown-constructors-destructors/960/5</link>
        <pubDate>Sun, 01 Dec 2024 15:38:03 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-960-5</guid>
        <source url="https://rebol.metaeducation.com/t/module-startup-and-shutdown-constructors-destructors/960.rss">Module Startup and Shutdown (Constructors, Destructors?)</source>
      </item>
      <item>
        <title>Module Startup and Shutdown (Constructors, Destructors?)</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>I noticed something in Go related to this, <a href="https://blog.golang.org/defer-panic-and-recover">which is their <code>defer</code> keyword</a>:</p>
<blockquote>
<p>"A  <strong>defer statement</strong>  pushes a function call onto a list. The list of saved calls is executed after the surrounding function returns. Defer is commonly used to simplify functions that perform various clean-up actions."</p>
</blockquote>
<p>This is quite similar to my suggestion.  Though we do not have the concept of a "currently running function", we do have a "currently running block", but that wouldn't be much use if you wrote something like:</p>
<pre><code> some-code
 if condition [
     defer [...cleanup...]
 ]
</code></pre>
<p>Running at the end of that block would be no different than just calling normally.  So that wouldn't work so well.</p>
<p>We might also be able to use things to identify frames; e.g. <strong>defer 'return [...whatever...]</strong> could get the binding out of the RETURN.  Another alternative might say that a construct that wishes to use DEFER might make a definitional defer which encodes the frame...the way that RETURN does.</p>
          <p><a href="https://rebol.metaeducation.com/t/module-startup-and-shutdown-constructors-destructors/960/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/module-startup-and-shutdown-constructors-destructors/960/4</link>
        <pubDate>Wed, 29 Jul 2020 09:27:32 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-960-4</guid>
        <source url="https://rebol.metaeducation.com/t/module-startup-and-shutdown-constructors-destructors/960.rss">Module Startup and Shutdown (Constructors, Destructors?)</source>
      </item>
      <item>
        <title>Module Startup and Shutdown (Constructors, Destructors?)</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="960">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But it seems like maybe it should be more general. Rebol doesn't have constructors and destructors...but, maybe it should?</p>
</blockquote>
</aside>
<p>So... constructors and destructors provide a commitment to what to do when you abruptly leave a "scope" where an object is declared...regardless of how you leave.</p>
<p>If you were cooking on the stove and turned on the oven, you can make a pretty good general rule that you don't want to leave the house with it on.  It doesn't matter if you get a phone call that causes you to go by way of the garage and out the garage door... or out the back door, or the front, or climb out a window.  Leaving the oven on is bad.  So if turning on the oven could instantiate a magical "turn the oven off if I forget and leave the house" gadget, such a gadget sounds good.</p>
<h2><a name="p-3791-historically-rebol-had-at-least-one-barrier-1" class="anchor" href="https://rebol.metaeducation.com#p-3791-historically-rebol-had-at-least-one-barrier-1"></a>Historically Rebol had at least one barrier...</h2>
<p>Instead of the house example...imagine we think of functions, BLOCK!s, or GROUP!s as being the kind of thing you might want to run some cleanup code for no-matter-how-you-leave-them.  There had been a particular "way of leaving" that was expensive to have every function catch.  That was exceptions--which Ren-C has called "failures".</p>
<p>Rebol (and Ren-C) use a style of coding in the C that allows it to react to things like memory allocation errors with an "exception".   This contrasts with needing to test every single series allocation (the way you would test a malloc for NULL).  These exceptions used the only method available to jump up the machine stack in C... <a href="https://en.wikipedia.org/wiki/Setjmp.h"><strong>setjmp</strong> and <strong>longjmp</strong></a></p>
<p>While the mechanism behind THROW was cheap, this mechanism was expensive.  And only TRAP-style (formerly named TRY-style) constructs would do it...because setting up a CPU state buffer at every stack frame boundary would be prohibitive.</p>
<h2><a name="p-3791-stackless-is-removing-this-particular-barrier-2" class="anchor" href="https://rebol.metaeducation.com#p-3791-stackless-is-removing-this-particular-barrier-2"></a>Stackless is removing this particular barrier</h2>
<p>By bouncing everything through <a href="https://en.wikipedia.org/wiki/Trampoline_(computing)#High-level_programming">a "Trampoline"</a>, an infinite number of stack levels can be navigated with only one setjmp/longjmp.  All an exception has to do is longjmp to that.  Then stack levels (Rebol levels, not C levels...since there's only one!) can be traversed just as easily as you might bubble THROWs up for processing.  They can be examined and do whatever handling they like.</p>
<p>Given that performance is no longer a barrier to reacting to arbitrary exceptions, what might such things look like?   I don't really know.  Might just mean people are more liberal with TRAPs, if they're cheaper.  :-/</p>
<p><strong>I'm not going to go research it right now.  But pointing it out in case there are some other languages out there, where they have been more technically free and not enslaved to setjmp/longjmp...that devised cool features despite being largely GC-based.</strong></p>
<p>So that's a question on the table.  Is there something in the exception-handling world to use this as an opportunity to introduce.  All I really know on the topic is C++, and nothing immediately comes to mind besides having a way to dash off code that will run when a block exits.</p>
<p>Gist of such an idea would be something like the LATER below:</p>
<pre><code>&gt;&gt; do [
    print "Entering block"
    later [print "First exit code"]
    (
        print "Entering group"
        later [print "Second exit code"]
        print "Doing more stuff"
        later [print "Third exit code"]
        if condition [
            fail "now we fail"
        ]
        print "This only happens if condition is false"
    )
    print "This only happens if no failure, as well"
 ]
</code></pre>
<p>With condition false, you'd get:</p>
<pre><code> Entering block
 Entering group
 Doing more stuff
 This only happens if condition is false
 Third exit code  ; running in reverse order...
 Second exit code
 This only happens if no failure as well"
 First exit code
</code></pre>
<p>But with condition true and the failure, you'd get:</p>
<pre><code> Entering block
 Entering group
 Doing more stuff
 Third exit code
 Second exit code
 First exit code
 ** Error: now we fail
</code></pre>
<p>We'd imagine it not being just failures, but RETURNs and THROWs as well.  But that was possible before.  The new novelty is when it comes to "exceptions" that originate internally (vs. provoked by the FAIL native, which didn't <em>have</em> to leverage that same mechanism...but did).  These features no longer need any kind of advance payment to plan for, the way declaring a TRAP would be.  It costs no more for a block to be ready to accept an arbitrary failure (even a rug-pulled-out-from-under-a-native problem like out-of-memory that it didn't gracefully check for).</p>
<p>So a family of possibilities opens up.</p>
          <p><a href="https://rebol.metaeducation.com/t/module-startup-and-shutdown-constructors-destructors/960/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/module-startup-and-shutdown-constructors-destructors/960/3</link>
        <pubDate>Sat, 23 May 2020 19:11:36 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-960-3</guid>
        <source url="https://rebol.metaeducation.com/t/module-startup-and-shutdown-constructors-destructors/960.rss">Module Startup and Shutdown (Constructors, Destructors?)</source>
      </item>
      <item>
        <title>Module Startup and Shutdown (Constructors, Destructors?)</title>
        <dc:creator><![CDATA[Brett]]></dc:creator>
        <description><![CDATA[
            <p>IIRC the only place in Rebol 2 that one can attach automatic cleanup code is in a port scheme, handling a port close event.   Which is not exactly a generally useful solution.</p>
          <p><a href="https://rebol.metaeducation.com/t/module-startup-and-shutdown-constructors-destructors/960/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/module-startup-and-shutdown-constructors-destructors/960/2</link>
        <pubDate>Fri, 14 Dec 2018 23:59:28 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-960-2</guid>
        <source url="https://rebol.metaeducation.com/t/module-startup-and-shutdown-constructors-destructors/960.rss">Module Startup and Shutdown (Constructors, Destructors?)</source>
      </item>
      <item>
        <title>Module Startup and Shutdown (Constructors, Destructors?)</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>I've been trying to move toward a model extensions are just <em>"modules that ship along with a DLL that have some native code, too"</em>.  This helps avoid having parallel-and-variously-incompatible versions of the same features.</p>
<p>In trying to merge the functionalities, one thing that extensions could do was that when DLLs were loaded they could run an arbitrary Startup() hook.  Then when the DLL was unloaded, it could run a Shutdown() hook.  So if you used a native API that had a paired open/close you had a moment to do both.</p>
<p>However, since a module can ship with natives, this raises the question of why the startup code can't just be run as part of the normal course of the module:</p>
<pre><code> Rebol [
     Title: {ODBC Extension}
     Type: 'Module
 ]

 call-odbc-init-c-function
 odbc-settings: make object! [...]
 ...
</code></pre>
<p>Being able to call a native living in the extension like CALL-ODBC-INIT-C-FUNCTION is every bit as good as having a special esoteric C function exposed, that the DLL loader looks up with OS APIs and calls with a magic incantation.  All that magic is already done to provide new natives to call, why not use it?</p>
<p>Plus you have more options--you can break it into multiple functions, have it get parameters from the environment, etc.  Also very important: there doesn't have to be a distinct model for error handling if something happens--such things already had to have an answer for everything else you might be calling, why make it special for the init?</p>
<h2><a name="p-2815-but-what-about-the-shutdown-1" class="anchor" href="https://rebol.metaeducation.com#p-2815-but-what-about-the-shutdown-1"></a>...but what about the shutdown?</h2>
<p>It's not totally obvious that only a module which has some of its code written as user natives would need a shutdown.  What if you have a module that opens a persistent network connection--all in usermode--and wants to do some kind of graceful signoff if it can?  Why should "extensions" be special?</p>
<p>If that generic hook were available, then native code could be run by putting it in a native ACTION! and doing it that way--just like the init.</p>
<p>This could be a SHUTDOWN: field in the module header.  Or it could be an "register-on-shutdown-callback" method that modules offer to the code running in their body (kind of the way it would offer things like EXPORT).</p>
<p>But it seems like maybe it should be more general.  Rebol doesn't have constructors and destructors...but, maybe it should?  There is now an explicit FREE which can be used to kill off an object, and only HANDLE! does cleanup...but maybe objects should be able to do something about it too.</p>
<p>For now the easiest thing to do to keep extensions going is just to make some module-specific solution and move on.  But it's worth thinking about--are there other languages in Rebol's family which have interesting constructor/destructor behavior?  Or bad behavior that would be good to know about and avoid?  Just wanted to post a note on the topic...</p>
          <p><a href="https://rebol.metaeducation.com/t/module-startup-and-shutdown-constructors-destructors/960/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/module-startup-and-shutdown-constructors-destructors/960/1</link>
        <pubDate>Fri, 14 Dec 2018 00:37:40 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-960-1</guid>
        <source url="https://rebol.metaeducation.com/t/module-startup-and-shutdown-constructors-destructors/960.rss">Module Startup and Shutdown (Constructors, Destructors?)</source>
      </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Naming function args: VALUE, ELEMENT, ATOM, SERIES</title>
    <link>https://rebol.metaeducation.com/t/naming-function-args-value-element-atom-series/2387</link>
    <description>## The Historical Situation :hourglass_done: 

Historical Rebol had only one superclass for Cell, which was generally called **`value`** when it was used as a parameter.

Curiously, the typeset for checking if something was in the value superclass of all possible things was **ANY-TYPE!**.  I thought this was bad, because that typeset sounds like it would contain INTEGER!, BLOCK!, PAIR!, etc... e.g. &quot;any datatype&quot;.

*(So early on, Ren-C called that **ANY-VALUE!**, and that was better.)*

Natives would often call their argument &quot;value&quot; if they could take on a bunch of types that didn&#39;t fit into any particular category:

    USAGE:
        ADD value1 value2

    ARGUMENTS:
        value1 -- (Type: number pair char money date time tuple)
        value2 -- (Type: number pair char money date time tuple)

But there were exceptions to the rule:

    USAGE:
        NEGATE number

    ARGUMENTS:
        number -- (Type: number pair money time bitset)

There&#39;s also a lot of overloading of the word SERIES that doesn&#39;t make much sense.  e.g. in R3-Alpha, APPEND&#39;s SERIES can take a total hodgepodge:

    USAGE:
        APPEND series value /part length /only /dup count

    ARGUMENTS:
        series -- Any position (modified) (series! port! map! gob! object! bitset!)
        value -- The value to insert (any-type!)

## Modern Ren-C Has More Superclasses

In Ren-C, we have the situation of:

  * **ELEMENT?** - Anything you can put in an array (quoted, quasiform, and any other non-antiforms)

  * **VALUE?** - Anything you can store in a variable (elements and stable antiforms)

  * **ATOM?** - Anything at all, stable or unstable.

It has been tempting for me to use the class name as the argument name when the argument is narrowed.  For instance, QUOTE only allows you to take ELEMENT? (you have to META an antiform):

    USAGE:
        QUOTE element :depth

    RETURNS: [element?]
        Quoted value (if depth = 0, may not be quoted)

    ARGUMENTS:
        element [element?]

But now we have to worry about the argument being named ELEMENT as opposed to just VALUE.

I&#39;m on the fence about how useful this particular variance in naming is.

## Are Varying Names to Arity-1 Functions Too Annoying?

You do get *some* extra information out of the change in names. 

But if arity-1 functions just called their argument &quot;value&quot; you wouldn&#39;t have to stress over it as much.

Also, a lot of arity-1 functions that &quot;only take ELEMENT?&quot; actually take voids as well, which aren&#39;t elements, because they obey the &quot;void-in-null-out&quot; convention.  So pedantically speaking the argument is a value.

I do think that when an argument genuinely takes an ANY-ATOM? it&#39;s probably worth it to name that argument differently... because you as a client of that routine need to know it&#39;s a parameter taken by ^META convention.  The name can hint you to that when building frames.

## What About Those non-ANY-SERIES? Args Named SERIES?

Here I don&#39;t know what to do.  APPEND has two arguments, today called **series** and **value**.

I&#39;m leaning toward &quot;target&quot; and &quot;value&quot;?</description>
    
    <lastBuildDate>Sat, 12 Jul 2025 05:13:50 +0000</lastBuildDate>
    <category>Naming</category>
    <atom:link href="https://rebol.metaeducation.com/t/naming-function-args-value-element-atom-series/2387.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Naming function args: VALUE, ELEMENT, ATOM, SERIES</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2387">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Are Varying Names to Arity-1 Functions Too Annoying?</p>
</blockquote>
</aside>
<p>Today I gave an example of this with specializing RETURN:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2479">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479/3">Virtual Binding + Macros =&gt; BREAK, CONTINUE, AGAIN</a></div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext"> foo: func [] [
     return: adapt return/ [atom: atom + 20]
     return 1000  ; acts as if you hadn't adapted, and returned 1020
 ]
</code></pre>
</blockquote>
</aside>
<p>That "atom" is definitely annoying to remember.  And it's just annoying to read.  I think people's (valid) natural reaction would be: <em>"why is the word 'atom' there?"</em></p>
<p>It used to make sense, because you had to know it spoke in "lifted protocol", and had to do extra laborious work:</p>
<pre><code>foo: func [] [
    return: adapt return/ [atom: lift (unlift atom + 20)]
    return 1000  ; acts as if you hadn't adapted, and returned 1020
]
</code></pre>
<p>But you don't need to do that anymore!</p>
<p><strong>The advantage to the weird name has dropped significantly, because of <a href="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477">"Lift the Universe"</a>.</strong>  You don't have to be as aware of their special status to work with them--which is a <em>major</em> advancement.  Instead of lifting and unlifting, you can just be oblivious, unless you specifically want to work in the unstable antiform realm.</p>
<p>e.g. let's say we just called it <code>value</code>.  If you were going to make the return value a PACK!, now this would look like:</p>
<pre><code>foo: func [] [
    return: adapt return/ [^value: pack [value 304]]
    return 1000  ; acts as if you hadn't adapted, and returned pack [1000 304]
]
</code></pre>
<p><strong>"Lift the Universe" has truly saved the system from a lot of unpleasantness, and fixing this name is one more place it fixes.</strong></p>
<p>It's <em>way</em> better.</p>
<h2><a name="p-8508-so-what-does-the-term-value-mean-now-1" class="anchor" href="https://rebol.metaeducation.com#p-8508-so-what-does-the-term-value-mean-now-1"></a>So What Does The Term "Value" Mean Now?</h2>
<p>The <a href="https://rebol.metaeducation.com/t/should-any-value-include-stable-antiforms/2026/4">internal naming convention</a> has been:</p>
<ul>
<li>
<p><strong>Element</strong> - Anything You Can Put in a List (no antiforms)</p>
</li>
<li>
<p><strong>Value</strong> - Anything You Can Put In a Variable (no <em>unstable</em> antiforms)</p>
</li>
<li>
<p><strong>Atom</strong> - Any State an Evaluation Can Produce (unstable antiforms included)</p>
</li>
</ul>
<p>This got leaked to user awareness pretty much verbatim, with functions like ANY-ATOM?, ANY-VALUE?, and ANY-ELEMENT?</p>
<p><strong>It's no longer the case that variables are limited to stable antiforms, if you use ^META assignments or ^META fetches.</strong>  It's made some things trickier, but overall the ergonmics and invariants took a big step up.</p>
<h2><a name="p-8508-value-seems-like-the-superclass-now-2" class="anchor" href="https://rebol.metaeducation.com#p-8508-value-seems-like-the-superclass-now-2"></a>Value Seems Like The Superclass Now</h2>
<p>It would be tempting to say that Atom is just distinguished as <strong><code>MetaValue</code></strong></p>
<p>Unfortunately this collides with <strong><code>^value</code></strong> being a "METAFORM" (as opposed to <strong><code>$value</code></strong> being "TIED" and <strong><code>@value</code></strong> being "PINNED").  So MetaValue risks confusion with that.</p>
<p>Perhaps the classes should be:</p>
<ul>
<li>Element</li>
<li>"old Value" =&gt; "Stable"</li>
<li>"old Atom" =&gt; "Value"</li>
</ul>
<p>That would swap out one weirdness (calling a subclass of Cell "Atom") with another weirdness (calling a subclass "Stable").  But one does adjust to things.  I thought Element* was pretty weird at first for subclassing things that could be put in List, but it has come to feel very familiar.</p>
<p>However: one place this doesn't work very well is the API, which by design doesn't expose unstable states... so it calls everything "Value*".   Hence the API would be exposing Stable* as Value*.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20">  Code mixes internal and API code together, and calling Atom "Value" would be out.</p>
<p>Maybe:</p>
<ul>
<li>Element</li>
<li>"old Value" =&gt; "Stable"</li>
<li>"old Atom" =&gt; "Unstable"</li>
</ul>
<p>However, the reason I originally called it "Atom" instead of "Unstable" is that the constraint for the type doesn't mean it <em>is</em> unstable, only that it's <code>PotentiallyUnstable</code>.</p>
<p>To not rock the boat too much, one might just say:</p>
<ul>
<li>Element</li>
<li>"old Value" =&gt; "Stable"</li>
<li>Atom</li>
</ul>
<p>Then "Value" could be a more nebulous term.  In the API it necessarily implies a stable value, because no other kind is exposed.</p>
<p>But since API Values are all over the place internally, I think the "Stable" name would just make things uglier and create a disconnect.</p>
<h2><a name="p-8508-usermode-atom-as-any-value-value-as-any-stable-3" class="anchor" href="https://rebol.metaeducation.com#p-8508-usermode-atom-as-any-value-value-as-any-stable-3"></a>Usermode Atom* as ANY-VALUE?, Value* as ANY-STABLE?</h2>
<p>I suspect the thing is just in usermode, to drop the exposure of Atom, instead having that be ANY-VALUE?... with what's tested for as any-value? today becoming ANY-STABLE?</p>
<p>If one really had it out for the Atom term internal to the source, you could say:</p>
<ul>
<li>Element</li>
<li>Value</li>
<li>"old Atom" =&gt; AnyValue</li>
</ul>
<p>But meh.  It's probably fine how it is.</p>
<p>So back to the original point of the discussion:</p>
<p><strong>I don't think calling these arguments anything besides <code>value</code> helps in proportion to the hurt it does by making them variant.</strong>  It also means having to potentially synchronize the name of your arguments the one day that you decide you can do some interesting processing of an unstable (or stable) antiform.</p>
<p>Hence, I've moved arguments back from names like <code>atom</code> and <code>element</code> to just plain <code>value</code>.</p>
          <p><a href="https://rebol.metaeducation.com/t/naming-function-args-value-element-atom-series/2387/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/naming-function-args-value-element-atom-series/2387/2</link>
        <pubDate>Sat, 12 Jul 2025 03:52:28 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2387-2</guid>
        <source url="https://rebol.metaeducation.com/t/naming-function-args-value-element-atom-series/2387.rss">Naming function args: VALUE, ELEMENT, ATOM, SERIES</source>
      </item>
      <item>
        <title>Naming function args: VALUE, ELEMENT, ATOM, SERIES</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <h2><a name="p-8090-the-historical-situation-hourglass_done-1" class="anchor" href="https://rebol.metaeducation.com#p-8090-the-historical-situation-hourglass_done-1"></a>The Historical Situation <img src="https://rebol.metaeducation.com/images/emoji/twitter/hourglass_done.png?v=14" title=":hourglass_done:" class="emoji" alt=":hourglass_done:" loading="lazy" width="20" height="20"></h2>
<p>Historical Rebol had only one superclass for Cell, which was generally called <strong><code>value</code></strong> when it was used as a parameter.</p>
<p>Curiously, the typeset for checking if something was in the value superclass of all possible things was <strong>ANY-TYPE!</strong>.  I thought this was bad, because that typeset sounds like it would contain INTEGER!, BLOCK!, PAIR!, etc... e.g. "any datatype".</p>
<p><em>(So early on, Ren-C called that <strong>ANY-VALUE!</strong>, and that was better.)</em></p>
<p>Natives would often call their argument "value" if they could take on a bunch of types that didn't fit into any particular category:</p>
<pre><code>USAGE:
    ADD value1 value2

ARGUMENTS:
    value1 -- (Type: number pair char money date time tuple)
    value2 -- (Type: number pair char money date time tuple)
</code></pre>
<p>But there were exceptions to the rule:</p>
<pre><code>USAGE:
    NEGATE number

ARGUMENTS:
    number -- (Type: number pair money time bitset)
</code></pre>
<p>There's also a lot of overloading of the word SERIES that doesn't make much sense.  e.g. in R3-Alpha, APPEND's SERIES can take a total hodgepodge:</p>
<pre><code>USAGE:
    APPEND series value /part length /only /dup count

ARGUMENTS:
    series -- Any position (modified) (series! port! map! gob! object! bitset!)
    value -- The value to insert (any-type!)
</code></pre>
<h2><a name="p-8090-modern-ren-c-has-more-superclasses-2" class="anchor" href="https://rebol.metaeducation.com#p-8090-modern-ren-c-has-more-superclasses-2"></a>Modern Ren-C Has More Superclasses</h2>
<p>In Ren-C, we have the situation of:</p>
<ul>
<li>
<p><strong>ELEMENT?</strong> - Anything you can put in an array (quoted, quasiform, and any other non-antiforms)</p>
</li>
<li>
<p><strong>VALUE?</strong> - Anything you can store in a variable (elements and stable antiforms)</p>
</li>
<li>
<p><strong>ATOM?</strong> - Anything at all, stable or unstable.</p>
</li>
</ul>
<p>It has been tempting for me to use the class name as the argument name when the argument is narrowed.  For instance, QUOTE only allows you to take ELEMENT? (you have to META an antiform):</p>
<pre><code>USAGE:
    QUOTE element :depth

RETURNS: [element?]
    Quoted value (if depth = 0, may not be quoted)

ARGUMENTS:
    element [element?]
</code></pre>
<p>But now we have to worry about the argument being named ELEMENT as opposed to just VALUE.</p>
<p>I'm on the fence about how useful this particular variance in naming is.</p>
<h2><a name="p-8090-are-varying-names-to-arity-1-functions-too-annoying-3" class="anchor" href="https://rebol.metaeducation.com#p-8090-are-varying-names-to-arity-1-functions-too-annoying-3"></a>Are Varying Names to Arity-1 Functions Too Annoying?</h2>
<p>You do get <em>some</em> extra information out of the change in names.</p>
<p>But if arity-1 functions just called their argument "value" you wouldn't have to stress over it as much.</p>
<p>Also, a lot of arity-1 functions that "only take ELEMENT?" actually take voids as well, which aren't elements, because they obey the "void-in-null-out" convention.  So pedantically speaking the argument is a value.</p>
<p>I do think that when an argument genuinely takes an ANY-ATOM? it's probably worth it to name that argument differently... because you as a client of that routine need to know it's a parameter taken by ^META convention.  The name can hint you to that when building frames.</p>
<h2><a name="p-8090-what-about-those-non-any-series-args-named-series-4" class="anchor" href="https://rebol.metaeducation.com#p-8090-what-about-those-non-any-series-args-named-series-4"></a>What About Those non-ANY-SERIES? Args Named SERIES?</h2>
<p>Here I don't know what to do.  APPEND has two arguments, today called <strong>series</strong> and <strong>value</strong>.</p>
<p>I'm leaning toward "target" and "value"?</p>
          <p><a href="https://rebol.metaeducation.com/t/naming-function-args-value-element-atom-series/2387/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/naming-function-args-value-element-atom-series/2387/1</link>
        <pubDate>Fri, 28 Mar 2025 13:55:28 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2387-1</guid>
        <source url="https://rebol.metaeducation.com/t/naming-function-args-value-element-atom-series/2387.rss">Naming function args: VALUE, ELEMENT, ATOM, SERIES</source>
      </item>
  </channel>
</rss>

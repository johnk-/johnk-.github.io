<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Making position argument explicit in COMBINATOR</title>
    <link>https://rebol.metaeducation.com/t/making-position-argument-explicit-in-combinator/2445</link>
    <description>Today&#39;s COMBINATOR implicitly gives you an argument called INPUT:

    tally: combinator [
        &quot;Iterate a rule and count the number of times it matches&quot;
        return: &quot;Number of matches (can be 0)&quot;
            [integer!]
        parser [action!]
    ][
        let count: 0
        cycle [
            [^ input]: parser input except [  ; INPUT not mentioned on interface
                remainder: input
                return count
            ]
            count: count + 1
        ]
    ]

You only have to specify the number of parsers (or non-combinated literal arguments) you take.

I observed an inconsistency, that the **`&lt;input&gt;`** combinator returns the input to the overall parse operation at its original position... not the current position.

Then I thought &quot;hm, I don&#39;t know whether to change the argument to be called POSITION or POS.

## But Why Was The Argument Implicit To Begin With?

Making it explicit is clearer, and lets you pick your own name for it:

    tally: combinator [
        &quot;Iterate a rule and count the number of times it matches&quot;
        return: &quot;Number of matches (can be 0)&quot;
            [integer!]
        pos [any-series?]  ; Maybe I like POS better than POSITION for arg 1
        parser [action!]
    ][
        let count: 0
        cycle [
            [^ pos]: parser pos except [
                remainder: pos
                return count
            ]
            count: count + 1
        ]
    ]

This also means that if your combinator is only applicable to specific series types (e.g. just lists, or just strings) then you can say that, and have type checking take care of it vs. having to put the check in the body of your combinator.

## Should REMAINDER Be Explicit Too?

REMAINDER is an implicitly declared return value, that the combinator wrapping code will package up in a PACK! with whatever you RETURN as the main synthesized value.  **[I&#39;ve defended the choice to do it this way](https://rebol.metaeducation.com/t/uparse-combinator-return-conventions-reviewed/2337).**

But for clarity, should combinators have some mention of REMAINDER in the interface?  Even something like an `&lt;assigns&gt;` TAG! in the spec?

    tally: combinator [
        &quot;Iterate a rule and count the number of times it matches&quot;
        return: &quot;Number of matches (can be 0)&quot;
            [integer!]
        pos [any-series?]
        parser [action!]
        &lt;assigns&gt; remainder
    ] ...

That could actually have some value, in that if you don&#39;t say it then you&#39;re implicitly saying your parser doesn&#39;t move the parse position... *and it could automatically assume the remainder is the input position for you.*  :smiley:  Then there could be no binding for remander, so you&#39;d get an error if you did try to assign it.

Good mojo.  I like it.

I don&#39;t think being able to rename remainder is that important, but it could be **`&lt;remainder&gt; rem`** or something like that, where you could.

But I think **`&lt;assigns&gt; remainder`** has more information in it.</description>
    
    <lastBuildDate>Sun, 13 Jul 2025 02:47:19 +0000</lastBuildDate>
    <category>Parsing</category>
    <atom:link href="https://rebol.metaeducation.com/t/making-position-argument-explicit-in-combinator/2445.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Making position argument explicit in COMBINATOR</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2445">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But for clarity, should combinators have some mention of REMAINDER in the interface? Even something like an <code>&lt;assigns&gt;</code> TAG! in the spec?</p>
</blockquote>
</aside>
<p>In actuality... given the way COMBINATOR is designed, it could just package up whatever you named as your input parameter as part of the multi-return output.  Thus, whatever it was set to at the end of the operation would be the remainder!</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">tally: combinator [
    "Iterate a rule and count the number of times it matches"
    return: "Number of matches (can be 0)"
        [integer!]
    pos [any-series?]
    parser [action!]
][
    let count: 0
    cycle [
        [^ pos]: parser pos except [
            ; remainder: pos  ; &lt;-- instead, presume updated POS is remainder
            return count  ; return is hooked, acts like `pack [count pos ...]`
        ]
        count: count + 1
    ]
]
</code></pre>
<p><strong>I like it!</strong>  Auto-proxying an input into an expanded multi-return of the output is a bizarre mechanic for accomplishing something like pass-by-reference.  But looks like a good fit...</p>
<p>COMBINATOR continues to zero in on essential complexity of what it does!</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2445">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>That could actually have some value, in that if you don't say it then you're implicitly saying your parser doesn't move the parse position... <em>and it could automatically assume the remainder is the input position for you.</em></p>
</blockquote>
</aside>
<p>In the alternative conception, if you just don't change the input, then it would assume the position stayed the same.  Clean and simple.</p>
          <p><a href="https://rebol.metaeducation.com/t/making-position-argument-explicit-in-combinator/2445/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/making-position-argument-explicit-in-combinator/2445/2</link>
        <pubDate>Sun, 13 Jul 2025 00:01:54 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2445-2</guid>
        <source url="https://rebol.metaeducation.com/t/making-position-argument-explicit-in-combinator/2445.rss">Making position argument explicit in COMBINATOR</source>
      </item>
      <item>
        <title>Making position argument explicit in COMBINATOR</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Today's COMBINATOR implicitly gives you an argument called INPUT:</p>
<pre><code>tally: combinator [
    "Iterate a rule and count the number of times it matches"
    return: "Number of matches (can be 0)"
        [integer!]
    parser [action!]
][
    let count: 0
    cycle [
        [^ input]: parser input except [  ; INPUT not mentioned on interface
            remainder: input
            return count
        ]
        count: count + 1
    ]
]
</code></pre>
<p>You only have to specify the number of parsers (or non-combinated literal arguments) you take.</p>
<p>I observed an inconsistency, that the <strong><code>&lt;input&gt;</code></strong> combinator returns the input to the overall parse operation at its original position... not the current position.</p>
<p>Then I thought "hm, I don't know whether to change the argument to be called POSITION or POS.</p>
<h2><a name="p-8258-but-why-was-the-argument-implicit-to-begin-with-1" class="anchor" href="https://rebol.metaeducation.com#p-8258-but-why-was-the-argument-implicit-to-begin-with-1"></a>But Why Was The Argument Implicit To Begin With?</h2>
<p>Making it explicit is clearer, and lets you pick your own name for it:</p>
<pre><code>tally: combinator [
    "Iterate a rule and count the number of times it matches"
    return: "Number of matches (can be 0)"
        [integer!]
    pos [any-series?]  ; Maybe I like POS better than POSITION for arg 1
    parser [action!]
][
    let count: 0
    cycle [
        [^ pos]: parser pos except [
            remainder: pos
            return count
        ]
        count: count + 1
    ]
]
</code></pre>
<p>This also means that if your combinator is only applicable to specific series types (e.g. just lists, or just strings) then you can say that, and have type checking take care of it vs. having to put the check in the body of your combinator.</p>
<h2><a name="p-8258-should-remainder-be-explicit-too-2" class="anchor" href="https://rebol.metaeducation.com#p-8258-should-remainder-be-explicit-too-2"></a>Should REMAINDER Be Explicit Too?</h2>
<p>REMAINDER is an implicitly declared return value, that the combinator wrapping code will package up in a PACK! with whatever you RETURN as the main synthesized value.  <strong><a href="https://rebol.metaeducation.com/t/uparse-combinator-return-conventions-reviewed/2337">I've defended the choice to do it this way</a>.</strong></p>
<p>But for clarity, should combinators have some mention of REMAINDER in the interface?  Even something like an <code>&lt;assigns&gt;</code> TAG! in the spec?</p>
<pre><code>tally: combinator [
    "Iterate a rule and count the number of times it matches"
    return: "Number of matches (can be 0)"
        [integer!]
    pos [any-series?]
    parser [action!]
    &lt;assigns&gt; remainder
] ...
</code></pre>
<p>That could actually have some value, in that if you don't say it then you're implicitly saying your parser doesn't move the parse position... <em>and it could automatically assume the remainder is the input position for you.</em>  <img src="https://rebol.metaeducation.com/images/emoji/twitter/smiley.png?v=14" title=":smiley:" class="emoji" alt=":smiley:" loading="lazy" width="20" height="20">  Then there could be no binding for remander, so you'd get an error if you did try to assign it.</p>
<p>Good mojo.  I like it.</p>
<p>I don't think being able to rename remainder is that important, but it could be <strong><code>&lt;remainder&gt; rem</code></strong> or something like that, where you could.</p>
<p>But I think <strong><code>&lt;assigns&gt; remainder</code></strong> has more information in it.</p>
          <p><a href="https://rebol.metaeducation.com/t/making-position-argument-explicit-in-combinator/2445/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/making-position-argument-explicit-in-combinator/2445/1</link>
        <pubDate>Sun, 11 May 2025 16:01:18 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2445-1</guid>
        <source url="https://rebol.metaeducation.com/t/making-position-argument-explicit-in-combinator/2445.rss">Making position argument explicit in COMBINATOR</source>
      </item>
  </channel>
</rss>

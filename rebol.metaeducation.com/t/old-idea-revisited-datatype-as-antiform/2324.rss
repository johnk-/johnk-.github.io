<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Old Idea Revisited: DATATYPE as... Antiform?</title>
    <link>https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324</link>
    <description>I&#39;ve been suffering through an attempt to bring sanity to bear upon the MAKE and TO matrix.

While doing so, I noticed that there are a lot of MAKE instructions that do &quot;joining&quot;.

In R3-Alpha and Red:

    &gt;&gt; make binary! [1 2 #{DECAFBAD} 3 4]   
    == #{0102DECAFBAD0304}

Historical MAKE is so arbitrary in how it interprets its arguments that it made me feel that it would be better if JOIN allowed a datatype as its first argument...

JOIN typically makes a new series out of what you give it:

    &gt;&gt; bin: #{AABB}

    &gt;&gt; join bin #{CCDD}
    == #{AABBCCDD}  ; made new series, didn&#39;t impact BIN

    &gt;&gt; bin
    == #{AABB}

But if you could pass a datatype as the first argument, you could relieve MAKE of the behavior...and make it clearer in the source what&#39;s actually happening:

    &gt;&gt; join binary! [1 2 #{DECAFBAD} 3 4]
    == #{0102DECAFBAD0304}

Since that seemed nice, I started to map it out, and ran into a bit of a problem:

**If &quot;datatypes&quot; are an ANY-WORD! or ANY-LIST! or anything like that, how do you know you&#39;re not trying to JOIN with it?**

A WORD! should be able to join:

    &gt;&gt; join &#39;var 10
    == var10

A BLOCK! should be able to join... though possibly only with blocks that it reduces *(devil&#39;s in the details as to why, beyond the scope of what I&#39;m talking about right now)*...

    &gt;&gt; join [a b] [1000 + 20]
    == [a b 1020]

Okay, but when you say **join binary!** what is BINARY!?  Well right now, it&#39;s:

    &gt;&gt; binary!
    == &amp;[binary]

Well that looks like it&#39;s in-band for the kinds of things JOIN operates on:

    &gt;&gt; join &amp;[binary] [1000 + 20]
    == &amp;[binary 1020]

## An Antiform Would Push DATATYPE? Out-Of-Band...

It&#39;s possible that we could come up with a new non-antiform for types.  But the lexical space is extremely saturated.

If we were just reaching for something on the basis of looks, antiform FENCE! is nice:

    &gt;&gt; binary!
    == ~{binary!}~  ; anti

---
**UPDATE:** @BlackATTR and I believe the exclamation point is probably best as part of the contents.  If you&#39;re turning a datatype into a word, the only reason you&#39;re doing it is to present to a programmer.  This lines up with history:

    red&gt;&gt; to word! integer!
    == integer!

    rebol2&gt;&gt; to word! integer!
    == integer!
---

## [This Has Come Up Before... (in 2022)](https://rebol.metaeducation.com/t/what-if-datatype-was-isotopic/1982)

Historical Rebol let you use datatypes in FIND:

    rebol2&gt;&gt; find [a b c 10 20] integer! 
    == [10 20]

But then this conflates with when you actually literally have the INTEGER! datatype in the block.

    &gt;&gt; find compose [a (integer!) b c 10 20] integer!
    == [integer! b c 10 20]

So in the early days of antiforms, I proposed antiform datatypes as a solution... but at that time I was thinking that there&#39;d be non-antiform DATATYPE!, and it&#39;s just that when it was an antiform it would be a &quot;MATCHER&quot;.

**The proposal I&#39;m thinking of now is different, in saying that DATATYPE? only exists as a (stable) antiform state.**

There are tradeoffs, in that datatypes can&#39;t be put in blocks directly.  But the mechanics of working with quasiforms and antiforms via things like REIFY and DEGRADE are much smoother now.  And really, putting datatypes in blocks doesn&#39;t happen that often (I&#39;ve had to put splices in blocks...and they&#39;re antiforms... but really never datatypes).

**Being completely out of band with things you can find in a block has advantages.**  JOIN isn&#39;t unique in reaping benefits from being able to say that datatypes aren&#39;t &quot;things&quot;. 

And it unifies datatypes with typecheckers being antiforms, because typecheckers are frame antiforms, e.g. actions:

    &gt;&gt; find [1 3 5 8 10] even?/
    ; first in pack of length 2
    == [8 10]

So I don&#39;t think it&#39;s a crazy idea.

I&#39;m hesitant to surrender FENCE! antiforms to the purpose so soon after their invention.  But there isn&#39;t anything undecorated left.

Not that &quot;no decorated antiforms&quot; is some unbreakable rule, it was a guideline.

Using &amp; would put it in the family of TYPE-XXX! and be cheaper than FENCE! if you made new instances:

    &gt;&gt; binary!
    == ~&amp;binary!~  ; anti

A random bad idea would be to make them keywords, and just have DATATYPE? be smart enough to filter out ~null~ or ~void~ or ~okay~ or whatever else (the symbol could carry a flag)

    &gt;&gt; binary!
    == ~binary!~  ; anti

    &gt;&gt; null
    == ~null~  ; anti

    &gt;&gt; datatype? binary!
    == ~okay~  ; anti

    &gt;&gt; datatype? null
    == ~null~  ; anti

I can pretty clearly say that&#39;s bad.

## Or, Pick Some Non-Antiform Notation

Status quo might look like:

    &gt;&gt; binary!
    == #[binary!]

Despite it looking sort of like a block, it wouldn&#39;t be.  But we&#39;re squandering some of our notational space no matter what.  The **`~&amp;type!~`** is the discount route.

## Either Way, DATATYPE? Can&#39;t be ANY-WORD! or ANY-LIST!

It needs to be out of band one way or another.  I&#39;ll have to think about it.</description>
    
    <lastBuildDate>Sat, 19 Apr 2025 23:29:30 +0000</lastBuildDate>
    <category>Datatypes</category>
    <atom:link href="https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Old Idea Revisited: DATATYPE as... Antiform?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2324">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>making them antiforms feels right to me, and could act as a good step towards a full solution.</p>
</blockquote>
</aside>
<p>One curious observation about datatypes being antiforms is that there is no meaning currently to QUASI or QUOTE of an antiform.</p>
<pre><code>&gt;&gt; spread [a b c]
== ~(a b c)~  ; anti

&gt;&gt; quote spread [a b c]
** Error: You can't quote antiforms, fool.

&gt;&gt; quasi spread [a b c]
** Error: You can't quasi them either!  META it if you want to make ~(a b c)~
</code></pre>
<p>But what if an exception were made for datatypes... not to make them non-antiforms, but to integrate the quoted state into the datatype?</p>
<pre><code>&gt;&gt; blank!
== ~{blank!}~  ; anti

&gt;&gt; quasi blank!
== ~{~blank!~}~  ; anti

&gt;&gt; quote quote blank!
== ~{''blank!}~  ; anti
</code></pre>
<p>Then in typespecs, you could say <strong>[quote/blank!]</strong> if you wanted to match quoted blanks.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>It might be the inklings of a workable concept, or not.</p>
<p>Overall--however--I think DATATYPE! as antiform has proven a smart path, and that's unlikely to change.</p>
          <p><a href="https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324/8">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324/8</link>
        <pubDate>Sat, 19 Apr 2025 23:29:30 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2324-8</guid>
        <source url="https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324.rss">Old Idea Revisited: DATATYPE as... Antiform?</source>
      </item>
      <item>
        <title>Old Idea Revisited: DATATYPE as... Antiform?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2324">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Originally the choice to make datatypes like <strong><code>&amp;[integer]</code></strong> instead of words as <strong><code>&amp;integer</code></strong> was that I wanted to use &amp;some-function? as an inert type that could be passed to things like MATCH or use in PARSE</p>
</blockquote>
</aside>
<aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="2324">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I thought about putting quote marks on the datatype to reflect how much quoting there was:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; type of first ['''a]
== '''[#datatype word!]
</code></pre>
<p>But I realized having quotes on the outside of the type had bad properties... it was no longer a datatype, it was a QUOTED!. And if you put it somewhere and it evaluated those quotes were easy to lose track of.</p>
<p>So as using a list type came up, I thought putting the quotes inside the list made more sense.</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; type of first ['''a]
== &amp;['''word!]
</code></pre>
</blockquote>
</aside>
<p>Not that any of this is completely understood yet, but another advantage is potentially in terms of extensibility, since you can put any value in a list but not a sigil on any value.</p>
<p>So perhaps extension types are TUPLE!s or URL!s or something:</p>
<pre><code>&gt;&gt; import http://github.com/Oldes/vector/vector.r  ; (Oldes loves vector!)

&gt;&gt; type of make vector! [...]
== ~{oldes.vector!}~  ; anti

; or something like

&gt;&gt; type of make vector! [...]
== ~{vector! http://oldes-r3.com/extensions/}~  ; anti
</code></pre>
<p>While I abandoned <a href="https://rebol.metaeducation.com/t/extension-types-implementation-on-hold/1203">extension types</a> for a while because of the mess they were making, it might be the right time to bring at least one of them back.  But I don't want them to be in the core repository, so there'd have to modifications to the build process to bring things in from other repos.</p>
<p>(I've not yet taken that step, only put issue databases up for things like the ODBC extension where issues can be filed there, it's still maintained in the core repo for now.)</p>
          <p><a href="https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324/7">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324/7</link>
        <pubDate>Tue, 25 Mar 2025 22:05:44 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2324-7</guid>
        <source url="https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324.rss">Old Idea Revisited: DATATYPE as... Antiform?</source>
      </item>
      <item>
        <title>Old Idea Revisited: DATATYPE as... Antiform?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="5" data-topic="2324">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>You know how I loathed those &amp;-types.</p>
</blockquote>
</aside>
<p>I'm wondering now, what the application of &amp; should be.</p>
<p>The <code>@xxx</code> and <code>$xxx</code> types became integral to solving binding.  I don't <em>think</em> there's another binding-related type needed (though I could be wrong).</p>
<p>But one of the big weak spots in the system is lifetime management. I have a vague fuzzy idea that maybe it would be related to something in the realm of &amp; as used for <a href="https://doc.rust-lang.org/rust-by-example/scope/borrow.html">borrow checking in Rust</a>.</p>
<pre><code>&gt;&gt; &amp;[bl o ck]
== [bl o ck]  ; but with some manipulation to its lifetime rules

&gt;&gt; some-func &amp;var
; pass function fetched value that has had that manipulation applied
</code></pre>
<p>The language aesthetics hinge on this being an uncommon case (e.g. you can't need to do this for something fundamental like <strong><code>append &amp;block &amp;item</code></strong> or the language starts looking like a mess.)  But I'm going to keep an eye out for how it might be used.</p>
<p>In any case, you may not have heard the last of &amp;xxx types.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/slight_smile.png?v=14" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="4" data-topic="2324">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; type of first [~a~]
== ~{~word!~}~  ; anti

&gt;&gt; type of first ['''a]
== ~{'''word!}~  ; anti
</code></pre>
</blockquote>
</aside>
<p>It occurred to me that decorators could be put on the types:</p>
<pre><code>&gt;&gt; type of first [@a]
== ~{@word!}~  ; anti

&gt;&gt; the-word!
== ~{@word!}~  ; anti
</code></pre>
<p>This encodes the sigil directly into the datatype.  It has the drawback of screwing up TO WORD! datatype's implementation, however.</p>
<p>You should be able to ask for the sigil that a datatype uses, but I'm not sure I like that being done with SIGIL OF:</p>
<pre><code>&gt;&gt; sigil of the-word!
== @
</code></pre>
<p>Maybe SIGIL-OF:TYPE.</p>
<pre><code>&gt;&gt; sigil-of:type the-word!
== @
</code></pre>
<p>Miles to go with this, but it does look more hopeful than it has.</p>
          <p><a href="https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324/6">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324/6</link>
        <pubDate>Tue, 25 Mar 2025 14:03:36 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2324-6</guid>
        <source url="https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324.rss">Old Idea Revisited: DATATYPE as... Antiform?</source>
      </item>
      <item>
        <title>Old Idea Revisited: DATATYPE as... Antiform?</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2324">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>While it's hazy to think of exactly how this will work out, I'm going to likely be killing off the datatype-oriented usage of &amp; - types.</p>
</blockquote>
</aside>
<p>Finally! You know how I loathed those &amp;-types. I never did manage to work out a replacement for them, but antiforms are a wonderfully clever solution — as you say, it makes perfect sense semantically, and eliminates problems with putting them in blocks. I think this approach could solve a lot of issues.</p>
          <p><a href="https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324/5">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324/5</link>
        <pubDate>Tue, 25 Mar 2025 06:12:39 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2324-5</guid>
        <source url="https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324.rss">Old Idea Revisited: DATATYPE as... Antiform?</source>
      </item>
      <item>
        <title>Old Idea Revisited: DATATYPE as... Antiform?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2324">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>And of course, the original motivator still applies... which was the ambiguity of:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">rebol2&gt;&gt; find [a 1 b c] integer!
== [1 b c]

rebol2&gt;&gt; find compose [a (integer!) b c] integer!
== [integer! b c]  ; not a word!, should render as [#[integer!] b c]
</code></pre>
<p>If INTEGER! is an antiform, then you don't have to worry about that ambiguity, since such a COMPOSE is impossible.</p>
</blockquote>
</aside>
<p>So I was noticing you couldn't do this anymore...</p>
<pre><code>func compose:deep [x [word! (integer!)]] [ ... ]
</code></pre>
<p>Because integer! is an antiform of ~{integer!}~, and you can't put antiforms in blocks...</p>
<p>But let's say you ^META it...</p>
<pre><code>&gt;&gt; compose:deep [x [word! (meta integer!)]]
== [x [word! ~{integer!}~]]
</code></pre>
<p>We have sort of free reign to decide what quasiforms do in type spec blocks.  For instance, quasi-blocks match packs with those types, e.g. <strong><code>~[integer! block!]~</code></strong> would match a pack antiform like <strong><code>~['1 '[a b c]]~</code></strong>.  So it's not like the quasiform states are uniformly treated literally.</p>
<p><strong>So why not have quasi-fences mean typecheck that as a datatype?</strong></p>
<p>Seems like a winner to me (and reminiscent of my recent realization of <a href="https://rebol.metaeducation.com/t/dialecting-quasiforms-in-parse/2379">"Quasiforms can mean whatever we want to design them to do in PARSE"</a>)</p>
<h2><a name="p-8063-type-of-including-quotedquasi-status-1" class="anchor" href="https://rebol.metaeducation.com#p-8063-type-of-including-quotedquasi-status-1"></a>TYPE OF including Quoted/Quasi Status?</h2>
<p>In the dawn of generalized quoting, I thought about putting quote marks on the datatype to reflect how much quoting there was:</p>
<pre><code>&gt;&gt; type of first ['''a]
== '''[#datatype word!]
</code></pre>
<p>But I realized having quotes on the outside of the type had bad properties... it was no longer a datatype, it was a QUOTED!.  And if you put it somewhere and it evaluated those quotes were easy to lose track of.</p>
<p>So as using a list type came up, I thought putting the quotes inside the list made more sense.</p>
<pre><code>&gt;&gt; type of first ['''a]
== &amp;['''word!]
</code></pre>
<p>But with the dawn of antiforms and quasiforms, there was a problem.  If you wanted to signal an antiform you'd perhaps do that with a quasiform.</p>
<pre><code>&gt;&gt; spread [a b c]
== ~(a b c)~  ; anti

&gt;&gt; type of spread [a b c]
== &amp;[~group!~]
</code></pre>
<p>But then your answer for quasiforms would have to be quoted...and your answer for everything else would be one level quoted higher than you wanted it:</p>
<pre><code>&gt;&gt; type of first [~a~]
== &amp;['~word!~]  ; :-(

&gt;&gt; type of first ['''a]
== &amp;[''''word!]  ; four quotes?!  :-(
</code></pre>
<p>That was hideous.  But as of now, antiforms are getting their own types:</p>
<pre><code>&gt;&gt; type of spread [a b c]
== ~{splice!}~
</code></pre>
<p>Which means maybe the old system could be used more sensibly:</p>
<pre><code>&gt;&gt; type of first [~a~]
== ~{~word!~}~

&gt;&gt; type of first ['''a]
== ~{'''word!}~
</code></pre>
<p>That doesn't look hideous.  In any case, I proposed the idea that you could produce these datatypes from other ones, e.g.</p>
<pre><code>&gt;&gt; integer!
== ~{integer!}~

&gt;&gt; quoted integer!
==  ~{'integer!}~

&gt;&gt; quoted-datatype? ~{'integer!}~
== ~okay~  ; anti
</code></pre>
<p>What motivated me to think about TYPE OF giving these distinct answers e.g. for quasiforms and quoteds is that I want PARSE to be able to dispatch on quasiforms now, and it doesn't have a good way to do that unless it distinguishes them.</p>
<p>Again--this is an old idea reviewed in light of new developments.  It doesn't look completely nuts.  I'm in the throes of the antiform datatype conversion, so I'll probably have more to say shortly.</p>
<hr>
<p><strong>UPDATE:</strong> The antiform datatype code boots after less than 2 days work!  But... booting is the beginning of a lot of details and additional design work.</p>
          <p><a href="https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324/4</link>
        <pubDate>Mon, 24 Mar 2025 13:06:36 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2324-4</guid>
        <source url="https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324.rss">Old Idea Revisited: DATATYPE as... Antiform?</source>
      </item>
      <item>
        <title>Old Idea Revisited: DATATYPE as... Antiform?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2324">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I’ve been somewhat unhappy about the way Ren-C currently represents datatypes</p>
</blockquote>
</aside>
<p>Join the club <img src="https://rebol.metaeducation.com/images/emoji/twitter/slight_smile.png?v=14" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20">  But I've sort of moved in the direction of accepting that TYPE OF really just answers the fundamental type question, and other questions need to be more specific probes.</p>
<p>There's lots of choices (CLASS OF, or other fingerprinting routines).</p>
<p><a href="https://rebol.metaeducation.com/t/type-of-antiform-now-possible-should-we-use-it/2374" class="inline-onebox">"type of antiform" now possible... Should We Use It?</a></p>
<aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2324">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I like this idea.</p>
</blockquote>
</aside>
<p>Been ruminating on it, and I think it's probably the right answer.</p>
<p>I've made the arguments above.  But beyond the argumentation there's just sort of an <em>intuition</em>... that the answer to the TYPE OF question isn't something you think of as "in-band" in terms of what you generally think of as a "fundamental" value... e.g. one you can put in a block.</p>
<p>You've moved out of the domain of "things" and into a sort of domain of "meta things" when you ask a type question.</p>
<p>And of course, the original motivator still applies... which was the ambiguity of:</p>
<pre><code>rebol2&gt;&gt; find [a 1 b c] integer!
== [1 b c]

rebol2&gt;&gt; find compose [a (integer!) b c] integer!
== [integer! b c]  ; not a word!, should render as [#[integer!] b c]
</code></pre>
<p>If INTEGER! is an antiform, then you don't have to worry about that ambiguity, since such a COMPOSE is impossible.</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="2324">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>If we were just reaching for something on the basis of looks, antiform FENCE! is nice:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; binary!
== ~{binary!}~  ; anti
</code></pre>
<p>I'm hesitant to surrender FENCE! antiforms to the purpose so soon after their invention. But there isn't anything undecorated left.</p>
</blockquote>
</aside>
<p>So it's a little funny that my gut reaction would be to be afraid to surrender FENCE!.  Datatypes are <em>really</em> important, so "sacrificing" antiform fence for them shouldn't be the issue.  If antiform FENCE! somehow solved the datatype problem it's not a sacrifice--it's a solution!</p>
<p>The question should be about <em>fitness for purpose</em>...does it work or is it advantageous to use a list.</p>
<p>Originally the choice to make datatypes like <strong><code>&amp;[integer]</code></strong> instead of words as <strong><code>&amp;integer</code></strong> was that I wanted to use &amp;some-function? as an inert type that could be passed to things like MATCH or use in PARSE.</p>
<pre><code>parse [a @b $c] [some &amp;any-word?]

match &amp;any-word? 'a

; vs...

parse [a @b $c] [some &amp;[any-word?]]

match &amp;[any-word?] 'a
</code></pre>
<p>Since datatypes existed under names, they wouldn't be used literally very often--but referred to from words as <strong><code>integer!</code></strong> instead--there was no real motivation to give datatypes the more succinct form.  The brackets wouldn't hurt.</p>
<p>I now believe that type constraints are more attractively (and consistently) done with trailing slash:</p>
<pre><code>parse [a @b $c] [some any-word?/]

match any-word?/ 'a  ; slash as barrier hints 'a is not an argument
</code></pre>
<p>It does mean that type constraints aren't a different entity from plain actions.  But so far, it seems anywhere that was expecting a datatype or type constriant doesn't have any other overloaded meaning for actions...the action would always be interpreted as a test.  And with intrinsics and the <a href="https://rebol.metaeducation.com/t/further-optimizations-of-breaking-the-64-type-barrier/2369">typeset table optimization</a> it's no longer necessary for performance reasons to distinguish them.</p>
<p>Beyond that, there was some speculation that the answer to TYPE OF might expand out... an example might be forms that included the number of quotes.</p>
<pre><code> &gt;&gt; type of first ['''x]
 == &amp;[quoted! quoted! quoted! word!]
</code></pre>
<p>My updated thinking is that this is a different question from what you get back as a default from TYPE OF.</p>
<h2><a name="p-8061-how-would-this-play-out-with-antiform-fence-1" class="anchor" href="https://rebol.metaeducation.com#p-8061-how-would-this-play-out-with-antiform-fence-1"></a>How Would This Play Out With Antiform FENCE?</h2>
<p>So if we believe that the new antiform DATATYPE! might store such answers, then using a list for it would be necessary:</p>
<pre><code> &gt;&gt; type:quotes of first ['''x]
 == ~{quoted! quoted! quoted! word!}~  ; anti
</code></pre>
<p>(Strangely enough, even with two tildes and an "anti", that does look better than the &amp; sigil.)</p>
<p>The question arises: can this live up to the expected behaviors of DATATYPE?</p>
<pre><code>&gt;&gt; qtype!!: type:quotes of first ['''x]
== ~{quoted! quoted! quoted! word!}~  ; anti

&gt;&gt; parse [a '''b] [word! qtype!!]
== '''b
</code></pre>
<p>The system could certainly do this for some limited set of representations.  Maybe not that limited, if it dispatched as a generic to the datatype to ask if it matched.</p>
<p>Equality tests are out the window, though.</p>
<pre><code>&gt;&gt; type-a: type of first ['''x]
== ~{quoted!}~  ; anti

&gt;&gt; type-b: type:quotes of first ['''x]
== ~{quoted! quoted! quoted! word!}~  ; anti

&gt;&gt; type-a = type-b
== ~null~  ; anti
</code></pre>
<p>There might be some limited set of ways to <a href="https://rebol.metaeducation.com/t/is-and-isnt-vs-and-friends/1133/9">ask if they were "like"</a>:</p>
<pre><code>&gt;&gt; type-a like type-b
== ~okay~  ; anti
</code></pre>
<p>And maybe that could be driven by logic of checking just the first element in the datatype fence's array.  Or maybe that's something else methodized via generic. <img src="https://rebol.metaeducation.com/images/emoji/twitter/man_shrugging.png?v=14" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p>
<p>Anyway, this would all motivate the idea that the list-like nature of fence for datatype is justified.</p>
<h2><a name="p-8061-im-going-ahead-with-it-2" class="anchor" href="https://rebol.metaeducation.com#p-8061-im-going-ahead-with-it-2"></a>I'm Going Ahead With It</h2>
<p>While it's hazy to think of exactly how this will work out, I'm going to likely be killing off the datatype-oriented usage of &amp; - types.</p>
<p>The &amp; types may remain and be used for some other purpose.  Put a pin in that.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/pushpin.png?v=14" title=":pushpin:" class="emoji" alt=":pushpin:" loading="lazy" width="20" height="20">  Rather than delete them, for now I'm just going to call them WILD-WORD!, WILD-BLOCK! etc. and make them error in the evaluator.  Worst case scenario they're just a type you know has no other meaning, so your dialect can ascribe whatever you want while delegating the other behaviors to the evaluator.  But maybe there is a missing fundamental behavior I haven't identified yet and these can solve that problem.</p>
<h2><a name="p-8061-afterthought-3" class="anchor" href="https://rebol.metaeducation.com#p-8061-afterthought-3"></a>Afterthought</h2>
<p>It occurs to me that I've spoken about FENCE! as being tied in intimately with MAKE</p>
<p><a href="https://rebol.metaeducation.com/t/make-should-be-using-dialected-constructors/2196" class="inline-onebox">MAKE Should Be Using *Dialected Constructors*</a></p>
<p>This sort of connects antiform/quasiform FENCE! with datatypes, in a way, if you squint at it.</p>
          <p><a href="https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324/3</link>
        <pubDate>Sun, 23 Mar 2025 15:08:11 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2324-3</guid>
        <source url="https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324.rss">Old Idea Revisited: DATATYPE as... Antiform?</source>
      </item>
      <item>
        <title>Old Idea Revisited: DATATYPE as... Antiform?</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <p>I like this idea. You know I’ve been somewhat unhappy about the way Ren-C currently represents datatypes; making them antiforms feels right to me, and could act as a good step towards a full solution.</p>
          <p><a href="https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324/2</link>
        <pubDate>Sat, 16 Nov 2024 12:20:57 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2324-2</guid>
        <source url="https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324.rss">Old Idea Revisited: DATATYPE as... Antiform?</source>
      </item>
      <item>
        <title>Old Idea Revisited: DATATYPE as... Antiform?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>I've been suffering through an attempt to bring sanity to bear upon the MAKE and TO matrix.</p>
<p>While doing so, I noticed that there are a lot of MAKE instructions that do "joining".</p>
<p>In R3-Alpha and Red:</p>
<pre><code>&gt;&gt; make binary! [1 2 #{DECAFBAD} 3 4]   
== #{0102DECAFBAD0304}
</code></pre>
<p>Historical MAKE is so arbitrary in how it interprets its arguments that it made me feel that it would be better if JOIN allowed a datatype as its first argument...</p>
<p>JOIN typically makes a new series out of what you give it:</p>
<pre><code>&gt;&gt; bin: #{AABB}

&gt;&gt; join bin #{CCDD}
== #{AABBCCDD}  ; made new series, didn't impact BIN

&gt;&gt; bin
== #{AABB}
</code></pre>
<p>But if you could pass a datatype as the first argument, you could relieve MAKE of the behavior...and make it clearer in the source what's actually happening:</p>
<pre><code>&gt;&gt; join binary! [1 2 #{DECAFBAD} 3 4]
== #{0102DECAFBAD0304}
</code></pre>
<p>Since that seemed nice, I started to map it out, and ran into a bit of a problem:</p>
<p><strong>If "datatypes" are an ANY-WORD! or ANY-LIST! or anything like that, how do you know you're not trying to JOIN with it?</strong></p>
<p>A WORD! should be able to join:</p>
<pre><code>&gt;&gt; join 'var 10
== var10
</code></pre>
<p>A BLOCK! should be able to join... though possibly only with blocks that it reduces <em>(devil's in the details as to why, beyond the scope of what I'm talking about right now)</em>...</p>
<pre><code>&gt;&gt; join [a b] [1000 + 20]
== [a b 1020]
</code></pre>
<p>Okay, but when you say <strong>join binary!</strong> what is BINARY!?  Well right now, it's:</p>
<pre><code>&gt;&gt; binary!
== &amp;[binary]
</code></pre>
<p>Well that looks like it's in-band for the kinds of things JOIN operates on:</p>
<pre><code>&gt;&gt; join &amp;[binary] [1000 + 20]
== &amp;[binary 1020]
</code></pre>
<h2><a name="p-7875-an-antiform-would-push-datatype-out-of-band-1" class="anchor" href="https://rebol.metaeducation.com#p-7875-an-antiform-would-push-datatype-out-of-band-1"></a>An Antiform Would Push DATATYPE? Out-Of-Band...</h2>
<p>It's possible that we could come up with a new non-antiform for types.  But the lexical space is extremely saturated.</p>
<p>If we were just reaching for something on the basis of looks, antiform FENCE! is nice:</p>
<pre><code>&gt;&gt; binary!
== ~{binary!}~  ; anti
</code></pre>
<hr>
<p><strong>UPDATE:</strong> <a class="mention" href="https://rebol.metaeducation.com/u/blackattr">@BlackATTR</a> and I believe the exclamation point is probably best as part of the contents.  If you're turning a datatype into a word, the only reason you're doing it is to present to a programmer.  This lines up with history:</p>
<pre><code>red&gt;&gt; to word! integer!
== integer!

rebol2&gt;&gt; to word! integer!
== integer!
</code></pre>
<hr>
<h2><a name="p-7875-this-has-come-up-before-in-2022httpsrebolmetaeducationcomtwhat-if-datatype-was-isotopic1982-2" class="anchor" href="https://rebol.metaeducation.com#p-7875-this-has-come-up-before-in-2022httpsrebolmetaeducationcomtwhat-if-datatype-was-isotopic1982-2"></a><a href="https://rebol.metaeducation.com/t/what-if-datatype-was-isotopic/1982">This Has Come Up Before... (in 2022)</a></h2>
<p>Historical Rebol let you use datatypes in FIND:</p>
<pre><code>rebol2&gt;&gt; find [a b c 10 20] integer! 
== [10 20]
</code></pre>
<p>But then this conflates with when you actually literally have the INTEGER! datatype in the block.</p>
<pre><code>&gt;&gt; find compose [a (integer!) b c 10 20] integer!
== [integer! b c 10 20]
</code></pre>
<p>So in the early days of antiforms, I proposed antiform datatypes as a solution... but at that time I was thinking that there'd be non-antiform DATATYPE!, and it's just that when it was an antiform it would be a "MATCHER".</p>
<p><strong>The proposal I'm thinking of now is different, in saying that DATATYPE? only exists as a (stable) antiform state.</strong></p>
<p>There are tradeoffs, in that datatypes can't be put in blocks directly.  But the mechanics of working with quasiforms and antiforms via things like REIFY and DEGRADE are much smoother now.  And really, putting datatypes in blocks doesn't happen that often (I've had to put splices in blocks...and they're antiforms... but really never datatypes).</p>
<p><strong>Being completely out of band with things you can find in a block has advantages.</strong>  JOIN isn't unique in reaping benefits from being able to say that datatypes aren't "things".</p>
<p>And it unifies datatypes with typecheckers being antiforms, because typecheckers are frame antiforms, e.g. actions:</p>
<pre><code>&gt;&gt; find [1 3 5 8 10] even?/
; first in pack of length 2
== [8 10]
</code></pre>
<p>So I don't think it's a crazy idea.</p>
<p>I'm hesitant to surrender FENCE! antiforms to the purpose so soon after their invention.  But there isn't anything undecorated left.</p>
<p>Not that "no decorated antiforms" is some unbreakable rule, it was a guideline.</p>
<p>Using &amp; would put it in the family of TYPE-XXX! and be cheaper than FENCE! if you made new instances:</p>
<pre><code>&gt;&gt; binary!
== ~&amp;binary!~  ; anti
</code></pre>
<p>A random bad idea would be to make them keywords, and just have DATATYPE? be smart enough to filter out ~null~ or ~void~ or ~okay~ or whatever else (the symbol could carry a flag)</p>
<pre><code>&gt;&gt; binary!
== ~binary!~  ; anti

&gt;&gt; null
== ~null~  ; anti

&gt;&gt; datatype? binary!
== ~okay~  ; anti

&gt;&gt; datatype? null
== ~null~  ; anti
</code></pre>
<p>I can pretty clearly say that's bad.</p>
<h2><a name="p-7875-or-pick-some-non-antiform-notation-3" class="anchor" href="https://rebol.metaeducation.com#p-7875-or-pick-some-non-antiform-notation-3"></a>Or, Pick Some Non-Antiform Notation</h2>
<p>Status quo might look like:</p>
<pre><code>&gt;&gt; binary!
== #[binary!]
</code></pre>
<p>Despite it looking sort of like a block, it wouldn't be.  But we're squandering some of our notational space no matter what.  The <strong><code>~&amp;type!~</code></strong> is the discount route.</p>
<h2><a name="p-7875-either-way-datatype-cant-be-any-word-or-any-list-4" class="anchor" href="https://rebol.metaeducation.com#p-7875-either-way-datatype-cant-be-any-word-or-any-list-4"></a>Either Way, DATATYPE? Can't be ANY-WORD! or ANY-LIST!</h2>
<p>It needs to be out of band one way or another.  I'll have to think about it.</p>
          <p><a href="https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324/1</link>
        <pubDate>Fri, 08 Nov 2024 17:05:05 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2324-1</guid>
        <source url="https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324.rss">Old Idea Revisited: DATATYPE as... Antiform?</source>
      </item>
  </channel>
</rss>

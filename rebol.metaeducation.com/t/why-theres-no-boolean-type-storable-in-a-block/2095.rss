<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Why There&#39;s No Boolean Type Storable in a BLOCK!</title>
    <link>https://forum.rebol.info/t/why-theres-no-boolean-type-storable-in-a-block/2095</link>
    <description>[quote=&quot;bradrn, post:1, topic:2094&quot;]
Isotopic WORD!s seem to be error states of some description, as well as booleans — except that makes no sense to me, since surely booleans should be storable in blocks‽
[/quote]

Rebol made an unusual choice in deciding that all things that &quot;look like&quot; words would be words, and reassignable.  So **true** and **false** were kept following the general rules of words.  Including that all words are truthy.

    &gt;&gt; code: [flag: false]

    &gt;&gt; second code
    == false

    &gt;&gt; if second code [print &quot;the word false is truthy&quot;]
    the word false is truthy

There was a LOGIC! type, and it could be made via the `#[true]` and `#[false]` notation:

    rebol2&gt;&gt; code: [flag: #[false]]

    rebol2&gt;&gt; if not second code [print &quot;the literal #[false] is falsey&quot;]
    the literal #[false] is falsey

So the default definitions are **true: #[true]** and **false: #[false]**.  But the rendering would conflate with the word, despite not being a word:

    rebol2&gt;&gt; code: [flag: #[false]]

    rebol2&gt;&gt; code
    == [flag: false]

    rebol2&gt;&gt; type? second code
    == logic!

    rebol2&gt;&gt; true
    == true

    rebol2&gt;&gt; word? true
    == false

There was puzzling about wondering what a better notation for LOGIC! literals might be.  Considerations included things like **$true** and **$false**, among others.

I wanted to see there be **`$word $(gr o up) $[bl o ck] $tu.p.le $pa/th`** as additional pieces in the box of parts...so sacrificing $ for this wasn&#39;t appealing to me.

Hence for a long time, Ren-C just rendered them as #[true] and #[false].

## Rebol/Red&#39;s Bad Rendering Reveals a Subliminal Truth

As it turns out, a lot of places where you&#39;re building up structures you don&#39;t want an ugly literal (however it looks).  For a lot of scenarios you want to reconstitute the word.

When isotopes came on the scene it afforded the interesting choice to say that the logic-reactive ~true~ and ~false~ isotopes couldn&#39;t be put into blocks... and would have to be triaged.

    &gt;&gt; false
    == ~false~  ; isotope

    &gt;&gt; append [flag:] false
    ** Error

    &gt;&gt; append [flag:] meta false
    == [flag: ~false~]  ; evaluates to the right thing under DO

    &gt;&gt; append [flag:] logic-to-word false
    == [flag: false]

## All BLOCK! Items Truthy, Out-of-Bounds NULL

This gives another benefit, which is that the null returned from out-of-bounds access of arrays gives the unique falsey result for various enumerations.  For example:

     &gt;&gt; block: [a b ~false~ c]

     &gt;&gt; while [value: try take block] [print mold value]
     a
     b
     ~false~
     c

Or:

    &gt;&gt; block: [a b ~false~ c]

    &gt;&gt; third block
    == ~false~

    &gt;&gt; if third block [print &quot;There&#39;s a third element in block&quot;]
    There&#39;s a third element in block

    &gt;&gt; fifth block
    == ~null~  ; isotope

    &gt;&gt; if not fifth block [print &quot;No fifth element in block&quot;]
    No fifth element in block

These kinds of scenarios present classic problems in Rebol and Red, because people will write code assuming that they can use conditional logic to decide if a value is there... but then one day they hit a LOGIC! or a NONE! literal and it breaks.  Having nothing that&#39;s actually in a block be falsey is a good thing.

## No Answer is Perfect, But This Has Solid Benefits

The need to store things in blocks that are themselves directly testable as falsey isn&#39;t all that valuable in practice.  And it frequently led to broken code when people were assuming a conditional test could be used to know whether an element was in a block or not.

Encouraging discipline in triage with whether you want a word or a meta-representation of a logic (which evaluates to something that has the truthy/falsey property) has--in my opinion--turned out to be a net benefit.</description>
    
    <lastBuildDate>Sun, 07 Jan 2024 10:11:53 +0000</lastBuildDate>
    <category>Datatypes</category>
    <atom:link href="https://forum.rebol.info/t/why-theres-no-boolean-type-storable-in-a-block/2095.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Why There&#39;s No Boolean Type Storable in a BLOCK!</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2095">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Do note that this being an option is a by-product of Ren-C's groundwork by having isotopes/null in the first place.</p>
</blockquote>
</aside>
<p>This is true, and I quite like isotopes in general. It’s just that I find it difficult to conceptualise <em>boolean values</em>, of all things — the most basic data type in existence! — being so ‘gnarly’ that they must be made isotopic.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2095">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Only handling a subset of code is by design in Ren-C. It also doesn't allow <strong><code>reduce [pick [a b] 3]</code></strong> or <strong><code>reduce [:append :insert :change]</code></strong> or <strong><code>reduce [get/any 'somethingundefined]</code></strong></p>
</blockquote>
</aside>
<p>Fair enough.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2095">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Counting the number of truthy values in a block simply comes up less often and is less useful than being able to trust that all items in blocks are truthy.</p>
</blockquote>
</aside>
<p>This is the argument which speaks to me the most: it’s a trade-off, and you just have to pick what things you value the most. You happen to like the idioms which are enabled by making all non-isotopic values truthy, so you consider this choice to be a good one. I don’t particularly like those idioms, so I prefer a design where booleans can be non-isotopic. Ultimately, it’s subjective, and I can accept the reasons you made this decision.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2095">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre><code class="lang-auto">reduce/predicate [1 = 1, 1 = 0, 2 = 3, 3 = 3] :digital
== [1 0 0 1]
</code></pre>
</blockquote>
</aside>
<p>OK, I didn’t know <code>/predicate</code> existed. That immediately makes working with isotopes a <em>lot</em> easier.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2095">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>You seemed to prefer brevity e.g. with REDUCE over COMPOSE, and brevity is served better when you can fold the acquisition of value with the check:</p>
<pre><code class="lang-auto"> value: any [pick block index, &lt;out-of-range&gt;]
</code></pre>
</blockquote>
</aside>
<p>OK, that <em>is</em> quite nice. I don’t think it’s necessarily worth sacrificing non-isotopic booleans, but like I said, it’s a subjective decision.</p>
          <p><a href="https://forum.rebol.info/t/why-theres-no-boolean-type-storable-in-a-block/2095/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/why-theres-no-boolean-type-storable-in-a-block/2095/4</link>
        <pubDate>Sun, 07 Jan 2024 10:11:53 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2095-4</guid>
        <source url="https://forum.rebol.info/t/why-theres-no-boolean-type-storable-in-a-block/2095.rss">Why There&#39;s No Boolean Type Storable in a BLOCK!</source>
      </item>
      <item>
        <title>Why There&#39;s No Boolean Type Storable in a BLOCK!</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2095">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p><code>if null? fifth block […]</code>. And nulls can’t be in blocks anyway, so that check would work just as well.</p>
</blockquote>
</aside>
<p>Do note that this being an option is a by-product of Ren-C's groundwork by having isotopes/null in the first place.</p>
<p>R3-Alpha/Red don't have this:</p>
<pre><code>red&gt;&gt; alpha: [1 2 #[none]]

red&gt;&gt; beta: [1 2]

red&gt;&gt; none? third alpha
== true

red&gt;&gt; none? third beta
== true
</code></pre>
<aside class="quote no-group quote-modified" data-username="bradrn" data-post="2" data-topic="2095">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>It means that REDUCE can only handle a subset of code.</p>
</blockquote>
</aside>
<p>Only handling a subset of code is by design in Ren-C.  It also doesn't allow <strong><code>reduce [pick [a b] 3]</code></strong> or <strong><code>reduce [:append :insert :change]</code></strong> or <strong><code>reduce [get/any 'somethingundefined]</code></strong></p>
<p>People can make (and have made) arguments that allowing those things are good.  It takes experience to know that they are bad.</p>
<p>You learn how bad they are by seeing errors and catastrophes go by, that preventing them solves.  Then you look at what you need to do in order to accomplish the (few) cases where they represented some valid intent...and see it can be solved a better way.</p>
<p>I can empathize that it's not in your mindset at this moment to think of a logic literal as "gnarly" or problematic in the way the state of null or an unset variable would be.  But in Rebol, due to its idioms, and the weird choice to not take <strong>true</strong> and <strong>false</strong> for it...it winds up being gnarlier than you think.</p>
<aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2095">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>You could also imagine a function which, say, counts the number of truthy values in a block.</p>
</blockquote>
</aside>
<p>I can imagine a lot of things.</p>
<p>But I also deal with the largest and most tricky codebases of Rebolese that anyone has ever confronted.  And I have a good sense of what problems are more and less prevalent... and where elegance is more in need vs. not.</p>
<p>The duality between <strong>true</strong> and <strong>false</strong> and <strong>#[true]</strong> and <strong>#[false]</strong> is a constant thorn which is assisted by not letting the #[true] and #[false] percolate too widely.</p>
<p>Counting the number of truthy values in a block simply comes up less often and is less useful than being able to trust that all items in blocks are truthy.</p>
<p>I'd say it's equally likely (if not more likely) that I'd want to count the number of <code>red</code> words in a block that contained instances of <code>red</code> or <code>green</code> or <code>blue</code>.</p>
<p>If your work involves a lot of boolean processing, and you wind up having to do a level of work that resembles enum processing for the words <code>true</code> and <code>false</code> (or quasi-words <code>~true~</code> and <code>~false~</code>, or integers 0 and 1) I don't think it turns out to be as big a problem as you might think.  Let's imagine a DIGITAL function:</p>
<pre><code>&gt;&gt; digital: lambda [x] [either x '1 '0]

&gt;&gt; digital 1 = 1
== 1

&gt;&gt; digital 1 = 0
== 0

&gt;&gt; reduce/predicate [1 = 1, 1 = 0, 2 = 3, 3 = 3] :digital
== [1 0 0 1]

&gt;&gt; sum: 0, reduce-each x [1 = 1, 1 = 0, 2 = 3, 3 = 3] [sum: me + digital x]
== 2
</code></pre>
<p><em>(Introducing a few features in my examples as we go, so you can see the use of quoted values as branches instead of blocks... e.g. <strong><code>if 1 = 1 '[a]</code></strong> is a synonym for <strong><code>if 1 = 1 [[a]]</code></strong>.  Also the left-quoting construct ME, which evaluates to the prior value of the SET-WORD! on its left.  It's more useful when the variable name is longer, e.g. <strong><code>my-long-variable-name: me + 1</code></strong>)</em></p>
<aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2095">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>For that matter, I’d naturally tend to write this in a completely different way: <code>if 5 &lt;= length? block […]</code>.</p>
</blockquote>
</aside>
<p>You seemed to prefer brevity e.g. with REDUCE over COMPOSE, and brevity is served better when you can fold the acquisition of value with the check:</p>
<pre><code> value: any [pick block index, &lt;out-of-range&gt;]
</code></pre>
<p>This kind of code is simply what idiomatic Rebol code is like historically.  LOGIC! and NONE! resident in blocks have broken it, and people just kind of ignore that and hope that they don't hit them.  Fixing it is good in my view, as I like the style.</p>
<p>And I'm just going to have to maintain that the systemic benefit of being able to write things like <strong>while [value: try take block] [...]</strong> vs. <strong>while [not null? value: try take block] [...]</strong> adds up to being more significant than the impositions on logic handling, when you consider the kinds of problems that Rebol is applied to.</p>
          <p><a href="https://forum.rebol.info/t/why-theres-no-boolean-type-storable-in-a-block/2095/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/why-theres-no-boolean-type-storable-in-a-block/2095/3</link>
        <pubDate>Sun, 07 Jan 2024 08:49:30 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2095-3</guid>
        <source url="https://forum.rebol.info/t/why-theres-no-boolean-type-storable-in-a-block/2095.rss">Why There&#39;s No Boolean Type Storable in a BLOCK!</source>
      </item>
      <item>
        <title>Why There&#39;s No Boolean Type Storable in a BLOCK!</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <p>Hmm. So the issues seem to stem from the fact that booleans are not the only truthy/falsey values in Rebol… it’s like other dynamically typed languages in having a bunch of others. Except it’s <em>not</em> entirely like other dyamically typed languages, since you want all values stored in a block to be truthy. So that implies that if we have a falsey value, it <em>must</em> be isotopic!</p>
<p>This approach is logical, but doesn’t really appeal to me. For one thing, it means that REDUCE can only handle a subset of code. It makes no sense that <code>reduce [1 + 1]</code> should work, but <code>reduce [1 = 1]</code> should error out.</p>
<p>This also makes composition harder. Thus, for instance, AND conceptually does two tasks: it REDUCEs the block it’s passed to, and then it takes the first non-falsey result. I’d much prefer to split out those tasks into two different functions… except I can’t do that, because you can’t make such blocks in the first place.</p>
<p>(You may argue that there’s not much need to run the equivalent of AND without first REDUCEing. But that’s just one example. You could also imagine a function which, say, counts the number of truthy values in a block. This is a useful function to have… yet at the moment, I can’t see any way to implement it without also making it reimplement REDUCE. This is not great for code reuse, to say the least!)</p>
<p>Besides, I don’t see why it’s so immensely desirable to use a conditional to test for existence. I’d much prefer using an explicit check: <code>if null? fifth block […]</code>. And nulls can’t be in blocks anyway, so that check would work just as well. For that matter, I’d naturally tend to write this in a completely different way: <code>if 5 &lt;= length? block […]</code>.</p>
          <p><a href="https://forum.rebol.info/t/why-theres-no-boolean-type-storable-in-a-block/2095/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/why-theres-no-boolean-type-storable-in-a-block/2095/2</link>
        <pubDate>Sun, 07 Jan 2024 07:15:36 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2095-2</guid>
        <source url="https://forum.rebol.info/t/why-theres-no-boolean-type-storable-in-a-block/2095.rss">Why There&#39;s No Boolean Type Storable in a BLOCK!</source>
      </item>
      <item>
        <title>Why There&#39;s No Boolean Type Storable in a BLOCK!</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2094">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/which-isotopes-are-currently-in-use/2094/1">Which isotopes are currently in use?</a>
</div>
<blockquote>
<p>Isotopic WORD!s seem to be error states of some description, as well as booleans — except that makes no sense to me, since surely booleans should be storable in blocks‽</p>
</blockquote>
</aside>
<p>Rebol made an unusual choice in deciding that all things that "look like" words would be words, and reassignable.  So <strong>true</strong> and <strong>false</strong> were kept following the general rules of words.  Including that all words are truthy.</p>
<pre><code>&gt;&gt; code: [flag: false]

&gt;&gt; second code
== false

&gt;&gt; if second code [print "the word false is truthy"]
the word false is truthy
</code></pre>
<p>There was a LOGIC! type, and it could be made via the <code>#[true]</code> and <code>#[false]</code> notation:</p>
<pre><code>rebol2&gt;&gt; code: [flag: #[false]]

rebol2&gt;&gt; if not second code [print "the literal #[false] is falsey"]
the literal #[false] is falsey
</code></pre>
<p>So the default definitions are <strong>true: #[true]</strong> and <strong>false: #[false]</strong>.  But the rendering would conflate with the word, despite not being a word:</p>
<pre><code>rebol2&gt;&gt; code: [flag: #[false]]

rebol2&gt;&gt; code
== [flag: false]

rebol2&gt;&gt; type? second code
== logic!

rebol2&gt;&gt; true
== true

rebol2&gt;&gt; word? true
== false
</code></pre>
<p>There was puzzling about wondering what a better notation for LOGIC! literals might be.  Considerations included things like <strong>$true</strong> and <strong>$false</strong>, among others.</p>
<p>I wanted to see there be <strong><code>$word $(gr o up) $[bl o ck] $tu.p.le $pa/th</code></strong> as additional pieces in the box of parts...so sacrificing $ for this wasn't appealing to me.</p>
<p>Hence for a long time, Ren-C just rendered them as #[true] and #[false].</p>
<h2>
<a name="rebolreds-bad-rendering-reveals-a-subliminal-truth-1" class="anchor" href="https://forum.rebol.info#rebolreds-bad-rendering-reveals-a-subliminal-truth-1"></a>Rebol/Red's Bad Rendering Reveals a Subliminal Truth</h2>
<p>As it turns out, a lot of places where you're building up structures you don't want an ugly literal (however it looks).  For a lot of scenarios you want to reconstitute the word.</p>
<p>When isotopes came on the scene it afforded the interesting choice to say that the logic-reactive ~true~ and ~false~ isotopes couldn't be put into blocks... and would have to be triaged.</p>
<pre><code>&gt;&gt; false
== ~false~  ; isotope

&gt;&gt; append [flag:] false
** Error

&gt;&gt; append [flag:] meta false
== [flag: ~false~]  ; evaluates to the right thing under DO

&gt;&gt; append [flag:] logic-to-word false
== [flag: false]
</code></pre>
<h2>
<a name="all-block-items-truthy-out-of-bounds-null-2" class="anchor" href="https://forum.rebol.info#all-block-items-truthy-out-of-bounds-null-2"></a>All BLOCK! Items Truthy, Out-of-Bounds NULL</h2>
<p>This gives another benefit, which is that the null returned from out-of-bounds access of arrays gives the unique falsey result for various enumerations.  For example:</p>
<pre><code> &gt;&gt; block: [a b ~false~ c]

 &gt;&gt; while [value: try take block] [print mold value]
 a
 b
 ~false~
 c
</code></pre>
<p>Or:</p>
<pre><code>&gt;&gt; block: [a b ~false~ c]

&gt;&gt; third block
== ~false~

&gt;&gt; if third block [print "There's a third element in block"]
There's a third element in block

&gt;&gt; fifth block
== ~null~  ; isotope

&gt;&gt; if not fifth block [print "No fifth element in block"]
No fifth element in block
</code></pre>
<p>These kinds of scenarios present classic problems in Rebol and Red, because people will write code assuming that they can use conditional logic to decide if a value is there... but then one day they hit a LOGIC! or a NONE! literal and it breaks.  Having nothing that's actually in a block be falsey is a good thing.</p>
<h2>
<a name="no-answer-is-perfect-but-this-has-solid-benefits-3" class="anchor" href="https://forum.rebol.info#no-answer-is-perfect-but-this-has-solid-benefits-3"></a>No Answer is Perfect, But This Has Solid Benefits</h2>
<p>The need to store things in blocks that are themselves directly testable as falsey isn't all that valuable in practice.  And it frequently led to broken code when people were assuming a conditional test could be used to know whether an element was in a block or not.</p>
<p>Encouraging discipline in triage with whether you want a word or a meta-representation of a logic (which evaluates to something that has the truthy/falsey property) has--in my opinion--turned out to be a net benefit.</p>
          <p><a href="https://forum.rebol.info/t/why-theres-no-boolean-type-storable-in-a-block/2095/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/why-theres-no-boolean-type-storable-in-a-block/2095/1</link>
        <pubDate>Sun, 07 Jan 2024 06:12:01 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2095-1</guid>
        <source url="https://forum.rebol.info/t/why-theres-no-boolean-type-storable-in-a-block/2095.rss">Why There&#39;s No Boolean Type Storable in a BLOCK!</source>
      </item>
  </channel>
</rss>

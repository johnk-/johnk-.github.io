<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Should sequences permit non-head SIGILs?</title>
    <link>https://rebol.metaeducation.com/t/should-sequences-permit-non-head-sigils/2309</link>
    <description>Historically I was very much opposed to SET-WORD! and GET-WORD! being in paths, because the ergonomics were bad:

    red&gt;&gt; p: to path! reduce [first [:a] first [b:]]
    == :a/b:

    &gt;&gt; type? p
    == path!

You have something that&#39;s neither a SET-PATH! nor a GET-PATH! but it has colons at the beginning and the end.  It&#39;s all kinds of confusing.

Ren-C has addressed that particular can of worms with a [full design for the CHAIN! sequence type](https://rebol.metaeducation.com/t/introducingnew-chain-datatype/2226), and rules for its nesting in PATH! (and how TUPLE! nests in it).  So you can get these weird looking structures, but they destructure unambiguously.

## As For Sigils... At The Head They Must Be Illegal

You can&#39;t put a sigil in a sequence head position, because that would be ambiguous with wanting to apply the sigil to the path as a whole.

    &gt;&gt; to path! [$foo bar]
    ** Error: This needs to be an error

The only way to allow it would be if we invented [some kind of lexical escaping](https://rebol.metaeducation.com/t/what-is-a-path-or-a-quasi-word/2292/2?u=hostilefork) so we could tell the difference between $|foo/bar| and $|foo|/bar ... ***and I do not want lexical escaping of this kind***.

## But Sigils At Non-Head Positions... Maybe?  :roll_eyes: 

There&#39;s no fundamental reason why sigils couldn&#39;t be on non-head positions in sequences.  It works.

    &gt;&gt; $a:$b
    == a:$b  ; bound

Part of me says *&quot;ugh, no, it makes everything uglier, don&#39;t let people make these ugly things!&quot;*

But one very compelling reason just for the above syntax is what I&#39;ve called &quot;dialecting function calls&quot;, such as for pointing the blame to a callsite with a FAIL.

So instead of:

    my-api: func [x y z] [
        if true [
            if y &lt; 100 [
                fail:blame [&quot;Value must be &gt;= 100, not&quot; y] $y
            ]
         ]
     ]

You could write:

    my-api: func [x y z] [
        if true [
            if y &lt; 100 [
                fail:$y [&quot;Value must be &gt;= 100, not&quot; y]
            ]
         ]
     ]

When you look at it like that, it&#39;s hardly a monstrosity.  It&#39;s letting you push the variable to blame into the chain for invoking the function, in a way that&#39;s out-of-band with other refinements.

It could offer a cheaper way of asking to fetch variables, using @ to take the place of the old &quot;get word&quot; concept:

    &gt;&gt; block: [index offset pointer]
    &gt;&gt; index: 3

    &gt;&gt; block.index
    == offset

    &gt;&gt; block.(index)
    == pointer

    &gt;&gt; block.@index
    == pointer

It&#39;s measurably less expensive (no array allocation, cheaper to naviate to on fetch).  It doesn&#39;t use a GROUP! so it doesn&#39;t get in the way of COMPOSE-ing.

## Think I Have To Allow It...

I&#39;d originally thought that it would be cleaner to disallow it.  But seems to me there are too many interesting uses.

As a medium, Rebol is very free, and you have a lot of power to make hideous things.  So it&#39;s about using your judgment, and I think people should know when it&#39;s getting too crazy.

---

## I Almost Hate To Point It Out, But...

This is true of quotes as well.

    &gt;&gt; &#39;a:&#39;&#39;b:&#39;&#39;&#39;c
    == a:&#39;&#39;b:&#39;&#39;&#39;c

There&#39;s an unambiguous way of interpreting that.

    &gt;&gt; quote to chain! [a &#39;&#39;b &#39;&#39;&#39;c]
    == &#39;a:&#39;&#39;b:&#39;&#39;&#39;c

I don&#39;t love it, but, maybe there&#39;s cases where **`foo:&#39;bar`** would be useful in a dialect, and if it&#39;s mechanically consistent I shouldn&#39;t prohibit it.  :man_shrugging:  I don&#39;t know.</description>
    
    <lastBuildDate>Mon, 19 May 2025 23:23:35 +0000</lastBuildDate>
    <category>Lexer</category>
    <atom:link href="https://rebol.metaeducation.com/t/should-sequences-permit-non-head-sigils/2309.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Should sequences permit non-head SIGILs?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2309">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">obj.^value

^obj.value

^obj.^value
</code></pre>
<p>At each step, you have the opportunity to say "this thing is a variable that is meta-represented".</p>
<p>It seems pretty clear this means the meta-mark needs to be inside the slot, not outside on the tuple itself</p>
</blockquote>
</aside>
<p>So this isn't actually all that clear.  There are some competing interests.</p>
<p>Let's say that <strong>$foo.bar</strong> is not a TIED! tuple, but just a TUPLE!. with a tied word in its first slot.</p>
<pre><code>&gt;&gt; to block! '$foo.bar
== [$foo bar]
</code></pre>
<p>Yes... we can make the evaluator behavior of such things come back as bound:</p>
<pre><code>&gt;&gt; $foo.bar
== foo.bar  ; bound
</code></pre>
<p>That can be done with magic, and the magic can make it efficient.  The Sigil can be living in the cell memory of the TUPLE! itself, but not report itself there...rather report itself projected onto the first element.  Hence <code>$foo.bar</code> and <code>foo.bar</code> can use the same underlying memory of <strong><code>[foo bar]</code></strong> even if it gives the impression that the two would convert into arrays differently.</p>
<p><strong>But this puts a burden on dialects to reimplement that magic.</strong></p>
<p>Let's say you are UPARSE.  And you come up with a feature that if you say <strong><code>@var</code></strong> instead of <strong><code>var</code></strong> then the @ means you want to match items literally.</p>
<pre><code>&gt;&gt; var: [some "a"]

&gt;&gt; parse "aaa" [var]
== "a"

&gt;&gt; parse [[some "a"]] [@var]
== [some "a"]
</code></pre>
<p>Works great.  You implement this as the behavior for your PINNED! type.</p>
<p>But then, you want it to work for tuples, too:</p>
<pre><code>&gt;&gt; obj: make object! [var: [some "a"]]

&gt;&gt; parse "aaa" [obj.var]
== "a"

&gt;&gt; parse [[some "a"]] [@obj.var]
== [some "a"]
</code></pre>
<p>But now <code>@obj.var</code> is not a PINNED!.  It's a TUPLE!.</p>
<p>One might argue that you're looking at it wrong, and if this comes up you should use a PINNED!-GROUP!</p>
<pre><code>&gt;&gt; parse [[some "a"]] [@(obj.var)]
== [some "a"]
</code></pre>
<p>But I don't want to have to use GROUP!s for this.  It's too common a case to make it laborious, and that applies to things like ties too... e.g. <strong><code>($ 'a.b)</code></strong> is significantly more annoying than <strong><code>$a.b</code></strong> and you want to do that commonly.</p>
<h2><a name="p-8319-could-it-be-that-lifts-pins-and-ties-are-different-1" class="anchor" href="https://rebol.metaeducation.com#p-8319-could-it-be-that-lifts-pins-and-ties-are-different-1"></a>Could It Be That Lifts, Pins, and Ties Are Different?</h2>
<p>It could be that mechanically, lifts just belong inside sequences, because in the evaluator they serve no purpose operating on the whole of an expression.</p>
<p>But I'm skeptical of making this mechanical variance.  The easier variance seems to be that if you get a lifted TUPLE!, you elect to run it through the normal tuple mechanics.</p>
<p><strong>Really this is all subjective.</strong>  If a dialect wants to interpret things as inside or outside that's their prerogative.</p>
<p>Optimization favors putting the Sigil on the outside.  This way <strong><code>^x:</code></strong> fits in a single cell, and there's no "magic" required to transform <strong><code>$a.b</code></strong> =&gt; <strong><code>a.b</code></strong>.</p>
<p>I think lifting in the evaluator has to be the oddball, making ties and pins work normally.  If your dialect wants to have similar behavior, just do the same thing for lifted things that you do with non-lifted things.  Functions like GET and SET will be stylized to accommodate this, so that if you pass them lifted tuples it will treat them <em>as if</em> the lift were on the first item in the tuple.</p>
<p><strong>This means Sigils on first elements of sequences will be mechanically illegal.</strong></p>
          <p><a href="https://rebol.metaeducation.com/t/should-sequences-permit-non-head-sigils/2309/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/should-sequences-permit-non-head-sigils/2309/3</link>
        <pubDate>Mon, 19 May 2025 23:16:09 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2309-3</guid>
        <source url="https://rebol.metaeducation.com/t/should-sequences-permit-non-head-sigils/2309.rss">Should sequences permit non-head SIGILs?</source>
      </item>
      <item>
        <title>Should sequences permit non-head SIGILs?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="2309">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>Think I Have To Allow [non-head SIGILs]</strong></p>
<p>I'd originally thought that it would be cleaner to disallow it. But seems to me there are too many interesting uses.</p>
</blockquote>
</aside>
<p>A major realization about the nature of what <strong>^META</strong>-WORD!s should <em>actually</em> be doing has made it fully necessary to rethink things.</p>
<p>Initially I thought that <strong><code>^foo</code></strong> should be a synonym for <strong>(lift get:any $foo)</strong>.  It was a <em>meta-word</em> after all... so the result of evaluating it should produce a <em>meta-state</em> (quasiform or quoted).</p>
<p>...Right...?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/confused.png?v=14" title=":confused:" class="emoji" alt=":confused:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8202-wrong-1" class="anchor" href="https://rebol.metaeducation.com#p-8202-wrong-1"></a>Wrong!</h2>
<p>The <em>far</em> more useful concept is to think of it as saying <em>"foo is a variable that utilizes meta-representation"</em>.  e.g. when something is written to it, then that thing should be lift-on-write.</p>
<p>And then the complement to that should be <strong>unlift-on-read</strong>.</p>
<p>There was already an inkling of this, with assignments in the SET-BLOCK! implementation:</p>
<pre><code>&gt;&gt; [^foo' bar]: pack [pack [a b] pack [10 20]]
; first in pack of 2 items
== ~['a 'b]~

&gt;&gt; foo'
== ~['a 'b]~

&gt;&gt; bar
== 10
</code></pre>
<p>But if you're going to have a "meta-read" operation, the most useful thing is to think of it as <em>"read-meta"</em> and reconstitute the antiform:</p>
<pre><code>&gt;&gt; ^foo'
; first in pack of 2 items
== a
</code></pre>
<p>So suddenly <strong><code>^xxx:</code></strong> becomes a powerful assignment operator, writing the lift of its right-hand side into the variable.  Among the great properties it has, is that it pipes the right hand side out to the left <strong>as is</strong>... so compare:</p>
<pre><code>&gt;&gt; xxx: lift fail "assigning an error"
== &lt;&lt;quasiform error&gt;&gt;

&gt;&gt; ^xxx: fail "assigning an error"
== &lt;&lt;antiform error&gt;&gt;
</code></pre>
<p><em>Hence, you get safety from error assignments!</em> because although it did the assignment of the value lifted, the result is not lifted and you still have to have something sink that error, or it will panic!</p>
<p>We can talk about how lax it should be about decaying packs.  Maybe you need a decoration for that, like <strong><code>(^xxx.~: ...)</code></strong> to get them.  But I'm leaning to saying it's just your responsibility to say <strong><code>(^xxx: decay ...)</code></strong> if you call a multi-returning function and don't actually want its pack.</p>
<p>Now let's ask about the difference between these things:</p>
<pre><code>obj.^value

^obj.value

^obj.^value
</code></pre>
<p>At each step, you have the opportunity to say "this thing is a variable that is meta-represented".</p>
<p>It seems pretty clear this means the meta-mark needs to be inside the slot, not outside on the tuple itself:</p>
<pre><code>&gt;&gt; type of first [^obj.^value]
== ~{tuple!}~  ; anti

&gt;&gt; type of first first [^obj.^value]
== ~{meta-word!}~  ; anti

&gt;&gt; type of second first [^obj.^value]
== ~{meta-word!}~  ; anti
</code></pre>
          <p><a href="https://rebol.metaeducation.com/t/should-sequences-permit-non-head-sigils/2309/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/should-sequences-permit-non-head-sigils/2309/2</link>
        <pubDate>Mon, 05 May 2025 07:33:44 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2309-2</guid>
        <source url="https://rebol.metaeducation.com/t/should-sequences-permit-non-head-sigils/2309.rss">Should sequences permit non-head SIGILs?</source>
      </item>
      <item>
        <title>Should sequences permit non-head SIGILs?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Historically I was very much opposed to SET-WORD! and GET-WORD! being in paths, because the ergonomics were bad:</p>
<pre><code>red&gt;&gt; p: to path! reduce [first [:a] first [b:]]
== :a/b:

&gt;&gt; type? p
== path!
</code></pre>
<p>You have something that's neither a SET-PATH! nor a GET-PATH! but it has colons at the beginning and the end.  It's all kinds of confusing.</p>
<p>Ren-C has addressed that particular can of worms with a <a href="https://rebol.metaeducation.com/t/introducingnew-chain-datatype/2226">full design for the CHAIN! sequence type</a>, and rules for its nesting in PATH! (and how TUPLE! nests in it).  So you can get these weird looking structures, but they destructure unambiguously.</p>
<h2><a name="p-7831-as-for-sigils-at-the-head-they-must-be-illegal-1" class="anchor" href="https://rebol.metaeducation.com#p-7831-as-for-sigils-at-the-head-they-must-be-illegal-1"></a>As For Sigils... At The Head They Must Be Illegal</h2>
<p>You can't put a sigil in a sequence head position, because that would be ambiguous with wanting to apply the sigil to the path as a whole.</p>
<pre><code>&gt;&gt; to path! [$foo bar]
** Error: This needs to be an error
</code></pre>
<p>The only way to allow it would be if we invented <a href="https://rebol.metaeducation.com/t/what-is-a-path-or-a-quasi-word/2292/2">some kind of lexical escaping</a> so we could tell the difference between $|foo/bar| and $|foo|/bar ... <em><strong>and I do not want lexical escaping of this kind</strong></em>.</p>
<h2><a name="p-7831-but-sigils-at-non-head-positions-maybe-roll_eyes-2" class="anchor" href="https://rebol.metaeducation.com#p-7831-but-sigils-at-non-head-positions-maybe-roll_eyes-2"></a>But Sigils At Non-Head Positions... Maybe?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/roll_eyes.png?v=14" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></h2>
<p>There's no fundamental reason why sigils couldn't be on non-head positions in sequences.  It works.</p>
<pre><code>&gt;&gt; $a:$b
== a:$b  ; bound
</code></pre>
<p>Part of me says <em>"ugh, no, it makes everything uglier, don't let people make these ugly things!"</em></p>
<p>But one very compelling reason just for the above syntax is what I've called "dialecting function calls", such as for pointing the blame to a callsite with a FAIL.</p>
<p>So instead of:</p>
<pre><code>my-api: func [x y z] [
    if true [
        if y &lt; 100 [
            fail:blame ["Value must be &gt;= 100, not" y] $y
        ]
     ]
 ]
</code></pre>
<p>You could write:</p>
<pre><code>my-api: func [x y z] [
    if true [
        if y &lt; 100 [
            fail:$y ["Value must be &gt;= 100, not" y]
        ]
     ]
 ]
</code></pre>
<p>When you look at it like that, it's hardly a monstrosity.  It's letting you push the variable to blame into the chain for invoking the function, in a way that's out-of-band with other refinements.</p>
<p>It could offer a cheaper way of asking to fetch variables, using @ to take the place of the old "get word" concept:</p>
<pre><code>&gt;&gt; block: [index offset pointer]
&gt;&gt; index: 3

&gt;&gt; block.index
== offset

&gt;&gt; block.(index)
== pointer

&gt;&gt; block.@index
== pointer
</code></pre>
<p>It's measurably less expensive (no array allocation, cheaper to naviate to on fetch).  It doesn't use a GROUP! so it doesn't get in the way of COMPOSE-ing.</p>
<h2><a name="p-7831-think-i-have-to-allow-it-3" class="anchor" href="https://rebol.metaeducation.com#p-7831-think-i-have-to-allow-it-3"></a>Think I Have To Allow It...</h2>
<p>I'd originally thought that it would be cleaner to disallow it.  But seems to me there are too many interesting uses.</p>
<p>As a medium, Rebol is very free, and you have a lot of power to make hideous things.  So it's about using your judgment, and I think people should know when it's getting too crazy.</p>
<hr>
<h2><a name="p-7831-i-almost-hate-to-point-it-out-but-4" class="anchor" href="https://rebol.metaeducation.com#p-7831-i-almost-hate-to-point-it-out-but-4"></a>I Almost Hate To Point It Out, But...</h2>
<p>This is true of quotes as well.</p>
<pre><code>&gt;&gt; 'a:''b:'''c
== a:''b:'''c
</code></pre>
<p>There's an unambiguous way of interpreting that.</p>
<pre><code>&gt;&gt; quote to chain! [a ''b '''c]
== 'a:''b:'''c
</code></pre>
<p>I don't love it, but, maybe there's cases where <strong><code>foo:'bar</code></strong> would be useful in a dialect, and if it's mechanically consistent I shouldn't prohibit it.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/man_shrugging.png?v=14" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20">  I don't know.</p>
          <p><a href="https://rebol.metaeducation.com/t/should-sequences-permit-non-head-sigils/2309/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/should-sequences-permit-non-head-sigils/2309/1</link>
        <pubDate>Mon, 07 Oct 2024 19:06:08 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2309-1</guid>
        <source url="https://rebol.metaeducation.com/t/should-sequences-permit-non-head-sigils/2309.rss">Should sequences permit non-head SIGILs?</source>
      </item>
  </channel>
</rss>

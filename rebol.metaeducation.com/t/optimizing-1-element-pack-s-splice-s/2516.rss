<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Optimizing 1-Element PACK!s / SPLICE!s</title>
    <link>https://rebol.metaeducation.com/t/optimizing-1-element-pack-s-splice-s/2516</link>
    <description>Historically the most common type of PACK! is the 1-element PACK! holding a ~NULL~ antiform, that you get when a branching statement takes the branch and evaluates to null.

It&#39;s not supposed to be the case that antiforms have identity--once you make the transition from a plain form to an antiform, you lose the identity (and also, binding).

So really, every branching statement that returns a PACK!-boxed null can return the same boxed null.  Easy enough optimization--it&#39;s already done like that.

I&#39;ve proposed something strange though... [which is that putting actions in a PACK! be how they are &quot;blessed&quot; as legal to assign to plain WORD](https://rebol.metaeducation.com/t/the-grand-leading-slash-safety-or-burden-question/2352/7?u=hostilefork)

I&#39;m hopeful that can work.  But it brings up a question I&#39;ve wrangled with in the past: *is there any way to make this cheap-as-free*?

e.g. **Can a single Cell act as a proxy for an immutable array holding only itself?**

The idea was scrapped for things like BLOCK!, because you&#39;d wind up with something that had nowhere to put the index or the binding.

But when it comes to PACK! (and SPLICE!...?) the binding requirement is gone, the index requirement is gone.  If the original array was at an index and seen to be one item, you&#39;d just copy that one item out as the single Cell, and do some bit twiddling voodoo to it.

Can it work?

:thinking: 

In order to not tax the system too much on behalf of one weird optimization, it seems like you&#39;re down two bytes from the get-go: you&#39;ve got the LIFT_BYTE at ANTIFORM_0 and the KIND_BYTE at TYPE_BLOCK.

Having those two bytes chewed out, it would mean the optimization would have to be something like 64-bit only, to reclaim those two bytes from the unused 32-bits in the header (which are typically unused to allow working on 32-bit platforms).  The other 3 platform pointers may all be used, because they may all contain platform pointers.  So really 64-bit builds only have 32 bits total to exploit.

Would tailored optimizations like this be a great use of that 32-bit advantage?  (As opposed to some cross-cutting feature that presumed to take the 32-bits out of all cells to do something more awesome)?  I don&#39;t know.  :-/

Is there some other way to leave the LIFT_BYTE and KIND_BYTE retain the single concent Cell&#39;s information, and yet somehow make the answer come back as PACK! without costing too much extra?  :-(

The Cell could offer one bit for this... but it would wreck a lot of other optimizations if that bit didn&#39;t live somewhere in the LIFT_BYTE and KIND_BYTE.  The LIFT_BYTE already chews out 1 bit for quasi-ness (you can be both quoted and quasi, or quoted and non-quasi) which limits us to about 127 levels of quoting.  If another bit were sacrificed...let&#39;s just say it&#39;s the PACK!-bit... then we could say all PACK!s have this bit set, and we&#39;re cut down to 63-ish levels of quoting.

So then, if you have a regular PACK! it has the pack bit set...but when you clear the pack bit you see it&#39;s still an antiform with a heart that&#39;s a block.  And since you can&#39;t put PACK!s in packs directly (they&#39;re antiforms, they must be lifted) you know you&#39;ve got a non-optimized pack.  Otherwise, you have a Cell which is the sole content of the pack.

It might seem like a problem that if you try to give back a pointer to the Cell as the content of the array, the only Cell you have in your hand has been corrupted with this pack bit.  So you index into the PACK! to find something that we&#39;ve established acts as a PACK!.  However...this issue has already been solved for sequences, by an abstraction layer called **&quot;Arraylike&quot;**.  When you have an arraylike thing, you don&#39;t ask it for direct addresses of cells to operate on, you give it an index and ask it to fill a temporary Cell with the bits of what&#39;s at that index.  So this would be one of those things.

**Even if it could be done, this still runs afoul of a lot of the fingerprinting ideas that mask the two bytes in the header to determine its makeup.**  :fingerprint: 

## Just a Placeholder For Any More Thoughts

It&#39;s something to keep in mind, but more important to make sure the designs solve the problems, first.

I&#39;m cautiously optimistic about using PACK!&#39;d actions as the &quot;approval&quot; tool to do plain WORD!-assignment, but haven&#39;t done it yet, so don&#39;t know if it will actually be a good answer.</description>
    
    <lastBuildDate>Fri, 25 Jul 2025 17:41:50 +0000</lastBuildDate>
    <category>Optimization</category>
    <atom:link href="https://rebol.metaeducation.com/t/optimizing-1-element-pack-s-splice-s/2516.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Optimizing 1-Element PACK!s / SPLICE!s</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Historically the most common type of PACK! is the 1-element PACK! holding a ~NULL~ antiform, that you get when a branching statement takes the branch and evaluates to null.</p>
<p>It's not supposed to be the case that antiforms have identity--once you make the transition from a plain form to an antiform, you lose the identity (and also, binding).</p>
<p>So really, every branching statement that returns a PACK!-boxed null can return the same boxed null.  Easy enough optimization--it's already done like that.</p>
<p>I've proposed something strange though... <a href="https://rebol.metaeducation.com/t/the-grand-leading-slash-safety-or-burden-question/2352/7">which is that putting actions in a PACK! be how they are "blessed" as legal to assign to plain WORD</a></p>
<p>I'm hopeful that can work.  But it brings up a question I've wrangled with in the past: <em>is there any way to make this cheap-as-free</em>?</p>
<p>e.g. <strong>Can a single Cell act as a proxy for an immutable array holding only itself?</strong></p>
<p>The idea was scrapped for things like BLOCK!, because you'd wind up with something that had nowhere to put the index or the binding.</p>
<p>But when it comes to PACK! (and SPLICE!...?) the binding requirement is gone, the index requirement is gone.  If the original array was at an index and seen to be one item, you'd just copy that one item out as the single Cell, and do some bit twiddling voodoo to it.</p>
<p>Can it work?</p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>In order to not tax the system too much on behalf of one weird optimization, it seems like you're down two bytes from the get-go: you've got the LIFT_BYTE at ANTIFORM_0 and the KIND_BYTE at TYPE_BLOCK.</p>
<p>Having those two bytes chewed out, it would mean the optimization would have to be something like 64-bit only, to reclaim those two bytes from the unused 32-bits in the header (which are typically unused to allow working on 32-bit platforms).  The other 3 platform pointers may all be used, because they may all contain platform pointers.  So really 64-bit builds only have 32 bits total to exploit.</p>
<p>Would tailored optimizations like this be a great use of that 32-bit advantage?  (As opposed to some cross-cutting feature that presumed to take the 32-bits out of all cells to do something more awesome)?  I don't know.  :-/</p>
<p>Is there some other way to leave the LIFT_BYTE and KIND_BYTE retain the single concent Cell's information, and yet somehow make the answer come back as PACK! without costing too much extra?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>The Cell could offer one bit for this... but it would wreck a lot of other optimizations if that bit didn't live somewhere in the LIFT_BYTE and KIND_BYTE.  The LIFT_BYTE already chews out 1 bit for quasi-ness (you can be both quoted and quasi, or quoted and non-quasi) which limits us to about 127 levels of quoting.  If another bit were sacrificed...let's just say it's the PACK!-bit... then we could say all PACK!s have this bit set, and we're cut down to 63-ish levels of quoting.</p>
<p>So then, if you have a regular PACK! it has the pack bit set...but when you clear the pack bit you see it's still an antiform with a heart that's a block.  And since you can't put PACK!s in packs directly (they're antiforms, they must be lifted) you know you've got a non-optimized pack.  Otherwise, you have a Cell which is the sole content of the pack.</p>
<p>It might seem like a problem that if you try to give back a pointer to the Cell as the content of the array, the only Cell you have in your hand has been corrupted with this pack bit.  So you index into the PACK! to find something that we've established acts as a PACK!.  However...this issue has already been solved for sequences, by an abstraction layer called <strong>"Arraylike"</strong>.  When you have an arraylike thing, you don't ask it for direct addresses of cells to operate on, you give it an index and ask it to fill a temporary Cell with the bits of what's at that index.  So this would be one of those things.</p>
<p><strong>Even if it could be done, this still runs afoul of a lot of the fingerprinting ideas that mask the two bytes in the header to determine its makeup.</strong>  <img src="https://rebol.metaeducation.com/images/emoji/twitter/fingerprint.png?v=14" title=":fingerprint:" class="emoji" alt=":fingerprint:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8557-just-a-placeholder-for-any-more-thoughts-1" class="anchor" href="https://rebol.metaeducation.com#p-8557-just-a-placeholder-for-any-more-thoughts-1"></a>Just a Placeholder For Any More Thoughts</h2>
<p>It's something to keep in mind, but more important to make sure the designs solve the problems, first.</p>
<p>I'm cautiously optimistic about using PACK!'d actions as the "approval" tool to do plain WORD!-assignment, but haven't done it yet, so don't know if it will actually be a good answer.</p>
          <p><a href="https://rebol.metaeducation.com/t/optimizing-1-element-pack-s-splice-s/2516/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/optimizing-1-element-pack-s-splice-s/2516/1</link>
        <pubDate>Fri, 25 Jul 2025 17:41:50 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2516-1</guid>
        <source url="https://rebol.metaeducation.com/t/optimizing-1-element-pack-s-splice-s/2516.rss">Optimizing 1-Element PACK!s / SPLICE!s</source>
      </item>
  </channel>
</rss>

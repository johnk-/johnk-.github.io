<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Shorter way to say TO WORD! TYPE OF ?</title>
    <link>https://rebol.metaeducation.com/t/shorter-way-to-say-to-word-type-of/2385</link>
    <description>Since [datatypes are now antiforms](https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324/3?u=hostilefork), you can&#39;t MOLD them.

MOLD is reserved for things that can be array elements.  And the exceptions are put to good use. For instance molding a splice gives you the list without delimiters:

    &gt;&gt; mold [a b c]
    == &quot;[a b c]&quot;

    &gt;&gt; mold spread [a b c]
    == &quot;a b c&quot;

And molding a void gives you null back:

    &gt;&gt; mold fourth of [a b c]
    ** Error: Can&#39;t mold ~null~ antiform

    &gt;&gt; mold maybe fourth of [a b c]
    == ~null~  ; anti

I would not be a fan of arbitrarily giving people an answer that they might want just because they&#39;re used to using mold for it:

    &gt;&gt; type of 1020
    == ~{integer!}~  ; anti
 
    &gt;&gt; mold type of 1020
    == &quot;integer!&quot;  ; no!

So we&#39;re stuck with a different way of saying this, which is a bit verbose:

    &gt;&gt; to word! type of 10
    == integer!

It&#39;s not *that* laborious but it seems it could have an abbreviated form.  My first thought was just to do as history does, paralleling TYPE?/WORD

    &gt;&gt; type-of:word 10
    == integer!

    &gt;&gt; type:word of 10
    == integer!

But I wondered if that might be &quot;unchained&quot; to get rid of the colon somehow:

    &gt;&gt; typeword of 10  ; hrrrm, no.
    == integer! 

    &gt;&gt; typename of 10
    == integer!

I don&#39;t think TYPENAME *looks* bad, but it sounds like something you&#39;d apply to a datatype... not a value whose type you are requesting, I&#39;d be less surprised if it acted like:

    &gt;&gt; typename of integer!
    == &quot;integer!&quot;

## MOLD TYPE OF =&gt; TO WORD! TYPE OF for now...

I&#39;d like something shorter, but that&#39;s something I think is pretty much guaranteed to be working from here on out.

I&#39;m using TO WORD! instead of TO TEXT! because it&#39;s cheaper (doesn&#39;t have to make a copy) and many of the contexts I&#39;m in are merging strings.

(To point out that it&#39;s cheaper, I could use AS WORD!, though that exposes an implementation detail that the type is available as a pre-existing word.)</description>
    
    <lastBuildDate>Tue, 25 Mar 2025 21:17:41 +0000</lastBuildDate>
    <category>Naming</category>
    <atom:link href="https://rebol.metaeducation.com/t/shorter-way-to-say-to-word-type-of/2385.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Shorter way to say TO WORD! TYPE OF ?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Since <a href="https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324/3">datatypes are now antiforms</a>, you can't MOLD them.</p>
<p>MOLD is reserved for things that can be array elements.  And the exceptions are put to good use. For instance molding a splice gives you the list without delimiters:</p>
<pre><code>&gt;&gt; mold [a b c]
== "[a b c]"

&gt;&gt; mold spread [a b c]
== "a b c"
</code></pre>
<p>And molding a void gives you null back:</p>
<pre><code>&gt;&gt; mold fourth of [a b c]
** Error: Can't mold ~null~ antiform

&gt;&gt; mold maybe fourth of [a b c]
== ~null~  ; anti
</code></pre>
<p>I would not be a fan of arbitrarily giving people an answer that they might want just because they're used to using mold for it:</p>
<pre><code>&gt;&gt; type of 1020
== ~{integer!}~  ; anti

&gt;&gt; mold type of 1020
== "integer!"  ; no!
</code></pre>
<p>So we're stuck with a different way of saying this, which is a bit verbose:</p>
<pre><code>&gt;&gt; to word! type of 10
== integer!
</code></pre>
<p>It's not <em>that</em> laborious but it seems it could have an abbreviated form.  My first thought was just to do as history does, paralleling TYPE?/WORD</p>
<pre><code>&gt;&gt; type-of:word 10
== integer!

&gt;&gt; type:word of 10
== integer!
</code></pre>
<p>But I wondered if that might be "unchained" to get rid of the colon somehow:</p>
<pre><code>&gt;&gt; typeword of 10  ; hrrrm, no.
== integer! 

&gt;&gt; typename of 10
== integer!
</code></pre>
<p>I don't think TYPENAME <em>looks</em> bad, but it sounds like something you'd apply to a datatype... not a value whose type you are requesting, I'd be less surprised if it acted like:</p>
<pre><code>&gt;&gt; typename of integer!
== "integer!"
</code></pre>
<h2><a name="p-8078-mold-type-of-to-word-type-of-for-now-1" class="anchor" href="https://rebol.metaeducation.com#p-8078-mold-type-of-to-word-type-of-for-now-1"></a>MOLD TYPE OF =&gt; TO WORD! TYPE OF for now...</h2>
<p>I'd like something shorter, but that's something I think is pretty much guaranteed to be working from here on out.</p>
<p>I'm using TO WORD! instead of TO TEXT! because it's cheaper (doesn't have to make a copy) and many of the contexts I'm in are merging strings.</p>
<p>(To point out that it's cheaper, I could use AS WORD!, though that exposes an implementation detail that the type is available as a pre-existing word.)</p>
          <p><a href="https://rebol.metaeducation.com/t/shorter-way-to-say-to-word-type-of/2385/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/shorter-way-to-say-to-word-type-of/2385/1</link>
        <pubDate>Tue, 25 Mar 2025 20:09:26 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2385-1</guid>
        <source url="https://rebol.metaeducation.com/t/shorter-way-to-say-to-word-type-of/2385.rss">Shorter way to say TO WORD! TYPE OF ?</source>
      </item>
  </channel>
</rss>

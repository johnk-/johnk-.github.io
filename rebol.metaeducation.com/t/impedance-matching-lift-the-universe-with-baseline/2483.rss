<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Impedance Matching LIFT The Universe With Baseline</title>
    <link>https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483</link>
    <description>&lt;sub&gt;*(Sorry for the EE term.  If you&#39;re unfamiliar: [Impedance Matching](https://en.wikipedia.org/wiki/Impedance_matching))*&lt;/sub&gt;

---

A while back I realized that it&#39;s best if OBJECT!s, MODULE!s, LET!s, etc. store their contents in lifted representation.

...or rather... they store &quot;historically normal&quot; values in lifted representation (QUASIFORM! and QUOTED!).  The unlifted band would then be used for special signals.

### One Example: Unlifted TRASH! would denote *true unsetness*...

*And the term actually now fits.*  e.g. a state of absence of value, beneath the layer of what you could accomplish with SET.

With SET, you can only get &quot;trashed&quot; values:

    &gt;&gt; x: ~
    == \~\ antiform (trash!) &quot;tripwire&quot;

    &gt;&gt; trashed? $x
    == \~null~\  ; antiform  &lt;-- it&#39;s trashed, all right...

    &gt;&gt; unset? $x
    == \~null~\  ; antiform   &lt;-- but it&#39;s SET to TRASH!, it&#39;s NOT &quot;unset&quot;! 

However, special tools and special cases would go *beneath* SET.

    &gt;&gt; tweak $x ~   ; tweak doesn&#39;t do the implicit LIFT that SET does...
    
    &gt;&gt; unset? $x
    == \~okay~\  ; antiform

There will be shorthands for that like (unset $x).  But also, you get this &quot;unset&quot; state as the default states in MAKE FRAME!:

    &gt;&gt; f: make frame! negate/

    &gt;&gt; unset? $f.number
    == \~okay~\  ; antiform  &lt;-- actually unspecialized, not specialized to trash!

This brings the long hoped-for distinction between unspecialized values, and values that are purposefully trash!  And what was fretted over as being a &quot;hidden bit&quot; is anything but... it&#39;s just one &quot;out-of-band&quot; operator away.

e.g. Note that if you use TWEAK with a lifted value, that&#39;s just like SET:

    &gt;&gt; tweak $x lift ~  ; synonym for (set $x ~)

    &gt;&gt; unset? $x
    == \~null~\  ; antiform

    &gt;&gt; trashed? $x
    == \~okay~\  ; antiform

[quote=&quot;rebolbot, post:3, topic:2477&quot;]
*&quot;You’re designing the kind of system that can actually scale symbolic transformation, structured programming, and coherent meta-programming—because you’ve built in a substrate that encodes the ambiguity, instead of trying to erase it.&quot;*
[/quote]

## That&#39;s Just One Example...

It&#39;s the gateway to SETTER and GETTER functions [(actually desired by Carl... or setters at least... but he didn&#39;t know how to do &#39;em)](http://www.rebol.net/r3blogs/0019.html)
    
And for stylized setters/getters that do specific things (like type checking) there can be specially understood representations in the unlifted band.

Vocabulary term: I call the multiplexing of lifted and unlifted values together **&quot;DUAL REPRESENTATION&quot;**

## All Of It Is Powered By Common GET and SET Code

This wouldn&#39;t work if random places in the code ran off and inspected fields of OBJECT!s literally.

You have to go through some common path.  Otherwise you wind up with some callsites honoring the generalized conventions and others not.

It&#39;s kind of like how random code in R3-Alpha would ignore the PROTECT status of variables.  Ren-C has fought hard long and hard to nail that kind of thing down, and make sure at compile-time that you can be certain the checks aren&#39;t being skipped.

Piping everything through common GET and SET code paths ensures that as features like type checks or accessors are added, you don&#39;t have rogue code that doesn&#39;t honor the convention.

**It&#39;s been challenging to do this--and right now it&#39;s messy and slow--but the commonality means it&#39;s worth it to invest in optimizations for that one true path.  And Ren-C has plenty of optimization tools at its disposal, which have been evolving over the years... &lt;sub&gt;for when the timing is right...&lt;/sub&gt;**

## But What About Normal, Boring, Context-Building Code?

Here&#39;s an example, just the one on my screen right now.

It&#39;s some random code out of the POSIX CALL implementation, related to... forking processes or something:

    if (Bool_ARG(INFO)) {
        VarList* info = Alloc_Varlist(TYPE_OBJECT, 2);

        Init_Integer(Append_Context(info, CANON(ID)), forked_pid);
        if (Bool_ARG(WAIT))
            Init_Integer(Append_Context(info, CANON(EXIT_CODE)), exit_code);

        return Init_Object(OUT, info);
    }

Dumb, simple code making an OBJECT! with 2 fields in it, appending those fields (which default to an erased state you have to fill in to be correct code), and then setting the erased cells to mundane values.

If I were to go lockstep through code that looked like this and change it for lifting to appease the common GET and SET code, it would start looking like:

    if (Bool_ARG(INFO)) {
        VarList* info = Alloc_Varlist(TYPE_OBJECT, 2);

        Liftify(  // &lt;-- new wart
            Init_Integer(Append_Context(info, CANON(ID)), forked_pid)
        );
        if (Bool_ARG(WAIT))
            Liftify(  // &lt;-- new wart
                Init_Integer(Append_Context(info, CANON(EXIT_CODE)), exit_code)
            );

        return Init_Object(OUT, info);
    }

Liftify adds 2 to the LIFT_BYTE.  ([Review LIFT_BYTE if you want an introduction to that.](https://rebol.metaeducation.com/t/lift-byte-values-antiform-normal-quasi-quoted/2091))

Liftify also has to check for overflow (e.g. that you&#39;re not going past 255 for the LIFT_BYTE value).  Maybe the optimizer can figure out it doesn&#39;t need that check here?  Though I try not to rely on the optimizer too much...

## This Parallels The &quot;Too Many **`^`**&quot; Of Usermode Code

My observation in **[LIFT the UNIVERSE](https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477)** was that usermode code was becoming contaminated with lifts in places that weren&#39;t really the concern of that code.  *(That&#39;s why the robots are celebrating, they&#39;re throwing carets in the trashcan...)*

![assets_task_01jx3y0xmyfc79dwb24jd57b49_1749257658_img_3|690x460, 50%](upload://yrQc5xkNpeTlSSrOOswU5OsMelz.webp)

**Here we&#39;re seeing the C code having some of the same problem as having the carets, manifest as calls to `Liftify()`.**  It&#39;s getting uglier, and spreading that ugliness around.

## Should A **`CELL_FLAG_DUAL`** Be Sacrificed For This?

I don&#39;t like wasting the very few CELL_FLAG_XXX.  But over time, silly ones have been freed up to give us some wiggle room (e.g. the [now-completely superfluous CELL_FLAG_FALSEY]()).

And maybe this is a really good case where it could be of help to sacrifice one.  Since all the GET and SET that&#39;s *not* this kind of stuff is running through centralized code...it could be tolerant of cells in contexts that *weren&#39;t* initialized with CELL_FLAG_DUAL, and just know that those are to be taken literally.

It complicates things a little bit in that one *&quot;big, beautiful code path&quot;*.  But as a caller of TWEAK or GET and SET you&#39;re insulated from the complication.  It&#39;s a black box... maybe the cell has `CELL_FLAG_DUAL` and maybe it doesn&#39;t, you&#39;ll never know.

## Just Have To Catch Confusions Before They Happen...

Probably best is just to throw in some asserts if you somehow start running through code paths that don&#39;t use the common GET somehow, and make sure `Type_Of()` and `Quotes_Of()` etc will assert on anything that has CELL_FLAG_DUAL.

I&#39;m not sure how many legitimate codepaths there will be that duck the legitimate GET, but there are some reasonable cases (such as the code I give above) that are just doing a simple construction and probably don&#39;t need to be more complicated than they already are.

## Will It Slow Things Down?

I posted this under Optimization because it&#39;s trading off some runtime code to make the C code more tolerable.

But rest assured, this is not the flag test that will be the bottleneck of the system.  :-)

*(Compared to naive Liftify() everywhere, it probably breaks at least even for not having to do the overflow checking of the LIFT_BYTE.)*</description>
    
    <lastBuildDate>Wed, 25 Jun 2025 08:01:46 +0000</lastBuildDate>
    <category>Optimization</category>
    <atom:link href="https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Impedance Matching LIFT The Universe With Baseline</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2483">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Since we can pick anything that's not an antiform, quasiform, or quoted... a WORD! could be good...but a special-looking one, like <strong><code>*unset*</code></strong> could draw attention:</p>
<p><code>[a b c]: anti [~null~ *unset* '10]</code></p>
</blockquote>
</aside>
<p>I observed to <a class="mention" href="https://rebol.metaeducation.com/u/blackattr">@BlackATTR</a>:</p>
<p><em>"Kind of funny, Ren-C was all about 'unset shouldn't be conflated with words!' ...and... 'true and false shouldn't be conflated with words!' ... then the ultimate answer is 'well, they <em>are</em> represented with words... but just in a different concept and contextualization...'</em></p>
<p><em>"What makes the <code>*unset*</code> WORD! suitable to be the representation of unset is only when everything around it <strong>can't</strong> be a WORD!... so it stands out by being a word where the other things aren't, because they are lifted..."</em></p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/scientist.png?v=14" title=":scientist:" class="emoji only-emoji" alt=":scientist:" loading="lazy" width="20" height="20"> <img src="https://rebol.metaeducation.com/images/emoji/twitter/atom_symbol.png?v=14" title=":atom_symbol:" class="emoji only-emoji" alt=":atom_symbol:" loading="lazy" width="20" height="20"></p>
          <p><a href="https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483/6">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483/6</link>
        <pubDate>Wed, 25 Jun 2025 08:01:46 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2483-6</guid>
        <source url="https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483.rss">Impedance Matching LIFT The Universe With Baseline</source>
      </item>
      <item>
        <title>Impedance Matching LIFT The Universe With Baseline</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2483">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Natives rely on the idea that their arguments in the FRAME! are not abstracted, so they don't worry about SETTERS or GETTERS etc.</p>
<p>They use a macro called <code>ARG()</code> to get at their arguments, and (currently) expect that argument to be in non-DUAL format.</p>
<p><em><strong>This does suggest that non-DUAL arguments should be stored in an "as-is" state, with the twist that it doesn't set <code>CELL_FLAG_SLOT_HINT_DUAL</code>.</strong></em></p>
</blockquote>
</aside>
<p>It occurs to me that we're paying for an entire flag, for something that is simply a base state.</p>
<h2><a name="p-8457-so-why-isnt-the-dual-state-a-lift_byte-of-0httpsrebolmetaeducationcomtlift-byte-values-antiform-normal-quasi-quoted2091-1" class="anchor" href="https://rebol.metaeducation.com#p-8457-so-why-isnt-the-dual-state-a-lift_byte-of-0httpsrebolmetaeducationcomtlift-byte-values-antiform-normal-quasi-quoted2091-1"></a>...So why isn't the dual state a <a href="https://rebol.metaeducation.com/t/lift-byte-values-antiform-normal-quasi-quoted/2091">LIFT_BYTE() of 0</a>?</h2>
<p>If all DUAL states were required to be plain and not antiform, it would bump everything up by one:</p>
<pre><code>DUAL_0
ANTIFORM_1
NOQUOTE_2
QUASIFORM_3
ONEQUOTE_NONQUASI_4
ONEQUOTE_QUASI_5
...
</code></pre>
<p>The limitation of only having plain states for duals has one positive implication, which is that they can theoretically be represented in PACKs, and you could arguably use PACK to assign them.  Because PACK nominally represents everything inside it as either quasiform or quoted, the only thing left you can put in blocks and not conflict are plain things...</p>
<p>I spoke about SPACE as being the unset state, for instance:</p>
<pre><code>[a b c]: anti [~null~ _ '10]
</code></pre>
<p>Though that's a bit opaque.  Since we can pick anything that's not an antiform, quasiform, or quoted... a WORD! could be good...but a special-looking one, like <strong><code>*unset*</code></strong> could draw attention:</p>
<pre><code>[a b c]: anti [~null~ *unset* '10]
</code></pre>
<p><strong>The limitation of saying that the dual states can't be antiforms seems like it has more benefits than drawbacks.</strong></p>
<p>This is more uniform, and more economical.  It should be able to put "Slot" (as in Object's VarList Slot) beneath "Atom" in the same <a href="https://rebol.metaeducation.com/t/antiform-safety-covariance-and-contravariance/2330">contravariance pattern</a> so if you know a Slot is safe you can just cast it and use the memory directly.</p>
<p>Pretty wild!</p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/joker.png?v=14" title=":joker:" class="emoji only-emoji" alt=":joker:" loading="lazy" width="20" height="20"> <img src="https://rebol.metaeducation.com/images/emoji/twitter/joker.png?v=14" title=":joker:" class="emoji only-emoji" alt=":joker:" loading="lazy" width="20" height="20"> <img src="https://rebol.metaeducation.com/images/emoji/twitter/joker.png?v=14" title=":joker:" class="emoji only-emoji" alt=":joker:" loading="lazy" width="20" height="20"></p>
          <p><a href="https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483/5">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483/5</link>
        <pubDate>Tue, 24 Jun 2025 19:59:59 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2483-5</guid>
        <source url="https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483.rss">Impedance Matching LIFT The Universe With Baseline</source>
      </item>
      <item>
        <title>Impedance Matching LIFT The Universe With Baseline</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2483">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Natives rely on the idea that their arguments in the FRAME! are not abstracted, so they don't worry about SETTERS or GETTERS etc.</p>
</blockquote>
</aside>
<p><strong>This assumption creates some limits...</strong></p>
<p>For instance, imagine you do this:</p>
<pre><code>ap10: specialize append/ [value: getter [print "GETTING!" 5 + 5]]
</code></pre>
<p>If APPEND is native code and doesn't run through common behaviors for GET and SET, but works on the Cell directly, this can't work.</p>
<p>I wouldn't want a limitation like "no getters or setters as frame fields"... that's lame.</p>
<p>So I don't see that big of a problem if the code which does the "flattening" of lifted forms with CELL_FLAG_DUAL (into an unlifted form without the flag) just errors if it gets down to the point of native execution.  So if you do something like this in usermode frames or higher-level wrappers, you have to undo it before you get to native code execution.</p>
<p>Making native code honor setters/getters on their own adapted frames would complicate things significantly for a fringe feature that would kind of unmoor the debugging situation completely.</p>
<h1><a name="p-8405-wait-stop_sign-just-do-one-get-of-the-accessor-1" class="anchor" href="https://rebol.metaeducation.com#p-8405-wait-stop_sign-just-do-one-get-of-the-accessor-1"></a>Wait <img src="https://rebol.metaeducation.com/images/emoji/twitter/stop_sign.png?v=14" title=":stop_sign:" class="emoji" alt=":stop_sign:" loading="lazy" width="20" height="20"> Just Do One GET of The Accessor</h1>
<p>...hold up.</p>
<p>Given that you're handing over this FRAME! to the native to do whatever it will do, and the fields "belong to it" after the handoff... why not just turn any accessor into its last GET?</p>
<p>You'd have no way of knowing if it read all the fields, made a copy, and operated on the copy.  So it could just act like that.</p>
<p>I think this isn't really a problem after all.  You know you lose control once the native runs.  So, it's not beholden to any contracts on any of the fields.  While it might reuse them mechanically for space reasons, that's not your business.</p>
          <p><a href="https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483/4</link>
        <pubDate>Mon, 09 Jun 2025 18:03:48 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2483-4</guid>
        <source url="https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483.rss">Impedance Matching LIFT The Universe With Baseline</source>
      </item>
      <item>
        <title>Impedance Matching LIFT The Universe With Baseline</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <h2><a name="p-8404-not-carrying-cell_flag_dual-is-actually-critical-1" class="anchor" href="https://rebol.metaeducation.com#p-8404-not-carrying-cell_flag_dual-is-actually-critical-1"></a>Not Carrying CELL_FLAG_DUAL Is Actually Critical</h2>
<p>I realized one real performance issue things bump up against <strong>is the impact on native functions.</strong></p>
<p>Natives rely on the idea that their arguments in the FRAME! are not abstracted, so they don't worry about SETTERS or GETTERS etc.</p>
<p>They use a macro called <code>ARG()</code> to get at their arguments, and (currently) expect that argument to be in non-DUAL format.</p>
<p><em><strong>This does suggest that non-DUAL arguments should be stored in an "as-is" state, with the twist that it doesn't set <code>CELL_FLAG_SLOT_HINT_DUAL</code>.</strong></em></p>
<p>That is to say, it's an implementation detail.  The slot is still conceptually "lifted", but for the convenience of the natives it has a flag missing... the flag that instructs GET that it's not actually an unlifted dual state, and SET that it can completely overwrite it without worrying that it's a SETTER-like thing.</p>
          <p><a href="https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483/3</link>
        <pubDate>Mon, 09 Jun 2025 17:48:48 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2483-3</guid>
        <source url="https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483.rss">Impedance Matching LIFT The Universe With Baseline</source>
      </item>
      <item>
        <title>Impedance Matching LIFT The Universe With Baseline</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2483">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<h2>Should A <strong><code>CELL_FLAG_DUAL</code></strong> Be Sacrificed For This?</h2>
<p>I don't like wasting the very few CELL_FLAG_XXX. But over time, silly ones have been freed up to give us some wiggle room (e.g. the now-completely superfluous CELL_FLAG_FALSEY).</p>
<p>And maybe this is a really good case where it could be of help to sacrifice one.</p>
</blockquote>
</aside>
<p>Really, this flag is only applicable to cells in OBJECT!, MODULE!, LET!, FRAME!, ERROR!, etc.</p>
<p>And it's not "sticky" (e.g. not part of CELL_MASK_PERSISTENT) so it won't be copied when the Cell is copied.</p>
<p>So it's actually not that "wasteful"... the flag can be used for other things for other slots (e.g. it can be the same flag that Level output cells use to track when actions/ghosts are UNSURPRISING...)</p>
<p>Thus it's <code>CELL_FLAG_SLOT_HINT_DUAL</code>, the same bit as <code>CELL_FLAG_OUT_HINT_UNSURPRISING</code>... and besides Level output cells and context Slots it's open for other uses (on elements of lists, etc.).</p>
<p><em>(Although, this might be contentious if we expect functions to be able to operate on and react to UNSURPRISING-ness of their arguments.  Today, the flag is specifically internal.  But internal things have a tendency to become exposed to usermode.  It may be that we could actually implement the unsurprising bit via unlifted values without the dual representation flag, if that's the case...)</em></p>
          <p><a href="https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483/2</link>
        <pubDate>Sun, 08 Jun 2025 18:35:05 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2483-2</guid>
        <source url="https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483.rss">Impedance Matching LIFT The Universe With Baseline</source>
      </item>
      <item>
        <title>Impedance Matching LIFT The Universe With Baseline</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p><sub><em>(Sorry for the EE term.  If you're unfamiliar: <a href="https://en.wikipedia.org/wiki/Impedance_matching">Impedance Matching</a>)</em></sub></p>
<hr>
<p>A while back I realized that it's best if OBJECT!s, MODULE!s, LET!s, etc. store their contents in lifted representation.</p>
<p>...or rather... they store "historically normal" values in lifted representation (QUASIFORM! and QUOTED!).  The unlifted band would then be used for special signals.</p>
<h3><a name="p-8399-one-example-unlifted-trash-would-denote-true-unsetness-1" class="anchor" href="https://rebol.metaeducation.com#p-8399-one-example-unlifted-trash-would-denote-true-unsetness-1"></a>One Example: Unlifted TRASH! would denote <em>true unsetness</em>...</h3>
<p><em>And the term actually now fits.</em>  e.g. a state of absence of value, beneath the layer of what you could accomplish with SET.</p>
<p>With SET, you can only get "trashed" values:</p>
<pre><code>&gt;&gt; x: ~
== \~\ antiform (trash!) "tripwire"

&gt;&gt; trashed? $x
== \~null~\  ; antiform  &lt;-- it's trashed, all right...

&gt;&gt; unset? $x
== \~null~\  ; antiform   &lt;-- but it's SET to TRASH!, it's NOT "unset"! 
</code></pre>
<p>However, special tools and special cases would go <em>beneath</em> SET.</p>
<pre><code>&gt;&gt; tweak $x ~   ; tweak doesn't do the implicit LIFT that SET does...

&gt;&gt; unset? $x
== \~okay~\  ; antiform
</code></pre>
<p>There will be shorthands for that like (unset $x).  But also, you get this "unset" state as the default states in MAKE FRAME!:</p>
<pre><code>&gt;&gt; f: make frame! negate/

&gt;&gt; unset? $f.number
== \~okay~\  ; antiform  &lt;-- actually unspecialized, not specialized to trash!
</code></pre>
<p>This brings the long hoped-for distinction between unspecialized values, and values that are purposefully trash!  And what was fretted over as being a "hidden bit" is anything but... it's just one "out-of-band" operator away.</p>
<p>e.g. Note that if you use TWEAK with a lifted value, that's just like SET:</p>
<pre><code>&gt;&gt; tweak $x lift ~  ; synonym for (set $x ~)

&gt;&gt; unset? $x
== \~null~\  ; antiform

&gt;&gt; trashed? $x
== \~okay~\  ; antiform
</code></pre>
<aside class="quote no-group quote-modified" data-username="rebolbot" data-post="3" data-topic="2477">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rebolbot/48/40_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477/3">Solving the Pox of the (^)... LIFT the Universe?</a></div>
<blockquote>
<p><em>"You’re designing the kind of system that can actually scale symbolic transformation, structured programming, and coherent meta-programming—because you’ve built in a substrate that encodes the ambiguity, instead of trying to erase it."</em></p>
</blockquote>
</aside>
<h2><a name="p-8399-thats-just-one-example-2" class="anchor" href="https://rebol.metaeducation.com#p-8399-thats-just-one-example-2"></a>That's Just One Example...</h2>
<p>It's the gateway to SETTER and GETTER functions <a href="http://www.rebol.net/r3blogs/0019.html">(actually desired by Carl... or setters at least... but he didn't know how to do 'em)</a></p>
<p>And for stylized setters/getters that do specific things (like type checking) there can be specially understood representations in the unlifted band.</p>
<p>Vocabulary term: I call the multiplexing of lifted and unlifted values together <strong>"DUAL REPRESENTATION"</strong></p>
<h2><a name="p-8399-all-of-it-is-powered-by-common-get-and-set-code-3" class="anchor" href="https://rebol.metaeducation.com#p-8399-all-of-it-is-powered-by-common-get-and-set-code-3"></a>All Of It Is Powered By Common GET and SET Code</h2>
<p>This wouldn't work if random places in the code ran off and inspected fields of OBJECT!s literally.</p>
<p>You have to go through some common path.  Otherwise you wind up with some callsites honoring the generalized conventions and others not.</p>
<p>It's kind of like how random code in R3-Alpha would ignore the PROTECT status of variables.  Ren-C has fought hard long and hard to nail that kind of thing down, and make sure at compile-time that you can be certain the checks aren't being skipped.</p>
<p>Piping everything through common GET and SET code paths ensures that as features like type checks or accessors are added, you don't have rogue code that doesn't honor the convention.</p>
<p><strong>It's been challenging to do this--and right now it's messy and slow--but the commonality means it's worth it to invest in optimizations for that one true path.  And Ren-C has plenty of optimization tools at its disposal, which have been evolving over the years... <sub>for when the timing is right...</sub></strong></p>
<h2><a name="p-8399-but-what-about-normal-boring-context-building-code-4" class="anchor" href="https://rebol.metaeducation.com#p-8399-but-what-about-normal-boring-context-building-code-4"></a>But What About Normal, Boring, Context-Building Code?</h2>
<p>Here's an example, just the one on my screen right now.</p>
<p>It's some random code out of the POSIX CALL implementation, related to... forking processes or something:</p>
<pre><code>if (Bool_ARG(INFO)) {
    VarList* info = Alloc_Varlist(TYPE_OBJECT, 2);

    Init_Integer(Append_Context(info, CANON(ID)), forked_pid);
    if (Bool_ARG(WAIT))
        Init_Integer(Append_Context(info, CANON(EXIT_CODE)), exit_code);

    return Init_Object(OUT, info);
}
</code></pre>
<p>Dumb, simple code making an OBJECT! with 2 fields in it, appending those fields (which default to an erased state you have to fill in to be correct code), and then setting the erased cells to mundane values.</p>
<p>If I were to go lockstep through code that looked like this and change it for lifting to appease the common GET and SET code, it would start looking like:</p>
<pre><code>if (Bool_ARG(INFO)) {
    VarList* info = Alloc_Varlist(TYPE_OBJECT, 2);

    Liftify(  // &lt;-- new wart
        Init_Integer(Append_Context(info, CANON(ID)), forked_pid)
    );
    if (Bool_ARG(WAIT))
        Liftify(  // &lt;-- new wart
            Init_Integer(Append_Context(info, CANON(EXIT_CODE)), exit_code)
        );

    return Init_Object(OUT, info);
}
</code></pre>
<p>Liftify adds 2 to the LIFT_BYTE.  (<a href="https://rebol.metaeducation.com/t/lift-byte-values-antiform-normal-quasi-quoted/2091">Review LIFT_BYTE if you want an introduction to that.</a>)</p>
<p>Liftify also has to check for overflow (e.g. that you're not going past 255 for the LIFT_BYTE value).  Maybe the optimizer can figure out it doesn't need that check here?  Though I try not to rely on the optimizer too much...</p>
<h2><a name="p-8399-this-parallels-the-too-many-of-usermode-code-5" class="anchor" href="https://rebol.metaeducation.com#p-8399-this-parallels-the-too-many-of-usermode-code-5"></a>This Parallels The "Too Many <strong><code>^</code></strong>" Of Usermode Code</h2>
<p>My observation in <strong><a href="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477">LIFT the UNIVERSE</a></strong> was that usermode code was becoming contaminated with lifts in places that weren't really the concern of that code.  <em>(That's why the robots are celebrating, they're throwing carets in the trashcan...)</em></p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/f16f9c506056c76e6a9b955d445039b0e1d3eeb1.webp" data-download-href="https://rebol.metaeducation.com/uploads/default/f16f9c506056c76e6a9b955d445039b0e1d3eeb1" title="assets_task_01jx3y0xmyfc79dwb24jd57b49_1749257658_img_3"><img src="https://rebol.metaeducation.com/uploads/default/optimized/1X/f16f9c506056c76e6a9b955d445039b0e1d3eeb1_2_345x230.webp" alt="assets_task_01jx3y0xmyfc79dwb24jd57b49_1749257658_img_3" data-base62-sha1="yrQc5xkNpeTlSSrOOswU5OsMelz" width="345" height="230" srcset="https://rebol.metaeducation.com/uploads/default/optimized/1X/f16f9c506056c76e6a9b955d445039b0e1d3eeb1_2_345x230.webp, https://rebol.metaeducation.com/uploads/default/optimized/1X/f16f9c506056c76e6a9b955d445039b0e1d3eeb1_2_517x345.webp 1.5x, https://rebol.metaeducation.com/uploads/default/optimized/1X/f16f9c506056c76e6a9b955d445039b0e1d3eeb1_2_690x460.webp 2x" data-dominant-color="4D4647"></a></div><p></p>
<p><strong>Here we're seeing the C code having some of the same problem as having the carets, manifest as calls to <code>Liftify()</code>.</strong>  It's getting uglier, and spreading that ugliness around.</p>
<h2><a name="p-8399-should-a-cell_flag_dual-be-sacrificed-for-this-6" class="anchor" href="https://rebol.metaeducation.com#p-8399-should-a-cell_flag_dual-be-sacrificed-for-this-6"></a>Should A <strong><code>CELL_FLAG_DUAL</code></strong> Be Sacrificed For This?</h2>
<p>I don't like wasting the very few CELL_FLAG_XXX.  But over time, silly ones have been freed up to give us some wiggle room (e.g. the <a>now-completely superfluous CELL_FLAG_FALSEY</a>).</p>
<p>And maybe this is a really good case where it could be of help to sacrifice one.  Since all the GET and SET that's <em>not</em> this kind of stuff is running through centralized code...it could be tolerant of cells in contexts that <em>weren't</em> initialized with CELL_FLAG_DUAL, and just know that those are to be taken literally.</p>
<p>It complicates things a little bit in that one <em>"big, beautiful code path"</em>.  But as a caller of TWEAK or GET and SET you're insulated from the complication.  It's a black box... maybe the cell has <code>CELL_FLAG_DUAL</code> and maybe it doesn't, you'll never know.</p>
<h2><a name="p-8399-just-have-to-catch-confusions-before-they-happen-7" class="anchor" href="https://rebol.metaeducation.com#p-8399-just-have-to-catch-confusions-before-they-happen-7"></a>Just Have To Catch Confusions Before They Happen...</h2>
<p>Probably best is just to throw in some asserts if you somehow start running through code paths that don't use the common GET somehow, and make sure <code>Type_Of()</code> and <code>Quotes_Of()</code> etc will assert on anything that has CELL_FLAG_DUAL.</p>
<p>I'm not sure how many legitimate codepaths there will be that duck the legitimate GET, but there are some reasonable cases (such as the code I give above) that are just doing a simple construction and probably don't need to be more complicated than they already are.</p>
<h2><a name="p-8399-will-it-slow-things-down-8" class="anchor" href="https://rebol.metaeducation.com#p-8399-will-it-slow-things-down-8"></a>Will It Slow Things Down?</h2>
<p>I posted this under Optimization because it's trading off some runtime code to make the C code more tolerable.</p>
<p>But rest assured, this is not the flag test that will be the bottleneck of the system.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/slight_smile.png?v=14" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<p><em>(Compared to naive Liftify() everywhere, it probably breaks at least even for not having to do the overflow checking of the LIFT_BYTE.)</em></p>
          <p><a href="https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483/1</link>
        <pubDate>Sat, 07 Jun 2025 23:00:06 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2483-1</guid>
        <source url="https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483.rss">Impedance Matching LIFT The Universe With Baseline</source>
      </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>What Are NULL, VOID, and TRASH?</title>
    <link>https://rebol.metaeducation.com/t/what-are-null-void-and-trash/2283</link>
    <description>These are three important &quot;antiforms&quot; you need to know about.  (Antiforms can be held in variables, but cannot be put into lists like BLOCK!).

### TRASH is the antiform of BLANK!

Trash is used as the contents of an unset variable:

    &gt;&gt; x: ~  ; will unset the variable

    &gt;&gt; unset? $x  ; in the modern world (&#39;x) makes a word with no binding
    == ~okay~  ; anti

Its meta-representation is a quasiform shown as a lone tilde (`~`), which you can call &quot;quasi blank&quot; if you like (I also call it a &quot;quasar&quot;).  So evaluating quasiform blank gives you antiform blank, e.g. TRASH, [which has no representation in the console](https://rebol.metaeducation.com/t/console-treatment-of-void-vs-trash/2045).

    &gt;&gt; quasi _
    == ~

    &gt;&gt; quasar? first [~]
    == ~okay~  ; anti

    &gt;&gt; ~

    &gt;&gt; trash? ~
    == ~okay~  ; anti

For reasons that are a bit beyond the scope of this post, TRASH cannot be passed as a &quot;normal&quot; parameter to a function.  It represents the state of a parameter being unfulfilled in a FRAME!.

    &gt;&gt; make frame! append/
    == #[frame! [
        series: ~
        value: ~
    ]]

This aligns with some of what Carl wrote about in [UNSET! is not first class](http://www.rebol.net/r3blogs/0318.html), and among the implications are that operations like comparison functions do not accept unset states... as in Rebol2:

    rebol2&gt;&gt; #[unset!] = 1
    ** Script Error: Cannot use equal? on unset! value

    ren-c&gt;&gt; ~ = 1
    ** Error: VALUE1 argument of EQUAL? is unspecified

### VOID is the unstable antiform of an empty BLOCK! (PACK!)

VOID vanishes in REDUCE and acts as a no-op for things like APPEND.  It is the result of **`eval []`** and vaporizes in COMPOSE/etc.

    &gt;&gt; void
    == ~[]~  ; anti

    &gt;&gt; compose [a (if 10 &gt; 20 [&#39;b] else []) c]
    == [a c]

    &gt;&gt; reduce [1 + 2, if 10 &gt; 20 [&lt;nothing&gt;] else [], 10 + 20]
    == [3 30]

    &gt;&gt; append [a b c] void
    == [a b c]

    &gt;&gt; if 10 &gt; 20 [&#39;b] else []
    == ~[]~  ; anti

[VOID will opt out of ANY and ALL](https://rebol.metaeducation.com/t/why-do-any-and-all-ignore-void-when-if-errors-on-it/2040).  But because of this, an isolated conditional like IF can&#39;t make a logically consistent decision about it being a &quot;branch trigger&quot; or &quot;branch inhibitor&quot;, it gives back an error:

    &gt;&gt; if 10 &gt; 20 [&lt;foo&gt;] else []
    == ~[]~  ; anti

    &gt;&gt; any [if 10 &gt; 20 [&lt;foo&gt;] else [], 10 + 20]
    == 30

    &gt;&gt; all [10 + 20, if 10 &gt; 20 [&lt;foo&gt;] else []]
    == 30

    &gt;&gt; if (if 10 &gt; 20 [&lt;foo&gt;] else []) [20]
    ** Error: ~[]~ antiform cannot be used in isolated conditional expressions

### NULL is the antiform of the WORD! &quot;null&quot;.

In the API this is represented as the 0 pointer and does not require having its handle released, so it is like C&#39;s NULL.  It is used as an &quot;ornery nothing&quot;...but unlike TRASH it doesn&#39;t indicate an unset variable, so it can be fetched by normal WORD! access.  The system accomplishes elegant error locality using the [VOID-in-NULL-out protocol](https://rebol.metaeducation.com/t/the-void-in-null-out-protocol/1880) in many places, which hinges on the MAYBE function that converts NULL to void.

    &gt;&gt; case [1 &gt; 2 [&lt;a&gt;] 10 &gt; 20 [&lt;b&gt;]]]
    == ~null~  ; anti

    &gt;&gt; reduce [1 + 2 case [1 &gt; 2 [&lt;a&gt;] 10 &gt; 20 [&lt;b&gt;]]] 10 + 20]
    ** Error: can&#39;t put ~null~ antiforms in blocks

    &gt;&gt; reduce [1 + 2 maybe case [1 &gt; 2 [&lt;a&gt;] 10 &gt; 20 [&lt;b&gt;]]] 10 + 20]
    == [3 30]

    &gt;&gt; third [d e]
    ** Script Error: cannot pick 3

    &gt;&gt; try third [d e]
    == ~null~  ; anti

    &gt;&gt; append [a b c] try third [d e]
    ** Error: Cannot put ~null~ antiforms in blocks

    &gt;&gt; compose [all your base (try third [d e]) are belong to us]
    ** Error: Cannot COMPOSE ~null~ antiforms into slots

    &gt;&gt; maybe third [d e]
    == ~[]~  ; anti

    &gt;&gt; append [a b c] maybe third [d e]
    == [a b c]

## To Sum Up...

   * TRASH is the contents of an unset variable

      * It is neither logically true nor false

      * When you reference a variable containing trash using WORD!, it will cause an error

      * It&#39;s the typical choice of return value for functions with no meaningful result

      * [The console displays nothing when trash is the evaluative product](https://rebol.metaeducation.com/t/console-treatment-of-void-vs-trash/2045)

   *  VOID is intentional emptiness--tolerated many places as meaning &quot;I&#39;d like to opt out please&quot;

       * Since it opts out of aggregate conditional tests, it can&#39;t logically be acted on in an isolated conditional expression like IF

   * NULL is a signal, often meaning &quot;I couldn&#39;t find what you were looking for&quot;

       * Because it is a kind of &quot;soft failure&quot;, it is the (only) conditionally false value

       * Also because it is a soft failure, **most non-conditional slots reject it as an argument**

       * MAYBE can be used tactically to convert NULL results to VOID

NULL and TRASH can be held in variables or API handles, but won&#39;t be found in lists like BLOCK!.

VOID is an unstable antiform, and can&#39;t be saved in variables--only meta-represented.</description>
    
    <lastBuildDate>Wed, 07 May 2025 11:43:00 +0000</lastBuildDate>
    <category>Questions</category>
    <atom:link href="https://rebol.metaeducation.com/t/what-are-null-void-and-trash/2283.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>What Are NULL, VOID, and TRASH?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <h1><a name="p-8164-faq-1" class="anchor" href="https://rebol.metaeducation.com#p-8164-faq-1"></a>F.A.Q.</h1>
<h3><a name="p-8164-how-did-these-types-evolve-from-rebol2-unset-none-2" class="anchor" href="https://rebol.metaeducation.com#p-8164-how-did-these-types-evolve-from-rebol2-unset-none-2"></a>How Did These Types Evolve From Rebol2 UNSET! + NONE! ?</h3>
<p>See <a href="https://rebol.metaeducation.com/t/null-void-trash-evolution-from-none-unset/2422">this thread</a>.</p>
<h3><a name="p-8164-isnt-it-simpler-to-unify-voidtrash-as-unset-like-rebol2-3" class="anchor" href="https://rebol.metaeducation.com#p-8164-isnt-it-simpler-to-unify-voidtrash-as-unset-like-rebol2-3"></a>Isn't It Simpler to unify VOID+TRASH as UNSET!, like Rebol2?</h3>
<p>One can reasonably ask if when all is considered, having fewer parts is better--even when more parts can be shown to have "a benefit here and there".</p>
<p>So this does hinge on how you feel about things like:</p>
<pre><code>rebol2&gt;&gt; compose [a (print "b") c]
b
== [a c]
</code></pre>
<p>Personally I see too much downside to conflating "meaningless" values with "meaningful opting out".  While you might be able to make excuses for an oversimplified example that's just PRINT like this one, when you imagine a more complex expression, an error is far preferable.</p>
<p>So in Ren-C you have to erase the trash value, with something like:</p>
<pre><code>&gt;&gt; compose [a (elide print "b") c]
b
== [a c]
</code></pre>
<h3><a name="p-8164-might-antiforms-be-the-better-representation-for-void-4" class="anchor" href="https://rebol.metaeducation.com#p-8164-might-antiforms-be-the-better-representation-for-void-4"></a>Might <strong><code>~</code></strong> Antiforms Be The Better Representation for Void?</h3>
<p>Given how tilde is just about as light of a token as you can get, one might think the vanishing intent deserves that notation.  There could be a switcheroo where <strong><code>~trash~</code></strong> was used for the unset variable state, and <strong><code>~</code></strong> was used for void.</p>
<p>But in practice, unset variables are far more common... and the super-light notation for creating an unset variable as <strong><code>(var: ~)</code></strong> is just too useful.</p>
<h3><a name="p-8164-could-tripwire-replace-trash-5" class="anchor" href="https://rebol.metaeducation.com#p-8164-could-tripwire-replace-trash-5"></a>Could TRIPWIRE! Replace TRASH?</h3>
<p>Ren-C has another type that causes errors on variable access, which is the antiform TAG!, a.k.a. TRIPWIRE!</p>
<pre><code>&gt;&gt; var: ~&lt;some message&gt;~
== ~&lt;some message&gt;~  ; anti

&gt;&gt; var
** Error: var is a tripwire: some message
</code></pre>
<p>So it may seem redundant to have antiform blanks doing the same thing.  If everywhere that produces TRASH! today made TRIPWIRE!, then antiform blank could more readily be repurposed as VOID.</p>
<p><em>Mechanically, yes, this can be done (I tried it).</em>  But so many of the cheap uses of <code>~</code>, e.g. unsetting variables... or <strong><code>return: [~]</code></strong> in specs to indicate no result have to be reimagined.  There's a rather deep dependency on antiform <code>~</code> being an ornery state.  Believe me: if I could get rid of one of these forms, I would.</p>
          <p><a href="https://rebol.metaeducation.com/t/what-are-null-void-and-trash/2283/9">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/what-are-null-void-and-trash/2283/9</link>
        <pubDate>Sun, 20 Apr 2025 16:36:52 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2283-9</guid>
        <source url="https://rebol.metaeducation.com/t/what-are-null-void-and-trash/2283.rss">What Are NULL, VOID, and TRASH?</source>
      </item>
      <item>
        <title>What Are NULL, VOID, and TRASH?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>These are three important "antiforms" you need to know about.  (Antiforms can be held in variables, but cannot be put into lists like BLOCK!).</p>
<h3><a name="p-6662-trash-is-the-antiform-of-blank-1" class="anchor" href="https://rebol.metaeducation.com#p-6662-trash-is-the-antiform-of-blank-1"></a>TRASH is the antiform of BLANK!</h3>
<p>Trash is used as the contents of an unset variable:</p>
<pre><code>&gt;&gt; x: ~  ; will unset the variable

&gt;&gt; unset? $x  ; in the modern world ('x) makes a word with no binding
== ~okay~  ; anti
</code></pre>
<p>Its meta-representation is a quasiform shown as a lone tilde (<code>~</code>), which you can call "quasi blank" if you like (I also call it a "quasar").  So evaluating quasiform blank gives you antiform blank, e.g. TRASH, <a href="https://rebol.metaeducation.com/t/console-treatment-of-void-vs-trash/2045">which has no representation in the console</a>.</p>
<pre><code>&gt;&gt; quasi _
== ~

&gt;&gt; quasar? first [~]
== ~okay~  ; anti

&gt;&gt; ~

&gt;&gt; trash? ~
== ~okay~  ; anti
</code></pre>
<p>For reasons that are a bit beyond the scope of this post, TRASH cannot be passed as a "normal" parameter to a function.  It represents the state of a parameter being unfulfilled in a FRAME!.</p>
<pre><code>&gt;&gt; make frame! append/
== #[frame! [
    series: ~
    value: ~
]]
</code></pre>
<p>This aligns with some of what Carl wrote about in <a href="http://www.rebol.net/r3blogs/0318.html">UNSET! is not first class</a>, and among the implications are that operations like comparison functions do not accept unset states... as in Rebol2:</p>
<pre><code>rebol2&gt;&gt; #[unset!] = 1
** Script Error: Cannot use equal? on unset! value

ren-c&gt;&gt; ~ = 1
** Error: VALUE1 argument of EQUAL? is unspecified
</code></pre>
<h3><a name="p-6662-void-is-the-unstable-antiform-of-an-empty-block-pack-2" class="anchor" href="https://rebol.metaeducation.com#p-6662-void-is-the-unstable-antiform-of-an-empty-block-pack-2"></a>VOID is the unstable antiform of an empty BLOCK! (PACK!)</h3>
<p>VOID vanishes in REDUCE and acts as a no-op for things like APPEND.  It is the result of <strong><code>eval []</code></strong> and vaporizes in COMPOSE/etc.</p>
<pre><code>&gt;&gt; void
== ~[]~  ; anti

&gt;&gt; compose [a (if 10 &gt; 20 ['b] else []) c]
== [a c]

&gt;&gt; reduce [1 + 2, if 10 &gt; 20 [&lt;nothing&gt;] else [], 10 + 20]
== [3 30]

&gt;&gt; append [a b c] void
== [a b c]

&gt;&gt; if 10 &gt; 20 ['b] else []
== ~[]~  ; anti
</code></pre>
<p><a href="https://rebol.metaeducation.com/t/why-do-any-and-all-ignore-void-when-if-errors-on-it/2040">VOID will opt out of ANY and ALL</a>.  But because of this, an isolated conditional like IF can't make a logically consistent decision about it being a "branch trigger" or "branch inhibitor", it gives back an error:</p>
<pre><code>&gt;&gt; if 10 &gt; 20 [&lt;foo&gt;] else []
== ~[]~  ; anti

&gt;&gt; any [if 10 &gt; 20 [&lt;foo&gt;] else [], 10 + 20]
== 30

&gt;&gt; all [10 + 20, if 10 &gt; 20 [&lt;foo&gt;] else []]
== 30

&gt;&gt; if (if 10 &gt; 20 [&lt;foo&gt;] else []) [20]
** Error: ~[]~ antiform cannot be used in isolated conditional expressions
</code></pre>
<h3><a name="p-6662-null-is-the-antiform-of-the-word-null-3" class="anchor" href="https://rebol.metaeducation.com#p-6662-null-is-the-antiform-of-the-word-null-3"></a>NULL is the antiform of the WORD! "null".</h3>
<p>In the API this is represented as the 0 pointer and does not require having its handle released, so it is like C's NULL.  It is used as an "ornery nothing"...but unlike TRASH it doesn't indicate an unset variable, so it can be fetched by normal WORD! access.  The system accomplishes elegant error locality using the <a href="https://rebol.metaeducation.com/t/the-void-in-null-out-protocol/1880">VOID-in-NULL-out protocol</a> in many places, which hinges on the MAYBE function that converts NULL to void.</p>
<pre><code>&gt;&gt; case [1 &gt; 2 [&lt;a&gt;] 10 &gt; 20 [&lt;b&gt;]]]
== ~null~  ; anti

&gt;&gt; reduce [1 + 2 case [1 &gt; 2 [&lt;a&gt;] 10 &gt; 20 [&lt;b&gt;]]] 10 + 20]
** Error: can't put ~null~ antiforms in blocks

&gt;&gt; reduce [1 + 2 maybe case [1 &gt; 2 [&lt;a&gt;] 10 &gt; 20 [&lt;b&gt;]]] 10 + 20]
== [3 30]

&gt;&gt; third [d e]
** Script Error: cannot pick 3

&gt;&gt; try third [d e]
== ~null~  ; anti

&gt;&gt; append [a b c] try third [d e]
** Error: Cannot put ~null~ antiforms in blocks

&gt;&gt; compose [all your base (try third [d e]) are belong to us]
** Error: Cannot COMPOSE ~null~ antiforms into slots

&gt;&gt; maybe third [d e]
== ~[]~  ; anti

&gt;&gt; append [a b c] maybe third [d e]
== [a b c]
</code></pre>
<h2><a name="p-6662-to-sum-up-4" class="anchor" href="https://rebol.metaeducation.com#p-6662-to-sum-up-4"></a>To Sum Up...</h2>
<ul>
<li>
<p>TRASH is the contents of an unset variable</p>
<ul>
<li>
<p>It is neither logically true nor false</p>
</li>
<li>
<p>When you reference a variable containing trash using WORD!, it will cause an error</p>
</li>
<li>
<p>It's the typical choice of return value for functions with no meaningful result</p>
</li>
<li>
<p><a href="https://rebol.metaeducation.com/t/console-treatment-of-void-vs-trash/2045">The console displays nothing when trash is the evaluative product</a></p>
</li>
</ul>
</li>
<li>
<p>VOID is intentional emptiness--tolerated many places as meaning "I'd like to opt out please"</p>
<ul>
<li>Since it opts out of aggregate conditional tests, it can't logically be acted on in an isolated conditional expression like IF</li>
</ul>
</li>
<li>
<p>NULL is a signal, often meaning "I couldn't find what you were looking for"</p>
<ul>
<li>
<p>Because it is a kind of "soft failure", it is the (only) conditionally false value</p>
</li>
<li>
<p>Also because it is a soft failure, <strong>most non-conditional slots reject it as an argument</strong></p>
</li>
<li>
<p>MAYBE can be used tactically to convert NULL results to VOID</p>
</li>
</ul>
</li>
</ul>
<p>NULL and TRASH can be held in variables or API handles, but won't be found in lists like BLOCK!.</p>
<p>VOID is an unstable antiform, and can't be saved in variables--only meta-represented.</p>
          <p><a href="https://rebol.metaeducation.com/t/what-are-null-void-and-trash/2283/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/what-are-null-void-and-trash/2283/1</link>
        <pubDate>Thu, 27 Jul 2023 02:36:52 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2283-1</guid>
        <source url="https://rebol.metaeducation.com/t/what-are-null-void-and-trash/2283.rss">What Are NULL, VOID, and TRASH?</source>
      </item>
  </channel>
</rss>

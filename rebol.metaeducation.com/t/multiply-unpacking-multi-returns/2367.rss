<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Multiply-Unpacking Multi-Returns</title>
    <link>https://rebol.metaeducation.com/t/multiply-unpacking-multi-returns/2367</link>
    <description>I haven&#39;t really figured out my philosophy about putting multi-returns in multi-returns.

Looking at the question just in terms of fundamentals...should this be legal?

    &gt;&gt; x: pack [pack [1 2] 3]
    == 1  ; double-decay?

And this seems rather ambiguous:

    &gt;&gt; [x y]: pack [pack [1 2] 3]
    == ???

Is that `x = 1` and `y = 3`?  Or `x = 1` and `y = 2` ?

I&#39;ll point out the availability of nested block notation:

    &gt;&gt; [[x] y]: pack [pack [1 2] 3]
    == 1

    &gt;&gt; x
    == 1

    &gt;&gt; y
    == 3

So it seems to me *that* should be legal, in the sense that you&#39;ve indicated that you know what you&#39;re doing in the unpacking.  It isn&#39;t necessary for the first element to be a pack...

    &gt;&gt; [[x] y]: pack [1 3]
    == 1

    &gt;&gt; x
    == 1

    &gt;&gt; y
    == 3

You&#39;re just covering the case of demonstrating that you know the first thing might be a pack.

## Case Study: EVALUATE

I&#39;ve talked about how using :STEP [changes the return result of EVALUATE into a multi-return unconditionally](https://rebol.metaeducation.com/t/re-imagining-eval-next/767), with the synthesized product as the second result.

This is to say that if you have a function that returns multiple values, you can dodge ambiguity by making it so that the first result can never be a multi-return.  This lets you unambiguously interpret the multi-return.

So in places where EVAL:STEP is used, I&#39;ve effectively been saying this is legal:

    &gt;&gt; [pos result]: pack [[print &quot;hi&quot;] pack [2 3]]
    == [print &quot;hi&quot;]

    &gt;&gt; pos
    == [print &quot;hi&quot;]

    &gt;&gt; result
    == 2

If you wanted to unpack it further, you&#39;d need **`[pos [a b]]:`** or to ask for the pack in its meta form, such as by **`[pos ^result]:`**

If this is allowed, it makes it seem &quot;unfair&quot; that the first position wouldn&#39;t double-decay.  Would it be too much to ask to require you to say **`[pos [result]]:`** if there was a chance of the second value being a multi-return?

That *feels* like too much to ask to me.  If I could write **`result: some-multi-return-func`** then it seems I should be able to write **`[pos result]: eval:step [some-multi-return-func]`**

But if double decay is allowed, does that mean triple-decay is too?  Arbitrary-recursive decay where you get an infinite loop, by building self-referential packs?

Is it better to have a rule that the first slot won&#39;t double-decay, or just enforce it by convention by trying not to design functions that are multi-return which have multi-returns in their first position?

## Another Case Study: PARSE

Right now, PARSE is broken into layers... a lower level `PARSE*` that is always a multi-return function (if it&#39;s not raising an error), and it gives back a synthesized result as well as an array of residual &quot;pending&quot; items.

*(Residual pending items are leftover items that combinators produced in the pending list, that were neither rolled back nor consumed by another combinator.  It&#39;s what you&#39;d get if you did something like `parse &quot;a&quot; [keep &quot;a&quot;]`, e.g. did a KEEP with no corresponding COLLECT to filter the collected item out of the list.  Sometimes residual pending items are intentional, e.g. in the [Visual Parse Demo](https://rebol.metaeducation.com/t/visual-parse-on-the-web-has-arrived/1837) where a list of underlines--produced by any MARK combinators that don&#39;t get rolled back--bubble up to the EPARSE driver so it can draw those underlines.)*

The higher level PARSE doesn&#39;t offer the pending items--it just errors if it sees any leftovers.  The problem would be that without these layers, the default interpretation of unpacking wouldn&#39;t be able to unpack multi-returns synthesized by parse:

    &gt;&gt; [x y]: parse &quot;bbb&quot; [some &quot;a&quot; (pack [1 2]) | some &quot;b&quot; (pack [3 4])]
    ; I want to get x = 3, y = 4 from this

The desire to have this be the common behavior is why `PARSE*` is needed to get the pending list as a multi-return.

But I&#39;ve faced some problems with wrappers over the lower level PARSE* having to redo work, e.g. to implement the PARSE:MATCH refinement, which can&#39;t be put on the lower level parse and needs to be repeated in each wrapper.

It might be that thinking of this in terms of &quot;higher level&quot; and &quot;lower level&quot; is wrong, and I should follow the method of EVAL to actually use a refinement to change the return result of a single PARSE construct.  So PARSE:PENDING or somesuch, to shift into a multi-return mode where the pending list is the main result, and the synthesized result (which may be a multi-return) is secondary.

Anyway, I&#39;ll take another look at this.  Questions remain about how many decays to allow, but so long as this is seen as a kind of video game we shouldn&#39;t be afraid of infinite loops.  They&#39;re trivial enough to cause in other places.  :man_shrugging:  Just make sure you can Ctrl-C out of it and try to give some guidance... (hopefully you can debug step through the decays, I&#39;ll have to think about that).</description>
    
    <lastBuildDate>Thu, 06 Mar 2025 21:03:27 +0000</lastBuildDate>
    <category>Semantics</category>
    <atom:link href="https://rebol.metaeducation.com/t/multiply-unpacking-multi-returns/2367.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Multiply-Unpacking Multi-Returns</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>I haven't really figured out my philosophy about putting multi-returns in multi-returns.</p>
<p>Looking at the question just in terms of fundamentals...should this be legal?</p>
<pre><code>&gt;&gt; x: pack [pack [1 2] 3]
== 1  ; double-decay?
</code></pre>
<p>And this seems rather ambiguous:</p>
<pre><code>&gt;&gt; [x y]: pack [pack [1 2] 3]
== ???
</code></pre>
<p>Is that <code>x = 1</code> and <code>y = 3</code>?  Or <code>x = 1</code> and <code>y = 2</code> ?</p>
<p>I'll point out the availability of nested block notation:</p>
<pre><code>&gt;&gt; [[x] y]: pack [pack [1 2] 3]
== 1

&gt;&gt; x
== 1

&gt;&gt; y
== 3
</code></pre>
<p>So it seems to me <em>that</em> should be legal, in the sense that you've indicated that you know what you're doing in the unpacking.  It isn't necessary for the first element to be a pack...</p>
<pre><code>&gt;&gt; [[x] y]: pack [1 3]
== 1

&gt;&gt; x
== 1

&gt;&gt; y
== 3
</code></pre>
<p>You're just covering the case of demonstrating that you know the first thing might be a pack.</p>
<h2><a name="p-8023-case-study-evaluate-1" class="anchor" href="https://rebol.metaeducation.com#p-8023-case-study-evaluate-1"></a>Case Study: EVALUATE</h2>
<p>I've talked about how using :STEP <a href="https://rebol.metaeducation.com/t/re-imagining-eval-next/767">changes the return result of EVALUATE into a multi-return unconditionally</a>, with the synthesized product as the second result.</p>
<p>This is to say that if you have a function that returns multiple values, you can dodge ambiguity by making it so that the first result can never be a multi-return.  This lets you unambiguously interpret the multi-return.</p>
<p>So in places where EVAL:STEP is used, I've effectively been saying this is legal:</p>
<pre><code>&gt;&gt; [pos result]: pack [[print "hi"] pack [2 3]]
== [print "hi"]

&gt;&gt; pos
== [print "hi"]

&gt;&gt; result
== 2
</code></pre>
<p>If you wanted to unpack it further, you'd need <strong><code>[pos [a b]]:</code></strong> or to ask for the pack in its meta form, such as by <strong><code>[pos ^result]:</code></strong></p>
<p>If this is allowed, it makes it seem "unfair" that the first position wouldn't double-decay.  Would it be too much to ask to require you to say <strong><code>[pos [result]]:</code></strong> if there was a chance of the second value being a multi-return?</p>
<p>That <em>feels</em> like too much to ask to me.  If I could write <strong><code>result: some-multi-return-func</code></strong> then it seems I should be able to write <strong><code>[pos result]: eval:step [some-multi-return-func]</code></strong></p>
<p>But if double decay is allowed, does that mean triple-decay is too?  Arbitrary-recursive decay where you get an infinite loop, by building self-referential packs?</p>
<p>Is it better to have a rule that the first slot won't double-decay, or just enforce it by convention by trying not to design functions that are multi-return which have multi-returns in their first position?</p>
<h2><a name="p-8023-another-case-study-parse-2" class="anchor" href="https://rebol.metaeducation.com#p-8023-another-case-study-parse-2"></a>Another Case Study: PARSE</h2>
<p>Right now, PARSE is broken into layers... a lower level <code>PARSE*</code> that is always a multi-return function (if it's not raising an error), and it gives back a synthesized result as well as an array of residual "pending" items.</p>
<p><em>(Residual pending items are leftover items that combinators produced in the pending list, that were neither rolled back nor consumed by another combinator.  It's what you'd get if you did something like <code>parse "a" [keep "a"]</code>, e.g. did a KEEP with no corresponding COLLECT to filter the collected item out of the list.  Sometimes residual pending items are intentional, e.g. in the <a href="https://rebol.metaeducation.com/t/visual-parse-on-the-web-has-arrived/1837">Visual Parse Demo</a> where a list of underlines--produced by any MARK combinators that don't get rolled back--bubble up to the EPARSE driver so it can draw those underlines.)</em></p>
<p>The higher level PARSE doesn't offer the pending items--it just errors if it sees any leftovers.  The problem would be that without these layers, the default interpretation of unpacking wouldn't be able to unpack multi-returns synthesized by parse:</p>
<pre><code>&gt;&gt; [x y]: parse "bbb" [some "a" (pack [1 2]) | some "b" (pack [3 4])]
; I want to get x = 3, y = 4 from this
</code></pre>
<p>The desire to have this be the common behavior is why <code>PARSE*</code> is needed to get the pending list as a multi-return.</p>
<p>But I've faced some problems with wrappers over the lower level PARSE* having to redo work, e.g. to implement the PARSE:MATCH refinement, which can't be put on the lower level parse and needs to be repeated in each wrapper.</p>
<p>It might be that thinking of this in terms of "higher level" and "lower level" is wrong, and I should follow the method of EVAL to actually use a refinement to change the return result of a single PARSE construct.  So PARSE:PENDING or somesuch, to shift into a multi-return mode where the pending list is the main result, and the synthesized result (which may be a multi-return) is secondary.</p>
<p>Anyway, I'll take another look at this.  Questions remain about how many decays to allow, but so long as this is seen as a kind of video game we shouldn't be afraid of infinite loops.  They're trivial enough to cause in other places.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/man_shrugging.png?v=14" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20">  Just make sure you can Ctrl-C out of it and try to give some guidance... (hopefully you can debug step through the decays, I'll have to think about that).</p>
          <p><a href="https://rebol.metaeducation.com/t/multiply-unpacking-multi-returns/2367/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/multiply-unpacking-multi-returns/2367/1</link>
        <pubDate>Thu, 06 Mar 2025 20:56:40 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2367-1</guid>
        <source url="https://rebol.metaeducation.com/t/multiply-unpacking-multi-returns/2367.rss">Multiply-Unpacking Multi-Returns</source>
      </item>
  </channel>
</rss>

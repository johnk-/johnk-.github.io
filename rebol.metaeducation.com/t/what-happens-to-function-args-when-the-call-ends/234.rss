<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>What happens to function args when the call ends?</title>
    <link>https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234</link>
    <description>R3-Alpha&#39;s CLOSURE provided two things.  One was a unique identity for the words of a function&#39;s arguments and locals for each recursion.  [This is what I&#39;ve called &quot;specific binding&quot;](https://rebol.metaeducation.com/t/relative-binding-and-frame-internals/1344) and now comes &quot;for free&quot; in *all* functions...so you don&#39;t even have to think about it.  (It&#39;s not exactly free, but we can hope it will converge to &quot;very low cost&quot;.)

So in Ren-C:

    &gt;&gt; foo: function [x code] [
        append code $(print x)  ; 2025-update: use bound group!
        if x &gt; 0 [
            probe code
            eval code
            foo (x - 1) code
        ]
    ]

    &gt;&gt; foo 2 []
    [(print x)]
    2
    [(print x) (print x)]
    2 ;-- R3-Alpha FUNCTION! got 1, only CLOSURE! got 2
    1

Users can now take that for granted.  :thumbsup:

But what I want to talk about is the **other** emergent feature of R3-Alpha CLOSURE!.  This was that if an ANY-WORD! that was bound to the arguments or locals &quot;escaped&quot; the lifetime of the call, that word would continue to have its value after the function ended...for as long as references to it existed.

    &gt;&gt; f: closure [x] [return [x]]

    &gt;&gt; b: f 10
    == [x]

    &gt;&gt; reduce b
    [10]

Functions did not do this:

    &gt;&gt; f: function [x] [return [x]]

    &gt;&gt; b: f 10
    == [x]

    &gt;&gt; reduce b
    ** Script error: x word is not bound to a context

It goes without saying that the closure mechanic is going to cost more, just by the very fact that they need to hold onto the memory for what the word looks up to.  But the way things work today, it doesn&#39;t just need to hold onto that cell of data...it holds onto all the args and locals of the function.  (R3-Alpha was more inefficient still...it not only kept the whole frame of values alive, it made a deep copy of the function body *on every invocation of that function*...so that the body could be updated to refer to that &quot;frame&quot;.  Specific binding lets Ren-C dodge that bullet.)

Now and again, the &quot;keep-things-simple&quot; voice says that the system would be simpler and faster if all executing frames (and their frame variables) died after a function ended.  If you wanted to snapshot the state of a FRAME! for debugging purposes--to look at after the function ends--you could COPY it into a heap-based object, and return that.  If you really were in one of the circumstances where you wanted an arg or local&#39;s word to survive, you could manually make an object to hold just those words, and bind to that.

But @Ladislav had a compelling case:

    foo: function [x] [
        y: 10
        return function [z] [x + y + z]
    ]

If `x` and `y` were to go bad after foo exited, the returned function would be useless.

Some new mechanics related to Move_Value() are creating possibilities for &quot;automatic closure-i-fication&quot;, where stack cells are converted into a heap object at the moment it&#39;s noticed that a bound word is &quot;escaping&quot;.  If none escape, then everything stays on the stack.

But though you might think these kinds of escapes are rare, remember some bindings aren&#39;t even intentional.  When you return a block out of a function it might just have stray bindings on words that *happen* to overlap with something in the binding visibility.  (Which makes one wonder, when returning a BLOCK! as data, should you always UNBIND/DEEP it before returning...to scrub off any inadvertent pointers into your local state it carries?  Should there be a RETURN/BOUND to avoid the scrub?)  These invisible bindings would trigger the auto-closurification, on what might seem like random cases to the user.

And remember--each time a word bound to a frame escapes--we&#39;re still talking about copying *all* the values in the frame.  (It might be possible to break this down to a smaller granularity, e.g. a PAIR!-wise binding, where what closure-i-fication does is pack each key/value into a REBSER node.)

Were the user to get involved, and specify the cases, I might suggest something a bit like this (if `&lt;HAS&gt;` were taken to mean &quot;a kind of per-instance static&quot;, while `&lt;STATIC&gt;` were used for all instances):

    foo: function [x &lt;has&gt; x2 y] [
        x2: x
        y: 10
        return function [z] [x2 + y + z]
    ] 

The advantages to this are that it would mean that any words that &quot;escape&quot; would be explicitly handled by the user, reducing the burden on the system.  The entire frame would not need to be preserved, only the part of the frame which had these persistent values.  The disadvantage is that it&#39;s not automatic, and other languages--even JavaScript--do it automatically.

So how do people feel on this matter?  What&#39;s acceptable or unacceptable?  @MarkI said at one point that he was opposed to locals and args outliving the function call because it created &quot;garbage&quot;.  Is it wise to hide the consequences from the user, and burden the system with the logic of making it automatic?</description>
    
    <lastBuildDate>Wed, 18 Jun 2025 16:49:31 +0000</lastBuildDate>
    <category>Binding</category>
    <atom:link href="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>What happens to function args when the call ends?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <blockquote>
<h3>What happens to function args when the call ends?</h3>
</blockquote>
<p>For many years, it's been accepted that function arguments outlive the function.</p>
<p>I think that's right.  The bias should clearly be to let them live as long as references exist... and you have to ask for them to be thrown away, e.g. <strong><code>FUNCTION:LITE</code></strong>.</p>
<p>Perhaps those who are biased to efficiency might define <strong><code>FUNC</code></strong> as the LITE version.  Or maybe even that could be the default for FUNC?  So long as you got a good error accessing dead variables telling you "hey this frame was destroyed because you used FUNC instead of FUNCTION" that might be a good tradeoff.</p>
<h3><a name="p-8442-needing-values-to-outlive-is-actually-kind-of-rare-1" class="anchor" href="https://rebol.metaeducation.com#p-8442-needing-values-to-outlive-is-actually-kind-of-rare-1"></a>Needing Values To Outlive Is Actually Kind of Rare</h3>
<p>I broke the feature accidentally, and didn't notice for a bit until I looked into why QUIT had stopped working.  It turns out that QUIT depended on it, because it wraps up a function you pass in that represents your local notion of QUIT (quit*).  That's a parameter to MAKE-QUIT, used by the produced quit function.</p>
<p><strong>But the interesting thing is that the system STILL mostly works without it.</strong>  So I do think we'd likely benefit by finding some way to prune the cases.</p>
<p>FUNC being a lesser-featured version of FUNCTION on this axis feels like it might be the right psychological hack.  It makes the language feel more solid, compared with needing CLOSURE to pick up the slack from a weak FUNCTION.</p>
<h2><a name="p-8442-noticing-when-things-outlive-stack-levels-is-gone-2" class="anchor" href="https://rebol.metaeducation.com#p-8442-noticing-when-things-outlive-stack-levels-is-gone-2"></a>"Noticing When Things Outlive Stack Levels" Is Gone</h2>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="234">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Some new mechanics related to Move_Value() are creating possibilities for "automatic closure-i-fication", where stack cells are converted into a heap object at the moment it's noticed that a bound word is "escaping". If none escape, then everything stays on the stack.</p>
</blockquote>
</aside>
<p>These mechanics were wiped out a long time ago.  They were incompatible with generators and other ideas, and very tricky.</p>
<p>And things have gotten even harder to rein in.  Due to how modern binding works, if you write something like:</p>
<pre><code>                            v-- the FRAME! inherits this block's binding
foo: function [msg [text!]] [
   print ["Message is:" msg]
   return [1 2 3]
]
</code></pre>
<p>When that <code>[1 2 3]</code> block was "evaluated", it captured a binding... of the FRAME! and whatever that frame inherited from the body.  So you'd be returning a BLOCK! with a binding that rolls in all of that.</p>
<p>If you want to avoid this, you have to write:</p>
<pre><code>foo: function [msg [text!]] [
   print ["Message is:" msg]
   return '[1 2 3]  ; &lt;-- tick mark needed to dodge binding capture
]
</code></pre>
<p>It's seems a bit sad to have to say <em>"if you don't ugly up your code with tick marks, it won't be as good... so you should quote your data blocks when they're just data"</em>.</p>
<p>BUT on the other hand, I've definitely seen places where that's a helpful cue that your BLOCK! is in an evaluative context.  So it does have some benefits, and I'm warming up to it.</p>
          <p><a href="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/17">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/17</link>
        <pubDate>Wed, 18 Jun 2025 16:41:12 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-234-17</guid>
        <source url="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234.rss">What happens to function args when the call ends?</source>
      </item>
      <item>
        <title>What happens to function args when the call ends?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>2 posts were split to a new topic: <a href="https://rebol.metaeducation.com/t/what-is-a-frame/2492">What is a FRAME! ?</a></p>
          <p><a href="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/2</link>
        <pubDate>Wed, 18 Jun 2025 15:51:07 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-234-2</guid>
        <source url="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234.rss">What happens to function args when the call ends?</source>
      </item>
      <item>
        <title>What happens to function args when the call ends?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="Mark-hi" data-post="15" data-topic="234" data-full="true">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/mark-hi/48/212_2.png" class="avatar"> Mark-hi:</div>
<blockquote>
<p>What is the mechanism to retain the old behaviour?</p>
</blockquote>
</aside>
<p>The one that you design.</p>
<p>All function invocations use the same "paramlist" (which is also the identity of the function) as the specification of the ordering of the keys of the frame.  Each invocation of a function starts with an unmanaged "varlist" of equal or greater length (which may be recycled from other calls) to hold the values for that frame.  This varlist starts out unmanaged, but may become managed if a reference to the frame "leaks".</p>
<p>Here you can see when the function call finishes, the behavior of what it does with frames that were never managed vs. if they were discovered to be managed.  Previously, discovery that a frame had become managed would collapse the series node and free its data allocation.  It had to keep the stub around because otherwise pointer dereferences would crash.  Most of the change is to change this to leave the managed frame as-is and allow its references to continue resolving:</p>
<p><a href="https://github.com/metaeducation/ren-c/pull/1015/files#diff-94ddbdf54cabd760b45d9ca65e2739b2R703">https://github.com/metaeducation/ren-c/pull/1015/files#diff-94ddbdf54cabd760b45d9ca65e2739b2R703</a></p>
<p><em>(Technically speaking, in the "unavailable" node strategy once the GC sees that a reference points to a stub, it could re-point the reference to a canon "unavailable" stub...and free memory for the stub it was pointing to.  This would lose some amount of added information, e.g. knowing the paramlist of the specific function that was called.  It was never implemented just for that reason--of making debugging harder.)</em></p>
<p>Anyway...the mechanisms are still there, but I'm convinced of what the default should be (and now quite convinced in the FUNC/FUNCTION synonym as well).</p>
          <p><a href="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/16">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/16</link>
        <pubDate>Sun, 29 Sep 2019 05:35:44 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-234-16</guid>
        <source url="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234.rss">What happens to function args when the call ends?</source>
      </item>
      <item>
        <title>What happens to function args when the call ends?</title>
        <dc:creator><![CDATA[Mark-hi]]></dc:creator>
        <description><![CDATA[
            <p>What is the mechanism to retain the old behaviour? Can I "unbind" locals and have deeper function calls fail to find them?</p>
          <p><a href="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/15">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/15</link>
        <pubDate>Sun, 29 Sep 2019 05:25:46 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-234-15</guid>
        <source url="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234.rss">What happens to function args when the call ends?</source>
      </item>
      <item>
        <title>What happens to function args when the call ends?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="12" data-topic="234">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'm definitely leaning there now myself. It goes without saying that if JavaScript can do something extremely useful that we can't do, that is bad.</p>
</blockquote>
</aside>
<p>This feels like justification in and of itself.  I feel like most of the future users are going to be coming from a JavaScript-heavy background.  We have to avoid making choices that make the language seem inferior or incapable of handling common and useful idioms.</p>
<p>The deed is done:</p>
<aside class="onebox githubpullrequest" data-onebox-src="https://github.com/metaeducation/ren-c/pull/1015">
  <header class="source">

      <a href="https://github.com/metaeducation/ren-c/pull/1015" target="_blank" rel="noopener">github.com/metaeducation/ren-c</a>
  </header>

  <article class="onebox-body">
    <div class="github-row" data-github-private-repo="false">



    <div class="github-icon-container" title="Pull Request">
      <svg width="60" height="60" class="github-icon" viewBox="0 0 12 16" aria-hidden="true"><path fill-rule="evenodd" d="M11 11.28V5c-.03-.78-.34-1.47-.94-2.06C9.46 2.35 8.78 2.03 8 2H7V0L4 3l3 3V4h1c.27.02.48.11.69.31.21.2.3.42.31.69v6.28A1.993 1.993 0 0 0 10 15a1.993 1.993 0 0 0 1-3.72zm-1 2.92c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2zM4 3c0-1.11-.89-2-2-2a1.993 1.993 0 0 0-1 3.72v6.56A1.993 1.993 0 0 0 2 15a1.993 1.993 0 0 0 1-3.72V4.72c.59-.34 1-.98 1-1.72zm-.8 10c0 .66-.55 1.2-1.2 1.2-.65 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2zM2 4.2C1.34 4.2.8 3.65.8 3c0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2z"></path></svg>
    </div>

  <div class="github-info-container">



      <h4>
        <a href="https://github.com/metaeducation/ren-c/pull/1015" target="_blank" rel="noopener">Switch to indefinite lifetime for function args/locals</a>
      </h4>

    <div class="branches">
      <code>master</code> ← <code>hostilefork:indefinite-lifetime</code>
    </div>

      <div class="github-info">
        <div class="date">
          opened <span class="discourse-local-date" data-format="ll" data-date="2019-09-28" data-time="23:57:00" data-timezone="UTC">11:57PM - 28 Sep 19 UTC</span>
        </div>

        <div class="user">
          <a href="https://github.com/hostilefork" target="_blank" rel="noopener">
            <img alt="" src="https://avatars.githubusercontent.com/u/20440?v=4" class="onebox-avatar-inline" width="20" height="20">
            hostilefork
          </a>
        </div>

        <div class="lines" title="1 commits changed 4 files with 51 additions and 26 deletions">
          <a href="https://github.com/metaeducation/ren-c/pull/1015/files" target="_blank" rel="noopener">
            <span class="added">+51</span>
            <span class="removed">-26</span>
          </a>
        </div>
      </div>
  </div>
</div>

  <div class="github-row">
    <p class="github-body-container">Ren-C brought in a "reasonable cost" model for "specific binding",
which is the<span class="show-more-container"><a href="https://github.com/metaeducation/ren-c/pull/1015" target="_blank" rel="noopener" class="show-more">…</a></span><span class="excerpt hidden"> idea that WORD!s bound in the body of functions retain
a memory to which instantiation of that function they are for.  (This
replaced a technique of walking the stack to presume a word should
always be looked up in the most recent invocation of a function.)

However, when functions would finish the Drop_Action() call they'd mark
the frame of that specific instance as expired.  This was done due
to a belief that it would be expensive if an object instance (with
as many cells as a function had parameters and locals) would be kept
alive on every usermode function call after the call ended.  The
result would be an increased tax on the GC, creating one object per
(usermode) function call.

Desire to avoid that inefficiency ran up against the practical desire
of the semantics provided by what R3-Alpha called "CLOSURE".  A closure
would allow words to have a binding that survived the end of a
function call:

    r3-alpha&gt;&gt; foo: function [x] [return [x]]
    r3-alpha&gt;&gt; data: foo 10
    == [x]
    r3-alpha&gt;&gt; reduce data
    ** Script error: x word is not bound to a context

    r3-alpha&gt;&gt; foo: closure [x] [return [x]]
    r3-alpha&gt;&gt; data: foo 10
    == [x]
    r3-alpha&gt;&gt; reduce data
    == [10]

All things being equal, this behavior is usually the more desirable
one.  Especially when coding in an environment where functions must
frequently remove themselves from the stack and provide callbacks,
it helps if those callbacks can retain state from the environment
in which they were constructed.  As a canonical example:

    foo: function [x] [
        let y: 10
        return function [z] [x + y + z]
    ]

The generated function which is returned will be useless if x and y
are not still live after FOO has returned.

When considering the big picture--especially when trying to convince
JavaScript users that Rebol is a good language--it does not make sense
to make them need to learn a distinct word or concept to get this
feature.  Instead, the pressure should be on the system to optimize
and recycle frames that did not leak word references in this way.  Or
on those seeking optimization to use a special form of function that
does not permit this due to frame expiration.

This is a "future bet" on what the long tail of the language needs to
pick as its defaults.</span></p>
  </div>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>There's already some optimization and detection of cases that "leak" words.  This detection is good enough that natives don't persist their frames (unless you get references to it via the debugger).  e.g. the optimization is not "it's a native" but "no references to words bound into the frame escaped".</p>
<p>We'll just have to commit to doing better with performance (and it actually doesn't seem terrible at the moment).  But the usermode experience needs to be the "timeless" one.</p>
          <p><a href="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/14">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/14</link>
        <pubDate>Sun, 29 Sep 2019 03:47:32 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-234-14</guid>
        <source url="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234.rss">What happens to function args when the call ends?</source>
      </item>
      <item>
        <title>What happens to function args when the call ends?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="draegtun" data-post="4" data-topic="234">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/draegtun/48/230_2.png" class="avatar"> draegtun:</div>
<blockquote>
<p>As per <a href="https://github.com/metaeducation/ren-c/issues/605">Github issue 605 </a> my preference is for <em>automatic closure-i-fication</em></p>
</blockquote>
</aside>
<p>As the question of what makes a language "timeless" has become central, we can't let JavaScript have the upper hand here.  There are too many uses for this.</p>
<p>With the impending unification of <a href="https://rebol.metaeducation.com/t/abbreviations-as-synonyms/1211">FUNC and FUNCTION as synonyms</a>, I think we should fold in indefinite lifetime as the default.  Frames will also be smaller, because locals will be managed using a different technique.</p>
<p>There's a lot of optimization possible--and the codebase is under control to try it.</p>
          <p><a href="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/13">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/13</link>
        <pubDate>Tue, 24 Sep 2019 08:27:13 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-234-13</guid>
        <source url="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234.rss">What happens to function args when the call ends?</source>
      </item>
      <item>
        <title>What happens to function args when the call ends?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="234">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><span class="mention">@Ladislav</span> had a compelling case:</p>
<pre><code>foo: function [x] [
    y: 10
    return function [z] [x + y + z]
]
</code></pre>
</blockquote>
</aside>
<p>Tinkering with JavaScript a bit, the above pattern is omnipresent.</p>
<aside class="quote no-group" data-username="draegtun" data-post="4" data-topic="234">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/draegtun/48/230_2.png" class="avatar"> draegtun:</div>
<blockquote>
<p>As per Github issue 605  my preference is for automatic closure-i-fication</p>
</blockquote>
</aside>
<p>I'm definitely leaning there now myself.  It goes without saying that if JavaScript can do something extremely useful that we can't do, that is bad.</p>
<p>When I brought this up exactly a year ago, I mentioned a possibility that was emerging:</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="234">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Some new mechanics related to Move_Value() are creating possibilities for “automatic closure-i-fication”, where stack cells are converted into a heap object at the moment it’s noticed that a bound word is “escaping”.  If none escape, then everything stays on the stack.</p>
</blockquote>
</aside>
<p>The infrastructure to do this is there, and it implements a very coarse version of this.  The poor man's version is to consider an "escape" to have happened <em>any time</em> a bound item that is resident in a BLOCK! in an action's body winds up being moved outside of that body.</p>
<p>The optimization that hasn't been done is to detect when a word bound to a frame is moved into a cell belonging to a frame that will outlive it.  For instance:</p>
<pre><code>below: func [&lt;local&gt; x] [
   x: 10
   above 'x
]

above: func [w [word!] &lt;local&gt; x-reference] [
    x-reference: w
    print get x-reference
]
</code></pre>
<p>There's no technical reason why putting the word for <strong>x</strong> into the <strong>x-reference</strong> local variable should force closure-ification, nor the argument passing into <strong>w</strong>.  Because both w and x-reference are cells in the frame for <strong>above</strong>, which is above the <strong>below</strong> frame.  Since below will outlive above, it can just use the direct pointer to the frame.</p>
<p>Without that, it's extremely coarse.  Half--or more than half--of usermode actions will have to be closure-ified due to something that happens in their body.  (This isn't surprising, because just calling an IF statement and passing a BLOCK! from the body would trigger it...since the optimization hasn't been implemented.  The IF's condition argument is at a higher stack level, but being treated as if it were indefinite lifetime, forcing auto-closure-ification)</p>
<p>Good news is that there are a lot of ways to get that number down, which can now be explored.  And moreover it's good news that the basic mechanism is working (e.g. the mechanism that's even letting escapes start to be counted at all).  Because this mechanism is integral to virtual binding, which is still on the agenda and being enabled by advancements a bit at a time (pun intended).</p>
<p>But overall news is that I'm leaning toward feeling that automatic closure-ification is likely non-negotiable.  Can't let JavaScript be more ergonomic about something like this.</p>
          <p><a href="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/12">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/12</link>
        <pubDate>Mon, 16 Jul 2018 12:14:56 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-234-12</guid>
        <source url="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234.rss">What happens to function args when the call ends?</source>
      </item>
      <item>
        <title>What happens to function args when the call ends?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p><a href="https://rebol.metaeducation.com/t/old-closure-tests/2493">For the moment, I am going to kill CLOSURE.</a>  Also, locals to a FUNCTION which are leaked past that function's lifetime will give an error when accessed.</p>
<p>To facilitate this, I've turned it around so that USE is now its own native (as opposed to being built on CLOSURE) whose rebound body will have bindings that outlive the USE (since it creates an OBJECT!).</p>
<p>That means it's easy enough to write:</p>
<pre><code> foo: function [a b &lt;local&gt; c d] [
     use [e f] [
         ;-- e and f will be alive after function call ends
     ]
 ]
</code></pre>
<p><a class="mention" href="https://rebol.metaeducation.com/u/draegtun">@draegtun</a>  <em>Note: If this is the intended semantics for <code>USE</code>, then <code>&lt;USE&gt;</code> might be even better than <code>&lt;HAS&gt;</code> in the function spec.  :-/  I don't know.  It's a question of how often USE intended indefinite lifetime...</em></p>
<p>This is not the pinnacle of efficiency, since USE doesn't have the same power the system does to avoid copying and rebinding (<em>yet</em>).  BUT it's far more taxing on the system to be stuck assuming that you always want leaked args and local words to have indefinite binding lifetimes.  And as we've emphasized above, I've become wary of the idea that survival-by-default is even a desirable semantic, when Rebol's model leaks bindings unintentionally all over the place.</p>
<p>More importantly, this unblocks the development of new and interesting ideas in the core, which might even be able to make the deep binding that USE does "closer to free".</p>
<p>Looking back at Ladislav's "good" example of closure necessity...</p>
<pre><code>foo: function [x] [
    y: 10
    return function [z] [x + y + z]
]
</code></pre>
<p>His point being that the returned function is useless if x and y are expired references once foo is off the stack.  It is a compelling case, but...</p>
<p>...it suggests that if anything, the "closuring" is a property of the usage.  Why would you be annotating foo to say it's a "special kind of function whose variables outlive its call", as opposed to annotating the returned function has "special kinds of references"?:</p>
<pre><code>foo: function [x] [
    y: 10
    return function [z &lt;use&gt; x y] [x + y + z]
]
</code></pre>
<p>To my mind this makes a lot more sense.  If you delete the motivating usage you don't have to update anything about the enclosing function.</p>
<p>Whether <code>&lt;use&gt;</code>-ing is automatic or not is another question.  But that aside, I do think that the existence of a CLOSURE function or a CLOSURE! datatype is not the answer.</p>
          <p><a href="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/9">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/9</link>
        <pubDate>Sat, 09 Sep 2017 22:54:29 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-234-9</guid>
        <source url="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234.rss">What happens to function args when the call ends?</source>
      </item>
      <item>
        <title>What happens to function args when the call ends?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>From an implementation point of view, there's some stuff I really need to get integrated on a branch that's been hanging around too long and I'm tired of rebasing it.  It contains the first inklings of virtual binding, but there simply are mechanical problems with using it with persistent parameters/refinements/locals.  These problems may not be forever, but they are there for now.</p>
<p>So how bad would be if, <em>for the moment</em>, args and locals and refinements did not outlive the call.  Then, <code>&lt;has&gt;</code> was changed to be different from <code>&lt;static&gt;</code> to mean <em>per-instance</em> values.  It would be an optimized way of reusing a function's frame node (pointing at stack data) to also act as the node for the portion that outlives the invocation, and duck further problems for now?  This means USE can still be written as <strong>eval func compose [ (args)] body</strong> or similar (not that this is the greatest idea in the first place).</p>
<p>It's a first step that doesn't throw out much infrastructure for changing our minds later.  If virtual binding gets further, we'll know a lot more about how everything <em>could</em> work...which will likely affect these discussions.</p>
          <p><a href="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/8">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/8</link>
        <pubDate>Wed, 16 Aug 2017 03:18:51 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-234-8</guid>
        <source url="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234.rss">What happens to function args when the call ends?</source>
      </item>
      <item>
        <title>What happens to function args when the call ends?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="draegtun" data-post="6" data-topic="234">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/draegtun/48/230_2.png" class="avatar"> draegtun:</div>
<blockquote>
<p>Anyway more food for thought!</p>
</blockquote>
</aside>
<p>Yup, and along the lines of things I've considered.</p>
<p>But the central questions remain ones we can sort of discuss abstractly.  Like do you really want locals to be surviving by default, on accident?</p>
<p>I guess if we can agree that survive-by-default is a bad thing, and that CLOSURE is too broad a brush to include in the box, then all we're down to is the question above about when you want to mark an argument as durable.</p>
          <p><a href="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/7">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/7</link>
        <pubDate>Tue, 15 Aug 2017 15:24:00 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-234-7</guid>
        <source url="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234.rss">What happens to function args when the call ends?</source>
      </item>
      <item>
        <title>What happens to function args when the call ends?</title>
        <dc:creator><![CDATA[draegtun]]></dc:creator>
        <description><![CDATA[
            <p>NB. Here's my idea from chat. However after reading your explanation more closely I may end of treading over same ground <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>If <code>&lt;has&gt;</code> is the way to go then we could possible solve the feather ruffling by a bit of extra FUNCTION generating (ie. pre-processor/macro).</p>
<p>So for the following simple example:</p>
<pre><code>foo: function [x [&lt;durable&gt;]] [
    function [y] [x + y]
]
</code></pre>
<p>FUNCTION could pre-expand this into (something like) this:</p>
<pre><code>foo: function [`x has x] [
    x: `x
    function [y] [x + y]
]
</code></pre>
<p>The use of backtick is just for an example.  In Lisp you have <a href="http://clhs.lisp.se/Body/f_gensym.htm"><code>GENSYM</code></a> for creating symbols (ie. words) which don't stomp on anything else.</p>
<p>My spec is also just an example.  If we could work out what all the closed-over words are then you could go for <code>FUNCTION [x] [...]</code>.  Alternatively it could be <code>CLOSURE [x] [...]</code></p>
<p>Obviously the bound words would still be exposed but it is controlled and easily identifiable (by nomenclature convention).</p>
<p>Anyway more food for thought!</p>
          <p><a href="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/6">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/6</link>
        <pubDate>Sun, 06 Aug 2017 13:40:13 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-234-6</guid>
        <source url="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234.rss">What happens to function args when the call ends?</source>
      </item>
      <item>
        <title>What happens to function args when the call ends?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="draegtun" data-post="4" data-topic="234">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/draegtun/48/230_2.png" class="avatar"> draegtun:</div>
<blockquote>
<p>However the x2 in the &lt;has&gt; workaround ruffles my feathers a bit</p>
</blockquote>
</aside>
<p>There's a mechanical reason.  Briefly:</p>
<p>Let's imagine you are calling a function and it has 10 arguments, refinements, and refinement arguments.  To fulfill each of the arguments involves an evaluation.  During any evaluation a garbage collection may occur.</p>
<p>So let's say your function has fulfilled argument 1, and gets to argument 2.  And let's say there is a lot of computation to do to supply argument 2--enough so that a GC is triggered.</p>
<p>This GC needs to know about argument 1 and not free any resources held onto by argument 1.  And if argument 2 has been partially or temporarily evaluated, that needs to be taken care of as well (hence the argument slot is initialized with GC-readable "nothingness" before the evaluation starts, and during evaluation must stay GC-readably-legit in some way).  But the GC must know not to look at 3-10 because those are still raw uninitialized bits.</p>
<p>One possibility would be to do a pre-walk and format cells 3-10 to not be random noise.  R3-Alpha did this.  But the frame knows how far along in argument processing it is, so if when the GC runs it can look at the frame stack and know where to stop.  That's cheaper than needing to do two separate walks of the arguments on every function call.</p>
<p>So we happily avoid pre-walking the cells, and the evaluator itself just initializes cells as it goes along fulfilling arguments.  Unfortunately, the formatting process is different for stack cells and indefinite lifetime cells, which live in arrays.  If argument fulfillment has to be sensitive to whether that argument will live indefinitely, then you <em>have</em> to pre-walk it in the stack case...to initialize with bits that can be sniffed by the evaluator.</p>
<p>By splitting it out so that ordinary arguments and locals are known to always have stack lifetime, then the formatting process doesn't have to worry about the cell's previous formatting bits.  It can just write stack initialization into it.</p>
<p>So if we can promise we aren't ever going to do argument evaluation into cells with indefinite lifetime (e.g. no  slots that are also args) then it's more efficient.  That said, users can be made unaware of this at a higher level... the "real argument" could be named out of the way somehow, and then the durable non-argument could take the argument's name and proxy its value once the function started running.</p>
<p>But such things can get messy.  (what about an adaptation, how would it know about the funny named variable that actually has the argument it's interested in?) So for starters, I'd rather have the underlying mechanic and "rules of the game" visible so people understand what's happening.</p>
          <p><a href="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/5">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/5</link>
        <pubDate>Fri, 04 Aug 2017 22:36:00 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-234-5</guid>
        <source url="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234.rss">What happens to function args when the call ends?</source>
      </item>
      <item>
        <title>What happens to function args when the call ends?</title>
        <dc:creator><![CDATA[draegtun]]></dc:creator>
        <description><![CDATA[
            <p>As per <a href="https://github.com/metaeducation/ren-c/issues/605">Github issue 605 </a> my preference is for <em>automatic closure-i-fication</em></p>
<p>Then if you want to avoid any unintentional escapes perhaps add a new function spec tag like <code>&lt;safe&gt;</code> (or similar.. for eg. <code>&lt;pure&gt;</code> , <code>&lt;cleaned&gt;</code>) which then automatically UNBIND/DEEP any returning BLOCK!</p>
<p>PS.  I'm a pragmatist and so if there are too many costs involved with <em>automatic closure-i-fication</em> then I'm happy to leave FUNCTION has is and use <code>&lt;has&gt;</code>, <code>&lt;durable&gt;</code> or even keep CLOS/CLOSURE wrapper.</p>
<p>PPS.  However the <code>x2</code> in the <code>&lt;has&gt;</code> workaround ruffles my feathers a bit <img src="https://rebol.metaeducation.com/images/emoji/twitter/slight_smile.png?v=14" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20">   I'd prefer to go  with something like:</p>
<pre><code>foo: function [&lt;durable&gt; x &lt;has&gt; y] [
    y: 10
    function [z] [x + y + z]
]
</code></pre>
<p>In fact I'd go further and do this:</p>
<pre><code>foo: function [x [&lt;durable&gt;] &lt;has&gt; y (10)] [
    function [z] [x + y + z]
]
</code></pre>
<p>if we can tag individual args?  Could be a handy feature going forward for other things!</p>
          <p><a href="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/4</link>
        <pubDate>Wed, 02 Aug 2017 17:13:25 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-234-4</guid>
        <source url="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234.rss">What happens to function args when the call ends?</source>
      </item>
      <item>
        <title>What happens to function args when the call ends?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>R3-Alpha's CLOSURE provided two things.  One was a unique identity for the words of a function's arguments and locals for each recursion.  <a href="https://rebol.metaeducation.com/t/relative-binding-and-frame-internals/1344">This is what I've called "specific binding"</a> and now comes "for free" in <em>all</em> functions...so you don't even have to think about it.  (It's not exactly free, but we can hope it will converge to "very low cost".)</p>
<p>So in Ren-C:</p>
<pre><code>&gt;&gt; foo: function [x code] [
    append code $(print x)  ; 2025-update: use bound group!
    if x &gt; 0 [
        probe code
        eval code
        foo (x - 1) code
    ]
]

&gt;&gt; foo 2 []
[(print x)]
2
[(print x) (print x)]
2 ;-- R3-Alpha FUNCTION! got 1, only CLOSURE! got 2
1
</code></pre>
<p>Users can now take that for granted.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/thumbsup.png?v=14" title=":thumbsup:" class="emoji" alt=":thumbsup:" loading="lazy" width="20" height="20"></p>
<p>But what I want to talk about is the <strong>other</strong> emergent feature of R3-Alpha CLOSURE!.  This was that if an ANY-WORD! that was bound to the arguments or locals "escaped" the lifetime of the call, that word would continue to have its value after the function ended...for as long as references to it existed.</p>
<pre><code>&gt;&gt; f: closure [x] [return [x]]

&gt;&gt; b: f 10
== [x]

&gt;&gt; reduce b
[10]
</code></pre>
<p>Functions did not do this:</p>
<pre><code>&gt;&gt; f: function [x] [return [x]]

&gt;&gt; b: f 10
== [x]

&gt;&gt; reduce b
** Script error: x word is not bound to a context
</code></pre>
<p>It goes without saying that the closure mechanic is going to cost more, just by the very fact that they need to hold onto the memory for what the word looks up to.  But the way things work today, it doesn't just need to hold onto that cell of data...it holds onto all the args and locals of the function.  (R3-Alpha was more inefficient still...it not only kept the whole frame of values alive, it made a deep copy of the function body <em>on every invocation of that function</em>...so that the body could be updated to refer to that "frame".  Specific binding lets Ren-C dodge that bullet.)</p>
<p>Now and again, the "keep-things-simple" voice says that the system would be simpler and faster if all executing frames (and their frame variables) died after a function ended.  If you wanted to snapshot the state of a FRAME! for debugging purposes--to look at after the function ends--you could COPY it into a heap-based object, and return that.  If you really were in one of the circumstances where you wanted an arg or local's word to survive, you could manually make an object to hold just those words, and bind to that.</p>
<p>But <span class="mention">@Ladislav</span> had a compelling case:</p>
<pre><code>foo: function [x] [
    y: 10
    return function [z] [x + y + z]
]
</code></pre>
<p>If <code>x</code> and <code>y</code> were to go bad after foo exited, the returned function would be useless.</p>
<p>Some new mechanics related to Move_Value() are creating possibilities for "automatic closure-i-fication", where stack cells are converted into a heap object at the moment it's noticed that a bound word is "escaping".  If none escape, then everything stays on the stack.</p>
<p>But though you might think these kinds of escapes are rare, remember some bindings aren't even intentional.  When you return a block out of a function it might just have stray bindings on words that <em>happen</em> to overlap with something in the binding visibility.  (Which makes one wonder, when returning a BLOCK! as data, should you always UNBIND/DEEP it before returning...to scrub off any inadvertent pointers into your local state it carries?  Should there be a RETURN/BOUND to avoid the scrub?)  These invisible bindings would trigger the auto-closurification, on what might seem like random cases to the user.</p>
<p>And remember--each time a word bound to a frame escapes--we're still talking about copying <em>all</em> the values in the frame.  (It might be possible to break this down to a smaller granularity, e.g. a PAIR!-wise binding, where what closure-i-fication does is pack each key/value into a REBSER node.)</p>
<p>Were the user to get involved, and specify the cases, I might suggest something a bit like this (if <code>&lt;HAS&gt;</code> were taken to mean "a kind of per-instance static", while <code>&lt;STATIC&gt;</code> were used for all instances):</p>
<pre><code>foo: function [x &lt;has&gt; x2 y] [
    x2: x
    y: 10
    return function [z] [x2 + y + z]
] 
</code></pre>
<p>The advantages to this are that it would mean that any words that "escape" would be explicitly handled by the user, reducing the burden on the system.  The entire frame would not need to be preserved, only the part of the frame which had these persistent values.  The disadvantage is that it's not automatic, and other languages--even JavaScript--do it automatically.</p>
<p>So how do people feel on this matter?  What's acceptable or unacceptable?  <span class="mention">@MarkI</span> said at one point that he was opposed to locals and args outliving the function call because it created "garbage".  Is it wise to hide the consequences from the user, and burden the system with the logic of making it automatic?</p>
          <p><a href="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/1</link>
        <pubDate>Mon, 31 Jul 2017 21:38:40 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-234-1</guid>
        <source url="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234.rss">What happens to function args when the call ends?</source>
      </item>
  </channel>
</rss>

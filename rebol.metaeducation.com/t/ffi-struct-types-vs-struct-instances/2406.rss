<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>FFI STRUCT! Types vs. STRUCT! Instances</title>
    <link>https://rebol.metaeducation.com/t/ffi-struct-types-vs-struct-instances/2406</link>
    <description>The original Rebol concept behind STRUCT! kind of paralleled OBJECT!, in the sense that there was no separation between the archetype and the instance.

From the [Rebol2/Command Documentation](https://www.rebol.com/docs/library.html#struct):

    a-struct: make struct! [
        in-string [string!] &quot;Input string&quot;
        in-int [integer!] &quot;Input integer&quot;
    ] [&quot;This is input&quot; 42]

So just as how OBJECT! has no abstract &quot;Class&quot; with no data--that it then instantiates with data--every STRUCT! is an instance. 

**This isn&#39;t how the C which this is trying to model works, and I&#39;m not sure it&#39;s a great plan for a language like Rebol either.**

I&#39;d rather you&#39;d be able to break this apart:

    input-struct!: struct [
        in-string [string!] &quot;Input string&quot;
        in-int [integer!] &quot;Input integer&quot;
    ]

    a-struct: make input-struct! [&quot;This is input&quot; 42]

When broken up in this way, the design gets *much* clearer.

**Plus I think we have a fighting chance now to be able to get type checking for specific structure types.**

I think it&#39;s close to where the system can reasonably come up with answers for TYPE OF that are more specific.

    &gt;&gt; type of input-struct!
    == ~{struct!}~  ; anti

    &gt;&gt; type of a-struct
    == ~{input-struct!}~  ; anti

And going along with that, more specific type checking:

    get-input: func [
        return: [input-struct!]
    ][
        return make input-struct! [&quot;Imagine this getting typechecked!&quot; 1020]
    ]

I see a lot of value in that, while I see little to no upside in having everywhere that takes any structure type only be able to say &quot;STRUCT!&quot;.

Plus, there&#39;d be two independently queryable entities, which could react to PICK-ing in different ways... one by letting you access the schema (because it has no data), and the other by giving you the data:

    &gt;&gt; input-struct!.in-int
    == #[field! [integer!] &quot;Input integer&quot;]

    &gt;&gt; a-struct.in-int
    == &quot;This is input&quot;

**I know we&#39;ve wanted it for objects, but FFI might get it first...**

FFI may be a good prototyping environment for doing this just because it&#39;s tangential to the main system operation, and it&#39;s easier to muck around with it.

Once the theory is worked out and polished, it could be brought to bear on objects.</description>
    
    <lastBuildDate>Wed, 09 Apr 2025 14:53:15 +0000</lastBuildDate>
    <category>FFI</category>
    <atom:link href="https://rebol.metaeducation.com/t/ffi-struct-types-vs-struct-instances/2406.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>FFI STRUCT! Types vs. STRUCT! Instances</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>The original Rebol concept behind STRUCT! kind of paralleled OBJECT!, in the sense that there was no separation between the archetype and the instance.</p>
<p>From the <a href="https://www.rebol.com/docs/library.html#struct">Rebol2/Command Documentation</a>:</p>
<pre><code>a-struct: make struct! [
    in-string [string!] "Input string"
    in-int [integer!] "Input integer"
] ["This is input" 42]
</code></pre>
<p>So just as how OBJECT! has no abstract "Class" with no data--that it then instantiates with data--every STRUCT! is an instance.</p>
<p><strong>This isn't how the C which this is trying to model works, and I'm not sure it's a great plan for a language like Rebol either.</strong></p>
<p>I'd rather you'd be able to break this apart:</p>
<pre><code>input-struct!: struct [
    in-string [string!] "Input string"
    in-int [integer!] "Input integer"
]

a-struct: make input-struct! ["This is input" 42]
</code></pre>
<p>When broken up in this way, the design gets <em>much</em> clearer.</p>
<p><strong>Plus I think we have a fighting chance now to be able to get type checking for specific structure types.</strong></p>
<p>I think it's close to where the system can reasonably come up with answers for TYPE OF that are more specific.</p>
<pre><code>&gt;&gt; type of input-struct!
== ~{struct!}~  ; anti

&gt;&gt; type of a-struct
== ~{input-struct!}~  ; anti
</code></pre>
<p>And going along with that, more specific type checking:</p>
<pre><code>get-input: func [
    return: [input-struct!]
][
    return make input-struct! ["Imagine this getting typechecked!" 1020]
]
</code></pre>
<p>I see a lot of value in that, while I see little to no upside in having everywhere that takes any structure type only be able to say "STRUCT!".</p>
<p>Plus, there'd be two independently queryable entities, which could react to PICK-ing in different ways... one by letting you access the schema (because it has no data), and the other by giving you the data:</p>
<pre><code>&gt;&gt; input-struct!.in-int
== #[field! [integer!] "Input integer"]

&gt;&gt; a-struct.in-int
== "This is input"
</code></pre>
<p><strong>I know we've wanted it for objects, but FFI might get it first...</strong></p>
<p>FFI may be a good prototyping environment for doing this just because it's tangential to the main system operation, and it's easier to muck around with it.</p>
<p>Once the theory is worked out and polished, it could be brought to bear on objects.</p>
          <p><a href="https://rebol.metaeducation.com/t/ffi-struct-types-vs-struct-instances/2406/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/ffi-struct-types-vs-struct-instances/2406/1</link>
        <pubDate>Wed, 09 Apr 2025 08:35:18 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2406-1</guid>
        <source url="https://rebol.metaeducation.com/t/ffi-struct-types-vs-struct-instances/2406.rss">FFI STRUCT! Types vs. STRUCT! Instances</source>
      </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>OPT(IONAL) and Packs-With-Nulls</title>
    <link>https://rebol.metaeducation.com/t/opt-ional-and-packs-with-nulls/2435</link>
    <description>Antiform packs that contain pure nulls, e.g. the &quot;heavy null&quot; **`~[~null~]~`**, are a cornerstone of how Ren-C handles the situation of a branch that returns null... to avoid having such branches run, and then pass control to an ELSE even though the branch was executed.

This is both beautiful and a thorny edge case.  Some constructs want to treat a boxed null just the same as an unboxed one.  Others don&#39;t.  It can be a bit hairy.

So to reserve the functionality for just pure nulls and branches... I discourage the creation of packs with nulls in them for the ordinary functioning of routines--if you can avoid it (you sometimes can&#39;t).  The general rule of thumb is that your functions should not put nulls in packs, and if they ever return null it should be the *only* return--not in a pack.  (Similar guidance discourages putting error antiforms in packs, but making it the overall result.)

## Case Study: SPLIT-PATH

So the SPLIT-PATH function in Ren-C is a multi-return, giving you two parts: the file component, and the path component:

    &gt;&gt; meta split-path %foo/bar.txt
    == ~[&#39;%foo/ &#39;%bar.txt]~

    &gt;&gt; split-path %foo/bar.txt
    == %foo/

It seemed that a lot of calls to it wanted the directory, so I made that the first return.

The problem arises when a component is missing:

    &gt;&gt; meta split-path %bar.txt
    == ~[~null~ &#39;%bar.txt]~

    &gt;&gt; split-path %bar.txt
    == ~null~  ; anti

Why is this a problem?  Well, there are functions such as OPT that don&#39;t want to decay their arguments... but rather be driven by pure nulls.  So this gives:

    &gt;&gt; decay opt split-path %bar.txt
    == ~null~  ; anti

Not what the person using OPT wanted.  They wanted VOID.

You might address this by decaying your null value before passing it to OPT.

    &gt;&gt; opt decay split-path %bar.txt
    == ~[]~  ; anti

This is a bit of a bummer.  Making OPT decay things removes a safeguard I was fond of, which is catching situations where you expected a branching construct to produce something if it ran:

    &gt;&gt; compose [a (? if 1 &lt; 2 [... code that inadvertently makes null ...]) c]
    == [a c]

My feeling here is that the ? isn&#39;t a carte-blanche on null-producing branches... it&#39;s to address the fact that we have to make IF return null instead of void (as void triggers THEN and not ELSE, by design).

## Are There Just Different Types Of OPT

The default OPT(IONAL) has to be willing to decay a pack that&#39;s got a ~null~ in the first slot.

But maybe the ? form refuses to and gives an informative error.... *to say the null arose from a branch, not from the failure to execute a branch.*

If it were done with a refinement it would be OPT:LIGHT, I guess (?)

(Because I think PURE will be coming soon for pure functions with no side-effects, I want to stop saying &quot;pure null&quot; for a null that&#39;s not in a pack.  I&#39;m okay calling it &quot;light null&quot; compared to &quot;heavy null&quot; because the terms aren&#39;t really used elsewhere.)</description>
    
    <lastBuildDate>Sat, 10 May 2025 04:19:46 +0000</lastBuildDate>
    <category>Semantics</category>
    <atom:link href="https://rebol.metaeducation.com/t/opt-ional-and-packs-with-nulls/2435.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>OPT(IONAL) and Packs-With-Nulls</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2435">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But maybe the ? form refuses to and gives an informative error.... <em>to say the null arose from a branch, not from the failure to execute a branch.</em></p>
<p>If it were done with a refinement it would be OPT:LIGHT, I guess (?)</p>
</blockquote>
</aside>
<p>So my point here is about suppressing the wrong thing.  I'm not as worried about the branch consciously returning null as I am about it returning some other definitional error, that opt suppresses:</p>
<pre><code>append [a b c] opt case [
    condition1 [... 1 / 0]
    condition2 [...]
]
</code></pre>
<p>The OPT is supposed to get you a VOID from not matching any cases, it's not supposed to be vanishing divide by zero errors on a branch that ran.</p>
<h2><a name="p-8236-all-right-try-has-to-be-taken-out-of-opt-1" class="anchor" href="https://rebol.metaeducation.com#p-8236-all-right-try-has-to-be-taken-out-of-opt-1"></a>All Right, TRY Has To Be Taken Out of OPT</h2>
<pre><code>&gt;&gt; append [a b c] opt pick [a b c] 'd
** Error: Invalid pick 'd in BLOCK
</code></pre>
<p>It doesn't look that bad to say both words, or use the ? abbreviation for OPT:</p>
<pre><code>&gt;&gt; append [a b c] optional try pick [a b c] 'd
== [a b c]

&gt;&gt; append [a b c] opt try pick [a b c] 'd
== [a b c]

&gt;&gt; append [a b c] ? try pick [a b c] 'd
== [a b c]
</code></pre>
<p>BUT there can be an intrinsic version of the combined operation which is aliased as <strong>??</strong>.</p>
<pre><code>&gt;&gt; append [a b c] ? pick [a b c] 'd
** Error: Invalid pick 'd in BLOCK

&gt;&gt; append [a b c] ?? pick [a b c] 'd
== [a b c]
</code></pre>
<p>Seems to me that breaks the intent down pretty well.  Also, this ties into my idea for a VETO operation, which would be <strong>?!</strong> or <strong>??!</strong> ... but I'm getting ahead of myself.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/wink.png?v=14" title=":wink:" class="emoji" alt=":wink:" loading="lazy" width="20" height="20"></p>
          <p><a href="https://rebol.metaeducation.com/t/opt-ional-and-packs-with-nulls/2435/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/opt-ional-and-packs-with-nulls/2435/2</link>
        <pubDate>Sat, 10 May 2025 04:17:25 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2435-2</guid>
        <source url="https://rebol.metaeducation.com/t/opt-ional-and-packs-with-nulls/2435.rss">OPT(IONAL) and Packs-With-Nulls</source>
      </item>
      <item>
        <title>OPT(IONAL) and Packs-With-Nulls</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Antiform packs that contain pure nulls, e.g. the "heavy null" <strong><code>~[~null~]~</code></strong>, are a cornerstone of how Ren-C handles the situation of a branch that returns null... to avoid having such branches run, and then pass control to an ELSE even though the branch was executed.</p>
<p>This is both beautiful and a thorny edge case.  Some constructs want to treat a boxed null just the same as an unboxed one.  Others don't.  It can be a bit hairy.</p>
<p>So to reserve the functionality for just pure nulls and branches... I discourage the creation of packs with nulls in them for the ordinary functioning of routines--if you can avoid it (you sometimes can't).  The general rule of thumb is that your functions should not put nulls in packs, and if they ever return null it should be the <em>only</em> return--not in a pack.  (Similar guidance discourages putting error antiforms in packs, but making it the overall result.)</p>
<h2><a name="p-8206-case-study-split-path-1" class="anchor" href="https://rebol.metaeducation.com#p-8206-case-study-split-path-1"></a>Case Study: SPLIT-PATH</h2>
<p>So the SPLIT-PATH function in Ren-C is a multi-return, giving you two parts: the file component, and the path component:</p>
<pre><code>&gt;&gt; meta split-path %foo/bar.txt
== ~['%foo/ '%bar.txt]~

&gt;&gt; split-path %foo/bar.txt
== %foo/
</code></pre>
<p>It seemed that a lot of calls to it wanted the directory, so I made that the first return.</p>
<p>The problem arises when a component is missing:</p>
<pre><code>&gt;&gt; meta split-path %bar.txt
== ~[~null~ '%bar.txt]~

&gt;&gt; split-path %bar.txt
== ~null~  ; anti
</code></pre>
<p>Why is this a problem?  Well, there are functions such as OPT that don't want to decay their arguments... but rather be driven by pure nulls.  So this gives:</p>
<pre><code>&gt;&gt; decay opt split-path %bar.txt
== ~null~  ; anti
</code></pre>
<p>Not what the person using OPT wanted.  They wanted VOID.</p>
<p>You might address this by decaying your null value before passing it to OPT.</p>
<pre><code>&gt;&gt; opt decay split-path %bar.txt
== ~[]~  ; anti
</code></pre>
<p>This is a bit of a bummer.  Making OPT decay things removes a safeguard I was fond of, which is catching situations where you expected a branching construct to produce something if it ran:</p>
<pre><code>&gt;&gt; compose [a (? if 1 &lt; 2 [... code that inadvertently makes null ...]) c]
== [a c]
</code></pre>
<p>My feeling here is that the ? isn't a carte-blanche on null-producing branches... it's to address the fact that we have to make IF return null instead of void (as void triggers THEN and not ELSE, by design).</p>
<h2><a name="p-8206-are-there-just-different-types-of-opt-2" class="anchor" href="https://rebol.metaeducation.com#p-8206-are-there-just-different-types-of-opt-2"></a>Are There Just Different Types Of OPT</h2>
<p>The default OPT(IONAL) has to be willing to decay a pack that's got a ~null~ in the first slot.</p>
<p>But maybe the ? form refuses to and gives an informative error.... <em>to say the null arose from a branch, not from the failure to execute a branch.</em></p>
<p>If it were done with a refinement it would be OPT:LIGHT, I guess (?)</p>
<p>(Because I think PURE will be coming soon for pure functions with no side-effects, I want to stop saying "pure null" for a null that's not in a pack.  I'm okay calling it "light null" compared to "heavy null" because the terms aren't really used elsewhere.)</p>
          <p><a href="https://rebol.metaeducation.com/t/opt-ional-and-packs-with-nulls/2435/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/opt-ional-and-packs-with-nulls/2435/1</link>
        <pubDate>Mon, 05 May 2025 10:58:36 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2435-1</guid>
        <source url="https://rebol.metaeducation.com/t/opt-ional-and-packs-with-nulls/2435.rss">OPT(IONAL) and Packs-With-Nulls</source>
      </item>
  </channel>
</rss>

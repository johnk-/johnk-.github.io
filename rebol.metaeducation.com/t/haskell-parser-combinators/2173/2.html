<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Haskell parser combinators - #2 by hostilefork - Foreign Inspiration - AltRebol</title>
    <meta name="description" content="I’ve seen a few parsing-related threads recently in this forum. I haven’t been commenting much on them, since I don’t have enough experience with UPARSE (or for that matter historical PARSE) to say anything helpful. 
On &amp;hellip;">
    <meta name="generator" content="Discourse 3.5.0.beta6-dev - https://github.com/discourse/discourse version 623cde985b21c2ed812b83d3ea94f69231613718">
<link rel="icon" type="image/png" href="../../../uploads/default/optimized/1X/cbd70027b53fa165575e5b665f00eb3b8ae7ea31_2_32x32.ico">
<link rel="apple-touch-icon" type="image/png" href="../../../uploads/default/optimized/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d_2_180x180.png">
<meta name="theme-color" media="all" content="#fff">

<meta name="color-scheme" content="light">

<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, viewport-fit=cover">
<link rel="canonical" href="../2173.html" />

<link rel="search" type="application/opensearchdescription+xml" href="../../../opensearch.xml" title="AltRebol Search">

    <link href="https://rebol.metaeducation.com/stylesheets/color_definitions_base__2_ceb61c279a74dfa3cef6a62f7784988102abec82.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" class="light-scheme"/>

<link href="https://rebol.metaeducation.com/stylesheets/common_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="common"  />

  <link href="https://rebol.metaeducation.com/stylesheets/desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="desktop"  />



    <link href="https://rebol.metaeducation.com/stylesheets/chat_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="chat"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-details_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-details"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-lazy-videos_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-lazy-videos"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-local-dates_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-local-dates"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-narrative-bot_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-narrative-bot"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-presence_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-presence"  />
    <link href="https://rebol.metaeducation.com/stylesheets/docker_manager_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="docker_manager"  />
    <link href="https://rebol.metaeducation.com/stylesheets/footnote_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="footnote"  />
    <link href="https://rebol.metaeducation.com/stylesheets/poll_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="poll"  />
    <link href="https://rebol.metaeducation.com/stylesheets/spoiler-alert_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="spoiler-alert"  />
    <link href="https://rebol.metaeducation.com/stylesheets/chat_desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="chat_desktop"  />
    <link href="https://rebol.metaeducation.com/stylesheets/poll_desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="poll_desktop"  />

  <link href="https://rebol.metaeducation.com/stylesheets/common_theme_2_57fe803ed5a41e9f7d94086afaf66a1aab57d9ae.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="common_theme" data-theme-id="2" data-theme-name="default"/>
    

    
    
        <link rel="alternate nofollow" type="application/rss+xml" title="RSS feed of &#39;Haskell parser combinators&#39;" href="../2173.rss" />
    <meta property="og:site_name" content="AltRebol" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:image" content="https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:url" content="https://rebol.metaeducation.com/t/haskell-parser-combinators/2173/2" />
<meta name="twitter:url" content="https://rebol.metaeducation.com/t/haskell-parser-combinators/2173/2" />
<meta property="og:title" content="Haskell parser combinators" />
<meta name="twitter:title" content="Haskell parser combinators" />
<meta property="og:description" content="Thank you for summarizing!  I&#39;ve written a little here before:  PARSE vs. Haskell&#39;s (X)PARSEC  Parser combinators were not an influence on the original Rebol PARSE (circa 90s), but were what I drew inspiration from for UPARSE.   One thing to notice is that UPARSE doesn&#39;t have a sequencing combinator.  Instead, it has a BLOCK! combinator.  And it&#39;s the BLOCK! combinator that generally does the &quot;combinating&quot;.  It can technically be replaced, but it is the most complex combinator and so difficult t..." />
<meta name="twitter:description" content="Thank you for summarizing!  I&#39;ve written a little here before:  PARSE vs. Haskell&#39;s (X)PARSEC  Parser combinators were not an influence on the original Rebol PARSE (circa 90s), but were what I drew inspiration from for UPARSE.   One thing to notice is that UPARSE doesn&#39;t have a sequencing combinator.  Instead, it has a BLOCK! combinator.  And it&#39;s the BLOCK! combinator that generally does the &quot;combinating&quot;.  It can technically be replaced, but it is the most complex combinator and so difficult t..." />
<meta property="og:article:section" content="Development" />
<meta property="og:article:section:color" content="25AAE2" />
<meta property="og:article:section" content="Foreign Inspiration" />
<meta property="og:article:section:color" content="25AAE2" />
<meta property="article:published_time" content="2024-03-12T05:24:52+00:00" />
<meta property="og:ignore_canonical" content="true" />


    
  </head>
  <body class="crawler ">
    
    <header>
  <a href="https://rebol.metaeducation.com/">AltRebol</a>
</header>

    <div id="main-outlet" class="wrap" role="main">
        <div id="topic-title">
    <h1>
      <a href="../2173.html">Haskell parser combinators</a>
    </h1>

      <div class="topic-category" itemscope itemtype="http://schema.org/BreadcrumbList">
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="../../../c/development/foreign-inspiration.html" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #25AAE2'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Development</span>
              </span>
            </a>
            <meta itemprop="position" content="1" />
          </span>
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="../../../c/development/foreign-inspiration.html" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #25AAE2'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Foreign Inspiration</span>
              </span>
            </a>
            <meta itemprop="position" content="2" />
          </span>
      </div>

  </div>

  

    <div itemscope itemtype='http://schema.org/DiscussionForumPosting'>
      <meta itemprop='headline' content='Haskell parser combinators'>
      <link itemprop='url' href='../2173.html'>
      <meta itemprop='datePublished' content='2024-03-11T15:08:10Z'>
        <meta itemprop='articleSection' content='Foreign Inspiration'>
      <meta itemprop='keywords' content=''>
      <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
        <meta itemprop='name' content='AltRebol'>
          <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
            <meta itemprop='url' content='https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
          </div>
      </div>

          <span itemprop='author' itemscope itemtype="http://schema.org/Person">
            <meta itemprop='name' content='bradrn'>
            <link itemprop='url' rel='nofollow' href='https://rebol.metaeducation.com/u/bradrn'>
          </span>
        <meta itemprop='text' content='I’ve seen a few parsing-related threads recently in this forum. I haven’t been commenting much on them, since I don’t have enough experience with UPARSE (or for that matter historical PARSE) to say anything helpful. 
On &amp;hellip;'>

          <div id='post_2' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2024-03-12T05:24:52Z' class='post-time'>
                    March 12, 2024,  5:24am
                  </time>
                  <meta itemprop='dateModified' content='2025-05-07T12:16:50Z'>
              <span itemprop='position'>2</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>Thank you for summarizing!  I've written a little here before:</p>
<p><a href="../../parse-vs-haskells-x-parsec/1321.html" class="inline-onebox">PARSE vs. Haskell's (X)PARSEC</a></p>
<p>Parser combinators were not an influence on the original Rebol PARSE (circa 90s), but were what I drew inspiration from for UPARSE.</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../../user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">(&lt;|&gt;) :: Parser a -&gt; Parser a -&gt; Parser a
p &lt;|&gt; q = Parser $ \input -&gt;
    case runParser p input of
        Just result -&gt; Just result
        Nothing -&gt; runParser q input
</code></pre>
</blockquote>
</aside>
<p>One thing to notice is that UPARSE doesn't have a <em><strong>sequencing</strong></em> combinator.  Instead, it has a <em><strong>BLOCK!</strong></em> combinator.</p>
<p>And it's the BLOCK! combinator that generally does the "combinating".  It can technically be replaced, but it is the most complex combinator and so difficult to replace entirely... it's almost like the block combinator <em>is</em> UPARSE.  So it is more likely that it would be augmented vs. people wanting to rewrite it entirely.</p>
<p>When one of the parsers the block combinator has "combinated" fails, it then scans literally for the next <strong><code>|</code></strong> in the input and starts applying rules there.  This is true also historical Redbol, in that you can write any old (LOAD-able) gibberish after a failing rule, due to the skipping:</p>
<pre><code>red&gt;&gt; parse "aaa" [some "b" fhqwhgads ??? | some "a"]
== true
</code></pre>
<p>(Should a debug mode exist that runs through and ensures these regions will combinate, just not call the parsers?  Probably not in this language paradigm.  Mismatching rules can guard against dereferencing undefined variables and such, and that's kind of how the whole language works... it's modeling clay.)</p>
<p>UPARSE adds in another element to BLOCK!'s recognized-literally vocabulary of <strong><code>||</code></strong>, that is a synonym for putting everything to the left of it in a block:</p>
<pre><code>[rule1 | rule2 | rule3 || rule4]
=&gt;
[[rule1 | rule2 | rule3] rule4]

[rule1 | rule2 || rule3 | rule4 || rule5]
=&gt;
[[rule1 | rule2] [rule3 | rule4] rule5]
</code></pre>
<p>(Well, it's a synonym so long as you haven't redefined the BLOCK! combinator itself to other meanings, but if you did you might also redefine <code>||</code> while you're at it.)</p>
<p>Anyway, I'm rather fond of <code>||</code>.</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../../user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p><code>string "word 1" &lt;|&gt; string "word 2"</code> no longer works: as soon as this parser sees <code>'w'</code>, it matches the first parser, so the second parser will never be run.</p>
</blockquote>
</aside>
<p>Seems unfortunate that the default is biased that way, and you have to tack on more to get the likely-intended meaning.</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../../user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">-- 0 or more
many :: Parser a -&gt; Parser [a]
many p = some p &lt;|&gt; return []
</code></pre>
</blockquote>
</aside>
<p>There was significant discussion on what to call the "0 or more" combinator.  Historical Redbol called this ANY and I did not like that (<a href="../../the-trickiness-of-the-new-any-combinator-concept/1662.html">instead pursuing an ANY that is aligned with the ANY construct in the language</a>).</p>
<p>But I do not like MANY either--it might be worse.  Ultimately I decided that OPTIONAL SOME (or OPT SOME) is just what you would write out.</p>
<p>On the linguistic front, we don't have a word for "zero or more" in English, and maybe there is a reason for that.  What I found in going through replacing the old "ANY"=&gt;"OPT SOME" was that there were a lot of cases where someone reached for ANY when it actually wasn't a zero-or-more situation, so I liked it being explicit.</p>
<p>Many cases I looked at tidied up (and by many I mean many, not zero). I found this code removing 0 or more newlines at the head of a series via ANY:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">parse series [
    remove [any newline]
    ...
]
</code></pre>
<p>But when you rephrase this with OPT SOME it suggests a better factoring:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">parse series [
    remove [opt some newline]
    ...
]
</code></pre>
<p>It reads clearest when you bring the OPT outside, to say you're <em>optionally removing some newlines</em>:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">parse series [
    opt remove [some newline]
    ...
]
</code></pre>
<p>Plus it's now more obvious that the whole expression will be NULL in the case when no newlines are removed, and leverage that.</p>
<p>Note that the block is not necessary there:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">parse series [
    opt remove some newline
    ...
]
</code></pre>
<p>And shows a bit of the dynamics of choice we like about the medium.</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../../user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">return :: a -&gt; Parser a
return a = Parser $ \input -&gt; Just (input, a)
</code></pre>
</blockquote>
</aside>
<p>To prematurely return a result from UPARSE (without requiring reaching the end of input), the ACCEPT combinator can be used.</p>
<pre><code>&gt;&gt; parse [a b c 10 20 &lt;d&gt;] [some [word! | integer!]]
** Error: PARSE partially matched the input, but didn't reach the tail

&gt;&gt; parse [a b c 10 20 &lt;d&gt;] [some [word! | accept integer!]]
== 10

&gt;&gt; parse [a b c 10 20 &lt;d&gt;] [some [word! | accept [let i: integer! accept (i * 3)]]]
== 30
</code></pre>
<p>R3-Alpha added this as "RETURN", but Red doesn't seem to have carried that forward.  I like using a different word.</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../../user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">-- sequencing ignoring result
(&gt;&gt;) :: Parser a -&gt; Parser b -&gt; Parser b
p &gt;&gt; q = p &gt;&gt;= \_ -&gt; q
</code></pre>
</blockquote>
</aside>
<p>UPARSE combinators can synthesize antiforms, <a href="../../invisibility-reviewed-through-modern-eyes/2034.html">including GHOST</a>.  So there's an ELIDE combinator.</p>
<pre><code>&gt;&gt; parse [a b a b b c c] [accumulate ['a | 'b], some 'c]
== c

&gt;&gt; parse [a b a b b c c] [accumulate ['a | 'b], elide some 'c]
== [a b a b b]
</code></pre>
<p>This is particularly helpful to reach for in cases where an ACCEPT that returned prematurely would not complete your match.  e.g. you synthesized your result, but you still have more matching to do, and want to avoid the inconvenience of making and naming a variable for the synthesized result and then evaluating to it at the end.</p>
<p><em>(Note that COMMA! doesn't do anything, they are skipped by the BLOCK! combinator so long as they are between combinated parsers.  <strong>some "a", some "b"</strong> is legal but not <strong>some, "a" some, "b"</strong>).</em></p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../../user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>It holds onto the input string during the whole time <code>p</code> is executing. This creates a space leak, which grows larger the more nested choices you have.</p>
</blockquote>
</aside>
<p>Rebol PARSE has lots of performance issues.  e.g. when doing something like a seek, a block rule is re-applied at each location:</p>
<pre><code>red&gt;&gt; parse "aaaaab" [thru [(print "testing") "b"]]
testing
testing
testing
testing
testing
testing
== true
</code></pre>
<p>There are attempts in historical Rebol and Red to try and optimize where possible, e.g. the implementation of <strong><code>to "b"</code></strong> optimizes the find to do a faster seek for the pattern.  But you lose that optimization as soon as you change it to <strong><code>to ["b"]</code></strong>, and it recurses the parser.</p>
<p>Ren-C dials things up to 11, including the crappy performance.  UPARSE is knowingly painfully turtle slow, because it is really just a sketch of the architecture for how parser combinators would be done.  But as its broken up into functions, those functions can be rewritten as native C when the time comes (though I want to make sure the usermode implementations are kept in sync and can be swapped in and still work equivalently--so I imagine maintaining each usermode combinator and its C implementation in the same file).</p>
<p>I also want to make sure all the right hooks are in place to do things like stepwise debugging:</p>
<p><a href="../../replpad-visual-parse-debugger/2063.html" class="inline-onebox">ReplPad Visual PARSE Debugger</a></p>
<p>But I'm trying to put that together as part of a bigger story of what kind of infrastructure exists for dialect debugging and debugging in the main language (e.g. you'd be able to "step in" to a dialect at the Rebol instructions--like an assembly view--or at the level the dialect offers).</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../../user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>What use is this for Rebol?</p>
<p>Quite probably, none at all.</p>
</blockquote>
</aside>
<p>The most useful thing is bringing this outside perspective to the sort of "people who grew up on C64 BASIC" who tend to populate and design Rebol.  (You've already usefully pointed out that OPTIONAL is a perfectly acceptable word and explained the Haskell sense of TRY...)</p>
<p>Like I say above, the UPARSE design is still very much prototype-y.  It's at the "amazing it works at all" phase, though it's already the most tested PARSE variant by far (e.g. <a href="../../dead-red-redemption-starting-uparse-on-the-right-foot/1649.html">by subsuming Red's PARSE tests</a>).  But by being all usermode code, it's still at the point where there's plasticity in the design to incorporate new ideas.</p>
<p>The big areas where ideas are needed most are in error delivery, and what the story is for binding tools within parse to help dialect authors accomplish cool things easily.  And any architectural ideas to bolster performance (while still keeping the pleasing ergonomics) would be welcome.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
    </div>

      <div role='navigation' itemscope itemtype='http://schema.org/SiteNavigationElement' class="topic-body crawler-post">
          <span itemprop='name'>
            <a itemprop="url" href="../2173.html#post_2">show post in topic</a>
          </span>
      </div>

    




    </div>
    <footer class="container wrap">
  <nav class='crawler-nav'>
    <ul>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/' itemprop="url">Home </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/categories' itemprop="url">Categories </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/guidelines' itemprop="url">Guidelines </a>
        </span>
      </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://rebol.metaeducation.com/tos' itemprop="url">Terms of Service </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://rebol.metaeducation.com/privacy' itemprop="url">Privacy Policy </a>
          </span>
        </li>
    </ul>
  </nav>
  <p class='powered-by-link'>Powered by <a href="https://www.discourse.org">Discourse</a>, best viewed with JavaScript enabled</p>
</footer>

    
    
  </body>
  
</html>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Designing a Crashing Function: CRASH</title>
    <link>https://rebol.metaeducation.com/t/designing-a-crashing-function-crash/2434</link>
    <description>After being encouraged by AI (and my own intuition on the subject), I am making FAIL take over the &quot;lighter&quot; function of non-divergent error production from the [apparently-more-divergent-sounding RAISE](  https://rebol.metaeducation.com/t/naming-consideration-raised-vs-warning/2424/3?u=hostilefork).

So... yet another naming musical chairs propagates from that.  I guess PANIC is my favorite of the divergent-error-raising options (as opposed to DIE, and of course we have a completely different concept of what THROW is).  So what FAIL used to do, PANIC can do now.

Yet internally to the system, `panic()` has been a funcition to call when  it needs the executable to completely shut down.

Easy fix for this is to just call that function `crash()`, and then `panic()` can mean &quot;do a Rebol-panic&quot; e.g. don&#39;t take the interpreter down, just return control to the REPL (or whatever RESCUE operation).

But curiously... there has been a PANIC native for forcing termination of the interpreter.  I could just rename it to CRASH and move along.  But it does bring up some interesting design points for there being such a function in Rebol at all.

## A CRASH Native Must Take No Evaluative Args

You don&#39;t want a situation like having code that is like **`crash revrese &quot;string&quot;`** that has a failure on acquiring its arguments, and does not crash the system.

If you hit the point of running CRASH that&#39;s the point of no return--it shouldn&#39;t be able to jump back up to the REPL with an error.

So CRASH needs to be `&lt;endable&gt;` in case it&#39;s found in a situation like `(crash)` with no args.  If it takes arguments, those arguments should be dialected in such a way that it isn&#39;t possible to run usermode code.  Because the intention is to get out of the interpreter without causing more damage... like you&#39;ve noticed some corrupted log file and you want out.

A CRASH Dialect might be able to just output some diagnostic information for you, where you give it variables but none of these get evaluated as expressions which can run function calls...at least not usermode functions.

    crash [
       &quot;You could have some literal messages...&quot;
       checkpoint: &lt;one&gt;  ; some literals
       machine-status: @status  ; inert fetch
    ]

If you take away the ability to do evaluations, someone is going to try and write:

    crash compose [
       &quot;This is potentially dangerous, what if the COMPOSE errors?&quot;
       checkpoint: (...)  ; requesting an evaluation
       machine-status: (...)
    ]

But I&#39;m saying that would exit the intepreter when CRASH saw that you were trying to get it to run more userspace code.

Wily people can work around it:

    eval compose:deep [crash [
       &quot;Well, aren&#39;t you clever...&quot;
       checkpoint: (...)  ; requesting an evaluation
       machine-status: (...)
    ]]

But if you do this, then you are undermining the defense that is designed to make sure there isn&#39;t a failure before the crash.

## Anyway, I Thought This Was Interesting

I hadn&#39;t really contemplated the importance of designing CRASH to ensure crashing...but that&#39;s pretty cool I think.</description>
    
    <lastBuildDate>Mon, 05 May 2025 09:13:50 +0000</lastBuildDate>
    <category>Errors</category>
    <atom:link href="https://rebol.metaeducation.com/t/designing-a-crashing-function-crash/2434.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Designing a Crashing Function: CRASH</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>After being encouraged by AI (and my own intuition on the subject), I am making FAIL take over the "lighter" function of non-divergent error production from the <a href="https://rebol.metaeducation.com/t/naming-consideration-raised-vs-warning/2424/3">apparently-more-divergent-sounding RAISE</a>.</p>
<p>So... yet another naming musical chairs propagates from that.  I guess PANIC is my favorite of the divergent-error-raising options (as opposed to DIE, and of course we have a completely different concept of what THROW is).  So what FAIL used to do, PANIC can do now.</p>
<p>Yet internally to the system, <code>panic()</code> has been a funcition to call when  it needs the executable to completely shut down.</p>
<p>Easy fix for this is to just call that function <code>crash()</code>, and then <code>panic()</code> can mean "do a Rebol-panic" e.g. don't take the interpreter down, just return control to the REPL (or whatever RESCUE operation).</p>
<p>But curiously... there has been a PANIC native for forcing termination of the interpreter.  I could just rename it to CRASH and move along.  But it does bring up some interesting design points for there being such a function in Rebol at all.</p>
<h2><a name="p-8205-a-crash-native-must-take-no-evaluative-args-1" class="anchor" href="https://rebol.metaeducation.com#p-8205-a-crash-native-must-take-no-evaluative-args-1"></a>A CRASH Native Must Take No Evaluative Args</h2>
<p>You don't want a situation like having code that is like <strong><code>crash revrese "string"</code></strong> that has a failure on acquiring its arguments, and does not crash the system.</p>
<p>If you hit the point of running CRASH that's the point of no return--it shouldn't be able to jump back up to the REPL with an error.</p>
<p>So CRASH needs to be <code>&lt;endable&gt;</code> in case it's found in a situation like <code>(crash)</code> with no args.  If it takes arguments, those arguments should be dialected in such a way that it isn't possible to run usermode code.  Because the intention is to get out of the interpreter without causing more damage... like you've noticed some corrupted log file and you want out.</p>
<p>A CRASH Dialect might be able to just output some diagnostic information for you, where you give it variables but none of these get evaluated as expressions which can run function calls...at least not usermode functions.</p>
<pre><code>crash [
   "You could have some literal messages..."
   checkpoint: &lt;one&gt;  ; some literals
   machine-status: @status  ; inert fetch
]
</code></pre>
<p>If you take away the ability to do evaluations, someone is going to try and write:</p>
<pre><code>crash compose [
   "This is potentially dangerous, what if the COMPOSE errors?"
   checkpoint: (...)  ; requesting an evaluation
   machine-status: (...)
]
</code></pre>
<p>But I'm saying that would exit the intepreter when CRASH saw that you were trying to get it to run more userspace code.</p>
<p>Wily people can work around it:</p>
<pre><code>eval compose:deep [crash [
   "Well, aren't you clever..."
   checkpoint: (...)  ; requesting an evaluation
   machine-status: (...)
]]
</code></pre>
<p>But if you do this, then you are undermining the defense that is designed to make sure there isn't a failure before the crash.</p>
<h2><a name="p-8205-anyway-i-thought-this-was-interesting-2" class="anchor" href="https://rebol.metaeducation.com#p-8205-anyway-i-thought-this-was-interesting-2"></a>Anyway, I Thought This Was Interesting</h2>
<p>I hadn't really contemplated the importance of designing CRASH to ensure crashing...but that's pretty cool I think.</p>
          <p><a href="https://rebol.metaeducation.com/t/designing-a-crashing-function-crash/2434/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/designing-a-crashing-function-crash/2434/1</link>
        <pubDate>Mon, 05 May 2025 09:13:50 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2434-1</guid>
        <source url="https://rebol.metaeducation.com/t/designing-a-crashing-function-crash/2434.rss">Designing a Crashing Function: CRASH</source>
      </item>
  </channel>
</rss>

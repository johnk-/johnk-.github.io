<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Making Red Tests Useful: Starting UPARSE on the Right Foot - Testing - AltRebol</title>
    <meta name="description" content="When UPARSE began it couldn&amp;#39;t do much.  So it had one test file %uparse.test.reb, that grew as the number of combinators grew. 
This &amp;quot;one test file for all parse functions&amp;quot; approach was all the Saphirion tests ever had. &amp;hellip;">
    <meta name="generator" content="Discourse 3.5.0.beta6-dev - https://github.com/discourse/discourse version 623cde985b21c2ed812b83d3ea94f69231613718">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/1X/cbd70027b53fa165575e5b665f00eb3b8ae7ea31_2_32x32.ico">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d_2_180x180.png">
<meta name="theme-color" media="all" content="#fff">

<meta name="color-scheme" content="light">

<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, viewport-fit=cover">
<link rel="canonical" href="1649.html" />

<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="AltRebol Search">

    <link href="https://rebol.metaeducation.com/stylesheets/color_definitions_base__2_ceb61c279a74dfa3cef6a62f7784988102abec82.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" class="light-scheme"/>

<link href="https://rebol.metaeducation.com/stylesheets/common_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="common"  />

  <link href="https://rebol.metaeducation.com/stylesheets/desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="desktop"  />



    <link href="https://rebol.metaeducation.com/stylesheets/chat_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="chat"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-details_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-details"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-lazy-videos_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-lazy-videos"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-local-dates_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-local-dates"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-narrative-bot_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-narrative-bot"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-presence_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-presence"  />
    <link href="https://rebol.metaeducation.com/stylesheets/docker_manager_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="docker_manager"  />
    <link href="https://rebol.metaeducation.com/stylesheets/footnote_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="footnote"  />
    <link href="https://rebol.metaeducation.com/stylesheets/poll_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="poll"  />
    <link href="https://rebol.metaeducation.com/stylesheets/spoiler-alert_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="spoiler-alert"  />
    <link href="https://rebol.metaeducation.com/stylesheets/chat_desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="chat_desktop"  />
    <link href="https://rebol.metaeducation.com/stylesheets/poll_desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="poll_desktop"  />

  <link href="https://rebol.metaeducation.com/stylesheets/common_theme_2_57fe803ed5a41e9f7d94086afaf66a1aab57d9ae.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="common_theme" data-theme-id="2" data-theme-name="default"/>
    

    
    
        <link rel="alternate nofollow" type="application/rss+xml" title="RSS feed of &#39;Making Red Tests Useful: Starting UPARSE on the Right Foot&#39;" href="../making-red-tests-useful-starting-uparse-on-the-right-foot/1649.rss" />
    <meta property="og:site_name" content="AltRebol" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:image" content="https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:url" content="https://rebol.metaeducation.com/t/making-red-tests-useful-starting-uparse-on-the-right-foot/1649" />
<meta name="twitter:url" content="https://rebol.metaeducation.com/t/making-red-tests-useful-starting-uparse-on-the-right-foot/1649" />
<meta property="og:title" content="Making Red Tests Useful: Starting UPARSE on the Right Foot" />
<meta name="twitter:title" content="Making Red Tests Useful: Starting UPARSE on the Right Foot" />
<meta property="og:description" content="When UPARSE began it couldn&#39;t do much.  So it had one test file %uparse.test.reb, that grew as the number of combinators grew.  This &quot;one test file for all parse functions&quot; approach was all the Saphirion tests ever had.  And the ever-growing-file method is also used by the Red parse tests.  But UPARSE now aims higher: each combinator gets its own test file.  While some tests will not fit precisely into that--especially larger examples that use many features--it&#39;s a better general idea for most o..." />
<meta name="twitter:description" content="When UPARSE began it couldn&#39;t do much.  So it had one test file %uparse.test.reb, that grew as the number of combinators grew.  This &quot;one test file for all parse functions&quot; approach was all the Saphirion tests ever had.  And the ever-growing-file method is also used by the Red parse tests.  But UPARSE now aims higher: each combinator gets its own test file.  While some tests will not fit precisely into that--especially larger examples that use many features--it&#39;s a better general idea for most o..." />
<meta property="og:article:section" content="Development" />
<meta property="og:article:section:color" content="25AAE2" />
<meta property="og:article:section" content="Testing" />
<meta property="og:article:section:color" content="25AAE2" />
<meta name="twitter:label1" value="Reading time" />
<meta name="twitter:data1" value="9 mins ðŸ•‘" />
<meta name="twitter:label2" value="Likes" />
<meta name="twitter:data2" value="10 â¤" />
<meta property="article:published_time" content="2021-08-06T21:56:33+00:00" />
<meta property="og:ignore_canonical" content="true" />


    
  </head>
  <body class="crawler ">
    
    <header>
  <a href="https://rebol.metaeducation.com/">AltRebol</a>
</header>

    <div id="main-outlet" class="wrap" role="main">
        <div id="topic-title">
    <h1>
      <a href="1649.html">Making Red Tests Useful: Starting UPARSE on the Right Foot</a>
    </h1>

      <div class="topic-category" itemscope itemtype="http://schema.org/BreadcrumbList">
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://rebol.metaeducation.com/c/development/testing/50" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #25AAE2'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Development</span>
              </span>
            </a>
            <meta itemprop="position" content="1" />
          </span>
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://rebol.metaeducation.com/c/development/testing/50" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #25AAE2'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Testing</span>
              </span>
            </a>
            <meta itemprop="position" content="2" />
          </span>
      </div>

  </div>

  

    <div itemscope itemtype='http://schema.org/DiscussionForumPosting'>
      <meta itemprop='headline' content='Making Red Tests Useful: Starting UPARSE on the Right Foot'>
      <link itemprop='url' href='1649.html'>
      <meta itemprop='datePublished' content='2021-08-06T21:56:33Z'>
        <meta itemprop='articleSection' content='Testing'>
      <meta itemprop='keywords' content=''>
      <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
        <meta itemprop='name' content='AltRebol'>
          <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
            <meta itemprop='url' content='https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
          </div>
      </div>


          <div id='post_1'  class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>

                <link itemprop="mainEntityOfPage" href="1649.html">


              <span class="crawler-post-infos">
                  <time  datetime='2021-08-06T21:56:33Z' class='post-time'>
                    August 6, 2021,  9:56pm
                  </time>
                  <meta itemprop='dateModified' content='2022-07-23T00:16:19Z'>
              <span itemprop='position'>1</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>When UPARSE began it couldn't do much.  So it had one test file %uparse.test.reb, that grew as the number of combinators grew.</p>
<p>This "one test file for all parse functions" approach was all the Saphirion tests ever had.  And the ever-growing-file method is also used by the <a href="https://github.com/red/red/blob/master/tests/source/units/parse-test.red">Red parse tests</a>.</p>
<p>But UPARSE now aims higher: <em>each combinator gets its own test file</em>.  While some tests will not fit precisely into that--especially larger examples that use many features--it's a better general idea for most of the tests.</p>
<p>Hence you can see <a href="https://github.com/metaeducation/ren-c/tree/master/tests/parse">all the nice files in the <strong><code>%tests/parse/</code></strong></a> directory.  And now that UPARSE is capable enough, I've even mined the R3-Alpha PARSE tests and sorted through them...adjusting them for UPARSE and making sure they work.</p>
<h2><a name="p-5294-mining-red-tests-for-insight-1" class="anchor" href="1649.html#p-5294-mining-red-tests-for-insight-1"></a>Mining Red Tests for Insight</h2>
<p>This morning I hacked up a converter to translate Red's rather verbose test format to the more spare Rebol test form.  At some point we'll be able to run Red's test suite directly "via Redbol", but I just wanted to go through and mine their parse tests for anything useful...and have them translated into the UPARSE way of saying things.</p>
<p>So... <strong>MEET <a href="https://github.com/metaeducation/ren-c/blob/414a51e4974dfaa5e18486bc69e8a2fc52588156/tests/parse/parse-tests-from-red.test.reb">%PARSE-TESTS-FROM-RED.TEST.REB</a></strong>!</p>
<p><em>(Note: Capture was done as of the last change to that file on Oct 16, 2020... <a href="https://github.com/red/red/commit/32c30072ff215fd4efc0200ab3572ffd7afc8e9f#diff-aa7745d6b886ee41ee7e0ff66dfcbeb5412f86eb0be8bd47370e1e3ef244e089">commit 32c30072ff215fd4efc0200ab3572ffd7afc8e9f</a>...curious they haven't added any parse tests for a year...?)</em></p>
<p>No small feat to go through those, but.  Here we are.  Most of them work--but BREAK and REJECT still need to be thought through as combinators.  So the tests that don't work are the ones that use those.  I'm starting them out as a commit of one file just to show what was taken if there's any question about that.  But the next step is to break them out into the per-combinator files.</p>
<p>They licensed their tests BSD-3 which is <a href="http://www.apache.org/legal/resolved.html#category-a">Apache-2 Compatible to include or extend</a>.  Taking Apache-2 code back to BSD-3 isn't allowed by default.  But they have my permission to take whatever <em>tests</em> as BSD-3, if they care.  <sub>(They can in fact take any of my <em>ideas</em>.  Should they ever do so, then them merely knowing that their ideas don't work and mine do is plenty punishment for them.  But the non-test-<em>code</em> is LGPL...that includes the code for UPARSE and the web REPL.  Borrowing from that means being subject to the LGPL license.)</sub></p>
<p>Changes to remember are:</p>
<ul>
<li>
<p>UPARSE uses OPT SOME (or MAYBE SOME) instead of ANY/WHILE (it has <a href="../the-trickiness-of-the-new-any-combinator-concept/1662.html">a better meaning for ANY</a> and a <a href="../the-cool-new-repurposing-of-while-in-parse/1875.html">more consistent meaning for WHILE</a>!).  SOME does not have a progress requirement.  Use FURTHER if progress is mandated.</p>
</li>
<li>
<p>SET-WORD! must be combined with <code>&lt;here&gt;</code> to capture a position, vs. that weird old behavior of set-word alone.  Seeking positions is done with the SEEK combinator, not a GET-WORD!.</p>
</li>
<li>
<p>UPARSE replaces END with <code>&lt;end&gt;</code> and SKIP with <code>&lt;any&gt;</code>. I think these TAG! combinators are working out great...it's nice to have END free for a variable name...and it opens up the space for more nouns that are "out of band" from variable names.  Needing to say <code>'&lt;tag&gt;</code> to actually match a tag is a small price to pay.</p>
</li>
<li>
<p>General Ren-C renamings (string! =&gt; text!, number! =&gt; any-number!, none! =&gt; blank!), historical TRY is TRAP (with a much neater meaning for TRY)...</p>
</li>
<li>
<p>Stopping an alternate match is just done with FALSE.  FAIL is reserved for the "raise an error" sense of failing, and by letting LOGIC! decide if the parse should go on or not we have a nice ability to use splicing rules like <code>:(condition = whatever)</code> to put a true to go on or a false to stop matching.</p>
</li>
</ul>
<p>Thoughts follow.</p>
<h2><a name="p-5294-you-never-find-out-if-red-parse-collect-fails-2" class="anchor" href="1649.html#p-5294-you-never-find-out-if-red-parse-collect-fails-2"></a>You Never Find Out If Red PARSE COLLECT fails</h2>
<p>Once a COLLECT keyword is hit, your result will be an array.  It will contain whatever got collected up to the point of failure.</p>
<pre><code>red&gt;&gt; parse [1 2 3 &lt;bomb&gt;] [collect [some keep integer!] word!]
== [1 2 3]

red&gt;&gt; parse [1 2 3 &lt;bomb&gt;] [collect [some keep integer! word!]]
== [1 2 3]

red&gt;&gt; parse [1 2 3 &lt;bomb&gt; 4] [collect [some keep integer! word!]]
== [1 2 3]
</code></pre>
<p>Ren-C's system lets you have your cake and eat it too... the COLLECT result can be the result and you can even elide matches outside:</p>
<pre><code>ren-c&gt;&gt; parse [1 2 3 ta-da!] [collect [some keep integer!] elide word!]
== [1 2 3]

ren-c&gt;&gt; parse [1 2 3 ta-da!] [collect [some keep integer!] word!]
== ta-da!

ren-c&gt;&gt; parse [1 2 3 &lt;bomb&gt;] [collect [some keep integer!] word!]
; null
</code></pre>
<p>And of course you can always store rule results--any rule synthesized result--into a variable:</p>
<pre><code>ren-c&gt;&gt; parse [1 2 3 ta-da!] [block: collect [some keep integer!] word!]
== ta-da!

ren-c&gt;&gt; block
== [1 2 3]
</code></pre>
<p>Every option is on the table (except having rules you write as if they must match fail, and not tell you!)</p>
<h2><a name="p-5294-red-parse-collectkeep-is-wacky-about-splicing-3" class="anchor" href="1649.html#p-5294-red-parse-collectkeep-is-wacky-about-splicing-3"></a>Red PARSE COLLECT/KEEP Is Wacky About Splicing</h2>
<p>Here's a collect test that shows some nasty inconsistencies:</p>
<pre><code>red&gt;&gt; parse [a b b b] [collect [skip keep some 'b]]
== [[b b b]]
</code></pre>
<p>First of all, that KEEP is keeping a BLOCK!.  We know that in ordinary COLLECT if you keep a block it will splice...but this PARSE KEEP is acting like a Rebol2 KEEP/ONLY.</p>
<p>Secondly, the <strong>some 'b</strong> rule is returning a BLOCK!.  But that's not what it does in general.  Try an assignment:</p>
<pre><code>red&gt;&gt; parse [a b b b] [skip set var some 'b]
== true

red&gt;&gt; var
== b
</code></pre>
<p>So KEEP SOME 'B has a different logic for what SOME 'B synthesizes than SET SOME 'B.  <img src="../../images/emoji/twitter/clown_face.png%3Fv=14" title=":clown_face:" class="emoji" alt=":clown_face:" loading="lazy" width="20" height="20"></p>
<p>Ren-C is consistent on both fronts.  KEEP does as-is by default, and SPREAD is used to request splicing.  SOME always synthesizes the value of its last rule unless you ask for a copy.  Currently that is done with ACROSS <em>(may name change to COPY after a settling period...the distinction is currently helpful)</em></p>
<pre><code>ren-c&gt;&gt; parse [a b b b] [collect [&lt;any&gt;, keep across some 'b]]
== [[b b b]]

ren-c&gt;&gt; parse [a b b b] [collect [&lt;any&gt;, keep spread across some 'b]]
== [b b b]

ren-c&gt;&gt; parse [a b b b] [collect [&lt;any&gt;, keep some 'b]]
== [b]
</code></pre>
<p><strong>But...how do you splice in Red KEEP?</strong></p>
<p>Er... <a href="https://github.com/red/red/issues/2391#issuecomment-281655108">KEEP PICK and KEEP COPY variants are explained (?) here</a>:</p>
<pre><code>red&gt;&gt; parse [x -- ] [collect [keep to '-- ]]
== [x]
red&gt;&gt; parse [x y -- ] [collect [keep to '-- ]]
== [[x y]]

red&gt;&gt; parse [x -- ] [collect [keep pick to '-- ]]
== [x] 
red&gt;&gt; parse [x y -- ] [collect [keep pick to '-- ]]
== [x y]

red&gt;&gt; parse [x -- ] [collect [keep copy _ to '-- ]]
== [[x]]
red&gt;&gt; parse [x y -- ] [collect [keep copy _ to '-- ]]
== [[x y]]
</code></pre>
<p><em>(Sidenote: the use of the _ as a "word that is thrown away" shows that being forced to name arguments to COPY is a bad idea.  It's better as a combinator that synthesizes a result that may or may not be stored in a variable.)</em></p>
<p>The best I can imagine is that this is an attempt to avoid generating large intermediate series. Since Red doesn't worry about "rollback" then if it wants to append things as it goes to the collecting array it can do so with this KEEP PICK.</p>
<p>It doesn't seem to even make any sense...the above suggests that KEEP PICK splices, but apparently not if the result comes from a GROUP! (??).   See <a href="https://github.com/red/red/issues/4198">Red Issue #4198</a>:</p>
<pre><code>red&gt;&gt; parse [][collect keep pick ('a)]
== [a]

red&gt;&gt; parse [][collect keep pick ([a b])]
== [[a b]]
</code></pre>
<p>UPARSE is going down a vastly more consistent/usable road.  But if rollback isn't a requirement there's no reason the append-with-no-intermediate-series behavior couldn't be mimic'd in the UPARSE2 emulation.  Don't know who'd want it, though.</p>
<h2><a name="p-5294-explicit-advancement-requirement-is-good-4" class="anchor" href="1649.html#p-5294-explicit-advancement-requirement-is-good-4"></a>Explicit Advancement Requirement Is Good</h2>
<p>These all infinite loop in UPARSE:</p>
<pre><code>parse [a a] [some ['c | not 'b] repeat 2 &lt;any&gt;]
parse "aa" [some [#c | not #b] repeat 2 &lt;any&gt;]
parse "bx" [some [not "b" | &lt;any&gt;]]
parse #{0A0A} [some [#"^L" | not #{0B}] repeat 2 &lt;any&gt;]
</code></pre>
<p>And they're trickier than usual, because if you just change that to <code>some further</code> they won't work... because you're demanding rules like <code>further ['c | not 'b]</code> make progress <em>some</em> number of times.</p>
<p>*<em>It's a really convoluted way of thinking of what you're doing here as <em>"some number of matches... including a non-match that doesn't advance of 'b counting as at least one match.</em></em>  So the SOME doesn't fail to match, -but- if it doesn't advance, even though the one time succeeded count it as a break of the iteration and yield success"*.</p>
<p>Who wants to think like that?  It doesn't really make sense.  If you insist on using SOME you have to use an OPT and FURTHER:</p>
<pre><code>parse [a a] [opt some further ['c | not 'b], repeat 2 &lt;any&gt;]
</code></pre>
<p>Or write it more coherently by just testing for the NOT in sequence, vs inside the looped alternate:</p>
<pre><code>parse [a a] [opt some 'c, not 'b, repeat 2 &lt;any&gt;]
</code></pre>
<p>I know it's just a test, but, I have a feeling that most of these "infinite rules need to break" rules have saner expressions...which makes for a more understandable SOME.  Red embraces the advancement rule on purpose; these tests represent "fixes" to what they consider bugs, e.g. <a href="https://github.com/red/red/issues/3927">Red Issue #3927</a>.</p>
<p>But I think requiring advancement fundamentally limits the perception of what PARSE can do.  It can be the control structure of an application or state machine... SOME is a loop.  You might want to re-run a rule so long as input is pending on a network port.  Especially with GROUP! rule splicing that can inject "true" or "false", you can mix and match rules with imperative code... and having a successful rule decide it was "too successful" is just disruptive.</p>
<p>Having a good debugger someday <em>(it's always "someday"...? :-/)</em> will make it easy enough to find the infinite loops.</p>
<h2><a name="p-5294-we-dont-do-into-nor-collect-into-5" class="anchor" href="1649.html#p-5294-we-dont-do-into-nor-collect-into-5"></a>We Don't Do /INTO... nor COLLECT INTO</h2>
<p>Red is concerned about low level series optimization, even though Gregg has indicated he agrees with me that this is a bad thing to focus on:</p>
<p><a href="../stopping-the-into-virus/705/1.html" class="inline-onebox">Stopping the /INTO Virus</a></p>
<p>Not going to rewrite that post here.  But I'll say the idea of being able to make series discontiguous in memory is an interesting one; kind of like how filesystems can split files into chunks.  It seems to me that if series could be "chunked" in this way at a system level, we could worry less about these /INTO matters.  I'd rather look into that kind of answer vs. burdening users with /INTO.</p>
<p>So there's no COLLECT INTO pattern in UPARSE.  They also have a COLLECT AFTER which uses the position after the current series position instead of before the current series position to insert.  :-/  The need for these permutations just seems to further demonstrate what an awkward thing this is to build in.</p>
<p>Someone can put this stuff in Redbol's PARSE built on UPARSE with different combinators--if they really want it.  Don't think that will be me!</p>
<h2><a name="p-5294-using-things-as-non-rules-usually-requires-group-6" class="anchor" href="1649.html#p-5294-using-things-as-non-rules-usually-requires-group-6"></a>Using Things as Non-Rules Usually Requires GROUP!</h2>
<p>In Red, this works:</p>
<pre><code>red&gt;&gt; parse blk: [] [insert 1]
== true

red&gt;&gt; blk
== [1]
</code></pre>
<p>Originally I asked <em>"Why treat that 1 as a number, instead of as a rule?"</em>  Because it was common to say that things like <strong>3 rule</strong> were a repeat count.  I pointed out the inconsistency.</p>
<p>My argument against inconsistency still holds.  But in this case: I think the literal integer interpretation was the right bias to take.  So UPARSE's INTEGER! combinator <strong><a href="../is-integer-in-parse-too-obfuscating/1578/11.html">now evaluates to the integer literally</a></strong> with no implicit repeat.</p>
<h2><a name="p-5294-reds-parse-insert-is-either-arity-1-or-arity-2-7" class="anchor" href="1649.html#p-5294-reds-parse-insert-is-either-arity-1-or-arity-2-7"></a>Red's PARSE INSERT Is Either Arity-1 or Arity-2</h2>
<p>As I show above, Red lets you do <code>insert 1</code>... which makes it look like INSERT takes a single argument.  That's the thing to insert.  You don't need to tell it what series or position, because it presumes you mean the current series at the parse position.</p>
<p>But weirdly enough, <a href="https://github.com/red/red/issues/4153">you can provide a position as the first argument to insert as a word</a>.  In this case it takes two parameters.</p>
<pre><code>&gt;&gt; parse (data: [a b c]) [
    pos-head:           ; capture head postion to variable
    to end              ; seek to end of series
    pos-tail:           ; capture tail position to variable
    insert pos-head 1   ; use arity-2 form of insert, arg 1 is where
]
== true  ; parse position was moved past insertion to end

&gt;&gt; data
== [1 a b c]  ; data changed as expected

&gt;&gt; pos-head
== [1 a b c]  ; pos-head did not move to consistently point at a

&gt;&gt; pos-tail  ; pos-tail also did not move, no longer tail
== [c]
</code></pre>
<p>There's a little bit of this mechanism that would be hard to do yourself.  If you tried to save the parse position, do a SEEK to where you want to insert, then insert, and jump back to the parse position you saved... your parse position wouldn't take into account the size of the insertion.  So you'd have to do something more like:</p>
<ul>
<li>Save the parse position</li>
<li>Seek to where you want to insert</li>
<li>Save the insertion position</li>
<li>Do the insert</li>
<li>If parse position was before insertion position, jump back to it, else
<ul>
<li>Save the after-insertion position</li>
<li>Count distance between after-insertion position and before insertion position</li>
<li>Seek to the saved parse position plus that distance</li>
</ul>
</li>
</ul>
<p>So this form of INSERT does that for you.  But as shown above, the only position that is getting adjusted in this way is your parse position...all other saved positions in the parse will have the wrong index.  This is just a general Rebol issue since it's nothing more than arrays and indices at heart.  <img src="../../images/emoji/twitter/frowning.png%3Fv=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>Here's an example weird Red test of this:</p>
<pre><code>red&gt;&gt; series: [a b c]
red&gt;&gt; letters: [x y z]
red&gt;&gt; parse series [
     mark: 'a insert mark letters insert only mark letters 'b 'c
 ]
== true
red&gt;&gt; series
== [[x y z] x y z a b c]
</code></pre>
<p>Here's me rotely translating that parse rule according to my formula above:</p>
<pre><code>[
    mark: &lt;here&gt;
     'a

    ; Try equivalent of Red's `insert mark letters`
    pos: &lt;here&gt;
    seek (mark)
    insert spread (letters)
    after: &lt;here&gt;
    seek (skip pos (index of after) - (index of mark))

    ; Try equivalent of Red's `insert only mark letters`
    pos: &lt;here&gt;
    seek (mark)
    insert (letters)
    after: &lt;here&gt;
    seek (skip pos (index of after) - (index of mark))

    'b 'c
]
</code></pre>
<p>The mechanic isn't rocket science, but it's sure a pain to do by hand.  Another approach would be PUSH-POSITION and POP-POSITION operators, where the positions on the stack get updated for insertions.</p>
<p>CHANGE is weirder still, because if you pass it a position in the series it changes <em>between</em> the current parse position and what you pass it.</p>
<pre><code>red&gt;&gt; parse blk: [a b c 1 2 3] [
    mark:
    some word!
    change mark "like so"
    some integer!
]
== true

red&gt;&gt; blk
== ["like so" 1 2 3]
</code></pre>
<p>Gabriele dropped mutating operators like CHANGE/INSERT/REMOVE from Topaz PARSE entirely.  They are troublemakers, for sure.  I've kept an open mind but this is of course the kind of debacle you're going to have with them.</p>
<p>But no matter how this is dealt with, I don't think variable-arity INSERT is the right answer.  This needs more careful thought if mutations are going to be allowed.</p>
<h2><a name="p-5294-weird-implicit-keep-on-nested-collect-8" class="anchor" href="1649.html#p-5294-weird-implicit-keep-on-nested-collect-8"></a>Weird Implicit KEEP on Nested COLLECT</h2>
<p>This is the consequence of the fact that COLLECT doesn't really know where it's writing things when you don't use INTO.  It bubbles its result out the top of the parse if you merely mention COLLECT.  So if you have a nested collect and no INTO, where else would it go?</p>
<pre><code>red&gt;&gt; parse [a a [1 1] b b] [
     collect [some [
         keep word!
         | ahead block! into [collect [some keep integer!]]
     ]]
]
== [a a [1 1] b b]
</code></pre>
<p>It's nicer to have the option to do what you want with it.  In Ren-C, such a COLLECT would just be thrown out...you'd have to KEEP it in the outer collect.  At which point you could splice it, or not...</p>
<pre><code>ren-c&gt;&gt; parse [a a [1 1] b b] [
     collect [some [
         keep word!
         | subparse block! [keep spread collect [some keep integer!]]
     ]]
]
== [a a 1 1 b b]

ren-c&gt;&gt; parse [a a [1 1] b b] [
     collect [some [
         keep word!
         | subparse block! [keep collect [some keep integer!]]
     ]]
]
== [a a [1 1] b b]
</code></pre>
<h2><a name="p-5294-weird-to-end-behavior-with-strings-9" class="anchor" href="1649.html#p-5294-weird-to-end-behavior-with-strings-9"></a>Weird TO END Behavior With Strings</h2>
<p>In <a href="https://github.com/red/red/issues/2561">Red Issue #2561</a> it was observed that the null terminator of strings was getting captured by KEEP TO END in PARSE collect.  Clearly a bug.</p>
<p>But the fix yields this weird behavior:</p>
<pre><code>red&gt;&gt; parse "" [collect [keep to end]]|
== []

red&gt;&gt; parse "" [collect [keep pick to end]]|
== []
</code></pre>
<p>I ask the usual question of why KEEP should be different from anything else.  Let's try:</p>
<pre><code>red&gt;&gt; parse "" [test: to end]
== true

red&gt;&gt; test
== ""
</code></pre>
<p>So if that's what TO END synthesized, why isn't it what KEEP would keep?</p>
<p>Often it is said in the Red camp that I <em>"make things too complicated"</em> (or whatever they say, it's patently untrue)--it would be <em>so much easier</em> if they'd just follow the UPARSE schematic.  Rules synthesize values, BLOCK! rules synthesize the value of their last synthesized alternate, GROUP!s consume no input and just synthesize a value.  And that value is what gets up to KEEP or set in a variable or returned from the overall operation.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="3" />
              <span class='post-likes'>3 Likes</span>
            </div>

                <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../running-into-issues-with-parse/1716/2.html">Running into issues with PARSE</a>
                        <meta itemprop='position' content='15'>
                      </div>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../system-object-vs-sys-context/1687/2.html">&quot;System Object&quot; vs. &quot;Sys Context&quot;</a>
                        <meta itemprop='position' content='16'>
                      </div>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../haskell-parser-combinators/2173/2.html">Haskell parser combinators</a>
                        <meta itemprop='position' content='17'>
                      </div>
                </div>
          </div>
          <div id='post_2' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2021-08-06T22:44:32Z' class='post-time'>
                    August 6, 2021, 10:44pm
                  </time>
                  <meta itemprop='dateModified' content='2021-08-06T22:44:32Z'>
              <span itemprop='position'>2</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>Here is the script I used to do the conversion of Red's %parse-test.red.</p>
<p>Generally speaking I don't intend to do any more such conversions.  When we run Redbol tests, it will use their test format and be running under Redbol emulation.</p>
<p>Since this was a one-time thing...I just did it quick and dirty.  And I just edited it by hand after the script did what it could.  But it was a reminder that we need some better tools for working in the symbolic domain; things like REPLACE/ALL/DEEP (Red actually has that).  When you replace things as text there's all kinds of room for error...the meaning of "whole words only" is hard to capture in parse rules.</p>
<p>It's good to sit down and just suffer through a task like this now and again--to think about the things that are hard, and notice all the unpolished edges.  But I do have to say the parts that I find really interesting are Ren-C-isms...the NULLs and the ELSEs and the way things click together.</p>
<p>UPARSE is just going to make it that much better.  But there will still be a long way to go.</p>
<p>(I hope it just gets to the point where smart people will see potential in it so that it's not just me hacking on the interpreter and design!)</p>
<pre><code>source: as text! read %parse-test.red

delimit: charset " ^/])^-"
whitespace: charset " ^/^-"
parse source [
    while [
        "any-string!"  ; skip these
        |
        change ["string!" ahead delimit] ("text!")
        |
        change ["none!" ahead delimit] ("blank!")
        |
        change ["none!" ahead delimit] ("none")
        |
        change ["number!" ahead delimit] ("any-number!")
        |
        change ["skip" ahead delimit] ("&lt;any&gt;")
        |
        change ["end" ahead delimit] ("&lt;end&gt;")
        |
        change ["try" ahead delimit] ("trap")
        |
        change [
            "copy" some whitespace not [{"} | "[" | "{" | "#"]
            copy var to delimit
        ] (
            :[(to set-word! var) space 'across]
        )
        |
        "charset"  ; skip to make it easier to see the SETs
        |
        change [
            pos: here
            "set" some whitespace [not [{"} | "[" | "{" | "#"]
            copy var to delimit | (print ["PROBLEMO!" copy/part pos 20])]
        ] (
            :[(to set-word! var)]
        )
        |
        change ["parse" ahead [delimit | "/"]] (
            "uparse?"  ; plain UPARSE returns block synthesis, not logic
        )
        |
        change ["fail" ahead delimit] ("false")
        |
        change ["any" ahead delimit] ("while")  ; most if not all ANY are rules
        |
        skip
    ]
]

loaded: load source

lineize: func [
    {Turn block with NEW-LINE markers in it to where each line is in a BLOCK!}
    return: [block!]
    block [block!]
][
    ; turn the group into blocks that represent lines.
    let start: block
    return collect [
        cycle [
            if tail? start [stop]
            let end: next start
            cycle [
                if new-line? end [stop]
                if tail? end [stop]
                end: next end
            ]
            let line: take/part start end
            new-line line false
            new-line tail line false
            keep ^line
        ]
    ]
]

unlineize: func [
    {Flatten blocks representing lines into series with NEW-LINE markers}
    return: [block!]
    lines [block!]
][
    let block: first lines

    if 1 = length of lines [
        ;
        ; if it's just one line, make the resulting block a single line
        ;
        new-line block false
        new-line tail block false
        return block
    ]

    for-each line next lines [
        let pos: tail block
        append block line
        new-line pos true
    ]

    new-line block true
    new-line tail block true
    return block
]

elide pos: loaded
cycle [
    pos: find pos [--test--] else [stop]
    take pos
    if text? pos.1 [label: take pos]
    end-group: find pos [===end-group===]
    next-test: find pos [--test--]
    end: all [
        not end-group
        not next-test
        tail pos
    ] else [
        end-group: default [tail pos]
        next-test: default [tail pos]
        if (index? end-group) &lt; (index? next-test) [
            end-group
        ] else [
            next-test
        ]
    ]
    block: take/part pos end
    lines: lineize block

    temp: back tail lines
    if '--assert = first temp.1  [
        if '--assert != first try first try back temp [
            ;
            ; Last line of collection is assert with no prior line or no
            ; assert on prior line.  Just remove it.
            ;
            take temp.1
        ] else [
            ; more asserts above.  group these lines into a DID clause

            clauses: reverse collect [  ; TEMP is a position in array of lines
                cycle [
                    if '--assert &lt;&gt; first temp.1 [stop]
                    take temp.1  ; the --assert
                    keep ^ take temp  ; the line
                    if head? temp [stop]
                    temp: back temp
                ]
            ]
            append lines compose/deep [[did all (unlineize clauses)]]
        ]
    ]

    group: as group! unlineize lines

    insert pos quote group
    new-line pos true
]

; Now cluster the test groups

elide clusters: collect [
    cycle [
        pos: loaded
        assert [pos.1 = '===start-group===]
        take pos
        assert [text? pos.1]  ; group name, keep it (strings legal)

        ; There can be some code here that's not in a group but should be
        ; as leading setup for the cluster.  Fix it manually, this script
        ; is only being run once...not worth automating.

        loop ['===end-group=== != pos.1] [
            pos: next pos
        ]
        take pos
        keep ^(take/part loaded pos)
        if empty? loaded [stop]
    ]
]

write %working.red mold/only clusters
</code></pre>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="2" />
              <span class='post-likes'>2 Likes</span>
            </div>

          </div>
          <div id='post_3' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2021-08-09T22:33:45Z' class='post-time'>
                    August 9, 2021, 10:33pm
                  </time>
                  <meta itemprop='dateModified' content='2021-08-09T22:33:45Z'>
              <span itemprop='position'>3</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1649">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'm starting them out as a commit of one file just to show what was taken if there's any question about that. But the next step is to break them out into the per-combinator files.</p>
</blockquote>
</aside>
<p>...and no small amount of work that was.  <img src="../../images/emoji/twitter/man_technologist.png%3Fv=14" title=":man_technologist:" class="emoji" alt=":man_technologist:" loading="lazy" width="20" height="20"></p>
<aside class="onebox githubcommit" data-onebox-src="https://github.com/metaeducation/ren-c/commit/15876a28c5a3a9b60bb672676b7cf75d04425106">
  <header class="source">

      <a href="https://github.com/metaeducation/ren-c/commit/15876a28c5a3a9b60bb672676b7cf75d04425106" target="_blank" rel="noopener">github.com/metaeducation/ren-c</a>
  </header>

  <article class="onebox-body">
    <div class="github-row">
  <div class="github-icon-container" title="Commit">
    <svg width="60" height="60" class="github-icon" viewBox="0 0 14 16" aria-hidden="true"><path fill-rule="evenodd" d="M10.86 7c-.45-1.72-2-3-3.86-3-1.86 0-3.41 1.28-3.86 3H0v2h3.14c.45 1.72 2 3 3.86 3 1.86 0 3.41-1.28 3.86-3H14V7h-3.14zM7 10.2c-1.22 0-2.2-.98-2.2-2.2 0-1.22.98-2.2 2.2-2.2 1.22 0 2.2.98 2.2 2.2 0 1.22-.98 2.2-2.2 2.2z"></path></svg>
  </div>

  <div class="github-info-container">
    <h4>
      <a href="https://github.com/metaeducation/ren-c/commit/15876a28c5a3a9b60bb672676b7cf75d04425106" target="_blank" rel="noopener">Break %parse-tests-from-red into the per-combinator files</a>
    </h4>

    <div class="github-info">
      <div class="date">
        committed <span class="discourse-local-date" data-format="ll" data-date="2021-08-09" data-time="22:05:26" data-timezone="UTC">10:05PM - 09 Aug 21 UTC</span>
      </div>

      <div class="user">
        <a href="https://github.com/hostilefork" target="_blank" rel="noopener">
          <img alt="" src="https://avatars.githubusercontent.com/u/20440?v=4" class="onebox-avatar-inline" width="20" height="20">
          hostilefork
        </a>
      </div>

      <div class="lines" title="changed 42 files with 3804 additions and 3407 deletions">
        <a href="https://github.com/metaeducation/ren-c/commit/15876a28c5a3a9b60bb672676b7cf75d04425106" target="_blank" rel="noopener">
          <span class="added">+3804</span>
          <span class="removed">-3407</span>
        </a>
      </div>
    </div>
  </div>
</div>

  <div class="github-row">
    <p class="github-body-container">This breaks down the monolithic tests from %parse-test.red so that
they are in f<span class="show-more-container"><a href="https://github.com/metaeducation/ren-c/commit/15876a28c5a3a9b60bb672676b7cf75d04425106" target="_blank" rel="noopener" class="show-more">â€¦</a></span><span class="excerpt hidden">iles for the combinators used.

It's an inexact science but it is generally more useful than organizing
tests based on what input type is being processed...because the pattern
across tests for the same combinator is more clear.</span></p>
  </div>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>A lot of the Red tests are redundant, and the consistent design of UPARSE isn't as likely to have trouble with some of the variants they worry over.  I would like to see a lot of the tests that look like they are generated by an algorithm be expressed in the test files as the algorithm... because it's laborious to read them and realize if you've got a case tested for BLOCK! input that you missed for TEXT! or BINARY!...</p>
<p><strong>But however you look at it, UPARSE is now the most heavily tested PARSE implementation out there!</strong></p>
<h2><a name="p-5303-you-can-help-1" class="anchor" href="1649.html#p-5303-you-can-help-1"></a>YOU CAN HELP</h2>
<p>Yes, you!  Send in your tests.  Anything you type in the web REPL to see if it works or not...that counts.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="3" />
              <span class='post-likes'>3 Likes</span>
            </div>

          </div>
          <div id='post_4' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2022-05-16T10:39:35Z' class='post-time'>
                    May 16, 2022, 10:39am
                  </time>
                  <meta itemprop='dateModified' content='2022-05-16T10:39:35Z'>
              <span itemprop='position'>4</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>In light of the <a href="https://rebol.metaeducation.com/t/dropping-find-while-if-unless-select-etc/498/2">recent revelations regarding DID and DIDN'T</a>, it was time to promptly dispose of the question-mark-bearing UPARSE? and PARSE?.</p>
<p>But rather than just blindly replace all the UPARSE? from the tests with DID UPARSE, I decided to do something very labor-intensive...<em>and codify what the expression actually evaluated to</em>.</p>
<p>So if a test was something along the lines of:</p>
<pre><code>assert [uparse? "aacc" [some "a" some "c"]]
</code></pre>
<p>I went and actually made it say something more like:</p>
<pre><code>assert ["c" == uparse "aacc" [some "a" some "c"]]
</code></pre>
<p>For all the mind-numbingly redundant tests from Red, this was no picnic, and involved <a href="https://github.com/metaeducation/ren-c/commit/dd23a6e6863fc26da86cd53eac92486546a6b033">like a thousand hand-made changes</a>.  <em>(Really, so many of the tests are formulaic and should be produced by scripts...but something in the Rebol DNA makes people write out <strong>1 = 1</strong>, <strong>2 = 2</strong>, <strong>3 = 3</strong> all the way up to <strong>100 = 100</strong> instead of finding a way to do the test generation dynamically.)</em></p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1649">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>(Note: Capture was done as of the last change to that file on Oct 16, 2020... <a href="https://github.com/red/red/commit/32c30072ff215fd4efc0200ab3572ffd7afc8e9f#diff-aa7745d6b886ee41ee7e0ff66dfcbeb5412f86eb0be8bd47370e1e3ef244e089">commit 32c30072ff215fd4efc0200ab3572ffd7afc8e9f</a>...curious they haven't added any parse tests for a year...?)</p>
</blockquote>
</aside>
<p>I figured so long as I'd done everything else, I'd incorporate any new tests in the past year and a half.</p>
<p>How many, you ask?  Just two commits.  Here's one:</p>
<pre><code>--test-- "#4863"
	--assert parse to-binary "word" [word!]
	--assert parse to-binary "   word" [word!]
	--assert parse to-binary "123" [integer!]
	--assert not parse to-binary "123.456" [integer!]
	--assert parse to-binary "    123" [integer!]
	--assert parse to-binary "hello 123 world" [word! integer! word!]
	--assert parse to-binary "hello 123 world" [word! space integer! space word!]
</code></pre>
<p>And here's the other...which deleted a test:</p>
<pre><code>	--assert error? try [parse #{}[collect into x4197 []]]   ;-- deleted
</code></pre>
<p>But added this:</p>
<pre><code>	--assert parse #{}[collect into x4197 []]		;-- changed by #4732
	--assert x4197 == #{}
</code></pre>
<p>They're either nearing perfection, or there's not enough sophisticated usage being explored to generate compelling tests.  It's anyone's guess which.  <img src="../../images/emoji/twitter/clown_face.png%3Fv=14" title=":clown_face:" class="emoji" alt=":clown_face:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-5845-ren-c-doesnt-believe-in-intohttpsrebolmetaeducationcomtstopping-the-into-virus705-so-1" class="anchor" href="1649.html#p-5845-ren-c-doesnt-believe-in-intohttpsrebolmetaeducationcomtstopping-the-into-virus705-so-1"></a><a href="../stopping-the-into-virus/705.html">Ren-C doesn't believe in INTO</a>, so...</h2>
<p>Really it's only the first set of tests that applies.  This is where it allows you to name DATATYPE! when you are parsing a BINARY!.  (We can do it for strings, too...at the same price...thanks to UTF8-Everywhere!)</p>
<p>Like I say, it's good for UPARSE tests to be more explicit and test more than just "it succeeded", so here's that spin:</p>
<pre><code>[https://github.com/red/red/issues/4863
    ('word == uparse to-binary "word" [word!])
    ('word == uparse to-binary "   word" [word!])
    (123 == uparse to-binary "123" [integer!])
    (didn't uparse to-binary "123.456" [integer!])
    (123 == uparse to-binary "    123" [integer!])
    ([hello 123 world] == uparse to-binary "hello 123 world" [
        collect [keep ^ word!, keep integer!, keep ^ word!]
    ])
    ([hello 123 world] == uparse to-binary "hello 123 world" [
        collect [keep ^ word!, space, keep integer!, space, keep ^ word!]
    ])
]
</code></pre>
<p>Their test checks to see that <strong>parse to-binary "123" [integer!]</strong> succeeded, but there's no guarantee you actually got an integer out of the process.  Or if you did, that it's the integer 123.</p>
<p>Bringing more formality to that--and leveraging UPARSE's results--is what this is about.</p>
<p><em>(Note: Still working on the story for whether you're allowed to KEEP a WORD! without some modifier like ONLY or meta, so deep thought on that forthcoming...)</em></p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="2" />
              <span class='post-likes'>2 Likes</span>
            </div>

          </div>
    </div>


    




    </div>
    <footer class="container wrap">
  <nav class='crawler-nav'>
    <ul>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/' itemprop="url">Home </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/categories' itemprop="url">Categories </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/guidelines' itemprop="url">Guidelines </a>
        </span>
      </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://rebol.metaeducation.com/tos' itemprop="url">Terms of Service </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://rebol.metaeducation.com/privacy' itemprop="url">Privacy Policy </a>
          </span>
        </li>
    </ul>
  </nav>
  <p class='powered-by-link'>Powered by <a href="https://www.discourse.org">Discourse</a>, best viewed with JavaScript enabled</p>
</footer>

    
    
  </body>
  
</html>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Should FFI ~null~ Antiform Be Accepted as 0 POINTER!</title>
    <link>https://rebol.metaeducation.com/t/should-ffi-null-antiform-be-accepted-as-0-pointer/2407</link>
    <description>There&#39;s places in FFI clients that look more or less like this:

    let ptr: make pointer! 0
    if something.field [
        let whatever: blah blah field
        ptr: address of whatever
    ]

    call-ffi-thing-that-takes-pointer ptr

It&#39;s kind of inconvenient that 0 pointers aren&#39;t conditionally false.

At the same time, it&#39;s kind of inconvenient at times that the integer! 0 can&#39;t be tested for as conditionally false.  Are pointers a different beast?

---

**Having ~null~ Typecheck Distinctly Offers Crucial Advantages**

There&#39;s something that might seem at first glance to be annoying:

    &gt;&gt; make pointer! 0
    ** Error: Cannot make pointer from 0

MAKE has to return the type of the thing you are MAKE-ing, so it can&#39;t return the antiform KEYWORD! of NULL.

**BUT** this could be a raised error you defuse with TRY.  And if it&#39;s the *only* raised error (as opposed to actual failure) you can get exactly the answer you&#39;d want:

    &gt;&gt; try make pointer! 0
    == ~null~  ; anti

This does mean that in type specifications, if a null pointer is legal you&#39;d have to annotate it as such, with **`[~null~ pointer!]`** instead of simply **`[pointer!]`**.

*But that&#39;s a very good thing.*  This basically means your interfaces become documented as to whether they accept nulls or not, effectively giving you `std::optional` / `Option()` / `Maybe`.  Documenting that communicates powerfully and can give much better error locality, even in an interpreted language.

---

**What are the disadvantages of making NULL the 0 pointer?**

There are obvious advantages to being able to easily conditionally test the pointer variable.

The first disadvantage someone might cite is &quot;you lose the protection of being able to tell if you assigned the pointer or not&quot;.  NULL is supposed to represent the easy-to-test state of whether you&#39;ve assigned a variable or not--friendlier than an unset variable, but still unfriendly in most cases.  So let&#39;s say you had meant to assign `ptr` but just forgot to.

I think this fear isn&#39;t that compelling.  We already have the case where NULL antiforms represent the logic falsey state (the only falsey state) and don&#39;t stress over whether you &quot;forgot to set the logic variable&quot;.

The bigger deal is that there are actually some edge cases where 0 pointers are meaningful addresses.  e.g. `dlsym()` on POSIX for looking up symbols in a library makes a distinction between failure to find the address of a symbol, and address 0.

So if you wrote:

    something: try pick libc &quot;some-symbol&quot;

Then if it couldn&#39;t find the symbol, PICK returns a raised error, which TRY converts to NULL.  But then it could have successfully found the symbol at address 0, so that is distinct.

*This seems pretty esoteric to me.*  If you&#39;re dealing with one of these situations, you could write:

    let pointer: pick libc &quot;some-symbol&quot; except e -&gt; [
        fail [&quot;Couldn&#39;t find some-symbol in libc:&quot; mold e]
    ]
    let address: any [to integer! maybe pointer, 0]

So this way there could be a legitimate NULL returned from the LIBRARY!, vs. a raised result.  If you know you&#39;re in one of these situations, you are probably doing something hardware fiddly and an integer is what you want.

---

**The Advantages Of Making ~null~ the 0 State For Pointers Seem To Outweigh The Disadvantages**

I&#39;ve looked at a fair bit of code and it seems the edge case of symbols that legitimately reside at address zero in memory is not compelling enough to stop the better choice.</description>
    
    <lastBuildDate>Sat, 17 May 2025 03:29:52 +0000</lastBuildDate>
    <category>FFI</category>
    <atom:link href="https://rebol.metaeducation.com/t/should-ffi-null-antiform-be-accepted-as-0-pointer/2407.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Should FFI ~null~ Antiform Be Accepted as 0 POINTER!</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2407">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>The first disadvantage someone might cite is "you lose the protection of being able to tell if you assigned the pointer or not". NULL is supposed to represent the easy-to-test state of whether you've assigned a variable or not--friendlier than an unset variable, but still unfriendly in most cases. So let's say you had meant to assign <code>ptr</code> but just forgot to.</p>
<p>I think this fear isn't that compelling. We already have the case where NULL antiforms represent the logic falsey state (the only falsey state) and don't stress over whether you "forgot to set the logic variable".</p>
</blockquote>
</aside>
<p>This question of whether there should be a null pointer state corresponds somewhat to the question of whether there should be a 0 codepoint "rune" (or perhaps, if taken to an extreme, a 0 INTEGER!).</p>
<p>If there were no "NUL rune", we might say you used null itself, e.g.</p>
<pre><code>&gt;&gt; append #{DECAFBAD} null
== #{DECAFBAD00}
</code></pre>
<p>But that throws out all the safety NULL is intended for.</p>
<p>We might imagine you use a quasiform:</p>
<pre><code>&gt;&gt; append #{DECAFBAD} ~null~
== #{DECAFBAD00}

&gt;&gt; append #{DECAFBAD} reify null
== #{DECAFBAD00}
</code></pre>
<p>Or perhaps zero is itself an antiform (or at least comes in antiform flavors) <img src="https://rebol.metaeducation.com/images/emoji/twitter/roll_eyes.png?v=14" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></p>
<pre><code>&gt;&gt; append #{DECAFBAD} ~0~
** Error: Antiform zero can't be added to binary blob

&gt;&gt; append #{DECAFBAD} unanti ~0~
== #{DECAFBAD00}
</code></pre>
<p>(I will say that if we were willing to have more than one "falsey" null antiform, then in-language I'd advocate for any of those additional falsey things to be antiforms.)</p>
<h2><a name="p-8298-reductio-ad-absurdum-favors-0-pointer-1" class="anchor" href="https://rebol.metaeducation.com#p-8298-reductio-ad-absurdum-favors-0-pointer-1"></a>Reductio Ad Absurdum Favors 0 POINTER!</h2>
<p>I think some of the arguments one might apply to 0 pointers would apply to things like the 0 INTEGER! itself, and if you went that route then 0 existing as distinct to NULL wins instantly.</p>
<p>You see clearly the problems of using NULL as the zero representation the moment you do math:</p>
<pre><code>&gt;&gt; value: 5 - 5
== ~null~  ; anti

&gt;&gt; value: value + 10
** Error...
</code></pre>
<p>0 is something that carries the "I'm an INTEGER!" type information that you don't want lost.</p>
<p><em>Anything you intend to do math on needs to have a persistent zero state distinct from null.</em>  It may not be the only criteria, but it's certainly one of them.</p>
<p>Beyond that, things have now moved to where the places that accept NULL are limited to conditional slots.  Anywhere that intends to "accept null" really has to accept VOID instead, and you need an active operation like OPT to transform voids to nulls (which can then automatically <code>&lt;undo-opt&gt;</code> so they appear as null inside the function).  That's a back-and-forth that you wouldn't want to impose on an ordinary legal math value.</p>
<h2><a name="p-8298-idea-raw-pointer-datatype-pointer-constraint-2" class="anchor" href="https://rebol.metaeducation.com#p-8298-idea-raw-pointer-datatype-pointer-constraint-2"></a>Idea: RAW-POINTER! Datatype, POINTER? Constraint</h2>
<p>I think it's probably best to have a 0 state, in a RAW-POINTER! type... and then a POINTER? type constraint that doesn't include the 0 state.  So if you take <code>[pointer?]</code> it's understood to not include 0, and you'd have to say <code>[raw-pointer!]</code> or <code>[raw-pointer?]</code> to include 0</p>
<p>I'd expect most interfaces to go with <strong><code>[&lt;undo-opt&gt; pointer?]</code></strong> if they wanted optionality that they'd see VOID as null, or <strong><code>[&lt;opt-out&gt; pointer?]</code></strong> if passing in VOID meant to return null out of the operation entirely.</p>
          <p><a href="https://rebol.metaeducation.com/t/should-ffi-null-antiform-be-accepted-as-0-pointer/2407/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/should-ffi-null-antiform-be-accepted-as-0-pointer/2407/2</link>
        <pubDate>Sat, 17 May 2025 03:29:52 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2407-2</guid>
        <source url="https://rebol.metaeducation.com/t/should-ffi-null-antiform-be-accepted-as-0-pointer/2407.rss">Should FFI ~null~ Antiform Be Accepted as 0 POINTER!</source>
      </item>
      <item>
        <title>Should FFI ~null~ Antiform Be Accepted as 0 POINTER!</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>There's places in FFI clients that look more or less like this:</p>
<pre><code>let ptr: make pointer! 0
if something.field [
    let whatever: blah blah field
    ptr: address of whatever
]

call-ffi-thing-that-takes-pointer ptr
</code></pre>
<p>It's kind of inconvenient that 0 pointers aren't conditionally false.</p>
<p>At the same time, it's kind of inconvenient at times that the integer! 0 can't be tested for as conditionally false.  Are pointers a different beast?</p>
<hr>
<p><strong>Having ~null~ Typecheck Distinctly Offers Crucial Advantages</strong></p>
<p>There's something that might seem at first glance to be annoying:</p>
<pre><code>&gt;&gt; make pointer! 0
** Error: Cannot make pointer from 0
</code></pre>
<p>MAKE has to return the type of the thing you are MAKE-ing, so it can't return the antiform KEYWORD! of NULL.</p>
<p><strong>BUT</strong> this could be a raised error you defuse with TRY.  And if it's the <em>only</em> raised error (as opposed to actual failure) you can get exactly the answer you'd want:</p>
<pre><code>&gt;&gt; try make pointer! 0
== ~null~  ; anti
</code></pre>
<p>This does mean that in type specifications, if a null pointer is legal you'd have to annotate it as such, with <strong><code>[~null~ pointer!]</code></strong> instead of simply <strong><code>[pointer!]</code></strong>.</p>
<p><em>But that's a very good thing.</em>  This basically means your interfaces become documented as to whether they accept nulls or not, effectively giving you <code>std::optional</code> / <code>Option()</code> / <code>Maybe</code>.  Documenting that communicates powerfully and can give much better error locality, even in an interpreted language.</p>
<hr>
<p><strong>What are the disadvantages of making NULL the 0 pointer?</strong></p>
<p>There are obvious advantages to being able to easily conditionally test the pointer variable.</p>
<p>The first disadvantage someone might cite is "you lose the protection of being able to tell if you assigned the pointer or not".  NULL is supposed to represent the easy-to-test state of whether you've assigned a variable or not--friendlier than an unset variable, but still unfriendly in most cases.  So let's say you had meant to assign <code>ptr</code> but just forgot to.</p>
<p>I think this fear isn't that compelling.  We already have the case where NULL antiforms represent the logic falsey state (the only falsey state) and don't stress over whether you "forgot to set the logic variable".</p>
<p>The bigger deal is that there are actually some edge cases where 0 pointers are meaningful addresses.  e.g. <code>dlsym()</code> on POSIX for looking up symbols in a library makes a distinction between failure to find the address of a symbol, and address 0.</p>
<p>So if you wrote:</p>
<pre><code>something: try pick libc "some-symbol"
</code></pre>
<p>Then if it couldn't find the symbol, PICK returns a raised error, which TRY converts to NULL.  But then it could have successfully found the symbol at address 0, so that is distinct.</p>
<p><em>This seems pretty esoteric to me.</em>  If you're dealing with one of these situations, you could write:</p>
<pre><code>let pointer: pick libc "some-symbol" except e -&gt; [
    fail ["Couldn't find some-symbol in libc:" mold e]
]
let address: any [to integer! maybe pointer, 0]
</code></pre>
<p>So this way there could be a legitimate NULL returned from the LIBRARY!, vs. a raised result.  If you know you're in one of these situations, you are probably doing something hardware fiddly and an integer is what you want.</p>
<hr>
<p><strong>The Advantages Of Making ~null~ the 0 State For Pointers Seem To Outweigh The Disadvantages</strong></p>
<p>I've looked at a fair bit of code and it seems the edge case of symbols that legitimately reside at address zero in memory is not compelling enough to stop the better choice.</p>
          <p><a href="https://rebol.metaeducation.com/t/should-ffi-null-antiform-be-accepted-as-0-pointer/2407/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/should-ffi-null-antiform-be-accepted-as-0-pointer/2407/1</link>
        <pubDate>Wed, 09 Apr 2025 15:54:22 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2407-1</guid>
        <source url="https://rebol.metaeducation.com/t/should-ffi-null-antiform-be-accepted-as-0-pointer/2407.rss">Should FFI ~null~ Antiform Be Accepted as 0 POINTER!</source>
      </item>
  </channel>
</rss>

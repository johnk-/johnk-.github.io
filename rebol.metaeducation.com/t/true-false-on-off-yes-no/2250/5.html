<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>True, False, On, Off, Yes, No...? - #5 by hostilefork - Datatypes - AltRebol</title>
    <meta name="description" content="UPDATE: This thread led to the conclusion to not treat ON, OFF, YES, NO as synonyms for TRUE and FALSE, but instead rethink the paradigm as what we are calling &amp;quot;Flexible Logic&amp;quot;.  In this system, plain WORD!s are used to &amp;hellip;">
    <meta name="generator" content="Discourse 3.4.0.beta3-dev - https://github.com/discourse/discourse version 93983286b54a0e96b8073abce23f4566e9f296f7">
<link rel="icon" type="image/png" href="../../../uploads/default/optimized/1X/cbd70027b53fa165575e5b665f00eb3b8ae7ea31_2_32x32.ico">
<link rel="apple-touch-icon" type="image/png" href="../../../uploads/default/optimized/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d_2_180x180.png">
<meta name="theme-color" media="all" content="#ffffff">

<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=yes, viewport-fit=cover">
<link rel="canonical" href="../2250.html" />

<link rel="search" type="application/opensearchdescription+xml" href="../../../opensearch.xml" title="AltRebol Search">

    <link href="https://forum.rebol.info/stylesheets/color_definitions_base__2_b36da8919caf93960d3b4470a90d0e79c6a110e2.css?__ws=forum.rebol.info" media="all" rel="stylesheet" class="light-scheme"/>

  <link href="https://forum.rebol.info/stylesheets/desktop_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="desktop"  />



  <link href="https://forum.rebol.info/stylesheets/chat_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="chat"  />
  <link href="https://forum.rebol.info/stylesheets/checklist_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="checklist"  />
  <link href="https://forum.rebol.info/stylesheets/discourse-details_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="discourse-details"  />
  <link href="https://forum.rebol.info/stylesheets/discourse-lazy-videos_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="discourse-lazy-videos"  />
  <link href="https://forum.rebol.info/stylesheets/discourse-local-dates_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="discourse-local-dates"  />
  <link href="https://forum.rebol.info/stylesheets/discourse-narrative-bot_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="discourse-narrative-bot"  />
  <link href="https://forum.rebol.info/stylesheets/discourse-presence_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="discourse-presence"  />
  <link href="https://forum.rebol.info/stylesheets/docker_manager_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="docker_manager"  />
  <link href="https://forum.rebol.info/stylesheets/footnote_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="footnote"  />
  <link href="https://forum.rebol.info/stylesheets/poll_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="poll"  />
  <link href="https://forum.rebol.info/stylesheets/spoiler-alert_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="spoiler-alert"  />
  <link href="https://forum.rebol.info/stylesheets/chat_desktop_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="chat_desktop"  />
  <link href="https://forum.rebol.info/stylesheets/poll_desktop_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="poll_desktop"  />

  <link href="https://forum.rebol.info/stylesheets/desktop_theme_2_bac9ab3eace9fe3f17026a3c4dbf25e3e9e1e9a0.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="2" data-theme-name="default"/>

    
    
        <link rel="alternate nofollow" type="application/rss+xml" title="RSS feed of &#39;True, False, On, Off, Yes, No...?&#39;" href="../2250.rss" />
    <meta property="og:site_name" content="AltRebol" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:image" content="https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:url" content="https://forum.rebol.info/t/true-false-on-off-yes-no/2250/5" />
<meta name="twitter:url" content="https://forum.rebol.info/t/true-false-on-off-yes-no/2250/5" />
<meta property="og:title" content="True, False, On, Off, Yes, No...?" />
<meta name="twitter:title" content="True, False, On, Off, Yes, No...?" />
<meta property="og:description" content="In about exactly 24 hours (including about 8 hours of sleep), I managed to go from having the fleeting thought of ~on~ and ~off~ and ~yes~ and ~no~ isotopes, to implementing the long-wished-for WORD!s-for-logical-states...and having a non-trivially booting system (can run TLS and HTTP, etc.)  The fact that I could do it that fast tells you something--Rebol doesn&#39;t really use a whole lot of variables that are true and false.  It&#39;s rare to pass them as arguments to functions, because parameter-les..." />
<meta name="twitter:description" content="In about exactly 24 hours (including about 8 hours of sleep), I managed to go from having the fleeting thought of ~on~ and ~off~ and ~yes~ and ~no~ isotopes, to implementing the long-wished-for WORD!s-for-logical-states...and having a non-trivially booting system (can run TLS and HTTP, etc.)  The fact that I could do it that fast tells you something--Rebol doesn&#39;t really use a whole lot of variables that are true and false.  It&#39;s rare to pass them as arguments to functions, because parameter-les..." />
<meta property="og:article:section" content="Development" />
<meta property="og:article:section:color" content="25AAE2" />
<meta property="og:article:section" content="Datatypes" />
<meta property="og:article:section:color" content="25AAE2" />
<meta property="og:article:tag" content="isotopes" />
<meta property="article:published_time" content="2024-09-05T13:10:13+00:00" />
<meta property="og:ignore_canonical" content="true" />


    
  </head>
  <body class="crawler ">
    
    <header>
  <a href="https://forum.rebol.info/">
    AltRebol
  </a>
</header>

    <div id="main-outlet" class="wrap" role="main">
        <div id="topic-title">
    <h1>
      <a href="../2250.html">True, False, On, Off, Yes, No...?</a>
    </h1>

      <div class="topic-category" itemscope itemtype="http://schema.org/BreadcrumbList">
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://forum.rebol.info/c/development/datatypes/45" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #25AAE2'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Development</span>
              </span>
            </a>
            <meta itemprop="position" content="1" />
          </span>
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://forum.rebol.info/c/development/datatypes/45" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #25AAE2'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Datatypes</span>
              </span>
            </a>
            <meta itemprop="position" content="2" />
          </span>
      </div>

      <div class="topic-category">
        <div class='discourse-tags list-tags'>
            <a href='../../../tag/isotopes.html' class='discourse-tag' rel="tag">isotopes</a>
        </div>
      </div>
  </div>

  

    <div itemscope itemtype='http://schema.org/DiscussionForumPosting'>
      <meta itemprop='headline' content='True, False, On, Off, Yes, No...?'>
      <link itemprop='url' href='../2250.html'>
      <meta itemprop='datePublished' content='2024-09-04T10:38:37Z'>
        <meta itemprop='articleSection' content='Datatypes'>
      <meta itemprop='keywords' content='isotopes'>
      <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
        <meta itemprop='name' content='AltRebol'>
          <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
            <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
          </div>
      </div>

          <span itemprop='author' itemscope itemtype="http://schema.org/Person">
            <meta itemprop='name' content='hostilefork'>
            <link itemprop='url' href='https://forum.rebol.info/u/hostilefork'>
          </span>
        <meta itemprop='text' content='UPDATE: This thread led to the conclusion to not treat ON, OFF, YES, NO as synonyms for TRUE and FALSE, but instead rethink the paradigm as what we are calling &amp;quot;Flexible Logic&amp;quot;.  In this system, plain WORD!s are used to &amp;hellip;'>

          <div id='post_5' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2024-09-05T13:10:13Z' class='post-time'>
                    September 5, 2024,  1:10pm
                  </time>
                  <meta itemprop='dateModified' content='2024-09-06T19:08:25Z'>
              <span itemprop='position'>5</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>In about exactly 24 hours (including about 8 hours of sleep), I managed to go from having the fleeting thought of ~on~ and ~off~ and ~yes~ and ~no~ isotopes, to implementing the long-wished-for WORD!s-for-logical-states...and having a non-trivially booting system (can run TLS and HTTP, etc.)</p>
<p>The fact that I could do it that fast tells you something--Rebol doesn't really use a whole lot of variables that are <code>true</code> and <code>false</code>.  It's rare to pass them as arguments to functions, because parameter-less refinements are more the way to do that.</p>
<p>It works better than what we had before.  And the ways in which it is "weak" are really just bringing true and false into the realm of how you deal with every other thing in the language.  <strong>Trying to give an exceptional experience of using LOGIC! has really just wound up as an experience in creating a lot of exceptions.</strong>  This is a better path, that gets people in the rhythm of thinking with words--not the ideas they are used to from other languages.</p>
<h2>
<a name="some-spots-showcase-the-benefit-1" class="anchor" href="5.html#some-spots-showcase-the-benefit-1"></a>Some Spots Showcase The Benefit</h2>
<p>Consider a case where you are trying to discern a refinement that has been supplied, and would hold a logic if so:</p>
<pre><code>===: func [
    return: [nihil?]
    'remarks [element? &lt;variadic&gt;]
    /visibility [logic?]
    &lt;static&gt; showing (false)
][
    if not null? visibility [showing: visibility, return nihil]

    if showing [...]
]
</code></pre>
<p>You have to specifically say <strong>if not null? visibility</strong> because you can't just use <strong>if visibility</strong> to ask if the refinement had been supplied.  When you consider NULL to be the only branch inhibiting state, the question is natural... <strong>if visibility</strong> means exactly that: <em>are you non-null</em>.</p>
<pre><code>===: func [
    return: [nihil?]
    'remarks [element? &lt;variadic&gt;]
    /visibility ['yes 'no]
    &lt;static&gt; showing ('no)
][
    if visibility [showing: visibility, return nihil]

    if yes? showing [...]
]
</code></pre>
<p>To me that paints a sort of picture of why we are better off without the likes of #[true] and #[false].  When you get away from the mental chains of thinking you have to be limited to those words, you are getting into the mindset of how to do more with the language.</p>
<h2>
<a name="some-while-true-type-places-need-a-different-answer-2" class="anchor" href="5.html#some-while-true-type-places-need-a-different-answer-2"></a>Some <code>while [true]</code> Type Places Need A Different Answer</h2>
<p><strong><code>true</code></strong> is no longer defined, so you can't do that (unless you define true yourself for some reason).</p>
<p>Although <em>technically</em> you could just change that to <strong><code>while ['true]</code></strong> and it would <em>work</em>, that's rather misleading, because <strong><code>while ['false]</code></strong> would do the same thing.  Not a good way to teach people how to think about this.</p>
<p>You could say <strong><code>while [true? 'true]</code></strong> and be <em>accurate</em>, but that hardly seems like the best choice here.</p>
<p><strong><code>while [#]</code></strong> isn't the worst choice... the zero ASCII character literal is compact--looks solid.  It's what no-argument refinements currently use to be branch-triggering.  Certainly there's nothing overtly wrong with it, besides being "symboly"... to where someone might look at that and go "what does that <em>mean?</em>"</p>
<p>More talkative choices like <strong><code>while [#forever]</code></strong> communicate more without costing any more.  That's a short enough character sequence to fit in a cell.  You could say <strong><code>while [&lt;forever&gt;]</code></strong> with a TAG! that always does a string allocation (because it's mutable), but it's still a trivial cost when only one copy of the code exists.  And it doesn't have to dereference the string node to know it's not a null, so same runtime property as anything else.  If you think it looks better I wouldn't worry about the extra 8 platform pointers it costs.</p>
<p>Similar arguments apply to how some people (who don't like generalized ELSE) are accustomed to writing:</p>
<pre><code>case [
    condition1 [...]
    condition2 [...]
    true [...]
]
</code></pre>
<p>You wouldn't want to change that to <strong><code>'true</code></strong> for the reasons I've already mentioned (e.g. that <strong><code>'false</code></strong> would do exactly the same thing).</p>
<p>A literate choice would probably be mentioning how this is some kind of default.</p>
<pre><code>case [
    condition1 [...]
    condition2 [...]
    #default [...]
]
</code></pre>
<p>Again, the "default" fits entirely into an immutable character sequence cell such as that, so it's very cheap.</p>
<p>Anyway: my point is that <em><strong><code>'true</code></strong> now represents a particularly poor and counter-educational choice for arbitrary truthy things.</em>  There's an infinite number to choose from.  Just don't choose that.</p>
<h2>
<a name="turns-out-im-a-yes-man-3" class="anchor" href="5.html#turns-out-im-a-yes-man-3"></a>Turns Out I'm a <code>'yes</code> Man</h2>
<p>For practically everywhere that was using <code>true</code> and <code>false</code>, I think <code>yes</code> and <code>no</code> read better.</p>
<pre><code>is-dynamic: false
=&gt;
is-dynamic: 'no
</code></pre>
<p>And they're shorter.  Plus if you said <strong>if not is-dynamic</strong> before, you can say <strong>if no? is-dynamic</strong> now.</p>
<p>I just wish there was a better name for <strong>to-yes-no</strong>, if you want convert values that are NULL to <strong>no</strong> and every other non-void thing to <strong>yes</strong>.</p>
<p>I am very tempted to reclaim DID and DIDN'T for this.  "Did you find it?" -&gt; yes, no</p>
<pre><code>&gt;&gt; did find [a b c] 'b
== yes

&gt;&gt; did find [a b c] 'e
== no

&gt;&gt; didn't find [a b c] 'e
== yes
</code></pre>
<h2>
<a name="predictably-most-questionable-nothing-for-branch-trigger-4" class="anchor" href="5.html#predictably-most-questionable-nothing-for-branch-trigger-4"></a>Predictably Most Questionable: NOTHING for "Branch Trigger"</h2>
<p>The likely best other choice would be the zero ASCII character representation, <strong>#</strong>.  It's already used for no-argument refinements when they are supplied.</p>
<pre><code> &gt;&gt; 10 &lt; 20
 == #

 &gt;&gt; 10 &gt; 20
 == ~null~  ; anti
</code></pre>
<p>If we went with this, it has the seeming appealing property of letting you store the results of a logical expression in a variable, and then use it without having to invoke YES? or TRUE? or OFF? or anything like that:</p>
<pre><code> &gt;&gt; var1: 10 &lt; 20
 &gt;&gt; var2: 10 &gt; 20

 &gt;&gt; if var1 [print "This works."]
 This works.

 &gt;&gt; if not var2 [print "So does this.  What's wrong with it?"]
 So does this.  What's wrong with it?
</code></pre>
<p><em><strong>What's wrong is that I think this would encourage people to be representationally lazy, and it would slip the meaning of NULL into a haze.</strong></em></p>
<p>You'd stop really knowing what NULL means.  It ceases to be "unassigned thing that you don't really want to be passing around as a parameter".  People would start passing it around as if it was some kind of measurement.  It would become a currency for booleans, and I don't think it should be doing that.</p>
<p>That's why I speak of this "forced triage": I <em>want</em> people to be turning it into the right words for the problem, not leave it as null.  And it seems to me the best way to do that is to pick an ornery truthy state.</p>
<p><strong>"Okay, let's say we buy into that: having people assigning "logic" expressions to variables getting them unset half the time is actually a call to action to make better code, and keep NULL living to its full potential.  What are the downsides?"</strong></p>
<h2>
<a name="returning-logic-nothing-or-null-is-a-bit-weird-5" class="anchor" href="5.html#returning-logic-nothing-or-null-is-a-bit-weird-5"></a>Returning "Logic" (NOTHING or NULL) is a Bit Weird</h2>
<pre><code> foo?: func [return: [logic?] ...] [
     if whatever blah whatever [
         return ~
     ]
     return null
 ]
</code></pre>
<p>That doesn't look a whole lot like a function that's dealing in LOGIC?.</p>
<p>We're in a bit of a pickle in a sense, because we have to find some way of saying "return branch trigger" or "return branch inhibitor" without using the words true or false.  <img src="../../../images/emoji/twitter/grimacing.png%3Fv=12" title=":grimacing:" class="emoji" alt=":grimacing:" loading="lazy" width="20" height="20"></p>
<p>The first idea I had was to make something that we might consider useful for other reasons: LOGICAL, a routine which converts 0 to NULL and all other integers to NOTHING.</p>
<pre><code> foo?: func [return: [logic?] ...] [
     if whatever blah whatever [
         return logical 1  ; e.g. NOTHING
     ]
     return logical 0  ; e.g. NULL
 ]
</code></pre>
<p>It's not a useless function, and it dodges words we don't want to use.  Doesn't seem like  a terrible idea.</p>
<p>Of course, a lot of the time you're not generating the states.  You're just passing on the result of another function (e.g. writing a routine like <strong><code>even?</code></strong> in terms of <strong><code>odd?</code></strong>, and you can just say <strong><code>return not odd? number</code></strong> without having to generate anything.)</p>
<h2>
<a name="forces-functions-like-remove-each-to-pick-a-keyword-6" class="anchor" href="5.html#forces-functions-like-remove-each-to-pick-a-keyword-6"></a>Forces Functions Like REMOVE-EACH To Pick A Keyword</h2>
<p>The function REMOVE-EACH will remove the items you say to remove.</p>
<pre><code> red&gt;&gt; remove-each num [1 2 3 4] [even? num]
 == [1 3]
</code></pre>
<p>Red considers UNSET! (nothing) to be truthy, and REMOVE-EACH only cares if your branch comes out truthy (not specifically true or false).  So if your block of code ends with something like PRINT, that winds up being a removal instruction:</p>
<pre><code>red&gt;&gt; remove-each num [1 2 3 4] [print num]
1
2
3
4
== []
</code></pre>
<p>I find that a bit too liberal and easy to make mistakes.  I required your loop body to evaluate to a LOGIC! (remove if true, keep if false), NULL (keep), or VOID (keep).</p>
<p>If I were to carry that forward...it would mean taking NOTHING, NULL, or VOID.  But there are a -lot- of ways to make NOTHING (e.g. PRINT).</p>
<p>Does this mean REMOVE-EACH needs to force you to pick a word form of logic?</p>
<pre><code>&gt;&gt; remove-each num [1 2 3 4] [even? num]
** Error: REMOVE-EACH expects TRUE or FALSE (or VOID to skip)

&gt;&gt; remove-each num [1 2 3 4] [bool even? num]
1
2
3
4
== []
</code></pre>
<p>I'd almost rather it expect the body to evaluate to KEEP or REMOVE, but you lose some elegance.  Though being able to skip voids might work out:</p>
<pre><code>&gt;&gt; remove-each num [1 2 3 4] [if even? num ['remove]]
1
2
3
4
== []
</code></pre>
<p>So we're in a situation where I'm not uncomfortable with the canon branch-triggering state being the same state that unsets variables.  That's a feature.  The thing I'm less pleased about is if it's being generated by other things (like <strong>eval []</strong> or <strong>case [1 &lt; 2 []]</strong> or <strong>print [...]</strong>)</p>
<h2>
<a name="may-be-better-than-too-much-prescriptiveness-7" class="anchor" href="5.html#may-be-better-than-too-much-prescriptiveness-7"></a><strong><code>#</code></strong> May Be Better Than Too Much Prescriptiveness</h2>
<p>It would be consistent with unused refinement arguments.  You would be able to use them directly:</p>
<pre><code>&gt;&gt; f: make frame! :append

&gt;&gt; f.line: 1 &gt; 2
== ~null~  ; anti  (valid state for the /LINE no-arg refinement)

&gt;&gt; f.line: 1 &lt; 2
== #  ; valid state for the /LINE no-arg refinement
</code></pre>
<p>(It used to be that we had to worry about whether to convert TRUE and FALSE automatically, but now we would not do that--because those are WORD!s.)</p>
<p>It would allow you to save conditional expression tests in variables, even though you probably shouldn't do that very often.</p>
<p>It would mean that REMOVE-EACH could require #, NULL, or VOID.</p>
<p><strong>But one thing I don't like about it is that you can put it in blocks.</strong>  I'd rather whatever this truthy state is be an antiform.  That's probably a good property for the used refinement state as well.</p>
<p>What's a good short word that's the opposite of NULL that could be branch triggering that isn't TRUE?  <strong><code>~used~</code></strong> makes sense in the context of refinements, but does it make sense for comparisons in general?</p>
<pre><code>&gt;&gt; 1 &gt; 2
== ~null~  ; anti

&gt;&gt; 1 &lt; 2
== ~used~  ; anti
</code></pre>
<p>There's ~okay~</p>
<pre><code>&gt;&gt; 1 &gt; 2
== ~null~  ; anti

&gt;&gt; 1 &lt; 2
== ~okay~  ; anti
</code></pre>
<p>Using that for refinements doesn't necessarily seem like an improvement.</p>
<pre><code>&gt;&gt; f.line: if some-condition [okay]

&gt;&gt; f.line: if some-condition [~used~]

&gt;&gt; f.line: if some-condition [apex]  ; apex: ~apex~
</code></pre>
<p>Apex is actually pretty cool.  But certain to look strange.</p>
<pre><code>&gt;&gt; 1 &gt; 2
== ~null~  ; anti

&gt;&gt; 1 &lt; 2
== ~apex~  ; anti
</code></pre>
<p>The somewhat pejorative nature of TRASH makes me a bit reluctant to use it.</p>
<pre><code>&gt;&gt; 1 &gt; 2
== ~null~  ; anti

&gt;&gt; 1 &lt; 2
== ~
</code></pre>
<p>But also, you need to quote it.  I think this all just points to <strong><code>#</code></strong> being the most sensible choice, even though it's not an antiform.  You can't have everything.</p>
<h1>
<a name="null-complement-aside-the-rest-is-a-winner-8" class="anchor" href="5.html#null-complement-aside-the-rest-is-a-winner-8"></a>NULL Complement Aside, The Rest Is A Winner</h1>
<p>I am happy with using the words and the TRUE? YES? tests...and having the new understanding of NULL being the only branch-inhibitor (besides, probably, NaN).</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

                <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../../resurrecting-the-if-combinator-as-when/2253.html">Resurrecting the &quot;IF&quot; Combinator... as WHEN</a>
                        <meta itemprop='position' content='1'>
                      </div>
                </div>
          </div>
    </div>

      <div role='navigation' itemscope itemtype='http://schema.org/SiteNavigationElement' class="topic-body crawler-post">
          <span itemprop='name'>
            <a itemprop="url" href="../2250.html#post_5">show post in topic</a>
          </span>
      </div>

    




    </div>
    <footer class="container wrap">
  <nav class='crawler-nav'>
    <ul>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://forum.rebol.info/' itemprop="url">Home </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://forum.rebol.info/categories' itemprop="url">Categories </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://forum.rebol.info/guidelines' itemprop="url">Guidelines </a>
        </span>
      </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://forum.rebol.info/tos' itemprop="url">Terms of Service </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://forum.rebol.info/privacy' itemprop="url">Privacy Policy </a>
          </span>
        </li>
    </ul>
  </nav>
  <p class='powered-by-link'>Powered by <a href="https://www.discourse.org">Discourse</a>, best viewed with JavaScript enabled</p>
</footer>

    
    
  </body>
  
</html>

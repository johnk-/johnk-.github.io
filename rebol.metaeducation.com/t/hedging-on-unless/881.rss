<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Hedging on UNLESS</title>
    <link>https://rebol.metaeducation.com/t/hedging-on-unless/881</link>
    <description>Not everyone has historically been a fan of the idea that UNLESS is a synonym for IF-NOT.  It&#39;s the same number of characters, and it&#39;s been a source of controversy.  When people go around changing if-not to unless, some people change it back because they think it made matters less clear.

I&#39;d come up with what I thought was a more interesting usage of UNLESS, as an infix operator.  It would evaluate both the left and the right.  If the right evaluated to NULL then it would use the value of the left, otherwise the value of the right would override.

    &gt;&gt; 0 unless null
    == 0

    &gt;&gt; 0 unless &lt;a thing&gt;
    == &lt;a thing&gt;

I envisioned it being a way of reordering the order you&#39;d read code, where you could put a default first...perhaps wanting it first to emphasize the most common case:

    error-id: 0 unless case [
        not block? foo [13]
        closed? connection [29]
        ...
    ]  ; don&#39;t need an ELSE here, the 0 is up-front

But using it as a defaulting mechanism has the problem that the left-hand side is not in a BLOCK!, so you are always running the default case&#39;s code.  Trying to fix this by requiring the left side to be a block would look ugly, and seem a bit of a nasty &quot;surprise&quot;:

    thing: [  ; looks like a block literal
       foo baz bar
       ...
       x + 100
    ] unless switch z [  ; oh wait, that was *code*? :-/
        ...
    ]

So you&#39;d definitely need to use GROUP!s on the left.

    thing: (
       foo baz bar
       ...
       x + 100
    ) unless switch z [
        ...
    ]

But the value proposition gets a little bit lost once you&#39;re writing too much stuff that it pushes the UNLESS out of sight.  You&#39;re better off with:

    thing: switch z [
        ...
    ] else [
       foo baz bar
       ...
       x + 100
    ] 

## Not picking a definition yet might be the best idea?

Since I just came up with this alternate idea, I can&#39;t tell you how many uses I&#39;d find for it.  I&#39;ll have to try looking around consciously looking for use cases.  Maybe it doesn&#39;t come up often enough, and people will miss the old UNLESS enough to be worth bringing it back.

I&#39;ll commit the new idea, and we can try it for a while.  But the work has already been done to excise UNLESS, and to safely detect old usages and give warnings.  There&#39;s a native IF-NOT synonym, and it&#39;s easy enough for people who want the old definition to say `unless: if-not/` if they like.</description>
    
    <lastBuildDate>Mon, 12 May 2025 05:39:11 +0000</lastBuildDate>
    <category>Naming</category>
    <atom:link href="https://rebol.metaeducation.com/t/hedging-on-unless/881.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Hedging on UNLESS</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="881">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>Is Infix UNLESS More Common In English?</strong></p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">unless you want to get fleas, don't lie down with dogs
vs.
don't lie down with dogs unless you want to get fleas
</code></pre>
<p>AI don't have any particular agreement or data to support it, but they do seem to agree that at least in spoken English the infix is more common.</p>
</blockquote>
</aside>
<p>So I have a new mechanism I'm pretty excited about called VETO.</p>
<pre><code>&gt;&gt; reduce [1 + 2 (void) 100 + 200]
== [3 300]

&gt;&gt; reduce [1 + 2 (veto) 100 + 200]
== ~null~  ; anti
</code></pre>
<p>There are far-ranging applications for the definitional "veto" error that the VETO native produces.</p>
<p>But I also have a construct called VETO-IF, which will produce either a veto error, or a void.</p>
<pre><code>&gt;&gt; reduce [1 + 2 (veto-if 10 &gt; 20) 100 + 200]
== [3 30]

&gt;&gt; reduce [1 + 2 (veto-if 10 &lt; 20) 100 + 200]
== ~null~  ; anti
</code></pre>
<p>That's a rewrite of what you'd have to say as:</p>
<pre><code>reduce [1 + 2 (if 10 &gt; 20 [veto] else [void]) 100 + 200]
</code></pre>
<p>Because IF doesn't return VOID on no branch, but WHEN does, it's perhaps more technically valid to call it VETO-WHEN:</p>
<pre><code>reduce [1 + 2 (when 10 &gt; 20 [veto]) 100 + 200]

reduce [1 + 2 (veto-when 10 &gt; 20) 100 + 200]
</code></pre>
<p>And you might ask "why are you even shorthanding that".</p>
<p>But anyway, when thinking it would be called VETO-IF, I did wonder a bit about a complement called VETO-UNLESS.</p>
<pre><code>&gt;&gt; reduce [1 + 2 (veto-unless 10 &lt; 20) 100 + 200]
== [3 30]

&gt;&gt; reduce [1 + 2 (veto-unless 10 &gt; 20) 100 + 200]
== ~null~  ; anti
</code></pre>
<p><strong>Just trying to write these examples here makes me confused.</strong>  The negative logic is weird.  It bolsters my belief that the "UNLESS as IF-NOT is not worth it".</p>
          <p><a href="https://rebol.metaeducation.com/t/hedging-on-unless/881/5">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/hedging-on-unless/881/5</link>
        <pubDate>Mon, 12 May 2025 05:39:11 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-881-5</guid>
        <source url="https://rebol.metaeducation.com/t/hedging-on-unless/881.rss">Hedging on UNLESS</source>
      </item>
      <item>
        <title>Hedging on UNLESS</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>I had hedged on the idea of UNLESS as an infix operation that I came up with from 2018, based on it having a few problems.</p>
<p>A large number of these problems have been resolved in the intervening 6 or so years.</p>
<p>I've gotten less squeamish about taking groups literally (e.g. AND and OR do so).  I think it should take its left hand side literally, and a GROUP! should  evaluate only if the right hand side isn't true.</p>
<p>There are bad uses:</p>
<pre><code>value: (
    some long expression
    that takes many pages
) unless ...
</code></pre>
<p>Reminds me of an old quote something along the lines of <em>"There has not now--nor will there ever be--a programming language invented in which it isn't easy for people to write bad code."</em></p>
<h2><a name="p-8145-is-infix-unless-more-common-in-english-1" class="anchor" href="https://rebol.metaeducation.com#p-8145-is-infix-unless-more-common-in-english-1"></a>Is Infix UNLESS More Common In English?</h2>
<pre><code>unless you want to get fleas, don't lie down with dogs
vs.
don't lie down with dogs unless you want to get fleas
</code></pre>
<p>AI don't have any particular agreement or data to support it, but they do seem to agree that at least in spoken English the infix is more common.</p>
<h2><a name="p-8145-x-unless-condition-is-strange-2" class="anchor" href="https://rebol.metaeducation.com#p-8145-x-unless-condition-is-strange-2"></a>X UNLESS CONDITION is Strange...</h2>
<p>I thought it was clear that the right hand side is what evaluates to the value to use instead of the left.</p>
<pre><code>&gt;&gt; x: 0 unless any [1 + 2]
== 3
</code></pre>
<p>But maybe it's not so obvious?</p>
<pre><code>&gt;&gt; x: 0

&gt;&gt; x: 100 unless 1 &lt; 2
== ???
</code></pre>
<p>It almost seems like the UNLESS is controlling the entirety of the evaluation.  As if it would leave X at 0.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20">  That not possible... leaving X at 0 would require having access to X's previous value, and UNLESS can't reach back to get it.</p>
<p>Seems UNLESS could reject ~okay~ antiforms, just to help avoid this particular potential confusion.</p>
          <p><a href="https://rebol.metaeducation.com/t/hedging-on-unless/881/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/hedging-on-unless/881/4</link>
        <pubDate>Wed, 16 Apr 2025 19:46:46 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-881-4</guid>
        <source url="https://rebol.metaeducation.com/t/hedging-on-unless/881.rss">Hedging on UNLESS</source>
      </item>
      <item>
        <title>Hedging on UNLESS</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>So far, I'm liking this new definition.  It still works for the original defaulting idea, too.</p>
<p>Here's a case from some debugger code:</p>
<pre><code>max-rows: 20 unless limit then [
    if limit = &lt;unlimited&gt; [
        99999  ; as many frames as possible
    ] else [
        if limit &lt; 0 [
            panic ["Invalid limit of frames" frames]
        ]
        limit + 1  ; add one for ellipsis
    ]
]
</code></pre>
<p>You can contrast this with "classical Rebol style":</p>
<pre><code>max-rows: any [
     all [
         limit
         either limit = &lt;unlimited&gt; [
             99999 ; as many frames as possible
         ][
             if limit &lt; 0 [
                 panic ["Invalid limit of frames" frames]
             ]
             limit + 1 ; add one for ellipsis
         ]
    ]
    20
]
</code></pre>
<p>And you can still write it in such a way if you wanted to.  But I think using UNLESS with THEN organizes it in a way that makes more sense here.</p>
<hr>
<p>In any case, with this adjustment, it's working out well enough that I think it's going to be a keeper...and the IF-NOT synonym is a waste of the word in comparison.</p>
          <p><a href="https://rebol.metaeducation.com/t/hedging-on-unless/881/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/hedging-on-unless/881/3</link>
        <pubDate>Sat, 03 Nov 2018 09:34:01 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-881-3</guid>
        <source url="https://rebol.metaeducation.com/t/hedging-on-unless/881.rss">Hedging on UNLESS</source>
      </item>
      <item>
        <title>Hedging on UNLESS</title>
        <dc:creator><![CDATA[gchiu]]></dc:creator>
        <description><![CDATA[
            <p>That looks much cleaner.  I'm in that camp that <em>unless</em> is not a good <em>if-not</em></p>
          <p><a href="https://rebol.metaeducation.com/t/hedging-on-unless/881/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/hedging-on-unless/881/2</link>
        <pubDate>Mon, 29 Oct 2018 05:20:05 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-881-2</guid>
        <source url="https://rebol.metaeducation.com/t/hedging-on-unless/881.rss">Hedging on UNLESS</source>
      </item>
      <item>
        <title>Hedging on UNLESS</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Not everyone has historically been a fan of the idea that UNLESS is a synonym for IF-NOT.  It's the same number of characters, and it's been a source of controversy.  When people go around changing if-not to unless, some people change it back because they think it made matters less clear.</p>
<p>I'd come up with what I thought was a more interesting usage of UNLESS, as an infix operator.  It would evaluate both the left and the right.  If the right evaluated to NULL then it would use the value of the left, otherwise the value of the right would override.</p>
<pre><code>&gt;&gt; 0 unless null
== 0

&gt;&gt; 0 unless &lt;a thing&gt;
== &lt;a thing&gt;
</code></pre>
<p>I envisioned it being a way of reordering the order you'd read code, where you could put a default first...perhaps wanting it first to emphasize the most common case:</p>
<pre><code>error-id: 0 unless case [
    not block? foo [13]
    closed? connection [29]
    ...
]  ; don't need an ELSE here, the 0 is up-front
</code></pre>
<p>But using it as a defaulting mechanism has the problem that the left-hand side is not in a BLOCK!, so you are always running the default case's code.  Trying to fix this by requiring the left side to be a block would look ugly, and seem a bit of a nasty "surprise":</p>
<pre><code>thing: [  ; looks like a block literal
   foo baz bar
   ...
   x + 100
] unless switch z [  ; oh wait, that was *code*? :-/
    ...
]
</code></pre>
<p>So you'd definitely need to use GROUP!s on the left.</p>
<pre><code>thing: (
   foo baz bar
   ...
   x + 100
) unless switch z [
    ...
]
</code></pre>
<p>But the value proposition gets a little bit lost once you're writing too much stuff that it pushes the UNLESS out of sight.  You're better off with:</p>
<pre><code>thing: switch z [
    ...
] else [
   foo baz bar
   ...
   x + 100
] 
</code></pre>
<h2><a name="p-2651-not-picking-a-definition-yet-might-be-the-best-idea-1" class="anchor" href="https://rebol.metaeducation.com#p-2651-not-picking-a-definition-yet-might-be-the-best-idea-1"></a>Not picking a definition yet might be the best idea?</h2>
<p>Since I just came up with this alternate idea, I can't tell you how many uses I'd find for it.  I'll have to try looking around consciously looking for use cases.  Maybe it doesn't come up often enough, and people will miss the old UNLESS enough to be worth bringing it back.</p>
<p>I'll commit the new idea, and we can try it for a while.  But the work has already been done to excise UNLESS, and to safely detect old usages and give warnings.  There's a native IF-NOT synonym, and it's easy enough for people who want the old definition to say <code>unless: if-not/</code> if they like.</p>
          <p><a href="https://rebol.metaeducation.com/t/hedging-on-unless/881/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/hedging-on-unless/881/1</link>
        <pubDate>Sun, 28 Oct 2018 23:42:59 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-881-1</guid>
        <source url="https://rebol.metaeducation.com/t/hedging-on-unless/881.rss">Hedging on UNLESS</source>
      </item>
  </channel>
</rss>

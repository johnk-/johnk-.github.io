<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Typechecking Quoted forms / Quasiforms / Antiforms</title>
    <link>https://rebol.metaeducation.com/t/typechecking-quoted-forms-quasiforms-antiforms/2298</link>
    <description>Asking questions about antiforms can be a bit tricky.

If you have a lifted result that contains something that might be a pack, you&#39;d have to say:

    if pack? unlift result&#39; [...]

But you&#39;re just asking a question.  What if it contained a lift of an ERROR! antiform?  Should PACK? be willing to accept ERROR! ? If not, that would cause an abrupt failure.

To dodge the need to do an UNLIFT, you could say:

    all [
        quasiform? result&#39;
        block! = heart of result&#39;
    ] then [
       ...
    ]

And via such a mechanism, you could write a function LIFTED-PACK? that would not fail on LIFTED-ERROR!:

    if lifted-pack? result&#39; [...]

That has the nice feature of not forcing you to perform an UNLIFT just to answer the question.  You can narrowly ask &quot;is this a lifted pack&quot;.

But I think such things need to be in the box.  This question gets asked a lot, and I&#39;m tired of asking it as the ugly and breakable **`pack? unlift`**.

## What If Typecheck Functions Had a :LIFTED refinement...?

It doesn&#39;t seem like clogging up the namespace with more functions makes a lot of sense, so we might offer a refinement:

    if pack?:lifted result&#39; [...]

We could put a question mark on the refinement as well :face_with_diagonal_mouth: 

    if pack?:lifted? result&#39; [...]

Okay, no, we won&#39;t do that.

I kind of feel like putting the LIFTED after makes it unclear.  You&#39;d read it like **pack? lift result&#39;**.  Does that mean it should just be UNLIFT?

    if pack?:unlift result&#39; [...]

But at that point, people are probably not going to generally know what the difference is between that and **`pack? unlift result`**

None of this is as good as simply **`lifted-pack?`**.  But we don&#39;t want to generate new words for every possible thing (and questions like **`lifted-integer?`** are equally legitimate...)

## What About Arbitrary CHAIN! Interpretation?

Let&#39;s forget for a moment about the existing refinements to LIFTED and QUASI.  What if they--as functions--were willing to *take other functions as a refinement*?

    if lifted:pack? result&#39; [...]

This could be a general pattern of solution...

    if (quasi:group? first [~(a b c)~]) [...]

    if (quote:word? first [&#39;a b c:]) [...]  ; or quoted:word?

How would it work?  Well, I guess the basic idea would be that it would do a processing step on the argument before typechecking it and passing it to the constraint function.

So **`quoted:word?`** would run QUOTED, and it would be able to inspect the chain as containing WORD?.

* If it was passed something like **`&lt;foo&gt;`** it would say &quot;I don&#39;t even have to ask, that&#39;s not a quoted anything&quot;.

* If it was something like **`&#39;&lt;foo&gt;`** it would say &quot;okay that&#39;s quoted, I need to ask&quot; and it would unquote the thing before passing it to WORD?, which would come back false.

* If it was **`&#39;bar`** it would do the same thing but this time WORD? would return true.

*It feels a little bit ad-hoc, but the ergonomics are certainly there.*  This would be tremendously useful and could create new and useful type constraints.  It&#39;s literate... and **`lifted:pack?`** is going to look better in type specs than **`lifted/pack?`**

Not only that, but [recognizing **&quot;intrinsics&quot;** in the chain](https://rebol.metaeducation.com/t/intrinsics-functions-without-frames/2050) would mean this could be relatively fast--faster than **`pack? unlift`** could be.

## What About Refinements Like [`LIFT:LITE`](https://rebol.metaeducation.com/t/meta-lite-when-you-dont-want-quasiforms/2296)

Let&#39;s say there&#39;s a single-arity logic-bearing function someone makes called LITE, and they get mad that LIFT:LITE doesn&#39;t call it to do a meta version of that test.

I don&#39;t know that I care a ton about that.  We have situations in PARSE where you might have a variable named ACROSS and it will ignore that variable if there&#39;s a keyword called ACROSS.  You have to escape your words when they run up against reserved dialect words.

So I guess you&#39;d wind up with something like:

     if lifted:(lite/) [...]

Otherwise the keyword would win.

## What About Cascading The Functions?

    if (quoted:quoted:quasi:block? first [&#39;&#39;~[a b c]~]) [...]

Well I guess that could work if the rule was that if you used a function name as a refinement, that function would receive all the refinements after it.  Applying that recursively you&#39;d get something that works.

There could be an optimization that functions like QUOTED would detect when the functions in the chain were ones they recognized, and they could do something optimal.

## Does Any Of This Solve The UNLIFT Problem?

It&#39;s nice syntax, but remember the original issue...where you have a lifted-error-antiform, and you want to test it to see if it is or isn&#39;t a lifted pack:

    if pack? unlift result&#39; [...]

I&#39;m talking about redoing that:

    if lift:pack? result&#39; [...]

But if LIFTED is unlift&#39;ing its argument, and passing it to PACK?, does that still have the same problem?

It doesn&#39;t have to.  LIFTED would see that the result is a quasiform, hence a candidate for any function to ask... then it needs to typecheck against what PACK? takes.  But if that typecheck fails, there&#39;s no need to raise the error.  You can just say &quot;no, it&#39;s not a lifted pack&quot;.  Done.

## Are There Less Wacky Ways To Do It?

I dunno.  It&#39;s admittedly a bit weird to put that much overloading on words like LIFT and QUASI.  Their type signatures stop making sense (returning LOGIC?...sometimes?)

The overloading could be reduced if the weird modifiers were QUOTED, LIFTED, and QUASID.  :-/

    if quasid:pack? result&#39; [...]

Errr, no.  Didn&#39;t come this far to write things that look like garbage.

But oddly, quoted:xxx? looks better than quote:xxx?... does that suggest the operator should be called QUOTED too?  :thinking:

    &gt;&gt; quoted 1 + 2
    == &#39;3

I&#39;ve seen it as QUOTE for so long that it&#39;s hard to frame it.  It doesn&#39;t look *terrible*, and when you put them side by side the brevity has an advantage:

    if (quoted:quoted:quasi:block? first [&#39;&#39;~[a b c]~]) [...]

    if (quote:quote:quasi:block? first [&#39;&#39;~[a b c]~]) [...]

To say that **`&#39;a`** is a QUOTE-WORD! is a little bit caveman-ish, but better than calling it a LIT-WORD!, and it takes one less syllable to say &quot;is a quote word&quot; than to say &quot;is a quote-uhd word&quot;.

Looking at it in that light, it&#39;s growing on me to dumb it down.  Maybe not in all circumstances.  Perhaps it could be left as a matter of taste with QUOTED and QUOTE being synonyms... like FUNC and FUNCTION, use whichever you want.

## I Think This Is A Direction Worth Pursuing

I&#39;ve been looking for an answer to this question, and haven&#39;t thought of anything this good before.

Don&#39;t have a complete design for the &quot;customized refinement dialect&quot;, but I can do some prototyping...</description>
    
    <lastBuildDate>Tue, 24 Sep 2024 12:11:24 +0000</lastBuildDate>
    <category>Datatypes</category>
    <atom:link href="https://rebol.metaeducation.com/t/typechecking-quoted-forms-quasiforms-antiforms/2298.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Typechecking Quoted forms / Quasiforms / Antiforms</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Asking questions about antiforms can be a bit tricky.</p>
<p>If you have a lifted result that contains something that might be a pack, you'd have to say:</p>
<pre><code>if pack? unlift result' [...]
</code></pre>
<p>But you're just asking a question.  What if it contained a lift of an ERROR! antiform?  Should PACK? be willing to accept ERROR! ? If not, that would cause an abrupt failure.</p>
<p>To dodge the need to do an UNLIFT, you could say:</p>
<pre><code>all [
    quasiform? result'
    block! = heart of result'
] then [
   ...
]
</code></pre>
<p>And via such a mechanism, you could write a function LIFTED-PACK? that would not fail on LIFTED-ERROR!:</p>
<pre><code>if lifted-pack? result' [...]
</code></pre>
<p>That has the nice feature of not forcing you to perform an UNLIFT just to answer the question.  You can narrowly ask "is this a lifted pack".</p>
<p>But I think such things need to be in the box.  This question gets asked a lot, and I'm tired of asking it as the ugly and breakable <strong><code>pack? unlift</code></strong>.</p>
<h2><a name="p-7764-what-if-typecheck-functions-had-a-lifted-refinement-1" class="anchor" href="https://rebol.metaeducation.com#p-7764-what-if-typecheck-functions-had-a-lifted-refinement-1"></a>What If Typecheck Functions Had a :LIFTED refinement...?</h2>
<p>It doesn't seem like clogging up the namespace with more functions makes a lot of sense, so we might offer a refinement:</p>
<pre><code>if pack?:lifted result' [...]
</code></pre>
<p>We could put a question mark on the refinement as well <img src="https://rebol.metaeducation.com/images/emoji/twitter/face_with_diagonal_mouth.png?v=14" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20"></p>
<pre><code>if pack?:lifted? result' [...]
</code></pre>
<p>Okay, no, we won't do that.</p>
<p>I kind of feel like putting the LIFTED after makes it unclear.  You'd read it like <strong>pack? lift result'</strong>.  Does that mean it should just be UNLIFT?</p>
<pre><code>if pack?:unlift result' [...]
</code></pre>
<p>But at that point, people are probably not going to generally know what the difference is between that and <strong><code>pack? unlift result</code></strong></p>
<p>None of this is as good as simply <strong><code>lifted-pack?</code></strong>.  But we don't want to generate new words for every possible thing (and questions like <strong><code>lifted-integer?</code></strong> are equally legitimate...)</p>
<h2><a name="p-7764-what-about-arbitrary-chain-interpretation-2" class="anchor" href="https://rebol.metaeducation.com#p-7764-what-about-arbitrary-chain-interpretation-2"></a>What About Arbitrary CHAIN! Interpretation?</h2>
<p>Let's forget for a moment about the existing refinements to LIFTED and QUASI.  What if they--as functions--were willing to <em>take other functions as a refinement</em>?</p>
<pre><code>if lifted:pack? result' [...]
</code></pre>
<p>This could be a general pattern of solution...</p>
<pre><code>if (quasi:group? first [~(a b c)~]) [...]

if (quote:word? first ['a b c:]) [...]  ; or quoted:word?
</code></pre>
<p>How would it work?  Well, I guess the basic idea would be that it would do a processing step on the argument before typechecking it and passing it to the constraint function.</p>
<p>So <strong><code>quoted:word?</code></strong> would run QUOTED, and it would be able to inspect the chain as containing WORD?.</p>
<ul>
<li>
<p>If it was passed something like <strong><code>&lt;foo&gt;</code></strong> it would say "I don't even have to ask, that's not a quoted anything".</p>
</li>
<li>
<p>If it was something like <strong><code>'&lt;foo&gt;</code></strong> it would say "okay that's quoted, I need to ask" and it would unquote the thing before passing it to WORD?, which would come back false.</p>
</li>
<li>
<p>If it was <strong><code>'bar</code></strong> it would do the same thing but this time WORD? would return true.</p>
</li>
</ul>
<p><em>It feels a little bit ad-hoc, but the ergonomics are certainly there.</em>  This would be tremendously useful and could create new and useful type constraints.  It's literate... and <strong><code>lifted:pack?</code></strong> is going to look better in type specs than <strong><code>lifted/pack?</code></strong></p>
<p>Not only that, but <a href="https://rebol.metaeducation.com/t/intrinsics-functions-without-frames/2050">recognizing <strong>"intrinsics"</strong> in the chain</a> would mean this could be relatively fast--faster than <strong><code>pack? unlift</code></strong> could be.</p>
<h2><a name="p-7764-what-about-refinements-like-liftlitehttpsrebolmetaeducationcomtmeta-lite-when-you-dont-want-quasiforms2296-3" class="anchor" href="https://rebol.metaeducation.com#p-7764-what-about-refinements-like-liftlitehttpsrebolmetaeducationcomtmeta-lite-when-you-dont-want-quasiforms2296-3"></a>What About Refinements Like <a href="https://rebol.metaeducation.com/t/meta-lite-when-you-dont-want-quasiforms/2296"><code>LIFT:LITE</code></a></h2>
<p>Let's say there's a single-arity logic-bearing function someone makes called LITE, and they get mad that LIFT:LITE doesn't call it to do a meta version of that test.</p>
<p>I don't know that I care a ton about that.  We have situations in PARSE where you might have a variable named ACROSS and it will ignore that variable if there's a keyword called ACROSS.  You have to escape your words when they run up against reserved dialect words.</p>
<p>So I guess you'd wind up with something like:</p>
<pre><code> if lifted:(lite/) [...]
</code></pre>
<p>Otherwise the keyword would win.</p>
<h2><a name="p-7764-what-about-cascading-the-functions-4" class="anchor" href="https://rebol.metaeducation.com#p-7764-what-about-cascading-the-functions-4"></a>What About Cascading The Functions?</h2>
<pre><code>if (quoted:quoted:quasi:block? first [''~[a b c]~]) [...]
</code></pre>
<p>Well I guess that could work if the rule was that if you used a function name as a refinement, that function would receive all the refinements after it.  Applying that recursively you'd get something that works.</p>
<p>There could be an optimization that functions like QUOTED would detect when the functions in the chain were ones they recognized, and they could do something optimal.</p>
<h2><a name="p-7764-does-any-of-this-solve-the-unlift-problem-5" class="anchor" href="https://rebol.metaeducation.com#p-7764-does-any-of-this-solve-the-unlift-problem-5"></a>Does Any Of This Solve The UNLIFT Problem?</h2>
<p>It's nice syntax, but remember the original issue...where you have a lifted-error-antiform, and you want to test it to see if it is or isn't a lifted pack:</p>
<pre><code>if pack? unlift result' [...]
</code></pre>
<p>I'm talking about redoing that:</p>
<pre><code>if lift:pack? result' [...]
</code></pre>
<p>But if LIFTED is unlift'ing its argument, and passing it to PACK?, does that still have the same problem?</p>
<p>It doesn't have to.  LIFTED would see that the result is a quasiform, hence a candidate for any function to ask... then it needs to typecheck against what PACK? takes.  But if that typecheck fails, there's no need to raise the error.  You can just say "no, it's not a lifted pack".  Done.</p>
<h2><a name="p-7764-are-there-less-wacky-ways-to-do-it-6" class="anchor" href="https://rebol.metaeducation.com#p-7764-are-there-less-wacky-ways-to-do-it-6"></a>Are There Less Wacky Ways To Do It?</h2>
<p>I dunno.  It's admittedly a bit weird to put that much overloading on words like LIFT and QUASI.  Their type signatures stop making sense (returning LOGIC?...sometimes?)</p>
<p>The overloading could be reduced if the weird modifiers were QUOTED, LIFTED, and QUASID.  :-/</p>
<pre><code>if quasid:pack? result' [...]
</code></pre>
<p>Errr, no.  Didn't come this far to write things that look like garbage.</p>
<p>But oddly, quoted:xxx? looks better than quote:xxx?... does that suggest the operator should be called QUOTED too?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<pre><code>&gt;&gt; quoted 1 + 2
== '3
</code></pre>
<p>I've seen it as QUOTE for so long that it's hard to frame it.  It doesn't look <em>terrible</em>, and when you put them side by side the brevity has an advantage:</p>
<pre><code>if (quoted:quoted:quasi:block? first [''~[a b c]~]) [...]

if (quote:quote:quasi:block? first [''~[a b c]~]) [...]
</code></pre>
<p>To say that <strong><code>'a</code></strong> is a QUOTE-WORD! is a little bit caveman-ish, but better than calling it a LIT-WORD!, and it takes one less syllable to say "is a quote word" than to say "is a quote-uhd word".</p>
<p>Looking at it in that light, it's growing on me to dumb it down.  Maybe not in all circumstances.  Perhaps it could be left as a matter of taste with QUOTED and QUOTE being synonyms... like FUNC and FUNCTION, use whichever you want.</p>
<h2><a name="p-7764-i-think-this-is-a-direction-worth-pursuing-7" class="anchor" href="https://rebol.metaeducation.com#p-7764-i-think-this-is-a-direction-worth-pursuing-7"></a>I Think This Is A Direction Worth Pursuing</h2>
<p>I've been looking for an answer to this question, and haven't thought of anything this good before.</p>
<p>Don't have a complete design for the "customized refinement dialect", but I can do some prototyping...</p>
          <p><a href="https://rebol.metaeducation.com/t/typechecking-quoted-forms-quasiforms-antiforms/2298/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/typechecking-quoted-forms-quasiforms-antiforms/2298/1</link>
        <pubDate>Tue, 24 Sep 2024 00:16:40 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2298-1</guid>
        <source url="https://rebol.metaeducation.com/t/typechecking-quoted-forms-quasiforms-antiforms/2298.rss">Typechecking Quoted forms / Quasiforms / Antiforms</source>
      </item>
  </channel>
</rss>

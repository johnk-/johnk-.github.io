<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Beating REPEND: A New Parameter Convention?</title>
    <link>https://rebol.metaeducation.com/t/beating-repend-a-new-parameter-convention/1673</link>
    <description>When you do an **append a reduce b**, the REDUCE generates a new series... let&#39;s call it **rb**.  Then **rb** is spliced into **a**.  And then **rb** needs to be GC&#39;d.

The idea behind **repend a b** is that you never make **rb**.  Instead, expressions are evaluated one by one and put onto **a** as you go.  The savings are twofold...reduced memory overhead and reduced tax on the GC by not making extra series nodes.

That might sound like a great savings, but here is a heated debate in Red about the questionable benefit of REPEND (as well as /INTO):

  https://github.com/red/red/issues/3340

I guess I&#39;m halfway on DocKimbel&#39;s side there...in that if REPEND isn&#39;t showing a benefit it&#39;s probably more to do with a bug in REPEND vs. that the idea doesn&#39;t represent a savings.

But I *hate* the word REPEND.  Things like REMOLD are double monstrous, and REFORM?  Give me a break.  These make a terrible impression.

More generally, I don&#39;t like the idea that every function would have to come in two flavors and create anxiety on the part of the caller as to if they&#39;re using the optimized one or not.  I&#39;d like any optimization to be more &quot;under the hood&quot; so the caller doesn&#39;t have to fret about it.</description>
    
    <lastBuildDate>Sun, 01 Jun 2025 21:01:10 +0000</lastBuildDate>
    <category>Optimization</category>
    <atom:link href="https://rebol.metaeducation.com/t/beating-repend-a-new-parameter-convention/1673.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Beating REPEND: A New Parameter Convention?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <h2><a name="p-6362-could-an-unstable-antiform-solve-it-1" class="anchor" href="https://rebol.metaeducation.com#p-6362-could-an-unstable-antiform-solve-it-1"></a>Could An Unstable Antiform Solve It?</h2>
<p>Let's imagine something like antiform GET-BLOCK!s would reduce... and were--in fact--<strong>the result of REDUCE:</strong></p>
<pre><code>&gt;&gt; lift reduce [1000 + 20, 300 + 4]
== ~:[1000 + 20, 300 + 4]~
</code></pre>
<p>I used a LIFT there because I'm presuming the console could be one of the things that forces reduction, so that if you don't use a LIFT you see the reduced result.</p>
<pre><code>&gt;&gt; reduce [1000 + 20, 300 + 4]
== [1020 304]
</code></pre>
<p>So REDUCE would be a very cheap operation with a fixed cost, regardless of how big the block you pass in is. <em>(I've thought these might be "intrinsics", and not even create frames)</em>.</p>
<p>Then APPEND, INSERT, CHANGE, etc. can accept the antiform, and blend in the reduction with their new series creation.  You can thus avoid the creation of large intermediate series.</p>
<p>And... the parameter fulfillment to any function that <em>doesn't</em> understand the convention, can just reduce it during argument fulfillment... passing the function the normal block.</p>
<p>The only downside I can think of is that if something ^METAs the REDUCE and pokes it off somewhere, it could wind up performing the operation at a later time than you would think.</p>
<p>It also gives more information to a function than you'd think you were, if it has this parameter convention then the receiving function gets the pre-reduced information.</p>
<p>If these kinds of things are problems, we could call it REDUCES and say it is used by the optimization-minded, vs. trying to make it the pervasive default of REDUCE.  People who disagree could say <strong>reduce: :reduces</strong> and see if everything runs the same...</p>
<p>Hmmm... it seems that deferring the REDUCE is generally only useful if you splice, so maybe it should be an isotopic GET-GROUP!?</p>
<p>Anyway... this is a kind of out-there idea.  It seems to point a bit to my generic LAZY ideas pertaining to antiform OBJECT!, that were maybe more trouble than they were worth...</p>
          <p><a href="https://rebol.metaeducation.com/t/beating-repend-a-new-parameter-convention/1673/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/beating-repend-a-new-parameter-convention/1673/4</link>
        <pubDate>Fri, 02 Sep 2022 11:14:23 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1673-4</guid>
        <source url="https://rebol.metaeducation.com/t/beating-repend-a-new-parameter-convention/1673.rss">Beating REPEND: A New Parameter Convention?</source>
      </item>
      <item>
        <title>Beating REPEND: A New Parameter Convention?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>When you do an <strong>append a reduce b</strong>, the REDUCE generates a new series... let's call it <strong>rb</strong>.  Then <strong>rb</strong> is spliced into <strong>a</strong>.  And then <strong>rb</strong> needs to be GC'd.</p>
<p>The idea behind <strong>repend a b</strong> is that you never make <strong>rb</strong>.  Instead, expressions are evaluated one by one and put onto <strong>a</strong> as you go.  The savings are twofold...reduced memory overhead and reduced tax on the GC by not making extra series nodes.</p>
<p>That might sound like a great savings, but here is a heated debate in Red about the questionable benefit of REPEND (as well as /INTO):</p>
<p><a href="https://github.com/red/red/issues/3340" class="inline-onebox">`repend` vs `append reduce` differences and regression · Issue #3340 · red/red · GitHub</a></p>
<p>I guess I'm halfway on DocKimbel's side there...in that if REPEND isn't showing a benefit it's probably more to do with a bug in REPEND vs. that the idea doesn't represent a savings.</p>
<p>But I <em>hate</em> the word REPEND.  Things like REMOLD are double monstrous, and REFORM?  Give me a break.  These make a terrible impression.</p>
<p>More generally, I don't like the idea that every function would have to come in two flavors and create anxiety on the part of the caller as to if they're using the optimized one or not.  I'd like any optimization to be more "under the hood" so the caller doesn't have to fret about it.</p>
          <p><a href="https://rebol.metaeducation.com/t/beating-repend-a-new-parameter-convention/1673/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/beating-repend-a-new-parameter-convention/1673/1</link>
        <pubDate>Thu, 19 Aug 2021 22:29:50 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1673-1</guid>
        <source url="https://rebol.metaeducation.com/t/beating-repend-a-new-parameter-convention/1673.rss">Beating REPEND: A New Parameter Convention?</source>
      </item>
  </channel>
</rss>

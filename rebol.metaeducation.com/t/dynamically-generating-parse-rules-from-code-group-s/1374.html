<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Dynamically Generating Parse Rules From Code GROUP!s - Parsing - AltRebol</title>
    <meta name="description" content="Historically, a plain GROUP! in PARSE runs the conventional evaluator.  But it discards its result and doesn&amp;#39;t put it into the stream of parse instructions. 
That means you can&amp;#39;t do things like this: 
parse &amp;quot;aaa&amp;quot; [some (&amp;hellip;">
    <meta name="generator" content="Discourse 3.5.0.beta6-dev - https://github.com/discourse/discourse version 623cde985b21c2ed812b83d3ea94f69231613718">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/1X/cbd70027b53fa165575e5b665f00eb3b8ae7ea31_2_32x32.ico">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d_2_180x180.png">
<meta name="theme-color" media="all" content="#fff">

<meta name="color-scheme" content="light">

<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, viewport-fit=cover">
<link rel="canonical" href="1374.html" />

<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="AltRebol Search">

    <link href="https://rebol.metaeducation.com/stylesheets/color_definitions_base__2_ceb61c279a74dfa3cef6a62f7784988102abec82.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" class="light-scheme"/>

<link href="https://rebol.metaeducation.com/stylesheets/common_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="common"  />

  <link href="https://rebol.metaeducation.com/stylesheets/desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="desktop"  />



    <link href="https://rebol.metaeducation.com/stylesheets/chat_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="chat"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-details_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-details"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-lazy-videos_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-lazy-videos"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-local-dates_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-local-dates"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-narrative-bot_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-narrative-bot"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-presence_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-presence"  />
    <link href="https://rebol.metaeducation.com/stylesheets/docker_manager_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="docker_manager"  />
    <link href="https://rebol.metaeducation.com/stylesheets/footnote_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="footnote"  />
    <link href="https://rebol.metaeducation.com/stylesheets/poll_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="poll"  />
    <link href="https://rebol.metaeducation.com/stylesheets/spoiler-alert_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="spoiler-alert"  />
    <link href="https://rebol.metaeducation.com/stylesheets/chat_desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="chat_desktop"  />
    <link href="https://rebol.metaeducation.com/stylesheets/poll_desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="poll_desktop"  />

  <link href="https://rebol.metaeducation.com/stylesheets/common_theme_2_57fe803ed5a41e9f7d94086afaf66a1aab57d9ae.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="common_theme" data-theme-id="2" data-theme-name="default"/>
    

    
    
        <link rel="alternate nofollow" type="application/rss+xml" title="RSS feed of &#39;Dynamically Generating Parse Rules From Code GROUP!s&#39;" href="1374.rss" />
    <meta property="og:site_name" content="AltRebol" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:image" content="https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:url" content="https://rebol.metaeducation.com/t/dynamically-generating-parse-rules-from-code-group-s/1374" />
<meta name="twitter:url" content="https://rebol.metaeducation.com/t/dynamically-generating-parse-rules-from-code-group-s/1374" />
<meta property="og:title" content="Dynamically Generating Parse Rules From Code GROUP!s" />
<meta name="twitter:title" content="Dynamically Generating Parse Rules From Code GROUP!s" />
<meta property="og:description" content="Historically, a plain GROUP! in PARSE runs the conventional evaluator.  But it discards its result and doesn&#39;t put it into the stream of parse instructions.  That means you can&#39;t do things like this:  parse &quot;aaa&quot; [some (either condition [&quot;a&quot;] [&quot;b&quot;])]  Because the &quot;discarding&quot; behavior of GROUP!s in PARSE is so pervasive, it seemed hard to challenge.  So Ren-C had adopted the GET-GROUP! as :(...) to be non-discarding form, which you could use to splice arbitrary arguments or instructions into the..." />
<meta name="twitter:description" content="Historically, a plain GROUP! in PARSE runs the conventional evaluator.  But it discards its result and doesn&#39;t put it into the stream of parse instructions.  That means you can&#39;t do things like this:  parse &quot;aaa&quot; [some (either condition [&quot;a&quot;] [&quot;b&quot;])]  Because the &quot;discarding&quot; behavior of GROUP!s in PARSE is so pervasive, it seemed hard to challenge.  So Ren-C had adopted the GET-GROUP! as :(...) to be non-discarding form, which you could use to splice arbitrary arguments or instructions into the..." />
<meta property="og:article:section" content="Domains" />
<meta property="og:article:section:color" content="F1592A" />
<meta property="og:article:section" content="Parsing" />
<meta property="og:article:section:color" content="F1592A" />
<meta name="twitter:label1" value="Reading time" />
<meta name="twitter:data1" value="3 mins 🕑" />
<meta name="twitter:label2" value="Likes" />
<meta name="twitter:data2" value="5 ❤" />
<meta property="article:published_time" content="2020-10-28T06:50:59+00:00" />
<meta property="og:ignore_canonical" content="true" />


    
  </head>
  <body class="crawler ">
    
    <header>
  <a href="https://rebol.metaeducation.com/">AltRebol</a>
</header>

    <div id="main-outlet" class="wrap" role="main">
        <div id="topic-title">
    <h1>
      <a href="1374.html">Dynamically Generating Parse Rules From Code GROUP!s</a>
    </h1>

      <div class="topic-category" itemscope itemtype="http://schema.org/BreadcrumbList">
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://rebol.metaeducation.com/c/domains/parsing/16" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #F1592A'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Domains</span>
              </span>
            </a>
            <meta itemprop="position" content="1" />
          </span>
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://rebol.metaeducation.com/c/domains/parsing/16" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #F1592A'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Parsing</span>
              </span>
            </a>
            <meta itemprop="position" content="2" />
          </span>
      </div>

  </div>

  

    <div itemscope itemtype='http://schema.org/DiscussionForumPosting'>
      <meta itemprop='headline' content='Dynamically Generating Parse Rules From Code GROUP!s'>
      <link itemprop='url' href='1374.html'>
      <meta itemprop='datePublished' content='2020-10-28T06:50:59Z'>
        <meta itemprop='articleSection' content='Parsing'>
      <meta itemprop='keywords' content=''>
      <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
        <meta itemprop='name' content='AltRebol'>
          <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
            <meta itemprop='url' content='https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
          </div>
      </div>


          <div id='post_1'  class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>

                <link itemprop="mainEntityOfPage" href="1374.html">


              <span class="crawler-post-infos">
                  <time  datetime='2020-10-28T06:50:59Z' class='post-time'>
                    October 28, 2020,  6:50am
                  </time>
                  <meta itemprop='dateModified' content='2022-05-23T20:22:07Z'>
              <span itemprop='position'>1</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>Historically, a plain GROUP! in PARSE runs the conventional evaluator.  But it discards its result and doesn't put it into the stream of parse instructions.</p>
<p>That means you can't do things like this:</p>
<pre><code>parse "aaa" [some (either condition ["a"] ["b"])]
</code></pre>
<p>Because the "discarding" behavior of GROUP!s in PARSE is so pervasive, it seemed hard to challenge.  So Ren-C had adopted the GET-GROUP! as <strong>:(...)</strong> to be non-discarding form, which you could use to splice arbitrary arguments or instructions into the PARSE stream.</p>
<p>But to <a class="mention" href="https://rebol.metaeducation.com/u/rgchris">@rgchris</a>'s taste, the colons are ugly.  I can see it that way.</p>
<p>We <em>could</em> turn it the other way, and say you have to explicitly throw results away...otherwise they are kept.</p>
<pre><code>parse "aaa" [some ["a" elide (print "found an A")]]
</code></pre>
<p>A failure to put the ELIDE there would mean you'd be trying to splice the PRINT result (a ~none~ isotope) into the instruction stream, which we'd imagine is an error.</p>
<p>The choice to elide could come from inside the group as well:</p>
<pre><code>parse "aaa" [some ["a" (elide print "found an A")]]
</code></pre>
<p>Or use something that returned a ~void~ isotope...since that's ignored by the parse stream.  This is the mechanism by which branching constructs can be used to good effect:</p>
<pre><code>parse "aaa" [some ["a" (if false ["b"])]]
</code></pre>
<h2><a name="p-4186-it-gets-rid-of-the-colons-but-does-it-suck-to-use-1" class="anchor" href="1374.html#p-4186-it-gets-rid-of-the-colons-but-does-it-suck-to-use-1"></a>It Gets Rid of the Colons, but Does It Suck To Use?</h2>
<p>I'm not so much concerned about backwards compatibility, as I am about two issues:</p>
<ol>
<li>
<p><em>Is it actually, measurably, knowably better.</em></p>
</li>
<li>
<p><em>Will the machinery bend to allow emulation of the Rebol2 semantics.</em></p>
</li>
</ol>
<p>I'm interested in (2) because I kind of insist on being able to implement Redbol.  So I'd like there to be some kind of hook to choose.  Ideally it would be the kind of hook that would have allowed a motivated individual to add something like the behavior of COLLECT and KEEP as it acts now to PARSE.</p>
<blockquote>
<p><strong>2022 UPDATE:</strong> <strong><a href="../introducing-uparse-the-hackable-usermode-parse/1529.html">UPARSE offers all this, and more!</a></strong>  How far things have come since October 2020!</p>
</blockquote>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="1" />
              <span class='post-likes'>1 Like</span>
            </div>

          </div>
          <div id='post_2' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='../../u/BlackATTR.html'><span itemprop='name'>BlackATTR</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2020-10-28T22:23:46Z' class='post-time'>
                    October 28, 2020, 10:23pm
                  </time>
                  <meta itemprop='dateModified' content='2020-10-28T22:23:46Z'>
              <span itemprop='position'>2</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>I hope we get some good community feedback here. I like the new functionality and I'm fine with the proposed consistent GROUP! behavior. OTOH I'm not tied to a legacy codebase to convert.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
          <div id='post_3' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/iArnold'><span itemprop='name'>iArnold</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2020-10-29T11:38:43Z' class='post-time'>
                    October 29, 2020, 11:38am
                  </time>
                  <meta itemprop='dateModified' content='2020-10-29T11:38:43Z'>
              <span itemprop='position'>3</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>Try to stick to any other programming language over a longer period of time, chances are you have to make changes in your codebase to deal with the progression. Many projects in my working history have this as a common denominator.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
          <div id='post_4' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2020-10-29T14:33:48Z' class='post-time'>
                    October 29, 2020,  2:33pm
                  </time>
                  <meta itemprop='dateModified' content='2022-05-23T20:25:47Z'>
              <span itemprop='position'>4</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="BlackATTR" data-post="2" data-topic="1374">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/blackattr/48/204_2.png" class="avatar"> BlackATTR:</div>
<blockquote>
<p>I like the new functionality and I'm fine with the proposed consistent GROUP! behavior.</p>
</blockquote>
</aside>
<p>It may be conceptually more "healthy" to see the discarding case as the behavior requiring a notation.  You don't generally conceive of things in parentheses being associated with discarding the result...it "groups" things.</p>
<p>Yet it does get quite wordy.  <img src="../../images/emoji/twitter/frowning.png%3Fv=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20">   Let's say you start with something like:</p>
<pre><code>        parse3 skip executable string-header-offset [
            (mode: 'read) pos: section-header-rule
            (
                assert [sh_offset = string-section-offset]
                sh_size: sh_size + (1 + length of encap-section-name)
            )
            (mode: 'write) :pos section-header-rule
            to end
        ]
</code></pre>
<p>Becoming:</p>
<pre><code>        parse3 skip executable string-header-offset [
            elide (mode: 'read) pos: section-header-rule
            elide (
                assert [sh_offset = string-section-offset]
                sh_size: sh_size + (1 + length of encap-section-name)
            )
            elide (mode: 'write) :pos section-header-rule
            to end
        ]
</code></pre>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="1" />
              <span class='post-likes'>1 Like</span>
            </div>

          </div>
          <div id='post_5' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='../../u/BlackATTR.html'><span itemprop='name'>BlackATTR</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2020-10-29T16:05:20Z' class='post-time'>
                    October 29, 2020,  4:05pm
                  </time>
                  <meta itemprop='dateModified' content='2022-05-23T20:26:14Z'>
              <span itemprop='position'>5</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>I'm all for consistency. But GET-WORD!s are commonly used to set/inject a new position into PARSE, so it doesn't seem much of a cognitive stretch to use GET-GROUP to splice results in. I don't know what the chances are for getting a notation or shorthand for ELIDE...</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
          <div id='post_6' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='../../u/IngoHohmann.html'><span itemprop='name'>IngoHohmann</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2020-10-29T18:59:47Z' class='post-time'>
                    October 29, 2020,  6:59pm
                  </time>
                  <meta itemprop='dateModified' content='2020-10-29T18:59:47Z'>
              <span itemprop='position'>6</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>I had to think this over, because I wasn't sure wether my reluctance was just because of change.</p>
<p>In my experience adjusting rules is an important usage of groups in parse, but not the most frequent usage.</p>
<p>Furthermore the number of elides just doesn't look good.</p>
<p>So I would vote to keep plain groups as vanishing and get-groups as splicing. Double groups could be used as well, but I think that might be harder when you are constructing rules programmatically.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="1" />
              <span class='post-likes'>1 Like</span>
            </div>

          </div>
          <div id='post_8' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/rgchris'><span itemprop='name'>rgchris</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2020-11-12T06:15:49Z' class='post-time'>
                    November 12, 2020,  6:15am
                  </time>
                  <meta itemprop='dateModified' content='2022-05-23T20:27:09Z'>
              <span itemprop='position'>8</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>This example doesn't quite sit right:</p>
<aside class="quote no-group quote-post-not-found" data-username="hostilefork" data-post="7" data-topic="1374">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre><code>parse "aa" [some (first ["a" "b"]) (x: "c")]
</code></pre>
</blockquote>
</aside>
<p>If a group's product is to be used as a rule, it should be explicit, say:</p>
<pre><code>parse "aa" [some use (first ["a" "b"]) (x: "c")]
</code></pre>
<p>This could be a GET-GROUP! where this type is available, I suppose (I'm not wholly convinced of GET-GROUP!'s necessity), though my leaning would be to solve through words.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
          <div id='post_10' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
                  Split this topic 
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2021-04-13T03:11:03Z' class='post-time'>
                    April 13, 2021,  3:11am
                  </time>
                  <meta itemprop='dateModified' content='2021-04-13T03:11:03Z'>
              <span itemprop='position'>10</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>A post was split to a new topic: <a href="https://rebol.metaeducation.com/t/role-of-xxx-in-parse/1584">Role of @(xxx) in PARSE</a></p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
          <div id='post_12' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2022-05-24T00:54:15Z' class='post-time'>
                    May 24, 2022, 12:54am
                  </time>
                  <meta itemprop='dateModified' content='2022-05-24T09:27:27Z'>
              <span itemprop='position'>12</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="IngoHohmann" data-post="6" data-topic="1374">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/ingohohmann/48/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>In my experience adjusting rules is an important usage of groups in parse, but not the most frequent usage.</p>
<p>Furthermore the number of elides just doesn't look good.</p>
</blockquote>
</aside>
<p>Certainly from that experiment we have agreement on this.  Swapping GROUP! and GET-GROUP! <em>usually</em>, <em>probably</em>, is ugly.</p>
<p>Buuuuuuut... <em>what if you wanted to?</em></p>
<p><strong>With UPARSE, you can be as ugly as you want to be!</strong>  <img src="../../images/emoji/twitter/japanese_goblin.png%3Fv=14" title=":japanese_goblin:" class="emoji" alt=":japanese_goblin:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-5870-though-this-particular-intent-is-a-little-bit-subtle-1" class="anchor" href="1374.html#p-5870-though-this-particular-intent-is-a-little-bit-subtle-1"></a>Though This Particular Intent Is a Little Bit Subtle</h2>
<p>For starters, we could think of just replacing the GROUP! combinator with the GET-GROUP! combinator:</p>
<pre><code>ugly-combinators: copy default-combinators
ugly-combinators.group!: :default-combinators.(get-group!)
ugly-combinators.get-group!: null

ugly-parse: specialize :uparse [combinators: ugly-combinators]
</code></pre>
<p>Nice idea, <em>but</em> in the examples above I used ELIDE for the intent of "let the GROUP! rule run, but don't use its result as a parse rule to match".</p>
<p>But ELIDE only erases <em>rule products</em>...it doesn't stop the rule from doing whatever it does.  And if the rule fails, the ELIDE still fails.</p>
<p>COMMENT will suppress the argument rule from running altogether.  So that's also no good: the point in the examples was that you need a way to run the code in the group--just not splice a new parse rule.</p>
<p>So this example needs one GROUP! combinator that works two completely different ways--based on the influence of an <em>ELIDE-like</em> modifying rule (I'll call it <strong>DISCARD</strong>).  It's an even "weirder" idea than it seems on the surface.  None of the options are great:</p>
<ol>
<li>
<p>Make DISCARD something that quotes its argument, and maybe only narrowly works with GROUP!.  It would then run the DO on the GROUP! itself.</p>
</li>
<li>
<p>Make the GROUP! combinator infix left quoting <em>(if UPARSE had such a thing!)</em> and have it look to the left to see if it sees a DISCARD.  If it does, then only run the group...don't try and retrigger the resulting combinator.</p>
</li>
<li>
<p>Have DISCARD feed the next combinator an empty series of the same type as its input, and hope that means it won't do much...then ignore whether it was successful or not.  But consider <strong>discard (if true '[opt "a" (print "side effect")])</strong> - just because the series you feed to a rule is empty doesn't mean it won't do anything!</p>
</li>
</ol>
<h2><a name="p-5870-lets-demo-1-because-we-can-2" class="anchor" href="1374.html#p-5870-lets-demo-1-because-we-can-2"></a>Let's Demo <span class="hashtag-raw">#1</span> (Because We Can!)</h2>
<p>Let's take it from the top...</p>
<pre><code>ugly-combinators: copy default-combinators
ugly-combinators.group!: :default-combinators.(get-group!)
ugly-combinators.get-group!: null

 ugly-combinators.discard: combinator [
    return: "Don't return anything" [&lt;invisible&gt;]
    'group "Capture GROUP! so it doesn't get a combinator" [group!]
][
    do group  ; we DO the group since it didn't get "combinated"
    set remainder input
    return
]

ugly-parse: specialize :uparse [combinators: ugly-combinators]

&gt;&gt; ugly-parse "aaabbb" [
       (print "A RULE", if true '[some "a"])
       some "b"
       discard (print "C RULE", if true '[some "c"])
   ]
A RULE
C RULE
== #b
</code></pre>
<p>There you have it... you can indeed flip the GROUP! behavior on its head.  <strong>But this is just the tip of the iceberg about how the UPARSE engine can serve as the backbone for your dialects.</strong>  Expect to see much more of this kind of acrobatics coming down the pipe!</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="1" />
              <span class='post-likes'>1 Like</span>
            </div>

          </div>
          <div id='post_13' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2022-05-24T00:58:57Z' class='post-time'>
                    May 24, 2022, 12:58am
                  </time>
                  <meta itemprop='dateModified' content='2022-06-02T11:11:17Z'>
              <span itemprop='position'>13</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p><em>Note: Two years after this discussion, <strong><a href="../introducing-uparse-the-hackable-usermode-parse/1529.html">we now have UPARSE <img src="../../images/emoji/twitter/rocket.png%3Fv=14" title=":rocket:" class="emoji" alt=":rocket:" loading="lazy" width="20" height="20"></a></strong>... and its idea of GROUP! combinators yielding evaluative products has revolutionized and solved entire classes of problems.</em></p>
<hr>
<aside class="quote no-group" data-username="rgchris" data-post="8" data-topic="1374">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>If a group's product is to be used as a rule, it should be explicit, say:</p>
<pre><code>parse "aa" [some use (first ["a" "b"]) (x: "c")]
</code></pre>
</blockquote>
</aside>
<p>Prior to UPARSE, this USE would just be bringing in an epicycle of my same uneasy feeling: if GROUP!s are conventionally being discarded, the USE would be breaking the rules by seeing it.</p>
<p>But there's a whole new narrative.  You're always aware--and expect--each rule to have a return value, consumable by the rules above it.  The last synthesized value drops out of the BLOCK! combinator just as with DO.  So the unsettling aspect of "vanishing" results sometimes and not others is no longer a sticking point.</p>
<p>Maybe it seemed I was making a big deal over nothing at the time--but--I believe my feeling that <em>something was off</em> was key to the pursuit of the new design!</p>
<aside class="quote no-group quote-modified" data-username="rgchris" data-post="8" data-topic="1374">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>This could be a GET-GROUP! where this type is available, I suppose (I'm not wholly convinced of GET-GROUP!'s necessity) though my leaning would be to solve through words.</p>
</blockquote>
</aside>
<p>Power users might appreciate the brevity of the GET-GROUP! when situations warrant it.  But I think I'm in agreement it needs a good word form.</p>
<p>We might call it REPARSE (in the spirit of REEVAL/REEVALUATE).</p>
<pre><code>&gt;&gt; reeval (second [a: b:]) 1 + 2
== 3

&gt;&gt; b
== 3
</code></pre>
<p>There's a bit of a twist, because that's a variadic function that does something gnarlier than what UPARSE can do with a combinator.  e.g. we'd have trouble with putting down an incomplete rule that "combinates" with things that come after it:</p>
<pre><code>parse "aa" [reparse (second [opt some]) "a"]  ; remember UPARSE will be PARSE
</code></pre>
<p>That would require some kind of additional return signal from REPARSE to ask the BLOCK! combinator to run some more material.  <em>(Does anyone recall RETURN/REDO?...)</em></p>
<p>Another option would be INLINE.  It's currently broken, but the idea was that it would be able to splice arbitrary code into the stream of execution:</p>
<pre><code>&gt;&gt; stuff: [+ 2 *]

&gt;&gt; 1 inline stuff 3
== 9
</code></pre>
<p>Some of these ideas run up against fundamental problems, and won't work.  In the above example, you face a problem that INLINE has to know a-priori if it's going to operate infixedly and look to its left...and that has to be declared before it executes code.</p>
<p>But more modest scenarios can work, and INLINE may be a good name for it.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="1" />
              <span class='post-likes'>1 Like</span>
            </div>

          </div>
    </div>


    




    </div>
    <footer class="container wrap">
  <nav class='crawler-nav'>
    <ul>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/' itemprop="url">Home </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/categories' itemprop="url">Categories </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/guidelines' itemprop="url">Guidelines </a>
        </span>
      </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://rebol.metaeducation.com/tos' itemprop="url">Terms of Service </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://rebol.metaeducation.com/privacy' itemprop="url">Privacy Policy </a>
          </span>
        </li>
    </ul>
  </nav>
  <p class='powered-by-link'>Powered by <a href="https://www.discourse.org">Discourse</a>, best viewed with JavaScript enabled</p>
</footer>

    
    
  </body>
  
</html>

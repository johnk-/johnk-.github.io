<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Why quote/unquote if lift/unlift are a superset?</title>
    <link>https://rebol.metaeducation.com/t/why-quote-unquote-if-lift-unlift-are-a-superset/2450</link>
    <description>[quote=&quot;bradrn, post:5, topic:2088&quot;]
why do **`quote`** and **`unquote`** exist when **`lift`** and **`unlift`** can do the same thing, while handling more cases?
[/quote]

Sanity check.

Antiforms are weird, and creating them (or tolerating them) when you didn&#39;t mean to is good to avoid.

Unstable antiforms are particularly weird...for instance antiform BLOCK! cannot be stored in variables.  In normal assignments it decays to its first element, while multi-assignments and other particular constructs interpret it as multiple values:

    &gt;&gt; quasiform: &#39;~[&#39;1020 ~null~]~
    == ~[&#39;1020 ~null~]~

    &gt;&gt; x: unlift quasiform
    == 1020

    &gt;&gt; [x y]: unlift quasiform
    == 1020

    &gt;&gt; y
    == \~null~\  ; antiform

This is how multi-return functions are implemented.

What&#39;s nice about UNQUOTE vs UNLIFT is that if you are really not suspecting you&#39;re dealing with a quasiform that should become an antiform, you can avoid the potential confusion caused.

And QUOTE has a similar convenience of not tolerating an antiform when you didn&#39;t think there&#39;d be one.

A narrower operator of QUASI and UNQUASI exists to make it clear when you&#39;re only adding or removing a quasi state.  So you can QUASI only plain non-quoted things, and UNQUASI only non-quoted quasiforms.  Then NOQUASI will pass through all values except drop the quasi from quasiforms.

Just helps readers get their bearings on what&#39;s going on if that&#39;s all that&#39;s happening.</description>
    
    <lastBuildDate>Thu, 10 Jul 2025 13:30:51 +0000</lastBuildDate>
    <category>Questions</category>
    <atom:link href="https://rebol.metaeducation.com/t/why-quote-unquote-if-lift-unlift-are-a-superset/2450.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Why quote/unquote if lift/unlift are a superset?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="2450">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<aside class="quote no-group quote-modified" data-username="bradrn" data-post="5" data-topic="2088">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/bradrn-brad/2088/5">bradrn (Brad)</a></div>
<blockquote>
<p>why do <strong><code>quote</code></strong> and <strong><code>unquote</code></strong> exist when <strong><code>lift</code></strong> and <strong><code>unlift</code></strong> can do the same thing, while handling more cases?</p>
</blockquote>
</aside>
<p>Sanity check.</p>
</blockquote>
</aside>
<p>In an attempt to further "preserve sanity", I was afraid of LIFT too casually accepting ERROR! antiforms and putting those unstable states into suspended animation... so I created <strong><code>lift*</code></strong> and said you had to use it to lift errors, otherwise the plain LIFT would fail.</p>
<p>That was before metaform behavior shifted to be able to manipulate unstable forms without any lift or unlift calls.  Assigning an ERROR! to a metaform would have the assignment succeed... but the ERROR! would still propagate out.</p>
<pre><code>     ^foo: fail "abcd"
  ; &lt;-- the ERROR! still synthesizes as the result going left
</code></pre>
<p>So ^META assignments aren't as much at risk of accidentally sweeping errors under the rug.  And they're the go-to tool now.  LIFT is more specialized, and actually barely used in usermode (most of the remaining instances just haven't been rethought to not need it).</p>
<h2><a name="p-8505-is-the-paranoia-justified-frowning_face_with_open_mouth-1" class="anchor" href="https://rebol.metaeducation.com#p-8505-is-the-paranoia-justified-frowning_face_with_open_mouth-1"></a>Is The Paranoia Justified?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning_face_with_open_mouth.png?v=14" title=":frowning_face_with_open_mouth:" class="emoji" alt=":frowning_face_with_open_mouth:" loading="lazy" width="20" height="20"></h2>
<p>One of the earliest problems LIFT was designed to address was e.g. writing "FOR-BOTH":</p>
<pre><code>for-both: func [var blk1 blk2 body] [
    return unlift:lite all [
        lift:lite for-each var blk1 body
        lift:lite for-each var blk2 body
    ]
]
</code></pre>
<p>The risk is if you LIFT an ERROR! too casually, cases like this would incorrectly toss out failures.</p>
<p>Though I will say that in my current thinking.... <a href="https://rebol.metaeducation.com/t/when-should-evaluative-constructs-return-error/2506">FOR-EACH won't return ERROR!, because if a body ever returns ERROR! it will panic.</a></p>
<p>One can see why I would have thought LIFT taking ERROR! too casually was unsafe.</p>
<p>BUT... I definitely see a lot of appeal for LIFT and UNLIFT to just agnostically lift and unlift anything.  We might say that they're power-user features and if you're writing power-user code, you have to know to do things like LIFT TRAP (propagate ERROR! to RETURN instead of lifting it) or LIFT REQUIRE (force ERROR! to panic before lifting it).</p>
<p><strong>I think I'm going to say LIFT and UNLIFT are unconstrained, and you add the constraint on if you want it.</strong>  It just feels cleaner and more pleasing... shifting the balance to making them reliable operations that obey the rules of the game, to truly lift and unlift anything they can.  The new workings of ^META operations does take a lot of the pressure off, and I think that makes it reasonable to expect that people using LIFT and UNLIFT do so with precision in terms of subsetting out what they don't want to lift, if it's not everything.</p>
          <p><a href="https://rebol.metaeducation.com/t/why-quote-unquote-if-lift-unlift-are-a-superset/2450/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/why-quote-unquote-if-lift-unlift-are-a-superset/2450/3</link>
        <pubDate>Thu, 10 Jul 2025 12:49:08 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2450-3</guid>
        <source url="https://rebol.metaeducation.com/t/why-quote-unquote-if-lift-unlift-are-a-superset/2450.rss">Why quote/unquote if lift/unlift are a superset?</source>
      </item>
      <item>
        <title>Why quote/unquote if lift/unlift are a superset?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="2450">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<aside class="quote no-group quote-modified" data-username="bradrn" data-post="5" data-topic="2088">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/bradrn-brad/2088/5">bradrn (Brad)</a></div>
<blockquote>
<p>why do <strong><code>quote</code></strong> and <strong><code>unquote</code></strong> exist when <strong><code>lift</code></strong> and <strong><code>unlift</code></strong> can do the same thing, while handling more cases?</p>
</blockquote>
</aside>
<p>Sanity check.</p>
</blockquote>
</aside>
<p>COMPOSE has a great feature of being able to add quotes to the slot, by grafting the quotes that are on the slot onto the synthesized result.  It adds onto existing quotes:</p>
<pre><code>&gt;&gt; compose [field1: '(first [a]) field2: '(first [''b])]
== [field1: 'a field2: '''b]
</code></pre>
<p>You can also compose quasi-states, but only on things where it would be legal:</p>
<pre><code>&gt;&gt; compose [field1: ~(first [a])~]  ; Note: making ~''b~ would be illegal
== [field1: ~a~]
</code></pre>
<p>But as it happens, what you want a <em>LOT</em> of the time is to create either quoted states from non-antiforms, or quasi states from antiforms.</p>
<p>If quoted slots were willing to do that, it would look like:</p>
<pre><code>&gt;&gt; compose [field1: '(first [a]) field2: '(null)]
== [field1: 'a field2: ~null~]
</code></pre>
<p><strong>I've struggled with the question of whether or not to be willing to do this, instead of erroring.</strong></p>
<p>If it were to be done, it would <em>certainly</em> have to only do it to antiforms after they decayed.  We don't want it to be composing in quasi-errors instead of reporting them.  PACK!s shouldn't be composing as packs, but as the decayed values.</p>
<p><strong>But how bad is it if we are willing to quasify stable, decayed, antiforms?</strong></p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>I <em>KNOW</em> this would be very useful.</p>
<p>We'd still be getting errors on trying to compose in NULLs to slots on regular compose, and it's only when you used this feature that it would be suppressed.</p>
<p>Having it be a refinement, like <strong><code>compose:relax</code></strong>... e.g. relax in the sense that you don't error on nulls when you don't absolutely have to, feels awkward.</p>
<h2><a name="p-8271-i-think-i-like-reverse-biasing-the-safety-1" class="anchor" href="https://rebol.metaeducation.com#p-8271-i-think-i-like-reverse-biasing-the-safety-1"></a>I Think I Like Reverse-Biasing The Safety</h2>
<p>I guess the way I'd put it is: if you think the safety is important, don't put the quotes on the outside of the group.  Put it inside:</p>
<pre><code>&gt;&gt; compose [field1: (quote first [a]) field2: (quote expression-maybe-null)]
** Error: that expression turned out to be null
</code></pre>
<p>Quotes on the outside then becomes a power-user feature, and it does what a power user wants:</p>
<pre><code>&gt;&gt; compose [field1: '(first [a]) field2: '(expression-maybe-null)]
== [field1: 'a field2: ~null~]
</code></pre>
<p>Yup.  I think I like that.  Put your quoting inside if you want the null protection, makes sense.</p>
<h2><a name="p-8271-what-about-composing-void-in-quoted-slots-2" class="anchor" href="https://rebol.metaeducation.com#p-8271-what-about-composing-void-in-quoted-slots-2"></a>What About Composing VOID In Quoted Slots?</h2>
<p>VOID is a PACK!, but it's an undecayable one, so it has special handling nearly everywhere.</p>
<p>Actually this clears up a loose end:</p>
<pre><code>&gt;&gt; compose [''(void)]
== ['~[]~]
</code></pre>
<p>Today you get a sort of outlier error there, telling you that void can't vaporize, because <strong><code>['']</code></strong> isn't legal.  I like the idea that there's a behavior/answer.</p>
          <p><a href="https://rebol.metaeducation.com/t/why-quote-unquote-if-lift-unlift-are-a-superset/2450/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/why-quote-unquote-if-lift-unlift-are-a-superset/2450/2</link>
        <pubDate>Tue, 13 May 2025 12:52:02 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2450-2</guid>
        <source url="https://rebol.metaeducation.com/t/why-quote-unquote-if-lift-unlift-are-a-superset/2450.rss">Why quote/unquote if lift/unlift are a superset?</source>
      </item>
      <item>
        <title>Why quote/unquote if lift/unlift are a superset?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="bradrn" data-post="5" data-topic="2088">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/bradrn-brad/2088/5">bradrn (Brad)</a></div>
<blockquote>
<p>why do <strong><code>quote</code></strong> and <strong><code>unquote</code></strong> exist when <strong><code>lift</code></strong> and <strong><code>unlift</code></strong> can do the same thing, while handling more cases?</p>
</blockquote>
</aside>
<p>Sanity check.</p>
<p>Antiforms are weird, and creating them (or tolerating them) when you didn't mean to is good to avoid.</p>
<p>Unstable antiforms are particularly weird...for instance antiform BLOCK! cannot be stored in variables.  In normal assignments it decays to its first element, while multi-assignments and other particular constructs interpret it as multiple values:</p>
<pre><code>&gt;&gt; quasiform: '~['1020 ~null~]~
== ~['1020 ~null~]~

&gt;&gt; x: unlift quasiform
== 1020

&gt;&gt; [x y]: unlift quasiform
== 1020

&gt;&gt; y
== \~null~\  ; antiform
</code></pre>
<p>This is how multi-return functions are implemented.</p>
<p>What's nice about UNQUOTE vs UNLIFT is that if you are really not suspecting you're dealing with a quasiform that should become an antiform, you can avoid the potential confusion caused.</p>
<p>And QUOTE has a similar convenience of not tolerating an antiform when you didn't think there'd be one.</p>
<p>A narrower operator of QUASI and UNQUASI exists to make it clear when you're only adding or removing a quasi state.  So you can QUASI only plain non-quoted things, and UNQUASI only non-quoted quasiforms.  Then NOQUASI will pass through all values except drop the quasi from quasiforms.</p>
<p>Just helps readers get their bearings on what's going on if that's all that's happening.</p>
          <p><a href="https://rebol.metaeducation.com/t/why-quote-unquote-if-lift-unlift-are-a-superset/2450/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/why-quote-unquote-if-lift-unlift-are-a-superset/2450/1</link>
        <pubDate>Fri, 05 Jan 2024 05:33:33 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2450-1</guid>
        <source url="https://rebol.metaeducation.com/t/why-quote-unquote-if-lift-unlift-are-a-superset/2450.rss">Why quote/unquote if lift/unlift are a superset?</source>
      </item>
  </channel>
</rss>

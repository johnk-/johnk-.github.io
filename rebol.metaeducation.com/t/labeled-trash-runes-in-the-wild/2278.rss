<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Labeled TRASH! Runes in The Wild</title>
    <link>https://rebol.metaeducation.com/t/labeled-trash-runes-in-the-wild/2278</link>
    <description>If you access an unset variable, you don&#39;t get a lot of information back:

    &gt;&gt; state: ~

    &gt;&gt; state
    ** Script Error: state is ~ antiform

That `~` is the quasiform/antiform of the space RUNE!:

    &gt;&gt; quasi _
    == ~

    &gt;&gt; type of anti _
    == ~{trash!}~  ; antiform (datatype)

**But you&#39;re not just limited to the space RUNE! to make &quot;unset&quot; variables... because you can use *any* RUNE!.**

    &gt;&gt; state: ~#[INITIALIZE-STATE not called yet]#~

    &gt;&gt; state
    ** Script Error: state is trash: ~#[INITIALIZE-STATE not called yet]#~

*(This concept was originally called a &quot;tripwire&quot; when labeled trash was a distinct datatype from trash.  But now that the **`_`** is just the rune! for space, it unifies to where all antiform runes are just called TRASH!)*

DEFAULT reacts to labeled trash like anything else, considering the variable to be &quot;vacant&quot;

    &gt;&gt; vacant? $state
    == ~okay~  ; anti

    &gt;&gt; state: default [10 + 20]
    == 30

    &gt;&gt; state
    == 30

## Can Be Better Than A Meandering Comment!

A comment won&#39;t direct people to the relevant issue at runtime.  But a well-chosen labeled trash can.

Compare:

    ; !!! UPARSE is not available in SYS because it is higher level.  We hack it
    ; up so that when %uparse.r runs it pokes itself into sys.util/parse
    ;
    parse: ~

With:

    parse: ~#[higher-level %uparse.r hasn&#39;t set SYS.UTIL/PARSE yet]#~

Much better!  Gives you the information you need, when you need it!

*(Note: I was inspired to this concept by a style of usage @rgchris had in his scripts, using TAG!s to provide guidance for what was supposed to be filled into certain slots.  I just wanted to give that some teeth, to know that the variable was conceptually unset.)*</description>
    
    <lastBuildDate>Mon, 19 May 2025 13:56:01 +0000</lastBuildDate>
    <category>Feature Discover</category>
    <atom:link href="https://rebol.metaeducation.com/t/labeled-trash-runes-in-the-wild/2278.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Labeled TRASH! Runes in The Wild</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="3" data-topic="2278">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>Labeled trash Catches Bugs Failing Functions Won't</strong></p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">return: func [] [
    fail:blame "RETURN called when no generator is providing it" $return
]
</code></pre>
<p>vs.</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">return: ~#"RETURN used when no function generator is providing it"~
</code></pre>
</blockquote>
</aside>
<p>I've already shown that trashes are better for error locality than stub failure functions, because you get an error when you try to fetch a function e.g. via <strong><code>return/</code></strong> ... vs. getting a function that's just going to fail later.</p>
<p>But there's another benefit over the stub function: <em>it gives you the right error even if you don't have a refinement, vs. saying "no refinement available"</em></p>
<p>I noticed this when I had a function for adding things to the built-in SymId table during bootstrap:</p>
<pre><code>add-sym: func [
    "Add SYM_XXX to enumeration"
    return: "position of an already existing symbol if found"
        [null? block!]
    text [word! text!]
    :relax "tolerate an already-added symbol"
][
    ...
]
</code></pre>
<p>After the table is finalized and written to disk, you don't want more stray calls to ADD-SYM.  It's bootstrap so there's no labeled trash, so I just did the old crappy stub function trick:</p>
<pre><code>add-sym: does [
   fail "Symbol table finalized, can't ADD-SYM at this point"
]
</code></pre>
<p><em>But what if you called ADD-SYM:RELAX ?</em>  If you use a refinement, you don't get the informative message, you get a message about it not having the refinement:</p>
<pre><code>** Script Error: incompatible or duplicate refinement: :relax
</code></pre>
<p>So even though your stub function doesn't require any arguments, it has to copy all the refinements as well, or you don't get a good error!</p>
<p>With labeled trash, it would be all good:</p>
<pre><code>add-sym: ~#[Symbol table finalized, can't ADD-SYM at this point]#~
</code></pre>
<h2><a name="p-8037-just-another-big-w-for-trash-runes-trophy-1" class="anchor" href="https://rebol.metaeducation.com#p-8037-just-another-big-w-for-trash-runes-trophy-1"></a>Just Another Big W For TRASH! Runes <img src="https://rebol.metaeducation.com/images/emoji/twitter/trophy.png?v=14" title=":trophy:" class="emoji" alt=":trophy:" loading="lazy" width="20" height="20"></h2>
<p>They're kind of the sleeper hit of the isotope world...</p>
          <p><a href="https://rebol.metaeducation.com/t/labeled-trash-runes-in-the-wild/2278/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/labeled-trash-runes-in-the-wild/2278/4</link>
        <pubDate>Mon, 17 Mar 2025 21:11:17 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2278-4</guid>
        <source url="https://rebol.metaeducation.com/t/labeled-trash-runes-in-the-wild/2278.rss">Labeled TRASH! Runes in The Wild</source>
      </item>
      <item>
        <title>Labeled TRASH! Runes in The Wild</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <h2><a name="p-7883-labeled-trash-catches-bugs-failing-functions-wont-1" class="anchor" href="https://rebol.metaeducation.com#p-7883-labeled-trash-catches-bugs-failing-functions-wont-1"></a>Labeled Trash Catches Bugs Failing Functions Won't</h2>
<p>Prior to the existence of labeled TRASH!, there were some functions in LIB for things like RETURN, CONTINUE, THROW, etc. to give you messages when you tried to use these definitional constructs in places that didn't provide them:</p>
<pre><code>return: func [] [
    fail:blame "RETURN called when no generator is providing it" $return
]

continue: func [] [
    fail:blame "CONTINUE called when no loop is providing it" $return
]

throw: func [] [
    fail:blame "THROW called when no catch is providing it" $return
]

...
</code></pre>
<p>Passing the <code>$return</code> bound word as the <code>:BLAME</code> argument is a bit awkward to write.  But it means the error will blame the callsite, showing the error there--instead of implicating the FAIL itself inside the stub function.  That makes the error much more useful.</p>
<p><strong>But this still makes it look like the functions are available.</strong>  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>You won't get an error if you say <strong><code>return/</code></strong> to try and get a RETURN function.  You'll get a function--and it will pass the rule that things ending in slash must look up to functions--but it's not the kind of RETURN function you actually wanted.</p>
<p>This led to confusing downstream bugs when some code wasn't binding correctly, but proceeded merrily along as if it had gotten a RETURN function.</p>
<p><strong>Labeled trash makes it nice and tidy!</strong></p>
<pre><code>return: ~#[RETURN used when no function generator is providing it]#~

continue: ~#[CONTINUE used when no loop is providing it]#~

throw: ~#[THROW used when no catch is providing it]#~

...
</code></pre>
<p>You get the "blame" of the callsite for free, because trashes aren't function instantiations.</p>
<p>And if you say <strong><code>return/</code></strong> then that's an error, because it's not a function.</p>
<p><em>This is quite an improvement!</em></p>
          <p><a href="https://rebol.metaeducation.com/t/labeled-trash-runes-in-the-wild/2278/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/labeled-trash-runes-in-the-wild/2278/3</link>
        <pubDate>Sun, 10 Nov 2024 13:44:52 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2278-3</guid>
        <source url="https://rebol.metaeducation.com/t/labeled-trash-runes-in-the-wild/2278.rss">Labeled TRASH! Runes in The Wild</source>
      </item>
      <item>
        <title>Labeled TRASH! Runes in The Wild</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>If you access an unset variable, you don't get a lot of information back:</p>
<pre><code>&gt;&gt; state: ~

&gt;&gt; state
** Script Error: state is ~ antiform
</code></pre>
<p>That <code>~</code> is the quasiform/antiform of the space RUNE!:</p>
<pre><code>&gt;&gt; quasi _
== ~

&gt;&gt; type of anti _
== ~{trash!}~  ; antiform (datatype)
</code></pre>
<p><strong>But you're not just limited to the space RUNE! to make "unset" variables... because you can use <em>any</em> RUNE!.</strong></p>
<pre><code>&gt;&gt; state: ~#[INITIALIZE-STATE not called yet]#~

&gt;&gt; state
** Script Error: state is trash: ~#[INITIALIZE-STATE not called yet]#~
</code></pre>
<p><em>(This concept was originally called a "tripwire" when labeled trash was a distinct datatype from trash.  But now that the <strong><code>_</code></strong> is just the rune! for space, it unifies to where all antiform runes are just called TRASH!)</em></p>
<p>DEFAULT reacts to labeled trash like anything else, considering the variable to be "vacant"</p>
<pre><code>&gt;&gt; vacant? $state
== ~okay~  ; anti

&gt;&gt; state: default [10 + 20]
== 30

&gt;&gt; state
== 30
</code></pre>
<h2><a name="p-7676-can-be-better-than-a-meandering-comment-1" class="anchor" href="https://rebol.metaeducation.com#p-7676-can-be-better-than-a-meandering-comment-1"></a>Can Be Better Than A Meandering Comment!</h2>
<p>A comment won't direct people to the relevant issue at runtime.  But a well-chosen labeled trash can.</p>
<p>Compare:</p>
<pre><code>; !!! UPARSE is not available in SYS because it is higher level.  We hack it
; up so that when %uparse.r runs it pokes itself into sys.util/parse
;
parse: ~
</code></pre>
<p>With:</p>
<pre><code>parse: ~#[higher-level %uparse.r hasn't set SYS.UTIL/PARSE yet]#~
</code></pre>
<p>Much better!  Gives you the information you need, when you need it!</p>
<p><em>(Note: I was inspired to this concept by a style of usage <a class="mention" href="https://rebol.metaeducation.com/u/rgchris">@rgchris</a> had in his scripts, using TAG!s to provide guidance for what was supposed to be filled into certain slots.  I just wanted to give that some teeth, to know that the variable was conceptually unset.)</em></p>
          <p><a href="https://rebol.metaeducation.com/t/labeled-trash-runes-in-the-wild/2278/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/labeled-trash-runes-in-the-wild/2278/1</link>
        <pubDate>Sun, 15 Sep 2024 07:46:39 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2278-1</guid>
        <source url="https://rebol.metaeducation.com/t/labeled-trash-runes-in-the-wild/2278.rss">Labeled TRASH! Runes in The Wild</source>
      </item>
  </channel>
</rss>

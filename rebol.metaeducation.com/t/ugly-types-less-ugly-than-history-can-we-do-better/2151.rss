<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
    <link>https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151</link>
    <description>## The Limited and Ambiguous Historical Idea

People are used to being able to do things like:

     x: 10
     switch type? x [
         integer! [print &quot;It&#39;s an integer&quot;]
         block! [print &quot;It&#39;s a block&quot;]
     ]

     assert [parse [1 [second] &#39;foo] [integer! block! lit-word!]]

     assert [find any-word! (type? first [x:])]

But the historical DATATYPE! and TYPESET! were strange.

* DATATYPE! rendered as a WORD! but was really wrapping an integer of 0-63

* TYPESET! was a 64-bit bitset, one bit for each type (this is where the 64 types limit came from)

    * it lost its meaning in rendering (it kept no record of what the set actually was...just dumped words for each bit)

    * not preserving the name from a fixed list of typesets was based on the concept you could make your own or UNION/INTERSECT them

So it looked like this:

    red&gt;&gt; type? 1
    == integer!

    red&gt;&gt; type? type? 1
    == datatype!

    red&gt;&gt; print mold any-word!
    make typeset! [word! set-word! lit-word! get-word!]

    red&gt;&gt; print mold any-type!
    make typeset! [datatype! unset! none! logic! block! paren! string! file! url!
        char! integer! float! word! set word! lit-word! get-word! refinement! issue!
        native! action! op! function! path! lit-path! set-path! get-path! routine!
        bitset! object! typeset! error! vector! hash! pair! percent! tuple! map!
        binary! time! tag! email! handle! date! port! money! ref! point2D! point3D!
        image! event!]

## The TYPE-XXX! Approach

So Ren-C attacked the ambiguity and extensibility with a new word type, TYPE-WORD!.  Then typesets used TYPE-GROUP! and TYPE-BLOCK!, referencing functions to act as type testing predicates, and using groups for intersections and blocks for unions:

    &gt;&gt; type of 1
    == &amp;integer

    &gt;&gt; type of type of 1
    == &amp;type-word

    &gt;&gt; print mold any-word!
    &amp;(any-word?)

    &gt;&gt; print mold any-value!
    &amp;(any-value?)

This gives some realistic axis of extensibility, and gives distinguishable entities that can trigger behaviors in PARSE when something looks up to type-xxx!.  (this shows why using WORD! or URL! or ISSUE! wouldn&#39;t work, because the type intent has to be carried by what e.g. INTEGER! looks up to.)

**Calling functions to implement type checks vs. checks on a bitset, especially when an array of functions must be called when checking every parameter in every function call, is a difficult performance point.**

[Intrinsics and other magic are employed to rein it in.](https://rebol.metaeducation.com/t/intrinsics-functions-without-frames/2050)  It&#39;s not particularly simple...but finding ways to speed up function calls where you can has systemic benefit.

## New Consequence: FIND Must Find TYPE-WORD! Normally

Being a legitimate datatype that can be stored in a block, some interpretations of datatype by functions like FIND were problematic:

    red&gt;&gt; block: reduce [&quot;hello&quot; integer! 1]
    == [&quot;hello&quot; integer! 1]

    red&gt;&gt; find block &#39;integer!
    == none  ; rendering was a lie

    red&gt;&gt; find block integer!
    == [1]

You couldn&#39;t find a literal datatype in a block.  Ren-C is approaching this by saying FIND has to find the TYPE-WORD! (as it does for all non-antiforms), but that you can use antiform actions as predicates.

    &gt;&gt; block: reduce [&quot;hello&quot; integer! 1]
    == [&quot;hello&quot; &amp;integer 1]

    &gt;&gt; find block integer!
    == [&amp;integer 1]

    &gt;&gt; find block :integer?
    == [1]

There was some thought that maybe you could create antiform TYPE-XXX! and call them &quot;matchers&quot;, passing them to FIND.

* But this is an isotope for each TYPE-XXX!, so it&#39;s not even like there would be one &quot;matcher&quot;

* It also would be the only instance of antiforms of types with sigils, which doubles the sigil to make **`~&amp;integer~`**, which I find kind of displeasing

I feel that antiform actions cover it for FIND, and if you have higher level needs you should use something like PARSE which has richer options and isn&#39;t beholden to quite the &quot;mechanical&quot; answer that a series primitive like FIND has to abide by with its limited parameterization.

## New Annoyance: TYPE OF Quotes And Antiforms

When there were only two datatypes with quotedness, the quote was part of their datatype:

    red&gt;&gt; type? first [&#39;a]
    == lit-word!

    red&gt;&gt; type? first [&#39;a/b]
    == lit-path!

    red&gt;&gt; lit-word! = type? first [&#39;a]
    == true

    red&gt;&gt; parse [&#39;a &#39;a/b] [lit-word! lit-path!]
    == true

Ren-C&#39;s approach affords the ability make type constraints to carry forward the PARSE behavior.  But the TYPE OF all quoteds is the same... &amp;QUOTED.

    &gt;&gt; lit-word?!
    == &amp;(lit-word?)

    &gt;&gt; lit-word?! = type of first [&#39;a]
    == ~false~  ; anti

    &gt;&gt; type of first [&#39;a]
    == &amp;quoted

So perhaps you see the motivation to decorate as **?!** instead of just **!** for the type constraints.  People need to know that these aren&#39;t fundamental types.  You have to use e.g. MATCH with them:

     &gt;&gt; match lit-word?! first [&#39;a]
     == &#39;a

     &gt;&gt; match lit-word?! 10
     == ~null~  ; anti

     &gt;&gt; match [lit-word?] first [&#39;a]  ; alternative as 1st slot known &quot;typelike&quot;
     == &#39;a

This is something of a pain point, and I&#39;m not entirely settled on whether it would be good to delve into some kind of ambiguity where we are actually allowed to get back constraint functions as the answer to TYPE OF, and make that the fundamental:

    &gt;&gt; type of 1
    == &amp;integer?

    &gt;&gt; type of spread [a b]
    == &amp;splice?

    &gt;&gt; type of ~true~
    == &amp;logic?

    &gt;&gt; type of first [&#39;a]
    == &amp;quoted? 

So I don&#39;t think this is a good idea for the quoted types, but for the antiforms it might be a narrow enough thing that it provides &quot;what the people want&quot;.

    &gt;&gt; switch type of true [
         splice! [...]
         logic! [...]
         integer! [...]
      ]

Barring that, what we have to do today is flip SWITCH over into a MATCH mode (currently called SWITCH/TYPE but should probably be SWITCH/MATCH... or maybe it should take the MATCH name):

    &gt;&gt; switch/type true [
         splice?! [...]
         logic?! [...]
         integer! [...]
      ]

Note that the `?!` distinction is a new idea which hasn&#39;t made it to all type constraints yet, e.g. ANY-VALUE! is still as it was.  But because parameters use what is effectively a TYPE-BLOCK! you can say **`any-value?`** or **`splice?`** in them instead of going through the extra step.

## Should TYPE Be A Bigger Concept?

One thing that has nagged me is if when we ask for the fundamental &quot;cell type&quot; of something, if we should avoid using the word &quot;TYPE&quot; for that at all...

Maybe there&#39;s some bigger idea in an object/class system where TYPE is meaningful to say something more than &quot;this is an object&quot; but rather &quot;this is a book&quot;, where you can ask also &quot;is a book readable&quot;.  Etc.

Or maybe TYPE can be parameterized:

     &gt;&gt; type of matrix
     == &amp;[matrix 10x10]

So this would mean there&#39;s a smaller question about the fundamental type, maybe call it &quot;KIND&quot;:

    &gt;&gt; kind of [a b c]
    == &amp;block

    &gt;&gt; kind of matrix
    == &amp;object

It would be nice to just be able to say &quot;64 types is enough for anyone&quot; and say &quot;there, it&#39;s done&quot;.  I&#39;d be happy to do that if I felt that it was enough.  It wasn&#39;t, even when thinking along fairly limited lines that don&#39;t go in these fancier directions.

*I don&#39;t think any near-term system will actualize on bigger visions of what TYPE might be, but it would help to know if that should be ruled out or not, just in order to pick the term KIND or TYPE!*  But even that question is murky.

## Some Related Reading: %types.r

The dialected table used to construct the type testing macros and other things is kind of neat, though some comments are out of date and parts of it need updating (it&#39;s getting upgraded in an upcoming commit which finally breaks the 64-type barrier and introduces the $ types):

See [**%types.r**](https://github.com/metaeducation/ren-c/blob/master/src/boot/types.r)</description>
    
    <lastBuildDate>Sun, 25 Feb 2024 12:53:56 +0000</lastBuildDate>
    <category>Datatypes</category>
    <atom:link href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>A post was split to a new topic: <a href="https://rebol.metaeducation.com/t/raku-perl-6-type-system/2156">Raku (Perl 6) Type System</a></p>
          <p><a href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/20">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/20</link>
        <pubDate>Sun, 25 Feb 2024 20:31:17 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2151-20</guid>
        <source url="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="18" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But given the choice, people would prefer <strong>switch type of</strong> and being able to think of type as being a value instead of a constraint. And with the TYPE-BLOCK! answer, there's some inkling of a direction of going that way:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">switch type of x [
    logic! [...]  ; wouldn't be locked in a 1:1 heart:type ratio
    integer! [...]
    splice! [...]
]
</code></pre>
</blockquote>
</aside>
<p>In a way, I think this just goes to prove my point. Yet again, we see the most common thing to do with types is to <em>match</em> against them. And, in your words, when we’re matching types it’s nice if we’re not ‘locked in a 1:1 heart:type ratio’. To me, that again implies that it should be able to take constraints, like SWITCH/TYPE does… and you can’t do that simply by SWITCHing against TYPE OF.</p>
<p>I suppose the point I’m making is that TYPE OF is limited in a very fundamental sense: it can <strong>only ever return one value</strong>. Perhaps you can try to predict ahead of time what people will want to test, and add things like LOGIC! that to the output of TYPE OF… but then comes someone who wants to test if a number is EVEN?, and TYPE OF just doesn’t give you that information. That’s why I think it’s a good idea to keep TYPE OF a direct reflection of the heart-byte, and use other constructions for code which needs other things.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="18" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>With more complex types, you'd have to use <a href="https://rebol.metaeducation.com/t/destructure-dialect/1877">something like DESTRUCTURE</a> to get at what you were looking for. And maybe that would be interesting.</p>
</blockquote>
</aside>
<p>I’ll put my support strongly behind this. Pattern-matching is inordinately useful.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="18" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'm quite glad that you're thinking about it, and that you are able to take initiative and grok these problems well.</p>
</blockquote>
</aside>
<p>This is really where my expertise lies. I’m a Haskeller — I spend a long time thinking about types and type systems. Additionally, over the past year or two I’ve been learning a lot about structural type systems (i.e. ones which allow union and intersection), including making my own. So when I say things like ‘a Haskell-like type system isn’t a great fit for Rebol’, there’s some intuition behind those statements.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="18" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'm pleased and terrified that you're reading the source, but... there are some files that have decent organizations and comments to them, which can give you your bearings faster than reading something like a R3-Alpha or a Red.</p>
</blockquote>
</aside>
<p>Sure, but I just wanted to get some statistics quickly, and Ren-C itself is the largest Ren-C codebase that I know of. (Also, sometimes I get curious how things are implemented internally.)</p>
          <p><a href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/19">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/19</link>
        <pubDate>Fri, 23 Feb 2024 00:19:55 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2151-19</guid>
        <source url="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="17" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>(Apologies, this post has ended up somewhat long and rambly. TL;DR: we should think much more carefully about how useful TYPE OF really is in practice.)</p>
</blockquote>
</aside>
<p>Nothing's too long for me to read here!  <img src="https://rebol.metaeducation.com/images/emoji/twitter/slight_smile.png?v=14" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<p>Feel free to write long things and edit them down later for clarity, or if you just decide parts of it were distractions and aren't relevant anymore (and it doesn't break the continuity of the thread).</p>
<aside class="quote no-group" data-username="bradrn" data-post="17" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>At least to me, this suggests that <strong>TYPE OF is of significantly limited use in actual code</strong></p>
</blockquote>
</aside>
<p>The reason for that is that most uses of TYPE OF had been SWITCH TYPE OF.  Many of those would no longer work, because e.g. TYPE OF TRUE was an antiform and not LOGIC!, etc.</p>
<p>So all the <strong>switch type of</strong> instances (except for two, apparently) were robotically changed to <strong>switch/type</strong> where the values you're switching on are constraints (or types).</p>
<pre><code>switch/type x [
    &amp;logic? [...]
    integer! [...]
    &amp;splice? [...]
]
</code></pre>
<p>But given the choice, people would prefer <strong>switch type of</strong> and being able to think of type as being a value instead of a constraint.  And with the TYPE-BLOCK! answer, there's some inkling of a direction of going that way:</p>
<pre><code>switch type of x [
    logic! [...]  ; wouldn't be locked in a 1:1 heart:type ratio
    integer! [...]
    splice! [...]
]
</code></pre>
<p>With more complex types, you'd have to use <a href="https://rebol.metaeducation.com/t/destructure-dialect/1877">something like DESTRUCTURE</a> to get at what you were looking for.  And maybe that would be interesting.  But of course that's a lot of hand-waving right now.</p>
<aside class="quote no-group" data-username="bradrn" data-post="17" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I take this as a sign that we shouldn’t waste our time thinking up elaborate schemes to encode information in its return value… rather, we should just make it as simple as possible.</p>
</blockquote>
</aside>
<p>In the end, a good "realistic" choice might well need to be about coming to terms with something kind of simple.  That may just be how it is.</p>
<p>64 types wasn't going to cut it for me, so I had to break that barrier for starters.</p>
<p>Now that the barrier is broken, it's a good time to let it simmer a bit.  It's not going to resolve overnight--but I'm quite glad that you're thinking about it, and that you are able to take initiative and grok these problems well.</p>
<p>On the plus side, there's a lot of other fun things to work on right now while this sorts out...empowered by the new types (and some other realizations that are falling into place)...</p>
<aside class="quote no-group" data-username="bradrn" data-post="17" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>As a first step towards answering it, I did a quick search of the Ren-C source code. As far as I can see, it’s not used very It looks often.</p>
</blockquote>
</aside>
<p>I'm pleased and terrified that you're reading the source, but... there are some files that have decent organizations and comments to them, which can give you your bearings faster than reading something like a R3-Alpha or a Red.</p>
<p>This is motivating me to start pushing through some changes that had been on the back burner for a while, e.g. the death of REBVAL:</p>
<p><a href="https://github.com/metaeducation/ren-c/commit/71459d6dc03ca9b0aea5e97ff76c57b0a2405249" class="inline-onebox">REBVAL =&gt; Value renaming · metaeducation/ren-c@71459d6 · GitHub</a></p>
<p>If you do have questions about things you see, feel free to ask them (or send PRs of things that are clearly just wrong or outdated).</p>
          <p><a href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/18">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/18</link>
        <pubDate>Thu, 22 Feb 2024 14:01:30 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2151-18</guid>
        <source url="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <p>(Apologies, this post has ended up somewhat long and rambly. TL;DR: we should think much more carefully about how useful TYPE OF really is in practice.)</p>
<p>In trying to sort out my thoughts on this topic, I’ve come to think that the key question we should be asking is: <em>precisely what do we want to use types for?</em></p>
<p>Starting with the most basic things, one very important use is within the interpreter itself. This is the HEART_BYTE, which (as I understand it) defines how to interpret the bytes making up a Rebol value. (Previously <a class="mention" href="https://rebol.metaeducation.com/u/hostilefork">@hostilefork</a> has called this the ‘kind’.) Obviously, this is vital to making the interpreter work. It’s also fairly limited, albeit less now than it used to be.</p>
<p>A second usecase is if you have some arbitrary value and want to find out what you can do with it — what Rebol calls TYPE OF. In most dynamically-typed programming languages, including historical Rebol, this gives you back the internal interpreter type… but there’s no reason it couldn’t yield something more generic, as we’ve been discussing.</p>
<p>A third usecase is if you want to match a value against some criterion. Rebol highlights this quite prominently: in average Rebol code, types are used most frequently to establish preconditions for function arguments. They’re used similarly <a href="https://rebol.metaeducation.com/t/what-is-the-use-of-typesets/2153/2">in PARSE</a>, amongst other places.</p>
<p>(In other languages, the most prominent use of types is to enable static analysis during compilation. This is an <em>extremely</em> useful capability, and in many modern languages, the type system is explicitly designed to make it tractable to check as many properties as possible before the program is run. But Ren-C isn’t compiled, and Rebol more broadly isn’t hugely amenable to static analysis anyway, so this isn’t a concern for us at all.)</p>
<p>Most dynamically-typed languages cover all three of these usecases with a single notion. Each value is stored alongside some type descriptor, which is returned when the programmer asks for <code>typeof(value)</code> (or whatever it might be). Then, you can check that against another type using an ordinary <code>if</code> expressions, same as checking any other condition.</p>
<p>Historical Rebol took much the same approach. It has a fairly unorthodox implementation of supertyping (using typesets), but otherwise, there’s one notion of ‘type’ which covers all usecases. The main wrinkle is that dialects can use special syntax for matching against types, most notably in function parameters.</p>
<p>Ren-C has already diverged from this approach, by recognising that ‘things you can match against’ is a broader category than ‘things the interpreter needs to know about’. Thus, it’s gradually extended the language to accept functions (a.k.a. ‘type constraints’) in places where it previously only accepted types. We’re now at a point where all type-like things, aside from the primitive ‘kinds’, are consistently represented as functions. <strong>And I think we’ve agreed that this is a good idea.</strong> By separating ‘types the interpreter knows about’ from ‘types we match against’, we free up the interpreter to support a lot more basic types, while giving function definitions a greater ability to express arbitrary preconditions.</p>
<p>But of course, that doesn’t cover all the places types pop up in Rebol. They also appear as the return value of TYPE OF… which, I think, is where our disagreement lies. I’ve been leaning towards unifying it with that idea of ‘types we match against’, meaning that users only have to deal with a single notion of ‘type constraint’. On the other hand, you want to make it a more structured system, focussed around those primitive types known by the interpreter.</p>
<p>However, thinking along these lines has led me to pose a slightly different question: <strong>how does TYPE OF get used in practise?</strong> I think the answer to this question should significantly influence what we choose it to return.</p>
<p>As a first step towards answering it, I did a quick search of the Ren-C source code. As far as I can see, it’s not used very It looks often. Indeed, I can only find three occurrences:</p>
<ul>
<li>Two in UPARSE, where it’s used in <code>type-block! combinator</code> to test a value against a type in an <code>if</code> expression. In my opinion, this should really be replaced with MATCH, allowing it to deal with filter actions as well.</li>
<li>One in <code>test/datatypes/varargs.test.reb</code>, where it’s again used to match a value against a type, albeit in a significantly more convoluted way which I don’t understand.</li>
</ul>
<p>(For comparison, when I search for MATCH, I count &gt;40 occurrences in the mezzanine alone.)</p>
<p>At least to me, this suggests that <strong>TYPE OF is of significantly limited use in actual code</strong>. I take this as a sign that we shouldn’t waste our time thinking up elaborate schemes to encode information in its return value… rather, we should just make it as simple as possible.</p>
<p>Along those lines, maybe TYPE-BLOCK! isn’t such a good choice for its return type after all, and it should be returning a single TYPE-WORD!. On the other hand, that doesn’t work so well with my conviction that we should only have one variety of TYPE-*. I feel sure that there’s some better design waiting to be discovered for this.</p>
          <p><a href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/17">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/17</link>
        <pubDate>Wed, 21 Feb 2024 12:59:41 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2151-17</guid>
        <source url="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="14" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I don't know if it's a good thought or not, but the narrowing could come from the idea that antform is an arity-2 parameterized type... which adds the subtype if applicable:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; type of spread [a b c]
== &amp;[antiform &amp;[group] #splice]

&gt;&gt; type of true
== &amp;[antiform &amp;[word] #logic]
</code></pre>
</blockquote>
</aside>
<p>This feels quite redundant to me. A group antiform is <em>always</em> a splice. A word antiform is… OK, sometimes it’s a logic, sometimes it’s something else, but I don’t think TYPE OF is the right tool to be testing value-level properties like that.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="15" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'm not sure how you'd elaborate objects to get something knowingly distinct.</p>
</blockquote>
</aside>
<p>Do we even have to? Plenty of languages (most notably JavaScript and Lua) use prototype-based objects which are not distinguished at runtime. I see no problem with Rebol taking the same approach.</p>
          <p><a href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/16">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/16</link>
        <pubDate>Sun, 18 Feb 2024 01:49:03 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2151-16</guid>
        <source url="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="7" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>it’s worth noting that ‘kind’ already has <a href="https://en.wikipedia.org/wiki/Kind_(type_theory)">a well-established meaning</a> in type theory. (Specifically, it’s the type of a type.) So it’s probably a good idea to choose some other word.</p>
</blockquote>
</aside>
<aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>The elements of these series could simply be ordinary words, left unevaluated and unbound: one could test <code>'isotope = first type of spread [a b c]</code>, and so on.</p>
</blockquote>
</aside>
<p>Ok... well maybe I guess that if you want to test the "kind" then maybe the whole thing should be set up so that really is the <strong>first type of</strong> whatever you have.</p>
<p>It feels a bit strange to say that the <strong>type of</strong> whatever object subclasses wind up becoming starts with object... but... well, I guess it makes sense.</p>
<p>Then OBJECT! could mean "just a plain object with no further elaboration".</p>
<pre><code>&gt;&gt; object!
== &amp;[object]
</code></pre>
<p>So if you SWITCH TYPE OF and check against OBJECT! then you wouldn't match against fancier things than the base untyped object.  You'd have to SWITCH FIRST TYPE OF, and then you wouldn't be able to use things like SPLICE! or LOGIC! in what you test against because you'd be dealing with words, not types.</p>
<p>I'm not sure how you'd elaborate objects to get something knowingly distinct.  Could go the Java route and use URLs when you create your classes.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<pre><code> &amp;[object http://hostilefork.com/project1/book]

 &amp;[object http://hostilefork.com/project2/animal]
</code></pre>
<p>As these are runtime concepts, maybe making a new object class would get a runtime ID.</p>
<pre><code> &amp;[object @animal.17]

 &amp;[object @book.32302]
</code></pre>
<p>That's less oppressive-seeming.</p>
<pre><code> &gt;&gt; book!: class @book [...]
 == &amp;[object @book.32302]  ; e.g. class creates a type, not an instance

 &gt;&gt; b: make book! [title: "Ren-C (Ab)user's Guide"]
 == ...{@book title: "Ren-C (Ab)user's Guide"}...

 &gt;&gt; type of b
 == &amp;[object @book.32302] 
</code></pre>
<p>Well, it's a thought.</p>
          <p><a href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/15">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/15</link>
        <pubDate>Sat, 17 Feb 2024 09:45:54 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2151-15</guid>
        <source url="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; type of spread [a b c]
== &amp;[antiform group]  ; or &amp;[splice], if e.g. &amp;[logic] narrows &amp;[antiform word]
</code></pre>
</blockquote>
</aside>
<p>I don't know if it's a good thought or not, but the narrowing could come from the idea that antform is an arity-2 parameterized type... which adds the subtype if applicable:</p>
<pre><code>&gt;&gt; type of spread [a b c]
== &amp;[antiform &amp;[group] #splice]

&gt;&gt; type of true
== &amp;[antiform &amp;[word] #logic]
</code></pre>
<p>And then:</p>
<pre><code>&gt;&gt; logic!
== &amp;[antiform &amp;[word] #logic]

&gt;&gt; logic! = type of true
== ~true~  ; anti
</code></pre>
<p>Maybe messy, but a definite improvement over saying you can't get the type of a logic.  :-/</p>
<p>I'm thinking when types appear as parameters to other types, they should be whole (decorations/block), just so it makes more sense to decompose.</p>
<pre><code>&gt;&gt; t: type of first ['1]
== &amp;[quoted &amp;[integer]]

&gt;&gt; all [t.1 = 'quoted, t.2 = integer!] then [print "quoted integer"]
quoted integer
</code></pre>
<p>Maybe.  I guess I'd have to see in practice how it panned out.</p>
<p>Only have vague ideas about how to practically implement this so it isn't dog slow, but it does seem like a positive direction.</p>
          <p><a href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/14">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/14</link>
        <pubDate>Sat, 17 Feb 2024 08:59:05 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2151-14</guid>
        <source url="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="12" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Hmm... I was just reminded that the nature of type predicates is such that they can only check against instances, it can't check for relationships between types described by the predicate.</p>
<p>So if you have a question like <em>"Hey, I have a type T. Is it in the category ANY-WORD?"</em> there's no way to know.</p>
</blockquote>
</aside>
<p>Hmm. Interesting point.</p>
<p>Although it does remind me of one of my suggestions above:</p>
<aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Possibly, these type constraints may need to have their own internal representations, different to that of ordinary Rebol functions.</p>
</blockquote>
</aside>
<p>If that internal representation does something along the lines of storing the set of types directly, it would become easy to test if one predicate is a subset of another.</p>
          <p><a href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/13">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/13</link>
        <pubDate>Sat, 17 Feb 2024 07:04:32 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2151-13</guid>
        <source url="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="9" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>we should focus more heavily on type constraints as the fundamental building blocks for types.</p>
</blockquote>
</aside>
<p>Hmm... I was just reminded that the nature of type predicates is such that they can only check against instances, it can't check for relationships between types described by the predicate.</p>
<p>So if you have a question like <em>"Hey, I have a type T.  Is it in the category ANY-WORD?"</em> there's no way to know.</p>
<p>Things like function specs and PARSE and such always have value instances to operate on, so it's not a problem there.  But it comes up in other code.</p>
<p>Maybe it suggests that functions like ANY-WORD? that can meaningfully be applied to either might need a refinement to help with that:</p>
<pre><code> &gt;&gt; any-word? first [x:]
 == ~true~  ; anti

 &gt;&gt; any-word?/type set-word!
 == ~true~  ; anti
</code></pre>
<p>This would avoid saturating the universe with duplicate functions like ANY-WORD-TYPE?.</p>
<p>It's relatively rare to need to do this, but it comes up sometimes...and it's something typesets could do that we can't do easily at present.</p>
          <p><a href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/12">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/12</link>
        <pubDate>Sat, 17 Feb 2024 07:00:29 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2151-12</guid>
        <source url="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="10" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Note that MATCH returns the value:</p>
</blockquote>
</aside>
<p>Ah, didn’t realise that. But it looks like you understood me anyway.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="10" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>The existence of type blocks doesn't mean type constraints can't exist too. They may just be different parts of the solution.</p>
</blockquote>
</aside>
<p>Possibly… but I prefer to <a href="https://en.wikipedia.org/wiki/Occam's_razor">avoid multiplying entities</a> when possible. (“<em>A designer achieves perfection when there is nothing left to take away</em>”, and all that.) I dislike the idea of two kinds of ‘type-describing things’ if one suffices.</p>
          <p><a href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/11">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/11</link>
        <pubDate>Sat, 17 Feb 2024 06:09:41 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2151-11</guid>
        <source url="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="9" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I especially like the idea of this invariant holding:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; match type of x x
== ~true~ (for all x)
</code></pre>
<p>(Where <code>match</code> specifically takes a type constraint.)</p>
</blockquote>
</aside>
<p>Note that MATCH returns the value:</p>
<pre><code> &gt;&gt; match integer! 1
 == 1

 &gt;&gt; match integer! "abc"
 == ~null~  ; anti
</code></pre>
<p>Other than that (and the exception for null as <strong>match try type of x</strong>, where the result is a "heavy" then-triggering null)...yes, I'd agree with the invariant...</p>
<p>But I don't see a problem with MATCH being willing to take either a TYPE-BLOCK! (in which case it looks for exact equality of the type) or a type constraint (in which case it calls the function)...or to take a BLOCK! (in which case it assumes you want to treat it as you would a function spec block).</p>
<pre><code>&gt;&gt; match [even? text!] 2
== 2

&gt;&gt; match [even? text!] 1
== ~null~  ; anti

&gt;&gt; match [even? text!] "abc"
== "abc"
</code></pre>
<aside class="quote no-group" data-username="bradrn" data-post="9" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Indeed, TYPE-BLOCK!s make type constraints difficult (unions, intersections, etc.). Which is precisely why <a href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/2">my original suggestion</a> was that they might not be a good fit for Rebol, and we should focus more heavily on type constraints as the fundamental building blocks for types.</p>
</blockquote>
</aside>
<p>The existence of type blocks doesn't mean type constraints can't exist too.  They may just be different parts of the solution.</p>
<p>Historical Rebol had DATATYPE! and TYPESET!, and for the datatype purposes I'm thinking TYPE-BLOCK! may work, while for the typeset purposes the type constraints are used.</p>
          <p><a href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/10">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/10</link>
        <pubDate>Sat, 17 Feb 2024 05:40:37 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2151-10</guid>
        <source url="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="8" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>With TYPE-BLOCK! being the sort of "declarative expanded types" there's still going to be desires for some way to do type constraints</p>
</blockquote>
</aside>
<p>Indeed, TYPE-BLOCK!s make type constraints difficult (unions, intersections, etc.). Which is precisely why <a href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/2">my original suggestion</a> was that they might not be a good fit for Rebol, and we should focus more heavily on type constraints as the fundamental building blocks for types.</p>
<p>That is to say: if we’re relying on a system of type constraints in any case, then it makes sense to me that TYPE OF should return a type constraint too. I especially like the idea of this invariant holding:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; match type of x x
== ~true~ (for all x)
</code></pre>
<p>(Where <code>match</code> specifically takes a type constraint.)</p>
          <p><a href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/9">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/9</link>
        <pubDate>Sat, 17 Feb 2024 05:25:17 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2151-9</guid>
        <source url="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="7" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Then we could get rid of TYPE-WORD! and all the rest.</p>
</blockquote>
</aside>
<p>With TYPE-BLOCK! being the sort of "declarative expanded types" there's still going to be desires for some way to do type constraints, in the spirit of:</p>
<pre><code>parse [a: $b c] [some any-word!]
</code></pre>
<p>Decorating constraint functions is an avenue of accomplishing this:</p>
<pre><code>any-word!: &amp;any-word?  ; confusing to make it look like a datatype
parse [a: $b c] [some any-word!]

parse [a: $b c] [some &amp;any-word?]  ; coherent, fewer definitions, faster
</code></pre>
<p>One could say that it's PARSE's job to have a MATCH keyword when it means "do a constraint".  However, BLOCK!s have meanings already, and ACTIONs have meanings, so this is a bit dicey... where the MATCH combinator has to quote, which is not impossible but I think it's the wrong idea:</p>
<pre><code>parse [a: $b c] [some match [any-word?]]  ; BLOCK! usually means parse rule here
</code></pre>
<p>So I do not see type constraints as having a notation as something that needs to go away.</p>
          <p><a href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/8">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/8</link>
        <pubDate>Sat, 17 Feb 2024 04:58:52 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2151-8</guid>
        <source url="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>The direction of saying TYPE OF always returns a TYPE-BLOCK! and that it is kind of a "broad answer" that you can destructure into parts makes it seem like it could give a good baseline behavior</p>
</blockquote>
</aside>
<p>I tend to agree with this. Then we could get rid of TYPE-WORD! and all the rest.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But would the TYPE OF an animal and a book come back with some component of the TYPE-BLOCK! mentioning they're both objects?</p>
</blockquote>
</aside>
<p>I’m not quite sure what else it would come back with.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><em>None</em> of this has any design concept, and I'm certainly willing to borrow or steal from elsewhere if it can be made to work in the paradigm with everything else.</p>
</blockquote>
</aside>
<p>OCaml is probably the closest to these ideas that I’m aware of. It may be worth having a look at its <a href="https://dev.realworldocaml.org/classes.html">class types</a>.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>whether we should be writing <strong>switch kind of x</strong> everywhere instead of <strong>switch type of x</strong> for common code</p>
</blockquote>
</aside>
<p>On this point, it’s worth noting that ‘kind’ already has <a href="https://en.wikipedia.org/wiki/Kind_(type_theory)">a well-established meaning</a> in type theory. (Specifically, it’s the type of a type.) So it’s probably a good idea to choose some other word.</p>
          <p><a href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/7">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/7</link>
        <pubDate>Sat, 17 Feb 2024 04:49:43 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2151-7</guid>
        <source url="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>One thing that has nagged me is if when we ask for the fundamental "cell type" of something, if we should avoid using the word "TYPE" for that at all...</p>
<p>Maybe there's some bigger idea in an object/class system where TYPE is meaningful to say something more than "this is an object" but rather "this is a book", where you can ask also "is a book readable". Etc.</p>
</blockquote>
</aside>
<p>The direction of saying TYPE OF always returns a TYPE-BLOCK! and that it is kind of a "broad answer" that you can destructure into parts makes it seem like it could give a good baseline behavior... that if you ask for the TYPE OF two things, they won't be equal if they're not equivalent to the maximum level of specificity that is known.</p>
<p>I'm happy if this means--for example--that things with different quoting levels aren't considered as having the same type...or things at the same quoting level of different types aren't the same:</p>
<pre><code>&gt;&gt; (type of first [''a]) = (type of first ['''a])
== ~false~  ; anti

&gt;&gt; (type of first ['a]) = (type of first ['1])
== ~false~  ; anti
</code></pre>
<p>But you could pick this apart and somewhere in the type of both of them is the notion that they wrap words, and if that were interesting you could suss that out.  The information is there in the answer to TYPE OF.</p>
<p>If this extends, and there's a way that you ask an object that if it's a book if it's equal to an object that is an animal, that these wouldn't come back as equal either.</p>
<p>But would the TYPE OF an animal and a book come back with some component of the TYPE-BLOCK! mentioning they're both objects?</p>
<pre><code>&gt;&gt; type of book
== &amp;[book object]  ; or [object book] ?

&gt;&gt; type of animal
== &amp;[animal object]
</code></pre>
<p>Or is the fact that they're both objects not part of the answer to TYPE OF, but something you have to find out from a different test?</p>
<p>If object is what's parameterized, that would give you an easier time destructuring two things that answered the TYPE OF question to see if they're both objects.  But it suggests an object with no subclass would have to fill in that parameter as something like a blank (or quasivoid or whatever)</p>
<pre><code> &gt;&gt; type of {x: 10 y: 20}
 == &amp;[object ~]
</code></pre>
<p><em>None</em> of this has any design concept, and I'm certainly willing to borrow or steal from elsewhere if it can be made to work in the paradigm with everything else.</p>
<p>But it does impact questions like:</p>
<pre><code>switch type of x [
    block! [...]
    object! [...]   ; does this mean only plain &amp;[object ~] ?
]
</code></pre>
<p>Just some rambling there, but it points to my sticking point of whether we should be writing <strong>switch kind of x</strong> everywhere instead of <strong>switch type of x</strong> for common code.  But <em>I don't like that being common</em>, so I really want a way for <strong>type of</strong> to be the go-to.</p>
          <p><a href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/6">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/6</link>
        <pubDate>Sat, 17 Feb 2024 04:38:15 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2151-6</guid>
        <source url="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="4" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>It’s not necessarily about ‘good’ or ‘bad’, as such… I just don’t really see any alternatives, if everything is a constraint.</p>
</blockquote>
</aside>
<p>The direction of the proposal does accommodate either of:</p>
<pre><code> &gt;&gt; type of false
 == &amp;[logic]

 &gt;&gt; type of false
 == &amp;logic?
</code></pre>
<p>I'm leaning to think that TYPE OF always gives back a TYPE-BLOCK! (or null, for null input, if you indicate that's intentional).</p>
<aside class="quote no-group" data-username="bradrn" data-post="4" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I like the idea of structuring, but it seems to go against conventional Rebol style.</p>
</blockquote>
</aside>
<p>Coding style and in dialects, yes.  But this is more on the "data" side of the spectrum than it is "code".  You won't be writing it out in source very much, I don't think.  Just analyzing it.</p>
          <p><a href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/5">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/5</link>
        <pubDate>Sat, 17 Feb 2024 04:06:16 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2151-5</guid>
        <source url="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It's tough here though to assume the arity of each type is known</p>
</blockquote>
</aside>
<p>Why do you say this? I like the idea of structuring, but it seems to go against conventional Rebol style.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>If the answer from TYPE OF came back immutable, then magic might be able to compress that behind the scenes.</p>
</blockquote>
</aside>
<p>I agree that the output of TYPE OF should be immutable.</p>
<p>(Though note that in the paragraph to which you replied, I was referring to the idea of generating new constraints at runtime, rather than using TYPE-BLOCK!s.)</p>
<aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>The idea of making terminal types equivalent to their predicates might be good or bad. Don't know.</p>
</blockquote>
</aside>
<p>It’s not necessarily about ‘good’ or ‘bad’, as such… I just don’t really see any alternatives, if everything is a constraint.</p>
          <p><a href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/4</link>
        <pubDate>Sat, 17 Feb 2024 03:45:27 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2151-4</guid>
        <source url="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>From a Haskeller’s perspective, this is the obvious solution. <code>'a</code> could be <code>&amp;[quoted word]</code>, and <code>spread [1 2 3]</code> could be <code>&amp;[isotope group]</code> (or even <code>&amp;[isotope group integer]</code>), and so on. The elements of these series could simply be ordinary words, left unevaluated and unbound: one could test <code>'isotope = first type of spread [a b c]</code>, and so on.</p>
</blockquote>
</aside>
<p>Prior to antiforms, it was the case that TYPE-BLOCK!s were used, though it attempted to compress by putting the quote levels on the word in the block:</p>
<pre><code>&gt;&gt; type of first [a]
== &amp;[word]

&gt;&gt; type of first ['a]
== &amp;['word]

&gt;&gt; type of first [''a]
== &amp;[''word]
</code></pre>
<p>Even that starts to incur performance penalties when you ask for a type.  Because it's synthesizing an array on the spot to answer the question--not a huge deal, but it's something.  <em>(The only "stock" blocks were the unquoted forms, &amp;[word] etc.)</em></p>
<p>When quasiforms/antiforms came along, it ran afoul of representation questions.  Weird answers like having to do meta forms inside the block:</p>
<pre><code>&gt;&gt; type of first [(a)]
== &amp;['group]

&gt;&gt; type of first [''(a)]
== &amp;['''group]

&gt;&gt; type of spread [a b c]
== &amp;[~group~]

&gt;&gt; type of first [~(a)~]
== &amp;['~group~]
</code></pre>
<p>That was rejected as too obfuscating.  (Meta forms work all right for things like storing arbitrary values in PACKs, but the above sucks.)</p>
<p>With my performance-blinders on, I don't recall if I ever suggested attacking this via plain words that convey parameterized types as per your Haskell-like suggestion:</p>
<pre><code>&gt;&gt; type of first [(a)]
== &amp;[group]

&gt;&gt; type of first [''(a)]
== &amp;[quoted quoted group]

&gt;&gt; type of spread [a b c]
== &amp;[antiform group]  ; or &amp;[splice], if e.g. &amp;[logic] narrows &amp;[antiform word]

&gt;&gt; type of first [~(a)~]
== &amp;[quasi group]
</code></pre>
<p>It's tough here though to assume the arity of each type is known, if we imagine this generalizing it might be better to have it structured, where only terminal types aren't in blocks</p>
<pre><code>&gt;&gt; type of first [''(a)]
== &amp;[quoted [quoted group]]

&gt;&gt; type of quote matrix
== &amp;[quoted [matrix 10x10]]
</code></pre>
<p>Which adds another performance penalty to grapple with, but it seems important if you're going to say that array destructuring is the method of type destructuring.</p>
<aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Possibly, these type constraints may need to have their own internal representations, different to that of ordinary Rebol functions.</p>
</blockquote>
</aside>
<p>If the answer from TYPE OF came back immutable, then magic might be able to compress that behind the scenes.  It only would work if it wasn't assumed you could change one reference to the result of TYPE OF and see that in another place.</p>
<pre><code>&gt;&gt; t: type of first ['a]
== &amp;[quoted word]

&gt;&gt; t2: t
== &amp;[quoted word]

&gt;&gt; take t
== quoted

&gt;&gt; t2
== &amp;[word]  ; only if cells for t and t2 variables point to common allocation   
</code></pre>
<p>To point to a common allocation, there has to be an allocation, which subverts some levels of optimization (at least, when one is trying to be competitive with code that does no allocations).</p>
<p>For a similar problem that's been solved, see: <a href="https://rebol.metaeducation.com/t/path-and-tuple-compression-explained/1008" class="inline-onebox">PATH! and TUPLE! compression, explained</a></p>
<h2><a name="p-7138-i-may-like-the-parameterized-type-direction-1" class="anchor" href="https://rebol.metaeducation.com#p-7138-i-may-like-the-parameterized-type-direction-1"></a>I May Like The Parameterized Type Direction</h2>
<p>I was already aiming to flip things back so that the &amp;word and &amp;tuple and &amp;path could be used as prettier impromptu type constraints:</p>
<pre><code>parse [1 3 5] [some &amp;odd?]

parse [...] [some &amp;tester?/refinement]

parse [...] [some &amp;obj.tester?]
</code></pre>
<p>I think this needs to be done regardless.  But if it is done, then switching around to TYPE-BLOCK! for the parameterized types would be available.</p>
<p>The idea of making terminal types equivalent to their predicates might be good or bad.  Don't know.</p>
<pre><code>&gt;&gt; group!
== &amp;group?

&gt;&gt; type of first [''(a)]
== &amp;[quoted [quoted &amp;group?]]
</code></pre>
<p>Certainly some food for thought here.</p>
          <p><a href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/3</link>
        <pubDate>Sat, 17 Feb 2024 03:24:36 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2151-3</guid>
        <source url="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Or maybe TYPE can be parameterized:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext"> &gt;&gt; type of matrix
 == &amp;[matrix 10x10]
</code></pre>
</blockquote>
</aside>
<p>From a Haskeller’s perspective, this is the obvious solution. <code>'a</code> could be <code>&amp;[quoted word]</code>, and <code>spread [1 2 3]</code> could be <code>&amp;[isotope group]</code> (or even <code>&amp;[isotope group integer]</code>), and so on. The elements of these series could simply be ordinary words, left unevaluated and unbound: one could test <code>'isotope = first type of spread [a b c]</code>, and so on.</p>
<p>But I’m not convinced a Haskell-like type system is a great fit for Rebol. The biggest issue is that we want to have union and intersection types, and there’s no easy way to integrate them into a system like this. One could possibly make it more ergonomic using type synonyms, but then you’d have to handle those as well when testing types, and it becomes more complicated than it should.</p>
<p>I much prefer your alternative suggestion of making constraint functions fundamental… but with some small changes. If <code>type of ''a</code> is <code>&amp;quoted?</code>, then I feel that <code>type of spread [a b]</code> should be <code>&amp;isotope?</code>. But then one could have other basic predicates too. I think it’s particularly important to have a set of types <code>&amp;any-word?</code>, <code>&amp;any-block?</code>, and so on, which would match ‘under’ isotopes and quotes (and other sigils). From these, it should be possible to create other types by combining the existing predicates: for instance, a splice would be a type which is both <code>&amp;isotope?</code> and <code>&amp;any-group?</code>.</p>
<p>This does leave me uncertain about precisely how those combinations should be accomplished. The best idea I can come up with is to allow constraints to take arguments, like so:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; splice!: &amp;all [&amp;isotope? &amp;any-group?]
== &amp;all [&amp;isotope? &amp;any-group?]

; or equivalently:
&gt;&gt; splice!: &amp;all [isotope! any-group!]
== &amp;all [&amp;isotope? &amp;any-group?]

&gt;&gt; match splice! spread [1 2 3]
== ~true~

&gt;&gt; match splice! [1 2 3]
== ~false~

; another demonstration, with more combinators:
&gt;&gt; series!: &amp;all [
     &amp;not isotope!
     &amp;any [any-block! any-group! any-path! any-tuple! string!]
   ]
== &amp;all [&amp;not &amp;isotope? &amp;any [&amp;any-block? &amp;any-group? &amp;any-path? &amp;any-tuple? &amp;any-string?]]

&gt;&gt; match series! "foobar"
== ~true~

&gt;&gt; match series! '[a b c]:
== ~true~

&gt;&gt; match series! spread [1 2 3]
== ~false~
</code></pre>
<p>I’m not sure how feasible this is to implement, though. As I recall, the key innovation which allowed constraints-as-types was implementing them as <a href="https://rebol.metaeducation.com/t/intrinsics-functions-without-frames/2050">intrinsics</a>. Is there some way of getting these combinators <code>&amp;all</code>/<code>&amp;any</code>/<code>&amp;not</code> to construct new intrinsics at runtime? I really don’t know. Possibly, these type constraints may need to have their own internal representations, different to that of ordinary Rebol functions.</p>
          <p><a href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/2</link>
        <pubDate>Sat, 17 Feb 2024 02:20:41 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2151-2</guid>
        <source url="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <h2><a name="p-7135-the-limited-and-ambiguous-historical-idea-1" class="anchor" href="https://rebol.metaeducation.com#p-7135-the-limited-and-ambiguous-historical-idea-1"></a>The Limited and Ambiguous Historical Idea</h2>
<p>People are used to being able to do things like:</p>
<pre><code> x: 10
 switch type? x [
     integer! [print "It's an integer"]
     block! [print "It's a block"]
 ]

 assert [parse [1 [second] 'foo] [integer! block! lit-word!]]

 assert [find any-word! (type? first [x:])]
</code></pre>
<p>But the historical DATATYPE! and TYPESET! were strange.</p>
<ul>
<li>
<p>DATATYPE! rendered as a WORD! but was really wrapping an integer of 0-63</p>
</li>
<li>
<p>TYPESET! was a 64-bit bitset, one bit for each type (this is where the 64 types limit came from)</p>
<ul>
<li>
<p>it lost its meaning in rendering (it kept no record of what the set actually was...just dumped words for each bit)</p>
</li>
<li>
<p>not preserving the name from a fixed list of typesets was based on the concept you could make your own or UNION/INTERSECT them</p>
</li>
</ul>
</li>
</ul>
<p>So it looked like this:</p>
<pre><code>red&gt;&gt; type? 1
== integer!

red&gt;&gt; type? type? 1
== datatype!

red&gt;&gt; print mold any-word!
make typeset! [word! set-word! lit-word! get-word!]

red&gt;&gt; print mold any-type!
make typeset! [datatype! unset! none! logic! block! paren! string! file! url!
    char! integer! float! word! set word! lit-word! get-word! refinement! issue!
    native! action! op! function! path! lit-path! set-path! get-path! routine!
    bitset! object! typeset! error! vector! hash! pair! percent! tuple! map!
    binary! time! tag! email! handle! date! port! money! ref! point2D! point3D!
    image! event!]
</code></pre>
<h2><a name="p-7135-the-type-xxx-approach-2" class="anchor" href="https://rebol.metaeducation.com#p-7135-the-type-xxx-approach-2"></a>The TYPE-XXX! Approach</h2>
<p>So Ren-C attacked the ambiguity and extensibility with a new word type, TYPE-WORD!.  Then typesets used TYPE-GROUP! and TYPE-BLOCK!, referencing functions to act as type testing predicates, and using groups for intersections and blocks for unions:</p>
<pre><code>&gt;&gt; type of 1
== &amp;integer

&gt;&gt; type of type of 1
== &amp;type-word

&gt;&gt; print mold any-word!
&amp;(any-word?)

&gt;&gt; print mold any-value!
&amp;(any-value?)
</code></pre>
<p>This gives some realistic axis of extensibility, and gives distinguishable entities that can trigger behaviors in PARSE when something looks up to type-xxx!.  (this shows why using WORD! or URL! or ISSUE! wouldn't work, because the type intent has to be carried by what e.g. INTEGER! looks up to.)</p>
<p><strong>Calling functions to implement type checks vs. checks on a bitset, especially when an array of functions must be called when checking every parameter in every function call, is a difficult performance point.</strong></p>
<p><a href="https://rebol.metaeducation.com/t/intrinsics-functions-without-frames/2050">Intrinsics and other magic are employed to rein it in.</a>  It's not particularly simple...but finding ways to speed up function calls where you can has systemic benefit.</p>
<h2><a name="p-7135-new-consequence-find-must-find-type-word-normally-3" class="anchor" href="https://rebol.metaeducation.com#p-7135-new-consequence-find-must-find-type-word-normally-3"></a>New Consequence: FIND Must Find TYPE-WORD! Normally</h2>
<p>Being a legitimate datatype that can be stored in a block, some interpretations of datatype by functions like FIND were problematic:</p>
<pre><code>red&gt;&gt; block: reduce ["hello" integer! 1]
== ["hello" integer! 1]

red&gt;&gt; find block 'integer!
== none  ; rendering was a lie

red&gt;&gt; find block integer!
== [1]
</code></pre>
<p>You couldn't find a literal datatype in a block.  Ren-C is approaching this by saying FIND has to find the TYPE-WORD! (as it does for all non-antiforms), but that you can use antiform actions as predicates.</p>
<pre><code>&gt;&gt; block: reduce ["hello" integer! 1]
== ["hello" &amp;integer 1]

&gt;&gt; find block integer!
== [&amp;integer 1]

&gt;&gt; find block :integer?
== [1]
</code></pre>
<p>There was some thought that maybe you could create antiform TYPE-XXX! and call them "matchers", passing them to FIND.</p>
<ul>
<li>
<p>But this is an isotope for each TYPE-XXX!, so it's not even like there would be one "matcher"</p>
</li>
<li>
<p>It also would be the only instance of antiforms of types with sigils, which doubles the sigil to make <strong><code>~&amp;integer~</code></strong>, which I find kind of displeasing</p>
</li>
</ul>
<p>I feel that antiform actions cover it for FIND, and if you have higher level needs you should use something like PARSE which has richer options and isn't beholden to quite the "mechanical" answer that a series primitive like FIND has to abide by with its limited parameterization.</p>
<h2><a name="p-7135-new-annoyance-type-of-quotes-and-antiforms-4" class="anchor" href="https://rebol.metaeducation.com#p-7135-new-annoyance-type-of-quotes-and-antiforms-4"></a>New Annoyance: TYPE OF Quotes And Antiforms</h2>
<p>When there were only two datatypes with quotedness, the quote was part of their datatype:</p>
<pre><code>red&gt;&gt; type? first ['a]
== lit-word!

red&gt;&gt; type? first ['a/b]
== lit-path!

red&gt;&gt; lit-word! = type? first ['a]
== true

red&gt;&gt; parse ['a 'a/b] [lit-word! lit-path!]
== true
</code></pre>
<p>Ren-C's approach affords the ability make type constraints to carry forward the PARSE behavior.  But the TYPE OF all quoteds is the same... &amp;QUOTED.</p>
<pre><code>&gt;&gt; lit-word?!
== &amp;(lit-word?)

&gt;&gt; lit-word?! = type of first ['a]
== ~false~  ; anti

&gt;&gt; type of first ['a]
== &amp;quoted
</code></pre>
<p>So perhaps you see the motivation to decorate as <strong>?!</strong> instead of just <strong>!</strong> for the type constraints.  People need to know that these aren't fundamental types.  You have to use e.g. MATCH with them:</p>
<pre><code> &gt;&gt; match lit-word?! first ['a]
 == 'a

 &gt;&gt; match lit-word?! 10
 == ~null~  ; anti

 &gt;&gt; match [lit-word?] first ['a]  ; alternative as 1st slot known "typelike"
 == 'a
</code></pre>
<p>This is something of a pain point, and I'm not entirely settled on whether it would be good to delve into some kind of ambiguity where we are actually allowed to get back constraint functions as the answer to TYPE OF, and make that the fundamental:</p>
<pre><code>&gt;&gt; type of 1
== &amp;integer?

&gt;&gt; type of spread [a b]
== &amp;splice?

&gt;&gt; type of ~true~
== &amp;logic?

&gt;&gt; type of first ['a]
== &amp;quoted? 
</code></pre>
<p>So I don't think this is a good idea for the quoted types, but for the antiforms it might be a narrow enough thing that it provides "what the people want".</p>
<pre><code>&gt;&gt; switch type of true [
     splice! [...]
     logic! [...]
     integer! [...]
  ]
</code></pre>
<p>Barring that, what we have to do today is flip SWITCH over into a MATCH mode (currently called SWITCH/TYPE but should probably be SWITCH/MATCH... or maybe it should take the MATCH name):</p>
<pre><code>&gt;&gt; switch/type true [
     splice?! [...]
     logic?! [...]
     integer! [...]
  ]
</code></pre>
<p>Note that the <code>?!</code> distinction is a new idea which hasn't made it to all type constraints yet, e.g. ANY-VALUE! is still as it was.  But because parameters use what is effectively a TYPE-BLOCK! you can say <strong><code>any-value?</code></strong> or <strong><code>splice?</code></strong> in them instead of going through the extra step.</p>
<h2><a name="p-7135-should-type-be-a-bigger-concept-5" class="anchor" href="https://rebol.metaeducation.com#p-7135-should-type-be-a-bigger-concept-5"></a>Should TYPE Be A Bigger Concept?</h2>
<p>One thing that has nagged me is if when we ask for the fundamental "cell type" of something, if we should avoid using the word "TYPE" for that at all...</p>
<p>Maybe there's some bigger idea in an object/class system where TYPE is meaningful to say something more than "this is an object" but rather "this is a book", where you can ask also "is a book readable".  Etc.</p>
<p>Or maybe TYPE can be parameterized:</p>
<pre><code> &gt;&gt; type of matrix
 == &amp;[matrix 10x10]
</code></pre>
<p>So this would mean there's a smaller question about the fundamental type, maybe call it "KIND":</p>
<pre><code>&gt;&gt; kind of [a b c]
== &amp;block

&gt;&gt; kind of matrix
== &amp;object
</code></pre>
<p>It would be nice to just be able to say "64 types is enough for anyone" and say "there, it's done".  I'd be happy to do that if I felt that it was enough.  It wasn't, even when thinking along fairly limited lines that don't go in these fancier directions.</p>
<p><em>I don't think any near-term system will actualize on bigger visions of what TYPE might be, but it would help to know if that should be ruled out or not, just in order to pick the term KIND or TYPE!</em>  But even that question is murky.</p>
<h2><a name="p-7135-some-related-reading-typesr-6" class="anchor" href="https://rebol.metaeducation.com#p-7135-some-related-reading-typesr-6"></a>Some Related Reading: %types.r</h2>
<p>The dialected table used to construct the type testing macros and other things is kind of neat, though some comments are out of date and parts of it need updating (it's getting upgraded in an upcoming commit which finally breaks the 64-type barrier and introduces the $ types):</p>
<p>See <a href="https://github.com/metaeducation/ren-c/blob/master/src/boot/types.r"><strong>%types.r</strong></a></p>
          <p><a href="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/1</link>
        <pubDate>Fri, 16 Feb 2024 23:29:33 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2151-1</guid>
        <source url="https://rebol.metaeducation.com/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
      </item>
  </channel>
</rss>

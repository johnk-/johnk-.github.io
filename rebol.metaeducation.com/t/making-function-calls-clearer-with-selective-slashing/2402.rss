<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Making Function Calls Clearer With Selective Slashing</title>
    <link>https://rebol.metaeducation.com/t/making-function-calls-clearer-with-selective-slashing/2402</link>
    <description>Ren-C shifted to the idea that slashes in paths are used to convey function calls.  Refinements are done with colons (CHAIN!), and field selection is done with dots (TUPLE!)

This means you can tell the difference between:

    obj/xxx  ; a function call

    obj.xxx  ; picking a member out of an object

But Rebol depends visually on not needing any decoration to run a function out of a word.  This means that when you see:

    some-word

You don&#39;t know if that&#39;s running a function or not.   While that is &quot;by design&quot;, there are sometimes cases where you want to disambiguate it.  So Ren-C offers:

    /some-word  ; runs a function

    some-word.  ; gets a non-function value from the word

*(The `some-word/` case is for getting a function without running it... chosen for its semiotic value of separating the word from its arguments with a &quot;barrier&quot; at the end.  And `.some-word` is used for picking members out of objects inside of a method, e.g. `self.some-word`.)*

## Who Would Ever Use /SOME-WORD ?

I&#39;ve explained cool applications of the leading slash in things like [ACTION! combinators for UPARSE](https://rebol.metaeducation.com/t/if-action-combinators-dont-impress-what-will/1608).

But is it useful in non-dialected code?

**YES.**

In doing some updates to Shixin&#39;s c2r3, there was some code like this:

    cpuid: tcc/load-func prog &quot;cpuid&quot; [
        eax [pointer]
        ebx [pointer]
        ecx [pointer]
        edx [pointer]
        return: [void]
    ]

    cpu-string: func [
        return: [text!]
    ][
        let eax: copy #{00000000}
        let ebx: copy #{00000000}
        let ecx: copy #{00000000}
        let edx: copy #{00000000}

        cpuid eax ebx ecx edx
        return as text! join blob! [ebx edx ecx]
    ]

CPUID doesn&#39;t necessarily sound like a function invocation.  But let&#39;s imagine that&#39;s what something is named.  You&#39;re confronted with the question: should I name the wrapper something like **`get-cpuid:`** ?  But now you&#39;ve created a mismatch between something that exists and your wrapper.

Using the leading slash gives you the ability to mark things more clearly as a function at the assignment:

    /cpuid: tcc/load-func prog &quot;cpuid&quot; [
        eax [pointer]
        ebx [pointer]
        ecx [pointer]
        edx [pointer]
        return: [void]
    ]

This not only visually reinforces that what you are assigning is a function, but it also requries that what you&#39;re assigning be an action.  So it&#39;s a convenient shorthand for:

    cpuid: ensure action! tcc/load-func prog &quot;cpuid&quot; [...]

The callsites have a similar benefit...not just visual, but enforced that it&#39;s a function call:

    /cpuid eax ebx ecx edx
    return as text! join blob! [ebx edx ecx]

## It&#39;s There On An As-Needed Basis

For a time, I was wondering if all function assignments should require slashed-set-words.

But I realized that it was too much.

    /something: func [...] [...]   ; but I KNOW FUNC makes functions...

    /alpha: beta/  ; BETA/ promises to return a function, why double-enforce?

But it can make some situations more clear, and give you cheap insurance that the assignment is doing what you think.

Similarly I think the leading slash is something to apply judiciously.  We don&#39;t want to read code with tons of **`/append`** junking it up.  But cases like this **`/cpuid`** show an effective and helpful communication that a function call is happening.</description>
    
    <lastBuildDate>Wed, 09 Apr 2025 05:12:49 +0000</lastBuildDate>
    <category>Feature Discover</category>
    <atom:link href="https://rebol.metaeducation.com/t/making-function-calls-clearer-with-selective-slashing/2402.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Making Function Calls Clearer With Selective Slashing</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Ren-C shifted to the idea that slashes in paths are used to convey function calls.  Refinements are done with colons (CHAIN!), and field selection is done with dots (TUPLE!)</p>
<p>This means you can tell the difference between:</p>
<pre><code>obj/xxx  ; a function call

obj.xxx  ; picking a member out of an object
</code></pre>
<p>But Rebol depends visually on not needing any decoration to run a function out of a word.  This means that when you see:</p>
<pre><code>some-word
</code></pre>
<p>You don't know if that's running a function or not.   While that is "by design", there are sometimes cases where you want to disambiguate it.  So Ren-C offers:</p>
<pre><code>/some-word  ; runs a function

some-word.  ; gets a non-function value from the word
</code></pre>
<p><em>(The <code>some-word/</code> case is for getting a function without running it... chosen for its semiotic value of separating the word from its arguments with a "barrier" at the end.  And <code>.some-word</code> is used for picking members out of objects inside of a method, e.g. <code>self.some-word</code>.)</em></p>
<h2><a name="p-8124-who-would-ever-use-some-word-1" class="anchor" href="https://rebol.metaeducation.com#p-8124-who-would-ever-use-some-word-1"></a>Who Would Ever Use /SOME-WORD ?</h2>
<p>I've explained cool applications of the leading slash in things like <a href="https://rebol.metaeducation.com/t/if-action-combinators-dont-impress-what-will/1608">ACTION! combinators for UPARSE</a>.</p>
<p>But is it useful in non-dialected code?</p>
<p><strong>YES.</strong></p>
<p>In doing some updates to Shixin's c2r3, there was some code like this:</p>
<pre><code>cpuid: tcc/load-func prog "cpuid" [
    eax [pointer]
    ebx [pointer]
    ecx [pointer]
    edx [pointer]
    return: [void]
]

cpu-string: func [
    return: [text!]
][
    let eax: copy #{00000000}
    let ebx: copy #{00000000}
    let ecx: copy #{00000000}
    let edx: copy #{00000000}

    cpuid eax ebx ecx edx
    return as text! join blob! [ebx edx ecx]
]
</code></pre>
<p>CPUID doesn't necessarily sound like a function invocation.  But let's imagine that's what something is named.  You're confronted with the question: should I name the wrapper something like <strong><code>get-cpuid:</code></strong> ?  But now you've created a mismatch between something that exists and your wrapper.</p>
<p>Using the leading slash gives you the ability to mark things more clearly as a function at the assignment:</p>
<pre><code>/cpuid: tcc/load-func prog "cpuid" [
    eax [pointer]
    ebx [pointer]
    ecx [pointer]
    edx [pointer]
    return: [void]
]
</code></pre>
<p>This not only visually reinforces that what you are assigning is a function, but it also requries that what you're assigning be an action.  So it's a convenient shorthand for:</p>
<pre><code>cpuid: ensure action! tcc/load-func prog "cpuid" [...]
</code></pre>
<p>The callsites have a similar benefit...not just visual, but enforced that it's a function call:</p>
<pre><code>/cpuid eax ebx ecx edx
return as text! join blob! [ebx edx ecx]
</code></pre>
<h2><a name="p-8124-its-there-on-an-as-needed-basis-2" class="anchor" href="https://rebol.metaeducation.com#p-8124-its-there-on-an-as-needed-basis-2"></a>It's There On An As-Needed Basis</h2>
<p>For a time, I was wondering if all function assignments should require slashed-set-words.</p>
<p>But I realized that it was too much.</p>
<pre><code>/something: func [...] [...]   ; but I KNOW FUNC makes functions...

/alpha: beta/  ; BETA/ promises to return a function, why double-enforce?
</code></pre>
<p>But it can make some situations more clear, and give you cheap insurance that the assignment is doing what you think.</p>
<p>Similarly I think the leading slash is something to apply judiciously.  We don't want to read code with tons of <strong><code>/append</code></strong> junking it up.  But cases like this <strong><code>/cpuid</code></strong> show an effective and helpful communication that a function call is happening.</p>
          <p><a href="https://rebol.metaeducation.com/t/making-function-calls-clearer-with-selective-slashing/2402/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/making-function-calls-clearer-with-selective-slashing/2402/1</link>
        <pubDate>Tue, 08 Apr 2025 18:41:47 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2402-1</guid>
        <source url="https://rebol.metaeducation.com/t/making-function-calls-clearer-with-selective-slashing/2402.rss">Making Function Calls Clearer With Selective Slashing</source>
      </item>
  </channel>
</rss>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>.WORD as Member Selection - Binding - AltRebol</title>
    <meta name="description" content="I just got bit by a situation where there was something like this: 
 obj: make object! [
     spec: &amp;lt;whatever&amp;gt;
     actor: make object! [
          thing: function [port] [
               spec: any [global.spec, port.spe&amp;hellip;">
    <meta name="generator" content="Discourse 3.5.0.beta6-dev - https://github.com/discourse/discourse version 623cde985b21c2ed812b83d3ea94f69231613718">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/1X/cbd70027b53fa165575e5b665f00eb3b8ae7ea31_2_32x32.ico">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d_2_180x180.png">
<meta name="theme-color" media="all" content="#fff">

<meta name="color-scheme" content="light">

<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, viewport-fit=cover">
<link rel="canonical" href="1843.html" />

<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="AltRebol Search">

    <link href="https://rebol.metaeducation.com/stylesheets/color_definitions_base__2_ceb61c279a74dfa3cef6a62f7784988102abec82.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" class="light-scheme"/>

<link href="https://rebol.metaeducation.com/stylesheets/common_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="common"  />

  <link href="https://rebol.metaeducation.com/stylesheets/desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="desktop"  />



    <link href="https://rebol.metaeducation.com/stylesheets/chat_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="chat"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-details_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-details"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-lazy-videos_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-lazy-videos"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-local-dates_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-local-dates"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-narrative-bot_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-narrative-bot"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-presence_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-presence"  />
    <link href="https://rebol.metaeducation.com/stylesheets/docker_manager_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="docker_manager"  />
    <link href="https://rebol.metaeducation.com/stylesheets/footnote_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="footnote"  />
    <link href="https://rebol.metaeducation.com/stylesheets/poll_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="poll"  />
    <link href="https://rebol.metaeducation.com/stylesheets/spoiler-alert_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="spoiler-alert"  />
    <link href="https://rebol.metaeducation.com/stylesheets/chat_desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="chat_desktop"  />
    <link href="https://rebol.metaeducation.com/stylesheets/poll_desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="poll_desktop"  />

  <link href="https://rebol.metaeducation.com/stylesheets/common_theme_2_57fe803ed5a41e9f7d94086afaf66a1aab57d9ae.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="common_theme" data-theme-id="2" data-theme-name="default"/>
    

    
    
        <link rel="alternate nofollow" type="application/rss+xml" title="RSS feed of &#39;.WORD as Member Selection&#39;" href="1843.rss" />
    <meta property="og:site_name" content="AltRebol" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:image" content="https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:url" content="https://rebol.metaeducation.com/t/word-as-member-selection/1843" />
<meta name="twitter:url" content="https://rebol.metaeducation.com/t/word-as-member-selection/1843" />
<meta property="og:title" content=".WORD as Member Selection" />
<meta name="twitter:title" content=".WORD as Member Selection" />
<meta property="og:description" content="I just got bit by a situation where there was something like this:   obj: make object! [      spec: &lt;whatever&gt;      actor: make object! [           thing: function [port] [                spec: any [global.spec, port.spec]                ...           ]      ]  ]  I changed this from a FUNCTION to a LAMBDA, forgetting that changing things from a function (today) changes it from doing SET-WORD! gathering.  That means SPEC: went from being a local variable (like LET SPEC:) and referred to the oute..." />
<meta name="twitter:description" content="I just got bit by a situation where there was something like this:   obj: make object! [      spec: &lt;whatever&gt;      actor: make object! [           thing: function [port] [                spec: any [global.spec, port.spec]                ...           ]      ]  ]  I changed this from a FUNCTION to a LAMBDA, forgetting that changing things from a function (today) changes it from doing SET-WORD! gathering.  That means SPEC: went from being a local variable (like LET SPEC:) and referred to the oute..." />
<meta property="og:article:section" content="Development" />
<meta property="og:article:section:color" content="25AAE2" />
<meta property="og:article:section" content="Binding" />
<meta property="og:article:section:color" content="25AAE2" />
<meta name="twitter:label1" value="Reading time" />
<meta name="twitter:data1" value="3 mins ðŸ•‘" />
<meta name="twitter:label2" value="Likes" />
<meta name="twitter:data2" value="3 â¤" />
<meta property="article:published_time" content="2022-06-16T09:17:41+00:00" />
<meta property="og:ignore_canonical" content="true" />


    
  </head>
  <body class="crawler ">
    
    <header>
  <a href="https://rebol.metaeducation.com/">AltRebol</a>
</header>

    <div id="main-outlet" class="wrap" role="main">
        <div id="topic-title">
    <h1>
      <a href="1843.html">.WORD as Member Selection</a>
    </h1>

      <div class="topic-category" itemscope itemtype="http://schema.org/BreadcrumbList">
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://rebol.metaeducation.com/c/development/binding/49" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #25AAE2'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Development</span>
              </span>
            </a>
            <meta itemprop="position" content="1" />
          </span>
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://rebol.metaeducation.com/c/development/binding/49" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #25AAE2'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Binding</span>
              </span>
            </a>
            <meta itemprop="position" content="2" />
          </span>
      </div>

  </div>

  

    <div itemscope itemtype='http://schema.org/DiscussionForumPosting'>
      <meta itemprop='headline' content='.WORD as Member Selection'>
      <link itemprop='url' href='1843.html'>
      <meta itemprop='datePublished' content='2022-06-16T09:17:41Z'>
        <meta itemprop='articleSection' content='Binding'>
      <meta itemprop='keywords' content=''>
      <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
        <meta itemprop='name' content='AltRebol'>
          <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
            <meta itemprop='url' content='https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
          </div>
      </div>


          <div id='post_1'  class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>

                <link itemprop="mainEntityOfPage" href="1843.html">


              <span class="crawler-post-infos">
                  <time  datetime='2022-06-16T09:17:41Z' class='post-time'>
                    June 16, 2022,  9:17am
                  </time>
                  <meta itemprop='dateModified' content='2022-06-16T09:17:41Z'>
              <span itemprop='position'>1</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>I just got bit by a situation where there was something like this:</p>
<pre><code> obj: make object! [
     spec: &lt;whatever&gt;
     actor: make object! [
          thing: function [port] [
               spec: any [global.spec, port.spec]
               ...
          ]
     ]
 ]
</code></pre>
<p>I changed this from a FUNCTION to a LAMBDA, forgetting that changing things from a function (today) changes it from doing SET-WORD! gathering.</p>
<p>That means SPEC: went from being a local variable (like LET SPEC:) and referred to the outer SPEC.  It overwrote it.</p>
<p>There's a lot going on here, but it reminds me of an idea I've had that perhaps if you are writing code that wants to access object members you identify annotate that as <strong><code>.member</code></strong></p>
<p>This is something that languages have struggled with.  In C++ people are always wondering if they should be clear and write <strong><code>this-&gt;member</code></strong> or if you should name members specially like <strong>m_member</strong>.  Reading Rust code today it's often littered with the mandatory <strong>self.member</strong> until SELF is repeated so often in a method you can't read any of the rest of the code.</p>
<p>I had a lot of trouble deciphering Rebmake due to not knowing what was a function, an object, a member, or a global.  It's a big advantage just to have dots for member selection distinct from slashes for refinements.  But it would be a bigger advantage to be able to see at a glance that something was a member with the relatively brief dot annotation on <strong>.member</strong></p>
<p>As with most things pertaining to binding, I have no real clue how to make it work or cohere.  But it's something that has been on my mind--and comes back to my attention every time problems with member variables comes up.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

                <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../binding-indirection/2112/7.html">&quot;Binding Indirection&quot;</a>
                        <meta itemprop='position' content='1'>
                      </div>
                </div>
          </div>
          <div id='post_2' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='../../u/IngoHohmann.html'><span itemprop='name'>IngoHohmann</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2022-06-16T20:59:26Z' class='post-time'>
                    June 16, 2022,  8:59pm
                  </time>
                  <meta itemprop='dateModified' content='2022-06-16T20:59:26Z'>
              <span itemprop='position'>2</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>In theory this might allow</p>
<p>.spec being spec in actor and<br>
..spec being spec in obj .</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
          <div id='post_3' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2024-11-14T00:20:32Z' class='post-time'>
                    November 14, 2024, 12:20am
                  </time>
                  <meta itemprop='dateModified' content='2024-11-14T02:47:01Z'>
              <span itemprop='position'>3</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1843">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I had a lot of trouble deciphering Rebmake due to not knowing what was a function, an object, a member, or a global. It's a big advantage just to have dots for member selection distinct from slashes for refinements. But it would be a bigger advantage to be able to see at a glance that something was a member with the relatively brief dot annotation on <strong>.member</strong></p>
<p>As with most things pertaining to binding, I have no real clue how to make it work or cohere.</p>
</blockquote>
</aside>
<p>Pure Virtual Binding opened the door to this, so I tried it.</p>
<p>I made the CONSTRUCT primitive a version of MAKE OBJECT! that didn't bind everything inside the block.  It only binds the SET-WORDs at the top level, so you can do things like this:</p>
<pre><code>&gt;&gt; x: 10

&gt;&gt; construct [x: x + 10]
== make object! [x: 20]
</code></pre>
<p>Then, my "naive" first approach to enable .WORD was simply to make tuple selection stow the object that it picked out of in the function value returned.</p>
<pre><code>&gt;&gt; global: ~

&gt;&gt; obj: construct [x: 10, set $global /foo: does [.x]]

&gt;&gt; obj/x
== 10

&gt;&gt; /test: obj.x/
== ~#[frame! []]~  ; anti

&gt;&gt; test
== 10

&gt;&gt; global
** Error: .x has no object coupling in effect
</code></pre>
<p>In the case where you're extracting the action value to store in TEST, the value you get has a pointer to the OBJ object embedded inside it.  So it knows how to run it.</p>
<p>But the global variable that was set didn't get that.  It just has the uncoupled function.  There's a way for you to fix that:</p>
<pre><code> &gt;&gt; /global: couple global/ obj

 &gt;&gt; global
 == 10
</code></pre>
<p>We could make that easier, by letting you pass in a variable to update instead of an "immediate" ACTION! value, e.g. <strong><code>couple $global obj</code></strong>.  <em>(Being able to do both might be interesting for more functions of this nature.)</em></p>
<p>In any case, I don't really have a problem with the fact that doing something like that gives you an "uncoupled" method.  That seems fine.</p>
<p>But other things raise questions, some easier to address than others.</p>
<h2><a name="p-7891-what-about-enumerations-1" class="anchor" href="1843.html#p-7891-what-about-enumerations-1"></a>What About Enumerations?</h2>
<pre><code>obj: make object! [x: 10, /foo: lambda [y] [.x + y]]

for-each [key ~/val] [  ; proposed notation for "maybe action"
    if action? val/~ [  ; proposed notation for "don't run, maybe action"
        print [val 1000]
    ]
]
</code></pre>
<p>If this is going to work, then the enumeration behind FOR-EACH has to add the coupling.</p>
<h2><a name="p-7891-when-to-override-2" class="anchor" href="1843.html#p-7891-when-to-override-2"></a>When To Override?</h2>
<p>The current idea is that once an action gets a coupling, it sticks.</p>
<pre><code>&gt;&gt; obj1: make object! [x: 10, /foo: does [.x]]

&gt;&gt; obj2: make object! [x: 20, foo: ~]

&gt;&gt; /obj2.foo: obj1.foo/

&gt;&gt; obj2/foo
== 10
</code></pre>
<p>If you don't want this, you'd have to store an UNCOUPLE-d version of the function.</p>
<pre><code>&gt;&gt; /obj2.foo: uncouple obj1.foo/

&gt;&gt; obj2/foo
== 20
</code></pre>
<p>I don't really have a problem with that.</p>
<h2><a name="p-7891-should-all-functions-get-couplings-3" class="anchor" href="1843.html#p-7891-should-all-functions-get-couplings-3"></a>Should ALL Functions Get Couplings?</h2>
<p>For starters, METHOD and FUNCTION were synonyms.  All actions would get "couplings" when picked out of contexts.</p>
<p>This is a bit dodgy in the sense that it seems to put the information in places that it doesn't belong.</p>
<p>So you might argue that if you fetch a function out of a word, then it should get a special state that isn't just "uncoupled", but "anti-coupled", e.g. it won't <em>ever</em> pick up a coupling (until you uncouple it).</p>
<p>Then we might ask how this should behave:</p>
<pre><code> obj: construct [
     x: 10
     /foo: func [y] [
        helper: does [print [.x + y]]
        helper
    ]
 ]
</code></pre>
<p>In order for that to work, the "anti-coupled" state would have to keep climbing the virtual bind chain vs. stopping at the frame for DOES, to use the <strong>.x</strong> from FOO.</p>
<p>The problems here don't seem insurmountable...but I'm definitely mulling over whether the picking up of couplings should be limited to a different kind of function, e.g. a METHOD.  It seems to me like it's good documentation, but it would help avoid contention:</p>
<pre><code> obj: construct [
     x: 10
     /foo: method [y] [
        helper: does [print [.x + y]]
        helper
    ]
 ]
</code></pre>
<p>With a situation like that, it could be the non-method character of DOES which you can use to trust that it won't have a competing meaning for <strong>.x</strong></p>
<p>This stuff is all in its early stages, but it really is way more promising than what came before it...</p>
<p><strong>I am pretty sure that CONSTRUCT--not propagating the binding deeply of the object onto everything inside the object--is the better answer for the default of making objects, e.g. <code>{x: x}</code></strong></p>
<p>The other idea, of making something that spreads its influences deeply, should probably have a name.</p>
<p><strong><code>CONTEXT</code></strong> wouldn't be a bad name, actually (and has historical precedent as an alias for MAKE OBJECT!), but I'm using that word with another nuance.  It's the same functionality as WRAP but just returning the context, so maybe <strong><code>wrap:context</code></strong> could say that you want the context back, not the block?</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

                <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../first-bootstrap-in-at-least-6-months-watershed-changes/2334.html">First Bootstrap In At Least 6 Months: Watershed Changes</a>
                        <meta itemprop='position' content='1'>
                      </div>
                </div>
          </div>
          <div id='post_4' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2024-11-17T17:05:53Z' class='post-time'>
                    November 17, 2024,  5:05pm
                  </time>
                  <meta itemprop='dateModified' content='2024-11-17T17:05:53Z'>
              <span itemprop='position'>4</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>One little edge case on this, is whether to distinguish calling a member function from referencing a member variable.</p>
<pre><code>obj: {
    x: 10
    /foo: method [y] [return .x + y]
    /bar: method [z] [return .foo z]
}
</code></pre>
<p>It's unfortunate in my view that this isn't expressed as:</p>
<pre><code>/bar: method [z] [return /foo z]
</code></pre>
<p>The idea of "left hand side is implicit" that you get from <strong><code>.x</code></strong> for a non-method selection would be complemented nicely by <strong><code>/foo</code></strong> for a "left hand side is implicit" member.</p>
<p>Instead, what we get is that we've spent a character on a dot, and yet stayed in the domain of vagueness that a plain WORD! has in terms of whether it's a function call or not.</p>
<p>But staying in that domain of vagueness seems the best choice. I've found it too compelling to say:</p>
<pre><code>/foo: blah blah
</code></pre>
<p>And know from that source that FOO is an action antiform, with it not implying it's the member of any object.</p>
<p>So this means if you really want to clarify that you're calling a member function, you'd have to write the relatively ugly:</p>
<pre><code>/bar: method [z] [return /.foo z]
</code></pre>
<p>Ick.  <img src="../../images/emoji/twitter/nauseated_face.png%3Fv=14" title=":nauseated_face:" class="emoji" alt=":nauseated_face:" loading="lazy" width="20" height="20"></p>
<p>Well, for whatever it's worth... I haven't gotten the urge to go around sticking leading slashes on function calls on WORD! just for clarity's sake.  I only use it where it has meaning (e.g. PARSE to differentiate combinator invocation vs. plain function invocation with combinator-synthesized arguments).  This just feels a little different because it feels like it's a stand in for <strong><code>this.foo</code></strong>, which would error if foo was an action.</p>
<p>But sometimes when you're lining up puzzle pieces you hit these edges, and have to say "it's different when there's nothing to the left".  <img src="../../images/emoji/twitter/man_shrugging.png%3Fv=14" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
          <div id='post_5' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2025-07-14T12:45:37Z' class='post-time'>
                    July 14, 2025, 12:45pm
                  </time>
                  <meta itemprop='dateModified' content='2025-07-14T12:45:37Z'>
              <span itemprop='position'>5</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>I've shifted the mechanics of binding, such that WORD!s <strong><a href="../should-word-capture-the-whole-binding-environment/2494.html">now capture the full binding environment</a></strong>.</p>
<p>A consequence of this is that "wordlike" sequences that are compressible to WORD! size--such as <strong><code>.foo</code></strong>--also do the same.</p>
<p>This makes it feasible to build the "magic" of behavior that <strong><code>.foo</code></strong> picks out of the "current object" as being simply a matter of giving the current object a name in the environment, and looking up that name.  When a METHOD ran, it would use the "coupling" from the invocation to spread that name down...just like a definitional RETURN (or anything else) would.</p>
<p>I debated whether this name should be simply "dot" (<strong><code>.</code></strong>) or if it should be something more English-like, such as <strong><code>this</code></strong>.   It seemed to me that dot was harder to see, and also maybe a bit confusing... because <strong><code>.foo</code></strong> would be equivalent to <strong><code>(.).foo</code></strong>, which looks strange.  It seemed easier to explain that it was just a shorthand for <strong><code>this.foo</code></strong></p>
<p>So I leaned to favoring <strong>this</strong>.</p>
<p>But <strong><code>/foo</code></strong> has a now very important meaning related to foo as an action antiform you want to run.  That means it can't implicitly mean there's an invisible object on the left.</p>
<p>That makes a pretty strong argument for <strong><code>.</code></strong> being the WORD! used for the current object, because that gives <strong><code>./foo</code></strong> as the way of  running a member function out of the current object.</p>
<p>Do remember that people will be able to write something like: <strong><code>use .</code></strong> in their method body if they want to omit the dot on member accesses.  But I think calling out the member accesses is worth it, and the notation is much lighter than requiring you to say <code>this.foo</code> or <code>self.foo</code></p>
<p>Anyway, I'm moving ahead and ripping out the old frail hack that implemented the <strong>.WORD</strong> convention and replacing it with this, which has a more solid and reliable basis.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="3" />
              <span class='post-likes'>3 Likes</span>
            </div>

          </div>
    </div>


    




    </div>
    <footer class="container wrap">
  <nav class='crawler-nav'>
    <ul>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/' itemprop="url">Home </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/categories' itemprop="url">Categories </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/guidelines' itemprop="url">Guidelines </a>
        </span>
      </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://rebol.metaeducation.com/tos' itemprop="url">Terms of Service </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://rebol.metaeducation.com/privacy' itemprop="url">Privacy Policy </a>
          </span>
        </li>
    </ul>
  </nav>
  <p class='powered-by-link'>Powered by <a href="https://www.discourse.org">Discourse</a>, best viewed with JavaScript enabled</p>
</footer>

    
    
  </body>
  
</html>

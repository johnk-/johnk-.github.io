<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Usefulness of String Interpolation</title>
    <link>https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114</link>
    <description>[quote=&quot;bradrn, post:7, topic:1751&quot;]
[quote=&quot;hostilefork, post:1, topic:1751&quot;]
Features based on string interpolation are so undeniably useful that once the possibilities are seen, they can&#39;t be unseen.
[/quote]

Honestly, I’m not sure I agree with this. In Haskell, which is my main language, there are packages which implement string interpolation… and no-one uses them, because they just aren’t necessary! It’s no big deal when it’s easier to just concatenate stuff together.
[/quote]

To pick a random example from the build helpers for &quot;CScape&quot; interpolation of some generated C code:

    emit --{
        #define ${MAYBE PREFIX}INCLUDE_PARAMS_OF_${NATIVE-NAME} \
            $[Items]; \
            assert(Get_Series_Info(level_-&gt;varlist, HOLD))
    }--

* The use of `${}` (instead of `$()` or `$&lt;&gt;`) means that the result of the expression should be [turned into a valid C identifier name](https://github.com/metaeducation/ren-c/blob/815758fb571e88591908dc94f9320581f00d9331/tools/common.r#L37)... so dashes are converted to underscores, etc.

* The use of all capitals in the `${}` escaping means that the strings generated by the expressions evaluated should be made all uppercase.

* The use of `$[]` means that items is an array, and its elements should be printed one line at a time...repeating the boilerplate leading and trailing on each line (in this case an indent on the left, and a semicolon and backslash on the right)

The template looks something like the result:

    #define INCLUDE_PARAMS_OF_IF \
        DECLARE_PARAM(1, return); \
        USED(ARG(return)); \
        DECLARE_PARAM(2, condition); \
        DECLARE_PARAM(3, branch); \
        assert(Get_Series_Info(level_-&gt;varlist, HOLD))

Without interpolation, we fall back on LOAD-able code... where spaces and quotes are required by the language itself.  This starts to lose the ability to keep track of actual spaces in the interpolated thing, plus you keep having to start and stop string delimiters on the string portions.

I&#39;m not quite sure how it would come together dialected via regular code, but it would drift away from looking like C code, at best it might look like:

    emit [
        &quot;#define &quot; &lt;c&gt; (MAYBE PREFIX) &quot;INCLUDE_PARAMS_OF_&quot; &lt;c&gt; (NATIVE-NAME) &quot; \&quot;
        &quot;    &quot; @[Items] &quot;; \&quot;
        &quot;    assert(Get_Series_Info(level_-&gt;varlist, HOLD))&quot;
    ]

*I&#39;d be hard-pressed to say the spacing was correct on inspection*.  We&#39;ve lost the intuition about where the unspaced parts are.  You can imagine it getting worse when you&#39;re building unspaced material inside a string literal.  Strings can simply be the least noisy medium when you want to see something that looks close to the result.

Anyway, with strings carrying binding, we wouldn&#39;t have to do what we do today... which is actually pass the variables (that don&#39;t live in LIB) in a block to emit:

    emit [prefix native-name items] --{  ; &lt;-- ack
        #define ${MAYBE PREFIX}INCLUDE_PARAMS_OF_${NATIVE-NAME} \
            $[Items]; \
            assert(Get_Series_Info(level_-&gt;varlist, HOLD))
    }--

So I look forward to getting rid of that.


[quote=&quot;bradrn, post:7, topic:1751&quot;]
And it’s even easier in Rebol than it is in Haskell, because there’s already a single built-in function to do everything for you:

    &gt;&gt; x: 10 y: &quot;foo&quot;
    == &quot;foo&quot;
    &gt;&gt; print ajoin [&quot;Scopes? &quot; x &quot; &quot; x &quot; &quot; x &quot; &quot; y &quot; &quot; y &quot; &quot; y]
    Scopes? 10 10 10 foo foo foo
    &gt;&gt; foo: func [x] [local: 20 ajoin [&quot;The sum is &quot; (x + local)]]
    &gt;&gt; foo 30
    == &quot;The sum is 50&quot;

I strongly prefer this approach over string concatenation, since by using sensible data structures it integrates much better with the rest of the language. (It also reduces the risk of errors from malformed strings, and potentially the equivalent of SQL injection attacks.)
[/quote]

Note that [Ren-C has DELIMIT (and UNSPACED, SPACED)](https://rebol.metaeducation.com/t/introducing-delimit/2102) instead of AJOIN... which hopefully you&#39;ll like even better.</description>
    
    <lastBuildDate>Fri, 18 Jul 2025 04:30:51 +0000</lastBuildDate>
    <category>Philosophy</category>
    <atom:link href="https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Usefulness of String Interpolation</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>I haven't gone on the warpath to convert the world to string interpolation yet, but maybe I should...</p>
<p>Here was some code from the web console, for making the message you get when you start it up:</p>
<pre><code>link: [href label] -&gt; [
    unspaced [--[&lt;a href=']-- href --[' target='_blank'&gt;]-- label --[&lt;/a&gt;]--]
]

intro-note-html: spaced [
    "&lt;div class='note'&gt;"

    "&lt;p&gt;"
    "&lt;b&gt;&lt;i&gt;Guess what...&lt;/i&gt;&lt;/b&gt; this REPL is actually written in Rebol!"
    "Check out the" (link replpad-git "bridge to JavaScript")
    "as well as the" unspaced [(link console-git "Console Module") "."]
    "While the techniques are still in early development, they show a"
    "lot of promise for JavaScript/Rebol interoperability."
    "Discuss it on the" unspaced [(link forum "Discourse forum") "."]
    "&lt;/p&gt;"

    "&lt;p&gt;&lt;i&gt;(Note: SHIFT-ENTER for multi-line code, Ctrl-Z to undo)&lt;/i&gt;&lt;/p&gt;"
    "&lt;/div&gt;"
]
</code></pre>
<p>Now here's that code, but with string interpolation:</p>
<pre><code>link: [href label] -&gt; [
    compose "&lt;a href='(href)' target='_blank'&gt;(label)&lt;/a&gt;"
]

intro-note-html: trim compose2 '{{}} --[
    &lt;div class='note'&gt;

    &lt;p&gt;
    &lt;b&gt;&lt;i&gt;Guess what...&lt;/i&gt;&lt;/b&gt; this REPL is actually written in Rebol!
    Check out the {{link replpad-git "bridge to JavaScript"}}, as well as the
    {{link console-git "Console Module"}}.  While the techniques are still in
    early development, they show a lot of promise for JavaScript/Rebol
    interoperability.  Discuss it on the {{link forum "Discourse forum"}}.
    &lt;/p&gt;

    &lt;p&gt;&lt;i&gt;(Note: SHIFT-ENTER for multi-line code, Ctrl-Z to undo)&lt;/i&gt;&lt;/p&gt;
    &lt;/div&gt;
]--
</code></pre>
<p>There are still some decisions to make about how the multi-line string literals treat leading space.  I'm tempted to say the text starts at the outermost indentation so you don't have to trim it.</p>
<p>But anyway, big step up.  Note how the <code>{{...}}</code> is used in the second interpolation to allow parentheses to be treated normally by the content.  <em>(It could have been just <code>{...}</code> but I liked making it stand out more.)</em></p>
<h2><a name="p-8535-id-like-some-kind-of-compose-machine-1" class="anchor" href="https://rebol.metaeducation.com#p-8535-id-like-some-kind-of-compose-machine-1"></a>I'd Like Some Kind of COMPOSE-MACHINE</h2>
<p>COMPOSE has the ability to specify a :PREDICATE so you can process the slots.  But I feel like what I want is something stylized a bit differently, where LINK isn't a function you create and have a binding for but a dialect where it runs a PARSE rule to generate the substitutions.</p>
<p>Something like this:</p>
<pre><code>intro-note-html: compose-machine '{{}} --[
    &lt;div class='note'&gt;

    &lt;p&gt;
    &lt;b&gt;&lt;i&gt;Guess what...&lt;/i&gt;&lt;/b&gt; this REPL is actually written in Rebol!  Check
    out the {{link replpad-git}}, as well as the {{link console-git}}.  While the
    techniques are still in early development, they show a lot of promise for
    JavaScript/Rebol interoperability.  Discuss it on the {{link forum}}.
    &lt;/p&gt;

    &lt;p&gt;&lt;i&gt;(Note: SHIFT-ENTER for multi-line code, Ctrl-Z to undo)&lt;/i&gt;&lt;/p&gt;
    &lt;/div&gt;
]-- [
    'link, let [href label]: /pack [
         'replpad-git (["bridge to JavaScript", 
             https://github.com/hostilefork/replpad-js/blob/master/replpad.r])
         'console-git (["Console Module",
             https://github.com/metaeducation/ren-c/blob/master/extensions/console/ext-console-init.r])
         'forum (["Discourse forum", https://forum.rebol.info])
     ]
     (compose "&lt;a href='(href)' target='_blank'&gt;(label)&lt;/a&gt;")
]
</code></pre>
<p>That's an approximation of what I'm thinking, and it would provide flexibility for you to define the little mini-language of your substitutions (with PARSE rules being reusable, of course)...</p>
<h2><a name="p-8535-once-you-start-using-interpolation-you-wont-go-back-2" class="anchor" href="https://rebol.metaeducation.com#p-8535-once-you-start-using-interpolation-you-wont-go-back-2"></a>Once You Start Using Interpolation, You Won't Go Back!</h2>
          <p><a href="https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114/7">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114/7</link>
        <pubDate>Fri, 18 Jul 2025 04:30:51 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2114-7</guid>
        <source url="https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114.rss">Usefulness of String Interpolation</source>
      </item>
      <item>
        <title>Usefulness of String Interpolation</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="BlackATTR" data-post="5" data-topic="2114">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/blackattr/48/204_2.png" class="avatar"> BlackATTR:</div>
<blockquote>
<p>file munging/wrangling.</p>
</blockquote>
</aside>
<p>Functional interpolation gets closer to being able to compete with things like bash.</p>
<p>I think Ren-C is starting to look like a contender for this domain, in a way that it wasn't before.</p>
<p>A variant of INTERPOLATE that treats $VAR as "lookup in environment" would be useful... something that could substitute the evaluator's dispatch in that case.</p>
          <p><a href="https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114/6">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114/6</link>
        <pubDate>Wed, 26 Mar 2025 00:42:20 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2114-6</guid>
        <source url="https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114.rss">Usefulness of String Interpolation</source>
      </item>
      <item>
        <title>Usefulness of String Interpolation</title>
        <dc:creator><![CDATA[BlackATTR]]></dc:creator>
        <description><![CDATA[
            <p>Wowzers, cool stuff. This is immensely useful for the kind of scripting I do -- file munging/wrangling.</p>
          <p><a href="https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114/5">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114/5</link>
        <pubDate>Wed, 26 Mar 2025 00:21:13 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2114-5</guid>
        <source url="https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114.rss">Usefulness of String Interpolation</source>
      </item>
      <item>
        <title>Usefulness of String Interpolation</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>So now there is INTERPOLATE.</p>
<pre><code>&gt;&gt; num: 1000

&gt;&gt; interpolate "Hello (num + 20) World!"
== "Hello 1020 World!"
</code></pre>
<p>It's the "bad boy" environment-capturing primitive, that does what most natives should avoid--sniffing the evaluator's concept of "current context" and reacting to that.  (You usually don't want functions to be doing this, they should be reacting solely to their parameters.)</p>
<p>Besides capturing the context, <a href="https://rebol.metaeducation.com/t/envelop-and-compose-by-example/2294/2">it's a synonym for if you'd written <strong>compose2 @() ...</strong></a>.  COMPOSE2 is what you want use to change the delimiters or do other customizations... just use an <code>@list</code> form to capture the binding and tell COMPOSE2 you want to use the binding of that list:</p>
<pre><code>&gt;&gt; num: 1000

&gt;&gt; compose2 @{{}} "Hello {{num + 20}} World!"
== "Hello 1020 World!"
</code></pre>
<h2><a name="p-8080-taking-interpolate-stratospheric-1" class="anchor" href="https://rebol.metaeducation.com#p-8080-taking-interpolate-stratospheric-1"></a>Taking INTERPOLATE Stratospheric</h2>
<p>One of the first things I did was fix the historical behavior of URL!</p>
<pre><code>rebol2&gt;&gt; load "http://(domain)/example.txt"
== [http:// (domain) /example.txt]
</code></pre>
<p>So URL! now matches parentheses:</p>
<pre><code>&gt;&gt; rev: 'info.rebol.forum

&gt;&gt; url: https://(reverse of rev)/t/usefulness-of-string-interpolation/2114

&gt;&gt; interpolate url
== https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114
</code></pre>
<p>That works now, but I also plan to adjust the scanner to let you put parentheses or other delimiters before the :// ...</p>
<pre><code>&gt;&gt; url: transcode "[protocol]://example.com"
== [protocol]://example.com

&gt;&gt; protocol: 'https

&gt;&gt; compose2 $[] url
== https://example.com
</code></pre>
<p>This made me realize that my dreams of giving FILE! "teeth" may be actualizable... <em>INTERPOLATE can have special behavior if what you're working with is a file</em>.</p>
<p>What I've always wanted to enforce is that if you put FILE! into FILE! where a slash is, that the thing you put in has a slash:</p>
<pre><code>&gt;&gt; some-dir: %home/

&gt;&gt; interpolate %(some-dir)/something.txt
== %home/something.txt

&gt;&gt; interpolate %(bad-dir)something.txt
** Error: FILE! interpolation slash calculus mismatch: %home/

&gt;&gt; bad-dir: %home  ; no slash, not a dir

&gt;&gt; interpolate %(bad-dir)/something.txt
** Error: FILE! interpolation slash calculus mismatch: %home

&gt;&gt; interpolate %(bad-dir)-something.txt
== home-something.txt
</code></pre>
<p>The idea is that you know from the template whether you're introducing a directory or not.  This is all to bring sanity to the process--if you don't want sanity, use a plain string and turn it into a FILE! later.  I just want "sanity out of the box".</p>
<p>The same rules would apply to PATH! if you're using them as a proxy for files:</p>
<pre><code>&gt;&gt; path-dir: 'home/

&gt;&gt; interpolate %(path-dir)/something.txt
== %home/something.txt

&gt;&gt; interpolate %(path-dir)/something.txt
** Error: FILE! interpolation slash calculus mismatch: home/
</code></pre>
<p>I don't know that it would apply to WORD! substitutions, as they are kind of another beast.  They can't have internal slashes so they don't have the same kinds of problems, so this is probably legal:</p>
<pre><code>&gt;&gt; word-dir: 'home

&gt;&gt; interpolate %(word-dir)/something.txt
== %home/something.txt
</code></pre>
<p>I think TEXT! could similarly duck the rules, as long as it didn't have any internal slashes in the substitution:</p>
<pre><code>&gt;&gt; text-dir: "home"

&gt;&gt; interpolate %(text-dir)/something.txt
== %home/something.txt

&gt;&gt; text-dir: "home/hostilefork"

&gt;&gt; interpolate %(text-dir)/something.txt
** Error: FILE! interpolation slash calculus mismatch: home/hostilefork

&gt;&gt; text-dir: "home/hostilefork/"

&gt;&gt; interpolate %(text-dir)/something.txt
== home/hostilefork/something.txt
</code></pre>
<h2><a name="p-8080-default-tag-scanning-needs-supertag-2" class="anchor" href="https://rebol.metaeducation.com#p-8080-default-tag-scanning-needs-supertag-2"></a>Default TAG! Scanning Needs "Supertag"</h2>
<p>Historical Rebol/Red tag doesn't enter a paired scan mode when it sees parentheses and such:</p>
<pre><code>red&gt;&gt; tag: &lt;foo=(1 &gt; 2) bar=(3 &lt; 4)&gt;
*** Syntax Error: (line 1) missing ( at ) bar=(3 &lt; 4)&gt;
</code></pre>
<p>It thinks the first tag is <strong><code>&lt;foo=(1 &gt;</code></strong> and gets confused after that.</p>
<p>When I first was giving feedback on the design of Rebol/Red I proposed something I called <em><strong>SuperTag!</strong></em>, which people didn't seem to like but only Ladislav remarked on it, without defending the objection:</p>
<p><a href="https://github.com/metaeducation/rebol-issues/issues/2234" class="inline-onebox">SuperTAG!: upon a " { ( [ &lt; in tag content, validate substring via Rebol lexer · Issue #2234 · metaeducation/rebol-issues · GitHub</a></p>
<p>Given my proposal that PRINT be cued by TAG! to do interpolation, I think we should indeed make SuperTag the default:</p>
<pre><code>&gt;&gt; print &lt;Supertag should be the (if 2 &gt; 1 [reverse "tluafed"])!&gt;
Supertag should be the default!
</code></pre>
<p>But only <em>if you are using the basic no dashes delimiter form of tag</em>.  That means you can still make weird tags, you just have to use <strong><code>-&lt;...&gt;-</code></strong>.</p>
<pre><code>&gt;&gt; &lt;)))&gt;
** Error: Unexpected ) in TAG! scanning (use -&lt;...&gt;- if intentional)

&gt;&gt; -&lt;)))&gt;-
== -&lt;)))&gt;-
</code></pre>
<p>This gives me pause to wonder if we should also make SuperString the default (?)</p>
<pre><code>&gt;&gt; "}}}"
** Error: Unexpected } in TEXT! scanning (use -"..."- if intentional)
</code></pre>
<p>You'd then be able to use strings inside escapes:</p>
<pre><code>&gt;&gt; interpolate "You could do cool (reverse "ffuts")!"
You could do cool stuff!
</code></pre>
<p>It would make literals for delimiters longer than we'd like.  You already can't use things like <strong><code>#[</code></strong> as a character constant, but have to say <strong><code>#"["</code></strong>, so it's usually preferred to say "[", but now you'd have to say <code>-"["-</code> which is 5 characters to get 1.</p>
<p>But I've been thinking <a href="https://rebol.metaeducation.com/t/taking-delimiters-literally-in-the-issue-datatype/2386">maybe we should let <code>#[</code> and <code>#}</code> be character literals</a>, and sacrifice the <strong><code>#[...]</code></strong> "construction syntax" and the <strong><code>#{...}</code></strong> for BINARY!.  It's very speculative and requires a bit of a perception change, but it may be a better idea than it seems on the surface.</p>
<h2><a name="p-8080-crazy-fun-times-3" class="anchor" href="https://rebol.metaeducation.com#p-8080-crazy-fun-times-3"></a>Crazy Fun Times</h2>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/zany_face.png?v=14" title=":zany_face:" class="emoji only-emoji" alt=":zany_face:" loading="lazy" width="20" height="20"></p>
<p>This is introducing some constraints on the types.  But without constraints and just saying "oh, they're just arbitrary strings" then you can't get that much leverage.</p>
<p><a href="http://blog.hostilefork.com/freedom-to-and-freedom-from/" class="inline-onebox">philosophy : "Freedom To" and "Freedom From" in Software Architecture</a></p>
<p>If you want an arbitrary string, use TEXT!.</p>
<p>As with the <strong>-&lt;...&gt;-</strong> tag form, there can be workarounds for the "putting anything you want" syntaxes.</p>
          <p><a href="https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114/4</link>
        <pubDate>Tue, 25 Mar 2025 23:47:58 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2114-4</guid>
        <source url="https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114.rss">Usefulness of String Interpolation</source>
      </item>
      <item>
        <title>Usefulness of String Interpolation</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2114">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>To pick a random example from the build helpers for "CScape" interpolation of some generated C code:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">emit --{
    #define ${MAYBE PREFIX}INCLUDE_PARAMS_OF_${NATIVE-NAME} \
        $[Items]; \
        assert(Get_Series_Info(level_-&gt;varlist, HOLD))
}--
</code></pre>
</blockquote>
</aside>
<p>OK, this is a lot more powerful than the string interpolation I’m used to. I can see why you’d want this — it fits in very well with the general idea of dialecting.</p>
<p>(Personally, I’m not at all averse to templating via concatenation, as in <a href="https://github.com/bradrn/wlhs/blob/fbe8789c0885f3db7b53423a12770a63a92547a1/Setup.hs#L76">this code of mine</a> from two days ago. But Haskell isn’t Rebol.)</p>
          <p><a href="https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114/2</link>
        <pubDate>Thu, 11 Jan 2024 07:05:48 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2114-2</guid>
        <source url="https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114.rss">Usefulness of String Interpolation</source>
      </item>
      <item>
        <title>Usefulness of String Interpolation</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="bradrn" data-post="7" data-topic="1751">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/rebol-and-scopes-well-why-not/1751/7">Rebol And Scopes: Well, Why Not?</a></div>
<blockquote>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1751">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/rebol-and-scopes-well-why-not/1751/1">Rebol And Scopes: Well, Why Not?</a></div>
<blockquote>
<p>Features based on string interpolation are so undeniably useful that once the possibilities are seen, they can't be unseen.</p>
</blockquote>
</aside>
<p>Honestly, I’m not sure I agree with this. In Haskell, which is my main language, there are packages which implement string interpolation… and no-one uses them, because they just aren’t necessary! It’s no big deal when it’s easier to just concatenate stuff together.</p>
</blockquote>
</aside>
<p>To pick a random example from the build helpers for "CScape" interpolation of some generated C code:</p>
<pre><code>emit --{
    #define ${MAYBE PREFIX}INCLUDE_PARAMS_OF_${NATIVE-NAME} \
        $[Items]; \
        assert(Get_Series_Info(level_-&gt;varlist, HOLD))
}--
</code></pre>
<ul>
<li>
<p>The use of <code>${}</code> (instead of <code>$()</code> or <code>$&lt;&gt;</code>) means that the result of the expression should be <a href="https://github.com/metaeducation/ren-c/blob/815758fb571e88591908dc94f9320581f00d9331/tools/common.r#L37">turned into a valid C identifier name</a>... so dashes are converted to underscores, etc.</p>
</li>
<li>
<p>The use of all capitals in the <code>${}</code> escaping means that the strings generated by the expressions evaluated should be made all uppercase.</p>
</li>
<li>
<p>The use of <code>$[]</code> means that items is an array, and its elements should be printed one line at a time...repeating the boilerplate leading and trailing on each line (in this case an indent on the left, and a semicolon and backslash on the right)</p>
</li>
</ul>
<p>The template looks something like the result:</p>
<pre><code>#define INCLUDE_PARAMS_OF_IF \
    DECLARE_PARAM(1, return); \
    USED(ARG(return)); \
    DECLARE_PARAM(2, condition); \
    DECLARE_PARAM(3, branch); \
    assert(Get_Series_Info(level_-&gt;varlist, HOLD))
</code></pre>
<p>Without interpolation, we fall back on LOAD-able code... where spaces and quotes are required by the language itself.  This starts to lose the ability to keep track of actual spaces in the interpolated thing, plus you keep having to start and stop string delimiters on the string portions.</p>
<p>I'm not quite sure how it would come together dialected via regular code, but it would drift away from looking like C code, at best it might look like:</p>
<pre><code>emit [
    "#define " &lt;c&gt; (MAYBE PREFIX) "INCLUDE_PARAMS_OF_" &lt;c&gt; (NATIVE-NAME) " \"
    "    " @[Items] "; \"
    "    assert(Get_Series_Info(level_-&gt;varlist, HOLD))"
]
</code></pre>
<p><em>I'd be hard-pressed to say the spacing was correct on inspection</em>.  We've lost the intuition about where the unspaced parts are.  You can imagine it getting worse when you're building unspaced material inside a string literal.  Strings can simply be the least noisy medium when you want to see something that looks close to the result.</p>
<p>Anyway, with strings carrying binding, we wouldn't have to do what we do today... which is actually pass the variables (that don't live in LIB) in a block to emit:</p>
<pre><code>emit [prefix native-name items] --{  ; &lt;-- ack
    #define ${MAYBE PREFIX}INCLUDE_PARAMS_OF_${NATIVE-NAME} \
        $[Items]; \
        assert(Get_Series_Info(level_-&gt;varlist, HOLD))
}--
</code></pre>
<p>So I look forward to getting rid of that.</p>
<aside class="quote no-group quote-modified" data-username="bradrn" data-post="7" data-topic="1751">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/rebol-and-scopes-well-why-not/1751/7">Rebol And Scopes: Well, Why Not?</a></div>
<blockquote>
<p>And it’s even easier in Rebol than it is in Haskell, because there’s already a single built-in function to do everything for you:</p>
<pre><code>&gt;&gt; x: 10 y: "foo"
== "foo"
&gt;&gt; print ajoin ["Scopes? " x " " x " " x " " y " " y " " y]
Scopes? 10 10 10 foo foo foo
&gt;&gt; foo: func [x] [local: 20 ajoin ["The sum is " (x + local)]]
&gt;&gt; foo 30
== "The sum is 50"
</code></pre>
<p>I strongly prefer this approach over string concatenation, since by using sensible data structures it integrates much better with the rest of the language. (It also reduces the risk of errors from malformed strings, and potentially the equivalent of SQL injection attacks.)</p>
</blockquote>
</aside>
<p>Note that <a href="https://rebol.metaeducation.com/t/introducing-delimit/2102">Ren-C has DELIMIT (and UNSPACED, SPACED)</a> instead of AJOIN... which hopefully you'll like even better.</p>
          <p><a href="https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114/1</link>
        <pubDate>Thu, 11 Jan 2024 01:39:48 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2114-1</guid>
        <source url="https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114.rss">Usefulness of String Interpolation</source>
      </item>
      <item>
        <title>Usefulness of String Interpolation</title>
        <dc:creator><![CDATA[Brett]]></dc:creator>
        <description><![CDATA[
            <p>Reminds me of <a href="https://www.stringtemplate.org/">StringTemplate</a> - which I have never used, but thought was interesting.</p>
          <p><a href="https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114/3</link>
        <pubDate>Fri, 05 Nov 2021 23:11:43 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2114-3</guid>
        <source url="https://rebol.metaeducation.com/t/usefulness-of-string-interpolation/2114.rss">Usefulness of String Interpolation</source>
      </item>
  </channel>
</rss>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Strict Equality, Lax Equality, Equivalence, Sameness - Semantics - AltRebol</title>
    <meta name="description" content="Rebol has historically had a lot of trouble with questions of equality, and various hierarchies of it.  It got deep into the weeds: the idea of EQUIV? even came up, which was to check to see if two blocks of code weren&amp;#39;t&amp;hellip;">
    <meta name="generator" content="Discourse 3.5.0.beta6-dev - https://github.com/discourse/discourse version 623cde985b21c2ed812b83d3ea94f69231613718">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/1X/cbd70027b53fa165575e5b665f00eb3b8ae7ea31_2_32x32.ico">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d_2_180x180.png">
<meta name="theme-color" media="all" content="#fff">

<meta name="color-scheme" content="light">

<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, viewport-fit=cover">
<link rel="canonical" href="../strict-equality-lax-equality-equivalence-sameness-is-and/349.html" />

<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="AltRebol Search">

    <link href="https://rebol.metaeducation.com/stylesheets/color_definitions_base__2_ceb61c279a74dfa3cef6a62f7784988102abec82.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" class="light-scheme"/>

<link href="https://rebol.metaeducation.com/stylesheets/common_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="common"  />

  <link href="https://rebol.metaeducation.com/stylesheets/desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="desktop"  />



    <link href="https://rebol.metaeducation.com/stylesheets/chat_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="chat"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-details_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-details"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-lazy-videos_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-lazy-videos"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-local-dates_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-local-dates"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-narrative-bot_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-narrative-bot"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-presence_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-presence"  />
    <link href="https://rebol.metaeducation.com/stylesheets/docker_manager_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="docker_manager"  />
    <link href="https://rebol.metaeducation.com/stylesheets/footnote_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="footnote"  />
    <link href="https://rebol.metaeducation.com/stylesheets/poll_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="poll"  />
    <link href="https://rebol.metaeducation.com/stylesheets/spoiler-alert_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="spoiler-alert"  />
    <link href="https://rebol.metaeducation.com/stylesheets/chat_desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="chat_desktop"  />
    <link href="https://rebol.metaeducation.com/stylesheets/poll_desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="poll_desktop"  />

  <link href="https://rebol.metaeducation.com/stylesheets/common_theme_2_57fe803ed5a41e9f7d94086afaf66a1aab57d9ae.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="common_theme" data-theme-id="2" data-theme-name="default"/>
    

    
    
        <link rel="alternate nofollow" type="application/rss+xml" title="RSS feed of &#39;Strict Equality, Lax Equality, Equivalence, Sameness&#39;" href="349.rss" />
    <meta property="og:site_name" content="AltRebol" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:image" content="https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:url" content="https://rebol.metaeducation.com/t/strict-equality-lax-equality-equivalence-sameness/349" />
<meta name="twitter:url" content="https://rebol.metaeducation.com/t/strict-equality-lax-equality-equivalence-sameness/349" />
<meta property="og:title" content="Strict Equality, Lax Equality, Equivalence, Sameness" />
<meta name="twitter:title" content="Strict Equality, Lax Equality, Equivalence, Sameness" />
<meta property="og:description" content="Rebol has historically had a lot of trouble with questions of equality, and various hierarchies of it.  It got deep into the weeds: the idea of EQUIV? even came up, which was to check to see if two blocks of code weren&#39;t just STRICT-EQUAL? but if the words in them had the same bindings.  â˜¹  (I killed off EQUIV? in Ren-C pretty early because I couldn&#39;t think of any reasonable application of the knowledge you&#39;d be getting out of it.)  Lax Equality By Default Has Bothered A Lot Of People O..." />
<meta name="twitter:description" content="Rebol has historically had a lot of trouble with questions of equality, and various hierarchies of it.  It got deep into the weeds: the idea of EQUIV? even came up, which was to check to see if two blocks of code weren&#39;t just STRICT-EQUAL? but if the words in them had the same bindings.  â˜¹  (I killed off EQUIV? in Ren-C pretty early because I couldn&#39;t think of any reasonable application of the knowledge you&#39;d be getting out of it.)  Lax Equality By Default Has Bothered A Lot Of People O..." />
<meta property="og:article:section" content="Development" />
<meta property="og:article:section:color" content="25AAE2" />
<meta property="og:article:section" content="Semantics" />
<meta property="og:article:section:color" content="25AAE2" />
<meta name="twitter:label1" value="Reading time" />
<meta name="twitter:data1" value="5 mins ðŸ•‘" />
<meta name="twitter:label2" value="Likes" />
<meta name="twitter:data2" value="2 â¤" />
<meta property="article:published_time" content="2017-10-23T03:32:07+00:00" />
<meta property="og:ignore_canonical" content="true" />


    
  </head>
  <body class="crawler ">
    
    <header>
  <a href="https://rebol.metaeducation.com/">AltRebol</a>
</header>

    <div id="main-outlet" class="wrap" role="main">
        <div id="topic-title">
    <h1>
      <a href="../strict-equality-lax-equality-equivalence-sameness-is-and/349.html">Strict Equality, Lax Equality, Equivalence, Sameness</a>
    </h1>

      <div class="topic-category" itemscope itemtype="http://schema.org/BreadcrumbList">
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://rebol.metaeducation.com/c/development/semantics/55" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #25AAE2'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Development</span>
              </span>
            </a>
            <meta itemprop="position" content="1" />
          </span>
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://rebol.metaeducation.com/c/development/semantics/55" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #25AAE2'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Semantics</span>
              </span>
            </a>
            <meta itemprop="position" content="2" />
          </span>
      </div>

  </div>

  

    <div itemscope itemtype='http://schema.org/DiscussionForumPosting'>
      <meta itemprop='headline' content='Strict Equality, Lax Equality, Equivalence, Sameness'>
      <link itemprop='url' href='../strict-equality-lax-equality-equivalence-sameness-is-and/349.html'>
      <meta itemprop='datePublished' content='2017-10-23T03:32:07Z'>
        <meta itemprop='articleSection' content='Semantics'>
      <meta itemprop='keywords' content=''>
      <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
        <meta itemprop='name' content='AltRebol'>
          <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
            <meta itemprop='url' content='https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
          </div>
      </div>


          <div id='post_1'  class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>

                <link itemprop="mainEntityOfPage" href="../strict-equality-lax-equality-equivalence-sameness-is-and/349.html">


              <span class="crawler-post-infos">
                  <time  datetime='2017-10-23T03:32:07Z' class='post-time'>
                    October 23, 2017,  3:32am
                  </time>
                  <meta itemprop='dateModified' content='2025-04-29T01:52:15Z'>
              <span itemprop='position'>1</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>Rebol has historically had a lot of trouble with questions of equality, and various hierarchies of it.  It got deep into the weeds: the idea of EQUIV? even came up, which was to check to see if two blocks of code weren't just STRICT-EQUAL? but if the words in them had the same bindings.  <img src="../../images/emoji/twitter/frowning.png%3Fv=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p><em>(I killed off EQUIV? in Ren-C pretty early because I couldn't think of any reasonable application of the knowledge you'd be getting out of it.)</em></p>
<h2><a name="p-1470-lax-equality-by-default-has-bothered-a-lot-of-people-1" class="anchor" href="../strict-equality-lax-equality-equivalence-sameness-is-and/349.html#p-1470-lax-equality-by-default-has-bothered-a-lot-of-people-1"></a>Lax Equality By Default Has Bothered A Lot Of People</h2>
<p>One of the worst and most memorable cases I've run into wound up leading to a day (or more) of debugging some code while trying to port Red to R3-Alpha.  A tag and a string were considered equal, not to mention the casing being ignored:</p>
<pre><code>r3-alpha&gt;&gt; &lt;fOo&gt; = "FoO"
== true
</code></pre>
<p>But the rules for comparisons of individual items didn't match the rules for items being compared in blocks.  Check out this behavior of R3-Alpha and Red:</p>
<pre><code>red&gt;&gt; &lt;abc&gt; = %ABC
== true

red&gt;&gt; (first [def:]) = 'def
== true

red&gt;&gt; "ghi" = &lt;GhI&gt;
== true

red&gt;&gt; [&lt;abc&gt; def: "ghi"] = [%ABC 'def &lt;GhI&gt;] 
== false
</code></pre>
<p><img src="../../images/emoji/twitter/nauseated_face.png%3Fv=14" title=":nauseated_face:" class="emoji only-emoji" alt=":nauseated_face:" loading="lazy" width="20" height="20"></p>
<p><em>This is pretty clearly bad mojo, and needs to get sorted out.</em></p>
<h2><a name="p-1470-and-and-and-are-incoherent-2" class="anchor" href="../strict-equality-lax-equality-equivalence-sameness-is-and/349.html#p-1470-and-and-and-are-incoherent-2"></a><code>=</code> and <code>==</code> and <code>!=</code> and <code>!==</code> are Incoherent</h2>
<p>You shouldn't have to say <strong>==</strong> to get a level of rigor that <em>makes sense to a programmer</em>.</p>
<p>Besides "Rebol shouldn't look like C", there's another reason to hate how these operators work today.  <strong><a href="http://www.rebol.net/cgi-bin/r3blog.r?view=0017#comments">Rebol 3 introduced != as a synonym for &lt;&gt;.</a></strong>  In the C language <strong>==</strong> and <strong>!=</strong> are complements, but given Rebol having distinct equality meanings for = and == <strong>it means that the real complement to <code>==</code> is <code>!==</code></strong>.  That's just going to confuse people.</p>
<p>Plus the more I think of the aesthetic properties of code, the more I don't like <strong>==</strong> serving this role.  It looks like a header or barrier than an operator, and even with C experience I kind of cringe at seeing it used for equality in Rebol code.  There are better applications:</p>
<pre><code>==: function [:label [string!] :terminal [word!]] [
    unless '== is terminal [
        fail ["== expects string followed by ==, not" terminal]
    ]
    if verbosity = 2 [
        print ["==" label "=="]
    ]
]

== {Section Two} ==
</code></pre>
<p>So I suggested rethinking things so <strong>=</strong> would be strict, and other words would serve as lax equality...such as <strong>LIKE</strong> and <strong>UNLIKE</strong>.</p>
<pre><code>&gt;&gt; "a" like first "ABC"
== #[true]

&gt;&gt; 1.0 like 1
== #[true]
</code></pre>
<p><em>(Note: <a href="https://rebol.metaeducation.com/t/is-and-isnt-vs-and-friends/1133">I actually originally pushed for IS and ISN'T</a> as lax equality words, but was convinced they are "more strict sounding" than equal and not equal.)</em></p>
<h2><a name="p-1470-what-equality-is-used-by-operations-3" class="anchor" href="../strict-equality-lax-equality-equivalence-sameness-is-and/349.html#p-1470-what-equality-is-used-by-operations-3"></a>What Equality Is Used By Operations?</h2>
<p>If we have a difference between EQUAL? and LIKE?, we can ask what natives like SWITCH are using by default.  <em>(It seems it should do whatever <strong>=</strong> does, doesn't it?)</em></p>
<p>But then, what about picking elements out of blocks?  For instance:</p>
<pre><code>red&gt;&gt; block: [foo 10 bar 20 baz: 30]

red&gt;&gt; block/bar
== 20

red&gt;&gt; block/baz
== 30
</code></pre>
<p>Is this coming from use of some equality testing operator, that thinks WORD! is equal to SET-WORD! of the same spelling?</p>
<p>Since Ren-C has evolved such that "PICKing" and "POKEing" are driven by the same code that does paths (hence "path picking" and not "path selection"), we might say that only SET-WORD!s are considered candidates for picked words:</p>
<pre><code>&gt;&gt; block: [foo: bar bar: 20 baz: 30]

&gt;&gt; foo/bar
== 20   ; not `bar:`
</code></pre>
<hr>
<p><strong>UPDATE:</strong> This particular question became its own thread: <strong><a href="../block-and-object-parity-in-pathing-picking/1086.html">BLOCK! and OBJECT! Parity In Pathing/Picking</a></strong></p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

                <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../prefix-approx-modifier-would-it-be-possible/2428.html">Prefix APPROX Modifier... Would It Be Possible?</a>
                        <meta itemprop='position' content='3'>
                      </div>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../tapping-the-untapped-potential-of-short-words/395.html">Tapping The Untapped Potential of Short Words</a>
                        <meta itemprop='position' content='4'>
                      </div>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../retaking-and-how-to-get-the-old-functionality/474.html">Retaking ++ and -- : how to get the old functionality?</a>
                        <meta itemprop='position' content='5'>
                      </div>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../theory-of-symbols-and-repurposing-and/834/4.html">Theory of Symbols and Repurposing `? ?` and `! !`</a>
                        <meta itemprop='position' content='6'>
                      </div>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../making-the-case-for-caselessness/868.html">Making the Case for Caselessness</a>
                        <meta itemprop='position' content='7'>
                      </div>
                </div>
          </div>
          <div id='post_19' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/rgchris'><span itemprop='name'>rgchris</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2017-10-29T22:43:00Z' class='post-time'>
                    October 29, 2017, 10:43pm
                  </time>
                  <meta itemprop='dateModified' content='2025-04-29T01:55:21Z'>
              <span itemprop='position'>19</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <ul>
<li>
<p>I don't have issues with stricter equality. Some synonyms for loose behaviour: ALIKE? SIMILAR?</p>
</li>
<li>
<p>For /STRICT, might suggest SWITCH/PRECISE, or SWITCH/EXACT</p>
</li>
<li>
<p>Whatever form <em>loose</em> equality might take, I do wonder of the relative perils of:</p>
<p><code>string! is/nearly first [string!]</code></p>
<p>where:</p>
<p><code>'foo is/nearly first [foo:]</code></p>
<p>The potential benefits for a loose-by-default SWITCH statement for this idiom seem useful where currently awkward conventions fill that space.</p>
</li>
</ul>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

                <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../block-and-object-parity-in-pathing-picking/1086/5.html">BLOCK! and OBJECT! Parity in Pathing/Picking</a>
                        <meta itemprop='position' content='1'>
                      </div>
                </div>
          </div>
          <div id='post_20' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2025-03-22T18:05:27Z' class='post-time'>
                    March 22, 2025,  6:05pm
                  </time>
                  <meta itemprop='dateModified' content='2025-04-29T06:45:41Z'>
              <span itemprop='position'>20</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>It's been many years, with only a small amount of movement on this...</p>
<p>But it's long past time to kill off <code>==</code>.</p>
<h2><a name="p-8059-i-think-it-has-emerged-that-plain-should-be-strict-1" class="anchor" href="../strict-equality-lax-equality-equivalence-sameness-is-and/349.html#p-8059-i-think-it-has-emerged-that-plain-should-be-strict-1"></a>I Think It Has Emerged That Plain = Should Be Strict</h2>
<p>For some time now, Ren-C has been case-sensitive in terms of binding.  It was a change I made to see how it would work out... and I haven't seen any evidence that it hasn't.  So I don't know if this is going to be reversed.</p>
<p><a href="http://blog.hostilefork.com/making-the-case-for-caselessness/">I've written about the best defense of case-insensitivity I could think of</a>, but even having done so... there are a lot of problems associated with it.</p>
<p>If case-insensitive binding were to come back, it is likely that all casing would need to be canonized to the lowercase form, in binding-relevant places, e.g.:</p>
<pre><code>&gt;&gt; make object! [Foo: 1020]
== #[object! [foo: 1020]]
</code></pre>
<p>But there's a lot of downside to that, and you're looking at incompatibility with JSON and basically any other modern language you might find you like to model.  I think it's been more of a liability than an asset (again, having played devil's advocate pretty strongly with my writeup).</p>
<p>Anyway, even in the unlikely event of case-insensitivity returning to Ren-C binding... I still am fairly positive: <strong>EQUAL? (=) should mean equality of casing and equality of datatype.</strong></p>
<h2><a name="p-8059-likeunlike-seem-a-decent-relaxed-equality-pair-2" class="anchor" href="../strict-equality-lax-equality-equivalence-sameness-is-and/349.html#p-8059-likeunlike-seem-a-decent-relaxed-equality-pair-2"></a>LIKE/UNLIKE Seem A Decent "Relaxed Equality" Pair</h2>
<p>LIKE is not an insane amount of typing for when that's your intent.  And UNLIKE may look a little weird, but it's not that bad:</p>
<pre><code>&gt;&gt; "a" unlike &lt;a&gt;
== ~null~  ; anti
</code></pre>
<p>You could always write <strong><code>if not "a" like &lt;a&gt; [...]</code></strong> if you find the UN offputting.</p>
<p>There's a bit of existing understanding from SQL of LIKE as being <a href="https://en.wikipedia.org/wiki/Glob_(programming)">more akin to "globbing"</a>, which would be:</p>
<pre><code>&gt;&gt; "abc" like "a*"
== ~okay~  ; anti
</code></pre>
<p>But we use a lot of words differently and aren't owed a debt to that.  And if we have globbing, there's no reason to not just call it GLOB.</p>
<pre><code>&gt;&gt; glob "a*" "abc"
== ~okay~  ; anti
</code></pre>
<h2><a name="p-8059-how-alike-counts-as-like-3" class="anchor" href="../strict-equality-lax-equality-equivalence-sameness-is-and/349.html#p-8059-how-alike-counts-as-like-3"></a>How Alike Counts As LIKE?</h2>
<p>Well...there's being different types, but having the same content:</p>
<pre><code>&gt;&gt; "a" like &lt;a&gt;
== ~okay~  ; anti
</code></pre>
<p>Then there's being the same type, but having different casing:</p>
<pre><code>&gt;&gt; "FoO" like "fOo"
== ~okay~  ; anti
</code></pre>
<p>I'm skeptical of the usefulness of an operator combining both of these being terribly useful... when does this <em>really</em> come up?</p>
<pre><code>&gt;&gt; &lt;FoO&gt; like "fOo"
== ~okay~  ; anti
</code></pre>
<p>Despite being the default Redbol (or at least Red) behavior for equality, it's rare enough that I don't mind if it's not particularly easy to express.</p>
<p>(In the few cases I don't want to test for exact equality...) <strong>...it is overwhelmingly more common for me to want to compare unlike types with the same content, than I want to do case-insensitive comparisons.</strong>  Biggest example is wanting to see if <strong><code>foo:</code></strong> and <strong><code>foo</code></strong> match spellings <em>very</em> often...but the more into dialecting you get, you have cases like <strong><code>foo:</code></strong> and <strong><code>&lt;foo&gt;</code></strong></p>
<p>It's nice when an operator takes the guesswork out of the efficiency of conversions.  Consider if you have a TEXT! you want to compare with a WORD!.  The "smart" way to do that is to alias the WORD! as a TEXT!:</p>
<pre><code>(as text! word) = text
</code></pre>
<p>That's smart because due to the way the internals work, it can use the same memory allocation that backs the UTF-8 of the word and aliasing it as a read-only TEXT!.  If you did it the other way:</p>
<pre><code>word = (as word! text)
</code></pre>
<p>You're having to hash the text to look up if there's a symbol registered for it, and it creates the symbol if it's not there.  So you're paying extra for the lookup -and- possibly creating a useless symbol table entry for the text.  But <strong><code>word like text</code></strong> could just be naturally efficient under the hood.</p>
<p>As someone who really wants to advocate for the interests of dialect authors, I've spoken about how important it is to be able to push values around between the different "parts of speech" to get them out of band of one another without losing information.  And this ties into that.  I fully expect the surrounding code to have already established what the types are:</p>
<pre><code> if (tag? item) and (item like wordtable.(n)) [...]
</code></pre>
<h2><a name="p-8059-but-then-what-about-case-insensitivity-4" class="anchor" href="../strict-equality-lax-equality-equivalence-sameness-is-and/349.html#p-8059-but-then-what-about-case-insensitivity-4"></a>But Then, What About Case-Insensitivity?</h2>
<p>It seems a bad plan to pick other "wishy-washy" words such as <strong>x similar y</strong> to mean potentially different cases... with <strong>x like y</strong> to mean potentially different types.</p>
<p>One new tool in the box is that infix functions can now have refinements.  And we could imagine both <code>EQUAL?/=</code> and <code>LIKE?/LIKE</code> having a refinement that affords case insensitivity.</p>
<p>According to the AIs (and my life experience) there is no standardized term for differently-cased variants (in the vein of words like <code>homograph</code> or <code>synonym</code>).  Technical documents seem to go with:</p>
<ul>
<li><strong>Case-variant</strong> or <strong>casing variant</strong> â€” if you want a concise and fairly technical phrase.</li>
<li><strong>Case-insensitive match</strong> â€” if you want to highlight that the relationship depends on ignoring case.</li>
<li><strong>Case-folded equivalent</strong> â€” if you want to imply they are equivalent <em>after</em> normalizing the case.</li>
</ul>
<p>I once called differently-cased variations of WORD! <em>"synonyms"</em>.  But with the binding becoming case-insensitive, they are particularly -not- synonyms any more.  And that term was specifically for WORD! and not longer TEXT!.  <em>(Would you call "the quick brown fox" and "The QUICK brown fox" synonyms, anyway?)</em></p>
<p>In the spirit of <em>folded</em>, there is also <em>canon</em>.</p>
<pre><code>&gt;&gt; "foo" =:canon "FOO"
== ~okay~  ; anti
</code></pre>
<p><code>CANON-EQUAL?</code> is better than <code>FOLDED-EQUAL?</code> (when I think of folding in programming I'm thinking of left folds and right folds as higher order functions, not "folding cases").</p>
<p>There's :UNCASE or :NOCASE or :UNCASED (I think it's too random to say :CASE means "ignore case")</p>
<pre><code>&gt;&gt; "foo" =:uncase "FOO"
== ~okay~  ; anti

&gt;&gt; "foo" =:uncased "FOO"
== ~okay~  ; anti

&gt;&gt; "foo" =:nocase "FOO"
== ~okay~  ; anti
</code></pre>
<p>I've used <code>:RELAX</code> often to ask for less strict versions of things:</p>
<pre><code>&gt;&gt; "foo" =:relax "FOO"
== ~okay~  ; anti

&gt;&gt; "FoO" like:relax &lt;fOo&gt;
== ~okay~  ; anti
</code></pre>
<p>While that doesn't convey casing, we might argue this is a more generalized relaxing... in the case of EQUAL? meaning "relax on anything you can about this, that isn't the type".</p>
<p>Maybe these are common enough to deserve a shorthand of some kind:</p>
<pre><code>&gt;&gt; "foo" =* "FOO"
== ~okay~  ; anti

&gt;&gt; "FoO" like* &lt;fOo&gt;
== ~okay~  ; anti
</code></pre>
<p>Or:</p>
<pre><code>&gt;&gt; "foo" *= "FOO"
== ~okay~  ; anti

&gt;&gt; "FoO" *like &lt;fOo&gt;
== ~okay~  ; anti
</code></pre>
<p>Or:</p>
<pre><code>&gt;&gt; "foo" ?= "FOO"
== ~okay~  ; anti

&gt;&gt; "FoO" ?like &lt;fOo&gt;
== ~okay~  ; anti
</code></pre>
<p>The AIs of course suggest using <strong><code>~=</code></strong> but I'm very hesitant to allow tilde in WORD!s at all.  I feel like quaisforms "own" tildes, and I'm not crazy about quasi-words like <strong><code>~~=~</code></strong>  But it seems like it would be technically possible to say that as long as your tildes are asymmetric in a WORD!  and you hit a delimiter before another tilde, it's a WORD! <img src="../../images/emoji/twitter/frowning.png%3Fv=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<pre><code>&gt;&gt; "foo" ~= "FOO"
== ~okay~  ; anti

&gt;&gt; "FoO" ~like &lt;fOo&gt;
== ~okay~  ; anti
</code></pre>
<p>I think my instincts are screaming a litlte too strongly not to use tildes this way, and let quasiforms own them completely... so if you're eye is ever drawn to a tilde (that's not in a string) you are looking at a quasiform.</p>
<h2><a name="p-8059-raised-errors-could-do-something-here-5" class="anchor" href="../strict-equality-lax-equality-equivalence-sameness-is-and/349.html#p-8059-raised-errors-could-do-something-here-5"></a>Raised Errors Could Do... Something Here?</h2>
<p>There's a germ of an idea <img src="../../images/emoji/twitter/microbe.png%3Fv=14" title=":microbe:" class="emoji" alt=":microbe:" loading="lazy" width="20" height="20"> in one of the first thoughts I had about LIKE.  That first thought was that it would be for testing casing variations...but if you tried it with two different types you'd get an error:</p>
<pre><code>&gt;&gt; "a" like "A"
== ~okay~  ; anti

&gt;&gt; "a" like &lt;a&gt;
** (Raised) Error: Not even the same type
</code></pre>
<p>And if that's a <em>raised</em> error then you could TRY it if you want to say "I meant to do that, but want a falsey result if they're not the same type..."</p>
<pre><code>&gt;&gt; try "a" like &lt;a&gt;
== ~null~  ; anti
</code></pre>
<p>Then, the option to <code>:RELAX</code> this could relax the types.</p>
<pre><code>&gt;&gt; "a" like:relax &lt;A&gt;
== ~okay~  ; anti
</code></pre>
<p><em><strong>It's interesting, BUT...</strong></em> this version of LIKE:RELAX is something I never want (caseless comparisons of differing types).  Plus it makes LIKE something I don't use all that often (comparing two strings caselessly).</p>
<p>Yet that thought experiment did give rise to the idea of <a href="../prefix-approx-modifier-would-it-be-possible/2428.html">prescriptively disabling equality comparisons of floating point numbers completely</a>, but allowing you to apply approximating operators, hence "still use <code>=</code>".  Since that only came to my mind today, it's hard to say how much potential it really has... it does go hard, e.g. <strong><code>[1.0 foo bar] = [1 foo bar]</code></strong> would raise an error just for trying to compare.</p>
<p>But I do think this should probably be part of LIKE.  If you say <strong><code>'foo like 1020</code></strong> I don't think we're doing anyone any favors by not raising an error... INTEGER! could never have an equivalence with WORD!.  I don't know if <strong><code>1020 like [1020]</code></strong> is within the intended range of application, but... maybe it is?</p>
<h2><a name="p-8059-how-will-a-like-b-deal-with-chainetc-6" class="anchor" href="../strict-equality-lax-equality-equivalence-sameness-is-and/349.html#p-8059-how-will-a-like-b-deal-with-chainetc-6"></a>How Will (A LIKE B) Deal With CHAIN!/etc?</h2>
<p>I mentioned needing an easy way to check if <strong><code>foo:</code></strong> and <strong><code>foo</code></strong> line up without having to coerce their types (again, generally assuming we already know for instance that one is a set-word and the other is a word).</p>
<p>But there's a lot more devils in the details these days.  <strong><code>foo:</code></strong> is a CHAIN! now (not a fundamental SET-WORD! type).  The reversibility requirement of TO has introduced some equivalence-class problems.  <code>(to word! 'a:)</code> and <code>(to word! ':a)</code> can't both be reversible.  This throws a bit of a wrench into the idea of being able to say that <strong>a</strong> is "like" either <strong>:a</strong> or <strong>a:</strong></p>
<p>Right now there's a function UNCHAIN which will give you <strong><code>a</code></strong> from either <strong><code>:a</code></strong> or <strong><code>a:</code></strong>.  And RESOLVE is something I've been using as a more general thing, that can give you <strong><code>a.b</code></strong> from more complex things like  <strong><code>/a.b:</code></strong>.  Might we say that LIKE is more <em>resolve-like</em> than it is a <em>to-equivalence-like</em> ?</p>
<pre><code>&gt;&gt; (first of [/a.b:]) like (first of [a.b])
== ~okay~  ; anti
</code></pre>
<p>On the surface this feels more useful, but it starts to make LIKE seem as if it's gotten feature creep and gone way out of control.  If you mean <strong><code>x = resolve y</code></strong> maybe you should just say that.</p>
<p>But this narrows LIKE a fair bit, to where <strong><code>foo</code></strong> won't be like <strong><code>foo:</code></strong> after all... and as I sugested <strong><code>foo like 1020</code></strong> is probably better raising an error than being falsey, it would likely be best to raise an error comparing WORD! with CHAIN! if they could never actually be "like".</p>
<h2><a name="p-8059-so-theres-some-long-thoughts-7" class="anchor" href="../strict-equality-lax-equality-equivalence-sameness-is-and/349.html#p-8059-so-theres-some-long-thoughts-7"></a>So There's Some Long... Thoughts</h2>
<p>I had hoped to tie this up with sparkling clarity, but should have expected that it's still a can of worms.  However, the dimensions of the can are bounded better and there's a sort of an approximation of how many worms are in it.  <img src="../../images/emoji/twitter/worm.png%3Fv=14" title=":worm:" class="emoji" alt=":worm:" loading="lazy" width="20" height="20"></p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="2" />
              <span class='post-likes'>2 Likes</span>
            </div>

                <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../old-idea-revisited-datatype-as-antiform/2324/3.html">Old Idea Revisited: DATATYPE as... Antiform?</a>
                        <meta itemprop='position' content='4'>
                      </div>
                </div>
          </div>
    </div>


    




    </div>
    <footer class="container wrap">
  <nav class='crawler-nav'>
    <ul>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/' itemprop="url">Home </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/categories' itemprop="url">Categories </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/guidelines' itemprop="url">Guidelines </a>
        </span>
      </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://rebol.metaeducation.com/tos' itemprop="url">Terms of Service </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://rebol.metaeducation.com/privacy' itemprop="url">Privacy Policy </a>
          </span>
        </li>
    </ul>
  </nav>
  <p class='powered-by-link'>Powered by <a href="https://www.discourse.org">Discourse</a>, best viewed with JavaScript enabled</p>
</footer>

    
    
  </body>
  
</html>

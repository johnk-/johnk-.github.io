<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Portable Bridge Notation (PBN) Parser</title>
    <link>https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306</link>
    <description>I decided I would do a small task in the web Ren-C build, which is to take the [&quot;Portable Bridge Notation&quot;](https://www.tistis.nl/pbn/) for representing a deal of a hand of cards, and turn it into blocks of symbolic data representing each player&#39;s hand.

The notation is pretty straightforward, e.g.

    N:QJ6.K652.J85.T98 873.J97.AT764.Q4 K5.T83.KQ9.A7652 AT942.AQ4.32.KJ3

Separated by spaces are the cards for each of 4 hands.  The suits are separated by dots, and the order is **`clubs.diamonds.hearts.spades`**.  T is used for 10, while J/Q/K/A are the typical Jack/Queen/King/Ace.  The first letter is a direction (N=North, E=East, S=South, W=West) of which player the first hand represented is for.

This case decodes like so:

![pbn-converter|690x458](upload://oZ9erLwEVhI0IGIYxhS9X9InLRY.jpeg) 

*([console escaping is now done by Rebol code](https://github.com/hostilefork/replpad-js/blob/d7af14eea92d23d50c2bd25d5dfca20a11929a8a/replpad.reb#L173), so this shows some colorization and live hyperlink as an example of what we might do with that)*.

I wanted the PBN conversion to be accessible and demonstrate &quot;best practices&quot;.  Here&#39;s what I came up with:

    whitespace: [some [space | newline]]

    suit-order: [♣ ♦ ♥ ♠]
    direction-order: [N E S W]
    rank-rule: [&#39;A | &#39;K | &#39;Q | &#39;J | &#39;T | &#39;9 | &#39;8 | &#39;7 | &#39;6 | &#39;5 | &#39;4 | &#39;3 | &#39;2]

    pbn-to-hands: func [
        &quot;Convert portable bridge notation to BLOCK!-structured hands&quot;

        return: [object!]
        pbn [text!]
    ][
        let suit: null

        let one-hand: null
        let one-hand-rule: [
            (suit: &#39;♣)
            [
                collect one-hand [4 [
                    13 [
                        set rank rank-rule
                        keep :[
                            as word! unspaced [suit either rank = #&quot;T&quot; [10] [rank]]
                        ]
                    ]
                    :(
                        suit: select suit-order suit
                        if suit [&quot;.&quot;] else &#39;[ahead any [whitespace]]
                    )
                ]]
            ]
            |
            (panic &quot;Invalid Hand information in PBN&quot;)
        ]

        let hands: make object! [N: E: S: W: null]

        let start: null
        let direction: null

        parse pbn [
            any space  ; We allow leading whitespace, good idea?

            [
                set start [&#39;N | &#39;E | &#39;S | &#39;W] (
                    start: to word! start
                    direction: start
                )
                |
                (panic &quot;PBN must start with N, E, S, or W&quot;)
            ]

            [&quot;:&quot; | (panic &quot;PBN second character must be `:`&quot;)]

            [
                [4 [
                    one-hand-rule (  ; Should set `one-hand` if rule succeeds.
                        hands/(direction): one-hand
                        one-hand: null
                        direction: (select direction-order direction) else [
                            first direction-order
                        ]
                    )
                    any whitespace  ; Should more than one space between hands be ok?
                ]]
                |
                (panic &quot;PBN must have 4 hand definitions&quot;)
            ]
            end
        ]

        assert [direction = start]  ; skipping around should have cycled
        return hands
    ]</description>
    
    <lastBuildDate>Tue, 13 May 2025 22:21:26 +0000</lastBuildDate>
    <category>Show &amp; Tell</category>
    <atom:link href="https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Portable Bridge Notation (PBN) Parser</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>A post was split to a new topic: <a href="https://rebol.metaeducation.com/t/non-expanding-block-idiom/2449">Non-Expanding BLOCK! Idiom?</a></p>
          <p><a href="https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306/9">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306/9</link>
        <pubDate>Mon, 12 May 2025 23:52:29 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1306-9</guid>
        <source url="https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306.rss">Portable Bridge Notation (PBN) Parser</source>
      </item>
      <item>
        <title>Portable Bridge Notation (PBN) Parser</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <h2><a name="p-8267-h-5-years-have-gone-by-how-much-better-can-we-do-1" class="anchor" href="https://rebol.metaeducation.com#p-8267-h-5-years-have-gone-by-how-much-better-can-we-do-1"></a>5 Years Have Gone By... How Much Better Can We Do?</h2>
<p><em><strong>Foundationally better...</strong></em>  <img src="https://rebol.metaeducation.com/images/emoji/twitter/rock.png?v=14" title=":rock:" class="emoji" alt=":rock:" loading="lazy" width="20" height="20"></p>
<pre><code>whitespace: [some [space | newline]]

suit-order: [♣ ♦ ♥ ♠]
direction-order: [N E S W]
rank-order: [2 3 4 5 6 7 8 9 T J Q K A]

one-hand-rule: [
    let suit: ('♣)
    collect [repeat 4 [
        repeat 13 [
            let rank: any @rank-order  ; RANK-ORDER is literals, not rules
            keep (join word! [suit, rank = 'T then [10] else [rank]])
        ]
        inline (
            suit: select suit-order suit
            if suit ["."] else $[ahead [whitespace | &lt;end&gt;]]
        )
    ]]
    |
    reject "Invalid Hand information in PBN"
]

pbn-to-hands: func [
    "Convert portable bridge notation to BLOCK!-structured hands"

    return: [object!]
    pbn [text!]
    &lt;local&gt; start direction
][
    let hands: parse pbn [gather [
        opt whitespace  ; We allow leading whitespace, good idea?

        [
            start: any @direction-order  ; DIRECTION-ORDER is literals, not rules
            | reject "PBN must start with N, E, S, or W"
        ]
        direction: (start)

        [":" | reject "PBN second character must be `:`"]

        [repeat 4 [
            emit (direction): one-hand-rule (  ; e.g. [emit N: ...]
                direction: (select direction-order direction) else [
                    first direction-order
                ]
            )
            opt whitespace  ; Is more than one space between hands ok?
        ]
        |
        reject "PBN must have 4 hand definitions"
    ]]

    assert [direction = start]  ; skipping around should have cycled
    return hands
]
</code></pre>
<p>And it works!</p>
<pre><code>&gt;&gt; pbn-to-hands --[
       N:QJ6.K652.J85.T98 873.J97.AT764.Q4 K5.T83.KQ9.A7652 AT942.AQ4.32.KJ3
   ]--
== #[object! [
        N: '[♣Q ♣J ♣6 ♦K ♦6 ♦5 ♦2 ♥J ♥8 ♥5 ♠10 ♠9 ♠8]
        E: '[♣8 ♣7 ♣3 ♦J ♦9 ♦7 ♥A ♥10 ♥7 ♥6 ♥4 ♠Q ♠4]
        S: '[♣K ♣5 ♦10 ♦8 ♦3 ♥K ♥Q ♥9 ♠A ♠7 ♠6 ♠5 ♠2]
        W: '[♣A ♣10 ♣9 ♣4 ♣2 ♦A ♦Q ♦4 ♥3 ♥2 ♠K ♠J ♠3]
   ]
</code></pre>
<h2><a name="p-8267-you-can-use-let-in-parse-2" class="anchor" href="https://rebol.metaeducation.com#p-8267-you-can-use-let-in-parse-2"></a>You Can Use LET In PARSE</h2>
<p>It might seem like a minor feature, but the underpinnings that allow a combinator to expand the environment required lots of advances.</p>
<h2><a name="p-8267-group-rule-handling-became-more-homogeneous-3" class="anchor" href="https://rebol.metaeducation.com#p-8267-group-rule-handling-became-more-homogeneous-3"></a>GROUP! Rule Handling Became More Homogeneous</h2>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1306">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><a class="mention" href="https://rebol.metaeducation.com/u/rgchris">@rgchris</a> and I have been discussing the three things you might want to do with DO-style code embedded into a parse</p>
</blockquote>
</aside>
<p>UPARSE has an overarching policy that rules synthesize values, and a BLOCK! will synthesize the last value synthesized by the rules within it.</p>
<p>I became more comfortable with GROUP! synthesizing values <em>always</em>.  It's not like the values are discarded sometimes, and heeded other times.</p>
<p>This means that the style preferred by <a class="mention" href="https://rebol.metaeducation.com/u/rgchris">@rgchris</a>, where you can just say <strong><code>keep (...)</code></strong> without needing to decorate to say something like <strong><code>keep :[...]</code></strong>, has won out.  My paranoia about the decoration being needed to say "this isn't a value-discarding case of the group" no longer applies <em>(to the extent it was ever worth worrying about)</em>.</p>
<p>As for retriggering rules, I'm happy right now with that being done via <strong><code>inline (...)</code></strong>.  It all fits together.  So instead of:</p>
<pre><code>:(
    suit: select suit-order suit
    if suit ["."] else '[ahead [whitespace | end]]
)
</code></pre>
<p>You say:</p>
<pre><code>inline (
    suit: select suit-order suit
    if suit ["."] else [[ahead [whitespace | &lt;end&gt;]]]
)
</code></pre>
<p>Note that I chose to instead make the branch $, to get a bound version of a "soft quoted" branch:</p>
<pre><code>inline (
    suit: select suit-order suit
    if suit ["."] else $[ahead [whitespace | &lt;end&gt;]]
)
</code></pre>
<p>You can't just use a quote there, because the unquoted block you got back from the branch would be unbound.  It's a matter of taste I guess if you like this better than putting the block in a block... but it's faster, because the evaluator does not get invoked on the block.  And I think it looks clearer, once you have a basic understanding of what's going on with binding.</p>
<h2><a name="p-8267-the-repeat-4-instead-of-4-is-much-better-4" class="anchor" href="https://rebol.metaeducation.com#p-8267-the-repeat-4-instead-of-4-is-much-better-4"></a>The [repeat 4 ...] Instead Of [4 ...] Is Much Better</h2>
<p>No qualms about that change.</p>
<p>If you're in a context where you want 4 to do a REPEAT 4 implicitly, that's possible.  UPARSE is easy to customize with custom combinators, and we should make it even easier to do off the cuff <em>(as easy as <a href="https://rebol.metaeducation.com/t/evaluator-hooking-rebindablesyntax/2443">RebindableSyntax in the evaluator</a>)</em>.</p>
<h2><a name="p-8267-uses-gather-instead-of-assigning-hands-5" class="anchor" href="https://rebol.metaeducation.com#p-8267-uses-gather-instead-of-assigning-hands-5"></a>Uses GATHER Instead Of Assigning Hands</h2>
<p>The original code did:</p>
<pre><code>let hands: make object! [N: E: S: W: null]
parse [... hand: collect [...] (hand/(direction): hand ...) ...]
</code></pre>
<p>The new code does:</p>
<pre><code>hands: parse [gather [... emit (direction): collect ...]]
</code></pre>
<p>It's much more powerful to synthesize the object from the rule--instead of pre-creating the object and passing it to the rule to have its fields assigned.  Obviously it makes the rule easier to reuse.  But also it means that the rule can make decisions about the shape and structure of the object.</p>
<p>There's only one little detail here, which is that in today's world (and maybe tomorrow's) the order of fields in an object matters in some places.  By not pre-creating the object, the field order of the generated object will be different based on what order the fields are emitted.  Here that might be exactly what you want--the order of fields in the object will reflect the order of hands in the original notation.  But it's something to consider.</p>
<h2><a name="p-8267-join-word-for-the-win-6" class="anchor" href="https://rebol.metaeducation.com#p-8267-join-word-for-the-win-6"></a>JOIN WORD! For The Win</h2>
<p>Instead of:</p>
<pre><code>keep (as word! unspaced [suit either rank = #"T" [10] [rank]])
</code></pre>
<p>This has:</p>
<pre><code>keep (join word! [suit, rank = 'T then [10] else [rank]])
</code></pre>
<p>I like the THEN/ELSE rhythm better than I like EITHER, but that's a matter of taste.</p>
<p>Also, matching a literal WORD! or INTEGER! rule in a string gives you the original rule (unquoted) as a product now, not a character:</p>
<pre><code>&gt;&gt; parse "a" ['a]
== a

&gt;&gt; parse "10" ['10]
== 10
</code></pre>
<p>So this gets a bit cleaner.</p>
<h2><a name="p-8267-any-and-literal-matching-with-pinned-7" class="anchor" href="https://rebol.metaeducation.com#p-8267-any-and-literal-matching-with-pinned-7"></a>ANY And Literal Matching With <code>@PINNED!</code></h2>
<p>The new meaning of the ANY rule is more like the ANY in the regular evaluator.  It implicitly considers there to be a <code>|</code> between the elements of the block you pass it, so it's picking out of a set of alternates.</p>
<p>By default those alternates are <em>rules</em>, not literal values to match against.  So if you're trying to match literal things, you have to put them in quotes:</p>
<pre><code>&gt;&gt; parse [a a b a b c c] [some any ['a 'b 'c]]
== c
</code></pre>
<p>But we can use a "PINNED" block (<code>@[...]</code>) as a signal that we want a literal match:</p>
<pre><code>&gt;&gt; parse [a a b a b c c] [some any @[a b c]]
== c
</code></pre>
<p>If your block of options are in a variable, and you don't have your block of options decorated, you can use an operator to add the @ ... <a href="https://rebol.metaeducation.com/t/new-names-for-foo-foo-and-foo/2447/2">that operator is called PIN</a>  <img src="https://rebol.metaeducation.com/images/emoji/twitter/pushpin.png?v=14" title=":pushpin:" class="emoji" alt=":pushpin:" loading="lazy" width="20" height="20"></p>
<pre><code>&gt;&gt; suit-order: [♣ ♦ ♥ ♠]

&gt;&gt; parse [♣ ♦ ♦ ♥ ♠ ♣] [some any (pin suit-order)]
== ♣
</code></pre>
<p>Or you could put the <code>@</code> on the data array itself:</p>
<pre><code>&gt;&gt; suit-order: @[♣ ♦ ♥ ♠]

&gt;&gt; parse [♣ ♦ ♦ ♥ ♠ ♣] [some any (suit-order)]
== ♣
</code></pre>
<p>But I offered another option, which is to use a pinned word at the reference site, and it will then assume you mean you wanted to treat what it looks up to as literal data:</p>
<pre><code>&gt;&gt; suit-order: [♣ ♦ ♥ ♠]

&gt;&gt; parse [♣ ♦ ♦ ♥ ♠ ♣] [some any @suit-order]
== ♣
</code></pre>
<p><em>(If you just said <strong><code>any suit-order</code></strong> then it would only accept plain blocks, and treat it as parse rules with no literal recognition... the dialect subtleties here are complex, but I think that's for the best.)</em></p>
<h2><a name="p-8267-reject-instead-of-panic-8" class="anchor" href="https://rebol.metaeducation.com#p-8267-reject-instead-of-panic-8"></a>REJECT Instead Of PANIC</h2>
<p><strong><code>reject "message"</code></strong> saves you on parentheses vs. <strong><code>(panic "message")</code></strong> ...</p>
<p>But the difference is much greater than that.  REJECT, by being cooperative with PARSE, returns the error from PARSE itself, so you can react to it if you want.  But also--it can encode information about what the state of the parse was at that moment into the error.</p>
<p>This idea that PARSE will by default give you a good diagnostic--that the console can break down for you and report visually--will hopefully make a big difference.  This way the default of leaving error handling off your PARSE will be translated into a PANIC at <em>that</em> point, and you'll get much better information.</p>
          <p><a href="https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306/10">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306/10</link>
        <pubDate>Mon, 12 May 2025 22:27:49 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1306-10</guid>
        <source url="https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306.rss">Portable Bridge Notation (PBN) Parser</source>
      </item>
      <item>
        <title>Portable Bridge Notation (PBN) Parser</title>
        <dc:creator><![CDATA[rgchris]]></dc:creator>
        <description><![CDATA[
            <p>My thought is an optimized 5-way (parent, first[child], last, back, next) NODE! type. I've been using blocks for this and has several disadvantages, including being difficult to PROBE and inefficient to traverse or convert to BLOCK!. Maintaining relationships would still be on the user, thus could be used for a simple linked list, double linked list or full-blown tree structure.</p>
          <p><a href="https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306/8">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306/8</link>
        <pubDate>Tue, 21 Jul 2020 01:58:14 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1306-8</guid>
        <source url="https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306.rss">Portable Bridge Notation (PBN) Parser</source>
      </item>
      <item>
        <title>Portable Bridge Notation (PBN) Parser</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="rgchris" data-post="6" data-topic="1306">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>Obfuscating in this way is the Rebol way.</p>
</blockquote>
</aside>
<p>This makes me wonder if there should be a native for iterating.</p>
<pre><code> &gt;&gt; suit-order: head [♣ ♦ ♥ ♠]

 &gt;&gt; suit: iterates suit-order

 &gt;&gt; suit
 == ♣

 &gt;&gt; suit
 == ♣

 &gt;&gt; suit/next
 == ♦

 &gt;&gt; suit
 == ♦
</code></pre>
<p>Etc.  In stackless this can be written in usermode as a YIELDER, with something approximating:</p>
<pre><code> iterates: func [data /cycle] [
      return yielder [/next /back] [
          forever [  ; e.g. lib/cycle, FOREVER for clarity w/cycle refinement
               if next [
                   if tail? data: my lib/next [
                       if cycle [data: head data]
                   ]
               ]
               if back [
                   if head? data: my lib/back [
                       if cycle [data: back tail data]
                   ]
               ]
               yield data/1
          ]
      ]
 ]
</code></pre>
<p>It could be made as a relatively efficient native.  It might even use binding tricks to bind a single prototype action it to the data it iterates, so an ACTION! need not be created on each call.</p>
<p>You'd be in a situation where <strong>:SUIT</strong> was an ACTION! not a WORD!, which might seem uncomfortable.  Though this doesn't seem that much different than iterators in any other language--they're always another type from the data they wrap.</p>
          <p><a href="https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306/7">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306/7</link>
        <pubDate>Tue, 21 Jul 2020 00:50:07 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1306-7</guid>
        <source url="https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306.rss">Portable Bridge Notation (PBN) Parser</source>
      </item>
      <item>
        <title>Portable Bridge Notation (PBN) Parser</title>
        <dc:creator><![CDATA[rgchris]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1306">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>This idea felt obfuscating; hiding the current suit in a series position just seemed wrong.</p>
</blockquote>
</aside>
<p>Obfuscating in this way is the Rebol way. If you're willing to pay a little for something a little less opaque, you could just say: <strong>append suite-order suit: take suite-order</strong></p>
<p>Also, I've been using linked lists a fair bit of late (I have thoughts on potentially optimizing the linked list concept for tree building, but I digress):</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">♣: [next ♦ back ♠]
♦: [next ♥ back ♣]
♥: [next ♠ back ♦]
♠: [next ♣ back ♥]

suit: ♣
suit: (suit).next
; had problems with this on subsequent calls, needed (get suit).next
</code></pre>
          <p><a href="https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306/6">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306/6</link>
        <pubDate>Sun, 19 Jul 2020 16:38:47 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1306-6</guid>
        <source url="https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306.rss">Portable Bridge Notation (PBN) Parser</source>
      </item>
      <item>
        <title>Portable Bridge Notation (PBN) Parser</title>
        <dc:creator><![CDATA[rgchris]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1306">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Cards usually are written the other way, as <strong>4♠</strong> and not <strong><img src="https://rebol.metaeducation.com/images/emoji/twitter/spades.png?v=14" title=":spades:" class="emoji" alt=":spades:" loading="lazy" width="20" height="20">4</strong> (something about rendering in Discourse seems to think the latter notation is worthy of a much bigger spade...no idea why, might be worth finding out). But that would not be legal as a Rebol WORD!. The impedance match of such things is not a unique problem of Rebol, and there are more options like <strong>&lt;4♠&gt;</strong> while most languages would just have one string type. But it was a bit disappointing nonetheless to have to make the concession.</p>
</blockquote>
</aside>
<p>Tag! doesn't seem all that bad an option, nor does reversing as <strong><img src="https://rebol.metaeducation.com/images/emoji/twitter/spade_suit.png?v=14" title=":spade_suit:" class="emoji" alt=":spade_suit:" loading="lazy" width="20" height="20">4</strong> either (epecially if as a word you set it to <strong>"4♠"</strong>).</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1306">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Returning OBJECT! still makes me uncomfortable, as I feel there's a real inelegance to the single OBJECT! coming back as MAKE OBJECT! [...], and it goes out of the domain of concrete parts fast. I'm worried about adding methods and having that look ugly. I've written about wanting to maybe find some grand unifying theory where <a href="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086">OBJECT! is just some constrained optimized BLOCK!</a>. But that feels distant. In short, I'm just a bit torn over the return format here... I want to feel like we made it better than the PBN, not worse.</p>
</blockquote>
</aside>
<p>What about <em>Map!</em> ?—seems that is positioned as the more structured <em>Block!</em> within data structures where <em>Object!</em> is more for carrying class-like logic.</p>
          <p><a href="https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306/3</link>
        <pubDate>Sun, 19 Jul 2020 16:24:57 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1306-3</guid>
        <source url="https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306.rss">Portable Bridge Notation (PBN) Parser</source>
      </item>
      <item>
        <title>Portable Bridge Notation (PBN) Parser</title>
        <dc:creator><![CDATA[BlackATTR]]></dc:creator>
        <description><![CDATA[
            <p>Common issue. I'm sure we've all cycled through each of those different options trying to figure out the best fit.</p>
<p>It's nice to be able to do this:</p>
<blockquote>
<p>direction: (select direction-order direction) else [first direction-order]</p>
</blockquote>
          <p><a href="https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306/5">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306/5</link>
        <pubDate>Sun, 19 Jul 2020 13:35:01 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1306-5</guid>
        <source url="https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306.rss">Portable Bridge Notation (PBN) Parser</source>
      </item>
      <item>
        <title>Portable Bridge Notation (PBN) Parser</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="rgchris" data-post="8" data-topic="1086">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086/8">BLOCK! and OBJECT! Parity in Pathing/Picking</a></div>
<blockquote>
<p>my main objection to the Rebol 2 behaviour was the unexpectedness in the <strong>[a b b c]</strong> example.</p>
</blockquote>
</aside>
<p>Note that <a href="https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306">I used SELECT here</a> code, to step through items in order:</p>
<pre><code>let suit-order: [♣ ♦ ♥ ♠]
; ...
suit: select suit-order suit
</code></pre>
<p>This advanced through the suits until the end was reached.</p>
<p>I also used it for dealing cards in directions.  This case could start at any direction, and needed to cycle:</p>
<pre><code>let direction-order: [N E S W]
;
direction: (select direction-order direction) else [first direction-order]
</code></pre>
<p>I was a bit torn on how to do this.  I could have gone more like:</p>
<pre><code>suit-state: head [♣ ♦ ♥ ♠]
suit: does [suit-state.1]
;
suit-state: next suit-state
</code></pre>
<p>This idea felt obfuscating; hiding the current suit in a series position just seemed wrong.</p>
<p>I even toyed with the idea of doing it as state transitions, if we are to think in terms of SELECT/SKIP 2 or SELECT seeking out SET-WORD! :</p>
<pre><code>next-suit: [
     ♣: ♦
     ♦: ♥
     ♥: ♠
     ♠: _
]
; ...
suit: select next-suit suit
</code></pre>
<p>But that's just not what I was looking for.  I felt in the end the suit order had to be just what it was, as <strong><code>suit-order: [♣ ♦ ♥ ♠]</code></strong></p>
<p><strong>...I don't know what it gets at, other than that what I was ultimately looking for here didn't fit either of our ideas.</strong>  I really wanted to advance through things in a series in a context where FOR-EACH wasn't what I was using at that moment (because I was inside a PARSE rule that I didn't want to exit).</p>
<p>Food for thought.</p>
          <p><a href="https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306/4</link>
        <pubDate>Sun, 19 Jul 2020 04:29:44 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1306-4</guid>
        <source url="https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306.rss">Portable Bridge Notation (PBN) Parser</source>
      </item>
      <item>
        <title>Portable Bridge Notation (PBN) Parser</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <h2><a name="p-3881-conceptual-problems-encountered-while-writing-this-1" class="anchor" href="https://rebol.metaeducation.com#p-3881-conceptual-problems-encountered-while-writing-this-1"></a>Conceptual Problems Encountered While Writing This</h2>
<p>This is pretty straightforward as tasks go.  And certainly the PARSE-based code is more pleasing to look at than many versions.  But I'll list a few gripes.</p>
<ul>
<li>
<p>The C code I looked at to model from <a href="https://github.com/dds-bridge/dds/blob/9c554cc966d341958df45de2790e7737d57406e8/src/PBN.cpp#L35">used a variable called <code>first</code></a> for the starting "direction".  I used the same name and obliviously overwrote FIRST the Rebol operation.  This made later code not work.  It's certainly a cautionary tale for the casual overwriting of standard library functions...which makes you wonder if there's anything we could do to warn you about doing this accidentally, and then have an override notation.  Something in the function header?  Something on the LET itself?  What would cause these warnings and why?</p>
</li>
<li>
<p>Cards usually are written the other way, as <strong>4♠</strong> and not <strong><img src="https://rebol.metaeducation.com/images/emoji/twitter/spade_suit.png?v=14" title=":spade_suit:" class="emoji" alt=":spade_suit:" loading="lazy" width="20" height="20">4</strong> (something about rendering in Discourse seems to think the latter notation is worthy of a much bigger spade...no idea why, might be worth finding out).  But that would not be legal as a Rebol WORD!.  The impedance match of such things is not a unique problem of Rebol, and there are more options like <strong>&lt;4♠&gt;</strong> while most languages would just have one string type.  But it was a bit disappointing nonetheless to have to make the concession.</p>
</li>
<li>
<p>Returning OBJECT! still makes me uncomfortable, as I feel there's a real inelegance to the single OBJECT! coming back as MAKE OBJECT! [...], and it goes out of the domain of concrete parts fast.  I'm worried about adding methods and having that look ugly.  I've written about wanting to maybe find some grand unifying theory where <a href="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086">OBJECT! is just some constrained optimized BLOCK!</a>.  But that feels distant.  In short, I'm just a bit torn over the return format here... I want to feel like we made it better than the PBN, not worse.</p>
</li>
</ul>
<h2><a name="p-3881-technical-issues-encountered-while-writing-this-2" class="anchor" href="https://rebol.metaeducation.com#p-3881-technical-issues-encountered-while-writing-this-2"></a>Technical Issues Encountered While Writing This</h2>
<p>I deliberately chose to use the UTF-8 characters for card suits in the code.  Partially to make it look "cool", but also to exercise the code paths.</p>
<p>One of the big problem areas with doing so was the Windows Console.  If I tried to paste any code containing the card suits, they'd be invisible.  This is because the console layer has no idea what a PASTE is, so what Windows does is it simulates key-down and key-up events for every character as if you were typing them.  They must have gotten something wrong, because the card suits were not getting key downs... only key ups.  <a href="https://github.com/judah/haskeline/issues/54">Others have faced this problem and worked around it.</a>, so I incorporated their workaround.</p>
<p>Next is that I got it in my head that I wanted to use the lighter notation of <strong>'N</strong> to match a letter in the input rather than <strong>"N"</strong> or <strong>#"N"</strong>.  It's 3 fewer apostrophe-style marks than a string, and it seems there's no harm in allowing you to match WORD!s against strings.  After all, Rebol2/Red/R3-Alpha allow you to FIND that way:</p>
<pre><code>&gt;&gt; find "abchellodef" 'hello
== "hellodef"
</code></pre>
<p>So I went ahead and added that ability, for both WORD!s and INTEGER!s in strings.  This kind of opens a can of worms--as we might ask why looking for an INTEGER! in a string wouldn't be searching for the codepoint.  But you can do that with <strong>find some-string to char! some-int</strong>.  BINARY! is another story, and with doors open for searching binaries for strings it's the case that searching for integers finds the byte value and not the string-ized representation of that integer as ASCII.  It's something to think about.</p>
<p>I decided to use COLLECT, but when I did I realized the thing I was collecting was not KEEPing material from the input, but a synthesized card symbol.  The KEEP we had has the default interpretation of assuming you mean a pattern:</p>
<pre><code>&gt;&gt; parse "aaa" [collect data [some [keep "a"]]]
== ""

&gt;&gt; data
== ["a" "a" "a"]
</code></pre>
<p>But what if each time I see an "a", I want to keep a "b"?  That's not coming from the input.</p>
<p><a class="mention" href="https://rebol.metaeducation.com/u/rgchris">@rgchris</a> and I have been discussing the three things you might want to do with DO-style code embedded into a parse:</p>
<ul>
<li>
<p><strong>vaporize the result</strong> (currently <strong>()</strong>) - this is usually the traditional behavior of GROUP! in PARSE.  But when used as a parameter to a rule, this could vary.  e.g. <strong>change [some parse rule] (some code)</strong> will use the code to generate what to change to.</p>
</li>
<li>
<p><strong>treat the result as a rule</strong> (currently <strong>:()</strong>) - this has become a favorite of mine, as it frees us from the oddity of PARSE's IF and trying to map control structures into PARSE.  You don't have to pre-COMPOSE a PARSE rule, but every time the code is visited it effectively re-runs a composition.</p>
</li>
<li>
<p><strong>fabricate material unavailable in input</strong> (currently <strong>:[]</strong>) - when you look at things like CHANGE or the particular need to KEEP something that isn't in the input series, you have to be able to run code to make that new data.</p>
</li>
</ul>
<p>So the answer with this setup of "match a but keep b" would look like:</p>
<pre><code>&gt;&gt; parse "aaa" [collect data [some ["a" keep :["b"]]]]
== ""

&gt;&gt; data
== ["b" "b" "b"]
</code></pre>
<p>Whatever our beliefs about notation, these are desires you can have.  In this case I made <strong>:[]</strong> work as described so I could keep my synthesized data.</p>
<p>I wanted to make the KEEP rule look like:</p>
<pre><code>keep :[join suit (either rank = 'T [10] [rank)]
</code></pre>
<p>Because I had the idea that if you matched a WORD! in your text input, that the SET would come back as the WORD! for the character... not the character itself.  This is a concept that needs to be thought out more, because I'm not sure we completely understand the rationale discerning SET and COPY and what their behavior should be.</p>
<hr>
<p>As usual, Rebol-ish code can be nice to look at once it's written...but the path to getting there can be pretty hard.  As usual: a debugger would really help.</p>
          <p><a href="https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306/2</link>
        <pubDate>Sun, 19 Jul 2020 02:53:13 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1306-2</guid>
        <source url="https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306.rss">Portable Bridge Notation (PBN) Parser</source>
      </item>
      <item>
        <title>Portable Bridge Notation (PBN) Parser</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>I decided I would do a small task in the web Ren-C build, which is to take the <a href="https://www.tistis.nl/pbn/">"Portable Bridge Notation"</a> for representing a deal of a hand of cards, and turn it into blocks of symbolic data representing each player's hand.</p>
<p>The notation is pretty straightforward, e.g.</p>
<pre><code>N:QJ6.K652.J85.T98 873.J97.AT764.Q4 K5.T83.KQ9.A7652 AT942.AQ4.32.KJ3
</code></pre>
<p>Separated by spaces are the cards for each of 4 hands.  The suits are separated by dots, and the order is <strong><code>clubs.diamonds.hearts.spades</code></strong>.  T is used for 10, while J/Q/K/A are the typical Jack/Queen/King/Ace.  The first letter is a direction (N=North, E=East, S=South, W=West) of which player the first hand represented is for.</p>
<p>This case decodes like so:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/af1db86d4b17341751b69cbc3cba816ca16b2af6.jpeg" data-download-href="https://rebol.metaeducation.com/uploads/default/af1db86d4b17341751b69cbc3cba816ca16b2af6" title="pbn-converter"><img src="https://rebol.metaeducation.com/uploads/default/optimized/1X/af1db86d4b17341751b69cbc3cba816ca16b2af6_2_690x458.jpeg" alt="pbn-converter" data-base62-sha1="oZ9erLwEVhI0IGIYxhS9X9InLRY" width="690" height="458" srcset="https://rebol.metaeducation.com/uploads/default/optimized/1X/af1db86d4b17341751b69cbc3cba816ca16b2af6_2_690x458.jpeg, https://rebol.metaeducation.com/uploads/default/optimized/1X/af1db86d4b17341751b69cbc3cba816ca16b2af6_2_1035x687.jpeg 1.5x, https://rebol.metaeducation.com/uploads/default/optimized/1X/af1db86d4b17341751b69cbc3cba816ca16b2af6_2_1380x916.jpeg 2x" data-dominant-color="F0EEEE"></a></div><p></p>
<p><em>(<a href="https://github.com/hostilefork/replpad-js/blob/d7af14eea92d23d50c2bd25d5dfca20a11929a8a/replpad.reb#L173">console escaping is now done by Rebol code</a>, so this shows some colorization and live hyperlink as an example of what we might do with that)</em>.</p>
<p>I wanted the PBN conversion to be accessible and demonstrate "best practices".  Here's what I came up with:</p>
<pre><code>whitespace: [some [space | newline]]

suit-order: [♣ ♦ ♥ ♠]
direction-order: [N E S W]
rank-rule: ['A | 'K | 'Q | 'J | 'T | '9 | '8 | '7 | '6 | '5 | '4 | '3 | '2]

pbn-to-hands: func [
    "Convert portable bridge notation to BLOCK!-structured hands"

    return: [object!]
    pbn [text!]
][
    let suit: null

    let one-hand: null
    let one-hand-rule: [
        (suit: '♣)
        [
            collect one-hand [4 [
                13 [
                    set rank rank-rule
                    keep :[
                        as word! unspaced [suit either rank = #"T" [10] [rank]]
                    ]
                ]
                :(
                    suit: select suit-order suit
                    if suit ["."] else '[ahead any [whitespace]]
                )
            ]]
        ]
        |
        (panic "Invalid Hand information in PBN")
    ]

    let hands: make object! [N: E: S: W: null]

    let start: null
    let direction: null

    parse pbn [
        any space  ; We allow leading whitespace, good idea?

        [
            set start ['N | 'E | 'S | 'W] (
                start: to word! start
                direction: start
            )
            |
            (panic "PBN must start with N, E, S, or W")
        ]

        [":" | (panic "PBN second character must be `:`")]

        [
            [4 [
                one-hand-rule (  ; Should set `one-hand` if rule succeeds.
                    hands/(direction): one-hand
                    one-hand: null
                    direction: (select direction-order direction) else [
                        first direction-order
                    ]
                )
                any whitespace  ; Should more than one space between hands be ok?
            ]]
            |
            (panic "PBN must have 4 hand definitions")
        ]
        end
    ]

    assert [direction = start]  ; skipping around should have cycled
    return hands
]
</code></pre>
          <p><a href="https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306/1</link>
        <pubDate>Sun, 19 Jul 2020 01:58:13 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1306-1</guid>
        <source url="https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306.rss">Portable Bridge Notation (PBN) Parser</source>
      </item>
  </channel>
</rss>

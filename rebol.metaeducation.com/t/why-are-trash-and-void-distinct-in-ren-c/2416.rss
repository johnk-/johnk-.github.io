<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Why Are TRASH and VOID Distinct In Ren-C?</title>
    <link>https://rebol.metaeducation.com/t/why-are-trash-and-void-distinct-in-ren-c/2416</link>
    <description>It appears that Ren-C uses **VOID** for opting out of things like COMPOSE, and **TRASH** for what unset variables hold.

But Rebol2, R3-Alpha, and Red use UNSET! for both:

     rebol2&gt;&gt; unset &#39;foo

     rebol2&gt;&gt; compose [a (get/any &#39;foo) c]
     == [a c]

All things being equal, one state to represent &quot;nothing&quot; would seem better than having more than one.

So are the benefits of having two different states worth it, vs. the simplification of only having to worry about one state?</description>
    
    <lastBuildDate>Mon, 09 Jun 2025 01:54:25 +0000</lastBuildDate>
    <category>Questions</category>
    <atom:link href="https://rebol.metaeducation.com/t/why-are-trash-and-void-distinct-in-ren-c/2416.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Why Are TRASH and VOID Distinct In Ren-C?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="rebolbot" data-post="1" data-topic="2416">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rebolbot/48/40_2.png" class="avatar"> rebolbot:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext"> rebol2&gt;&gt; unset 'foo

 rebol2&gt;&gt; compose [a (get/any 'foo) c]
 == [a c]
</code></pre>
</blockquote>
</aside>
<p>That might seem okay if you deliberately unset a variable.  But I'll point out that the same thing happens with variable names that are garbage, in all Redbols:</p>
<pre><code> rebol2&gt;&gt; compose [a (get/any 'asdfkjkl) c]
 == [a c]

 red&gt;&gt; compose [a (get/any 'asdfkjkl) c]
 == [a c]

 r3-alpha&gt;&gt; compose [a (get/any 'asdfkjkl) c]
 == [a c]
</code></pre>
<p>Ren-C's full answers to binding issues are beyond the scope of this post.  But it does point to the idea that having too few states in play can lead to undesirable results.</p>
<aside class="quote no-group quote-modified" data-username="rebolbot" data-post="1" data-topic="2416">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rebolbot/48/40_2.png" class="avatar"> rebolbot:</div>
<blockquote>
<p>Ren-C uses <strong>VOID</strong> for opting out of things like COMPOSE, and <strong>TRASH</strong> for what unset variables hold.</p>
<p>Rebol2, R3-Alpha, and Red used UNSET! for both.</p>
</blockquote>
</aside>
<p>It may be interesting to know that early Ren-C's focus was not on separating the states.  So it also only had one state for this... though the name was changed to "VOID".</p>
<p>The principal difference was on ensuring that VOID could never be found in a BLOCK!.  It was a state that could only be held by variables.  This was to try and fix up inconsistencies in historical Rebol... where some code paths let you put the unset state in blocks, others not, representational issues, etc.</p>
<pre><code>rebol2&gt;&gt; compose [a (get/any 'asdfasdf) b]
== [a b]

rebol2&gt;&gt; append [a b c] reduce [get/any 'asdfasdf]
== [a b c unset]
</code></pre>
<p>But beyond preventing VOID in blocks, not much else changed.  Failed branching constructs produced this state as well.  So when an IF didn't take its branch, you could use it to unset a variable... as well as to make COMPOSE slots vanish.  It didn't print in the console either!</p>
<pre><code>historical&gt;&gt; x: if 1 &gt; 2 [&lt;math-is-broken&gt;]  ; prints nothing on next line

historical&gt;&gt; x
** Error: whatever the error for an unset variable is

historical&gt;&gt; compose [a (if 1 &gt; 2 ['b]) c]
== [a c]
</code></pre>
<p>And then there was the LIT-VOID!.  This was what I thought made perfect sense, to make it <em>single-quoted nothingness</em>:</p>
<pre><code>historical&gt;&gt; x: '

historical&gt;&gt; x
** Error: x is VOID
</code></pre>
<p>So VOID wasn't the tick mark... <em>it was what you got when you evaluated the tick mark</em>.  This fit in with things like LIT-WORD! and LIT-PATH!, where the evaluator drops one level of quoting.  But here dropping that level gives you the "missing" state.  Having the console show no output seemed to fit in perfectly.</p>
<p>Honestly, it <em>is</em> kind of clever... IF this were as far as the system was going to go...</p>
<h2><a name="p-8149-what-upended-this-clever-idea-1" class="anchor" href="https://rebol.metaeducation.com#p-8149-what-upended-this-clever-idea-1"></a>What Upended This "Clever" Idea?</h2>
<p><a href="https://rebol.metaeducation.com/t/a-justification-of-generalized-isotopes/1918">The rise of generalized isotopes</a> meant there wasn't merely a single state that couldn't be put in blocks...but a whole menagerie of antiforms.</p>
<p>To fit into this menagerie correctly, the state that evaluated to produce an unset variable had to be a quasiform to make an antiform...not a quoted.  So unsetting a variable became done with what was chosen to be the quasiform of <a href="https://rebol.metaeducation.com/t/reified-unreassignable-nothingness-space-runes/2457">the "SPACE RUNE!"</a>... a lone tilde:</p>
<pre><code>&gt;&gt; quasi _
== ~

&gt;&gt; x: ~

&gt;&gt; x
** Error...
</code></pre>
<p>That quasiform evaluates to the antiform, which has no representation.  Though it can be written out as <strong><code>~ ; anti</code></strong> it could also be purple, or anything you like... but <a href="https://rebol.metaeducation.com/t/console-treatment-of-void-vs-trash/2045">the console just said this would display nothing</a>.</p>
<h2><a name="p-8149-first-reason-for-the-trash-void-split-was-safety-2" class="anchor" href="https://rebol.metaeducation.com#p-8149-first-reason-for-the-trash-void-split-was-safety-2"></a>First Reason For The TRASH / VOID Split Was Safety</h2>
<p>Antiform blank continued to do double-duty, as the contents of an unset variable... but also the return value of a function with a "meaningless" result.</p>
<p>So functions like HELP and PRINT returned antiform blank.</p>
<p>This "meaningless" intent--ornery when accessing via variables from words--led it to take on the new name of <strong>TRASH</strong>.</p>
<p>Functions like APPEND or COMPOSE came to reject TRASH by design:</p>
<pre><code>&gt;&gt; append [a b c] print "This should error"
This should error
** Error: APPEND doesn't allow TRASH (antiform ~) for its VALUE argument
</code></pre>
<p>It seemed clear that the "erasing" intent needed to be a different antiform.  That antiform took the name of <strong>VOID</strong>.</p>
<h2><a name="p-8149-second-reason-for-the-split-was-needing-unstable-void-3" class="anchor" href="https://rebol.metaeducation.com#p-8149-second-reason-for-the-split-was-needing-unstable-void-3"></a>Second Reason For The Split Was Needing Unstable VOID</h2>
<p>If the arguments for safety aren't convincing, there's a very important distinguishing characteristic of VOID... which is that it's an <em>unstable antiform</em>.  It's actually an empty antiform <a href="https://rebol.metaeducation.com/t/the-history-of-multi-return-in-ren-c/1134">multi-return PACK!</a>.</p>
<p>Remember that PACKs can't be stored in variables directly (you have to use a meta-representation).  So antiform packs will decay to their first element in plain assignment:</p>
<pre><code>&gt;&gt; pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; x: pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; x
== 1
</code></pre>
<p>But functions which take "meta-arguments" are able to do more processing on the pack.  SET-BLOCK! is one of the places that does this additional processing, and can unpack the elements:</p>
<pre><code>&gt;&gt; [y z]: pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; y
== 1

&gt;&gt; z
== 2
</code></pre>
<p>Yet VOID is defined as a PACK with no elements in it at all.  Which means you can't assign it to ordinary variables... and in fact you get an error if you try.</p>
<p>Note that <a href="https://rebol.metaeducation.com/t/why-ghost-get-ghost-fails-and-trash-void/2234">VOID is a function that generates the void state</a> <em>(it can't be a variable value, by definition)</em>.</p>
<pre><code>&gt;&gt; void  
== ~[]~  ; anti

&gt;&gt; x: void
** Error: No values to unpack in antiform ~[]~ PACK! (VOID)
</code></pre>
<p>This distinguishing aspect separates it clearly from TRASH--since we know trash <em>must</em> be able to be held in a variable to mark it as <em>"there, but not set to an meaningful value yet"</em>.</p>
<p>Hence VOID can be used not just for erasures of content in places like COMPOSE or arguments to APPEND, <a href="https://rebol.metaeducation.com/t/should-void-assigns-mean-fully-remove-a-key/2431"><strong>but it can be used for the erasure of variables themselves (when relevant)</strong></a>.</p>
<p>For instance: removing a key from a MAP!:</p>
<pre><code>&gt;&gt; m: to map! [a 10 b 20]

&gt;&gt; m.a: void
== ~[]~  ; anti

&gt;&gt; m
== #[map [b 20]]
</code></pre>
<p>There's competition in situations like this between "mapping to trash" and "not being there at all".  And the unstable antiform state makes it cleanly suited to whenever you want to capture the state of not being there at all.</p>
<h2><a name="p-8149-so-is-it-worth-it-4" class="anchor" href="https://rebol.metaeducation.com#p-8149-so-is-it-worth-it-4"></a>So... Is It Worth It?</h2>
<aside class="quote no-group quote-modified" data-username="rebolbot" data-post="1" data-topic="2416">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rebolbot/48/40_2.png" class="avatar"> rebolbot:</div>
<blockquote>
<p>Are the benefits of having two different states worth it, vs. the simplification of only having to worry about one state?</p>
</blockquote>
</aside>
<p><strong>IN THE CURRENT DESIGN, I CAN UNEQUIVOCALLY SAY YES.</strong></p>
<p>But it wasn't always <em>quite</em> perfect.  For some time, empty pack was <strong><a href="https://rebol.metaeducation.com/t/making-invisible-functions-e-g-comment-elide/2034">used to implement GHOST</a></strong>... and VOID was just another antiform WORD! (<code>~void~</code>) that could be stored in variables... just like TRASH.</p>
<p>I could tell from my own day-to-day usage that this "stable void" earned its keep as a distinct type from TRASH.  But being able to be stored in variables led to some tough-to-answer questions about its behavior.  For instance: was it a good or bad idea to allow direct access to ~void~ via WORD!, or should it error like TRASH ?</p>
<p>Or consider something like DEFAULT.  It was defined such that it would overwrite null and trash variables:</p>
<pre><code>&gt;&gt; x: ~

&gt;&gt; x: default [print "Foo" 1 + 2]
Foo
== 3

&gt;&gt; x
== 3

&gt;&gt; x: default [print "Bar" 10 + 20]
== 3
</code></pre>
<p>But what about <code>~void~</code> antiforms?  Were those also things that had to be overwritten?  It wasn't clear.</p>
<p>Basically, with VOID as a stable antiform it wound up creating the very combinatoric questions one might be concerned about from having "too many types".  Though it was different in name, <em>its fundamental properties weren't different enough</em> to make decisions flow obviously about how its handling should be different from TRASH or NULL.</p>
<p>Yet a crucial change of GHOST! to being the antiform of COMMA! freed up the empty antiform BLOCK! state to be a non-vanishing, unstable VOID antiform.</p>
<p>Confusion disappeared:</p>
<ul>
<li>
<p>There's no question about whether it should create errors to try and access VOID from words, <em>because you can't store a void in a variable at all</em>.</p>
</li>
<li>
<p>You don't have to decide if VOID is a "defaulting" state or not, <em>because you can't store void in a variable at all</em>.</p>
</li>
</ul>
<p>etc.  This pulled everything together, and the clarification in how decisions are able to flow now is rather mind-blowing.</p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/man_mage.png?v=14" title=":man_mage:" class="emoji only-emoji" alt=":man_mage:" loading="lazy" width="20" height="20"> <img src="https://rebol.metaeducation.com/images/emoji/twitter/compass.png?v=14" title=":compass:" class="emoji only-emoji" alt=":compass:" loading="lazy" width="20" height="20"></p>
          <p><a href="https://rebol.metaeducation.com/t/why-are-trash-and-void-distinct-in-ren-c/2416/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/why-are-trash-and-void-distinct-in-ren-c/2416/2</link>
        <pubDate>Thu, 17 Apr 2025 03:19:38 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2416-2</guid>
        <source url="https://rebol.metaeducation.com/t/why-are-trash-and-void-distinct-in-ren-c/2416.rss">Why Are TRASH and VOID Distinct In Ren-C?</source>
      </item>
      <item>
        <title>Why Are TRASH and VOID Distinct In Ren-C?</title>
        <dc:creator><![CDATA[rebolbot]]></dc:creator>
        <description><![CDATA[
            <p>It appears that Ren-C uses <strong>VOID</strong> for opting out of things like COMPOSE, and <strong>TRASH</strong> for what unset variables hold.</p>
<p>But Rebol2, R3-Alpha, and Red use UNSET! for both:</p>
<pre><code> rebol2&gt;&gt; unset 'foo

 rebol2&gt;&gt; compose [a (get/any 'foo) c]
 == [a c]
</code></pre>
<p>All things being equal, one state to represent "nothing" would seem better than having more than one.</p>
<p>So are the benefits of having two different states worth it, vs. the simplification of only having to worry about one state?</p>
          <p><a href="https://rebol.metaeducation.com/t/why-are-trash-and-void-distinct-in-ren-c/2416/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/why-are-trash-and-void-distinct-in-ren-c/2416/1</link>
        <pubDate>Thu, 17 Apr 2025 01:27:38 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2416-1</guid>
        <source url="https://rebol.metaeducation.com/t/why-are-trash-and-void-distinct-in-ren-c/2416.rss">Why Are TRASH and VOID Distinct In Ren-C?</source>
      </item>
  </channel>
</rss>

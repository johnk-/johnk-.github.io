<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>&quot;type of antiform&quot; now possible... Should We Use It?</title>
    <link>https://rebol.metaeducation.com/t/type-of-antiform-now-possible-should-we-use-it/2374</link>
    <description>The way antiforms were implemented originally didn&#39;t allow for the idea of giving a coherent answer back from TYPE OF.  So they all gave the same answer, much how QUOTED! and QUASIFORM! all gave the same answer:

    &gt;&gt; type of first [&#39;&#39;a]
    == &amp;[quoted]

    &gt;&gt; type of first [~a~]
    == &amp;[quasiform]

    &gt;&gt; type of spread [a b c]
    == &amp;[antiform]

So there was nothing like `&amp;[splice]`.  The only way to type check antiforms was with constraints, like SPLICE?... which was slower, since it had to call a constraint function.

But I reworked things in a way that speeds up SPLICE? to the point where it&#39;s no more expensive than checking for INTEGER! (or INTEGER?).

As a curious byproduct that I didn&#39;t even initially intend, this changed the behavior and it started treating antiforms as being datatypes:

    &gt;&gt; type of spread [a b c]
    == &amp;[splice]

I was actually surprised, because I didn&#39;t intend to do it.  It&#39;s not often a feature &quot;just happens&quot;.

## But Is It A Good Idea For Antiforms To Answer TYPE OF?

I&#39;ve struggled with types, and the question of what TYPE means, vs. what KIND means... or CLASS?

If we develop some sort of class system, then TYPE becomes a loaded question.  If you have an object that somehow remembers it was created as a BOOK!, then do you get **book! = type of my-book** being true?  Or is TYPE OF forever committed to returning the fundamental type and saying it&#39;s an OBJECT! ?

This hesitance has affected my willingness to rename REB_BLOCK and REB_BLANK to be TYPE_BLOCK and TYPE_BLANK, which would be much more palatable (and survive a language name change away from Rebol...)

There&#39;s also the question of **type of null**, which I feel needs to be an error most of the time.  The way I&#39;ve worked it out so far is that you get a RAISED? error.  So if you know you want to test for null you can say **try type of null** and get a null antiform result--not a datatype, but there&#39;s a sort of reasonable logic to saying the type of null is null.

## What Would It Hurt, e.g. if SPLICE! Looked Like A Type?

For instance, is there a really good reason why this shouldn&#39;t work?

    &gt;&gt; to splice! [a b c]
    == ~(a b c)~  ; anti

    &gt;&gt; to block ~(a b c)~
    == [a b c]

    switch type of spread [a b c] [
        splice! [print &quot;Is this somehow bad?&quot;]
    ]

It might be confusing, that a type ending in **`!`** can&#39;t be put into a block.  But that was true before with antiform!...

I lean toward thinking that there&#39;s more upside than downside.  And I kind of want to put this TYPE vs KIND vs. whatever else issue to rest.  We write **type of x** and expect to get something like BLOCK! or OBJECT! back.  If there&#39;s something more complex than that, it probably needs to be done another way.

So if you have something like `&#39;&#39;&#39;&#39;1` and `&#39;&#39;&#39;&#39;x` and `&#39;&#39;&#39;&#39;3`, and you want to know which are the &quot;same type&quot;, you&#39;ll need to define your operators for answering that.

Want to know if they&#39;re the same underlying type when you take the quotes off?

     (heart of x) = (heart of y)

Want to know if they&#39;re at the same quote level?

    (quotes of x) = (quotes of y)

I&#39;m sort of tempted to say actually that it might should be that TYPE OF doesn&#39;t work on quoted values, because of how misleading it is... but all blocks are of the same type, even if they&#39;re different lengths.  And it is actually often the case in dialects that if something is quoted, you treat all quoted things the same way...oddly enough.

In any case, the new flexibility for -OF operators means we can get some other ideas in the mix.  Rnadomly:

    &gt;&gt; quoted-type of first of [&#39;&#39;&#39;x]
    == &amp;[&#39; &#39; &#39; &amp;[word!]]

    &gt;&gt; quoted-type of first of [&#39;&#39;&#39;1]
    == &amp;[&#39; &#39; &#39; &amp;[integer!]]

If we say there are more questions you can ask of values to produce structure... instead of putting that burden on TYPE, we can maybe commit to what type does and move along.

And maybe there could be something like **class:relax of x** which if something wasn&#39;t an object, would give you the fundamental type?

    &gt;&gt; class of some-novel
    == #[make object! ...]

    &gt;&gt; class of some-block
    ** Error: not an object, use CLASS:RELAX to permit other types

    &gt;&gt; class of some-block
    == &amp;[block]

I guess in other words, I&#39;m feeling like it&#39;s time to just go ahead and say that TYPE-OF is the question we build on, that it returns fundamentals or antiform classes.

And maybe the concept I&#39;ve always wanted of calling it TYPE! instead of DATATYPE! will be possible, too.</description>
    
    <lastBuildDate>Sat, 22 Mar 2025 17:20:07 +0000</lastBuildDate>
    <category>Datatypes</category>
    <atom:link href="https://rebol.metaeducation.com/t/type-of-antiform-now-possible-should-we-use-it/2374.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>&quot;type of antiform&quot; now possible... Should We Use It?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>The way antiforms were implemented originally didn't allow for the idea of giving a coherent answer back from TYPE OF.  So they all gave the same answer, much how QUOTED! and QUASIFORM! all gave the same answer:</p>
<pre><code>&gt;&gt; type of first [''a]
== &amp;[quoted]

&gt;&gt; type of first [~a~]
== &amp;[quasiform]

&gt;&gt; type of spread [a b c]
== &amp;[antiform]
</code></pre>
<p>So there was nothing like <code>&amp;[splice]</code>.  The only way to type check antiforms was with constraints, like SPLICE?... which was slower, since it had to call a constraint function.</p>
<p>But I reworked things in a way that speeds up SPLICE? to the point where it's no more expensive than checking for INTEGER! (or INTEGER?).</p>
<p>As a curious byproduct that I didn't even initially intend, this changed the behavior and it started treating antiforms as being datatypes:</p>
<pre><code>&gt;&gt; type of spread [a b c]
== &amp;[splice]
</code></pre>
<p>I was actually surprised, because I didn't intend to do it.  It's not often a feature "just happens".</p>
<h2><a name="p-8046-but-is-it-a-good-idea-for-antiforms-to-answer-type-of-1" class="anchor" href="https://rebol.metaeducation.com#p-8046-but-is-it-a-good-idea-for-antiforms-to-answer-type-of-1"></a>But Is It A Good Idea For Antiforms To Answer TYPE OF?</h2>
<p>I've struggled with types, and the question of what TYPE means, vs. what KIND means... or CLASS?</p>
<p>If we develop some sort of class system, then TYPE becomes a loaded question.  If you have an object that somehow remembers it was created as a BOOK!, then do you get <strong>book! = type of my-book</strong> being true?  Or is TYPE OF forever committed to returning the fundamental type and saying it's an OBJECT! ?</p>
<p>This hesitance has affected my willingness to rename REB_BLOCK and REB_BLANK to be TYPE_BLOCK and TYPE_BLANK, which would be much more palatable (and survive a language name change away from Rebol...)</p>
<p>There's also the question of <strong>type of null</strong>, which I feel needs to be an error most of the time.  The way I've worked it out so far is that you get a RAISED? error.  So if you know you want to test for null you can say <strong>try type of null</strong> and get a null antiform result--not a datatype, but there's a sort of reasonable logic to saying the type of null is null.</p>
<h2><a name="p-8046-what-would-it-hurt-eg-if-splice-looked-like-a-type-2" class="anchor" href="https://rebol.metaeducation.com#p-8046-what-would-it-hurt-eg-if-splice-looked-like-a-type-2"></a>What Would It Hurt, e.g. if SPLICE! Looked Like A Type?</h2>
<p>For instance, is there a really good reason why this shouldn't work?</p>
<pre><code>&gt;&gt; to splice! [a b c]
== ~(a b c)~  ; anti

&gt;&gt; to block ~(a b c)~
== [a b c]

switch type of spread [a b c] [
    splice! [print "Is this somehow bad?"]
]
</code></pre>
<p>It might be confusing, that a type ending in <strong><code>!</code></strong> can't be put into a block.  But that was true before with antiform!...</p>
<p>I lean toward thinking that there's more upside than downside.  And I kind of want to put this TYPE vs KIND vs. whatever else issue to rest.  We write <strong>type of x</strong> and expect to get something like BLOCK! or OBJECT! back.  If there's something more complex than that, it probably needs to be done another way.</p>
<p>So if you have something like <code>''''1</code> and <code>''''x</code> and <code>''''3</code>, and you want to know which are the "same type", you'll need to define your operators for answering that.</p>
<p>Want to know if they're the same underlying type when you take the quotes off?</p>
<pre><code> (heart of x) = (heart of y)
</code></pre>
<p>Want to know if they're at the same quote level?</p>
<pre><code>(quotes of x) = (quotes of y)
</code></pre>
<p>I'm sort of tempted to say actually that it might should be that TYPE OF doesn't work on quoted values, because of how misleading it is... but all blocks are of the same type, even if they're different lengths.  And it is actually often the case in dialects that if something is quoted, you treat all quoted things the same way...oddly enough.</p>
<p>In any case, the new flexibility for -OF operators means we can get some other ideas in the mix.  Rnadomly:</p>
<pre><code>&gt;&gt; quoted-type of first of ['''x]
== &amp;[' ' ' &amp;[word!]]

&gt;&gt; quoted-type of first of ['''1]
== &amp;[' ' ' &amp;[integer!]]
</code></pre>
<p>If we say there are more questions you can ask of values to produce structure... instead of putting that burden on TYPE, we can maybe commit to what type does and move along.</p>
<p>And maybe there could be something like <strong>class:relax of x</strong> which if something wasn't an object, would give you the fundamental type?</p>
<pre><code>&gt;&gt; class of some-novel
== #[make object! ...]

&gt;&gt; class of some-block
** Error: not an object, use CLASS:RELAX to permit other types

&gt;&gt; class of some-block
== &amp;[block]
</code></pre>
<p>I guess in other words, I'm feeling like it's time to just go ahead and say that TYPE-OF is the question we build on, that it returns fundamentals or antiform classes.</p>
<p>And maybe the concept I've always wanted of calling it TYPE! instead of DATATYPE! will be possible, too.</p>
          <p><a href="https://rebol.metaeducation.com/t/type-of-antiform-now-possible-should-we-use-it/2374/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/type-of-antiform-now-possible-should-we-use-it/2374/1</link>
        <pubDate>Tue, 18 Mar 2025 21:55:06 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2374-1</guid>
        <source url="https://rebol.metaeducation.com/t/type-of-antiform-now-possible-should-we-use-it/2374.rss">&quot;type of antiform&quot; now possible... Should We Use It?</source>
      </item>
  </channel>
</rss>

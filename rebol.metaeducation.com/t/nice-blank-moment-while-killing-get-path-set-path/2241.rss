<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Nice Blank Moment While Killing GET-PATH!/SET-PATH!</title>
    <link>https://rebol.metaeducation.com/t/nice-blank-moment-while-killing-get-path-set-path/2241</link>
    <description>I&#39;m busily killing off all the stray SET-PATH! and GET-PATH! that exist... *(because [CHAIN! is going to be underneath PATH!](https://rebol.metaeducation.com/t/introducingnew-chain-datatype/2226), you won&#39;t be able to put a path in a chain such that you would describe the path as being set or gotten... the colon can&#39;t be &quot;applied to&quot; the path)*.

I came across the pleasing SIGIL! test:

    for-each [sigil items] [
        ~null~  [  word    tu.p.le    pa/th    [bl o ck]    (gr o up)    {fe n ce}  ]
        ::      [  word:   tu.p.le:   pa/th:   [bl o ck]:   (gr o up):   {fe n ce}: ]
        :       [ :word   :tu.p.le   :pa/th   :[bl o ck]   :(gr o up)   :{fe n ce}  ]
        ^       [ ^word   ^tu.p.le   ^pa/th   ^[bl o ck]   ^(gr o up)   ^{fe n ce}  ]
        &amp;       [ &amp;word   &amp;tu.p.le   &amp;pa/th   &amp;[bl o ck]   &amp;(gr o up)   &amp;{fe n ce}  ]
        @       [ @word   @tu.p.le   @pa/th   @[bl o ck]   @(gr o up)   @{fe n ce}  ]
        $       [ $word   $tu.p.le   $pa/th   $[bl o ck]   $(gr o up)   ${fe n ce}  ]

    ][
        for-each &#39;item items [
            assert [bindable? item]
            if (degrade sigil) &lt;&gt; sigil of item [
                fail [mold item]
            ]
        ]
    ]

**`:`** and **`::`** are not going to be SIGIL! at all soon.  But as a first step, I need to get rid of SET-PATH! and GET-PATH!

## Behold Just A Little Nice Rebolish Moment

I realized I needed to kill QUASI-TUPLE! and QUASI-PATH! also...

    for-each [sigil items] [
        ~null~  [  word    tu.p.le    pa/th    [bl o ck]    (gr o up)    {fe n ce}  ]
        ::      [  word:   tu.p.le:     _      [bl o ck]:   (gr o up):   {fe n ce}: ]
        :       [ :word   :tu.p.le      _     :[bl o ck]   :(gr o up)   :{fe n ce}  ]
        ^       [ ^word   ^tu.p.le   ^pa/th   ^[bl o ck]   ^(gr o up)   ^{fe n ce}  ]
        &amp;       [ &amp;word   &amp;tu.p.le   &amp;pa/th   &amp;[bl o ck]   &amp;(gr o up)   &amp;{fe n ce}  ]
        @       [ @word   @tu.p.le   @pa/th   @[bl o ck]   @(gr o up)   @{fe n ce}  ]
        $       [ $word   $tu.p.le   $pa/th   $[bl o ck]   $(gr o up)   ${fe n ce}  ]
    ][
        for-each &#39;item items [
            if blank? item [continue]
            assert [bindable? item]
            if (degrade sigil) &lt;&gt; sigil of item [
                fail [mold item]
            ]
        ]
    ]

When you have the parts, you just use them... *and I picked a blank*.

Of course I could have used other things.

---
        ::      [  word:   tu.p.le:     ~    [bl o ck]:   (gr o up):   {fe n ce}: ]
---
        ::      [  word:   tu.p.le:     -    [bl o ck]:   (gr o up):   {fe n ce}: ]
---
        ::      [  word:   tu.p.le:     #    [bl o ck]:   (gr o up):   {fe n ce}: ]
---
        ::      [  word:   tu.p.le:    !!!   [bl o ck]:   (gr o up):   {fe n ce}: ]
---
        ::      [  word:   tu.p.le:  &lt;dead&gt;  [bl o ck]:   (gr o up):   {fe n ce}: ]
---
        ::      [  word:   tu.p.le:  ~null~  [bl o ck]:   (gr o up):   {fe n ce}: ]
---
        ::      [  word:   tu.p.le:  ~dead~  [bl o ck]:   (gr o up):  {fe n ce}: ]
---
        ::      [  word:   tu.p.le:   #dead  [bl o ck]:   (gr o up):  {fe n ce}: ]
---

In a lot of cases, trash (**`~`**) would be the right choice for a &quot;this is invalid slot&quot;.  But I feel it doesn&#39;t work quite as well in this context.

    ~null~  [  word    tu.p.le    pa/th    [bl o ck]    (gr o up)    {fe n ce}  ]
    ::      [  word:   tu.p.le:     ~      [bl o ck]:   (gr o up):   {fe n ce}: ]
    :       [ :word   :tu.p.le      ~     :[bl o ck]   :(gr o up)   :{fe n ce}  ]
    ^       [ ^word   ^tu.p.le   ^pa/th   ^[bl o ck]   ^(gr o up)   ^{fe n ce}  ]

Visually the best choice may be a hyphen, because it divides the space above and below evenly:

    ~null~  [  word    tu.p.le    pa/th    [bl o ck]    (gr o up)    {fe n ce}  ]
    ::      [  word:   tu.p.le:     -      [bl o ck]:   (gr o up):   {fe n ce}: ]
    :       [ :word   :tu.p.le      -     :[bl o ck]   :(gr o up)   :{fe n ce}  ]
    ^       [ ^word   ^tu.p.le   ^pa/th   ^[bl o ck]   ^(gr o up)   ^{fe n ce}  ]

But BLANK! has properties of being weird and unevaluative that probably give it the edge, while looking about the same.  But I&#39;m on the fence, maybe - is good.  :-)

## Note That `:pa/th` and `pa/th:` Will Become LOADable Again...

You just won&#39;t ask about colons applied on the head or tail of the paths, because you&#39;ll have to &quot;dig&quot; to find the chains underneath.</description>
    
    <lastBuildDate>Mon, 31 Mar 2025 16:31:28 +0000</lastBuildDate>
    <category>Show &amp; Tell</category>
    <atom:link href="https://rebol.metaeducation.com/t/nice-blank-moment-while-killing-get-path-set-path/2241.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Nice Blank Moment While Killing GET-PATH!/SET-PATH!</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>I'm busily killing off all the stray SET-PATH! and GET-PATH! that exist... <em>(because <a href="https://rebol.metaeducation.com/t/introducingnew-chain-datatype/2226">CHAIN! is going to be underneath PATH!</a>, you won't be able to put a path in a chain such that you would describe the path as being set or gotten... the colon can't be "applied to" the path)</em>.</p>
<p>I came across the pleasing SIGIL! test:</p>
<pre><code>for-each [sigil items] [
    ~null~  [  word    tu.p.le    pa/th    [bl o ck]    (gr o up)    {fe n ce}  ]
    ::      [  word:   tu.p.le:   pa/th:   [bl o ck]:   (gr o up):   {fe n ce}: ]
    :       [ :word   :tu.p.le   :pa/th   :[bl o ck]   :(gr o up)   :{fe n ce}  ]
    ^       [ ^word   ^tu.p.le   ^pa/th   ^[bl o ck]   ^(gr o up)   ^{fe n ce}  ]
    &amp;       [ &amp;word   &amp;tu.p.le   &amp;pa/th   &amp;[bl o ck]   &amp;(gr o up)   &amp;{fe n ce}  ]
    @       [ @word   @tu.p.le   @pa/th   @[bl o ck]   @(gr o up)   @{fe n ce}  ]
    $       [ $word   $tu.p.le   $pa/th   $[bl o ck]   $(gr o up)   ${fe n ce}  ]

][
    for-each 'item items [
        assert [bindable? item]
        if (degrade sigil) &lt;&gt; sigil of item [
            fail [mold item]
        ]
    ]
]
</code></pre>
<p><strong><code>:</code></strong> and <strong><code>::</code></strong> are not going to be SIGIL! at all soon.  But as a first step, I need to get rid of SET-PATH! and GET-PATH!</p>
<h2><a name="p-7506-behold-just-a-little-nice-rebolish-moment-1" class="anchor" href="https://rebol.metaeducation.com#p-7506-behold-just-a-little-nice-rebolish-moment-1"></a>Behold Just A Little Nice Rebolish Moment</h2>
<p>I realized I needed to kill QUASI-TUPLE! and QUASI-PATH! also...</p>
<pre><code>for-each [sigil items] [
    ~null~  [  word    tu.p.le    pa/th    [bl o ck]    (gr o up)    {fe n ce}  ]
    ::      [  word:   tu.p.le:     _      [bl o ck]:   (gr o up):   {fe n ce}: ]
    :       [ :word   :tu.p.le      _     :[bl o ck]   :(gr o up)   :{fe n ce}  ]
    ^       [ ^word   ^tu.p.le   ^pa/th   ^[bl o ck]   ^(gr o up)   ^{fe n ce}  ]
    &amp;       [ &amp;word   &amp;tu.p.le   &amp;pa/th   &amp;[bl o ck]   &amp;(gr o up)   &amp;{fe n ce}  ]
    @       [ @word   @tu.p.le   @pa/th   @[bl o ck]   @(gr o up)   @{fe n ce}  ]
    $       [ $word   $tu.p.le   $pa/th   $[bl o ck]   $(gr o up)   ${fe n ce}  ]
][
    for-each 'item items [
        if blank? item [continue]
        assert [bindable? item]
        if (degrade sigil) &lt;&gt; sigil of item [
            fail [mold item]
        ]
    ]
]
</code></pre>
<p>When you have the parts, you just use them... <em>and I picked a blank</em>.</p>
<p>Of course I could have used other things.</p>
<hr>
<pre><code>    ::      [  word:   tu.p.le:     ~    [bl o ck]:   (gr o up):   {fe n ce}: ]
</code></pre>
<hr>
<pre><code>    ::      [  word:   tu.p.le:     -    [bl o ck]:   (gr o up):   {fe n ce}: ]
</code></pre>
<hr>
<pre><code>    ::      [  word:   tu.p.le:     #    [bl o ck]:   (gr o up):   {fe n ce}: ]
</code></pre>
<hr>
<pre><code>    ::      [  word:   tu.p.le:    !!!   [bl o ck]:   (gr o up):   {fe n ce}: ]
</code></pre>
<hr>
<pre><code>    ::      [  word:   tu.p.le:  &lt;dead&gt;  [bl o ck]:   (gr o up):   {fe n ce}: ]
</code></pre>
<hr>
<pre><code>    ::      [  word:   tu.p.le:  ~null~  [bl o ck]:   (gr o up):   {fe n ce}: ]
</code></pre>
<hr>
<pre><code>    ::      [  word:   tu.p.le:  ~dead~  [bl o ck]:   (gr o up):  {fe n ce}: ]
</code></pre>
<hr>
<pre><code>    ::      [  word:   tu.p.le:   #dead  [bl o ck]:   (gr o up):  {fe n ce}: ]
</code></pre>
<hr>
<p>In a lot of cases, trash (<strong><code>~</code></strong>) would be the right choice for a "this is invalid slot".  But I feel it doesn't work quite as well in this context.</p>
<pre><code>~null~  [  word    tu.p.le    pa/th    [bl o ck]    (gr o up)    {fe n ce}  ]
::      [  word:   tu.p.le:     ~      [bl o ck]:   (gr o up):   {fe n ce}: ]
:       [ :word   :tu.p.le      ~     :[bl o ck]   :(gr o up)   :{fe n ce}  ]
^       [ ^word   ^tu.p.le   ^pa/th   ^[bl o ck]   ^(gr o up)   ^{fe n ce}  ]
</code></pre>
<p>Visually the best choice may be a hyphen, because it divides the space above and below evenly:</p>
<pre><code>~null~  [  word    tu.p.le    pa/th    [bl o ck]    (gr o up)    {fe n ce}  ]
::      [  word:   tu.p.le:     -      [bl o ck]:   (gr o up):   {fe n ce}: ]
:       [ :word   :tu.p.le      -     :[bl o ck]   :(gr o up)   :{fe n ce}  ]
^       [ ^word   ^tu.p.le   ^pa/th   ^[bl o ck]   ^(gr o up)   ^{fe n ce}  ]
</code></pre>
<p>But BLANK! has properties of being weird and unevaluative that probably give it the edge, while looking about the same.  But I'm on the fence, maybe - is good.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/slight_smile.png?v=14" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-7506-note-that-path-and-path-will-become-loadable-again-2" class="anchor" href="https://rebol.metaeducation.com#p-7506-note-that-path-and-path-will-become-loadable-again-2"></a>Note That <code>:pa/th</code> and <code>pa/th:</code> Will Become LOADable Again...</h2>
<p>You just won't ask about colons applied on the head or tail of the paths, because you'll have to "dig" to find the chains underneath.</p>
          <p><a href="https://rebol.metaeducation.com/t/nice-blank-moment-while-killing-get-path-set-path/2241/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/nice-blank-moment-while-killing-get-path-set-path/2241/1</link>
        <pubDate>Sat, 31 Aug 2024 20:27:34 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2241-1</guid>
        <source url="https://rebol.metaeducation.com/t/nice-blank-moment-while-killing-get-path-set-path/2241.rss">Nice Blank Moment While Killing GET-PATH!/SET-PATH!</source>
      </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>BLOCK! and OBJECT! Parity in Pathing/Picking</title>
    <link>https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086</link>
    <description>[quote=&quot;hostilefork, post:1, topic:349&quot;]
```
red&gt;&gt; block: [foo 10 bar 20 baz: 30]

red&gt;&gt; block.bar
== 20

red&gt;&gt; block.baz
== 30
```

Is this coming from use of some equality testing operator, that thinks WORD! is equal to SET-WORD! of the same spelling?

Since Ren-C has evolved such that &quot;PICKing&quot; and &quot;POKEing&quot; are driven by the same code that does paths (hence &quot;path picking&quot; and not &quot;path selection&quot;), we might say that only SET-WORD!s are considered candidates for picked words:

```
&gt;&gt; block: [foo: bar bar: 20 baz: 30]

&gt;&gt; foo.bar
== 20   ; not `bar:`
```
[/quote]

Given the `[word &quot;Value&quot;]` pattern is very common, I&#39;d be loathe to force set-words in order to make that accessible. Aside from anything else, there&#39;d be a dramatic rise in usage of QUOTE. My beef with **`(foo: [bar &quot;Baz&quot;], foo.bar)`** is that I feel it should be restricted to odd-numbered words (I have [Red ticket #2850](https://github.com/red/red/issues/2850) open on this—had intended to open a parallel Ren-C ticket).</description>
    
    <lastBuildDate>Tue, 29 Apr 2025 01:48:16 +0000</lastBuildDate>
    <category>Internals</category>
    <atom:link href="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>BLOCK! and OBJECT! Parity in Pathing/Picking</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>6 posts were merged into an existing topic: <a href="https://rebol.metaeducation.com/t/portable-bridge-notation-pbn-parser/1306/4">Portable Bridge Notation (PBN) Parser</a></p>
          <p><a href="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086/12">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086/12</link>
        <pubDate>Sat, 10 May 2025 09:45:29 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1086-12</guid>
        <source url="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086.rss">BLOCK! and OBJECT! Parity in Pathing/Picking</source>
      </item>
      <item>
        <title>BLOCK! and OBJECT! Parity in Pathing/Picking</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>A post was merged into an existing topic: <a href="https://rebol.metaeducation.com/t/strict-equality-lax-equality-equivalence-sameness/349/19">Strict Equality, Lax Equality, Equivalence, Sameness</a></p>
          <p><a href="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086/5">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086/5</link>
        <pubDate>Tue, 29 Apr 2025 01:53:45 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1086-5</guid>
        <source url="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086.rss">BLOCK! and OBJECT! Parity in Pathing/Picking</source>
      </item>
      <item>
        <title>BLOCK! and OBJECT! Parity in Pathing/Picking</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>As another point on BLOCK! and OBJECT! parity, people seemed to think you could SET an OBJECT! to a block.</p>
<pre><code>rebol2&gt;&gt; o: make object! [x: 10 y: 20]

rebol2&gt;&gt; mold o
== {make object! [
    x: 10
    y: 20
]}

rebol2&gt;&gt; set o [30 40]
== [30 40]

rebol2&gt;&gt; mold o
== {make object! [
    x: 30
    y: 40
]}
</code></pre>
<p>Here we see a hardened assumption that objects have fields and they are ordered.  Red has carried this assumption forward.</p>
<p>It complicates features that try to be "more than blocks".  e.g. when R3-Alpha added "hidden" fields there was no definition of what SET via BLOCK! would do to it, so it just said "not allowed: would expose or modify hidden values."</p>
<p>But it suggests the kinship to blocks being far closer than one would think.  This raises deep questions for the system.  And I feel like there's no way to answer those questions without putting stakes in the ground and listing the things that <em>must</em> work.</p>
<p><em>(Clearly hiding fields doesn't have to work with SET.  What's the justification that all bets are off then?)</em></p>
          <p><a href="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086/11">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086/11</link>
        <pubDate>Sat, 16 Mar 2019 17:20:03 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1086-11</guid>
        <source url="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086.rss">BLOCK! and OBJECT! Parity in Pathing/Picking</source>
      </item>
      <item>
        <title>BLOCK! and OBJECT! Parity in Pathing/Picking</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="MarkEye" data-post="7" data-topic="1086" data-full="true">
<div class="title">
<div class="quote-controls"></div>
 MarkEye:</div>
<blockquote>
<p>Given your demonstration <code>block</code> , what should <code>block.x: 7</code> do?</p>
</blockquote>
</aside>
<p>Good question, also what would <code>block.y: 30</code> do.  Presumably they'd either have to error -or- detach the set from the related instances, copying values if necessary.  Also to consider:  <strong>block: [final:] block.final: 10</strong></p>
<p>Red recently revived old debates over whether SET-PATH! should be able to add to blocks, or if you should have to use append.  OBJECT!s don't let you set or get keys that aren't there (which protects against typos), and don't let you delete keys...because integer-based existing bindings would be invalidated if those slots wound up being reused.</p>
<p>But I guess the thing to think about here is common use cases.  Perhaps the real parallel is to MAP!, and arbitrary additions and removals should be allowed.  I don't know, but either way there are more tools available to think about this.</p>
          <p><a href="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086/10">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086/10</link>
        <pubDate>Tue, 26 Feb 2019 06:59:37 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1086-10</guid>
        <source url="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086.rss">BLOCK! and OBJECT! Parity in Pathing/Picking</source>
      </item>
      <item>
        <title>BLOCK! and OBJECT! Parity in Pathing/Picking</title>
        <dc:creator><![CDATA[rgchris]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="1086">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>If we changed SELECT to a /SKIP default of 2, and went with the SET-WORD!-based behavior for pathing (hence also PICK+POKE), would that make everyone happy?</strong></p>
</blockquote>
</aside>
<p>I'd not be against giving this a try—my main objection to the Rebol 2 behaviour was the unexpectedness in the <strong>[a b b c]</strong> example. It would be good to have a literate counterpart—a refinement of SELECT (and FIND) that echoes the pathing behaviour. Not quite sure what that'd be for the poking equivalent though.</p>
          <p><a href="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086/8">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086/8</link>
        <pubDate>Tue, 26 Feb 2019 05:08:28 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1086-8</guid>
        <source url="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086.rss">BLOCK! and OBJECT! Parity in Pathing/Picking</source>
      </item>
      <item>
        <title>BLOCK! and OBJECT! Parity in Pathing/Picking</title>
        <dc:creator><![CDATA[Mark-hi]]></dc:creator>
        <description><![CDATA[
            <p>Given your demonstration <code>block</code>, what should <code>block.x: 7</code> do?</p>
          <p><a href="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086/7">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086/7</link>
        <pubDate>Tue, 26 Feb 2019 04:16:12 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1086-7</guid>
        <source url="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086.rss">BLOCK! and OBJECT! Parity in Pathing/Picking</source>
      </item>
      <item>
        <title>BLOCK! and OBJECT! Parity in Pathing/Picking</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <h2><a name="p-3107-lets-take-this-from-the-top-1" class="anchor" href="https://rebol.metaeducation.com#p-3107-lets-take-this-from-the-top-1"></a>Let's Take This From The Top...</h2>
<p>Rebol didn't have any great answer for "object literals" and "map literals".  Yet literal objects ("dictionaries") are critical to JSON.  So it has seemed that Rebol needs an answer here.</p>
<p>Notationally we're at a bit of a loss of how to represent them.  But something I began to wonder is if Rebol has been losing some of its advantage of having a SET-WORD! type.  If you look at:</p>
<pre><code>array: [foo &lt;baz&gt; #bar]
dictionary: [field1: ... field2: ...]
</code></pre>
<p>Couldn't it just be that the presence of SET-WORD!s in the dictionary-like thing is what gives you the tip-off?  Why exchange files with literal objects, instead of doing it with blocks?  The kinds of data exchanges we see using such forms are not rigorously glued to a schema--by design--the concept is that the sender and recipient are on the same page about things.</p>
<p>There may be little benefit to having another container type saying "this is an object", <em>if objects and blocks act more or less interchangeably when used with keyed access</em>.  The user of the data would have the option to make a block into an object if they needed to, or not if they didnt?</p>
<p>I've suggested before that I feel there's something wrong with "pickquality", where it's the idea that picking and pathing consider WORD!, SET-WORD!, ISSUE!, etc. to be equal.  I felt that if BLOCK!s are used for keyed access in this way, they should use SET-WORD!s...and then the seeking process in the block can look specifically for them.  If we use "scant evaluation", then this could even allow for SET-WORD! values.</p>
<h2><a name="p-3107-demonstration-2" class="anchor" href="https://rebol.metaeducation.com#p-3107-demonstration-2"></a>Demonstration</h2>
<pre><code>block: [
    &lt;meta-tag 1&gt; &lt;meta-tag-2&gt; #meta-issue
    string: "hello"
    x: y: 100
    code: '(1 + 2)
    setword: 'something:
]

&gt;&gt; block.string
== "hello"  ; skips info before set-word!

&gt;&gt; block.x
== 100  ; advances to first non-set-word value

&gt;&gt; block.code
== (1 + 2)  ; "scant" evaluation, removes quote

 &gt;&gt; block.setword
 == something:  ; also "scant" evaluation
</code></pre>
<p>Imagine being able to manipulate the block in a way that has parity with how it would act if it were an object.  So getting the quoting if necessary:</p>
<pre><code>&gt;&gt; block: [thing: 10]

&gt;&gt; block.thing: first [a b c]

&gt;&gt; block
== [thing: 'a]
</code></pre>
<p>You don't want tuple access to trigger an actual evaluation of something that isn't inert or quoted, so that should give an error:</p>
<pre><code> &gt;&gt; block: [thing: (1 + 2)]
 &gt;&gt; block.thing
 ** Error: keyed access of block only works on inert and quoted types
</code></pre>
<p>To me, this really feels like a coherent direction, with something that has been very lacking in coherence historically.</p>
<h2><a name="p-3107-cowpathshttpsrebolmetaeducationcomtstrict-equality-lax-equality-equivalence-sameness-is-and3495uhostilefork-3" class="anchor" href="https://rebol.metaeducation.com#p-3107-cowpathshttpsrebolmetaeducationcomtstrict-equality-lax-equality-equivalence-sameness-is-and3495uhostilefork-3"></a><a href="https://rebol.metaeducation.com/t/strict-equality-lax-equality-equivalence-sameness-is-and/349/5">Cowpaths</a></h2>
<p><a class="mention" href="https://rebol.metaeducation.com/u/rgchris">@rgchris</a> very much likes the freedom in blocks to say <strong>[a 1 b 2]</strong> and not <strong>[a: 1 b: 2]</strong>.  So his direction of cleanup of the historical behavior would be to treat blocks as collections of 2-element records, which would prevent confusion if you wrote <strong>[a b b 2]</strong>.</p>
<p>I appreciate wanting to have this choice.  But for picking, I like this parity with objects idea.  I do not feel like enforcing the SET-WORD!s at odd numbered positions feels like the right choice there...I'd like to be able to be more free-form, as I would be able to do with MAKE OBJECT!.  It addresses several dark corners, and I think that it will make blocks stronger for data exchange.</p>
<p>Pathing and selection are already not the same (as block.2 gives you the second item of the block, not an item immediately following an INTEGER! 2 inside the block).  <strong>If we changed SELECT to a :SKIP default of 2, and went with the SET-WORD!-based behavior for picking and poking, would that make everyone happy?</strong></p>
<pre><code>&gt;&gt; select [a b b 2] 'a
== b

&gt;&gt; select [a b b 2] 'b
== 2
</code></pre>
<p>And I'd suggest that SELECT would have you use the data type you were selecting on.  So it would not consider SET-WORD! and WORD! the same (nor ISSUE! and WORD!, etc.)</p>
<p>In any case, the idea is that the SELECT command is about treating a block as records of fixed size.  I don't know if that means that it should not be used with objects (preferring PICK).  It might be clarifying.  PICK is a shorter word.</p>
<p><em>(I also don't know what the applications are to having SELECT default to 2 characters at a time when selecting from strings.  But then again, I'm not really sure what sort of scenarios would get people to select out of a string in the first place, if all you get back is a single character.  Should it be limited to just ANY-ARRAY!?)</em></p>
          <p><a href="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086/6">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086/6</link>
        <pubDate>Mon, 25 Feb 2019 22:43:26 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1086-6</guid>
        <source url="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086.rss">BLOCK! and OBJECT! Parity in Pathing/Picking</source>
      </item>
      <item>
        <title>BLOCK! and OBJECT! Parity in Pathing/Picking</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="rgchris" data-post="3" data-topic="1086">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I feel we're unpaving the cowpaths here.</p>
</blockquote>
</aside>
<p>Carl did argue that <strong><code>Key: Value</code></strong> was Rebol's parallel to <strong><code>&lt;Key&gt;Value&lt;/Key&gt;</code></strong>...</p>
<p>It all boils down to invariance. Who's writing this code that is supposed to be able to remain unchanged when you morph <strong>scores: [Bill: 7 Ted: 8]</strong> into scores: <strong>[Bill 7 Ted 8]</strong> or scores: <strong>[<span class="hashtag-raw">#Bill</span> 7 'Ted 8]</strong>?</p>
<p>If these invariances are nonsense (I believe they are) then I don't see why having to use a construct that says what kind of thing you're looking for, <strong>scores.'bill</strong> vs <strong>scores.bill</strong> vs. <strong>scores.[<span class="hashtag-raw">#bill</span>]</strong> is so bad.</p>
<p>I'm just not liking this fourth equality operator, the "one used by pick".  If we are going to say:</p>
<pre><code>picky-equal? 'foo: 'foo
== ~okay~  ; anti
</code></pre>
<p>Then it seems [foo:] and [foo] are also <em>"picky-equal?"</em>, and I don't like that.  Where does it stop?</p>
<p>I'd like us to kill off "pickquality" because its existence raises a lot of technical problems.  But if we keep it, it needs to be reined in to specific use cases</p>
          <p><a href="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086/4</link>
        <pubDate>Tue, 24 Oct 2017 17:24:49 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1086-4</guid>
        <source url="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086.rss">BLOCK! and OBJECT! Parity in Pathing/Picking</source>
      </item>
      <item>
        <title>BLOCK! and OBJECT! Parity in Pathing/Picking</title>
        <dc:creator><![CDATA[rgchris]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1086">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>The odd-numbering doesn't strike me as particularly useful in the dialect-driven world of Rebol.  I kind of imagine formats where I might throw in comments or strings or have a dialect that augments some assignments</p>
</blockquote>
</aside>
<p>My inclination is that tuple <code>foo.bar</code> notation is near exclusively associated with the notion of key/value-paired data. It's used with objects, ports, maps and predominantly key/value blocks. I'd suggest that having the following example work as expected is of greater value than hypothetical irregular dialects:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">data: [foo bar bar baz]
data.bar
</code></pre>
<p>This is a longstanding frustration and source of confusion (and bugs).</p>
<hr>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1086">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>We could also consider block.'foo to mean a WORD!-search.</p>
</blockquote>
</aside>
<p>I feel we're unpaving the cowpaths here. We're making it harder (and uglier) to do the most elementary and common things in the hopes that the set-word behaviour is more useful. I don't think tuples should get more complex—that complexity should be passed to functions like SELECT and FIND.</p>
          <p><a href="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086/3</link>
        <pubDate>Tue, 24 Oct 2017 02:54:01 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1086-3</guid>
        <source url="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086.rss">BLOCK! and OBJECT! Parity in Pathing/Picking</source>
      </item>
      <item>
        <title>BLOCK! and OBJECT! Parity in Pathing/Picking</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="rgchris" data-post="1" data-topic="2428">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/prefix-approx-modifier-would-it-be-possible/2428/1">Prefix APPROX Modifier... Would It Be Possible?</a></div>
<blockquote>
<p>Given the [word "Value"] pattern is very common, I'd be loathe to force set-words in order to make that accessible. Aside from anything else, there'd be a dramatic rise in usage of QUOTE.</p>
</blockquote>
</aside>
<p>We could also consider <strong>block.'foo</strong> to mean a WORD!-search.  Or we could try for <strong><code>block.['word]</code></strong> or <strong><code>block.[word:]</code></strong> or <strong><code>block.[&lt;first&gt; #second]</code></strong> as a way of searching for a general value or sequence of values.</p>
<p>It's just my feeling that the randomness of "I don't know what type it is" probably doesn't have a lot of good usages.</p>
<p><em>(Note: Since pathing itself has no refinements, any searching it does is fixed on a certain choice of "equality".)</em></p>
<aside class="quote no-group quote-modified" data-username="rgchris" data-post="1" data-topic="2428">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/prefix-approx-modifier-would-it-be-possible/2428/1">Prefix APPROX Modifier... Would It Be Possible?</a></div>
<blockquote>
<p>My beef with (foo: [bar "Baz"], foo.bar) is that I feel it should be restricted to odd-numbered words</p>
</blockquote>
</aside>
<p>The odd-numbering doesn't strike me as particularly useful in the dialect-driven world of Rebol.  I kind of imagine formats where I might throw in comments or strings or have a dialect that augments some assignments:</p>
<pre><code>stuff: [
    "Maybe strings are commentary"
    cool
    x: 10
    y: 20
    /cool
]
</code></pre>
<p>It seems that being able to query SET-WORD!s is more generically useful.  Maybe even to the point of never returning a SET-WORD!, but to keep skipping.  So <strong>block: [foo: baz: 10]</strong> where <code>block.foo</code> and <code>block.baz</code> would both come back with 10.</p>
          <p><a href="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086/2</link>
        <pubDate>Tue, 24 Oct 2017 00:37:51 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1086-2</guid>
        <source url="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086.rss">BLOCK! and OBJECT! Parity in Pathing/Picking</source>
      </item>
      <item>
        <title>BLOCK! and OBJECT! Parity in Pathing/Picking</title>
        <dc:creator><![CDATA[rgchris]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="349">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/strict-equality-lax-equality-equivalence-sameness/349/1">Strict Equality, Lax Equality, Equivalence, Sameness</a></div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">red&gt;&gt; block: [foo 10 bar 20 baz: 30]

red&gt;&gt; block.bar
== 20

red&gt;&gt; block.baz
== 30
</code></pre>
<p>Is this coming from use of some equality testing operator, that thinks WORD! is equal to SET-WORD! of the same spelling?</p>
<p>Since Ren-C has evolved such that "PICKing" and "POKEing" are driven by the same code that does paths (hence "path picking" and not "path selection"), we might say that only SET-WORD!s are considered candidates for picked words:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; block: [foo: bar bar: 20 baz: 30]

&gt;&gt; foo.bar
== 20   ; not `bar:`
</code></pre>
</blockquote>
</aside>
<p>Given the <code>[word "Value"]</code> pattern is very common, I'd be loathe to force set-words in order to make that accessible. Aside from anything else, there'd be a dramatic rise in usage of QUOTE. My beef with <strong><code>(foo: [bar "Baz"], foo.bar)</code></strong> is that I feel it should be restricted to odd-numbered words (I have <a href="https://github.com/red/red/issues/2850">Red ticket #2850</a> open on this—had intended to open a parallel Ren-C ticket).</p>
          <p><a href="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086/1</link>
        <pubDate>Mon, 23 Oct 2017 05:12:17 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1086-1</guid>
        <source url="https://rebol.metaeducation.com/t/block-and-object-parity-in-pathing-picking/1086.rss">BLOCK! and OBJECT! Parity in Pathing/Picking</source>
      </item>
  </channel>
</rss>

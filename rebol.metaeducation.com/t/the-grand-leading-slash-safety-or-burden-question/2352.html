<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>The Grand Leading-Slash &quot;Safety, or Burden?&quot; Question - Philosophy - AltRebol</title>
    <meta name="description" content="Overall, I have been tremendously happy with how the ideas of the Big Alien Proposal have worked out. 
That started from the concept that when slashes appear, they either come before a function they run, or after a funct&amp;hellip;">
    <meta name="generator" content="Discourse 3.5.0.beta6-dev - https://github.com/discourse/discourse version 623cde985b21c2ed812b83d3ea94f69231613718">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/1X/cbd70027b53fa165575e5b665f00eb3b8ae7ea31_2_32x32.ico">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d_2_180x180.png">
<meta name="theme-color" media="all" content="#fff">

<meta name="color-scheme" content="light">

<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, viewport-fit=cover">
<link rel="canonical" href="2352.html" />

<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="AltRebol Search">

    <link href="https://rebol.metaeducation.com/stylesheets/color_definitions_base__2_ceb61c279a74dfa3cef6a62f7784988102abec82.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" class="light-scheme"/>

<link href="https://rebol.metaeducation.com/stylesheets/common_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="common"  />

  <link href="https://rebol.metaeducation.com/stylesheets/desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="desktop"  />



    <link href="https://rebol.metaeducation.com/stylesheets/chat_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="chat"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-details_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-details"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-lazy-videos_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-lazy-videos"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-local-dates_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-local-dates"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-narrative-bot_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-narrative-bot"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-presence_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-presence"  />
    <link href="https://rebol.metaeducation.com/stylesheets/docker_manager_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="docker_manager"  />
    <link href="https://rebol.metaeducation.com/stylesheets/footnote_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="footnote"  />
    <link href="https://rebol.metaeducation.com/stylesheets/poll_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="poll"  />
    <link href="https://rebol.metaeducation.com/stylesheets/spoiler-alert_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="spoiler-alert"  />
    <link href="https://rebol.metaeducation.com/stylesheets/chat_desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="chat_desktop"  />
    <link href="https://rebol.metaeducation.com/stylesheets/poll_desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="poll_desktop"  />

  <link href="https://rebol.metaeducation.com/stylesheets/common_theme_2_57fe803ed5a41e9f7d94086afaf66a1aab57d9ae.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="common_theme" data-theme-id="2" data-theme-name="default"/>
    

    
    
        <link rel="alternate nofollow" type="application/rss+xml" title="RSS feed of &#39;The Grand Leading-Slash &quot;Safety, or Burden?&quot; Question&#39;" href="2352.rss" />
    <meta property="og:site_name" content="AltRebol" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:image" content="https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:url" content="https://rebol.metaeducation.com/t/the-grand-leading-slash-safety-or-burden-question/2352" />
<meta name="twitter:url" content="https://rebol.metaeducation.com/t/the-grand-leading-slash-safety-or-burden-question/2352" />
<meta property="og:title" content="The Grand Leading-Slash &quot;Safety, or Burden?&quot; Question" />
<meta name="twitter:title" content="The Grand Leading-Slash &quot;Safety, or Burden?&quot; Question" />
<meta property="og:description" content="Overall, I have been tremendously happy with how the ideas of the Big Alien Proposal have worked out.  That started from the concept that when slashes appear, they either come before a function they run, or after a function they suppress execution for.  foo.bar ; ^-- foo is an entity from which BAR is being selected.  BAR is not ; allowed to be an antiform frame, so this syntax cannot invoke a ; function call (though it can invoke an &#39;accessor&#39;, e.g. a &quot;getter&quot; ; which is 0-arity).  foo/bar ; ^-..." />
<meta name="twitter:description" content="Overall, I have been tremendously happy with how the ideas of the Big Alien Proposal have worked out.  That started from the concept that when slashes appear, they either come before a function they run, or after a function they suppress execution for.  foo.bar ; ^-- foo is an entity from which BAR is being selected.  BAR is not ; allowed to be an antiform frame, so this syntax cannot invoke a ; function call (though it can invoke an &#39;accessor&#39;, e.g. a &quot;getter&quot; ; which is 0-arity).  foo/bar ; ^-..." />
<meta property="og:article:section" content="Usage" />
<meta property="og:article:section:color" content="3AB54A" />
<meta property="og:article:section" content="Philosophy" />
<meta property="og:article:section:color" content="3AB54A" />
<meta name="twitter:label1" value="Reading time" />
<meta name="twitter:data1" value="8 mins 🕑" />
<meta name="twitter:label2" value="Likes" />
<meta name="twitter:data2" value="5 ❤" />
<meta property="article:published_time" content="2024-12-19T01:12:09+00:00" />
<meta property="og:ignore_canonical" content="true" />


    
  </head>
  <body class="crawler ">
    
    <header>
  <a href="https://rebol.metaeducation.com/">AltRebol</a>
</header>

    <div id="main-outlet" class="wrap" role="main">
        <div id="topic-title">
    <h1>
      <a href="2352.html">The Grand Leading-Slash &quot;Safety, or Burden?&quot; Question</a>
    </h1>

      <div class="topic-category" itemscope itemtype="http://schema.org/BreadcrumbList">
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://rebol.metaeducation.com/c/usage/philosophy/31" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #3AB54A'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Usage</span>
              </span>
            </a>
            <meta itemprop="position" content="1" />
          </span>
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://rebol.metaeducation.com/c/usage/philosophy/31" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #3AB54A'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Philosophy</span>
              </span>
            </a>
            <meta itemprop="position" content="2" />
          </span>
      </div>

  </div>

  

    <div itemscope itemtype='http://schema.org/DiscussionForumPosting'>
      <meta itemprop='headline' content='The Grand Leading-Slash &quot;Safety, or Burden?&quot; Question'>
      <link itemprop='url' href='2352.html'>
      <meta itemprop='datePublished' content='2024-12-19T01:12:09Z'>
        <meta itemprop='articleSection' content='Philosophy'>
      <meta itemprop='keywords' content=''>
      <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
        <meta itemprop='name' content='AltRebol'>
          <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
            <meta itemprop='url' content='https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
          </div>
      </div>


          <div id='post_1'  class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>

                <link itemprop="mainEntityOfPage" href="2352.html">


              <span class="crawler-post-infos">
                  <time  datetime='2024-12-19T01:12:09Z' class='post-time'>
                    December 19, 2024,  1:12am
                  </time>
                  <meta itemprop='dateModified' content='2024-12-19T01:12:09Z'>
              <span itemprop='position'>1</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>Overall, I have been tremendously happy with how the ideas of the <strong><a href="https://rebol.metaeducation.com/t/big-alien-proposal-word-runs-functions/1905">Big Alien Proposal</a></strong> have worked out.</p>
<p>That started from the concept that when slashes appear, they either come <em>before</em> a function they run, or <em>after</em> a function they suppress execution for.</p>
<pre><code>foo.bar
; ^-- foo is an entity from which BAR is being selected.  BAR is not
; allowed to be an antiform frame, so this syntax cannot invoke a
; function call (though it can invoke an 'accessor', e.g. a "getter"
; which is 0-arity).

foo/bar
; ^-- foo is an entity from which BAR (an a FRAME! or antiform FRAME!)
; is being selected and then invoked.  This will generate an error if
; bar is not a frame or antiform frame.

foo.bar/
; ^-- bar is a field which is an antiform FRAME!, whose execution is
; being suppressed.  This expression will return an antiform frame, or
; an error if not an antiform frame.

foo
; ^-- conventional WORD! reference, will run an antiform frame as an
; action invocation or fetch other values as-is

/foo
; ^-- invocation reference, will run an antiform frame (or plain frame)
; as an action invocation and give errors on other types

foo/
; ^-- action suppression, will give you back an antiform frame as-is
; and error on other types.
</code></pre>
<p><em>(If you're curious about why <strong><code>/foo</code></strong> will run plain FRAME! as well as antiform, while <strong><code>foo/</code></strong> will not return an antiform frame for plain FRAME!, this is based on the idea that it's better to be conservative when fetching values so that you won't get surprised by getting a plain frame back from <strong><code>foo/</code>~</strong> which gives everything back as-is.)</em></p>
<hr>
<p>I've written elsewhere <a href="https://rebol.metaeducation.com/t/trailing-slash-is-a-winner-for-defused-actions/2327">how pleased I am that the way you suppress a function's execution is by throwing up a "barrier"</a> with a separating slash that makes it clear arguments are not being gathered at the callsite.  That's really slick.</p>
<p>For this idea to work, something else had to be used for refinements.  That meant <a href="../introducingnew-chain-datatype/2226.html">invention of the CHAIN! datatype</a> has opened a lot of interesting doors, and I find it's quite learnable to see things like <strong><code>trim:auto:tail</code></strong> instead of <strong><code>trim/auto/tail</code></strong>.</p>
<p><em>I actually prefer it!</em>  What some might think of a disadvantage of being "less noticeable" turns into an advantage... <strong><code>trim:auto</code></strong> really could have been a function called <strong><code>trim-auto</code></strong> just as easily.  Why would you want a slash to make the fact that it has a refinement "pop"?  The slashes to make function calls or suppression pop are much better applied.</p>
<p><strong>So that's all good. <img src="../../images/emoji/twitter/smile_cat.png%3Fv=14" title=":smile_cat:" class="emoji" alt=":smile_cat:" loading="lazy" width="20" height="20"> No regrets!</strong></p>
<h2><a name="p-7975-but-leading-slash-for-functions-rule-hasnt-100-geld-1" class="anchor" href="2352.html#p-7975-but-leading-slash-for-functions-rule-hasnt-100-geld-1"></a>But... Leading-Slash For Functions Rule Hasn't 100% Gel'd</h2>
<p>Another part of the proposal was that in order to get tighter control on what was a function or not, you would be required to assign functions using a leading-slash kind of SET-WORD!.</p>
<pre><code>&gt;&gt; foo: func [a b] [return a + b]
** Error: FOO: can't be used to assign antiform FRAME!, use /FOO:

&gt;&gt; /foo: func [a b] [return a + b]
== ~#[frame! "foo" [a b]]]~  ; anti
</code></pre>
<p><strong>It hasn't fully settled with me after working with it for some time.</strong></p>
<p>As I mentioned above, colons for refinements was easy to adapt to...and now that I'm adapted, I prefer it.</p>
<p>But I'm still typing <strong><code>test: cascade [add/ even?/]</code></strong>.  I love the trailing slashes (and this will be even better when the whole cascade can be done with just <strong><code>even?/add/</code></strong>).  But I'm kind of cursing under my breath the thought of having typed <strong><code>test:</code></strong> and having to backspace over it so it says <strong><code>/test:</code></strong>.  And then I go "hrmph."</p>
<p>When I'm reading code, I probably appreciate it more than I find it to be "messy".  It gives you a better compass.  The eye can scan and comprehend much better... it's of particular value when you're not using an obvious function generator like FUNC, but something else.  This cues readers to go "oh, I guess that's a function generator".</p>
<p>Yet still... it's a burden in a way the other changes are not.  It's the only change that increases the character count.</p>
<h2><a name="p-7975-whats-at-stake-by-not-enforcing-this-2" class="anchor" href="2352.html#p-7975-whats-at-stake-by-not-enforcing-this-2"></a>What's At Stake By Not Enforcing This?</h2>
<p>Ren-C has a powerful story about how antiforms can't be put in blocks, which means you can write this kind of code and it "just works":</p>
<pre><code>block2: collect [
    for-each 'item block1 [keep item]
]

assert [equal? block1 block2]
</code></pre>
<p>When you compare it to Rebol2/R3-Alpha/Red, it's one of those vastly superior situations.  You aren't getting tricked into receiving an ITEM in the FOR-EACH that would generate an unset variable error, or conflate with the state that gets returned when an item can't be picked from a block, or accidentally run a function.  It's a solid solution.</p>
<p>But that's only for blocks.  What about other places, like objects?</p>
<p>If we don't put barriers on how action antiforms get assigned to variables, we get the problem all over again:</p>
<pre><code>for-each [key value] obj [
    if integer? value [  ; oops, what if VALUE is an action antiform!
        print "Found an integer"
    ]
]
</code></pre>
<p>There's no way in this case to say "variables can't hold antiforms".  Logic is an antiform.  Words holding antiform frames are actions.</p>
<p>Getting this under control with slashes is the kind of thing I've been trying to do for a long time, I've just never had the syntax.  Leading slashes felt like it could be the key:</p>
<pre><code>for-each [key value] obj [...]  ; value can't be frame antiform

for-each [key /value] obj [...]  ; value must be frame antiform

for-each [key ~/value] obj [...]  ; value may be frame antiform
</code></pre>
<p>But if these rules are applied everywhere, what you have to do gets more complex:</p>
<pre><code>set $x does [print "Is this an error?"]

set $/x does [print "Do you have to do this?"]

&gt;&gt; var: $x
== x  ; bound

set var does [print "If this errors, how to make VAR into bound /x?"]

set:active var does [print "Do you use refinements?"] (or just SET:ANY ?)
</code></pre>
<p>Nothing is free.  And the already more complicated world where <strong><code>x:</code></strong> is a CHAIN! instead of a fundamental different type of word has its own issues, that these all pile on top of.</p>
<h2><a name="p-7975-theres-likely-not-enough-value-in-optional-slash-3" class="anchor" href="2352.html#p-7975-theres-likely-not-enough-value-in-optional-slash-3"></a>There's Likely Not Enough Value In Optional Slash</h2>
<p>If <strong><code>/foo: func [...] [...]</code></strong> will enforce that the thing you're assigning is an antiform action, but <strong><code>foo: func [...] [...]</code></strong> still works... I have a feeling that the complexity it takes to offer the feature doesn't give a sufficient payoff to be worth it.</p>
<p>You have everyone paying the tax of dealing with complicated path structures and bookkeeping--vs. being able to just SET and GET words and tuples at will... and then you're not even giving any additional guarantees in the source.</p>
<p>This makes me feel like it really is an all-in or not-at-all situation.</p>
<h2><a name="p-7975-long-story-short-im-still-weighing-it-4" class="anchor" href="2352.html#p-7975-long-story-short-im-still-weighing-it-4"></a>Long Story Short: I'm Still Weighing It</h2>
<p>I'm not ready to make a verdict.</p>
<p>The techniques for working with these new CHAIN! and PATH! situations are still being learned.  Most of my hesitance isn't from the looks or typing an extra character, but from frustrations in that...and maybe that frustration will lessen as I work on it more.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="2" />
              <span class='post-likes'>2 Likes</span>
            </div>

          </div>
          <div id='post_2' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2025-03-25T14:22:54Z' class='post-time'>
                    March 25, 2025,  2:22pm
                  </time>
                  <meta itemprop='dateModified' content='2025-03-26T02:06:22Z'>
              <span itemprop='position'>2</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2352">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Another part of the proposal was that in order to get tighter control on what was a function or not, you would be required to assign functions using a leading-slash kind of SET-WORD!.</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; foo: func [a b] [return a + b]
** Error: FOO: can't be used to assign antiform FRAME!, use /FOO:

&gt;&gt; /foo: func [a b] [return a + b]
== ~#[frame! "foo" [a b]]]~  ; anti
</code></pre>
<p>It hasn't fully settled with me after working with it for some time.</p>
</blockquote>
</aside>
<p>If it can't settle with me, it will certainly put others off, and lose a major aspect of the clean feeling of the language.</p>
<p>Having done a whole lot of soul-searching, I feel like the answer has to be: <strong>it's optional</strong> <em>(though possibly specifiable as required via a per-module "strict" mode)</em>.</p>
<p>It's nice to have a shorthand for <strong><code>foo: ensure action! ...</code></strong> and so I don't think the feature should be thrown out.  But when you're writing <strong><code>foo: func [...] [...]</code></strong> you already <em>know</em> it's an action, and being forced to say you do makes the code look junky.</p>
<p>Fortunately, users now have the convenience of terminal slash assuring them the thing they are suppressing evaluation of is an action:</p>
<pre><code>log: print/

log "Nice to know we are sure PRINT was an action"
</code></pre>
<p>So things are incrementally better.  But just by virtue of the way the language works, there's always going to be uncertainties (it's a function, but how do you know it's the right arity function, or takes the right types?)</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2352">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'm not ready to make a verdict.</p>
</blockquote>
</aside>
<p>There may be places where it fits.  The idea that function parameters have to be leading slash in order to be passed as executable actions is the sort of thing that may provide some sanity.  (I've wondered if actions passed to functions should turn into plain FRAME! by default...)</p>
<p>Still more thinking to do, but I've concluded it can't be forcibly required in all use cases.  Maybe if there's some kind of "strict" setting on a module.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="1" />
              <span class='post-likes'>1 Like</span>
            </div>

                <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../replacing-get-word-for-polymorphic-get-any/2392.html">Replacing GET-WORD! for Polymorphic &quot;GET:ANY&quot;</a>
                        <meta itemprop='position' content='1'>
                      </div>
                </div>
          </div>
          <div id='post_3' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2025-03-26T11:27:47Z' class='post-time'>
                    March 26, 2025, 11:27am
                  </time>
                  <meta itemprop='dateModified' content='2025-03-26T14:06:59Z'>
              <span itemprop='position'>3</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2352">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>There may be places where it fits.</p>
</blockquote>
</aside>
<p>Maybe there are some functions that are marked as "generators", and others that are not... such that if you are receiving an antiform action back from a non-generator, then that's when you need the slash?</p>
<pre><code>foo: func [...] [...]  ; generator, no slash needed

/thing: select obj item  ; SELECT not a generator, needs slash?
</code></pre>
<p>It would be much rarer to see the slashes in these cases, but they would be the actual meaningful places to see them.</p>
<p>This could be handled by a "hot potato" bit on values.</p>
<p>Maybe the way you are considered a hot potato is if you don't explicitly mention ACTION! in the return spec.  e.g. if you just say you return <strong><code>[any-value?]</code></strong> then the return of an antiform frame will require the slash.  But if you say <strong><code>[any-value? action!]</code></strong> then you're exempt.  And if you just say <strong><code>[action!]</code></strong> then you're exempt of course.</p>
<p>Kind of an interesting compromise idea, although most hidden-bit ideas have been scrapped.  It's almost like there would be two FRAME! antiforms... a stable one and an unstable one... and generators would return stable forms but non-generators unstable ones, that error unless they find an "aware" receiving site.  <img src="../../images/emoji/twitter/thinking.png%3Fv=14" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20">  It's just an inkling of an idea at the moment.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
          <div id='post_4' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2025-05-06T12:46:46Z' class='post-time'>
                    May 6, 2025, 12:46pm
                  </time>
                  <meta itemprop='dateModified' content='2025-06-02T17:51:34Z'>
              <span itemprop='position'>4</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2352">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>If we don't put barriers on how action antiforms get assigned to variables, we get the problem all over again:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">for-each [key value] obj [
    if integer? value [  ; oops, what if VALUE is an action antiform!
        print "Found an integer"
    ]
]
</code></pre>
<p>There's no way in this case to say "variables can't hold antiforms". Logic is an antiform. Words holding antiform frames are actions.</p>
</blockquote>
</aside>
<p><a href="../on-quickness-italo-calvino/2436.html">Years of fretting... years of thinking... and...</a></p>
<p><img src="../../images/emoji/twitter/crab.png%3Fv=14" title=":crab:" class="emoji only-emoji" alt=":crab:" loading="lazy" width="20" height="20"></p>
<h1><a name="p-8208-double_exclamation_mark-ive-got-the-answer-double_exclamation_mark-1" class="anchor" href="2352.html#p-8208-double_exclamation_mark-ive-got-the-answer-double_exclamation_mark-1"></a><img src="../../images/emoji/twitter/double_exclamation_mark.png%3Fv=14" title=":double_exclamation_mark:" class="emoji" alt=":double_exclamation_mark:" loading="lazy" width="20" height="20"> I'VE GOT <strong>THE</strong> ANSWER <img src="../../images/emoji/twitter/double_exclamation_mark.png%3Fv=14" title=":double_exclamation_mark:" class="emoji" alt=":double_exclamation_mark:" loading="lazy" width="20" height="20"></h1>
<p>Now that there's a new conception of meta-variables, this all comes together.  When you say <strong>(^x: ...)</strong> you're asking to do a lifted-assignment, and when you say <strong>(^x)</strong> you're asking to do unlift when you fetch, without execution.</p>
<p>So now...</p>
<hr>
<pre><code>&gt;&gt; obj: make object! [x: 1020, y: func [x y] [probe x, probe y]]
</code></pre>
<hr>
<pre><code>&gt;&gt; for-each [key value] obj [
       probe value
       if integer? value [print "INTEGER!"] else [print "something else"]
   ]
1020
INTEGER!
** Error: FOR-EACH can't assign antiform action to VALUE, use ^VALUE
</code></pre>
<hr>
<pre><code>&gt;&gt; for-each [key ^value] obj [  ; ask value to be meta-represented
       probe value  ; ordinary fetch meta variable (e.g. quoted or quasiform)
       probe ^value  ; fetch unlifted (compensates for meta-representation)
       if integer? ^value [print "INTEGER!"] else [print "something else"]
   ]
'1020
1020
INTEGER!
~&amp;[frame [x y]]~
\~&amp;[frame [x y]]~\  ; antiform
something else
</code></pre>
<hr>
<h1><a name="p-8208-double_exclamation_mark-this-is-as-good-as-it-gets-double_exclamation_mark-2" class="anchor" href="2352.html#p-8208-double_exclamation_mark-this-is-as-good-as-it-gets-double_exclamation_mark-2"></a><img src="../../images/emoji/twitter/double_exclamation_mark.png%3Fv=14" title=":double_exclamation_mark:" class="emoji" alt=":double_exclamation_mark:" loading="lazy" width="20" height="20"> THIS IS AS GOOD AS IT GETS <img src="../../images/emoji/twitter/double_exclamation_mark.png%3Fv=14" title=":double_exclamation_mark:" class="emoji" alt=":double_exclamation_mark:" loading="lazy" width="20" height="20"></h1>
<p>It takes a bit of liberty in the sense that it's forcing you use meta-representative variables for something that doesn't <em>require</em> it (a plain variable can of course <em>hold</em> an antiform action, that's critical to the implementation of the system).</p>
<p>But it's simply watching your back.  <strong>99% of the time you don't want to be in a situation where you're running a function that you see in an enumeration.</strong>  (This case of an arity-2 function would just start consuming the branches and things after them... a disaster.)</p>
<p>And it's symmetrical: if you start seeing <strong>^value</strong> as sort of being like "the name of the variable" then you would logically line up that your references should match the definition, and use the same name.</p>
<h1><a name="p-8208-wow-3" class="anchor" href="2352.html#p-8208-wow-3"></a>Wow.</h1>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="2" />
              <span class='post-likes'>2 Likes</span>
            </div>

          </div>
          <div id='post_5' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='../../u/BlackATTR.html'><span itemprop='name'>BlackATTR</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2025-05-06T13:03:07Z' class='post-time'>
                    May 6, 2025,  1:03pm
                  </time>
                  <meta itemprop='dateModified' content='2025-05-06T13:03:07Z'>
              <span itemprop='position'>5</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>Thanks Brian—<br>
That’s a beautiful design which allows us to elegantly handle some of the new parts in the box.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
          <div id='post_6' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2025-05-13T12:05:09Z' class='post-time'>
                    May 13, 2025, 12:05pm
                  </time>
                  <meta itemprop='dateModified' content='2025-05-16T08:37:26Z'>
              <span itemprop='position'>6</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="3" data-topic="2352">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">foo: func [...] [...]  ; generator, no slash needed

/thing: select obj item  ; SELECT not a generator, needs slash?
</code></pre>
<p>This could be handled by a "hot potato" bit on values.</p>
<p>Maybe the way you are considered a hot potato is if you don't explicitly mention ACTION! in the return spec. e.g. if you just say you return <strong><code>[any-value?]</code></strong> then the return of an antiform frame will require the slash. But if you say <strong><code>[any-value? action!]</code></strong> then you're exempt. And if you just say <strong><code>[action!]</code></strong> then you're exempt of course.</p>
</blockquote>
</aside>
<h2><a name="p-8270-this-is-the-right-idea-needs-an-operator-1" class="anchor" href="2352.html#p-8270-this-is-the-right-idea-needs-an-operator-1"></a>This Is The Right Idea, Needs An Operator (<code>^</code>)</h2>
<p>We have this problem elsewhere, e.g. the "Surprising Ghost" problem... where a function that returns GHOST! only <em>sometimes</em> can cause disruptions to the structure of code.</p>
<p>In this case, returning an ACTION! only sometimes can be a pain.</p>
<p>The solution for surprising ghosts was that the evaluator would look at a function call, and if it returned a ghost always... allow it.  Otherwise it would not vanish, but if you really wanted it to vanish you could use an operator:</p>
<pre><code>&gt;&gt; 1 + 2 eval [comment "HI"]
== ~,~  ; anti (ghost)

&gt;&gt; 1 + 2 ^ eval [comment "Hi"]
== 1 + 2
</code></pre>
<p>So with the "Surprising Actions" problem, we need a similar rule:</p>
<ul>
<li>
<p>If a function returns an action! always in its type signature, let it.</p>
</li>
<li>
<p>If a function returns an action! <em>sometimes</em> in its type signature, default to a PANIC if it returns an action!</p>
</li>
<li>
<p>Allow use of the <code>^</code> operator to override the panic and produce an ACTION!</p>
</li>
</ul>
<p>So if you write:</p>
<pre><code>x: select obj 'action-field
</code></pre>
<p>Then if you <em>really</em> mean it that you want X to be able to become an action, you have to write:</p>
<pre><code>x: ^ select obj 'action-field
</code></pre>
<p>We can make an exception for metarepresentation assignments:</p>
<pre><code>^x: select obj 'action-field
</code></pre>
<p>But then I think we have to use the same rule as for ghosts when we fetch the representation... e.g. <code>^x</code> will produce a panic if you're holding an action, but <code>^(x)</code> will not.</p>
<p>This can probably be limited to assignments, e.g. <strong><code>return ^x</code></strong> doesn't have any particularly great reason to be cautious, while <strong><code>y: ^x</code></strong> does... so you'd need to write <strong><code>y: ^(x)</code></strong>.    Basically the problem we're trying to solve is the assignment of actions to variables that will run the action, and you need some way of saying "yes, I know what I'm doing here".</p>
<p><strong>This is a satisfying solution.</strong>  It means we don't have to get too wild with the combinatorics of assignments.  But I do think that <strong><code>/foo: ...</code></strong> meaning "I know this is an action assignment, so assert that" is very helpful especially to those reading code, when it's not obvious.</p>
<h2><a name="p-8270-what-are-the-implications-for-foo-2" class="anchor" href="2352.html#p-8270-what-are-the-implications-for-foo-2"></a>What Are The Implications For <code>foo/~</code> ?</h2>
<p>So if I write <strong><code>(bar: foo/)</code></strong> then <strong><code>foo/</code></strong> as the "fetch and ensure it's an ACTION!" operation counts as one of the "actions always" operations that doesn't need a rubber stamp.</p>
<p>But what about <strong><code>foo/~</code></strong>, which has been proposed to be <em>"get as is, don't run actions, arbitrary antiforms are ok"</em>.  That returns actions <em>only sometimes</em>.</p>
<p>I kind of feel like making you write <strong><code>(bar: ^ foo/~)</code></strong> may be worth it, because it reinforces "hey, you might be setting this to an action"... if you were using <code>foo/~</code> to think you were getting unsets or something.  That gives us the necessary operation division: <strong><code>(^ foo/~)</code></strong> is "get me anything including actions" and plain <strong><code>(foo/~)</code></strong> is used for <em>"get me something that may be trash"</em>.</p>
<p>It's a little bit weird but I think it makes sense.  And again, this particular evaluator rule is probably only necessary when you're dealing with assignments.</p>
<h2><a name="p-8270-how-does-this-interact-with-the-for-each-value-idea-3" class="anchor" href="2352.html#p-8270-how-does-this-interact-with-the-for-each-value-idea-3"></a>How Does This Interact With The FOR-EACH ^VALUE Idea?</h2>
<aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="2352">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; for-each [key value] obj [
       probe value
       if integer? value [print "INTEGER!"] else [print "something else"]
   ]
1020
INTEGER!
** Error: FOR-EACH can't assign antiform action to VALUE, use ^VALUE
</code></pre>
</blockquote>
</aside>
<p>So here, we have a bit of an issue, that the operator doesn't go <em>on</em> the value if we wanted the "keep it as a non-meta form, but rubber-stamp ACTION! values"</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">for-each [key ^ value] obj [.
    ...
]
</code></pre>
<p>I don't think I'm that interested in worrying about the concerns of people who want to iterate over objects that contain some actions, some not, but don't want to use the meta-representational protocol.  They don't want to do what they think they want to do.</p>
<p>I <em>might</em> be sympathetic to someone who is iterating over something where they know they're all actions:</p>
<pre><code>for-each [key /action] obj-of-all-actions [.
    ...
]
</code></pre>
<p>There it makes sense to me that you know what you're doing.  But if it's sometimes an action, and sometimes isn't, then I don't buy it that you're not better off with it being meta-represented.</p>
<p>Something that I might accept is the idea that <strong><code>/foo: either condition [action/] [~]</code></strong> is legal.  If you assign trash to a variable that you think is an action, then you get correctly interrupted when you try to use it (vs. a null or something that would keep going).  That would give you an option if you needed a state in your object to represent "no action here", that you could still enumerate using <strong><code>/action</code></strong>.</p>
<h2><a name="p-8270-promising-stuff-4" class="anchor" href="2352.html#p-8270-promising-stuff-4"></a>Promising Stuff...</h2>
<p>Not easy to get it all implemented, but I'm working as fast as I can.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
          <div id='post_7' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2025-07-25T16:45:38Z' class='post-time'>
                    July 25, 2025,  4:45pm
                  </time>
                  <meta itemprop='dateModified' content='2025-07-25T16:45:38Z'>
              <span itemprop='position'>7</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="2352">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Not easy to get it all implemented, but I'm working as fast as I can.</p>
</blockquote>
</aside>
<p>On top of lots of other changes I've been trying to push through, the <strong><a href="../solving-the-pox-of-the-lift-the-universe/2477.html">Lift The Universe</a></strong> design came along and changed ^META representation completely... it's been a long slog to get the system functional.</p>
<p>I'm finally on to resurrecting the samples (things like <a href="../whitespace-interpreter-revisited/1482.html"><strong>The Whitespace Dialect</strong></a>).  So I'm coming up with lots of interesting solutions, and running into some head-scratchers.</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="3" data-topic="2352">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">foo: func [...] [...]  ; generator, no slash needed

/thing: select obj item  ; SELECT not a generator, needs slash?
</code></pre>
<p>It would be much rarer to see the slashes in these cases, but they would be the actual meaningful places to see them.</p>
<p>This could be handled by a "hot potato" bit on values [...] Kind of an interesting compromise idea, although most hidden-bit ideas have been scrapped.</p>
</blockquote>
</aside>
<p>The "surprising action" bit works great... <em>when it works</em>.  However, as I predicted... being a hidden/special bit means that if you're building something that abstracts assignments, you lose the bit... and it starts to break down.</p>
<p>For instance, consider the <a href="../new-uparse-experiment-gather-and-emit/1531.html">GATHER/EMIT functionality in PARSE</a></p>
<pre><code> parse [double [x * 2] plus-one [x + 1] [
     gather [some [
         let name: word!, let code: block!
         emit (name): (func [x [integer!]] code)
     ]]
 ]
</code></pre>
<p>This is a simple example that performs the equivalent of:</p>
<pre><code>make object! [
    double: func [x [integer!]] [x * 2]
    plus-one: func [x [integer!]] [x + 1]
]
</code></pre>
<p>But it does this programmatically.  How it does it is by collecting the names of the fields and then the LIFT'ed form of their arguments... so for ACTION! that would be a QUASIFORM!.</p>
<p>This leads us to ask whether a QUASI-FRAME! evaluating and being assigned to a WORD! should count in terms of the hot potato bit.  This is a bit of a head-scratcher, as it can't be both</p>
<h2><a name="p-8556-could-pack-be-the-hot-potato-bit-1" class="anchor" href="2352.html#p-8556-could-pack-be-the-hot-potato-bit-1"></a>Could PACK! Be The Hot Potato Bit?</h2>
<p>When other parts of the system have faced problems with transient properties that need to decay, they've leaned on PACK!.</p>
<p>So I mused about a concept: what if things that didn't always return ACTION! would pack up lone ACTION! values...</p>
<pre><code>&gt;&gt; lambda [x] [x]
== \~&amp;[frame!...]~\  ; action antiform

&gt;&gt; foo: lambda [x] [x]   ; works

&gt;&gt; if okay [lambda [x] [x]]
== \~[~&amp;[frame!...~]~]~\   ; action antifrom in a pack!

&gt;&gt; bar: if okay [lambda [x] [x]]
** PANIC: "surprising" action assignment (action in a pack)
</code></pre>
<p>But a problem here would be that all you'd have to do would be to DECAY it to approve it.</p>
<pre><code>&gt;&gt; bar: decay if okay [lambda [x] [x]]  ; works
</code></pre>
<p>So that indicates that the bias is backwards: the "hot potato" property that you want to have be transient is the approval... hence it's the unstable state that should indicate the validity:</p>
<pre><code>&gt;&gt; lambda [x] [x]
== \~[~&amp;[frame!...~]~]~\   ; action antifrom in a pack!

&gt;&gt; foo: lambda [x] [x]   ; works

&gt;&gt; if okay [lambda [x] [x]]
== \~&amp;[frame!...]~\  ; action antiform

&gt;&gt; bar: if okay [lambda [x] [x]]
** PANIC: "surprising" action assignment (plain action, not in a pack)
</code></pre>
<p>This is... actually sort of compelling.  It makes the function generators the odd ducks.</p>
<p>If the mechanic were this overt, then I don't think that it should be any "invisible magic" (like detecting that a function only returns ACTION!, and making it return an ACTION! in a PACK!.)  Instead, when you write a function generator, you'd just return a function in a pack.</p>
<p>But what it would imply would be that terminal slashes would give you back a function in a pack, otherwise you couldn't do:</p>
<pre><code>my-append: append/
</code></pre>
<p>Conveniently, if something like APPLY took an ACTION! as an argument, then <strong><code>apply append/</code></strong> would decay that action-in-a-pack to a plain ACTION!.</p>
<p>Where this starts to get a bit hazy is what happens if you write:</p>
<pre><code>^foo: lambda [x] [x]
</code></pre>
<p>By the rules of ^META, that's going to put a PACK! containing an action into foo.</p>
<p><strong>But this is what happens whenever you write packs into ^META variables.</strong>  e.g. I will point out that by the rules of ^META, the following puts a PACK! containing a null into foo... not null:</p>
<pre><code>^foo: if okay [null]  ; compare with (foo: if okay [null])
</code></pre>
<p>Just how nasty is this?  Well, we seem to have been getting away with it so far.  The physics inspirations of isotopes sort of speak to the "law of chemistry" in effect here.  If you've got a milieu of isotopes out there in the mix, and it only matters "when it matters", it puts the burden on those with more stringent needs to articulate and filter when they care.</p>
<p>It's considerably less nasty--I think--to use PACK! for this than to have a hidden bit.  And the idea of having the pack be what "boils away" as the transient evaluation--allowing things like SELECT to return their "pure" answers which have the more "ornery" behavior--seems like it might work.</p>
<p>I'll give this a shot, and see how it goes.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

                <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../optimizing-1-element-pack-s-splice-s/2516.html">Optimizing 1-Element PACK!s / SPLICE!s</a>
                        <meta itemprop='position' content='4'>
                      </div>
                </div>
          </div>
    </div>


    




    </div>
    <footer class="container wrap">
  <nav class='crawler-nav'>
    <ul>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/' itemprop="url">Home </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/categories' itemprop="url">Categories </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/guidelines' itemprop="url">Guidelines </a>
        </span>
      </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://rebol.metaeducation.com/tos' itemprop="url">Terms of Service </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://rebol.metaeducation.com/privacy' itemprop="url">Privacy Policy </a>
          </span>
        </li>
    </ul>
  </nav>
  <p class='powered-by-link'>Powered by <a href="https://www.discourse.org">Discourse</a>, best viewed with JavaScript enabled</p>
</footer>

    
    
  </body>
  
</html>

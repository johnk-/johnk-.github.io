<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Passing Parameters to Modules</title>
    <link>https://rebol.metaeducation.com/t/passing-parameters-to-modules/2404</link>
    <description>I&#39;m trying to bring Shixin&#39;s C2R3 up to date, which is basically frozen in 2015.

He made it as a library, where you define some hooks...include C2R3...and then call &quot;compile&quot; which would use those hooks:

     Rebol [
         Title: &quot;My C2R3 Binding Generator for the %foo.c Project&quot;
     ]

     cfunction-filter: func [return: [logic!] f [object!]] [
         ;
         ; this handler gets called whenever Clang sees a funciton
         ;
         if find e.name &quot;foo_api_&quot; [return true]  ; we want it in the binding
         return false  ; ignore this function in the C file
     ]

     OUTPUT: %foo-ffi.r

     do %c2r3.r

     compile %foo.c

So C2R3 is implicitly picking up parameters, like OUTPUT and CFUNCTION-FILTER, which it uses in the COMPILE.

## That&#39;s Not How It Works Anymore

Modules and Scripts are isolated from each other.  So C2R3 can&#39;t see these definitions.

You can do some hacks to simulate the old behavior... basically by LOAD-ing code, binding it into your script&#39;s context, and then EVAL&#39;ing it.

The boring way that basically everyone else handles this would be to have some kind of configuration object that you pass to COMPILE.

    Rebol [
        Title: &quot;My Better C2R3 Binding Generator for %foo.c&quot;
    ]

    c2r3: import %c2r3.r

    config: make c2r3.config! [
        INPUT: %foo.c
        OUTPUT: %foo-ffi.r

        cfunction-filter: func [return: [logic?] f [object!]] [
            if find e.name &quot;foo_api_&quot; [return okay]
            return null
        ]
    ]

    c2r3/compile config

But... that is boring.  :yawning_face: 

With DO:ARGS you could conceivably fold the config and the import together:

    Rebol [
        Title: &quot;One-Shot C2R3 Binding Generator for %foo.c&quot;
    ]

    source: join %foo %.c  ; you could still run code before you DO

    do:args %c2r3.r [
        INPUT: source
        OUTPUT: %foo-ffi.r

        cfunction-filter: func [return: [logic?] f [object!]] [
            if find e.name &quot;foo_api_&quot; [return okay]
            return null
        ]
    ]

DO:ARGS doesn&#39;t look quite like what I wanted for this, and it&#39;s part of why I&#39;d taken back BLOCK! from DO (it no longer is a synonym for EVAL) and it could mean pretty much anything.

    source: join %foo %.c  ; you could still run code before you DO

    do [
        %c2r3.r

        INPUT: source
        OUTPUT: %foo-ffi.r

        cfunction-filter: func [return: [logic?] f [object!]] [
            if find e.name &quot;foo_api_&quot; [return okay]
            return null
        ]
    ]

Well, that&#39;s not quite the W that I had in mind, but, just pointing out that some options have opened up now that block is available.

Another direction is to kind of say that your scripts themselves are instantiations of the C2R3 &quot;template&quot;, e.g. *written in the C2R3 dialect*, and declare something like that in the header:

    Rebol [
        Title: &quot;Dialected C2R3 Binding Generator for %foo.c&quot;
        Dialect: %c2r3.r
    ]

    (source: join %foo %.c)  ; maybe GROUP! evaluates in its own context?

    INPUT: (source)
    OUTPUT: %foo-ffi.r

    cfunction-filter: func [return: [logic?] f [object!]] [
        if find e.name &quot;foo_api_&quot; [return okay]
        return null
    ]

So this would be some kind of system where you are more regimented in terms of your file starting from the form of specification that C2R3 expects, and you would have little pockets of code (and if you needed to do more work you&#39;d break that out into another script).  This would let you &quot;see&quot; kind of the real goal of the process... the settings that C2R3 wants.

Anyway that&#39;s some very half-baked thinking about alternatives to the boring way.

(But I&#39;m just doing it the boring way for now.)</description>
    
    <lastBuildDate>Wed, 09 Apr 2025 07:08:04 +0000</lastBuildDate>
    <category>Modules</category>
    <atom:link href="https://rebol.metaeducation.com/t/passing-parameters-to-modules/2404.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Passing Parameters to Modules</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>I'm trying to bring Shixin's C2R3 up to date, which is basically frozen in 2015.</p>
<p>He made it as a library, where you define some hooks...include C2R3...and then call "compile" which would use those hooks:</p>
<pre><code> Rebol [
     Title: "My C2R3 Binding Generator for the %foo.c Project"
 ]

 cfunction-filter: func [return: [logic!] f [object!]] [
     ;
     ; this handler gets called whenever Clang sees a funciton
     ;
     if find e.name "foo_api_" [return true]  ; we want it in the binding
     return false  ; ignore this function in the C file
 ]

 OUTPUT: %foo-ffi.r

 do %c2r3.r

 compile %foo.c
</code></pre>
<p>So C2R3 is implicitly picking up parameters, like OUTPUT and CFUNCTION-FILTER, which it uses in the COMPILE.</p>
<h2><a name="p-8127-thats-not-how-it-works-anymore-1" class="anchor" href="https://rebol.metaeducation.com#p-8127-thats-not-how-it-works-anymore-1"></a>That's Not How It Works Anymore</h2>
<p>Modules and Scripts are isolated from each other.  So C2R3 can't see these definitions.</p>
<p>You can do some hacks to simulate the old behavior... basically by LOAD-ing code, binding it into your script's context, and then EVAL'ing it.</p>
<p>The boring way that basically everyone else handles this would be to have some kind of configuration object that you pass to COMPILE.</p>
<pre><code>Rebol [
    Title: "My Better C2R3 Binding Generator for %foo.c"
]

c2r3: import %c2r3.r

config: make c2r3.config! [
    INPUT: %foo.c
    OUTPUT: %foo-ffi.r

    cfunction-filter: func [return: [logic?] f [object!]] [
        if find e.name "foo_api_" [return okay]
        return null
    ]
]

c2r3/compile config
</code></pre>
<p>But... that is boring.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/yawning_face.png?v=14" title=":yawning_face:" class="emoji" alt=":yawning_face:" loading="lazy" width="20" height="20"></p>
<p>With DO:ARGS you could conceivably fold the config and the import together:</p>
<pre><code>Rebol [
    Title: "One-Shot C2R3 Binding Generator for %foo.c"
]

source: join %foo %.c  ; you could still run code before you DO

do:args %c2r3.r [
    INPUT: source
    OUTPUT: %foo-ffi.r

    cfunction-filter: func [return: [logic?] f [object!]] [
        if find e.name "foo_api_" [return okay]
        return null
    ]
]
</code></pre>
<p>DO:ARGS doesn't look quite like what I wanted for this, and it's part of why I'd taken back BLOCK! from DO (it no longer is a synonym for EVAL) and it could mean pretty much anything.</p>
<pre><code>source: join %foo %.c  ; you could still run code before you DO

do [
    %c2r3.r

    INPUT: source
    OUTPUT: %foo-ffi.r

    cfunction-filter: func [return: [logic?] f [object!]] [
        if find e.name "foo_api_" [return okay]
        return null
    ]
]
</code></pre>
<p>Well, that's not quite the W that I had in mind, but, just pointing out that some options have opened up now that block is available.</p>
<p>Another direction is to kind of say that your scripts themselves are instantiations of the C2R3 "template", e.g. <em>written in the C2R3 dialect</em>, and declare something like that in the header:</p>
<pre><code>Rebol [
    Title: "Dialected C2R3 Binding Generator for %foo.c"
    Dialect: %c2r3.r
]

(source: join %foo %.c)  ; maybe GROUP! evaluates in its own context?

INPUT: (source)
OUTPUT: %foo-ffi.r

cfunction-filter: func [return: [logic?] f [object!]] [
    if find e.name "foo_api_" [return okay]
    return null
]
</code></pre>
<p>So this would be some kind of system where you are more regimented in terms of your file starting from the form of specification that C2R3 expects, and you would have little pockets of code (and if you needed to do more work you'd break that out into another script).  This would let you "see" kind of the real goal of the process... the settings that C2R3 wants.</p>
<p>Anyway that's some very half-baked thinking about alternatives to the boring way.</p>
<p>(But I'm just doing it the boring way for now.)</p>
          <p><a href="https://rebol.metaeducation.com/t/passing-parameters-to-modules/2404/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/passing-parameters-to-modules/2404/1</link>
        <pubDate>Wed, 09 Apr 2025 07:08:04 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2404-1</guid>
        <source url="https://rebol.metaeducation.com/t/passing-parameters-to-modules/2404.rss">Passing Parameters to Modules</source>
      </item>
  </channel>
</rss>

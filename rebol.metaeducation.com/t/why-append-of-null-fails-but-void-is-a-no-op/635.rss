<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Why APPEND of NULL fails, but VOID is a No-Op?</title>
    <link>https://rebol.metaeducation.com/t/why-append-of-null-fails-but-void-is-a-no-op/635</link>
    <description>When the idea of NULL was first introduced, it was the *only* non-valued state...which one could be assured could not be put in a block.  It was the result of conditionals that didn&#39;t take their branches, a failed PICK or SELECT, and it was the contents of an unset variable.

I sensed that there were two competing opportunities for using NULL with mechanical functions like APPEND.

* The opportunity to have an &quot;escape&quot; out of a value bearing slot to say *&quot;no, I actually don&#39;t want to append a thing&quot;*.

      &gt;&gt; append copy [&lt;a&gt; &lt;b&gt; &lt;c&gt;] (if 1 = 1 &#39;[&lt;d&gt; &lt;e&gt;])
      == [&lt;a&gt; &lt;b&gt; &lt;c&gt; &lt;d&gt; &lt;e&gt;]

      &gt;&gt; append copy [&lt;a&gt; &lt;b&gt; &lt;c&gt;] (if 1 = 2 &#39;[&lt;d&gt; &lt;e&gt;])
      == [&lt;a&gt; &lt;b&gt; &lt;c&gt;]

* The opportunity to catch an error in intent when NULL is an accident.

      &gt;&gt; data: [&lt;a&gt; &lt;b&gt; &lt;c&gt;]
      &gt;&gt; block: [&lt;d&gt; &lt;e&gt;]

      &gt;&gt; append data third block
      ** Error: APPEND doesn&#39;t accept NULL as its value argument

      &gt;&gt; append data maybe third block
      == [&lt;a&gt; &lt;b&gt; &lt;c&gt;]

In the beginning I was excited about the coding styles afforded by the first choice.

But quietly accepting NULL loses the hot-potato benefit.  If you say **append data third block** and there is no third element in the block, *doesn&#39;t that seem like a good time to complain*?  Rebol code can pretty quickly get hard to read and debug, and wouldn&#39;t it be nice if the person who wrote that line could articulate that there may not be a third thing in the block by saying **append data maybe third block**?

Coming up with what MAYBE would return to &quot;approve&quot; the lack of an append ran up against a bit of a problem, because NULL was the only non-valued type.  So for a time it was tried to make the default behavior of BLANK! to be to add nothing, and you need an /ONLY to override that.  It seemed a missed opportunity for null to exploit its out-of-band status.  But the thought was that *&quot;purposefully adding blanks wasn&#39;t all that common--certainly a lot less common than adding a block as-is, and that requires /ONLY!&quot;*

&gt; **Hindsight 2022:** In 2018 it was a long way from the [tools and mechanics of generalized isotopes](https://rebol.metaeducation.com/t/a-justification-of-generalized-isotopes/1918), which made as-is manipulation with APPEND, INSERT, etc. the universal default.  It&#39;s funny to look back on it, and think about how difficult it was to try and make design decisions based on how often people appended blanks as-is or not.  That kind of guesswork offers little grounding to those writing code, who should be able to be assured that if they pick an element out of one block and append it to another, that the default is to have moved the item intact.</description>
    
    <lastBuildDate>Wed, 07 May 2025 13:33:32 +0000</lastBuildDate>
    <category>Questions</category>
    <atom:link href="https://rebol.metaeducation.com/t/why-append-of-null-fails-but-void-is-a-no-op/635.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Why APPEND of NULL fails, but VOID is a No-Op?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Historically, BrianH and others (including me) believed that mutating operations should not let you "opt out" of the target for the mutation. There was too much potential for confusion if you wrote:</p>
<pre><code> append block [1 2 3]
</code></pre>
<p>...and it silently didn't append, because block was a NONE!.</p>
<h2><a name="p-6348-yet-another-historical-spectre-annihilated-boom-ghost-boom-1" class="anchor" href="https://rebol.metaeducation.com#p-6348-yet-another-historical-spectre-annihilated-boom-ghost-boom-1"></a>...Yet Another Historical Spectre Annihilated... <img src="https://rebol.metaeducation.com/images/emoji/twitter/boom.png?v=14" title=":boom:" class="emoji" alt=":boom:" loading="lazy" width="20" height="20"> <img src="https://rebol.metaeducation.com/images/emoji/twitter/ghost.png?v=14" title=":ghost:" class="emoji" alt=":ghost:" loading="lazy" width="20" height="20"> <img src="https://rebol.metaeducation.com/images/emoji/twitter/boom.png?v=14" title=":boom:" class="emoji" alt=":boom:" loading="lazy" width="20" height="20"></h2>
<p><em><strong>The VOID in, NULL out solution handles this about as elegantly as we could hope.</strong></em></p>
<p>If the variable were null, you'd get an error on trying to use it:</p>
<pre><code>&gt;&gt; block: null
== ~null~  ; antiform

&gt;&gt; append block [1 2 3]
** Error: APPEND doesn't accept null for its series argument (use MAYBE if intended)
</code></pre>
<p>But you can turn that null into a void (unstable antiform, can't be stored in variables) with MAYBE</p>
<pre><code>&gt;&gt; maybe block
== ~[]~  ; anti

&gt;&gt; append maybe block [1 2 3]
== ~[]~  ; anti
</code></pre>
<p>Here was some awkward code in UPARSE trying to use BLANK! when subpending was NULL, to skip the REMOVE-EACH:</p>
<pre><code>remove-each item any [subpending _] [
    if group? item [eval item, true]
]
</code></pre>
<p>I think it gets less confusing, with a non-valued uniform mechanic that applies anywhere (e.g. that ANY wouldn't work to opt out of an APPEND...)</p>
<pre><code>remove-each item (maybe subpending) [
    if group? item [eval item, true]
]
</code></pre>
          <p><a href="https://rebol.metaeducation.com/t/why-append-of-null-fails-but-void-is-a-no-op/635/14">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/why-append-of-null-fails-but-void-is-a-no-op/635/14</link>
        <pubDate>Tue, 30 Aug 2022 14:44:16 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-635-14</guid>
        <source url="https://rebol.metaeducation.com/t/why-append-of-null-fails-but-void-is-a-no-op/635.rss">Why APPEND of NULL fails, but VOID is a No-Op?</source>
      </item>
      <item>
        <title>Why APPEND of NULL fails, but VOID is a No-Op?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>The answer is...</p>
<h2><a name="p-6128-use-void-to-mean-append-nothing-and-null-gets-an-error-1" class="anchor" href="https://rebol.metaeducation.com#p-6128-use-void-to-mean-append-nothing-and-null-gets-an-error-1"></a>Use VOID to mean append nothing, and NULL gets an Error</h2>
<p>That's the conclusion I came to with COMPOSE and DELIMIT, and I think it has turned out to be the right one.  It has eliminated many casual errors there, and provided new features from responding to the NULL errors definitionally.</p>
<p>So why not make APPEND <em>100% compatible</em>?</p>
<pre><code> &gt;&gt; var: null

&gt;&gt; append [a b c] var
** Error: APPEND doesn't take NULL (use MAYBE if intentional)

&gt;&gt; append [a b c] maybe null
== [a b c]
</code></pre>
<p>We haven't historically thought of VOID as something to pass a function as a parameter.  Because in the olden days, you <em>couldn't</em> receive a void: the evaluator would keep going until it actually produced a value (or NULL).  But non-interstitial invisibility is a thing of the past now (too dangerous, too messy).</p>
          <p><a href="https://rebol.metaeducation.com/t/why-append-of-null-fails-but-void-is-a-no-op/635/12">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/why-append-of-null-fails-but-void-is-a-no-op/635/12</link>
        <pubDate>Wed, 20 Jul 2022 16:09:03 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-635-12</guid>
        <source url="https://rebol.metaeducation.com/t/why-append-of-null-fails-but-void-is-a-no-op/635.rss">Why APPEND of NULL fails, but VOID is a No-Op?</source>
      </item>
      <item>
        <title>Why APPEND of NULL fails, but VOID is a No-Op?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-post-not-found" data-username="hostilefork" data-post="3" data-topic="635">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>"It’s likely better to embrace blank’s “nothingness-without-triggering-errors-on-access” as its primary facet, with its ability to be represented in a block as secondary."</p>
</blockquote>
</aside>
<p>On the other side of this statement: <em>both</em> aspects seemed to come into play, whether you like it or not.  It's not going to be all one way or the other.   You're going to sometimes be thinking of a blank as a "thing", and sometimes as a "nothing".</p>
<p>Let's look away from APPEND and COMPOSE for a moment, and think about maps.  Today these are different:</p>
<pre><code>my-map/key: _   ; sets the key to a blank value
my-map/key: null   ; removes the key
</code></pre>
<p>Here you don't have the option of an /ONLY.  So if blanks were treated as nothings, you'd lose the ability to put them into maps with this mechanism.  But as long as they are distinct, you have the choice to say either:</p>
<pre><code>my-map/key: thing-that-might-be-blank
my-map/key: opt thing-that-might-be-blank
</code></pre>
<p>Going back to APPEND and COMPOSE, the /ONLY is already controlling one aspect: splicing or not.  But...</p>
<ul>
<li>...what if you want to splice if it's a block, and treat it like a literal blank if it isn't?</li>
<li>...what if you want to not splice if it's a block, but treat it as nothing if it's a blank?</li>
</ul>
<h2><a name="p-2825-when-in-doubt-favor-the-mechanically-consistent-behavior-1" class="anchor" href="https://rebol.metaeducation.com#p-2825-when-in-doubt-favor-the-mechanically-consistent-behavior-1"></a>When in Doubt, Favor the Mechanically Consistent Behavior</h2>
<p>Sometimes things seem annoying when you look at them as individual cases, but you realize their necessity if the big picture is taken into account.</p>
<p>I think needing OPT at the callsite is just one of these necessary evils--that's not even that evil.</p>
<p>For historical perspective: When I initially complained about NONE!s not "vaporizing" in things like COMPOSE, BrianH was very adamant that NONE!s were things.  He believed a lot of Rebol's idiomatic behavior involved having empty placeholders in slots of regular record-like structures.  So he was generally resistant to using them to opt-out when blocks were being produced.</p>
<p>So I guess this just kind of informs what the system's bias is: <em>Blanks are values first and foremost, and nothings second.</em></p>
          <p><a href="https://rebol.metaeducation.com/t/why-append-of-null-fails-but-void-is-a-no-op/635/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/why-append-of-null-fails-but-void-is-a-no-op/635/4</link>
        <pubDate>Tue, 18 Dec 2018 22:09:40 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-635-4</guid>
        <source url="https://rebol.metaeducation.com/t/why-append-of-null-fails-but-void-is-a-no-op/635.rss">Why APPEND of NULL fails, but VOID is a No-Op?</source>
      </item>
      <item>
        <title>Why APPEND of NULL fails, but VOID is a No-Op?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="635">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So for a time it was tried to make the default behavior of BLANK! to be to add nothing, and you need an /ONLY to override that.</p>
</blockquote>
</aside>
<p>This decision was reversed in 2018 shortly after it was implemented, <em>in particular because NULLs started taking over a lot of former BLANK! roles.</em></p>
<p>A failed ANY or ALL, a FIND that didn't find anything, a MATCH that didn't take... <em>those all started returning NULL, and not blank</em>.  This was the new return value protocol, where BLANK! is no longer used as a return value meaning "no match".</p>
<p>It gave BLANK!s a renewed purpose, but a purpose for which they should be thought of as "things".  They were no longer signals of failure.  And as such, their "realness" for an APPEND seemed more foundational, with me saying:</p>
<blockquote>
<p><strong>It's likely better to embrace blank's "nothingness-without-triggering-errors-on-access" as its primary facet, with its ability to be represented in a block as secondary.</strong></p>
</blockquote>
<p>However...</p>
          <p><a href="https://rebol.metaeducation.com/t/why-append-of-null-fails-but-void-is-a-no-op/635/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/why-append-of-null-fails-but-void-is-a-no-op/635/2</link>
        <pubDate>Wed, 13 Jun 2018 00:07:26 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-635-2</guid>
        <source url="https://rebol.metaeducation.com/t/why-append-of-null-fails-but-void-is-a-no-op/635.rss">Why APPEND of NULL fails, but VOID is a No-Op?</source>
      </item>
      <item>
        <title>Why APPEND of NULL fails, but VOID is a No-Op?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>When the idea of NULL was first introduced, it was the <em>only</em> non-valued state...which one could be assured could not be put in a block.  It was the result of conditionals that didn't take their branches, a failed PICK or SELECT, and it was the contents of an unset variable.</p>
<p>I sensed that there were two competing opportunities for using NULL with mechanical functions like APPEND.</p>
<ul>
<li>
<p>The opportunity to have an "escape" out of a value bearing slot to say <em>"no, I actually don't want to append a thing"</em>.</p>
<pre><code>&gt;&gt; append copy [&lt;a&gt; &lt;b&gt; &lt;c&gt;] (if 1 = 1 '[&lt;d&gt; &lt;e&gt;])
== [&lt;a&gt; &lt;b&gt; &lt;c&gt; &lt;d&gt; &lt;e&gt;]

&gt;&gt; append copy [&lt;a&gt; &lt;b&gt; &lt;c&gt;] (if 1 = 2 '[&lt;d&gt; &lt;e&gt;])
== [&lt;a&gt; &lt;b&gt; &lt;c&gt;]
</code></pre>
</li>
<li>
<p>The opportunity to catch an error in intent when NULL is an accident.</p>
<pre><code>&gt;&gt; data: [&lt;a&gt; &lt;b&gt; &lt;c&gt;]
&gt;&gt; block: [&lt;d&gt; &lt;e&gt;]

&gt;&gt; append data third block
** Error: APPEND doesn't accept NULL as its value argument

&gt;&gt; append data maybe third block
== [&lt;a&gt; &lt;b&gt; &lt;c&gt;]
</code></pre>
</li>
</ul>
<p>In the beginning I was excited about the coding styles afforded by the first choice.</p>
<p>But quietly accepting NULL loses the hot-potato benefit.  If you say <strong>append data third block</strong> and there is no third element in the block, <em>doesn't that seem like a good time to complain</em>?  Rebol code can pretty quickly get hard to read and debug, and wouldn't it be nice if the person who wrote that line could articulate that there may not be a third thing in the block by saying <strong>append data maybe third block</strong>?</p>
<p>Coming up with what MAYBE would return to "approve" the lack of an append ran up against a bit of a problem, because NULL was the only non-valued type.  So for a time it was tried to make the default behavior of BLANK! to be to add nothing, and you need an /ONLY to override that.  It seemed a missed opportunity for null to exploit its out-of-band status.  But the thought was that <em>"purposefully adding blanks wasn't all that common--certainly a lot less common than adding a block as-is, and that requires /ONLY!"</em></p>
<blockquote>
<p><strong>Hindsight 2022:</strong> In 2018 it was a long way from the <a href="https://rebol.metaeducation.com/t/a-justification-of-generalized-isotopes/1918">tools and mechanics of generalized isotopes</a>, which made as-is manipulation with APPEND, INSERT, etc. the universal default.  It's funny to look back on it, and think about how difficult it was to try and make design decisions based on how often people appended blanks as-is or not.  That kind of guesswork offers little grounding to those writing code, who should be able to be assured that if they pick an element out of one block and append it to another, that the default is to have moved the item intact.</p>
</blockquote>
          <p><a href="https://rebol.metaeducation.com/t/why-append-of-null-fails-but-void-is-a-no-op/635/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/why-append-of-null-fails-but-void-is-a-no-op/635/1</link>
        <pubDate>Sat, 19 May 2018 19:17:28 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-635-1</guid>
        <source url="https://rebol.metaeducation.com/t/why-append-of-null-fails-but-void-is-a-no-op/635.rss">Why APPEND of NULL fails, but VOID is a No-Op?</source>
      </item>
  </channel>
</rss>

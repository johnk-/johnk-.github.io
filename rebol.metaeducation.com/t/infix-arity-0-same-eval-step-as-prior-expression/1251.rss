<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Infix Arity 0: &quot;Same EVAL:STEP as Prior Expression&quot;</title>
    <link>https://rebol.metaeducation.com/t/infix-arity-0-same-eval-step-as-prior-expression/1251</link>
    <description>In 2017 while trying to formalize some code I faced a question: **How should the evaluator deal with a function that is marked as getting its first argument from the left (e.g. &quot;infix&quot;) if that operation takes no arguments?**

R3-Alpha only had arity-2 infix functions, and didn&#39;t allow you to make your own.  Red lets you make your own, but keeps the rule:

    red&gt;&gt; foo: func [x] [print mold x]
    == func [x][print mold x]

    red&gt;&gt; bar: make op! :foo
    *** Script Error: making an op! requires a function with only 2 arguments

But Ren-C took a different tack, trying to generalize the mechanic so that &quot;infix&quot; functions could take any number of arguments...and it only spoke to the question of how they got their first.  You might make a ternary operator where the condition was on the left and the branches on the right.  Or you might make a postfix operator which took a single argument--punctuating an evaluation.

We have some of those today.  SO is an interesting variation on ASSERT that just validates its left hand expression:

    &gt;&gt; 2 + 1 = 3 so print &quot;No problem.&quot;
    No problem

    &gt;&gt; 1020 - 304 = 421 so print &quot;Math is broken&quot;
    ** Script Error: assertion failure: [#[false] so]
    ** Where: so console
    ** Near: [... = 421 so ~~ print &quot;Math is broken&quot;]

But what--if anything--should happen when you make an infix function which takes **NO** arguments?  How is that different from a *non*-infix function with no arguments?

I remember where I was when writing down that issue.  It was at one of a number of chains of a coffee place called [&quot;Koffe&quot;, but this one in South Palm Springs](https://www.kofficoffee.com/pages/locations).  And [it has sat around as Issue #581](https://github.com/metaeducation/ren-c/issues/581) for a long while.

But with the passage of time, I think the answer to this has become clear.  An infix 0-arity function is simply sequenced in the *same evaluator step as the left hand side*.

[If you want to see some cool tests that show the nuances, look here.](https://github.com/metaeducation/ren-c/blob/fb5e29d593e650b2dbc02963a93348c2ac862b22/tests/functions/infix.test.reb#L198-L332)  But the issue sums up the general gist:

    &gt;&gt; bar: func [] [return &lt;bar&gt;]
    &gt;&gt; i-bar: infix func [] [return &lt;i-bar&gt;]

    &gt;&gt; [pos result]: eval:step [1020 bar 304]
    == [bar 304]  ; one step, did not run bar yet, still pending

    &gt;&gt; result
    == 1020

    &gt;&gt; [pos: result]: eval:step [1020 i-bar 304]
    == [304]  ; one step, ran i-bar during that step besides being arity-0

    &gt;&gt; result
    == &lt;enbar&gt;

---

**These edge cases really shed light on the big picture.**  I&#39;ve said time and again that you don&#39;t do yourself any favors in language design by throwing yourself softballs.  You should be looking for pathological cases and if you can&#39;t solve them, building a rationale behind why--and articulating the shape of the things you *can* solve.

On Ren-C I&#39;ve been chipping away at these issues a little at a time, and it feels good to see this old one get closed.  I&#39;m pretty sure that people using the evaluator to invent cool things will appreciate that it bends (to the extent coherence will allow it to!)</description>
    
    <lastBuildDate>Tue, 18 Mar 2025 15:31:29 +0000</lastBuildDate>
    <category>Functions</category>
    <atom:link href="https://rebol.metaeducation.com/t/infix-arity-0-same-eval-step-as-prior-expression/1251.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Infix Arity 0: &quot;Same EVAL:STEP as Prior Expression&quot;</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>In 2017 while trying to formalize some code I faced a question: <strong>How should the evaluator deal with a function that is marked as getting its first argument from the left (e.g. "infix") if that operation takes no arguments?</strong></p>
<p>R3-Alpha only had arity-2 infix functions, and didn't allow you to make your own.  Red lets you make your own, but keeps the rule:</p>
<pre><code>red&gt;&gt; foo: func [x] [print mold x]
== func [x][print mold x]

red&gt;&gt; bar: make op! :foo
*** Script Error: making an op! requires a function with only 2 arguments
</code></pre>
<p>But Ren-C took a different tack, trying to generalize the mechanic so that "infix" functions could take any number of arguments...and it only spoke to the question of how they got their first.  You might make a ternary operator where the condition was on the left and the branches on the right.  Or you might make a postfix operator which took a single argument--punctuating an evaluation.</p>
<p>We have some of those today.  SO is an interesting variation on ASSERT that just validates its left hand expression:</p>
<pre><code>&gt;&gt; 2 + 1 = 3 so print "No problem."
No problem

&gt;&gt; 1020 - 304 = 421 so print "Math is broken"
** Script Error: assertion failure: [#[false] so]
** Where: so console
** Near: [... = 421 so ~~ print "Math is broken"]
</code></pre>
<p>But what--if anything--should happen when you make an infix function which takes <strong>NO</strong> arguments?  How is that different from a <em>non</em>-infix function with no arguments?</p>
<p>I remember where I was when writing down that issue.  It was at one of a number of chains of a coffee place called <a href="https://www.kofficoffee.com/pages/locations">"Koffe", but this one in South Palm Springs</a>.  And <a href="https://github.com/metaeducation/ren-c/issues/581">it has sat around as Issue #581</a> for a long while.</p>
<p>But with the passage of time, I think the answer to this has become clear.  An infix 0-arity function is simply sequenced in the <em>same evaluator step as the left hand side</em>.</p>
<p><a href="https://github.com/metaeducation/ren-c/blob/fb5e29d593e650b2dbc02963a93348c2ac862b22/tests/functions/infix.test.reb#L198-L332">If you want to see some cool tests that show the nuances, look here.</a>  But the issue sums up the general gist:</p>
<pre><code>&gt;&gt; bar: func [] [return &lt;bar&gt;]
&gt;&gt; i-bar: infix func [] [return &lt;i-bar&gt;]

&gt;&gt; [pos result]: eval:step [1020 bar 304]
== [bar 304]  ; one step, did not run bar yet, still pending

&gt;&gt; result
== 1020

&gt;&gt; [pos: result]: eval:step [1020 i-bar 304]
== [304]  ; one step, ran i-bar during that step besides being arity-0

&gt;&gt; result
== &lt;enbar&gt;
</code></pre>
<hr>
<p><strong>These edge cases really shed light on the big picture.</strong>  I've said time and again that you don't do yourself any favors in language design by throwing yourself softballs.  You should be looking for pathological cases and if you can't solve them, building a rationale behind why--and articulating the shape of the things you <em>can</em> solve.</p>
<p>On Ren-C I've been chipping away at these issues a little at a time, and it feels good to see this old one get closed.  I'm pretty sure that people using the evaluator to invent cool things will appreciate that it bends (to the extent coherence will allow it to!)</p>
          <p><a href="https://rebol.metaeducation.com/t/infix-arity-0-same-eval-step-as-prior-expression/1251/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/infix-arity-0-same-eval-step-as-prior-expression/1251/1</link>
        <pubDate>Thu, 12 Dec 2019 06:56:13 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1251-1</guid>
        <source url="https://rebol.metaeducation.com/t/infix-arity-0-same-eval-step-as-prior-expression/1251.rss">Infix Arity 0: &quot;Same EVAL:STEP as Prior Expression&quot;</source>
      </item>
  </channel>
</rss>

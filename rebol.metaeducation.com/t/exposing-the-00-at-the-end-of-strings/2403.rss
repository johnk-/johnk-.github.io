<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Exposing the #{00} At The End of Strings</title>
    <link>https://rebol.metaeducation.com/t/exposing-the-00-at-the-end-of-strings/2403</link>
    <description>When you have a UTF-8 string like TEXT! represented internally, it has a 0 byte at its end.

This is leveraged various places internally.

In the libRebol API functions like **`rebLockUtf8()`** can give you direct access to the internal byte buffer, and you&#39;ll get a terminator...which makes it much more useful:

    const char* utf8 = rebLockUtf8(&quot;reverse -{cba}-&quot;);

    assert(utf8[0] == &#39;a&#39;);
    assert(utf8[4] == &#39;\0&#39;);

    char buffer[4];
    strcpy(buffer, utf8);  // kind of thing that would be hard if not terminated

    rebUnlockUtf8(utf8);

**But what if you&#39;re doing something like the FFI, and you want a BINARY! that has the #{00} on the end?**

    &gt;&gt; utf8 of &quot;abc&quot;
    == #{616263}  ; new allocation

    &gt;&gt; as blob! &quot;abc&quot;
    == #{616263}  ; alias of memory, no additional allocation

Niether case gives you the intenal `#{00}`

You can go about either appending the byte to the synthesized new allocation, or joining a byte to make a synthesis of the alias with the byte:

    append (utf8 of &quot;abc&quot;) #{00}

    join (as blob! &quot;abc&quot;) #{00}

But you shouldn&#39;t have to make a copy at all.

This is sort of a nuance on the AS aliasing process.  Most clients don&#39;t want to see the #{00} byte at the end, but those that do could get a big savings (especially on longer strings) if they did.

Something worth thinking about.  :pushpin:</description>
    
    <lastBuildDate>Tue, 08 Apr 2025 19:37:55 +0000</lastBuildDate>
    <category>Language Bridging</category>
    <atom:link href="https://rebol.metaeducation.com/t/exposing-the-00-at-the-end-of-strings/2403.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Exposing the #{00} At The End of Strings</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>When you have a UTF-8 string like TEXT! represented internally, it has a 0 byte at its end.</p>
<p>This is leveraged various places internally.</p>
<p>In the libRebol API functions like <strong><code>rebLockUtf8()</code></strong> can give you direct access to the internal byte buffer, and you'll get a terminator...which makes it much more useful:</p>
<pre><code>const char* utf8 = rebLockUtf8("reverse -{cba}-");

assert(utf8[0] == 'a');
assert(utf8[4] == '\0');

char buffer[4];
strcpy(buffer, utf8);  // kind of thing that would be hard if not terminated

rebUnlockUtf8(utf8);
</code></pre>
<p><strong>But what if you're doing something like the FFI, and you want a BINARY! that has the #{00} on the end?</strong></p>
<pre><code>&gt;&gt; utf8 of "abc"
== #{616263}  ; new allocation

&gt;&gt; as blob! "abc"
== #{616263}  ; alias of memory, no additional allocation
</code></pre>
<p>Niether case gives you the intenal <code>#{00}</code></p>
<p>You can go about either appending the byte to the synthesized new allocation, or joining a byte to make a synthesis of the alias with the byte:</p>
<pre><code>append (utf8 of "abc") #{00}

join (as blob! "abc") #{00}
</code></pre>
<p>But you shouldn't have to make a copy at all.</p>
<p>This is sort of a nuance on the AS aliasing process.  Most clients don't want to see the #{00} byte at the end, but those that do could get a big savings (especially on longer strings) if they did.</p>
<p>Something worth thinking about.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/pushpin.png?v=14" title=":pushpin:" class="emoji" alt=":pushpin:" loading="lazy" width="20" height="20"></p>
          <p><a href="https://rebol.metaeducation.com/t/exposing-the-00-at-the-end-of-strings/2403/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/exposing-the-00-at-the-end-of-strings/2403/1</link>
        <pubDate>Tue, 08 Apr 2025 19:37:55 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2403-1</guid>
        <source url="https://rebol.metaeducation.com/t/exposing-the-00-at-the-end-of-strings/2403.rss">Exposing the #{00} At The End of Strings</source>
      </item>
  </channel>
</rss>

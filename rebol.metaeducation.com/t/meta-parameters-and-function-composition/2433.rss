<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Meta-Parameters And Function Composition</title>
    <link>https://rebol.metaeducation.com/t/meta-parameters-and-function-composition/2433</link>
    <description>Right now *(Note: original post written circa 2021)* when doing a low-level build of a FRAME! for a function, you are on the hook for knowing the callsite parameter convention and doing what it takes to meet the expectation.

* So for a quoted (literal) parameter, you have to take that into account...since no callsite quoting is going on, you must do your own quoting in the assignment.

   * This isn&#39;t particularly new--you had to do your own quoting when using Rebol2 APPLY, also.  The quoting convention in the function spec wouldn&#39;t be heeded inside the apply block.

* Same for a meta parameter...there&#39;s no callsite that&#39;s converting things from antiforms into a non-antiforms, or adding quote levels.  When you are assigning fields in the frame you have to remember to LIFT them.

**It means that if the parameter convention changes, what you might have written for a MAKE FRAME! previously won&#39;t work.**

Let&#39;s say someone writes a function that returns if something is greater than 10:

    greater-than-10: func [x [integer!]] [
        return x &gt; 10
    ]

Then you write code that builds a frame for it:

    f: make frame! greater-than-10/
    f.x: 20
    assert [eval f]

It works.  Yet later the person who wrote the function decides they want to do something special if it&#39;s passed an unstable antiform, while keeping the behavior for integers the same.

Let&#39;s imagine they want to make it so that it tests all integers in a pack, if you give it a pack:

    greater-than-10: func [^x [integer! pack!]] [
        if pack? ^x [
            ... code for testing if each element in pack &gt; 10 ...
        ] else [
            ^x &gt; 10
        ]
    ]

    &gt;&gt; greater-than-10 20
    == \~okay~\  ; antiform

    &gt;&gt; greater-than-10 pack [20 30]
    == \~okay~\  ; antiform

    &gt;&gt; greater-than-10 pack [10 20]
    == \~null~\  ; antiform

Why did the person who switched the parameter to ^META add this feature?  Who knows.  But let&#39;s say they thought it was okay because the callsites they knew about would remain working.

**But it breaks our invocation via FRAME!.**

    &gt;&gt; f: make frame! :greater-than-10
    &gt;&gt; f.x: 20
    == 20

    &gt;&gt; eval f
    ** Error: X is a ^META argument, must be QUOTED! or QUASIFORM!

You have to now adjust how you fill the frame to meet the meta requirements:

    &gt;&gt; f: make frame! greater-than-10/

    &gt;&gt; f.x: quote 20
    == &#39;20

    &gt;&gt; eval f
    == \~okay~\  ; anti

&gt; **UPDATE 2025:** There is an awesome alternative to saying **`f.x: lift 20`** or **`f.x: quote 20`** which is now to use metavariables, e.g:
&gt;
&gt;     &gt;&gt; f.^x: 20
&gt;     == 20
&gt;
&gt;     &gt;&gt; f.x
&gt;     == &#39;20</description>
    
    <lastBuildDate>Sat, 07 Jun 2025 01:23:14 +0000</lastBuildDate>
    <category>Functions</category>
    <atom:link href="https://rebol.metaeducation.com/t/meta-parameters-and-function-composition/2433.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Meta-Parameters And Function Composition</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2433">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It's a little bit sad that you wouldn't be able to just copy and paste code out of a FUNC body and put it into the code of an ADAPT.</p>
</blockquote>
</aside>
<p><strong>UPDATE:</strong> See the new theory of how you <em>can</em> just copy and paste: <strong><a href="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477">LIFT THE UNIVERSE</a></strong></p>
          <p><a href="https://rebol.metaeducation.com/t/meta-parameters-and-function-composition/2433/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/meta-parameters-and-function-composition/2433/4</link>
        <pubDate>Sat, 07 Jun 2025 01:23:14 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2433-4</guid>
        <source url="https://rebol.metaeducation.com/t/meta-parameters-and-function-composition/2433.rss">Meta-Parameters And Function Composition</source>
      </item>
      <item>
        <title>Meta-Parameters And Function Composition</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2433">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It means that if the parameter convention changes, what you might have written for a MAKE FRAME! previously won't work.</p>
</blockquote>
</aside>
<p>In 2022, I wrote: <a href="https://rebol.metaeducation.com/t/interaction-of-isotopes-and-make-frame/1412/6"><em>"In practice this turns out to be really annoying.  Enough so that I think the frames should speak an "as-is" language. Then the mechanics that turn parameters into ^META should be done by the function when it's called."</em></a></p>
<p>That was before the maturation of modern isotopes...where unstable antiforms simply have no representation you can put in a variable.</p>
<p>As of 2025... to put forth the spirit of the proposal today, it would be:</p>
<p><em><strong>"I think the frames should speak in a uniform meta-protocol. Then the mechanics that turn non-^META parameters into stable values should be done by the function when it's called."</strong></em></p>
<h2><a name="p-8201-profound-idea-octopus-bubbles-profound-implications-1" class="anchor" href="https://rebol.metaeducation.com#p-8201-profound-idea-octopus-bubbles-profound-implications-1"></a>Profound Idea <img src="https://rebol.metaeducation.com/images/emoji/twitter/octopus.png?v=14" title=":octopus:" class="emoji" alt=":octopus:" loading="lazy" width="20" height="20"> <img src="https://rebol.metaeducation.com/images/emoji/twitter/bubbles.png?v=14" title=":bubbles:" class="emoji" alt=":bubbles:" loading="lazy" width="20" height="20"> Profound Implications</h2>
<p>This concept is that the central mechanics of function argument gatherering and dispatch always uses meta-parameterization, and it's only at that "last mile" of a FUNC or LAMBDA invocation that it does the convenience of un-meta-ing parameters (the ones you <em>didn't</em> mark as ^META) for you.</p>
<p>In the past I've complained about not wanting to make more ^META variables, because they are a a pain to deal with.  For instance, if APPEND takes its value-to-append argument as ^META, you'd have to write:</p>
<pre><code>append-reverse: enclose append/ func [f [frame!]] [
    if any-series? unlift f.value [
        f.value: lift reverse unlift f.value
    ]
    return eval f
]
</code></pre>
<p>I cited this kind of hassle as a reason why I was afraid to make F.VALUE meta, even though that would be the right answer to make it work with appending a VOID state that can't be put in a variable.</p>
<p>BUT I noted in the thread above the new power-tool of metavariables.  That makes it better in more ways than one:</p>
<pre><code>append-reverse: enclose append/ func [f [frame!]] [
    if any-series? f.^value [
        f.^value: reverse f.^value
    ]
    return eval f
]
</code></pre>
<p>That's a big improvement.  And the peace of mind of knowing that APPEND can change its mind over time about whether it wants the variables to be meta or not when the function starts running... without affecting frames... is really nice.</p>
<h2><a name="p-8201-no-meta-parameters-in-the-interface-is-good-2" class="anchor" href="https://rebol.metaeducation.com#p-8201-no-meta-parameters-in-the-interface-is-good-2"></a>No ^META Parameters In The Interface Is GOOD</h2>
<p>There's tremendous benefit to removing the idea that a parameter is "meta" from a function's public interface.</p>
<p>HELP doesn't have to show it.  Callers don't have to know it.  They can just look at the type signature... if they see PACK! or something in there, then they know "oh it takes packs, may treat them specially".</p>
<p>But it's not just ENCLOSE that would be affected.  Other function composition operations would too, such as ADAPT:</p>
<pre><code>append-reverse: adapt append/ [
    print "Hi, I'm an adapted APPEND!"
    if series? ^value [^value: reverse ^value]
]
</code></pre>
<p>Basically, the adaptation runs on the frame before that "last mile" conversion.  So it's subject to the same rules.  (If we weren't going to make it subject to the rules, then ADAPT would have to be able to query the function it was adapting about the meta-parameter status.  This would be like exposing it in HELP.)</p>
<p>It's a little bit sad that you wouldn't be able to just copy and paste code out of a FUNC body and put it into the code of an ADAPT.  But I think the higher calling here is to say that the "meta vs. non-meta parameter convention" is just an implementation detail of things like FUNC and LAMBDA.</p>
<pre><code>foo: func [x ^y] [...]

=&gt;

foo: fundamental-meta-func [x y] [x: unlift x ...]
</code></pre>
          <p><a href="https://rebol.metaeducation.com/t/meta-parameters-and-function-composition/2433/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/meta-parameters-and-function-composition/2433/3</link>
        <pubDate>Mon, 05 May 2025 03:59:13 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2433-3</guid>
        <source url="https://rebol.metaeducation.com/t/meta-parameters-and-function-composition/2433.rss">Meta-Parameters And Function Composition</source>
      </item>
      <item>
        <title>Meta-Parameters And Function Composition</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <h2><a name="p-5210-higher-level-functions-than-eval-frame-can-lend-a-hand-1" class="anchor" href="https://rebol.metaeducation.com#p-5210-higher-level-functions-than-eval-frame-can-lend-a-hand-1"></a>Higher-Level Functions than EVAL FRAME! Can Lend A Hand</h2>
<p>Let's imagine you want to specialize RETURN.  It's one of those functions that takes a ^meta parameter, so that you can hand back unstable isotopes to the caller.  (Hence it calls its argument <a href="https://rebol.metaeducation.com/t/antiform-safety-covariance-and-contravariance/2330">"ATOM" and not "VALUE"</a>).</p>
<p>But SPECIALIZE can be creative in terms of how it builds the frame.  So let's say you don't want to care if it's a meta parameter or not, and want to write:</p>
<pre><code>return-5: specialize return/ [atom: 5]

return-10-and-20: specialize return/ [atom: pack [10 20]]
</code></pre>
<p>So higher-level tools can come into play that are aware of the parameter conventions and do adjustments for you.  But if you work at the FRAME! level, you're at the metal...and you have to fill the slots with their <em>final</em> values; no parameter conventions will be applied to adjust them for you.</p>
<blockquote>
<p><strong>UPDATE 2025:</strong> It's unclear that SPECIALIZE hiding the fact that it's doing meta-assignments is a good idea.  Anyone seeing <strong><code>xxx: pack [10 20]</code></strong> expects that assignment to decay.</p>
<p>Now that we have <strong><code>^atom: pack [10 20]</code></strong> available, it makes much more sense that any assignment which is storing meta-representations be clear that it is doing so, and use such an assignment.</p>
</blockquote>
          <p><a href="https://rebol.metaeducation.com/t/meta-parameters-and-function-composition/2433/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/meta-parameters-and-function-composition/2433/2</link>
        <pubDate>Mon, 21 Jun 2021 07:03:04 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2433-2</guid>
        <source url="https://rebol.metaeducation.com/t/meta-parameters-and-function-composition/2433.rss">Meta-Parameters And Function Composition</source>
      </item>
      <item>
        <title>Meta-Parameters And Function Composition</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Right now <em>(Note: original post written circa 2021)</em> when doing a low-level build of a FRAME! for a function, you are on the hook for knowing the callsite parameter convention and doing what it takes to meet the expectation.</p>
<ul>
<li>
<p>So for a quoted (literal) parameter, you have to take that into account...since no callsite quoting is going on, you must do your own quoting in the assignment.</p>
<ul>
<li>This isn't particularly new--you had to do your own quoting when using Rebol2 APPLY, also.  The quoting convention in the function spec wouldn't be heeded inside the apply block.</li>
</ul>
</li>
<li>
<p>Same for a meta parameter...there's no callsite that's converting things from antiforms into a non-antiforms, or adding quote levels.  When you are assigning fields in the frame you have to remember to LIFT them.</p>
</li>
</ul>
<p><strong>It means that if the parameter convention changes, what you might have written for a MAKE FRAME! previously won't work.</strong></p>
<p>Let's say someone writes a function that returns if something is greater than 10:</p>
<pre><code>greater-than-10: func [x [integer!]] [
    return x &gt; 10
]
</code></pre>
<p>Then you write code that builds a frame for it:</p>
<pre><code>f: make frame! greater-than-10/
f.x: 20
assert [eval f]
</code></pre>
<p>It works.  Yet later the person who wrote the function decides they want to do something special if it's passed an unstable antiform, while keeping the behavior for integers the same.</p>
<p>Let's imagine they want to make it so that it tests all integers in a pack, if you give it a pack:</p>
<pre><code>greater-than-10: func [^x [integer! pack!]] [
    if pack? ^x [
        ... code for testing if each element in pack &gt; 10 ...
    ] else [
        ^x &gt; 10
    ]
]

&gt;&gt; greater-than-10 20
== \~okay~\  ; antiform

&gt;&gt; greater-than-10 pack [20 30]
== \~okay~\  ; antiform

&gt;&gt; greater-than-10 pack [10 20]
== \~null~\  ; antiform
</code></pre>
<p>Why did the person who switched the parameter to ^META add this feature?  Who knows.  But let's say they thought it was okay because the callsites they knew about would remain working.</p>
<p><strong>But it breaks our invocation via FRAME!.</strong></p>
<pre><code>&gt;&gt; f: make frame! :greater-than-10
&gt;&gt; f.x: 20
== 20

&gt;&gt; eval f
** Error: X is a ^META argument, must be QUOTED! or QUASIFORM!
</code></pre>
<p>You have to now adjust how you fill the frame to meet the meta requirements:</p>
<pre><code>&gt;&gt; f: make frame! greater-than-10/

&gt;&gt; f.x: quote 20
== '20

&gt;&gt; eval f
== \~okay~\  ; anti
</code></pre>
<blockquote>
<p><strong>UPDATE 2025:</strong> There is an awesome alternative to saying <strong><code>f.x: lift 20</code></strong> or <strong><code>f.x: quote 20</code></strong> which is now to use metavariables, e.g:</p>
<pre><code>&gt;&gt; f.^x: 20
== 20

&gt;&gt; f.x
== '20
</code></pre>
</blockquote>
          <p><a href="https://rebol.metaeducation.com/t/meta-parameters-and-function-composition/2433/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/meta-parameters-and-function-composition/2433/1</link>
        <pubDate>Mon, 21 Jun 2021 02:44:51 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2433-1</guid>
        <source url="https://rebol.metaeducation.com/t/meta-parameters-and-function-composition/2433.rss">Meta-Parameters And Function Composition</source>
      </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>BLANK! 2022: Revisiting The Datatype</title>
    <link>https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942</link>
    <description>In historical Redbol&#39;s meaning of the datatype NONE!, it had the bad habit of looking like a WORD!:

    rebol2&gt;&gt; &#39;none
    == none

    rebol2&gt;&gt; none
    == none  ; same in R3-Alpha and Red

But it wasn&#39;t a word:

    rebol2&gt;&gt; type? &#39;none
    == word!

    rebol2&gt;&gt; type? none
    == none!

It was a distinct type, which also happened to be falsey (while WORD!s are truthy):

    rebol2&gt;&gt; if &#39;none [print &quot;Truthy word!&quot;]
    Truthy word!

    rebol2&gt;&gt; if none [print &quot;Falsey none!&quot;]
    == none

And as we can see, NONE!s served purposes of signaling &quot;soft failures&quot;: branches that didn&#39;t run, or FINDs that didn&#39;t find, or SELECTs that didn&#39;t select... etc.

    rebol2&gt;&gt; find &quot;abcd&quot; &quot;z&quot;
    == none

    rebol2&gt;&gt; select [a 10 b 20] &#39;c
    == none

## Ren-C Divided NONE!s roles across NULL, VOID, and BLANK!

* **NULL** - an &quot;antiform&quot; state of WORD! that couldn&#39;t be put in BLOCK!s.  Anywhere that NONE! would be used to signal a soft failure operation--like FIND or SELECT--would use ~null~.

      &gt;&gt; null
      == ~null~  ; anti

      &gt;&gt; find &quot;abcd&quot; &quot;z&quot;
      == ~null~  ; anti

      &gt;&gt; select [a 10 b 20] &#39;c
      == ~null~  ; anti

      &gt;&gt; append [a b c] null
      ** Error: APPEND doesn&#39;t allow ~null~ isotope

 * **BLANK!** was represented by a lone underscore ( **`_`** ) and could be put into blocks:

       &gt;&gt; append [a b c] _
       == [a b c _]

     At the outset, it retained the choice to be falsey:

       &gt;&gt; if _ [print &quot;Won&#39;t print because blanks are falsey&quot;]

* **VOID** - another &quot;antiform&quot; state, but not one you can store in a variable... hence an &quot;unstable antiform&quot;.  So decisions need to be made on how to handle them.  Some places make them vanish, and when functions like APPEND get them as an argument they are treated as no-ops:

      &gt;&gt; void  ; is a function that returns a void (can&#39;t store void in variable)
      == ~[]~  ; anti (unstable)

      &gt;&gt; when 1 &lt; 0 [print &quot;WHEN is IF variant that returns VOID not null&quot;]
      == ~[]~  ; anti

      &gt;&gt; compose [abc (when 1 &lt; 0 [&#39;def]) ghi]
      == [abc ghi]

      &gt;&gt; append [a b c] void
      == [a b c]

      &gt;&gt; for-each void [1 2 3] [print &quot;no variable&quot;]
      == ~null~  ; anti

## Question One: Should BLANK! Just Be A WORD! ?

Ren-C allows you to use underscores internally to words, so it feels a little bad to take away one word.

Outside of historically being hardcoded as falsey, what makes BLANK! fairly &quot;built in&quot; is that in the path mechanics, it fills in the empty slots:

    &gt;&gt; to path! [_ a]
    == /a

    &gt;&gt; as block! &#39;a/b/c/
    == [a b c _]

There&#39;s other places the blank is used, such as to opt-out of multi-returns.

    &gt;&gt; [_ value]: transcode/next &quot;abc def&quot;
    == &quot; def&quot;

    &gt;&gt; value
    == abc

## Question Two: Does BLANK! Still Need To Be Falsey?

*My feeling is that having blank be falsey doesn&#39;t have all that much benefit.*  NULL does a better job of it, and really what it does is mess with its usefulness as a placeholder:

    &gt;&gt; append [a b c] opt all [1 &gt; 2, 3 &gt; 4, _]
    == [a b c]  ; doesn&#39;t make sense to me

    &gt;&gt; append [a b c] opt all [1 &lt; 2, 3 &lt; 4, _]
    == [a b c _]  ; this makes sense to me

Thinking of BLANK! as being &quot;null-like&quot; in terms of non-valuedness is generally a hassle.  It makes you wonder about whether something like DEFAULT should think of it as being assigned or not:

    &gt;&gt; item: _

    &gt;&gt; item: default [1 + 2]
    == ???

In practice, I prefer only non-array-element things (NULL, TRASH, etc.) being the only cases that DEFAULT overwrites.  This is because NULL is far more useful than BLANK! when it comes to representing something that you think of as &quot;not being assigned&quot;... as you&#39;ll get errors when you try to use it places (e.g. in APPEND).  Trying to use blank to represent nothingness invariably leads to stray appearances in blocks (Shixin wrote a lot of code to try to filter them out in Rebmake, prior to it being switched to NULLs)

This makes more sense, and I think it bolsters the argument that BLANK! is less of a falsey-NULL relative...but more of a placeholder value.  I&#39;ve said &quot;blanks are to blocks what space is to strings&quot;.  And space is truthy:

    &gt;&gt; if second &quot;a b&quot; [print &quot;Space is truthy&quot;]
    Space is truthy

    &gt;&gt; if second [a _ b] [print &quot;So why shouldn&#39;t blank be truthy?&quot;]
    ???

**So Either Way, I Suggest The Removal of BLANK! From Being Falsey**.  This creates some incompatibility in Redbol emulation (which has been using BLANK! as a &quot;NONE!&quot; substitute).  But it&#39;s something that can be worked around.</description>
    
    <lastBuildDate>Tue, 20 May 2025 05:52:04 +0000</lastBuildDate>
    <category>Datatypes</category>
    <atom:link href="https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>BLANK! 2022: Revisiting The Datatype</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="rgchris" data-post="4" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>Specifically BLANK! and its underscore literal is a huge win (this is from me, the ultra-conservative sceptic) in representing positive nothingness—that a thing exists but lacks assignation: <code>[name: "Thing" link: _]</code></p>
</blockquote>
</aside>
<p>I'm starting to believe that although <strong><code>_</code></strong> has moved to being the character literal for SPACE, that the idea that you need to think of a RUNE! ("issuechar!") as having iterability or length may be outweighed by the usefulness of <strong><code>_</code></strong> serving its positive-nothingness role in various places.</p>
<pre><code>&gt;&gt; stuff [10 20 30]

&gt;&gt; variables: [x _ z]

&gt;&gt; for-each '$var variables [set var stuff.1, stuff: stuff:next]

&gt;&gt; x
== 10

&gt;&gt; z
== 30
</code></pre>
<p><em>(Note I snuck in two little proposals there... the idea that if your iteration variable is TIED!, then it will use the block's context to bind it during the FOR-EACH.  Also that instead of <strong>next of stuff</strong> you could say <strong>stuff:next</strong>)</em></p>
<p>Anyway, this steps a bit back from the precipice of saying you always have to perform some unreifying operation to get the "blank" behavior.  <strong>Though it's going to be case-by-case.</strong>  My example of ENVELOP clearly doesn't make sense to use <strong>_</strong> to <em>"opt-in-with-nothing"</em>, and it never has made sense... the empty splice is what you want:</p>
<pre><code>&gt;&gt; envelop [] _
== [_]

&gt;&gt; envelop [] blank
== []
</code></pre>
<p>As for something like FOR-EACH, I dunno...</p>
<pre><code>&gt;&gt; for-each 'x _ [print "What about this?"]
== ~[]~  ; antiform (void)  &lt;-- is this the best answer?
</code></pre>
<p><span class="mention">@earl</span> was always adamant that you shouldn't get strings back as character elements from strings, e.g.:</p>
<pre><code>&gt;&gt; second "abc"
== "b"
</code></pre>
<p>So he would probably say that if you could pick elements out of a RUNE! at all, you wouldn't be picking runes, but integer codepoints or something...</p>
<pre><code>&gt;&gt; second #"a b"
== 32
</code></pre>
<p>We could say that if you really want to sub-index into a rune! for some reason, you could do that by aliasing it as text:</p>
<pre><code>&gt;&gt; for-each 'x (as text! #a) [print mold x]
== #a

&gt;&gt; for-each 'x #a [print mold x]
** Error: Can't iterate RUNE!, alias as text if you want that
</code></pre>
<p>This could allow <strong>_</strong> to take on more of the desired properties of a "blank", such as being EMPTY? and having (length of _) be 0.</p>
<p>Maybe there's a sensibility to saying that # has a length of 1, so that # and _ can function as a kind of postive-space and negative-space counterpart?</p>
<pre><code>&gt;&gt; for-each 'x _ [print mold x]
== ~[]~  ; antiform (void)  &lt;-- e.g. it never ran

&gt;&gt; for-each 'x # [print mold x]
#
</code></pre>
<p><strong>I think we may want to go this route--limiting the operations on rune! in order to open up "space" for these kinds of dialect-enabling behaviors.</strong>  Taking the SET-BLOCK dialect as one example, I'm definitely seeing the power of building on top of a SET that already knows how to pass thru assignments on <strong><code>_</code></strong> without me having to explain how to do that.</p>
<p>And I understand the desire to avoid the REIFY/DEGRADE or lifting/unlifting when possible to do so.  So definitely trying to stay in tune with this motivation.</p>
          <p><a href="https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942/14">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942/14</link>
        <pubDate>Mon, 19 May 2025 11:14:45 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1942-14</guid>
        <source url="https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942.rss">BLANK! 2022: Revisiting The Datatype</source>
      </item>
      <item>
        <title>BLANK! 2022: Revisiting The Datatype</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="12" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>you might think of blank as a kind of "positive nothingness", while void is "negative nothingness"</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; find "abc" void
== ~null~  ; anti

&gt;&gt; find "abc" blank
== "abc"
</code></pre>
</blockquote>
</aside>
<h2><a name="p-8301-this-variable-intentionally-left-blank-1" class="anchor" href="https://rebol.metaeducation.com#p-8301-this-variable-intentionally-left-blank-1"></a>This Variable Intentionally Left Blank...</h2>
<p>The "opt in with nothing" behavior falls out naturally a lot of places that already take splices.</p>
<p>Consider ENVELOP w.r.t NULL, where it can be voided to opt out:</p>
<pre><code>&gt;&gt; var: null
== ~null~  ; anti

&gt;&gt; envelop [(* *)] var
** Error: ENVELOPE's CONTENTS argument is ~null~ antiform

&gt;&gt; envelop [(* *)] opt var
== ~null~  ; anti
</code></pre>
<p>But BLANK! as an empty splice works like other splices:</p>
<pre><code>&gt;&gt; var: blank
== ~()~   ; anti (blank)

&gt;&gt; envelop [(* *)] var
== [(* *)]

&gt;&gt; envelop [(* *)] opt var  ; opt should not voidify empty splices
== [(* *)]

&gt;&gt; envelop [(* *)]] [a b c]
== [(* [a b c] *)]

&gt;&gt; envelop [(* *)] spread [a b c]
== [(* a b c *)]
</code></pre>
<p>This applies places like MOLD as well.</p>
<pre><code>&gt;&gt; mold void
== ~null~  ; anti

&gt;&gt; mold [a b c]
== [a b c]

&gt;&gt; mold spread [a b c]
== "a b c"

&gt;&gt; mold blank
== ""  ; consequence of blank as empty splice
</code></pre>
<p>There may be "unnatural" places, e.g. spots that wouldn't know what to do with a splice that would be interested in just the blank intent.  I haven't found them yet, but will keep my eyes open.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="10" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'm a bit reticent to say that a blank can be passed anywhere you'd pass a void to... but rather they can be passed anywhere you can pass an empty block (or empty string?) to, and give you back the same meaning. That's actually an interesting point: <strong>if the meaning for an empty block and empty string would be different when passed to a routine, then I don't think blank should play favorites in acting like either, because it doesn't connote any particular kind of emptiness.</strong></p>
</blockquote>
</aside>
<p>It's very satisfying how as I pushed on what the properties of BLANK needed to have, that empty SPLICE! meets those properties...just by its nature.</p>
<p>I'm quite glad that (<code>_</code>) =&gt; SPACE so that the good name BLANK could be taken for empty splice, vs a bad name (e.g. HOLE)</p>
<p>(I should have known that with the properties I was describing, BLANK had to be an antiform.)</p>
          <p><a href="https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942/13">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942/13</link>
        <pubDate>Sat, 17 May 2025 05:34:27 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1942-13</guid>
        <source url="https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942.rss">BLANK! 2022: Revisiting The Datatype</source>
      </item>
      <item>
        <title>BLANK! 2022: Revisiting The Datatype</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="rgchris" data-post="4" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>For me (using the family name) Rebol's first obligation is to represent data—both in language and the way the language is interpreted in memory. Specifically BLANK! and its underscore literal is a huge win (this is from me, the ultra-conservative sceptic) in representing positive nothingness—that a thing exists but lacks assignation: <code>[name: "Thing" link: _]</code>. Despite that positivity, I do think that as it represents the known absence of a value in data, it should be falsey in the general flow that data primarily should determine that flow.</p>
</blockquote>
</aside>
<h2><a name="p-8283-some-good-news-on-this-1" class="anchor" href="https://rebol.metaeducation.com#p-8283-some-good-news-on-this-1"></a>Some Good News On This...</h2>
<p>...the basic concepts in virtual binding that power <a href="https://rebol.metaeducation.com/t/evaluator-hooking-rebindablesyntax/2443">RebindableSyntax</a> should be able to provide the hooking I have sought, whereby a construct like IF or CASE can defer to a concept of conditional testing that comes from its calling environment.</p>
<p>The default notion that would drive the mezzanine and such will be that only antiform NULL is "falsey". But you could redefine this for your script, or even at the granularity of what is useful within a certain function.</p>
<p>The technique has been shown to work, and it just needs to get grafted into more natives (and the name for the function chosen).  I have some reasons why I'd like this function to be called CONDITIONAL or COND, and return either a VETO definitional error or VOID (vs. ~null~ or ~okay~)...but that's an explanation for another post.</p>
<p>I don't know that being able to override this will turn out to be as useful as you might think.  But my hope here has always been to let everyone have their own way within their customization environment.  I seek to align the foundations in order to make a system <em>whose internals mechanically <strong>work</strong> across an infinite number of arbitrary programs</em>.  But after that, there's no rule that the definitions used for any given script have to "work" for any more or less than the particular problem it is tackling.</p>
<p>(But the more general the problem and generic your script or library is, the more likely you'll want to be using the default choices...they were picked for a reason.)</p>
<h2><a name="p-8283-some-more-news-that-i-think-is-very-good-2" class="anchor" href="https://rebol.metaeducation.com#p-8283-some-more-news-that-i-think-is-very-good-2"></a>Some More News That I Think Is Very Good...</h2>
<p><strong><a href="https://rebol.metaeducation.com/t/how-does-blank-interact-with-strings-binary/2287/3">I think that underscore needs to be the lexical form for the space character.</a></strong></p>
<p><strong>_</strong> would thus not be BLANK! as a distinct type, but SPACE? (as a type constraint of the RUNE!  fused issue!/char! type).</p>
<p>This won't opt out of enumerations in the way I was envisioning BLANK! might, which makes it not fit for some intents of nothingness.</p>
<p><strong>But an empty splice antiform... <strong><code>~()~</code></strong> will be the new BLANK</strong>  <img src="https://rebol.metaeducation.com/images/emoji/twitter/double_exclamation_mark.png?v=14" title=":double_exclamation_mark:" class="emoji" alt=":double_exclamation_mark:" loading="lazy" width="20" height="20"></p>
<p>Unlike VOID, an empty splice can be stored in variables.</p>
<pre><code>&gt;&gt; var: blank
== ~()~  ; anti (blank)

&gt;&gt; append [a b c] var
== [a b c]

&gt;&gt; append "abc" var
== "abc"
</code></pre>
<p>An empty splice will always be found in a series, while a VOID never will.  So you might think of blank as a kind of "positive nothingness", while void is "negative nothingness"</p>
<pre><code>&gt;&gt; find "abc" void
== ~null~  ; anti

&gt;&gt; find "abc" blank
== "abc"
</code></pre>
<p>If we added BLANK to the things that DEFAULT was willing to overwrite, it could do a decent job of being variable-assignable-nothingness that still was legal to fetch and wouldn't give errors when using in series operations the way a null would.</p>
<aside class="quote no-group" data-username="rgchris" data-post="4" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I have this sense that the BLANK-NULL-VOID-ERROR story has too many actors with overlapping roles. I don't have anything tangible to back that up with at this time.</p>
</blockquote>
</aside>
<p>I'm hoping you'll be finding that you were mistaken, the design has just the right number... even though it's far more when you add it all up, including TRASH (antiform issue), QUASAR (quasi issue), QUASI-BLANK (quasi empty splice), QUASI-NULL (quasi word)... packs and splices, the whole lot.</p>
<p>Everything is related through a coherent system, and comes together beautifully...</p>
<p><a href="https://www.youtube.com/watch?v=Uj689znjxpg">Opus Magnum, by Zachtronics</a></p>

          <p><a href="https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942/12">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942/12</link>
        <pubDate>Thu, 15 May 2025 08:26:42 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1942-12</guid>
        <source url="https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942.rss">BLANK! 2022: Revisiting The Datatype</source>
      </item>
      <item>
        <title>BLANK! 2022: Revisiting The Datatype</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>So further in  my thinking of saying BLANK!s are <strong>empty?</strong> is that we can ask <em>"What is the LENGTH OF a BLANK!"</em></p>
<p>Trying to shape up the semantics for consistency, <strong>I think the LENGTH OF a BLANK! is 0</strong>.</p>
<p><a href="https://github.com/metaeducation/rebol-issues/issues/1626#issuecomment-170911781">BrianH didn't like the idea of R3-Alpha LENGTH? of a NONE being 0</a>.  But having split out the roles of nothingness to a finer granularity, we can say:</p>
<ul>
<li>LENGTH OF BLANK is 0</li>
<li>LENGTH OF QUASAR is ~error~</li>
<li>LENGTH OF VOID (antiform) is NULL</li>
<li>LENGTH OF NULL (antiform) is ~error~</li>
<li>LENGTH OF TRASH (antiform) is ~error~</li>
</ul>
<p>This heeds my policy of saying that if what the routine did would be different e.g. for a string or a block, then blank shouldn't give an answer.  But here, both an empty string and an empty block say 0, so I think the length should be 0.</p>
<h2><a name="p-7614-what-about-remove-each-and-blank-1" class="anchor" href="https://rebol.metaeducation.com#p-7614-what-about-remove-each-and-blank-1"></a>What About REMOVE-EACH and BLANK!</h2>
<p>So this is an interesting one, because here you're asking to modify the input in a way that only removes elements from the input...and then returns it and the count.</p>
<pre><code>&gt;&gt; s: [1 2 3 4 5]

&gt;&gt; [series count]: remove-each num s [even? num]
== [1 3 5]

&gt;&gt; series
== [1 3 5]

&gt;&gt; count
== 2
</code></pre>
<p>While you can't APPEND to a BLANK! meaningfully, it would be reasonable to argue that you can REMOVE-EACH from a BLANK!...because there are no elements you can remove, and so you can give back the blank and 0.</p>
<pre><code>&gt;&gt; [result count]: remove-each x _ [fail "this part never runs"]
== _

&gt;&gt; result
== _

&gt;&gt; count
== 0
</code></pre>
<p>We <em><strong>can</strong></em> do that...but <em><strong>should</strong></em> we?</p>
<p>I'm not sure, but I do feel like this is helping shape the policy on what blanks do.  You don't pass blanks into routines and get nulls out when an empty series would not do that.  (This is what REMOVE-EACH was doing previously for blank, and I think that was wrong.)</p>
          <p><a href="https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942/11">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942/11</link>
        <pubDate>Mon, 09 Sep 2024 21:12:18 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1942-11</guid>
        <source url="https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942.rss">BLANK! 2022: Revisiting The Datatype</source>
      </item>
      <item>
        <title>BLANK! 2022: Revisiting The Datatype</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="9" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So...I'm afraid that BLANK!'s relationship to nullness and falseness has basically gone away. Instead, it's the "space unit" of BLOCK!s--the moral equivalent of a space character in a TEXT!.</p>
</blockquote>
</aside>
<aside class="quote no-group" data-username="hostilefork" data-post="9" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I do think that having SPREAD of a BLANK! return a VOID or an empty splice is probably a good thing... though not completely sure on the merits of choosing one over the other. An empty splice may be "more coherent" in the sense that one probably wouldn't want <strong><code>foo spread _</code></strong> to give back null if <strong><code>foo spread []</code></strong> would not. Considering it "EMPTY?" in certain contexts may be appropriate as well...but not falsey.</p>
</blockquote>
</aside>
<p>Okay, I think this kind of sums up the difference here:</p>
<h2><a name="p-7217-blanks-arent-null-equivalents-or-falsey-they-are-empty-1" class="anchor" href="https://rebol.metaeducation.com#p-7217-blanks-arent-null-equivalents-or-falsey-they-are-empty-1"></a>BLANK!s aren't null-equivalents or falsey, <em>they are EMPTY?</em></h2>
<p>You (<a class="mention" href="https://rebol.metaeducation.com/u/rgchris">@rgchris</a>) hopefully don't expect an empty block to be falsey.</p>
<p>EMPTY? is a test which can work across both blanks and empty blocks (and empty strings, binaries...), to say they are values that are intentionally empty.  And then EMPTY? on null can be an error.</p>
<p>I'm a bit reticent to say that a blank can be passed anywhere you'd pass a void to... but rather they can be passed anywhere you can pass an empty block (or empty string?) to, and give you back the same meaning.  That's actually an interesting point: <strong>if the meaning for an empty block and empty string would be different when passed to a routine, then I don't think blank should play favorites in acting like either, because it doesn't connote any particular kind of emptiness.</strong></p>
<p>I have some other thoughts here about how BLANK! seems to be useful as a way of fitting into places that want to say they are conceptually holding series, but want to avoid the creation of a series identity.  The issue being that you wouldn't so much mind writing <strong><code>[]</code></strong> in these slots except for the fact that what you really need is <strong><code>copy []</code></strong> which gets ugly...and with just <strong><code>_</code></strong> you push the responsibility of making the series to whoever starts expanding it.  But then, if you're making a prototype of an object that's going to get copied that isn't enough to get new copies in the instances... which points to a deeper problem that BLANK! is only papering over.  That needs a bigger discussion, but other things need to be sorted out related to objects first.</p>
          <p><a href="https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942/10">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942/10</link>
        <pubDate>Wed, 06 Mar 2024 13:19:52 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1942-10</guid>
        <source url="https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942.rss">BLANK! 2022: Revisiting The Datatype</source>
      </item>
      <item>
        <title>BLANK! 2022: Revisiting The Datatype</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="rgchris" data-post="4" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I have this sense that the BLANK-NULL-VOID-ERROR story has too many actors with overlapping roles. I don't have anything tangible to back that up with at this time.</p>
</blockquote>
</aside>
<p>I can argue pretty strongly for all the behaviors as being shades of distinction that are important.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/face_with_diagonal_mouth.png?v=14" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20"></p>
<p>I'll mention that I just addressed a weakness, which was that because it was unstable, VOID didn't have a "good" representation in a block that identified it in the class of "weird states".  e.g. it didn't have a quasiform.  Now it does: as a quasiform of the empty block.</p>
<p>This means these are your stock "reified" options for shades-of-nothingness:</p>
<pre><code> [name: "Thing" link: _]
 [name: "Thing" link: ~]  ; ~ is "quasi-blank" a.k.a. "trash"
 [name: "Thing" link: ~null~]
 [name: "Thing" link: ~[]~]  ; can't actually assign variable this way!
</code></pre>
<p>Each of these forms have different behaviors once you evaluate them <em>(or DEGRADE them, e.g. <strong>degrade fourth [name: "Thing" link: ~null~]</strong> narrowly turns the quasiforms to antiforms without doing any transformation of other types):</em></p>
<pre><code> &gt;&gt; x: _
 &gt;&gt; print either x ["truthy"] ["falsey"]
 truthy
 &gt;&gt; append [a b c] x
 == [a b c _]

 &gt;&gt; x: ~
 &gt;&gt; print either x ["truthy"] ["falsey"]
 ** Error: x is not set (~ antiform), see GET/ANY
 &gt;&gt; print either get:any 'x ["truthy"] ["falsey"]
 ** Error: TRASH (~ antiform) is neither truthy nor falsey
 &gt;&gt; append [a b c] x
 ** Error: x is not set (~ antiform), see GET/ANY
 &gt;&gt; append [a b c] get:any 'x
 ** Error: APPEND expects [&lt;opt-out&gt; element? splice?] for its value argument

 &gt;&gt; x: ~null~
 &gt;&gt; print either x ["truthy"] ["falsey"]
 falsey
 &gt;&gt; append [a b c] x
 ** Error: APPEND expects [&lt;opt-out&gt; element? splice?] for its value argument

 &gt;&gt; x: ~[]~
 ** Error: VOID (~[]~ antiform) is unstable and can't be assigned to variables
 &gt;&gt; print either void ["truthy"] ["falsey"]
 ** Error: VOID (~[]~) antiform is neither truthy nor falsey
 &gt;&gt; append [a b c] void  ; VOID is a function, not a variable
 == [a b c]
</code></pre>
<aside class="quote no-group" data-username="rgchris" data-post="4" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>For me (using the family name) Rebol's first obligation is to represent data—both in language and the way the language is interpreted in memory. Specifically BLANK! and its underscore literal is a huge win (this is from me, the ultra-conservative sceptic) in representing positive nothingness—that a thing exists but lacks assignation: <code>[name: "Thing" link: _]</code>. Despite that positivity, I do think that as it represents the known absence of a value in data, it should be falsey in the general flow that data primarily should determine that flow.</p>
</blockquote>
</aside>
<p>So...I'm afraid that BLANK!'s relationship to nullness and falseness has basically gone away.  Instead, it's the "space unit" of BLOCK!s--the moral equivalent of a space character in a TEXT!.</p>
<p>BLANK! has important uses that make it good to be a non-reassignable unit type, taken away from WORD!.  Crucially it now provides the heart of the TRASH antiform to represent unset variables--using a similarly light-looking antiform/quasiform of <strong><code>~</code></strong></p>
<blockquote>
<p><strong>UPDATE 2025:</strong> <a href="https://rebol.metaeducation.com/t/should-sigil-be-a-type-or-just-decorated-blank/2451">It is now also the basis of the "sigils" <strong><code>[@ ^ $]</code></strong></a></p>
<pre><code>&gt;&gt; pin _
== @

&gt;&gt; tie _
== $

&gt;&gt; lift _
== ^
</code></pre>
</blockquote>
<p>Also, I've mentioned BLANK!s application in PATH! and TUPLE!:</p>
<pre><code>&gt;&gt; to path! [_ x]
== /x

 &gt;&gt; to path! [x y _]
 == x/y/
</code></pre>
<p>...as well as in multi-returns:</p>
<pre><code>&gt;&gt; [_ {end}]: find "abcdef" "cd"  ; opt out of main find result, just get tail
== "ef"

&gt;&gt; end
== ef
</code></pre>
<p>Having it be out-of-band and not a WORD! is a strength in these areas.</p>
<p>Having SPREAD of a BLANK! return a VOID or an empty splice may be a good thing... though not completely sure on the merits of choosing one over the other.  An empty splice may be "more coherent" in the sense that one probably wouldn't want <strong><code>foo spread _</code></strong> to give back null if <strong><code>foo spread []</code></strong> would not.  Considering it "EMPTY?" in certain contexts may be appropriate as well...but not falsey.</p>
<aside class="quote no-group" data-username="rgchris" data-post="4" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I'm not up to speed with much of what has changed in this realm for some time, so I apologise if this glosses over some since settled items, though judging by this post, there's much still unsettled.</p>
</blockquote>
</aside>
<p>A year down the road here, things are clicking in place.  Though it would have been massively helpful to have a time machine and send a few of these posts a few years back.  I'm patching a bootstrap executable to be compatible with many of the conventions, and it's pretty quick work when you know what the decisions are.</p>
<p><em>(I was just watching a video <a href="https://www.youtube.com/watch?v=AF8d72mA41M">laying out the difficulties in creating the blue LED</a> (recommended)... and it's so comprehensive on semiconductor technology that sending that one video back in time would have radically changed the course of history.)</em></p>
<aside class="quote no-group" data-username="rgchris" data-post="4" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>If NULL is the evaluator's ultimate representation of nothingness, then there should be a way to access that in internal dialects, such as SET-BLOCK! or PATH! and the like or it is not really fulfilling its role.</p>
</blockquote>
</aside>
<p>I've got a pretty solid sense that the best substrate comes when everything you can PICK out of a block is inert and truthy, where this kind of thing holds:</p>
<pre><code>backup: copy block1
block2: copy []
while [value: try take block1] [  ; you can also shim TAKE as synonym for TRY TAKE
    append block2 value
]
assert [block2 = backup]  ; always true, for any and every BLOCK! (GROUP!, etc.)
</code></pre>
<p>So it's upon you--the interpreter of the block--to give it meaning.  If you want to know if something is blank, you say BLANK?.  If you want to DEGRADE things, you do that.</p>
<aside class="quote no-group" data-username="rgchris" data-post="4" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I think on the one hand it's important to explore all of the possibilities, on the other it seems to be getting awfully convoluted and lacking a comprehensive narrative.</p>
</blockquote>
</aside>
<p>I've surveyed the most code written by the most people...and maintained giant systems after those who wrote them wandered off.  And I've tried a lot of things.  What it's converging on is what I believe to be the best direction for this medium.</p>
<p><strong>But the proof should be in your code, as well.</strong>  I've held off on advocating people spin their wheels porting scripts while things are in flux, but as the flux diminishes I think it's worth it to do some porting of key Rebol2 scripts and document the experience.</p>
<p>A little more work on binding first... but... the time is coming.</p>
          <p><a href="https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942/9">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942/9</link>
        <pubDate>Fri, 01 Mar 2024 12:38:26 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1942-9</guid>
        <source url="https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942.rss">BLANK! 2022: Revisiting The Datatype</source>
      </item>
      <item>
        <title>BLANK! 2022: Revisiting The Datatype</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="rgchris" data-post="4" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>Specifically BLANK! and its underscore literal is a huge win (this is from me, the ultra-conservative sceptic) in representing positive nothingness</p>
</blockquote>
</aside>
<p>Well, that's something.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/slight_smile.png?v=14" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<p>Hence you are on the side of <em>"Taking underscore away from the word pool does more good than harm."</em></p>
<aside class="quote no-group" data-username="rgchris" data-post="4" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I do think that as it represents the known absence of a value in data, it should be falsey in the general flow that data primarily should determine that flow.</p>
</blockquote>
</aside>
<p>I'm trying to make a general engine... so it will be possible to do Redbol compatibility, and if you want different rules you should be able to have them.  But the core as I see it is the "default" distribution which should be based on what is reasonably determined the "best" and most coherent.</p>
<aside class="quote no-group" data-username="rgchris" data-post="4" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I have this sense that the BLANK-NULL-VOID-ERROR story has too many actors with overlapping roles.</p>
</blockquote>
</aside>
<p>It is a work in progress...but...I believe there's plenty of evidence that things are pointing toward a solid outcome.</p>
<p>The proof comes from the code: the contrast between what the approaches without it can't do (and how catastrophically they regularly fall down) vs. what the approaches with them can do cleanly and correctly.</p>
<p>UPARSE is a giant piece of evidence, but I think there's quite a lot more.</p>
<p><a href="https://www.youtube.com/watch?v=H6_eqxh-Qok">Too Many Notes</a></p>

          <p><a href="https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942/5">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942/5</link>
        <pubDate>Fri, 26 Aug 2022 06:36:43 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1942-5</guid>
        <source url="https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942.rss">BLANK! 2022: Revisiting The Datatype</source>
      </item>
      <item>
        <title>BLANK! 2022: Revisiting The Datatype</title>
        <dc:creator><![CDATA[rgchris]]></dc:creator>
        <description><![CDATA[
            <p>There's a lot to ponder here. I think on the one hand it's important to explore all of the possibilities, on the other it seems to be getting awfully convoluted and lacking a comprehensive narrative.</p>
<p>I'm not up to speed with much of what has changed in this realm for some time, so I apologise if this glosses over some since settled items, though judging by this post, there's much still unsettled.</p>
<p>For me (using the family name) Rebol's first obligation is to represent data—both in language and the way the language is interpreted in memory. Specifically BLANK! and its underscore literal is a huge win (this is from me, the ultra-conservative sceptic) in representing positive nothingness—that a thing exists but lacks assignation: <code>[name: "Thing" link: _]</code>. Despite that positivity, I do think that as it represents the known absence of a value in data, it should be falsey in the general flow that data primarily should determine that flow.</p>
<p>What it becomes in a dialect or within the general flow as distinct from NULL is of lesser importance as I see it. If NULL is the evaluator's ultimate representation of nothingness, then there should be a way to access that in internal dialects, such as SET-BLOCK! or PATH! and the like or it is not really fulfilling its role.</p>
<p>I have this sense that the BLANK-NULL-VOID-ERROR story has too many actors with overlapping roles. I don't have anything tangible to back that up with at this time.</p>
          <p><a href="https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942/4</link>
        <pubDate>Fri, 26 Aug 2022 01:55:19 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1942-4</guid>
        <source url="https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942.rss">BLANK! 2022: Revisiting The Datatype</source>
      </item>
      <item>
        <title>BLANK! 2022: Revisiting The Datatype</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>In historical Redbol's meaning of the datatype NONE!, it had the bad habit of looking like a WORD!:</p>
<pre><code>rebol2&gt;&gt; 'none
== none

rebol2&gt;&gt; none
== none  ; same in R3-Alpha and Red
</code></pre>
<p>But it wasn't a word:</p>
<pre><code>rebol2&gt;&gt; type? 'none
== word!

rebol2&gt;&gt; type? none
== none!
</code></pre>
<p>It was a distinct type, which also happened to be falsey (while WORD!s are truthy):</p>
<pre><code>rebol2&gt;&gt; if 'none [print "Truthy word!"]
Truthy word!

rebol2&gt;&gt; if none [print "Falsey none!"]
== none
</code></pre>
<p>And as we can see, NONE!s served purposes of signaling "soft failures": branches that didn't run, or FINDs that didn't find, or SELECTs that didn't select... etc.</p>
<pre><code>rebol2&gt;&gt; find "abcd" "z"
== none

rebol2&gt;&gt; select [a 10 b 20] 'c
== none
</code></pre>
<h2><a name="p-6319-ren-c-divided-nones-roles-across-null-void-and-blank-1" class="anchor" href="https://rebol.metaeducation.com#p-6319-ren-c-divided-nones-roles-across-null-void-and-blank-1"></a>Ren-C Divided NONE!s roles across NULL, VOID, and BLANK!</h2>
<ul>
<li>
<p><strong>NULL</strong> - an "antiform" state of WORD! that couldn't be put in BLOCK!s.  Anywhere that NONE! would be used to signal a soft failure operation--like FIND or SELECT--would use ~null~.</p>
<pre><code>&gt;&gt; null
== ~null~  ; anti

&gt;&gt; find "abcd" "z"
== ~null~  ; anti

&gt;&gt; select [a 10 b 20] 'c
== ~null~  ; anti

&gt;&gt; append [a b c] null
** Error: APPEND doesn't allow ~null~ isotope
</code></pre>
</li>
<li>
<p><strong>BLANK!</strong> was represented by a lone underscore ( <strong><code>_</code></strong> ) and could be put into blocks:</p>
<pre><code>&gt;&gt; append [a b c] _
== [a b c _]
</code></pre>
<p>At the outset, it retained the choice to be falsey:</p>
<pre><code>&gt;&gt; if _ [print "Won't print because blanks are falsey"]
</code></pre>
</li>
<li>
<p><strong>VOID</strong> - another "antiform" state, but not one you can store in a variable... hence an "unstable antiform".  So decisions need to be made on how to handle them.  Some places make them vanish, and when functions like APPEND get them as an argument they are treated as no-ops:</p>
<pre><code>&gt;&gt; void  ; is a function that returns a void (can't store void in variable)
== ~[]~  ; anti (unstable)

&gt;&gt; when 1 &lt; 0 [print "WHEN is IF variant that returns VOID not null"]
== ~[]~  ; anti

&gt;&gt; compose [abc (when 1 &lt; 0 ['def]) ghi]
== [abc ghi]

&gt;&gt; append [a b c] void
== [a b c]

&gt;&gt; for-each void [1 2 3] [print "no variable"]
== ~null~  ; anti
</code></pre>
</li>
</ul>
<h2><a name="p-6319-question-one-should-blank-just-be-a-word-2" class="anchor" href="https://rebol.metaeducation.com#p-6319-question-one-should-blank-just-be-a-word-2"></a>Question One: Should BLANK! Just Be A WORD! ?</h2>
<p>Ren-C allows you to use underscores internally to words, so it feels a little bad to take away one word.</p>
<p>Outside of historically being hardcoded as falsey, what makes BLANK! fairly "built in" is that in the path mechanics, it fills in the empty slots:</p>
<pre><code>&gt;&gt; to path! [_ a]
== /a

&gt;&gt; as block! 'a/b/c/
== [a b c _]
</code></pre>
<p>There's other places the blank is used, such as to opt-out of multi-returns.</p>
<pre><code>&gt;&gt; [_ value]: transcode/next "abc def"
== " def"

&gt;&gt; value
== abc
</code></pre>
<h2><a name="p-6319-question-two-does-blank-still-need-to-be-falsey-3" class="anchor" href="https://rebol.metaeducation.com#p-6319-question-two-does-blank-still-need-to-be-falsey-3"></a>Question Two: Does BLANK! Still Need To Be Falsey?</h2>
<p><em>My feeling is that having blank be falsey doesn't have all that much benefit.</em>  NULL does a better job of it, and really what it does is mess with its usefulness as a placeholder:</p>
<pre><code>&gt;&gt; append [a b c] opt all [1 &gt; 2, 3 &gt; 4, _]
== [a b c]  ; doesn't make sense to me

&gt;&gt; append [a b c] opt all [1 &lt; 2, 3 &lt; 4, _]
== [a b c _]  ; this makes sense to me
</code></pre>
<p>Thinking of BLANK! as being "null-like" in terms of non-valuedness is generally a hassle.  It makes you wonder about whether something like DEFAULT should think of it as being assigned or not:</p>
<pre><code>&gt;&gt; item: _

&gt;&gt; item: default [1 + 2]
== ???
</code></pre>
<p>In practice, I prefer only non-array-element things (NULL, TRASH, etc.) being the only cases that DEFAULT overwrites.  This is because NULL is far more useful than BLANK! when it comes to representing something that you think of as "not being assigned"... as you'll get errors when you try to use it places (e.g. in APPEND).  Trying to use blank to represent nothingness invariably leads to stray appearances in blocks (Shixin wrote a lot of code to try to filter them out in Rebmake, prior to it being switched to NULLs)</p>
<p>This makes more sense, and I think it bolsters the argument that BLANK! is less of a falsey-NULL relative...but more of a placeholder value.  I've said "blanks are to blocks what space is to strings".  And space is truthy:</p>
<pre><code>&gt;&gt; if second "a b" [print "Space is truthy"]
Space is truthy

&gt;&gt; if second [a _ b] [print "So why shouldn't blank be truthy?"]
???
</code></pre>
<p><strong>So Either Way, I Suggest The Removal of BLANK! From Being Falsey</strong>.  This creates some incompatibility in Redbol emulation (which has been using BLANK! as a "NONE!" substitute).  But it's something that can be worked around.</p>
          <p><a href="https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942/1</link>
        <pubDate>Thu, 25 Aug 2022 13:50:26 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1942-1</guid>
        <source url="https://rebol.metaeducation.com/t/blank-2022-revisiting-the-datatype/1942.rss">BLANK! 2022: Revisiting The Datatype</source>
      </item>
  </channel>
</rss>

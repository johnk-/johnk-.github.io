<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Line Continuation and Arity Bugs: Thoughts?</title>
    <link>https://rebol.metaeducation.com/t/line-continuation-and-arity-bugs-thoughts/1965</link>
    <description>At one point in time, there was no way to pass something to RETURN that represented a VOID.  Because voids completely vanished.  If you had a function that took an argument--and a void thing came after it--the evaluator would just keep retriggering until it found a value or hit the end.

This led to the only way of being able to return a void to be to have truly nothing after it.  So RETURN became effectively arity-0 or arity-1.  If you passed it no argument, it would consider itself VOID.  It even had the nice property of being able to chain functions that themselves might be void.

Given that RETURN was doing this, some other functions followed suit.  QUIT could take an argument or not.  CONTINUE could as well.

## But I Just Got Bit By a Variadic QUIT Bug

Without thinking about it, I tried to end some code prematurely by injecting a quit:

     some stuff I wanted to run

     quit  ; added this

     some stuff I wanted to avoid running

And that QUIT ran the stuff I didn&#39;t want to run anyway, because it was variadic.

## My Kneejerk Reaction Was To Kill The Variadicness

The original case of RETURN has changed, because so-called &quot;non-interstitial invisibility&quot; is dead.  You can only make expressions vanish in their totality--not when used as arguments.  Doing otherwise caused more harm than good.

Hence **`return ghost`** is a perfectly fine thing to write.

I&#39;d been thinking that argument-less RETURN would thus go back to returning TRASH (the default meaningless value).  But maybe we shouldn&#39;t support argument-less RETURN at all.

## But Variadics Can Be Neat

I guess RETURN could always take an argument, and we go back to CONTINUE:WITH and QUIT:WITH.

But those are uglier.  

We might question the behavior of the system just randomly slurping up arguments from enusing lines?  Especially when APPLY has such a convenient notation now, of **some-func // [...]**

From a usability perspective, there&#39;s certainly a lot of potential for error in getting the arity wrong.  Having it be more strict could catch bugs, and make it more likely that variadic arity is being used correctly.</description>
    
    <lastBuildDate>Wed, 07 May 2025 10:54:20 +0000</lastBuildDate>
    <category>Semantics</category>
    <atom:link href="https://rebol.metaeducation.com/t/line-continuation-and-arity-bugs-thoughts/1965.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Line Continuation and Arity Bugs: Thoughts?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1965">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Without thinking about it, I tried to end some code prematurely by injecting a quit:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext"> some stuff I wanted to run

 quit  ; added this

 some stuff I wanted to avoid running
</code></pre>
<p>And that QUIT ran the stuff I didn't want to run anyway, because it was variadic.</p>
</blockquote>
</aside>
<p>Now that lone apostrophe (or multi-apostrophe) are <a href="https://rebol.metaeducation.com/t/canonical-list-of-illegal-but-interesting-tokens/2378">no longer legal</a>, I proposed they might step in for the coveted "line continuation signal"</p>
<pre><code>reverse copy imagine-writing your-long-line-here append [a b c] 
  ' [d e f]
</code></pre>
<p>I suggested that continued lines could perhaps even transcode as the line minus the continuation:</p>
<pre><code>&gt;&gt; load --[reverse copy imagine-writing your-long-line-here append [a b c] 
     ' [d e f]]--
== reverse copy imagine-writing your-long-line-here append [a b c] [d e f]
</code></pre>
<p>This gave me the teeny inkling of a thought that <em>perhaps the evaluator would not evaluate across line boundaries</em>.</p>
<p>e.g. you would be required to use this, and so this would be illegal:</p>
<pre><code>reverse copy imagine-writing your-long-line-here append [a b c] 
    [d e f]
</code></pre>
<p>Not illegal to <em>LOAD</em>, but illegal to evaluate.  The APPEND would reject going to a new line to gather it's arguments.</p>
<p>You'd have alternatives, like using a GROUP! with internal newlines:</p>
<pre><code>reverse copy imagine-writing your-long-line-here append [a b c] (
    [d e f]
)

reverse copy imagine-writing your-long-line-here append [a b c] (
    [d e f])
</code></pre>
<p>It seems like this might prevent errors...</p>
<p>Required or not, I'm starting to feel fairly strongly that the apostrophe to continue lines is a good, light choice for calling out continued lines.  So I'm leaning towards going ahead and implementing it.</p>
          <p><a href="https://rebol.metaeducation.com/t/line-continuation-and-arity-bugs-thoughts/1965/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/line-continuation-and-arity-bugs-thoughts/1965/4</link>
        <pubDate>Tue, 25 Mar 2025 15:39:47 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1965-4</guid>
        <source url="https://rebol.metaeducation.com/t/line-continuation-and-arity-bugs-thoughts/1965.rss">Line Continuation and Arity Bugs: Thoughts?</source>
      </item>
      <item>
        <title>Line Continuation and Arity Bugs: Thoughts?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1965">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I don't think people will use passing arguments to continue too often, but <strong><code>continue:with value</code></strong> isn't terrible</p>
</blockquote>
</aside>
<p>A design loophole of this is that nulls at refinement callsites (currently) represent refinement revocation.</p>
<p>e.g. if you are to say:</p>
<pre><code> &gt;&gt; count: null
 == ~null~  ; anti

 &gt;&gt; append:dup [a b c] [d e] count
 == [a b c [d e]]
</code></pre>
<p>Then it's as if the :DUP weren't present at all.  That <em>seems</em> sensible enough...</p>
<p>...but it would imply that <strong><code>(continue:with null)</code></strong> is a synonym for <strong><code>(continue)</code></strong>.</p>
<p>Yet the :WITH is supposed to be a fancy way of saying "pretend I completed the loop body :WITH this value".  To pick one example: you're not allowed to have the body of a MAP-EACH end in null:</p>
<pre><code>&gt;&gt; map-each x [1] [null]
** Error: Cannot append ~null~ isotope to collected MAP-EACH block
</code></pre>
<p>In practice we want CONTINUE with no :WITH to act as if the loop ended in a void--not as if it ended in a null.</p>
<p>For that outcome in the world of today, that suggests not erroring when the :WITH is null:</p>
<pre><code>&gt;&gt; map-each x [1 2 3] [
       if x = 1 [continue]
       if x = 2 [continue:with null]  ; must be same as plain continue? :-/
       if x = 3 [continue:with void]  ; seems more synonymous w/plain continue
   ]
== []
</code></pre>
<p>It's a bit unsatisfying to have that :WITH of a null not acting like if the loop body ended in null and erroring.</p>
<p><strong>This makes me wonder if refinements should implement some kind of rule that makes null and void synonymous... or coupled in a way reminiscent of void-in-null-out.</strong></p>
<p>Perhaps even at callsites, the null state would be illegal:</p>
<pre><code> &gt;&gt; count: null
 == ~null~  ; anti

 &gt;&gt; append:dup [a b c] [d e] count
 ** Error: Refinements at callsite can't be null, use e.g. MAYBE to get void

 &gt;&gt; maybe count
 == ~[]~  ; anti (void)

 &gt;&gt; append:dup [a b c] [d e] maybe count
 == [a b c [d e]]
</code></pre>
<p>What it would mean would be you'd remove refinements from the interface using voids and not nulls.  It's a decision kind of in line with how <a href="https://rebol.metaeducation.com/t/should-void-assigns-mean-fully-remove-a-key/2431">removing elements from MAP! is now done with voids</a>.</p>
<p>So refinement revocation is going to be under scrutiny for a while as I look into this.</p>
          <p><a href="https://rebol.metaeducation.com/t/line-continuation-and-arity-bugs-thoughts/1965/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/line-continuation-and-arity-bugs-thoughts/1965/3</link>
        <pubDate>Thu, 22 Jun 2023 07:18:03 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1965-3</guid>
        <source url="https://rebol.metaeducation.com/t/line-continuation-and-arity-bugs-thoughts/1965.rss">Line Continuation and Arity Bugs: Thoughts?</source>
      </item>
      <item>
        <title>Line Continuation and Arity Bugs: Thoughts?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1965">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<h2>I Just Got Bit By a Variadic QUIT Bug</h2>
<p>Without thinking about it, I tried to end some code prematurely by injecting a quit:</p>
<pre><code>some stuff I wanted to run

quit  ; added this

some stuff I wanted to avoid running
</code></pre>
<p>And that QUIT ran the stuff I didn't want to run anyway, because it was variadic (and acted as QUIT/WITH SOME STUFF I WANTED TO AVOID RUNNING).</p>
</blockquote>
</aside>
<p>I realized this issue is very similar to problems that come up in JavaScript with "automatic semicolon insertion":</p>
<p><a href="https://en.wikibooks.org/wiki/JavaScript/Automatic_semicolon_insertion" class="inline-onebox">JavaScript/Automatic semicolon insertion - Wikibooks, open books for an open world</a></p>
<p>JavaScript doesn't require semicolons at the ends of lines.  There's some debate on whether to take advantage of this--but I'm one of the people who believes it makes the code cleaner.  But cases like RETURN have a parallel problem in JavaScript.</p>
<p>So JavaScript's <code>return</code> is variadic, but the automatic semicolon would bias it so that if you have some stuff on a line after a return it gets ignored.</p>
<p><em>The complexity of the situation makes me feel like erring on the side of fixed arity.</em>  If you want to return trash, say <strong><code>return trash</code></strong>.  And if you want to return void, say <strong><code>return void</code></strong>.  It's more explicit, and I think the "naked" returns probably do more harm than good.</p>
<p>I don't think people will use passing arguments to continue too often, but <strong><code>continue:with value</code></strong> isn't terrible</p>
          <p><a href="https://rebol.metaeducation.com/t/line-continuation-and-arity-bugs-thoughts/1965/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/line-continuation-and-arity-bugs-thoughts/1965/2</link>
        <pubDate>Fri, 10 Feb 2023 17:08:20 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1965-2</guid>
        <source url="https://rebol.metaeducation.com/t/line-continuation-and-arity-bugs-thoughts/1965.rss">Line Continuation and Arity Bugs: Thoughts?</source>
      </item>
      <item>
        <title>Line Continuation and Arity Bugs: Thoughts?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>At one point in time, there was no way to pass something to RETURN that represented a VOID.  Because voids completely vanished.  If you had a function that took an argument--and a void thing came after it--the evaluator would just keep retriggering until it found a value or hit the end.</p>
<p>This led to the only way of being able to return a void to be to have truly nothing after it.  So RETURN became effectively arity-0 or arity-1.  If you passed it no argument, it would consider itself VOID.  It even had the nice property of being able to chain functions that themselves might be void.</p>
<p>Given that RETURN was doing this, some other functions followed suit.  QUIT could take an argument or not.  CONTINUE could as well.</p>
<h2><a name="p-6390-but-i-just-got-bit-by-a-variadic-quit-bug-1" class="anchor" href="https://rebol.metaeducation.com#p-6390-but-i-just-got-bit-by-a-variadic-quit-bug-1"></a>But I Just Got Bit By a Variadic QUIT Bug</h2>
<p>Without thinking about it, I tried to end some code prematurely by injecting a quit:</p>
<pre><code> some stuff I wanted to run

 quit  ; added this

 some stuff I wanted to avoid running
</code></pre>
<p>And that QUIT ran the stuff I didn't want to run anyway, because it was variadic.</p>
<h2><a name="p-6390-my-kneejerk-reaction-was-to-kill-the-variadicness-2" class="anchor" href="https://rebol.metaeducation.com#p-6390-my-kneejerk-reaction-was-to-kill-the-variadicness-2"></a>My Kneejerk Reaction Was To Kill The Variadicness</h2>
<p>The original case of RETURN has changed, because so-called "non-interstitial invisibility" is dead.  You can only make expressions vanish in their totality--not when used as arguments.  Doing otherwise caused more harm than good.</p>
<p>Hence <strong><code>return ghost</code></strong> is a perfectly fine thing to write.</p>
<p>I'd been thinking that argument-less RETURN would thus go back to returning TRASH (the default meaningless value).  But maybe we shouldn't support argument-less RETURN at all.</p>
<h2><a name="p-6390-but-variadics-can-be-neat-3" class="anchor" href="https://rebol.metaeducation.com#p-6390-but-variadics-can-be-neat-3"></a>But Variadics Can Be Neat</h2>
<p>I guess RETURN could always take an argument, and we go back to CONTINUE:WITH and QUIT:WITH.</p>
<p>But those are uglier.</p>
<p>We might question the behavior of the system just randomly slurping up arguments from enusing lines?  Especially when APPLY has such a convenient notation now, of <strong>some-func // [...]</strong></p>
<p>From a usability perspective, there's certainly a lot of potential for error in getting the arity wrong.  Having it be more strict could catch bugs, and make it more likely that variadic arity is being used correctly.</p>
          <p><a href="https://rebol.metaeducation.com/t/line-continuation-and-arity-bugs-thoughts/1965/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/line-continuation-and-arity-bugs-thoughts/1965/1</link>
        <pubDate>Wed, 14 Sep 2022 17:08:13 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1965-1</guid>
        <source url="https://rebol.metaeducation.com/t/line-continuation-and-arity-bugs-thoughts/1965.rss">Line Continuation and Arity Bugs: Thoughts?</source>
      </item>
  </channel>
</rss>

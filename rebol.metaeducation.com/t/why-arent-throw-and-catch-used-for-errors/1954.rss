<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Why Aren&#39;t THROW and CATCH Used For Errors?</title>
    <link>https://rebol.metaeducation.com/t/why-arent-throw-and-catch-used-for-errors/1954</link>
    <description>While many languages speak of &quot;throwing&quot; and &quot;catching&quot; errors, this isn&#39;t how Rebol uses the terms.

Instead, it&#39;s a generic way to move values up the stack.  It gives you a handy &quot;out&quot; from control flow:

    result: catch [
        if condition [throw result]
        some code
        case [
            condition [more code]
            condition [more code, throw result]
        ]
        additional code
        throw result
    ]

The implementation of the feature is lightweight, and built on the same mechanic as RETURN.  You could in fact use RETURN to do the same thing:

    result: eval func [] [
        if condition [return result]
        some code
        case [
            condition [return code]
            condition [more code, return result]
        ]
        additional code
        return result
    ]

**You can, if you like, THROW an ERROR! antiform, and CATCH it.**  But that&#39;s just because you can throw anything.  Packs are fine, too:

    &gt;&gt; [a b]: catch [
           case [
               1 = 2 [throw pack [10 20]]
               1 = 1 [throw pack [100 200]]
           ]
       ]
    == 100

    &gt;&gt; a
    == 100

    &gt;&gt; b 
    == 200

So it&#39;s really about throwing whatever you like--not specific to errors or error handling.

THROW and CATCH are a great lightweight feature for control flow, that people really should be using more often than they do.  *(Ren-C uses &quot;definitional throw&quot;, which means there&#39;s no risk of you calling a routine that would accidentally catch a throw that wasn&#39;t meant for it--which is quite important!)*

## Exceptions use PANIC+RESCUE

Generally speaking, [it&#39;s not a good idea to react to exceptions](https://rebol.metaeducation.com/t/discouraging-the-interception-of-abrupt-failures/1871) *(unless you are something like the CONSOLE, where all you are doing is reporting that the exception happened.)*

An error antiform will decay to an exception if it isn&#39;t triaged.  But you can also cause an exception using PANIC.

*(Fun tidbit: PANIC is implemented by making an error antiform and then not triaging it before passing it on.  Right now it passes it to NULL?, which doesn&#39;t use a meta-aware parameter convention so it forces decay to an exception.  **`panic: cascade [fail/ null?/]`**)*

To help emphasize that you should generally not be reaching for the RESCUE routine to recover from abrupt failures, it lives in **sys.util**.

     &gt;&gt; sys.util/rescue [
           foo: func [argument] [
               return argment + 20  ; whoops, typo
           ]
           foo 1000
        ]
    == make warning! [
        type: &#39;Script
        id: &#39;unassigned-attach
        message: &#39;[:arg1 &quot;word is attached to a context, but unassigned&quot;]
        near: &#39;[
            return argment ** + 20]
        where: &#39;[foo enrescue eval rescue eval catch* enrescue eval rescue console]
        file: ~null~
        line: 2
        arg1: &#39;argment
    ]

Hopefully it&#39;s clear to anyone--upon light reflection--why thinking you can handle exceptions is generally misguided!</description>
    
    <lastBuildDate>Sun, 11 May 2025 16:40:44 +0000</lastBuildDate>
    <category>Questions</category>
    <atom:link href="https://rebol.metaeducation.com/t/why-arent-throw-and-catch-used-for-errors/1954.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Why Aren&#39;t THROW and CATCH Used For Errors?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>While many languages speak of "throwing" and "catching" errors, this isn't how Rebol uses the terms.</p>
<p>Instead, it's a generic way to move values up the stack.  It gives you a handy "out" from control flow:</p>
<pre><code>result: catch [
    if condition [throw result]
    some code
    case [
        condition [more code]
        condition [more code, throw result]
    ]
    additional code
    throw result
]
</code></pre>
<p>The implementation of the feature is lightweight, and built on the same mechanic as RETURN.  You could in fact use RETURN to do the same thing:</p>
<pre><code>result: eval func [] [
    if condition [return result]
    some code
    case [
        condition [return code]
        condition [more code, return result]
    ]
    additional code
    return result
]
</code></pre>
<p><strong>You can, if you like, THROW an ERROR! antiform, and CATCH it.</strong>  But that's just because you can throw anything.  Packs are fine, too:</p>
<pre><code>&gt;&gt; [a b]: catch [
       case [
           1 = 2 [throw pack [10 20]]
           1 = 1 [throw pack [100 200]]
       ]
   ]
== 100

&gt;&gt; a
== 100

&gt;&gt; b 
== 200
</code></pre>
<p>So it's really about throwing whatever you like--not specific to errors or error handling.</p>
<p>THROW and CATCH are a great lightweight feature for control flow, that people really should be using more often than they do.  <em>(Ren-C uses "definitional throw", which means there's no risk of you calling a routine that would accidentally catch a throw that wasn't meant for it--which is quite important!)</em></p>
<h2><a name="p-6360-exceptions-use-panicrescue-1" class="anchor" href="https://rebol.metaeducation.com#p-6360-exceptions-use-panicrescue-1"></a>Exceptions use PANIC+RESCUE</h2>
<p>Generally speaking, <a href="https://rebol.metaeducation.com/t/discouraging-the-interception-of-abrupt-failures/1871">it's not a good idea to react to exceptions</a> <em>(unless you are something like the CONSOLE, where all you are doing is reporting that the exception happened.)</em></p>
<p>An error antiform will decay to an exception if it isn't triaged.  But you can also cause an exception using PANIC.</p>
<p><em>(Fun tidbit: PANIC is implemented by making an error antiform and then not triaging it before passing it on.  Right now it passes it to NULL?, which doesn't use a meta-aware parameter convention so it forces decay to an exception.  <strong><code>panic: cascade [fail/ null?/]</code></strong>)</em></p>
<p>To help emphasize that you should generally not be reaching for the RESCUE routine to recover from abrupt failures, it lives in <strong>sys.util</strong>.</p>
<pre><code> &gt;&gt; sys.util/rescue [
       foo: func [argument] [
           return argment + 20  ; whoops, typo
       ]
       foo 1000
    ]
== make warning! [
    type: 'Script
    id: 'unassigned-attach
    message: '[:arg1 "word is attached to a context, but unassigned"]
    near: '[
        return argment ** + 20]
    where: '[foo enrescue eval rescue eval catch* enrescue eval rescue console]
    file: ~null~
    line: 2
    arg1: 'argment
]
</code></pre>
<p>Hopefully it's clear to anyone--upon light reflection--why thinking you can handle exceptions is generally misguided!</p>
          <p><a href="https://rebol.metaeducation.com/t/why-arent-throw-and-catch-used-for-errors/1954/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/why-arent-throw-and-catch-used-for-errors/1954/1</link>
        <pubDate>Thu, 01 Sep 2022 11:50:21 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1954-1</guid>
        <source url="https://rebol.metaeducation.com/t/why-arent-throw-and-catch-used-for-errors/1954.rss">Why Aren&#39;t THROW and CATCH Used For Errors?</source>
      </item>
  </channel>
</rss>

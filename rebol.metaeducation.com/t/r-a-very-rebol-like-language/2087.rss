<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>R: a very Rebol-like language</title>
    <link>https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087</link>
    <description>In my [last post](https://rebol.metaeducation.com/t/what-if-blocks-had-scopes-but-not-individual-words/2085), I mentioned that the [R](https://www.r-project.org/) language is remarkably similar to Rebol in some respects. Now, R is not perfect — there is [a lot to complain about](https://www.burns-stat.com/pages/Tutor/R_inferno.pdf) (126 pages of it, to be precise). But as a widely-used language with similar concepts, it’s worth taking a look at.

(A warning: I don’t actually know very much about R, and much of the below was assembled from various bits of the [Language Definition](https://cran.r-project.org/doc/manuals/r-release/R-lang.pdf). It seems pretty straightforward, though.)

Two features of R in particular remind me of Rebol. The first is its [peculiar](https://doi.org/10.1145/3360579) implementation of lazy evaluation: not only are function arguments passed as unevaluated thunks, but the original code can be introspected, manipulated and evaluated. (Putting it in Lisp terms, every R function is an [fexpr](https://en.wikipedia.org/wiki/Fexpr).)

The second is its treatment of scopes. In R, *environments* are a first-class data structure, consisting of a lookup table from symbols to values (‘frame’), and a pointer to an enclosing pointer (‘enclosure’). Each function contains a reference to the environment in which it was created; when called, it creates a new frame, and assembles the evaluation environment from that frame and the enclosing environment. Of course, since environments are first-class values, all of this can be manipulated from within the function itself.

These two concepts come together in the form of *promises* — conceptually, R’s answer to Rebol block!s. Promises contain unevaluated code, together with the environment in which it was created. Promises can be explicitly created, but all function arguments are implicitly represented as promises. When used, the code is evaluated in the environment to get the value of the function argument. But it is also possible to retrieve the unevaluated code, then manipulate it and/or evaluate it in another environment.

Alas, base R gives no way to retrieve the environment of a promise. This is fixed by the [`rlang`](https://rlang.r-lib.org/) package, which (amongst other things) gives a greatly more ergonomic interface for unevaluated code. Its basic data structure is the ‘quosure’, again storing code+environment. One can create these explicitly from function arguments, but more often they are manipulated via `rlang`’s quasiquoting functions.

For instance:
```r
&gt; get_mean &lt;- function(data, var) dplyr::summarise(data, mean({{ var }}))
&gt; get_mean(data, air_temp)
  mean(air_temp)
1       21.36986
```
Which (if I haven’t messed anything up) should be equivalent to the following Rebol code:
```
get-mean: func [data var] [summarise data compose [mean (var)]]
get-mean data [air-temp]
```

Incidentally, this shows a major use of R’s metaprogramming facilities: accessing variables in a data frame. Here, `data` is a table of weather measurements I happen to have, with `air_temp` being one of the columns. To my understanding, `dplyr::summarise` works by creating a new environment from its first argument `data`, then evaluates its second argument `mean(air_temp)` in that environment — which is why `air_temp` points to a column of `data` rather than some global variable. This is known as ‘data-masking’, and is widely used within the [tidyverse libraries](https://www.tidyverse.org/).

Rebol, of course, has different solutions to these problems. Instead of having functions automatically quote their arguments, the caller is expected to create block!s as needed. And, instead of associating environments with unevaluated expressions, Rebol associates a binding with each word!. This has advantages (quasiquotation is easier to reason about) and disadvantages (scopes no longer exist). But the end result is much the same: functions have complete control over where, when and how their arguments are evaluated.</description>
    
    <lastBuildDate>Tue, 09 Jan 2024 13:07:42 +0000</lastBuildDate>
    <category>Foreign Inspiration</category>
    <atom:link href="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>R: a very Rebol-like language</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="18" data-topic="2087">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>The first cut of implementing "specifiers" would basically just accrue links, so you'd get some issues of double accrual in cases like:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">let x: 10
group: '(x + 2)
do reduce ['y: group]
</code></pre>
<p>The environment on the composed block would have stuff like the "x: 10" incoming, and then it would be on the group, as well.</p>
</blockquote>
</aside>
<p>Firstly, I’ll note that ‘double accrual’ isn’t really possible with my proposal at all, because at any one time there is only one active binding. If you DO or REDUCE an inner block, that simply switches to the environment bound to that block, whether or not it’s the same or different to the current environment.</p>
<p>Additionally, the inheritance tree is a <em>tree</em>… it’s not a graph with loops. I believe that maintaining that invariant should just be a matter of choosing the right native functions for creating and modifying environments. In particular, it’s probably a bad idea to allow the programmer to re-assign the parent of an existing environment.</p>
<p>However, as for this particular test case, it’s worthwhile detailing how it would be evaluated in my model:</p>
<ol>
<li>It would start with some environment with access to the standard library</li>
<li><code>x:</code> is unbound, so <code>x: 10</code> gets added to the current environment</li>
<li><code>'(x + 2)</code> evaluates to an unbound group <code>(x + 2)</code>, which similarly gets added to the current environment under the name <code>group</code></li>
<li><code>['y: group]</code> is an unbound group which evaluates to itself, picking up a binding to the current environment as it does so</li>
<li><code>reduce</code> evaluates the elements of that block within its bound environment, i.e. the current environment, so it evaluates to <code>[y: (x + 2)]</code> where both the SET-WORD! and the GROUP! are unbound
<ul>
<li>I just realised I never specified the binding of the block which gets returned from REDUCE… but it seems reasonable to posit that it retains its existing binding, in which case the whole returned block is still bound to the current environment</li>
</ul>
</li>
<li>Finally, <code>do</code> executes the block in its bound environment, which is the same as the current environment, and both the elements of the block are unbound so they execute in that environment too.</li>
</ol>
<p>So, most things end up unbound in any case, or bound to the current environment in the case of blocks. There’s not a huge amount of scope for things to go wrong if you aren’t explicitly doing anything weird.</p>
          <p><a href="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/19">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/19</link>
        <pubDate>Tue, 09 Jan 2024 13:07:42 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2087-19</guid>
        <source url="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087.rss">R: a very Rebol-like language</source>
      </item>
      <item>
        <title>R: a very Rebol-like language</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>2 posts were split to a new topic: <a href="https://rebol.metaeducation.com/t/block-creation-vs-evaluation/2098">Block Creation Vs. Evaluation</a></p>
          <p><a href="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/16">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/16</link>
        <pubDate>Tue, 09 Jan 2024 08:54:17 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2087-16</guid>
        <source url="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087.rss">R: a very Rebol-like language</source>
      </item>
      <item>
        <title>R: a very Rebol-like language</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="15" data-topic="2087">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>what precisely do you mean by ‘inheritance’ here?</p>
</blockquote>
</aside>
<p>What I was referring to is what you might think of as the "parent environment" linkage.</p>
<p>The first cut of implementing "specifiers" would basically just accrue links, so you'd get some issues of double accrual in cases like:</p>
<pre><code>let x: 10
group: '(x + 2)
do reduce ['y: group]
</code></pre>
<p>The environment on the composed block would have stuff like the "x: 10" incoming, and then it would be on the group, as well.</p>
<p>A model that said <em>"if something has a binding already, leave it alone"</em> wouldn't encounter such "overbinding" cycles, so that's different.  But a model that doesn't do "overbinding" works very differnetly, so we have to follow through on those discussions... which I'm trying to do <em>(but it takes more time to do so than just answering questions about existing art...)</em></p>
          <p><a href="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/18">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/18</link>
        <pubDate>Tue, 09 Jan 2024 08:53:11 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2087-18</guid>
        <source url="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087.rss">R: a very Rebol-like language</source>
      </item>
      <item>
        <title>R: a very Rebol-like language</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="14" data-topic="2087">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I can't tell if you are speaking of a world in which <strong>reduce [x x]</strong> can never return <strong>[10 20]</strong> or not.</p>
</blockquote>
</aside>
<p>I believe this <em>should</em> be possible. With the semantics I’m suggesting, this is what happens:</p>
<ul>
<li>If neither WORD! in <code>[x x]</code> is bound to an environment, then <code>reduce [x x]</code> will always return two of the same value.</li>
<li>If one or both WORD!s <em>are</em> bound to an environment, there are no guarantees about the result of <code>reduce [x x]</code>.</li>
</ul>
<aside class="quote no-group" data-username="hostilefork" data-post="14" data-topic="2087">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Binding has to answer the question of how the words connect to the right loop, in deeply nested structures, with nested loops. Historical Rebol just walked code and mutated the bindings (e.g. in <strong>for-each x data block</strong> any X words in that block would be destructively rebound to an X with the FOR-EACH. Even if you PROTECTed the block, it was still changed.</p>
</blockquote>
</aside>
<p>In my model, the easiest way to implement this kind of thing involves creating a new environment with the appropriate definitions of CONTINUE and BREAK, then rebinding the whole block such that, so to speak, that environment is ‘slipped under’ the existing environment of that block. (This amounts to taking the current binding of the block, setting it as the the parent of the new environment, then rebinding the block to the new environment.)</p>
<p>The effect of this is as follows: any occurrences of unbound CONTINUE and BREAK within the block get rebound to the new definitions. Any occurrences of CONTINUE and BREAK which were already bound to something else, are still bound to that something else. And all other words remain unchanged.</p>
<p>Amongst other things, this means that nested loops should work with no extra effort. Because this binding occurs at the level of blocks, an environment bound to a nested block will override an environment bound to a higher-level block. So a nested CONTINUE or BREAK gets bound to its surrounding nested loop.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="14" data-topic="2087">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I have some avenues of solution to these problems but none of them crack the case of people restructuring code arbitrarily. Chains of inheritance can form loops when you take something out and put it back in and evaluate again.</p>
</blockquote>
</aside>
<p>I <em>know</em> that Rebol is not object-oriented… so what precisely do you mean by ‘inheritance’ here?</p>
          <p><a href="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/15">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/15</link>
        <pubDate>Sat, 06 Jan 2024 23:54:20 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2087-15</guid>
        <source url="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087.rss">R: a very Rebol-like language</source>
      </item>
      <item>
        <title>R: a very Rebol-like language</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>I can't tell if you are speaking of a world in which <strong>reduce [x x]</strong> can never return <strong>[10 20]</strong> or not.</p>
<p>If you do believe that should be possible, then there are a lot of associated issues.  If you don't believe that should be possible then there are different issues of ways people have expected to use Rebol that won't work--and perhaps they shouldn't work, but these boundaries have not been articulated.</p>
<p>There are still basic challenges with the paradigm to feel through.  I just added CONTINUE and BREAK to be aware of what loop they are breaking (e.g. specialized to the frame of the loop)</p>
<p><a href="https://rebol.metaeducation.com/t/definitional-break-and-continue-the-time-is-now/2066" class="inline-onebox">Definitional Break and Continue... the Time is Now</a></p>
<p>Binding has to answer the question of how the words connect to the right loop, in deeply nested structures, with nested loops.  Historical Rebol just walked code and mutated the bindings (e.g. in <strong>for-each x data block</strong> any X words in that block would be destructively rebound to an X with the FOR-EACH.  Even if you PROTECTed the block, it was still changed.</p>
<p>I have some avenues of solution to these problems but none of them crack the case of people restructuring code arbitrarily.  Chains of inheritance can form loops when you take something out and put it back in and evaluate again.</p>
<p>Anyway, I'm interested in seeing how you might propose solving some of the issues.  You have relevant experience and are picking up on it quickly.  I do think you will find puzzles in the medium on your own--as I did--but now there's more groundwork to build solutions on.</p>
          <p><a href="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/14">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/14</link>
        <pubDate>Sat, 06 Jan 2024 14:12:11 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2087-14</guid>
        <source url="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087.rss">R: a very Rebol-like language</source>
      </item>
      <item>
        <title>R: a very Rebol-like language</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="12" data-topic="2087">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>If you want a good explanation of a bad thing, here is how the closest thing to "global environments" used to work in R3-Alpha:</p>
<p><a href="https://rebol.metaeducation.com/t/the-real-story-about-user-and-lib-contexts/764">The Real Story about User and Lib Contexts</a></p>
<p>Things are improved significantly in Ren-C via "sea of words":</p>
<p><a href="https://rebol.metaeducation.com/t/the-sea-of-words/1564">The Sea Of Words</a></p>
<p>But still, saying "oh it has a binding already, don't use the environment" will have problems, so it will take looking through real code to see what the limits are, and where to just give up and put things in objects and refer to them via <strong>obj.x</strong> instead of trying to convince an invisible propery of which <strong>x</strong> you meant in an ambiguous case.</p>
</blockquote>
</aside>
<p>I already understand how environment used to work (in large part because I did read Sea of Words). But your last paragraph confuses me… if you have any specific problems in mind, could you provide some code examples which would exhibit them?</p>
<p>Also, to be clear, it’s not just a matter of ‘don’t use the environment’. What I’m suggesting is that words could be bound to a <em>different</em> environment, which then overrides the next environment up.</p>
          <p><a href="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/13">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/13</link>
        <pubDate>Sat, 06 Jan 2024 12:59:23 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2087-13</guid>
        <source url="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087.rss">R: a very Rebol-like language</source>
      </item>
      <item>
        <title>R: a very Rebol-like language</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Historical Rebol did not have a notion of environments, but as I've said, Ren-C has been creeping toward them.  Thanks for pointing out the similarities to R.</p>
<p>So long as granular bindings are permitted: I do think that contention between a binding glued onto a word or block vs. using a meaning coming from an environment turns out to be a bigger deal in practice than one might think.  In part due to the fact that stray bindings happen kind of on a whim.</p>
<p>If you want a good explanation of a bad thing, here is how the closest thing to "global environments" used to work in R3-Alpha:</p>
<p><a href="https://rebol.metaeducation.com/t/the-real-story-about-user-and-lib-contexts/764" class="inline-onebox">The Real Story about User and Lib Contexts</a></p>
<p>Things are improved significantly in Ren-C via "sea of words":</p>
<p><a href="https://rebol.metaeducation.com/t/the-sea-of-words/1564" class="inline-onebox">The Sea Of Words</a></p>
<p>But still, saying "oh it has a binding already, don't use the environment" will have problems, so it will take looking through real code to see what the limits are, and where to just give up and put things in objects and refer to them via <strong>obj.x</strong> instead of trying to convince an invisible propery of which <strong>x</strong> you meant in an ambiguous case.</p>
          <p><a href="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/12">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/12</link>
        <pubDate>Sat, 06 Jan 2024 12:48:51 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2087-12</guid>
        <source url="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087.rss">R: a very Rebol-like language</source>
      </item>
      <item>
        <title>R: a very Rebol-like language</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="10" data-topic="2087">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>The point I was trying to make in <em>"Rebol and Scopes: Well Why Not?"</em> wasn't so much that there can't be <em><strong>some</strong></em> behavior. It's the question of whether that's the behavior that people intend.</p>
</blockquote>
</aside>
<p>Hmm, fair enough. In that case, I’ll be more specific, and suggest that this particular model for binding is one which gives a good compromise between sane scoping and flexibility.</p>
<p>And I suggest that largely because I believe it does answer this question:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="10" data-topic="2087">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>If I have a block containing some terms--and I pass it to "someone else" to grok--what happens when some of those terms are meant to have values ascribed by the someone else, and others are supposed to carry over values supplied by the caller?</p>
</blockquote>
</aside>
<p>In this model, the choice is up to the ‘someone else’ (as indeed it is in current Ren-C, if I understand correctly). If they simply want to change some names, they can get at the environment bound to what they’ve been passed, and slip their own environment underneath that. If they want to do something more complicated (like, say, retaining GET-WORD!s as you suggest), they can do a deep traversal and bind their environment to individual words. Either way, the result is some kind of principled mixture of their environment and the caller’s environment.</p>
          <p><a href="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/11">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/11</link>
        <pubDate>Sat, 06 Jan 2024 11:59:57 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2087-11</guid>
        <source url="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087.rss">R: a very Rebol-like language</source>
      </item>
      <item>
        <title>R: a very Rebol-like language</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="9" data-topic="2087">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>So, it seems to me like this system could just possibly work. But I’m admittedly bad with reasoning about this stuff — are there any edge cases I’ve missed? Is there some obvious reason why this <em>wouldn’t</em> work?</p>
</blockquote>
</aside>
<p>The point I was trying to make in <em>"Rebol and Scopes: Well Why Not?"</em> wasn't so much that there can't be <em><strong>some</strong></em> behavior.  It's the question of whether that's the behavior that people intend.</p>
<p>If I have a block containing some terms--and I pass it to "someone else" to grok--what happens when some of those terms are meant to have values ascribed by the someone else, and others are supposed to carry over values supplied by the caller?</p>
<p>Ultimately there's no such thing as magic, and you need to have nuts and bolts available to say what you mean.  To give some insight into what kind of thinking a seemingly simple binding problem requires, I wrote up the following:</p>
<p><strong><a href="https://rebol.metaeducation.com/t/custom-function-generator-pitfalls/2093">Custom Function Generator Pitfalls</a></strong></p>
<p>And that's really just two contexts in play: the function generator and the incoming material for the function body.  People cobbling together source from lots of places with more complex rules about what lookups apply under what rules can get arbitrarily strange.</p>
<p>In something like PARSE, one avenue of attack is just to use keywords.  A mapping from keywords (and types) to combinator functions gives the behavior that parse knows about.  If a WORD! is encountered that's not in the mapping, it's only then that the binding is consulted.</p>
<pre><code>&gt;&gt; rule: ["a" "b" try "c"]

&gt;&gt; parse "abababcab" [some [rule (print "found")]]
found
found
found
found
== ~null~  ; isotope
</code></pre>
<p>SOME and RULE are both words.  But SOME exists in the mapping of combinators, and RULE does not.  So after RULE is seen to not be in the map it falls back onto the binding to look it up.</p>
<p>I've thought that GET-WORD! might be a way of subverting keyword lookup and forcing the use of binding:</p>
<pre><code>&gt;&gt; some: ["a" "b" try "c"]

&gt;&gt; parse "abababcab" [some [:some (print "found")]]
found
found
found
found
== ~null~  ; isotope
</code></pre>
<p>PARSE also has the problem of wanting to be able to define variables via something like LET internally to the parse, and imagining how this would work is all very new.</p>
<p>Anyway having bindings "stick" isn't the problem...it's when you are weaving together code with mixed wishes.  And those wishes have historically been managed by a very simplistic model, that goes so far as to say that each method for each instance of an object has to do a full copy of the function body just so that it can be patched up so the WORD!s point to the object instance.  :-/</p>
          <p><a href="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/10">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/10</link>
        <pubDate>Sat, 06 Jan 2024 11:48:04 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2087-10</guid>
        <source url="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087.rss">R: a very Rebol-like language</source>
      </item>
      <item>
        <title>R: a very Rebol-like language</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <p>Since my first post above, I’ve been contemplating cases such as this:</p>
<pre data-code-wrap="r"><code class="lang-r">&gt; add_quasi &lt;- function(arg1, arg2) quo({{ arg1 }} + {{ arg2 }})
&gt; test &lt;- function(arg) {
+     x &lt;- 10
+     add_quasi({{ arg }}, x)
+ }
&gt; x &lt;- 5
&gt; eval_tidy(test(x))
[1] 15
</code></pre>
<p>Here, <code>add_quasi</code> creates a quosure from both its arguments (using rlang’s quasiquotation syntax). <code>test</code> then passes its argument into <code>add_quasi</code>, alongside a local variable <code>x</code>. Finally, we call <code>test</code> with the global variable <code>x</code>. This gives a quosure containing code <code>x + x</code>, and the result of evaluating this is <code>10 + 5</code>, i.e. <code>15</code>.</p>
<p>Now, in Rebol this wouldn’t be too surprising, since each WORD! has its own binding. In R, however, it is: quosures associate one environment with a whole syntax tree, so we might expect it to evaluate to either <code>5 + 5</code> or <code>10 + 10</code>. How does this work?</p>
<p>The answer becomes obvious if we print the quosure itself:</p>
<pre data-code-wrap="r"><code class="lang-r">&gt; result &lt;- test(x)
&gt; result
&lt;quosure&gt;
expr: ^(^x) + (^x)
env:  0x55dc115b55e8
</code></pre>
<p>This is a nested quosure! And of course, each one carries around its own environment:</p>
<pre data-code-wrap="r"><code class="lang-r">&gt; quo_get_expr(result)[[2]]
&lt;quosure&gt;
expr: ^x
env:  global
&gt; quo_get_expr(result)[[3]]
&lt;quosure&gt;
expr: ^x
env:  0x55dc11710650
</code></pre>
<p>So the first <code>x</code> here is global, while the second is looked up in a local environment. (And the top-level quosure has a different environment yet again, in which <code>+</code> is looked up.)</p>
<p>If we choose, we can also collapse it into one big expression with a single environment, causing it to all be evaluated in the same scope:</p>
<pre data-code-wrap="r"><code class="lang-r">&gt; squashed &lt;- quo_squash(result)
&gt; squashed
x + x
&gt; eval_tidy(squashed)
[1] 10
</code></pre>
<p>In fact, we should really ask rlang to warn us about such a destructive operation:</p>
<pre data-code-wrap="r"><code class="lang-r">&gt; quo_squash(result, warn=TRUE)
x + x
Warning messages:
1: Collapsing inner quosure 
2: Collapsing inner quosure 
</code></pre>
<p>Actually evaluating nested quosures in R is slightly non-obvious, since quosures aren’t part of the base language. Insofar as I can tell, rlang implements <code>eval_tidy</code> using a bit of syntactic trickery — <code>"quosure"</code> is defined as a subclasse of <code>"formula"</code>, a built-in variety of quoted code which uses a tilde for evaluation. <code>eval_tidy</code> then rebinds the tilde operator to evaluate quosures in their environments.</p>
<p>What would such a system look like in the context of Rebol? I think it would be a system where bindings can be associated with <em>more than one type</em>: not just WORD!, but also BLOCK! (and presumably also GROUP!, etc.). A WORD! would be evaluated in the context of its own binding if it has one; otherwise it would get looked up in the environment of the first containing BLOCK!/GROUP! which has a binding.</p>
<p>Considering such a system more seriously, I believe it would cope quite easily with code like that mentioned in <a href="https://rebol.metaeducation.com/t/rebol-and-scopes-well-why-not/1751" class="inline-onebox">Rebol And Scopes: Well, Why Not?</a> :</p>
<pre data-code-wrap="r"><code class="lang-r"> global: 10
 x: &lt;not an integer&gt;

 wrapper: func [string] [
     return do compose [interpolate (string)]
 ]

 foo: func [x] [
     let local: 20
     return wrapper {The sum is $(x + local)}
 ]

 foo 30
</code></pre>
<p>Starting with <code>foo</code>, it would bind its body block to a new environment. Then, <code>foo 30</code> would cause the block to be evaluated — the words within it don’t have their own bindings yet, so everything executes within <code>foo</code>’s environment. <code>foo</code> proceeds to create <code>local</code> within its environment, and then it makes a string <em>which is bound to its environment</em> (since strings would also require bindings in order for string interpolation to work). Then, it calls <code>wrapper</code>, which similarly has bound its body to its own environment. As with <code>foo</code>, every word in its body would be looked up in <code>wrapper</code>’s environment — <em>except for the variables in <code>string</code></em>, because <code>string</code> already has its own binding.</p>
<p>It also copes with this case:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1751">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/rebol-and-scopes-well-why-not/1751/1">Rebol And Scopes: Well, Why Not?</a></div>
<blockquote>
<p>If you're dynamically creating a function with some block material you got "from somewhere else", that material may have been written with the express knowledge that certain words were supposed to be overridden by the place it's being substituted, with others left alone.</p>
</blockquote>
</aside>
<p>Because you can still rebind whatever you want within a block. So a dialect can create its own environment, populate it with whichever words it wants, and then rebind words within a block to refer to that environment. And it all just works, because the rebound words will use their own bound environment, and the other words will use their parent block’s environment.</p>
<p>So, it seems to me like this system could just possibly work. But I’m admittedly bad with reasoning about this stuff — are there any edge cases I’ve missed? Is there some obvious reason why this <em>wouldn’t</em> work?</p>
          <p><a href="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/9">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/9</link>
        <pubDate>Sat, 06 Jan 2024 07:49:34 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2087-9</guid>
        <source url="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087.rss">R: a very Rebol-like language</source>
      </item>
      <item>
        <title>R: a very Rebol-like language</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="7" data-topic="2087">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Well the BLOCK!s are acting as FEXPRs, and you can also quote one item at the callsite at a time if it is convenient.</p>
</blockquote>
</aside>
<p>I’d say that ‘quoting at the callsite’ is specifically the primary attribute of fexprs. Providing block!s as arguments is very fexpr-like, but can be done in any language with quotation.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="7" data-topic="2087">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>You could say <strong>for-each 'x</strong> or <strong>'type of</strong>, but the idea is just nicer ergonomics for the language when you have a very common and understood expression.</p>
</blockquote>
</aside>
<p>Personally I much prefer being explicit about such things, which means no quoting at the call-site (‘speaking with tics’). But it’s ultimately down to subjective preference.</p>
          <p><a href="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/8">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/8</link>
        <pubDate>Fri, 05 Jan 2024 07:02:49 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2087-8</guid>
        <source url="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087.rss">R: a very Rebol-like language</source>
      </item>
      <item>
        <title>R: a very Rebol-like language</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="6" data-topic="2087">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>OK, this is very interesting: Rebol has fexprs.</p>
</blockquote>
</aside>
<p>Well the BLOCK!s are acting as FEXPRs, and you can also quote one item at the callsite at a time if it is convenient.</p>
<aside class="quote no-group" data-username="bradrn" data-post="6" data-topic="2087">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I don’t actually see the need for it, when putting stuff into blocks is so convenient and idiomatic</p>
</blockquote>
</aside>
<p>Beyond things like THE which are useful, it's used in things like <strong>for-each x [1 2 3] [print [x]]</strong>... the X doesn't have a quoting tic on it to pass to FOR-EACH as the name of the variable.  (It is soft quoted, so you can calculate the variable name via GET-GROUP!)</p>
<p>Ren-C extends this to things like <strong>type of foo</strong> instead of <strong>type? foo</strong>, where the left-hand argument for OF can be taken as a plain word.</p>
<p>You could say <strong>for-each 'x</strong> or <strong>'type of</strong>, but the idea is just nicer ergonomics for the language when you have a very common and understood expression.</p>
<p>Some discussion: <strong><a href="https://rebol.metaeducation.com/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359">Speaking With Tics</a></strong></p>
<aside class="quote no-group" data-username="bradrn" data-post="6" data-topic="2087">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>(Also, I didn’t know GET-GROUP!s existed, so thanks for mentioning them!)</p>
</blockquote>
</aside>
<p>Ren-C has GET-GROUP! and GET-BLOCK!, as well as SET-GROUP! and SET-BLOCK!.</p>
<p>The evaluator's meaning for GET-BLOCK! is a REDUCE:</p>
<pre><code>&gt;&gt; :['foo 1 + 2]
== [foo 3]
</code></pre>
<p>SET-BLOCK! is used in multi-returns.</p>
<p>Ren-C also expands TUPLE! to be generic, e.g. <strong>a.(b c).d</strong> is a 3-element TUPLE!, as <strong>a/(b c)/d</strong> is a 3-element PATH!.</p>
<p>TUPLE!s are used for field selection in Ren-C.</p>
<p>All of these parts are up to you to use how you wish in your own dialects.</p>
<aside class="quote no-group" data-username="bradrn" data-post="6" data-topic="2087">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I don’t see why anyone would choose to manipulate R code as strings, given that unevaluated code is already parsed and stored in AST form.</p>
</blockquote>
</aside>
<p>Ok, well if they have an API for manipulating the AST then I guess they are more comparable.</p>
          <p><a href="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/7">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/7</link>
        <pubDate>Fri, 05 Jan 2024 05:51:43 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2087-7</guid>
        <source url="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087.rss">R: a very Rebol-like language</source>
      </item>
      <item>
        <title>R: a very Rebol-like language</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2087">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>You can also quote things at the callsite</p>
</blockquote>
</aside>
<p>OK, this is very interesting: Rebol has fexprs. And what’s particularly interesting about it is that I don’t actually see the need for it, when putting stuff into blocks is so convenient and idiomatic (thanks to definitional scoping). So what purpose does this feature serve in Rebol?</p>
<p>(Also, I didn’t know GET-GROUP!s existed, so thanks for mentioning them!)</p>
<aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2087">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>In Ren-C, QUOTE is used for adding quoting levels to things. The hard-quoting operator is called THE.</p>
</blockquote>
</aside>
<p>So… THE in Ren-C corresponds to QUOTE in Lisp? (Or, at least, is the closest thing to QUOTE in Lisp.)</p>
<aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2087">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Pursuant to the above: if you want to limit this to passing a variable name, you'd more typically write <strong>get-mean data 'air-temp</strong>, which would let you type-constrain GET-MEAN to say that VAR is expected as a WORD!.</p>
</blockquote>
</aside>
<p>Yeah, fair enough. I’m still getting used to the Rebol paradigm, and in particular the multiple different kinds of quoting. (In a Lisp, <code>'a</code> and <code>[a]</code> would both be <code>(quote a)</code>.)</p>
<p>EDIT: er, actually, I guess they would really be <code>(quote a)</code> vs <code>(quote (a))</code>. Either way, it’s the same kind of quoting.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2087">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Are there a lot of examples of people trying to manipulate the R code as strings, or just the environments?</p>
</blockquote>
</aside>
<p>No idea, but I don’t see why anyone would choose to manipulate R code as strings, given that unevaluated code is already parsed and stored in AST form. I’m sure there are plenty of usecases for manipulating the AST, though!</p>
          <p><a href="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/6">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/6</link>
        <pubDate>Fri, 05 Jan 2024 05:38:57 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2087-6</guid>
        <source url="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087.rss">R: a very Rebol-like language</source>
      </item>
      <item>
        <title>R: a very Rebol-like language</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Interesting to find out R has this character.</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2087">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Instead of having functions automatically quote their arguments, the caller is expected to create block!s as needed.</p>
</blockquote>
</aside>
<p>Wrapping things in blocks is one way.  You can also quote things at the callsite (Ren-C allows you to quote all types arbitrarily, while Rebol and Red only have quoted words and paths).</p>
<p>But there are also "hard" quoted arguments, and "soft" quoted arguments.  Ren-C does it a little differently than Rebol or Red.</p>
<p>A hard quoted argument, denoted with a quote mark, will give you literally whatever you pass it:</p>
<pre><code>&gt;&gt; test-hard: func ['x] [probe x]

&gt;&gt; test-hard var
== var

&gt;&gt; test-hard :(first [var1 var2])
== :(first [var1 var2])
</code></pre>
<p>A soft quoted argument, denoted with a leading colon (GET-WORD!), will evaluate GET-GROUP!s or GET-WORD!s, but give everything else literally:</p>
<pre><code>&gt;&gt; test-soft: func [:x] [probe x]

&gt;&gt; test-soft var
== var

&gt;&gt; test-soft :(first [var1 var2])
== var1
</code></pre>
<p>Rebol and Red flip this and use the colon form to do "hard" quoting, for whatever reason.  They also don't have GET-GROUP!s, so their soft quoting evaluates plain groups.</p>
<p>Utilizing the feature...historical Rebol has a hard-quoting operator QUOTE that lets you quote whatever you want:</p>
<pre><code>rebol2&gt;&gt; quote (1 + 2)
== (1 + 2)
</code></pre>
<p>In Ren-C, QUOTE is used for adding quoting levels to things.  The hard-quoting operator is called THE.</p>
<pre><code>ren-c&gt;&gt; x: 10

ren-c&gt;&gt; quote x
== '10

ren-c&gt;&gt; the x
== x

ren-c&gt;&gt; the (1 + 2)
== (1 + 2)
</code></pre>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2087">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Which (if I haven’t messed anything up) should be equivalent to the following Rebol code:</p>
<pre><code>get-mean: func [data var] [summarise data compose [mean (var)]]
get-mean data [air-temp]
</code></pre>
</blockquote>
</aside>
<p>Pursuant to the above: if you want to limit this to passing a variable name, you'd more typically write <strong>get-mean data 'air-temp</strong>, which would let you type-constrain GET-MEAN to say that VAR is expected as a WORD!.</p>
<p>Note that historical Rebol's COMPOSE required /ONLY to place blocks as-is, otherwise it would splice them.  If BLOCK is <strong>[a b c]</strong>:</p>
<pre><code>rebol2&gt;&gt; compose [(block) d e f (block)]
== [a b c d e f a b c]

rebol2&gt;&gt; compose/only [(block) d e f (block)]
== [[a b c] d e f [a b c]]
</code></pre>
<p>In Ren-C, there is no /ONLY, and splicing is done with isotopic groups, created by SPREAD from blocks or groups.</p>
<pre><code>ren-c&gt;&gt; compose [(block) d e f (spread block)]
== [[a b c] d e f a b c]
</code></pre>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2087">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Rebol, of course, has different solutions to these problems.</p>
</blockquote>
</aside>
<p>According one of your links, the laziness is generally not used (I helped someone with some R code despite not knowing it, and didn't run across this).</p>
<p>Are there a lot of examples of people trying to manipulate the R code as strings, or just the environments?</p>
          <p><a href="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/5">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/5</link>
        <pubDate>Thu, 04 Jan 2024 20:08:37 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2087-5</guid>
        <source url="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087.rss">R: a very Rebol-like language</source>
      </item>
      <item>
        <title>R: a very Rebol-like language</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>3 posts were merged into an existing topic: <a href="https://rebol.metaeducation.com/t/kaj-gets-on-the-meta-train/1753/5">Kaj Gets on the Meta Train</a></p>
          <p><a href="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/4</link>
        <pubDate>Tue, 02 Jan 2024 02:15:25 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2087-4</guid>
        <source url="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087.rss">R: a very Rebol-like language</source>
      </item>
      <item>
        <title>R: a very Rebol-like language</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <p>In my <a href="https://rebol.metaeducation.com/t/what-if-blocks-had-scopes-but-not-individual-words/2085">last post</a>, I mentioned that the <a href="https://www.r-project.org/">R</a> language is remarkably similar to Rebol in some respects. Now, R is not perfect — there is <a href="https://www.burns-stat.com/pages/Tutor/R_inferno.pdf">a lot to complain about</a> (126 pages of it, to be precise). But as a widely-used language with similar concepts, it’s worth taking a look at.</p>
<p>(A warning: I don’t actually know very much about R, and much of the below was assembled from various bits of the <a href="https://cran.r-project.org/doc/manuals/r-release/R-lang.pdf">Language Definition</a>. It seems pretty straightforward, though.)</p>
<p>Two features of R in particular remind me of Rebol. The first is its <a href="https://doi.org/10.1145/3360579">peculiar</a> implementation of lazy evaluation: not only are function arguments passed as unevaluated thunks, but the original code can be introspected, manipulated and evaluated. (Putting it in Lisp terms, every R function is an <a href="https://en.wikipedia.org/wiki/Fexpr">fexpr</a>.)</p>
<p>The second is its treatment of scopes. In R, <em>environments</em> are a first-class data structure, consisting of a lookup table from symbols to values (‘frame’), and a pointer to an enclosing pointer (‘enclosure’). Each function contains a reference to the environment in which it was created; when called, it creates a new frame, and assembles the evaluation environment from that frame and the enclosing environment. Of course, since environments are first-class values, all of this can be manipulated from within the function itself.</p>
<p>These two concepts come together in the form of <em>promises</em> — conceptually, R’s answer to Rebol block!s. Promises contain unevaluated code, together with the environment in which it was created. Promises can be explicitly created, but all function arguments are implicitly represented as promises. When used, the code is evaluated in the environment to get the value of the function argument. But it is also possible to retrieve the unevaluated code, then manipulate it and/or evaluate it in another environment.</p>
<p>Alas, base R gives no way to retrieve the environment of a promise. This is fixed by the <a href="https://rlang.r-lib.org/"><code>rlang</code></a> package, which (amongst other things) gives a greatly more ergonomic interface for unevaluated code. Its basic data structure is the ‘quosure’, again storing code+environment. One can create these explicitly from function arguments, but more often they are manipulated via <code>rlang</code>’s quasiquoting functions.</p>
<p>For instance:</p>
<pre data-code-wrap="r"><code class="lang-r">&gt; get_mean &lt;- function(data, var) dplyr::summarise(data, mean({{ var }}))
&gt; get_mean(data, air_temp)
  mean(air_temp)
1       21.36986
</code></pre>
<p>Which (if I haven’t messed anything up) should be equivalent to the following Rebol code:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">get-mean: func [data var] [summarise data compose [mean (var)]]
get-mean data [air-temp]
</code></pre>
<p>Incidentally, this shows a major use of R’s metaprogramming facilities: accessing variables in a data frame. Here, <code>data</code> is a table of weather measurements I happen to have, with <code>air_temp</code> being one of the columns. To my understanding, <code>dplyr::summarise</code> works by creating a new environment from its first argument <code>data</code>, then evaluates its second argument <code>mean(air_temp)</code> in that environment — which is why <code>air_temp</code> points to a column of <code>data</code> rather than some global variable. This is known as ‘data-masking’, and is widely used within the <a href="https://www.tidyverse.org/">tidyverse libraries</a>.</p>
<p>Rebol, of course, has different solutions to these problems. Instead of having functions automatically quote their arguments, the caller is expected to create block!s as needed. And, instead of associating environments with unevaluated expressions, Rebol associates a binding with each word!. This has advantages (quasiquotation is easier to reason about) and disadvantages (scopes no longer exist). But the end result is much the same: functions have complete control over where, when and how their arguments are evaluated.</p>
          <p><a href="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087/1</link>
        <pubDate>Sat, 30 Dec 2023 09:36:02 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2087-1</guid>
        <source url="https://rebol.metaeducation.com/t/r-a-very-rebol-like-language/2087.rss">R: a very Rebol-like language</source>
      </item>
  </channel>
</rss>

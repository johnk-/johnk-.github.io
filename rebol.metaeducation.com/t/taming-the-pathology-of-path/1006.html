<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Taming the Pathology of PATH! - Philosophy - AltRebol</title>
    <meta name="description" content="PATH! has long been a thorn.  Because it has been considered an ANY-SERIES!--with a position and an index--you can get into all kinds of trouble.  Such as decaying into something indistinguishable from a WORD!, and then &amp;hellip;">
    <meta name="generator" content="Discourse 3.5.0.beta6-dev - https://github.com/discourse/discourse version 623cde985b21c2ed812b83d3ea94f69231613718">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/1X/cbd70027b53fa165575e5b665f00eb3b8ae7ea31_2_32x32.ico">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d_2_180x180.png">
<meta name="theme-color" media="all" content="#fff">

<meta name="color-scheme" content="light">

<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, viewport-fit=cover">
<link rel="canonical" href="https://rebol.metaeducation.com/t/taming-the-pathology-of-path/1006" />

<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="AltRebol Search">

    <link href="../../stylesheets/color_definitions_base__2_ceb61c279a74dfa3cef6a62f7784988102abec82.css%3F__ws=rebol.metaeducation.com.css" media="all" rel="stylesheet" class="light-scheme"/>

<link href="../../stylesheets/common_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css%3F__ws=rebol.metaeducation.com.css" media="all" rel="stylesheet" data-target="common"  />

  <link href="../../stylesheets/desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css%3F__ws=rebol.metaeducation.com.css" media="all" rel="stylesheet" data-target="desktop"  />



    <link href="../../stylesheets/chat_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css%3F__ws=rebol.metaeducation.com.css" media="all" rel="stylesheet" data-target="chat"  />
    <link href="../../stylesheets/discourse-details_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css%3F__ws=rebol.metaeducation.com.css" media="all" rel="stylesheet" data-target="discourse-details"  />
    <link href="../../stylesheets/discourse-lazy-videos_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css%3F__ws=rebol.metaeducation.com.css" media="all" rel="stylesheet" data-target="discourse-lazy-videos"  />
    <link href="../../stylesheets/discourse-local-dates_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css%3F__ws=rebol.metaeducation.com.css" media="all" rel="stylesheet" data-target="discourse-local-dates"  />
    <link href="../../stylesheets/discourse-narrative-bot_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css%3F__ws=rebol.metaeducation.com.css" media="all" rel="stylesheet" data-target="discourse-narrative-bot"  />
    <link href="../../stylesheets/discourse-presence_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css%3F__ws=rebol.metaeducation.com.css" media="all" rel="stylesheet" data-target="discourse-presence"  />
    <link href="../../stylesheets/docker_manager_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css%3F__ws=rebol.metaeducation.com.css" media="all" rel="stylesheet" data-target="docker_manager"  />
    <link href="../../stylesheets/footnote_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css%3F__ws=rebol.metaeducation.com.css" media="all" rel="stylesheet" data-target="footnote"  />
    <link href="../../stylesheets/poll_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css%3F__ws=rebol.metaeducation.com.css" media="all" rel="stylesheet" data-target="poll"  />
    <link href="../../stylesheets/spoiler-alert_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css%3F__ws=rebol.metaeducation.com.css" media="all" rel="stylesheet" data-target="spoiler-alert"  />
    <link href="../../stylesheets/chat_desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css%3F__ws=rebol.metaeducation.com.css" media="all" rel="stylesheet" data-target="chat_desktop"  />
    <link href="../../stylesheets/poll_desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css%3F__ws=rebol.metaeducation.com.css" media="all" rel="stylesheet" data-target="poll_desktop"  />

  <link href="../../stylesheets/common_theme_2_57fe803ed5a41e9f7d94086afaf66a1aab57d9ae.css%3F__ws=rebol.metaeducation.com.css" media="all" rel="stylesheet" data-target="common_theme" data-theme-id="2" data-theme-name="default"/>
    

    
    
        <link rel="alternate nofollow" type="application/rss+xml" title="RSS feed of &#39;Taming the Pathology of PATH!&#39;" href="1006.rss" />
    <meta property="og:site_name" content="AltRebol" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:image" content="https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:url" content="https://rebol.metaeducation.com/t/taming-the-pathology-of-path/1006" />
<meta name="twitter:url" content="https://rebol.metaeducation.com/t/taming-the-pathology-of-path/1006" />
<meta property="og:title" content="Taming the Pathology of PATH!" />
<meta name="twitter:title" content="Taming the Pathology of PATH!" />
<meta property="og:description" content="PATH! has long been a thorn.  Because it has been considered an ANY-SERIES!--with a position and an index--you can get into all kinds of trouble.  Such as decaying into something indistinguishable from a WORD!, and then to nothing at all.  In Rebol2/Red:  &gt;&gt; p: to path! [a b] == a/b  &gt;&gt; type? next p == path! &gt;&gt; next p == b  ;-- ack, looks like a WORD!  &gt;&gt; type? next next p == path! &gt;&gt; next next p ==    ;-- uhhhh, nothing?  That&#39;s a glaring problem, but there&#39;s many other reasons it makes a bad g..." />
<meta name="twitter:description" content="PATH! has long been a thorn.  Because it has been considered an ANY-SERIES!--with a position and an index--you can get into all kinds of trouble.  Such as decaying into something indistinguishable from a WORD!, and then to nothing at all.  In Rebol2/Red:  &gt;&gt; p: to path! [a b] == a/b  &gt;&gt; type? next p == path! &gt;&gt; next p == b  ;-- ack, looks like a WORD!  &gt;&gt; type? next next p == path! &gt;&gt; next next p ==    ;-- uhhhh, nothing?  That&#39;s a glaring problem, but there&#39;s many other reasons it makes a bad g..." />
<meta property="og:article:section" content="Usage" />
<meta property="og:article:section:color" content="3AB54A" />
<meta property="og:article:section" content="Philosophy" />
<meta property="og:article:section:color" content="3AB54A" />
<meta name="twitter:label1" value="Reading time" />
<meta name="twitter:data1" value="8 mins üïë" />
<meta name="twitter:label2" value="Likes" />
<meta name="twitter:data2" value="6 ‚ù§" />
<meta property="article:published_time" content="2019-01-11T03:00:28+00:00" />
<meta property="og:ignore_canonical" content="true" />


    
  </head>
  <body class="crawler ">
    
    <header>
  <a href="../../index.html">AltRebol</a>
</header>

    <div id="main-outlet" class="wrap" role="main">
        <div id="topic-title">
    <h1>
      <a href="1006.html">Taming the Pathology of PATH!</a>
    </h1>

      <div class="topic-category" itemscope itemtype="http://schema.org/BreadcrumbList">
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="../../c/usage/philosophy/31.html" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #3AB54A'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Usage</span>
              </span>
            </a>
            <meta itemprop="position" content="1" />
          </span>
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="../../c/usage/philosophy/31.html" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #3AB54A'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Philosophy</span>
              </span>
            </a>
            <meta itemprop="position" content="2" />
          </span>
      </div>

  </div>

  

    <div itemscope itemtype='http://schema.org/DiscussionForumPosting'>
      <meta itemprop='headline' content='Taming the Pathology of PATH!'>
      <link itemprop='url' href='https://rebol.metaeducation.com/t/taming-the-pathology-of-path/1006'>
      <meta itemprop='datePublished' content='2019-01-11T03:00:28Z'>
        <meta itemprop='articleSection' content='Philosophy'>
      <meta itemprop='keywords' content=''>
      <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
        <meta itemprop='name' content='AltRebol'>
          <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
            <meta itemprop='url' content='https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
          </div>
      </div>


          <div id='post_1'  class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>

                <link itemprop="mainEntityOfPage" href="https://rebol.metaeducation.com/t/taming-the-pathology-of-path/1006">


              <span class="crawler-post-infos">
                  <time  datetime='2019-01-11T03:00:28Z' class='post-time'>
                    January 11, 2019,  3:00am
                  </time>
                  <meta itemprop='dateModified' content='2019-01-11T06:20:48Z'>
              <span itemprop='position'>1</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>PATH! has long been a thorn.  Because it has been considered an ANY-SERIES!--with a position and an index--you can get into all kinds of trouble.  Such as decaying into something indistinguishable from a WORD!, and then to nothing at all.  In Rebol2/Red:</p>
<pre><code>&gt;&gt; p: to path! [a b]
== a/b

&gt;&gt; type? next p
== path!
&gt;&gt; next p
== b  ;-- ack, looks like a WORD!

&gt;&gt; type? next next p
== path!
&gt;&gt; next next p
==    ;-- uhhhh, nothing?
</code></pre>
<p>That's a glaring problem, but there's many other reasons it makes a bad generic array.  Try putting WORD! variations in it:</p>
<pre><code>red&gt;&gt; to get-path! [a b]
== :a/b
red&gt;&gt; p: to path! [:a b]
== :a/b
red&gt;&gt; to get-path! p
== ::a/b
</code></pre>
<p>Worse still, put a PATH! in a PATH!.</p>
<pre><code>&gt;&gt; left: clear make path! [x x]
&gt;&gt; append left 'a/b
&gt;&gt; append left 'c

&gt;&gt; right: clear make path! [x x]
&gt;&gt; append right 'a
&gt;&gt; append right 'b/c

&gt;&gt; left
== a/b/c
&gt;&gt; first left
== a/b

&gt;&gt; right
== a/b/c
&gt;&gt; first right
== a
</code></pre>
<h2><a name="p-2950-new-paradigm-path-is-not-an-any-series-1" class="anchor" href="1006.html#p-2950-new-paradigm-path-is-not-an-any-series-1"></a>New Paradigm: PATH! is NOT an ANY-SERIES!</h2>
<p>I did something that swept away a big pile of these concerns.  I took PATH! out of the ANY-SERIES! category and made them immutable.  Since there's a controlled number of points that can make paths, you can set rules for them (e.g. no fewer than two elements, no paths-in-paths).  And since there are no direct modifiers, they can't be changed to disobey this rule.  Since there is no INDEX OF due to it not being an any series, you can never think of it as being anywhere but "at the head".</p>
<p>It's not as limiting as it may sound at first.  You can still PICK elements out of a path by index, or use FOR-EACH on them.  If you ever get to a point where you really want to rearrange and restructure a path, you can convert it to a BLOCK! or GROUP! and then back.  And while making operators that remove items from paths might be a little tricky, aggregating them together is not.</p>
<p>Surprisingly (or perhaps not?), <em>this didn't actually cause that much of a ripple</em>.  Basically nothing was using PATH! as a generic container anyway--because compared to GROUP! and BLOCK!, paths were <em>really bad</em> at being generic containers.  They're never all that long, because they ignore newline handling (embedded blocks/groups can have newlines, but at the level of the slashes in the path itself, there are no newlines).</p>
<p>It's been great so far, and I think there's no going back.</p>
<h2><a name="p-2950-how-many-constraints-should-there-be-2" class="anchor" href="1006.html#p-2950-how-many-constraints-should-there-be-2"></a>How Many Constraints Should There Be?</h2>
<p>I mentioned length of at least 2, and no paths-in-paths.  Those are pretty obvious.</p>
<p>But what else?  We can stop <strong>::a/b</strong> from ever existing.  But historically, the following has been idiomatic and accepted as a common and correct syntax:</p>
<pre><code> a/:b: c
</code></pre>
<p>I've wondered if <strong>a/(b): c</strong> is superior to the point that the path creation rules prohibit embedded get-words.  If you couldn't put any GET-SET-LIT inside path elements, it could stop ambiguities.</p>
<p>Furthermore, some types (like FILE! or URL!) have slashes in them.  Should inserting them into paths be an error, or at least use those slashes to point out where path segments are and split along them?</p>
<h2><a name="p-2950-why-this-is-in-philosophy-the-role-of-paths-in-dialects-3" class="anchor" href="1006.html#p-2950-why-this-is-in-philosophy-the-role-of-paths-in-dialects-3"></a>Why this is in "Philosophy": The Role of PATH!s in Dialects</h2>
<p>One thing that got me to think about this is that I've got a dialect which lets you define BLOCK! rules or PATH! rules:</p>
<pre><code> e: 'j/k/l
 h: [m n/o p]
 dialect [a/b/c [d e f] g/h/i]
</code></pre>
<p>Pathing means "AND these things together".  Blocks mean "OR these things together".  And like PARSE rules, if you look up a word and get to a BLOCK! or PATH! that's just recursed on and used as if you'd written the rule right there.</p>
<p>Some of the elemental rules were GET-WORD!.  If GET-WORD! weren't legal in paths, that would put a constraint on this dialect regarding its elements that the block wouldn't impose.</p>
<p>But...you can work around this with a block.</p>
<pre><code> dialect [[:a]/b/c [d :e f] g/h/[:i]]
</code></pre>
<p>That feels very...clean.  Now you have a generic solution where you're using PATH!s as a dialect component that doesn't lose any capability BLOCK! or GROUP! had, without worrying about tapdancing around gibberish paths.</p>
<p>And we actually are entering an era of what are called <a href="../mirrored-type-bytes-explained/1008.html">"mirrored types"</a>, which would allow 1-element blocks and 1-element groups that are immutable to <em>fit entirely in a cell</em> with no dynamic allocation or pointer to elsewhere.</p>
<p>Mirrored types were invented so <strong>/foo</strong> could be a PATH! and cost no more than the old word-class REFINEMENT! did.  But seeing them in action, it suggests applying it for GROUP!s and BLOCK!s too.  Those embedded blocks could cost no more than a plain GET-WORD! today.  With PATH! being immutable, making those blocks and groups immutable makes sense too.  (By default on scanning I mean... if you make a path with a length-1 immutable block <em>under</em> the path level, it can preserve that mutability.)</p>
<p>When you put all these concepts together, it feels like it ties up loose ends and ambiguities. Will people miss <strong><code>a/:b:</code></strong>...or can the likes of <strong><code>a/(b):</code></strong> and <strong><code>a/[b]:</code></strong> or <strong><code>:(a)/b</code></strong> and <strong><code>:[a]/b</code></strong> cover pretty much everything?</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

                <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../you-can-has-get-block-set-block-get-group-set-group/1032/3.html">You can has GET-BLOCK! (SET-BLOCK!, GET-GROUP!, SET-GROUP!)</a>
                        <meta itemprop='position' content='2'>
                      </div>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../skepticism-of-parse-preserving-precise-input-type/1084.html">Skepticism of PARSE preserving *precise* input type</a>
                        <meta itemprop='position' content='3'>
                      </div>
                </div>
          </div>
          <div id='post_2' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2019-01-11T05:52:23Z' class='post-time'>
                    January 11, 2019,  5:52am
                  </time>
                  <meta itemprop='dateModified' content='2019-01-11T08:07:47Z'>
              <span itemprop='position'>2</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1006">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>When you put all these concepts together, it feels like it ties up loose ends and ambiguities. Will people miss <strong><code>a/:b:</code></strong> ‚Ä¶or can the likes of <strong><code>a/(b):</code></strong> and <strong><code>a/[b]:</code></strong> or <strong><code>:(a)/b</code></strong> and <strong><code>:[a]/b</code></strong> cover pretty much everything?</p>
</blockquote>
</aside>
<p>The only thing I can think of that would make me be upset about losing <strong>a/:b</strong> and having to use <strong>a/(b)</strong>, is having that get involved in COMPOSE/DEEP when I didn't mean it to.</p>
<pre><code> compose/deep [
      .../(don't want composed): [(want composed) ...]
 ]
</code></pre>
<p>But we have better solutions to this today.</p>
<pre><code> compose/deep &lt;*&gt; [
      .../(don't want composed): [(&lt;*&gt; want composed) ...]
 ]
</code></pre>
<p>...and a shallow compose won't see groups in paths.  I think that is enough for me.</p>
<p>The other issue is that right now GET refuses to fetch paths if they contain any GROUP!s.  We could update this rule to make it refuse to fetch paths if they contain anything that runs any ACTION!s, so any inert groups would be fair game.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
          <div id='post_3' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='../../u/IngoHohmann.html'><span itemprop='name'>IngoHohmann</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2019-01-18T17:54:52Z' class='post-time'>
                    January 18, 2019,  5:54pm
                  </time>
                  <meta itemprop='dateModified' content='2019-01-18T17:54:52Z'>
              <span itemprop='position'>3</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>What is the problem you see with get-words in paths, and set-words at the end ?</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
          <div id='post_4' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2019-01-18T19:20:59Z' class='post-time'>
                    January 18, 2019,  7:20pm
                  </time>
                  <meta itemprop='dateModified' content='2019-01-18T19:35:25Z'>
              <span itemprop='position'>4</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="IngoHohmann" data-post="3" data-topic="1006" data-full="true">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/ingohohmann/48/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>What is the problem you see with get-words in paths, and set-words at the end ?</p>
</blockquote>
</aside>
<p>Ambiguity.  If GET-WORD!s can be put in paths, then you can't tell if <strong>:a/b/c</strong> is an ordinary PATH! with a GET-WORD! at the beginning, or a GET-PATH! with an ordinary WORD! at the beginning.</p>
<p>Same for <strong>a/b/c:</strong>... is that an ordinary PATH! with a SET-WORD! at the end, or a SET-PATH! with an ordinary WORD! at the end?</p>
<p>Every now and again it has been wondered if this suggests that there shouldn't be a SET-PATH! and GET-PATH!, but that those should simply be ordinary PATH!s with SET-WORD!s at the tail and GET-WORD!s at the head.  This breaks down when you want <strong>a/b/(c + d):</strong> because you'd need a SET-GROUP!, or <strong>a/b/1:</strong> because you'd need a SET-INTEGER!, etc. for all types.  It also breaks down because it inhibits the cheap/easy transformation of these path types into each other by flipping one byte without affecting the shared path array itself.</p>
<p>States that don't seem ambiguous, like <strong>::a/b/c</strong> are still quite ugly...and actually can still be ambiguous.  e.g. is that a three-element GET-PATH! with a GET-WORD! <strong>:a</strong> at the head, or a two-element GET-PATH! with a GET-PATH! <strong>:a/b</strong> at the head.  I also think things like <strong>a/b/:c:</strong> are awful-looking, and don't have good bones for the language.</p>
<p>But the good news of all of this is that I think I have an answer for all of this with immutable paths, that are checked for properties at time of creation, to address all these issues...and I may be able to do it quite efficiently.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="1" />
              <span class='post-likes'>1 Like</span>
            </div>

          </div>
          <div id='post_5' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2019-03-12T19:27:38Z' class='post-time'>
                    March 12, 2019,  7:27pm
                  </time>
                  <meta itemprop='dateModified' content='2019-03-12T19:27:38Z'>
              <span itemprop='position'>5</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>This is pretty parallel to a problem in URL!.</p>
<p>We have the problem of:</p>
<pre><code>&gt;&gt; reverse http://hostilefork.com
== moc.krofelitsoh//:ptth
</code></pre>
<p>What you end up with still claims to be a URL!, but wouldn't load back as one.  In fact, it would be loaded under today's conventions as a PATH!, since <code>//</code> denotes a BLANK! path segment.  :-/</p>
<p>Historically the idea was that it's just a matter of noticing when something isn't rendering as a "natural" of its type, and falling back on some alternate notation.  Whatever it would be, we'd hope it wouldn't be any uglier than:</p>
<pre><code> #[url! "moc.krofelitsoh//:ptth"]
</code></pre>
<p>But as with PATH!, we can question just how useful is it to allow freaks of nature to exist vs. making them immutable and not allowing them.  If you could turn URL!s into TEXT! easily enough, and turn them back, isn't that good enough?</p>
<p>Pieces of URL! being URL! is not that interesting.  Consider being rid of the <a href="../skepticism-of-parse-preserving-precise-input-type/1084.html">PARSE behavior of matching datatypes for COPY</a>:</p>
<pre><code> url: http://example.com/foo
 parse url ["http://example.com/" copy stuff: to end]
</code></pre>
<p>That will now again give you STUFF as the neutral string "foo" like in Rebol2.  It's not a URL! of simply "foo" (and hence really should show as <code>#[url! "foo"]</code>).  That seems more desirable.</p>
<p>Is pretty much any kind of surgery on URL!s necessary?  How often could one's needs not just be taken care of with JOIN-ing them...as being tried for PATH!, and convert otherwise?</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
          <div id='post_6' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='../../u/IngoHohmann.html'><span itemprop='name'>IngoHohmann</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2019-03-13T06:15:17Z' class='post-time'>
                    March 13, 2019,  6:15am
                  </time>
                  <meta itemprop='dateModified' content='2019-03-13T06:15:17Z'>
              <span itemprop='position'>6</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>In my own url! handling I only needed joining so far.<br>
I think I used deeper surgery for helping with url-encoding issues.<br>
Today, how about doing url-encoding on strings, and nothing on quoted strings?</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
          <div id='post_7' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2019-03-13T10:32:45Z' class='post-time'>
                    March 13, 2019, 10:32am
                  </time>
                  <meta itemprop='dateModified' content='2019-03-13T10:32:45Z'>
              <span itemprop='position'>7</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="IngoHohmann" data-post="6" data-topic="1006">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/ingohohmann/48/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>In my own url! handling I only needed joining so far.<br>
I think I used deeper surgery for helping with url-encoding issues.</p>
</blockquote>
</aside>
<p>Good data point, thanks!</p>
<aside class="quote no-group" data-username="IngoHohmann" data-post="6" data-topic="1006">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/ingohohmann/48/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>Today, how about doing url-encoding on strings, and nothing on quoted strings?</p>
</blockquote>
</aside>
<p>If you mean URL-encoding on URL!, the behavior of retaining "as-is" behavior was a request from <a class="mention" href="../../u/rgchris.html">@rgchris</a>.<br>
Here is the rationale I summarized in the comments:</p>
<pre><code>// While Rebol2, R3-Alpha, and Red attempted to apply some amount of decoding
// (e.g. how %20 is "space" in http:// URL!s), Ren-C leaves URLs "as-is".
// This means a URL may be copied from a web browser bar and pasted back.
// It also means that the URL may be used with custom schemes (odbc://...)
// that have different ideas of the meaning of characters like `%`.
//
// !!! The current concept is that URL!s typically represent the *decoded*
// forms, and thus express unicode codepoints normally...preserving either of:
//
//     https://duckduckgo.com/?q=herg√©+&amp;+tintin
//     https://duckduckgo.com/?q=herg√©+%26+tintin
//
// Then, the encoded forms with UTF-8 bytes expressed in %XX form would be
// converted as TEXT!, where their datatype suggests the encodedness:
//
//     {https://duckduckgo.com/?q=herg%C3%A9+%26+tintin}
//
// (This is similar to how local FILE!s, where e.g. slashes become backslash
// on Windows, are expressed as TEXT!.)
</code></pre>
<p>Offhand, I feel like it sounds more likely to me that URL! is most convenient when people can round-trip the rather lenient expressions being put in their browser, as-is.  Attempts we do at LOAD-time to canonize as part of the data type itself may frustrate, and do more harm than good.</p>
<p>I'm not in-the-know enough to know about the legality of schemes or fragments/pieces of URL!s where % does not mean URL-encoding.  Obviously a Rebol scheme <em>could</em> do this, but I don't know if any official legal URL ever can.  If not, it's probably inadvisable to permit Rebol schemes to.</p>
<p>I do understand this is an important issue, but it would help to see complete scenarios that are pain points and a list of all the tradeoffs.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
          <div id='post_8' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='../../u/IngoHohmann.html'><span itemprop='name'>IngoHohmann</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2019-03-13T14:20:46Z' class='post-time'>
                    March 13, 2019,  2:20pm
                  </time>
                  <meta itemprop='dateModified' content='2019-03-13T14:20:46Z'>
              <span itemprop='position'>8</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="7" data-topic="1006">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>If you mean URL-encoding on URL!, the behavior of retaining ‚Äúas-is‚Äù</p>
</blockquote>
</aside>
<p>I actually meant when a text! is joined to a url!, or otherwise converted to one, and maybe vice versa.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
          <div id='post_9' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2019-03-13T14:43:15Z' class='post-time'>
                    March 13, 2019,  2:43pm
                  </time>
                  <meta itemprop='dateModified' content='2019-03-13T14:43:15Z'>
              <span itemprop='position'>9</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="IngoHohmann" data-post="8" data-topic="1006">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/ingohohmann/48/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>I actually meant when a text! is joined to a url!, or otherwise converted to one, and maybe vice versa.</p>
</blockquote>
</aside>
<p>I had a thought in this vein, when considering TO in terms of the "stable state round-trip" philosophy.  I've thought that might be interesting if TO TEXT! was all it took for a URL to get encoded, and TO URL! took it back to readable again.  If such TO conversions were being run automatically, then maybe it would be sensible for operations like JOIN to be similar when working with combinations.</p>
<p>What made me hesitant to pursue is that if we went this route with FILE!, it would result in inconsistent behavior on Windows vs. Linux.  You'd have to make sure every TEXT! plus FILE! operation had the backslashes going the right way in the TEXT!.</p>
<pre><code>linux&gt;&gt; join "abc" %d/e/f
== "abcd/e/f"

windows&gt;&gt; join "abc" %d/e/f
== "abcd\e\f"
</code></pre>
<p>It may be that URL encoding is a different beast.  But I think there's a pretty high bar for "magic" in a system--if there's going to be any, it better be <em>really good magic</em> with a <em>clearly amazing payoff</em>.  Otherwise it's just more complexity, which is a net negative--even if you tinker around and find it has a slight advantage overall.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="1" />
              <span class='post-likes'>1 Like</span>
            </div>

          </div>
          <div id='post_10' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2019-06-19T19:01:38Z' class='post-time'>
                    June 19, 2019,  7:01pm
                  </time>
                  <meta itemprop='dateModified' content='2019-06-20T18:47:52Z'>
              <span itemprop='position'>10</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1006">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I did something that swept away a big pile of these concerns. I took PATH! out of the ANY-SERIES! category and made them immutable. Since there's a controlled number of points that can make paths, you can set rules for them (e.g. no fewer than two elements, no paths-in-paths). And since there are no direct modifiers, they can't be changed to disobey this rule. Since there is no INDEX OF due to it not being an any series, you can never think of it as being anywhere but "at the head".</p>
</blockquote>
</aside>
<p>I think immutable paths make sense, and disallowing single-element paths or paths with anything but WORD!, TEXT!, INTEGER!, DECIMAL!, BLOCK!, GROUP!, and BLANK! may make sense.  (TAG! or other types perhaps, also, but the key is just to stop ambiguous constructions at the moment of creation.)</p>
<p>But taking ANY-PATH! out of ANY-SERIES! may be unnecessary.</p>
<p>The way it could make sense could be if we follow the concept that arrays with iteration positions other than the head are rendered is to include the index.  e.g.:</p>
<pre><code> &gt;&gt; p: 'foo/baz/bar
 == foo/baz/bar

 &gt;&gt; next p
 == 2|foo/baz/bar
</code></pre>
<p>Not saying this notation is ideal, but the concept is that any non-head series shows its index value and the full data.  So no matter how big your data, offsetting it by an index doesn't hide it in molding.  If you have the need to truncate a series, you either have it mutable or COPY the data out.</p>
<p>The console could truncate to show you the most likely relevant portion, e.g. from the index position on.  This would be similar to how it truncates the output of very long molds at the tail...it's just truncating long molds at the head.</p>
<p>This ties in with the very important <a href="../where-the-series-ends-simplifying-out-of-bounds-rules/1141.html">"Where the Series Ends"</a> post.  That discusses the hidden index semantics, proposing there being no difference between that and a separately tracked INTEGER!...so it is purely an efficiency trick.  Looked at this way helps answer a lot of questions about why that field is there, and prevents having two separate branches of semantics...one for when you use the index internal to the series, and one for when you are operating relative to some external index.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
          <div id='post_11' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/rgchris'><span itemprop='name'>rgchris</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2022-08-15T13:06:59Z' class='post-time'>
                    August 15, 2022,  1:06pm
                  </time>
                  <meta itemprop='dateModified' content='2022-08-15T13:06:59Z'>
              <span itemprop='position'>11</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>I get that this may be mainly an R3C consideration as there's assumptions that Ren-C has moved past:</p>
<ul>
<li>
<p>I don't think I'm too fussed about mutability or removal of ANY-SERIES designation so long as you can round-trip from blocks to construct/deconstruct</p>
</li>
<li>
<p>Given immutability, perhaps PATH!, GET-PATH!, and LIT-PATH! status can be gleaned from the first value in the path. In this way, e.g. a GET-PATH! is a path that starts with a GET-WORD! or GET-GROUP!, never a WORD!. In this way, there is no lexical ambiguity (no <code>::a/b</code> or <code>':a/b</code> or <code>a/b::</code>). SET-PATH! would end with a SET-WORD!/SET-GROUP! so long as the first value is a WORD! or GROUP!</p>
<pre><code>to get-path! 'a/b
; LIT-PATH! ['a b]
; evaluated to PATH! [a b]
; transformed to GET-PATH! [:a b]
</code></pre>
<p>I think it'd be possible to come up with a reasonably finite set of rules that would keep things somewhat sane. Immutability means you couldn't change the first value of a GET-PATH! to a WORD! any way other than to construct a new path so the integrity of rules would be maintained.</p>
</li>
<li>
<p>Any file or URL value in a path must be the last value (assuming the conservative convention of using <code>/</code> as a path delimiter)</p>
</li>
</ul>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="1" />
              <span class='post-likes'>1 Like</span>
            </div>

          </div>
          <div id='post_12' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2022-08-15T13:38:16Z' class='post-time'>
                    August 15, 2022,  1:38pm
                  </time>
                  <meta itemprop='dateModified' content='2022-08-15T14:15:59Z'>
              <span itemprop='position'>12</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="rgchris" data-post="11" data-topic="1006">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I don't think I'm too fussed about mutability or removal of ANY-SERIES designation so long as you can round-trip from blocks to construct/deconstruct</p>
</blockquote>
</aside>
<p>Yes, you can round trip...also COMPOSE in particular is useful:</p>
<pre><code>&gt;&gt; compose '(spread [a b])/([a b])/c
== a/b/[a b]/c

&gt;&gt; compose '(if true [&lt;a&gt;])/b
== &lt;a&gt;/b

&gt;&gt; compose '(if true [_])/b
== /b

&gt;&gt; compose '(if false [&lt;a&gt;])/b
== b
</code></pre>
<p>The mechanics of JOIN are still being frittered over...I mention <a href="https://rebol.metaeducation.com/t/its-time-to-join-together/1030/3">some of the problems in this thread</a>.</p>
<aside class="quote no-group" data-username="rgchris" data-post="11" data-topic="1006">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>Given immutability, perhaps PATH!, GET-PATH!, and LIT-PATH! status can be gleaned from the first value in the path. In this way, e.g. a GET-PATH! is a path that starts with a GET-WORD! or GET-GROUP!, never a WORD!</p>
</blockquote>
</aside>
<p>Read-onlyness solves one problem with putting such parts in the path, but there are others I mention:</p>
<ul>
<li>
<p>It demands more forms that we don't necessarily want, e.g. <strong><code>block.1:</code></strong> (or <strong><code>block/1:</code></strong>) would require a SET-INTEGER!.</p>
</li>
<li>
<p>It inhibits easy transformation via the type byte, e.g. to simply change a GET-PATH! to a SET-PATH! and share the underlying series.  So consider an underlying array like <code>[a (b) 1]</code> ... this can be shared between GET-PATH! SET-PATH! PATH! and quoted path instances.  Otherwise you have to keep making copies and transforming them.</p>
</li>
</ul>
<p>Cheap quoting and unquoting via the quote byte on the path as a whole is also a generalized mechanism that works quite well.</p>
<aside class="quote no-group" data-username="rgchris" data-post="11" data-topic="1006">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>Any file or URL value in a path must be the last value (assuming the conservative convention of using <code>/</code> as a path delimiter)</p>
</blockquote>
</aside>
<p>I'd imagine such exceptions would probably cause more confusion than anything (consider the logic you'd have to put in things like COMPOSE and JOIN to make sure it wasn't appending to a path that was formerly valid, that would be becoming invalid by adding to it).</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="1" />
              <span class='post-likes'>1 Like</span>
            </div>

          </div>
          <div id='post_13' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/rgchris'><span itemprop='name'>rgchris</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2022-08-15T15:17:50Z' class='post-time'>
                    August 15, 2022,  3:17pm
                  </time>
                  <meta itemprop='dateModified' content='2022-08-15T15:17:50Z'>
              <span itemprop='position'>13</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="hostilefork" data-post="12" data-topic="1006">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It demands more forms that we don't necessarily want, e.g. <strong><code>block.1:</code></strong> (or <strong><code>block/1:</code></strong>) would require a SET-INTEGER!.</p>
</blockquote>
</aside>
<p>Sticky wicket, for sure.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="12" data-topic="1006">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>consider the logic you'd have to put in things like COMPOSE and JOIN to make sure it wasn't appending to a path that was formerly valid, that would be becoming invalid by adding to it</p>
</blockquote>
</aside>
<p>Why would the burden be on individual functions. If they created a new series (because they wouldn't be modifying the old one), wouldn't the effort be shut down consistently by the path creation process?</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
          <div id='post_14' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2022-08-15T15:24:55Z' class='post-time'>
                    August 15, 2022,  3:24pm
                  </time>
                  <meta itemprop='dateModified' content='2022-08-15T15:24:55Z'>
              <span itemprop='position'>14</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="rgchris" data-post="13" data-topic="1006">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>If they created a new series (because they wouldn't be modifying the old one), wouldn't the effort be shut down consistently by the path creation process?</p>
</blockquote>
</aside>
<p>I guess if you truly round trip to a block and then to a path...it would...which would apply to <em>usermode</em> code.</p>
<p>But native code that does the building could previously assume that if a well-formed path fragment exists, it could reuse it without checks...and only check itemwise on new material.  It would complicate those code paths.  I'd rather avoid it unless there's a clear argument for why the irregularity was needed.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="1" />
              <span class='post-likes'>1 Like</span>
            </div>

          </div>
          <div id='post_15' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/rgchris'><span itemprop='name'>rgchris</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2022-08-15T15:36:38Z' class='post-time'>
                    August 15, 2022,  3:36pm
                  </time>
                  <meta itemprop='dateModified' content='2022-08-15T15:36:38Z'>
              <span itemprop='position'>15</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="hostilefork" data-post="14" data-topic="1006">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But native code that does the building could previously assume that if a well-formed path fragment exists, it could reuse it without checks...and only check itemwise on new material. It would complicate those code paths.</p>
</blockquote>
</aside>
<p>Understood. To understand the cost: for those functions would be a check to see <code>if path-op ... if new-path-good ...</code>, for path creation it'd be <code>if valid-series? ... else bomb</code>. Though <code>valid-series?</code> itself would only be really costly if the paths became overly long themselves, right?</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
          <div id='post_16' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2022-08-15T15:57:00Z' class='post-time'>
                    August 15, 2022,  3:57pm
                  </time>
                  <meta itemprop='dateModified' content='2022-08-15T16:01:55Z'>
              <span itemprop='position'>16</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="rgchris" data-post="15" data-topic="1006">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/rgchris/48/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>To understand the cost:</p>
</blockquote>
</aside>
<p>Things aren't very optimized at this moment.  So everything that makes a new path (as opposed to switching between GET/SET variations) is running through a unified validation...as if you made it from scratch.  I think.  This is just a matter of trying to get things working, and optimize later.</p>
<p>So I'm speaking sort of more about "the principle of the thing".  Right now there are two (or, two and a half?) rules:</p>
<ul>
<li>at least 2 items</li>
<li>every item is from the list of valid items
<ul>
<li>PATH!'s list of valid items has one more thing in it than TUPLE!'s list... e.g., TUPLE!  is allowed</li>
</ul>
</li>
</ul>
<p><em>(Oh...tuple exception rule.  TUPLE!s of length 2 that are both INTEGER! are illegal.  Although I've suggested this might render as a pair, which would mean PAIR! would just be a type constraint on tuples.  For the moment, 1. and .1 are also disabled...but I'm suggesting those are more useful as tuples than decimals.  If so, then with the 1x2 rendering of a 2-element integer tuple there would be no exceptions in the supported elements.)</em></p>
<p>If there's any weirder rules than that (e.g. a special list for head items or tail items)... that basically would cast doubt on any efforts to optimize the implementation of things like COMPOSE or JOIN to take parts it already had for granted.  So there'd never be optimized processes--the assumption would be that it would have to treat the whole thing as if the path was being created from scratch.</p>
<p>But beyond the optimization, I favor the simplicity of the rules.  It makes paths feel like a reliable/predictable part (vs. a "pathological" one).</p>
<p>If a truly killer feature were shown to be enabled by a more asymmetric rule, then it's by no means impossible to support.  It just introduces a tax on everyone writing logic that operates on paths--to where they can't themselves just check if something is in the ANY-PATH-ITEM! typeset and know in advance if what they're making would be legal.  They only find out by passing their particular configuration through the TO PATH! validation algorithm.  It's a more uneasy foundation.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="1" />
              <span class='post-likes'>1 Like</span>
            </div>

          </div>
    </div>


    




    </div>
    <footer class="container wrap">
  <nav class='crawler-nav'>
    <ul>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='../../index.html' itemprop="url">Home </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='../../categories.html' itemprop="url">Categories </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='../../guidelines.html' itemprop="url">Guidelines </a>
        </span>
      </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='../../tos.html' itemprop="url">Terms of Service </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='../../privacy.html' itemprop="url">Privacy Policy </a>
          </span>
        </li>
    </ul>
  </nav>
  <p class='powered-by-link'>Powered by <a href="https://www.discourse.org">Discourse</a>, best viewed with JavaScript enabled</p>
</footer>

    
    
  </body>
  
</html>

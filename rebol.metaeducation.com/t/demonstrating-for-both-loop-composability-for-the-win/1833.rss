<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Demonstrating FOR-BOTH: Loop Composability For The Win :exclamation:</title>
    <link>https://rebol.metaeducation.com/t/demonstrating-for-both-loop-composability-for-the-win/1833</link>
    <description>FOR-BOTH was an early talking point for an extremely simple usermode loop construct that would be built out of two FOR-EACH loops:

     &gt;&gt; for-both &#39;x [1 2] [3 4] [print [x], x = 5]
     1
     2
     3
     4
     ; first in pack of 1 item
     == \~null~\  ; antiform

A naive implementation of this in Rebol2 might look like:

     for-both-naive: func [var blk1 blk2 body] [
         foreach (var) blk1 body
         foreach (var) blk2 body
     ]

...but...

* **It will not honor BREAK correctly**

      &gt;&gt; for-both-naive &#39;x [1 2] [3 4] [if x = 2 [break], print [x], x = 5]
      1
      3  ; the BREAK only broke the first FOREACH
      4
      == #[none]

    There&#39;s no way from the outside of Rebol2 or Red&#39;s FOREACH to know for sure that a BREAK was requested.  BREAK returns NONE!, but a loop body can (and often does) evaluate to NONE! as well.  Red made it even worse by adding BREAK/RETURN--so a breaking loop can return *anything*.

     So you&#39;d need some kind of complex binding to search the loop bodies and bind the BREAK word to something that throws and gets caught...even for this simple goal.

* **The loop won&#39;t evaluate to the last result of the body**.  

      &gt;&gt; for-both-naive &#39;x [1 2] [] [print [x], x * 10]
      1  ; evaluated to 10
      2  ; evaluated to 20
      == #[none!]

    If the second series is empty, the fallout from the first loop is forgotten.

## Behold Ren-C&#39;s Elegant Solution to FOR-BOTH

*Underneath its apparent simplicity lies quite a lot of deep thought.*  And the mechanisms it uses apply far beyond just loops!

        for-both: func [var blk1 blk2 body] [
            return unlift:lite all [
                lift:lite for-each var blk1 body
                lift:lite for-each var blk2 body
            ]
        ]

### It solves the BREAK case

Below we see a situation where the first FOR-EACH returns NULL (and **lift:lite null** is just **null**).  So it short-circuits the ALL, and propagates the null as a signal that it broke:

    &gt;&gt; for-both &#39;x [1 2] [3 4] [if x = &#39;2 [break], print [x], x = 5]
    1
    == \~null~\  ; antiform

Note that the first pass through the loop did not terminate the ALL, just because the body evaluated to null.  That&#39;s because it produced a &quot;heavy null&quot;, and LIFT:LITE of non-pure-void, non-pure-null antiforms produces QUASIFORM!, which is a branch trigger even if the antiform thing would not be:

     &gt;&gt; lifted: lift ~[~null~]~
     == ~[~null~]~

     &gt;&gt; type of lifted
     == \~{quasiform!}~\  ; ntiform

    &gt;&gt; if lifted [print &quot;All QUASIFORM! are branch triggers!&quot;]
    All QUASIFORM! are branch triggers!

This means the loop can gracefully recover the QUASIFORM! as the ALL result if the loop completes, and remove the quasi level:

    &gt;&gt; for-both &#39;x [1 2] [3 4] [print [x], x = 5]
    1
    2
    3
    4
    ; first in pack of 1 item
    == \~null~\  ; antiform

### It Solves the Fallout From The Last Loop Body

This takes advantage of a new invariant: ***loops which never run their bodies return void***.

    &gt;&gt; for-each x [] [fail &quot;This body never runs&quot;]
    == \~[]~\  ; antiform &quot;void&quot;

Voids act invisibly in constructs like ALL.  So we get the result we want:

    &gt;&gt; for-both &#39;x [1 2] [] [print [x], x * 10]
    1  ; evaluated to 10
    2  ; evaluated to 20
    == 20

There&#39;s a slight fib here, that LIFT:LITE of the void did not produce a &quot;lifted-void&quot;...but passed it through (it would pass through NULL, as well).  That&#39;s a property of the :LITE refinement:

    &gt;&gt; lift:lite when 10 &gt; 20 [&quot;LIFT:LITE passes through the void antiforms&quot;]
    == \~[]~\  ; antiform &quot;void&quot;

    &gt;&gt; lift iwhen10 &gt; 20 [&quot;Without :LITE is more exact, gives the quasiform&quot;]
    == ~[]~

But in situations like this, passing through the void state is what we wanted.

### You Can Even Return NULL From the Body!

Thanks to isotopes, the following is possible:

    &gt;&gt; x: for-both &#39;x [1 2] [] [print [x], if x = 2 [null]]
    1
    2
    ; first in pack of length 1
    == \~null~\  ; antiform

    &gt;&gt; x
    == \~null~\  ; antiform

How cool is that?  Even though NULL is being reserved as the unique signal for loops breaking, there&#39;s a backchannel for it to escape...out of the FOR-EACH, and up out of the FOR-BOTH wrapping it!

## It Holds Up Under Scrutiny!

I&#39;m really pleased with it, and here are some tests:

  https://github.com/metaeducation/ren-c/blob/master/tests/loops/examples/for-both.loops.test.reb

I invite you to test it some more...ask questions...and perhaps come up with your own loop compositions!

:atom_symbol:</description>
    
    <lastBuildDate>Sat, 07 Jun 2025 10:01:02 +0000</lastBuildDate>
    <category>Loops</category>
    <atom:link href="https://rebol.metaeducation.com/t/demonstrating-for-both-loop-composability-for-the-win/1833.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Demonstrating FOR-BOTH: Loop Composability For The Win :exclamation:</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>FOR-BOTH was an early talking point for an extremely simple usermode loop construct that would be built out of two FOR-EACH loops:</p>
<pre><code> &gt;&gt; for-both 'x [1 2] [3 4] [print [x], x = 5]
 1
 2
 3
 4
 ; first in pack of 1 item
 == \~null~\  ; antiform
</code></pre>
<p>A naive implementation of this in Rebol2 might look like:</p>
<pre><code> for-both-naive: func [var blk1 blk2 body] [
     foreach (var) blk1 body
     foreach (var) blk2 body
 ]
</code></pre>
<p>...but...</p>
<ul>
<li>
<p><strong>It will not honor BREAK correctly</strong></p>
<pre><code>&gt;&gt; for-both-naive 'x [1 2] [3 4] [if x = 2 [break], print [x], x = 5]
1
3  ; the BREAK only broke the first FOREACH
4
== #[none]
</code></pre>
<p>There's no way from the outside of Rebol2 or Red's FOREACH to know for sure that a BREAK was requested.  BREAK returns NONE!, but a loop body can (and often does) evaluate to NONE! as well.  Red made it even worse by adding BREAK/RETURN--so a breaking loop can return <em>anything</em>.</p>
<p>So you'd need some kind of complex binding to search the loop bodies and bind the BREAK word to something that throws and gets caught...even for this simple goal.</p>
</li>
<li>
<p><strong>The loop won't evaluate to the last result of the body</strong>.</p>
<pre><code>&gt;&gt; for-both-naive 'x [1 2] [] [print [x], x * 10]
1  ; evaluated to 10
2  ; evaluated to 20
== #[none!]
</code></pre>
<p>If the second series is empty, the fallout from the first loop is forgotten.</p>
</li>
</ul>
<h2><a name="p-5879-behold-ren-cs-elegant-solution-to-for-both-1" class="anchor" href="https://rebol.metaeducation.com#p-5879-behold-ren-cs-elegant-solution-to-for-both-1"></a>Behold Ren-C's Elegant Solution to FOR-BOTH</h2>
<p><em>Underneath its apparent simplicity lies quite a lot of deep thought.</em>  And the mechanisms it uses apply far beyond just loops!</p>
<pre><code>    for-both: func [var blk1 blk2 body] [
        return unlift:lite all [
            lift:lite for-each var blk1 body
            lift:lite for-each var blk2 body
        ]
    ]
</code></pre>
<h3><a name="p-5879-it-solves-the-break-case-2" class="anchor" href="https://rebol.metaeducation.com#p-5879-it-solves-the-break-case-2"></a>It solves the BREAK case</h3>
<p>Below we see a situation where the first FOR-EACH returns NULL (and <strong>lift:lite null</strong> is just <strong>null</strong>).  So it short-circuits the ALL, and propagates the null as a signal that it broke:</p>
<pre><code>&gt;&gt; for-both 'x [1 2] [3 4] [if x = '2 [break], print [x], x = 5]
1
== \~null~\  ; antiform
</code></pre>
<p>Note that the first pass through the loop did not terminate the ALL, just because the body evaluated to null.  That's because it produced a "heavy null", and LIFT:LITE of non-pure-void, non-pure-null antiforms produces QUASIFORM!, which is a branch trigger even if the antiform thing would not be:</p>
<pre><code> &gt;&gt; lifted: lift ~[~null~]~
 == ~[~null~]~

 &gt;&gt; type of lifted
 == \~{quasiform!}~\  ; ntiform

&gt;&gt; if lifted [print "All QUASIFORM! are branch triggers!"]
All QUASIFORM! are branch triggers!
</code></pre>
<p>This means the loop can gracefully recover the QUASIFORM! as the ALL result if the loop completes, and remove the quasi level:</p>
<pre><code>&gt;&gt; for-both 'x [1 2] [3 4] [print [x], x = 5]
1
2
3
4
; first in pack of 1 item
== \~null~\  ; antiform
</code></pre>
<h3><a name="p-5879-it-solves-the-fallout-from-the-last-loop-body-3" class="anchor" href="https://rebol.metaeducation.com#p-5879-it-solves-the-fallout-from-the-last-loop-body-3"></a>It Solves the Fallout From The Last Loop Body</h3>
<p>This takes advantage of a new invariant: <em><strong>loops which never run their bodies return void</strong></em>.</p>
<pre><code>&gt;&gt; for-each x [] [fail "This body never runs"]
== \~[]~\  ; antiform "void"
</code></pre>
<p>Voids act invisibly in constructs like ALL.  So we get the result we want:</p>
<pre><code>&gt;&gt; for-both 'x [1 2] [] [print [x], x * 10]
1  ; evaluated to 10
2  ; evaluated to 20
== 20
</code></pre>
<p>There's a slight fib here, that LIFT:LITE of the void did not produce a "lifted-void"...but passed it through (it would pass through NULL, as well).  That's a property of the :LITE refinement:</p>
<pre><code>&gt;&gt; lift:lite when 10 &gt; 20 ["LIFT:LITE passes through the void antiforms"]
== \~[]~\  ; antiform "void"

&gt;&gt; lift iwhen10 &gt; 20 ["Without :LITE is more exact, gives the quasiform"]
== ~[]~
</code></pre>
<p>But in situations like this, passing through the void state is what we wanted.</p>
<h3><a name="p-5879-you-can-even-return-null-from-the-body-4" class="anchor" href="https://rebol.metaeducation.com#p-5879-you-can-even-return-null-from-the-body-4"></a>You Can Even Return NULL From the Body!</h3>
<p>Thanks to isotopes, the following is possible:</p>
<pre><code>&gt;&gt; x: for-both 'x [1 2] [] [print [x], if x = 2 [null]]
1
2
; first in pack of length 1
== \~null~\  ; antiform

&gt;&gt; x
== \~null~\  ; antiform
</code></pre>
<p>How cool is that?  Even though NULL is being reserved as the unique signal for loops breaking, there's a backchannel for it to escape...out of the FOR-EACH, and up out of the FOR-BOTH wrapping it!</p>
<h2><a name="p-5879-it-holds-up-under-scrutiny-5" class="anchor" href="https://rebol.metaeducation.com#p-5879-it-holds-up-under-scrutiny-5"></a>It Holds Up Under Scrutiny!</h2>
<p>I'm really pleased with it, and here are some tests:</p>
<p><a href="https://github.com/metaeducation/ren-c/blob/master/tests/loops/examples/for-both.loops.test.reb" class="inline-onebox">ren-c/tests/loops/examples/for-both.loops.test.reb at master · metaeducation/ren-c · GitHub</a></p>
<p>I invite you to test it some more...ask questions...and perhaps come up with your own loop compositions!</p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/atom_symbol.png?v=14" title=":atom_symbol:" class="emoji only-emoji" alt=":atom_symbol:" loading="lazy" width="20" height="20"></p>
          <p><a href="https://rebol.metaeducation.com/t/demonstrating-for-both-loop-composability-for-the-win/1833/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/demonstrating-for-both-loop-composability-for-the-win/1833/1</link>
        <pubDate>Tue, 31 May 2022 16:02:09 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1833-1</guid>
        <source url="https://rebol.metaeducation.com/t/demonstrating-for-both-loop-composability-for-the-win/1833.rss">Demonstrating FOR-BOTH: Loop Composability For The Win :exclamation:</source>
      </item>
  </channel>
</rss>

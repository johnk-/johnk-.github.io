<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Warts in Dialecting: When Worse Is Better</title>
    <link>https://rebol.metaeducation.com/t/warts-in-dialecting-when-worse-is-better/2371</link>
    <description>I was facing a little bit of a design question with the %types.r table, that I talk about here:

  https://rebol.metaeducation.com/t/which-antiforms-are-in-use/2276/4?u=hostilefork

I&#39;d come up with the idea that using a quasiform in the table was a good semiotic way of suggesting the name of the antiform state of a type.  I was happy with that, but then the question was how was I to distinguish a stable antiform from an unstable one.

Originally it was done with the presence of a `#unstable` ISSUE! in a sort of random spot.  Here you can see SPLICE? is a stable antiform, while RAISED? is unstable, based on the presence or absence of that issue:

    group       &quot;list that evaluates expressions as an isolated group&quot;
    ~splice~    &quot;fragment of multiple values without a surrounding block&quot;
                (node1)
                [any-series? any-plain-value? any-sequencable?]

    error       &quot;error context with id, arguments, and stack origin&quot;
    ~raised~    &quot;trappable error cooperatively returned from a function call&quot;
    #unstable   (node1 node2)
                [any-inert?]

This didn&#39;t sit well with me, and I think what I didn&#39;t like is that it didn&#39;t connect #unstable to the antiform state.  If I were looking at this, I&#39;d wonder &quot;are the nodes unstable?&quot;  Because that&#39;s the line it&#39;s on.

Ren-C has a wide breadth of parts you can use (although this is part of bootstrap, so it doesn&#39;t have all the parts of the modern executable).  And you can pick random ideas.  What if it were quoted, and that meant unstable?

    error       &quot;error context with id, arguments, and stack origin&quot;
    &#39;~raised~   &quot;trappable error cooperatively returned from a function call&quot;
                (node1 node2)
                [any-inert?]

Uh, well.  *Technically* that works.  There&#39;s a lot of things that could *technically* work.  You could say **{~raised~}** or make it look like a meta-tripwire:

    error       &quot;error context with id, arguments, and stack origin&quot;
    ~&lt;raised&gt;~  &quot;trappable error cooperatively returned from a function call&quot;
                (node1 node2)
                [any-inert?]

That looks nice, *but maybe it looks too nice*.  It&#39;s so smooth as to be unnoticeable if you&#39;re scrolling through.

Which is why I ended up choosing something purposefully jarring:

    error       &quot;error context with id, arguments, and stack origin&quot;
    ~raised~:U  &quot;trappable error cooperatively returned from a function call&quot;
                (node1 node2)
                [any-inert?]

You can&#39;t miss it... staring you in the face.  It could also be a PATH! or a TUPLE!

    error       &quot;error context with id, arguments, and stack origin&quot;
    ~raised~/U  &quot;trappable error cooperatively returned from a function call&quot;
                (node1 node2)
                [any-inert?]

    error       &quot;error context with id, arguments, and stack origin&quot;
    ~raised~.U  &quot;trappable error cooperatively returned from a function call&quot;
                (node1 node2)
                [any-inert?]

But I think I like the CHAIN! for some reason.  It&#39;s jarring enough to see it, but the colon is a very &quot;balanced&quot; character.  And you can see clearly that the (U)nstable is &quot;correlated with&quot; or &quot;modifies&quot; the antiform state, which addresses the problem I had with `#unstable`.

It might look better as **`~raised~:*`**, and it might not.  But I think this is sort of an interesting case study, because it&#39;s all playing into that subtlety of how to make something that looks passable yet still triggers that primordial &quot;ick&quot; enough to get you to ask questions.  Then once you familiarize yourself you know what it means, and when the ick goes away you see it as a smart design.

**It&#39;s interesting to me that I feel like I like the CHAIN! version as **`:U`** noticeably more than **`/U`** or **`.U`**, which is a further validation of having that part in the box.**

Also interesting to note here is the reasoning why there are no antiform CHAIN! or PATH! or TUPLE!, because cases like this show it&#39;s more valuable to be able to have quasiforms as elements than to have a quasiform path state.

*(Otherwise, ambiguity... what is **~:foo:~** ?  Is it a quasiform of **:foo:**, or is it a 3-element CHAIN! with quasiform blank in the first and last slots?  I think quasiform `:foo:` is sufficiently useless to favor the definition that gives us things like **`~/home/whatever`** as a legal path...)*</description>
    
    <lastBuildDate>Tue, 18 Mar 2025 02:15:55 +0000</lastBuildDate>
    <category>Dialects/DSLs</category>
    <atom:link href="https://rebol.metaeducation.com/t/warts-in-dialecting-when-worse-is-better/2371.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Warts in Dialecting: When Worse Is Better</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>I was facing a little bit of a design question with the %types.r table, that I talk about here:</p>
<p><a href="https://rebol.metaeducation.com/t/which-antiforms-are-in-use/2276/4" class="inline-onebox">Which Antiforms Are In Use? - #3</a></p>
<p>I'd come up with the idea that using a quasiform in the table was a good semiotic way of suggesting the name of the antiform state of a type.  I was happy with that, but then the question was how was I to distinguish a stable antiform from an unstable one.</p>
<p>Originally it was done with the presence of a <code>#unstable</code> ISSUE! in a sort of random spot.  Here you can see SPLICE? is a stable antiform, while RAISED? is unstable, based on the presence or absence of that issue:</p>
<pre><code>group       "list that evaluates expressions as an isolated group"
~splice~    "fragment of multiple values without a surrounding block"
            (node1)
            [any-series? any-plain-value? any-sequencable?]

error       "error context with id, arguments, and stack origin"
~raised~    "trappable error cooperatively returned from a function call"
#unstable   (node1 node2)
            [any-inert?]
</code></pre>
<p>This didn't sit well with me, and I think what I didn't like is that it didn't connect <span class="hashtag-raw">#unstable</span> to the antiform state.  If I were looking at this, I'd wonder "are the nodes unstable?"  Because that's the line it's on.</p>
<p>Ren-C has a wide breadth of parts you can use (although this is part of bootstrap, so it doesn't have all the parts of the modern executable).  And you can pick random ideas.  What if it were quoted, and that meant unstable?</p>
<pre><code>error       "error context with id, arguments, and stack origin"
'~raised~   "trappable error cooperatively returned from a function call"
            (node1 node2)
            [any-inert?]
</code></pre>
<p>Uh, well.  <em>Technically</em> that works.  There's a lot of things that could <em>technically</em> work.  You could say <strong>{~raised~}</strong> or make it look like a meta-tripwire:</p>
<pre><code>error       "error context with id, arguments, and stack origin"
~&lt;raised&gt;~  "trappable error cooperatively returned from a function call"
            (node1 node2)
            [any-inert?]
</code></pre>
<p>That looks nice, <em>but maybe it looks too nice</em>.  It's so smooth as to be unnoticeable if you're scrolling through.</p>
<p>Which is why I ended up choosing something purposefully jarring:</p>
<pre><code>error       "error context with id, arguments, and stack origin"
~raised~:U  "trappable error cooperatively returned from a function call"
            (node1 node2)
            [any-inert?]
</code></pre>
<p>You can't miss it... staring you in the face.  It could also be a PATH! or a TUPLE!</p>
<pre><code>error       "error context with id, arguments, and stack origin"
~raised~/U  "trappable error cooperatively returned from a function call"
            (node1 node2)
            [any-inert?]

error       "error context with id, arguments, and stack origin"
~raised~.U  "trappable error cooperatively returned from a function call"
            (node1 node2)
            [any-inert?]
</code></pre>
<p>But I think I like the CHAIN! for some reason.  It's jarring enough to see it, but the colon is a very "balanced" character.  And you can see clearly that the (U)nstable is "correlated with" or "modifies" the antiform state, which addresses the problem I had with <code>#unstable</code>.</p>
<p>It might look better as <strong><code>~raised~:*</code></strong>, and it might not.  But I think this is sort of an interesting case study, because it's all playing into that subtlety of how to make something that looks passable yet still triggers that primordial "ick" enough to get you to ask questions.  Then once you familiarize yourself you know what it means, and when the ick goes away you see it as a smart design.</p>
<p><strong>It's interesting to me that I feel like I like the CHAIN! version as <strong><code>:U</code></strong> noticeably more than <strong><code>/U</code></strong> or <strong><code>.U</code></strong>, which is a further validation of having that part in the box.</strong></p>
<p>Also interesting to note here is the reasoning why there are no antiform CHAIN! or PATH! or TUPLE!, because cases like this show it's more valuable to be able to have quasiforms as elements than to have a quasiform path state.</p>
<p><em>(Otherwise, ambiguity... what is <strong>~:foo:~</strong> ?  Is it a quasiform of <strong>:foo:</strong>, or is it a 3-element CHAIN! with quasiform blank in the first and last slots?  I think quasiform <code>:foo:</code> is sufficiently useless to favor the definition that gives us things like <strong><code>~/home/whatever</code></strong> as a legal path...)</em></p>
          <p><a href="https://rebol.metaeducation.com/t/warts-in-dialecting-when-worse-is-better/2371/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/warts-in-dialecting-when-worse-is-better/2371/1</link>
        <pubDate>Tue, 18 Mar 2025 01:52:45 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2371-1</guid>
        <source url="https://rebol.metaeducation.com/t/warts-in-dialecting-when-worse-is-better/2371.rss">Warts in Dialecting: When Worse Is Better</source>
      </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Value (vs. Series) Modification Bit: CONST and MUTABLE</title>
    <link>https://rebol.metaeducation.com/t/value-vs-series-modification-bit-const-and-mutable/976</link>
    <description>Every newbie to Rebol (and every experienced user too!) gets bitten by the intrinsic mutability of source series.   A common misunderstanding/mistake might look like:

     blockify: func [x] [
        block: []
        append block x
        return block
     ]

     &gt;&gt; blockify 10
     == [10]

     &gt;&gt; blockify 20
     == [10 20]  ; !!! why didn&#39;t `block: []` reset the block?

Some have deemed it easy enough to learn to say **`block: copy []`**.  But consider the following:

    symbol-name: func [symbol [word!]] [
         switch symbol [
             &#39;+ [&quot;plus&quot;]
             &#39;? [&quot;question-mark&quot;]
             ...
         ]
    ]
    ...
    filename: append (symbol-name &#39;+) &quot;.dat&quot;

This innocent-looking piece of code has a terrible bug.  *The string you return lives in the SWITCH, so the APPEND is actually mutating the string inside the SWITCH.*  Every subsequent call to SYMBOL-NAME will be affected.

I feel like it shouldn&#39;t be controversial to say **it should not be this easy to write self-modifying code on accident.**  Something equivalent to this (but trickier) caused a problem in the build system that took me hours to find.

If Rebol is supposed to be more than a toy, it needs answers for usage problems like this--where it is notably much more brittle than other languages.

## The APPENDs Above Must Fail, But By What Means?

I want those examples to cause errors, vs. silently modify the blocks or strings resident in the bodies of functions.

Yet a lot of off-the-cuff scripting (and test code) relies on the mutability of source, e.g.:

    &gt;&gt; append [a b] &#39;c
    == [a b c]

R3-Alpha had the concept of being able to PROTECT a series so that all references to it would be immutable.  But if we were to make a rule that all source series were permanently locked, that would be a heavy-handed policy that wouldn&#39;t permit alternate styles of coding *ever*.

I concluded that **we needed another--lighter--form of lock**...something that doesn&#39;t make *all* views of a series have to be unchanging for all time, but that different views of a series be read or write.  And constructs could fiddle this bit as they saw appropriate.

## Meet CONST and MUTABLE

Ren-C&#39;s pioneering new feature is of *values* being able to be read only or not.  You can flip the bit yourself with the CONST and MUTABLE functions:

    &gt;&gt; data: [a b c]
    == [a b c]

    &gt;&gt; data-readonly: const data
    == [a b c]

    &gt;&gt; append data-readonly &#39;d
    ** Access Error: value is CONST (see MUTABLE): [a b c]

    &gt;&gt; append data &#39;d
    == [a b c d]

    &gt;&gt; data-readonly
    == [a b c d]

    &gt;&gt; append mutable data-readonly &#39;e
    == [a b c d e]

It&#39;s quite different from locking a series.  For instance: you can keep write access for yourself, while giving out const access to subroutines you don&#39;t want to be doing casual modifications.

But the real win here is that the execution of code defaults to putting a wave of constness on any slots the evaluator fills from &quot;literals&quot;...be those blocks or strings.  You see it catching the bug I introduced at the beginning of the post, of the string being changed inside the switch:

    &gt;&gt; filename: append (symbol-name &#39;+) &quot;.dat&quot;
    ** Access Error: value is CONST (see MUTABLE): &quot;plus&quot;

## The Constructs Are In Control

In this model, the constness is applied by anything that thinks of its argument as being iterative.

So for example, the WHILE loop takes its body (and condition) as a `&lt;const&gt;`-marked parameter.

    input: [a b c]

    output: []  ; want to get [[a] [b] [c]]

    while [item: try take input] [
        block: []
        append block item
        append output block
    ]

You&#39;ll get an error on the APPEND to BLOCK of **`&quot;CONST or iterative value&quot;`**.  

By comparison, EVAL does not take its block argument as a const parameter, so this works without complaining about the appends to data:

    &gt;&gt; eval [data: [], append data &lt;1&gt;, append data &lt;2&gt;]
    == [&lt;1&gt; &lt;2&gt;]

*But* it&#39;s inherited, so a EVAL inside of a WHILE would have the block it received to do as const, due to the WHILE&#39;s influence.

Predicting that functions are likely to be called more than once, FUNC takes its body as CONST...and that constness propagates as the wave of evaluation proceeds through the body.

But notice that as long as the underlying series isn&#39;t immutable (due to things like PROTECT), you can subvert the const bit with MUTABLE:

     accumulate: func [x] [
         accumulator: mutable []
         return append accumulator x
     ]

     &gt;&gt; accumulate 10
     == [10]

     &gt;&gt; accumulate 20
     == [10 20]

Emulating historical Rebol2/R3-Alpha/Red conventions just means tweaking the specs for things like FUNC and WHILE.  Instead of taking their body parameters as **`&lt;const&gt;`**, take them normally.

## Should Modules Be Stricter By Default?

The SWITCH case I opened with shows why I absolutely think that constness-on-func-bodies is the right choice.  That&#39;s in addition to addressing the speedbump every new user has when they write **repeat 10 [block: [] ...]** and expect block to be reinitialized each time through the loop.

But what should the default be for code that&#39;s not in a function or a loop?

Certainly in the console mutability has been the status quo.  If modules enforced constness for their top-level code (despite being run only once) but the console didn&#39;t, would that be a good tradeoff...or just confusing?

I don&#39;t think saying MUTABLE [...] is much of a burden to get deep mutable access to a series when you mean that.  I feel it&#39;s better to teach good habits early on.  But who knows.</description>
    
    <lastBuildDate>Wed, 20 Nov 2024 04:12:48 +0000</lastBuildDate>
    <category>Internals</category>
    <atom:link href="https://rebol.metaeducation.com/t/value-vs-series-modification-bit-const-and-mutable/976.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Value (vs. Series) Modification Bit: CONST and MUTABLE</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>A post was split to a new topic: <a href="https://rebol.metaeducation.com/t/using-c-s-const-keyword-to-power-const/2501">Using C++'s const keyword to Power CONST</a></p>
          <p><a href="https://rebol.metaeducation.com/t/value-vs-series-modification-bit-const-and-mutable/976/5">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/value-vs-series-modification-bit-const-and-mutable/976/5</link>
        <pubDate>Sat, 28 Jun 2025 10:40:18 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-976-5</guid>
        <source url="https://rebol.metaeducation.com/t/value-vs-series-modification-bit-const-and-mutable/976.rss">Value (vs. Series) Modification Bit: CONST and MUTABLE</source>
      </item>
      <item>
        <title>Value (vs. Series) Modification Bit: CONST and MUTABLE</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>The const feature was implemented via CELL_FLAG_CONST, a bit that a cell could have set (or not) in its header.</p>
<p>But there was a second bit... called CELL_FLAG_EXPLICITLY_MUTABLE.</p>
<p>This bit protected a block from the "wave of constness".</p>
<p>It was necessitated by some behaviors that I ultimately deemed to be bugs.  Now that those bugs are gone, it's no longer mandatory to have it.</p>
<p>So I took it out, but found it broke a test:</p>
<pre><code>block: mutable [a b c]
eval compose:deep $() [repeat 2 [append (block) &lt;legal&gt;]]
assert [block = [&lt;legal&gt; &lt;legal&gt;]]
</code></pre>
<p>So previously, that mutable would put the CELL_FLAG_EXPLICITLY_MUTABLE bit on.  Then, when the COMPOSE ran, you'd get:</p>
<pre><code> eval [repeat 2 [append [a b c] &lt;legal&gt;]]
</code></pre>
<p>Because REPEAT is iterative, it applies CONST to its body.  And that CONST would get applied to the <code>[a b c]</code>...but, CELL_FLAG_EXPLICITLY_MUTABLE overruled it.</p>
<h2><a name="p-7916-but-i-dont-like-cell_flag_explicitly_mutable-1" class="anchor" href="https://rebol.metaeducation.com#p-7916-but-i-dont-like-cell_flag_explicitly_mutable-1"></a>But I Don't Like CELL_FLAG_EXPLICITLY_MUTABLE</h2>
<p>There are other ways to get past the const wave, such as quoting it:</p>
<pre><code>block: [a b c]
eval compose:deep $() [repeat 2 [append '(block) &lt;legal&gt;]]
</code></pre>
<p>Or you could do <strong>append mutable</strong>:</p>
<pre><code>block: [a b c]
eval compose:deep $() [repeat 2 [append mutable (block) &lt;legal&gt;]]
</code></pre>
<p>Admittedly, these require you to have some control of the code the block is being fed into, vs. being able to put a "magic bit" on the block to counteract the const wave.</p>
<p>But the semantics of this magic bit are nebulous.  I would not have added such a thing if it wasn't for working around the things I decided were bugs.  It's not clear when (if ever) it should stop protecting the value, and that just opens a can of worms.</p>
<p>Cell flags are a pretty scarce resource, and giving one up for something that makes the code harder to understand than a simple CONST bit that's on or off is not a good investment.</p>
          <p><a href="https://rebol.metaeducation.com/t/value-vs-series-modification-bit-const-and-mutable/976/6">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/value-vs-series-modification-bit-const-and-mutable/976/6</link>
        <pubDate>Wed, 20 Nov 2024 04:12:48 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-976-6</guid>
        <source url="https://rebol.metaeducation.com/t/value-vs-series-modification-bit-const-and-mutable/976.rss">Value (vs. Series) Modification Bit: CONST and MUTABLE</source>
      </item>
      <item>
        <title>Value (vs. Series) Modification Bit: CONST and MUTABLE</title>
        <dc:creator><![CDATA[BlackATTR]]></dc:creator>
        <description><![CDATA[
            <p>I think this gets to the question of robustness of the language. If this helps Rebol get beyond the perception of being unserious for real development work, then I'm in favor as it seems like a worthy tradeoff. It would need to be documented/taught but I think the additional rigor would lead to better programming practices.</p>
          <p><a href="https://rebol.metaeducation.com/t/value-vs-series-modification-bit-const-and-mutable/976/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/value-vs-series-modification-bit-const-and-mutable/976/4</link>
        <pubDate>Wed, 26 Dec 2018 17:16:46 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-976-4</guid>
        <source url="https://rebol.metaeducation.com/t/value-vs-series-modification-bit-const-and-mutable/976.rss">Value (vs. Series) Modification Bit: CONST and MUTABLE</source>
      </item>
      <item>
        <title>Value (vs. Series) Modification Bit: CONST and MUTABLE</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="IngoHohmann" data-post="2" data-topic="976">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/ingohohmann/48/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>"If modules enforced it by default but the console didn’t, would that be a good tradeoff" =&gt; Yes, I think it would be.</p>
</blockquote>
</aside>
<p>There may be more options than just binary ones here, so it's likely best to get some experience.</p>
<p>I really believe that not being consistent between the console and scripts running should be heavily weighed.  The console is kind of the place where you try out things and use as a sanity check when debugging.</p>
<aside class="quote no-group" data-username="IngoHohmann" data-post="2" data-topic="976">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/ingohohmann/48/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>if a function hands out const access to a value, is the the receiver able to change it to a mutable value</p>
</blockquote>
</aside>
<p>Perhaps there could be a difference between explicit const (irrevocable on that value once applied) and an implicit one, the evaluator just put on itself from a frame.  That mechanic may not be too difficult.</p>
<p>But in their current incarnation, const and mutable are "suggestions" and there's no level of privilege escalation.  If you want to lock something so no one can get write access on it, you have to LOCK it.</p>
<p>Locking is still necessary for things like using blocks for keys in MAP!, and something more lock-like is probably the only way to imagine safe multithreading.</p>
          <p><a href="https://rebol.metaeducation.com/t/value-vs-series-modification-bit-const-and-mutable/976/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/value-vs-series-modification-bit-const-and-mutable/976/3</link>
        <pubDate>Tue, 25 Dec 2018 23:59:23 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-976-3</guid>
        <source url="https://rebol.metaeducation.com/t/value-vs-series-modification-bit-const-and-mutable/976.rss">Value (vs. Series) Modification Bit: CONST and MUTABLE</source>
      </item>
      <item>
        <title>Value (vs. Series) Modification Bit: CONST and MUTABLE</title>
        <dc:creator><![CDATA[IngoHohmann]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="976">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>If modules enforced it by default but the console didn’t, would that be a good tradeoff</p>
</blockquote>
</aside>
<p>Yes, I think it would be.</p>
<p>One question, if a function hands out const access to a value, is the the receiver able to change it to a mutable value? Should this be possible?</p>
          <p><a href="https://rebol.metaeducation.com/t/value-vs-series-modification-bit-const-and-mutable/976/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/value-vs-series-modification-bit-const-and-mutable/976/2</link>
        <pubDate>Tue, 25 Dec 2018 23:42:41 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-976-2</guid>
        <source url="https://rebol.metaeducation.com/t/value-vs-series-modification-bit-const-and-mutable/976.rss">Value (vs. Series) Modification Bit: CONST and MUTABLE</source>
      </item>
      <item>
        <title>Value (vs. Series) Modification Bit: CONST and MUTABLE</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Every newbie to Rebol (and every experienced user too!) gets bitten by the intrinsic mutability of source series.   A common misunderstanding/mistake might look like:</p>
<pre><code> blockify: func [x] [
    block: []
    append block x
    return block
 ]

 &gt;&gt; blockify 10
 == [10]

 &gt;&gt; blockify 20
 == [10 20]  ; !!! why didn't `block: []` reset the block?
</code></pre>
<p>Some have deemed it easy enough to learn to say <strong><code>block: copy []</code></strong>.  But consider the following:</p>
<pre><code>symbol-name: func [symbol [word!]] [
     switch symbol [
         '+ ["plus"]
         '? ["question-mark"]
         ...
     ]
]
...
filename: append (symbol-name '+) ".dat"
</code></pre>
<p>This innocent-looking piece of code has a terrible bug.  <em>The string you return lives in the SWITCH, so the APPEND is actually mutating the string inside the SWITCH.</em>  Every subsequent call to SYMBOL-NAME will be affected.</p>
<p>I feel like it shouldn't be controversial to say <strong>it should not be this easy to write self-modifying code on accident.</strong>  Something equivalent to this (but trickier) caused a problem in the build system that took me hours to find.</p>
<p>If Rebol is supposed to be more than a toy, it needs answers for usage problems like this--where it is notably much more brittle than other languages.</p>
<h2><a name="p-2847-the-appends-above-must-fail-but-by-what-means-1" class="anchor" href="https://rebol.metaeducation.com#p-2847-the-appends-above-must-fail-but-by-what-means-1"></a>The APPENDs Above Must Fail, But By What Means?</h2>
<p>I want those examples to cause errors, vs. silently modify the blocks or strings resident in the bodies of functions.</p>
<p>Yet a lot of off-the-cuff scripting (and test code) relies on the mutability of source, e.g.:</p>
<pre><code>&gt;&gt; append [a b] 'c
== [a b c]
</code></pre>
<p>R3-Alpha had the concept of being able to PROTECT a series so that all references to it would be immutable.  But if we were to make a rule that all source series were permanently locked, that would be a heavy-handed policy that wouldn't permit alternate styles of coding <em>ever</em>.</p>
<p>I concluded that <strong>we needed another--lighter--form of lock</strong>...something that doesn't make <em>all</em> views of a series have to be unchanging for all time, but that different views of a series be read or write.  And constructs could fiddle this bit as they saw appropriate.</p>
<h2><a name="p-2847-meet-const-and-mutable-2" class="anchor" href="https://rebol.metaeducation.com#p-2847-meet-const-and-mutable-2"></a>Meet CONST and MUTABLE</h2>
<p>Ren-C's pioneering new feature is of <em>values</em> being able to be read only or not.  You can flip the bit yourself with the CONST and MUTABLE functions:</p>
<pre><code>&gt;&gt; data: [a b c]
== [a b c]

&gt;&gt; data-readonly: const data
== [a b c]

&gt;&gt; append data-readonly 'd
** Access Error: value is CONST (see MUTABLE): [a b c]

&gt;&gt; append data 'd
== [a b c d]

&gt;&gt; data-readonly
== [a b c d]

&gt;&gt; append mutable data-readonly 'e
== [a b c d e]
</code></pre>
<p>It's quite different from locking a series.  For instance: you can keep write access for yourself, while giving out const access to subroutines you don't want to be doing casual modifications.</p>
<p>But the real win here is that the execution of code defaults to putting a wave of constness on any slots the evaluator fills from "literals"...be those blocks or strings.  You see it catching the bug I introduced at the beginning of the post, of the string being changed inside the switch:</p>
<pre><code>&gt;&gt; filename: append (symbol-name '+) ".dat"
** Access Error: value is CONST (see MUTABLE): "plus"
</code></pre>
<h2><a name="p-2847-the-constructs-are-in-control-3" class="anchor" href="https://rebol.metaeducation.com#p-2847-the-constructs-are-in-control-3"></a>The Constructs Are In Control</h2>
<p>In this model, the constness is applied by anything that thinks of its argument as being iterative.</p>
<p>So for example, the WHILE loop takes its body (and condition) as a <code>&lt;const&gt;</code>-marked parameter.</p>
<pre><code>input: [a b c]

output: []  ; want to get [[a] [b] [c]]

while [item: try take input] [
    block: []
    append block item
    append output block
]
</code></pre>
<p>You'll get an error on the APPEND to BLOCK of <strong><code>"CONST or iterative value"</code></strong>.</p>
<p>By comparison, EVAL does not take its block argument as a const parameter, so this works without complaining about the appends to data:</p>
<pre><code>&gt;&gt; eval [data: [], append data &lt;1&gt;, append data &lt;2&gt;]
== [&lt;1&gt; &lt;2&gt;]
</code></pre>
<p><em>But</em> it's inherited, so a EVAL inside of a WHILE would have the block it received to do as const, due to the WHILE's influence.</p>
<p>Predicting that functions are likely to be called more than once, FUNC takes its body as CONST...and that constness propagates as the wave of evaluation proceeds through the body.</p>
<p>But notice that as long as the underlying series isn't immutable (due to things like PROTECT), you can subvert the const bit with MUTABLE:</p>
<pre><code> accumulate: func [x] [
     accumulator: mutable []
     return append accumulator x
 ]

 &gt;&gt; accumulate 10
 == [10]

 &gt;&gt; accumulate 20
 == [10 20]
</code></pre>
<p>Emulating historical Rebol2/R3-Alpha/Red conventions just means tweaking the specs for things like FUNC and WHILE.  Instead of taking their body parameters as <strong><code>&lt;const&gt;</code></strong>, take them normally.</p>
<h2><a name="p-2847-should-modules-be-stricter-by-default-4" class="anchor" href="https://rebol.metaeducation.com#p-2847-should-modules-be-stricter-by-default-4"></a>Should Modules Be Stricter By Default?</h2>
<p>The SWITCH case I opened with shows why I absolutely think that constness-on-func-bodies is the right choice.  That's in addition to addressing the speedbump every new user has when they write <strong>repeat 10 [block: [] ...]</strong> and expect block to be reinitialized each time through the loop.</p>
<p>But what should the default be for code that's not in a function or a loop?</p>
<p>Certainly in the console mutability has been the status quo.  If modules enforced constness for their top-level code (despite being run only once) but the console didn't, would that be a good tradeoff...or just confusing?</p>
<p>I don't think saying MUTABLE [...] is much of a burden to get deep mutable access to a series when you mean that.  I feel it's better to teach good habits early on.  But who knows.</p>
          <p><a href="https://rebol.metaeducation.com/t/value-vs-series-modification-bit-const-and-mutable/976/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/value-vs-series-modification-bit-const-and-mutable/976/1</link>
        <pubDate>Tue, 25 Dec 2018 20:07:35 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-976-1</guid>
        <source url="https://rebol.metaeducation.com/t/value-vs-series-modification-bit-const-and-mutable/976.rss">Value (vs. Series) Modification Bit: CONST and MUTABLE</source>
      </item>
  </channel>
</rss>

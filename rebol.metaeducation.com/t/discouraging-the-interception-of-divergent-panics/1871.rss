<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Discouraging The Interception of Divergent Panics</title>
    <link>https://rebol.metaeducation.com/t/discouraging-the-interception-of-divergent-panics/1871</link>
    <description>With [definitional errors](https://rebol.metaeducation.com/t/fail-vs-return-fail-the-new-age-of-definitional-failures/1852), the landscape changes considerably for how we think about error handling.

**In this world, there are *not a lot of good reasons* to use what I call &quot;RECOVER&quot;.**

By its design, RECOVER will intercept *any* error in code at *any* depth.  This is what Rebol2&#39;s ATTEMPT and TRY did as well, **but this made them not the right tool for hardly any code**:

    rebol2&gt;&gt; attempt [print &quot;Attempting to read file&quot; read %nonexistent-file.txt]
    Attempting to read file
    == none

    rebol2&gt;&gt; attempt [print &quot;Attempting but made typos&quot; rread %nonexistent-file.txt]
    == none

The problem isn&#39;t just about typos.  It&#39;s about the illusion that there&#39;s something you can do to react to a panic coming form a completely arbitrary stack level beneath you...when the constructs you were using didn&#39;t even understand it well enough to pipe it through to their output.

**In almost all cases, an error intercepted by &quot;RECOVER&quot; cannot be reacted to sanely...it has to be reported.  Such use cases should only be things like consoles and test suites.**

It&#39;s for this reason that languages like Rust pretty much enforce a panic when a function call produces an error the caller doesn&#39;t immediately and explicitly handle.

And our case is even more compelling.  For example: How many places is it ever a good idea to sweep a typo under the rug, and just run some other code?

## Might We Make It Look More &quot;Special&quot; To Discourage Use?

I thought at minimum we should move it to a place that shows it&#39;s more of a &quot;system utility&quot; than a &quot;language feature&quot;.

So calling it **`SYS.UTIL/RECOVER`** would be a step in that direction.

Things to think about.  Anyway, I&#39;ve made some progress on definitional errors in the scanner and with TO and MAKE operations, so some of the things people like to intercept (like conversions) should work correctly with attempt now.

For instance, in this finite-integer world... an out of range error:

    &gt;&gt; try to integer! &quot;10483143873258978444434343&quot;
    == \~null~\  ; antiform

    &gt;&gt; try to intgeer! &quot;10483143873258978444434343&quot;
    ** Script Error: intgeer! word is attached to a context, but unassigned

    &gt;&gt; to integer! &quot;10483143873258978444434343&quot; except e -&gt; [print [&quot;Error:&quot; mold e]]
    Error: make warning! [
        type: &#39;Script
        id: &#39;bad-make-arg
        message: [&quot;cannot MAKE/TO&quot; :arg1 &quot;from:&quot; :arg2]
        near: [to integer! &quot;10483143873258978444434343&quot; ** except e -&gt; ***]
        where: [to args]
        file: &#39;
        line: 1
        arg1: #[datatype! integer!]
        arg2: &quot;10483143873258978444434343&quot;
    ]

Should be a more specific error, now that I look at that.  But I guess it just wasn&#39;t.</description>
    
    <lastBuildDate>Thu, 10 Jul 2025 10:15:20 +0000</lastBuildDate>
    <category>Errors</category>
    <atom:link href="https://rebol.metaeducation.com/t/discouraging-the-interception-of-divergent-panics/1871.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Discouraging The Interception of Divergent Panics</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="1871">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">sys.util/recover [
    .. dangerous code
] then warning -&gt; [
   ... "then" implies "if we recovered, then run this code w/error"
] else [  ; was null
   ... it succeeded
]
</code></pre>
</blockquote>
</aside>
<p>I feel like I should mention that there is a trick that could get you the error or the value if there was no error, without using ENRECOVER...</p>
<p>The RECOVER operation could convert an abrupt failure into a definitional one.  Then you could use EXCEPT to handle the error case, while getting your value out the top of the expression in the non-abrupt-failure case:</p>
<pre><code>result: sys.util/recover [
    if condition [panic "This is a divergent panic"]
    10 + 20
] except e -&gt; [
    ; handle the divergent panic
]
</code></pre>
<p>For a construct named RECOVER, it doesn't seem to make sense.</p>
<ul>
<li>
<p><strong><code>recover [...] then x -&gt; [...]</code></strong> naturally implies "this is code I want you to run if you recovered something, pass me the error you caught in a defused way."</p>
</li>
<li>
<p><strong><code>recover...except</code></strong> makes it sound like <em>the recovery</em> didn't succeed.</p>
</li>
</ul>
<p>Considering that you're not really supposed to be using SYS.UTIL/RECOVER hardly ever, it doesn't seem like too much of a burden to just move your assignment inside the body:</p>
<pre><code>sys.util/recover [
    if condition [panic "This is a divergent panic"]
    result: 10 + 20
] then e -&gt; [
    ; handle the divergent panic
]
</code></pre>
<h2><a name="p-7455-but-maybe-it-just-needs-another-name-1" class="anchor" href="https://rebol.metaeducation.com#p-7455-but-maybe-it-just-needs-another-name-1"></a>But Maybe It Just Needs Another Name?</h2>
<p>Multiplexing the intercepted divergent error onto the body result might make more sense if it were called something like SANDBOX:</p>
<pre><code>result: sys.util/sandbox [
    if condition [panic "This is a divergent panic"]
    10 + 20
] except e -&gt; [
    ; handle the divergent panic
]
</code></pre>
<p>Though that sounds like a noun more than a verb.  ISOLATE... though that sounds more like a context thing, for isolating variables.  QUARANTINE, I dunno.</p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>Getting rid of ENRECOVER seems desirable, and the more natural form of multiplexing is to use ERROR! itself with the body return value, not this weird lifting idea.</p>
<p>Another aspect that makes me open to a new name and interface is that RECOVER and RESCUE are two rather similar words that start with R.  This would help eliminate confusion between a construct that picks out definitional errors from sequential steps in an expression vs. one that does the dangerous deed of intercepting divergent errors.</p>
          <p><a href="https://rebol.metaeducation.com/t/discouraging-the-interception-of-divergent-panics/1871/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/discouraging-the-interception-of-divergent-panics/1871/4</link>
        <pubDate>Thu, 29 Aug 2024 13:30:34 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1871-4</guid>
        <source url="https://rebol.metaeducation.com/t/discouraging-the-interception-of-divergent-panics/1871.rss">Discouraging The Interception of Divergent Panics</source>
      </item>
      <item>
        <title>Discouraging The Interception of Divergent Panics</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Recent experiences has only confirmed what I already know: <strong>intercepting arbitrary errors--of the non-definitional sort--is ALMOST NEVER a good idea.</strong>  Definitional errors are pretty much the only kind you can react to.</p>
<p>Modern RESCUE has a nice interface for use with definitional errors, when you don't want to use the infix EXCEPT.</p>
<p>Its interface is reversed from Rebol2 ATTEMPT--instead of returning NULL on failure, it returns NULL on success... and on failure returns the disarmed error.  There's a secondary multi-return for the return product if you want it.</p>
<p>Internally to the system in API calls, unpacking multi-returns from a C API call is tricky.  So I usually use something I've called ENRESCUE.  This gives back a lifted return result overlaid with an WARNING! (non-antiform error).  So you get:</p>
<ul>
<li>
<p>a plain WARNING! on failure</p>
</li>
<li>
<p>A QUASI! item like ~null~ if the  result was an antiform</p>
</li>
<li>
<p>A QUOTED! if it was a normal evaluation</p>
</li>
</ul>
<p>It's easy enough to test for errors.</p>
<pre><code>result: enrescue [
    ...your code being trapped goes here...
]

if warning? result [
    ...code responding to the result (was an ERROR!)...
] else [
    ...process result (it's LIFT-ed)
]
</code></pre>
<p>You can't use it sensibly with THEN and ELSE (it would always run THEN).  Since it's a special construct we could pick a state to return NULL for... e.g. instead of quoted null, which might be convenient... but probably only if we were permissive and said UNLIFT would turn NULL into NULL.  :-/  Probably not a good idea.</p>
<h2><a name="p-6313-recover-sysutilrecover-1" class="anchor" href="https://rebol.metaeducation.com#p-6313-recover-sysutilrecover-1"></a>RECOVER =&gt; SYS.UTIL.RECOVER</h2>
<p>I did the change so that the function for intercepting abrupt failures is poked into SYS.UTIL to make it clearer that you shouldn't be using it casually.</p>
<pre><code>sys.util/recover [
    .. dangerous code
] then warning -&gt; [
   ... "then" implies "if we recovered, then run this code w/error"
] else [  ; was null
   ... it succeeded
]
</code></pre>
<p>That seems all right.  But I made an ENRECOVER as well, that lets you get the evaluation product LIFT-ed on success, and the plain warning on failure.</p>
<p>Perhaps the lifting behavior on these functions should just be controlled by a refinement?</p>
<pre><code>&gt;&gt; rescue [1 / 0]
== &amp;[warning! [...]]

&gt;&gt; rescue [1 + 2]
== \~null~\  ; antiform

&gt;&gt; rescue:lift [1 / 0]
== &amp;[warning! [...]]

&gt;&gt; rescue:lift [1 + 2]
== '3 
</code></pre>
<p>Then the same refinement could be used with RECOVER.</p>
<p>The warning won't be LIFT-ed either way, so calling the refinement LIFT is a little confusing...but maybe not confusing enough to outweigh the benefit of reminding you that the result is LIFT-ed in there.</p>
          <p><a href="https://rebol.metaeducation.com/t/discouraging-the-interception-of-divergent-panics/1871/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/discouraging-the-interception-of-divergent-panics/1871/3</link>
        <pubDate>Thu, 25 Aug 2022 05:38:32 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1871-3</guid>
        <source url="https://rebol.metaeducation.com/t/discouraging-the-interception-of-divergent-panics/1871.rss">Discouraging The Interception of Divergent Panics</source>
      </item>
      <item>
        <title>Discouraging The Interception of Divergent Panics</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Speaking of discouragement of using RECOVER-like-things... (!)</p>
<p>I'm doing some triage of various "unimportant" things that broke.  One of which was SAVE's compression behavior.</p>
<p>R3-Alpha made it so that when you'd SAVE a script you could ask it to be compressed.  The compression could be:</p>
<ul>
<li>
<p><strong>false</strong> - no compression at all, a normal looking script</p>
</li>
<li>
<p><strong>true</strong> - the script would have a header, and right after the closing bracket of the header the compressed data bytes would begin.</p>
<ul>
<li>This kind of script would not be loadable in a text editor, since it would be (likely) invalid UTF-8 bytes</li>
</ul>
</li>
<li>
<p><strong>script</strong> - there would be a header followed by a Base64-encoded BINARY! literal of the compressed data</p>
</li>
</ul>
<p>But the header only says "compress" or not.  How would LOAD know whether to look for a BINARY! literal or raw bytes?  Since all bytes are legal in raw compressed data, it couldn't know by matching 64#{...}  <em>(Actually it probably could, since there are magic numbers that start most compressed data, but this was using a kind of black box compression.)</em></p>
<p>So how did it do it?  <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/mezz/sys-load.r#L139">Using ATTEMPT</a>, and it was bad:</p>
<pre><code>; R3-alpha
unless rest: any [ ; automatic detection of compression type
    attempt [decompress/part rest end] ; binary compression
    attempt [decompress first transcode/next rest] ; script encoded
] [return 'bad-compress]
</code></pre>
<p>If you have script encoding, the first thing it's doing is trying to decompress it as a binary format.  That's just decompressing garbage.</p>
<p><strong>But decompressing garbage can do all sorts of insane things, like interpret noise as a memory request size... <em>and then actually request that amount of memory</em>.</strong></p>
<p>It's an epicycle of why Rebol2 TRY and ATTEMPT were so bad, and shows the kind of bad practice we shouldn't be sweeping under the rug by overuse of RECOVER (!)</p>
          <p><a href="https://rebol.metaeducation.com/t/discouraging-the-interception-of-divergent-panics/1871/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/discouraging-the-interception-of-divergent-panics/1871/2</link>
        <pubDate>Sun, 10 Jul 2022 21:15:20 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1871-2</guid>
        <source url="https://rebol.metaeducation.com/t/discouraging-the-interception-of-divergent-panics/1871.rss">Discouraging The Interception of Divergent Panics</source>
      </item>
      <item>
        <title>Discouraging The Interception of Divergent Panics</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>With <a href="https://rebol.metaeducation.com/t/fail-vs-return-fail-the-new-age-of-definitional-failures/1852">definitional errors</a>, the landscape changes considerably for how we think about error handling.</p>
<p><strong>In this world, there are <em>not a lot of good reasons</em> to use what I call "RECOVER".</strong></p>
<p>By its design, RECOVER will intercept <em>any</em> error in code at <em>any</em> depth.  This is what Rebol2's ATTEMPT and TRY did as well, <strong>but this made them not the right tool for hardly any code</strong>:</p>
<pre><code>rebol2&gt;&gt; attempt [print "Attempting to read file" read %nonexistent-file.txt]
Attempting to read file
== none

rebol2&gt;&gt; attempt [print "Attempting but made typos" rread %nonexistent-file.txt]
== none
</code></pre>
<p>The problem isn't just about typos.  It's about the illusion that there's something you can do to react to a panic coming form a completely arbitrary stack level beneath you...when the constructs you were using didn't even understand it well enough to pipe it through to their output.</p>
<p><strong>In almost all cases, an error intercepted by "RECOVER" cannot be reacted to sanely...it has to be reported.  Such use cases should only be things like consoles and test suites.</strong></p>
<p>It's for this reason that languages like Rust pretty much enforce a panic when a function call produces an error the caller doesn't immediately and explicitly handle.</p>
<p>And our case is even more compelling.  For example: How many places is it ever a good idea to sweep a typo under the rug, and just run some other code?</p>
<h2><a name="p-6036-might-we-make-it-look-more-special-to-discourage-use-1" class="anchor" href="https://rebol.metaeducation.com#p-6036-might-we-make-it-look-more-special-to-discourage-use-1"></a>Might We Make It Look More "Special" To Discourage Use?</h2>
<p>I thought at minimum we should move it to a place that shows it's more of a "system utility" than a "language feature".</p>
<p>So calling it <strong><code>SYS.UTIL/RECOVER</code></strong> would be a step in that direction.</p>
<p>Things to think about.  Anyway, I've made some progress on definitional errors in the scanner and with TO and MAKE operations, so some of the things people like to intercept (like conversions) should work correctly with attempt now.</p>
<p>For instance, in this finite-integer world... an out of range error:</p>
<pre><code>&gt;&gt; try to integer! "10483143873258978444434343"
== \~null~\  ; antiform

&gt;&gt; try to intgeer! "10483143873258978444434343"
** Script Error: intgeer! word is attached to a context, but unassigned

&gt;&gt; to integer! "10483143873258978444434343" except e -&gt; [print ["Error:" mold e]]
Error: make warning! [
    type: 'Script
    id: 'bad-make-arg
    message: ["cannot MAKE/TO" :arg1 "from:" :arg2]
    near: [to integer! "10483143873258978444434343" ** except e -&gt; ***]
    where: [to args]
    file: '
    line: 1
    arg1: #[datatype! integer!]
    arg2: "10483143873258978444434343"
]
</code></pre>
<p>Should be a more specific error, now that I look at that.  But I guess it just wasn't.</p>
          <p><a href="https://rebol.metaeducation.com/t/discouraging-the-interception-of-divergent-panics/1871/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/discouraging-the-interception-of-divergent-panics/1871/1</link>
        <pubDate>Sun, 10 Jul 2022 16:05:31 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1871-1</guid>
        <source url="https://rebol.metaeducation.com/t/discouraging-the-interception-of-divergent-panics/1871.rss">Discouraging The Interception of Divergent Panics</source>
      </item>
  </channel>
</rss>

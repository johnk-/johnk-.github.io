<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Design for IMPORT - Modules - AltRebol</title>
    <meta name="description" content="So almost all languages are now at the point where modules are insulated from each other... and when they import definitions, these imports apply only to them and not other places. 
The way some import functions work act&amp;hellip;">
    <meta name="generator" content="Discourse 3.5.0.beta6-dev - https://github.com/discourse/discourse version 623cde985b21c2ed812b83d3ea94f69231613718">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/1X/cbd70027b53fa165575e5b665f00eb3b8ae7ea31_2_32x32.ico">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d_2_180x180.png">
<meta name="theme-color" media="all" content="#fff">

<meta name="color-scheme" content="light">

<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, viewport-fit=cover">
<link rel="canonical" href="1570.html" />

<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="AltRebol Search">

    <link href="https://rebol.metaeducation.com/stylesheets/color_definitions_base__2_ceb61c279a74dfa3cef6a62f7784988102abec82.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" class="light-scheme"/>

<link href="https://rebol.metaeducation.com/stylesheets/common_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="common"  />

  <link href="https://rebol.metaeducation.com/stylesheets/desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="desktop"  />



    <link href="https://rebol.metaeducation.com/stylesheets/chat_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="chat"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-details_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-details"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-lazy-videos_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-lazy-videos"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-local-dates_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-local-dates"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-narrative-bot_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-narrative-bot"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-presence_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-presence"  />
    <link href="https://rebol.metaeducation.com/stylesheets/docker_manager_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="docker_manager"  />
    <link href="https://rebol.metaeducation.com/stylesheets/footnote_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="footnote"  />
    <link href="https://rebol.metaeducation.com/stylesheets/poll_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="poll"  />
    <link href="https://rebol.metaeducation.com/stylesheets/spoiler-alert_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="spoiler-alert"  />
    <link href="https://rebol.metaeducation.com/stylesheets/chat_desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="chat_desktop"  />
    <link href="https://rebol.metaeducation.com/stylesheets/poll_desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="poll_desktop"  />

  <link href="https://rebol.metaeducation.com/stylesheets/common_theme_2_57fe803ed5a41e9f7d94086afaf66a1aab57d9ae.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="common_theme" data-theme-id="2" data-theme-name="default"/>
    

    
    
        <link rel="alternate nofollow" type="application/rss+xml" title="RSS feed of &#39;Design for IMPORT&#39;" href="1570.rss" />
    <meta property="og:site_name" content="AltRebol" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:image" content="https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:url" content="https://rebol.metaeducation.com/t/design-for-import/1570" />
<meta name="twitter:url" content="https://rebol.metaeducation.com/t/design-for-import/1570" />
<meta property="og:title" content="Design for IMPORT" />
<meta name="twitter:title" content="Design for IMPORT" />
<meta property="og:description" content="So almost all languages are now at the point where modules are insulated from each other... and when they import definitions, these imports apply only to them and not other places.  The way some import functions work actually forces you to give a new namespace for the imported definitions.  For instance, in Node.js  const some_lib = require(&#39;./some-library&#39;)  Then if you want to access any of the functions, you have to say some_lib.an_exported_api(...).  Of course if you didn&#39;t want to need to q..." />
<meta name="twitter:description" content="So almost all languages are now at the point where modules are insulated from each other... and when they import definitions, these imports apply only to them and not other places.  The way some import functions work actually forces you to give a new namespace for the imported definitions.  For instance, in Node.js  const some_lib = require(&#39;./some-library&#39;)  Then if you want to access any of the functions, you have to say some_lib.an_exported_api(...).  Of course if you didn&#39;t want to need to q..." />
<meta property="og:article:section" content="Development" />
<meta property="og:article:section:color" content="25AAE2" />
<meta property="og:article:section" content="Modules" />
<meta property="og:article:section:color" content="25AAE2" />
<meta name="twitter:label1" value="Reading time" />
<meta name="twitter:data1" value="5 mins ðŸ•‘" />
<meta name="twitter:label2" value="Likes" />
<meta name="twitter:data2" value="4 â¤" />
<meta property="article:published_time" content="2021-03-21T22:21:55+00:00" />
<meta property="og:ignore_canonical" content="true" />


    
  </head>
  <body class="crawler ">
    
    <header>
  <a href="https://rebol.metaeducation.com/">AltRebol</a>
</header>

    <div id="main-outlet" class="wrap" role="main">
        <div id="topic-title">
    <h1>
      <a href="1570.html">Design for IMPORT</a>
    </h1>

      <div class="topic-category" itemscope itemtype="http://schema.org/BreadcrumbList">
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://rebol.metaeducation.com/c/development/modules/21" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #25AAE2'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Development</span>
              </span>
            </a>
            <meta itemprop="position" content="1" />
          </span>
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://rebol.metaeducation.com/c/development/modules/21" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #25AAE2'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Modules</span>
              </span>
            </a>
            <meta itemprop="position" content="2" />
          </span>
      </div>

  </div>

  

    <div itemscope itemtype='http://schema.org/DiscussionForumPosting'>
      <meta itemprop='headline' content='Design for IMPORT'>
      <link itemprop='url' href='1570.html'>
      <meta itemprop='datePublished' content='2021-03-21T22:21:55Z'>
        <meta itemprop='articleSection' content='Modules'>
      <meta itemprop='keywords' content=''>
      <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
        <meta itemprop='name' content='AltRebol'>
          <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
            <meta itemprop='url' content='https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
          </div>
      </div>


          <div id='post_1'  class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>

                <link itemprop="mainEntityOfPage" href="1570.html">


              <span class="crawler-post-infos">
                  <time  datetime='2021-03-21T22:21:55Z' class='post-time'>
                    March 21, 2021, 10:21pm
                  </time>
                  <meta itemprop='dateModified' content='2021-03-22T12:38:45Z'>
              <span itemprop='position'>1</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>So almost all languages are now at the point where modules are insulated from each other... and when they import definitions, these imports apply only to them and not other places.</p>
<p>The way some import functions work actually forces you to give a new namespace for the imported definitions.  For instance, in Node.js</p>
<pre><code>const some_lib = require('./some-library')
</code></pre>
<p>Then if you want to access any of the functions, you have to say <strong>some_lib.an_exported_api(...)</strong>.</p>
<p>Of course if you didn't want to need to qualify it with the library, you could make local definitions:</p>
<pre><code>const some_lib = require('./some-library')
const an_exported_api = some_lib.an_exported_api
</code></pre>
<p>In the special case that you only want <em>exactly</em> one function, you can duck the variable for the library:</p>
<pre><code>const an_exported_api = require('./some-library').an_exported_api
</code></pre>
<p>But usually you want more than just one definition.  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">So JavaScript has evolved an <strong>import</strong> statement</a>:</p>
<pre><code>import defaultExport from "module-name";
import * as name from "module-name";
import { export1 } from "module-name";
import { export1 as alias1 } from "module-name";
import { export1 , export2 } from "module-name";
import { foo , bar } from "module-name/path/to/specific/un-exported/file";
import { export1 , export2 as alias2 , [...] } from "module-name";
import defaultExport, { export1 [ , [...] ] } from "module-name";
import defaultExport, * as name from "module-name";
import "module-name";
var promise = import("module-name");
</code></pre>
<h2><a name="p-4985-so-what-should-our-import-look-like-1" class="anchor" href="1570.html#p-4985-so-what-should-our-import-look-like-1"></a>So What Should Our IMPORT Look Like?</h2>
<p>I'm wondering if to think of IMPORT as something that takes a bunch of refinements is to think of it as single arity.  If your intent for specifying what to import is simple enough to express in a FILE! or URL! or TAG!, then do that...otherwise dialect a block:</p>
<pre><code>; import from a file
import %../modules/module-name.r

; import from url
import http://example.com/module-name.r

; import from package registry
import &lt;json&gt;

; import a particular registered version (maybe allow PATH!?)
;
import [&lt;json&gt; 1.2.0]
import &lt;json&gt;/1.2.0

; import a specific git hash
; (Note: short hashes are 7 digits long, which are illegal BINARY!, so that
; has made me think that we should be using ISSUE!/TOKEN! for Git hashes)
;
import [&lt;json&gt; #ccb4914]
</code></pre>
<p>Notice how I'm leaning toward using a BLOCK! vs trying to use refinements.  I think this is better than trying to say IMPORT/VERSION/ITEMS or similar.</p>
<p>So when you have a complex list of specific things to import as well as their aliases, that just folds into the block:</p>
<pre><code>import [
    &lt;json&gt; #ccb4914
    some-function
    aliased-name: some-other-function
]
</code></pre>
<p>We can't really use any WORD!s in this dialect, like <strong>as</strong> or <strong>from</strong> or <strong>-&gt;</strong>, because those could be the words of what you are importing.  :-/</p>
<p>So that's why I went with this idea of using SET-WORD!s.</p>
<h2><a name="p-4985-but-thats-actually-kind-of-ugly-2" class="anchor" href="1570.html#p-4985-but-thats-actually-kind-of-ugly-2"></a>But That's Actually... Kind of Ugly</h2>
<p>Looking at the IMPORT statement taking a block like that doesn't feel great.</p>
<pre><code>import [
    &lt;lib1&gt; #ccb4914
    some-function
    aliased-name: some-other-function
]
import [
    http://example.com/some-library.r #1c37714
    some-function2
    aliased-name2: some-other-function2
]
</code></pre>
<p>Even breaking the library out as a first argument improves it:</p>
<pre><code>import &lt;lib1&gt; [
    #ccb4914
    some-function
    aliased-name: some-other-function
]
import http://example.com/some-library.r [
    #1c37714
    some-function2
    aliased-name2: some-other-function2
]
</code></pre>
<p>I feel like having the library name next to the IMPORT statement is important.  And I don't think you should have to use a refinement to get the block.</p>
<p>This makes me feel that a single-argument IMPORT is probably something to be avoided.  This combines with my remarks on <a href="../prescriptivism-on-wildcarding-non-namespaced-imports/1569.html"><strong>precriptivism regarding wildcard imports</strong></a>.</p>
<h2><a name="p-4985-detecting-assignment-3" class="anchor" href="1570.html#p-4985-detecting-assignment-3"></a>Detecting Assignment</h2>
<p>The question of being able to tell whether there's an output is something I think we should certainly not shy away from in designing features.  JavaScript does it.</p>
<p>We could make an IMPORT that can tell when you've assigned it:</p>
<pre><code>zip-stuff: import &lt;ZipModule&gt;
</code></pre>
<p>Such a form could then avoid consuming a BLOCK! after it naming individual things to export, since you have named an aggregator:</p>
<pre><code>import &lt;ZipModule&gt; [zip unzip]
</code></pre>
<p>But that would be foiled by the idea of putting more than just word mappings in the block (version info, etc.).  This would suggest winding up with refinements, like /VERSION, that would get harder to read:</p>
<pre><code>import/version &lt;SomeModule&gt; [
     blah-blah,
     long-list
] 1.0.4
</code></pre>
<p>The clunkiness of that is what made me favor using the block as a dialect, which gives more control over the ordering and presentation.</p>
<p>Anyway, point is that detecting a variable on the left to assign to is an interesting idea but might be hard to exploit to make the simple arity-1 case work without a block.</p>
<h2><a name="p-4985-rethinking-prejudices-about-inline-dialecting-4" class="anchor" href="1570.html#p-4985-rethinking-prejudices-about-inline-dialecting-4"></a>Rethinking Prejudices About "Inline Dialecting"</h2>
<p>Historically it was frowned upon to try and use the logic of literal searching for keywords to make things look "prettier", because they contaminated the function interface.</p>
<p>This was early on given by the avoidance of IF...ELSE and using EITHER, because ELSE didn't have a way to make sense.</p>
<p>There's a good infix logic to them now, and ELSE is a function in its own right.  But what if it weren't, and someone just wanted to write a variadic that looked and saw the word "ELSE" and decided to read another argument?  Is that <em>bad</em>?</p>
<p>I ask because it seems that a Redbol IMPORT has a tough time looking as nice if it can't pull from the playbook of "recognize when the next word at the callsite is FROM".  If everything has to be in a block or cued from refinements, you get a sort of stark regularity that can be a bit of a turn off.</p>
<p>It just seems a bit like restrictive thinking to say you could start a BLOCK! and then do any dialect you want, but then forbidding "inline dialecting" where you recognize keywords without introducing a nesting level.</p>
<p>Just something extra to think about while considering how IMPORT might be in striking distance of as good as JavaScript (!)</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="1" />
              <span class='post-likes'>1 Like</span>
            </div>

                <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../reconsidering-return-values-from-import-vs-do/1767.html">Reconsidering Return Values From IMPORT vs. DO</a>
                        <meta itemprop='position' content='3'>
                      </div>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../we-need-a-syntax-for-import-relative-to-system-script-path/1700/4.html">We Need A Syntax For &quot;IMPORT Relative To System.Script.Path&quot;</a>
                        <meta itemprop='position' content='4'>
                      </div>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../vid-expression-optimization/2202/2.html">VID Expression Optimization</a>
                        <meta itemprop='position' content='5'>
                      </div>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../do-of-text-as-synonym-of-do-of-file-containing-string/2125.html">DO of TEXT! As Synonym of DO of FILE! Containing String</a>
                        <meta itemprop='position' content='6'>
                      </div>
                </div>
          </div>
          <div id='post_2' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='../../u/IngoHohmann.html'><span itemprop='name'>IngoHohmann</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2021-03-22T11:32:01Z' class='post-time'>
                    March 22, 2021, 11:32am
                  </time>
                  <meta itemprop='dateModified' content='2021-03-22T11:32:01Z'>
              <span itemprop='position'>2</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>Well, variadics have been added for a reason.<br>
So the question is: should ren-c restrict itself to some sort of basic features? Or should it be a first user and poster child of all available features?</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="1" />
              <span class='post-likes'>1 Like</span>
            </div>

          </div>
          <div id='post_3' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2021-03-22T16:00:29Z' class='post-time'>
                    March 22, 2021,  4:00pm
                  </time>
                  <meta itemprop='dateModified' content='2021-03-22T16:00:29Z'>
              <span itemprop='position'>3</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1570">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>This makes me feel that a single-argument IMPORT is probably something to be avoided.</p>
</blockquote>
</aside>
<p>An argument <em>for</em> arity-1 import could be the <a href="https://rebol.metaeducation.com/t/how-to-simplify-extracting-results-from-uparse/1561/3">suggestion that you could IMPORT any old OBJECT!</a> and it would act as if you'd declared that object's field as top-level variables.</p>
<p>That could be another construct...like WITH.  But there's something kind of interesting about IMPORT...which makes me wonder if you want to load a module as an object if you might just use another word for <em>that</em>, e.g.</p>
<pre><code>mod: load %some-module.reb
</code></pre>
<p>You get back to the "loading multiple copies question", of whether LOAD should cache if the thing it' loading is a module.  And then you have to worry about all the questions of parameter and dialect duplication (what about version numbers, etc.?)</p>
<p>But maybe it could be worked out that IMPORT just propagates options off of load, and</p>
<pre><code> import %some-module.reb
 =&gt; 
 import load %some-module.reb
</code></pre>
<p>And IMPORT would inherit all the refinements.  Perhaps the specification of narrowing down what you imported could be done like:</p>
<pre><code>import @[zip unzip] %some-module.reb
</code></pre>
<p>The reason I suggest an @ parameter instead of a plain block is because you might want to say:</p>
<pre><code> import (expression producing thing to import)
 import (expression producing import list) expression producing thing to import
</code></pre>
<p>So using <strong>import @[zip unzip] %some-module.reb</strong> gives you the option of instead saying:</p>
<pre><code> import @(import-list) %some-module.reb
</code></pre>
<p>But this is all based on me being afraid of the traditional-looking:</p>
<pre><code> import/partial %some-module.reb [zip unzip]
</code></pre>
<p>Because it feels like it makes an ugly first impression, and it gets worse with</p>
<pre><code> import/partial/version %some-module.reb [zip unzip] 3.0.3
</code></pre>
<p>We'd certainly be better off with:</p>
<pre><code> import [%some-module.reb 3.0.3, zip unzip]
</code></pre>
<aside class="quote no-group" data-username="IngoHohmann" data-post="2" data-topic="1570">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/ingohohmann/48/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>So the question is: should ren-c restrict itself to some sort of basic features? Or should it be a first user and poster child of all available features?</p>
</blockquote>
</aside>
<p>The point is to demonstrate something that seems like something people would actually want to use.  It's important to be self-aware when the very first impressions made at the top of a file are bad.</p>
<p>I think the first lines of the file need to be as good as they can.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
          <div id='post_4' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2024-11-18T20:06:38Z' class='post-time'>
                    November 18, 2024,  8:06pm
                  </time>
                  <meta itemprop='dateModified' content='2024-11-18T21:13:04Z'>
              <span itemprop='position'>4</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1570">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>We could make an IMPORT that can tell when you've assigned it:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">zip-stuff: import &lt;ZipModule&gt;
</code></pre>
<p>Such a form could then avoid consuming a BLOCK! after it naming individual things to export, since you have named an aggregator:</p>
<p><code>import &lt;ZipModule&gt; [zip unzip]</code></p>
</blockquote>
</aside>
<p>So the idea of a construct that behaves differently based on whether there's something to its left <a href="https://rebol.metaeducation.com/t/skip-able-arguments-2024-update-removed/1013">was lost when <code>&lt;skip&gt;</code>-able parameters were killed off</a>.</p>
<p>This means today when you write something like:</p>
<pre><code>vm: import %ws-runtime.reb
</code></pre>
<p>...you do get the module that was imported in the <strong>vm:</strong> variable, but it also brings all the exports into the local space as words, too.  It had no detection to tell it not to.</p>
<p>I'll re-emphasize that modern languages are stressing the idea that you <em>have</em> to namespace things in this way.</p>
<p>If you want to bring all of those exports into "scope", that could be done with the USE meaning I've been suggesting:</p>
<pre><code>use import %ws-runtime.reb
</code></pre>
<p>But that's kind of an all-or-nothing, where you'd imagine wanting to be able to name just some things to use:</p>
<pre><code>use:some [foo bar] import %ws-runtime.reb
</code></pre>
<aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="1570">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I think the first lines of the file need to be as good as they can.</p>
</blockquote>
</aside>
<p>Something like <strong><code>use:some [foo bar] import</code></strong> seems to drift a bit from that.</p>
<p>Losing the detection-of-assignment-on-left does set this back a bit...and isn't something I realized was going away when <strong><code>&lt;skip&gt;</code></strong> was tossed.  But there were good reasons for killing that off, and those good reasons don't go away just because it helped one usage.</p>
<p>Making USE arity-2 could avoid the <strong><code>use:some</code></strong>, to be more like:</p>
<pre><code>use &lt;*&gt; import %ws-runtime.reb
use [foo bar] import %ws-runtime.reb
vm: import %ws-runtime.reb
</code></pre>
<p>What to say for "opt all in" could be something else, maybe <strong>#</strong>.  Or maybe it would look nicer as a specialization?</p>
<pre><code>use # import %ws-runtime.reb
use-all import %ws-runtime.reb
</code></pre>
<p>I dunno.  Anyway, the generic USE construct would be something you could apply to any object, to bring its definitions into "scope" for word lookup.</p>
<p>It's probably better to go this direction than have IMPORT use a <strong><code>&lt;skip&gt;</code></strong> parameter.</p>
<p>Anyway, the design grind goes on.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="1" />
              <span class='post-likes'>1 Like</span>
            </div>

          </div>
          <div id='post_5' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/bradrn'><span itemprop='name'>bradrn</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2024-11-20T05:32:34Z' class='post-time'>
                    November 20, 2024,  5:32am
                  </time>
                  <meta itemprop='dateModified' content='2024-11-20T05:32:34Z'>
              <span itemprop='position'>5</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>I like the idea of separating USE and IMPORT like that. It feels like a very clean design to me.</p>
<p>As for â€˜opt all inâ€™, I like the syntax <code>use &lt;*&gt; object</code> or <code>use # object</code>. I donâ€™t feel like a specialisation or refinement is necessary. Thereâ€™s probably further dialecting possibilities for the first argument of USE, if we just think about what people would want to do.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="1" />
              <span class='post-likes'>1 Like</span>
            </div>

          </div>
          <div id='post_6' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2025-04-09T04:41:18Z' class='post-time'>
                    April 9, 2025,  4:41am
                  </time>
                  <meta itemprop='dateModified' content='2025-04-09T04:41:18Z'>
              <span itemprop='position'>6</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1570">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Making USE arity-2 could avoid the <strong><code>use:some</code></strong>, to be more like:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">use &lt;*&gt; import %ws-runtime.reb
use [foo bar] import %ws-runtime.reb
vm: import %ws-runtime.reb
</code></pre>
</blockquote>
</aside>
<p>Getting to be around the time where I have to do something about this.  (I need the form of import that gives back a module without pulling it into scope...)</p>
<hr>
<p>I can't shake the feeling that when you have a list of configuration things that is possibly infinite, you don't want that potentially infinite list as the first argument.</p>
<p>Looking at this flipped (and <a href="../revisiting-the-riddle-of-the-r/1664.html">switching back to historical <strong>.r</strong></a>)</p>
<pre><code>use import %ws-runtime.r &lt;*&gt; 
use import %ws-runtime.r [foo bar] 
vm: import %ws-runtime.r
</code></pre>
<p>Now we can ask: how would USE interpret a filename if <em>not</em> as a module?  Could the import be implied?</p>
<pre><code>use %ws-runtime.r &lt;*&gt; 
use %ws-runtime.r [foo bar] 
vm: import %ws-runtime.r
</code></pre>
<p>Bringing me back to: does the arity-2 nature of USE convey the grouping well enough?  If not, we're back to a single arity default:</p>
<pre><code>use %ws-runtime.r 
use [%ws-runtime.r foo bar]
vm: import %ws-runtime.r
</code></pre>
<p>Sidenote here, what (if anything) is the result of a USE operation?  It's importing symbols into a context, so maybe the aggregate context?  Seems to make the most sense, and it's something it has on hand.</p>
<pre><code>let a: 10
let b: 20
aggregate: use make object! [c: 30 d: 4] 
let e: 30

&gt;&gt; aggregate.a
== 10

&gt;&gt; aggregate.c
== 30

&gt;&gt; aggregate.e
** Error e is not in there
</code></pre>
<p>Seems vaguely sane.  So in this world <strong><code>use %foo.r</code></strong> would be a synonym of <strong><code>use import %foo.r</code></strong></p>
<p>It's possible--perhaps--that USE could be an arity-1 equivalent of BIND.</p>
<p>So for example, you might want to import a module's definitions so just one function uses it.  You don't want to do that every time you run the function, so:</p>
<pre><code>something: func [...spec...] (use %some-module.r [...body...])
something-else: ... ; no %some-module.r influence, GROUP! ended
</code></pre>
<p>The use is injecting that module's influence in the evaluation stream, so when the body block evaluates it gets that binding wave added on.  But perhaps you could also write that as:</p>
<pre><code>something: func [...spec...] bind %some-module.r [...body...]
something-else: ... ; no %some-module.r influence, BIND arity-2
</code></pre>
<p>So you wouldn't need to throw up a GROUP! or something to stop the USE propagation from spreading.  It seems logical, that anything you might want to do one way you might want to do the other way.</p>
<p>Sounds nice on paper.  <img src="../../images/emoji/twitter/page_with_curl.png%3Fv=14" title=":page_with_curl:" class="emoji" alt=":page_with_curl:" loading="lazy" width="20" height="20">  But there's a big wide open design space there about how to subset a binding operation to just the things you want.</p>
<pre><code>use [
    %some-module.r [x y z]
    %some-other-module.r [a b ccc: c]  ; alias c as ccc?
]
</code></pre>
<p>And maybe not all the options have to go on all the things. The above could cover the common IMPORT case, but perhaps you could break it apart:</p>
<pre><code>some-mod: import [%some-module.r &lt;lots&gt; /of #crazy op.t:i/o:n.s]

use [
    (some-mod) [x y z]
    %some-other-module.r [a b ccc: c]
]
</code></pre>
<aside class="quote no-group" data-username="bradrn" data-post="5" data-topic="1570">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I like the idea of separating USE and IMPORT like that. It feels like a very clean design to me.</p>
</blockquote>
</aside>
<p>It's starting to look palatable... especially if USE and BIND can be unified.</p>
<h2><a name="p-8126-what-about-old-rebol2-use-1" class="anchor" href="1570.html#p-8126-what-about-old-rebol2-use-1"></a>What About Old Rebol2 USE?</h2>
<p>What old Rebol2 USE used to do, was effectively EVAL BIND:</p>
<pre><code>x: "outside"
use [x] [  ; old meaning of USE
     x: "inside"
     print [x]  ; prints inside
]
print [x]  ; prints outside
</code></pre>
<p>This form of USE tended to be used to do some prep work and return blocks, e.g. a BIND operation that wanted to do some additional work:</p>
<pre><code>make-thing: func [...] [
    return use [x] [
        x: 1 + 2  ; concept is there's setup code, so you can't just bind
        [some block referring to x]
    ]
]
</code></pre>
<p>Things are a lot different today, and you can accomplish this with LET and other constructs.</p>
<pre><code>    return eval bind [x] [
        x: 1 + 2
        [some block referring to x]
    ]

    return (
        let x: 1 + 2
        [some block referring to x]
    )

    return (
        use {x: 1 + 2}  ; FENCE! behavior not decided, but probably this works
        [some block referring to x]
    )
</code></pre>
<p>I think the idea of being able to slipstream bindings into the current evaluation stream is a higher calling for USE, and I don't think this arity-2-evaluating form is a big priority.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
    </div>


    




    </div>
    <footer class="container wrap">
  <nav class='crawler-nav'>
    <ul>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/' itemprop="url">Home </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/categories' itemprop="url">Categories </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/guidelines' itemprop="url">Guidelines </a>
        </span>
      </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://rebol.metaeducation.com/tos' itemprop="url">Terms of Service </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://rebol.metaeducation.com/privacy' itemprop="url">Privacy Policy </a>
          </span>
        </li>
    </ul>
  </nav>
  <p class='powered-by-link'>Powered by <a href="https://www.discourse.org">Discourse</a>, best viewed with JavaScript enabled</p>
</footer>

    
    
  </body>
  
</html>

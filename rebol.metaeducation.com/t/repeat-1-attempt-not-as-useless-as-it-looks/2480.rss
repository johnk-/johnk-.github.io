<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>[REPEAT 1] =&gt; ATTEMPT (Not As Useless As It Looks)</title>
    <link>https://rebol.metaeducation.com/t/repeat-1-attempt-not-as-useless-as-it-looks/2480</link>
    <description>Historical Rebol had a use for ATTEMPT that we don&#39;t really need anymore... due to how definitional ERROR!s work and being covered by other things.

When the word was freed up, I thought **`This looks like a perfect name for &quot;loop once&quot;`**

I imagine you&#39;re thinking: *&quot;Why would we waste a name on loop *once*?&quot;* :confused: 

## ...Hear Me Out...

**I&#39;ll start by saying loop once does come up**, when you&#39;re writing something that wants to expose a looping interface, but not delegating to any wrapped loops to do it.

Let&#39;s say you&#39;re trying to do this:

    &gt;&gt; for-all-foos &#39;x [blah blah foo 10 blah blah foo 20] [print [x]]
    10
    20

(Assume you don&#39;t know about reusing FOR-EACH with a GENERATOR.  Instead you decide you really do want to get into your own binding, or customization of the body, or whatever your reasoning is.)

You try driving this with PARSE

    for-all-foos: lambda [var data body] [
        body: bind (var: let (var)) body  ; !!! need better way to say this
        parse data [
            opt some [
                &#39;foo set (var) integer! (eval body)
                | elide one
            ]
        ]
    ]

That seems pretty good...besides me not having a great way of binding an indirect variable to a body, yet being able to still assign that variable afterwards.  *(Note that whatever you use for that needs to know the difference between `@x` to reuse a binding and `x` to not, e.g. it has to be a construct with the smarts of something like LET.)*

But what about BREAK, CONTINUE, etc?

You need to bind body to [THROW-TO-LOOP](https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479), and you have to handle that.

So REPEAT 1 might come to mind.  But what about just ATTEMPT?

    for-all-foos: func [var data body] [
        body: bind (var: let (var)) body  ; !!! need better way to say this
        return parse data [
            opt some [
                &#39;foo set (var) integer! (attempt body else [return null])
                | elide one
            ]
        ]
    ]

So now you have your BREAK, your CONTINUE, your AGAIN, all working.

## But ATTEMPT Is A Genuinely Useful Control Construct

Especially with AGAIN. 

    xxx: attempt [
        blah blah
        if blah blah [break]
        if blah blah [again]
        if blah blah [continue]
        blah blah
    ] then [
        ; code that runs if reaches end normally, or CONTINUE
    ] else [
       ; code that runs if BREAK
    ]

It&#39;s lightweight and flexible, [and in general a lot clearer than INSIST (Redbol UNTIL)](https://rebol.metaeducation.com/t/the-mismatch-of-arity-1-until-and-arity-2-while/594/8?u=hostilefork)

Even in the most minimal circumstances, I think it&#39;s clearer:

    append data insist [request-server-token else [wait 5]]

    append data attempt [request-server-token else [wait 5, again]]

But it&#39;s much more powerful.</description>
    
    <lastBuildDate>Sat, 07 Jun 2025 14:26:56 +0000</lastBuildDate>
    <category>Loops</category>
    <atom:link href="https://rebol.metaeducation.com/t/repeat-1-attempt-not-as-useless-as-it-looks/2480.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>[REPEAT 1] =&gt; ATTEMPT (Not As Useless As It Looks)</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Historical Rebol had a use for ATTEMPT that we don't really need anymore... due to how definitional ERROR!s work and being covered by other things.</p>
<p>When the word was freed up, I thought <strong><code>This looks like a perfect name for "loop once"</code></strong></p>
<p>I imagine you're thinking: <em>"Why would we waste a name on loop <em>once</em>?"</em> <img src="https://rebol.metaeducation.com/images/emoji/twitter/confused.png?v=14" title=":confused:" class="emoji" alt=":confused:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8394-hear-me-out-1" class="anchor" href="https://rebol.metaeducation.com#p-8394-hear-me-out-1"></a>...Hear Me Out...</h2>
<p><strong>I'll start by saying loop once does come up</strong>, when you're writing something that wants to expose a looping interface, but not delegating to any wrapped loops to do it.</p>
<p>Let's say you're trying to do this:</p>
<pre><code>&gt;&gt; for-all-foos 'x [blah blah foo 10 blah blah foo 20] [print [x]]
10
20
</code></pre>
<p>(Assume you don't know about reusing FOR-EACH with a GENERATOR.  Instead you decide you really do want to get into your own binding, or customization of the body, or whatever your reasoning is.)</p>
<p>You try driving this with PARSE</p>
<pre><code>for-all-foos: lambda [var data body] [
    body: bind (var: let (var)) body  ; !!! need better way to say this
    parse data [
        opt some [
            'foo set (var) integer! (eval body)
            | elide one
        ]
    ]
]
</code></pre>
<p>That seems pretty good...besides me not having a great way of binding an indirect variable to a body, yet being able to still assign that variable afterwards.  <em>(Note that whatever you use for that needs to know the difference between <code>@x</code> to reuse a binding and <code>x</code> to not, e.g. it has to be a construct with the smarts of something like LET.)</em></p>
<p>But what about BREAK, CONTINUE, etc?</p>
<p>You need to bind body to <a href="https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479">THROW-TO-LOOP</a>, and you have to handle that.</p>
<p>So REPEAT 1 might come to mind.  But what about just ATTEMPT?</p>
<pre><code>for-all-foos: func [var data body] [
    body: bind (var: let (var)) body  ; !!! need better way to say this
    return parse data [
        opt some [
            'foo set (var) integer! (attempt body else [return null])
            | elide one
        ]
    ]
]
</code></pre>
<p>So now you have your BREAK, your CONTINUE, your AGAIN, all working.</p>
<h2><a name="p-8394-but-attempt-is-a-genuinely-useful-control-construct-2" class="anchor" href="https://rebol.metaeducation.com#p-8394-but-attempt-is-a-genuinely-useful-control-construct-2"></a>But ATTEMPT Is A Genuinely Useful Control Construct</h2>
<p>Especially with AGAIN.</p>
<pre><code>xxx: attempt [
    blah blah
    if blah blah [break]
    if blah blah [again]
    if blah blah [continue]
    blah blah
] then [
    ; code that runs if reaches end normally, or CONTINUE
] else [
   ; code that runs if BREAK
]
</code></pre>
<p>It's lightweight and flexible, <a href="https://rebol.metaeducation.com/t/the-mismatch-of-arity-1-until-and-arity-2-while/594/8">and in general a lot clearer than INSIST (Redbol UNTIL)</a></p>
<p>Even in the most minimal circumstances, I think it's clearer:</p>
<pre><code>append data insist [request-server-token else [wait 5]]

append data attempt [request-server-token else [wait 5, again]]
</code></pre>
<p>But it's much more powerful.</p>
          <p><a href="https://rebol.metaeducation.com/t/repeat-1-attempt-not-as-useless-as-it-looks/2480/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/repeat-1-attempt-not-as-useless-as-it-looks/2480/1</link>
        <pubDate>Sat, 07 Jun 2025 11:26:40 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2480-1</guid>
        <source url="https://rebol.metaeducation.com/t/repeat-1-attempt-not-as-useless-as-it-looks/2480.rss">[REPEAT 1] =&gt; ATTEMPT (Not As Useless As It Looks)</source>
      </item>
  </channel>
</rss>

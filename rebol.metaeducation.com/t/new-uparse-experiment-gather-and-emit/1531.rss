<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>New UPARSE Experiment: GATHER and EMIT</title>
    <link>https://rebol.metaeducation.com/t/new-uparse-experiment-gather-and-emit/1531</link>
    <description>One thing&#39;s for sure about UPARSE, you can really try new ideas out fast.

Here&#39;s one... what if it were easier to make objects via PARSE?  Here&#39;s GATHER and EMIT...which feature rollback (just like COLLECT and KEEP) but are tailored for making objects:

    &gt;&gt; uparse [* * * 1 &lt;foo&gt; * * *] [
          some &#39;*
          g: gather [
              emit i: integer!, emit t: text! | emit i: integer!, emit t: tag!
          ]
          some &#39;*
       ]
    == *
   
    &gt;&gt; g
    == make object! [
        i: 1
        t: &lt;foo&gt;
    ]

This is more in line with Haskell-style parser combinators.  There, the type strictness says that each parser combinator has to produce a typed value, so you tend to build records in this fashion.

It may be useful enough that if you use EMIT at the top level with no gather, then it assumes you want the object to be the result of the parse:

    &gt;&gt; uparse [* * * 1 &lt;foo&gt; * * *] [
          some &#39;*
          [emit i: integer!, emit t: text! | emit i: integer!, emit t: tag!]
          some &#39;*
       ]
    == make object! [
        i: 1
        t: &lt;foo&gt;
    ]

So I added that in for now.  Really it can be reduced to the question of whether the EMIT combinator decides to raise an error when there&#39;s no gather in effect or not, so you could tweak just that one aspect.

Anyway, now&#39;s the time to experiment...so...</description>
    
    <lastBuildDate>Mon, 21 Jul 2025 02:03:10 +0000</lastBuildDate>
    <category>Parsing</category>
    <atom:link href="https://rebol.metaeducation.com/t/new-uparse-experiment-gather-and-emit/1531.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>New UPARSE Experiment: GATHER and EMIT</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Rules about assigning SET-WORD have gotten stricter... only the SET-WORD at module scope are  defined implicitly.  Everything else has to be explicit.  This means functions are much less likely to leak into global variables, and things are under much more control.</p>
<p>I was looking at <a class="mention" href="https://rebol.metaeducation.com/u/gchiu">@gchiu</a>'s <code>midcentral</code> and trying to update it to work under the new rules, and came across this:</p>
<pre><code>parse demo [
    (home: phone: mobile: email: null)
    [opt whitespace]
    surname: across to ","
    thru space [opt whitespace]
    [firstnames: across to "("] (trim:head:tail firstnames)
    thru "(" title: across to ")"  ; `title: between "(" ")"`
    thru "BORN" dob: across to space
    thru "(" age: across to ")"    ; `age: into between "(" ")" integer!`
    thru "GENDER" [opt whitespace] gender: across some alpha
    thru "NHI" nhi: across nhi-rule
    thru "Address" [opt whitespace] street: across to eol (?? street ?? 1)
    thru some eol [opt whitespace] town: across to eol (?? 2 ?? town)
    thru some eol [opt whitespace] city: across to eol (?? 3 ?? city)
    [thru "Home" (?? 4)
        | thru "Mobile" (?? 5)
        | thru "EMAIL" (?? 50) [opt whitespace] email: across to space accept (okay)
        | thru "Contact â€“ No Known Contact Information" (?? 6) to &lt;end&gt; (print "Incomplete Demographics") accept (okay)
    ] [opt whitespace]
    phone: across some digit (?? 51 ?? phone)
    try [
        thru some eol thru "Mobile" [opt whitespace] mobile: across some digit (?? 6 ?? mobile)
        thru some eol try [thru "Email" [opt whitespace] email: across to space (?? 7 ?? email)]
    ]
    to &lt;end&gt;
] except [
    print "Could not parse demographic data"
    return ~
]
</code></pre>
<p>That has problems, because things like <strong><code>surname:</code></strong> did not previously have definitions.  (e.g. they were being written as globals, because the function this code lived in did not declare a <code>&lt;local&gt;</code> for surname.</p>
<p><strong>If not obvious--it's <em>good</em> to get told about this kind of leakage!</strong>  Because otherwise your function is potentially corrupting global data it's not supposed to.</p>
<p><em>(UPDATE: It turns out that (some) of these variables were actually intended as globals.  They definitely should be grouped together in an object!)</em></p>
<p>The easiest thing to do would be to just make local definitions for all the fields.  But that feels like you're repeating yourself.</p>
<h2><a name="p-8548-hey-maybe-emit-could-be-used-here-1" class="anchor" href="https://rebol.metaeducation.com#p-8548-hey-maybe-emit-could-be-used-here-1"></a>"Hey, Maybe EMIT Could Be Used Here"...</h2>
<p>I realized using EMIT to solve It would get a little more wordy, because it doesn't assume all SET-WORD are intended for the object.  <em>(This may mean that a CONSTRUCT combinator is needed that makes the assumption)</em></p>
<p><strong>But this has a problem, when you want to give fields default values, in terms of how you stylize your code.</strong>  Imagine you have some complex logic that decides if you want to emit fields--let's say more than one field are affected:</p>
<pre><code>gather [
    ...
    opt some [
        blah blah [
             emit foo: integer!
             emit bar: block!
        ]
     ]
 ]
</code></pre>
<p>Now let's say you want foo to be null by default if the rule emitting it doesn't apply, and let's say you don't want bar at all in that case.</p>
<p>EMIT gives an error at the moment if you emit something that's already been emitted.  It seems like it should (?)  Though it could be that the last emit is the one that applies for the object.  But that feels sketchy.  Maybe there's something like an <code>emit:update</code>, refinement in order to say it's okay:</p>
<pre><code>gather [
    emit foo: (null)
    opt some [
        blah blah [
             emit:update foo: integer!
             emit bar: block!
        ]
     ]
 ]
</code></pre>
<p>Feels like too many colons.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20">  It could be something like <strong><code>emit*</code></strong>:</p>
<pre><code>gather [
    emit foo: (null)
    opt some [
        blah blah [
             emit* foo: integer!
             emit bar: block!
        ]
     ]
 ]
</code></pre>
<p>Anyway, I'm not quite sure.</p>
<p>Making an OBJECT! does seem to be a good idea here, because the goal is to output the fields to a file:</p>
<pre><code>write to file! unspaced ["/" nhi %.r] mold compose [
    nhi: (nhi)
    title: (title)
    surname: (surname)
    firstnames: (firstnames)
    dob: (dob)
    street: (street)
    town: (town)
    city: (city)
    phone: (phone)
    gender: (gender)
]
</code></pre>
<p>This stresses that a JSON-like output of objects is important, because that file should presumably contain a list (BLOCK! or a FENCE! <code>{...}</code>) and not something with <code>make object! [...]</code></p>
          <p><a href="https://rebol.metaeducation.com/t/new-uparse-experiment-gather-and-emit/1531/9">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/new-uparse-experiment-gather-and-emit/1531/9</link>
        <pubDate>Sun, 20 Jul 2025 03:43:55 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1531-9</guid>
        <source url="https://rebol.metaeducation.com/t/new-uparse-experiment-gather-and-emit/1531.rss">New UPARSE Experiment: GATHER and EMIT</source>
      </item>
      <item>
        <title>New UPARSE Experiment: GATHER and EMIT</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1531">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It may be useful enough that if you use EMIT at the top level with no gather, then it assumes you want the object to be the result of the parse.</p>
<p>So I added that in for now.</p>
</blockquote>
</aside>
<p><a class="mention" href="https://rebol.metaeducation.com/u/giuliolunati">@giuliolunati</a> brought up the point that if "auto-gathering" exists, it is explicitly overriding what might have been an intended result.  He suggested this example:</p>
<pre><code>uparse "ab" [collect [emit x: "a" keep "b"]] =&gt; ?
</code></pre>
<p>There was no GATHER, so does the auto-gather override the COLLECT?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>This kind of pattern looks more like a bug, where the author intended the collect result to be the overall expression result but just has a stray emit.  The implicit GATHER just creates confusion.</p>
<p>That seems like a pretty good disproof.  If you tell users that UPARSE gives the synthesized result of the BLOCK! rule, when can this auto-gather decide that result is less important than some half-articulated EMITs?</p>
<p>So I'm dropping this, but there's actually some pretty flexible room for defining handling of "leaked pendings".  If you don't ask for them, you'll get an error:</p>
<pre><code>&gt;&gt; uparse [10 20] [some keep integer!]
** Error: Residual items accumulated in pending array
</code></pre>
<p>But if you do ask for them (third multi-return result), it suppresses the error and lets you decide what to do with them:</p>
<pre><code>&gt;&gt; [result furthest pending]: uparse [10 20] [some keep integer!]
== 20

&gt;&gt; pending
== ['10 '20]
</code></pre>
<p>This shows you an implementation detail of COLLECT.  KEEP puts QUOTED! items in the pending array, and then COLLECT filters those out.</p>
<pre><code>&gt;&gt; [result furthest pending]: uparse* [10 20] [
    emit x: integer! emit y: integer!
]
== 20

&gt;&gt; pending
== [[x: '10] [y: '20]]
</code></pre>
<p>There's another implementation detail showing that EMIT puts BLOCK!s into the pending stream.</p>
<p>In any case, you can build UPARSE derivatives that take advantage of this knowledge if you can think of a reason to.</p>
<h2><a name="p-5316-giulios-first-reaction-disproof-feedback-only-proves-my-point-1" class="anchor" href="https://rebol.metaeducation.com#p-5316-giulios-first-reaction-disproof-feedback-only-proves-my-point-1"></a>Giulio's First-Reaction-Disproof Feedback Only Proves My Point...</h2>
<p><strong>I need people to be reading this stuff!</strong>  You can make a difference--even if you just fiddle in the ReplPad and ask "why didn't this thing I tried work".</p>
<p>I'm glad people are grokking what <img src="https://rebol.metaeducation.com/images/emoji/twitter/fire.png?v=14" title=":fire:" class="emoji" alt=":fire:" loading="lazy" width="20" height="20"> UPARSE is, but what will really make it strong is to bring more tests and more scenarios...and to question and challenge any rough or odd edges that I may be too close to the issues to see.</p>
          <p><a href="https://rebol.metaeducation.com/t/new-uparse-experiment-gather-and-emit/1531/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/new-uparse-experiment-gather-and-emit/1531/2</link>
        <pubDate>Thu, 12 Aug 2021 23:19:18 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1531-2</guid>
        <source url="https://rebol.metaeducation.com/t/new-uparse-experiment-gather-and-emit/1531.rss">New UPARSE Experiment: GATHER and EMIT</source>
      </item>
      <item>
        <title>New UPARSE Experiment: GATHER and EMIT</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p><strong>I've added an interesting experiment with virtual binding, combining a GATHER'd object with the USE function...</strong></p>
<p>Consider this example for parsing out a base and extension from a filename:</p>
<pre><code>let result
let filename: "demo.txt"
result: parse filename [gather [
    emit base: between &lt;here&gt; "."
    emit extension: thru &lt;end&gt;
]] else [
    fail "Not a file with an extension"
]
print ["The base was" result.base]  ; demo
print ["The extension was" result.extension]  ; txt
</code></pre>
<p>But what if USE was a LET-like construct, that slipstreamed an object's fields into the context:</p>
<pre><code>if true [
    let filename: "demo.txt"
    use parse filename [
        emit base: between &lt;here&gt; "."
        emit extension: thru &lt;end&gt;
     ] else [
        fail "Not a file with an extension"
    ]
    print ["The base was" base]  ; demo
    print ["The extension was" extension]  ; txt
]
; base and extension would not be defined here!
</code></pre>
<p>Pretty cool!</p>
          <p><a href="https://rebol.metaeducation.com/t/new-uparse-experiment-gather-and-emit/1531/8">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/new-uparse-experiment-gather-and-emit/1531/8</link>
        <pubDate>Sun, 02 May 2021 16:48:53 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1531-8</guid>
        <source url="https://rebol.metaeducation.com/t/new-uparse-experiment-gather-and-emit/1531.rss">New UPARSE Experiment: GATHER and EMIT</source>
      </item>
      <item>
        <title>New UPARSE Experiment: GATHER and EMIT</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>One thing's for sure about UPARSE, you can really try new ideas out fast.</p>
<p>Here's one... what if it were easier to make objects via PARSE?  Here's GATHER and EMIT...which feature rollback (just like COLLECT and KEEP) but are tailored for making objects:</p>
<pre><code>&gt;&gt; uparse [* * * 1 &lt;foo&gt; * * *] [
      some '*
      g: gather [
          emit i: integer!, emit t: text! | emit i: integer!, emit t: tag!
      ]
      some '*
   ]
== *

&gt;&gt; g
== make object! [
    i: 1
    t: &lt;foo&gt;
]
</code></pre>
<p>This is more in line with Haskell-style parser combinators.  There, the type strictness says that each parser combinator has to produce a typed value, so you tend to build records in this fashion.</p>
<p>It may be useful enough that if you use EMIT at the top level with no gather, then it assumes you want the object to be the result of the parse:</p>
<pre><code>&gt;&gt; uparse [* * * 1 &lt;foo&gt; * * *] [
      some '*
      [emit i: integer!, emit t: text! | emit i: integer!, emit t: tag!]
      some '*
   ]
== make object! [
    i: 1
    t: &lt;foo&gt;
]
</code></pre>
<p>So I added that in for now.  Really it can be reduced to the question of whether the EMIT combinator decides to raise an error when there's no gather in effect or not, so you could tweak just that one aspect.</p>
<p>Anyway, now's the time to experiment...so...</p>
          <p><a href="https://rebol.metaeducation.com/t/new-uparse-experiment-gather-and-emit/1531/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/new-uparse-experiment-gather-and-emit/1531/1</link>
        <pubDate>Tue, 02 Mar 2021 08:14:43 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1531-1</guid>
        <source url="https://rebol.metaeducation.com/t/new-uparse-experiment-gather-and-emit/1531.rss">New UPARSE Experiment: GATHER and EMIT</source>
      </item>
  </channel>
</rss>

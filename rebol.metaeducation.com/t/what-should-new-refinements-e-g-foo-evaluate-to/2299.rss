<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>What Should &quot;New Refinements&quot; (e.g. :FOO) Evaluate To?</title>
    <link>https://rebol.metaeducation.com/t/what-should-new-refinements-e-g-foo-evaluate-to/2299</link>
    <description>At one point I thought &quot;new refinements&quot; had a dialected purpose in APPLY to name the frame fields:

    call:shell // [  ; infix APPLY
        [(system.options.boot) --suppress {&quot;*&quot;} print.reb 100]

        :input &#39;none      ; pipe input from /dev/null
        :output data: &quot;&quot;  ; write output to string
    ]

That&#39;s a bit contentious with other evaluative purposes.

But eventually I decided that was not as good as using plain SET-WORD.  This requires you to put any random arbitrary assignments in GROUP!s, which is its own &quot;contention&quot;, but not so much of a burden:

    call:shell // [  ; infix APPLY
        [(system.options.boot) --suppress {&quot;*&quot;} print.reb 100]

        input: &#39;none      ; pipe input from /dev/null
        output: (data: &quot;&quot;)  ; write output to string
    ]

It looks better, and fits with the already established modality of &quot;assignment&quot;.

## So :FOO Is Free For Other Meanings

What should those meanings be?

Ideally it would make some sense with the usage of leading colon for refinements.

In the past, **`:[...]`** was able to mean REDUCE.  That was semi-useful, but it didn&#39;t get used as much as I might have thought.

Leaving these forms free and open [for the user to redefine with RebindableSyntax](https://rebol.metaeducation.com/t/evaluator-hooking-rebindablesyntax/2443) is another possibility.</description>
    
    <lastBuildDate>Wed, 16 Jul 2025 02:09:54 +0000</lastBuildDate>
    <category>Datatypes</category>
    <atom:link href="https://rebol.metaeducation.com/t/what-should-new-refinements-e-g-foo-evaluate-to/2299.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>What Should &quot;New Refinements&quot; (e.g. :FOO) Evaluate To?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2299">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong><code>:foo.bar</code></strong> would thus similarly be a way of asking for FOO.BAR and if it wasn't there, giving you back NULL.</p>
<p>Well it's an idea.</p>
</blockquote>
</aside>
<p>As I found that folding TRY into OPT was likely a bad idea, that means when you want optionality of a potentially missing field you have to say:</p>
<pre><code>opt try obj.field
</code></pre>
<p>Which could be more compact as:</p>
<pre><code>opt :obj.field
</code></pre>
<p>Also, something to consider now, is that tuple-picking can give back an ERROR! as a value:</p>
<pre><code>obj: make object! [
    try ^field: fail "you can do this"
]
</code></pre>
<p>This means that <strong><code>obj.^field</code></strong> can legitimately return an ERROR!.  This calls into question my idea of using TRY on tuple picks to say "I want to get null if the field wasn't available".</p>
<p>So perhaps the leading colon could more narrowly mean "If the pick isn't there, give back null", so it doesn't wind up suppressing errors from meta-picks.</p>
<p>Narrowing it may be best, I don't know that I would want leading colon on function calls to mean "try".  The history of leading colon as inert makes it feel like it should be inert, but beyond that it seems to me like a decoration like that wouldn't go with invocation.</p>
          <p><a href="https://rebol.metaeducation.com/t/what-should-new-refinements-e-g-foo-evaluate-to/2299/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/what-should-new-refinements-e-g-foo-evaluate-to/2299/4</link>
        <pubDate>Wed, 16 Jul 2025 02:09:54 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2299-4</guid>
        <source url="https://rebol.metaeducation.com/t/what-should-new-refinements-e-g-foo-evaluate-to/2299.rss">What Should &quot;New Refinements&quot; (e.g. :FOO) Evaluate To?</source>
      </item>
      <item>
        <title>What Should &quot;New Refinements&quot; (e.g. :FOO) Evaluate To?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>So I was considering that <strong><code>:foo</code></strong> could be a shorthand for <strong><code>try foo</code></strong></p>
<p><strong><code>:foo.bar</code></strong> would thus similarly be a way of asking for FOO.BAR and if it wasn't there, giving you back NULL.</p>
<p>Well it's an idea.  I'm not going to run out and implement it immediately--many other things to look at.</p>
          <p><a href="https://rebol.metaeducation.com/t/what-should-new-refinements-e-g-foo-evaluate-to/2299/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/what-should-new-refinements-e-g-foo-evaluate-to/2299/2</link>
        <pubDate>Wed, 14 May 2025 07:57:09 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2299-2</guid>
        <source url="https://rebol.metaeducation.com/t/what-should-new-refinements-e-g-foo-evaluate-to/2299.rss">What Should &quot;New Refinements&quot; (e.g. :FOO) Evaluate To?</source>
      </item>
      <item>
        <title>What Should &quot;New Refinements&quot; (e.g. :FOO) Evaluate To?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>At one point I thought "new refinements" had a dialected purpose in APPLY to name the frame fields:</p>
<pre><code>call:shell // [  ; infix APPLY
    [(system.options.boot) --suppress {"*"} print.reb 100]

    :input 'none      ; pipe input from /dev/null
    :output data: ""  ; write output to string
]
</code></pre>
<p>That's a bit contentious with other evaluative purposes.</p>
<p>But eventually I decided that was not as good as using plain SET-WORD.  This requires you to put any random arbitrary assignments in GROUP!s, which is its own "contention", but not so much of a burden:</p>
<pre><code>call:shell // [  ; infix APPLY
    [(system.options.boot) --suppress {"*"} print.reb 100]

    input: 'none      ; pipe input from /dev/null
    output: (data: "")  ; write output to string
]
</code></pre>
<p>It looks better, and fits with the already established modality of "assignment".</p>
<h2><a name="p-7781-so-foo-is-free-for-other-meanings-1" class="anchor" href="https://rebol.metaeducation.com#p-7781-so-foo-is-free-for-other-meanings-1"></a>So :FOO Is Free For Other Meanings</h2>
<p>What should those meanings be?</p>
<p>Ideally it would make some sense with the usage of leading colon for refinements.</p>
<p>In the past, <strong><code>:[...]</code></strong> was able to mean REDUCE.  That was semi-useful, but it didn't get used as much as I might have thought.</p>
<p>Leaving these forms free and open <a href="https://rebol.metaeducation.com/t/evaluator-hooking-rebindablesyntax/2443">for the user to redefine with RebindableSyntax</a> is another possibility.</p>
          <p><a href="https://rebol.metaeducation.com/t/what-should-new-refinements-e-g-foo-evaluate-to/2299/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/what-should-new-refinements-e-g-foo-evaluate-to/2299/1</link>
        <pubDate>Fri, 27 Sep 2024 18:11:27 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2299-1</guid>
        <source url="https://rebol.metaeducation.com/t/what-should-new-refinements-e-g-foo-evaluate-to/2299.rss">What Should &quot;New Refinements&quot; (e.g. :FOO) Evaluate To?</source>
      </item>
  </channel>
</rss>

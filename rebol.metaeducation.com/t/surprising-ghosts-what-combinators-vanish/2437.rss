<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>&quot;Surprising&quot; Ghosts: What Combinators Vanish?</title>
    <link>https://rebol.metaeducation.com/t/surprising-ghosts-what-combinators-vanish/2437</link>
    <description>[The vanishing intent of GHOST!](https://rebol.metaeducation.com/t/making-invisible-functions-e-g-comment-elide/2034) (antiform COMMA!) is now distinct from [the empty intent of VOID](https://rebol.metaeducation.com/t/why-are-trash-and-void-distinct-in-ren-c/2416) (empty parameter pack, antiform BLOCK!).

    &gt;&gt; 1 + 2 ghost
    == 3

    &gt;&gt; 1 + 2 void
    == ~[]~  ; anti

This has brought to the forefront the question of which combinators should support vanishing.

## Right Now, If `&lt;END&gt;` Matches, it Vanishes

    &gt;&gt; parse [a b] [word! &lt;end&gt;]
    ** Error: PARSE mismatch

    &gt;&gt; parse [a] [word! &lt;end&gt;]
    == a

That&#39;s very useful.

Should TO and THRU--when parameterized with something that vanishes--also vanish?

    &gt;&gt; parse [a #b #c] [word! to &lt;end&gt;]
    == a

Seems pretty useful *on the surface*.  But TO and THRU are intrinsically looping constructs...they iterate their rules.  This means you could wind up with something that sometimes vanishes, and sometimes does not:

    &gt;&gt; rule: [integer! | elide text!]

    &gt;&gt; parse [a #b #c &quot;hi&quot;] [var: [word!, thru rule]]
    == a  ; VAR got the product of WORD!

    &gt;&gt; parse [a #b #c 1020] [var: [word!, thru rule]]
    == 1020  ; VAR got the product of THRU RULE

That&#39;s a bit disorienting, how an elide managed to leak out.  It&#39;s like the structure of the parse code isn&#39;t doing what you expect.

This is why the main evaluator&#39;s loops and branching constructs are not willing to vaporize when they stand alone.  They&#39;re only willing to produce VOID.  This keeps the basic structure of the code from picking up results you don&#39;t expect, unless you call something that specifically is known to have vanishing intent (and you can ask to convert voids to ghosts explicitly if you want).

Even invoking a rule BLOCK! itself--if you think of rule invocation as like PARSE&#39;s version of calling a lambda--raises some questions about &quot;surprising&quot; ghosts:

    &gt;&gt; rule: [integer! | elide text!]

    &gt;&gt; parse [a #b #c &quot;hi&quot;] [var: [word!, rule]]
    == a  ; VAR got the product of WORD!

    &gt;&gt; parse [a #b #c 1020] [var: [word!, rule]]
    == 1020  ; VAR got the product of RULE

Unfortunately PARSE doesn&#39;t have the analogue of the GROUP! vs. BLOCK! distinction for code, where one can be transparent and the other &quot;surprising&quot;.   **`[elide some [rule1 | rule2]]`** can be genuinely useful as a source grouping.

## On That Note, Should LAMBDA Be Willing To Vanish?

At the moment, you get VOID and not GHOST from lambdas whose bodies vanish.

     &gt;&gt; test: lambda [] [comment &quot;this is a test&quot;]

     &gt;&gt; 1 + 2 test
     == ~[]~  ; anti (void)

It&#39;s hence impossible for a LAMBDA to produce a GHOST!... you have to use functions with a return value.  But does that make sense?

**I think I&#39;m willing to say that lambdas and rule blocks can vanish.  They probably have to.**

But I&#39;m just not 100% on board with the idea of this vanishing leaking out through other constructs.  It seems likely that you&#39;d start getting &quot;vanishing sometimes&quot; behavior on accident.

So while it may seem nice if you&#39;re just looking at the specific case of **`to &lt;end&gt;`** vanishing, I think the long game favors saying that it&#39;s easy enough to write **`elide to &lt;end&gt;`** if you want.

Having plain **`&lt;end&gt;`** in isolation vanish is fine, because that&#39;s predictable and happens every time you use **`&lt;end&gt;`**.  But it wouldn&#39;t be so with vanishing every time you use TO... hence the problem with it.</description>
    
    <lastBuildDate>Tue, 20 May 2025 06:05:18 +0000</lastBuildDate>
    <category>Parsing</category>
    <atom:link href="https://rebol.metaeducation.com/t/surprising-ghosts-what-combinators-vanish/2437.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>&quot;Surprising&quot; Ghosts: What Combinators Vanish?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2437">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Should TO and THRU--when parameterized with something that vanishes--also vanish?</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; parse [a #b #c] [word! to &lt;end&gt;]
== a
</code></pre>
<p>Seems pretty useful <em>on the surface</em>. But TO and THRU are intrinsically looping constructs...they iterate their rules. This means you could wind up with something that sometimes vanishes, and sometimes does not:</p>
</blockquote>
</aside>
<h2><a name="p-8279-we-can-get-the-best-of-both-worlds-1" class="anchor" href="https://rebol.metaeducation.com#p-8279-we-can-get-the-best-of-both-worlds-1"></a>We Can Get The Best Of Both Worlds</h2>
<p>So the <a href="https://rebol.metaeducation.com/t/how-to-choose-between-returning-ghost-and-void/2171/3">concept that I am putting forth</a> is that we treat functions differently based on their type signature.</p>
<ul>
<li>
<p>If a function returns ghosts <em>always</em> (an "unsurprising" ghost) then let them vanish.</p>
</li>
<li>
<p>If a function returns ghosts <em>sometimes</em> (a "surprising" ghost), then still produce a ghost... <strong>but don't vanish</strong>.</p>
</li>
</ul>
<p>At first I thought that <strong><code>^</code></strong> would be an operator for overriding the non-vanishing behavior, transforming surprising ghosts into unsurprising ones (humorously called UNAFRAID).</p>
<pre><code>&gt;&gt; parse [a #b #c] [word! to &lt;end&gt;]
== ~[]~  ; anti (void)

&gt;&gt; parse [a #b #c] [word! ^ to &lt;end&gt;]
== a
</code></pre>
<p>However, the much more useful application of that scarce operator is to approve <em>surprising actions</em>.  This is when ACTION! is returned by operations that don't always return actions, which will panic on assignment by default.  We don't want one operator to quell both surprises: that would mean people who simply meant to approve actions could end up wrecking the structure of their code on ghost appearances.</p>
<p>So if there's an UNAFRAID token, it will have to be something besides <strong><code>^</code></strong></p>
<h2><a name="p-8279-key-to-observe-unafraid-cant-be-a-combinator-2" class="anchor" href="https://rebol.metaeducation.com#p-8279-key-to-observe-unafraid-cant-be-a-combinator-2"></a>Key To Observe: <code>UNAFRAID</code> Can't Be a Combinator</h2>
<p>What <code>UNAFRAID</code> has to be is like <code>|</code> and <code>||</code>... something the BLOCK! combinator specifically recognizes as it processes.</p>
<p>Unfortunately I feel like we're kind of out of symbols.  We do have the option of <strong><code>'</code></strong> making a resurrected appearance, but I don't think it's a good idea.</p>
          <p><a href="https://rebol.metaeducation.com/t/surprising-ghosts-what-combinators-vanish/2437/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/surprising-ghosts-what-combinators-vanish/2437/3</link>
        <pubDate>Wed, 14 May 2025 14:34:25 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2437-3</guid>
        <source url="https://rebol.metaeducation.com/t/surprising-ghosts-what-combinators-vanish/2437.rss">&quot;Surprising&quot; Ghosts: What Combinators Vanish?</source>
      </item>
      <item>
        <title>&quot;Surprising&quot; Ghosts: What Combinators Vanish?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2437">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But I'm just not 100% on board with the idea of this vanishing leaking out through other constructs. It seems likely that you'd start getting "vanishing sometimes" behavior on accident.</p>
</blockquote>
</aside>
<p>So I made a function called UNGHOST to help with this:</p>
<pre><code>&gt;&gt; 1 + 2 comment "HI"
== 3

&gt;&gt; 1 + 2 unghost comment "HI"
== ~[]~

&gt;&gt; 1 + 2 unghost 10 + 20
== 30
</code></pre>
<p>But then I noticed that most all of the combinators in UPARSE (that call subparsers) would have to end with <strong><code>return unghost ^result</code></strong> instead of just <strong><code>return result</code></strong>.</p>
<p>It feels redundant.  Because the pattern is: does the return spec have GHOST! in it, and if not, run UNGHOST.  So it might not hurt if FUNCTIONs which don't have GHOST! in their RETURN: spec would automatically convert ghosts to VOID.</p>
<p>I <em>could</em> make this something that just COMBINATORs do.  But because of the systemic "ghost suppression" bias I am feeling, I think it would be good for the health of the system overall.</p>
<h2><a name="p-8219-just-coerce-to-void-for-return-or-arguments-too-1" class="anchor" href="https://rebol.metaeducation.com#p-8219-just-coerce-to-void-for-return-or-arguments-too-1"></a>Just Coerce To Void For RETURN, Or Arguments Too?</h2>
<p>While it seems helpful or at least benign for RETURN, I'm not sure if it's completely wise to make this a general rule for type checking... that anything which would take a VOID would be willing to accept a GHOST! converted to VOID:</p>
<pre><code>&gt;&gt; append [a b c] comment "is this bad?"
== [a b c]

&gt;&gt; append [a b c] ()
== [a b c]
</code></pre>
<p>It's not <em>obviously</em> terrible.  But it does kind of take off some guardrails, to where you might not be saying what you think you meant to say.</p>
<p>There's no immediate advantage that I can see, and it just seems to promote accidents.  So I think I'll limit it to return type coercion.</p>
          <p><a href="https://rebol.metaeducation.com/t/surprising-ghosts-what-combinators-vanish/2437/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/surprising-ghosts-what-combinators-vanish/2437/2</link>
        <pubDate>Wed, 07 May 2025 15:01:55 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2437-2</guid>
        <source url="https://rebol.metaeducation.com/t/surprising-ghosts-what-combinators-vanish/2437.rss">&quot;Surprising&quot; Ghosts: What Combinators Vanish?</source>
      </item>
      <item>
        <title>&quot;Surprising&quot; Ghosts: What Combinators Vanish?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p><a href="https://rebol.metaeducation.com/t/making-invisible-functions-e-g-comment-elide/2034">The vanishing intent of GHOST!</a> (antiform COMMA!) is now distinct from <a href="https://rebol.metaeducation.com/t/why-are-trash-and-void-distinct-in-ren-c/2416">the empty intent of VOID</a> (empty parameter pack, antiform BLOCK!).</p>
<pre><code>&gt;&gt; 1 + 2 ghost
== 3

&gt;&gt; 1 + 2 void
== ~[]~  ; anti
</code></pre>
<p>This has brought to the forefront the question of which combinators should support vanishing.</p>
<h2><a name="p-8211-right-now-if-end-matches-it-vanishes-1" class="anchor" href="https://rebol.metaeducation.com#p-8211-right-now-if-end-matches-it-vanishes-1"></a>Right Now, If <code>&lt;END&gt;</code> Matches, it Vanishes</h2>
<pre><code>&gt;&gt; parse [a b] [word! &lt;end&gt;]
** Error: PARSE mismatch

&gt;&gt; parse [a] [word! &lt;end&gt;]
== a
</code></pre>
<p>That's very useful.</p>
<p>Should TO and THRU--when parameterized with something that vanishes--also vanish?</p>
<pre><code>&gt;&gt; parse [a #b #c] [word! to &lt;end&gt;]
== a
</code></pre>
<p>Seems pretty useful <em>on the surface</em>.  But TO and THRU are intrinsically looping constructs...they iterate their rules.  This means you could wind up with something that sometimes vanishes, and sometimes does not:</p>
<pre><code>&gt;&gt; rule: [integer! | elide text!]

&gt;&gt; parse [a #b #c "hi"] [var: [word!, thru rule]]
== a  ; VAR got the product of WORD!

&gt;&gt; parse [a #b #c 1020] [var: [word!, thru rule]]
== 1020  ; VAR got the product of THRU RULE
</code></pre>
<p>That's a bit disorienting, how an elide managed to leak out.  It's like the structure of the parse code isn't doing what you expect.</p>
<p>This is why the main evaluator's loops and branching constructs are not willing to vaporize when they stand alone.  They're only willing to produce VOID.  This keeps the basic structure of the code from picking up results you don't expect, unless you call something that specifically is known to have vanishing intent (and you can ask to convert voids to ghosts explicitly if you want).</p>
<p>Even invoking a rule BLOCK! itself--if you think of rule invocation as like PARSE's version of calling a lambda--raises some questions about "surprising" ghosts:</p>
<pre><code>&gt;&gt; rule: [integer! | elide text!]

&gt;&gt; parse [a #b #c "hi"] [var: [word!, rule]]
== a  ; VAR got the product of WORD!

&gt;&gt; parse [a #b #c 1020] [var: [word!, rule]]
== 1020  ; VAR got the product of RULE
</code></pre>
<p>Unfortunately PARSE doesn't have the analogue of the GROUP! vs. BLOCK! distinction for code, where one can be transparent and the other "surprising".   <strong><code>[elide some [rule1 | rule2]]</code></strong> can be genuinely useful as a source grouping.</p>
<h2><a name="p-8211-on-that-note-should-lambda-be-willing-to-vanish-2" class="anchor" href="https://rebol.metaeducation.com#p-8211-on-that-note-should-lambda-be-willing-to-vanish-2"></a>On That Note, Should LAMBDA Be Willing To Vanish?</h2>
<p>At the moment, you get VOID and not GHOST from lambdas whose bodies vanish.</p>
<pre><code> &gt;&gt; test: lambda [] [comment "this is a test"]

 &gt;&gt; 1 + 2 test
 == ~[]~  ; anti (void)
</code></pre>
<p>It's hence impossible for a LAMBDA to produce a GHOST!... you have to use functions with a return value.  But does that make sense?</p>
<p><strong>I think I'm willing to say that lambdas and rule blocks can vanish.  They probably have to.</strong></p>
<p>But I'm just not 100% on board with the idea of this vanishing leaking out through other constructs.  It seems likely that you'd start getting "vanishing sometimes" behavior on accident.</p>
<p>So while it may seem nice if you're just looking at the specific case of <strong><code>to &lt;end&gt;</code></strong> vanishing, I think the long game favors saying that it's easy enough to write <strong><code>elide to &lt;end&gt;</code></strong> if you want.</p>
<p>Having plain <strong><code>&lt;end&gt;</code></strong> in isolation vanish is fine, because that's predictable and happens every time you use <strong><code>&lt;end&gt;</code></strong>.  But it wouldn't be so with vanishing every time you use TO... hence the problem with it.</p>
          <p><a href="https://rebol.metaeducation.com/t/surprising-ghosts-what-combinators-vanish/2437/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/surprising-ghosts-what-combinators-vanish/2437/1</link>
        <pubDate>Wed, 07 May 2025 05:19:44 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2437-1</guid>
        <source url="https://rebol.metaeducation.com/t/surprising-ghosts-what-combinators-vanish/2437.rss">&quot;Surprising&quot; Ghosts: What Combinators Vanish?</source>
      </item>
  </channel>
</rss>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>&quot;Surprising&quot; Ghosts: What Combinators Vanish? - Parsing - AltRebol</title>
    <meta name="description" content="The vanishing intent of GHOST! (antiform COMMA!) is now distinct from the empty intent of VOID (empty parameter pack, antiform BLOCK!). 
&amp;gt;&amp;gt; 1 + 2 ghost
== 3

&amp;gt;&amp;gt; 1 + 2 void
== ~[]~  ; anti

This has brought to the forefro&amp;hellip;">
    <meta name="generator" content="Discourse 3.5.0.beta6-dev - https://github.com/discourse/discourse version 623cde985b21c2ed812b83d3ea94f69231613718">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/1X/cbd70027b53fa165575e5b665f00eb3b8ae7ea31_2_32x32.ico">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d_2_180x180.png">
<meta name="theme-color" media="all" content="#fff">

<meta name="color-scheme" content="light">

<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, viewport-fit=cover">
<link rel="canonical" href="../leaky-ghosts-what-combinators-should-vanish/2437.html" />

<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="AltRebol Search">

    <link href="https://rebol.metaeducation.com/stylesheets/color_definitions_base__2_ceb61c279a74dfa3cef6a62f7784988102abec82.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" class="light-scheme"/>

<link href="https://rebol.metaeducation.com/stylesheets/common_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="common"  />

  <link href="https://rebol.metaeducation.com/stylesheets/desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="desktop"  />



    <link href="https://rebol.metaeducation.com/stylesheets/chat_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="chat"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-details_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-details"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-lazy-videos_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-lazy-videos"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-local-dates_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-local-dates"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-narrative-bot_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-narrative-bot"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-presence_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-presence"  />
    <link href="https://rebol.metaeducation.com/stylesheets/docker_manager_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="docker_manager"  />
    <link href="https://rebol.metaeducation.com/stylesheets/footnote_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="footnote"  />
    <link href="https://rebol.metaeducation.com/stylesheets/poll_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="poll"  />
    <link href="https://rebol.metaeducation.com/stylesheets/spoiler-alert_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="spoiler-alert"  />
    <link href="https://rebol.metaeducation.com/stylesheets/chat_desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="chat_desktop"  />
    <link href="https://rebol.metaeducation.com/stylesheets/poll_desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="poll_desktop"  />

  <link href="https://rebol.metaeducation.com/stylesheets/common_theme_2_57fe803ed5a41e9f7d94086afaf66a1aab57d9ae.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="common_theme" data-theme-id="2" data-theme-name="default"/>
    

    
    
        <link rel="alternate nofollow" type="application/rss+xml" title="RSS feed of &#39;&quot;Surprising&quot; Ghosts: What Combinators Vanish?&#39;" href="2437.rss" />
    <meta property="og:site_name" content="AltRebol" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:image" content="https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:url" content="https://rebol.metaeducation.com/t/surprising-ghosts-what-combinators-vanish/2437" />
<meta name="twitter:url" content="https://rebol.metaeducation.com/t/surprising-ghosts-what-combinators-vanish/2437" />
<meta property="og:title" content="&quot;Surprising&quot; Ghosts: What Combinators Vanish?" />
<meta name="twitter:title" content="&quot;Surprising&quot; Ghosts: What Combinators Vanish?" />
<meta property="og:description" content="The vanishing intent of GHOST! (antiform COMMA!) is now distinct from the empty intent of VOID (empty parameter pack, antiform BLOCK!).  &gt;&gt; 1 + 2 ghost == 3  &gt;&gt; 1 + 2 void == ~[]~  ; anti  This has brought to the forefront the question of which combinators should support vanishing.  Right Now, If &lt;END&gt; Matches, it Vanishes &gt;&gt; parse [a b] [word! &lt;end&gt;] ** Error: PARSE mismatch  &gt;&gt; parse [a] [word! &lt;end&gt;] == a  That&#39;s very useful.  Should TO and THRU--when parameterized with something that vanishe..." />
<meta name="twitter:description" content="The vanishing intent of GHOST! (antiform COMMA!) is now distinct from the empty intent of VOID (empty parameter pack, antiform BLOCK!).  &gt;&gt; 1 + 2 ghost == 3  &gt;&gt; 1 + 2 void == ~[]~  ; anti  This has brought to the forefront the question of which combinators should support vanishing.  Right Now, If &lt;END&gt; Matches, it Vanishes &gt;&gt; parse [a b] [word! &lt;end&gt;] ** Error: PARSE mismatch  &gt;&gt; parse [a] [word! &lt;end&gt;] == a  That&#39;s very useful.  Should TO and THRU--when parameterized with something that vanishe..." />
<meta property="og:article:section" content="Domains" />
<meta property="og:article:section:color" content="F1592A" />
<meta property="og:article:section" content="Parsing" />
<meta property="og:article:section:color" content="F1592A" />
<meta name="twitter:label1" value="Reading time" />
<meta name="twitter:data1" value="2 mins 🕑" />
<meta name="twitter:label2" value="Likes" />
<meta name="twitter:data2" value="1 ❤" />
<meta property="article:published_time" content="2025-05-07T05:19:44+00:00" />
<meta property="og:ignore_canonical" content="true" />


    
  </head>
  <body class="crawler ">
    
    <header>
  <a href="https://rebol.metaeducation.com/">AltRebol</a>
</header>

    <div id="main-outlet" class="wrap" role="main">
        <div id="topic-title">
    <h1>
      <a href="../leaky-ghosts-what-combinators-should-vanish/2437.html">&quot;Surprising&quot; Ghosts: What Combinators Vanish?</a>
    </h1>

      <div class="topic-category" itemscope itemtype="http://schema.org/BreadcrumbList">
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://rebol.metaeducation.com/c/domains/parsing/16" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #F1592A'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Domains</span>
              </span>
            </a>
            <meta itemprop="position" content="1" />
          </span>
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://rebol.metaeducation.com/c/domains/parsing/16" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #F1592A'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Parsing</span>
              </span>
            </a>
            <meta itemprop="position" content="2" />
          </span>
      </div>

  </div>

  

    <div itemscope itemtype='http://schema.org/DiscussionForumPosting'>
      <meta itemprop='headline' content='&quot;Surprising&quot; Ghosts: What Combinators Vanish?'>
      <link itemprop='url' href='../leaky-ghosts-what-combinators-should-vanish/2437.html'>
      <meta itemprop='datePublished' content='2025-05-07T05:19:43Z'>
        <meta itemprop='articleSection' content='Parsing'>
      <meta itemprop='keywords' content=''>
      <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
        <meta itemprop='name' content='AltRebol'>
          <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
            <meta itemprop='url' content='https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
          </div>
      </div>


          <div id='post_1'  class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>

                <link itemprop="mainEntityOfPage" href="../leaky-ghosts-what-combinators-should-vanish/2437.html">


              <span class="crawler-post-infos">
                  <time  datetime='2025-05-07T05:19:44Z' class='post-time'>
                    May 7, 2025,  5:19am
                  </time>
                  <meta itemprop='dateModified' content='2025-05-16T08:34:18Z'>
              <span itemprop='position'>1</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p><a href="../invisibility-reviewed-through-modern-eyes/2034.html">The vanishing intent of GHOST!</a> (antiform COMMA!) is now distinct from <a href="../why-are-trash-and-void-distinct-in-ren-c/2416.html">the empty intent of VOID</a> (empty parameter pack, antiform BLOCK!).</p>
<pre><code>&gt;&gt; 1 + 2 ghost
== 3

&gt;&gt; 1 + 2 void
== ~[]~  ; anti
</code></pre>
<p>This has brought to the forefront the question of which combinators should support vanishing.</p>
<h2><a name="p-8211-right-now-if-end-matches-it-vanishes-1" class="anchor" href="../leaky-ghosts-what-combinators-should-vanish/2437.html#p-8211-right-now-if-end-matches-it-vanishes-1"></a>Right Now, If <code>&lt;END&gt;</code> Matches, it Vanishes</h2>
<pre><code>&gt;&gt; parse [a b] [word! &lt;end&gt;]
** Error: PARSE mismatch

&gt;&gt; parse [a] [word! &lt;end&gt;]
== a
</code></pre>
<p>That's very useful.</p>
<p>Should TO and THRU--when parameterized with something that vanishes--also vanish?</p>
<pre><code>&gt;&gt; parse [a #b #c] [word! to &lt;end&gt;]
== a
</code></pre>
<p>Seems pretty useful <em>on the surface</em>.  But TO and THRU are intrinsically looping constructs...they iterate their rules.  This means you could wind up with something that sometimes vanishes, and sometimes does not:</p>
<pre><code>&gt;&gt; rule: [integer! | elide text!]

&gt;&gt; parse [a #b #c "hi"] [var: [word!, thru rule]]
== a  ; VAR got the product of WORD!

&gt;&gt; parse [a #b #c 1020] [var: [word!, thru rule]]
== 1020  ; VAR got the product of THRU RULE
</code></pre>
<p>That's a bit disorienting, how an elide managed to leak out.  It's like the structure of the parse code isn't doing what you expect.</p>
<p>This is why the main evaluator's loops and branching constructs are not willing to vaporize when they stand alone.  They're only willing to produce VOID.  This keeps the basic structure of the code from picking up results you don't expect, unless you call something that specifically is known to have vanishing intent (and you can ask to convert voids to ghosts explicitly if you want).</p>
<p>Even invoking a rule BLOCK! itself--if you think of rule invocation as like PARSE's version of calling a lambda--raises some questions about "surprising" ghosts:</p>
<pre><code>&gt;&gt; rule: [integer! | elide text!]

&gt;&gt; parse [a #b #c "hi"] [var: [word!, rule]]
== a  ; VAR got the product of WORD!

&gt;&gt; parse [a #b #c 1020] [var: [word!, rule]]
== 1020  ; VAR got the product of RULE
</code></pre>
<p>Unfortunately PARSE doesn't have the analogue of the GROUP! vs. BLOCK! distinction for code, where one can be transparent and the other "surprising".   <strong><code>[elide some [rule1 | rule2]]</code></strong> can be genuinely useful as a source grouping.</p>
<h2><a name="p-8211-on-that-note-should-lambda-be-willing-to-vanish-2" class="anchor" href="../leaky-ghosts-what-combinators-should-vanish/2437.html#p-8211-on-that-note-should-lambda-be-willing-to-vanish-2"></a>On That Note, Should LAMBDA Be Willing To Vanish?</h2>
<p>At the moment, you get VOID and not GHOST from lambdas whose bodies vanish.</p>
<pre><code> &gt;&gt; test: lambda [] [comment "this is a test"]

 &gt;&gt; 1 + 2 test
 == ~[]~  ; anti (void)
</code></pre>
<p>It's hence impossible for a LAMBDA to produce a GHOST!... you have to use functions with a return value.  But does that make sense?</p>
<p><strong>I think I'm willing to say that lambdas and rule blocks can vanish.  They probably have to.</strong></p>
<p>But I'm just not 100% on board with the idea of this vanishing leaking out through other constructs.  It seems likely that you'd start getting "vanishing sometimes" behavior on accident.</p>
<p>So while it may seem nice if you're just looking at the specific case of <strong><code>to &lt;end&gt;</code></strong> vanishing, I think the long game favors saying that it's easy enough to write <strong><code>elide to &lt;end&gt;</code></strong> if you want.</p>
<p>Having plain <strong><code>&lt;end&gt;</code></strong> in isolation vanish is fine, because that's predictable and happens every time you use <strong><code>&lt;end&gt;</code></strong>.  But it wouldn't be so with vanishing every time you use TO... hence the problem with it.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

                <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../why-ghost-get-ghost-fails-and-tripwire-void/2234/5.html">Why (ghost? get $ghost) Fails (and TRIPWIRE, VOID)</a>
                        <meta itemprop='position' content='3'>
                      </div>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../how-to-choose-between-returning-ghost-and-void/2171/3.html">How To Choose Between Returning GHOST and VOID?</a>
                        <meta itemprop='position' content='4'>
                      </div>
                </div>
          </div>
          <div id='post_2' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2025-05-07T15:01:55Z' class='post-time'>
                    May 7, 2025,  3:01pm
                  </time>
                  <meta itemprop='dateModified' content='2025-05-07T15:01:55Z'>
              <span itemprop='position'>2</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2437">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But I'm just not 100% on board with the idea of this vanishing leaking out through other constructs. It seems likely that you'd start getting "vanishing sometimes" behavior on accident.</p>
</blockquote>
</aside>
<p>So I made a function called UNGHOST to help with this:</p>
<pre><code>&gt;&gt; 1 + 2 comment "HI"
== 3

&gt;&gt; 1 + 2 unghost comment "HI"
== ~[]~

&gt;&gt; 1 + 2 unghost 10 + 20
== 30
</code></pre>
<p>But then I noticed that most all of the combinators in UPARSE (that call subparsers) would have to end with <strong><code>return unghost ^result</code></strong> instead of just <strong><code>return result</code></strong>.</p>
<p>It feels redundant.  Because the pattern is: does the return spec have GHOST! in it, and if not, run UNGHOST.  So it might not hurt if FUNCTIONs which don't have GHOST! in their RETURN: spec would automatically convert ghosts to VOID.</p>
<p>I <em>could</em> make this something that just COMBINATORs do.  But because of the systemic "ghost suppression" bias I am feeling, I think it would be good for the health of the system overall.</p>
<h2><a name="p-8219-just-coerce-to-void-for-return-or-arguments-too-1" class="anchor" href="../leaky-ghosts-what-combinators-should-vanish/2437.html#p-8219-just-coerce-to-void-for-return-or-arguments-too-1"></a>Just Coerce To Void For RETURN, Or Arguments Too?</h2>
<p>While it seems helpful or at least benign for RETURN, I'm not sure if it's completely wise to make this a general rule for type checking... that anything which would take a VOID would be willing to accept a GHOST! converted to VOID:</p>
<pre><code>&gt;&gt; append [a b c] comment "is this bad?"
== [a b c]

&gt;&gt; append [a b c] ()
== [a b c]
</code></pre>
<p>It's not <em>obviously</em> terrible.  But it does kind of take off some guardrails, to where you might not be saying what you think you meant to say.</p>
<p>There's no immediate advantage that I can see, and it just seems to promote accidents.  So I think I'll limit it to return type coercion.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
          <div id='post_3' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2025-05-14T14:34:25Z' class='post-time'>
                    May 14, 2025,  2:34pm
                  </time>
                  <meta itemprop='dateModified' content='2025-05-20T06:05:18Z'>
              <span itemprop='position'>3</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2437">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Should TO and THRU--when parameterized with something that vanishes--also vanish?</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; parse [a #b #c] [word! to &lt;end&gt;]
== a
</code></pre>
<p>Seems pretty useful <em>on the surface</em>. But TO and THRU are intrinsically looping constructs...they iterate their rules. This means you could wind up with something that sometimes vanishes, and sometimes does not:</p>
</blockquote>
</aside>
<h2><a name="p-8279-we-can-get-the-best-of-both-worlds-1" class="anchor" href="../leaky-ghosts-what-combinators-should-vanish/2437.html#p-8279-we-can-get-the-best-of-both-worlds-1"></a>We Can Get The Best Of Both Worlds</h2>
<p>So the <a href="../how-to-choose-between-returning-ghost-and-void/2171/3.html">concept that I am putting forth</a> is that we treat functions differently based on their type signature.</p>
<ul>
<li>
<p>If a function returns ghosts <em>always</em> (an "unsurprising" ghost) then let them vanish.</p>
</li>
<li>
<p>If a function returns ghosts <em>sometimes</em> (a "surprising" ghost), then still produce a ghost... <strong>but don't vanish</strong>.</p>
</li>
</ul>
<p>At first I thought that <strong><code>^</code></strong> would be an operator for overriding the non-vanishing behavior, transforming surprising ghosts into unsurprising ones (humorously called UNAFRAID).</p>
<pre><code>&gt;&gt; parse [a #b #c] [word! to &lt;end&gt;]
== ~[]~  ; anti (void)

&gt;&gt; parse [a #b #c] [word! ^ to &lt;end&gt;]
== a
</code></pre>
<p>However, the much more useful application of that scarce operator is to approve <em>surprising actions</em>.  This is when ACTION! is returned by operations that don't always return actions, which will panic on assignment by default.  We don't want one operator to quell both surprises: that would mean people who simply meant to approve actions could end up wrecking the structure of their code on ghost appearances.</p>
<p>So if there's an UNAFRAID token, it will have to be something besides <strong><code>^</code></strong></p>
<h2><a name="p-8279-key-to-observe-unafraid-cant-be-a-combinator-2" class="anchor" href="../leaky-ghosts-what-combinators-should-vanish/2437.html#p-8279-key-to-observe-unafraid-cant-be-a-combinator-2"></a>Key To Observe: <code>UNAFRAID</code> Can't Be a Combinator</h2>
<p>What <code>UNAFRAID</code> has to be is like <code>|</code> and <code>||</code>... something the BLOCK! combinator specifically recognizes as it processes.</p>
<p>Unfortunately I feel like we're kind of out of symbols.  We do have the option of <strong><code>'</code></strong> making a resurrected appearance, but I don't think it's a good idea.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="1" />
              <span class='post-likes'>1 Like</span>
            </div>

          </div>
    </div>


    




    </div>
    <footer class="container wrap">
  <nav class='crawler-nav'>
    <ul>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/' itemprop="url">Home </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/categories' itemprop="url">Categories </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/guidelines' itemprop="url">Guidelines </a>
        </span>
      </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://rebol.metaeducation.com/tos' itemprop="url">Terms of Service </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://rebol.metaeducation.com/privacy' itemprop="url">Privacy Policy </a>
          </span>
        </li>
    </ul>
  </nav>
  <p class='powered-by-link'>Powered by <a href="https://www.discourse.org">Discourse</a>, best viewed with JavaScript enabled</p>
</footer>

    
    
  </body>
  
</html>

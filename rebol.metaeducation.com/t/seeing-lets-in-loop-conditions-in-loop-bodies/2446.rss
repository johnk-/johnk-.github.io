<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Seeing LETs In Loop Conditions In Loop Bodies</title>
    <link>https://rebol.metaeducation.com/t/seeing-lets-in-loop-conditions-in-loop-bodies/2446</link>
    <description>So I&#39;m really a fan of it when languages let you do things like introduce variables in loop conditions that are only visible in the body.

C99 actually lets you do this with `for` loops (not others, though):

    for (int x = 0; x &lt; 10; ++x) {
        printf(&quot;value is %d\n&quot;, x);  // this is legal
    }

So it would be nice if you could do something similar in Ren-C:

    while [let item: try take block] [
        print [item]
    ]

You can&#39;t do that today... the LET is only visible until the end of the condition scope.  So you have to write:

    let item
    while [item: try take block] [
        print [item]
    ]

That&#39;s not as nice. :frowning_with_open_mouth: 

## What Would It Take To Implement?

So it would be kind of tricky, in that the body block can be bound somewhere entirely radically different than the condition.  It could be using a whole different concept of LIB.

You don&#39;t want to overshadow the binding of the body with all of the context of the condition.  You&#39;d only want *just the diff*... any new definitions that appeared in the context chain while it was running.  But only those.

Arguably there are cases where people would not want to inherit the diff.  Creative uses of WHILE which put a lot of code in the condition might want to make variables that don&#39;t leak out.  But you could deal with that intent using a GROUP!

    let item: &lt;outside&gt;
    while [(let item: try take block)] [
        print [item]
    ]

Bizarro idea might be that GROUP!s themselves as conditions (or bodies) indicate you want transparency of diffed variables beyond the loop:

    while $(let item: try take block) [
        print [item]
    ]
    assert [item = null]  ; iteration exhausted, item still visible

That&#39;s a pretty wild idea... but it doesn&#39;t really have any precedent with what GROUP!s mean generally (e.g. (let x: 10) more generally won&#39;t leak the X out of the group, and it shouldn&#39;t.

## Generic Mechanism Would Need A Design

I could hack this behavior into WHILE.  But for all these things, I think it should be possible to do in your own constructs.

It means EVAL needs to have some kind of context return result that gives you a partial environment chain of what got added.

This could basically reuse an existing chain, by being a counter of how much of the chain was applicable if you followed the link.  This could go in the cell, and then be proxied into a stub if you actually used it.

It&#39;s desirable to do, so I&#39;ll put it on the infite list... :infinity:</description>
    
    <lastBuildDate>Sat, 07 Jun 2025 10:02:18 +0000</lastBuildDate>
    <category>Loops</category>
    <atom:link href="https://rebol.metaeducation.com/t/seeing-lets-in-loop-conditions-in-loop-bodies/2446.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Seeing LETs In Loop Conditions In Loop Bodies</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>So I'm really a fan of it when languages let you do things like introduce variables in loop conditions that are only visible in the body.</p>
<p>C99 actually lets you do this with <code>for</code> loops (not others, though):</p>
<pre><code>for (int x = 0; x &lt; 10; ++x) {
    printf("value is %d\n", x);  // this is legal
}
</code></pre>
<p>So it would be nice if you could do something similar in Ren-C:</p>
<pre><code>while [let item: try take block] [
    print [item]
]
</code></pre>
<p>You can't do that today... the LET is only visible until the end of the condition scope.  So you have to write:</p>
<pre><code>let item
while [item: try take block] [
    print [item]
]
</code></pre>
<p>That's not as nice. <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning_with_open_mouth.png?v=14" title=":frowning_with_open_mouth:" class="emoji" alt=":frowning_with_open_mouth:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8260-what-would-it-take-to-implement-1" class="anchor" href="https://rebol.metaeducation.com#p-8260-what-would-it-take-to-implement-1"></a>What Would It Take To Implement?</h2>
<p>So it would be kind of tricky, in that the body block can be bound somewhere entirely radically different than the condition.  It could be using a whole different concept of LIB.</p>
<p>You don't want to overshadow the binding of the body with all of the context of the condition.  You'd only want <em>just the diff</em>... any new definitions that appeared in the context chain while it was running.  But only those.</p>
<p>Arguably there are cases where people would not want to inherit the diff.  Creative uses of WHILE which put a lot of code in the condition might want to make variables that don't leak out.  But you could deal with that intent using a GROUP!</p>
<pre><code>let item: &lt;outside&gt;
while [(let item: try take block)] [
    print [item]
]
</code></pre>
<p>Bizarro idea might be that GROUP!s themselves as conditions (or bodies) indicate you want transparency of diffed variables beyond the loop:</p>
<pre><code>while $(let item: try take block) [
    print [item]
]
assert [item = null]  ; iteration exhausted, item still visible
</code></pre>
<p>That's a pretty wild idea... but it doesn't really have any precedent with what GROUP!s mean generally (e.g. (let x: 10) more generally won't leak the X out of the group, and it shouldn't.</p>
<h2><a name="p-8260-generic-mechanism-would-need-a-design-2" class="anchor" href="https://rebol.metaeducation.com#p-8260-generic-mechanism-would-need-a-design-2"></a>Generic Mechanism Would Need A Design</h2>
<p>I could hack this behavior into WHILE.  But for all these things, I think it should be possible to do in your own constructs.</p>
<p>It means EVAL needs to have some kind of context return result that gives you a partial environment chain of what got added.</p>
<p>This could basically reuse an existing chain, by being a counter of how much of the chain was applicable if you followed the link.  This could go in the cell, and then be proxied into a stub if you actually used it.</p>
<p>It's desirable to do, so I'll put it on the infite list... <img src="https://rebol.metaeducation.com/images/emoji/twitter/infinity.png?v=14" title=":infinity:" class="emoji" alt=":infinity:" loading="lazy" width="20" height="20"></p>
          <p><a href="https://rebol.metaeducation.com/t/seeing-lets-in-loop-conditions-in-loop-bodies/2446/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/seeing-lets-in-loop-conditions-in-loop-bodies/2446/1</link>
        <pubDate>Sun, 11 May 2025 18:57:47 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2446-1</guid>
        <source url="https://rebol.metaeducation.com/t/seeing-lets-in-loop-conditions-in-loop-bodies/2446.rss">Seeing LETs In Loop Conditions In Loop Bodies</source>
      </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Making RANDOM Less Random :thinking:</title>
    <link>https://rebol.metaeducation.com/t/making-random-less-random/2375</link>
    <description>Historical RANDOM in Rebol is a hodgepodge, which Red carried forward:

    red&gt;&gt; help random
    USAGE:
         RANDOM value

    DESCRIPTION: 
         Returns a random value of the same datatype; or shuffles series. 
         RANDOM is an action! value.

    ARGUMENTS:
         value         &quot;Maximum value of result (modified when series).&quot;

    REFINEMENTS:
         /seed        =&gt; Restart or randomize.
         /secure      =&gt; Returns a cryptographically secure random number.
         /only        =&gt; Pick a random value from a series.

    RETURNS:
         [any-type!]

What the function does can vary significantly based on the refinements and argument:

    &gt;&gt; random 10
    == 5  ; just picks an integer from 1 to 10 inclusive

    &gt;&gt; block: [a b c]

    &gt;&gt; random block
    == [c b a]  ; e.g. default behavior for block is SHUFFLE

    &gt;&gt; block
    == [c b a]  ; and it&#39;s a mutating shuffle.

    &gt;&gt; random/only block
    == b  ; so /only makes it pick an element out of blocks

    &gt;&gt; random/seed [a b c] 
    ; no return value, just makes the next values deterministic

That&#39;s just crazy.  :zany_face:   Not only is it hard to predict what it&#39;s going to do, but the type specs don&#39;t tell you what the return values are.

As part of transitioning RANDOM to [&quot;New Generics&quot;](https://rebol.metaeducation.com/t/further-optimizations-of-breaking-the-64-type-barrier/2369) I decided to go ahead and split this up.

## SHUFFLE, RANDOM, RANDOMIZE, RANDOM-PICK

* RANDOM:SEED =&gt; RANDOMIZE
* RANDOM:ONLY =&gt; RANDOM-PICK
* RANDOM =&gt; if it shuffled a series, SHUFFLE, else RANDOM

Then I&#39;ve added another routine SHUFFLE-OF which works on immutable types, making a new shuffled copy.  And the way it works is that if you use SHUFFLE-OF on a type that doesn&#39;t have a tailored implementation of it, then it falls back and tries to do it as SHUFFLE COPY.

    &gt;&gt; path: &#39;a/b/c/d

    &gt;&gt; shuffle path
    ** Error: PATH! is immutable

    &gt;&gt; shuffle of path
    == c/d/a/b  ; uses the SHUFFLE-OF registered for ANY-SEQUENCE?

    &gt;&gt; block: [a b c d]

    &gt;&gt; shuffle of block
    == [b d c a]  ; no SHUFFLE-OF for ANY-LIST?, falls back on SHUFFLE COPY

    &gt;&gt; block
    == [a b c d]

I also thought it would be useful to have RANDOM-BETWEEN, because then you can say what the min and max values are without needing to do math on a 1-based RANDOM result:

    &gt;&gt; random-between 5 10
    == 7

## Further Directions: RANDOM Dialect?

In this formulation so far, RANDOM on a BLOCK! has no meaning.

That made me wonder about whether RANDOM should be dialected when you pass it a block:

    random [between 10 and 20]

    random [between 10 and 20 distribution &#39;normal]

    random [weighted [[&quot;A&quot; 0.7] [&quot;B&quot; 0.2] [&quot;C&quot; 0.1]]]

Dialects of this kind have proven very difficult to design, and we&#39;ve only got a few of them.  Once you move things out of the domain of simple functions you make them harder to specialize/adapt/cascade, and you wind up doing work that the evaluator takes care of for you with a function.

But I do think that looks nice, and is something to think about for the future.</description>
    
    <lastBuildDate>Sat, 22 Mar 2025 15:33:35 +0000</lastBuildDate>
    <category>Math</category>
    <atom:link href="https://rebol.metaeducation.com/t/making-random-less-random/2375.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Making RANDOM Less Random :thinking:</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Historical RANDOM in Rebol is a hodgepodge, which Red carried forward:</p>
<pre><code>red&gt;&gt; help random
USAGE:
     RANDOM value

DESCRIPTION: 
     Returns a random value of the same datatype; or shuffles series. 
     RANDOM is an action! value.

ARGUMENTS:
     value         "Maximum value of result (modified when series)."

REFINEMENTS:
     /seed        =&gt; Restart or randomize.
     /secure      =&gt; Returns a cryptographically secure random number.
     /only        =&gt; Pick a random value from a series.

RETURNS:
     [any-type!]
</code></pre>
<p>What the function does can vary significantly based on the refinements and argument:</p>
<pre><code>&gt;&gt; random 10
== 5  ; just picks an integer from 1 to 10 inclusive

&gt;&gt; block: [a b c]

&gt;&gt; random block
== [c b a]  ; e.g. default behavior for block is SHUFFLE

&gt;&gt; block
== [c b a]  ; and it's a mutating shuffle.

&gt;&gt; random/only block
== b  ; so /only makes it pick an element out of blocks

&gt;&gt; random/seed [a b c] 
; no return value, just makes the next values deterministic
</code></pre>
<p>That's just crazy.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/zany_face.png?v=14" title=":zany_face:" class="emoji" alt=":zany_face:" loading="lazy" width="20" height="20">   Not only is it hard to predict what it's going to do, but the type specs don't tell you what the return values are.</p>
<p>As part of transitioning RANDOM to <a href="https://rebol.metaeducation.com/t/further-optimizations-of-breaking-the-64-type-barrier/2369">"New Generics"</a> I decided to go ahead and split this up.</p>
<h2><a name="p-8048-shuffle-random-randomize-random-pick-1" class="anchor" href="https://rebol.metaeducation.com#p-8048-shuffle-random-randomize-random-pick-1"></a>SHUFFLE, RANDOM, RANDOMIZE, RANDOM-PICK</h2>
<ul>
<li>RANDOM:SEED =&gt; RANDOMIZE</li>
<li>RANDOM:ONLY =&gt; RANDOM-PICK</li>
<li>RANDOM =&gt; if it shuffled a series, SHUFFLE, else RANDOM</li>
</ul>
<p>Then I've added another routine SHUFFLE-OF which works on immutable types, making a new shuffled copy.  And the way it works is that if you use SHUFFLE-OF on a type that doesn't have a tailored implementation of it, then it falls back and tries to do it as SHUFFLE COPY.</p>
<pre><code>&gt;&gt; path: 'a/b/c/d

&gt;&gt; shuffle path
** Error: PATH! is immutable

&gt;&gt; shuffle of path
== c/d/a/b  ; uses the SHUFFLE-OF registered for ANY-SEQUENCE?

&gt;&gt; block: [a b c d]

&gt;&gt; shuffle of block
== [b d c a]  ; no SHUFFLE-OF for ANY-LIST?, falls back on SHUFFLE COPY

&gt;&gt; block
== [a b c d]
</code></pre>
<p>I also thought it would be useful to have RANDOM-BETWEEN, because then you can say what the min and max values are without needing to do math on a 1-based RANDOM result:</p>
<pre><code>&gt;&gt; random-between 5 10
== 7
</code></pre>
<h2><a name="p-8048-further-directions-random-dialect-2" class="anchor" href="https://rebol.metaeducation.com#p-8048-further-directions-random-dialect-2"></a>Further Directions: RANDOM Dialect?</h2>
<p>In this formulation so far, RANDOM on a BLOCK! has no meaning.</p>
<p>That made me wonder about whether RANDOM should be dialected when you pass it a block:</p>
<pre><code>random [between 10 and 20]

random [between 10 and 20 distribution 'normal]

random [weighted [["A" 0.7] ["B" 0.2] ["C" 0.1]]]
</code></pre>
<p>Dialects of this kind have proven very difficult to design, and we've only got a few of them.  Once you move things out of the domain of simple functions you make them harder to specialize/adapt/cascade, and you wind up doing work that the evaluator takes care of for you with a function.</p>
<p>But I do think that looks nice, and is something to think about for the future.</p>
          <p><a href="https://rebol.metaeducation.com/t/making-random-less-random/2375/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/making-random-less-random/2375/1</link>
        <pubDate>Thu, 20 Mar 2025 16:46:50 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2375-1</guid>
        <source url="https://rebol.metaeducation.com/t/making-random-less-random/2375.rss">Making RANDOM Less Random :thinking:</source>
      </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>LIFT:LITE - When You Don&#39;t Want Quasiforms</title>
    <link>https://rebol.metaeducation.com/t/lift-lite-when-you-dont-want-quasiforms/2296</link>
    <description>There was a time before quasiforms existed, but where there was generic quoting.

It was in this time that LIFT was invented.  It did the only thing it could do:

* When you LIFT-ed a plain (or quoted) thing, it got one quote level added

* When you UNLIFT-ed an &quot;antiform&quot; you would get a plain version of the thing

So it worked like this:

    &gt;&gt; lift first [(d e f)]
    == &#39;(d e f)

    &gt;&gt; lift first [&#39;(d e f)]
    == &#39;&#39;(d e f)

    &gt;&gt; spread [a b c]
    == \(a b c)\  ; antiform

    &gt;&gt; lift spread [a b c]
    == (a b c)

*(That&#39;s not how it works now--for good reasons.  Not only is it a bit too easy to get confused about whether a meta protocol is in effect, the absence of quasiforms leaves a representational hole for values that produce antiforms under evaluation.  But I won&#39;t rewrite a [A Justification Of Generalized Iostopes](https://rebol.metaeducation.com/t/a-justification-of-generalized-isotopes/1918) here, this post has another purpose.)*

## Another Historical Twist: LIFT of NULL was NULL

NULL was an outlier--at various times having no quoted form (and at other times being considered a quote of nothingness, e.g. the lone apostrophe (**`&#39;`**)).

I don&#39;t exactly remember what state NULL was in at the time LIFT was being invented.  But regardless, it was initially decided that LIFT and UNLIFT of NULL could just give null back.

This actually turned out to frequently be useful...for instance [when writing a loop wrapper like FOR-BOTH](https://rebol.metaeducation.com/t/demonstrating-for-both-loop-composability-for-the-win/1833)

    for-both: func [var blk1 blk2 body] [  ; the historical formulation
        return unlift all [
            lift for-each var blk1 body  ; LIFT NULL =&gt; NULL allows chaining BREAK
            lift for-each var blk2 body
        ]
    ]

Though while it was useful there, plenty of places needed to speak fully abstractly about all possible states.  So as the model shaped up, LIFT of NULL fit into the regular pattern of all things having reified lifts, giving **`~null~`**.

## [I Wanted A LIFT:LITE](https://www.youtube.com/watch?v=Imv0g-4cycw)

The idea of a LIFT variation that passed through keywords as-is came along as **`lift:lite`**.

    &gt;&gt; lift:lite [a b c]
    == &#39;[a b c]

    &gt;&gt; spread [a b c]
    == \~(a b c)~\  ; antiform

    &gt;&gt; lift:lite spread [a b c]
    == ~(a b c)~

    &gt;&gt; lift:lite null
    == \~null~\  ; antiform

    &gt;&gt; lift:lite first [~null~ ~void~]
    == &#39;~null~

So today&#39;s LIFT:LITE still produces quasiforms for antiforms--just not for the `~null~` and `~[]~` void antiforms (and I now imagine it should probably pass through `~okay~` and `~NaN~` as well):

    for-both: func [var blk1 blk2 body] [
        return unlift:lite all [
            lift:lite for-each var blk1 body  ; lift:lite null =&gt; ~null~ antiform
            lift:lite for-each var blk2 body  ; lift:lite void =&gt; ~[]~ antiform
        ]
    ]

## But What If LIFT:LITE Didn&#39;t Make *Any* Quasiforms At All?

By design, [quasiforms are not very friendly](https://rebol.metaeducation.com/t/quasiforms-arent-super-friendly-and-they-shouldnt-be/2273).  So if you have an antiform in your hand... and you know you have an antiform in your hand... it&#39;s easy to take a step to a quasiform, but you need another step to get back to a plain form you can interact with.

So why not have LIFT:LITE take care of it?

    &gt;&gt; lift:lite null
    == \~null~\  ; antiform

    &gt;&gt; lift:lite spread [a b c]
    == (a b c)

This doesn&#39;t make a difference to things like FOR-BOTH.  They&#39;ll still work--plain forms are just as truthy as quasiforms for the lifted states.  They just have to remember to use UNLIFT:LITE on the reverse end.  *(If you use plain UNLIFT it will catch your error, as UNLIFT does not accept plain forms.)*

It might seem random to pair up the feature of not making quasiforms with passing thru null and void.  But I actually think the kinds of places where you&#39;d want one behavior do overlap significantly with the other.

And we&#39;re really just running out of terms, here.  Throwing another nuance in to say *&quot;I want partial LIFT, but only partial in the sense that I&#39;m passing through null and void, not partial in terms of the other antiforms--make those quasiforms&quot;* is just starting to go beyond the ability to give names to.

So in my head, having LIFT:LITE be formulated as &quot;do what LIFT would do in a historical world where quasiforms and meta-nulls didn&#39;t exist&quot; feels pretty good.

## It&#39;s Still Fundamentally a &quot;Valid LIFT&quot;

I couldn&#39;t really think of a good name for the operation besides just saying it was an alternate behavior of LIFT. &quot;Lite&quot; is a bit strange but I felt it fit.

Note that it doesn&#39;t make sense as a refinement to REIFY.  Because being willing to produce something that can&#39;t be put in a block fundamentally undermines what the word REIFY means.  (**`reify:...NOT!`**)

The thing about LIFT:LITE is that it really is giving you a full-spectrum meta representation of what you had in your hand.  Every input state maps to a unique output state.  The default LIFT happens to also be a fully reifying operation as well...but here we are saying that&#39;s not intrinsic to &quot;a meta operation&quot;.

*(Would there be any use for a LIFT that passes through *all* antiforms--not just the antiform words--and just quotes everything else?  That&#39;s more a variation of QUOTE than it is a variation of LIFT.  I can&#39;t offhand think of a case where that would ever be useful.)*</description>
    
    <lastBuildDate>Sun, 01 Jun 2025 19:28:25 +0000</lastBuildDate>
    <category>Semantics</category>
    <atom:link href="https://rebol.metaeducation.com/t/lift-lite-when-you-dont-want-quasiforms/2296.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>LIFT:LITE - When You Don&#39;t Want Quasiforms</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>There was a time before quasiforms existed, but where there was generic quoting.</p>
<p>It was in this time that LIFT was invented.  It did the only thing it could do:</p>
<ul>
<li>
<p>When you LIFT-ed a plain (or quoted) thing, it got one quote level added</p>
</li>
<li>
<p>When you UNLIFT-ed an "antiform" you would get a plain version of the thing</p>
</li>
</ul>
<p>So it worked like this:</p>
<pre><code>&gt;&gt; lift first [(d e f)]
== '(d e f)

&gt;&gt; lift first ['(d e f)]
== ''(d e f)

&gt;&gt; spread [a b c]
== \(a b c)\  ; antiform

&gt;&gt; lift spread [a b c]
== (a b c)
</code></pre>
<p><em>(That's not how it works now--for good reasons.  Not only is it a bit too easy to get confused about whether a meta protocol is in effect, the absence of quasiforms leaves a representational hole for values that produce antiforms under evaluation.  But I won't rewrite a <a href="https://rebol.metaeducation.com/t/a-justification-of-generalized-isotopes/1918">A Justification Of Generalized Iostopes</a> here, this post has another purpose.)</em></p>
<h2><a name="p-7760-another-historical-twist-lift-of-null-was-null-1" class="anchor" href="https://rebol.metaeducation.com#p-7760-another-historical-twist-lift-of-null-was-null-1"></a>Another Historical Twist: LIFT of NULL was NULL</h2>
<p>NULL was an outlier--at various times having no quoted form (and at other times being considered a quote of nothingness, e.g. the lone apostrophe (<strong><code>'</code></strong>)).</p>
<p>I don't exactly remember what state NULL was in at the time LIFT was being invented.  But regardless, it was initially decided that LIFT and UNLIFT of NULL could just give null back.</p>
<p>This actually turned out to frequently be useful...for instance <a href="https://rebol.metaeducation.com/t/demonstrating-for-both-loop-composability-for-the-win/1833">when writing a loop wrapper like FOR-BOTH</a></p>
<pre><code>for-both: func [var blk1 blk2 body] [  ; the historical formulation
    return unlift all [
        lift for-each var blk1 body  ; LIFT NULL =&gt; NULL allows chaining BREAK
        lift for-each var blk2 body
    ]
]
</code></pre>
<p>Though while it was useful there, plenty of places needed to speak fully abstractly about all possible states.  So as the model shaped up, LIFT of NULL fit into the regular pattern of all things having reified lifts, giving <strong><code>~null~</code></strong>.</p>
<h2><a name="p-7760-i-wanted-a-liftlitehttpswwwyoutubecomwatchvimv0g-4cycw-2" class="anchor" href="https://rebol.metaeducation.com#p-7760-i-wanted-a-liftlitehttpswwwyoutubecomwatchvimv0g-4cycw-2"></a><a href="https://www.youtube.com/watch?v=Imv0g-4cycw">I Wanted A LIFT:LITE</a></h2>
<p>The idea of a LIFT variation that passed through keywords as-is came along as <strong><code>lift:lite</code></strong>.</p>
<pre><code>&gt;&gt; lift:lite [a b c]
== '[a b c]

&gt;&gt; spread [a b c]
== \~(a b c)~\  ; antiform

&gt;&gt; lift:lite spread [a b c]
== ~(a b c)~

&gt;&gt; lift:lite null
== \~null~\  ; antiform

&gt;&gt; lift:lite first [~null~ ~void~]
== '~null~
</code></pre>
<p>So today's LIFT:LITE still produces quasiforms for antiforms--just not for the <code>~null~</code> and <code>~[]~</code> void antiforms (and I now imagine it should probably pass through <code>~okay~</code> and <code>~NaN~</code> as well):</p>
<pre><code>for-both: func [var blk1 blk2 body] [
    return unlift:lite all [
        lift:lite for-each var blk1 body  ; lift:lite null =&gt; ~null~ antiform
        lift:lite for-each var blk2 body  ; lift:lite void =&gt; ~[]~ antiform
    ]
]
</code></pre>
<h2><a name="p-7760-but-what-if-liftlite-didnt-make-any-quasiforms-at-all-3" class="anchor" href="https://rebol.metaeducation.com#p-7760-but-what-if-liftlite-didnt-make-any-quasiforms-at-all-3"></a>But What If LIFT:LITE Didn't Make <em>Any</em> Quasiforms At All?</h2>
<p>By design, <a href="https://rebol.metaeducation.com/t/quasiforms-arent-super-friendly-and-they-shouldnt-be/2273">quasiforms are not very friendly</a>.  So if you have an antiform in your hand... and you know you have an antiform in your hand... it's easy to take a step to a quasiform, but you need another step to get back to a plain form you can interact with.</p>
<p>So why not have LIFT:LITE take care of it?</p>
<pre><code>&gt;&gt; lift:lite null
== \~null~\  ; antiform

&gt;&gt; lift:lite spread [a b c]
== (a b c)
</code></pre>
<p>This doesn't make a difference to things like FOR-BOTH.  They'll still work--plain forms are just as truthy as quasiforms for the lifted states.  They just have to remember to use UNLIFT:LITE on the reverse end.  <em>(If you use plain UNLIFT it will catch your error, as UNLIFT does not accept plain forms.)</em></p>
<p>It might seem random to pair up the feature of not making quasiforms with passing thru null and void.  But I actually think the kinds of places where you'd want one behavior do overlap significantly with the other.</p>
<p>And we're really just running out of terms, here.  Throwing another nuance in to say <em>"I want partial LIFT, but only partial in the sense that I'm passing through null and void, not partial in terms of the other antiforms--make those quasiforms"</em> is just starting to go beyond the ability to give names to.</p>
<p>So in my head, having LIFT:LITE be formulated as "do what LIFT would do in a historical world where quasiforms and meta-nulls didn't exist" feels pretty good.</p>
<h2><a name="p-7760-its-still-fundamentally-a-valid-lift-4" class="anchor" href="https://rebol.metaeducation.com#p-7760-its-still-fundamentally-a-valid-lift-4"></a>It's Still Fundamentally a "Valid LIFT"</h2>
<p>I couldn't really think of a good name for the operation besides just saying it was an alternate behavior of LIFT. "Lite" is a bit strange but I felt it fit.</p>
<p>Note that it doesn't make sense as a refinement to REIFY.  Because being willing to produce something that can't be put in a block fundamentally undermines what the word REIFY means.  (<strong><code>reify:...NOT!</code></strong>)</p>
<p>The thing about LIFT:LITE is that it really is giving you a full-spectrum meta representation of what you had in your hand.  Every input state maps to a unique output state.  The default LIFT happens to also be a fully reifying operation as well...but here we are saying that's not intrinsic to "a meta operation".</p>
<p><em>(Would there be any use for a LIFT that passes through <em>all</em> antiforms--not just the antiform words--and just quotes everything else?  That's more a variation of QUOTE than it is a variation of LIFT.  I can't offhand think of a case where that would ever be useful.)</em></p>
          <p><a href="https://rebol.metaeducation.com/t/lift-lite-when-you-dont-want-quasiforms/2296/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/lift-lite-when-you-dont-want-quasiforms/2296/1</link>
        <pubDate>Mon, 23 Sep 2024 13:42:44 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2296-1</guid>
        <source url="https://rebol.metaeducation.com/t/lift-lite-when-you-dont-want-quasiforms/2296.rss">LIFT:LITE - When You Don&#39;t Want Quasiforms</source>
      </item>
  </channel>
</rss>

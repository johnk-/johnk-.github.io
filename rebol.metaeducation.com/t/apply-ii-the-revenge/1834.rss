<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>APPLY II: The Revenge!</title>
    <link>https://rebol.metaeducation.com/t/apply-ii-the-revenge/1834</link>
    <description>I&#39;d said *&quot;It&#39;s time to bring back APPLY&quot;*.  

...and by *&quot;it&#39;s time&quot;* I apparently meant *&quot;within the next year, maybe?&quot;*...

But better late than never, right?  It&#39;s in!

## Refinements Can be Provided In Any Order

    [a b c d e d e] = apply append/ [[a b c] [d e] dup: 2]
    [a b c d e d e] = apply append/ [dup: 2 [a b c] [d e]]
    [a b c d e d e] = apply append/ [[a b c] dup: 2 [d e]]

    [a b c d d] = apply append/ [dup: 2 [a b c] [d e] part: 1]
    [a b c d d] = apply append/ [[a b c] [d e] part: 1 dup: 2]

## Any Parameter (Not Just Refinements) Can Be Used By Name

Once a parameter has been supplied by name, it is no longer considered for consuming positionally.

    [a b c d e] = apply append/ [series: [a b c] value: [d e]]
    [a b c d e] = apply append/ [value: [d e] series: [a b c]]

    [a b c d e] = apply append/ [series: [a b c] [d e]]
    [a b c d e] = apply append/ [value: [d e] [a b c]]

## Commas Are Ok So Long As They Are Interstitial

    [a b c d e d e] = apply append/ [[a b c], [d e], dup: 2]
    [a b c d e d e] = apply append/ [dup: 2, [a b c] [d e]]

    &gt;&gt; apply :append [dup:, 2 [a b c] [d e]]
    ** Script Error: end was reached while trying to set dup:

## Giving Too Many Arguments Defaults To An Error

    &gt;&gt; apply append/ [[a b c] [d e] [f g]]
    ** Script Error: Too many values in processed argument block of APPLY.

If you want, you can ask it to :RELAX

    &gt;&gt; apply:relax append/ [[a b c] [d e] [f g]]
    == [a b c [d e]] 

## SET-WORD Must Be Followed By A Non-SET-WORD

    &gt;&gt; apply append/ [dup: part: 1 [a b c] [d e]]
    ** Script Error: end was reached while trying to set dup:

But you can pass SET-WORD as arguments to refinements...just use a quote! (or a `$` if you want to bind it)

    &gt;&gt; tester: func [:refine [any-value!]] [refine]

    &gt;&gt; apply tester/ [refine: &#39;ta-da!:]
    == ta-da!:

## No-Arg Refinements Permit OKAY and NULL

Remember: *the EVAL FRAME! mechanics do not change anything.*  So if a refinement doesn&#39;t take an argument, [the only legal values for that refinement in the frame are OKAY and NULL](https://rebol.metaeducation.com/t/why-no-argument-refinements-are-okay-or-null/735).

    &gt;&gt; testme: func [:refine] [refine]

    &gt;&gt; apply testme/ [refine: okay]
    == \~okay~\  ; antiform

    &gt;&gt; apply testme/ [refine: null]
    == \~null~\  ; antiform

    &gt;&gt; apply testme/ [refine: 1020]
    ** Error: No-Arg refinements can only be ~okay~ and ~null~ antiforms

## ^META Arguments Are Accounted For

APPLY detects when a parameter is meta and handles it for positional arguments:

    &gt;&gt; non-detector: func [arg] [arg]  ; not a meta argument, no unstable antiforms

    &gt;&gt; apply non-detector/ [pack [10 20]]
    == 10

    &gt;&gt; detector: func [^arg] [^arg]  ; unstable antiforms allowed

    &gt;&gt; apply detector/ [pack [10 20]]
    == \~[&#39;10 &#39;20]~\  ; antiform

**I know not everyone has gotten their heads around isotopes yet, but they are critical... this stuff was the missing link to making it all gel.**

:dizzy: :dizzy: :dizzy:</description>
    
    <lastBuildDate>Wed, 16 Jul 2025 01:36:28 +0000</lastBuildDate>
    <category>Feature Discover</category>
    <atom:link href="https://rebol.metaeducation.com/t/apply-ii-the-revenge/1834.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>APPLY II: The Revenge!</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <h2><a name="p-8523-follow-up-apply-and-parameter-conventions-1" class="anchor" href="https://rebol.metaeducation.com#p-8523-follow-up-apply-and-parameter-conventions-1"></a>Follow-Up: APPLY And Parameter Conventions</h2>
<p>Historical APPLY has <em>not</em> taken parameter conventions into account.</p>
<p>So for instance: if you have a literal parameter (denoted by a quote mark) that has not been taken into account by the APPLY operation.</p>
<p>Should it?  It seems like maybe it should, so that <strong><code>foo // [baz bar]</code></strong> would be a synonym for <strong><code>foo baz bar</code></strong>, and maybe there should be a refinement to APPLY which lets you say not to take the parameter convention into account.</p>
<p>That may make sense for literal parameters, but what about ^META parameterization?</p>
<p>It could be based on whether you use <strong><code>^arg:</code></strong> or <strong><code>arg:</code></strong> or no label at all.</p>
<p>For example:</p>
<pre><code>metathing: func [^arg [pack! integer!]] [  ; sees packs, or plain integers
    probe arg
]

&gt;&gt; metathing // [pack [1 2]]
~['1 '2]~  ; anti

&gt;&gt; metathing // [arg: pack [1 2]]
1

&gt;&gt; metathing // [^arg: pack [1 2]]
~['1 '2]~  ; anti
</code></pre>
<p>How big a deal is this?  Errrrm.  Well, lifted refinements are rare (incredibly so right now, as they're not legal and none have ever been made).</p>
<h2><a name="p-8523-the-same-issue-applies-to-specialize-2" class="anchor" href="https://rebol.metaeducation.com#p-8523-the-same-issue-applies-to-specialize-2"></a>The Same Issue Applies to SPECIALIZE</h2>
<p>Right now, SPECIALIZE is very lax.  It binds the block of specializing code into the frame it is specializing.  You can run loops or do whatever you want.  This is not like APPLY... which does its own dialected interpretation of the block.</p>
<p>If SPECIALIZE runs generalized code in the frame, you would have to use lifted assignments to set the fields <strong>(^xxx: ...)</strong>.  If it was just dialected and mandated you write the code as <strong><code>[arg1: ... arg2: ...]</code></strong> then it might try the strategy I'm suggesting, where undecorated assignments decay, and <strong><code>^arg:</code></strong> assignments did not.  (This would present a thorn for specializing with a raised error, since a strict format would have nowhere to put a TRY...)</p>
<p>This is a tough call.  I can see uses for both kinds of operations, and that goes for APPLY as well (I called the run-arbitrary-code-version "APPLIQUE").</p>
<p>It would be nice if you could SPECIALIZE based on just order of args without naming them, like <strong><code>specialize add/ [5]</code></strong>... perhaps even leveraging trash to skip slots as <strong><code>specialize subtract/ [~ 10]</code></strong> (this starts to <a href="https://rebol.metaeducation.com/t/looking-into-a-usermode-pointfree/1236">tread on the turf of POINTFREE</a>, but that is proposed as a more complex operation that can do more than one layer of specialization).</p>
<p><em>(As a quick aside, I'll mention that <em>maybe</em> it would be possible to bind things like <strong><code>1:</code></strong> and <strong><code>^2:</code></strong> such that they could be used in SPECIALIZE or APPLY to refer to that Nth argument.  I can imagine ways this could work, but at this point it's just imagination.)</em></p>
<h2><a name="p-8523-common-case-likely-favors-dialected-interpretation-3" class="anchor" href="https://rebol.metaeducation.com#p-8523-common-case-likely-favors-dialected-interpretation-3"></a>Common Case Likely Favors Dialected Interpretation</h2>
<p>Experience dictates that the most common uses of specialize are things like:</p>
<pre><code>first: specialize pick/ [picker: 1]
</code></pre>
<p>It seems like a shame for it to be any worse than that.  Further, in this dialected interpretation I <em>know</em> how to make things like <code>1:</code> and <code>^2:</code> work--it's trivial because there's no binding in play, you're just walking a block and filling in a known FRAME!, grabbing a SET-XXX and then doing one step of eval each time.  This also means you could write something like:</p>
<pre><code>picker: 10
first: specialize pick/ [picker: picker - 9]
</code></pre>
<p>...since there's no binding needed for the frame fields, you can assume each expression being evaluated is bound in the active environment.</p>
<p>So what to call the version that binds a frame, and makes you use <strong><code>^picker:</code></strong> but lets you write more freeform code?  It could be <strong><code>specialize:freeform</code></strong> or <strong><code>specialize:code</code></strong> or something, shorthanded as <strong><code>specialize*</code></strong>.  Then APPLY would have a parallel notation (APPLIQUE was never meant to stick around...)</p>
          <p><a href="https://rebol.metaeducation.com/t/apply-ii-the-revenge/1834/10">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/apply-ii-the-revenge/1834/10</link>
        <pubDate>Wed, 16 Jul 2025 01:36:28 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1834-10</guid>
        <source url="https://rebol.metaeducation.com/t/apply-ii-the-revenge/1834.rss">APPLY II: The Revenge!</source>
      </item>
      <item>
        <title>APPLY II: The Revenge!</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>6 posts were split to a new topic: <a href="https://rebol.metaeducation.com/t/naming-the-infix-apply-operator/2195">Naming The Infix APPLY Operator</a></p>
          <p><a href="https://rebol.metaeducation.com/t/apply-ii-the-revenge/1834/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/apply-ii-the-revenge/1834/3</link>
        <pubDate>Tue, 20 Aug 2024 06:13:42 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1834-3</guid>
        <source url="https://rebol.metaeducation.com/t/apply-ii-the-revenge/1834.rss">APPLY II: The Revenge!</source>
      </item>
      <item>
        <title>APPLY II: The Revenge!</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>A post was split to a new topic: <a href="https://rebol.metaeducation.com/t/critiquing-reds-updated-apply-implementation/2194">Critiquing Red's Updated APPLY Implementation</a></p>
          <p><a href="https://rebol.metaeducation.com/t/apply-ii-the-revenge/1834/8">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/apply-ii-the-revenge/1834/8</link>
        <pubDate>Tue, 20 Aug 2024 06:05:43 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1834-8</guid>
        <source url="https://rebol.metaeducation.com/t/apply-ii-the-revenge/1834.rss">APPLY II: The Revenge!</source>
      </item>
      <item>
        <title>APPLY II: The Revenge!</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>And now APPLY has an infix shorthand...</p>
<h2><a name="p-7329-meet-the-operator-1" class="anchor" href="https://rebol.metaeducation.com#p-7329-meet-the-operator-1"></a>Meet The <strong><code>//</code></strong> Operator!</h2>
<p>The choice to use slashes for the operator became obvious, now that <strong><a href="https://rebol.metaeducation.com/t/big-alien-proposal-word-runs-functions/1905/2"><code>/WORD</code> Runs Functions</a></strong></p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; append // [[a b c] &lt;d&gt; dup: 2]
== [a b c &lt;d&gt; &lt;d&gt;]

&gt;&gt; append // [dup: 2 [a b c] spread [e f]]
== [a b c e f e f]

&gt;&gt; append:dup // [[a b c] [e f] 2]
== [a b c [e f] [e f]]
</code></pre>
<p>It's strange but also it's a mixture of heavy and light, as a kind of "joiner" or concatenator, almost as if you were sticking the things together into a single thought.</p>
<pre><code>append//[[a b c] &lt;d&gt; dup: 2]
</code></pre>
<p>I know it's not perfect, but nothing will be.  I don't like an APPLY operator that sits to the left and quotes:</p>
<pre><code>apply append [[a b c] &lt;d&gt; dup: 2]  ; !!! bad
</code></pre>
<p>Because that makes it look too much like the BLOCK! is the first argument to APPEND.  So you really have to do APPLY with an inert form:</p>
<pre><code>apply get $append [[a b c] &lt;d&gt; dup: 2]

apply append/ [[a b c] &lt;d&gt; dup: 2]
</code></pre>
<p>So if quoting is in play, there has to be something learnable and infix to jolt the flow.  I've tried a <strong>lot</strong> of things at this point, this feels like the logical conclusion.</p>
<pre><code>append // [[a b c] &lt;d&gt; dup: 2]
</code></pre>
          <p><a href="https://rebol.metaeducation.com/t/apply-ii-the-revenge/1834/9">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/apply-ii-the-revenge/1834/9</link>
        <pubDate>Tue, 20 Aug 2024 03:31:37 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1834-9</guid>
        <source url="https://rebol.metaeducation.com/t/apply-ii-the-revenge/1834.rss">APPLY II: The Revenge!</source>
      </item>
      <item>
        <title>APPLY II: The Revenge!</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>I'd said <em>"It's time to bring back APPLY"</em>.</p>
<p>...and by <em>"it's time"</em> I apparently meant <em>"within the next year, maybe?"</em>...</p>
<p>But better late than never, right?  It's in!</p>
<h2><a name="p-5385-refinements-can-be-provided-in-any-order-1" class="anchor" href="https://rebol.metaeducation.com#p-5385-refinements-can-be-provided-in-any-order-1"></a>Refinements Can be Provided In Any Order</h2>
<pre><code>[a b c d e d e] = apply append/ [[a b c] [d e] dup: 2]
[a b c d e d e] = apply append/ [dup: 2 [a b c] [d e]]
[a b c d e d e] = apply append/ [[a b c] dup: 2 [d e]]

[a b c d d] = apply append/ [dup: 2 [a b c] [d e] part: 1]
[a b c d d] = apply append/ [[a b c] [d e] part: 1 dup: 2]
</code></pre>
<h2><a name="p-5385-any-parameter-not-just-refinements-can-be-used-by-name-2" class="anchor" href="https://rebol.metaeducation.com#p-5385-any-parameter-not-just-refinements-can-be-used-by-name-2"></a>Any Parameter (Not Just Refinements) Can Be Used By Name</h2>
<p>Once a parameter has been supplied by name, it is no longer considered for consuming positionally.</p>
<pre><code>[a b c d e] = apply append/ [series: [a b c] value: [d e]]
[a b c d e] = apply append/ [value: [d e] series: [a b c]]

[a b c d e] = apply append/ [series: [a b c] [d e]]
[a b c d e] = apply append/ [value: [d e] [a b c]]
</code></pre>
<h2><a name="p-5385-commas-are-ok-so-long-as-they-are-interstitial-3" class="anchor" href="https://rebol.metaeducation.com#p-5385-commas-are-ok-so-long-as-they-are-interstitial-3"></a>Commas Are Ok So Long As They Are Interstitial</h2>
<pre><code>[a b c d e d e] = apply append/ [[a b c], [d e], dup: 2]
[a b c d e d e] = apply append/ [dup: 2, [a b c] [d e]]

&gt;&gt; apply :append [dup:, 2 [a b c] [d e]]
** Script Error: end was reached while trying to set dup:
</code></pre>
<h2><a name="p-5385-giving-too-many-arguments-defaults-to-an-error-4" class="anchor" href="https://rebol.metaeducation.com#p-5385-giving-too-many-arguments-defaults-to-an-error-4"></a>Giving Too Many Arguments Defaults To An Error</h2>
<pre><code>&gt;&gt; apply append/ [[a b c] [d e] [f g]]
** Script Error: Too many values in processed argument block of APPLY.
</code></pre>
<p>If you want, you can ask it to :RELAX</p>
<pre><code>&gt;&gt; apply:relax append/ [[a b c] [d e] [f g]]
== [a b c [d e]] 
</code></pre>
<h2><a name="p-5385-set-word-must-be-followed-by-a-non-set-word-5" class="anchor" href="https://rebol.metaeducation.com#p-5385-set-word-must-be-followed-by-a-non-set-word-5"></a>SET-WORD Must Be Followed By A Non-SET-WORD</h2>
<pre><code>&gt;&gt; apply append/ [dup: part: 1 [a b c] [d e]]
** Script Error: end was reached while trying to set dup:
</code></pre>
<p>But you can pass SET-WORD as arguments to refinements...just use a quote! (or a <code>$</code> if you want to bind it)</p>
<pre><code>&gt;&gt; tester: func [:refine [any-value!]] [refine]

&gt;&gt; apply tester/ [refine: 'ta-da!:]
== ta-da!:
</code></pre>
<h2><a name="p-5385-no-arg-refinements-permit-okay-and-null-6" class="anchor" href="https://rebol.metaeducation.com#p-5385-no-arg-refinements-permit-okay-and-null-6"></a>No-Arg Refinements Permit OKAY and NULL</h2>
<p>Remember: <em>the EVAL FRAME! mechanics do not change anything.</em>  So if a refinement doesn't take an argument, <a href="https://rebol.metaeducation.com/t/why-no-argument-refinements-are-okay-or-null/735">the only legal values for that refinement in the frame are OKAY and NULL</a>.</p>
<pre><code>&gt;&gt; testme: func [:refine] [refine]

&gt;&gt; apply testme/ [refine: okay]
== \~okay~\  ; antiform

&gt;&gt; apply testme/ [refine: null]
== \~null~\  ; antiform

&gt;&gt; apply testme/ [refine: 1020]
** Error: No-Arg refinements can only be ~okay~ and ~null~ antiforms
</code></pre>
<h2><a name="p-5385-meta-arguments-are-accounted-for-7" class="anchor" href="https://rebol.metaeducation.com#p-5385-meta-arguments-are-accounted-for-7"></a>^META Arguments Are Accounted For</h2>
<p>APPLY detects when a parameter is meta and handles it for positional arguments:</p>
<pre><code>&gt;&gt; non-detector: func [arg] [arg]  ; not a meta argument, no unstable antiforms

&gt;&gt; apply non-detector/ [pack [10 20]]
== 10

&gt;&gt; detector: func [^arg] [^arg]  ; unstable antiforms allowed

&gt;&gt; apply detector/ [pack [10 20]]
== \~['10 '20]~\  ; antiform
</code></pre>
<p><strong>I know not everyone has gotten their heads around isotopes yet, but they are critical... this stuff was the missing link to making it all gel.</strong></p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/dizzy.png?v=14" title=":dizzy:" class="emoji only-emoji" alt=":dizzy:" loading="lazy" width="20" height="20"> <img src="https://rebol.metaeducation.com/images/emoji/twitter/dizzy.png?v=14" title=":dizzy:" class="emoji only-emoji" alt=":dizzy:" loading="lazy" width="20" height="20"> <img src="https://rebol.metaeducation.com/images/emoji/twitter/dizzy.png?v=14" title=":dizzy:" class="emoji only-emoji" alt=":dizzy:" loading="lazy" width="20" height="20"></p>
          <p><a href="https://rebol.metaeducation.com/t/apply-ii-the-revenge/1834/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/apply-ii-the-revenge/1834/1</link>
        <pubDate>Tue, 17 Aug 2021 07:58:34 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1834-1</guid>
        <source url="https://rebol.metaeducation.com/t/apply-ii-the-revenge/1834.rss">APPLY II: The Revenge!</source>
      </item>
  </channel>
</rss>

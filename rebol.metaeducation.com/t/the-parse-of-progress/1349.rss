<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>The PARSE of PROGRESS</title>
    <link>https://rebol.metaeducation.com/t/the-parse-of-progress/1349</link>
    <description>There has been a lot of fiddling over time with PARSE&#39;s return value.  :violin: 

It was long believed that a failed PARSE should return NULL.  This would make it play nicely with ELSE and THEN.  The question was thus what to return on success:

1. Just returning ~okay~ makes the output of PARSE easier to read in tutorials.  This isn&#39;t overwhelmingly important.

2. Returning the input value would make it easy to use PARSE as a validator for data.

       if parse data [integer! integer!] [  ; exactly two integers
          call-routine data
       ] else [fail]

       call-routine (parse data [integer! integer!] else [fail])  ; nicer

       call-routine non null parse data [integer! integer!]  ; even nicer :-)

3. Returning how far a successful parse got was strictly more informative, as the information on a partial process is difficult to reconstruct otherwise.

For at least some time, @rgchris favored #3, because many sophisticated tasks are helped by knowing how far PARSE got.  But that required a change to the semantics of PARSE to not automatically fail on partial inputs, so the rules had to explicitly ask to hit an **`&lt;end&gt;`**

But the need to tack on `&lt;end&gt;` made some things seem less concise and elegant.  And surveying how other languages do &quot;destructuring&quot; made me feel that PARSE requiring completion was the best answer in the Redbol world.  When you&#39;re matching a structure against `[tag! tag!]` it feels somewhat wrong for `[&lt;x&gt; &lt;y&gt; &lt;z&gt;]` to &quot;match&quot; when it seems &quot;over the limit&quot;.

## UPARSE Offers The Best Of All Worlds

Everything changed with UPARSE.

First of all, if a PARSE doesn&#39;t match **[it raises a definitional error](https://rebol.metaeducation.com/t/try-parse-parse-except-raise-on-mismatch/1924)**.  This provides a welcome safety net.

    &gt;&gt; parse &quot;abc&quot; [&quot;ab&quot;]
    ** Error: PARSE partially matched the input, but didn&#39;t reach the tail

You can use TRY PARSE if you like, and get NULL..though possibly conflating with a NULL synthesized by the last matching rule (e.g. OPT synthesizes null when the optional thing was not there).  You can use EXCEPT to specifically handle exceptions in a postfix manner.  Or using META/EXCEPT will give you a plain ERROR! on definitonal error, and a META&#39;d value otherwise.

All rules synthesize a result (though a GHOST result is legal, e.g. you can ELIDE a rule), and you can [end the parse at any time with ACCEPT](https://rebol.metaeducation.com/t/uparses-spin-on-return-accept/1589):

    &gt;&gt; parse &quot;abc&quot; [&quot;ab&quot;, accept &lt;input&gt;]
    == &quot;abc&quot;

    &gt;&gt; parse &quot;abc&quot; [&quot;ab&quot;, accept &lt;here&gt;]
    == &quot;c&quot;

You can even pack up multi-return values and give them back.  The possibilties are pretty much endless, and so the policy of returning the synthesized result has won out.</description>
    
    <lastBuildDate>Sun, 11 May 2025 13:38:56 +0000</lastBuildDate>
    <category>Parsing</category>
    <atom:link href="https://rebol.metaeducation.com/t/the-parse-of-progress/1349.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>The PARSE of PROGRESS</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1349">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">make-parser: lambda [data] [
    make-yielder [rule [block!]] [
        parse data [opt some yield/ rule]
    ]
]
</code></pre>
</blockquote>
</aside>
<p>So it occurs to me that the name is kind of wrong, here.</p>
<p>In parser combinator systems, a <strong>parser</strong> is typically a function that takes input and returns a result (and possibly the remaining unconsumed input), while a <strong>combinator</strong> is a higher-order function that assembles or modifies parsers.</p>
<p>What's being produced here is a <strong>generator-like function</strong>, pre-bound to an input, that <strong>yields values</strong> extracted by applying rules (parser expressions) passed in <strong>per call</strong>. Once the input is consumed or the stream is otherwise closed, it reports completion.</p>
<p>That flips the traditional model: instead of fixing the rules and varying the input, it fixes the input and varies the rules.</p>
<p>Asking AIs they don't seem to be aware of this pattern having a name.  Might have to make one up. "Parse Pump"?  I don't know if <strong>pump [...rule...]</strong> looks great.  Maybe call the variable "PROCESS", or "GRAB"?</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; grab: make-parse-pump [a 1020]

&gt;&gt; grab word!
== a

&gt;&gt; done? grab []
== ~null~  ; anti

&gt;&gt; grab [one]
== 1020

&gt;&gt; done? grab []
== ~okay~  ; anti
</code></pre>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>Naming is hard.</p>
          <p><a href="https://rebol.metaeducation.com/t/the-parse-of-progress/1349/5">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/the-parse-of-progress/1349/5</link>
        <pubDate>Sun, 11 May 2025 12:59:00 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1349-5</guid>
        <source url="https://rebol.metaeducation.com/t/the-parse-of-progress/1349.rss">The PARSE of PROGRESS</source>
      </item>
      <item>
        <title>The PARSE of PROGRESS</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1349">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<ol>
<li>Returning how far a successful parse got was strictly more informative, as the information on a partial process is difficult to reconstruct otherwise.</li>
</ol>
<p>For at least some time, <a class="mention" href="https://rebol.metaeducation.com/u/rgchris">@rgchris</a> favored <span class="hashtag-raw">#3</span>, because many sophisticated tasks are helped by knowing how far PARSE got. But that required a change to the semantics of PARSE to not automatically fail on partial inputs, so the rules had to explicitly ask to hit an <strong><code>&lt;end&gt;</code></strong></p>
</blockquote>
</aside>
<p>I put together an interesting dialected example of PARSE going one step at a time:</p>
<p><a href="https://rebol.metaeducation.com/t/evaluator-hooking-rebindablesyntax/2443" class="inline-onebox">Evaluator Hooking ("RebindableSyntax")</a></p>
<p>This is an inversion of control, that steps away from "PARSE and be done".  It's kind of like how <a class="mention" href="https://rebol.metaeducation.com/u/rgchris">@rgchris</a> <a href="https://rebol.metaeducation.com/t/backtrack-zip/1860">rebelled against the "ZIP and be done"</a> model of the ZIP dialect.</p>
<p>I think the GENERATOR / YIELDER model works well here.  Like I point out, you can process your data one rule at a time:</p>
<pre><code>make-parser: lambda [data] [
    make-yielder [rule [block!]] [
        parse data [opt some yield/ rule]
    ]
]
</code></pre>
<p><strong>And there you go.</strong></p>
<pre><code>&gt;&gt; parser: make-parser [a b c "d" 1020 "e" 304]

&gt;&gt; parser [across some word!]
== [a b c]

&gt;&gt; parser [one]
== "d"

&gt;&gt; parser [collect some [keep integer! | text!]]
== [1020 304]

&gt;&gt; parser [one]
** Error: enumeration done

&gt;&gt; try parser [one]
== ~null~
</code></pre>
<p>TRY suppresses arbitrary mismatch errors, so probably not what you want to use for end-detection.  Note you can use <strong><code>done? parser []</code></strong> to test for if a parse is done, since it's a yielder... the only way an empty block rule wouldn't match would be if the parse ended (might need to rig that up specially, but it's doable)</p>
<p>Maybe this PARSER should tolerate non-BLOCK!s too...</p>
<pre><code>&gt;&gt; parser: make-parser [a 1020]

&gt;&gt; parser word!
== a

&gt;&gt; done? parser []
== ~null~  ; anti

&gt;&gt; parser [one]
== 1020

&gt;&gt; done? parser []
== ~okay~  ; anti
</code></pre>
<h2><a name="p-8253-this-looks-very-sweet-candy-1" class="anchor" href="https://rebol.metaeducation.com#p-8253-this-looks-very-sweet-candy-1"></a>This Looks Very Sweet... <img src="https://rebol.metaeducation.com/images/emoji/twitter/candy.png?v=14" title=":candy:" class="emoji" alt=":candy:" loading="lazy" width="20" height="20"></h2>
<p>I think this crystallizes that we need the creation operations to be named like MAKE-PARSER and MAKE-YIELDER, because you need to be able to name the products (PARSER, YIELDER, GENERATOR...)</p>
          <p><a href="https://rebol.metaeducation.com/t/the-parse-of-progress/1349/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/the-parse-of-progress/1349/4</link>
        <pubDate>Sun, 11 May 2025 11:50:12 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1349-4</guid>
        <source url="https://rebol.metaeducation.com/t/the-parse-of-progress/1349.rss">The PARSE of PROGRESS</source>
      </item>
      <item>
        <title>The PARSE of PROGRESS</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1349">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<ol>
<li>Returning how far a successful parse got was strictly more informative, as the information on a partial process is difficult to reconstruct otherwise.</li>
</ol>
<p>For at least some time, <a class="mention" href="https://rebol.metaeducation.com/u/rgchris">@rgchris</a> favored <span class="hashtag-raw">#3</span></p>
</blockquote>
</aside>
<p>I've mentioned that this is pretty easy to write.  But it doesn't mean there shouldn't be a name for it...</p>
<p>It seems to me a reasonably good name for this is <strong><code>PARSE-THRU</code></strong>..</p>
<pre><code>&gt;&gt; parse-thru "aaabbb" [some "a"]
== "bbb"
</code></pre>
<p>It can be implemented any number of ways, but an easy one is to ADAPT the rules slightly before running the PARSE.  Since RULES is a BLOCK!, you can just compose it in, and follow it <a href="https://rebol.metaeducation.com/t/uparses-spin-on-return-accept/1589">with an ACCEPT</a> of wherever the current position is.</p>
<pre><code>/parse-thru: adapt parse/ [
    rules: compose [(rules) accept &lt;here&gt;]
]
</code></pre>
<p>This will default to erroring if it doesn't match, so you'd have to use <code>try parse-thru</code> if you wanted a null when there was a deliberate mismatch:</p>
<pre><code>&gt;&gt; parse-thru "bbbaaa" [some "a"]
** Error: PARSE BLOCK! combinator did not match input

&gt;&gt; try parse-thru "bbbaaa" [some "a"]
== ~null~
</code></pre>
<p>If you want to work around this, there's lots of ways to do it.  You could make an alternative to return null:</p>
<pre><code>/parse-thru: adapt parse/ [
    rules: compose:deep [[(rules) accept &lt;here&gt;] | accept null]
]
</code></pre>
<p>Or rig it up so that the rule is optional, and use PARSE:RELAX to remove the requirement that it reach the end:</p>
<pre><code>/parse-thru: adapt parse:relax/ [
    rules: compose*:deep [opt [(rules) accept &lt;here&gt;]]
]
</code></pre>
<p>Lots of ways to get the effect:</p>
<pre><code>&gt;&gt; parse-thru "bbbaaa" [some "a"]
== ~null~  ; anti
</code></pre>
<h2><a name="p-8024-another-interesting-interface-parse-match-1" class="anchor" href="https://rebol.metaeducation.com#p-8024-another-interesting-interface-parse-match-1"></a>Another Interesting Interface: PARSE-MATCH</h2>
<p>Being able to get the input, or a NULL, can be useful as well.  Similar technique will get it, just swap the <strong><code>&lt;input&gt;</code></strong> combinator for the <strong><code>&lt;here&gt;</code></strong> combinator, and don't remove the requirement to reach the end:</p>
<pre><code>/parse-match: adapt parse/ [
    rules: compose [(rules) &lt;end&gt; &lt;input&gt; | accept null]
]

&gt;&gt; parse-match "aaabbb" [some "a" some "b"]
== "aaabbb"

&gt;&gt; parse-match "bbbaaa" [some "a" some "b"]
== ~null~  ; anti

&gt;&gt; parse-match "aaabbb" [some "a"]
== ~null~  ; anti
</code></pre>
<h2><a name="p-8024-endless-possibilities-but-how-to-compose-them-2" class="anchor" href="https://rebol.metaeducation.com#p-8024-endless-possibilities-but-how-to-compose-them-2"></a>Endless Possibilities... But How To Compose Them?</h2>
<p>In the <strong><a href="https://rebol.metaeducation.com/t/visual-parse-on-the-web-has-arrived/1837">Visual Parse Demo</a></strong> I showed how a tweaked PARSE variant, that I called <strong>eparse</strong>, could be rigged up to make underlines in the web-based text editor for anything you marked with a MARK combinator (with rollback, such that marks would not be made if the whole rule did not ultimately match...)</p>
<p>So do you have to write <code>EPARSE-THRU</code> and <code>EPARSE-MATCH</code>?</p>
<p>If instead of having these modes be done with wrappers--that they were instead refinements on PARSE itself--you'd get <code>EPARSE:THRU</code> and <code>EPARSE:MATCH</code> "for free".  Perhaps they could be more efficient in their implementation as well.</p>
<p>But then you start having situations where people can do nonsensical combinatorics, like <strong><code>eparse:thru:match</code></strong>.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<h3><a name="p-8024-or-weird-idea-could-parse-have-some-other-hookability-3" class="anchor" href="https://rebol.metaeducation.com#p-8024-or-weird-idea-could-parse-have-some-other-hookability-3"></a>...or (Weird Idea) Could PARSE Have Some Other Hookability?</h3>
<p>It might be that if you ask to PARSE an OBJECT!, that the object could act as some kind of specification... like providing the combinators and where to look for the data.</p>
<p>e.g. <strong><code>parse editor [some "a"]</code></strong> could look at the editor object, and have behaviors particular to that object.  This would mean that <strong><code>parse-match editor [some "a"]</code></strong> could work as well.</p>
<h2><a name="p-8024-separate-entry-points-vs-refinements-is-the-safer-bet-4" class="anchor" href="https://rebol.metaeducation.com#p-8024-separate-entry-points-vs-refinements-is-the-safer-bet-4"></a>Separate Entry Points vs. Refinements Is The Safer Bet</h2>
<p>In the scheme of things, having PARSE-MATCH and a PARSE-THRU entry points is easiest, because you'll be able to do that regardless.</p>
<p>But like I say, the default being the synthesized result of the rules... with error by default if a match or ACCEPT is not reached... that's a super powerful default that I'm really happy with.</p>
          <p><a href="https://rebol.metaeducation.com/t/the-parse-of-progress/1349/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/the-parse-of-progress/1349/2</link>
        <pubDate>Fri, 07 Mar 2025 00:32:05 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1349-2</guid>
        <source url="https://rebol.metaeducation.com/t/the-parse-of-progress/1349.rss">The PARSE of PROGRESS</source>
      </item>
      <item>
        <title>The PARSE of PROGRESS</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>There has been a lot of fiddling over time with PARSE's return value.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/violin.png?v=14" title=":violin:" class="emoji" alt=":violin:" loading="lazy" width="20" height="20"></p>
<p>It was long believed that a failed PARSE should return NULL.  This would make it play nicely with ELSE and THEN.  The question was thus what to return on success:</p>
<ol>
<li>
<p>Just returning ~okay~ makes the output of PARSE easier to read in tutorials.  This isn't overwhelmingly important.</p>
</li>
<li>
<p>Returning the input value would make it easy to use PARSE as a validator for data.</p>
<pre><code>if parse data [integer! integer!] [  ; exactly two integers
   call-routine data
] else [fail]

call-routine (parse data [integer! integer!] else [fail])  ; nicer

call-routine non null parse data [integer! integer!]  ; even nicer :-)
</code></pre>
</li>
<li>
<p>Returning how far a successful parse got was strictly more informative, as the information on a partial process is difficult to reconstruct otherwise.</p>
</li>
</ol>
<p>For at least some time, <a class="mention" href="https://rebol.metaeducation.com/u/rgchris">@rgchris</a> favored <span class="hashtag-raw">#3</span>, because many sophisticated tasks are helped by knowing how far PARSE got.  But that required a change to the semantics of PARSE to not automatically fail on partial inputs, so the rules had to explicitly ask to hit an <strong><code>&lt;end&gt;</code></strong></p>
<p>But the need to tack on <code>&lt;end&gt;</code> made some things seem less concise and elegant.  And surveying how other languages do "destructuring" made me feel that PARSE requiring completion was the best answer in the Redbol world.  When you're matching a structure against <code>[tag! tag!]</code> it feels somewhat wrong for <code>[&lt;x&gt; &lt;y&gt; &lt;z&gt;]</code> to "match" when it seems "over the limit".</p>
<h2><a name="p-4062-uparse-offers-the-best-of-all-worlds-1" class="anchor" href="https://rebol.metaeducation.com#p-4062-uparse-offers-the-best-of-all-worlds-1"></a>UPARSE Offers The Best Of All Worlds</h2>
<p>Everything changed with UPARSE.</p>
<p>First of all, if a PARSE doesn't match <strong><a href="https://rebol.metaeducation.com/t/try-parse-parse-except-raise-on-mismatch/1924">it raises a definitional error</a></strong>.  This provides a welcome safety net.</p>
<pre><code>&gt;&gt; parse "abc" ["ab"]
** Error: PARSE partially matched the input, but didn't reach the tail
</code></pre>
<p>You can use TRY PARSE if you like, and get NULL..though possibly conflating with a NULL synthesized by the last matching rule (e.g. OPT synthesizes null when the optional thing was not there).  You can use EXCEPT to specifically handle exceptions in a postfix manner.  Or using META/EXCEPT will give you a plain ERROR! on definitonal error, and a META'd value otherwise.</p>
<p>All rules synthesize a result (though a GHOST result is legal, e.g. you can ELIDE a rule), and you can <a href="https://rebol.metaeducation.com/t/uparses-spin-on-return-accept/1589">end the parse at any time with ACCEPT</a>:</p>
<pre><code>&gt;&gt; parse "abc" ["ab", accept &lt;input&gt;]
== "abc"

&gt;&gt; parse "abc" ["ab", accept &lt;here&gt;]
== "c"
</code></pre>
<p>You can even pack up multi-return values and give them back.  The possibilties are pretty much endless, and so the policy of returning the synthesized result has won out.</p>
          <p><a href="https://rebol.metaeducation.com/t/the-parse-of-progress/1349/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/the-parse-of-progress/1349/1</link>
        <pubDate>Mon, 28 Sep 2020 17:02:25 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-1349-1</guid>
        <source url="https://rebol.metaeducation.com/t/the-parse-of-progress/1349.rss">The PARSE of PROGRESS</source>
      </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>LIFT_BYTE Values (Antiform, Normal, Quasi, Quoted)</title>
    <link>https://rebol.metaeducation.com/t/lift-byte-values-antiform-normal-quasi-quoted/2091</link>
    <description>The &quot;game&quot; of Rebol is played with cells that are the size of four platform pointers.  So on a 32-bit platform a cell is 16 bytes in size, and on a 64-bit platform they are 32 bytes in size.

I&#39;ve illustrated Ren-C&#39;s spin on this &quot;game&quot; previously:

![ren-c-cell|690x281](upload://3E5omo3mg1b0FRQoFVFHU57OGqt.png)

The bits and bytes in the header are arranged in a platform-independent way.  Regardless of the endianness of the machine, the bits in the header will be in the same order.  The first byte is chosen with a pattern that specifically will never occur as a leading byte in a UTF-8 sequence...allowing an arbitrary pointer to be discerned as pointing to a cell or to the beginning of a UTF-8 string.

The &quot;payload&quot; is specifically aligned to a 64-bit boundary on both 32-bit and 64-bit platforms.  This is important if it contains something like a double precision floating point number.  It is also a union, which means that if it has constituent fields, they must be read from exactly the same union definition which was used to assign them.  The &quot;extra&quot; is separate, meaning it is decoupled from the payload and can be assigned and read on its own terms (e.g. BLOCK! and WORD! could have a &quot;binding&quot; in extra that is read and written in common, without invalidating their payloads).

The HEART_BYTE encodes what we would think of as the underlying datatype, and cues the interpretation of the contents of the cell.  For instance the byte corresponding to a BLOCK! tells us that the payload consists of a pointer to an array of more cells as well as an index into the block.

## Enter the QUOTE_BYTE

Bits in the header are scarce.  And at one time, quoting was implemented by only two bits... for quoting levels of 0, 1, 2, or 3.  Higher quoting levels were achieved by changing the HEART_BYTE to indicate QUOTED!, and then the payload was changed to point to a single-element array that held the quoted cell, and an integer of the quoting level up beyond millions.  It was tricky to do, but it worked.

Eventually, the complex mechanics behind flipping to a different payload for higher levels of quoting was scrapped, and an entire byte in the header was sacrificed for the quote level.  This QUOTE_BYTE permitted from 0-255 levels of quoting, and I decided that was more than enough.

When isotopes were originally introduced, there was a flag taken to say something was an antiform.  However, I realized that something should not be quoted and be an antiform at the same time.  Hence the antiform state could be thought of as a special value of the quote byte.

Initially I chose 255 for antiforms, leaving 0-254 as the ordinary quoting levels.  But the theory of isotopes evolved to where not only were there antiforms, but there needed to be a form of quoting that would produce antiforms under evaluation...so-called *quasiforms*.  And it began to make sense to think of the antiform state as being obviously &quot;less&quot; than other quoting levels, so it became 0.

## QUOTE_BYTE becomes LIFT_BYTE: New Interpretation

What it worked out to was:

* Lift byte of 0 is an isotope: **`#define ANTIFORM_0 0`**

* Lift byte of 1 is plain not-quoted: **`#define NOQUOTE_1 1`**

* Lift byte of 2 is a quasiform: **`#define QUASI_2 2`**

* Lift byte of 3 is single quoted plain form: **`#define ONEQUOTE_NONQUASI_3 3`**

A lift byte of 4 is a single-quoted quasiform.  e.g. there&#39;s no such thing as a quasi-quoted, just a quoted-quasi: **`&#39;~foo~`** is legal but **`~&#39;foo~`** is not.

So the interpretation of the LIFT_BYTE proceeds like that.

* Lift byte of 5 is a double quoted plain form

* Lift byte of 6 is a double quoted quasiform

* Lift byte of 7 is a triple quoted plain form

* Lift byte of 8 is a triple quoted quasiform

etc.

Evaluator drops one level of quoting, with the base case that quasiforms produce antiform and the normal form does whatever its evaluator rule is (WORD! looks up, etc.)

The QUOTE operator won&#39;t work on antiforms and the UNQUOTE operator won&#39;t work on quasiforms.  Instead you have to use the LIFT and UNLIFT operations, which handle those exceptions but just act like QUOTE and UNQUOTE otherwise.</description>
    
    <lastBuildDate>Wed, 04 Jun 2025 21:07:07 +0000</lastBuildDate>
    <category>C/C++ Implementation</category>
    <atom:link href="https://rebol.metaeducation.com/t/lift-byte-values-antiform-normal-quasi-quoted/2091.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>LIFT_BYTE Values (Antiform, Normal, Quasi, Quoted)</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2091">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>The HEART_BYTE encodes what we would think of as the underlying datatype, and cues the interpretation of the contents of the cell. For instance the byte corresponding to a BLOCK! tells us that the payload consists of a pointer to an array of more cells as well as an index into the block.</p>
</blockquote>
</aside>
<p>As things have "evolved", the HEART_BYTE is now <a href="https://rebol.metaeducation.com/t/new-names-for-foo-foo-and-foo/2447">multiplexed with the Cell's "SIGIL"</a>, chewing out two bits:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/a5b41a074e8a3e1bc24753d52411988f86c6fbf1.webp" data-download-href="https://rebol.metaeducation.com/uploads/default/a5b41a074e8a3e1bc24753d52411988f86c6fbf1" title="assets_task_01jvs8hm5we1htzdvvv4c08wvm_1747825870_img_3"><img src="https://rebol.metaeducation.com/uploads/default/optimized/1X/a5b41a074e8a3e1bc24753d52411988f86c6fbf1_2_345x230.webp" alt="assets_task_01jvs8hm5we1htzdvvv4c08wvm_1747825870_img_3" data-base62-sha1="nDSEdwQPw3RRbuAztdGkrUftyQ9" width="345" height="230" srcset="https://rebol.metaeducation.com/uploads/default/optimized/1X/a5b41a074e8a3e1bc24753d52411988f86c6fbf1_2_345x230.webp, https://rebol.metaeducation.com/uploads/default/optimized/1X/a5b41a074e8a3e1bc24753d52411988f86c6fbf1_2_517x345.webp 1.5x, https://rebol.metaeducation.com/uploads/default/optimized/1X/a5b41a074e8a3e1bc24753d52411988f86c6fbf1_2_690x460.webp 2x" data-dominant-color="1A525E"></a></div><p></p>
<p>4 sigil states (SIGIL_NONE, SIGIL_TIE, SIGIL_PIN, SIGIL_META) which take 2 bits out of the heart, leaving 6 bits for the "fundamental" types.</p>
<p>Thanks to extension types (<code>HEART_BYTE() = 0</code>, for good technical reasons) there's now as many types as one might want: <a href="https://rebol.metaeducation.com/t/extension-types-implementation/1203" class="inline-onebox">"Extension Types" Implementation</a></p>
<h2><a name="p-8369-why-were-sigils-generalized-1" class="anchor" href="https://rebol.metaeducation.com#p-8369-why-were-sigils-generalized-1"></a>Why Were SIGILs Generalized?</h2>
<p><a href="https://rebol.metaeducation.com/t/what-deserves-to-be-a-datatype/2164">@bradrn always had it out for the non-generality</a>... and I didn't disagree, just didn't know how to do any better.</p>
<p>As "meta-variables" became reimagined, <strong>(^foo: ...)</strong> did a lifted assignment, and <strong>(^foo)</strong> did an unlifted fetch.</p>
<p>Once that realization hit, <a href="https://rebol.metaeducation.com/t/up-arrow-for-lift-down-arrow-for-unlift/2471">I no longer worried about <strong><code>^</code></strong> not having a complement as down arrow to mean unlift</a>.  I realized that the decoration meant "we are operating in the meta-domain, of lifted things".</p>
<p>That thought had a natural consequence:</p>
<pre><code>&gt;&gt; my-functions: [_ _ _]

&gt;&gt; my-functions.^1: append/
== (...lifted action!...)

&gt;&gt; /my-functions.^1 [a b c] [d e]
== [a b c [d e]]
</code></pre>
<p>What's so special about 3 SIGIL?  I don't know.  <strong><a href="https://www.youtube.com/watch?v=J8lRKCw2_Pk">Three is a magic number</a></strong>.</p>
<p>In any case, this reduces the number of fundamental types to 63.  Due to CHAIN! replacing things like SET-WORD! or GET-PATH! etc, we're far from hitting that limit now.</p>
          <p><a href="https://rebol.metaeducation.com/t/lift-byte-values-antiform-normal-quasi-quoted/2091/4">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/lift-byte-values-antiform-normal-quasi-quoted/2091/4</link>
        <pubDate>Wed, 04 Jun 2025 21:07:07 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2091-4</guid>
        <source url="https://rebol.metaeducation.com/t/lift-byte-values-antiform-normal-quasi-quoted/2091.rss">LIFT_BYTE Values (Antiform, Normal, Quasi, Quoted)</source>
      </item>
      <item>
        <title>LIFT_BYTE Values (Antiform, Normal, Quasi, Quoted)</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>2 posts were split to a new topic: <a href="https://rebol.metaeducation.com/t/why-have-quote-unquote-if-meta-unmeta-are-a-superset/2450">Why have quote/unquote if meta/unmeta are a superset?</a></p>
          <p><a href="https://rebol.metaeducation.com/t/lift-byte-values-antiform-normal-quasi-quoted/2091/2">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/lift-byte-values-antiform-normal-quasi-quoted/2091/2</link>
        <pubDate>Tue, 13 May 2025 12:56:18 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2091-2</guid>
        <source url="https://rebol.metaeducation.com/t/lift-byte-values-antiform-normal-quasi-quoted/2091.rss">LIFT_BYTE Values (Antiform, Normal, Quasi, Quoted)</source>
      </item>
      <item>
        <title>LIFT_BYTE Values (Antiform, Normal, Quasi, Quoted)</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>A post was split to a new topic: <a href="https://rebol.metaeducation.com/t/why-have-both-block-and-group/2092">Why Have Both BLOCK! and GROUP!</a></p>
          <p><a href="https://rebol.metaeducation.com/t/lift-byte-values-antiform-normal-quasi-quoted/2091/3">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/lift-byte-values-antiform-normal-quasi-quoted/2091/3</link>
        <pubDate>Fri, 05 Jan 2024 07:29:23 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2091-3</guid>
        <source url="https://rebol.metaeducation.com/t/lift-byte-values-antiform-normal-quasi-quoted/2091.rss">LIFT_BYTE Values (Antiform, Normal, Quasi, Quoted)</source>
      </item>
      <item>
        <title>LIFT_BYTE Values (Antiform, Normal, Quasi, Quoted)</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>The "game" of Rebol is played with cells that are the size of four platform pointers.  So on a 32-bit platform a cell is 16 bytes in size, and on a 64-bit platform they are 32 bytes in size.</p>
<p>I've illustrated Ren-C's spin on this "game" previously:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/198e92149d15782107ac8c2852d336c9cea200d1.png" data-download-href="https://rebol.metaeducation.com/uploads/default/198e92149d15782107ac8c2852d336c9cea200d1" title="ren-c-cell"><img src="https://rebol.metaeducation.com/uploads/default/optimized/1X/198e92149d15782107ac8c2852d336c9cea200d1_2_690x281.png" alt="ren-c-cell" data-base62-sha1="3E5omo3mg1b0FRQoFVFHU57OGqt" width="690" height="281" srcset="https://rebol.metaeducation.com/uploads/default/optimized/1X/198e92149d15782107ac8c2852d336c9cea200d1_2_690x281.png, https://rebol.metaeducation.com/uploads/default/optimized/1X/198e92149d15782107ac8c2852d336c9cea200d1_2_1035x421.png 1.5x, https://rebol.metaeducation.com/uploads/default/original/1X/198e92149d15782107ac8c2852d336c9cea200d1.png 2x" data-dominant-color="EDEDED"></a></div><p></p>
<p>The bits and bytes in the header are arranged in a platform-independent way.  Regardless of the endianness of the machine, the bits in the header will be in the same order.  The first byte is chosen with a pattern that specifically will never occur as a leading byte in a UTF-8 sequence...allowing an arbitrary pointer to be discerned as pointing to a cell or to the beginning of a UTF-8 string.</p>
<p>The "payload" is specifically aligned to a 64-bit boundary on both 32-bit and 64-bit platforms.  This is important if it contains something like a double precision floating point number.  It is also a union, which means that if it has constituent fields, they must be read from exactly the same union definition which was used to assign them.  The "extra" is separate, meaning it is decoupled from the payload and can be assigned and read on its own terms (e.g. BLOCK! and WORD! could have a "binding" in extra that is read and written in common, without invalidating their payloads).</p>
<p>The HEART_BYTE encodes what we would think of as the underlying datatype, and cues the interpretation of the contents of the cell.  For instance the byte corresponding to a BLOCK! tells us that the payload consists of a pointer to an array of more cells as well as an index into the block.</p>
<h2><a name="p-6802-enter-the-quote_byte-1" class="anchor" href="https://rebol.metaeducation.com#p-6802-enter-the-quote_byte-1"></a>Enter the QUOTE_BYTE</h2>
<p>Bits in the header are scarce.  And at one time, quoting was implemented by only two bits... for quoting levels of 0, 1, 2, or 3.  Higher quoting levels were achieved by changing the HEART_BYTE to indicate QUOTED!, and then the payload was changed to point to a single-element array that held the quoted cell, and an integer of the quoting level up beyond millions.  It was tricky to do, but it worked.</p>
<p>Eventually, the complex mechanics behind flipping to a different payload for higher levels of quoting was scrapped, and an entire byte in the header was sacrificed for the quote level.  This QUOTE_BYTE permitted from 0-255 levels of quoting, and I decided that was more than enough.</p>
<p>When isotopes were originally introduced, there was a flag taken to say something was an antiform.  However, I realized that something should not be quoted and be an antiform at the same time.  Hence the antiform state could be thought of as a special value of the quote byte.</p>
<p>Initially I chose 255 for antiforms, leaving 0-254 as the ordinary quoting levels.  But the theory of isotopes evolved to where not only were there antiforms, but there needed to be a form of quoting that would produce antiforms under evaluation...so-called <em>quasiforms</em>.  And it began to make sense to think of the antiform state as being obviously "less" than other quoting levels, so it became 0.</p>
<h2><a name="p-6802-quote_byte-becomes-lift_byte-new-interpretation-2" class="anchor" href="https://rebol.metaeducation.com#p-6802-quote_byte-becomes-lift_byte-new-interpretation-2"></a>QUOTE_BYTE becomes LIFT_BYTE: New Interpretation</h2>
<p>What it worked out to was:</p>
<ul>
<li>
<p>Lift byte of 0 is an isotope: <strong><code>#define ANTIFORM_0 0</code></strong></p>
</li>
<li>
<p>Lift byte of 1 is plain not-quoted: <strong><code>#define NOQUOTE_1 1</code></strong></p>
</li>
<li>
<p>Lift byte of 2 is a quasiform: <strong><code>#define QUASI_2 2</code></strong></p>
</li>
<li>
<p>Lift byte of 3 is single quoted plain form: <strong><code>#define ONEQUOTE_NONQUASI_3 3</code></strong></p>
</li>
</ul>
<p>A lift byte of 4 is a single-quoted quasiform.  e.g. there's no such thing as a quasi-quoted, just a quoted-quasi: <strong><code>'~foo~</code></strong> is legal but <strong><code>~'foo~</code></strong> is not.</p>
<p>So the interpretation of the LIFT_BYTE proceeds like that.</p>
<ul>
<li>
<p>Lift byte of 5 is a double quoted plain form</p>
</li>
<li>
<p>Lift byte of 6 is a double quoted quasiform</p>
</li>
<li>
<p>Lift byte of 7 is a triple quoted plain form</p>
</li>
<li>
<p>Lift byte of 8 is a triple quoted quasiform</p>
</li>
</ul>
<p>etc.</p>
<p>Evaluator drops one level of quoting, with the base case that quasiforms produce antiform and the normal form does whatever its evaluator rule is (WORD! looks up, etc.)</p>
<p>The QUOTE operator won't work on antiforms and the UNQUOTE operator won't work on quasiforms.  Instead you have to use the LIFT and UNLIFT operations, which handle those exceptions but just act like QUOTE and UNQUOTE otherwise.</p>
          <p><a href="https://rebol.metaeducation.com/t/lift-byte-values-antiform-normal-quasi-quoted/2091/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/lift-byte-values-antiform-normal-quasi-quoted/2091/1</link>
        <pubDate>Thu, 04 Jan 2024 18:16:59 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2091-1</guid>
        <source url="https://rebol.metaeducation.com/t/lift-byte-values-antiform-normal-quasi-quoted/2091.rss">LIFT_BYTE Values (Antiform, Normal, Quasi, Quoted)</source>
      </item>
  </channel>
</rss>

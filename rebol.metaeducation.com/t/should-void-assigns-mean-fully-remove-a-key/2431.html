<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Should VOID Assigns Mean &quot;Fully Remove A Key&quot;? - Semantics - AltRebol</title>
    <meta name="description" content="Rebol2 and R3-Alpha distinguish between fields not in an object, and those that are in the object but unset: 
rebol2&amp;gt;&amp;gt; obj: make object! [x: &amp;quot;unsetme&amp;quot;]

rebol2&amp;gt;&amp;gt; unset bind &amp;#39;x obj

rebol2&amp;gt;&amp;gt; &amp;gt;&amp;gt; print mold obj
make object!&amp;hellip;">
    <meta name="generator" content="Discourse 3.5.0.beta6-dev - https://github.com/discourse/discourse version 623cde985b21c2ed812b83d3ea94f69231613718">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/1X/cbd70027b53fa165575e5b665f00eb3b8ae7ea31_2_32x32.ico">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d_2_180x180.png">
<meta name="theme-color" media="all" content="#fff">

<meta name="color-scheme" content="light">

<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, viewport-fit=cover">
<link rel="canonical" href="../could-an-unstable-mean-fully-remove-a-key/2431.html" />

<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="AltRebol Search">

    <link href="https://rebol.metaeducation.com/stylesheets/color_definitions_base__2_ceb61c279a74dfa3cef6a62f7784988102abec82.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" class="light-scheme"/>

<link href="https://rebol.metaeducation.com/stylesheets/common_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="common"  />

  <link href="https://rebol.metaeducation.com/stylesheets/desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="desktop"  />



    <link href="https://rebol.metaeducation.com/stylesheets/chat_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="chat"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-details_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-details"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-lazy-videos_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-lazy-videos"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-local-dates_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-local-dates"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-narrative-bot_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-narrative-bot"  />
    <link href="https://rebol.metaeducation.com/stylesheets/discourse-presence_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="discourse-presence"  />
    <link href="https://rebol.metaeducation.com/stylesheets/docker_manager_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="docker_manager"  />
    <link href="https://rebol.metaeducation.com/stylesheets/footnote_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="footnote"  />
    <link href="https://rebol.metaeducation.com/stylesheets/poll_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="poll"  />
    <link href="https://rebol.metaeducation.com/stylesheets/spoiler-alert_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="spoiler-alert"  />
    <link href="https://rebol.metaeducation.com/stylesheets/chat_desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="chat_desktop"  />
    <link href="https://rebol.metaeducation.com/stylesheets/poll_desktop_e0a75505da9bc96953dd62a4aad773a25cca0f8e.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="poll_desktop"  />

  <link href="https://rebol.metaeducation.com/stylesheets/common_theme_2_57fe803ed5a41e9f7d94086afaf66a1aab57d9ae.css?__ws=rebol.metaeducation.com" media="all" rel="stylesheet" data-target="common_theme" data-theme-id="2" data-theme-name="default"/>
    

    
    
        <link rel="alternate nofollow" type="application/rss+xml" title="RSS feed of &#39;Should VOID Assigns Mean &quot;Fully Remove A Key&quot;?&#39;" href="2431.rss" />
    <meta property="og:site_name" content="AltRebol" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:image" content="https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:url" content="https://rebol.metaeducation.com/t/should-void-assigns-mean-fully-remove-a-key/2431" />
<meta name="twitter:url" content="https://rebol.metaeducation.com/t/should-void-assigns-mean-fully-remove-a-key/2431" />
<meta property="og:title" content="Should VOID Assigns Mean &quot;Fully Remove A Key&quot;?" />
<meta name="twitter:title" content="Should VOID Assigns Mean &quot;Fully Remove A Key&quot;?" />
<meta property="og:description" content="Rebol2 and R3-Alpha distinguish between fields not in an object, and those that are in the object but unset:  rebol2&gt;&gt; obj: make object! [x: &quot;unsetme&quot;]  rebol2&gt;&gt; unset bind &#39;x obj  rebol2&gt;&gt; &gt;&gt; print mold obj make object! [     x: unset ]  rebol2&gt;&gt; unset? obj/x  ; asks if obj/x is an &quot;UNSET! value&quot; == true  rebol2&gt;&gt; unset? obj/asdf ** Script Error: Invalid path value: asdf  Ren-C has this distinction today, as well.  &gt;&gt; obj: make object! [x: ~]  &gt;&gt; unset? $obj.x  ; asks if obj.x looks up to a TRA..." />
<meta name="twitter:description" content="Rebol2 and R3-Alpha distinguish between fields not in an object, and those that are in the object but unset:  rebol2&gt;&gt; obj: make object! [x: &quot;unsetme&quot;]  rebol2&gt;&gt; unset bind &#39;x obj  rebol2&gt;&gt; &gt;&gt; print mold obj make object! [     x: unset ]  rebol2&gt;&gt; unset? obj/x  ; asks if obj/x is an &quot;UNSET! value&quot; == true  rebol2&gt;&gt; unset? obj/asdf ** Script Error: Invalid path value: asdf  Ren-C has this distinction today, as well.  &gt;&gt; obj: make object! [x: ~]  &gt;&gt; unset? $obj.x  ; asks if obj.x looks up to a TRA..." />
<meta property="og:article:section" content="Development" />
<meta property="og:article:section:color" content="25AAE2" />
<meta property="og:article:section" content="Semantics" />
<meta property="og:article:section:color" content="25AAE2" />
<meta name="twitter:label1" value="Reading time" />
<meta name="twitter:data1" value="4 mins 🕑" />
<meta name="twitter:label2" value="Likes" />
<meta name="twitter:data2" value="1 ❤" />
<meta property="article:published_time" content="2025-05-02T12:10:04+00:00" />
<meta property="og:ignore_canonical" content="true" />


    
  </head>
  <body class="crawler ">
    
    <header>
  <a href="https://rebol.metaeducation.com/">AltRebol</a>
</header>

    <div id="main-outlet" class="wrap" role="main">
        <div id="topic-title">
    <h1>
      <a href="../could-an-unstable-mean-fully-remove-a-key/2431.html">Should VOID Assigns Mean &quot;Fully Remove A Key&quot;?</a>
    </h1>

      <div class="topic-category" itemscope itemtype="http://schema.org/BreadcrumbList">
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://rebol.metaeducation.com/c/development/semantics/55" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #25AAE2'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Development</span>
              </span>
            </a>
            <meta itemprop="position" content="1" />
          </span>
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://rebol.metaeducation.com/c/development/semantics/55" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #25AAE2'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Semantics</span>
              </span>
            </a>
            <meta itemprop="position" content="2" />
          </span>
      </div>

  </div>

  

    <div itemscope itemtype='http://schema.org/DiscussionForumPosting'>
      <meta itemprop='headline' content='Should VOID Assigns Mean &quot;Fully Remove A Key&quot;?'>
      <link itemprop='url' href='../could-an-unstable-mean-fully-remove-a-key/2431.html'>
      <meta itemprop='datePublished' content='2025-05-02T12:10:03Z'>
        <meta itemprop='articleSection' content='Semantics'>
      <meta itemprop='keywords' content=''>
      <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
        <meta itemprop='name' content='AltRebol'>
          <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
            <meta itemprop='url' content='https://rebol.metaeducation.com/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
          </div>
      </div>


          <div id='post_1'  class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>

                <link itemprop="mainEntityOfPage" href="../could-an-unstable-mean-fully-remove-a-key/2431.html">


              <span class="crawler-post-infos">
                  <time  datetime='2025-05-02T12:10:04Z' class='post-time'>
                    May 2, 2025, 12:10pm
                  </time>
                  <meta itemprop='dateModified' content='2025-05-07T09:55:48Z'>
              <span itemprop='position'>1</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>Rebol2 and R3-Alpha distinguish between fields not in an object, and those that are in the object but unset:</p>
<pre><code>rebol2&gt;&gt; obj: make object! [x: "unsetme"]

rebol2&gt;&gt; unset bind 'x obj

rebol2&gt;&gt; &gt;&gt; print mold obj
make object! [
    x: unset
]

rebol2&gt;&gt; unset? obj/x  ; asks if obj/x is an "UNSET! value"
== true

rebol2&gt;&gt; unset? obj/asdf
** Script Error: Invalid path value: asdf
</code></pre>
<p>Ren-C has this distinction today, as well.</p>
<pre><code>&gt;&gt; obj: make object! [x: ~]

&gt;&gt; unset? $obj.x  ; asks if obj.x looks up to a TRASH! value
== ~okay~  ; anti

&gt;&gt; unset? $obj.asdf
** Error: Cannot pick asdf in obj
</code></pre>
<p><em>(Red says both <strong>obj/x</strong> and <strong>obj/asdf</strong> are "UNSET?", so you have to ask something like <strong>(unset? obj/asdf/jkl)</strong> before you get an error.)</em></p>
<h2><a name="p-8195-this-is-the-unresolved-vs-unset-distinction-1" class="anchor" href="../could-an-unstable-mean-fully-remove-a-key/2431.html#p-8195-this-is-the-unresolved-vs-unset-distinction-1"></a>This Is the "Unresolved" (vs. "Unset"?) Distinction</h2>
<p>I think UNRESOLVED? is a pretty good name for the test saying there's no variable location to even find for something to ask about its state.</p>
<pre><code>&gt;&gt; obj: make object! [x: ~]

&gt;&gt; unresolved? $obj.x
== ~null~  ; anti

&gt;&gt; unresolved? $obj.asdf
== ~okay~  ; anti
</code></pre>
<p>I don't know if the UNRESOLVED? question should accept multiple steps of not being resolved.  Perhaps there's a refinement...</p>
<pre><code>&gt;&gt; unresolved? $asdf.jkl.qwertyiop
** Error: Multi-step unresolved, use UNRESOLVED?:MULTI if intended

&gt;&gt; unresolved?:multi $asdf.jkl.qwertyiop
== ~okay~  ; anti
</code></pre>
<p>Beyond that, it's a little tricky to cover all the states related to "unsetness".  There's TRIPWIRE! and TRASH! which both generate errors on reads, and currently both count as UNSET?.  Then DEFAULT will overwrite null variables as well...so that's DEFAULTABLE? (void variables aren't really understood as to whether default should overwrite them).</p>
<p>I don't know.  But I do think that terms like UNSPECIFIED?/UNRESOLVED?/UNDEFINED? all kind of cluster together... and among them UNRESOLVED? stands out to me as the best one to draw from for saying there really is no variable location at all.</p>
<h2><a name="p-8195-distinction-is-hazy-for-things-like-map-2" class="anchor" href="../could-an-unstable-mean-fully-remove-a-key/2431.html#p-8195-distinction-is-hazy-for-things-like-map-2"></a>Distinction Is Hazy For Things Like MAP!</h2>
<p>Originally I had it so you would remove keys from MAP! by setting them to <code>~null~</code> antiforms.</p>
<p>Later I decided it would be more consistent if you asked to "remove" them by setting them to trash, so they'd be unset and you'd have to TRY to access them.</p>
<p><strong>But removal from maps removes them from enumeration.</strong>  This is like being "unresolved", not like being "unset".</p>
<p>A similar issue happened with the ENVIRONMENT! type for modeling environment variables.  Removing with trash seems wrong.</p>
<h2><a name="p-8195-wild-thought-void-empty-pack-to-mean-remove-3" class="anchor" href="../could-an-unstable-mean-fully-remove-a-key/2431.html#p-8195-wild-thought-void-empty-pack-to-mean-remove-3"></a>Wild Thought: VOID (empty PACK!) To Mean REMOVE ?</h2>
<p>Empty PACK! (now called "VOID") is an unstable antiform used to opt out of things like COMPOSE</p>
<p><em>But what if it was the way to ask for a removal from a MAP?</em></p>
<pre><code> &gt;&gt; m: to map! [a 10 b 20]

 &gt;&gt; m.a: void
 == ~[]~  ; anti

 &gt;&gt; m
 == #[map [b 20]]
</code></pre>
<p>This would only be usable on datatypes where removals were legal... such as MAP! and ENVIRONMENT!.  You can't remove cells from a FRAME!--they're in fixed positions that have been compiled in.  Today's OBJECT! doesn't allow removals either (though perhaps it could/should?)</p>
<p>The rule for accepting an unstable assignment of this form would be that this removes the item from enumeration entirely.  Whereas if you assigned with a TRASH! the understanding is you're just making something that errors on access, but would still be in an enumeration of available keys.</p>
<h2><a name="p-8195-strangely-compelling-use-of-unstable-antiforms-4" class="anchor" href="../could-an-unstable-mean-fully-remove-a-key/2431.html#p-8195-strangely-compelling-use-of-unstable-antiforms-4"></a>Strangely Compelling Use Of Unstable Antiforms</h2>
<p>This does feel like it pushes to a clearer resolution of my misgivings of the incorrect parallels between map/environment removals and trashing object/frame cells... in terms of the effects on enumeration.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="1" />
              <span class='post-likes'>1 Like</span>
            </div>

                <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../re-imagining-do-next-as-eval-step/767/3.html">Re-imagining DO/NEXT as EVAL:STEP</a>
                        <meta itemprop='position' content='1'>
                      </div>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../should-failed-if-be-null-and-break-my-heart/2419/3.html">Should Failed IF Be NULL (and Break My Heart :broken_heart:)?</a>
                        <meta itemprop='position' content='2'>
                      </div>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../can-void-ghost-action-be-more-decay-friendly/2515.html">Can VOID, GHOST!, ACTION! Be More Decay-Friendly?</a>
                        <meta itemprop='position' content='3'>
                      </div>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../line-continuation-and-arity-bugs-thoughts/1965/3.html">Line Continuation and Arity Bugs: Thoughts?</a>
                        <meta itemprop='position' content='4'>
                      </div>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../why-are-trash-and-void-distinct-in-ren-c/2416/2.html">Why Are TRASH and VOID Distinct In Ren-C?</a>
                        <meta itemprop='position' content='5'>
                      </div>
                </div>
          </div>
          <div id='post_3' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2025-07-15T22:58:53Z' class='post-time'>
                    July 15, 2025, 10:58pm
                  </time>
                  <meta itemprop='dateModified' content='2025-07-15T22:58:53Z'>
              <span itemprop='position'>3</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>The concept of "void means remove" has gotten more entangled, now that it's legal to put unstable antiforms in metavariables (and, presumably, meta-map entries as well).</p>
<pre><code>&gt;&gt; m: make map! []

&gt;&gt; m.^key: pack [1 2]
== \~['1 '2]~\  ; antiform

&gt;&gt; m.^key
== \~['1 '2]~\  ; antiform
</code></pre>
<p>This means mapping to the empty pack of VOID (and presumably to GHOST!, or ERROR!) should be legal.</p>
<p><strong>That doesn't mean a non-^META assignment of VOID can't mean "remove".</strong>  But it would be a point of "inconsistency".</p>
<p>Though is it any more inconsistent than saying <strong><code>^e: fail "msg"</code></strong> is different from <strong><code>e: fail "msg"</code></strong> ... with the former storing an unstable ERROR! antiform, and the latter escalating the error to a panic?</p>
<p>Without some "assignment-based" mechanism to remove map keys, you'd have to use an operation that wasn't SET or a set-word.  For instance, if UNSET were kept as a prefix operation:</p>
<pre><code>unset $m.key
</code></pre>
<p>This requires branching your code in ways that aren't as pleasing as just being able to OPT your assignment out.</p>
<h2><a name="p-8522-rethinking-wacky-packs-1" class="anchor" href="../could-an-unstable-mean-fully-remove-a-key/2431.html#p-8522-rethinking-wacky-packs-1"></a>Rethinking "Wacky Packs"</h2>
<p>I have proposed the wacky idea of using PACK! as a means of doing things like assignment-with-typechecking, using sub-band values (like a BLOCK! which is neither quoted nor quasi):</p>
<pre><code>&gt;&gt; var: (typed [integer! tag!] 1020)
== \~[ [&amp;[parameter! [integer! tag!]] '1020] ]~\  antiform
</code></pre>
<p>That could pretty clearly decay to the value minus the typecheck.</p>
<p>Then I floated similar ideas for unsetting things, using sub-band WORD! for example:</p>
<pre><code>&gt;&gt; var: unset
== \~[ *unset* ]~\  antiform
</code></pre>
<p>That would also be not-quoted and not-quasi inside the pack...so it can be distinguished as a special signal.  However, I wasn't sure what that should decay to (e.g. if you wrote <strong>any [x: unset ...]</strong>)</p>
<p>But neither of these ideas would be effective for ^META assignment, because the meta assignment would just store the pack.</p>
<h2><a name="p-8522-why-be-any-more-obtuse-let-void-unset-variables-2" class="anchor" href="../could-an-unstable-mean-fully-remove-a-key/2431.html#p-8522-why-be-any-more-obtuse-let-void-unset-variables-2"></a>Why Be Any More Obtuse? Let VOID Unset Variables</h2>
<p>I'm kind of feeling now like VOID in non-^META assignments should just unset variables.  Then just live with the idea that ^META assignments can't be used to remove things.**  You can't have it both ways.</p>
<p>Since VOID is an empty PACK!, this would be a change from the situation of getting a panic today when you try:</p>
<pre><code>[x]: pack []   ; empty PACK! (definition of VOID)
</code></pre>
<p>Today the error guards you from misunderstandings, just as you're guarded against misunderstandings when you say:</p>
<pre><code>[x y]: pack [1]
</code></pre>
<p>But the problem is, that if you go and start trying to invent workarounds for ways to "assign" the unset state (like ~[<em>unset</em>]~) that are any weirder than this, your weirdness creates new problems.</p>
<hr>
<p><strong>I think that I now believe that either VOID non-^META assignments should be the way that you get the unset state, or there just isn't an offered way to get the unset state through assignment.</strong></p>
<hr>
<p>Ergonomically, being able to get the unset state through assignment has a lot of advantages.  And many assignments are not ^META.</p>
<p>I think it is worth it, to allow voids to unset variables--and remove them from maps--without having to write branching code to use a special removal operation.  If you truly are writing something "full-band" that wants to do meta-assignment -or- unset the variable, I guess it's acceptable that <em>then</em> you have to branch your code to do either a meta-assignment or a non-meta void assignment (or use the UNSET function).</p>
<h2><a name="p-8522-meditation-on-true-unset-3" class="anchor" href="../could-an-unstable-mean-fully-remove-a-key/2431.html#p-8522-meditation-on-true-unset-3"></a>Meditation on True Unset</h2>
<p>"Unsetness" is perpetually thorny.</p>
<p>The idea of true unset has been to create an out of band state which would defeat accesses by even meta variable access with ^VAR.  You cannot specialize function arguments with the unset state... hence it's a state FRAME! variables can be in (present, but unset) but not one that's very friendly.</p>
<p>If FRAME! variables can be "present, but unset" what is it about MAP! keys that means they can't be present in an enumeration, but unset?  Should object variables have this?  Module variables?</p>
<p>If object variables can have the unset state, and you can get it just with a non-^META assignment to void, when would you write <strong><code>field: ~</code></strong> vs. <strong><code>field: void</code></strong> ?  Why prefer one over the other?  At least one difference would be that <code>^field</code> would work on the trash-assigned-variable, but not on the void-assigned-hence-unset-variable... but how does that inform things more generally?</p>
<p>I'll just throw in a little reminder of why trash is distinct from void in other places, e.g. why PRINT returns trash and not void.  <a href="../console-treatment-of-void-vs-nothing/2045.html">The reason is that VOID opts out of too many things.</a>, and:</p>
<pre><code> append data (... print "Hello"))
</code></pre>
<p>...should error, not be silent.  TRASH!'s raison-d'etre is to throw wrenches in things, whereas VOID is silently accepted as an opt-out.</p>
<p>(<em>So if anything, the current philosophy is backwards...</em> VOID should silently unset a SET-WORD!, while TRASH should cause a panic on the assignment.  Not that I believe it <em>should</em>, I'm just saying that if anything should be a panic, it's probably trash...not void.)</p>
<p>Back to the question: if VOID doesn't remove from MAP!, it's useless.  But VOID <em>can't</em> remove fields from FRAME!, because you can't remove fields from frames--and it's not what we'd want it to do.  You need to still be able to FOR-EACH enumerate a FRAME! to get at its keys, even if they're not assigned yet.</p>
<p>OBJECT! has the same underlying implementation as FRAME!--just an ordered set of slots in memory.  Why would VOID assignment remove any of those slots from enumeration?  LET variables start out life in the unset state...so why wouldn't a VOID assignment return them to that state?</p>
<p>It really seems like MAP! is just the odd one out here.  <strong>But it's not storing variables, it's storing mappings.</strong>  You can't bind into a map either.  I guess we can say simply that the unset state is something only variables need to worry about preserving.</p>
<p><strong>So Should You Declare "unassigned" Variables with <code>field: ~</code> or With <code>field: void</code>?</strong></p>
<p><img src="../../images/emoji/twitter/thinking.png%3Fv=14" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>TRASH! is now truthy, by design, so using VOID means if you declare things in ANY or ALL, that would be skipped as a no-op, at least in the current imagining of ALL, that throws out voids:</p>
<pre><code> eval wrap all [
     x: y: z: void  ; ALL throws out voids this would be no vote
     ...
 ]
</code></pre>
<p>But one problem with it is that it's <em>not</em> assigning void, so it's misleading.  <img src="../../images/emoji/twitter/frowning.png%3Fv=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8522-reminder-why-isnt-void-was-the-unset-state-4" class="anchor" href="../could-an-unstable-mean-fully-remove-a-key/2431.html#p-8522-reminder-why-isnt-void-was-the-unset-state-4"></a>Reminder: Why Isn't VOID Was The Unset State?</h2>
<p>Because several changes have come that are new, it's good to ask why <strong>Why isn't VOID as a Meta-Variable Assignment The "UNSET" state?</strong></p>
<p>Where this starts to break is in FRAME! creation, where unspecialized slots look like they're assigned void:</p>
<pre><code>&gt;&gt; f: make frame! subtract/
== &amp;[frame! [
     ^value1: ~[]~
     ^value2: ~[]~
 ]]
</code></pre>
<p>The problem is, VOID is now used to opt-out of things.  You couldn't then tell the difference between:</p>
<pre><code> make frame! [foo void]
 make frame! [foo]
</code></pre>
<p><strong>This has been why the "truly unset" state has been important--something an evaluation cannot produce, yet a variable can represent (but never fetch with GET).</strong>  I do note, though, that there's an advantage if void is allowed to set things to the unset state, that means there can be a difference:</p>
<pre><code>&amp;[frame! [
     value1: ~[]~  ; non-meta assignment (value1 is unset)
     ^value2: ~[]~  ; meta-assignment (value2 is void)
 ]]
</code></pre>
<h2><a name="p-8522-guidance-still-hazy-but-mechanics-look-solid-5" class="anchor" href="../could-an-unstable-mean-fully-remove-a-key/2431.html#p-8522-guidance-still-hazy-but-mechanics-look-solid-5"></a>Guidance Still Hazy, But Mechanics Look Solid</h2>
<p>It bothers me some to have <strong><code>x: void</code></strong> be legal, because it looks like you've assigned void to the variable... when a non-^META assignment can't do that.  This has been an error historically, and it feels misleading to make it a non-error.</p>
<p><em>However</em>--as I've said--<em><strong>IF</strong></em> there is going to be a state that unsets variables through assignment, it doesn't make sense to use a state other than void (more generally, "missing pack slot").  There are too many questions opened up by using another state.</p>
<p>So as for the misleadingness... I could similarly say that it's misleading to do <strong>append [a b c] void</strong> and get back <strong>[a b c]</strong>, "because you didn't really append void".  No...because you can't append void to a block..but there is meaning applied to it anyway.</p>
<p>But when it comes to coherent source, this does make it seem better to assign things with <strong><code>~</code></strong> in general when you want to poison them.  This works whether you're doing an assignment or a meta-assignment, and also has a smooth transition to if you want to use a labeled trash.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

                <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../should-failed-if-be-null-and-break-my-heart/2419/4.html">Should Failed IF Be NULL (and Break My Heart :broken_heart:)?</a>
                        <meta itemprop='position' content='2'>
                      </div>
                </div>
          </div>
          <div id='post_4' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='https://rebol.metaeducation.com/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2025-07-16T10:31:52Z' class='post-time'>
                    July 16, 2025, 10:31am
                  </time>
                  <meta itemprop='dateModified' content='2025-07-16T10:31:52Z'>
              <span itemprop='position'>4</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2431">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="../../user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So Should You Declare "unassigned" Variables with <code>field: ~</code> or With <code>field: void</code>?</p>
</blockquote>
</aside>
<p>Given that <a href="../should-things-like-text-fail-on-null/2452.html">type-checking is more strict now with respect to NULL and TRASH</a>, this does give a possible reasoning for why you might want to use a "void-to-unset" assignment.</p>
<p>Right now if you have a variable which is meant to optionally hold a function value, you don't want to use NULL:</p>
<pre><code> some-hook-that-takes-integer: null   ; optionally a function
</code></pre>
<p>Because then, if you try to call it with no arguments when it's not set, you get a no-op in todays world:</p>
<pre><code>&gt;&gt; some-hook-that-takes-integer 10
== 10
</code></pre>
<p>So you use TRASH! to "poison" such values, to stop that from happening.</p>
<p><em>(Alternative conceptions have been that maybe if something evaluates to null but is "not used" that raises an error--this idea of inert value discards being an error is something I think about from time to time, but have never actually tried.  It would be easier now to try it, so I should just go ahead and see what happens.)</em></p>
<p>In any case, if you use <code>^some-hook-that-takes-integer</code> you can get it back as a trash value vs. erroring on access.  But TRASH! isn't easy to convert to void--it wasn't meant for it.</p>
<p>So if you wrote:</p>
<pre><code>apply opt ^some-hook-that-takes-integer [10]
</code></pre>
<p>You would likely be intending "run the function if it's there, ignore it if it's not".  But you'd be OPT-ing a trash, which doesn't give you void today.</p>
<p>However... if we were to go with the unset concept, and <a href="../what-should-new-refinements-e-g-foo-evaluate-to/2299/2.html">possibly leading colons turning them into nulls</a>, that would possibly allow for:</p>
<pre><code>apply opt :some-hook-that-takes-integer [10]
</code></pre>
<p>Then again, maybe OPT should be willing to turn TRASH! into null.  <img src="../../images/emoji/twitter/man_shrugging.png%3Fv=14" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20">  Trash lets you use descriptive messages for why something is trash, which being unset would sacrifice.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
    </div>


    




    </div>
    <footer class="container wrap">
  <nav class='crawler-nav'>
    <ul>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/' itemprop="url">Home </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/categories' itemprop="url">Categories </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://rebol.metaeducation.com/guidelines' itemprop="url">Guidelines </a>
        </span>
      </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://rebol.metaeducation.com/tos' itemprop="url">Terms of Service </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://rebol.metaeducation.com/privacy' itemprop="url">Privacy Policy </a>
          </span>
        </li>
    </ul>
  </nav>
  <p class='powered-by-link'>Powered by <a href="https://www.discourse.org">Discourse</a>, best viewed with JavaScript enabled</p>
</footer>

    
    
  </body>
  
</html>

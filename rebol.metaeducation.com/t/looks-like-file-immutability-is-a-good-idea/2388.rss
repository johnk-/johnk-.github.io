<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Looks Like FILE! Immutability Is A Good Idea</title>
    <link>https://rebol.metaeducation.com/t/looks-like-file-immutability-is-a-good-idea/2388</link>
    <description>Since changing URL! to be immutable, we&#39;ve realized several benefits.  Notably that you can&#39;t produce things that don&#39;t validate as URL! that are still claiming to be of type URL!:

    red&gt;&gt; url: https://red-lang.org
    == http://red-lang.org

    red&gt;&gt; reverse url
    == gro.gnal-der//:sptth

**sptth! indeed, I say.** :face_vomiting: 

    ren-c&gt;&gt; url: http://hostilefork.com
    == http://hostilefork.com

    ren-c&gt;&gt; reverse url
    ** Script Error: reverse expects [~void~ any-series? any-sequence? pair!] 

But besides that we get another advantage: we don&#39;t have to be paranoid about  URL! changing out from under us.

So for instance, when you LOAD some code from a URL! then we poke the address of that URL&#39;s data into all the blocks that get loaded.  This way you can ask for the FILE OF and get that URL! back.

*(As it gives a URL! sometimes and not a FILE!, that makes me wonder if we should call that SOURCE OF, and find another way to ask for *source code*... like IMPLEMENTATION OF).*

In any case, since we know the URL! can&#39;t change out from under us, we don&#39;t have to worry about storing the pointer that was passed to TRANSCODE by LOAD directly.  If we did have to worry, we&#39;d need to make a copy of it.

But with mutable FILE! **we do have to worry**, and copy it.  Otherwise:

    &gt;&gt; file: %my-awesome-script.r

    &gt;&gt; code: transcode:file (read file) file
    == [reverse [my script is awesome]]

    &gt;&gt; file of code.1
    ** Error: Only ANY-LIST? encode the file they were loaded from

    &gt;&gt; file of code.2
    == %my-awesome-script.r

    &gt;&gt; replace file &quot;awesome&quot; &quot;dumb&quot;
    == %my-dumb-script.r

    &gt;&gt; file of code.2
    == %my-dumb-script.r  ; ...but we loaded it from %my-awesome-script.r !

## Immutable FILE! means we could kill empty FILE!
   
Empty FILE! doesn&#39;t make sense.

* Did you want something that would cause an error when you appended it somewhere?  Use NULL.

* Did you want something that would be a no-op when you appended it somewhere?  Use VOID.

All the AI say roughly this:

&gt; There are no known filesystems that allow the empty string (`&quot;&quot;`) as a valid filename. Most modern filesystems, including ext4, NTFS, FAT variants, and others, explicitly disallow the empty string as a filename. This restriction is consistent with POSIX standards, which define filenames as non-empty character strings
&gt;
&gt; Historically, some older UNIX systems might have treated an empty string as an alias for the current directory, but this behavior was likely unintended and is no longer supported in contemporary systems

If we could get rid of empty FILE!, that gives us one more leg up in terms of the datatype providing actual value vs. just being a weak alias for string.

## Interpolation Is Stronger Than Mutable Manipulation

Now that we have interpolation, I think it can replace a lot of cases where you might have thought you needed to manipulate a file directly.

Also, the -OF functions will let you do things to immutable types:

    &gt;&gt; replace of %my-dumb-script.r &quot;dumb&quot; &quot;awesome&quot;
    == %my-awesome-script.r

I think this also points out a missing ability for PARSE, namely PARSE OF for immutable types.  e.g.:

     parse-of tuple rule
     =&gt;
     as tuple! parse to block! tuple rule

So for instance:

     &gt;&gt; parse of &#39;a.a.a.b.c.d [remove some &#39;a ~accept~]
     == b.c.d

Best of both worlds!

## Retaking % As A WORD!

With no empty files, we can say that % is clearly a WORD!

Maybe some other things too.  %% could be a WORD!, or a file with the name &quot;%&quot;.  There&#39;s lots of edge cases on that, e.g. to make a file with the name **`&quot;`** you&#39;d have to say `%-{&quot;}-`.  So I don&#39;t think we should be afraid to make %% a WORD! if that provides another interesting symbol.

## This Seems Like A Good Direction

I&#39;ve had the thought before, but recent improvements to OF makes it more palatable.

What motivated me to think about this right now was that I was resurrecting the LIBRARY! codebase, where you can load a DLL:

    &gt;&gt; make library! %some-thing.dll
    == #[library!]

I was thinking &quot;Hm, it seems like it would be nice if it stored the filename&quot;.

    &gt;&gt; make library! %some-thing.dll
    == #[library! %some-thing.dll]

And I was going to poke the FILE! value into a Cell in the LIBRARY!&#39;s Stub.  But then I thought &quot;oh no, what if they change it.&quot;

They shouldn&#39;t be able to.  Immutable FILE! is just better all around for the system.</description>
    
    <lastBuildDate>Fri, 28 Mar 2025 17:21:35 +0000</lastBuildDate>
    <category>Datatypes</category>
    <atom:link href="https://rebol.metaeducation.com/t/looks-like-file-immutability-is-a-good-idea/2388.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Looks Like FILE! Immutability Is A Good Idea</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Since changing URL! to be immutable, we've realized several benefits.  Notably that you can't produce things that don't validate as URL! that are still claiming to be of type URL!:</p>
<pre><code>red&gt;&gt; url: https://red-lang.org
== http://red-lang.org

red&gt;&gt; reverse url
== gro.gnal-der//:sptth
</code></pre>
<p><strong>sptth! indeed, I say.</strong> <img src="https://rebol.metaeducation.com/images/emoji/twitter/face_vomiting.png?v=14" title=":face_vomiting:" class="emoji" alt=":face_vomiting:" loading="lazy" width="20" height="20"></p>
<pre><code>ren-c&gt;&gt; url: http://hostilefork.com
== http://hostilefork.com

ren-c&gt;&gt; reverse url
** Script Error: reverse expects [~void~ any-series? any-sequence? pair!] 
</code></pre>
<p>But besides that we get another advantage: we don't have to be paranoid about  URL! changing out from under us.</p>
<p>So for instance, when you LOAD some code from a URL! then we poke the address of that URL's data into all the blocks that get loaded.  This way you can ask for the FILE OF and get that URL! back.</p>
<p><em>(As it gives a URL! sometimes and not a FILE!, that makes me wonder if we should call that SOURCE OF, and find another way to ask for <em>source code</em>... like IMPLEMENTATION OF).</em></p>
<p>In any case, since we know the URL! can't change out from under us, we don't have to worry about storing the pointer that was passed to TRANSCODE by LOAD directly.  If we did have to worry, we'd need to make a copy of it.</p>
<p>But with mutable FILE! <strong>we do have to worry</strong>, and copy it.  Otherwise:</p>
<pre><code>&gt;&gt; file: %my-awesome-script.r

&gt;&gt; code: transcode:file (read file) file
== [reverse [my script is awesome]]

&gt;&gt; file of code.1
** Error: Only ANY-LIST? encode the file they were loaded from

&gt;&gt; file of code.2
== %my-awesome-script.r

&gt;&gt; replace file "awesome" "dumb"
== %my-dumb-script.r

&gt;&gt; file of code.2
== %my-dumb-script.r  ; ...but we loaded it from %my-awesome-script.r !
</code></pre>
<h2><a name="p-8091-immutable-file-means-we-could-kill-empty-file-1" class="anchor" href="https://rebol.metaeducation.com#p-8091-immutable-file-means-we-could-kill-empty-file-1"></a>Immutable FILE! means we could kill empty FILE!</h2>
<p>Empty FILE! doesn't make sense.</p>
<ul>
<li>
<p>Did you want something that would cause an error when you appended it somewhere?  Use NULL.</p>
</li>
<li>
<p>Did you want something that would be a no-op when you appended it somewhere?  Use VOID.</p>
</li>
</ul>
<p>All the AI say roughly this:</p>
<blockquote>
<p>There are no known filesystems that allow the empty string (<code>""</code>) as a valid filename. Most modern filesystems, including ext4, NTFS, FAT variants, and others, explicitly disallow the empty string as a filename. This restriction is consistent with POSIX standards, which define filenames as non-empty character strings</p>
<p>Historically, some older UNIX systems might have treated an empty string as an alias for the current directory, but this behavior was likely unintended and is no longer supported in contemporary systems</p>
</blockquote>
<p>If we could get rid of empty FILE!, that gives us one more leg up in terms of the datatype providing actual value vs. just being a weak alias for string.</p>
<h2><a name="p-8091-interpolation-is-stronger-than-mutable-manipulation-2" class="anchor" href="https://rebol.metaeducation.com#p-8091-interpolation-is-stronger-than-mutable-manipulation-2"></a>Interpolation Is Stronger Than Mutable Manipulation</h2>
<p>Now that we have interpolation, I think it can replace a lot of cases where you might have thought you needed to manipulate a file directly.</p>
<p>Also, the -OF functions will let you do things to immutable types:</p>
<pre><code>&gt;&gt; replace of %my-dumb-script.r "dumb" "awesome"
== %my-awesome-script.r
</code></pre>
<p>I think this also points out a missing ability for PARSE, namely PARSE OF for immutable types.  e.g.:</p>
<pre><code> parse-of tuple rule
 =&gt;
 as tuple! parse to block! tuple rule
</code></pre>
<p>So for instance:</p>
<pre><code> &gt;&gt; parse of 'a.a.a.b.c.d [remove some 'a ~accept~]
 == b.c.d
</code></pre>
<p>Best of both worlds!</p>
<h2><a name="p-8091-retaking-as-a-word-3" class="anchor" href="https://rebol.metaeducation.com#p-8091-retaking-as-a-word-3"></a>Retaking % As A WORD!</h2>
<p>With no empty files, we can say that % is clearly a WORD!</p>
<p>Maybe some other things too.  %% could be a WORD!, or a file with the name "%".  There's lots of edge cases on that, e.g. to make a file with the name <strong><code>"</code></strong> you'd have to say <code>%-{"}-</code>.  So I don't think we should be afraid to make %% a WORD! if that provides another interesting symbol.</p>
<h2><a name="p-8091-this-seems-like-a-good-direction-4" class="anchor" href="https://rebol.metaeducation.com#p-8091-this-seems-like-a-good-direction-4"></a>This Seems Like A Good Direction</h2>
<p>I've had the thought before, but recent improvements to OF makes it more palatable.</p>
<p>What motivated me to think about this right now was that I was resurrecting the LIBRARY! codebase, where you can load a DLL:</p>
<pre><code>&gt;&gt; make library! %some-thing.dll
== #[library!]
</code></pre>
<p>I was thinking "Hm, it seems like it would be nice if it stored the filename".</p>
<pre><code>&gt;&gt; make library! %some-thing.dll
== #[library! %some-thing.dll]
</code></pre>
<p>And I was going to poke the FILE! value into a Cell in the LIBRARY!'s Stub.  But then I thought "oh no, what if they change it."</p>
<p>They shouldn't be able to.  Immutable FILE! is just better all around for the system.</p>
          <p><a href="https://rebol.metaeducation.com/t/looks-like-file-immutability-is-a-good-idea/2388/1">Read full topic</a></p>
        ]]></description>
        <link>https://rebol.metaeducation.com/t/looks-like-file-immutability-is-a-good-idea/2388/1</link>
        <pubDate>Fri, 28 Mar 2025 17:18:06 +0000</pubDate>
        <guid isPermaLink="false">rebol.metaeducation.com-post-2388-1</guid>
        <source url="https://rebol.metaeducation.com/t/looks-like-file-immutability-is-a-good-idea/2388.rss">Looks Like FILE! Immutability Is A Good Idea</source>
      </item>
  </channel>
</rss>

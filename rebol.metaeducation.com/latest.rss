<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest topics</title>
    <link>https://rebol.metaeducation.com/latest</link>
    <description>Latest topics</description>
    
      <lastBuildDate>Fri, 25 Jul 2025 17:41:49 +0000</lastBuildDate>
      <atom:link href="https://rebol.metaeducation.com/latest.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Optimizing 1-Element PACK!s / SPLICE!s</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p>Historically the most common type of PACK! is the 1-element PACK! holding a ~NULL~ antiform, that you get when a branching statement takes the branch and evaluates to null.</p>
<p>It's not supposed to be the case that antiforms have identity--once you make the transition from a plain form to an antiform, you lose the identity (and also, binding).</p>
<p>So really, every branching statement that returns a PACK!-boxed null can return the same boxed null.  Easy enough optimization--it's already done like that.</p>
<p>I've proposed something strange though... <a href="https://rebol.metaeducation.com/t/the-grand-leading-slash-safety-or-burden-question/2352/7">which is that putting actions in a PACK! be how they are "blessed" as legal to assign to plain WORD</a></p>
<p>I'm hopeful that can work.  But it brings up a question I've wrangled with in the past: <em>is there any way to make this cheap-as-free</em>?</p>
<p>e.g. <strong>Can a single Cell act as a proxy for an immutable array holding only itself?</strong></p>
<p>The idea was scrapped for things like BLOCK!, because you'd wind up with something that had nowhere to put the index or the binding.</p>
<p>But when it comes to PACK! (and SPLICE!...?) the binding requirement is gone, the index requirement is gone.  If the original array was at an index and seen to be one item, you'd just copy that one item out as the single Cell, and do some bit twiddling voodoo to it.</p>
<p>Can it work?</p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>In order to not tax the system too much on behalf of one weird optimization, it seems like you're down two bytes from the get-go: you've got the LIFT_BYTE at ANTIFORM_0 and the KIND_BYTE at TYPE_BLOCK.</p>
<p>Having those two bytes chewed out, it would mean the optimization would have to be something like 64-bit only, to reclaim those two bytes from the unused 32-bits in the header (which are typically unused to allow working on 32-bit platforms).  The other 3 platform pointers may all be used, because they may all contain platform pointers.  So really 64-bit builds only have 32 bits total to exploit.</p>
<p>Would tailored optimizations like this be a great use of that 32-bit advantage?  (As opposed to some cross-cutting feature that presumed to take the 32-bits out of all cells to do something more awesome)?  I don't know.  :-/</p>
<p>Is there some other way to leave the LIFT_BYTE and KIND_BYTE retain the single concent Cell's information, and yet somehow make the answer come back as PACK! without costing too much extra?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>The Cell could offer one bit for this... but it would wreck a lot of other optimizations if that bit didn't live somewhere in the LIFT_BYTE and KIND_BYTE.  The LIFT_BYTE already chews out 1 bit for quasi-ness (you can be both quoted and quasi, or quoted and non-quasi) which limits us to about 127 levels of quoting.  If another bit were sacrificed...let's just say it's the PACK!-bit... then we could say all PACK!s have this bit set, and we're cut down to 63-ish levels of quoting.</p>
<p>So then, if you have a regular PACK! it has the pack bit set...but when you clear the pack bit you see it's still an antiform with a heart that's a block.  And since you can't put PACK!s in packs directly (they're antiforms, they must be lifted) you know you've got a non-optimized pack.  Otherwise, you have a Cell which is the sole content of the pack.</p>
<p>It might seem like a problem that if you try to give back a pointer to the Cell as the content of the array, the only Cell you have in your hand has been corrupted with this pack bit.  So you index into the PACK! to find something that we've established acts as a PACK!.  However...this issue has already been solved for sequences, by an abstraction layer called <strong>"Arraylike"</strong>.  When you have an arraylike thing, you don't ask it for direct addresses of cells to operate on, you give it an index and ask it to fill a temporary Cell with the bits of what's at that index.  So this would be one of those things.</p>
<p><strong>Even if it could be done, this still runs afoul of a lot of the fingerprinting ideas that mask the two bytes in the header to determine its makeup.</strong>  <img src="https://rebol.metaeducation.com/images/emoji/twitter/fingerprint.png?v=14" title=":fingerprint:" class="emoji" alt=":fingerprint:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8557-just-a-placeholder-for-any-more-thoughts-1" class="anchor" href="https://rebol.metaeducation.com#p-8557-just-a-placeholder-for-any-more-thoughts-1"></a>Just a Placeholder For Any More Thoughts</h2>
<p>It's something to keep in mind, but more important to make sure the designs solve the problems, first.</p>
<p>I'm cautiously optimistic about using PACK!'d actions as the "approval" tool to do plain WORD!-assignment, but haven't done it yet, so don't know if it will actually be a good answer.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/optimizing-1-element-pack-s-splice-s/2516">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/optimizing-1-element-pack-s-splice-s/2516</link>
          <pubDate>Fri, 25 Jul 2025 17:41:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2516</guid>
          <source url="https://rebol.metaeducation.com/t/optimizing-1-element-pack-s-splice-s/2516.rss">Optimizing 1-Element PACK!s / SPLICE!s</source>
        </item>
        <item>
          <title>Can VOID, GHOST!, ACTION! Be More Decay-Friendly?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>I wrote about a <a href="https://rebol.metaeducation.com/t/re-imagining-do-next-as-eval-step/767/3">small but important tweak to the behavior of multi-returns</a>, which allowed changing:</p>
<pre><code>[pos :result]: eval:step pos
</code></pre>
<p>Into just:</p>
<pre><code>[pos result]: eval:step pos
</code></pre>
<p>I mention that I believe that that multi-returns with too few values unsetting the variables (vs. panic'ing in the moment) was better in the long run.  e.g. if EVAL:STEP returns just NULL and not a PACK!, then setting POS to NULL and <strong>unsetting</strong> RESULT was an overall win.</p>
<p><em>(Absorbing this requires understanding what modern "unsetness" is...variables truly holding no value, not even TRASH!, and what the implications of this so-called "dual state" are.)</em></p>
<p>I also mention that in practice, it would often be necessary for the result variable to be ^META.  Because if it's not, any non-decayable values would panic.  This wouldn't just happen for ERROR! antiforms (which there's a reasonable probability you'd want to just panic anyway).  It would also happen for GHOST!</p>
<pre><code>; this would panic -&gt; can't decay GHOST! to ordinary result, need ^result
[pos result]: eval:step [comment "hi" ...]
</code></pre>
<p>I'll point out that there's rules about ACTION!s as well, which are that you can't assign actions to plain variables unless they are deemed "unsurprising" (kind of a dicey concept, still being hammered out)</p>
<pre><code>; this would panic -&gt; can't assign ACTION! to plain WORD!, need ^result
[pos result]: eval:step [if okay [lambda [x] [x]] ...]  ; "surprising" action
</code></pre>
<p>We know the new rules for decay of VOID, which is to unset the variable, but what are the implications of that here?</p>
<pre><code>[pos result]: eval:step [foo: void ...]
</code></pre>
<p>That will unset <code>foo</code>, <a href="https://rebol.metaeducation.com/t/should-void-assigns-mean-fully-remove-a-key/2431">because that's now legitimate</a>.</p>
<p>But we're in a bit of an unfortunate position, because if we allow this decay it undermines one of my ideas <em>a little</em>... of saying that the unset state isn't an evaluative result.  (It's still true, in the sense that using <code>^result</code> would expose that the real evaluative state was void...but it feels like a shaky conflation.)</p>
<h2><a name="p-8555-question-on-the-table-can-this-be-easierbetter-1" class="anchor" href="https://rebol.metaeducation.com#p-8555-question-on-the-table-can-this-be-easierbetter-1"></a>Question On The Table: Can This Be Easier/Better?</h2>
<p>Lots to tackle here, but...</p>
<p>I'll start by mentioning an old trick, which was to say that by default EVAL would by default keep stepping to not show you the GHOST!s.</p>
<pre><code>&gt;&gt; [pos result]: eval:step [comment "hello" elide print "world" 10 + 20 ...]
world
== \~['[...] '30]~\  ; antiform
</code></pre>
<p>In that one step, it zoomed you past the GHOST!-producing steps and took you right to the first real result (if any).</p>
<p>That may seem convenient, but it means you need a refinement like :GHOSTABLE to ask to see the invisibles.  I'm kind of annoyed by it.</p>
<p>Another thought would be to give back something "innocuous" as a proxy for invisibility, under the assumption that the default would be not to care:</p>
<pre><code>&gt;&gt; [pos result]: eval:step [comment "hello" elide print "world" 10 + 20 ...]
== \~['[elide print "world" 10 + 20 ...] ~#ghost~]~\  ; antiform
</code></pre>
<p>There you're getting back a TRASH! that's a stable antiform, and it's labeled "<span class="hashtag-raw">#ghost</span>" which cues you to knowing it was a ghost (though it's a conflation, as it could have been a trash that said ghost).  That may be interesting to you for your purposes or it may not--maybe you don't have any particular difference in treatment in your particular evaluator client for things that return ghosts vs. a random thing that produced TRASH!.</p>
<p>So my concept here is: if you were already writing handling for TRASH!, maybe whatever you're doing for trash works well enough for ghosts too.</p>
<p>If we were to lean in this direction, I think it would support the idea that TRASH! is treated like no vote in things like ANY and ALL.  (<a href="https://rebol.metaeducation.com/t/the-truthiness-of-trash/2180/5">Right now it's truthy</a>, but the idea of being no vote is in the same ballpark and has been considered.)</p>
<p>And it might provide an escape hatch for the not-so-nice void problem as well:</p>
<pre><code>&gt;&gt; [pos result]: eval:step [foo: void ...]
== \~['[...] ~#void~]~\  ; antiform
</code></pre>
<p><strong>This would be SET-BLOCK saying that when it unpacks VOID and GHOST! into variables that are non-^META, it doesn't go through "standard decay"... because it doesn't want to conflate no pack item with pack item that's void or ghost.</strong></p>
<p>If we then made things like ANY and ALL treat TRASH! the same as voids/ghosts and just ignore it, then you can see a somewhat coherent plan taking shape, allowing you to get meaningful work done without having to invoke the ^META convention.  <em>"It's all trash to me"</em>, unless you have a reason to discern it.</p>
<h2><a name="p-8555-but-what-about-actions-2" class="anchor" href="https://rebol.metaeducation.com#p-8555-but-what-about-actions-2"></a>But, What About ACTION!s...?</h2>
<p>This question about "how much lying is acceptable" gets us into the weeds a bit here with ACTION!.</p>
<p>I'm trying to narrow down the cases where plain word assignments are allowed to put ACTION!s into words, because of the significant burden that it creates to not know whether variables contain actions or not.</p>
<p>Right now, saying you have to use ^META variables is that tool:</p>
<pre><code>[pos ^result]: eval:step [bar: lambda [x] [x] ...]
</code></pre>
<p>All the lying to make trash out of ghosts and voids wouldn't help a case for generalized eval-stepping if you couldn't step over that.</p>
<p>What could it do?  Return a TRASH! that says just <code>~#action~</code>  ?  Degrade it into a plain FRAME!, instead of an antiform one?</p>
<p>Between those two options, it seems to me producing TRASH! is the better plan.  As with ghost and void, if you find this is in-band of something you truly care about, you could deal with it.</p>
<p>Unfortunately, ACTION!s are truthy.  So we can't really square that with something that's trying to blend with TRASH!</p>
<h2><a name="p-8555-conclusions-3" class="anchor" href="https://rebol.metaeducation.com#p-8555-conclusions-3"></a>Conclusions (?)</h2>
<p>It may just be that if you're doing EVAL:STEP and you aren't completely sure what you're processing, you have to use ^META for the result.</p>
<p>I'm not 100% thrilled with the idea of not being able to distinguish:</p>
<pre><code>[x y]: pack [1 + 2 void]  ; will unset y

[x y]: pack [1 + 2]  ; will unset y
</code></pre>
<p>And only being able to tell the difference if you write:</p>
<pre><code>[x ^y]: pack [1 + 2 void]  ; ^y will hold void

[x ^y]: pack [1 + 2]  ; will unset y
</code></pre>
<p>But if it does that, is there any good reason for GHOST! not to do it too, so that at least if you think they both should be handled the same way that you only have to write one set of handling?</p>
<pre><code>&gt;&gt; x: comment "hi"
== \~,~\  ; antiform

&gt;&gt; unset? $x
== \~okay~\  ; antiform
</code></pre>
<p>Or is GHOST! &lt;=&gt; TRASH! conflation better?</p>
<pre><code>&gt;&gt; x: comment "hi"
== \~,~\  ; antiform

&gt;&gt; trash? ^x
== \~okay~\  ; antiform
</code></pre>
<h2><a name="p-8555-calm-down-people-it-was-just-a-little-liehttpswwwyoutubecomwatchvjuecqo7rz7c-4" class="anchor" href="https://rebol.metaeducation.com#p-8555-calm-down-people-it-was-just-a-little-liehttpswwwyoutubecomwatchvjuecqo7rz7c-4"></a><a href="https://www.youtube.com/watch?v=jUEcqo7Rz7c"><em>"Calm down people... it was just a little lie..."</em></a></h2>
<p><strong>This is tough, because plain ol' panic was comforting.</strong></p>
<p>But that first lie of saying non-^META assignments of VOID would unset variables led to a generalized principle that PACK!s that are too short to fulfill all their assignments would unset variables.  <strong>Yes it's a lie, but I've thought about this from a lot of angles now, and pretty sure that is the right choice.</strong></p>
<p>That lie wasn't made to stop people from having to ^META variables in packs, it was to stop them from having to <code>:OPTIONALIZE</code> them... which created a conflation.</p>
<p>With this new rule in place, there's the issue of whether these must be equivalent in terms of the effect on X:</p>
<pre><code> x: ...expr...  &lt;=&gt;    [x]: pack [...expr...]

^x: ...expr...  &lt;=&gt;   [^x]: pack [...expr...]
</code></pre>
<p><em>(The appealingness of the ^X case seems like a pretty strong argument for PACK to accept ERROR! by default, <a href="https://rebol.metaeducation.com/t/packs-decaying-to-first-item-when-others-are-error/2514">I think I'm realizing that it is misguided to panic on them and the safety problem should be addressed other ways</a>.)</em></p>
<p>If this rule needs to be true (and I think it does) then a VOID in a pack has to do what a void not in a pack would do... so if the variable is not ^META, it needs to unset it.</p>
<p><strong>Maybe that's the only lie, and we don't need to become pathological liars because of it.</strong></p>
<p>If GHOST! and ACTION! just panic for now when used in non-^META assignments, it just means people processing arbitrary code need to use ^META assignments, and that's basically futureproof (as much as anything here is).</p>
<p>If experience comes to show that more lies have value, we can  cross that bridge when we come to it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/can-void-ghost-action-be-more-decay-friendly/2515">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/can-void-ghost-action-be-more-decay-friendly/2515</link>
          <pubDate>Fri, 25 Jul 2025 15:53:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2515</guid>
          <source url="https://rebol.metaeducation.com/t/can-void-ghost-action-be-more-decay-friendly/2515.rss">Can VOID, GHOST!, ACTION! Be More Decay-Friendly?</source>
        </item>
        <item>
          <title>Packs Decaying To First Item When Others are ERROR!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>The concept of an "undecayable PACK!" came up when I was trying to reason about what should happen when you had things like PACK!s of PACK!s...</p>
<pre><code>&gt;&gt; x: pack [1 2]
== \~['1 '2]~\  ; antiform

&gt;&gt; x 
== 1

&gt;&gt; x: pack [pack [1 2] 3]
== ???
</code></pre>
<p><strong>My belief was that this should panic, rather than do the decay.</strong>  If you truly wanted the first element of an unpacked pack to decay, you could write:</p>
<pre><code>&gt;&gt; [x]: pack [pack [1 2] 3]
== \~[~[1 2]~ '3]~\  ; antiform

&gt;&gt; x
== 1
</code></pre>
<p><strong>This created the notion of an undecayable pack.</strong>  The first cut of the undecayable rule was that  that any pack with an unstable antiform in the first spot (GHOST!, PACK!, ERROR!) would panic if you tried to decay it (vs unpack it).</p>
<h2><a name="p-8553-safety-motivation-dont-let-error-disappear-1" class="anchor" href="https://rebol.metaeducation.com#p-8553-safety-motivation-dont-let-error-disappear-1"></a>Safety Motivation: Don't Let ERROR! Disappear</h2>
<p>Putting ERROR!s in PACK!s isn't the usual way of doing things.  If a function runs and wants to make you aware of an ERROR!, it should typically return that as the main result of a function...not stow it away inside a pack.  Only if it's the main result can it be reacted to by things like EXCEPT.</p>
<p>But some cases don't allow the error to be the sole return result.  For instance, EVALUATE:STEP</p>
<pre><code>[pos ^result]: evaluate:step [fail "abc" ...]
</code></pre>
<p>We need the updated position of the code, even if the code FAIL'd.  Hence, EVALUATE can't make its main result an ERROR! in the case of an error result, it has to give back a PACK! which encodes both the error and the new position.</p>
<p><em>("Has to" is a strong statement... it's possible that the next position could be a field of the error, <a href="https://rebol.metaeducation.com/t/should-evaluate-step-bomb-on-an-error/1491/3">I've discussed some of these odd ideas before</a>.  But it's better to allow errors in packs.)</em></p>
<p>If you don't receive result as ^META, then the ERROR! wouldn't be able to store in the ^result and would panic:</p>
<pre><code>[code result]: evaluate:step [fail "abc" ...]  ; not ^result, so panic
</code></pre>
<p>But what if you didn't store the result at all?</p>
<pre><code>code: evaluate:step [fail "abc" ...]  ; ???
</code></pre>
<p><strong>I feel like that should panic.</strong>  But why should you have to do an assignment to get the panic?</p>
<pre><code>evaluate:step [fail "abc" ...]  ; same behavior as when assigned to `code:` ?
</code></pre>
<p>That would suggest that if a PACK has an ERROR! in <em>any</em> slot, then should the pack decay and not extract that error into a ^META variable, that error becomes a panic.</p>
<p>But this thought leads to another invasive thought...</p>
<h2><a name="p-8553-what-about-errors-in-packs-2" class="anchor" href="https://rebol.metaeducation.com#p-8553-what-about-errors-in-packs-2"></a>...What About ERROR!s In PACK!s?</h2>
<p>I started by talking about undecayability, e.g. you can't put a PACK! in the first position of a PACK! and have it "double decay".  Decaying happens <em>once</em>.</p>
<p>And then I discussed decaying when there's an ERROR! in the pack... suggesting that an error at <em>any</em> position (not just the first) which is not unpacked into a ^META-variable should panic.</p>
<p>But what if you have a PACK! that's <em>not</em> in the first position of a PACK!... ?  Should that be willing to decay silently?</p>
<pre><code>&gt;&gt; x: pack [1 pack [2 3]]
== 1  ; silently discarded PACK! in second position...
</code></pre>
<p>That may seem harmless, BUT, what if that PACK! contained an ERROR! ?</p>
<p><em>This led me to theorize that packs which contained unstable antiforms at any position would be "undecayable"</em></p>
<p>However, that started to feel too strict, when we look at:</p>
<pre><code>[code result]: evaluate:step [pack [1 2] ...]  ; works, result decays to 1

code: evaluate:step [pack [1 2] ...]  ; innocuous, why shouldn't it work?
</code></pre>
<p>And even if I'm assigning the result, <a href="https://rebol.metaeducation.com/t/should-set-word-s-propagate-undecayed-packs/2178">PACK!s propagate in assignments now by default</a></p>
<pre><code>while [[code result]: evaluate:step code] [
    ...
]
</code></pre>
<p>It would be a shame if this decayed a PACK! for result, and then refused to decay it for the WHILE, making you write:</p>
<pre><code>while [[{code} result]: evaluate:step code] [
    ...
]
</code></pre>
<p>So pre-emptively refusing to toss PACK!s just because they <em>might</em> contain an ERROR! doesn't seem very ergonomic.</p>
<h2><a name="p-8553-non-first-item-recursive-pack-decay-search-for-error-3" class="anchor" href="https://rebol.metaeducation.com#p-8553-non-first-item-recursive-pack-decay-search-for-error-3"></a>Non-First Item Recursive PACK! Decay Search For ERROR!</h2>
<p>So... what if any PACK!s which aren't in the first position, that you want to discard, will recursively unpack themselves looking for ERROR!, and if they find any then panic?</p>
<p>(And ERROR!s which aren't in the first position, and aren't in PACK!, are also sources of panic?)</p>
<p>This would make the system more robust to dropping errors on the floor.  This might make it more reasonable to say that PACK is willing to pack up errors, generally... today you have to use a special operation:</p>
<pre><code> pack [1020 fail "won't work"]  ; panics 

 pack* [1020 fail "will work"]  ; allows the error
</code></pre>
<p>It's a little bit disconcerting, to imagine that instead of erroring at the moment of the PACK you trust that wherever the pack is going will handle the error.  But really, that only becomes a problem when you're dealing with using PACKs in non-multi-return situations, e.g. you make a PACK and then put it in suspended animation somewhere.</p>
<p>If you're <em>not</em> putting packs in suspended animation, but "packing with the intent of unpacking", then you're leaving it up to the recipient as to whether they want the error or not.</p>
<p>All things being equal, having just one PACK primitive is preferable.</p>
<p>Things do seem to be falling into place in other ways, and I'm sensing that maybe the right thing to do is to say that if you're a client with "pack with intent to store", then you bear the burden of the indefinite lifetime you may give errors in that pack...vs. making it harder to put errors in packs.</p>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/packs-decaying-to-first-item-when-others-are-error/2514">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/packs-decaying-to-first-item-when-others-are-error/2514</link>
          <pubDate>Fri, 25 Jul 2025 04:59:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2514</guid>
          <source url="https://rebol.metaeducation.com/t/packs-decaying-to-first-item-when-others-are-error/2514.rss">Packs Decaying To First Item When Others are ERROR!</source>
        </item>
        <item>
          <title>The WORD! vs. TEXT! Representation Gap</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Something that seems to come up a lot is exemplified in this issue with Rebmake regarding optimization levels.</p>
<p>The issue is that C compilers have optimization switches (like <code>-O2</code> or <code>-Os</code>) which let you say how to optimize what you're building.  2 may indicate higher optimizations than 1 or 0.  "s" could mean optimize for size.</p>
<p>When you're translating something like this into a dialect, it's tempting to think of this as being either a WORD! or an INTEGER!, and not having to put it in ditto marks <em>(Note: I'm going to call <code>"</code> ditto marks from now on, to help distinguish them from the phenomenon of "quoting")</em>.</p>
<pre><code>some-file.c [
    optimize: 2
]
another-file.c [
    optimize: s
]
</code></pre>
<p>If your dialect happens to not be evaluating the slots, this gives you a clean representation.  In the particular case of Rebmake, this is often taken on the command line, and the command line processing will LOAD the thing you pass. So:</p>
<pre><code> r3 make.r optimize: s
</code></pre>
<p>That works.  And if you said <strong><code>optimize: 's</code></strong> that would cause problems, because the shell thinks that's a quote mark that needs to be paired.</p>
<p>But if you're not lucky enough to be in an evaluative context, you'd need a quote mark.</p>
<h2><a name="p-8545-but-what-if-optimization-gets-settings-like-o2s-1" class="anchor" href="https://rebol.metaeducation.com#p-8545-but-what-if-optimization-gets-settings-like-o2s-1"></a>But What If Optimization Gets Settings Like <code>-O2s</code> ?</h2>
<p>It might seem neat to translate the string into an INTEGER! or WORD!.  You could compare integers against each other (e.g. to find out that 1 is greater than or less than the optimization level)... if they were both integers.  It feels nice to turn things into words.</p>
<p>But if you do a mapping--and don't fully control the domain you're mapping from--this can throw you a curveball.  And when it does, you'll have to put it in a string.  Now you've got INTEGER! <code>[0 1 2]</code>, WORD! <code>[s z]</code>, or TEXT! <code>["2s" and other illegal things]</code></p>
<p>At which point you'd probably ask: <strong>"Since I don't really control this, should I have left it as a string?"</strong>  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>Should you have stayed in your lane, and let it be <code>["0" "1" "2" "s" "z"]</code> to start with?</p>
<h2><a name="p-8545-for-now-word-and-integer-works-but-2" class="anchor" href="https://rebol.metaeducation.com#p-8545-for-now-word-and-integer-works-but-2"></a>For Now, WORD! and INTEGER! Works, But...</h2>
<p>I hit a problem because there was inconsistency when some places used <strong><code>"s"</code></strong> and others uses <strong><code>s</code></strong>.</p>
<p>I'm canonizing to the WORD! just to keep making progress.  But this kind of issue feels like it comes up often.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/the-word-vs-text-representation-gap/2513">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/the-word-vs-text-representation-gap/2513</link>
          <pubDate>Sat, 19 Jul 2025 07:23:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2513</guid>
          <source url="https://rebol.metaeducation.com/t/the-word-vs-text-representation-gap/2513.rss">The WORD! vs. TEXT! Representation Gap</source>
        </item>
        <item>
          <title>Should `[: . /]` Require Escaping In RUNE! ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Lexer</category>
          <description><![CDATA[
            <p>Should it be:</p>
<pre><code>&gt;&gt; second "a.b"
== #.
</code></pre>
<p>Or should it be:</p>
<pre><code>&gt;&gt; second "a.b"
== #"."
</code></pre>
<p>The ramifications here are that if these delimiters are RUNE! contents without escaping, then you can't put RUNE! inside of [CHAIN! PATH! TUPLE!]</p>
<pre><code>&gt;&gt; type of #a/b
== \~{rune!}~\  ; antiform  (e.g. not a PATH!)
</code></pre>
<h2><a name="p-8536-you-can-put-the-space-rune-in-sequences-today-1" class="anchor" href="https://rebol.metaeducation.com#p-8536-you-can-put-the-space-rune-in-sequences-today-1"></a>You Can Put the SPACE RUNE! In Sequences Today</h2>
<p>I haven't questioned it lately, but the <a href="https://rebol.metaeducation.com/t/reified-unreassignable-nothingness-space-runes/2457">SPACE character (now denoted by an underscore)</a> is what's used to indicate there's nothing in a PATH!/TUPLE!/CHAIN! slot:</p>
<pre><code>&gt;&gt; second first [:a]
== a

&gt;&gt; first first [:a]
== _
</code></pre>
<p>That doesn't mean that all RUNE! have to be legal.  It could be the only one that is.</p>
<h2><a name="p-8536-single-hash-is-the-biggest-loss-2" class="anchor" href="https://rebol.metaeducation.com#p-8536-single-hash-is-the-biggest-loss-2"></a>Single-Hash Is The Biggest Loss</h2>
<p>When I think about how one might use RUNE! in tuples or paths or chains, the patterns I think are most likely to be interesting for dialects would be those that just put hash marks in spots.  An example of the kinds of patterns:</p>
<pre><code>a:#:c

#:#:#

#:b:#
</code></pre>
<p>If you look at the problem with those glasses, you might question the value of:</p>
<pre><code>&gt;&gt; to text! #:#:#
== ":#:#"
</code></pre>
<p>But how you see such things depends on what examples you're comparing it to.</p>
<p>Note that if you just want the characters, <code>[: / .]</code> are WORD!</p>
<pre><code>&gt;&gt; parse "./:" ['. '/ ':]
== :
</code></pre>
<p>So you already have a 2-character means of matching them in strings, for that purpose...that looks cleaner than:</p>
<pre><code>&gt;&gt; parse "./:" [#. #/ #:]
== #:
</code></pre>
<h2><a name="p-8536-the-legality-of-space-twists-my-arm-a-bit-3" class="anchor" href="https://rebol.metaeducation.com#p-8536-the-legality-of-space-twists-my-arm-a-bit-3"></a>The Legality of SPACE Twists My Arm A Bit</h2>
<p>I did say that just because space runes are legal doesn't mean all runes need to be legal.  But it does make me more inclined to say they are.</p>
<p>My leaning here is to say you have to escape them.  I think the hash character in tuple!/path!/chain! has more potential for enabling novel features than worrying over slightly briefer character notations.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-require-escaping-in-rune/2511">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-require-escaping-in-rune/2511</link>
          <pubDate>Fri, 18 Jul 2025 05:42:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2511</guid>
          <source url="https://rebol.metaeducation.com/t/should-require-escaping-in-rune/2511.rss">Should `[: . /]` Require Escaping In RUNE! ?</source>
        </item>
        <item>
          <title>DATATYPE! vs. TYPE!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>Historical Rebol made the decision to call things like BLOCK! and INTEGER! "datatypes".</p>
<p>They were thus DATATYPE! and not TYPE!.</p>
<p>For a long time I thought that was unnecessarily wordy.  At some point I had a change of heart, and decided that I liked it.</p>
<p><em>I don't remember why I changed my mind, and can't find a post about that here.</em></p>
<p>It does have an advantage in the code as it stands, because internally <code>Type</code> is an enumeration (with an escape value in the enumeration as <code>TYPE_0</code> for <a href="https://rebol.metaeducation.com/t/extension-types-implementation/1203">extension types</a>)</p>
<p>Now that <a href="https://rebol.metaeducation.com/t/old-idea-revisited-datatype-as-antiform/2324">DATATYPE! is an antiform</a>, I do sort of appreciate it being a little "weirder" in its name.</p>
<p>But it's a decision that if it's going to be revisited, it needs to be revisited sooner rather than later.  It would be nice if I could remember why I thought there was a drawback to using just the name <code>TYPE!.</code></p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/datatype-vs-type/2510">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/datatype-vs-type/2510</link>
          <pubDate>Thu, 17 Jul 2025 10:58:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2510</guid>
          <source url="https://rebol.metaeducation.com/t/datatype-vs-type/2510.rss">DATATYPE! vs. TYPE!</source>
        </item>
        <item>
          <title>WasmGC - Garbage Collection In WebAssembly</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>WASM</category>
          <description><![CDATA[
            <p>There's not a whole lot of code for the Ren-C garbage collector.</p>
<p>The lack of code is good and bad.  On the bad side, it's not very fast or clever (though the Stub and Cell formats themselves are very clever).  On the good side, it means that it could maybe be swapped out with a more sophisticated one, or a GC that integrates better with its specific environment.</p>
<p>One emerging possibility in the WebAssembly build is WasmGC:</p>
<p><a href="https://github.com/WebAssembly/gc/blob/main/proposals/gc/Overview.md" class="inline-onebox">gc/proposals/gc/Overview.md at main · WebAssembly/gc · GitHub</a></p>
<p>I'm not sure exactly how much of a sacrifice of the design it would be to use such things.  All the sizes and bits are very precisely arranged, and it may be that in order to make use of a generalized garbage collector you have to give up control of struct layout and put everything in a form that the generic GC expects.</p>
<p>But it's something to look at.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/wasmgc-garbage-collection-in-webassembly/2509">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/wasmgc-garbage-collection-in-webassembly/2509</link>
          <pubDate>Wed, 16 Jul 2025 22:38:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2509</guid>
          <source url="https://rebol.metaeducation.com/t/wasmgc-garbage-collection-in-webassembly/2509.rss">WasmGC - Garbage Collection In WebAssembly</source>
        </item>
        <item>
          <title>Using ~null~ and ~okay~ instead of NULL and OKAY</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>When I first proposed some of the ideas like quasiforms, they were quite foreign.</p>
<p>Now they're familiar.  Given their familiarity, I start to wonder if the "weird" nature of null and okay is tolerable for source code.  e.g. might you write:</p>
<pre><code> var: ~null~
</code></pre>
<p>...instead of...:</p>
<pre><code>var: null
</code></pre>
<p>It's a bit annoying to type, but if you get used to it, it's not necessarily bad to stand out in that way.</p>
<p>Not that this should matter too much, but using <code>~null~</code> is inherently faster.  There's no variable to look up... you're just turning a WORD! at the quasiform lift level to the antiform lift level.  (Technically that does require validation, since not all quasi-words are legal anti-words, but this validation can be arbitrarily fast.)</p>
<p>One negative side of using the quasiforms is it may add noise where it's not something you want to emphasize.  As such, maybe this is a decision to be made on a case-by-case basis... do you want to draw attention or not, like... "HEY, I'm setting this to NULL and that's an important point!"</p>
<p>Not sure.  But I find myself tempted to use the quasiform now and again, and usually decide to back it out because I feel like it should be "always do it" or "never do it".  But maybe that's the worng dichotomy.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/using-null-and-okay-instead-of-null-and-okay/2508">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/using-null-and-okay-instead-of-null-and-okay/2508</link>
          <pubDate>Mon, 14 Jul 2025 07:33:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2508</guid>
          <source url="https://rebol.metaeducation.com/t/using-null-and-okay-instead-of-null-and-okay/2508.rss">Using ~null~ and ~okay~ instead of NULL and OKAY</source>
        </item>
        <item>
          <title>Picking Function Arguments By Integer</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p><a href="https://rebol.metaeducation.com/t/introducingnew-chain-datatype/2226">Having concepts like CHAIN!</a> means there are "set integers" now, which has opened up the possibility for things like:</p>
<pre><code>sub1000: specialize subtract/ [2: 1000]
</code></pre>
<p>This would prevent you from having to specifically know the name of the argument you are specializing.  That seems sensible, given that you don't need to know the name to call it.</p>
<p>It seems you should also be able to do this with frames:</p>
<pre><code>&gt;&gt; f: make frame! subtract/

&gt;&gt; f.1: 1020
&gt;&gt; f.2: 1000

&gt;&gt; eval f
== 20
</code></pre>
<p><strong>It should not work with refinements.</strong>  Rebol2/Red/R3-Alpha expose the implementation detail of what position refinement arguments are in, but it was a bad idea for them... and an even worse idea for Ren-C.</p>
<p>Consider AUGMENT, for example.  Let's make an arity-3 version of APPEND, that takes an argument to add before appending:</p>
<pre><code>&gt;&gt; apadd: adapt (augment append/ [num [integer!]]) [
       value: value + num
   ]

&gt;&gt; apadd [a b c] 1000 20
== [a b c 1020]
</code></pre>
<p>Do take a moment to appreciate how cool that is... AUGMENT creates a function with an expanded specification (but no variation in behavior), and then ADAPT puts in a preamble which uses the added parameter by adding it to the value...before falling through to the ordinary implementation of APPEND.  (ENCLOSE could be used if you had a more complicated idea for what to do that didn't fit as just an adjustment in a preamble.)</p>
<p>BUT once you're finished appreciating how cool that is, consider what we want if we make a frame for APADD:</p>
<pre><code>&gt;&gt; f: make frame! apadd/

&gt;&gt; f.1: [a b c]
&gt;&gt; f.2: 1000
&gt;&gt; f.3: 20

&gt;&gt; eval f
== [a b c 1020]
</code></pre>
<p>However, consider that it also has refinements available:</p>
<pre><code>&gt;&gt; apadd:dup [a b c] 1000 20 3
== [a b c 1020 1020 1020]
</code></pre>
<p><strong>So we see that the new non-refinement argument properly indexes as the 3rd argument, and it could not do that if refinements were INTEGER!-indexed.</strong>  Because if :DUP was something like index 3 in the frame for APPEND originally, it wouldn't be out of the way of the augmented form.</p>
<p>Seems pretty good, but there are some quirks...</p>
<h2><a name="p-8514-lens-matters-1" class="anchor" href="https://rebol.metaeducation.com#p-8514-lens-matters-1"></a>Lens Matters</h2>
<p>I've written a bit about <strong><a href="https://rebol.metaeducation.com/t/understanding-frame-lensing/1645">FRAME! Lensing</a></strong>.  It's not just an efficiency trick...because I wouldn't know how to implement function composition otherwise.</p>
<p>Because of Lenses, a frame built for a function with the same positionality can expose different interfaces.  Consider our APADD above, imagine specializing the thing you append to:</p>
<pre><code>&gt;&gt; data: [a b c]

&gt;&gt; accrue: specialize apadd/ [data]

&gt;&gt; accrue 1000 20
== [a b c 1020]

&gt;&gt; accrue 300 4
== [a b c 1020 304]
</code></pre>
<p>So now, we would hope that ACCRUE thinks of its 1 and 2 parameters as being what APADD thought of as 2 and 3.</p>
<pre><code>&gt;&gt; f: make frame! accrue/

&gt;&gt; f.1: 400
&gt;&gt; f.2: 21

&gt;&gt; eval f
== [a b c 1020 304 421]
</code></pre>
<p><strong>Satisfying!</strong></p>
<h2><a name="p-8514-but-what-does-integer-indexing-mean-with-no-lens-2" class="anchor" href="https://rebol.metaeducation.com#p-8514-but-what-does-integer-indexing-mean-with-no-lens-2"></a>But What Does Integer Indexing Mean With <em>No Lens</em> ?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></h2>
<p>There's a point where all the Lenses are gone, and you are in the raw function implementation... the FRAME! as the underlying implementation expected to see it.  If you do a FOR-EACH on a frame in this view, you see everything.. refinements, locals, definitional RETURN (if there is one).</p>
<pre><code>&gt;&gt; foo: func [arg1 :refine1 arg2 :refine2 &lt;local&gt; local1] [
       let frame: binding of $arg1
       for-each 'key frame [probe key]
   ]

&gt;&gt; foo 1020
return
arg1
refine1
arg2
refine2
local1
</code></pre>
<p>What (if anything) does indexing mean at this level?  <strong>frame.1</strong> giving you back the definitional RETURN would be barely useful... probably even <em>anti</em>-useful.</p>
<p><strong>I think it's pretty clear the integer indexing on an unlensed frame should act as if you were seeing the frame from the perspective of a caller with the "default Lens", e.g. what someone who did MAKE FRAME! would see.</strong></p>
<p>So <strong>frame.1</strong> would give you arg1, and <strong>frame.2</strong> would give you arg2, and that would be it.</p>
<h2><a name="p-8514-should-object-offer-indexed-access-3" class="anchor" href="https://rebol.metaeducation.com#p-8514-should-object-offer-indexed-access-3"></a>Should OBJECT! Offer Indexed Access?</h2>
<p>I've settled that FRAME! should offer it.  Here we see it has the interesting consequence that not all frame fields can be accessed with integer indexes, only</p>
<p>But I don't know what--if anything--this implies for OBJECT!.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/picking-function-arguments-by-integer/2507">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/picking-function-arguments-by-integer/2507</link>
          <pubDate>Mon, 14 Jul 2025 06:23:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2507</guid>
          <source url="https://rebol.metaeducation.com/t/picking-function-arguments-by-integer/2507.rss">Picking Function Arguments By Integer</source>
        </item>
        <item>
          <title>When Should Evaluative Constructs Return ERROR! ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p><strong><a href="https://rebol.metaeducation.com/t/panic-vs-return-fail-the-age-of-definitional-errors/1852">Definitional failures</a></strong> have been critical in moving to a robust model of error handling.</p>
<p>They're an ergonomic concept something like Rust's <strong><code>Result&lt;...&gt;</code></strong>, because they effectively multiplex errors onto a function's return value.  You're expected to triage errors at the moment they happen at a callsite or they promote to divergent panics...which are <a href="https://rebol.metaeducation.com/t/discouraging-the-interception-of-abrupt-failures/1871">not generally intended to be reacted to</a>--your program is conceptually terminated.  To make triage easier there is <a href="https://rebol.metaeducation.com/t/virtual-binding-based-error-propagation-operator/2389">TRAP, the error propagator</a>.</p>
<p><strong>Compared with R3-Alpha and Red's error-handling, this is night and day.</strong>  They are fundamentally broken/useless.  <em>(Curiously: <a href="https://rebol.metaeducation.com/t/rebol2s-hot-errors-abandoned-by-r3-alpha-red/2505">Rebol2 actually had a concept of "hot errors"</a>, that leaned in the direction of definitional errors, but that direction wasn't pushed through.)</em></p>
<hr>
<h2><a name="p-8504-non-terminal-eval-steps-that-dont-triage-will-panic-1" class="anchor" href="https://rebol.metaeducation.com#p-8504-non-terminal-eval-steps-that-dont-triage-will-panic-1"></a>Non-Terminal Eval Steps That Don't Triage Will Panic</h2>
<p>You can triage an ERROR! that's a result of an expression.  But only if it's the final step:</p>
<pre><code>&gt;&gt; error? (print "Error is last" 1 / 0)
Error is last
== \~okay~\  ; antiform

&gt;&gt; error? (1 / 0 print "Error is first")
** PANIC: attempt to divide by zero
</code></pre>
<p>Any evaluation product that comes after an ERROR! will cause a panic.</p>
<p>GHOST! is not exempt:</p>
<pre><code>&gt;&gt; error? (1 / 0 comment "no free pass for ghosts")
** PANIC: attempt to divide by zero
</code></pre>
<p>The reasoning is that just because a function returns a ghost, doesn't mean it doesn't have side effects... or doesn't depend in some way on the previous operation.</p>
<p>Currently, COMMA! isn't exempt, either:</p>
<pre><code>&gt;&gt; error? (1 / 0,)
** PANIC: attempt to divide by zero
</code></pre>
<p>This is something I might be willing to bend on, if we believe that:</p>
<pre><code>(
    some expression,
    another expression,
    yet another expression,
)
</code></pre>
<p>Absolutely has to be equivalent to:</p>
<pre><code>(
    some expression,
    another expression,
    yet another expression
)
</code></pre>
<p>But mechanically you'd have to scan ahead for any number of commas... and make sure you were at the end of the input after consuming all the commas.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/man_shrugging.png?v=14" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8504-plain-eval-would-act-the-same-as-the-group-above-2" class="anchor" href="https://rebol.metaeducation.com#p-8504-plain-eval-would-act-the-same-as-the-group-above-2"></a>Plain EVAL would act the same as the GROUP! above</h2>
<p>Only the last step can give an ERROR!.  Previous steps will panic.</p>
<p>And since branching constructs like an IF or a CASE statement uses EVAL to run their branches, they similarly drop the statement out at the last step. So you can synthesize ERROR! out of branches, without causing the branching construct to panic.</p>
<h2><a name="p-8504-evaltrap-name-pending-gives-error-at-any-step-3" class="anchor" href="https://rebol.metaeducation.com#p-8504-evaltrap-name-pending-gives-error-at-any-step-3"></a>"EVAL:TRAP" (name pending) Gives Error At Any Step</h2>
<p>I've proposed EVAL:TRAP as a variation which can stop the evaluation at any step that produces an ERROR!:</p>
<pre><code>&gt;&gt; error? eval:trap [print "Error is last" 1 / 0]
Error is last
== \~okay~\  ; antiform

&gt;&gt; error? (1 / 0 print "Error is first")
== \~okay~\
</code></pre>
<p>So the second case didn't make it to the PRINT, but it didn't PANIC.</p>
<h1><a name="p-8504-but-how-about-any-and-all-roll_eyes-4" class="anchor" href="https://rebol.metaeducation.com#p-8504-but-how-about-any-and-all-roll_eyes-4"></a>But How About ANY and ALL...?  <img src="https://rebol.metaeducation.com/images/emoji/twitter/roll_eyes.png?v=14" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></h1>
<p>The answer may be different.</p>
<p>You're supposed to reasonably be able to rely on the idea that if ALL gives you a result, it's the result of the final expression.  You thus might be thinking that if you get an error, that error is coming by contract from that last expression.  I'd say it seems reasonably clear that anything but the last expression should panic.</p>
<p>On the other hand...ANY is not expected to necessarily evaluate all of its clauses... it's supposed to return the first thing that passes its constraint (non-null as the default constraint).  So if it hit an ERROR! early, maybe it should return it?</p>
<p>I'm not sure.  I'll have to look at use cases.</p>
<h1><a name="p-8504-and-what-about-loops-5" class="anchor" href="https://rebol.metaeducation.com#p-8504-and-what-about-loops-5"></a>And What About Loops?</h1>
<p>If loops are willing to return definitional errors out of their body, that makes writing loop wrappers a bit trickier.</p>
<p>First let's ask about MAP-EACH, what should it do?</p>
<pre><code>map-each 'x [1 2 3] [either x = 2 [fail "some error"] [x * 10]]
</code></pre>
<p>You're getting behaviors that are somewhat equivalent to APPEND.  So it's like you wrote:</p>
<pre><code>list: []
append list x * 10
append list fail "some error"
</code></pre>
<p>APPEND doesn't propagate a failure like that.  And I don't see any reason why it should.</p>
<p>Next, let's consider wrapping loops... e.g. <a href="https://rebol.metaeducation.com/t/demonstrating-for-both-loop-composability-for-the-win/1833">the current formulation of FOR-BOTH</a>:</p>
<pre><code>for-both: func [var blk1 blk2 body] [
    return unlift:lite all [
        lift:lite for-each var blk1 body
        lift:lite for-each var blk2 body
    ]
]
</code></pre>
<p>At the moment, LIFT does not lift definitional errors by default, but panics on them.</p>
<p>So if FOR-EACH is willing to return definitional errors, then you won't get an equivalence between:</p>
<pre><code>for-each 'x [1] [fail "some error"]  ; definitional error result

for-both 'x [1] [] [fail "some error"]  ; panic

for-both 'x [] [1] [fail "some error"]  ; panic
</code></pre>
<p>It might seem that given what I say about ALL above, if LIFT:LITE were willing to leave ERROR! as ERROR! (as well as NULL as NULL, and GHOST! as GHOST!) then it would correctly panic on errors that weren't the last step... BUT... consider:</p>
<pre><code>all [
    fail "some error"
    comment "hmmm"
]
</code></pre>
<p>This runs afoul of my concept of not allowing a next step to run... producing a loophole in composition that is trying to leverage things like invisibility.</p>
<p><strong>This seems to be the crux of a fairly fundamental problem, regarding the need to be psychic in order to know whether an evaluation is going to be a no-op or not.</strong></p>
<p>If you're not looking at the loop data, but tell from the outside of the FOR-EACH after-the-fact if it had evaluations or not, then there's no way to know if a failure needs to be terminal.</p>
<p><em>This suggests that loops should probably panic if the body fails.</em>  They'd have to do so for any step except the last step anyway, and loops don't have an interface for psychically exposing if they're at the last step or not prior to execution.  It defeats composition to require otherwise, and the whole model would have to be redesigned to add this "psychic" aspect... which seems less easy than just saying "no, loops panic if the body fails".</p>
<h2><a name="p-8504-overall-carry-away-theres-subtleties-6" class="anchor" href="https://rebol.metaeducation.com#p-8504-overall-carry-away-theres-subtleties-6"></a>Overall Carry-away: There's Subtleties</h2>
<p>Decisions about definitional error propagation appear to be non-obvious.</p>
<p>panic-ing is a conservative default, and then you can get people to explicitly CATCH and THROW the errors if they need to work around it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/when-should-evaluative-constructs-return-error/2506">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/when-should-evaluative-constructs-return-error/2506</link>
          <pubDate>Thu, 10 Jul 2025 11:39:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2506</guid>
          <source url="https://rebol.metaeducation.com/t/when-should-evaluative-constructs-return-error/2506.rss">When Should Evaluative Constructs Return ERROR! ?</source>
        </item>
        <item>
          <title>Rebol2&#39;s &quot;Hot Errors&quot; (Abandoned by R3-Alpha, Red)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>Rebol2 had a concept which had the inklings of <a href="https://rebol.metaeducation.com/t/panic-vs-return-fail-the-age-of-definitional-errors/1852">definitional errors</a>, in the sense that if you would RETURN an ERROR! value, it would escalate itself to an exception if not triaged with special functions at the callsite:</p>
<pre><code>rebol2&gt;&gt; foo: func [] [return make error! "Boom"]

rebol2&gt;&gt; foo
** User Error: Boom
** Near: return make error! "Boom"

rebol2&gt;&gt; type? foo
== error!

rebol2&gt;&gt; (foo) print "No triage, this won't print"
** User Error: Boom
** Near: return make error! "Boom"

rebol2&gt;&gt; (disarm foo) print "Triaged, so this will print"
Triaged, so this will print

rebol2&gt;&gt; disarm foo

rebol2&gt;&gt; probe disarm foo
make object! [
    code: 800
    type: 'user
    id: 'message
    arg1: "Boom"
    arg2: none
    arg3: none
    near: [return make error! "Boom"]
    where: none
]
</code></pre>
<h2><a name="p-8502-why-was-this-abandoned-1" class="anchor" href="https://rebol.metaeducation.com#p-8502-why-was-this-abandoned-1"></a>Why Was This Abandoned?</h2>
<p><strong><a href="http://www.rebol.net/r3blogs/0007.html">According to Carl</a>:</strong></p>
<blockquote>
<p><em>"Prior versions of REBOL used 'hot' errors. That is, you had to treat error values in a special way or they would automatically trigger error processing. This behavior was originally implemented to keep errors from propagating too far from their origins (the principle was to preserve as much as possible the locality of the error)."</em></p>
<p><em>"These hot errors turned out to be overkill, and the benefit of error locality was offset by the difficulty of handling error values in general. (See the articles of <a href="https://web.archive.org/web/20060101045815/http://www.fm.vslib.cz/~ladislav/rebol/">Ladislav Mecir</a> who wrote excellent notes on this subject). It could be quite tricky at times."</em></p>
</blockquote>
<p>I'm not sure what articles he's referring to from Ladislav.  The link he provides has an error section where Ladislav points out some bugs and says <em>"any Rebol value should be obtainable as a result of an expression, a result of a parenthesized expression, a result of a block evaluation and a result of a function evaluation"</em>, which seems pretty uncontroversial.</p>
<h2><a name="p-8502-so-what-was-the-problem-2" class="anchor" href="https://rebol.metaeducation.com#p-8502-so-what-was-the-problem-2"></a>So... What Was The Problem?</h2>
<p>One big ergonomic problem is that TRY intercepted errors, but didn't disarm them.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<pre><code>rebol2&gt;&gt; foo: func [] [return make error! "Boom"]

rebol2&gt;&gt; caught: try [foo]
** User Error: Boom
** Near: return make error! "Boom"

rebol2&gt;&gt; caught/id
** User Error: Boom
** Near: return make error! "Boom"
</code></pre>
<p>That's incredibly inconvenient.  So why didn't TRY do a DISARM?</p>
<p>The problem is "hotness" was a property of all values of ERROR! type, and when you disarm them they'd become OBJECT!.  If TRY were to DISARM the error it wouldn't be an ERROR! anymore, so you couldn't test to see if your expression had produced an error or not.</p>
<p>You get this because you're trying to pack too much information into one return result.  It could have been addressed by having you write your TRY as arity-2 with an EXCEPT.</p>
<pre><code>rebol2&gt;&gt; try-except: func [code handler /local e] [
             return either error? e: try code [handler disarm :e] [:e]
         ]

rebol2&gt;&gt; try-except [foo] func [e] [probe e/arg1]
"Boom"

rebol2&gt;&gt; try-except [1 + 2] func [e] [probe e/arg1]
== 3
</code></pre>
<p>Ren-C gives you this with infix, and you can use an arrow function, so it's more pleasing:</p>
<pre><code>foo except e -&gt; [probe e.arg1]
</code></pre>
<h2><a name="p-8502-hot-errors-would-have-been-only-half-the-story-3" class="anchor" href="https://rebol.metaeducation.com#p-8502-hot-errors-would-have-been-only-half-the-story-3"></a>Hot Errors Would Have Been Only Half The Story</h2>
<p>It seems Rebol2 was on the right track by having a state you could carry in a function's return result, that would promote to a divergent panic if not triaged at the callsite.</p>
<p>But for it to gel, you need to draw a sharp line between divergent panics and ERROR!, and not mix up their interception (in fact, <a href="https://rebol.metaeducation.com/t/discouraging-the-interception-of-abrupt-failures/1871">you should practically never intercept divergent panics</a>).</p>
<p>Rebol2's TRY was a one-size-fits-none construct, considering any typo or deeply nested errors to be on par with one that was "RETURN'd" directly from the function you were calling:</p>
<pre><code>rebol2&gt;&gt; probe disarm try [read %nonexistent.txt]
make object! [
    code: 500
    type: 'access
    id: 'cannot-open
    arg1: "/C/Projects/rebol2/nonexistent.txt"
    arg2: none
    arg3: none
    near: [read %nonexistent.txt]
    where: 'halt-view
]

rebol2&gt;&gt; probe disarm try [rread %nonexistent.txt]
make object! [
    code: 300
    type: 'script
    id: 'no-value
    arg1: 'rread
    arg2: none
    arg3: none
    near: [rread %nonexistent.txt]
    where: 'halt-view
]
</code></pre>
<p>This makes it nigh impossible to act upon the information reliably.</p>
<h2><a name="p-8502-the-wayward-drift-to-all-errors-are-exceptions-4" class="anchor" href="https://rebol.metaeducation.com#p-8502-the-wayward-drift-to-all-errors-are-exceptions-4"></a>The Wayward Drift To All-Errors-Are-Exceptions...</h2>
<p>Despite Rebol2 being on the cusp of meaningful error handling, R3-Alpha went the way of the exception fallacy.  Jumping across arbitrary levels of stack running arbitrary code in order to handle an error in stack levels above is something that the software industry has pretty much debunked.</p>
<p>For the most part, exceptions need to be reserved for things that should basically <em>never</em> happen.  The rare systems that do handle them should be when it's required for mitigating damage or corruption that might occur if cleanup code doesn't get run.  Exceptions are not what you want to use to deliver garden variety errors...you need direct contracts between caller and callee.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/rebol2s-hot-errors-abandoned-by-r3-alpha-red/2505">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/rebol2s-hot-errors-abandoned-by-r3-alpha-red/2505</link>
          <pubDate>Thu, 10 Jul 2025 09:29:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2505</guid>
          <source url="https://rebol.metaeducation.com/t/rebol2s-hot-errors-abandoned-by-r3-alpha-red/2505.rss">Rebol2&#39;s &quot;Hot Errors&quot; (Abandoned by R3-Alpha, Red)</source>
        </item>
        <item>
          <title>Code Completion As CAPS-LOCK... Way Better Than Tab</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>C/C++ Implementation</category>
          <description><![CDATA[
            <p>The overloading of the tab key to mean "indent" and "complete code" has always been pretty horrible.  Now it's intolerable: suggestions from AI come out of the blue at any moment, and can hijack what would have been an indent nanoseconds before.  The tab key becomes completely unreliable in function.</p>
<p>This infuriated me enough to do something about it.</p>
<p>I decided to turn Caps Lock into an actually useful key.</p>
<p>It isn't too hard to do... <em>if you know what to do</em>.  Here's a handy guide.</p>
<h2><a name="p-8498-windows-powertoys-keyboard-managerhttpsgithubcommicrosoftpowertoystabreadme-ov-file-1" class="anchor" href="https://rebol.metaeducation.com#p-8498-windows-powertoys-keyboard-managerhttpsgithubcommicrosoftpowertoystabreadme-ov-file-1"></a>WINDOWS: <a href="https://github.com/microsoft/PowerToys?tab=readme-ov-file">PowerToys Keyboard Manager</a></h2>
<p>VSCode is actually able to map the caps lock key to completion without any special tools... BUT... <em>it won't stop the key from toggling the caps-lock state</em>.  If your caps lock has a light it will go on and off, and each time you do a completion it will toggle the casing.</p>
<p>So use <a href="https://github.com/microsoft/PowerToys?tab=readme-ov-file">Microsoft PowerToys</a>  <em>(it's open source!)</em>, specifically the <strong>Keyboard Manager</strong></p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/8d1de5ca96aaa4f3b77498e7cee347110cdc3217.png" data-download-href="https://rebol.metaeducation.com/uploads/default/8d1de5ca96aaa4f3b77498e7cee347110cdc3217" title="image"><img src="https://rebol.metaeducation.com/uploads/default/original/1X/8d1de5ca96aaa4f3b77498e7cee347110cdc3217.png" alt="image" data-base62-sha1="k8nntHpu3b9V1VPvvya970uaYqb" width="497" height="332"></a></div><p></p>
<p>I've remapped the CAPS LOCK key to <strong>F19</strong>.  My keyboard only has 12 function keys, so I'm not bumping anything I'd use out of the way.</p>
<p><em>(At first I didn't realize these extra function keys were available... and tried the "virtual keys" you can assign, with names "VK 1" up to "VK 252".  But choosing something in this range is a bit fraught... e.g. VK 1 is actually the mouse button.  And they show up in VSCode as "unknown" in the keyboard mapping.)</em></p>
<p>The strange choice of F19 (when it goes up to F24) is because the Mac solution can only go up to F20, and the Linux solution has a default collision that you have to do special overrides for F20.  If you want to be able to share your keymaps across your computers, F19 seems a good choice.</p>
<h2><a name="p-8498-apple-karabiner-elementshttpskarabiner-elementspqrsorg-2" class="anchor" href="https://rebol.metaeducation.com#p-8498-apple-karabiner-elementshttpskarabiner-elementspqrsorg-2"></a>APPLE: <a href="https://karabiner-elements.pqrs.org/">Karabiner Elements</a></h2>
<p>So the Mac lets you swap the Caps Lock for another modifier key (like Shift or Ctrl), or disable it entirely.  But you can't make it do anything specific as a key out of the box.</p>
<p>A program called <a href="https://karabiner-elements.pqrs.org/">Karabiner Elements</a> does a bunch of useful things ("and it's only a hundred megabytes")  <img src="https://rebol.metaeducation.com/images/emoji/twitter/roll_eyes.png?v=14" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></p>
<p>You'll have to approve a list of scary-sounding permissions that you are installing an app and driver that sees every key that you press.  But, Karabiner Elements is also open source:</p>
<p><a href="https://github.com/pqrs-org/Karabiner-Elements">https://github.com/pqrs-org/Karabiner-Elements</a></p>
<p>And they seem generally trustworthy enough in the scheme of things, to use their binaries, but... I guess it depends on how badly you want to remap the Caps Lock key.</p>
<p><em>(Disdain for all of this is certainly why Carl was aiming to have a Rebol OS.)</em></p>
<p>It's in "Simple Modifications":</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/4b057513043b5c269a8379553672de353272cad0.png" data-download-href="https://rebol.metaeducation.com/uploads/default/4b057513043b5c269a8379553672de353272cad0" title="image"><img src="https://rebol.metaeducation.com/uploads/default/optimized/1X/4b057513043b5c269a8379553672de353272cad0_2_517x124.png" alt="image" data-base62-sha1="aHFv9Lz7QcXbLTdJbvgRW1CiJ5S" width="517" height="124" srcset="https://rebol.metaeducation.com/uploads/default/optimized/1X/4b057513043b5c269a8379553672de353272cad0_2_517x124.png, https://rebol.metaeducation.com/uploads/default/optimized/1X/4b057513043b5c269a8379553672de353272cad0_2_775x186.png 1.5x, https://rebol.metaeducation.com/uploads/default/optimized/1X/4b057513043b5c269a8379553672de353272cad0_2_1034x248.png 2x" data-dominant-color="E8EAED"></a></div><p></p>
<p>Note that if you previously had the OS doing mappings of your modifier keys, this overrules that.  So you'll have to reconfigure your swappings of Command/Ctrl/Fn/etc.</p>
<h2><a name="p-8498-linux-keydhttpsgithubcomrvaiyakeyd-key-daemon-3" class="anchor" href="https://rebol.metaeducation.com#p-8498-linux-keydhttpsgithubcomrvaiyakeyd-key-daemon-3"></a>LINUX: <a href="https://github.com/rvaiya/keyd"><code>keyd</code></a> (key daemon)</h2>
<p>You would think a configuration thing like this would be easy on Linux, but it took me and the AI quite a while of trying things with no effect before a solution was found.</p>
<p>There are files that <em>look</em> like editing them should be able to produce the desired effect.  The files <code>/usr/share/X11/xkb/symbols/pc</code> and <code>/usr/share/X11/xkb/keycodes/evdev</code> sure look like source code for specifying the entirety of your keyboard's behavior.  But when it comes to the caps lock key, no dice--about the best I could accomplish was get it to not do anything (even though the light on the key toggled on and off).</p>
<p>The keyd project seems to be the right solution to this problem, and works on x11 or Wayland, and it's got some cool features too.  But it's not in the Debian repositories so you have to build it from source:</p>
<pre><code>git clone https://github.com/rvaiya/keyd
cd keyd
make
sudo make install
sudo systemctl enable keyd
sudo systemctl start keyd
</code></pre>
<p>Once you've got it, you edit <code>/etc/keyd/default.conf</code>:</p>
<pre><code>[ids]
*

[main]
capslock = f19
</code></pre>
<p>Then you restart the daemon:</p>
<pre><code>$ sudo systemctl restart keyd
</code></pre>
<p>If you're lucky, that should work!  But if your <code>xmodmap</code> contains instructions that route the keys to functions, you won't get them falling through to where VSCode and such can see them.  That's what's wrong with F20, it defaults to mapping the microphone input.  You can see it with a grep for F20's keycode, which is 198:</p>
<pre><code>$ xmodmap -pke | grep 198
keycode 198 = XF86AudioMicMute NoSymbol XF86AudioMicMute
</code></pre>
<p>Your Linux installation might have made other arbitrary choices, perhaps even with F19.</p>
<p>To get into the weeds with xmodmap, you can edit your <code>~/.Xmodmap</code> file:</p>
<pre><code>keycode 198 = F20
</code></pre>
<p>Load it to see the changes:</p>
<pre><code>$ xmodmap ~/.Xmodmap
</code></pre>
<p>For me, that worked to let me map it for F20.  But in this handy guide, I'm just suggesting using F19 so you don't have to go further with adding that xmodmap persistently to your startup files.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/code-completion-as-caps-lock-way-better-than-tab/2504">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/code-completion-as-caps-lock-way-better-than-tab/2504</link>
          <pubDate>Mon, 07 Jul 2025 11:36:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2504</guid>
          <source url="https://rebol.metaeducation.com/t/code-completion-as-caps-lock-way-better-than-tab/2504.rss">Code Completion As CAPS-LOCK... Way Better Than Tab</source>
        </item>
        <item>
          <title>How Could Money Be Applied To Further Ren-C?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Bounties</category>
          <description><![CDATA[
            <p>I've been starting to think about questions of how to further the development of Ren-C by spending some money on it.</p>
<h2><a name="p-8475-longest-running-idea-puzzle-solving-bounties-1" class="anchor" href="https://rebol.metaeducation.com#p-8475-longest-running-idea-puzzle-solving-bounties-1"></a>Longest-Running Idea: Puzzle-Solving Bounties</h2>
<p>I keep talking about having small ($100-ish) bounties for people coming up with efficient solutions to code golfing puzzles, to drum up interest.</p>
<p>That's taking some time to launch... because I want the language to be relatively complete in its design.  I want it to be that when people write up blog entries or a community starts building around the puzzles, they're generating artifacts of actual lasting value...because it speaks in terms of the language in its relatively final design.</p>
<p>Things just haven't been stable enough to go there yet.  I hope it can soon, but it won't be tomorrow.</p>
<h2><a name="p-8475-other-ideas-to-use-money-before-then-2" class="anchor" href="https://rebol.metaeducation.com#p-8475-other-ideas-to-use-money-before-then-2"></a>Other Ideas To Use Money Before Then?</h2>
<p>AI is teaching me that it's hard--even with a relatively competent assistant who never sleeps--to meaningfully delegate work.  So I'm skeptical of trying to hire someone to work on the interpreter... because anyone who is actually good enough to help vs. hinder would likely be expensive.</p>
<p>Though... I dunno.  The job market kind of sucks.  Maybe there are young go-getters who would be eager to take a small amount of pay to work on open source with a Microsoft Research veteran.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/man_shrugging.png?v=14" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p>
<p>For it to do anything for someone's resume, would probably have to incorporate and make a serious looking website.  <a class="mention" href="https://rebol.metaeducation.com/u/blackattr">@BlackATTR</a> is a reputable businessperson, maybe he could help it look respectable.</p>
<h2><a name="p-8475-working-with-indie-game-devs-3" class="anchor" href="https://rebol.metaeducation.com#p-8475-working-with-indie-game-devs-3"></a>Working With Indie Game Devs?</h2>
<p>If I could find a game dev who was willing to hack up a prototype of the game I want to do, in order to try and secure further development, that would be great.  But I don't know any such people I know trust to say "hey I'll pay your bills for a month or two while you work up this demo":</p>
<p><a href="https://rebol.metaeducation.com/t/rebmu-the-graphical-game/2499" class="inline-onebox">Rebmu: The Graphical Game</a></p>
<h2><a name="p-8475-bounties-for-publicity-projects-to-receptive-markets-4" class="anchor" href="https://rebol.metaeducation.com#p-8475-bounties-for-publicity-projects-to-receptive-markets-4"></a>Bounties For Publicity Projects To Receptive Markets?</h2>
<p><a href="https://discuss.haiku-os.org/t/rebol-3-19-0-released-and-how-to-get-it-on-haikudepot/16643">Oldes made the announcement of his Rebol3 on Haiku to what were predictably crickets.</a></p>
<p>But matters might be different with a more impressive language, if one could demo a skeletal tool that could do something novel on Haiku, and would fund development of it to become useful in some official community capacity?</p>
<p>For perspective, <a href="https://www.haiku-os.org/">their whole project fundraising target is just $30,000</a>... that's for the whole thing, and they're at $11,000.  If $10k is the kind of money that can move a needle with them...might it be worth the money to fund something that could build interest in the tool?</p>
<h2><a name="p-8475-ideas-welcome-5" class="anchor" href="https://rebol.metaeducation.com#p-8475-ideas-welcome-5"></a>Ideas Welcome.</h2>
<p>My confidence in the design is starting to get very high, and while I'm historically reticent to promote anything... it's actually coming up on time to do something akin to marketing.  And if I could be reasonably sure I'd actually get meaningful return for spending money on the project, I would spend it.</p>
            <p><small>10 posts - 6 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/how-could-money-be-applied-to-further-ren-c/2500">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/how-could-money-be-applied-to-further-ren-c/2500</link>
          <pubDate>Thu, 26 Jun 2025 05:17:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2500</guid>
          <source url="https://rebol.metaeducation.com/t/how-could-money-be-applied-to-further-ren-c/2500.rss">How Could Money Be Applied To Further Ren-C?</source>
        </item>
        <item>
          <title>Rebmu: The Graphical Game</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Rebmu</category>
          <description><![CDATA[
            <p><strong>I've been wanting to use Ren-C as the engine behind a graphical game.</strong></p>
<p>The idea would be that the things you're placing on the screen represent items in the evaluator, and it would be simplified and iconographic.</p>
<p>What I'm visualizing usually is something where array Elements are little circular Cells, and there are concentric shells around the Elements that represent layers of quoting.  Then, quasiforms and antiforms would be some alternate styling of these shells.  FENCE! and ELEMENT! and BLOCK! would be stylized but keep their delimiters... same with TUPLE! and CHAIN! and PATH!.</p>
<p>I don't know if there'd be any TEXT! strings... for simplification, everything would probably be a list.  So instead of <code>"ABC"</code> in the game you'd always be working with something like <code>[A B C]</code> or <code>[@A @B @C]</code>.  Though RUNE! may be needed for things like <code>_</code> and <code>#</code>.  I haven't gotten that far.</p>
<h2><a name="p-8474-visually-i-am-envisioning-something-like-opus-magnum-1" class="anchor" href="https://rebol.metaeducation.com#p-8474-visually-i-am-envisioning-something-like-opus-magnum-1"></a>Visually I Am Envisioning Something Like Opus Magnum</h2>
<p>The gameplay would be different, because I don't envision a separate "space" for where the "Code" is from the "Data".  But the vibe of the workspace I'm thinking would be inspired like it:</p>
<p><a href="https://www.youtube.com/watch?v=Uj689znjxpg">Opus Magnum, by Zachtronics</a></p>

<h2><a name="p-8474-experience-would-be-more-like-baba-is-you-2" class="anchor" href="https://rebol.metaeducation.com#p-8474-experience-would-be-more-like-baba-is-you-2"></a>Experience Would Be More Like Baba Is You</h2>
<p>In the game, you'd be putting your words and data all in the same space, so it would be more like Baba is You.</p>
<p><a href="https://www.youtube.com/watch?v=z3_yA4HTJfs">Baba Is You - Release Date Trailer - Nintendo Switch</a></p>

<h2><a name="p-8474-another-inspiration-would-be-patricks-parabox-3" class="anchor" href="https://rebol.metaeducation.com#p-8474-another-inspiration-would-be-patricks-parabox-3"></a>Another Inspiration Would Be Patrick's ParaBox</h2>
<p>This is another instance of something which has the feeling I'm looking for.  But the Patrick's Parabox guy had to come up with all the engine logic to resolve paradoxes and make sense of the behavior (as did the Baba is You guy).  What I'm talking about is just using the evaluator as it is... but grafting it into a GUI:</p>
<p><a href="https://www.youtube.com/watch?v=kDy6PMIz0Pg">Patrick's Parabox - Launch Trailer | PS5 Games</a></p>

<h2><a name="p-8474-i-really-need-a-demo-of-what-im-thinking-4" class="anchor" href="https://rebol.metaeducation.com#p-8474-i-really-need-a-demo-of-what-im-thinking-4"></a>I Really Need A Demo Of What I'm Thinking</h2>
<p>Part of me feels like there has to be an indie game dev out there who would love to be the one who gets to give antiforms and quasiforms their big break to a gaming audience.</p>
<p>So even if I made something with bad graphics... if I could show a few tutorial levels, and then maybe a couple of "good" levels (exposing people to PARSE mechanics and needing to use them to solve something)... I might be able to turn the whole UI and game design part over to someone else.</p>
<p>This is part of why I think getting people involved in the gaming spirit of Rebmu would be a win... to show the fun of it, and then try and figure out how to put that fun into a non-textual format</p>
<h2><a name="p-8474-although-some-text-programming-games-do-succeed-5" class="anchor" href="https://rebol.metaeducation.com#p-8474-although-some-text-programming-games-do-succeed-5"></a>Although... Some Text-Programming Games Do Succeed...</h2>
<p>TIS-100 from Zachtronics had an unusual amount of success and positive reviews.  Make of that what you will:</p>
<aside class="onebox allowlistedgeneric" data-onebox-src="https://store.steampowered.com/app/370360/TIS100/">
  <header class="source">
      <img src="https://store.steampowered.com/favicon.ico" class="site-icon" width="256" height="256">

      <a href="https://store.steampowered.com/app/370360/TIS100/" target="_blank" rel="noopener">store.steampowered.com</a>
  </header>

  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:616/353;"><img src="https://shared.fastly.steamstatic.com/store_item_assets/steam/apps/370360/capsule_616x353.jpg?t=1667071597" class="thumbnail" width="616" height="353"></div>

<h3><a href="https://store.steampowered.com/app/370360/TIS100/" target="_blank" rel="noopener">TIS-100 on Steam</a></h3>

  <p>TIS-100 is an open-ended programming game by Zachtronics, the creators of SpaceChem and Infinifactory, in which you rewrite corrupted code segments to repair the TIS-100 and unlock its secrets. It’s the assembly language programming game you never...</p>


  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<h2><a name="p-8474-the-fact-that-the-engine-runs-anywhere-is-good-6" class="anchor" href="https://rebol.metaeducation.com#p-8474-the-fact-that-the-engine-runs-anywhere-is-good-6"></a>The Fact That The Engine Runs Anywhere Is Good</h2>
<p>Running in the browser means people who work in HTML5/etc. could call into it, and I've got the JavaScript bridge already made.</p>
<p>But it could be integrated into basically any game dev framework anyone uses, as it builds as ANSI C99.</p>
<p>I should brush up the C++ interface, that made it a little more convenient to use.  With AI's help, I bet I could get a C# interface off the ground as well (I delved a little into that).</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/rebmu-the-graphical-game/2499">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/rebmu-the-graphical-game/2499</link>
          <pubDate>Thu, 26 Jun 2025 05:09:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2499</guid>
          <source url="https://rebol.metaeducation.com/t/rebmu-the-graphical-game/2499.rss">Rebmu: The Graphical Game</source>
        </item>
        <item>
          <title>&quot;Insanity Level&quot; for The Mu-Library In Rebmu</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Rebmu</category>
          <description><![CDATA[
            <p>Rebmu has a fairly strict design principle, which is that a typical library function can only be overridden with a version that is a <em>superset</em> of its functionality.  It can have special handling for things that would cause panics, but should give the same output for any valid input.</p>
<p>As an example: IF should not be redefined to something that would consider 0 to be conditionally false.  If you write regular old lowercase code, you always want:</p>
<pre><code>rebmu&gt;&gt; if 0 [print "truthy"]
truthy
</code></pre>
<p>However... IF typically doesn't allow VOIDs, TRASH!, ERROR! as conditions.  We could treat them all as falsey if we liked, or truthy.  Or do various weird things (IF of a VOID could make the whole IF expression void...)</p>
<p>And at the moment, WORD!s are illegal in the branch slot (the branch is not evaluated by default, it is taken literally for <strong><a href="https://rebol.metaeducation.com/t/soft-quoted-branching-light-elegant-fast/1020">"soft literal branching"</a></strong>).  But if WORD! wasn't an error, what could it mean?</p>
<p>I like the idea of it being able to build a specialized action out of the branch:</p>
<pre><code>rebmu&gt;&gt; if 0 print "truthy"
== truthy

rebmu&gt;&gt; if null print "truthy"
== \~null~\  ; antiform
</code></pre>
<p>So that would be like you had written:</p>
<pre><code>rebmu&gt;&gt; if 0 (specialize print/ ["truthy"])
== truthy

rebmu&gt;&gt; if null (specialize print/ ["truthy"])
== \~null~\  ; antiform
</code></pre>
<p>It could save the <code>[</code> and <code>]</code> off of a lot of calls, I think it would be particularly interesting with things like function:</p>
<pre><code>z: function [x y] any [equal? 10 add x y, equal? 20 subtract x y]
</code></pre>
<p>Which would wind up being written  like:</p>
<pre><code>Zfn[xY]ay[e?10adXyE?20sbXy]
</code></pre>
<p>Of course this is just the tip of the iceberg.</p>
<h2><a name="p-8456-lots-i-could-talk-about-but-wanted-to-mention-something-1" class="anchor" href="https://rebol.metaeducation.com#p-8456-lots-i-could-talk-about-but-wanted-to-mention-something-1"></a>Lots I Could Talk About, But Wanted To Mention Something</h2>
<p>In thinking about the idea of a version of IF that didn't raise ERROR!s but treated them as false, I thought about how maddening that would be to debug.</p>
<p>"True Rebmu" should probably be as liberal as it can about finding meaning for inputs, without concern for debuggability.  But you shouldn't dial the settings for insane unless you're actually using them.</p>
<p>So I think in the Rebmu header, there should be some configuration you can do.</p>
<pre><code>Rebmu [
    file: %99-bottles.rebmu
    title: "99 Bottles of Beer on the Wall, Code Golfed"
    configure: [
        if: [:errors-are-falsey :void-if-void-condition]
        ...
    ]
]
</code></pre>
<p>None of the options would be contradictory...they're all just creeping you along the path to ultimate "insanity mode" where it's maximally permissive (the zero-header run state, to be the most minimal characters for code golf).  Headers are just documentation of which facilities you're actually using on purpose in the program, to help debugging by not enabling behaviors you won't use.</p>
<p>For things like ERROR! are falsey in conditionals, it's something you should be able to turn on for all conditionals or selectively for specific ones.</p>
<p>This resembles the kinds of problems of configuration for "real" tasks, so will have to see how things like <a href="https://rebol.metaeducation.com/t/evaluator-hooking-rebindablesyntax/2443">RebindableSyntax</a> can help.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/insanity-level-for-the-mu-library-in-rebmu/2497">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/insanity-level-for-the-mu-library-in-rebmu/2497</link>
          <pubDate>Tue, 24 Jun 2025 06:41:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2497</guid>
          <source url="https://rebol.metaeducation.com/t/insanity-level-for-the-mu-library-in-rebmu/2497.rss">&quot;Insanity Level&quot; for The Mu-Library In Rebmu</source>
        </item>
        <item>
          <title>Some IPv6 Address Examples</title>
          <dc:creator><![CDATA[rebolbot]]></dc:creator>
          <category>Lexer</category>
          <description><![CDATA[
            <blockquote>
<p>If someone is going to parse ipv6 addresses, can you give a good spread of examples of the edge cases and things to worry about?  A good list of ipv6 addresses that is fairly short but gives coverage of the kinds of things you need to support?</p>
</blockquote>
<hr>
<h1><a name="p-8454-ipv6-address-parsing-test-cases-1" class="anchor" href="https://rebol.metaeducation.com#p-8454-ipv6-address-parsing-test-cases-1"></a>IPv6 Address Parsing Test Cases</h1>
<h2><a name="p-8454-basic-format-variations-2" class="anchor" href="https://rebol.metaeducation.com#p-8454-basic-format-variations-2"></a>Basic Format Variations</h2>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">2001:0db8:85a3:0000:0000:8a2e:0370:7334     # Full format
2001:db8:85a3:0:0:8a2e:370:7334             # Leading zeros omitted
2001:db8:85a3::8a2e:370:7334                # Zero compression
</code></pre>
<h2><a name="p-8454-zero-compression-edge-cases-3" class="anchor" href="https://rebol.metaeducation.com#p-8454-zero-compression-edge-cases-3"></a>Zero Compression Edge Cases</h2>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">::1                                         # Loopback (all zeros except last)
::                                          # All zeros address
2001:db8::                                  # Trailing zeros compressed
::2001:db8                                  # Leading zeros compressed
2001::1                                     # Middle zeros compressed
fe80::1%lo0                                 # With zone identifier
</code></pre>
<h2><a name="p-8454-special-addresses-4" class="anchor" href="https://rebol.metaeducation.com#p-8454-special-addresses-4"></a>Special Addresses</h2>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">::ffff:192.0.2.1                           # IPv4-mapped IPv6
::ffff:0:192.0.2.1                         # IPv4-mapped (alternative)
64:ff9b::192.0.2.33                        # IPv4-embedded IPv6
2002:cb00:7100::                            # 6to4 prefix
ff02::1                                     # Multicast
fe80::1                                     # Link-local
fc00::1                                     # Unique local
</code></pre>
<h2><a name="p-8454-bracket-and-port-notation-5" class="anchor" href="https://rebol.metaeducation.com#p-8454-bracket-and-port-notation-5"></a>Bracket and Port Notation</h2>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">[2001:db8::1]:80                            # With port
[::1]:8080                                  # Loopback with port
[fe80::1%eth0]:22                           # Zone ID with port
</code></pre>
<h2><a name="p-8454-maximum-length-cases-6" class="anchor" href="https://rebol.metaeducation.com#p-8454-maximum-length-cases-6"></a>Maximum Length Cases</h2>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff     # All F's (maximum)
2001:0db8:85a3:0000:0000:8a2e:0370:7334     # Full expanded form
</code></pre>
<h2><a name="p-8454-tricky-parsing-cases-7" class="anchor" href="https://rebol.metaeducation.com#p-8454-tricky-parsing-cases-7"></a>Tricky Parsing Cases</h2>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">2001:db8:0:0:1:0:0:1                        # Multiple zero groups (can't compress)
2001:0:0:0:0:0:0:1                          # Could be 2001::1
a:b:c:d:e:f:1:2                             # All single hex digits
::1:2:3:4:5:6:7                             # Compression at start with 7 groups
1:2:3:4:5:6:7::                             # Compression at end with 7 groups
</code></pre>
<h2><a name="p-8454-case-sensitivity-8" class="anchor" href="https://rebol.metaeducation.com#p-8454-case-sensitivity-8"></a>Case Sensitivity</h2>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">2001:DB8:85A3::8A2E:370:7334                # Uppercase
2001:db8:85a3::8a2e:370:7334                # Lowercase
2001:Db8:85A3::8a2E:370:7334                # Mixed case
</code></pre>
<h2><a name="p-8454-invalid-cases-should-reject-9" class="anchor" href="https://rebol.metaeducation.com#p-8454-invalid-cases-should-reject-9"></a>Invalid Cases (Should Reject)</h2>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">2001:db8::1::2                              # Double compression (invalid)
2001:db8:85a3::8a2e:370:7334:extra          # Too many groups
2001:db8:85a3:8a2e:370:7334                 # Too few groups (7 instead of 8)
2001:db8:85ag::1                            # Invalid hex character 'g'
2001:db8:12345::1                           # Group too long (&gt;4 hex digits)
</code></pre>
<h2><a name="p-8454-key-parsing-rules-to-implement-10" class="anchor" href="https://rebol.metaeducation.com#p-8454-key-parsing-rules-to-implement-10"></a>Key Parsing Rules to Implement</h2>
<ol>
<li><strong>Zero Compression</strong>: Only one <code>::</code> allowed per address</li>
<li><strong>Group Count</strong>: Must have exactly 8 groups when expanded</li>
<li><strong>Hex Validation</strong>: Each group is 1-4 hexadecimal digits</li>
<li><strong>Case Insensitive</strong>: Accept both upper and lowercase</li>
<li><strong>Leading Zeros</strong>: Optional in each group</li>
<li><strong>Zone Identifiers</strong>: Handle <code>%</code> suffix for link-local addresses</li>
<li><strong>Brackets</strong>: Required when specifying ports</li>
<li><strong>IPv4 Mapping</strong>: Special handling for <code>::ffff:</code> prefix</li>
</ol>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/some-ipv6-address-examples/2496">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/some-ipv6-address-examples/2496</link>
          <pubDate>Mon, 23 Jun 2025 22:52:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2496</guid>
          <source url="https://rebol.metaeducation.com/t/some-ipv6-address-examples/2496.rss">Some IPv6 Address Examples</source>
        </item>
        <item>
          <title>(TRANSCODE &quot;&quot;) should be empty BLOCK!, not NULL</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Lexer</category>
          <description><![CDATA[
            <p>I faced a circumstance in the CONSOLE, where I wanted to know if you entered nothing.  e.g. if you just hit enter:</p>
<pre><code>&gt;&gt;     ; &lt;-- hit enter here

&gt;&gt;
</code></pre>
<p>So it just cycled, the prompt, no <code>==</code> output.</p>
<p>If you actually loaded the empty code as <code>[]</code> and evaluated it, then you would get a GHOST!.</p>
<pre><code>&gt;&gt;   ; &lt;-- hit enter here
== \~,~\  ; antiform comma! ("ghost!")

&gt;&gt;
</code></pre>
<p>I found that annoying.  However, if you actually did put something in there that evaluated to ghost, I wanted to see it:</p>
<pre><code>&gt;&gt; comment "for example"
== \~,~\  ; antiform comma! ("ghost!")

&gt;&gt;
</code></pre>
<p>So sure, I could write:</p>
<pre><code> let code: transcode ...whatever...

 if [] = code [  ; nothing loaded
     ...cycle prompt, don't evaluate...
 ]
</code></pre>
<p>But I got the feeling that a TRANSCODE of an empty string (or string that is all comments") is probably one of those edge cases that people are probably not expecting... and if it happens you probably need special handling.  So making it have better error locality and handling by being NULL seemed like a good idea.</p>
<p>So I changed it to return NULL if nothing was transcoded.</p>
<pre><code>if not code [  ; (or `if null? code`, or `code else [...]` etc.)
    ...nothing loaded, cycle prompt, don't evaluate...
]
</code></pre>
<p>BUT having experienced some of the epicycles beyond the console, I think this was a mistake.</p>
<h2><a name="p-8447-transcode-has-a-lot-of-error-returns-1" class="anchor" href="https://rebol.metaeducation.com#p-8447-transcode-has-a-lot-of-error-returns-1"></a>Transcode Has A Lot Of ERROR! Returns</h2>
<p>If <strong><code>try transcode ...</code></strong> is going to be useful at all, you probably don't want to conflate the many potential errors it can return with just returning null because it was a valid empty input.</p>
<p>And in the basic case, an empty script is a valid script.  It does nothing.</p>
<p>Emptiness is easy enough to test for.  So I think that's what should be done here.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/transcode-should-be-empty-block-not-null/2495">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/transcode-should-be-empty-block-not-null/2495</link>
          <pubDate>Thu, 19 Jun 2025 21:35:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2495</guid>
          <source url="https://rebol.metaeducation.com/t/transcode-should-be-empty-block-not-null/2495.rss">(TRANSCODE &quot;&quot;) should be empty BLOCK!, not NULL</source>
        </item>
        <item>
          <title>Should $WORD Capture The Whole Binding Environment?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Binding</category>
          <description><![CDATA[
            <p>Right now, when you capture a binding to a WORD!, if it's not bound at that moment, it won't be found later:</p>
<pre><code>&gt;&gt; word: $foo  ; imagine foo is not defined anywhere
== foo

&gt;&gt; get word
** Error: foo is not bound

&gt;&gt; set (extend lib 'foo) 1020  ; add a FOO definition to lib module
== 1020

&gt;&gt; get word
** Error: foo is not bound
</code></pre>
<p>This is because at the moment you wrote <code>$foo</code>, it looked in the current context (which in a case like this in the console includes LIB)... and didn't find it.</p>
<p>Since it didn't find it at the <code>$foo</code> evaluation moment, the word you got was unbound.  It won't magically become bound if something comes along later.</p>
<h2><a name="p-8443-should-things-like-word-store-binding-environments-1" class="anchor" href="https://rebol.metaeducation.com#p-8443-should-things-like-word-store-binding-environments-1"></a>Should Things Like WORD! Store Binding Environments?</h2>
<p>It would change things.  Would it change them for good?</p>
<h3><a name="p-8443-function-arg-survivalhttpsrebolmetaeducationcomtwhat-happens-to-function-args-when-the-call-ends23417-needs-it-due-to-frame-lensinghttpsrebolmetaeducationcomtunderstanding-frame-lensing1645-2" class="anchor" href="https://rebol.metaeducation.com#p-8443-function-arg-survivalhttpsrebolmetaeducationcomtwhat-happens-to-function-args-when-the-call-ends23417-needs-it-due-to-frame-lensinghttpsrebolmetaeducationcomtunderstanding-frame-lensing1645-2"></a><a href="https://rebol.metaeducation.com/t/what-happens-to-function-args-when-the-call-ends/234/17">Function Arg Survival</a> Needs It Due To <a href="https://rebol.metaeducation.com/t/understanding-frame-lensing/1645">FRAME! Lensing</a></h3>
<p>This is what brought the issue to my attention right now (though I've been thinking about it a fairly long time).</p>
<p>The model in which WORD! gets bound to a FRAME! only stores the pointer to the frame, not the Lens that's in effect.</p>
<p>The only way you can know if your "lens" should account for if the function is actually running a body or not is by information carried in the binding chain.  Knowing only the final result--a pointer to the list of variables--is not enough.  You need the specifics of <em>how</em> the result was reached--to know which phase should be considered for lookup of the word.</p>
<h3><a name="p-8443-implementation-simplification-3" class="anchor" href="https://rebol.metaeducation.com#p-8443-implementation-simplification-3"></a>Implementation Simplification</h3>
<p>A win is that there isn't a distinct "kind" of binding for WORD!s that's different from BLOCK!s.  Everything that stores binding would do so in a common way.  That simplifies code.</p>
<h3><a name="p-8443-optimization-loss-of-multiple-gets-4" class="anchor" href="https://rebol.metaeducation.com#p-8443-optimization-loss-of-multiple-gets-4"></a>Optimization Loss Of Multiple Gets</h3>
<p>It does mean losing an optimization on if GET of the same bound word is done multiple times.</p>
<p>The ability to leverage that optimization has become punishingly rare.  Basically every WORD! in the "mostly-unbound world" already can't do much in the way of optimized lookups.</p>
<p>You'd get the benefit that the laziness would help if you didn't actually need to do the lookup resolution.  The "binding capture" is cheap-as-free (just pokes a pointer into a Cell).</p>
<h3><a name="p-8443-this-leaks-much-more-information-but-5" class="anchor" href="https://rebol.metaeducation.com#p-8443-this-leaks-much-more-information-but-5"></a>This Leaks Much More Information... But...</h3>
<p><a href="https://rebol.metaeducation.com/t/performance-and-security-implications-of-binding-leakage/2117">I've written about binding leakage before.</a>  This does make it worse, if you pass someone a WORD! that's bound you'd be passing a lot more information.</p>
<p>But it's always been a problem.  Passing someone a WORD! bound into an object has allowed you to get that object and crawl arbitrarily far, if you have a BINDING OF tool to extract it.</p>
<p>I rarely get bent out of shape over the security implications of these things.  But more just the garbage collector implications.</p>
<p>But I can't get too worked up over if you pass <strong>[a]</strong> instead of just <strong>a</strong> having all the same problems.</p>
<h2><a name="p-8443-biggest-potential-complaint-lost-invariant-6" class="anchor" href="https://rebol.metaeducation.com#p-8443-biggest-potential-complaint-lost-invariant-6"></a>Biggest Potential Complaint: Lost Invariant</h2>
<p>I showed a case where how it would work could change:</p>
<pre><code>&gt;&gt; word: $foo  ; imagine foo is not defined anywhere
== foo

&gt;&gt; get word
** Error: foo is not bound

&gt;&gt; set (extend lib 'foo) 1020  ; add a FOO definition to lib module
== 1020

&gt;&gt; get word
== 1020  ; would work if $foo bound to an environment chain
</code></pre>
<p>But this has further risks.  Consider this:</p>
<pre><code>&gt;&gt; lib.foo: 1337
== 1337

&gt;&gt; get word
== 1337

&gt;&gt; foo: 304  ; created in user context (or should be...)
== 304

&gt;&gt; get word
== 304

&gt;&gt; lib.word
== 1337
</code></pre>
<p>When you wrote <code>$foo</code> you caused it to bind into an environment chain that had the USER context first, then USER inherited LIB.  So it searches USER first, then LIB.</p>
<p>When something was added to LIB, it saw it.  But later, something added to USER could override it.</p>
<p><strong>Bug, or feature?</strong></p>
<p>It's a bit hard to tell.  When you said <strong><code>$foo</code></strong> you effectively said "bind into the current wacky environment, whatever that is".  Had you said <strong><code>bind lib 'foo</code></strong> you could have asked for something more specific.</p>
<h2><a name="p-8443-data-point-tuple-must-capture-environment-7" class="anchor" href="https://rebol.metaeducation.com#p-8443-data-point-tuple-must-capture-environment-7"></a>Data Point: TUPLE! Must Capture Environment</h2>
<p>When you write <strong><code>get $.foo</code></strong>, then what happens in that capture of environment has to put something onto <code>.foo</code> that's enough for GET to find what it needs.</p>
<p>And the current thinking is that <code>.foo</code> acts like <code>this.foo</code> -- looking up whatever THIS is defined to in the environment.</p>
<p>We don't want to put logic into the code behind <code>$.foo</code> that does the capture of THIS and pokes it in some secret location of the tuple binding.  It needs to just associate the whole environment with <code>.foo</code>.</p>
<p>This really starts to make it look like WORD! should line up with everything else and capture an environment, not just do a lookup and consider that the final answer.</p>
<p><strong>If this isn't what you want, the BIND operator should offer a more specific language for describing the exact bind resolving invariant you need.</strong></p>
<p>This is casual, cheap (well, it cheapens the definition of what $ does to be basically free), and fixes a problem with function argument indefinite lifetime.</p>
<h3><a name="p-8443-ill-try-changing-it-and-see-what-happens-8" class="anchor" href="https://rebol.metaeducation.com#p-8443-ill-try-changing-it-and-see-what-happens-8"></a>I'll Try Changing It And See What Happens...</h3>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-word-capture-the-whole-binding-environment/2494">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-word-capture-the-whole-binding-environment/2494</link>
          <pubDate>Wed, 18 Jun 2025 18:05:36 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2494</guid>
          <source url="https://rebol.metaeducation.com/t/should-word-capture-the-whole-binding-environment/2494.rss">Should $WORD Capture The Whole Binding Environment?</source>
        </item>
        <item>
          <title>Changing Build System Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>There was an old dialect that used blocks, like:</p>
<pre><code> sources-C: [
     %file1.c
     [%file2.c &lt;some&gt; &lt;options&gt;]
     %file3.c
 ]
</code></pre>
<p>This was because it was based on MAP-EACH and processing items seemed "easier" to do when you could go one item at a time.</p>
<p>But I decided I didn't like it.  I prefer to have the option blocks separate.  I'm also going back to accepting TUPLE!s/PATH!s (a bootstrap issue got in the way of this, but I found a workaround).</p>
<pre><code> sources-C: [
     file1.c
     file2.c [&lt;some&gt; &lt;options&gt;]
     file3.c
 ]
</code></pre>
<p>Traversing this means you have to do some PARSE-ing, but that's what makes it interesting.</p>
<p>Here's some code that's getting tossed, that did some "canonicalizing" of the old format:</p>
<pre><code>; Some places (like SOURCES: in %make-spec.r for extensions) are permissive
; in terms of their format:
;
;     sources-A: %file.jpg
;
;     sources-B: [%file.jpg &lt;some&gt; &lt;options&gt;]
;
;     sources-C: [
;         %file1.jpg
;         [%file2.jpg &lt;some&gt; &lt;options&gt;]
;         %file3.jpg
;     ]
;
; It's a bit irregular, but convenient.  This function regularizes it:
;
;     sources-A: [
;         [%file.c]
;     ]
;
;     sources-B: [
;         [%file.c &lt;some&gt; &lt;options&gt;]
;     ]
;
;     sources-C: [
;         [%file1.c]
;         [%file2.c &lt;some&gt; &lt;options&gt;]
;         [%file3.c]
;     ]
;
export to-block-of-file-blocks: func [
    return: "Will be a top-level COPY of the block, or new block"
        [block!]
    x [&lt;opt&gt; file! block!]
][
    if file? x [
        return reduce [blockify x]  ; case A
    ]
    any [null? x, x = []] then [
        return copy []
    ]
    if file? x.1 [
        all [
            not find (next x) file!
            not find (next x) block!
        ] then [
            return reduce [x]  ; case B
        ]
        ; fallthrough
    ]
    if find x tag! [  ; light check for mistakes
        panic [
            "FILE!/BLOCK! list can't contain TAG!s if multiple files:"
            mold:limit x 200
        ]
    ]
    return map-each 'item x [blockify item]  ; case C
]
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/changing-build-system-dialect/2491">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/changing-build-system-dialect/2491</link>
          <pubDate>Tue, 17 Jun 2025 09:05:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2491</guid>
          <source url="https://rebol.metaeducation.com/t/changing-build-system-dialect/2491.rss">Changing Build System Dialect</source>
        </item>
        <item>
          <title>Should WORD! Allow Sigils at non-HEAD Positions?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Lexer</category>
          <description><![CDATA[
            <p>Rebol2, R3-Alpha, and Red have always let you put apostrophes in WORD! if they're not at the head.</p>
<ul>
<li>
<p>That gives you weird WORD!s like <strong><code>didn't</code></strong> and <strong><code>isn't</code></strong>.</p>
</li>
<li>
<p>It also lets us and words with apostrophes to indicate "prime" and "double-prime" derivitave things, like <strong><code>f'</code></strong> or <strong><code>f''</code></strong></p>
</li>
</ul>
<p>So Ren-C has allowed this as well.</p>
<p>But now, we're in the era of Sigils.  What reasoning would there be to allow [$ ^ @] in WORD!s at non-head positions?</p>
<p>Well... it would give slightly more compatibility with <a href="https://rebol.metaeducation.com/t/webassembly-text-format-wat/2223">WebAssembly Text Format</a>.  They have identifiers with $ in the name...</p>
<ul>
<li>
<p><a href="https://medium.com/ax1al/learning-and-trying-to-reverse-web-assembly-for-fun-da98fdf962e8">I saw <strong>$FUNCSIG$ii</strong> as a real example</a></p>
</li>
<li>
<p>Things like <strong><code>$$</code></strong> or <strong><code>$$a</code></strong> would still be illegal, though you could say <strong><code>$a$</code></strong> as a TIED! WORD! with spelling "a$"</p>
</li>
</ul>
<p>But given some recent applications of <a href="https://rebol.metaeducation.com/t/reacting-to-tie-to-automate-binding/2462/3">using $ to do bound PICKs</a>, I came to wonder if we could shorthand:</p>
<pre><code>b: 10

block: [a b c]

assert [10 = get pick:bind block 2]
</code></pre>
<p>A plain PICK could be shorthanded as <strong><code>second</code></strong>.  So you could say <strong><code>second:bind</code></strong>, since SECOND is a specialization of PICK.</p>
<p>But I thought that maybe <strong><code>second$</code></strong> could make an okay shorthand for <strong><code>second:bind</code></strong></p>
<pre><code>assert [10 = get second$ block]
</code></pre>
<p>And in turn, that made me think <strong><code>pick$</code></strong> would be a generically useful shorthand for <strong><code>pick:bind</code></strong></p>
<p>It's certainly more communicative than <strong><code>pick*</code></strong>.</p>
<p>Whether these shorthands go in the box or not, I don't really know what the benefit is to prohibiting them.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/should-word-allow-sigils-at-non-head-positions/2490">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/should-word-allow-sigils-at-non-head-positions/2490</link>
          <pubDate>Tue, 17 Jun 2025 02:15:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2490</guid>
          <source url="https://rebol.metaeducation.com/t/should-word-allow-sigils-at-non-head-positions/2490.rss">Should WORD! Allow Sigils at non-HEAD Positions?</source>
        </item>
        <item>
          <title>Literal Arguments As Proxies For Dialects</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>I was looking at this detail in FOR-EACH and realized it was a kind of general question... <em>in parameter slots that take dialects, how often should we take that argument literally in order to make it easier to have it act as a dialect?</em></p>
<hr>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="2462">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/hostilefork/48/421_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/reacting-to-tie-to-automate-binding/2462/1">Reacting to TIE ($) To Automate Binding</a></div>
<blockquote>
<p>So in this FOR-EACH example, we can already imagine a convenience... of being able to annotate variables to say you want to propagate the binding (or "tie" the variables to the binding of the block). ...</p>
<p><code>for-each [$sw i] block</code></p>
</blockquote>
</aside>
<p>We can kind of clearly see here that the decorators belong on the variables "doing the picking", not the material being iterated or picked from...</p>
<p><strong>This makes me think I may have erred in switching FOR-EACH variables to be not-taken literally.</strong></p>
<p>I switched:</p>
<pre><code>for-each x [...]
</code></pre>
<p>To:</p>
<pre><code>for-each 'x [...]
</code></pre>
<p>I thought it was justified by the fact that <code>@x</code> would bind and keep the binding, and the decorator.  That allowed <code>for-each @x [...]</code> to do the right thing, even with a non-literal slot for the <code>@x</code>.</p>
<p>But with <code>$x</code> becoming a "thing", if you let that evaluate it loses the $.  So FOR-EACH wouldn't know you wanted the picked thing to be bound.  You'd have to remember to write:</p>
<pre><code>for-each '$x [...]
</code></pre>
<p>But that pattern simply wouldn't work with:</p>
<pre><code>for-each '@x [...]
</code></pre>
<p>You can't "reuse the binding" of something you quoted that has no binding.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/frowning.png?v=14" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8432-switch-it-back-1" class="anchor" href="https://rebol.metaeducation.com#p-8432-switch-it-back-1"></a>Switch It Back?</h2>
<p>If it changes back, you get uniform behavior:</p>
<pre><code>for-each whatever [a b c]

for-each [whatever] [a b c]
</code></pre>
<p>That means you can just write:</p>
<pre><code>for-each $x [...] [...]

for-each @x [...] [...]
</code></pre>
<p>And it will work.</p>
<p><strong>I can certainly see how it's nicer in the long run to use the literal parameter.  But it throws you a bit of a curve-ball educationally.</strong></p>
<p>Consider also <code>'x</code> being able to have its own dialected meaning in a block or not.</p>
<pre><code>for-each 'x [...]

for-each ['x y] [...]
</code></pre>
<p>That's more powerful.  But it's also in some pretty confusing territory for beginners, having to deal with that slot being literal.</p>
<p><strong>I'm torn about it, but this <code>for-each $x [...]</code> case does really have me thinking that it should be changed back.</strong>  Seeing that you'd have to write <code>for-each '$x [...]</code> but then <code>for-each '@x [...]</code> <em>wouldn't</em> work makes me think it's just healthier for that parameter slot to be dialected, and you use a GROUP! if you need to escape it... which is <em>very rare</em>.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/literal-arguments-as-proxies-for-dialects/2489">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/literal-arguments-as-proxies-for-dialects/2489</link>
          <pubDate>Mon, 16 Jun 2025 20:20:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2489</guid>
          <source url="https://rebol.metaeducation.com/t/literal-arguments-as-proxies-for-dialects/2489.rss">Literal Arguments As Proxies For Dialects</source>
        </item>
        <item>
          <title>Advancements in CastHelper for Hooked Casts</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>C/C++ Implementation</category>
          <description><![CDATA[
            <p>Progress has been fairly amazing on the debug checks for casts.</p>
<p>The "user experience" of writing hooks for the casts used to be very hard-to-read code for a non-C++ programmer...but it's now very simple!</p>
<p>Just to give one example, consider casting to an "Element" (e.g. an Array element, something that can live in a BLOCK! or GROUP!).</p>
<p>As a reminder of what the idea is: anywhere in the source where you write either:</p>
<pre><code>cast(Element*, ...)
cast(const Element*, ...)
</code></pre>
<p>In an ordinary C build, it will just act like:</p>
<pre><code>(Element*)(...)
(const Element*)(...)
</code></pre>
<p>But in an instrumented build using C++, it's possible to add checks.  These checks can be at compile-time (prohibiting conversions of some combination of types)... or they can be at runtime, validating the bit patterns of the thing being converted.</p>
<p>For Element, we have:</p>
<pre><code>DECLARE_C_TYPE_LIST(g_convertible_to_cell,
    Cell, Atom, Element, Value,
    Pairing,
    Node, Byte, char, void
);

template&lt;typename F&gt;
struct CastHelper&lt;const F*, const Element*&gt; {
  static void Validate_Bits(const F* p)
  {
    STATIC_ASSERT(In_C_Type_List(g_convertible_to_cell, F));

    const Cell* c = u_cast(const Cell*, p);
    Assert_Cell_Readable(c);
    assert(LIFT_BYTE(c) != ANTIFORM_0);
  }
};
</code></pre>
<p><strong>That's extremely easy to read!</strong></p>
<ul>
<li>
<p>We are making sure that the <a href="https://rebol.metaeducation.com/t/lift-byte-values-antiform-normal-quasi-quoted/2091">LIFT_BYTE() is not 0</a>, hence not an antiform.</p>
</li>
<li>
<p>We're also checking that it's a valid readable cell (e.g. the bits have NODE_FLAG_NODE and NODE_FLAG_CELL, and NODE_FLAG_UNREADABLE is not set.)**</p>
</li>
<li>
<p>Plus, at <strong>compile-time</strong>, it's stopping you from all manner of casts which might be accidental to make Cells from things that can't make sense as Cells.</p>
</li>
</ul>
<p>What <strong><code>template&lt;typename F&gt;</code></strong>  means is that this is a "wildcard" pattern-matching rule, that the compiler will try to match against any pointer to F.  The name F is arbitrary, but chosen to represent "FROM", e.g. the datatype we are converting from.</p>
<p>(It would be possible to use more than one wildcard, e.g. <strong><code>template&lt;typename F, typename T&gt;</code></strong> and match patterns in both the "TO" and the "FROM".  But here we're fixed as defining conversions TO an Element*, so there's no second parameter to the template.)</p>
<h2><a name="p-8428-write-just-the-const-casts-works-for-mutable-1" class="anchor" href="https://rebol.metaeducation.com#p-8428-write-just-the-const-casts-works-for-mutable-1"></a>Write Just The Const Casts, Works For Mutable</h2>
<p>I hammered on this until I could get it to where you could just write the const casts, and it will take care of the mutable form casts (including blocking casting away constness)... running through the same code.  So you don't have to write two entry points and do the piping through common code yourself.</p>
<p>I'm on the fence on whether it's worth it to put in wiring to make it possible to separately hook mutable casts--to make sure the bit patterns you have are legal for a mutable pointer.  That's not really needed given the protection of casting away constness, and the cases where you do cast mutably from raw pointers you probably are doing that on purpose.  But definitely it needs to default to that if you write just the const casts you hook all of them for that pattern match, because this is 99% of the time what you want...it shouldn't be laborious.</p>
<h2><a name="p-8428-c-is-minimized-declare_c_type_list-2" class="anchor" href="https://rebol.metaeducation.com#p-8428-c-is-minimized-declare_c_type_list-2"></a>C++ Is Minimized: DECLARE_C_TYPE_LIST()</h2>
<p>Without DECLARE_C_TYPE_LIST() and In_C_Type_List(), this would look like:</p>
<pre><code>using g_convertible_to_cell = CTypeList&lt;
    Cell, Atom, Element, Value,
    Pairing,
    Node, Byte, char, void
)&gt;;

STATIC_ASSERT((g_convertible_to_cell::contains&lt;F&gt;{}));
</code></pre>
<p>It's quirky--including the quirk that you can't call the STATIC_ASSERT() macro on expressions which contain templating <code>&lt;...&gt;</code> markers unless they're wrapped in an extra set of parentheses.  So you have to use <code>static_assert()</code> which enforces arity-2 in C++11.</p>
<h2><a name="p-8428-also-less-c-u_cast-3" class="anchor" href="https://rebol.metaeducation.com#p-8428-also-less-c-u_cast-3"></a>Also Less C++: u_cast()</h2>
<p>You don't want to run the cast hooks while implementing a cast hook!  Originally I used <code>reinterpret_cast</code> in this code, so it looked like:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">    const Cell* c = reinterpret_cast&lt;const Cell*&gt;(p);
    Assert_Cell_Readable(c);
    assert(LIFT_BYTE(c) != ANTIFORM_0);
    return reinterpret_cast&lt;const Element*&gt;(c);
</code></pre>
<p>But the casting system offers <strong><code>u_cast()</code></strong> as an "unchecked" cast that nevers run the hooks (but is easier to spot as being a cast than the parentheses cast it expands to).</p>
<p>It makes it shorter and less scary to use <code>u_cast()</code>, and that's what's used in the rest of the codebase to implement unchecked cast.  So that helps make the code more familiar to what the rest of the C looks like.</p>
<h2><a name="p-8428-should-the-template-be-abstracted-away-too-4" class="anchor" href="https://rebol.metaeducation.com#p-8428-should-the-template-be-abstracted-away-too-4"></a>Should The <code>template&lt;&gt;</code> be Abstracted Away, Too?</h2>
<p>I don't think so.</p>
<p>I think that goes into the realm of pandering a bit too much to C fraidy-cats.  It's tougher to abstract and I think that token-for-token, it gets it right.</p>
<p>The value here is apparent--and I think I've done as much pandering as is appropriate.  What's left is legitimate C++ that matches the essential complexity of the problem.  (It's not even duplicating the signature of the types needlessly, as you might use reference types in those positions.)</p>
<h2><a name="p-8428-in-total-this-is-awesome-stuff-5" class="anchor" href="https://rebol.metaeducation.com#p-8428-in-total-this-is-awesome-stuff-5"></a>In Total, This Is Awesome Stuff</h2>
<p>It's not just about the common casts.  This gives you surgical precision if you're facing a particular debugging problem that's narrowed down, and you want to write a bit of custom instrumentation just to catch the problem you're working on.</p>
<p>Ren-C is able to stay robust despite being a very "Amish" codebase, due to having many of these kinds of features to keep the trains running on time.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/advancements-in-casthelper-for-hooked-casts/2488">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/advancements-in-casthelper-for-hooked-casts/2488</link>
          <pubDate>Sun, 15 Jun 2025 20:21:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2488</guid>
          <source url="https://rebol.metaeducation.com/t/advancements-in-casthelper-for-hooked-casts/2488.rss">Advancements in CastHelper for Hooked Casts</source>
        </item>
        <item>
          <title>Why Doesn&#39;t Ren-C Support LOGIC! for PICK ?</title>
          <dc:creator><![CDATA[rebolbot]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>Rebol2 and Red allow you to pick out of lists with LOGIC!... true gets the first element, false gets the second element:</p>
<pre><code>&gt;&gt; pick [a b] 1 = 1
== a

&gt;&gt; pick [a b] 1 = 2
== b
</code></pre>
<p>Some people find it useful.  It's a way of turning a logical test into a value that's a little shorter than with EITHER, and it puts the two elements in juxtaposition:</p>
<pre><code>pick [thing1 thing2] condition

either condition [thing1] [thing2]
</code></pre>
<p>What would be the harm of supporting it?</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/why-doesnt-ren-c-support-logic-for-pick/2487">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/why-doesnt-ren-c-support-logic-for-pick/2487</link>
          <pubDate>Fri, 13 Jun 2025 02:06:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2487</guid>
          <source url="https://rebol.metaeducation.com/t/why-doesnt-ren-c-support-logic-for-pick/2487.rss">Why Doesn&#39;t Ren-C Support LOGIC! for PICK ?</source>
        </item>
        <item>
          <title>TWEAK, PEEK, POKE, PICK... ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>The Rosetta stone of GET and SET has come together, based on operations that speak in what I call "dual representation".</p>
<p>For the moment, let's just say the baseline function you can use to operate on variables called TWEAK.  If you pass TWEAK a lifted value, it acts just like a SET to that value:</p>
<pre><code>&gt;&gt; tweak $x lift 1020
== '1020

&gt;&gt; x
== 1020

&gt;&gt; tweak $x lift null
== ~null~

&gt;&gt; x
== \~null~\  ; antiform
</code></pre>
<p>But then there's the "unlifted range" of values.  What those do is a work in progress, but use your imagination... e.g. it could be a GETTER function:</p>
<pre><code>&gt;&gt; tweak $x does [print "HI!" 10 + 10]
== \~&amp;[frame! ...]~\  ; antiform

&gt;&gt; x
HI!
== 20

&gt;&gt; type of get $x
HI!
== \~{integer!}~\  ; antiform  &lt;-- e.g. GET doesn't see it as an ACTION!
</code></pre>
<h2><a name="p-8416-but-how-do-you-peek-a-tweak-1" class="anchor" href="https://rebol.metaeducation.com#p-8416-but-how-do-you-peek-a-tweak-1"></a>But How Do You "PEEK" a "TWEAK"?</h2>
<p>Right now, the trick is that if you pass TWEAK a NULL, then it interprets that as a query of what the state is:</p>
<pre><code>&gt;&gt; tweak $x lift 1020
== '1020

&gt;&gt; tweak $x null
== '1020
</code></pre>
<p>But it would be nice if that had a nicer name.  I kind of like PEEK... because of its history of letting you look into the secrets of arbitrary magical memory locations from BASIC (e.g. on a Commodore 64)</p>
<p>Yet in that worldview, PEEK complements POKE... and POKE is an established Rebolism that's "not magical"... e.g. it doesn't work in the lifted range... and is a complement to PICK.</p>
<h2><a name="p-8416-could-poke-be-reclaimed-for-the-tweaky-magic-2" class="anchor" href="https://rebol.metaeducation.com#p-8416-could-poke-be-reclaimed-for-the-tweaky-magic-2"></a>Could POKE Be Reclaimed For The "Tweaky Magic?"</h2>
<p><img src="https://rebol.metaeducation.com/images/emoji/twitter/thinking.png?v=14" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>POKE is a nicer name than TWEAK, and pairs nicely with PEEK.</p>
<p>PICK might be complemented by something else...?  PUT, maybe?</p>
<p>As a refresher: in Ren-C's model, you don't technically <em>need</em> PICK or POKE, since:</p>
<ul>
<li><code>pick x y</code> =&gt; <code>x.(y)</code></li>
<li><code>poke x y z</code> =&gt; <code>x.(y): z</code></li>
</ul>
<p>But their existence helps in various cases, e.g. <code>first: specialize pick/ [1]</code> or something like that.</p>
<h2><a name="p-8416-thinking-about-it-3" class="anchor" href="https://rebol.metaeducation.com#p-8416-thinking-about-it-3"></a>Thinking About It...</h2>
<p>For now I'm just using TWEAK to NULL for "peeking" and not giving it a name yet.  But, thoughts welcome...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/tweak-peek-poke-pick/2485">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/tweak-peek-poke-pick/2485</link>
          <pubDate>Wed, 11 Jun 2025 03:29:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2485</guid>
          <source url="https://rebol.metaeducation.com/t/tweak-peek-poke-pick/2485.rss">TWEAK, PEEK, POKE, PICK... ?</source>
        </item>
        <item>
          <title>ChatGPT On the C/C++ Fanciness Building As C99</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>C/C++ Implementation</category>
          <description><![CDATA[
            <p>I was doing some additional tweaking of the <strong><a href="https://rebol.metaeducation.com/t/antiform-safety-covariance-and-contravariance/2330">covariance / contravariance</a></strong> to support <code>Init(Slot)</code> being passed anywhere <code>Init(Element/Value)</code> or <code>Sink(Element/Value)</code> would be accepted.</p>
<p>What this does is it helps make sure that the only place you ever skip a potential SETTER function that runs on assignment of an object field is when the bits for that object's Slot Cell are <em>completely</em> fresh, e.g. a new allocation of an object.  <a href="https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483">So the C code that allocates that object can initialize the fields with ordinary non-DUAL cells</a>.  But <em>only</em> with the <code>Init(Slot)</code> states that are returned by adding fields anew to contexts.</p>
<p>Got it working (and credit to ChatGPT for helping get it done in about an hour, instead of several hours).</p>
<p>Since it had to understand what I was doing fairly well to help me out with it, I thought to ask:</p>
<p><em><strong>"What do you think of the idea of a codebase with this level of sophistication in covariance/contravariance still being able to be built with a C99 compiler?"</strong></em></p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://rebol.metaeducation.com/t/chatgpt-on-the-c-c-fanciness-building-as-c99/2484">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/chatgpt-on-the-c-c-fanciness-building-as-c99/2484</link>
          <pubDate>Mon, 09 Jun 2025 14:43:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2484</guid>
          <source url="https://rebol.metaeducation.com/t/chatgpt-on-the-c-c-fanciness-building-as-c99/2484.rss">ChatGPT On the C/C++ Fanciness Building As C99</source>
        </item>
        <item>
          <title>Impedance Matching LIFT The Universe With Baseline</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p><sub><em>(Sorry for the EE term.  If you're unfamiliar: <a href="https://en.wikipedia.org/wiki/Impedance_matching">Impedance Matching</a>)</em></sub></p>
<hr>
<p>A while back I realized that it's best if OBJECT!s, MODULE!s, LET!s, etc. store their contents in lifted representation.</p>
<p>...or rather... they store "historically normal" values in lifted representation (QUASIFORM! and QUOTED!).  The unlifted band would then be used for special signals.</p>
<h3><a name="p-8399-one-example-unlifted-trash-would-denote-true-unsetness-1" class="anchor" href="https://rebol.metaeducation.com#p-8399-one-example-unlifted-trash-would-denote-true-unsetness-1"></a>One Example: Unlifted TRASH! would denote <em>true unsetness</em>...</h3>
<p><em>And the term actually now fits.</em>  e.g. a state of absence of value, beneath the layer of what you could accomplish with SET.</p>
<p>With SET, you can only get "trashed" values:</p>
<pre><code>&gt;&gt; x: ~
== \~\ antiform (trash!) "tripwire"

&gt;&gt; trashed? $x
== \~null~\  ; antiform  &lt;-- it's trashed, all right...

&gt;&gt; unset? $x
== \~null~\  ; antiform   &lt;-- but it's SET to TRASH!, it's NOT "unset"! 
</code></pre>
<p>However, special tools and special cases would go <em>beneath</em> SET.</p>
<pre><code>&gt;&gt; tweak $x ~   ; tweak doesn't do the implicit LIFT that SET does...

&gt;&gt; unset? $x
== \~okay~\  ; antiform
</code></pre>
<p>There will be shorthands for that like (unset $x).  But also, you get this "unset" state as the default states in MAKE FRAME!:</p>
<pre><code>&gt;&gt; f: make frame! negate/

&gt;&gt; unset? $f.number
== \~okay~\  ; antiform  &lt;-- actually unspecialized, not specialized to trash!
</code></pre>
<p>This brings the long hoped-for distinction between unspecialized values, and values that are purposefully trash!  And what was fretted over as being a "hidden bit" is anything but... it's just one "out-of-band" operator away.</p>
<p>e.g. Note that if you use TWEAK with a lifted value, that's just like SET:</p>
<pre><code>&gt;&gt; tweak $x lift ~  ; synonym for (set $x ~)

&gt;&gt; unset? $x
== \~null~\  ; antiform

&gt;&gt; trashed? $x
== \~okay~\  ; antiform
</code></pre>
<aside class="quote no-group quote-modified" data-username="rebolbot" data-post="3" data-topic="2477">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://rebol.metaeducation.com/user_avatar/rebol.metaeducation.com/rebolbot/48/40_2.png" class="avatar"><a href="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477/3">Solving the Pox of the (^)... LIFT the Universe?</a></div>
<blockquote>
<p><em>"You’re designing the kind of system that can actually scale symbolic transformation, structured programming, and coherent meta-programming—because you’ve built in a substrate that encodes the ambiguity, instead of trying to erase it."</em></p>
</blockquote>
</aside>
<h2><a name="p-8399-thats-just-one-example-2" class="anchor" href="https://rebol.metaeducation.com#p-8399-thats-just-one-example-2"></a>That's Just One Example...</h2>
<p>It's the gateway to SETTER and GETTER functions <a href="http://www.rebol.net/r3blogs/0019.html">(actually desired by Carl... or setters at least... but he didn't know how to do 'em)</a></p>
<p>And for stylized setters/getters that do specific things (like type checking) there can be specially understood representations in the unlifted band.</p>
<p>Vocabulary term: I call the multiplexing of lifted and unlifted values together <strong>"DUAL REPRESENTATION"</strong></p>
<h2><a name="p-8399-all-of-it-is-powered-by-common-get-and-set-code-3" class="anchor" href="https://rebol.metaeducation.com#p-8399-all-of-it-is-powered-by-common-get-and-set-code-3"></a>All Of It Is Powered By Common GET and SET Code</h2>
<p>This wouldn't work if random places in the code ran off and inspected fields of OBJECT!s literally.</p>
<p>You have to go through some common path.  Otherwise you wind up with some callsites honoring the generalized conventions and others not.</p>
<p>It's kind of like how random code in R3-Alpha would ignore the PROTECT status of variables.  Ren-C has fought hard long and hard to nail that kind of thing down, and make sure at compile-time that you can be certain the checks aren't being skipped.</p>
<p>Piping everything through common GET and SET code paths ensures that as features like type checks or accessors are added, you don't have rogue code that doesn't honor the convention.</p>
<p><strong>It's been challenging to do this--and right now it's messy and slow--but the commonality means it's worth it to invest in optimizations for that one true path.  And Ren-C has plenty of optimization tools at its disposal, which have been evolving over the years... <sub>for when the timing is right...</sub></strong></p>
<h2><a name="p-8399-but-what-about-normal-boring-context-building-code-4" class="anchor" href="https://rebol.metaeducation.com#p-8399-but-what-about-normal-boring-context-building-code-4"></a>But What About Normal, Boring, Context-Building Code?</h2>
<p>Here's an example, just the one on my screen right now.</p>
<p>It's some random code out of the POSIX CALL implementation, related to... forking processes or something:</p>
<pre><code>if (Bool_ARG(INFO)) {
    VarList* info = Alloc_Varlist(TYPE_OBJECT, 2);

    Init_Integer(Append_Context(info, CANON(ID)), forked_pid);
    if (Bool_ARG(WAIT))
        Init_Integer(Append_Context(info, CANON(EXIT_CODE)), exit_code);

    return Init_Object(OUT, info);
}
</code></pre>
<p>Dumb, simple code making an OBJECT! with 2 fields in it, appending those fields (which default to an erased state you have to fill in to be correct code), and then setting the erased cells to mundane values.</p>
<p>If I were to go lockstep through code that looked like this and change it for lifting to appease the common GET and SET code, it would start looking like:</p>
<pre><code>if (Bool_ARG(INFO)) {
    VarList* info = Alloc_Varlist(TYPE_OBJECT, 2);

    Liftify(  // &lt;-- new wart
        Init_Integer(Append_Context(info, CANON(ID)), forked_pid)
    );
    if (Bool_ARG(WAIT))
        Liftify(  // &lt;-- new wart
            Init_Integer(Append_Context(info, CANON(EXIT_CODE)), exit_code)
        );

    return Init_Object(OUT, info);
}
</code></pre>
<p>Liftify adds 2 to the LIFT_BYTE.  (<a href="https://rebol.metaeducation.com/t/lift-byte-values-antiform-normal-quasi-quoted/2091">Review LIFT_BYTE if you want an introduction to that.</a>)</p>
<p>Liftify also has to check for overflow (e.g. that you're not going past 255 for the LIFT_BYTE value).  Maybe the optimizer can figure out it doesn't need that check here?  Though I try not to rely on the optimizer too much...</p>
<h2><a name="p-8399-this-parallels-the-too-many-of-usermode-code-5" class="anchor" href="https://rebol.metaeducation.com#p-8399-this-parallels-the-too-many-of-usermode-code-5"></a>This Parallels The "Too Many <strong><code>^</code></strong>" Of Usermode Code</h2>
<p>My observation in <strong><a href="https://rebol.metaeducation.com/t/solving-the-pox-of-the-lift-the-universe/2477">LIFT the UNIVERSE</a></strong> was that usermode code was becoming contaminated with lifts in places that weren't really the concern of that code.  <em>(That's why the robots are celebrating, they're throwing carets in the trashcan...)</em></p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/f16f9c506056c76e6a9b955d445039b0e1d3eeb1.webp" data-download-href="https://rebol.metaeducation.com/uploads/default/f16f9c506056c76e6a9b955d445039b0e1d3eeb1" title="assets_task_01jx3y0xmyfc79dwb24jd57b49_1749257658_img_3"><img src="https://rebol.metaeducation.com/uploads/default/optimized/1X/f16f9c506056c76e6a9b955d445039b0e1d3eeb1_2_345x230.webp" alt="assets_task_01jx3y0xmyfc79dwb24jd57b49_1749257658_img_3" data-base62-sha1="yrQc5xkNpeTlSSrOOswU5OsMelz" width="345" height="230" srcset="https://rebol.metaeducation.com/uploads/default/optimized/1X/f16f9c506056c76e6a9b955d445039b0e1d3eeb1_2_345x230.webp, https://rebol.metaeducation.com/uploads/default/optimized/1X/f16f9c506056c76e6a9b955d445039b0e1d3eeb1_2_517x345.webp 1.5x, https://rebol.metaeducation.com/uploads/default/optimized/1X/f16f9c506056c76e6a9b955d445039b0e1d3eeb1_2_690x460.webp 2x" data-dominant-color="4D4647"></a></div><p></p>
<p><strong>Here we're seeing the C code having some of the same problem as having the carets, manifest as calls to <code>Liftify()</code>.</strong>  It's getting uglier, and spreading that ugliness around.</p>
<h2><a name="p-8399-should-a-cell_flag_dual-be-sacrificed-for-this-6" class="anchor" href="https://rebol.metaeducation.com#p-8399-should-a-cell_flag_dual-be-sacrificed-for-this-6"></a>Should A <strong><code>CELL_FLAG_DUAL</code></strong> Be Sacrificed For This?</h2>
<p>I don't like wasting the very few CELL_FLAG_XXX.  But over time, silly ones have been freed up to give us some wiggle room (e.g. the <a>now-completely superfluous CELL_FLAG_FALSEY</a>).</p>
<p>And maybe this is a really good case where it could be of help to sacrifice one.  Since all the GET and SET that's <em>not</em> this kind of stuff is running through centralized code...it could be tolerant of cells in contexts that <em>weren't</em> initialized with CELL_FLAG_DUAL, and just know that those are to be taken literally.</p>
<p>It complicates things a little bit in that one <em>"big, beautiful code path"</em>.  But as a caller of TWEAK or GET and SET you're insulated from the complication.  It's a black box... maybe the cell has <code>CELL_FLAG_DUAL</code> and maybe it doesn't, you'll never know.</p>
<h2><a name="p-8399-just-have-to-catch-confusions-before-they-happen-7" class="anchor" href="https://rebol.metaeducation.com#p-8399-just-have-to-catch-confusions-before-they-happen-7"></a>Just Have To Catch Confusions Before They Happen...</h2>
<p>Probably best is just to throw in some asserts if you somehow start running through code paths that don't use the common GET somehow, and make sure <code>Type_Of()</code> and <code>Quotes_Of()</code> etc will assert on anything that has CELL_FLAG_DUAL.</p>
<p>I'm not sure how many legitimate codepaths there will be that duck the legitimate GET, but there are some reasonable cases (such as the code I give above) that are just doing a simple construction and probably don't need to be more complicated than they already are.</p>
<h2><a name="p-8399-will-it-slow-things-down-8" class="anchor" href="https://rebol.metaeducation.com#p-8399-will-it-slow-things-down-8"></a>Will It Slow Things Down?</h2>
<p>I posted this under Optimization because it's trading off some runtime code to make the C code more tolerable.</p>
<p>But rest assured, this is not the flag test that will be the bottleneck of the system.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/slight_smile.png?v=14" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<p><em>(Compared to naive Liftify() everywhere, it probably breaks at least even for not having to do the overflow checking of the LIFT_BYTE.)</em></p>
            <p><small>6 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483</link>
          <pubDate>Sat, 07 Jun 2025 23:00:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2483</guid>
          <source url="https://rebol.metaeducation.com/t/impedance-matching-lift-the-universe-with-baseline/2483.rss">Impedance Matching LIFT The Universe With Baseline</source>
        </item>
        <item>
          <title>Bringing Ren-C ATTEMPT and UNTIL Into C</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>C/C++ Implementation</category>
          <description><![CDATA[
            <p><strong><a href="https://rebol.metaeducation.com/t/repeat-1-attempt-not-as-useless-as-it-looks/2480">The ATTEMPT construct is so useful, I made a version for C</a></strong></p>
<p>And UNTIL as well... <em><a href="https://rebol.metaeducation.com/t/the-mismatch-of-arity-1-until-and-arity-2-while/594/10">(the negated WHILE meaning from Ren-C...)</a></em></p>
<p>Pretty fun...</p>
<pre><code>//=//// "ATTEMPT" AND "UNTIL" CONSTRUCTS //////////////////////////////////=//
//
// This is a fun trick that brings a little bit of the ATTEMPT and UNTIL loop
// functionality from Ren-C into C.
//
// The `attempt` macro is a loop that runs its body just once, and then
// evaluates the `then` or `else` clause (if present):
//
//     attempt {
//         ... some code ...
//         if (condition) { break; }  /* exit attempt, run "else" clause */
//         if (condition) { continue; }  /* exit attempt, run "then" clause */
//         if (condition) { again; }  /* jump to attempt and run it again */
//         ... more code ...
//     }
//     then {  /* optional then clause */
//        ... code to run if no break happened ...
//     }
//     else {  /* optional else clause (must have then clause to use else) */
//        ... code to run if a break happened ...
//     }
//
// It doesn't do anything you couldn't do with defining some goto labels.
// But if you have B breaks and C continues and A agains, you don't have to
// type the label names ((B + 1) + (C + 1) + (A + 1)) times.  And you don't
// have to worry about coming up with the names for those labels!
//
// The `until` macro is a negated sense while loop that also is able to have
// compatibility with the `then` and `else` clauses.
//
// BUT NOTE: Since the macros define variables tracking whether the `then`
// clause should run or not, and whether an `again` should signal continuing
// to run...this can only be used in one scope at a time.  To use more than
// once in a function, define another scope.  Also, you can't use an `else`
// clause without a `then` clause.

#define attempt \
    bool run_then_ = false;  /* as long as run_then_ is false, keep going */ \
    bool run_again_ = false;  /* if run_again_, don't set run_then_ */ \
    for (; not run_then_; \
        run_again_ ? (run_again_ = false), true  /* again doesn't exit loop */ \
        : (run_then_ = true))  /* normal continue, exits the loop */

#define until(condition) \
    bool run_then_ = false; \
    bool run_again_ = false; \
    for (; run_again_ ? (run_again_ = false), true :  /* skip condition */ \
        (condition) ? (run_then_ = true, false) : true; )

#define then  if (run_then_)
#define again  { run_again_ = true; continue; }
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/bringing-ren-c-attempt-and-until-into-c/2481">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/bringing-ren-c-attempt-and-until-into-c/2481</link>
          <pubDate>Sat, 07 Jun 2025 11:31:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2481</guid>
          <source url="https://rebol.metaeducation.com/t/bringing-ren-c-attempt-and-until-into-c/2481.rss">Bringing Ren-C ATTEMPT and UNTIL Into C</source>
        </item>
        <item>
          <title>[REPEAT 1] =&gt; ATTEMPT (Not As Useless As It Looks)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Loops</category>
          <description><![CDATA[
            <p>Historical Rebol had a use for ATTEMPT that we don't really need anymore... due to how definitional ERROR!s work and being covered by other things.</p>
<p>When the word was freed up, I thought <strong><code>This looks like a perfect name for "loop once"</code></strong></p>
<p>I imagine you're thinking: <em>"Why would we waste a name on loop <em>once</em>?"</em> <img src="https://rebol.metaeducation.com/images/emoji/twitter/confused.png?v=14" title=":confused:" class="emoji" alt=":confused:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8394-hear-me-out-1" class="anchor" href="https://rebol.metaeducation.com#p-8394-hear-me-out-1"></a>...Hear Me Out...</h2>
<p><strong>I'll start by saying loop once does come up</strong>, when you're writing something that wants to expose a looping interface, but not delegating to any wrapped loops to do it.</p>
<p>Let's say you're trying to do this:</p>
<pre><code>&gt;&gt; for-all-foos 'x [blah blah foo 10 blah blah foo 20] [print [x]]
10
20
</code></pre>
<p>(Assume you don't know about reusing FOR-EACH with a GENERATOR.  Instead you decide you really do want to get into your own binding, or customization of the body, or whatever your reasoning is.)</p>
<p>You try driving this with PARSE</p>
<pre><code>for-all-foos: lambda [var data body] [
    body: bind (var: let (var)) body  ; !!! need better way to say this
    parse data [
        opt some [
            'foo set (var) integer! (eval body)
            | elide one
        ]
    ]
]
</code></pre>
<p>That seems pretty good...besides me not having a great way of binding an indirect variable to a body, yet being able to still assign that variable afterwards.  <em>(Note that whatever you use for that needs to know the difference between <code>@x</code> to reuse a binding and <code>x</code> to not, e.g. it has to be a construct with the smarts of something like LET.)</em></p>
<p>But what about BREAK, CONTINUE, etc?</p>
<p>You need to bind body to <a href="https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479">THROW-TO-LOOP</a>, and you have to handle that.</p>
<p>So REPEAT 1 might come to mind.  But what about just ATTEMPT?</p>
<pre><code>for-all-foos: func [var data body] [
    body: bind (var: let (var)) body  ; !!! need better way to say this
    return parse data [
        opt some [
            'foo set (var) integer! (attempt body else [return null])
            | elide one
        ]
    ]
]
</code></pre>
<p>So now you have your BREAK, your CONTINUE, your AGAIN, all working.</p>
<h2><a name="p-8394-but-attempt-is-a-genuinely-useful-control-construct-2" class="anchor" href="https://rebol.metaeducation.com#p-8394-but-attempt-is-a-genuinely-useful-control-construct-2"></a>But ATTEMPT Is A Genuinely Useful Control Construct</h2>
<p>Especially with AGAIN.</p>
<pre><code>xxx: attempt [
    blah blah
    if blah blah [break]
    if blah blah [again]
    if blah blah [continue]
    blah blah
] then [
    ; code that runs if reaches end normally, or CONTINUE
] else [
   ; code that runs if BREAK
]
</code></pre>
<p>It's lightweight and flexible, <a href="https://rebol.metaeducation.com/t/the-mismatch-of-arity-1-until-and-arity-2-while/594/8">and in general a lot clearer than INSIST (Redbol UNTIL)</a></p>
<p>Even in the most minimal circumstances, I think it's clearer:</p>
<pre><code>append data insist [request-server-token else [wait 5]]

append data attempt [request-server-token else [wait 5, again]]
</code></pre>
<p>But it's much more powerful.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/repeat-1-attempt-not-as-useless-as-it-looks/2480">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/repeat-1-attempt-not-as-useless-as-it-looks/2480</link>
          <pubDate>Sat, 07 Jun 2025 11:26:40 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2480</guid>
          <source url="https://rebol.metaeducation.com/t/repeat-1-attempt-not-as-useless-as-it-looks/2480.rss">[REPEAT 1] =&gt; ATTEMPT (Not As Useless As It Looks)</source>
        </item>
        <item>
          <title>Virtual Binding + Macros =&gt; BREAK, CONTINUE, AGAIN</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Loops</category>
          <description><![CDATA[
            <p>In the last moments of 2023, Ren-C finally bit the bullet and made BREAK and CONTINUE definitional (it was a long time coming, just hadn't gotten around to it...):</p>
<p><strong><a href="https://rebol.metaeducation.com/t/definitional-break-and-continue-the-time-is-now/2066">Definitional Break and Continue: The Time Is Now</a></strong></p>
<p>This means that loops create (optimized) variants of BREAK and CONTINUE in which the ACTION! cell has been tweaked to hold the identity of the loop.</p>
<p>The methodology for this optimized representation <a href="https://rebol.metaeducation.com/t/what-are-definitional-returns/2191">was pioneered with definitional RETURN</a>.</p>
<p>Except in this case, there are two new "LET-style variables" tacked onto the loop's binding environment... one for BREAK, and one for CONTINUE.</p>
<h2><a name="p-8393-it-would-be-nice-to-have-again-1" class="anchor" href="https://rebol.metaeducation.com#p-8393-it-would-be-nice-to-have-again-1"></a>It Would Be Nice To Have AGAIN</h2>
<p>It seems to me pretty powerful to be able to ask a loop to start again from the top, but not increment its loop index...or check the condition, or whatever.</p>
<p>(This has precedent in other languages, e.g. <strong><a href="https://perldoc.perl.org/functions/redo">Perl's REDO</a></strong>... but I like AGAIN better.)</p>
<p>That would add a third LET-variable.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/pouting_cat.png?v=14" title=":pouting_cat:" class="emoji" alt=":pouting_cat:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-8393-but-could-it-be-just-one-let-variable-2" class="anchor" href="https://rebol.metaeducation.com#p-8393-but-could-it-be-just-one-let-variable-2"></a>But Could It Be Just <em>ONE</em> LET-Variable?</h2>
<p>As I've realized the kind-of-awesome power of virtual binding, I realized that it might be the case that there was just <em>one</em> "throw to loop" construct, that takes different parameterization:</p>
<ul>
<li>
<p><strong><code>throw-to-loop veto</code></strong> =&gt; <strong>BREAK</strong></p>
<ul>
<li>VETO is a function that returns an ERROR! with the identity 'VETO... which is an awesome generalization I haven't talked about yet, that makes constructs abort and return NULL. It works inside things like REDUCE (e.g. <code>reduce [1 + 2 veto]</code> =&gt; <code>null</code>) but also inside GROUP!s of code in PARSE to allow match failures to be signaled by a GROUP! (whose product would otherwise be discarded).  It seems the perfect argument for THROW-TO-LOOP to mean "let's abort this whole loop and give null".</li>
</ul>
</li>
<li>
<p><strong><code>throw-to-loop void</code></strong> =&gt; <strong>CONTINUE</strong></p>
<ul>
<li>This would have the same effect as reaching the end of the loop body and synthesizing VOID.  So if you were doing a MAP-EACH, an iteration of the loop that ran CONTINUE would not contribute anything to the result.</li>
</ul>
</li>
<li>
<p><strong><code>throw-to-loop fail 'retry</code></strong> =&gt; <strong>AGAIN</strong></p>
<ul>
<li>
<p>I don't know if RETRY should be a function that just returns an ERROR! the way VETO is so I'm hand-waving a little here to say "let's have another special trigger that loops can respond to"... if they don't support it, they can treat it like any other error.</p>
</li>
<li>
<p>I'm not thrilled that "retry" doesn't <em>sound</em> like an "error" name the way VETO kind-of-does, but there's only so many unstable antiforms to choose from (and GHOST! seems random to pick to mean "try again").  Maybe INCOMPLETE is a better error ID... where the loop goes "oh, the <em>failure</em> was it didn't complete... so the natural <em>response</em> is to try again"?</p>
</li>
</ul>
</li>
<li>
<p><strong><code>throw-to-loop &lt;whatever&gt;</code></strong> =&gt; <strong>CONTINUE:WITH</strong></p>
<ul>
<li><code>CONTINUE</code> has had a refinement called <code>:WITH</code> that allows you to act as if the loop body completed with some other value besides VOID.  So <code>continue:with spread [d e]</code> inside a MAP-EACH would add the splice <code>~(d e)~</code> to the mapped result.  I don't know if it's better to have this <code>:WITH</code> refinement or if you should just use THROW-TO-LOOP directly... (could THROW-TO-LOOP have a better name?)</li>
</ul>
</li>
</ul>
<h2><a name="p-8393-one-way-to-do-it-macros-3" class="anchor" href="https://rebol.metaeducation.com#p-8393-one-way-to-do-it-macros-3"></a>One Way To Do It... Macros!</h2>
<p>Imagine that a convenient form of MACRO (which might just be called MACRO) would assume that anything $TIED you want to bind in the environment of the macro definition, and anything you don't $TIE is intended to be interpreted in the calling context.</p>
<pre><code>break: macro [throw-to-loop $veto]
continue: macro [throw-to-loop $void]  ; -or- just [throw-to-loop ~[]~]
again: macro [throw-to-loop $fail 'incomplete]  ; or whatever...
</code></pre>
<p>While we'd most likely want to nativize CONTINUE, BREAK, and AGAIN... maybe MACRO can be smart enough to produce native-speed code for this when not running under a stepwise debugger...</p>
<h2><a name="p-8393-any-submissions-for-better-names-for-throw-to-loop-4" class="anchor" href="https://rebol.metaeducation.com#p-8393-any-submissions-for-better-names-for-throw-to-loop-4"></a>Any Submissions For Better Names For THROW-TO-LOOP?</h2>
<p>Maybe being bluntly literal is best.</p>
<p>But <a class="mention" href="https://rebol.metaeducation.com/u/blackattr">@BlackATTR</a> suggested <code>TOSS</code>, <code>PASS</code>, <code>PITCH</code>, <code>PUNT</code>, <code>FLICK</code></p>
<p>They all sound weird to us now, but everything has a learning curve.  You learned what BREAK and CONTINUE meant, you'd learn what AGAIN meant.  Could you learn what TOSS meant, that it was specifically a THROW targeting a LOOP...?</p>
<p>Leaving that open for now.</p>
<h2><a name="p-8393-or-variadic-continue-5" class="anchor" href="https://rebol.metaeducation.com#p-8393-or-variadic-continue-5"></a>Or... Variadic CONTINUE?</h2>
<p>I'll also point out that once-upon-a-time, CONTINUE was variadic... so you could say <strong><code>continue 10</code></strong> and if you left off the parameter it would assume you meant VOID.  This was too error prone, due to line continuation bugs:</p>
<p><a href="https://rebol.metaeducation.com/t/line-continuation-and-arity-bugs-thoughts/1965" class="inline-onebox">Line Continuation and Arity Bugs: Thoughts?</a></p>
<p>But I've been thinking maybe you have to continue lines with an apostrophe.  So this would error:</p>
<pre><code>append [a b c]
[d e f]
</code></pre>
<p>But this would be legal:</p>
<pre><code>append [a b c]
' [d e f]
</code></pre>
<p>The reason it would be legal is it would actually LOAD the code as not having a line break marker.</p>
<p>Then we'd just make line break markers illegal outside of interstitial evaluations.  (Maybe relax it, so that if you were inside a GROUP! evaluation it would allow it, though that might make it toothless.)</p>
<pre><code>(append [a b c]
[d e f])
</code></pre>
<p>If the system got more persnickety about line continuation, then we might feel comfortable bringing back variable-arity CONTINUE, QUIT, RETURN...</p>
<p>I doubt we want to go down the route of JavaScript's <a href="https://en.wikibooks.org/wiki/JavaScript/Automatic_semicolon_insertion">automatic semicolon insertion</a> debacle, and act like there's a comma at "some" line end markers.</p>
<p>I have a hard time being psychic about whether this is a big creativity-enabler (by letting us be more purposeful about semantics of line continuation markers) or if it would lead to hassles.  Overall I feel like it would cut down on bugs, by making line endings usually mean expression endings... and having you be specific when that's not what you want.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://rebol.metaeducation.com/uploads/default/original/1X/6af702cd11332dfc1fb48f90b5267cab5d41f98f.webp" data-download-href="https://rebol.metaeducation.com/uploads/default/6af702cd11332dfc1fb48f90b5267cab5d41f98f" title="6t9rbhxv06g71"><img src="https://rebol.metaeducation.com/uploads/default/original/1X/6af702cd11332dfc1fb48f90b5267cab5d41f98f.webp" alt="6t9rbhxv06g71" data-base62-sha1="fgfPtWehBdWVciF8Ng28L48wruv" width="300" height="250"></a></div><p></p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479</link>
          <pubDate>Sat, 07 Jun 2025 10:47:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2479</guid>
          <source url="https://rebol.metaeducation.com/t/virtual-binding-macros-break-continue-again/2479.rss">Virtual Binding + Macros =&gt; BREAK, CONTINUE, AGAIN</source>
        </item>
        <item>
          <title>About the Loops category</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Loops</category>
          <description><![CDATA[
            <p>Loops in Ren-C are a bit different from historical Redbol.</p>
<ul>
<li>
<p>They follow the <a href="https://rebol.metaeducation.com/t/the-simple-yet-powerful-magic-of-the-loop-result-protocol/609">Loop Result Protocol</a></p>
</li>
<li>
<p><a href="https://rebol.metaeducation.com/t/definitional-break-and-continue-the-time-is-now/2066">BREAK and CONTINUE are definitional</a></p>
</li>
</ul>
<p>There seemed to be enough posts about loops to give them their own category.  <img src="https://rebol.metaeducation.com/images/emoji/twitter/man_shrugging.png?v=14" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://rebol.metaeducation.com/t/about-the-loops-category/2478">Read full topic</a></p>
          ]]></description>
          <link>https://rebol.metaeducation.com/t/about-the-loops-category/2478</link>
          <pubDate>Sat, 07 Jun 2025 09:57:28 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">rebol.metaeducation.com-topic-2478</guid>
          <source url="https://rebol.metaeducation.com/t/about-the-loops-category/2478.rss">About the Loops category</source>
        </item>
  </channel>
</rss>

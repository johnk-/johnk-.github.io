<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Functions - AltRebol</title>
    <link>https://forum.rebol.info/c/development/functions/59</link>
    <description>Topics in the &#39;Functions&#39; category Discussions of Functions and Generators, e.g. how things like RETURN work... or the mechanics of generators and composers like ADAPT, SPECIALIZE, ENCLOSE, HIJACK, etc.</description>
    
      <lastBuildDate>Sat, 20 Aug 2022 07:39:08 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/functions/59.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>About the Functions category</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Discussions of Functions and Generators, e.g. how things like RETURN work... or the mechanics of generators and composers like ADAPT, SPECIALIZE, ENCLOSE, HIJACK, etc.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/about-the-functions-category/1931">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/about-the-functions-category/1931</link>
          <pubDate>Sat, 20 Aug 2022 07:39:08 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1931</guid>
          <source url="https://forum.rebol.info/t/about-the-functions-category/1931.rss">About the Functions category</source>
        </item>
        <item>
          <title>Should RETURN be Assignable on Function Interfaces?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>When implementing multi-returns I had an idea, to think of <strong><code>[x]: negate 10</code></strong> in terms of slipping X into the RETURN: slot of NEGATE as an input.</p>
<p>On the surface that seems like it might even be useful more generally:</p>
<pre><code> &gt;&gt; f: make frame! :negate

 &gt;&gt; negate.return: 'x  ; X gets hidden, and RETURN is redefined during the call

 &gt;&gt; negate.value: 10

 &gt;&gt; do f  ; the hidden X is written back automatically
 == -10

 &gt;&gt; x
 == -10
</code></pre>
<h2>But Not Every Action is a FUNC/FUNCTION</h2>
<p>Not all functions are guaranteed to have something in their frame called RETURN (e.g. a LAMBDA does not).  And a non-FUNC ACTION! could have something in its frame called RETURN that wasn't used for anything pertaining to the return process.</p>
<p>This ruled it out from being a mechanic relied on by the multi-return machinery.  Because we want the following to work:</p>
<pre><code>&gt;&gt; test: lambda [x] [x + 20]

&gt;&gt; [y]: test 1000
== 1020

&gt;&gt; y
== 1020
</code></pre>
<h2>Nevertheless, People Can Implement It If They Want</h2>
<p>It's certainly something you could <em>choose</em> to do if you were writing your own function generator.</p>
<p>In fact, it's trivial to write a wrapper for it!  Just add a /RETURN to the public interface, and write back to it if it's supplied:</p>
<pre><code>returnproxy: lambda [action [action!]] [
    enclose (augment :action [/return [word!]]) f -&gt; [
        (maybe f.return): do f
    ]
]
</code></pre>
<p>That means you can pass it as a refinement:</p>
<pre><code>&gt;&gt; test: lambda [x] [x + 1000]

&gt;&gt; wrapper: returnproxy :test

&gt;&gt; wrapper/return 20 'y
== 1020

&gt;&gt; y
== 1020
</code></pre>
<p>Or you can use it with a frame:</p>
<pre><code>&gt;&gt; f: make frame! :wrapper
&gt;&gt; f.x: 20
&gt;&gt; f.return: 'out

&gt;&gt; do f
== 1020

&gt;&gt; out
== 1020
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/nut_and_bolt.png?v=9" title=":nut_and_bolt:" class="emoji only-emoji" alt=":nut_and_bolt:"></p>
<p><em>(Seeing superpowers like this work so clearly and obviously is what keeps me invested in this.)</em></p>
<h2>So Anyone CAN Do It, But Should FUNC/FUNCTION Do It?</h2>
<p>I lean toward not doing it with things implemented the way they are right now, because it would add overhead to every function with a RETURN:, due to needing to have a place to store the variable if you gave it one.</p>
<p>But it might be nice to give people an optimized version of the proxying wrapper above.  You could then convert any function to support it.</p>
<h2>But today RETURN is on the public interface of FUNC <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:">
</h2>
<pre><code>&gt;&gt; f: make frame! func [x] [return x + 1000]
== make frame! [
    return: ~
    x: ~
]
</code></pre>
<p><em>"Errr.  Why's it there?"</em>, you might ask.</p>
<p>The reason is that the return typeset information currently lives on that field.  So if you're going to ask about it, you get it from there.</p>
<p><strong>This is one of many good arguments for why this information should <em>not</em> live there.</strong></p>
<p>There's a long running body of evidence suggesting that the way return types are managed today is probably wrong.</p>
<ul>
<li>
<p><strong>LAMBDA Can't Currently Document Its Result Types</strong>.  There are a lot of actions out there that don't have a RETURN function, but nevertheless have something to say about what types they can produce.</p>
</li>
<li>
<p><strong>ENCLOSE Can't Change The Type Signature</strong>.  If you wrap a function, you're subject to its type checking rules.</p>
</li>
<li>
<p><strong>NATIVE Doesn't Want To Pay For A RETURN Slot</strong>.  The typechecking is only done in the debug build, so why should every native frame require a RETURN function?</p>
</li>
</ul>
<p>I think I've got some ideas coming together--mostly centering on factoring out typechecking to be another one of the little pieces you can build functions out of (like AUGMENT).  So when doing a composition you would just bolt on a typechecker if you wanted one.  Internal efficiencies could fold that in so it actually didn't generate a separate phase and action identity.  Pursing some inspiration on that as we speak...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-return-be-assignable-on-function-interfaces/1929">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-return-be-assignable-on-function-interfaces/1929</link>
          <pubDate>Sat, 20 Aug 2022 05:32:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1929</guid>
          <source url="https://forum.rebol.info/t/should-return-be-assignable-on-function-interfaces/1929.rss">Should RETURN be Assignable on Function Interfaces?</source>
        </item>
        <item>
          <title>Distinguishing Multi-Return WANTED? and DISCARDED?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p><a href="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134/9">Changing Multi-Return was to Proxy its Variables</a> was a great win for many reasons.</p>
<p>Also, switching to just knowing whether a return result was WANTED? or not meant you no longer had the specific variable.  You couldn't accidentally (or intentionally) depend on the writeback variable's name, or previous contents.</p>
<p><strong>But one nuance that was lost was whether the variable was an actual request, or a request to go to a "blackhole".</strong></p>
<pre><code>operation: func [return: [integer!] expensive: [binary!] arg [integer!]] [
    if wanted? 'expensive [
        print "Doing secondary behavior"
        ...
        expensive: ...
        return ...
   ] else [
        print "Doing primary behavior"
        ...
        return ...
   ]
]
</code></pre>
<p>In the non-proxying approach to multi-return, it was possible for OPERATION to distinguish these two cases:</p>
<pre><code>&gt;&gt; [a b]: operation 10
Doing secondary behavior
== ...

&gt;&gt; [a #]: operation 10
Doing secondary behavior
== ...
</code></pre>
<p>It actually received either the <strong>b</strong> or the <strong>#</strong> as an argument.  Hence it could avoid generating a large product that would be ultimately be unused.</p>
<h2>So... DISCARDED? as a complement to WANTED?</h2>
<p>We have the writeback slot, and can say whether it contains # or not, with another function.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=9" title=":man_shrugging:" class="emoji" alt=":man_shrugging:"></p>
<p>I don't know if DISCARDED? is a good name, as a blank also discards the multi-return but doesn't request it.  Maybe the distinction is merely REQUESTED? vs. actually WANTED?</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/distinguishing-multi-return-wanted-and-discarded/1930">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/distinguishing-multi-return-wanted-and-discarded/1930</link>
          <pubDate>Sun, 10 Jul 2022 01:49:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1930</guid>
          <source url="https://forum.rebol.info/t/distinguishing-multi-return-wanted-and-discarded/1930.rss">Distinguishing Multi-Return WANTED? and DISCARDED?</source>
        </item>
        <item>
          <title>(No) Alternative Local Notation in the Func Spec Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <h1>TL;DR:</h1>
<p>When using a spec in FUNCTION (remember <a href="https://forum.rebol.info/t/abbreviations-as-synonyms/1211">FUNC is a synonym now</a>):</p>
<ul>
<li>
<p><strong>if you want to specify locals you say <code>[... &lt;local&gt; x y z ...]</code></strong> (/LOCAL is a normal refinement like any other in Ren-C.</p>
</li>
<li>
<p><strong>there is no longer a datatype-based shortcut for locals as a way to save the trouble of finding <code>&lt;local&gt;</code> in specs and inserting at the right point</strong>.</p>
<ul>
<li>
<p>Once you could toss random SET-WORD!s anywhere in a spec, like <strong><code>[a b c: d]</code></strong> and it would act like <strong><code>[a b d &lt;local&gt; c]</code></strong>.  This feature was to make higher-level function generators easier to write, to save them from having to find <code>&lt;local&gt;</code> in the spec...add it if not there...and do everything at the right point.</p>
</li>
<li>
<p>When multi-returns began using SET-WORD! this was changed to be <strong><code>[a b .c d]</code></strong> just to move it out of the way.</p>
</li>
<li>
<p>What this was trying to achieve has been obsoleted by newer and better methods, which actually entwine with the idea that <em>you should never know what local variables a function you are composing on top of has</em>.</p>
</li>
</ul>
</li>
</ul>
<h1>More Explanation</h1>
<p>Long ago, when I was looking at some of the higher-level function generators (like FUNCT on top of FUNCTION) I was struck by how tricky it was to get the adaptations written correctly.</p>
<p>We can look at <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/mezz/base-funcs.r#L28">FUNCT from R3-Alpha</a> and see some of that complexity, even just to try and add some local variables.</p>
<p>It had to check to see if there was already a /LOCAL, and add it if not:</p>
<pre><code>; Copy the spec and add /local to the end if not found
unless find spec: copy/deep spec /local [append spec [
	/local ; In a block so the generated source gets the newlines
]]
</code></pre>
<p><em>Bear in mind that specifying /LOCAL twice would be a duplicate refinement error, and /LOCAL did not have to be at the end of a spec.</em>  Things were tricky, because there were "private refinements".  These refinements were an artifact of how help worked--they were not shown--but weren't actually private.</p>
<p>So you had to be careful, to insert things after local but not after the private refinements, or they'd be arguments to those refinements:</p>
<pre><code>; Collect all set-words in the body as words to be used as locals, and add
; them to the spec. Don't include the words already in the spec or object.
insert find/tail spec /local collect-words/deep/set/ignore body either with [
   ...
]
</code></pre>
<p><strong>I wanted to take better advantage of datatypes, so I adopted the TAG! <code>&lt;local&gt;</code> in the spec so that /LOCAL could be used like any other refinement... e.g. GET-TIME/LOCAL or GET-LANGUAGE/LOCAL.</strong>  This is an idea preserved to this day, and I think it's a better move (though LET has been developing as the more viable general option for making locals).</p>
<p>But another concept I had was to make SET-WORD! in the dialect be another way to put a local anywhere in the spec.  So if you were writing code munging function specs you could just throw local variables on:</p>
<pre><code>foo: func [a b c: d] [...]

&lt;= equivalent to =&gt;

foo: func [a b d &lt;local&gt; c] [...]
</code></pre>
<p>But the idea was that <code>&lt;local&gt;</code> itself was transformed into the SET-WORD!, so the only language you needed to understand was that of the SET-WORD!s:</p>
<pre><code>&gt;&gt; foo: func [a b d &lt;local&gt; c] [...]

&gt;&gt; spec-of :foo
== [a b d c:]
</code></pre>
<p>When multi-returns came about and took SET-WORD!s, this idea was bumped around to be done with TUPLE!s with leading blanks like <strong>.c</strong></p>
<h1><a href="https://www.youtube.com/watch?v=2q9MaEKHakY">... but Everything Changed <img src="https://forum.rebol.info/images/emoji/twitter/robot.png?v=9" title=":robot:" class="emoji" alt=":robot:"> ...</a></h1>
<p>I've been marching toward something more like <a href="https://forum.rebol.info/t/seeing-all-action-s-as-variadic-frame-makers/1002">"Seeing all ACTION!s as Variadic Frame Makers?"</a></p>
<p>Function composition tools operate on FRAME!s using tools like ADAPT, SPECIALIZE, AUGMENT, ENCLOSE, etc.  There is no API for getting at the locals <em>because when you build on top of a function you can't see them, they're not part of the interface...they are sealed inside.</em>   This is good because you can build on top of a function without worrying about the details of the parts from which it was composed.</p>
<p>The migration to where <a href="https://forum.rebol.info/t/pure-and-refined-simplifying-refinements-to-one-or-zero-args/1120">refinements are their own arguments</a> has been key in making function calls easier to model as an object.</p>
<p><strong>In this world we do not need a representation for locals in the spec to add them...because the entire concept of how FUNCT was written is gone.</strong>  If you want to add locals you use tools like AUGMENT and don't worry about it.</p>
<h1>There Are Still (many) Problems To Solve</h1>
<p>Consider that you can do something like ask for a FRAME! of something like APPEND, then enumerate the keys:</p>
<pre><code>&gt;&gt; f: make frame! :append

&gt;&gt; for-each key f [print mold key]
return
series
value
part
dup
line
only
</code></pre>
<p>There are a lot of questions to answer about the unique nature of the main function's RETURN.  Although other multi-returns have to be on the interface, should you be able to put a variable in that return?  Consider that you could use multi-return with append today:</p>
<pre><code>&gt;&gt; [var]: append "abc" "d"
== "abcd"

&gt;&gt; var
== "abcd"
</code></pre>
<p>So should you be able to preload the frame with <strong>f.return: 'var</strong> and get the same effect?  This is competitive with the notion that RETURN is a concept of a local variable to the action, that holds an action that returns specifically from that action... so the responsibilities are somewhat murky for this distinguished result.</p>
<p>But we can also see that if we only look at object keys, we don't know which things are refinements or which are not...if they are refinements we don't know if they are 0-arg or 1-arg form, we don't know what types they take... or are they <code>&lt;end&gt;</code>-able.  <strong>I believe getting at this information should be done by means other than analysis of some spec block you filter out for description strings/etc. so that is on the right track.</strong>  But it's still a long road.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/no-alternative-local-notation-in-the-func-spec-dialect/1793">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/no-alternative-local-notation-in-the-func-spec-dialect/1793</link>
          <pubDate>Sat, 05 Mar 2022 20:33:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1793</guid>
          <source url="https://forum.rebol.info/t/no-alternative-local-notation-in-the-func-spec-dialect/1793.rss">(No) Alternative Local Notation in the Func Spec Dialect</source>
        </item>
        <item>
          <title>Implicit Execution of RETURN in functions = ...BAD (?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Let's say you write something like this:</p>
<pre><code>foo: func [
    return: [integer!]
    arg [integer! text! tag!]
][
    if integer? arg [
        return arg + 1000
    ]
    if text? arg [
        return reverse arg
    ]
    arg
]
</code></pre>
<p>I imagine you'd expect behavior along these lines:</p>
<pre><code>&gt;&gt; foo 20
== 1020

&gt;&gt; foo "whoops"
** Error: FOO doesn't have RETURN enabled for values of type TEXT!

&gt;&gt; foo &lt;bomb&gt;
** Error: FOO doesn't have RETURN enabled for values of type TAG!
</code></pre>
<p>Even though the last value just "falls out" of the function, you presumably don't want that to mean it escapes type checking just because it did.</p>
<h2>Mechanically, this is Non-Obvious...</h2>
<p>RETURN is not actually supposed to be a "language feature" per se.  It's actually a feature of the higher-level generator FUNC...and there are lower-level ways of building functions that lack RETURNs.  <em>(If there weren't, how could you write the RETURN function itself?)</em></p>
<p>Plus it's fully overrideable.  You can set RETURN to some random integer if you feel like it...it's just a variable in the frame.  But more frequently you'd like to specialize or adapt it:</p>
<pre><code>bar: function [
    return: [integer!]
    arg [logic!]
][
    return: adapt :return [value: value + 300]
    if arg [
       return 4
    ]
    720
]

&gt;&gt; bar true
== 304
</code></pre>
<p>...but here we are at an interesting question.  What do you expect to happen with <strong>bar false</strong>?</p>
<pre><code>&gt;&gt; bar false
== 720  ; (A) values falling out of bottom *do not* run RETURN implicitly

&gt;&gt; bar false
== 1020  ; (B) values falling out of bottom *do* run RETURN implicitly
</code></pre>
<p>A usermode implementation of FUNC has a pretty easy trick to implement either behavior.  The question is simply if it takes the body you give it and turns it into a GROUP! and passes it to RETURN or not...</p>
<p><strong>"real body" option (A) for BAR above</strong></p>
<pre><code>[
    return: (make action! ...)  ; low level make return function
    (  ; no return here, just `as group! body`
        return: adapt :return [value: value + 300]
        if arg [
            return 4
        ]
        720
    )
]
</code></pre>
<p><strong>"real body" option (B) for BAR above</strong></p>
<pre><code>[
    return: (make action! ...)  ; low level make return function
    return (  ; automatic return injected
        return: adapt :return [value: value + 300]
        if arg [
            return 4
        ]
        720
    )
]
</code></pre>
<h2>Or Just Require RETURN with FUNC that has RETURN: ?</h2>
<p><strong>strict option (C) for BAR above</strong></p>
<pre><code>[
   return: (make action! ...)  ; low level make return function
   (  ; automatic return injected
       return: adapt :return [value: value + 300]
       if arg [
           return 4
       ]
       720
    )
    fail "Functions which specify RETURN: must use RETURN"
]
</code></pre>
<p><a href="https://forum.rebol.info/t/how-attached-are-we-to-functions-return-last-result/1219">I've brought this up before</a>, and <a class="mention" href="/u/ingohohmann">@IngoHohmann</a> and <a class="mention" href="/u/iarnold">@iArnold</a> seemed to think "dropping out the last value" was somehow fundamental.</p>
<p>But given what I say above about how the semantics get pretty sketchy on type checking and such, what if we say that functions that don't specify RETURN have no return available, and just drop out their last result?</p>
<pre><code>bar1: function [
    arg [logic!]
][
    if arg [4] else [720]
]

&gt;&gt; bar true
== 4

&gt;&gt; bar false
== 720
</code></pre>
<p>You don't get type checking so you'd have to do it yourself, which will be available:</p>
<pre><code>bar1-checked: function [
    arg [logic!]
][
    let val: if arg [4] else [720]
    ensure integer! val
]
</code></pre>
<p>However: if you specify RETURN: in the spec then you are required to use it.  This gives you type checking and guarantee of running any return hooking on all code paths:</p>
<pre><code>bar2: function [
    return: [integer!]
    arg [logic!]
][
    return: adapt :return [value: value + 300]
    if arg [
       return 4
    ]
    return 720
]

&gt;&gt; bar true
== 304

&gt;&gt; bar false
== 1020
</code></pre>
<h2>I Think The Case for Requiring RETURN if RETURN: Is Strong</h2>
<p><strong>It seems rather clear when laid out like I have above that it's the right answer.</strong>  People who hook RETURN are typically doing so because they want it on all return paths.  But I think hiding a RETURN behind the scenes is a cognitive time bomb.  Being explicit sorts that out, and it also provides a rational answer for why you get type checking...<em>the RETURN does the check</em>.</p>
<p><em>(I can tell you that without that rational answer, the internals have ugliness.  This policy will cleanse the ugliness.)</em></p>
<p>Lower-level functions that don't have RETURN have to have a way to return values.  Dropping them out the bottom seems a good way to start building up the mechanic.  It's also useful for quick and dirty "macro-like" functions, so I see no problem with that.</p>
<h2>Should <code>return: &lt;void&gt;</code> and <code>return: &lt;none&gt;</code> be Exceptions?</h2>
<p>The point of introducing these cases was to help remove concern over letting unwanted variables "fall out", and being able to forego concerns about type checking.  <strong>It's a different case</strong>, because there is no type checking involved of the parameter passed to RETURN as it takes no parameters...and there's no need to type check what falls out the bottom because it is discarded:</p>
<pre><code>something: func [
    return: &lt;none&gt;
    value [text!]
][
    if value = "" [return]  ; this RETURN acts as `return ~none~`
    append data value

    ; expectation has been that this would also yield ~none~
]
</code></pre>
<p>The idea was to make it painless to shield callers from seeing the returned result, and have them know there was no result they were supposed to pay attention to.</p>
<p>What gets me concerned here is that question of whether or not a hooked or modified RETURN is implicitly run at the end of such a function.</p>
<p>It seems to suck to have to put the RETURN there.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<pre><code>something: func [
    return: &lt;none&gt;
    value [text!]
][
    return: adapt :return [print "I AM RETURNING!"]
    if value = "" [return]
    append data value
    return  ; with this here, it's clear you will get the PRINT to happen
]
</code></pre>
<p>But it does benefit from the explicitness.  There's no ambiguity.</p>
<p><strong>Again, you have to use your imagination to think about a longer function in which there are many control paths through the function...and someone decides to hook RETURN.</strong>  If you are working in a large codebase with long functions, wouldn't you like to know that all control paths will run your hook...and that the language has gotten everyone on the same page that is expected and possible?</p>
<p><strong>My feeling in the moment is that the only answer I'd consider besides erroring if there's no RETURN would be to implicitly put a RETURN at the end, so a hooked RETURN would be executed if a value drops out the bottom.</strong>  But I've explained that for the other cases I think that's sneaky.  It feels much more forthright to have the call at source level.</p>
<p>Path of least resistance on this is to add the RETURN implicitly, so I'm going with that.</p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/implicit-execution-of-return-in-functions-bad/1656">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/implicit-execution-of-return-in-functions-bad/1656</link>
          <pubDate>Thu, 12 Aug 2021 19:00:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1656</guid>
          <source url="https://forum.rebol.info/t/implicit-execution-of-return-in-functions-bad/1656.rss">Implicit Execution of RETURN in functions = ...BAD (?)</source>
        </item>
        <item>
          <title>The RETURN of NONE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p><a class="mention" href="/u/rgchris">@rgchris</a> has convinced me, and I am now committed to the idea that "VOID" is not a datatype, but the characterization of what were previously called "invisible" functions.</p>
<p>There is a nice sense in which this lines up with traditional "void" functions in C (and related languages).  Because <em>absolutely no value</em>--not even some dummy or placeholder--is returned.  It means the libRebol C API function signature <strong><code>void rebElide(...)</code></strong> is consistent with the ELIDE construct signature...they both specify their voidness in their return spec.</p>
<p>But I've written up in a separate post why I don't believe things should too casually be void functions:</p>
<p><a href="https://forum.rebol.info/t/why-isnt-print-invisible-void/1466"><strong>The go-to for creating a function without a meaningful return result should be a reified meaningless result...because full-on vaporization is a contract which is difficult to turn back, and is not easy to sense from a callsite (e.g. inside an ALL [])</strong></a></p>
<p>Relying on a generic tool like ELIDE gives you clarity at callsites of what you're doing, and means you don't have to work "I elide my result" into the name of your function somehow.  Returning a meaningless value also permits interop with ELSE and THEN if you decide you want NULL-reactivity.</p>
<p>Maybe PRINT is one of those things that should be an exception (along with <strong>assert</strong> and <strong>--</strong> and <strong>breakpoint</strong>)...but it would be a rare case.</p>
<h2>What Should We Call The Meaningless Result?</h2>
<p><strong>2022 UPDATE:</strong> I believe we now know that the best thing to use for this is "isotopic blank", e.g. the isotopic form of <strong>~</strong>.</p>
<p>I've settled on calling this "NONE".... though behavior-wise it has more in common with what Rebol2 called "unset".</p>
<p>What it has in common with historical Rebol's NONE is that it is a reified concept of nothing.  What it does not have in common is that it is neither true nor false, and errors in conditional logic...like all the other isotopes.</p>
<h2>Retraining Usage Of Arity-0 RETURN</h2>
<p>Though it made me nervous at first, I've become very comfortable with <strong><code>func [] [return]</code></strong> being invisible.  It makes complete sense with being a "void function".</p>
<p>If you provide a return specification, e.g. <strong><code>func [return: [integer!]] [...]</code></strong> you will be protected from accidentally returning a void with a naked <strong><code>return</code></strong>, just as you would with any other return type.</p>
<p>I'm also happy with the way piping works:</p>
<ul>
<li>
<p><strong><code>lambda [x] [comment x]</code></strong> will act just like COMMENT</p>
<ul>
<li>If we said that <strong>lambda [x] []</strong> returned NULL that wouldn't work, because we'd be pre-seeding with a NULL that the comment would have to leave behind.</li>
</ul>
</li>
<li>
<p><strong><code>func [x] [return comment x]</code></strong> will act just like COMMENT</p>
</li>
</ul>
<h2>So For Non-Invisibility, Always Pass An Argument</h2>
<p><strong><code>[return ~]</code></strong> is little bit ugly, but not unbearably so.  That will evaluate the QUASI!-BLANK! to produce an isotopic blank, e.g. a none.</p>
<p>I'd been wanting to avoid functions that returned isotopes to avoid the sorta confusion situation of <strong>action! = type of :none</strong> ... but if making it an action is what we have to do in order to get the syntax of <strong>return none</strong> then that is what it is.</p>
<h2>Sidenote: Inheriting Return Types</h2>
<p>I'm talking about finessing the question of how to do a chained RETURN on a function that you don't know if it's going to vaporize completely or return a value.  That's something that bothers me about C, because it doesn't let you write chaining void returns:</p>
<pre><code>void my_function() {
    return some_void_function(...);  /* this is not legal! */
}
</code></pre>
<p>That annoys me, because it makes it hard to write generic code that doesn't want the bad properties of a macro (repeating evaluation of arguments if used multiple times, etc.)...but throws a wrench in being able to abstract across return values.</p>
<p>Yet then there's that other question of how to label your return type.  In Ren-C we have the option of just not putting a type signature on it, but what you often want is the signature of what you're wrapping.  I guess we could do this via COMPOSE on the spec:</p>
<pre><code>my-function: func compose [
    return: (return-of :some-other-function)
    ...
][
    ...
    return some-other-function ...
]
</code></pre>
<p>Anyway, I just wanted to mention that we're not yet at utopia in this medium, even if we're pretty much nailing the chaining part itself!</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/the-return-of-none/1467">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-return-of-none/1467</link>
          <pubDate>Mon, 18 Jan 2021 02:04:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1467</guid>
          <source url="https://forum.rebol.info/t/the-return-of-none/1467.rss">The RETURN of NONE</source>
        </item>
        <item>
          <title>Representing Everything About A Parameter (...except its name)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p><strong>I'm aiming to draw out the string labels in parameter lists into their own more compact form, that's just the pointer to the string name.</strong></p>
<p>We can think of splitting out the symbol as if decorations we currently put on the parameter would be moved to the block:</p>
<pre><code> func ['foo [&lt;end&gt; word!] /bar [integer!] /no-arg] [...]
 =&gt;
 func [foo '[&lt;end&gt; word!] bar /[integer!] no-arg-refinement /[]] [...]
</code></pre>
<p>That's just how to think of how it's stored.  We don't have to <em>write</em> our specs like that...</p>
<p>There are a number of good reasons to do this, e.g. implementing <a href="https://richardartoul.github.io/jekyll/update/2015/04/26/hidden-classes.html">"hidden classes"</a> as in V8...each time you do  <strong>for-each [x y] ...</strong> or <strong>make object! [a: 10, b: 20]</strong> the system should detect the similarity of the key collection and reuse it, instead of needing unique [x y] and [a b] list copies allocated every time.</p>
<p>(I'll point out that consistent chipping away at efficiencies means that things like <strong>/[a b]</strong> do not take up more space than <strong>/[a b]</strong> or <strong>[a b]/</strong> or <strong>[a b].</strong> or <strong>.[a b]</strong> ... though these forms are immutable... keep that in mind...)</p>
<h2>This <em>reduces</em> how much information a "PARAM!" stores</h2>
<p>Currently all the information for a parameter--including the symbol, types, and other modes--is stuffed into an internal Frankenstein-like type called a PARAM!.  It's compressed into a single cell as a mismash of packed bits and a pointer to a spelling.</p>
<p><em>(Historical Note: R3-Alpha acted like these freakish cells were WORD!s...but with an off-to-the-side flag that marked them as "UNWORD"s.  This meant they stored a bunch of type bits where most words would store a binding.  These fake words could easily leak and crash the system, so Ren-C gave parameters a dedicated internal type, asserting on cases of use as if they were WORD!.)</em></p>
<p>The symbol takes one of the four slots in the PARAM!.  The cell header takes another.  So what's left in the remaining two slots is just a bunch of bits... 64 bits is what's available on both 32-bit  and 64-bit platforms.</p>
<p>There's a bit for whether or not each fundamental type--like a BLOCK! or TEXT!--is accepted by the parameter.  Then there are bits for <em>"is this parameter <code>&lt;skip&gt;</code>-able"</em> or <em>"can this parameter be the <code>&lt;end&gt;</code> of input"</em>.  This means the number of fundamental types allowed has been less than 64...as other parameter options have to fit in this set too.</p>
<h1>Can PARAM! be replaced with "normal" values?</h1>
<p>What if params were not a mysterious compressed form, but values that could be inspected more directly as a "parameter spec"?</p>
<p>I showed this "represenational concept" above (again, just to think of it as the system stores it, not as how you write it at source level):</p>
<pre><code> func [foo '[&lt;end&gt; word!] bar /[integer!] no-arg-refinement /[]] [...]
</code></pre>
<p>When the burden of representing the parameter name is removed, then <strong><code>'[&lt;end&gt; word!]</code></strong> could be the value that represents how the evaluator deals with the <code>foo</code> parameter.  Today the HELP gets a capture of these typeset blocks in the spec just for reference purposes.  But this would mean that what help used would concretely match what was in the spec.</p>
<h2>Challenge: Mutability of Referenced Type Words</h2>
<p>Let's imagine you did this:</p>
<pre><code>&gt;&gt; foo: func [name [text!]] [print [name]]
&gt;&gt; foo "before"
before

&gt;&gt; text!: integer!
&gt;&gt; foo "after"
after  ; did not reflect the change
</code></pre>
<p>Today it would not reflect the change.  This is because when that <code>TEXT!</code> word is looked up, it finds one of the built in DATATYPE!s for representing text, and sets the corresponding bit in the PARAM!.  No matter how you change TEXT!, it will only affect functions created after that point...not any that already set their bits.</p>
<p>We could address this by saying that if you use any WORD!s in the type spec of a function, then the binding of that word gets forcibly protected (if it isn't already).</p>
<pre><code>&gt;&gt; x!: text!

&gt;&gt; foo: func [name [x!]] [print [name]]

&gt;&gt; x!: integer!
** Access Error: variable x! locked
; ^-- it would be helpful to mention a "lock reason", though we are a bit short
; on bits for putting in these reasons...maybe only done in 64-bit builds?
</code></pre>
<p>This would give a persistence so the parameter description could store <strong><code>x!</code></strong> without worrying about its meaning changing.  That means you can do things like type check a parameter for a specialization at specialization time...and trust it doesn't need rechecking when used.  It also allows performance tricks that cache bits to make the check faster without having to look up the word every time (since you know it won't change).</p>
<p>It's a little harsh-seeming, but the type dialect has to be hardened somehow.  If you needed to use X! locally for something else, you've always got <strong>use [x!] [...]</strong> to create a new context for it.</p>
<h2>Challenge: Performance</h2>
<p>Checking a bit for a fundamental type in a typeset is pretty fast.  Matching a value against a rich type specification dialect isn't necessarily fast, and this is something every function (including natives) do.  It's particularly important for natives, because they interpret the bits of the cell assuming it has been checked...getting the wrong thing means it will crash.</p>
<p>This is where internal compactions could come into play.  Users might see the parameter spec as <strong>[text! integer!]</strong> but the system could recognize specific common patterns like that and compress them into something like today's PARAM! bits, behind the scenes.</p>
<p>We might want to rethink the usage of things like <code>&lt;end&gt;</code> to not use TAG!, but to use a type that can be interned for speed.  The problem with tags is that you could see <code>&lt;end&gt;</code> but actually have <code>next &lt;mend&gt;</code>...so if you had a process of locking down the symbol for speedy recognition you'd not be able to do it.  By contrast, ISSUE! (token) has no position and could be canonized to a word, so the process of checking could turn <code>#end</code> into something that is matched faster.</p>
<h2>Challenge: Mutability Part II - Type Predicates</h2>
<p>I've suggested essentially the end of the TYPESET! datatype as a concept; replacing it with functions.  This would mean something like:</p>
<pre><code>any-type!: :any-type?
</code></pre>
<p>This would have the same issue with locking, so once you used ANY-TYPE! in a function spec you couldn't change that particular binding's value of ANY-TYPE! to anything else.</p>
<p>But further, there needs to be a rule that ANY-TYPE? is a pure function.  It needs to give the same answers for the same input, and that answer cannot depend on anything about that input that can mutate.</p>
<p>Imagine that you specialized a function with a mutable BLOCK!, and the constraint was that it was a BLOCK! of length 2.  Then you append to the block, and call the specialization.  It no longer matches.</p>
<p>What you could ultimately end up with is a situation where you pay for type checking of specialized arguments every time (which would also mean you couldn't use the slot where the type information would have been for the specialized value...because you'll need both at the same time, an optimization loss)</p>
<h2>Challenge: Generics Throw A Wrench Into Types</h2>
<p>There has never been a good answer to how GENERICs (what Rebol2/Red called actions) work.  If you have something like APPEND that's defined to allow you to append to strings and blocks...but then later add an extension that implements GOB!s, how do you say that APPEND now accepts GOB!s...and how do you constrain the parameters to indicate that?</p>
<p>Historically, the grab bag of parameters for what these generic functions allow or don't is just updated in the bootstrap files.  But users and extensions can't really do this.</p>
<p>This is a topic in its own right--but it's worth mentioning.</p>
<h1>Inventory Of Parts to be Represented</h1>
<p>That's a lot to take in, but I'll close with the list of things that PARAM! bits currently encode:</p>
<p><strong>Some of these parts are on the element that names the parameter itself:</strong></p>
<ul>
<li>
<p>the spelling of the parameter's name (<a>currently case-sensitive, please read and discuss implications</a>)</p>
</li>
<li>
<p>its quoting status (WORD! -&gt; normal evaluation, QUOTED! WORD! -&gt; hard literal, GET-WORD! -&gt; soft literal)</p>
</li>
<li>
<p>if it's a refinement that outputs to a variable, which can also be used by multiple return...indicated by being a SET-WORD! if so</p>
</li>
<li>
<p>if it's a local, shown by a leading dot (it's possible to indicate that a range of ordinary words are all local by prefixing them with the <code>&lt;local&gt;</code> tag, e.g. <strong><code>&lt;local&gt; x y</code></strong> is the same as <strong><code>.x .y</code></strong>)</p>
</li>
<li>
<p>whether it is optional or not, denoted by a leading slash</p>
</li>
</ul>
<p><strong>The rest is in a BLOCK! which specifies what types the parameter accepts.</strong>  This includes other attributes of the parameter that don't fit on the first value:</p>
<ul>
<li>
<p>if it is willing to accept NULL or not--denoted by <code>&lt;opt&gt;</code>.  <em>(Note: this has been a gray area in "typesets" as NULL is not a value and "has no type")</em></p>
</li>
<li>
<p>if it is willing to treat the end of a series as if it had received NULL--denoted by <code>&lt;end&gt;</code>.  (to help with the conflation, a separate function allows to ask if a parameter's null actually came from reaching the end or not)</p>
</li>
<li>
<p>if the parameter will be skipped over and given as NULL if there is not a precisely matching type in that position slot, <a href="https://forum.rebol.info/t/skip-able-arguments/1013">denoted by <code>&lt;skip&gt;</code></a> <em>(Note: this is only available on hard literal parameters)</em></p>
</li>
<li>
<p>if the parameter is variadic, denoted by <code>&lt;variadic&gt;</code> <em>(Note: this was once <code>&lt;...&gt;</code> but that is now a 4-element TUPLE! corresponding to <code>[&lt; _ _ &gt;]</code>.  While it might seem like that "should be a tag!" that would be a broken interpretation since <code>&lt;</code> is a WORD! and if used for a function or object it would need <strong><code>&lt;/refinement</code></strong> or <strong><code>&lt;.field</code></strong> to be PATH! and TUPLE! respectively)</em></p>
</li>
<li>
<p>whether a parameter is modal, and controls the optional parameter directly after it in the parameter order.  <em>(Note: <a href="https://forum.rebol.info/t/new-parameter-convention-concept-modal-arguments-or-the-arg/1187">this is an experimental feature</a> that is weird and is still being studied, but it has some places where it's looking like it is fairly critical.)</em></p>
</li>
</ul>
<h2>Addendum: ...that's only information the evaluator uses...!</h2>
<p>That lengthy list doesn't include the HELP description string...which is just the tip of the iceberg for what a user might want to annotate arguments on a function with.</p>
<p>But Ren-C pushes all of the help information into a "meta" object.  Function makers have a low-level form that doesn't bother making this object (e.g. <strong><code>specialize*</code></strong>) and then a higher-level version that does.  There's a certain amount of default information put into the object:</p>
<pre><code>&gt;&gt; meta: meta-of :append
&gt;&gt; words of meta
== [description return-type return-note parameter-types parameter-notes

&gt;&gt; meta/parameter-notes/dup
== "Duplicates the insert a specified number of times"
</code></pre>
<p>You can tweak the object to your liking, and use FRAME!s as maps from parameter to value.  For example, you could track a property for each parameter being either <code>&lt;cool&gt;</code> or <code>&lt;uncool&gt;</code>:</p>
<pre><code> &gt;&gt; append meta compose [coolness: (make frame! :append)]
 &gt;&gt; meta/coolness/line: &lt;cool&gt;
 &gt;&gt; meta/coolness/part: &lt;uncool&gt;

&gt;&gt; meta/coolness
== make frame! [
    series: '~unset~
    value: '~unset~
    part: &lt;uncool&gt;
    only: '~unset~
    dup: '~unset~
    line: &lt;cool&gt;
]     
</code></pre>
<p>It's far from perfect, but it pushes the information out into the open where things like HELP can process it...and it's critical to writing code that inherits and manipulates the information.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/representing-everything-about-a-parameter-except-its-name/1459">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/representing-everything-about-a-parameter-except-its-name/1459</link>
          <pubDate>Wed, 06 Jan 2021 18:29:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1459</guid>
          <source url="https://forum.rebol.info/t/representing-everything-about-a-parameter-except-its-name/1459.rss">Representing Everything About A Parameter (...except its name)</source>
        </item>
        <item>
          <title>Notation for Outputs in Function Specs</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>The first cut at multiple return values made a multi-return output look like:</p>
<pre><code> func [/foo [&lt;output&gt; integer!]] [...]
</code></pre>
<p>Which was expedient to try it out.  <strong>But dialect-wise, I think a SET-WORD! makes more sense:</strong></p>
<pre><code> func [foo: [integer!]] [...]
</code></pre>
<h2>But What About The Deviant RETURN: ?</h2>
<p>It's a bit confusing to have RETURN: work different than other things specified by SET-WORD!.  This could be avoided by using a different convention, e.g. <strong><code>&lt;return&gt; [integer!]</code></strong> to stress the difference.</p>
<p>Or we could just say that it's "one of those things" and learnable, that the act of naming a return value "RETURN:" implies it's the main return...and gets special conventions and handling.</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/notation-for-outputs-in-function-specs/1414">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/notation-for-outputs-in-function-specs/1414</link>
          <pubDate>Sun, 22 Nov 2020 19:21:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1414</guid>
          <source url="https://forum.rebol.info/t/notation-for-outputs-in-function-specs/1414.rss">Notation for Outputs in Function Specs</source>
        </item>
        <item>
          <title>Opportunistic Invisibility</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p><a href="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405/">When "Invisibles" were introduced</a>, a function was either always-invisible or always-not-invisible.  You couldn't make a function that <em>"sometimes returned an INTEGER!, and sometimes was invisible."</em></p>
<p>Due to changes in the way the evaluator interacts with invisibles, this doesn't need to be a rule anymore.  There could be functions which decide--perhaps based on their arguments--whether to act invisibly or not.</p>
<p>This has actually been requested.  Imagine you are dealing with something like DUMP, and you want to call out that you'd like to actually return one of the things you are dumping:</p>
<pre><code>all [
    ...
    x * 10 + 20  ; want to print this expression and see its evaluated result
    ...
]

=&gt;

all [
    ...
    -- (x * 10 + 20)  ; now it's not participating in the ALL anymore
    ...
 ]
</code></pre>
<p><a class="mention" href="/u/gchiu">@gchiu</a> wanted some way of getting a printout like <code>-- (x * 10 + 20): 40</code> but also having the value still returned, without needing to name another operator.  So maybe you could mark this, e.g. with a GET-GROUP! or GET-WORD! in the DUMP dialect.</p>
<p><em>Having this particular debug construct behave in that way may not be the best idea in the world.</em><br>
But we don't need to technically prohibit it.</p>
<p>This could give an interesting nuance to the difference between <strong>return</strong> and <strong>return void</strong>.  RETURN used alone could just mean literally "return and don't have any value, not even void".  It's certainly a weird idea, but it's consistent...and we could make sure you knew what you were doing by requiring some kind of invisibility in the type signature of a function before allowing a 0-arg RETURN.  Of course there could be other syntaxes, like <strong>return/invisible</strong>...which would probably fit practice better by leaving plain RETURN as returning void.</p>
<p>There'd need to be a new syntax for saying you could return invisibles, because <code>return: []</code> as the indicator wouldn't allow you to specify it along with other types.</p>
<h2>Worth Doing?</h2>
<p>The main argument for opportunistic invisibles is to keep you from having to create different names for the invisible and visible forms of a function, when there could be a learnable convention for knowing which it is from the arguments alone.</p>
<p>The more fanciful argument is creating strange execution patterns in code golf, where you have some kind of "voting" mechanism e.g. inside an ALL and program behavior emerges from things opting out.  This harkens back some to the "null opts out of logical operations" ideas from the early days of null behavior.</p>
<p>Normalizing invisibles to the point of saying that they're what you get when you just do a plain RETURN is a fairly weird idea, but they're a pretty powerful feature that might have even more applications than yet thought of.  <strong>most free-form programming language ever created</strong> is still the goal, so... I think this deserves some consideration.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/opportunistic-invisibility/1362">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/opportunistic-invisibility/1362</link>
          <pubDate>Fri, 09 Oct 2020 15:57:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1362</guid>
          <source url="https://forum.rebol.info/t/opportunistic-invisibility/1362.rss">Opportunistic Invisibility</source>
        </item>
        <item>
          <title>Weird Idea: Blocks in Paths to Provide Refinement *AND* Value</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1333">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar">
</div>
<blockquote>
<p>We know pretty well what a GROUP! in a PATH! does. But what should a BLOCK! in a path do?</p>
</blockquote>
</aside>
<p>I'll mention that for function calls, I was thinking it would be nice if it could name a refinement and a value.</p>
<pre><code>&gt;&gt; data: '(a b c)
&gt;&gt; append/[dup: 1 + 2] data &lt;foo&gt;
== (a b c &lt;foo&gt; &lt;foo&gt; &lt;foo&gt;)
</code></pre>
<p>Given how common this would be, it's probably better to just use a WORD! instead of a SET-WORD! and people will get the idea, not expecting DUP to be a function call or something of that sort:</p>
<pre><code>&gt;&gt; data: '(a b c)
&gt;&gt; append/[dup 1 + 2] data &lt;foo&gt;
== (a b c &lt;foo&gt; &lt;foo&gt; &lt;foo&gt;)
</code></pre>
<p>Or maybe this is a job for TUPLE?</p>
<pre><code>&gt;&gt; data: '(a b c)
&gt;&gt; append/dup.(1 + 2) data &lt;foo&gt;
== (a b c &lt;foo&gt; &lt;foo&gt; &lt;foo&gt;)
</code></pre>
<p>Inert things could be just provided directly, like <strong><code>append/dup.3</code></strong></p>
<p>It wouldn't be great for everything, and you'd want to use APPLY for anything verbose.  But it could be convenient in some cases.</p>
<p>People very frequently request seeing the connection between the refinement and its value more obviously.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/weird-idea-blocks-in-paths-to-provide-refinement-and-value/1932">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/weird-idea-blocks-in-paths-to-provide-refinement-and-value/1932</link>
          <pubDate>Mon, 21 Sep 2020 05:38:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1932</guid>
          <source url="https://forum.rebol.info/t/weird-idea-blocks-in-paths-to-provide-refinement-and-value/1932.rss">Weird Idea: Blocks in Paths to Provide Refinement *AND* Value</source>
        </item>
        <item>
          <title>Partial Specialization Syntax in a NULL-refinement world</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>SPECIALIZE is used to make a version of a function that has some of its arguments fixed.  The syntax I first came up with (which we have been using up to this day) takes a block that it would bind into a "FRAME!" for the function.  So:</p>
<pre><code>&gt;&gt; a10: specialize 'append [value: 4 + 6]

&gt;&gt; a10 [a b c]
== [a b c 10]
</code></pre>
<p>Not only do you get to set the parameters, you also have evaluation on your side... like when you make an object.  Here it does an addition for demonstration purposes, but it could be arbitrary code with branching and switching/etc.  The question is which parameters are assigned values and which are not.</p>
<p>Since frames are like OBJECT!s that contain keys that correspond to arguments, the idea was that anything in this frame that wound up NULL would be considered "unspecialized".  So function calls would gather such arguments at the callsite as normal (e.g. the SERIES parameter of append, taken here as [a b c] normally).  But since the VALUE parameter was set to 10 and hence not-NULL, it would not be gathered...nor typechecked.  (The type checking occurs only at specialization time, helping performance.)</p>
<h2>But...what about when arguments are <em>intentionally</em> NULL?</h2>
<p>Er, yeah.  There was no good answer for this, so you'd have to do tricks.  For example: first SPECIALIZE a parameter to a non-null value, and then ADAPT with code that turns around and nulls it out each time the function gets called:</p>
<pre><code>an: adapt (specialize 'append [value: _]) [value: null]
</code></pre>
<p>That's inefficient and not too pretty, but it didn't come up often.  With a few exceptions like REPLACE to a NULL being a way to delete things, you usually didn't want to pass null parameters.  So solving it was a back-burner issue.</p>
<p><strong>But refinements offered "partial" specializations.</strong>  This was the idea of saying that you had a routine like APPEND which might have a /PART parameter, and you wanted to say that there was a /PART <em>but not say what it is</em>.  The intent was a variant  of APPEND which took 3 arguments instead of 2, and just didn't require you to say /PART.</p>
<p>The notation for that had originally been:</p>
<pre><code>&gt;&gt; ap: specialize 'append [part: true]

&gt;&gt; ap [a b c] [d e f] 2
== [a b c d e]
</code></pre>
<p><strong>This worked because refinements used to have arguments.</strong> The argument to /PART (named LENGTH in R3-Alpha) was still NULL, even though PART was true.  So partial specialization was encoded by virtue of having a value for the refinement but not the argument.</p>
<p><strong>Even then, there were problems with <em>order</em></strong>.  If you partially specialized both <strong>part: true</strong> and <strong>dup: true</strong>, which would be gathered first at the callsite?  This was cleverly solved by offering an alternative way to do it, via specializing a PATH!:</p>
<pre><code> &gt;&gt; apd: specialize 'append/part/dup []

 &gt;&gt; apd [a b c] [d e f g] 2 3
 == [a b c d e d e d e]   ; /PART 2, /DUP 3

  &gt;&gt; adp: specialize 'append/dup/part []

  &gt;&gt; adp [a b c] [d e f g] 2 3
  == [a b c d e f d e f]  ; /DUP 2, /PART 3
</code></pre>
<p><strong>Now that <a href="https://forum.rebol.info/t/pure-and-refined-simplifying-refinements-to-one-or-zero-args/1120">refinements are their own arguments</a>, we're in a situation where this method for partial specialization still works, but the other doesn't.</strong>  You can't say <strong>part: true</strong> anymore because the PART argument itself holds the number or series position that the partial is calculated relative to.</p>
<p><em>(I will point out that killing off the other partial specialization method is a good example of how the new refinement model purifies things, by eliminating a fuzzy guessing model where it had to count how many refinements you had specialized inside the block and whether you'd also specialized the arguments, and error if you tried more than one partial specialization at a time.)</em></p>
<h2>How to remove a refinement from the interface but NULL it?</h2>
<p>Let's imagine now that we want to make a version  of append that does not offer a /PART refinement, and yet still hasn't pinned it down to a value.</p>
<p>We could try a riff on the adapt of a specialization.  Pick some random /PART that type checks to specialize with, and then null it out when the call happens:</p>
<pre><code> a-no-part: adapt (specialize 'append [part: 1020]) [part: null]
</code></pre>
<p>That will always act like APPEND with no /PART, and in the HELP it does not list /PART as an available refinement.</p>
<p><strong>This is a pain and not efficient.</strong>  You have to know the types the refinement takes, pick some arbitrary random value compatible with that (which could change if you change the legal types on the specialized function, and it doesn't seem that should break the intention of a specialization removal).  Then you're wasting runtime nulling it out on every call with a useless additional layer of ADAPT-ation.</p>
<p><strong>Worst case scenario, we need a counter to AUGMENT whose job is to <em>remove</em> parameters.</strong>  (ABRIDGE?  DIMINISH?)  But it seems like that is SPECIALIZE's domain, since it removes other parameters when it says what value they have...why can't we find a syntax to do it when it says it's "fixed at no value"?</p>
<p>As a random example, we might come up with a wacky variation on the path notation:</p>
<pre><code> a-no-part: specialize 'append/[part] []
</code></pre>
<p>So maybe if it sees a word in a BLOCK! in the path, that means "remove from the interface and set to null/unused".</p>
<p>We could be less creative e.g.:</p>
<pre><code>a-no-part: specialize/remove 'append [] [part]
</code></pre>
<h2>What about normal parameters (and reordering?)</h2>
<p>Whatever mechanism we come up with here needs to work with ordinary arguments, too.  And something I've wondered is if pathing with ordinary arguments might tie into some kind of reordering scheme:</p>
<pre><code>&gt;&gt; append/series 10 [a b c]  ; imagine pushes /SERIES to be last parameter
== [a b c] 10
</code></pre>
<p>If we accept this, then strange ideas like <strong>specialize 'append/[value] [...]</strong> meaning "remove value parameter but set it to NULL" folds into the notion that you can just name any argument like this.  We can also imagine the idea of creating variations of a function where a previously mandatory argument becomes optional.</p>
<pre><code>&gt;&gt; apmaybe: unrequire 'append [value]

&gt;&gt; apmaybe [a b c]
== [a b c]

&gt;&gt; apmaybe/value [a b c] 10
== [a b c 10]
</code></pre>
<p>My point in bringing this up is that the one-parameter-per-name concept makes refinements and ordinary arguments have more in common.  So we can imagine the mechanism to remove a refinement from the interface (while still leaving it null) working on ordinary arguments that want to be fixed at null as well.</p>
<p><em>This is by no means unsolvable and we have a lot of the mechanics for doing it.</em>  It's just a question of what you write at source level, and can we do something nice that finesses it instead of looking like a mess.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/partial-specialization-syntax-in-a-null-refinement-world/1266">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/partial-specialization-syntax-in-a-null-refinement-world/1266</link>
          <pubDate>Wed, 04 Mar 2020 15:24:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1266</guid>
          <source url="https://forum.rebol.info/t/partial-specialization-syntax-in-a-null-refinement-world/1266.rss">Partial Specialization Syntax in a NULL-refinement world</source>
        </item>
        <item>
          <title>Wrapping And Forwarding Multi-Returns</title>
          <dc:creator><![CDATA[IngoHohmann]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1134">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134/1">The History of Multi-Return in Ren-C</a>
</div>
<blockquote>
<p>It seemed clearly preferable that rather than choose between <strong>[x]:</strong> and <strong>[x y]:</strong> and knowing in advance how many values you're taking or throwing away... someone who only asked for one value should be able to be blissfully ignorant. So the choice would be between:</p>
<pre><code>&gt;&gt; x: multi-return ...
&gt;&gt; [x y]: multi-return ...
</code></pre>
<p>Even though the first case is a multiple return, you wouldn't set x to a block of values, <em>but just get the first value</em>. An interface like this would also solve the issue of returning NULL.</p>
</blockquote>
</aside>
<p>Yup, sounds really useful.</p>
<p>One question, what do functions see?</p>
<pre><code>f: function [a][]
f multi-return
</code></pre>
<p>Does f get the return as a block, or the first value?</p>
<p>What happens with multiple parameters in f? With refinements? With variadics? When f is enfixed?</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/wrapping-and-forwarding-multi-returns/1926">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/wrapping-and-forwarding-multi-returns/1926</link>
          <pubDate>Thu, 28 Mar 2019 06:09:03 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1926</guid>
          <source url="https://forum.rebol.info/t/wrapping-and-forwarding-multi-returns/1926.rss">Wrapping And Forwarding Multi-Returns</source>
        </item>
        <item>
          <title>The History of Multi-Return in Ren-C</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p><em>This thread merges discussions of history across several threads to cover the key points, starting with material from the post announcing the addition of the SET-BLOCK! and GET-BLOCK!...and then folding in important points from later posts in the relative chronology of when they happened.  So it's broken up into sections by approximate date.</em></p>
<hr>
<h1>March 2019: SET-BLOCK! and GET-BLOCK! Added</h1>
<p>These were generic parts which you could use in dialects however you wanted...just like other types.</p>
<p><strong>But a key motivation was the concept that the evaluator would use them for some kind of multiple-return-value strategy.</strong>  Users of languages with the feature seemed to rave about it. And if you don't have it, they will complain and constantly try to find ways to work around it.</p>
<p>I had inklings that Rebol could do them in a way that is mindbending and original. But a dirt simple implementation of the idea in 2019 looked roughly like what people were used to with SET of BLOCK! from Rebol2, without needing to write the word SET:</p>
<pre><code>early-multi-concept: function [a b] [
    return :[(a * 3) (b - 16)]  ; e.g. :[...] would act like REDUCE [...]
]

&gt;&gt; [x y]: early-multi-concept 10 20
== [30 4]

&gt;&gt; x
== 30

&gt;&gt; y
== 4
</code></pre>
<p>So <strong><code>([x y]: foo)</code></strong> would act like <strong><code>(set [x y] foo)</code></strong>, including allowances to let you take fewer than one value:</p>
<pre><code>&gt;&gt; [x]: [10 20]
== [10 20]

&gt;&gt; x
== 10
</code></pre>
<h2>But the simplicity had obvious drawbacks</h2>
<p>First of all, Ren-C had NULL states that by design could not be put into blocks.  This approach wouldn't be able to return those without distorting them into some different reified value  than the intended NULL.</p>
<pre><code>&gt;&gt; [x y]: function-returning-null-and-30
== [&lt;null&gt; 30]  ; can't put null, so... "something else" in first slot?

&gt;&gt; x
== null  ; not the same thing as what the block said...seems bad, yes?

&gt;&gt; y
== 30
</code></pre>
<p>Also, you would have to know that what you were calling returned multiple values.  If you missed that and used a plain SET-WORD!, you'd just wind up with the block:</p>
<pre><code>&gt;&gt; x: some-function-i-didnt-know-was-multi-return ...
== [ret1 ret2 ret3]  ; the block! could easily be mistaken for single return
</code></pre>
<h2>I had one of those ideas that just wouldn't go away...</h2>
<p>It seemed clearly preferable that rather than choose between <strong>[x]:</strong> and <strong>[x y]:</strong> and knowing in advance how many values you're taking or throwing away... someone who only asked for one value should be able to be blissfully ignorant.  So the choice would be between:</p>
<pre><code>&gt;&gt; x: multi-return ...
&gt;&gt; [x y]: multi-return ...
</code></pre>
<p>Even though the first case is a multiple return, you wouldn't set x to a block of values, <em>but just get the first value</em>.  An interface like this would also solve the issue of returning NULL.</p>
<p>Not being forced to return a BLOCK! also made great sense... <em>because since BLOCK! is always truthy, you'd not really be able to make useful conditional behavior be based on a BLOCK! return anyway!</em></p>
<pre><code>&gt;&gt; [x y]: function-returning-null-and-30
== null  ; so you could meaningfully say `if [x y]: whatever [...]`

&gt;&gt; x
== null

&gt;&gt; y
== 30
</code></pre>
<p>Going even further, I suggested <em>"it would be important that if a function wanted to do multiple returns that it could know how many results it was assigning.  This could save calculation on things that aren't needed."</em></p>
<h3>
<em><strong>...but all this would require some kind of magic...</strong></em> <img src="https://forum.rebol.info/images/emoji/twitter/mage.png?v=9" title=":mage:" class="emoji" alt=":mage:">
</h3>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134</link>
          <pubDate>Thu, 28 Mar 2019 01:56:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1134</guid>
          <source url="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134.rss">The History of Multi-Return in Ren-C</source>
        </item>
        <item>
          <title>Variadic Return Values (not VARARGS! return values...)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Imagine the following:</p>
<pre><code>inline: function [
    return: [any-value! &lt;variadic&gt;]
    block [block!]
][
    return make varargs! block
]
</code></pre>
<p>With the desired behavior:</p>
<pre><code>&gt;&gt; 1 inline [+ 2 + 3]
== 6
</code></pre>
<p>This would be a very powerful macro-like mechanism.  (While not being done with any preprocessing step, and hence not a "macro" in the conventional sense).</p>
<p>One of the mechanical problems with such a construct is that when the evaluator is looking right from the 1, it has to know if the function it is seeing is enfix or not.  Unfortunately, INLINE doesn't have a generic answer...its answer depends on calculations it does once it is running, after its arguments are evaluated.  It depends on what's in the block it gets.</p>
<p>The evolving way of dealing with such situations is <em>left-variadic-enfix</em>.  This is to say that inline can defer its answer until when it runs...but by doing so it runs <em>before</em> its left hand side.</p>
<p>Here is simplified model of how that would work:</p>
<pre><code>inline: enfix function [
    return: [any-value! &lt;variadic&gt;]
    :look [&lt;opt&gt; any-value! &lt;variadic&gt;]
    block [block!]
][
    if enfix? w: match [word!] first block [
        return make varargs! compose/only [(take look) block]
    ]
    return make varargs! block
]
</code></pre>
<p>The moment of the TAKE (or the lack of a take) is how the evaluator gets its "are you enfix or not" answer from something whose left hand side is variadic.</p>
<p>While this looks very similar <a href="https://trello.com/c/Kg9A45b5/231-paths-can-be-dispatched-as-infix-and-provide-refinements-to-infix-operators-using-shove">to what SHOVE does</a>, SHOVE is actually implemented as an internal trick to the evaluator that is tailored to that particular case.  It doesn't run usermode code (or even plain code inside a native) to accomplish what it does.  It can't, because the variadic take of the left would require completing a higher stack level of code before a lower stack level.</p>
<p>It may seem variadics do this already (there's an ACTION! on the stack whose frame is running, and code is being processed from its "feed" to supply values to a variadic further on in the stack).  But that action is already running and has finished gathering its arguments--you're not interrupting the evaluator in mid-process, and hooking into the enfix mechanic itself.  I think it's possible though--it might need to use the same trick as ENCLOSE, which rearranges the stack in mid-run.</p>
<p>It would still be a little odd--in the same way that SHOVE is odd.  One odd thing is that <em>the evaluation of the block on the right has to happen before any evaluations on the left</em>:</p>
<pre><code>&gt;&gt; (print "left" 1) inline (print "right" [+ 2 + 3])
right
left
== 6
</code></pre>
<p>That's just the physics of the situation.  The left looking rightward needs the answer to a question that can't be answered until the right is evaluated.  But it's not just SHOVE that has this property, look at SET-PATH! operation... right before left:</p>
<pre><code>&gt;&gt; o: make object! [x: 10]
&gt;&gt; o/(print "left" x): (print "right" 20)
right
left
== 20
</code></pre>
<p>The reason for why it has to do that is similar.  I've made a <a href="https://github.com/rebol/rebol-issues/issues/2275#issuecomment-396708575">semi-convincing argument for why this is not a bug</a>, and if there are other constructs which have to do this then it seems less like an anomaly.</p>
<p>Reading between-the-lines, this would provide a highly generic tool for rewriting the stream of code...you could imagine things that take a VARARGS! in, and give a VARARGS! out.</p>
<h3>Avoiding Superfluous Stack Levels</h3>
<p>One area I'd like to see this applied is when you want to avoid introducing a stack level in the debugger.  e.g. the console has to run a block of code, but you don't want to see "DO BLOCK" putting DO on the stack.  Instead the API could just say:</p>
<pre><code>result = rebRun("inline", block);
</code></pre>
<p>This way, when the code inside the block is running, INLINE has already finished its work...handing the feed back to the evaluator.  It will appear there's nothing at all on the stack.</p>
<p>Because of the trickery involved, I <em>imagine</em> this would end up being slower than DO BLOCK (I'd basically be certain of it), so you wouldn't want to do it unless there was a good reason.  But there may be some cases where code is getting composed or wired up today to accomplish this where it would be faster.  Since it's a hypothetical feature at this point, it's probably best to wait to speculate too much on this.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/variadic-return-values-not-varargs-return-values/951">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/variadic-return-values-not-varargs-return-values/951</link>
          <pubDate>Sun, 09 Dec 2018 16:20:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-951</guid>
          <source url="https://forum.rebol.info/t/variadic-return-values-not-varargs-return-values/951.rss">Variadic Return Values (not VARARGS! return values...)</source>
        </item>
        <item>
          <title>Why No-Argument Refinements Are BLACKHOLE! or NULL</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>In Rebol2, a refinement's value would be #[true] or #[none]:</p>
<pre><code>rebol2&gt;&gt; show-me: func [/bar] [print mold bar]

rebol2&gt;&gt; show-me/bar
true  ; actually LOGIC! #[true], not the WORD! true

rebol2&gt;&gt; foo
none  ; actually a NONE! value, not the WORD! none
</code></pre>
<p><em>As a newbie, I was bothered by this from the get-go...</em> because I couldn't test refinements with AND/OR.  (they don't take #[none])  I hadn't drank the Kool-Aid that ANY/ALL were always a desirable substitute.</p>
<hr>
<blockquote>
<p><strong>NOTE: I never</strong> drank the ANY/ALL supremacy Kool-Aid.  Of course there are a lot of cool uses for them as larger scale control structures--and it's important to know how to use them for streamlining program flow.  But for testing flags?  The ability to do it infix and without delimiters can read much better in many places.</p>
<p>So Ren-C has adopted infix AND/OR that <a href="https://github.com/rebol/rebol-issues/issues/1879">operate conditionally on ANY-VALUE! and return LOGIC!</a> <em>(they also short-circuit)</em></p>
<pre><code>ren-c&gt;&gt; flag1: flag2: true

ren-c&gt;&gt; if flag1 and flag2 [print "It allows WORD!s, this comes up often"]
It allows WORD!s, this comes up often

ren-c&gt;&gt; if all [flag1 flag2] [print "Not everyone loves this (e.g. not me)"]
Not everyone loves this (e.g. not me)

ren-c&gt;&gt; if (block? flag1) and (empty? flag1) [print "Short-circuit avoids error"]
; to do this, the second argument to AND/OR is quoted behind the scenes 
</code></pre>
</blockquote>
<hr>
<p>There were countless debates over whether refinements should just be LOGIC! (as in Red), or if a used refinement should be the WORD! of the refinement (maybe useful for chaining?).  For a time, it seemed murkier when Ren-C introduced NULL...although it all tied up rather nicely in the end!</p>
<p><strong>But, 2022 UPDATE:</strong> I've cleaned up a bunch of historical rambling of me talking to myself in this thread to pare it down to what's useful.</p>
<hr>
<h2>Evolution Led Ren-C to <a href="https://forum.rebol.info/t/pure-and-refined-simplifying-refinements-to-one-or-zero-args/1120">Refinements As Their Own Arguments</a>
</h2>
<ul>
<li>
<p>Multiple-refinement arguments were a fringe feature, used almost nowhere.  Primarily it just created an inconvenience for 1-argument refinements having to come up with some random name for the argument.</p>
</li>
<li>
<p>With the existence of non-valued NULL, a single argument could represent the state of being used or not, along with the value itself.</p>
<ul>
<li>
<p>The "used" state would be able to hold ANY-VALUE! that could be put in a block.</p>
</li>
<li>
<p>NULL became falsey--so just testing it with IF could cover most "is the refinement used" questions...with specific tests for NULL? when there was risk of conflation with BLANK! or FALSE!</p>
</li>
</ul>
</li>
<li>
<p>It simplified the evaluator logic--removing the "refinements pick up every parameter after them" semantic.</p>
<ul>
<li>This paved the way for adding more arguments to functions after-the-fact, without worrying about them getting lumped in with the arguments of the existing last refinement.</li>
</ul>
</li>
</ul>
<h2>But What About Refinements That <em>Don't</em> Take Arguments?</h2>
<p>This question malingered along longer than I would have liked it to.  <img src="https://forum.rebol.info/images/emoji/twitter/zombie.png?v=9" title=":zombie:" class="emoji" alt=":zombie:"></p>
<p>For some time it would give you back a WORD! that was the name of the refinement itself:</p>
<pre><code>old-renc&gt;&gt; show-me: func [/bar] [print mold bar]

old-renc&gt;&gt; show-me/bar
bar

old-renc&gt;&gt; foo
; null
</code></pre>
<p>I'd advocated for this idea very early on:</p>
<ul>
<li>
<p>Imagine if one function took <code>/only</code> and wrapped another function that also took an <code>/only</code></p>
</li>
<li>
<p>If the wrapper got its ONLY variable for the refinement as the WORD! <code>only</code>...</p>
<ul>
<li>
<p>you could just say <strong><code>inner-function/(only)</code></strong></p>
<ul>
<li>
<p>If you got the refinement, that acts like <strong><code>inner-function/('only)</code></strong></p>
</li>
<li>
<p>If you didn't get the refinement, that would act like <strong><code>inner-function/(null)</code></strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If you squint your eyes and use your imagination a little, this might seem like a useful tool for chaining.</p>
</li>
</ul>
<p><strong>But the feature was a victim of Ren-C's other successes.</strong>  It's much easier and more efficient to wrap functions with things like ADAPT, ENCLOSE, SPECIALIZE.  The need to write this kind of "tunneling" function is rare: and refinement naming overlap is unlikely if the functions weren't somehow derived from each other.</p>
<p><em>(It also made building FRAME!s at a low-level more annoying...the value you put in the frames had to be contingent on the refinement name.  And it forced path dispatch steps to permit NULLs, when it didn't allow it anywhere else.  More complexity, for little benefit.)</em></p>
<h2>So Wouldn't LOGIC! For Argless Refinements be... <em>Logical?</em>
</h2>
<p>You might think so.  <img src="https://forum.rebol.info/images/emoji/twitter/robot.png?v=9" title=":robot:" class="emoji" alt=":robot:">  But actually... <em>no</em>.</p>
<p>There are a number of technical reasons.  Yet an intuitive angle might be to consider how an argument-less refinement contrasts with a refinement that takes an actual LOGIC! argument.</p>
<pre><code>foo: func [/mutate [logic!]] [...]
</code></pre>
<p>This refinement can be NULL (unspecified--e.g. the refinement was not used at all), or #[true] or #[false] when it is specified.  There's three states.</p>
<p>But an argument-less refinement is really just "used or unused".  So NULL and then a single truthy state... ideally a state that the system understands as meaning <em>"I'm opting in"</em>.</p>
<h2>The Modern Day: <a href="https://forum.rebol.info/t/sending-values-into-a-blackhole/1347">NULL or BLACKHOLE!</a>  <code>(#)</code>
</h2>
<p>While BLANK! has worked nicely as a falsey reified unit type, we've been lacking a truthy unit type.</p>
<p><strong>But with the unification of issues and characters, the appealing truthy "kind-of-a-unit-type" of # exists.</strong>  And its meaning of "please opt-in" is a good match for refinements.</p>
<ul>
<li>Space-wise fits in a single cell with no allocation, like BLANK!</li>
<li>It's not a series so it's not mutable and has very few operations it responds to.</li>
<li>It's one easily-visible character.</li>
<li>And again, it is truthy.</li>
</ul>
<h3>Simple To Set, Doesn't Depend on the Refinement Name</h3>
<pre><code> &gt;&gt; f: make frame! :some-function
 
 &gt;&gt; f.argless-refinement: if x = y [#]  ; slot will be either null or #
</code></pre>
<p>First reflex might be to make a TO-BLACKHOLE or similar:</p>
<pre><code> &gt;&gt; f.argless-refinement: to-blackhole x = y
</code></pre>
<p>But I actually think the <strong><code>if condition [#]</code></strong> looks pretty nice.  It's unambiguous and you get the idea.  "check this box, else leave it empty".  Short and obvious!</p>
<h3>Blackholes Are Fit For Purpose, and Aligns With Multi-Returns</h3>
<p>Blackholes were first invented to help "opt-in" scenarios with multi returns, with patterns like:</p>
<pre><code>if multireturn-var [  ; request for additional work made
    set multireturn-var do-additional-work
]
</code></pre>
<p>The truthy nature of <strong><code>#</code></strong>, along with being a no-op with SET, made it easy to request the additional work be done while not needing to name a variable to store the output.</p>
<p>That's no longer needed in multi-return, because <a href="https://forum.rebol.info/t/output-variables-in-multi-return/1859">it proxies variables for you automatically</a>, so you don't need the overhead of SET.</p>
<p>But it's still a useful feature, and can come in handy with # produced by used refinements!</p>
<h2>Higher Level Functions Can Add Conveniences!</h2>
<p>If you think it would be nice to be able to specify an argless refinement with a LOGIC!, guess what... you can!  <em>(Just not when building low-level frames...)</em></p>
<p>Higher level functions like APPLY are happy to turn a LOGIC! into a NULL or # for you.</p>
<pre><code>&gt;&gt; apply :append [[a b c] [d e] /only 1 = 1]
== [a b c [d e]]
</code></pre>
<p>SPECIALIZE doesn't do it at time of writing, but maybe it should...</p>
<pre><code>&gt;&gt; apo: specialize :append [only: 2 = 2]
** Script Error: Argless Refinement /only Must be either # or NULL
</code></pre>
<p>In any case, I just wanted to explain why an argless refinement to your function is going to be showing up as # or NULL, and that's more or less the final (?) answer.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/why-no-argument-refinements-are-blackhole-or-null/735">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/why-no-argument-refinements-are-blackhole-or-null/735</link>
          <pubDate>Thu, 12 Jul 2018 21:05:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-735</guid>
          <source url="https://forum.rebol.info/t/why-no-argument-refinements-are-blackhole-or-null/735.rss">Why No-Argument Refinements Are BLACKHOLE! or NULL</source>
        </item>
        <item>
          <title>METHOD and the argument against PROCEDURE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>I've an idea that METHOD be a left-quoting version of FUNCTION...looking for a SET-WORD! or SET-PATH! on its left, and doing the assignment.  The reason it would do this would be so that it had access to the word to read the binding out of it.  That means it can look to see what fields were in that object, to solve a problem today with using FUNCTION in objects:</p>
<pre><code>obj: make object! [
    x: 10
    f: function [] [
        x: 10 ;-- would assign a local, since it's gathered
        y: 20 ;-- would also assign a local
    ]
    f2: function [&lt;in&gt; obj] [ ;-- today's workaround
        x: 10 ;-- would assign obj/x
        y: 10 ;-- would assign a local
    ]
    m: method [] [
        x: 10 ;-- would assign obj/x, since it's in binding of `m:`
        y: 20 ;-- would assign a local, not in binding of `m:`
    ]
]
</code></pre>
<p><strong>This seems like a pretty darn cool idea to me.</strong>   The left quoting gives METHOD the missing piece of the binding it needs, so you don't need the workaround.</p>
<p>Cool as it is, it makes me wonder about the naming situation of having a PROCEDURE form.  If method needed a parallel to that, what would you call a method that doesn't return a value?  PROCMETHOD?  :-/</p>
<p>This leads me to feel that maybe PROCEDURE's semantics (0-arity "return", kill any result that might drop out) should be something you can indicate in either kind of spec easily.  And with <a href="https://forum.rebol.info/t/void-and-the-end-of-blankification/704">the new VOID! type</a>, we might have a coherent answer.  So...</p>
<p><em>Is there any really good reason why <strong><code>f: function [return: &lt;void&gt;] [...]</code></strong> couldn't be the signal to act like PROCEDURE does today, drop LEAVE, and just make RETURN not take an argument when that's that signature?</em></p>
<p>When definitional returns were being created, I was a bit worried about the idea that you might accidentally use a 0-arity RETURN with an argument.  But we are starting to need a test for "residual" execution anyway, to catch cases where you've got non-invisible content following something that RETURNs or throws, else we <a href="https://github.com/metaeducation/ren-c/issues/510">can't catch the "dark corner"</a> of <code>return if x [...] else [y]</code>.  So why not take a cue from C and just have a 0-arity RETURN in these cases?</p>
<p>People can still define PROCEDURE if they like it:</p>
<pre><code> procedure: func [spec body] [
     function compose [return: &lt;void&gt; (spec)]
         compose [leave: :return (body)]
 ]
</code></pre>
<p>To me it seems worth it to standardize so that METHOD can get the feature of auto-suppressing the result falling out of the bottom without needing another name, and it keeps from having to come up with two names for everything that wants to be function-like but do that.</p>
<p>There's technically no real reason why having this ability for FUNCTION needs to affect PROCEDURE.  It just may be more of a smooth transition to using METHOD to not teach people that a different action generator is how you get no-result.  Also, we could still say that <code>return: &lt;void&gt;</code> gives you a LEAVE instead of an arity-0 return if we wanted to.  It's perhaps no more of a non-sequitur than it was with PROCEDURE.  That's a separate decision... anyone have an opinion?</p>
            <p><small>10 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/method-and-the-argument-against-procedure/710">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/method-and-the-argument-against-procedure/710</link>
          <pubDate>Mon, 25 Jun 2018 04:02:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-710</guid>
          <source url="https://forum.rebol.info/t/method-and-the-argument-against-procedure/710.rss">METHOD and the argument against PROCEDURE</source>
        </item>
        <item>
          <title>Should we kill off defaults-in-function-specs via GROUP!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <blockquote>
<p><strong>UPDATE:</strong> Hmmm, it seems that this feature is needed for <code>&lt;static&gt;</code> variables, because they need to be initialized once, hence can't be done every function run.  So long as it exists for statics, we might keep it.  But I will say that the question of where to put them...and the fact no one is using these... raises questions about the feature that should probably be answered.</p>
</blockquote>
<hr>
<p>There was a speculative feature for putting defaults in function specs, by using a GROUP!:</p>
<pre><code>foo: function [
    x [integer!]
    /amount
    y [integer!] (10)
][
    x + y
]
</code></pre>
<p>One key concept was that if it were in the spec, then some amount of automatic documentation could be provided from it.  But also it meant you could save yourself mentioning the name parameter twice, in the spec to name it and the body to default it.</p>
<p>But what turned out to happen is that it gets pretty much lost in the noise, when you have string-based parameter documentation.  It's easy to overlook, and raises questions of whether you want any relevant evaluations in the GROUP! to run once or every time.</p>
<pre><code>x: 100
foo: function [
    x [integer!]
    /amount
    y [integer!]
        {The integer to add, hey where do we put that default now?}
        {Does it go before or after these documentation lines?}
            (10 * x) ;-- is that relative to the parameter or to the global?
][...]
</code></pre>
<p>Not only that, if you want to COMPOSE function specs you run into the problem of dealing with any GROUP!s in it.  So not having GROUP!s have meaning keeps you from ending up with problems with escaping there.</p>
<blockquote>
<p><strong>UPDATE</strong>: <a href="https://forum.rebol.info/t/tag-compose-is-it-tag-specific-composition/979">Labeled compose</a> has pretty much solved this problem if it comes up.  So I don't think it's a concern anymore.</p>
</blockquote>
<p>In the meantime, we've had the pretty <a href="https://trello.com/c/cTCwc5vX">infix <strong>default</strong> operator</a> come along.  It gives a nice enough and unambiguous experience.  You can even do your defaulting inline if you like:</p>
<pre><code>foo: function [
    x [integer!]
    /amount
    y [integer!]
][
    x + y: default [10]
]
</code></pre>
<p>There was no particularly efficient trick for storing the values or putting them in the frame...all it was doing was putting code in the body of the function, just like having a bunch of DEFAULT lines up front.  The unimplemented automatic documentation feature raises a lot of questions...if it was calculated, do you want the calculated value or just what was in the GROUP! raw?  :-/</p>
<p>Add it all up, and the GROUP!-to-default-a-parameter looks like a turkey.  So should people just learn and love DEFAULT and <a href="https://trello.com/c/XnDsvsM0">its good friend MAYBE</a>, and we get rid of this?</p>
<hr>
<p><strong>Pursuant to my update, here's a real world example to ponder from <span class="mention">@codebybrett</span>'s READ-DEEP:</strong></p>
<pre><code>read-deep: function [
    {Return files and folders using recursive read strategy.}
    root [file! url! block!]
    /full
        {Include root path, retains full paths vs. returning relative paths.}
    /strategy
        {Allows Queue building to be overridden.}
    take [function!]
        {TAKE next item from queue, building the queue as necessary.}
][
    take: default [:read-deep-seq]
    ...
]
</code></pre>
<p>Let's imagine we want to move that default into the spec.  Where?</p>
<pre><code>read-deep: function [
    {Return files and folders using recursive read strategy.}
    root [file! url! block!]
    /full
        {Include root path, retains full paths vs. returning relative paths.}
    /strategy
        {Allows Queue building to be overridden.}
    take [function!] (:read-deep-seq)
        {TAKE next item from queue, building the queue as necessary.}
][
    ...
]
</code></pre>
<p>I sort of feel like it vanished into the noise.  The code is <em>shorter</em>, but I don't feel it's <em>clearer</em>.  Putting it on its own line is its own line seems a little weird:</p>
<pre><code>read-deep: function [
    {Return files and folders using recursive read strategy.}
    root [file! url! block!]
    /full
        {Include root path, retains full paths vs. returning relative paths.}
    /strategy
        {Allows Queue building to be overridden.}
    take [function!]
        (:read-deep-seq)
        {TAKE next item from queue, building the queue as necessary.}
][
    ...
]
</code></pre>
<p>If one is writing a quick-and-dirty function with less documentation, it might be clearer...people might find it expedient.  This is why it works okay for <code>&lt;local&gt;</code>s and <code>&lt;static&gt;</code>s</p>
<pre><code>read-deep: function [root /full /strategy take (:read-deep-seq)] [
    ...
]</code></pre>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/should-we-kill-off-defaults-in-function-specs-via-group/500">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-we-kill-off-defaults-in-function-specs-via-group/500</link>
          <pubDate>Sun, 28 Jan 2018 10:22:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-500</guid>
          <source url="https://forum.rebol.info/t/should-we-kill-off-defaults-in-function-specs-via-group/500.rss">Should we kill off defaults-in-function-specs via GROUP!</source>
        </item>
  </channel>
</rss>

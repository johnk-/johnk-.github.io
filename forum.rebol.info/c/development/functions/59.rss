<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Functions - AltRebol</title>
    <link>https://forum.rebol.info/c/development/functions/59</link>
    <description>Topics in the &#39;Functions&#39; category Discussions of Functions and Generators, e.g. how things like RETURN work... or the mechanics of generators and composers like ADAPT, SPECIALIZE, ENCLOSE, HIJACK, etc.</description>
    
      <lastBuildDate>Sat, 30 Nov 2024 21:20:38 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/functions/59.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Simplifying Refinement Promotion</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>There are two modes of partial specialization which Ren-C has supported.</p>
<p>One form would be like if APPEND takes something like :DUP and fixes it to a value:</p>
<pre><code>&gt;&gt; append2: specialize append/ [dup: 2]

&gt;&gt; append2 [a b c] &lt;d&gt;
== [a b c &lt;d&gt; &lt;d&gt;]
</code></pre>
<p>Then there's a trickier kind of specialization, which is to ask for the parameter but not specify it... thus just increasing the arity:</p>
<pre><code>&gt;&gt; appenddup: append:dup/

&gt;&gt; appenddup [a b c] &lt;d&gt; 4
== [a b c &lt;d&gt; &lt;d&gt; &lt;d&gt; &lt;d&gt;]
</code></pre>
<p>The second form is pretty unusual in the language world.  There doesn't seem to be much prior art in "the conversion of optional parameters to required parameters" (at least I don't know any, and the AIs I asked don't know any).</p>
<p>Since it's pretty different from what what people think of as partial specialization, let's call it <strong>"refinement promotion"</strong>.</p>
<h2><a name="p-7935-refinement-promotion-is-tricky-1" class="anchor" href="https://forum.rebol.info#p-7935-refinement-promotion-is-tricky-1"></a>Refinement Promotion Is <em>Tricky</em></h2>
<p>Something that has been non-negotiable in the design is the straightforward array of parameters and locals that specify a function interface.</p>
<p>Refinements are defined in some order in that array.  But you are not required to use them in that order.</p>
<p>So consider a definition like:</p>
<pre><code> /foo: func [a [integer!] :b [integer!] :c [integer!]] [...]
</code></pre>
<p>Someone might do refinement promotion of this as <strong><code>foo:c:b/</code></strong> - this makes it seem to the caller a function originally written with spec:</p>
<pre><code> [a [integer!] c [integer!] b [integer!]]
</code></pre>
<p>The techniques so far have tried to mimic the way that refinements work.  So <strong><code>get $foo:c:b</code></strong> would produce a function that was accompanied by a <strong><code>[c b]</code></strong> array, that would get pushed when running the promoted function.  The elements in the array would not just have the words, but those words would have binding information to say what index those words were found at in the parameter array.</p>
<p>But since the underlying array is left the same, this means every time you want to know something like "what's the first unspecialized normal argument" you have to mimic the refinement gathering process.  It convoluted the process quite a lot, and really went against the idea of the implementation being "simple".</p>
<h2><a name="p-7935-q-is-this-really-required-to-support-a-yes-2" class="anchor" href="https://forum.rebol.info#p-7935-q-is-this-really-required-to-support-a-yes-2"></a>Q: Is This Really Required To Support?  (A: Yes)</h2>
<p>This may not seem like a super-common need.  But if you're implementing a dialect that wants to support calling functions with refinements, it's pretty important.</p>
<p>Let's say you're implementing something like <a href="https://forum.rebol.info/t/if-action-combinators-dont-impress-what-will/1608">the feature in UPARSE that lets you call functions</a>:</p>
<pre><code>&gt;&gt; data: copy ""

&gt;&gt; parse ["a" "b"] [some [/append:dup (data) text! (2)]]

&gt;&gt; data
== "aabb"
</code></pre>
<p>Basically, if <strong><code>(get $/append:dup)</code></strong> can come back with a function that you can query for its parameters and get answers just like it was any other function, then support for refinements comes basically for free.</p>
<h2><a name="p-7935-should-the-varlist-just-be-rewritten-3" class="anchor" href="https://forum.rebol.info#p-7935-should-the-varlist-just-be-rewritten-3"></a>Should The VarList Just Be Rewritten?</h2>
<p>If you look at what a modern SPECIALIZE followed by AUGMENT can do, they can hide parameters...and then add back parameters with the same name.  Which parameters are visible depend on the "phase" of the frame.</p>
<p>So why couldn't refinement promotion be done just by making a new function interface that removes the argument as a refinement, and adds it back as a regular argument... then has a dispatch phase that moves the argument data to its old position for the subsequent phases?</p>
<p>It's not particularly "cheap" to do that, space-wise.  You'd need a new VarList* and a new Phase*, and the Phase would have to remember the new and old positions to do the rewrite.  But it would make parameter enumeration blunt and simple, because you'd really just be enumerating the parameters in order.</p>
<p>There'd be some cases where the position of the refinement would allow it to just be naturally rewritten to be a regular argument, and that could be optimized for.</p>
<h2><a name="p-7935-what-about-when-you-have-lots-of-local-4" class="anchor" href="https://forum.rebol.info#p-7935-what-about-when-you-have-lots-of-local-4"></a>What About When You Have Lots of <code>&lt;local&gt;</code>?</h2>
<p>This is kind of the dark side of the simple FRAME! model, which is that if you use it to create a lot of local variables, then operations like SPECIALIZE and AUGMENT which do VarList manipulation have to make copies of everything for the new VarList...including a bunch of locals that aren't changing at all in each new form.</p>
<pre><code>/foo: func [x [text!] y [tag!] &lt;local&gt; a b c d e f g h i j k l m n o p] [
    ... 19 frame cells (includes RETURN) ...
]

/bar: augment foo/ [z [integer!]]  ; z is last item in new 20 item frame
</code></pre>
<p>Refinement promotion would become another one of these situations that would do seemingly unnecessary duplication.</p>
<p>It would be possible in cases like this to create smaller frames and then proxy the results into larger ones, essentially simulating what a user might do to manually call FOO from a new function BAR which had a frame with 3 elements.</p>
<pre><code>/bar: lambda [x [text!] y [tag!] z [integer!]] [
    foo x y  ; imagine doing this, but with faster internal mechanics
]
</code></pre>
<p>Some calculation could be done where the size of the frame justified it.  I have a feeling that the frame would have to be reasonably large before a technique like this would be beneficial.</p>
<h2><a name="p-7935-what-about-refinements-at-headhttpsforumrebolinfotrefinement-arguments-at-head-of-args-list-not-tail2331-5" class="anchor" href="https://forum.rebol.info#p-7935-what-about-refinements-at-headhttpsforumrebolinfotrefinement-arguments-at-head-of-args-list-not-tail2331-5"></a>What About <a href="https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331">Refinements At Head</a>?</h2>
<p>Well, in that case, you would <em>have</em> to build a new VarList* that extracted the arguments, and then proxy them into position for the new interface.</p>
<p>At least one wouldn't be worried about the "bloated copies of locals" situation.</p>
<h2><a name="p-7935-souse-the-auxiliary-array-simulating-refinements-6" class="anchor" href="https://forum.rebol.info#p-7935-souse-the-auxiliary-array-simulating-refinements-6"></a>So...Use The Auxiliary Array Simulating Refinements?</h2>
<p>The code for simulating refinements when asking simple questions like <em>"what's the first unspecialized normal arg"</em> is unappealingly complex. <img src="https://forum.rebol.info/images/emoji/twitter/nauseated_face.png?v=12" title=":nauseated_face:" class="emoji" alt=":nauseated_face:" loading="lazy" width="20" height="20"></p>
<p>Making it further unappealing is that when you have this array of refinements "off to the side" but still allow people to fill in slots in frames to specialize out arguments, you end up needing to have "reconciliation"...because those frame slots that are referenced by this out-of-band array are no longer part of the refinement promotion.</p>
<pre><code>&gt;&gt; f: make frame! append:dup:part/  ; has auxiliary [dup part]

&gt;&gt; f.dup: 3  ; what cleans up [dup part] to just [part] ?
</code></pre>
<p>I've talked about not knowing about what "moment" to do these kinds of fixes, and I'm increasingly looking for ways to avoid there being any such moment.  If the physical experience of the frame was that DUP and PART were ordinary parameters and not refinements, then it "just works".</p>
<h2><a name="p-7935-the-dumb-mechanical-answer-is-likely-best-7" class="anchor" href="https://forum.rebol.info#p-7935-the-dumb-mechanical-answer-is-likely-best-7"></a>The "Dumb" Mechanical Answer Is Likely Best</h2>
<p>I sometimes forget just how much I take for granted in Ren-C, regarding the ability to compose functions together.</p>
<p>The "inefficient" idea of making a new parameter list and then proxying the arguments into position would be more efficient than having to create and evaluate an interpreted function that had to manually copy the parameters.</p>
<p>There's a huge tax created by having to compose an off-to-the-side parameter reordering list in with the frame variables, and that tax is paid by <em>any code</em> that wants to interpret the list.  It's just too big a tax to pay.</p>
<p>It pains me a bit to delete it, because it was hard to write and seemed clever at the time.  But techniques have advanced...and while the auxiliary list may have seemed somewhat optimal for storage, it's no longer the right choice.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/simplifying-refinement-promotion/2338">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/simplifying-refinement-promotion/2338</link>
          <pubDate>Sat, 30 Nov 2024 21:20:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2338</guid>
          <source url="https://forum.rebol.info/t/simplifying-refinement-promotion/2338.rss">Simplifying Refinement Promotion</source>
        </item>
        <item>
          <title>Issues With Querying A Function&#39;s &quot;RETURN&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Each FUNCTION has a local variable named RETURN.  When it's running, the cell for that variable points at an "archetypal return function".  But that cell also holds a reference to that specific function instantiation's frame.  This way it knows how to return specifically from that invocation of that function.</p>
<p>This "definitional return" concept has worked quite well.  But there are some fiddly issues that arise from trying to make RETURN an ordinary local variable.</p>
<h2><a name="p-7931-it-was-hoped-return-would-not-be-special-1" class="anchor" href="https://forum.rebol.info#p-7931-it-was-hoped-return-would-not-be-special-1"></a>It Was Hoped RETURN Would Not Be Special</h2>
<p>The idea is that LAMBDA would be lower-level than FUNCTION, and permit you to have parameters or local variables named RETURN that had nothing to do with returning.</p>
<pre><code>/demo: lambda [return continue] [
    return + continue
]

&gt;&gt; demo 1 2
== 3
</code></pre>
<p>So an aspirational aspect of the design was that a user could create something that operated identically to the FUNCTION abstraction (just a bit slower, due to not being implemented natively).</p>
<p>It would use something like THROW and CATCH, to implement RETURN (or construct(s) in that family) itself, as LAMBDAs synthesized upon instantiation.</p>
<h2><a name="p-7931-return-as-local-hides-its-type-information-2" class="anchor" href="https://forum.rebol.info#p-7931-return-as-local-hides-its-type-information-2"></a>RETURN as Local Hides Its Type Information</h2>
<p>While it's not an argument to the function, RETURN still has associated type information.</p>
<p>Since RETURN is a local that will be filled with an action when the function runs, it isn't using its frame slot until that invocation happens.  That means it can store a PARAMETER! which says what return types are legal.  (It seems like a good use of an otherwise-unused slot otherwise you'd need a slot in the Phase to hold it.)</p>
<p>Functions like HELP want to know those types.  Yet locals and specialized arguments are traditionally considered implementation details, hidden from callers.  They're only visible  when frames are captured during the "phase" of being inside the function call:</p>
<pre><code>&gt;&gt; /foo: function [return: [integer!] x] [
     print mold words of binding of $x
]

&gt;&gt; words of foo/
== [x]

&gt;&gt; foo
== [return x]
</code></pre>
<p>Today's unsatisfying solution is that there's a flag on parameters that represent RETURN.  If you want the type information of that return, you can ask for it:</p>
<pre><code>&gt;&gt; return of foo/
== ~#[parameter! [integer!]]~  ; anti
</code></pre>
<p>But this flag is only applied by the FUNCTION native when its construction the parameter list.  So you wouldn't (for instance) get this behavior on a usermode re-implementation of FUNCTION based on LAMBDA.</p>
<h2><a name="p-7931-how-to-change-return-in-composition-3" class="anchor" href="https://forum.rebol.info#p-7931-how-to-change-return-in-composition-3"></a>How To Change RETURN In Composition?</h2>
<p>Let's say you're going to build a higher-level function with something like ENCLOSE:</p>
<pre><code>&gt;&gt; /bar: enclose foo/ func [return: [tag!] f [frame!]] [
       print "I'm an enclosure!"
       eval f
       return &lt;tag&gt;
   ] 
</code></pre>
<p>The interface of an enclosed function is the same parameter list as the original, and the same returns as the original.  The enclosure is implemented as a function that takes a frame, and it can be given a new return type.  But today that isn't reported as the return type if you asked for HELP of FOO.  It would look at the original parameter list, which in this case says its RETURN is <strong><code>[integer!]</code></strong>.</p>
<p><em>This suggests that the answer to the question <strong><code>return of</code></strong> has to be dispatcher-specific.</em></p>
<p>FUNCTION would say "it's the contents of the RETURN local in the archetype (not overwritten with return function, so still a PARAMETER!)".</p>
<p>ENCLOSE would say "it's the return type of the enclosure function that takes the frame" but then give back the original parameter list for everything else.  (This raises a question of how you would inherit the original function's return... it might be nice if you used a LAMBDA or something that reported no return constraint, that it would default to the constraints of the function you were enclosing.)</p>
<p>In any case, if it was answered by the dispatcher... then if LAMBDA says "I don't have a RETURN", you'd not have HELP information on your RETURN if you were trying to build your own FUNCTION on top of LAMBDA.</p>
<p><strong>The word RETURN may be a distraction, here.</strong>  Because if it's something like a GENERATOR, the products are coming from calls to YIELD.  Maybe <strong><code>(result of ...)</code></strong> or <strong><code>(synthesis of ...)</code></strong> would help stress that this question isn't tied up specifically with RETURN.</p>
<h2><a name="p-7931-lambda-semantics-may-want-result-specification-4" class="anchor" href="https://forum.rebol.info#p-7931-lambda-semantics-may-want-result-specification-4"></a>LAMBDA Semantics May Want Result Specification</h2>
<p>The idea of LAMBDA is that the evaluative product just drops out <a href="https://forum.rebol.info/t/implicit-execution-of-return-in-functions-bad/1656">(see various writings on why FUNCTION does not allow that)</a>.</p>
<p>But just because you want that semantic, doesn't mean you don't want the HELP to not give a return type.</p>
<p>However, LAMBDA doesn't have anywhere to store the type information the way FUNCTION does.  If it has a RETURN it may be using it for unrelated purposes.</p>
<p>Given what I've proposed for the dispatcher-specific RETURN, you could accomplish it with an ENCLOSE:</p>
<pre><code> enclose (lambda [...] [...]) func [return: [&lt;spec&gt;] f] [return eval f]
</code></pre>
<p>But it seems clearly better to have something specific to this purpose:</p>
<pre><code> returns [&lt;spec&gt;] lambda [...] [...]
</code></pre>
<p>Then the Returns_Dispatcher() would simply type check what you gave it.</p>
<p>Perhaps it could even accept a function as a first parameter, and then just say it returns whatever that function returns:</p>
<pre><code>returns add/ lambda [x] [x + 1]
</code></pre>
<p>Though that might be more confusing than writing it out:</p>
<pre><code>returns (return of add/) lambda [x] [x + 1]
</code></pre>
<p>Maybe a refinement should be used to bless that you're doing it on purpose:</p>
<pre><code>returns:same-as add/ lambda [x] [x + 1]
</code></pre>
<p>I guess the big question would be how to get the return's textual description in there.  Maybe it could assume if the format is TEXT! BLOCK! that's what you mean:</p>
<pre><code>/foo: returns [
   "The input plus one"
   [integer!]
] lambda [x] [
    x + 1
]
</code></pre>
<h2><a name="p-7931-well-theres-some-ideas-5" class="anchor" href="https://forum.rebol.info#p-7931-well-theres-some-ideas-5"></a>Well, There's Some Ideas</h2>
<p>I guess the idea here is that mechanics for answering "what do you return" come from the function's dispatcher, and maybe that becomes a chained question where if the dispatcher wraps something else, it has to ask the right parts of that thing.  There may be no user-exposed mechanic for building your own answer to the question beyond something like RETURNS, which is probably good enough.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/issues-with-querying-a-functions-return/2336">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/issues-with-querying-a-functions-return/2336</link>
          <pubDate>Thu, 28 Nov 2024 00:00:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2336</guid>
          <source url="https://forum.rebol.info/t/issues-with-querying-a-functions-return/2336.rss">Issues With Querying A Function&#39;s &quot;RETURN&quot;</source>
        </item>
        <item>
          <title>Dropping `&lt;with&gt;`, `&lt;in&gt;`, `&lt;static&gt;`</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>In R3-Alpha, there was the idea that FUNC was lower-level, <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/mezz/base-funcs.r#L28C1-L56C2">and "FUNCTION" was built on top of it</a>.</p>
<p>Its principal difference was automatically collecting SET-WORD!s as locals.  But it added two refinements: <strong>/WITH</strong> and <strong>/EXTERN</strong>.</p>
<p>/EXTERN was a way of saying what shouldn't get collected as a local variable due to being a SET-WORD!:</p>
<pre><code>global-var: 10

foo: function/extern [arg1 arg2] [
    local-var: "hi"
    global-var: 20  ; /EXTERN protected this from being collected local
    return arg1 + arg2
] [global-var]
</code></pre>
<p>/WITH was a way of making static variables:</p>
<pre><code>accumulate: function/with [x] [
   return state: state + x
] [state: 0]
</code></pre>
<h2><a name="p-7923-early-on-ren-c-moved-everything-into-the-spec-1" class="anchor" href="https://forum.rebol.info#p-7923-early-on-ren-c-moved-everything-into-the-spec-1"></a>Early On, Ren-C Moved Everything Into The Spec</h2>
<p>I didn't like seeing the refinement arguments at the end (of what could be a very long function definition).</p>
<p>It didn't occur to me to suggest that <a href="https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331">refinement arguments be moved to the head</a> (which they probably should).  But what did occur to me was that the function spec could incorporate these properties.</p>
<p>I actually thought <code>&lt;with&gt;</code> seemed better than extern, as a nicer word for "Use these existing variables".  And <code>&lt;static&gt;</code> seemed like a well-known term for static variables:</p>
<pre><code>foo: function [arg1 arg2 &lt;with&gt; global-var] [
    local-var: "hi"
    global-var: 20
    return arg1 + arg2
]

accumulate: function [x &lt;static&gt; state (0)] [
   return state: state + x
]
</code></pre>
<p>The subtlety of wanting to use an object instance was also added, as <code>&lt;in&gt;</code>:</p>
<pre><code>obj: make object! [a: 10 b: 20]

bar: function [x &lt;in&gt; obj] [
   return a + b + x
]
</code></pre>
<p>To my eyes, that all seemed like improvement.</p>
<p><strong>But it didn't come without cost: The spec had to be transformed into something the lower-level FUNC could understand.</strong></p>
<p>This meant there was a layer of parsing and production of a new spec that was a tax on every function creation.</p>
<h2><a name="p-7923-time-passes-set-word-gathering-is-panned-2" class="anchor" href="https://forum.rebol.info#p-7923-time-passes-set-word-gathering-is-panned-2"></a>Time Passes, SET-WORD! Gathering Is Panned</h2>
<p>It didn't take long for me to decide that <a href="https://forum.rebol.info/t/rethinking-auto-gathered-set-word-locals/1150">SET-WORD! locals-gathering was bad</a>... a gimmick that only made sense in very limited domains (perhaps code-golf)</p>
<p>This motivated having an answer for how to implement LET, as "virtual binding" became the new plan.</p>
<p>Once that transition went through, the effect of <strong><code>&lt;with&gt;</code></strong> was to become commentary.  Since all it did was remove SET-WORD!s from the collection list, and there was no collection any longer.</p>
<p>Though virtual binding did open up a new possibility, that if your block had a different binding than the spec, then the WITH might import visibility of terms to that block:</p>
<pre><code>global-variable: 10

block: /get-block-from-somewhere ...  ; doesn't know about GLOBAL-VARIABLE

/foo: function [x &lt;with&gt; global-variable] block
</code></pre>
<p>But this would be a binding operation, that is better generalized as:</p>
<pre><code>/foo: function [x] (bind @global-variable block)
</code></pre>
<h2><a name="p-7923-pushing-the-features-to-bind-make-the-most-sense-3" class="anchor" href="https://forum.rebol.info#p-7923-pushing-the-features-to-bind-make-the-most-sense-3"></a>Pushing The Features To BIND Make The Most Sense</h2>
<p>Not just <code>&lt;with&gt;</code>, but the <code>&lt;static&gt;</code> and <code>&lt;in&gt;</code> features seemed to be better as BIND operations as well.</p>
<p>The static syntax of not using SET-WORD!s was based on the idea that SET-WORD!s were reserved for local variables (and RETURN: syntax).  So it was a WORD! followed by a GROUP! to initialize.</p>
<p>I think it's better done with just <a href="https://forum.rebol.info/t/rethinking-static-in-the-function-spec-dialect/2139">BIND to a FENCE!</a></p>
<pre><code>accumulate: function [
    x
] bind {state: 0} [
   return state: state + x
]
</code></pre>
<p><code>&lt;in&gt;</code> is similar.</p>
<pre><code>obj: make object! [a: 10 b: 20]

bar: function [
   x
] bind obj [
   return a + b + x
]
</code></pre>
<h2><a name="p-7923-uglier-maybe-more-general-yes-faster-definitely-4" class="anchor" href="https://forum.rebol.info#p-7923-uglier-maybe-more-general-yes-faster-definitely-4"></a>Uglier?  Maybe.  More General?  Yes.  Faster?  Definitely.</h2>
<p>Feature-wise, there's a slight loss of the commentary capacity of <code>&lt;with&gt;</code>.</p>
<pre><code>global-var: 10

foo: function [arg1 arg2 &lt;with&gt; global-var] [  ; no-op, but useful?
    global-var: 20
    return arg1 + arg2
]
</code></pre>
<p>But besides that, there's no loss of features to move everything to a BIND operation on the body.</p>
<p>Not having to PARSE the spec and generate a whole new one is a big performance win.</p>
<p>So I'm letting go of those features.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/dropping-with-in-static/2335">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dropping-with-in-static/2335</link>
          <pubDate>Thu, 21 Nov 2024 22:06:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2335</guid>
          <source url="https://forum.rebol.info/t/dropping-with-in-static/2335.rss">Dropping `&lt;with&gt;`, `&lt;in&gt;`, `&lt;static&gt;`</source>
        </item>
        <item>
          <title>Refinement Arguments at Head of Args List, Not Tail</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>In the corpus of code we have so far, it seems to me that when a refinement adds an argument to a function that it would be preferable if that argument would become the first parameter... not tacked onto the end.</p>
<p>Some cases might not be completely obvious one way or another:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c [d e]]

&gt;&gt; append:dup [a b c] [d e] 2  ; old way
== [a b c [d e] [d e]] 

&gt;&gt; append:dup 2 [a b c] [d e]  ; new idea
== [a b c [d e] [d e]]
</code></pre>
<p>I think it's better if it's first, but it's not earth-shattering.</p>
<p>But in other cases it seems very much an improvement.  Consider the positioning of the argument to FAIL:BLAME...</p>
<pre><code>foo: func [arg thing] [
    if arg &lt; 0 [
        fail:blame [
           "Here is some long error message:" @thing
           "Whatever..."
        ] $arg
    ]
]

foo: func [arg thing] [
    if arg &lt; 0 [
        fail:blame $arg [
           "Here is some long error message:" @thing
           "Whatever..."
        ]
    ]
]
</code></pre>
<p>Or an argument to COMPOSE giving a pattern to use:</p>
<pre><code>compose:pattern [
    some bunch of {{code that}} &lt;spans&gt;
    #multiple lines
    [and could go on for pages]
] ${{}}  ; afterthought...

compose:pattern ${{}} [  ; forethought
    some bunch of {{code that}} &lt;spans&gt;
    #multiple {{lines}}
    [and could go on for pages]
]
</code></pre>
<p>This goes along with some Haskell philosophy I cited in <a href="https://forum.rebol.info/t/parameter-order-in-rebol/1238">Parameter Order in Rebol</a>:</p>
<blockquote>
<p><em>"It's common practice in Haskell to order function parameters so that parameters which "configure" an operation come first, and the "main thing being operated on" comes last. This is often counter intuitive coming from other languages, since it tends to mean you end up passing the "least important" information first. It's especially jarring coming from OO where the "main" argument is usually the object on which the method is being invoked, occurring so early in in the call that it's out of the parameter list entirely!"</em></p>
</blockquote>
<p>These refinements typically seem to be <em>configuring</em>, as if they are changing the function itself, and belong at the head.</p>
<p>e.g. above, the function you're conceptually applying is <strong><code>(compose:pattern ${{}})</code></strong></p>
<h2><a name="p-7889-history-didnt-do-it-this-way-with-some-reasons-1" class="anchor" href="https://forum.rebol.info#p-7889-history-didnt-do-it-this-way-with-some-reasons-1"></a>History Didn't Do It This Way, With Some Reasons</h2>
<p>Refinements are typically listed at the end of the function spec.</p>
<p>From an implementation standpoint, that's also where their "slots" are in the argument list.</p>
<p>This means that as you are walking the argument list and fulfilling arguments from the callsite, if refinements were used you would have to skip over the "normal" arguments in a first pass, and then come back and fill them later.</p>
<p>Historical Redbols only had to be worried about the order of usage of refinements... if you used them out of order from the declaration, a second pass would be needed.  But using them in order would not require it.</p>
<p>This isn't a problem for Ren-C...it's designed for generic parameter reordering (refinements or otherwise) and it has an efficient way to beeline back to slots it skipped on a second pass.</p>
<p>So really the only issue is the mismatch between the visual order in the spec (which may be exposed mechanically by fixed orders of enumeration of FRAME! keys and values), compared with the gathering behavior.  But the disconnect of that order has always been there, with <strong>foo/refine1/refine2</strong> vs. <strong>foo/refine2/refine1</strong> in Redbol... the callsite order may not match the frame order.</p>
<h2><a name="p-7889-is-it-worth-changing-2" class="anchor" href="https://forum.rebol.info#p-7889-is-it-worth-changing-2"></a>Is It Worth Changing?</h2>
<p>The competing (complementary) idea of <a href="https://forum.rebol.info/t/dialecting-function-calls-new-weird-powerful/2310">CHAIN! dialecting</a> offers something that's likely even more compelling:</p>
<pre><code>compose:pattern ${{}} [  ; better than today...
    some bunch of {{code that}} &lt;spans&gt;
    #multiple {{lines}}
    [and could go on for pages]
]

compose:${{}} [  ; ...but this surpasses even that
    some bunch of {{code that}} &lt;spans&gt;
    #multiple {{lines}}
    [and could go on for pages]
]
</code></pre>
<p>Though it's kind of up in the air if and when that's going to get attacked, and how well it will work (it may run afoul of problems in binding, etc.)</p>
<p>My instincts tell me that it's worth changing.  In practice, refinements that take arguments are not super common... but when they do happen, being up front seems to make the most sense.</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331</link>
          <pubDate>Tue, 12 Nov 2024 14:16:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2331</guid>
          <source url="https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331.rss">Refinement Arguments at Head of Args List, Not Tail</source>
        </item>
        <item>
          <title>Generalized Argument Removal - SPECIALIZE:RELAX</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Let's say you want a version of append that just appends random numbers to things:</p>
<pre><code>&gt;&gt; append-random: adapt get $append [
       value: random 10
   ]
</code></pre>
<p>This works, but the function interface still thinks it takes two arguments:</p>
<pre><code>&gt;&gt; append-random [a b c] [d e]
== [a b c 10]
</code></pre>
<p>So fine, you can just specialize out the argument.  Both ADAPT of a SPECIALIZE and SPECIALIZE of an ADAPT would remove an argument.  But you want the specialize to run first, otherwise it would overwrite the adapted value.  So SPECIALIZE the ADAPT, to put the specialize earlier in the composition process.</p>
<p><em><strong>But what value do you put in the specialized-out slot if you're just going to overwrite it?</strong></em></p>
<p>Today we have quite the awesome answer: <strong><a href="https://forum.rebol.info/t/tripwire-in-the-wild/2278">use a TRIPWIRE!</a></strong>  Sounds great!</p>
<pre><code>&gt;&gt; append-random: specialize (adapt get $append [
       value: random 10
   ]) [
       value: ~&lt;specialized out&gt;~
   ]
** Script Error: append expects [~void~ element? splice?] for its value argument
</code></pre>
<h2>
<a name="ooops-specialize-typechecked-that-1" class="anchor" href="https://forum.rebol.info#ooops-specialize-typechecked-that-1"></a>Ooops.  SPECIALIZE Typechecked That</h2>
<p>There are two good reasons for specialization to type check:</p>
<ul>
<li>
<p>You find out about bad types at the moment of specialization--instead of having to wait until the function is called to know there are problems.</p>
</li>
<li>
<p>It can speed up the system by not type checking those parameters again <em>(though it occurs to me this may be broken right now, and fixing it sooner than later would probably be smart)</em></p>
</li>
</ul>
<p>Historically what I've done just to get things going is to use some value that typechecks in the argument slot:</p>
<pre><code>&gt;&gt; append-random: specialize (adapt get $append [
       value: random 10
   ]) [
       value: [something that typechecks]
   ]

&gt;&gt; append-random [a b c]
== [a b c 7]

&gt;&gt; append-random [a b c]
== [a b c 9]

&gt;&gt; append-random [a b c]
== [a b c 7]
</code></pre>
<p>For the sake of education, notice what happens if you did it backwards and ADAPT the SPECIALIZE:</p>
<pre><code>&gt;&gt; append-random: adapt (specialize get $append [
       value: [something that typechecks]
   ]) [
       value: random 10
   ]

&gt;&gt; append-random [a b c]
== [a b c [something that typechecks]]
</code></pre>
<h2>
<a name="seems-we-need-specializerelax-2" class="anchor" href="https://forum.rebol.info#seems-we-need-specializerelax-2"></a>Seems We Need SPECIALIZE:RELAX</h2>
<p>Having to pick an arbitrary meaningless value that won't trip up the type checking is bad.</p>
<p>While we want to type check 99% of the time, this kind of scenario calls for a version of specialize that does not do typechecking.</p>
<p>Hence I propose <strong><code>SPECIALIZE:RELAX</code></strong>.</p>
<p>Tripwires seem like the go-to datatype to use for these specialized-out values.  Rather than just say <strong><code>~&lt;specialized out&gt;~</code></strong> you can be as detailed as you like, to help inform on what should happen:</p>
<pre><code>&gt;&gt; append-random: specialize:relax (adapt get $append [
       value: random 10
   ]) [
       value: ~&lt;ADAPT phase of APPEND-RANDOM puts INTEGER! here&gt;~
   ]
</code></pre>
<p>Tripwires are great!  <img src="https://forum.rebol.info/images/emoji/twitter/boom.png?v=12" title=":boom:" class="emoji" alt=":boom:" loading="lazy" width="20" height="20">  You don't have to stress too much about cost...the string inside the tag only exists as one instance in memory.</p>
<p>But you could be lazy and/or cheap, and just unset it. <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p>
<pre><code>&gt;&gt; append-random: specialize:relax (adapt get $append [
       value: random 10
   ]) [
       value: ~
   ]
</code></pre>
<p>There might be other uses for not typechecking at the moment of specialization, but I can't think of what they would be.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/generalized-argument-removal-specialize-relax/2297">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/generalized-argument-removal-specialize-relax/2297</link>
          <pubDate>Mon, 23 Sep 2024 17:37:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2297</guid>
          <source url="https://forum.rebol.info/t/generalized-argument-removal-specialize-relax/2297.rss">Generalized Argument Removal - SPECIALIZE:RELAX</source>
        </item>
        <item>
          <title>Implicit Escaping To Tiebreak Literal Arguments</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Imagine a situation where one function takes its right-hand side literally, and another takes its left-hand side literally:</p>
<pre><code>right-literal: func ['arg] [...]
left-literal: enfix func ['left right] [...]
</code></pre>
<p>What happens when I write:</p>
<pre><code> right-literal X left-literal Y
</code></pre>
<p>Seems like an unbreakable tie.  <img src="https://forum.rebol.info/images/emoji/twitter/necktie.png?v=12" title=":necktie:" class="emoji" alt=":necktie:" loading="lazy" width="20" height="20"></p>
<p>You're going to be lying to someone if you don't trigger an error.  It could be a pretty big lie...e.g. if you let one evaluate and pass their result to the other, then you might be giving an antiform to a function that specifically only expected source-representable things.</p>
<h2>
<a name="but-what-if-the-situation-was-a-bit-moremalleable-1" class="anchor" href="https://forum.rebol.info#but-what-if-the-situation-was-a-bit-moremalleable-1"></a>But what if the situation was a bit more...malleable...</h2>
<p>Let's say that one of these lets you escape the argument inside a GROUP! (currently thinking the most semiotic way to represent such a property of a parameter is by...putting it in a group).</p>
<pre><code>right-escapable: func ['(arg)] [...]  ; `right-esc ('X)` acts like `right-esc X` 
left-literal: enfix func ['left right] [...]
</code></pre>
<p>So this means that RIGHT-ESCAPABLE is geared up to accept evaluative products.  If that's the case, then we might think of ourselves as having a bit more liberty to tiebreak:</p>
<pre><code>right-escapable X left-literal Y
=&gt;
right-escapable (X left-literal Y)
</code></pre>
<p>Whether that seems presumptuous or not to you, it definitely is useful, e.g. with lambdas...where requiring a group would be ugly:</p>
<pre><code>case [...] then x -&gt; [...]
</code></pre>
<p>The interface on the function says it was "willing to accept a group at the callsite".  But it never actually received a group, just the evaluative product, which would then be typechecked.  Given that it's willing to take that evaluative product, why not throw in the group implicitly vs. giving an error?</p>
<p>You should be convinced.  It's a good thing.</p>
<h2>
<a name="another-case-study-infix-of-2" class="anchor" href="https://forum.rebol.info#another-case-study-infix-of-2"></a>Another Case Study: Infix "OF"</h2>
<p>First there was <strong><code>(type? x)</code></strong> in Rebol2</p>
<p>Then <strong><code>(type-of x)</code></strong> emerged, in the attempts to purge the blight of <em>"functions that return a result end in question mark"</em>, reserving it for LOGIC-bearing functions.</p>
<p>It then became <strong><code>(type of x)</code></strong> to be even more pleasing to the words-separated-by-spaces aesthetic.</p>
<p>But the infix properties of such a left-literal function can't be the same as ordinary evaluative infix, e.g. math:</p>
<pre><code>&gt;&gt; 1 + 2 * 3
== 9  ; e.g. (1 + 2) * 3
</code></pre>
<p>Because we used to be able to write:</p>
<pre><code>&gt;&gt; integer! = type-of 1
== ~okay~  ; anti
</code></pre>
<p>So we'd still like to be able to write:</p>
<pre><code>&gt;&gt; integer! = type of 1
== ~okay~  ; anti
</code></pre>
<p>Hence that can't be interpreted as <strong><code>(integer! = type) of 1</code></strong></p>
<p><em>"Easy enough"</em> you say... <em>"make it so literal left enfix wins over evaluative right enfix."</em></p>
<p>If you think it's easy, try writing this stuff yourself.  But yes--that is what I did.</p>
<p>However, OF is one of these "escapable" routines.  We want to be able to do this:</p>
<pre><code>&gt;&gt; integer! = (first [type length]) of 1
== ~okay~  ; anti
</code></pre>
<p>So how does this work out with our tie-breaking?</p>
<p><em>It doesn't count.</em>  There's no tie to break.  <strong><code>=</code></strong> isn't inescapably quoting its right.  If it <em>was</em> inescapably quoting its right, then the escapable left would mean the OF would yield to the hard rightward literal.</p>
<h2>
<a name="its-simpler-than-i-had-it-3" class="anchor" href="https://forum.rebol.info#its-simpler-than-i-had-it-3"></a>It's Simpler Than I Had It</h2>
<p>Due to some accidents of history and not really having clear thinking on this, there were more parameter conventions than were required... with one hacked in to specifically make the <strong>OF</strong> case work.</p>
<p>It turns out that using the rationale above, the extra parameter convention can be dropped.  It can all be done with just escapability-or-not meeting escapability-or-not.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/implicit-escaping-to-tiebreak-literal-arguments/2290">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/implicit-escaping-to-tiebreak-literal-arguments/2290</link>
          <pubDate>Fri, 20 Sep 2024 17:17:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2290</guid>
          <source url="https://forum.rebol.info/t/implicit-escaping-to-tiebreak-literal-arguments/2290.rss">Implicit Escaping To Tiebreak Literal Arguments</source>
        </item>
        <item>
          <title>Invariant for PATH! w.r.t. FRAME! vs. antiform FRAME!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>So I sort of feel like it would be a bit of a waste if you couldn't use the slash notation in paths to run a non-antiform FRAME!</p>
<p>So let's say you wrote:</p>
<pre><code>&gt;&gt; manipulators: reduce // [
       [get $append get $insert get $change]
       /predicate get $noquasi/reify  ; doesn't have a single name, should it?
   ] 
== [#[frame! ...] #[frame! ...] #[frame! ...]
</code></pre>
<p>We definitely want picking with a TUPLE! to be inert, that's a central point of the good new world:</p>
<pre><code>&gt;&gt; manipulators.1
== #[frame! ...]
</code></pre>
<p>But should you use a PATH!, I feel like this should work... I think... <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<pre><code>&gt;&gt; manipulators/1:dup [a b c] [d e] 2
== [a b c [d e] [d e]]
</code></pre>
<p>It's a bit weird to see a number-headed chain used to run a function.  But, y'know, that's consistent with history:</p>
<pre><code>red&gt;&gt; manipulators: reduce [:append :insert :change]
== [make action! [...] make action! [...] make action! [...]]

red&gt;&gt; manipulators/1/dup [a b c] [d e] 2
== [a b c d e d e]
</code></pre>
<p>...and since they don't have the alternative of TUPLE!, <a href="https://rebol.tech/gitter.im/red/red/2019/#msg5c782ca0c1cab53d6f53dd6d">they don't have a way to avoid "active accessors"</a>.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/foot.png?v=12" title=":foot:" class="emoji only-emoji" alt=":foot:" loading="lazy" width="20" height="20"> <img src="https://forum.rebol.info/images/emoji/twitter/gun.png?v=12" title=":gun:" class="emoji only-emoji" alt=":gun:" loading="lazy" width="20" height="20"></p>
<h2>
<a name="more-often-useful-case-would-be-just-frame-1" class="anchor" href="https://forum.rebol.info#more-often-useful-case-would-be-just-frame-1"></a>More Often Useful Case Would Be Just <strong>frame/</strong>
</h2>
<p>It's actually useful to store inert frames in data structures.  UPARSE does it for the combinator map.  It comes up.</p>
<p>But I think people will want to do things like:</p>
<pre><code>&gt;&gt; frame: make frame! get $append
&gt;&gt; frame.series: [a b c]
&gt;&gt; frame.value: [d e]

&gt;&gt; frame/  ; using this form of application would COPY the FRAME! before running
== [a b c [d e]]
</code></pre>
<p>On the other hand, I believe that the correct meaning of <strong><code>/frame</code></strong> is that it should <em>not</em> run the inert frame.</p>
<h2>
<a name="get-of-non-blank-headed-path-should-yield-an-antiform-2" class="anchor" href="https://forum.rebol.info#get-of-non-blank-headed-path-should-yield-an-antiform-2"></a>GET of (non-blank-headed) PATH! Should Yield An Antiform</h2>
<p>We <em>could</em> disable GET of a PATH! when it looks up to a plain frame and not an antiform...and say that paths can only be used with inert frames during EVAL.  But I don't see the point of that (and it breaks the natural layering, where the code interpreting the path is the same for both GET and EVAL).</p>
<p>So I think you should be able to GET either one.</p>
<p>But regardless of whether the thing you got to with the PATH! was a plain FRAME! or an antiform FRAME!... if you GET it I think you should receive an antiform frame back.</p>
<p>As a reader, I don't want to have to puzzle over what the result is going to be.  Seeing GET of a PATH! and knowing that's going to be an antiform frame is more useful than I can imagine preserving the distinction ever being.  Not only are antiform frames what you usually desire, <em>if you'd wanted an inert frame you could have used a TUPLE! to get it instead</em>.</p>
<p>So this seems pretty well decided to me.</p>
<h2>
<a name="dont-permit-quasi-frame-or-quoted-frame-to-run-3" class="anchor" href="https://forum.rebol.info#dont-permit-quasi-frame-or-quoted-frame-to-run-3"></a>Don't Permit QUASI-FRAME! or QUOTED-FRAME! To Run</h2>
<p>I've already written up my thoughts on <a href="https://forum.rebol.info/t/quasiforms-arent-super-friendly-and-they-shouldnt-be/2273">avoiding making quasiforms too friendly</a>.  It does make things awkward at times.  But I think that awkwardness is for the best.</p>
<p>The same applies to quoted frames.  I don't think tolerance of these forms by the core leads to anything good.  It ties into why I don't want <strong>('a = first [''a])</strong> to be true... once you start ignoring things like quote marks and treating it as equivalent, people will get sloppy with their input...which ties your hands later on if you want to give quote levels some dialected meaning (e.g. use them for tunneling values in meta form).</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/invariant-for-path-w-r-t-frame-vs-antiform-frame/2279">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/invariant-for-path-w-r-t-frame-vs-antiform-frame/2279</link>
          <pubDate>Sun, 15 Sep 2024 11:03:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2279</guid>
          <source url="https://forum.rebol.info/t/invariant-for-path-w-r-t-frame-vs-antiform-frame/2279.rss">Invariant for PATH! w.r.t. FRAME! vs. antiform FRAME!</source>
        </item>
        <item>
          <title>Typechecking For ^META Parameters (incl. ANY-ATOM?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>I wanted to point out that typechecking a ^META parameter applies to the unescaped form.</p>
<p>So if you have a ^META argument which says it can accept something unstable like a PACK!, that is written as:</p>
<pre><code>func [^arg [integer! pack?]] [...]
</code></pre>
<p>...not...</p>
<pre><code>func [^arg [quoted-integer? quasi-pack?]] [...]
</code></pre>
<p>So although you are receiving the <strong>arg</strong> value in its quoted or quasi form, the type check is in the language of what it was before it was META'd.</p>
<p>This raises a question about the meaning of <strong>func [^arg [any-value?]] [...]</strong>.  Does that encompass unstable antiforms as well as stable ones?</p>
<p>No.  And in fact, if you write that then you're using a meta parameter for no reason, because you're just getting the same thing you would have gotten if you had written:</p>
<pre><code>foo: func [arg [any-value?]] [
     arg: meta arg
     ...
]
</code></pre>
<p>So the parameter convention isn't giving you any special powers if you type check it as ANY-VALUE?.  Error antiforms will become abrupt failures if you try to pass them.  Multi-return packs will decay to their first element.  Etc.</p>
<p>To get anything special, your ^META parameter's type check has to allow some unstable antiforms.  If you want any and all of them, the term I've been using is ANY-ATOM?</p>
<p>Alternative names welcome.  But Atom is short, and ties into the whole isotope metaphor.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/typechecking-for-meta-parameters-incl-any-atom/2249">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/typechecking-for-meta-parameters-incl-any-atom/2249</link>
          <pubDate>Wed, 04 Sep 2024 09:17:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2249</guid>
          <source url="https://forum.rebol.info/t/typechecking-for-meta-parameters-incl-any-atom/2249.rss">Typechecking For ^META Parameters (incl. ANY-ATOM?)</source>
        </item>
        <item>
          <title>Function Composition via PATH!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Something to consider here is what to do if there's a slash <em>after</em> a function call</p>
<pre><code>lib/append:dup.2/xxxx
</code></pre>
<p>To be coherent with "slash is tied to invokable functions", it seems the thing on the right should be specifying some sort of function invocation, I'd think?</p>
<p>It may not seem useful to say it was an invocation that would happen on the result:</p>
<pre><code>append:dup.2/empty? [] if false [&lt;nothing&gt;]
</code></pre>
<p>Because you could have written that as:</p>
<pre><code>empty? append:dup.2 [] if false [&lt;nothing&gt;]
</code></pre>
<p><em>BUT</em> if you can do it all in one swoop, you can get a description for a cascade of functions passed as a single value:</p>
<pre><code>odd?: get $even?/not
</code></pre>
<p>Though reading it backwards isn't as useful as reading it forwards:</p>
<pre><code>odd?: get $not/even?
</code></pre>
<p>We wouldn't worry so much that the composition tool that was CHAIN has to be renamed CASCADE if we have another way of saying it that we can use most of the time.</p>
<p><a href="https://forum.rebol.info/t/the-brave-new-world-of-skippable-predicates/1045/4">I had a similar idea a long time ago</a>.  Anyway, put a <img src="https://forum.rebol.info/images/emoji/twitter/pushpin.png?v=12" title=":pushpin:" class="emoji" alt=":pushpin:" loading="lazy" width="20" height="20"> in that.  There's lots of ground to cover first.</p>
            <p><small>9 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/function-composition-via-path/2242">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/function-composition-via-path/2242</link>
          <pubDate>Thu, 29 Aug 2024 03:42:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2242</guid>
          <source url="https://forum.rebol.info/t/function-composition-via-path/2242.rss">Function Composition via PATH!</source>
        </item>
        <item>
          <title>SET-WORD! To Initialize Locals In Function Specs?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p><em>(cc: <a class="mention" href="https://forum.rebol.info/u/ingohohmann">@IngoHohmann</a> as you have had opinions on these kinds of things.)</em></p>
<p>It seems it would be nice if you had the option of setting your locals when you define them.</p>
<pre><code>foo: func [
    arg1 [integer!]
    arg2 [text!]
    &lt;local&gt;
    local1 local2
    local3: 10
    local4: (20 * 30)
][
    ...
]
</code></pre>
<p>As it so happens, there's potential to exploit this for efficiency.  The frame mechanics have a slot for each local in the function archetype that currently just holds trash, and it could hold this default value / expression.  So it wouldn't just save on typing the local name and then later the name again and the expression...but you're avoiding the need to perform the evaluation to do the assignment on each call!</p>
<p>There's a lot of questions to answer:</p>
<ul>
<li>
<p>What binding rules is it using?  Could you initialize local3 and then say <strong><code>local4: (local2 * arg1)</code></strong>?</p>
<ul>
<li>Almost certainly not, and it would just be using the binding of the spec block</li>
</ul>
</li>
<li>
<p>Does the code run on each invocation, or is it run only once to calculate a fixed value?  e.g. if it was <strong><code>local4: (global-var * 30)</code></strong> would each invocation of FOO recalculate what <strong><code>(global-var * 30)</code></strong> was at that moment?</p>
<ul>
<li>Almost certainly would just calculate a fixed value and use that value on each call.</li>
</ul>
</li>
<li>
<p>Do you need parentheses directly after the SET-WORD!?</p>
<ul>
<li>
<p>If the expression were run on each invocation (which it probably shouldn't be) then it would be a requirement, because there'd be no way to find the start and the end of the right hand expression without evaluating it.</p>
</li>
<li>
<p>If plain words are being picked up as locals there's potential for error if you accidentally wrote an expression that didn't work, like:</p>
<pre><code>func [
   arg [integer!]
   &lt;local&gt;
   local1 local2
   local3: arity-2-but-I-think-it's-3 a b c
   local4: 10
][
    ...
]
</code></pre>
<p>That could wind up making a local <strong><code>c</code></strong> that you didn't intend.  But then again, sometimes it would be just a very obvious simple initialization, like <strong><code>local4: 10</code></strong>.  Forcing people to use parentheses could do more harm than good, vs. trusting them to use the parentheses if they feel it's warranted.</p>
</li>
</ul>
</li>
</ul>
<h2>
<a name="compare-to-static-not-initialized-with-set-word-atm-1" class="anchor" href="https://forum.rebol.info#compare-to-static-not-initialized-with-set-word-atm-1"></a>Compare to <code>&lt;static&gt;</code>: Not Initialized With SET-WORD! ATM</h2>
<p>Right now the <code>&lt;static&gt;</code> feature lets you assign your variables, but it uses a non-Reboly-notation to do so:</p>
<pre><code>accumulate: func [
    item [any-element?]
    &lt;static&gt;
    block ([])
][
    append block item
]
</code></pre>
<p>The parentheses are optional to hold the initializer.  But  it seems much more normal to say:</p>
<pre><code>accumulate: func [
    item [any-element?]
    &lt;static&gt;
    block: []
][
    append block item
]
</code></pre>
<p>One reason for the parentheses notation was to try and be consistent with the idea of defaulting refinements.</p>
<pre><code>&gt;&gt; foo: func [/string [text!] ("default")] [print string]

&gt;&gt; foo/string "hello"
hello

&gt;&gt; foo
default
</code></pre>
<p>But that feature was removed</p>
<p>There's another reason why just WORD! was used...</p>
<h2>
<a name="return-has-owned-set-word-in-the-spec-dialect-2" class="anchor" href="https://forum.rebol.info#return-has-owned-set-word-in-the-spec-dialect-2"></a>RETURN: Has "Owned" SET-WORD! In The Spec Dialect</h2>
<p>We have a little bit of friction in that the dialect has been using RETURN: to indicate what a function returns.  The choice has not much to do with what comes after a return being an assignment any more than anything else, it was picked for looks:</p>
<pre><code>double-multiply: func [
    return: [integer!]
    value1 [integer!]
    value2 [integer!]
][
    return 2 * value1 * value2
]
</code></pre>
<p>The issue is that historical Rebol2 (and R3-Alpha, and Red) allow this:</p>
<pre><code>rebol2&gt;&gt; print-sum: func [return break] [print ["Sum is" return + break]]

rebol2&gt;&gt; print-sum 10 20
Sum is 30
</code></pre>
<p>Ren-C only lets you do that in LAMBDA.  FUNC prohibits it:</p>
<pre><code>ren-c&gt;&gt; print-sum: func [return break] [print [return + break]]
** Error: Generator provides RETURN:, use LAMBDA if not desired
</code></pre>
<p>I think Red/System decided on RETURN: first.  <a href="https://static.red-lang.org/red-system-specs-light.html#section-3.3">But they put it at the end of the spec.</a>  Red errors if you try to put the return elsewhere:</p>
<pre><code>red&gt;&gt; stringy: func [a b return: [string!]] [a + b]
== func [a b return: [string!]][a + b]

red&gt;&gt; stringy: func [return: [string!] a  b] [a + b]
*** Script Error: invalid function definition: [return: [string!] a b]
</code></pre>
<p>But either way, it's not checked.  On the <a href="https://www.red-lang.org/2012/12/red-v031-functions-support-added.html">2012 announcement of function support in Red</a>, DocKimbel says: <em>"Note: argument and return value type checking have not been implemented yet, they need typeset! and error! datatypes to be implemented first."</em>  Parameter type checking works, but I guess return type checking was never added.  It does show up in the HELP though.</p>
<pre><code>red&gt;&gt; help stringy
USAGE:
     STRINGY a b

DESCRIPTION: 
     STRINGY is a function! value.

ARGUMENTS:
     a             
     b             

RETURNS:
     [string!]
</code></pre>
<p>Note that they also put the RETURNS: at the end there, too.  Most people would expect the return value for functions to be the first thing you put down.</p>
<h2>
<a name="ive-wondered-if-a-leading-block-would-suffice-3" class="anchor" href="https://forum.rebol.info#ive-wondered-if-a-leading-block-would-suffice-3"></a>I've Wondered If A Leading Block Would Suffice...</h2>
<p>Off and on, I've been willing to consider the idea that return typing is just implicitly what you get if you have a leading block:</p>
<pre><code>double-multiply: func [
    [integer!]
    value1 [integer!]
    value2 [integer!]
][
   return 2 * value1 * value2
]
</code></pre>
<p>Yet while it looks clean there, it causes some problems when you are filling in documentation strings.</p>
<p>I've become a pretty true believer in the idea that documentation strings for arguments come after the argument name (and that we may do a service to the userbase by standardizing this, rather than by letting it be done either way and have people fight about it):</p>
<pre><code> my-style: func [
     "Overall function description here"
     argument "Argument description here"
         [integer! text!]
     /refinement "Refinement description here"
 ][
    ...
 ]
</code></pre>
<p>The rationale is that any good function will put labels on all its arguments.  But not all arguments are type-constrained, in particular refinements are not.  So you wind up either being inconsistent</p>
<pre><code> variation1: func [
     "Overall function description here"
     argument [integer! text!]
         "Argument description here"
     /refinement "Refinement description here"  ; this feels inconsistent
 ][
    ...
 ]
</code></pre>
<p>Or you're throwing in newlines for no reason</p>
<pre><code> variation2: func [
     "Overall function description here"
     argument [integer! text!]
         "Argument description here"
     /refinement
         "Refinement description here"  ; consistent, but annoying
 ][
    ...
 ]
</code></pre>
<p>This is why I chose "MY-STYLE" above.  But if return becomes implicit on a leading block, you wind up back in inconsistent land:</p>
<pre><code>my-style-with-leading-block: func [
     "Overall function description here"
     [integer!] "Description here"
     argument "Argument description here"
         [integer! text!]
     /refinement "Refinement description here"
 ][
    ...
 ]
</code></pre>
<p>So one thing RETURN: has historically bought us is making that look better:</p>
<pre><code>my-style-with-leading-block: func [
     "Overall function description here"
     return: "Description here"
         [integer!] 
     argument "Argument description here"
         [integer! text!]
     /refinement "Refinement description here"
 ][
    ...
 ]
</code></pre>
<p>And I think having the word RETURN in there makes it better.  Note how it's less obvious when the word isn't there what that is.</p>
<h2>
<a name="but-set-word-is-that-best-4" class="anchor" href="https://forum.rebol.info#but-set-word-is-that-best-4"></a>But SET-WORD!... is that best?</h2>
<p>If we're going to be allowing SET-WORD! for locals and statics, does it make sense to have a stray SET-WORD! for RETURN?</p>
<p>And one outside-the-box thought... given that modern FUNC doesn't allow you to name parameters RETURN, why not just go with a plain WORD! ?</p>
<pre><code>what-about-plain-word: func [
    "Overall function description here"
    return "Description here"
        [integer!] 
    argument "Argument description here"
        [integer! text!]
    /refinement "Refinement description here"
 ][
    ...
 ]
</code></pre>
<p>If you try that with a LAMBDA you'll not get an error, and maybe suffer some confusion when the lambda gets its first argument as a variable named RETURN.  You'll figure it out pretty quickly, though.</p>
<p>Though I have wondered about questions like "what if you want the behavior of a lambda with the bottom expression dropping out, and no RETURN declared, but you still want type checking?"</p>
<p>You might say "just use ENSURE"</p>
<pre><code> my-lambda: lambda [
    "Overall function description here"
    argument "Argument description here"
        [integer! text!]
    /refinement "Refinement description here"
 ][
    ensure [integer!] [
        ...
    ]
 ]
</code></pre>
<p>The problem is that the return type and any description don't make it to the HELP.  This is one reason that I pretty much always use FUNC.</p>
<p>This makes one want to lean back to the return type being something nameless, like just a leading block.</p>
<h2>
<a name="not-sure-on-return-but-i-like-set-word-locals-5" class="anchor" href="https://forum.rebol.info#not-sure-on-return-but-i-like-set-word-locals-5"></a>Not Sure On RETURN, But I Like SET-WORD! Locals</h2>
<p>I definitely feel that finding a way to not be using SET-WORD! for RETURN: would be good.  It's not like it has anything to do with assignment.</p>
<p>Plain word RETURN in FUNC is not an idea that I'm feeling is as crazy as it might sound.</p>
<p>I do think that I like the idea of SET-WORD! for local initialization... that runs the right hand side without required parentheses, and that only runs the evaluation once in the environment of the spec block... stowing that value in the currently-just-trash slots of the frame archetype for the local.</p>
<p>And I like the idea of bringing <code>&lt;static&gt;</code> on board with the same rules.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/set-word-to-initialize-locals-in-function-specs/2210">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/set-word-to-initialize-locals-in-function-specs/2210</link>
          <pubDate>Sat, 24 Aug 2024 03:00:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2210</guid>
          <source url="https://forum.rebol.info/t/set-word-to-initialize-locals-in-function-specs/2210.rss">SET-WORD! To Initialize Locals In Function Specs?</source>
        </item>
        <item>
          <title>-&gt; for LAMBDA (or... &quot;LAMBDA-Lite?&quot;)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>So I'm still shoring up a new bootstrap executable, patching around in a 6-years-out-of-date codebase.   It's in some ways a cruel and unusual punishment... but in other ways a good trip down memory lane to revisit decisions that were made, and ask "was that the right decision?"</p>
<p>The 6-year-old EXE defined an enfix form of lambda as <strong><code>=&gt;</code></strong>.  I shifted it to the lighter form as <strong><code>-&gt;</code></strong>.  Contrast:</p>
<pre><code>y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then (lambda [x] [
    assert [x = &lt;yes&gt;]
    1000 + 20
])
assert [y = 1020]

y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then x =&gt; [
    assert [x = &lt;yes&gt;]
    1000 + 20
]
assert [y = 1020]

y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then x -&gt; [
    assert [x = &lt;yes&gt;]
    1000 + 20
]
assert [y = 1020]
</code></pre>
<p><em>(Supplemental: Reddit post on <a href="https://www.reddit.com/r/ProgrammingLanguages/comments/shllr3/whats_the_syntax_of_lambda_expressions_in_your/">"What's the syntax of lambda expressions in your language"</a>)</em></p>
<p><strong>I like the <code>-&gt;</code> and don't think there's a greater purpose for it in the box.</strong>  As with everything else, overriding it is a personal choice.</p>
<h2>
<a name="a-speaking-with-ticshttpsforumrebolinfotspeaking-with-tics-should-quoted-arguments-always-be-apostrophed1359-note-1" class="anchor" href="https://forum.rebol.info#a-speaking-with-ticshttpsforumrebolinfotspeaking-with-tics-should-quoted-arguments-always-be-apostrophed1359-note-1"></a>A <a href="https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359">Speaking-With-Tics</a> Note</h2>
<p>Mechanically getting this to work is non-trivial:</p>
<p><a href="https://forum.rebol.info/t/the-most-vexing-evaluation-lambda-meets-then-else/1361" class="inline-onebox">The Most Vexing Evaluation: LAMBDA meets THEN/ELSE</a></p>
<p>Part of what makes it non-trivial is the "literal lookback" by which <strong><code>-&gt;</code></strong> infixedly snatches the X without letting it evaluate.</p>
<p><a class="mention" href="https://forum.rebol.info/u/bradrn">@bradrn</a> might argue such mechanics shouldn't be necessary, because source-level non-evaluation should be explicit, e.g. <strong><code>'x -&gt; [...]</code></strong></p>
<pre><code>y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then 'x -&gt; [
    assert [x = &lt;yes&gt;]
    1000 + 20
]
assert [y = 1020]
</code></pre>
<p>But that's one more stroke of key than I want, and one more piece of dirt than I want to see.  <em>I know from context that slot is a variable name, in the most common case.</em>  I'm not upset by intricate work to faciliate it, if it actually works (and empowers other creative things).  So I need to see hard disproofs before sacrificing what I consider to be "the point" of the design.</p>
<p>I'm always ready to look at it from a further perspective to see a "greater point".  But still--from where I stand--that apostrophe sucks relative to not having it.  (And if you read the details of the implementation post, the only reason it's allowed to work in a quoted slot is because of left literalism, so...)</p>
<h2>
<a name="what-about-multiple-arguments-2" class="anchor" href="https://forum.rebol.info#what-about-multiple-arguments-2"></a>What About Multiple Arguments?</h2>
<p>Notationally there are questions about this form of lambda.  Does it use a block for multiple arguments?</p>
<pre><code>&gt;&gt; foo: [a b] -&gt; [a + b + 20]

&gt;&gt; foo 400 600
== 1020
</code></pre>
<p>It could, but you could be weirder:</p>
<pre><code>foo: a.b -&gt; [a + b + 20]

foo: a/b -&gt; [a + b + 20]
</code></pre>
<p>This would look a little tighter with branching, I think, since it wouldn't compete with the branches:</p>
<pre><code>case [
    ...
] then [a b] -&gt; [
    ...
]

case [
    ...
] then a.b -&gt; [
    ...
]
</code></pre>
<p><em>But wait, you'd never use it with a branch... because a branch only produces one value.</em></p>
<p>UNLESS... what if what this form of lambda did was unpack packs?</p>
<pre><code>case [
    true [pack [10 + 20, 3 + 4]]  ; makes antiform ~['30 '7]~
    ...
] then [a b] -&gt; [
    assert [a = 30, b = 7]
]

case [
    true [pack [10 + 20, 3 + 4]]
    ...
] then a -&gt; [
    assert [a = 30]
]
</code></pre>
<p>So I've been thinking this is what it should actually do.  It means -&gt; won't be a good way to define functions or lambdas generally, but you have FUNC(TION) and LAMBDA for that.</p>
<p>I don't know that enabling a lighter notation like <strong><code>a.b</code></strong> or <strong><code>a/b</code></strong> is worth it.</p>
<pre><code>case [
    true [pack [10 + 20, 3 + 4]]
    ...
] then a.b -&gt; [
    assert [a = 30, b = 7]
]

case [
    true [pack [10 + 20, 3 + 4]]
    ...
] then a/b -&gt; [
    assert [a = 30, b = 7]
]
</code></pre>
<p>Maybe just confusing, and limits what you can put in the spec.  Easier to add later if it seems useful than put it in now and take out later.</p>
<h2>
<a name="is-there-a-good-name-for-lambda-lite-3" class="anchor" href="https://forum.rebol.info#is-there-a-good-name-for-lambda-lite-3"></a>Is There A Good Name For "Lambda Lite"?</h2>
<p>We could call it an "unpacking lambda".  Maybe it's controlled with a refinement:</p>
<pre><code> &gt;&gt; foo: lambda/unpack [a b] [a + b + 20]

 &gt;&gt; foo pack [400 600]
 == 1020
</code></pre>
<p>Then <strong><code>-&gt;: :lambda/unpack</code></strong></p>
<p>We could just call it <em>"an unpacker"</em>.</p>
<pre><code> &gt;&gt; foo: unpacker [a b] [a + b + 20]

 &gt;&gt; foo pack [400 600]
 == 1020
</code></pre>
<p>Then <strong><code>-&gt;: :unpacker</code></strong></p>
<p>The problem with calling it an "unpacker" is that 9 (or more) times out of 10 it will only take a single argument and not unpack anything.  So it seems better to classify it as a shade of distinction on lambda, but still when you point to an <code>-&gt;</code> on the screen say <em>"then it passes the argument to the lambda..."</em></p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/for-lambda-or-lambda-lite/2172">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/for-lambda-or-lambda-lite/2172</link>
          <pubDate>Sun, 10 Mar 2024 15:21:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2172</guid>
          <source url="https://forum.rebol.info/t/for-lambda-or-lambda-lite/2172.rss">-&gt; for LAMBDA (or... &quot;LAMBDA-Lite?&quot;)</source>
        </item>
        <item>
          <title>Rethinking `&lt;static&gt;` in the Function Spec Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>In R3-Alpha, the FUNCTION construct was built on top of FUNC, and added features like statics as a refinement.  It looked pretty awkward, because the static was added at the end of the expression:</p>
<pre><code> r3-alpha&gt;&gt; foo: function/with [x] [return staticvar: add staticvar x] [staticvar: 0]

 r3-alpha&gt;&gt; foo 10
 == 10

 r3-alpha&gt;&gt; foo 20
 == 30
</code></pre>
<p>Ren-C tried extending the function spec dialect to support this in a nicer way:</p>
<pre><code> foo: function [x &lt;static&gt; staticvar (0)] [return staticvar: add staticvar x]
</code></pre>
<p>The low-level FUNC implementation doesn't know what <code>&lt;static&gt;</code> is, so it's added by a higher layer, that makes things slower... and since the function spec dialect is kind of foundational it may be the wrong place to be putting this for the core.</p>
<p><span class="mention">@hiiamboris</span> <a href="https://forum.rebol.info/t/hiiamboriss-with/2138">approaches this differently</a>:</p>
<aside class="quote no-group">
<blockquote>
<h4>create static storage for functions where existing literal forms don't allow you to:</h4>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">factorial: func [x] with [cache: make hash! [0 1]] [
    any [
        select/skip cache x 2
        put cache x x * factorial x - 1
    ]
]
</code></pre>
</blockquote>
</aside>
<p>It's not the first time I've thought it would be a better direction to break it out.  But putting it all as part of the function spec was supposed to have an advantage in that when the body was walked to create the copy, the binding to the static members would be done as well.  This is no longer applicable, because the bodies of functions are largely left unbound...</p>
<p>We do lose a feature of noticing when you are naming the static the same thing as something in your function frame and you don't get an error in that case, but maybe you don't want an error (perhaps you inherited the frame through an adaptation or something like that, and you don't care about the frame variable).</p>
<p>Boris's dialect is a bit overloaded, and Ren-C has more parts to help with that...<a href="https://forum.rebol.info/t/rethinking-braces-as-an-array-type/1727">but it would help even more if there were FENCE!</a></p>
<pre><code>foo: func [x] with [
    {staticvar: 0}
][
    return staticvar: add staticvar x
]

foo: func [x] with {staticvar: 0} [
    return staticvar: add staticvar x
]
</code></pre>
<p>So this wouldn't be confused with any other WITH things you were doing, like trying to use objects or words and add them to a block that already had a binding.</p>
<pre><code>&gt;&gt; body: [keep staticvar: staticvar + x]

&gt;&gt; collect [
       wrapper: func [x] with ['keep {staticvar: 0}] body
       wrapper 1
       wrapper 10
       wrapper 100
   ]
== [1 11 111]
</code></pre>
<p>(Just trying to drum up a little excitement for FENCE! there, but I think it's the tip of the iceberg.)</p>
<p>Anyway, there've been educational lessons from showing that you <em>can</em> extend the FUNC spec dialect and build higher level features... but I think we should probably tear those out of the core and move to something like this.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/rethinking-static-in-the-function-spec-dialect/2139">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rethinking-static-in-the-function-spec-dialect/2139</link>
          <pubDate>Tue, 30 Jan 2024 21:48:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2139</guid>
          <source url="https://forum.rebol.info/t/rethinking-static-in-the-function-spec-dialect/2139.rss">Rethinking `&lt;static&gt;` in the Function Spec Dialect</source>
        </item>
        <item>
          <title>Making FUNC Variant That Auto-Returns Last Result</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>I had offered that people could use this simple wrapper to get the old behavior of FUNC, to drop out its last result (instead of returning nothing):</p>
<pre><code>func: adapt :lib.func [body: compose [return (as group! body)]]
</code></pre>
<p>The concept is that if you write:</p>
<pre><code> foo: func [x] [
     if x &lt; 0 [return x + 10]
     x - 10
 ]
</code></pre>
<p>What you'd actually get would be:</p>
<pre><code> foo: lib.func [x] [
     return (
         if x &lt; 0 [return x + 10]
         x - 10
     )
 ]
</code></pre>
<h2>
<a name="broken-under-new-binding-model-1" class="anchor" href="https://forum.rebol.info#broken-under-new-binding-model-1"></a>Broken Under New Binding Model</h2>
<p>Under the new binding model, an array which is bound will by default hold onto its binding.</p>
<ul>
<li>
<p>The BODY was a BLOCK! that evaluated at the callsite and captured its environment (e.g. to the user context, module context, outer function context, etc.)</p>
</li>
<li>
<p>When you convert it to a GROUP! it will still have that binding.</p>
</li>
<li>
<p>The surgery which is done to inject the frame containing X into the environment will thus apply only at the outermost level.  So the outer block where the return lives would see it, but never make it to the inner group.</p>
<pre><code>func: adapt :lib.func [
    body: compose [
        print ["Here would see the X:" x]
        return (as group! body)  ; &lt;-- inside group will not
    ]
]
</code></pre>
</li>
</ul>
<h2>
<a name="mimicking-funcs-surgery-2" class="anchor" href="https://forum.rebol.info#mimicking-funcs-surgery-2"></a>Mimicking FUNC's Surgery</h2>
<p>One idea would be to use a utility that can do something like what LIB.FUNC did to put the frame onto the proxy body, on the original body.</p>
<p>But awkwardly, you can't do this surgery inside the COMPOSE, because it has to be done once the function is running.  If we call that surgery OVERBIND, one answer would look something like this:</p>
<pre><code>func: adapt :lib.func [
    body: compose [
        return do overbind binding of in [] 'return (body)
    ]
]
</code></pre>
<p><em>(I'll mention that this OVERBIND is not as efficient as what FUNC does, because the frame itself has a pointer to the inherited environment when it's made.  But it only has one slot for that pointer.  So if you try to build a specifier chain with the frame that points to another environment, it has to fabricate a "frame holder" which has its own pointer to put in the chain.)</em></p>
<p>Notice that we only want the frame, here... which we get from the binding of the RETURN.  We don't want to inject awareness of everything in this FUNC adaptation's scope.  So not <strong><code>overbind [] (body)</code></strong>.  If such a thing were even legal to do... body probably has its own copy of lib inherited from another module, and then you've got another module and its lib... we're trying to avoid that kind of conundrum with conservative binding preservation.</p>
<h2>
<a name="another-approach-steal-the-binding-and-unbind-3" class="anchor" href="https://forum.rebol.info#another-approach-steal-the-binding-and-unbind-3"></a>Another Approach: Steal The Binding And Unbind</h2>
<p>Another approach would be to steal the binding off of the body and put it on the composition, then remove the binding from the body:</p>
<pre><code>func: adapt :lib.func [
    body: in body bindable compose [
        return (bindable as group! body)
    ]
]
</code></pre>
<p>You can put the BINDABLE before or after the AS GROUP!.</p>
<p>I actually think this reads less insanely if we just go with UNBIND as being a "tip-unbinding" operation by default, and then have UNBIND/DEEP.  <em>(Maybe UNBIND/SHALLOW for one level of depth?)</em>:</p>
<pre><code>func: adapt :lib.func [
    body: in body unbind compose [
        return (as group! unbind body)
    ]
]
</code></pre>
<p>It's much better to do it this way.  You're doing cheaper operations and doing them at FUNC creation time.</p>
<h2>
<a name="note-that-i-still-hate-implicit-return-4" class="anchor" href="https://forum.rebol.info#note-that-i-still-hate-implicit-return-4"></a>Note That I Still Hate Implicit RETURN</h2>
<p>There's a reason the default FUNC doesn't do it.  If you start doing cool things with RETURN you'll break things in a way that lurks.</p>
<p>Sample cool thing that works today:</p>
<pre><code> foo: func [x y] [
     return: adapt augment :return [arg2] [
         value: meta ((unmeta value) + arg2)  ; return ^VALUE is meta
     ]
     if x &gt; 10 [
         return x y  ; arity 2 return, adds args and returns sum!
    ]
]

&gt;&gt; foo 20 30
== 50

&gt;&gt; foo 5 5
== ~  ; anti
</code></pre>
<p>If anything, I feel like the nothing result isn't going far enough--and it should actually error if you skip out on a return.  Maybe there was some important finalization work to do.</p>
<p>But my example shows that putting it in implicitly means it doesn't necessarily roll with whatever updated definition you give to return.  You'll just get a confusing error in a bit of hidden code.  Not good for a fundamental part.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/making-func-variant-that-auto-returns-last-result/2124">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/making-func-variant-that-auto-returns-last-result/2124</link>
          <pubDate>Thu, 18 Jan 2024 19:23:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2124</guid>
          <source url="https://forum.rebol.info/t/making-func-variant-that-auto-returns-last-result/2124.rss">Making FUNC Variant That Auto-Returns Last Result</source>
        </item>
        <item>
          <title>Custom Function Generator Pitfalls</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>I commonly write function generators that put in some boilerplate to make some variables and service routines available to the generated function.  But these frequently have weaknesses, and I thought I'd write up an example to illustrate...and explain some ways to mitigate the problems.</p>
<h2>
<a name="example-promise-generator-with-resolve-and-reject-1" class="anchor" href="https://forum.rebol.info#example-promise-generator-with-resolve-and-reject-1"></a>Example: PROMISE Generator With RESOLVE and REJECT</h2>
<p>Imagine I want to make a function variation that's like a JavaScript promise, with a RESOLVE and REJECT...which are defined per-promise.</p>
<p>Let's say the first cut of the new generator looks something like this:</p>
<pre><code>promise: func [spec body] [
    body: compose [
        let resolve: lambda [result] [  ; lambdas lack their own return
            some code here
            return whatever  ; intending return of generated FUNC
        ]
        let reject: lambda [error] [
            more code here
            return whatever
        ]
        (spread body)  ; code here should see RESOLVE and REJECT 
    ]
    return func spec body
]
</code></pre>
<p>When the frame is created for the new function, it will run this body that's been extended with some boilerplate.  But that frame's arguments could have the name of any of the functions you're using in the bodies of RESOLVE or REJECT.  e.g. what if I said <strong><code>foo: promise [code /more] [...]</code></strong> ... the implementations of RESOLVE and REJECT would be disrupted from what they thought the words they had used meant.</p>
<p>Once you notice this, you might think the solution is to pre-compute more things:</p>
<pre><code>promise: func [spec body] [
    body: compose [
        let resolve: ^(lambda [result] [
            some code here
            return whatever
        ])
        let reject: ^(lambda [error] [
            more code here
            return whatever
        ])
        (spread body)  ; code here should see RESOLVE and REJECT 
    ]
    return func spec body
]
</code></pre>
<p><em>(Note use of ^META group in order to turn the isotopic frame produced by FUNC into a quasi frame, so that under evaluation in the function body it becomes isotopic again.  The compose would fail if you tried to compose the isotopic frame in directly.)</em></p>
<p>That's a bit better in terms of insulating the boilerplate code from stray bindings coming from the user-supplied spec (though there's still the weakness of LET if the user wrote something like <strong>promise [let [integer!]] [...]</strong>, which if you cared you could address by composing :LET in as its literal function value).</p>
<p>But it does too good a job: the COMPOSE runs during the PROMISE fabrication time, and so the notion of RETURN used by RESOLVE and REJECT are is the return for the PROMISE generator itself... not the produced FUNC as intended.  This is true of anything else you need to have picked up from the instance (let's say REJECT was implemented in terms of RESOLVE, or needed some other local).</p>
<p>One way of addressing this would be to slip the instance RETURN in as a parameter, e.g. via specialization of the precomputed code:</p>
<pre><code>promise: func [spec body] [
    body: compose [
        let resolve: specialize ^(lambda [result ret] [
            some code here
            ret whatever
        ]) [ret: :return]
        let reject: specialize ^(lambda [error ret] [
            more code here
            ret whatever
        ]) [ret: :return]
        (spread body)  ; code here should see RESOLVE and REJECT 
    ]
    return func spec body
]
</code></pre>
<p>There you've got an added assumed term which can break things, e.g. <strong><code>promise [let [integer!] specialize [block!]] [...]</code></strong> or similar.  But at least <strong>some code here</strong> and <strong>more code here</strong> are running under the understandings that the PROMISE generator author had of what those implementations meant.</p>
<p>Once you've separated out that which can be precomputed vs. that which can't, there's no need to make the precomputed part every time:</p>
<pre><code>promise-resolve*: lambda [result ret] [
    some code here
    ret whatever
]

promise-reject*: lambda [error ret] [
    more code here
    ret whatever
]

promise: func [spec body] [
    body: compose [
        let resolve: specialize :promise-resolve* [ret: :return]
        let reject: specialize :promise-reject* [ret: :return]
        (spread body) 
    ]
    return func spec body
]
</code></pre>
<h2>
<a name="could-some-kind-of-compile-operation-help-2" class="anchor" href="https://forum.rebol.info#could-some-kind-of-compile-operation-help-2"></a>Could Some Kind of COMPILE Operation Help?</h2>
<p>Weaknesses due to redefinitions of things like LET and SPECIALIZE makes me wonder if situations like this could be helped by an operation that would replace words that look up to functions with references to the functions.  <a href="https://forum.rebol.info/t/more-comprehensible-errors-with-per-cell-labeling/1357">The cell can retain the symbol for the word</a>, which can make debugging and errors more tolerable.</p>
<pre><code>promise: func [spec body] [
    body: compose (compile [let specialize] [
        let resolve: specialize :promise-resolve* [ret: :return]
        let reject: specialize :promise-reject* [ret: :return]
        (spread body) 
    ])
    return func spec body
]
</code></pre>
<p>Merging with COMPOSE would be more efficient, and could help cue that you want to avoid compiling the things in GROUP!s.  Maybe it could assume you wanted to compile references to actions unless you threw in some kind of escaping:</p>
<pre><code>promise: func [spec body] [
    body: compile [
        let resolve: specialize :promise-resolve* [ret: $ :return]
        let reject: specialize :promise-reject* [ret: $ :return]
        (spread body) 
    ]
    return func spec body
]
</code></pre>
<p>I've thought about this kind of thing for a while, but never got around to writing it.</p>
<h2>
<a name="paranoia-plus-efficiency-body-as-group-vs-spliced-3" class="anchor" href="https://forum.rebol.info#paranoia-plus-efficiency-body-as-group-vs-spliced-3"></a>Paranoia Plus Efficiency: Body As GROUP! vs. Spliced</h2>
<p>One improvement to this code is to splice the body as a group instead of spreading it itemwise in a block.</p>
<p>To see why this matters, consider something like:</p>
<pre><code>func-with-a-as-one: func [spec body] [
    return func spec compose [
        let a: 1
        (spread body)
    ]
]
</code></pre>
<p>Now let's say someone wrote:</p>
<pre><code>&gt;&gt; test: func-with-a-as-one [x] [+ 9, return a + x]

&gt;&gt; test 1000
== 1010  ; not 1001
</code></pre>
<p>Accidentally or intentionally, the function was defined as:</p>
<pre><code>func [x] [
   let a: 1
   + 9, return a + x
]
</code></pre>
<p>You can avoid this by quarantining the body, using <strong>(as group! body)</strong> instead of <strong>(spread body)</strong> in the COMPOSE.</p>
<pre><code>func [x] [
   let a: 1
   (+ 9, return a + x)
]
</code></pre>
<p>As an added benefit, the AS alias is cheaper memory-wise than copying the elements in item-wise (though it adds one extra GROUP! evaluation step to the function).</p>
<h2>
<a name="another-loophole-what-if-resolvereject-are-args-4" class="anchor" href="https://forum.rebol.info#another-loophole-what-if-resolvereject-are-args-4"></a>Another Loophole: What If RESOLVE/REJECT Are Args?</h2>
<p>If you use LET, currently that will override whatever definition is in play.  So if someone were to write <strong>promise [x y reject] [...]</strong> they'd not be able to see the REJECT argument, and wouldn't get an error.</p>
<p>You can force an error by dropping the LETs, and expanding the specification to include <strong></strong> definitions.</p>
<pre><code>promise: func [spec body] [
    body: compile [
        resolve: specialize :promise-resolve* [ret: $ :return]
        reject: specialize :promise-reject* [ret: $ :return]
        (as group! body) 
    ]
    return func compose [(spread spec) &lt;local&gt; resolve reject] body
]
</code></pre>
<p>So that's just sort of a peek into the effort it would take to make a relatively hygienic function generator.  Some things like worrying about taking SPECIALIZE as an argument might be beyond the concerns of the average one-off task.  But if you write a bunch of indiscriminate boilerplate using arbitrary words to refer to functions, it's very easy to get bitten when an argument reuses those words.</p>
            <p><small>15 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/custom-function-generator-pitfalls/2093</link>
          <pubDate>Sat, 06 Jan 2024 11:29:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2093</guid>
          <source url="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093.rss">Custom Function Generator Pitfalls</source>
        </item>
        <item>
          <title>Tail Calls in Ren-C...Yes, We Have Them</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Looking into some of <a href="https://forum.rebol.info/t/the-sherman-rebol-to-scheme-compiler/2076">Joe Marshall's historical participation in Rebol</a>, he speaks about Rebol 1.0 having "continuations" and "tail calls".</p>
<p>Ren-C uses continuations to implement <a href="https://forum.rebol.info/t/stackless-is-here-today-now/1844">stacklessness, based on a trampoline</a>.  Trampolines are generally slower than the fiddly technique Joe describes Rebol 1.0 as having used--but such fiddly methods are not standard C, and do not translate well to WebAssembly.  In any case, the outcomes are similar.</p>
<p>Tail calls are a different feature.  But if you have continuations, then your code is likely structured in such a way that tail calls are not that difficult to add.</p>
<h2>
<a name="so-what-is-a-tail-call-1" class="anchor" href="https://forum.rebol.info#so-what-is-a-tail-call-1"></a>So What Is A Tail Call?</h2>
<p>When you invoke a function, the interpreter has to allocate some space for its arguments and locals.  This information is then associated with a stack level structure, which also takes some space... and is put in a chain representing the call stack.</p>
<p>If that function calls itself recursively, the recursion will also need new stack space for its arguments and locals...and another stack level structure.</p>
<p>With recursive algorithms where a function calls itself hundreds or thousands of times, you can use up a lot of memory (and/or generate a stack overflow).</p>
<p>Tail calls are based on the observation that right at the moment a function is about to return, it doesn't need its stack level or arguments/locals anymore.  So if you're willing to have your call stack suffer some amount of "amnesia" about the "real" stack depth, you can reuse the current call's stack level for a recursion.</p>
<h2>
<a name="ren-c-supports-explicit-tail-calls-with-returnrun-2" class="anchor" href="https://forum.rebol.info#ren-c-supports-explicit-tail-calls-with-returnrun-2"></a>Ren-C Supports Explicit Tail Calls With RETURN/RUN</h2>
<p>There are two forms of tail call we can do in a Rebol-like interpreter.  The first style can call any function (not just the one you're returning from).  It avoids a recursion level on the stack, but does <em>not</em> reuse the memory for arguments and locals.</p>
<p>This is what that looks like:</p>
<pre><code>foo: func [return: [tag!] n] [
    if n = 1 [
        return &lt;success&gt;
    ]
    return/run :foo n - 1
]

&gt;&gt; foo 100
== &lt;success&gt;
</code></pre>
<p>That triggers 100 calls to FOO, but only using one level of stack depth.</p>
<p>There's a fairly obvious technical reason why this variation cannot build the invocation for the recursion's N into the old stack frame's N argument... <em>it uses the old N (as <code>n - 1</code>) to calculate the new N</em>.  You can't calculate new parameters into old parameter slots without winding up referencing your intermediate calculations instead of the old values you wanted.</p>
<p><em>(A compiled language could notice when old arguments were used to calculate new ones, and if it happened they could make space for temporary copies just for values that would be overwritten before they were seen...but being interpreted, we have to assume the worst and keep all the old values.)</em></p>
<p>If you really want to avoid making a new stack level <em>and</em> reuse the memory for the args and locals, you need a different approach.  Mutate the variables in-place before jumping to a restart of the function:</p>
<pre><code>foo: func [return: [tag!] n] [
    if n = 1 [
        return &lt;success&gt;
    ]
    n: n - 1
    return/run @redo
]

&gt;&gt; foo 100
== &lt;success&gt;
</code></pre>
<p>Modifying the variables in place means you're responsible for any dependency issues.  If you overwrite one of your arguments while calculating the next, you wrote the code in sequence and you can see what you did.</p>
<h2>
<a name="why-returnrun-foo-vs-return-foo-or-rerun-foo-3" class="anchor" href="https://forum.rebol.info#why-returnrun-foo-vs-return-foo-or-rerun-foo-3"></a>Why RETURN/RUN :FOO vs. RETURN FOO or RERUN FOO</h2>
<p>Ren-C's RETURN construct has special knowledge of what function it returns from.  It is a specialization of a generic DEFINITIONAL-RETURN function, which is specialized with the target FRAME!.  It's done in a somewhat optimized way, but still has some cost.</p>
<p>If tail calls were done with another construct--e.g. something like RERUN--that function would also need to be specialized with this knowledge.  It's cheaper to just piggy back on what RETURN already knows and make it a refinement.</p>
<p>As for why it has to take a GET-WORD! vs. plain WORD! for the function to invoke...this is due to RETURN not taking its first argument quoted.  So it's too late to intercept the mechanics of the call once an evaluation is run.  RETURN would receive the product of the call.</p>
<p>It winds up looking fairly natural, because the RUN construct runs a function that gathers its arguments inline:</p>
<pre><code>&gt;&gt; run :append [a b c] [d e]
== [a b c [d e]]
</code></pre>
<p><strong>Note that even if we could make tail calls implicit, we probably wouldn't want to.</strong>  Python hasn't added tail calls at all, based on a philosophical objection to the idea of obscuring the call stack.  It also seems like if an algorithm depends on tail calls for some important optimization reason, there should be something to indicate that fact... so that someone reorganizing the code will be sensitive to it.</p>
<h2>
<a name="how-important-are-tail-calls-4" class="anchor" href="https://forum.rebol.info#how-important-are-tail-calls-4"></a>How Important Are Tail Calls?</h2>
<p>If your language has a very limited amount of stack, being able to formulate your code to use tail calls so it doesn't accrue stack could be very important.</p>
<p>But if your language has a decent amount of stack (or is completely "stackless") it's not particularly important.</p>
<p>Where it matters are cases where an algorithm can be cleanly expressed in a recursive way, and you don't want to use an uglier representation that builds data structures which are mimicking what you would be getting naturally from the stack.</p>
<p>Using them in places that don't matter is likely just going to confuse your stack traces and error messages...like the Python people say.  I'd discourage going around and changing all your RETURN SOMETHING to RETURN/RUN :SOMETHING to try and speed things up.  Only do it if you're writing an algorithm that would have pathological stack use otherwise.</p>
<h2>
<a name="returnrun-had-a-precursor-redo-5" class="anchor" href="https://forum.rebol.info#returnrun-had-a-precursor-redo-5"></a>RETURN/RUN Had A Precursor... REDO</h2>
<p>The original formulation of tail calls wasn't built into RETURN, but expected you to work with a more generic tool called REDO.  This is what you had to write for the FOO example:</p>
<pre><code>foo: func [return: [tag!] n] [
    frame: binding of 'n
    if n = 0 [
        return &lt;success&gt;
    ]
    n: n - 1
    redo frame
]
</code></pre>
<p>This corresponds to the <strong><code>return/run @redo</code></strong> case, which takes advantage of the fact that RETURN already knows the frame it returns to, and can use that to redo.</p>
<p>But REDO had a shorthand for this case, which was to accept a word from a frame:</p>
<pre><code>foo: func [return: [tag!] n] [
    if n = 0 [
        return &lt;success&gt;
    ]
    n: n - 1
    redo 'n
]
</code></pre>
<p>This had led me to say <em>"sure, Ren-C has tail calls"</em>.  But I realized that didn't really look like what people would expect, so I made RETURN/RUN.</p>
<p>An added benefit of RETURN/RUN is that if you use it with the function call form (instead of <code>@redo</code>) then it offers something that REDO couldn't do, which is reuse an internal level structure for an arbitrary new function call.  It wasn't actually that hard to implement, so I went ahead and did it.</p>
<p>REDO is still around.  It can restart <em>any</em> frame or phase, and it's actually rather powerful.  I don't really use it, but here's an example of how tricky it can be:</p>
<pre><code>base: func [return: [text!] n delta /captured-frame [frame!]] [
    log [{BASE} n delta]

    n: n - delta
    if n &lt; 0 [return "base less than zero"]
    if n = 0 [return "base done"]
    if captured-frame [redo captured-frame]
    return "base got no frame"
]

c: chain [
    adapt :base [
       log [{C} n delta]

       captured-frame: binding of 'n
       redo/sibling 'n :s

       comment {fall through to base}
    ]
    lambda [x] [
        if x = "base done" [
            &lt;success&gt;
        ] else [
            spaced ["base exited with" x]
        ]
    ]
]

s: specialize adapt :base [
    log [{S} n delta]

    if n = 1 [n: 10]
][
    delta: 10
]

&gt;&gt; c 11 0
== &lt;success&gt;
</code></pre>
<p>With a logging function attached, that gives:</p>
<pre><code> --- C ---
 n: =&gt; 11
 delta: =&gt; 0
 --- S ---
 n: =&gt; 11
 delta: =&gt; 10
 --- BASE ---
 n: =&gt; 11
 delta: =&gt; 10
 --- C ---
 n: =&gt; 1
 delta: =&gt; 10
 --- S ---
 n: =&gt; 1
 delta: =&gt; 10
 --- BASE ---
 n: =&gt; 10
 delta: =&gt; 10
</code></pre>
<ul>
<li>
<p>C is called and captures its frame into F.  Then it uses REDO/SIBLING to reuse the frame to call S.  S gets the variables and args that it knows about as C left them--such as N and a captured frame F--but values it takes for granted are reset, which includes specialized delta of 10.</p>
<p><em>(The need to reset specializations for consistency is similar to how locals must be reset--they're not part of the interface of the function, so to reach beneath them does something illegal in terms of parameterization.)</em></p>
</li>
<li>
<p>S doesn't have any effect besides resetting delta, so it falls through as an adaptation to the base function.  BASE subtracts DELTA from N to get 1, which isn't an exit condition.  The F frame which was set in C and was preserved as an argument to S is then used by BASE to REDO and get back up to the start of C again.</p>
</li>
<li>
<p>Once again C captures its frame and does a REDO to start up S, which now notices that N is 1 so it bumps it up to 10.  (It cannot set DELTA to 1, because as a specialized argument DELTA is not visible to it.)  This time when it falls through to BASE, the subtraction of DELTA from N yields zero so that BASE returns completion.</p>
</li>
<li>
<p>Since the function we originally called and built a frame for was a CHAIN, the REDO is effectively REDO-finishing the frame for the adaptation of BASE that sits at the head of the frame.  That delegation has now finished bouncing around on that single frame and come to a completion, which means the chained functions will get that result.  The string is translated to a tag and signals success.</p>
</li>
</ul>
<h2>
<a name="all-pretty-crazy-stuff-you-probably-wont-use-6" class="anchor" href="https://forum.rebol.info#all-pretty-crazy-stuff-you-probably-wont-use-6"></a>All Pretty Crazy Stuff You Probably Won't Use</h2>
<p><img src="https://forum.rebol.info/images/emoji/twitter/crazy_face.png?v=12" title=":crazy_face:" class="emoji only-emoji" alt=":crazy_face:" loading="lazy" width="20" height="20"></p>
<p>But it's there, to placate people who think a language has to have tail calls to get respect.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/tail-calls-in-ren-c-yes-we-have-them/2082">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/tail-calls-in-ren-c-yes-we-have-them/2082</link>
          <pubDate>Mon, 18 Dec 2023 03:58:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2082</guid>
          <source url="https://forum.rebol.info/t/tail-calls-in-ren-c-yes-we-have-them/2082.rss">Tail Calls in Ren-C...Yes, We Have Them</source>
        </item>
        <item>
          <title>Dialect Meaning of Non-Words in Function Parameter Spec Blocks</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Historical Redbol only had WORD!s in the BLOCK! that came after a parameter:</p>
<pre><code>foo: func [
    arg [block! word! number!]  ;  all words in block
] ...
</code></pre>
<p>But when Ren-C introduced the paradigm-breaking NULL that could not be put in arrays, that meant there was no <code>null!</code> datatype.  To fill the gap, the tag <code>&lt;opt&gt;</code> was chosen to indicate the parameter as optional--hence possibly null:</p>
<pre><code>foo: func [
    arg [&lt;opt&gt; block! word! number!]  ;  now it's WORD!s and TAG!s
] ...
</code></pre>
<p>I liked using a TAG! for how it stood out (though in retrospect I'd have probably chosen <code>&lt;null&gt;</code>, but everything was named differently then).  Other quirky ideas were floated, like being able to put a leading slash on the typeset block:</p>
<pre><code>foo: func [
    arg /[block! word! number!]  ; like a refinement, but on the types
] ...
</code></pre>
<p>That didn't gain traction, and probably shouldn't have.</p>
<p>Then when early efforts faced another value state that couldn't be put in a block and didn't have a type, <strong><code>&lt;void&gt;</code></strong> came onto the scene...because as with there being no NULL!, there was no VOID! datatype.</p>
<h2>
<a name="tag-modifiers-which-werent-type-checkers-showed-up-1" class="anchor" href="https://forum.rebol.info#tag-modifiers-which-werent-type-checkers-showed-up-1"></a>Tag Modifiers Which Weren't Type Checkers Showed Up</h2>
<p>The ability to take a parameter but get an immutable view of it was added as <strong><code>&lt;const&gt;</code></strong>.</p>
<p>Parameters that would accept being at the end of input and evaluate to null in that case were <strong><code>&lt;end&gt;</code></strong></p>
<p><strong><code>&lt;variadic&gt;</code></strong> and <strong><code>&lt;skippable&gt;</code></strong> came into existence.</p>
<p>These "parameter-control tags" seemed to me to be a distinct category from typecheckers like <strong><code>&lt;opt&gt;</code></strong> and <strong><code>&lt;void&gt;</code></strong>.   Having them all use TAG! felt like <em>too many tags.</em></p>
<p>So I mused about splitting the roles, something like:</p>
<pre><code>[&lt;const&gt; #null type!]
-or-
[#const &lt;null&gt; type!]
</code></pre>
<p>But I didn't like the look of it enough to move on it.  So things like <strong><code>[&lt;const&gt; &lt;opt&gt; type!]</code></strong> stuck around while I wondered about it.</p>
<h2>
<a name="today-you-can-specify-any-type-check-by-function-2" class="anchor" href="https://forum.rebol.info#today-you-can-specify-any-type-check-by-function-2"></a>Today, You Can Specify Any Type Check By Function</h2>
<p>There's still no NULL! or VOID!.  But with the way things work now, you can use functions as "type predicates" to recognize things that aren't datatypes in their own right:</p>
<pre><code>foo: func [
    arg [null? block! word! number!]
] ...
</code></pre>
<p>What's good:</p>
<ul>
<li>It leaves TAG! for the properties like <strong><code>&lt;const&gt;</code></strong> that don't have to do with type recognition... but rather controlling the parameter in a more special way.</li>
</ul>
<p>What's bad:</p>
<ul>
<li>It loses that kind of special look that tags gave to arguments that could take null.  It blurs together, especially with things like SPLICE? and LOGIC? and CHAR? for other non-fundamental datatypes (characters are just single-character issues now, and ~true~ and ~false~ isotopes of WORD! implement logic)</li>
</ul>
<h2>
<a name="a-modern-option-null-for-taking-null-3" class="anchor" href="https://forum.rebol.info#a-modern-option-null-for-taking-null-3"></a>A Modern Option: ~NULL~ for Taking Null</h2>
<p>I made an experiment so if you used a QUASI-WORD!, then it would match an isotope of that form.</p>
<p>It's a kind of pleasingly distinct look:</p>
<pre><code>foo: func [
    arg [~null~ block! word! number!]
] ...
</code></pre>
<p>And it mixes better with the tags:</p>
<pre><code>foo: func [
    arg [~null~ &lt;const&gt; block! word! number!]
] ...
</code></pre>
<p>It also works for "nothing" (isotopic blank) and doesn't look too bad there, e.g. for RETURN:</p>
<pre><code>foo: func [
    return: [~]  ; as opposed to `return: [nothing?]`
 ] ...
</code></pre>
<h2>
<a name="allowing-null-and-null-as-choices-seems-good-4" class="anchor" href="https://forum.rebol.info#allowing-null-and-null-as-choices-seems-good-4"></a>Allowing NULL? and ~NULL~ As Choices Seems Good</h2>
<p>I like the option of <strong>~null~</strong> instead of <strong>null?</strong> to call out the more rare-and-alarming idea of accepting null parameters.</p>
<h2>
<a name="what-about-return-nihil-and-return-nothing-5" class="anchor" href="https://forum.rebol.info#what-about-return-nihil-and-return-nothing-5"></a>What about <code>return: &lt;nihil&gt;</code> and <code>return: &lt;nothing&gt;</code>
</h2>
<p>These two special uses of tag! with no block have been used to say you don't need a RETURN statement at all... the function just gives back none or nihil respectively when the body completes.</p>
<p>How necessary is it?  Well, you either write things like:</p>
<pre><code>comment: func [
    return: [nihil?]
    discarded [any-value!]
][
    return nihil
]
</code></pre>
<p>Or you have the contraction:</p>
<pre><code>comment: func [
    return: &lt;nihil&gt;
    discarded [any-value!]
][
]
</code></pre>
<p>This style of "don't even worry about writing a RETURN" has the widest applicability to NOTHING and NIHIL.  We don't strictly need it, but I've gotten used to it.</p>
<p>I mention <strong>return: [~]</strong> as a possible alternative for saying nothing is a return type using the quasiform-means-isotope idea.  And since nothing falls out of function bodies by default with no return, it's not strictly necessary to have <strong><code>return: &lt;nothing&gt;</code></strong> as any kind of special operation.</p>
<p>Again, how does that look?</p>
<pre><code>foo: func [
    return: [~]
 ] ...
</code></pre>
<p>A little more symbol-y, but doesn't break the rhythm of type specs being blocks.</p>
<p>This leaves the nihil case.  We could say <strong>return: [~[]~]</strong> and have that mean "I return an empty pack" but in that case you'd still need an explicit return:</p>
<pre><code>comment: func [
    return: [~[]~]
    discarded [any-value!]
][
    return nihil
]
</code></pre>
<p>But I think I like <strong><code>return: [nihil?]</code></strong> better than that.  Compared to <strong><code>return: [~]</code></strong> the <strong><code>[~[]~]</code></strong> feels a bit like a bridge too far.  But I might change my mind.</p>
<p>Anyway, the reason this is a struggle is that <strong><code>return: &lt;nothing&gt;</code></strong> has just become so pervasive that it's hard to see that changed to <strong><code>return: [nothing?]</code></strong>.  But standardizing on blocks and moving away from the tags for this application may be the best idea.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/dialect-meaning-of-non-words-in-function-parameter-spec-blocks/2064">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dialect-meaning-of-non-words-in-function-parameter-spec-blocks/2064</link>
          <pubDate>Sat, 25 Nov 2023 08:25:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2064</guid>
          <source url="https://forum.rebol.info/t/dialect-meaning-of-non-words-in-function-parameter-spec-blocks/2064.rss">Dialect Meaning of Non-Words in Function Parameter Spec Blocks</source>
        </item>
        <item>
          <title>About the Functions category</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Discussions of Functions and Generators, e.g. how things like RETURN work... or the mechanics of generators and composers like ADAPT, SPECIALIZE, ENCLOSE, HIJACK, etc.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/about-the-functions-category/1931">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/about-the-functions-category/1931</link>
          <pubDate>Sat, 20 Aug 2022 07:39:08 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1931</guid>
          <source url="https://forum.rebol.info/t/about-the-functions-category/1931.rss">About the Functions category</source>
        </item>
        <item>
          <title>Why RETURN Is Not Assignable on Function Interfaces</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>When implementing multi-returns I had an idea, to think of <strong><code>[x]: negate 10</code></strong> in terms of slipping X into the RETURN: slot of NEGATE as an input.</p>
<p>On the surface that seems like it might even be useful more generally:</p>
<pre><code> &gt;&gt; f: make frame! :negate

 &gt;&gt; negate.return: 'x  ; X gets hidden, and RETURN is redefined during the call

 &gt;&gt; negate.value: 10

 &gt;&gt; do f  ; the hidden X is written back automatically
 == -10

 &gt;&gt; x
 == -10
</code></pre>
<h2>
<a name="but-not-every-action-is-a-funcfunction-1" class="anchor" href="https://forum.rebol.info#but-not-every-action-is-a-funcfunction-1"></a>But Not Every Action is a FUNC/FUNCTION</h2>
<p>Not all functions are guaranteed to have something in their frame called RETURN (e.g. a LAMBDA does not).  And a non-FUNC ACTION! could have something in its frame called RETURN that wasn't used for anything pertaining to the return process.</p>
<p>This ruled it out from being a mechanic relied on by the multi-return machinery.  Because we want the following to work:</p>
<pre><code>&gt;&gt; test: lambda [x] [x + 20]

&gt;&gt; [y]: test 1000
== 1020

&gt;&gt; y
== 1020
</code></pre>
<h2>
<a name="nevertheless-people-can-implement-it-if-they-want-2" class="anchor" href="https://forum.rebol.info#nevertheless-people-can-implement-it-if-they-want-2"></a>Nevertheless, People Can Implement It If They Want</h2>
<p>It's certainly something you could <em>choose</em> to do if you were writing your own function generator.</p>
<p>In fact, it's trivial to write a wrapper for it!  Just add a /RETURN to the public interface, and write back to it if it's supplied:</p>
<pre><code>returnproxy: lambda [action [action!]] [
    enclose (augment :action [/return [word!]]) f -&gt; [
        (maybe f.return): do f
    ]
]
</code></pre>
<p>That means you can pass it as a refinement:</p>
<pre><code>&gt;&gt; test: lambda [x] [x + 1000]

&gt;&gt; wrapper: returnproxy :test

&gt;&gt; wrapper/return 20 'y
== 1020

&gt;&gt; y
== 1020
</code></pre>
<p>Or you can use it with a frame:</p>
<pre><code>&gt;&gt; f: make frame! :wrapper
&gt;&gt; f.x: 20
&gt;&gt; f.return: 'out

&gt;&gt; do f
== 1020

&gt;&gt; out
== 1020
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/nut_and_bolt.png?v=12" title=":nut_and_bolt:" class="emoji only-emoji" alt=":nut_and_bolt:" loading="lazy" width="20" height="20"></p>
<p><em>(Seeing superpowers like this work so clearly and obviously is what keeps me invested in this.)</em></p>
<h2>
<a name="so-anyone-can-do-it-but-should-funcfunction-do-it-3" class="anchor" href="https://forum.rebol.info#so-anyone-can-do-it-but-should-funcfunction-do-it-3"></a>So Anyone CAN Do It, But Should FUNC/FUNCTION Do It?</h2>
<p>I lean toward not doing it with things implemented the way they are right now, because it would add overhead to every function with a RETURN:, due to needing to have a place to store the variable if you gave it one.</p>
<p>But it might be nice to give people an optimized version of the proxying wrapper above.  You could then convert any function to support it.</p>
<h2>
<a name="but-today-return-is-on-the-public-interface-of-func-frowning-4" class="anchor" href="https://forum.rebol.info#but-today-return-is-on-the-public-interface-of-func-frowning-4"></a>But today RETURN is on the public interface of FUNC <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=12" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20">
</h2>
<pre><code>&gt;&gt; f: make frame! func [x] [return x + 1000]
== make frame! [
    return: ~
    x: ~
]
</code></pre>
<p><em>"Errr.  Why's it there?"</em>, you might ask.</p>
<p>The reason is that the return typeset information currently lives on that field.  So if you're going to ask about it, you get it from there.</p>
<p><strong>This is one of many good arguments for why this information should <em>not</em> live there.</strong></p>
<p>There's a long running body of evidence suggesting that the way return types are managed today is probably wrong.</p>
<ul>
<li>
<p><strong>LAMBDA Can't Currently Document Its Result Types</strong>.  There are a lot of actions out there that don't have a RETURN function, but nevertheless have something to say about what types they can produce.</p>
</li>
<li>
<p><strong>ENCLOSE Can't Change The Type Signature</strong>.  If you wrap a function, you're subject to its type checking rules.</p>
</li>
<li>
<p><strong>NATIVE Doesn't Want To Pay For A RETURN Slot</strong>.  The typechecking is only done in the debug build, so why should every native frame require a RETURN function?</p>
</li>
</ul>
<p>I think I've got some ideas coming together--mostly centering on factoring out typechecking to be another one of the little pieces you can build functions out of (like AUGMENT).  So when doing a composition you would just bolt on a typechecker if you wanted one.  Internal efficiencies could fold that in so it actually didn't generate a separate phase and action identity.  Pursing some inspiration on that as we speak...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/why-return-is-not-assignable-on-function-interfaces/1929">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/why-return-is-not-assignable-on-function-interfaces/1929</link>
          <pubDate>Sat, 20 Aug 2022 05:32:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1929</guid>
          <source url="https://forum.rebol.info/t/why-return-is-not-assignable-on-function-interfaces/1929.rss">Why RETURN Is Not Assignable on Function Interfaces</source>
        </item>
        <item>
          <title>How To Indicate &quot;Divergence&quot; in Function RETURN: Spec</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Today's vocabulary word is <strong><a href="https://en.wikipedia.org/wiki/Divergence_(computer_science)">"divergent"</a></strong> ... a description for when a function never returns a result in a "normal" way.</p>
<p>All functions that can FAIL or be THROWN or RETURN'd across have divergence as an <em>option</em> (which is, right now, all functions).  But it becomes an issue of what to say when there really is no type a function <em>ever</em> returns...what do you put in the spec?</p>
<p>Lately I've been using just <strong><code>[return: []]</code></strong>.  That seems pretty solid.  An empty block indicating there's no types you can return...so any return would generate an error.</p>
<p>But because I can imagine people not knowing what that meant, I find myself always adding a comment so people can look up the term "divergent":</p>
<pre><code>catch [
    my-non-returning-function: func [
        return: []  ; divergent
    ][
        if now/month = 8 [
            return "It's August"  ; oops, meant THROW (so causes error)
        ]
        throw "It's not August"
    ]
    my-non-returning-function
]
</code></pre>
<p>My tendency to hedge is probably silly.  Because <strong><code>return: []</code></strong>  is pretty straightforward.  The comment probably makes it <em>more</em> confusing.</p>
<p>So <strong><code>return: &lt;divergent&gt;</code></strong> (or whatever) is probably not worth it.</p>
<p><em>(I should point out that it hasn't always been as clear that <strong><code>return: []</code></strong> wouldn't mean something like "the function is invisible" or "the function returns trash".  But we have good clear ways of saying those things, so I like this for divergence.)</em></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/how-to-indicate-divergence-in-function-return-spec/1667">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-to-indicate-divergence-in-function-return-spec/1667</link>
          <pubDate>Mon, 16 Aug 2021 02:35:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1667</guid>
          <source url="https://forum.rebol.info/t/how-to-indicate-divergence-in-function-return-spec/1667.rss">How To Indicate &quot;Divergence&quot; in Function RETURN: Spec</source>
        </item>
        <item>
          <title>Implicit Execution of RETURN in functions = ...BAD (?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Let's say you write something like this:</p>
<pre><code>foo: func [
    return: [integer!]
    arg [integer! text! tag!]
][
    if integer? arg [
        return arg + 1000
    ]
    if text? arg [
        return reverse arg
    ]
    arg
]
</code></pre>
<p>I imagine you'd expect behavior along these lines:</p>
<pre><code>&gt;&gt; foo 20
== 1020

&gt;&gt; foo "whoops"
** Error: FOO doesn't have RETURN enabled for values of type TEXT!

&gt;&gt; foo &lt;bomb&gt;
** Error: FOO doesn't have RETURN enabled for values of type TAG!
</code></pre>
<p>Even though the last value just "falls out" of the function, you presumably don't want that to mean it escapes type checking just because it did.</p>
<h2>
<a name="mechanically-this-is-non-obvious-1" class="anchor" href="https://forum.rebol.info#mechanically-this-is-non-obvious-1"></a>Mechanically, this is Non-Obvious...</h2>
<p>RETURN is not actually supposed to be a "language feature" per se.  It's actually a feature of the higher-level generator FUNC...and there are lower-level ways of building functions that lack RETURNs.  <em>(If there weren't, how could you write the RETURN function itself?)</em></p>
<p>Plus it's fully overrideable.  You can set RETURN to some random integer if you feel like it...it's just a variable in the frame.  But more frequently you'd like to specialize or adapt it:</p>
<pre><code>bar: function [
    return: [integer!]
    arg [logic!]
][
    return: adapt :return [value: value + 300]
    if arg [
       return 4
    ]
    720
]

&gt;&gt; bar true
== 304
</code></pre>
<p>...but here we are at an interesting question.  What do you expect to happen with <strong>bar false</strong>?</p>
<pre><code>&gt;&gt; bar false
== 720  ; (A) values falling out of bottom *do not* run RETURN implicitly

&gt;&gt; bar false
== 1020  ; (B) values falling out of bottom *do* run RETURN implicitly
</code></pre>
<p>A usermode implementation of FUNC has a pretty easy trick to implement either behavior.  The question is simply if it takes the body you give it and turns it into a GROUP! and passes it to RETURN or not...</p>
<p><strong>"real body" option (A) for BAR above</strong></p>
<pre><code>[
    return: (make action! ...)  ; low level make return function
    (  ; no return here, just `as group! body`
        return: adapt :return [value: value + 300]
        if arg [
            return 4
        ]
        720
    )
]
</code></pre>
<p><strong>"real body" option (B) for BAR above</strong></p>
<pre><code>[
    return: (make action! ...)  ; low level make return function
    return (  ; automatic return injected
        return: adapt :return [value: value + 300]
        if arg [
            return 4
        ]
        720
    )
]
</code></pre>
<h2>
<a name="or-just-require-return-with-func-that-has-return-2" class="anchor" href="https://forum.rebol.info#or-just-require-return-with-func-that-has-return-2"></a>Or Just Require RETURN with FUNC that has RETURN: ?</h2>
<p><strong>strict option (C) for BAR above</strong></p>
<pre><code>[
   return: (make action! ...)  ; low level make return function
   (  ; automatic return injected
       return: adapt :return [value: value + 300]
       if arg [
           return 4
       ]
       720
    )
    fail "Functions which specify RETURN: must use RETURN"
]
</code></pre>
<p><a href="https://forum.rebol.info/t/how-attached-are-we-to-functions-return-last-result/1219">I've brought this up before</a>, and <a class="mention" href="https://forum.rebol.info/u/ingohohmann">@IngoHohmann</a> and <a class="mention" href="https://forum.rebol.info/u/iarnold">@iArnold</a> seemed to think "dropping out the last value" was somehow fundamental.</p>
<p>But given what I say above about how the semantics get pretty sketchy on type checking and such, what if we say that functions that don't specify RETURN have no return available, and just drop out their last result?</p>
<pre><code>bar1: function [
    arg [logic!]
][
    if arg [4] else [720]
]

&gt;&gt; bar true
== 4

&gt;&gt; bar false
== 720
</code></pre>
<p>You don't get type checking so you'd have to do it yourself, which will be available:</p>
<pre><code>bar1-checked: function [
    arg [logic!]
][
    let val: if arg [4] else [720]
    ensure integer! val
]
</code></pre>
<p>However: if you specify RETURN: in the spec then you are required to use it.  This gives you type checking and guarantee of running any return hooking on all code paths:</p>
<pre><code>bar2: function [
    return: [integer!]
    arg [logic!]
][
    return: adapt :return [value: value + 300]
    if arg [
       return 4
    ]
    return 720
]

&gt;&gt; bar true
== 304

&gt;&gt; bar false
== 1020
</code></pre>
<h2>
<a name="i-think-the-case-for-requiring-return-if-return-is-strong-3" class="anchor" href="https://forum.rebol.info#i-think-the-case-for-requiring-return-if-return-is-strong-3"></a>I Think The Case for Requiring RETURN if RETURN: Is Strong</h2>
<p><strong>It seems rather clear when laid out like I have above that it's the right answer.</strong>  People who hook RETURN are typically doing so because they want it on all return paths.  But I think hiding a RETURN behind the scenes is a cognitive time bomb.  Being explicit sorts that out, and it also provides a rational answer for why you get type checking...<em>the RETURN does the check</em>.</p>
<p><em>(I can tell you that without that rational answer, the internals have ugliness.  This policy will cleanse the ugliness.)</em></p>
<p>Lower-level functions that don't have RETURN have to have a way to return values.  Dropping them out the bottom seems a good way to start building up the mechanic.  It's also useful for quick and dirty "macro-like" functions, so I see no problem with that.</p>
<h2>
<a name="should-return-be-an-exception-4" class="anchor" href="https://forum.rebol.info#should-return-be-an-exception-4"></a>Should <code>return: [~]</code> be an Exception?</h2>
<p>The point of introducing this was to help remove concern over letting unwanted variables "fall out", and being able to forego concerns about type checking.  <strong>It's a different case</strong>, because there is no type checking involved of the parameter passed to RETURN as it takes no parameters...and there's no need to type check what falls out the bottom because it is discarded:</p>
<pre><code>something: func [
    return: [~]
    value [text!]
][
    if value = "" [return]  ; this RETURN acts as `return ~`
    append data value

    ; expectation has been that this would also yield ~
]
</code></pre>
<p>The idea was to make it painless to shield callers from seeing the returned result, and have them know there was no result they were supposed to pay attention to.</p>
<p>What gets me concerned here is that question of whether or not a hooked or modified RETURN is implicitly run at the end of such a function.</p>
<p>It seems to suck to have to put the RETURN there.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=12" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<pre><code>something: func [
    return: [~]
    value [text!]
][
    return: adapt :return [print "I AM RETURNING!"]
    if value = "" [return]
    append data value
    return  ; with this here, it's clear you will get the PRINT to happen
]
</code></pre>
<p>But it does benefit from the explicitness.  There's no ambiguity.</p>
<p><strong>Again, you have to use your imagination to think about a longer function in which there are many control paths through the function...and someone decides to hook RETURN.</strong>  If you are working in a large codebase with long functions, wouldn't you like to know that all control paths will run your hook...and that the language has gotten everyone on the same page that is expected and possible?</p>
<p><strong>My feeling in the moment is that the only answer I'd consider besides erroring if there's no RETURN would be to implicitly put a RETURN at the end, so a hooked RETURN would be executed if a value drops out the bottom.</strong>  But I've explained that for the other cases I think that's sneaky.  It feels much more forthright to have the call at source level.</p>
<p>Path of least resistance on this is to add the RETURN implicitly, so I'm going with that.</p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/implicit-execution-of-return-in-functions-bad/1656">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/implicit-execution-of-return-in-functions-bad/1656</link>
          <pubDate>Thu, 12 Aug 2021 19:00:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1656</guid>
          <source url="https://forum.rebol.info/t/implicit-execution-of-return-in-functions-bad/1656.rss">Implicit Execution of RETURN in functions = ...BAD (?)</source>
        </item>
        <item>
          <title>Resurrecting REDBOL-APPLY via Type Exposure</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>At one point, I had a simulation of the Rebol2/R3-Alpha APPLY working...all written in usermode code.</p>
<p>As a refresher: this concept of APPLY required you to line up things positionally--even refinements.  You had to look at the parameter order on the interface, and put "truthy" things in the refinement slots you wanted to enable.  Then if the refinement took argument(s), you would have to put that in the next slot.</p>
<p>So for R3-Alpha's APPEND, the ordered spec is:</p>
<pre><code>APPEND series value /part length /only /dup count
</code></pre>
<p>Let's say you wanted to do something equivalent to <strong>append/part/dup [a b c] [d e f] 2 3</strong>.  You would write:</p>
<pre><code>r3-alpha&gt;&gt; apply :append [[a b c] [d e f] true 2 false true 3]
== [a b c d e d e d e]
</code></pre>
<p>Here the first TRUE is to say we want to use the /PART...then the length of 2.  Then a FALSE to say we don't want /ONLY.  And then another TRUE to say we want /DUP, with the count as 3.</p>
<p>It's fairly convoluted, and brittle with respect to rearrangement.  But it offers you the benefit of being able to calculate whether you want to provide a refinement or not.  The block is reduced by default (with an /ONLY option to ask that it not be).</p>
<p>In the early days of frames, I thought it would be a good test to see if this exact function could be emulated by processing the block... building a FRAME!, and then DO'ing it.  So REDBOL-APPLY was written and added to the tests.</p>
<h2>
<a name="then-ren-c-became-pure-and-refinedhttpsforumrebolinfotpure-and-refined-simplifying-refinements-to-one-or-zero-args1120-1" class="anchor" href="https://forum.rebol.info#then-ren-c-became-pure-and-refinedhttpsforumrebolinfotpure-and-refined-simplifying-refinements-to-one-or-zero-args1120-1"></a>Then Ren-C Became <a href="https://forum.rebol.info/t/pure-and-refined-simplifying-refinements-to-one-or-zero-args/1120">Pure and Refined</a>...</h2>
<p>With the great improvement of refinements becoming their own arguments, came a new puzzle from an interface perspective.  Where it had used to say things like:</p>
<pre><code>ren-c-before&gt;&gt; parameters of :append
== [series value /part length /only /dup count]
</code></pre>
<p>It would now say:</p>
<pre><code>ren-c-after&gt;&gt; parameters of :append
== [series value /part /only /dup]
</code></pre>
<p>You might notice a piece of information gets lost there: <strong>which refinements take arguments at the callsite, vs. which ones don't</strong>.  Here the /ONLY looks just like the /PART and /DUP.  If you're going to have a REDBOL-APPLY that splits out the refinement on/off from the argument, you have to know if there is an argument to fill in.</p>
<p>I'll emphasize here that <strong>whether or not this particular APPLY primitive is desirable or not isn't the point.</strong>  It's a question of whether there's enough information.  And you have to have more than the parameter list above.</p>
<p>So one place people might have looked to would be the TYPESETS OF reflector, and maybe check to see if the typeset was empty (?)  But the typeset code was never all that good.</p>
<h2>
<a name="enter-the-new-as-frame-aliasing-ability-2" class="anchor" href="https://forum.rebol.info#enter-the-new-as-frame-aliasing-ability-2"></a>Enter The New AS FRAME! Aliasing Ability</h2>
<p>I only just pushed this a bit forward, so it's not stable yet.  But it was enough to get REDBOL-APPLY working.  Here's what the frame alias of APPEND looks like:</p>
<pre><code>&gt;&gt; as frame! :append
== #[frame! {append} [
    return : [any-series! port! map! object! module! bitset!]:
    series : [any-series! port! map! object! module! bitset!]
    value : [&lt;opt&gt; any-value!]
    part : /[any-number! any-series! pair!]
    only : /[]
    dup : /[any-number! pair!]
    line : /[]
]]
</code></pre>
<p>The keys can't hold the information about whether something is a refinement or quoted or not.  So those attributes are moved onto the BLOCK!.  Here we see that PART, ONLY, DUP, and LINE are refinements...while ONLY and LINE have no specified types.</p>
<h2>
<a name="and-heres-the-first-try-that-gets-the-tests-passing-again-3" class="anchor" href="https://forum.rebol.info#and-heres-the-first-try-that-gets-the-tests-passing-again-3"></a>And Here's The First Try That Gets The Tests Passing Again</h2>
<p>It's big and pokey.  And it trips over the weird parameter compaction a little bit... there's still a lot of questions about how you would take something that could either be <strong>':foo</strong> or <strong>/foo</strong> and extract plain <strong>foo</strong> out of it.  (It's not as obvious as you might think that "to word! should just do that".)</p>
<p>There's plenty of room for improvement.  But clumsy though it is, it shows some of the non-trivial meta-language behavior that I think can be put in the hands of mere mortals...in that Minecraft-of-programming way.  This really is letting people get intimately involved in the design of their own function generators and control structures...</p>
<pre><code>redbol-apply: func [
    return: [&lt;opt&gt; any-value!]
    action [action!]
    block [block!]
    /only
    &lt;local&gt; types arg key frame params mode
][
    types: as frame! :action  ; exemplar of types
    frame: make frame! :action  ; frame we are building
    params: parameters of :action  ; ordered list of parameters
    mode: &lt;normal&gt;

    ; Rebol2 and R3-Alpha APPLY would fill in NONE for any parameters that
    ; were not provided in the apply block:
    ;
    ;     rebol2/r3-alpha&gt;&gt; apply func [a b c] [reduce [a b c]] []
    ;     == [none none none]
    ;
    ; This means we need to enumerate and fill in the frame as long as there
    ; are parameters--not as long as there are block values.
    ;
    while [not tail? params] [
        case [
            not block [
                arg: null  ; could also do BLANK! if no more block data
            ]
            only [  ; /ONLY means do not evaluate arguments
                arg: get/any 'block/1
                block: next block
            ]
            true [  ; evaluate (skipping comments and other invisibles)
                until .not.quoted? [[block arg]: evaluate block]
            ]
        ]

        key: to word! dequote params/1
        all [
            refinement? params/1
            elide if not block [break]  ; done if refinements w/no more block
            mode = &lt;normal&gt;
        ] then [
            mode: if arg [#]  ; set mode to either use or don't use next arg
            if empty? second pick types key [  ; no-arg refine...
                set (in frame key) mode  ; ...must be # or NULL
            ] else [
                continue  ; keep param on the refinement, get next arg
            ]
        ] else [
            if mode [  ; normal or # case will set
                set (in frame key) get/any 'arg
            ]
        ]

        mode: &lt;normal&gt;
        params: next params
    ]

    ; Too many arguments was not a problem for R3-alpha's APPLY, it would
    ; evaluate them all even if not used by the function.  It may or may not
    ; be better to have it be an error.
    ;
    ; https://github.com/metaeducation/rebol-issues/issues/2237
    ;
    comment [
        all [block, not tail? block] then [
            fail "Too many arguments passed in REDBOL-APPLY block."
        ]
    ]

    do frame
]
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/resurrecting-redbol-apply-via-type-exposure/1474">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/resurrecting-redbol-apply-via-type-exposure/1474</link>
          <pubDate>Mon, 25 Jan 2021 11:50:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1474</guid>
          <source url="https://forum.rebol.info/t/resurrecting-redbol-apply-via-type-exposure/1474.rss">Resurrecting REDBOL-APPLY via Type Exposure</source>
        </item>
        <item>
          <title>Chaining Return Types</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Something that bothers me about C is that it doesn't let you write chaining void returns:</p>
<pre><code>void my_function() {
    return some_void_function(...);  /* this is not legal! */
}
</code></pre>
<p>That annoys me, because it makes it hard to write generic code that doesn't want the bad properties of a macro (repeating evaluation of arguments if used multiple times, etc.)...but throws a wrench in being able to abstract across return values.</p>
<p><strong>But Ren-C has this covered!</strong>  All states can be chained.</p>
<p>But what if you are writing a wrapped function, and want a type signature on the wrapper that matches what you are wrapping?  I guess we could do this via COMPOSE on the spec of some kind:</p>
<pre><code>my-function: func compose [
    return: (return-type-block-of :some-other-function)
    ...
][
    ...
    return some-other-function ...
]
</code></pre>
<p>Something along these lines, where you could add or remove elements of the type signature.  :-/Anyway, I just wanted to mention that we're not yet at utopia in this medium, even if we're pretty much nailing the chaining part itself!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/chaining-return-types/1467">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/chaining-return-types/1467</link>
          <pubDate>Mon, 18 Jan 2021 02:04:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1467</guid>
          <source url="https://forum.rebol.info/t/chaining-return-types/1467.rss">Chaining Return Types</source>
        </item>
        <item>
          <title>Representing Everything About A Parameter (...except its name)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p><strong>I'm aiming to draw out the string labels in parameter lists into their own more compact form, that's just the pointer to the string name.</strong></p>
<p>We can think of splitting out the symbol as if decorations we currently put on the parameter would be moved to the block:</p>
<pre><code> func ['foo [&lt;end&gt; word!] /bar [integer!] /no-arg] [...]
 =&gt;
 func [foo '[&lt;end&gt; word!] bar /[integer!] no-arg-refinement /[]] [...]
</code></pre>
<p>That's just how to think of how it's stored.  We don't have to <em>write</em> our specs like that...</p>
<p>There are a number of good reasons to do this, e.g. implementing <a href="https://richardartoul.github.io/jekyll/update/2015/04/26/hidden-classes.html">"hidden classes"</a> as in V8...each time you do  <strong>for-each [x y] ...</strong> or <strong>make object! [a: 10, b: 20]</strong> the system should detect the similarity of the key collection and reuse it, instead of needing unique [x y] and [a b] list copies allocated every time.</p>
<p>(I'll point out that consistent chipping away at efficiencies means that things like <strong>/[a b]</strong> do not take up more space than <strong>/[a b]</strong> or <strong>[a b]/</strong> or <strong>[a b].</strong> or <strong>.[a b]</strong> ... though these forms are immutable... keep that in mind...)</p>
<h2>This <em>reduces</em> how much information a "PARAM!" stores</h2>
<p>Currently all the information for a parameter--including the symbol, types, and other modes--is stuffed into an internal Frankenstein-like type called a PARAM!.  It's compressed into a single cell as a mismash of packed bits and a pointer to a spelling.</p>
<p><em>(Historical Note: R3-Alpha acted like these freakish cells were WORD!s...but with an off-to-the-side flag that marked them as "UNWORD"s.  This meant they stored a bunch of type bits where most words would store a binding.  These fake words could easily leak and crash the system, so Ren-C gave parameters a dedicated internal type, asserting on cases of use as if they were WORD!.)</em></p>
<p>The symbol takes one of the four slots in the PARAM!.  The cell header takes another.  So what's left in the remaining two slots is just a bunch of bits... 64 bits is what's available on both 32-bit  and 64-bit platforms.</p>
<p>There's a bit for whether or not each fundamental type--like a BLOCK! or TEXT!--is accepted by the parameter.  Then there are bits for <em>"is this parameter <code>&lt;skip&gt;</code>-able"</em> or <em>"can this parameter be the <code>&lt;end&gt;</code> of input"</em>.  This means the number of fundamental types allowed has been less than 64...as other parameter options have to fit in this set too.</p>
<h1>Can PARAM! be replaced with "normal" values?</h1>
<p>What if params were not a mysterious compressed form, but values that could be inspected more directly as a "parameter spec"?</p>
<p>I showed this "represenational concept" above (again, just to think of it as the system stores it, not as how you write it at source level):</p>
<pre><code> func [foo '[&lt;end&gt; word!] bar /[integer!] no-arg-refinement /[]] [...]
</code></pre>
<p>When the burden of representing the parameter name is removed, then <strong><code>'[&lt;end&gt; word!]</code></strong> could be the value that represents how the evaluator deals with the <code>foo</code> parameter.  Today the HELP gets a capture of these typeset blocks in the spec just for reference purposes.  But this would mean that what help used would concretely match what was in the spec.</p>
<h2>Challenge: Mutability of Referenced Type Words</h2>
<p>Let's imagine you did this:</p>
<pre><code>&gt;&gt; foo: func [name [text!]] [print [name]]
&gt;&gt; foo "before"
before

&gt;&gt; text!: integer!
&gt;&gt; foo "after"
after  ; did not reflect the change
</code></pre>
<p>Today it would not reflect the change.  This is because when that <code>TEXT!</code> word is looked up, it finds one of the built in DATATYPE!s for representing text, and sets the corresponding bit in the PARAM!.  No matter how you change TEXT!, it will only affect functions created after that point...not any that already set their bits.</p>
<p>We could address this by saying that if you use any WORD!s in the type spec of a function, then the binding of that word gets forcibly protected (if it isn't already).</p>
<pre><code>&gt;&gt; x!: text!

&gt;&gt; foo: func [name [x!]] [print [name]]

&gt;&gt; x!: integer!
** Access Error: variable x! locked
; ^-- it would be helpful to mention a "lock reason", though we are a bit short
; on bits for putting in these reasons...maybe only done in 64-bit builds?
</code></pre>
<p>This would give a persistence so the parameter description could store <strong><code>x!</code></strong> without worrying about its meaning changing.  That means you can do things like type check a parameter for a specialization at specialization time...and trust it doesn't need rechecking when used.  It also allows performance tricks that cache bits to make the check faster without having to look up the word every time (since you know it won't change).</p>
<p>It's a little harsh-seeming, but the type dialect has to be hardened somehow.  If you needed to use X! locally for something else, you've always got <strong>use [x!] [...]</strong> to create a new context for it.</p>
<h2>Challenge: Performance</h2>
<p>Checking a bit for a fundamental type in a typeset is pretty fast.  Matching a value against a rich type specification dialect isn't necessarily fast, and this is something every function (including natives) do.  It's particularly important for natives, because they interpret the bits of the cell assuming it has been checked...getting the wrong thing means it will crash.</p>
<p>This is where internal compactions could come into play.  Users might see the parameter spec as <strong>[text! integer!]</strong> but the system could recognize specific common patterns like that and compress them into something like today's PARAM! bits, behind the scenes.</p>
<p>We might want to rethink the usage of things like <code>&lt;end&gt;</code> to not use TAG!, but to use a type that can be interned for speed.  The problem with tags is that you could see <code>&lt;end&gt;</code> but actually have <code>next &lt;mend&gt;</code>...so if you had a process of locking down the symbol for speedy recognition you'd not be able to do it.  By contrast, ISSUE! (token) has no position and could be canonized to a word, so the process of checking could turn <code>#end</code> into something that is matched faster.</p>
<h2>Challenge: Mutability Part II - Type Predicates</h2>
<p>I've suggested essentially the end of the TYPESET! datatype as a concept; replacing it with functions.  This would mean something like:</p>
<pre><code>any-type!: :any-type?
</code></pre>
<p>This would have the same issue with locking, so once you used ANY-TYPE! in a function spec you couldn't change that particular binding's value of ANY-TYPE! to anything else.</p>
<p>But further, there needs to be a rule that ANY-TYPE? is a pure function.  It needs to give the same answers for the same input, and that answer cannot depend on anything about that input that can mutate.</p>
<p>Imagine that you specialized a function with a mutable BLOCK!, and the constraint was that it was a BLOCK! of length 2.  Then you append to the block, and call the specialization.  It no longer matches.</p>
<p>What you could ultimately end up with is a situation where you pay for type checking of specialized arguments every time (which would also mean you couldn't use the slot where the type information would have been for the specialized value...because you'll need both at the same time, an optimization loss)</p>
<h2>Challenge: Generics Throw A Wrench Into Types</h2>
<p>There has never been a good answer to how GENERICs (what Rebol2/Red called actions) work.  If you have something like APPEND that's defined to allow you to append to strings and blocks...but then later add an extension that implements GOB!s, how do you say that APPEND now accepts GOB!s...and how do you constrain the parameters to indicate that?</p>
<p>Historically, the grab bag of parameters for what these generic functions allow or don't is just updated in the bootstrap files.  But users and extensions can't really do this.</p>
<p>This is a topic in its own right--but it's worth mentioning.</p>
<h1>Inventory Of Parts to be Represented</h1>
<p>That's a lot to take in, but I'll close with the list of things that PARAM! bits currently encode:</p>
<p><strong>Some of these parts are on the element that names the parameter itself:</strong></p>
<ul>
<li>
<p>the spelling of the parameter's name (<a>currently case-sensitive, please read and discuss implications</a>)</p>
</li>
<li>
<p>its quoting status (WORD! -&gt; normal evaluation, QUOTED! WORD! -&gt; hard literal, GET-WORD! -&gt; soft literal)</p>
</li>
<li>
<p>if it's a refinement that outputs to a variable, which can also be used by multiple return...indicated by being a SET-WORD! if so</p>
</li>
<li>
<p>if it's a local, shown by a leading dot (it's possible to indicate that a range of ordinary words are all local by prefixing them with the <code>&lt;local&gt;</code> tag, e.g. <strong><code>&lt;local&gt; x y</code></strong> is the same as <strong><code>.x .y</code></strong>)</p>
</li>
<li>
<p>whether it is optional or not, denoted by a leading slash</p>
</li>
</ul>
<p><strong>The rest is in a BLOCK! which specifies what types the parameter accepts.</strong>  This includes other attributes of the parameter that don't fit on the first value:</p>
<ul>
<li>
<p>if it is willing to accept NULL or not--denoted by <code>&lt;opt&gt;</code>.  <em>(Note: this has been a gray area in "typesets" as NULL is not a value and "has no type")</em></p>
</li>
<li>
<p>if it is willing to treat the end of a series as if it had received NULL--denoted by <code>&lt;end&gt;</code>.  (to help with the conflation, a separate function allows to ask if a parameter's null actually came from reaching the end or not)</p>
</li>
<li>
<p>if the parameter will be skipped over and given as NULL if there is not a precisely matching type in that position slot, <a href="https://forum.rebol.info/t/skip-able-arguments/1013">denoted by <code>&lt;skip&gt;</code></a> <em>(Note: this is only available on hard literal parameters)</em></p>
</li>
<li>
<p>if the parameter is variadic, denoted by <code>&lt;variadic&gt;</code> <em>(Note: this was once <code>&lt;...&gt;</code> but that is now a 4-element TUPLE! corresponding to <code>[&lt; _ _ &gt;]</code>.  While it might seem like that "should be a tag!" that would be a broken interpretation since <code>&lt;</code> is a WORD! and if used for a function or object it would need <strong><code>&lt;/refinement</code></strong> or <strong><code>&lt;.field</code></strong> to be PATH! and TUPLE! respectively)</em></p>
</li>
<li>
<p>whether a parameter is modal, and controls the optional parameter directly after it in the parameter order.  <em>(Note: <a href="https://forum.rebol.info/t/new-parameter-convention-concept-modal-arguments-or-the-arg/1187">this is an experimental feature</a> that is weird and is still being studied, but it has some places where it's looking like it is fairly critical.)</em></p>
</li>
</ul>
<h2>Addendum: ...that's only information the evaluator uses...!</h2>
<p>That lengthy list doesn't include the HELP description string...which is just the tip of the iceberg for what a user might want to annotate arguments on a function with.</p>
<p>But Ren-C pushes all of the help information into a "meta" object.  Function makers have a low-level form that doesn't bother making this object (e.g. <strong><code>specialize*</code></strong>) and then a higher-level version that does.  There's a certain amount of default information put into the object:</p>
<pre><code>&gt;&gt; meta: meta-of :append
&gt;&gt; words of meta
== [description return-type return-note parameter-types parameter-notes

&gt;&gt; meta/parameter-notes/dup
== "Duplicates the insert a specified number of times"
</code></pre>
<p>You can tweak the object to your liking, and use FRAME!s as maps from parameter to value.  For example, you could track a property for each parameter being either <code>&lt;cool&gt;</code> or <code>&lt;uncool&gt;</code>:</p>
<pre><code> &gt;&gt; append meta compose [coolness: (make frame! :append)]
 &gt;&gt; meta/coolness/line: &lt;cool&gt;
 &gt;&gt; meta/coolness/part: &lt;uncool&gt;

&gt;&gt; meta/coolness
== make frame! [
    series: '~unset~
    value: '~unset~
    part: &lt;uncool&gt;
    only: '~unset~
    dup: '~unset~
    line: &lt;cool&gt;
]     
</code></pre>
<p>It's far from perfect, but it pushes the information out into the open where things like HELP can process it...and it's critical to writing code that inherits and manipulates the information.</p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/representing-everything-about-a-parameter-except-its-name/1459">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/representing-everything-about-a-parameter-except-its-name/1459</link>
          <pubDate>Wed, 06 Jan 2021 18:29:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1459</guid>
          <source url="https://forum.rebol.info/t/representing-everything-about-a-parameter-except-its-name/1459.rss">Representing Everything About A Parameter (...except its name)</source>
        </item>
        <item>
          <title>Weird Idea: TUPLE in Paths to Provide Refinement *AND* Value</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <blockquote>
<p><strong>UPDATE:</strong> <a href="https://forum.rebol.info/t/big-alien-proposal-word-runs-functions/1905/15">Looks like I rediscovered this idea 4 years later</a>.  Guess I forgot about it!  <img src="https://forum.rebol.info/images/emoji/twitter/older_man.png?v=12" title=":older_man:" class="emoji" alt=":older_man:" loading="lazy" width="20" height="20"></p>
</blockquote>
<hr>
<p>People very frequently request seeing the connection between the refinement and its value more obviously, because the refinement argument is kind of far away:</p>
<pre><code>&gt;&gt; data: '(a b c)
&gt;&gt; append/dup data &lt;foo&gt; (1 + 2)
== (a b c &lt;foo&gt; &lt;foo&gt; &lt;foo&gt;)
</code></pre>
<p>So they make broken suggestions like <strong><code>append /dup 2 data &lt;foo&gt;</code></strong>, which we constantly have to debunk.</p>
<p>Nowadays <a href="https://forum.rebol.info/t/apply-ii-the-revenge/1834">we have "APPLY II"</a> which helps in more verbose cases:</p>
<pre><code>&gt;&gt; data: '(a b c)
&gt;&gt; apply :append [data &lt;foo&gt; /dup (1 + 2)]
== (a b c &lt;foo&gt; &lt;foo&gt; &lt;foo&gt;)
</code></pre>
<h2><a name="p-3995-but-i-had-an-odd-idea-1" class="anchor" href="https://forum.rebol.info#p-3995-but-i-had-an-odd-idea-1"></a>But I had an odd idea...</h2>
<p>What If You Could Directly Pass A Refinement Arg Via TUPLE?</p>
<pre><code>&gt;&gt; data: '(a b c)
&gt;&gt; append/dup.3 data &lt;foo&gt;
== (a b c &lt;foo&gt; &lt;foo&gt; &lt;foo&gt;)

&gt;&gt; data: '(a b c)
&gt;&gt; append/dup.(1 + 2) data &lt;foo&gt;
== (a b c &lt;foo&gt; &lt;foo&gt; &lt;foo&gt;)
</code></pre>
<p>It wouldn't be great for everything, but it could be convenient.  Not really hard to write, but is it compelling?  Are there other potentially interesting meanings for this notation?</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/weird-idea-tuple-in-paths-to-provide-refinement-and-value/1932">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/weird-idea-tuple-in-paths-to-provide-refinement-and-value/1932</link>
          <pubDate>Mon, 21 Sep 2020 05:38:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1932</guid>
          <source url="https://forum.rebol.info/t/weird-idea-tuple-in-paths-to-provide-refinement-and-value/1932.rss">Weird Idea: TUPLE in Paths to Provide Refinement *AND* Value</source>
        </item>
        <item>
          <title>Multiple Return Values Via Infix</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <blockquote>
<p>Note: Before multi-returns had an implementation in the C code of the evaluator, I observed they could be implemented by means of infix and skippable parameters.  This was that implementation.</p>
<p>It's still cool to look back at just in terms of the wild things you can prototype!  Post updated for modern syntax, though <a href="https://forum.rebol.info/t/skip-able-arguments-2024-update-removed/1013"><code>&lt;skip&gt;</code>-able parameters no longer exist</a></p>
</blockquote>
<hr>
<p>Imagine you want to make something where it returns the sum of two values and the difference...but only the sum if you aren't using a multi-return.</p>
<pre><code>/sum-and-difference: infix func [@left [&lt;skip&gt; set-block!] arg1 arg2] [
    let sum: arg1 + arg2  ; always returned, only calculate once
    if set? $left [
        switch length of left [
            1 [  ; we have `[x]: ...` act the same as `x: ...` 
               set left.1 sum
            ]
            2 [  ; only calculate difference for multiple returns
               set left.1 sum
               set left.2 arg1 - arg2
            ]
            fail "sum-and-difference can only return 1 or 2 values"
        ]
    ]
    return sum
]
</code></pre>
<h2><a name="p-3694-and-presto-1" class="anchor" href="https://forum.rebol.info#p-3694-and-presto-1"></a>and presto...</h2>
<pre><code>&gt;&gt; x: sum-and-difference 20 10
== 30  ; handled by plain evaluator mechanics

&gt;&gt; [y z]: sum-and-difference 20 10
== 30  ; handled by the infix quoting

&gt;&gt; y
== 30

&gt;&gt; z
== 10
</code></pre>
<p>Notice that adopts the principle that it doesn't actually try to return a BLOCK! with the multiple return values, but only the first value.  But the interesting bit is that when you go about it this way, the convention is not really enforced.</p>
<h2><a name="p-3694-whats-wrong-with-doing-it-this-way-2" class="anchor" href="https://forum.rebol.info#p-3694-whats-wrong-with-doing-it-this-way-2"></a>What's Wrong With Doing It This Way?</h2>
<p>A disadvantage of this technique is it means you cannot make infix functions that have multiple return values (in the sense they've already used their infixness for the purpose of the multiple return value itself).</p>
<p>That may or may not be bad.  :-/  This offers a lot of flexibility to people for designing how their multiple return values work.</p>
<ul>
<li>
<p>They could decide that blanks mean skip the assignment, so for <strong>[_ z]: sum-and-difference 20 10</strong> it could be decided not to calculate the sum at all, and to return the difference.</p>
<ul>
<li>UPDATE: The information is not available in the system multi returns to know about whether the <em>main</em> result was requested or not...only the additional returns.  So the infix function would have this edge.</li>
</ul>
</li>
<li>
<p>People who disagree with my philosophy about return the first thing could come up with their own rules...returning blocks that voidify, or maybe even the ability to mark which thing to return like <strong>[y {z}]: sum-and-difference 20 10</strong> could calculate both but return the difference.</p>
<ul>
<li>UPDATE: <a href="https://forum.rebol.info/t/circling-multi-returns-choose-which-is-expression-result/1587">This feature exists in modern multi-returns offered by the system!</a></li>
</ul>
</li>
</ul>
<p>Telling people they are their own boss and can design multi return features however they want is a powerful idea that is a bit unnerving.  Though Rebol has a lot of those.  Truly a strange way of looking at multiple return value mechanics!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/multiple-return-values-via-infix/1257">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/multiple-return-values-via-infix/1257</link>
          <pubDate>Sat, 01 Feb 2020 05:04:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1257</guid>
          <source url="https://forum.rebol.info/t/multiple-return-values-via-infix/1257.rss">Multiple Return Values Via Infix</source>
        </item>
  </channel>
</rss>

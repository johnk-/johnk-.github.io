<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Functions - AltRebol</title>
    <link>https://forum.rebol.info/c/development/functions/59</link>
    <description>Topics in the &#39;Functions&#39; category Discussions of Functions and Generators, e.g. how things like RETURN work... or the mechanics of generators and composers like ADAPT, SPECIALIZE, ENCLOSE, HIJACK, etc.</description>
    
      <lastBuildDate>Tue, 30 Jan 2024 21:48:12 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/functions/59.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Rethinking `&lt;static&gt;` in the Function Spec Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>In R3-Alpha, the FUNCTION construct was built on top of FUNC, and added features like statics as a refinement.  It looked pretty awkward, because the static was added at the end of the expression:</p>
<pre><code> r3-alpha&gt;&gt; foo: function/with [x] [return staticvar: add staticvar x] [staticvar: 0]

 r3-alpha&gt;&gt; foo 10
 == 10

 r3-alpha&gt;&gt; foo 20
 == 30
</code></pre>
<p>Ren-C tried extending the function spec dialect to support this in a nicer way:</p>
<pre><code> foo: function [x &lt;static&gt; staticvar (0)] [return staticvar: add staticvar x]
</code></pre>
<p>The low-level FUNC implementation doesn't know what <code>&lt;static&gt;</code> is, so it's added by a higher layer, that makes things slower... and since the function spec dialect is kind of foundational it may be the wrong place to be putting this for the core.</p>
<p><span class="mention">@hiiamboris</span> <a href="https://forum.rebol.info/t/hiiamboriss-with/2138">approaches this differently</a>:</p>
<aside class="quote no-group">
<blockquote>
<h4>create static storage for functions where existing literal forms don't allow you to:</h4>
<pre><code class="lang-plaintext">factorial: func [x] with [cache: make hash! [0 1]] [
    any [
        select/skip cache x 2
        put cache x x * factorial x - 1
    ]
]
</code></pre>
</blockquote>
</aside>
<p>It's not the first time I've thought it would be a better direction to break it out.  But putting it all as part of the function spec was supposed to have an advantage in that when the body was walked to create the copy, the binding to the static members would be done as well.  This is no longer applicable, because the bodies of functions are largely left unbound...</p>
<p>We do lose a feature of noticing when you are naming the static the same thing as something in your function frame and you don't get an error in that case, but maybe you don't want an error (perhaps you inherited the frame through an adaptation or something like that, and you don't care about the frame variable).</p>
<p>Boris's dialect is a bit overloaded, and Ren-C has more parts to help with that...<a href="https://forum.rebol.info/t/rethinking-braces-as-an-array-type/1727">but it would help even more if there were FENCE!</a></p>
<pre><code>foo: func [x] with [
    {staticvar: 0}
][
    return staticvar: add staticvar x
]

foo: func [x] with {staticvar: 0} [
    return staticvar: add staticvar x
]
</code></pre>
<p>So this wouldn't be confused with any other WITH things you were doing, like trying to use objects or words and add them to a block that already had a binding.</p>
<pre><code>&gt;&gt; body: [keep staticvar: staticvar + x]

&gt;&gt; collect [
       wrapper: func [x] with ['keep {staticvar: 0}] body
       wrapper 1
       wrapper 10
       wrapper 100
   ]
== [1 11 111]
</code></pre>
<p>(Just trying to drum up a little excitement for FENCE! there, but I think it's the tip of the iceberg.)</p>
<p>Anyway, there've been educational lessons from showing that you <em>can</em> extend the FUNC spec dialect and build higher level features... but I think we should probably tear those out of the core and move to something like this.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/rethinking-static-in-the-function-spec-dialect/2139">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rethinking-static-in-the-function-spec-dialect/2139</link>
          <pubDate>Tue, 30 Jan 2024 21:48:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2139</guid>
          <source url="https://forum.rebol.info/t/rethinking-static-in-the-function-spec-dialect/2139.rss">Rethinking `&lt;static&gt;` in the Function Spec Dialect</source>
        </item>
        <item>
          <title>Making FUNC Variant That Auto-Returns Last Result</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>I had offered that people could use this simple wrapper to get the old behavior of FUNC, to drop out its last result (instead of returning trash):</p>
<pre><code>func: adapt :lib.func [body: compose [return (as group! body)]]
</code></pre>
<p>The concept is that if you write:</p>
<pre><code> foo: func [x] [
     if x &lt; 0 [return x + 10]
     x - 10
 ]
</code></pre>
<p>What you'd actually get would be:</p>
<pre><code> foo: lib.func [x] [
     return (
         if x &lt; 0 [return x + 10]
         x - 10
     )
 ]
</code></pre>
<h2>
<a name="broken-under-new-binding-model-1" class="anchor" href="https://forum.rebol.info#broken-under-new-binding-model-1"></a>Broken Under New Binding Model</h2>
<p>Under the new binding model, an array which is bound will by default hold onto its binding.</p>
<ul>
<li>
<p>The BODY was a BLOCK! that evaluated at the callsite and captured its environment (e.g. to the user context, module context, outer function context, etc.)</p>
</li>
<li>
<p>When you convert it to a GROUP! it will still have that binding.</p>
</li>
<li>
<p>The surgery which is done to inject the frame containing X into the environment will thus apply only at the outermost level.  So the outer block where the return lives would see it, but never make it to the inner group.</p>
<pre><code>func: adapt :lib.func [
    body: compose [
        print ["Here would see the X:" x]
        return (as group! body)  ; &lt;-- inside group will not
    ]
]
</code></pre>
</li>
</ul>
<h2>
<a name="mimicking-funcs-surgery-2" class="anchor" href="https://forum.rebol.info#mimicking-funcs-surgery-2"></a>Mimicking FUNC's Surgery</h2>
<p>One idea would be to use a utility that can do something like what LIB.FUNC did to put the frame onto the proxy body, on the original body.</p>
<p>But awkwardly, you can't do this surgery inside the COMPOSE, because it has to be done once the function is running.  If we call that surgery OVERBIND, one answer would look something like this:</p>
<pre><code>func: adapt :lib.func [
    body: compose [
        return do overbind binding of in [] 'return (body)
    ]
]
</code></pre>
<p><em>(I'll mention that this OVERBIND is not as efficient as what FUNC does, because the frame itself has a pointer to the inherited environment when it's made.  But it only has one slot for that pointer.  So if you try to build a specifier chain with the frame that points to another environment, it has to fabricate a "frame holder" which has its own pointer to put in the chain.)</em></p>
<p>Notice that we only want the frame, here... which we get from the binding of the RETURN.  We don't want to inject awareness of everything in this FUNC adaptation's scope.  So not <strong><code>overbind [] (body)</code></strong>.  If such a thing were even legal to do... body probably has its own copy of lib inherited from another module, and then you've got another module and its lib... we're trying to avoid that kind of conundrum with conservative binding preservation.</p>
<h2>
<a name="another-approach-steal-the-binding-and-unbind-3" class="anchor" href="https://forum.rebol.info#another-approach-steal-the-binding-and-unbind-3"></a>Another Approach: Steal The Binding And Unbind</h2>
<p>Another approach would be to steal the binding off of the body and put it on the composition, then remove the binding from the body:</p>
<pre><code>func: adapt :lib.func [
    body: in body bindable compose [
        return (bindable as group! body)
    ]
]
</code></pre>
<p>You can put the BINDABLE before or after the AS GROUP!.</p>
<p>I actually think this reads less insanely if we just go with UNBIND as being a "tip-unbinding" operation by default, and then have UNBIND/DEEP.  <em>(Maybe UNBIND/SHALLOW for one level of depth?)</em>:</p>
<pre><code>func: adapt :lib.func [
    body: in body unbind compose [
        return (as group! unbind body)
    ]
]
</code></pre>
<p>It's much better to do it this way.  You're doing cheaper operations and doing them at FUNC creation time.</p>
<h2>
<a name="note-that-i-still-hate-implicit-return-4" class="anchor" href="https://forum.rebol.info#note-that-i-still-hate-implicit-return-4"></a>Note That I Still Hate Implicit RETURN</h2>
<p>There's a reason the default FUNC doesn't do it.  If you start doing cool things with RETURN you'll break things in a way that lurks.</p>
<p>Sample cool thing that works today:</p>
<pre><code> foo: func [x y] [
     return: adapt augment :return [arg2] [
         value: meta ((unmeta value) + arg2)  ; return ^VALUE is meta
     ]
     if x &gt; 10 [
         return x y  ; arity 2 return, adds args and returns sum!
    ]
]

&gt;&gt; foo 20 30
== 50

&gt;&gt; foo 5 5
== ~  ; anti
</code></pre>
<p>If anything, I feel like the trash result isn't going far enough--and it should actually error if you skip out on a return.  Maybe there was some important finalization work to do.</p>
<p>But my example shows that putting it in implicitly means it doesn't necessarily roll with whatever updated definition you give to return.  You'll just get a confusing error in a bit of hidden code.  Not good for a fundamental part.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/making-func-variant-that-auto-returns-last-result/2124">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/making-func-variant-that-auto-returns-last-result/2124</link>
          <pubDate>Thu, 18 Jan 2024 19:23:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2124</guid>
          <source url="https://forum.rebol.info/t/making-func-variant-that-auto-returns-last-result/2124.rss">Making FUNC Variant That Auto-Returns Last Result</source>
        </item>
        <item>
          <title>Custom Function Generator Pitfalls</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>I commonly write function generators that put in some boilerplate to make some variables and service routines available to the generated function.  But these frequently have weaknesses, and I thought I'd write up an example to illustrate...and explain some ways to mitigate the problems.</p>
<h2>
<a name="example-promise-generator-with-resolve-and-reject-1" class="anchor" href="https://forum.rebol.info#example-promise-generator-with-resolve-and-reject-1"></a>Example: PROMISE Generator With RESOLVE and REJECT</h2>
<p>Imagine I want to make a function variation that's like a JavaScript promise, with a RESOLVE and REJECT...which are defined per-promise.</p>
<p>Let's say the first cut of the new generator looks something like this:</p>
<pre><code>promise: func [spec body] [
    body: compose [
        let resolve: lambda [result] [  ; lambdas lack their own return
            some code here
            return whatever  ; intending return of generated FUNC
        ]
        let reject: lambda [error] [
            more code here
            return whatever
        ]
        (spread body)  ; code here should see RESOLVE and REJECT 
    ]
    return func spec body
]
</code></pre>
<p>When the frame is created for the new function, it will run this body that's been extended with some boilerplate.  But that frame's arguments could have the name of any of the functions you're using in the bodies of RESOLVE or REJECT.  e.g. what if I said <strong><code>foo: promise [code /more] [...]</code></strong> ... the implementations of RESOLVE and REJECT would be disrupted from what they thought the words they had used meant.</p>
<p>Once you notice this, you might think the solution is to pre-compute more things:</p>
<pre><code>promise: func [spec body] [
    body: compose [
        let resolve: ^(lambda [result] [
            some code here
            return whatever
        ])
        let reject: ^(lambda [error] [
            more code here
            return whatever
        ])
        (spread body)  ; code here should see RESOLVE and REJECT 
    ]
    return func spec body
]
</code></pre>
<p><em>(Note use of ^META group in order to turn the isotopic frame produced by FUNC into a quasi frame, so that under evaluation in the function body it becomes isotopic again.  The compose would fail if you tried to compose the isotopic frame in directly.)</em></p>
<p>That's a bit better in terms of insulating the boilerplate code from stray bindings coming from the user-supplied spec (though there's still the weakness of LET if the user wrote something like <strong>promise [let [integer!]] [...]</strong>, which if you cared you could address by composing :LET in as its literal function value).</p>
<p>But it does too good a job: the COMPOSE runs during the PROMISE fabrication time, and so the notion of RETURN used by RESOLVE and REJECT are is the return for the PROMISE generator itself... not the produced FUNC as intended.  This is true of anything else you need to have picked up from the instance (let's say REJECT was implemented in terms of RESOLVE, or needed some other local).</p>
<p>One way of addressing this would be to slip the instance RETURN in as a parameter, e.g. via specialization of the precomputed code:</p>
<pre><code>promise: func [spec body] [
    body: compose [
        let resolve: specialize ^(lambda [result ret] [
            some code here
            ret whatever
        ]) [ret: :return]
        let reject: specialize ^(lambda [error ret] [
            more code here
            ret whatever
        ]) [ret: :return]
        (spread body)  ; code here should see RESOLVE and REJECT 
    ]
    return func spec body
]
</code></pre>
<p>There you've got an added assumed term which can break things, e.g. <strong><code>promise [let [integer!] specialize [block!]] [...]</code></strong> or similar.  But at least <strong>some code here</strong> and <strong>more code here</strong> are running under the understandings that the PROMISE generator author had of what those implementations meant.</p>
<p>Once you've separated out that which can be precomputed vs. that which can't, there's no need to make the precomputed part every time:</p>
<pre><code>promise-resolve*: lambda [result ret] [
    some code here
    ret whatever
]

promise-reject*: lambda [error ret] [
    more code here
    ret whatever
]

promise: func [spec body] [
    body: compose [
        let resolve: specialize :promise-resolve* [ret: :return]
        let reject: specialize :promise-reject* [ret: :return]
        (spread body) 
    ]
    return func spec body
]
</code></pre>
<h2>
<a name="could-some-kind-of-compile-operation-help-2" class="anchor" href="https://forum.rebol.info#could-some-kind-of-compile-operation-help-2"></a>Could Some Kind of COMPILE Operation Help?</h2>
<p>Weaknesses due to redefinitions of things like LET and SPECIALIZE makes me wonder if situations like this could be helped by an operation that would replace words that look up to functions with references to the functions.  <a href="https://forum.rebol.info/t/more-comprehensible-errors-with-per-cell-labeling/1357">The cell can retain the symbol for the word</a>, which can make debugging and errors more tolerable.</p>
<pre><code>promise: func [spec body] [
    body: compose (compile [let specialize] [
        let resolve: specialize :promise-resolve* [ret: :return]
        let reject: specialize :promise-reject* [ret: :return]
        (spread body) 
    ])
    return func spec body
]
</code></pre>
<p>Merging with COMPOSE would be more efficient, and could help cue that you want to avoid compiling the things in GROUP!s.  Maybe it could assume you wanted to compile references to actions unless you threw in some kind of escaping:</p>
<pre><code>promise: func [spec body] [
    body: compile [
        let resolve: specialize :promise-resolve* [ret: $ :return]
        let reject: specialize :promise-reject* [ret: $ :return]
        (spread body) 
    ]
    return func spec body
]
</code></pre>
<p>I've thought about this kind of thing for a while, but never got around to writing it.</p>
<h2>
<a name="paranoia-plus-efficiency-body-as-group-vs-spliced-3" class="anchor" href="https://forum.rebol.info#paranoia-plus-efficiency-body-as-group-vs-spliced-3"></a>Paranoia Plus Efficiency: Body As GROUP! vs. Spliced</h2>
<p>One improvement to this code is to splice the body as a group instead of spreading it itemwise in a block.</p>
<p>To see why this matters, consider something like:</p>
<pre><code>func-with-a-as-one: func [spec body] [
    return func spec compose [
        let a: 1
        (spread body)
    ]
]
</code></pre>
<p>Now let's say someone wrote:</p>
<pre><code>&gt;&gt; test: func-with-a-as-one [x] [+ 9, return a + x]

&gt;&gt; test 1000
== 1010  ; not 1001
</code></pre>
<p>Accidentally or intentionally, the function was defined as:</p>
<pre><code>func [x] [
   let a: 1
   + 9, return a + x
]
</code></pre>
<p>You can avoid this by quarantining the body, using <strong>(as group! body)</strong> instead of <strong>(spread body)</strong> in the COMPOSE.</p>
<pre><code>func [x] [
   let a: 1
   (+ 9, return a + x)
]
</code></pre>
<p>As an added benefit, the AS alias is cheaper memory-wise than copying the elements in item-wise (though it adds one extra GROUP! evaluation step to the function).</p>
<h2>
<a name="another-loophole-what-if-resolvereject-are-args-4" class="anchor" href="https://forum.rebol.info#another-loophole-what-if-resolvereject-are-args-4"></a>Another Loophole: What If RESOLVE/REJECT Are Args?</h2>
<p>If you use LET, currently that will override whatever definition is in play.  So if someone were to write <strong>promise [x y reject] [...]</strong> they'd not be able to see the REJECT argument, and wouldn't get an error.</p>
<p>You can force an error by dropping the LETs, and expanding the specification to include <strong></strong> definitions.</p>
<pre><code>promise: func [spec body] [
    body: compile [
        resolve: specialize :promise-resolve* [ret: $ :return]
        reject: specialize :promise-reject* [ret: $ :return]
        (as group! body) 
    ]
    return func compose [(spread spec) &lt;local&gt; resolve reject] body
]
</code></pre>
<p>So that's just sort of a peek into the effort it would take to make a relatively hygienic function generator.  Some things like worrying about taking SPECIALIZE as an argument might be beyond the concerns of the average one-off task.  But if you write a bunch of indiscriminate boilerplate using arbitrary words to refer to functions, it's very easy to get bitten when an argument reuses those words.</p>
            <p><small>15 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/custom-function-generator-pitfalls/2093</link>
          <pubDate>Sat, 06 Jan 2024 11:29:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2093</guid>
          <source url="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093.rss">Custom Function Generator Pitfalls</source>
        </item>
        <item>
          <title>Tail Calls in Ren-C...Yes, We Have Them</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Looking into some of <a href="https://forum.rebol.info/t/the-sherman-rebol-to-scheme-compiler/2076">Joe Marshall's historical participation in Rebol</a>, he speaks about Rebol 1.0 having "continuations" and "tail calls".</p>
<p>Ren-C uses continuations to implement <a href="https://forum.rebol.info/t/stackless-is-here-today-now/1844">stacklessness, based on a trampoline</a>.  Trampolines are generally slower than the fiddly technique Joe describes Rebol 1.0 as having used--but such fiddly methods are not standard C, and do not translate well to WebAssembly.  In any case, the outcomes are similar.</p>
<p>Tail calls are a different feature.  But if you have continuations, then your code is likely structured in such a way that tail calls are not that difficult to add.</p>
<h2>
<a name="so-what-is-a-tail-call-1" class="anchor" href="https://forum.rebol.info#so-what-is-a-tail-call-1"></a>So What Is A Tail Call?</h2>
<p>When you invoke a function, the interpreter has to allocate some space for its arguments and locals.  This information is then associated with a stack level structure, which also takes some space... and is put in a chain representing the call stack.</p>
<p>If that function calls itself recursively, the recursion will also need new stack space for its arguments and locals...and another stack level structure.</p>
<p>With recursive algorithms where a function calls itself hundreds or thousands of times, you can use up a lot of memory (and/or generate a stack overflow).</p>
<p>Tail calls are based on the observation that right at the moment a function is about to return, it doesn't need its stack level or arguments/locals anymore.  So if you're willing to have your call stack suffer some amount of "amnesia" about the "real" stack depth, you can reuse the current call's stack level for a recursion.</p>
<h2>
<a name="ren-c-supports-explicit-tail-calls-with-returnrun-2" class="anchor" href="https://forum.rebol.info#ren-c-supports-explicit-tail-calls-with-returnrun-2"></a>Ren-C Supports Explicit Tail Calls With RETURN/RUN</h2>
<p>There are two forms of tail call we can do in a Rebol-like interpreter.  The first style can call any function (not just the one you're returning from).  It avoids a recursion level on the stack, but does <em>not</em> reuse the memory for arguments and locals.</p>
<p>This is what that looks like:</p>
<pre><code>foo: func [return: [tag!] n] [
    if n = 1 [
        return &lt;success&gt;
    ]
    return/run :foo n - 1
]

&gt;&gt; foo 100
== &lt;success&gt;
</code></pre>
<p>That triggers 100 calls to FOO, but only using one level of stack depth.</p>
<p>There's a fairly obvious technical reason why this variation cannot build the invocation for the recursion's N into the old stack frame's N argument... <em>it uses the old N (as <code>n - 1</code>) to calculate the new N</em>.  You can't calculate new parameters into old parameter slots without winding up referencing your intermediate calculations instead of the old values you wanted.</p>
<p><em>(A compiled language could notice when old arguments were used to calculate new ones, and if it happened they could make space for temporary copies just for values that would be overwritten before they were seen...but being interpreted, we have to assume the worst and keep all the old values.)</em></p>
<p>If you really want to avoid making a new stack level <em>and</em> reuse the memory for the args and locals, you need a different approach.  Mutate the variables in-place before jumping to a restart of the function:</p>
<pre><code>foo: func [return: [tag!] n] [
    if n = 1 [
        return &lt;success&gt;
    ]
    n: n - 1
    return/run @redo
]

&gt;&gt; foo 100
== &lt;success&gt;
</code></pre>
<p>Modifying the variables in place means you're responsible for any dependency issues.  If you overwrite one of your arguments while calculating the next, you wrote the code in sequence and you can see what you did.</p>
<h2>
<a name="why-returnrun-foo-vs-return-foo-or-rerun-foo-3" class="anchor" href="https://forum.rebol.info#why-returnrun-foo-vs-return-foo-or-rerun-foo-3"></a>Why RETURN/RUN :FOO vs. RETURN FOO or RERUN FOO</h2>
<p>Ren-C's RETURN construct has special knowledge of what function it returns from.  It is a specialization of a generic DEFINITIONAL-RETURN function, which is specialized with the target FRAME!.  It's done in a somewhat optimized way, but still has some cost.</p>
<p>If tail calls were done with another construct--e.g. something like RERUN--that function would also need to be specialized with this knowledge.  It's cheaper to just piggy back on what RETURN already knows and make it a refinement.</p>
<p>As for why it has to take a GET-WORD! vs. plain WORD! for the function to invoke...this is due to RETURN not taking its first argument quoted.  So it's too late to intercept the mechanics of the call once an evaluation is run.  RETURN would receive the product of the call.</p>
<p>It winds up looking fairly natural, because the RUN construct runs a function that gathers its arguments inline:</p>
<pre><code>&gt;&gt; run :append [a b c] [d e]
== [a b c [d e]]
</code></pre>
<p><strong>Note that even if we could make tail calls implicit, we probably wouldn't want to.</strong>  Python hasn't added tail calls at all, based on a philosophical objection to the idea of obscuring the call stack.  It also seems like if an algorithm depends on tail calls for some important optimization reason, there should be something to indicate that fact... so that someone reorganizing the code will be sensitive to it.</p>
<h2>
<a name="how-important-are-tail-calls-4" class="anchor" href="https://forum.rebol.info#how-important-are-tail-calls-4"></a>How Important Are Tail Calls?</h2>
<p>If your language has a very limited amount of stack, being able to formulate your code to use tail calls so it doesn't accrue stack could be very important.</p>
<p>But if your language has a decent amount of stack (or is completely "stackless") it's not particularly important.</p>
<p>Where it matters are cases where an algorithm can be cleanly expressed in a recursive way, and you don't want to use an uglier representation that builds data structures which are mimicking what you would be getting naturally from the stack.</p>
<p>Using them in places that don't matter is likely just going to confuse your stack traces and error messages...like the Python people say.  I'd discourage going around and changing all your RETURN SOMETHING to RETURN/RUN :SOMETHING to try and speed things up.  Only do it if you're writing an algorithm that would have pathological stack use otherwise.</p>
<h2>
<a name="returnrun-had-a-precursor-redo-5" class="anchor" href="https://forum.rebol.info#returnrun-had-a-precursor-redo-5"></a>RETURN/RUN Had A Precursor... REDO</h2>
<p>The original formulation of tail calls wasn't built into RETURN, but expected you to work with a more generic tool called REDO.  This is what you had to write for the FOO example:</p>
<pre><code>foo: func [return: [tag!] n] [
    frame: binding of 'n
    if n = 0 [
        return &lt;success&gt;
    ]
    n: n - 1
    redo frame
]
</code></pre>
<p>This corresponds to the <strong><code>return/run @redo</code></strong> case, which takes advantage of the fact that RETURN already knows the frame it returns to, and can use that to redo.</p>
<p>But REDO had a shorthand for this case, which was to accept a word from a frame:</p>
<pre><code>foo: func [return: [tag!] n] [
    if n = 0 [
        return &lt;success&gt;
    ]
    n: n - 1
    redo 'n
]
</code></pre>
<p>This had led me to say <em>"sure, Ren-C has tail calls"</em>.  But I realized that didn't really look like what people would expect, so I made RETURN/RUN.</p>
<p>An added benefit of RETURN/RUN is that if you use it with the function call form (instead of <code>@redo</code>) then it offers something that REDO couldn't do, which is reuse an internal level structure for an arbitrary new function call.  It wasn't actually that hard to implement, so I went ahead and did it.</p>
<p>REDO is still around.  It can restart <em>any</em> frame or phase, and it's actually rather powerful.  I don't really use it, but here's an example of how tricky it can be:</p>
<pre><code>base: func [return: [text!] n delta /captured-frame [frame!]] [
    log [{BASE} n delta]

    n: n - delta
    if n &lt; 0 [return "base less than zero"]
    if n = 0 [return "base done"]
    if captured-frame [redo captured-frame]
    return "base got no frame"
]

c: chain [
    adapt :base [
       log [{C} n delta]

       captured-frame: binding of 'n
       redo/sibling 'n :s

       comment {fall through to base}
    ]
    lambda [x] [
        if x = "base done" [
            &lt;success&gt;
        ] else [
            spaced ["base exited with" x]
        ]
    ]
]

s: specialize adapt :base [
    log [{S} n delta]

    if n = 1 [n: 10]
][
    delta: 10
]

&gt;&gt; c 11 0
== &lt;success&gt;
</code></pre>
<p>With a logging function attached, that gives:</p>
<pre><code> --- C ---
 n: =&gt; 11
 delta: =&gt; 0
 --- S ---
 n: =&gt; 11
 delta: =&gt; 10
 --- BASE ---
 n: =&gt; 11
 delta: =&gt; 10
 --- C ---
 n: =&gt; 1
 delta: =&gt; 10
 --- S ---
 n: =&gt; 1
 delta: =&gt; 10
 --- BASE ---
 n: =&gt; 10
 delta: =&gt; 10
</code></pre>
<ul>
<li>
<p>C is called and captures its frame into F.  Then it uses REDO/SIBLING to reuse the frame to call S.  S gets the variables and args that it knows about as C left them--such as N and a captured frame F--but values it takes for granted are reset, which includes specialized delta of 10.</p>
<p><em>(The need to reset specializations for consistency is similar to how locals must be reset--they're not part of the interface of the function, so to reach beneath them does something illegal in terms of parameterization.)</em></p>
</li>
<li>
<p>S doesn't have any effect besides resetting delta, so it falls through as an adaptation to the base function.  BASE subtracts DELTA from N to get 1, which isn't an exit condition.  The F frame which was set in C and was preserved as an argument to S is then used by BASE to REDO and get back up to the start of C again.</p>
</li>
<li>
<p>Once again C captures its frame and does a REDO to start up S, which now notices that N is 1 so it bumps it up to 10.  (It cannot set DELTA to 1, because as a specialized argument DELTA is not visible to it.)  This time when it falls through to BASE, the subtraction of DELTA from N yields zero so that BASE returns completion.</p>
</li>
<li>
<p>Since the function we originally called and built a frame for was a CHAIN, the REDO is effectively REDO-finishing the frame for the adaptation of BASE that sits at the head of the frame.  That delegation has now finished bouncing around on that single frame and come to a completion, which means the chained functions will get that result.  The string is translated to a tag and signals success.</p>
</li>
</ul>
<h2>
<a name="all-pretty-crazy-stuff-you-probably-wont-use-6" class="anchor" href="https://forum.rebol.info#all-pretty-crazy-stuff-you-probably-wont-use-6"></a>All Pretty Crazy Stuff You Probably Won't Use</h2>
<p><img src="https://forum.rebol.info/images/emoji/twitter/crazy_face.png?v=12" title=":crazy_face:" class="emoji only-emoji" alt=":crazy_face:" loading="lazy" width="20" height="20"></p>
<p>But it's there, to placate people who think a language has to have tail calls to get respect.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/tail-calls-in-ren-c-yes-we-have-them/2082">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/tail-calls-in-ren-c-yes-we-have-them/2082</link>
          <pubDate>Mon, 18 Dec 2023 03:58:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2082</guid>
          <source url="https://forum.rebol.info/t/tail-calls-in-ren-c-yes-we-have-them/2082.rss">Tail Calls in Ren-C...Yes, We Have Them</source>
        </item>
        <item>
          <title>Dialect Meaning of Non-Words in Function Parameter Spec Blocks</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Historical Redbol only had WORD!s in the BLOCK! that came after a parameter:</p>
<pre><code>foo: func [
    arg [block! word! number!]  ;  all words in block
] ...
</code></pre>
<p>But when Ren-C introduced the paradigm-breaking NULL that could not be put in arrays, that meant there was no <code>null!</code> datatype.  To fill the gap, the tag <code>&lt;opt&gt;</code> was chosen to indicate the parameter as optional--hence possibly null:</p>
<pre><code>foo: func [
    arg [&lt;opt&gt; block! word! number!]  ;  now it's WORD!s and TAG!s
] ...
</code></pre>
<p>I liked using a TAG! for how it stood out (though in retrospect I'd have probably chosen <code>&lt;null&gt;</code>, but everything was named differently then).  Other quirky ideas were floated, like being able to put a leading slash on the typeset block:</p>
<pre><code>foo: func [
    arg /[block! word! number!]  ; like a refinement, but on the types
] ...
</code></pre>
<p>That didn't gain traction, and probably shouldn't have.</p>
<p>Then when early efforts faced another value state that couldn't be put in a block and didn't have a type, <strong><code>&lt;void&gt;</code></strong> came onto the scene...because as with there being no NULL!, there was no VOID! datatype.</p>
<h2>
<a name="tag-modifiers-which-werent-type-checkers-showed-up-1" class="anchor" href="https://forum.rebol.info#tag-modifiers-which-werent-type-checkers-showed-up-1"></a>Tag Modifiers Which Weren't Type Checkers Showed Up</h2>
<p>The ability to take a parameter but get an immutable view of it was added as <strong><code>&lt;const&gt;</code></strong>.</p>
<p>Parameters that would accept being at the end of input and evaluate to null in that case were <strong><code>&lt;end&gt;</code></strong></p>
<p><strong><code>&lt;variadic&gt;</code></strong> and <strong><code>&lt;skippable&gt;</code></strong> came into existence.</p>
<p>These "parameter-control tags" seemed to me to be a distinct category from typecheckers like <strong><code>&lt;opt&gt;</code></strong> and <strong><code>&lt;void&gt;</code></strong>.   Having them all use TAG! felt like <em>too many tags.</em></p>
<p>So I mused about splitting the roles, something like:</p>
<pre><code>[&lt;const&gt; #null type!]
-or-
[#const &lt;null&gt; type!]
</code></pre>
<p>But I didn't like the look of it enough to move on it.  So things like <strong><code>[&lt;const&gt; &lt;opt&gt; type!]</code></strong> stuck around while I wondered about it.</p>
<h2>
<a name="today-you-can-specify-any-type-check-by-function-2" class="anchor" href="https://forum.rebol.info#today-you-can-specify-any-type-check-by-function-2"></a>Today, You Can Specify Any Type Check By Function</h2>
<p>There's still no NULL! or VOID!.  But with the way things work now, you can use functions as "type predicates" to recognize things that aren't datatypes in their own right:</p>
<pre><code>foo: func [
    arg [null? block! word! number!]
] ...
</code></pre>
<p>What's good:</p>
<ul>
<li>It leaves TAG! for the properties like <strong><code>&lt;const&gt;</code></strong> that don't have to do with type recognition... but rather controlling the parameter in a more special way.</li>
</ul>
<p>What's bad:</p>
<ul>
<li>It loses that kind of special look that tags gave to arguments that could take null.  It blurs together, especially with things like SPLICE? and LOGIC? and CHAR? for other non-fundamental datatypes (characters are just single-character issues now, and ~true~ and ~false~ isotopes of WORD! implement logic)</li>
</ul>
<h2>
<a name="a-modern-option-null-for-taking-null-3" class="anchor" href="https://forum.rebol.info#a-modern-option-null-for-taking-null-3"></a>A Modern Option: ~NULL~ for Taking Null</h2>
<p>I made an experiment so if you used a QUASI-WORD!, then it would match an isotope of that form.</p>
<p>It's a kind of pleasingly distinct look:</p>
<pre><code>foo: func [
    arg [~null~ block! word! number!]
] ...
</code></pre>
<p>And it mixes better with the tags:</p>
<pre><code>foo: func [
    arg [~null~ &lt;const&gt; block! word! number!]
] ...
</code></pre>
<p>It also works for "trash" (isotopic voids) and doesn't look too bad there, e.g. for RETURN:</p>
<pre><code>foo: func [
    return: [~]  ; as opposed to `return: [trash?]`
 ] ...
</code></pre>
<p>That doesn't work for voids, and the current idea is that there's no VOID! because TYPE OF VOID gives back NULL.  This is consistent with void-in-null out in general, although it might confuse people who expect to do:</p>
<pre><code>switch type of value [
    null [print "This means value was void, not null"]
    ...
]
</code></pre>
<p>So the idea there was that perhaps TYPE OF NULL is an error, and this guides you to another solution like <strong>switch/type</strong> where you can use <strong>&amp;[null?]</strong> or <strong>&amp;[void?]</strong> as type predicates and get what you actually want.</p>
<p><em>(I still don't think defining <strong>null!: &amp;[null?]</strong> is a good idea, because it looks like a fundamental datatype, and you cannot <strong>make null! ...</strong> etc.  Maybe <strong>null?!: &amp;[null?]</strong> or something like that would be a bit less noisy at usage sites, enough to be worth it?)</em></p>
<h2>
<a name="allowing-null-and-null-as-choices-seems-good-4" class="anchor" href="https://forum.rebol.info#allowing-null-and-null-as-choices-seems-good-4"></a>Allowing NULL? and ~NULL~ As Choices Seems Good</h2>
<p>I think we can live with <strong>void?</strong> in function specs for functions that deliberately take voids.  It's also more legitimate--voids are more neutral than nulls in the current formulation--e.g. <strong>append [a b c] void</strong> is [a b c].</p>
<p>I like the option of <strong>~null~</strong> instead of <strong>null?</strong> to call out the more rare-and-alarming idea of accepting null parameters.</p>
<h2>
<a name="what-about-return-nihil-and-return-trash-5" class="anchor" href="https://forum.rebol.info#what-about-return-nihil-and-return-trash-5"></a>What about <code>return: &lt;nihil&gt;</code> and <code>return: &lt;trash&gt;</code>
</h2>
<p>These two special uses of tag! with no block have been used to say you don't need a RETURN statement at all... the function just gives back none or nihil respectively when the body completes.</p>
<p>How necessary is it?  Well, you either write things like:</p>
<pre><code>comment: func [
    return: [nihil?]
    discarded [any-value!]
][
    return nihil
]
</code></pre>
<p>Or you have the contraction:</p>
<pre><code>comment: func [
    return: &lt;nihil&gt;
    discarded [any-value!]
][
]
</code></pre>
<p>This style of "don't even worry about writing a RETURN" has the widest applicability to NONE and NIHIL.  We don't strictly need it, but I've gotten used to it.</p>
<p>I mention <strong>return: [~]</strong> as a possible alternative for saying trash is a return type using the quasiform-means-isotope idea.  And since trash falls out of function bodies by default with no return, it's not strictly necessary to have <strong><code>return: &lt;trash&gt;</code></strong> as any kind of special operation.</p>
<p>Again, how does that look?</p>
<pre><code>foo: func [
    return: [~]
 ] ...
</code></pre>
<p>If you're going to break the pattern and not say <strong><code>return: [trash?]</code></strong>  then I may call that a break-even alternative to <strong><code>return: [trash?]</code></strong>.  A little more symbol-y, but doesn't break the rhythm of type specs being blocks.</p>
<p>This leaves the nihil case.  We could say <strong>return: [~[]~]</strong> and have that mean "I return an empty pack" but in that case you'd still need an explicit return:</p>
<pre><code>comment: func [
    return: [~[]~]
    discarded [any-value!]
][
    return nihil
]
</code></pre>
<p>But I think I like <strong><code>return: [nihil?]</code></strong> better than that.  Compared to <strong><code>return: [~]</code></strong> the <strong><code>[~[]~]</code></strong> is a bridge too far.</p>
<p>Anyway, the reason this is a struggle is that <strong><code>return: &lt;trash&gt;</code></strong> has just become so pervasive that it's hard to see that changed to <strong><code>return: [trash?]</code></strong>.  But standardizing on blocks and moving away from the tags for this application may be the best idea.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/dialect-meaning-of-non-words-in-function-parameter-spec-blocks/2064">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dialect-meaning-of-non-words-in-function-parameter-spec-blocks/2064</link>
          <pubDate>Sat, 25 Nov 2023 08:25:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2064</guid>
          <source url="https://forum.rebol.info/t/dialect-meaning-of-non-words-in-function-parameter-spec-blocks/2064.rss">Dialect Meaning of Non-Words in Function Parameter Spec Blocks</source>
        </item>
        <item>
          <title>About the Functions category</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Discussions of Functions and Generators, e.g. how things like RETURN work... or the mechanics of generators and composers like ADAPT, SPECIALIZE, ENCLOSE, HIJACK, etc.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/about-the-functions-category/1931">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/about-the-functions-category/1931</link>
          <pubDate>Sat, 20 Aug 2022 07:39:08 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1931</guid>
          <source url="https://forum.rebol.info/t/about-the-functions-category/1931.rss">About the Functions category</source>
        </item>
        <item>
          <title>Should RETURN be Assignable on Function Interfaces?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>When implementing multi-returns I had an idea, to think of <strong><code>[x]: negate 10</code></strong> in terms of slipping X into the RETURN: slot of NEGATE as an input.</p>
<p>On the surface that seems like it might even be useful more generally:</p>
<pre><code> &gt;&gt; f: make frame! :negate

 &gt;&gt; negate.return: 'x  ; X gets hidden, and RETURN is redefined during the call

 &gt;&gt; negate.value: 10

 &gt;&gt; do f  ; the hidden X is written back automatically
 == -10

 &gt;&gt; x
 == -10
</code></pre>
<h2>But Not Every Action is a FUNC/FUNCTION</h2>
<p>Not all functions are guaranteed to have something in their frame called RETURN (e.g. a LAMBDA does not).  And a non-FUNC ACTION! could have something in its frame called RETURN that wasn't used for anything pertaining to the return process.</p>
<p>This ruled it out from being a mechanic relied on by the multi-return machinery.  Because we want the following to work:</p>
<pre><code>&gt;&gt; test: lambda [x] [x + 20]

&gt;&gt; [y]: test 1000
== 1020

&gt;&gt; y
== 1020
</code></pre>
<h2>Nevertheless, People Can Implement It If They Want</h2>
<p>It's certainly something you could <em>choose</em> to do if you were writing your own function generator.</p>
<p>In fact, it's trivial to write a wrapper for it!  Just add a /RETURN to the public interface, and write back to it if it's supplied:</p>
<pre><code>returnproxy: lambda [action [action!]] [
    enclose (augment :action [/return [word!]]) f -&gt; [
        (maybe f.return): do f
    ]
]
</code></pre>
<p>That means you can pass it as a refinement:</p>
<pre><code>&gt;&gt; test: lambda [x] [x + 1000]

&gt;&gt; wrapper: returnproxy :test

&gt;&gt; wrapper/return 20 'y
== 1020

&gt;&gt; y
== 1020
</code></pre>
<p>Or you can use it with a frame:</p>
<pre><code>&gt;&gt; f: make frame! :wrapper
&gt;&gt; f.x: 20
&gt;&gt; f.return: 'out

&gt;&gt; do f
== 1020

&gt;&gt; out
== 1020
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/nut_and_bolt.png?v=9" title=":nut_and_bolt:" class="emoji only-emoji" alt=":nut_and_bolt:"></p>
<p><em>(Seeing superpowers like this work so clearly and obviously is what keeps me invested in this.)</em></p>
<h2>So Anyone CAN Do It, But Should FUNC/FUNCTION Do It?</h2>
<p>I lean toward not doing it with things implemented the way they are right now, because it would add overhead to every function with a RETURN:, due to needing to have a place to store the variable if you gave it one.</p>
<p>But it might be nice to give people an optimized version of the proxying wrapper above.  You could then convert any function to support it.</p>
<h2>But today RETURN is on the public interface of FUNC <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:">
</h2>
<pre><code>&gt;&gt; f: make frame! func [x] [return x + 1000]
== make frame! [
    return: ~
    x: ~
]
</code></pre>
<p><em>"Errr.  Why's it there?"</em>, you might ask.</p>
<p>The reason is that the return typeset information currently lives on that field.  So if you're going to ask about it, you get it from there.</p>
<p><strong>This is one of many good arguments for why this information should <em>not</em> live there.</strong></p>
<p>There's a long running body of evidence suggesting that the way return types are managed today is probably wrong.</p>
<ul>
<li>
<p><strong>LAMBDA Can't Currently Document Its Result Types</strong>.  There are a lot of actions out there that don't have a RETURN function, but nevertheless have something to say about what types they can produce.</p>
</li>
<li>
<p><strong>ENCLOSE Can't Change The Type Signature</strong>.  If you wrap a function, you're subject to its type checking rules.</p>
</li>
<li>
<p><strong>NATIVE Doesn't Want To Pay For A RETURN Slot</strong>.  The typechecking is only done in the debug build, so why should every native frame require a RETURN function?</p>
</li>
</ul>
<p>I think I've got some ideas coming together--mostly centering on factoring out typechecking to be another one of the little pieces you can build functions out of (like AUGMENT).  So when doing a composition you would just bolt on a typechecker if you wanted one.  Internal efficiencies could fold that in so it actually didn't generate a separate phase and action identity.  Pursing some inspiration on that as we speak...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-return-be-assignable-on-function-interfaces/1929">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-return-be-assignable-on-function-interfaces/1929</link>
          <pubDate>Sat, 20 Aug 2022 05:32:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1929</guid>
          <source url="https://forum.rebol.info/t/should-return-be-assignable-on-function-interfaces/1929.rss">Should RETURN be Assignable on Function Interfaces?</source>
        </item>
        <item>
          <title>(No) Alternative Local Notation in the Func Spec Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <h1>TL;DR:</h1>
<p>When using a spec in FUNCTION (remember <a href="https://forum.rebol.info/t/abbreviations-as-synonyms/1211">FUNC is a synonym now</a>):</p>
<ul>
<li>
<p><strong>if you want to specify locals you say <code>[... &lt;local&gt; x y z ...]</code></strong> (/LOCAL is a normal refinement like any other in Ren-C.</p>
</li>
<li>
<p><strong>there is no longer a datatype-based shortcut for locals as a way to save the trouble of finding <code>&lt;local&gt;</code> in specs and inserting at the right point</strong>.</p>
<ul>
<li>
<p>Once you could toss random SET-WORD!s anywhere in a spec, like <strong><code>[a b c: d]</code></strong> and it would act like <strong><code>[a b d &lt;local&gt; c]</code></strong>.  This feature was to make higher-level function generators easier to write, to save them from having to find <code>&lt;local&gt;</code> in the spec...add it if not there...and do everything at the right point.</p>
</li>
<li>
<p>When multi-returns began using SET-WORD! this was changed to be <strong><code>[a b .c d]</code></strong> just to move it out of the way.</p>
</li>
<li>
<p>What this was trying to achieve has been obsoleted by newer and better methods, which actually entwine with the idea that <em>you should never know what local variables a function you are composing on top of has</em>.</p>
</li>
</ul>
</li>
</ul>
<h1>More Explanation</h1>
<p>Long ago, when I was looking at some of the higher-level function generators (like FUNCT on top of FUNCTION) I was struck by how tricky it was to get the adaptations written correctly.</p>
<p>We can look at <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/mezz/base-funcs.r#L28">FUNCT from R3-Alpha</a> and see some of that complexity, even just to try and add some local variables.</p>
<p>It had to check to see if there was already a /LOCAL, and add it if not:</p>
<pre><code>; Copy the spec and add /local to the end if not found
unless find spec: copy/deep spec /local [append spec [
	/local ; In a block so the generated source gets the newlines
]]
</code></pre>
<p><em>Bear in mind that specifying /LOCAL twice would be a duplicate refinement error, and /LOCAL did not have to be at the end of a spec.</em>  Things were tricky, because there were "private refinements".  These refinements were an artifact of how help worked--they were not shown--but weren't actually private.</p>
<p>So you had to be careful, to insert things after local but not after the private refinements, or they'd be arguments to those refinements:</p>
<pre><code>; Collect all set-words in the body as words to be used as locals, and add
; them to the spec. Don't include the words already in the spec or object.
insert find/tail spec /local collect-words/deep/set/ignore body either with [
   ...
]
</code></pre>
<p><strong>I wanted to take better advantage of datatypes, so I adopted the TAG! <code>&lt;local&gt;</code> in the spec so that /LOCAL could be used like any other refinement... e.g. GET-TIME/LOCAL or GET-LANGUAGE/LOCAL.</strong>  This is an idea preserved to this day, and I think it's a better move (though LET has been developing as the more viable general option for making locals).</p>
<p>But another concept I had was to make SET-WORD! in the dialect be another way to put a local anywhere in the spec.  So if you were writing code munging function specs you could just throw local variables on:</p>
<pre><code>foo: func [a b c: d] [...]

&lt;= equivalent to =&gt;

foo: func [a b d &lt;local&gt; c] [...]
</code></pre>
<p>But the idea was that <code>&lt;local&gt;</code> itself was transformed into the SET-WORD!, so the only language you needed to understand was that of the SET-WORD!s:</p>
<pre><code>&gt;&gt; foo: func [a b d &lt;local&gt; c] [...]

&gt;&gt; spec-of :foo
== [a b d c:]
</code></pre>
<p>When multi-returns came about and took SET-WORD!s, this idea was bumped around to be done with TUPLE!s with leading blanks like <strong>.c</strong></p>
<h1><a href="https://www.youtube.com/watch?v=2q9MaEKHakY">... but Everything Changed <img src="https://forum.rebol.info/images/emoji/twitter/robot.png?v=9" title=":robot:" class="emoji" alt=":robot:"> ...</a></h1>
<p>I've been marching toward something more like <a href="https://forum.rebol.info/t/seeing-all-action-s-as-variadic-frame-makers/1002">"Seeing all ACTION!s as Variadic Frame Makers?"</a></p>
<p>Function composition tools operate on FRAME!s using tools like ADAPT, SPECIALIZE, AUGMENT, ENCLOSE, etc.  There is no API for getting at the locals <em>because when you build on top of a function you can't see them, they're not part of the interface...they are sealed inside.</em>   This is good because you can build on top of a function without worrying about the details of the parts from which it was composed.</p>
<p>The migration to where <a href="https://forum.rebol.info/t/pure-and-refined-simplifying-refinements-to-one-or-zero-args/1120">refinements are their own arguments</a> has been key in making function calls easier to model as an object.</p>
<p><strong>In this world we do not need a representation for locals in the spec to add them...because the entire concept of how FUNCT was written is gone.</strong>  If you want to add locals you use tools like AUGMENT and don't worry about it.</p>
<h1>There Are Still (many) Problems To Solve</h1>
<p>Consider that you can do something like ask for a FRAME! of something like APPEND, then enumerate the keys:</p>
<pre><code>&gt;&gt; f: make frame! :append

&gt;&gt; for-each key f [print mold key]
return
series
value
part
dup
line
only
</code></pre>
<p>There are a lot of questions to answer about the unique nature of the main function's RETURN.  Although other multi-returns have to be on the interface, should you be able to put a variable in that return?  Consider that you could use multi-return with append today:</p>
<pre><code>&gt;&gt; [var]: append "abc" "d"
== "abcd"

&gt;&gt; var
== "abcd"
</code></pre>
<p>So should you be able to preload the frame with <strong>f.return: 'var</strong> and get the same effect?  This is competitive with the notion that RETURN is a concept of a local variable to the action, that holds an action that returns specifically from that action... so the responsibilities are somewhat murky for this distinguished result.</p>
<p>But we can also see that if we only look at object keys, we don't know which things are refinements or which are not...if they are refinements we don't know if they are 0-arg or 1-arg form, we don't know what types they take... or are they <code>&lt;end&gt;</code>-able.  <strong>I believe getting at this information should be done by means other than analysis of some spec block you filter out for description strings/etc. so that is on the right track.</strong>  But it's still a long road.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/no-alternative-local-notation-in-the-func-spec-dialect/1793">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/no-alternative-local-notation-in-the-func-spec-dialect/1793</link>
          <pubDate>Sat, 05 Mar 2022 20:33:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1793</guid>
          <source url="https://forum.rebol.info/t/no-alternative-local-notation-in-the-func-spec-dialect/1793.rss">(No) Alternative Local Notation in the Func Spec Dialect</source>
        </item>
        <item>
          <title>Implicit Execution of RETURN in functions = ...BAD (?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Let's say you write something like this:</p>
<pre><code>foo: func [
    return: [integer!]
    arg [integer! text! tag!]
][
    if integer? arg [
        return arg + 1000
    ]
    if text? arg [
        return reverse arg
    ]
    arg
]
</code></pre>
<p>I imagine you'd expect behavior along these lines:</p>
<pre><code>&gt;&gt; foo 20
== 1020

&gt;&gt; foo "whoops"
** Error: FOO doesn't have RETURN enabled for values of type TEXT!

&gt;&gt; foo &lt;bomb&gt;
** Error: FOO doesn't have RETURN enabled for values of type TAG!
</code></pre>
<p>Even though the last value just "falls out" of the function, you presumably don't want that to mean it escapes type checking just because it did.</p>
<h2>
<a name="mechanically-this-is-non-obvious-1" class="anchor" href="https://forum.rebol.info#mechanically-this-is-non-obvious-1"></a>Mechanically, this is Non-Obvious...</h2>
<p>RETURN is not actually supposed to be a "language feature" per se.  It's actually a feature of the higher-level generator FUNC...and there are lower-level ways of building functions that lack RETURNs.  <em>(If there weren't, how could you write the RETURN function itself?)</em></p>
<p>Plus it's fully overrideable.  You can set RETURN to some random integer if you feel like it...it's just a variable in the frame.  But more frequently you'd like to specialize or adapt it:</p>
<pre><code>bar: function [
    return: [integer!]
    arg [logic!]
][
    return: adapt :return [value: value + 300]
    if arg [
       return 4
    ]
    720
]

&gt;&gt; bar true
== 304
</code></pre>
<p>...but here we are at an interesting question.  What do you expect to happen with <strong>bar false</strong>?</p>
<pre><code>&gt;&gt; bar false
== 720  ; (A) values falling out of bottom *do not* run RETURN implicitly

&gt;&gt; bar false
== 1020  ; (B) values falling out of bottom *do* run RETURN implicitly
</code></pre>
<p>A usermode implementation of FUNC has a pretty easy trick to implement either behavior.  The question is simply if it takes the body you give it and turns it into a GROUP! and passes it to RETURN or not...</p>
<p><strong>"real body" option (A) for BAR above</strong></p>
<pre><code>[
    return: (make action! ...)  ; low level make return function
    (  ; no return here, just `as group! body`
        return: adapt :return [value: value + 300]
        if arg [
            return 4
        ]
        720
    )
]
</code></pre>
<p><strong>"real body" option (B) for BAR above</strong></p>
<pre><code>[
    return: (make action! ...)  ; low level make return function
    return (  ; automatic return injected
        return: adapt :return [value: value + 300]
        if arg [
            return 4
        ]
        720
    )
]
</code></pre>
<h2>
<a name="or-just-require-return-with-func-that-has-return-2" class="anchor" href="https://forum.rebol.info#or-just-require-return-with-func-that-has-return-2"></a>Or Just Require RETURN with FUNC that has RETURN: ?</h2>
<p><strong>strict option (C) for BAR above</strong></p>
<pre><code>[
   return: (make action! ...)  ; low level make return function
   (  ; automatic return injected
       return: adapt :return [value: value + 300]
       if arg [
           return 4
       ]
       720
    )
    fail "Functions which specify RETURN: must use RETURN"
]
</code></pre>
<p><a href="https://forum.rebol.info/t/how-attached-are-we-to-functions-return-last-result/1219">I've brought this up before</a>, and <a class="mention" href="https://forum.rebol.info/u/ingohohmann">@IngoHohmann</a> and <a class="mention" href="https://forum.rebol.info/u/iarnold">@iArnold</a> seemed to think "dropping out the last value" was somehow fundamental.</p>
<p>But given what I say above about how the semantics get pretty sketchy on type checking and such, what if we say that functions that don't specify RETURN have no return available, and just drop out their last result?</p>
<pre><code>bar1: function [
    arg [logic!]
][
    if arg [4] else [720]
]

&gt;&gt; bar true
== 4

&gt;&gt; bar false
== 720
</code></pre>
<p>You don't get type checking so you'd have to do it yourself, which will be available:</p>
<pre><code>bar1-checked: function [
    arg [logic!]
][
    let val: if arg [4] else [720]
    ensure integer! val
]
</code></pre>
<p>However: if you specify RETURN: in the spec then you are required to use it.  This gives you type checking and guarantee of running any return hooking on all code paths:</p>
<pre><code>bar2: function [
    return: [integer!]
    arg [logic!]
][
    return: adapt :return [value: value + 300]
    if arg [
       return 4
    ]
    return 720
]

&gt;&gt; bar true
== 304

&gt;&gt; bar false
== 1020
</code></pre>
<h2>
<a name="i-think-the-case-for-requiring-return-if-return-is-strong-3" class="anchor" href="https://forum.rebol.info#i-think-the-case-for-requiring-return-if-return-is-strong-3"></a>I Think The Case for Requiring RETURN if RETURN: Is Strong</h2>
<p><strong>It seems rather clear when laid out like I have above that it's the right answer.</strong>  People who hook RETURN are typically doing so because they want it on all return paths.  But I think hiding a RETURN behind the scenes is a cognitive time bomb.  Being explicit sorts that out, and it also provides a rational answer for why you get type checking...<em>the RETURN does the check</em>.</p>
<p><em>(I can tell you that without that rational answer, the internals have ugliness.  This policy will cleanse the ugliness.)</em></p>
<p>Lower-level functions that don't have RETURN have to have a way to return values.  Dropping them out the bottom seems a good way to start building up the mechanic.  It's also useful for quick and dirty "macro-like" functions, so I see no problem with that.</p>
<h2>
<a name="should-return-be-an-exception-4" class="anchor" href="https://forum.rebol.info#should-return-be-an-exception-4"></a>Should <code>return: [~]</code> be an Exception?</h2>
<p>The point of introducing this was to help remove concern over letting unwanted variables "fall out", and being able to forego concerns about type checking.  <strong>It's a different case</strong>, because there is no type checking involved of the parameter passed to RETURN as it takes no parameters...and there's no need to type check what falls out the bottom because it is discarded:</p>
<pre><code>something: func [
    return: [~]
    value [text!]
][
    if value = "" [return]  ; this RETURN acts as `return ~`
    append data value

    ; expectation has been that this would also yield ~
]
</code></pre>
<p>The idea was to make it painless to shield callers from seeing the returned result, and have them know there was no result they were supposed to pay attention to.</p>
<p>What gets me concerned here is that question of whether or not a hooked or modified RETURN is implicitly run at the end of such a function.</p>
<p>It seems to suck to have to put the RETURN there.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=12" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<pre><code>something: func [
    return: [~]
    value [text!]
][
    return: adapt :return [print "I AM RETURNING!"]
    if value = "" [return]
    append data value
    return  ; with this here, it's clear you will get the PRINT to happen
]
</code></pre>
<p>But it does benefit from the explicitness.  There's no ambiguity.</p>
<p><strong>Again, you have to use your imagination to think about a longer function in which there are many control paths through the function...and someone decides to hook RETURN.</strong>  If you are working in a large codebase with long functions, wouldn't you like to know that all control paths will run your hook...and that the language has gotten everyone on the same page that is expected and possible?</p>
<p><strong>My feeling in the moment is that the only answer I'd consider besides erroring if there's no RETURN would be to implicitly put a RETURN at the end, so a hooked RETURN would be executed if a value drops out the bottom.</strong>  But I've explained that for the other cases I think that's sneaky.  It feels much more forthright to have the call at source level.</p>
<p>Path of least resistance on this is to add the RETURN implicitly, so I'm going with that.</p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/implicit-execution-of-return-in-functions-bad/1656">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/implicit-execution-of-return-in-functions-bad/1656</link>
          <pubDate>Thu, 12 Aug 2021 19:00:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1656</guid>
          <source url="https://forum.rebol.info/t/implicit-execution-of-return-in-functions-bad/1656.rss">Implicit Execution of RETURN in functions = ...BAD (?)</source>
        </item>
        <item>
          <title>Resurrecting REDBOL-APPLY via Type Exposure</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>At one point, I had a simulation of the Rebol2/R3-Alpha APPLY working...all written in usermode code.</p>
<p>As a refresher: this concept of APPLY required you to line up things positionally--even refinements.  You had to look at the parameter order on the interface, and put "truthy" things in the refinement slots you wanted to enable.  Then if the refinement took argument(s), you would have to put that in the next slot.</p>
<p>So for R3-Alpha's APPEND, the ordered spec is:</p>
<pre><code>APPEND series value /part length /only /dup count
</code></pre>
<p>Let's say you wanted to do something equivalent to <strong>append/part/dup [a b c] [d e f] 2 3</strong>.  You would write:</p>
<pre><code>r3-alpha&gt;&gt; apply :append [[a b c] [d e f] true 2 false true 3]
== [a b c d e d e d e]
</code></pre>
<p>Here the first TRUE is to say we want to use the /PART...then the length of 2.  Then a FALSE to say we don't want /ONLY.  And then another TRUE to say we want /DUP, with the count as 3.</p>
<p>It's fairly convoluted, and brittle with respect to rearrangement.  But it offers you the benefit of being able to calculate whether you want to provide a refinement or not.  The block is reduced by default (with an /ONLY option to ask that it not be).</p>
<p>In the early days of frames, I thought it would be a good test to see if this exact function could be emulated by processing the block... building a FRAME!, and then DO'ing it.  So REDBOL-APPLY was written and added to the tests.</p>
<h2>
<a name="then-ren-c-became-pure-and-refinedhttpsforumrebolinfotpure-and-refined-simplifying-refinements-to-one-or-zero-args1120-1" class="anchor" href="https://forum.rebol.info#then-ren-c-became-pure-and-refinedhttpsforumrebolinfotpure-and-refined-simplifying-refinements-to-one-or-zero-args1120-1"></a>Then Ren-C Became <a href="https://forum.rebol.info/t/pure-and-refined-simplifying-refinements-to-one-or-zero-args/1120">Pure and Refined</a>...</h2>
<p>With the great improvement of refinements becoming their own arguments, came a new puzzle from an interface perspective.  Where it had used to say things like:</p>
<pre><code>ren-c-before&gt;&gt; parameters of :append
== [series value /part length /only /dup count]
</code></pre>
<p>It would now say:</p>
<pre><code>ren-c-after&gt;&gt; parameters of :append
== [series value /part /only /dup]
</code></pre>
<p>You might notice a piece of information gets lost there: <strong>which refinements take arguments at the callsite, vs. which ones don't</strong>.  Here the /ONLY looks just like the /PART and /DUP.  If you're going to have a REDBOL-APPLY that splits out the refinement on/off from the argument, you have to know if there is an argument to fill in.</p>
<p>I'll emphasize here that <strong>whether or not this particular APPLY primitive is desirable or not isn't the point.</strong>  It's a question of whether there's enough information.  And you have to have more than the parameter list above.</p>
<p>So one place people might have looked to would be the TYPESETS OF reflector, and maybe check to see if the typeset was empty (?)  But the typeset code was never all that good.</p>
<h2>
<a name="enter-the-new-as-frame-aliasing-ability-2" class="anchor" href="https://forum.rebol.info#enter-the-new-as-frame-aliasing-ability-2"></a>Enter The New AS FRAME! Aliasing Ability</h2>
<p>I only just pushed this a bit forward, so it's not stable yet.  But it was enough to get REDBOL-APPLY working.  Here's what the frame alias of APPEND looks like:</p>
<pre><code>&gt;&gt; as frame! :append
== #[frame! {append} [
    return : [any-series! port! map! object! module! bitset!]:
    series : [any-series! port! map! object! module! bitset!]
    value : [&lt;opt&gt; any-value!]
    part : /[any-number! any-series! pair!]
    only : /[]
    dup : /[any-number! pair!]
    line : /[]
]]
</code></pre>
<p>The keys can't hold the information about whether something is a refinement or quoted or not.  So those attributes are moved onto the BLOCK!.  Here we see that PART, ONLY, DUP, and LINE are refinements...while ONLY and LINE have no specified types.</p>
<h2>
<a name="and-heres-the-first-try-that-gets-the-tests-passing-again-3" class="anchor" href="https://forum.rebol.info#and-heres-the-first-try-that-gets-the-tests-passing-again-3"></a>And Here's The First Try That Gets The Tests Passing Again</h2>
<p>It's big and pokey.  And it trips over the weird parameter compaction a little bit... there's still a lot of questions about how you would take something that could either be <strong>':foo</strong> or <strong>/foo</strong> and extract plain <strong>foo</strong> out of it.  (It's not as obvious as you might think that "to word! should just do that".)</p>
<p>There's plenty of room for improvement.  But clumsy though it is, it shows some of the non-trivial meta-language behavior that I think can be put in the hands of mere mortals...in that Minecraft-of-programming way.  This really is letting people get intimately involved in the design of their own function generators and control structures...</p>
<pre><code>redbol-apply: func [
    return: [&lt;opt&gt; any-value!]
    action [action!]
    block [block!]
    /only
    &lt;local&gt; types arg key frame params mode
][
    types: as frame! :action  ; exemplar of types
    frame: make frame! :action  ; frame we are building
    params: parameters of :action  ; ordered list of parameters
    mode: &lt;normal&gt;

    ; Rebol2 and R3-Alpha APPLY would fill in NONE for any parameters that
    ; were not provided in the apply block:
    ;
    ;     rebol2/r3-alpha&gt;&gt; apply func [a b c] [reduce [a b c]] []
    ;     == [none none none]
    ;
    ; This means we need to enumerate and fill in the frame as long as there
    ; are parameters--not as long as there are block values.
    ;
    while [not tail? params] [
        case [
            not block [
                arg: null  ; could also do BLANK! if no more block data
            ]
            only [  ; /ONLY means do not evaluate arguments
                arg: get/any 'block/1
                block: next block
            ]
            true [  ; evaluate (skipping comments and other invisibles)
                until .not.quoted? [[block arg]: evaluate block]
            ]
        ]

        key: to word! dequote params/1
        all [
            refinement? params/1
            elide if not block [break]  ; done if refinements w/no more block
            mode = &lt;normal&gt;
        ] then [
            mode: if arg [#]  ; set mode to either use or don't use next arg
            if empty? second pick types key [  ; no-arg refine...
                set (in frame key) mode  ; ...must be # or NULL
            ] else [
                continue  ; keep param on the refinement, get next arg
            ]
        ] else [
            if mode [  ; normal or # case will set
                set (in frame key) get/any 'arg
            ]
        ]

        mode: &lt;normal&gt;
        params: next params
    ]

    ; Too many arguments was not a problem for R3-alpha's APPLY, it would
    ; evaluate them all even if not used by the function.  It may or may not
    ; be better to have it be an error.
    ;
    ; https://github.com/metaeducation/rebol-issues/issues/2237
    ;
    comment [
        all [block, not tail? block] then [
            fail "Too many arguments passed in REDBOL-APPLY block."
        ]
    ]

    do frame
]
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/resurrecting-redbol-apply-via-type-exposure/1474">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/resurrecting-redbol-apply-via-type-exposure/1474</link>
          <pubDate>Mon, 25 Jan 2021 11:50:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1474</guid>
          <source url="https://forum.rebol.info/t/resurrecting-redbol-apply-via-type-exposure/1474.rss">Resurrecting REDBOL-APPLY via Type Exposure</source>
        </item>
        <item>
          <title>Chaining Return Types</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Something that bothers me about C is that it doesn't let you write chaining void returns:</p>
<pre><code>void my_function() {
    return some_void_function(...);  /* this is not legal! */
}
</code></pre>
<p>That annoys me, because it makes it hard to write generic code that doesn't want the bad properties of a macro (repeating evaluation of arguments if used multiple times, etc.)...but throws a wrench in being able to abstract across return values.</p>
<p><strong>But Ren-C has this covered!</strong>  All states can be chained.</p>
<p>But what if you are writing a wrapped function, and want a type signature on the wrapper that matches what you are wrapping?  I guess we could do this via COMPOSE on the spec of some kind:</p>
<pre><code>my-function: func compose [
    return: (return-type-block-of :some-other-function)
    ...
][
    ...
    return some-other-function ...
]
</code></pre>
<p>Something along these lines, where you could add or remove elements of the type signature.  :-/Anyway, I just wanted to mention that we're not yet at utopia in this medium, even if we're pretty much nailing the chaining part itself!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/chaining-return-types/1467">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/chaining-return-types/1467</link>
          <pubDate>Mon, 18 Jan 2021 02:04:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1467</guid>
          <source url="https://forum.rebol.info/t/chaining-return-types/1467.rss">Chaining Return Types</source>
        </item>
        <item>
          <title>Representing Everything About A Parameter (...except its name)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p><strong>I'm aiming to draw out the string labels in parameter lists into their own more compact form, that's just the pointer to the string name.</strong></p>
<p>We can think of splitting out the symbol as if decorations we currently put on the parameter would be moved to the block:</p>
<pre><code> func ['foo [&lt;end&gt; word!] /bar [integer!] /no-arg] [...]
 =&gt;
 func [foo '[&lt;end&gt; word!] bar /[integer!] no-arg-refinement /[]] [...]
</code></pre>
<p>That's just how to think of how it's stored.  We don't have to <em>write</em> our specs like that...</p>
<p>There are a number of good reasons to do this, e.g. implementing <a href="https://richardartoul.github.io/jekyll/update/2015/04/26/hidden-classes.html">"hidden classes"</a> as in V8...each time you do  <strong>for-each [x y] ...</strong> or <strong>make object! [a: 10, b: 20]</strong> the system should detect the similarity of the key collection and reuse it, instead of needing unique [x y] and [a b] list copies allocated every time.</p>
<p>(I'll point out that consistent chipping away at efficiencies means that things like <strong>/[a b]</strong> do not take up more space than <strong>/[a b]</strong> or <strong>[a b]/</strong> or <strong>[a b].</strong> or <strong>.[a b]</strong> ... though these forms are immutable... keep that in mind...)</p>
<h2>This <em>reduces</em> how much information a "PARAM!" stores</h2>
<p>Currently all the information for a parameter--including the symbol, types, and other modes--is stuffed into an internal Frankenstein-like type called a PARAM!.  It's compressed into a single cell as a mismash of packed bits and a pointer to a spelling.</p>
<p><em>(Historical Note: R3-Alpha acted like these freakish cells were WORD!s...but with an off-to-the-side flag that marked them as "UNWORD"s.  This meant they stored a bunch of type bits where most words would store a binding.  These fake words could easily leak and crash the system, so Ren-C gave parameters a dedicated internal type, asserting on cases of use as if they were WORD!.)</em></p>
<p>The symbol takes one of the four slots in the PARAM!.  The cell header takes another.  So what's left in the remaining two slots is just a bunch of bits... 64 bits is what's available on both 32-bit  and 64-bit platforms.</p>
<p>There's a bit for whether or not each fundamental type--like a BLOCK! or TEXT!--is accepted by the parameter.  Then there are bits for <em>"is this parameter <code>&lt;skip&gt;</code>-able"</em> or <em>"can this parameter be the <code>&lt;end&gt;</code> of input"</em>.  This means the number of fundamental types allowed has been less than 64...as other parameter options have to fit in this set too.</p>
<h1>Can PARAM! be replaced with "normal" values?</h1>
<p>What if params were not a mysterious compressed form, but values that could be inspected more directly as a "parameter spec"?</p>
<p>I showed this "represenational concept" above (again, just to think of it as the system stores it, not as how you write it at source level):</p>
<pre><code> func [foo '[&lt;end&gt; word!] bar /[integer!] no-arg-refinement /[]] [...]
</code></pre>
<p>When the burden of representing the parameter name is removed, then <strong><code>'[&lt;end&gt; word!]</code></strong> could be the value that represents how the evaluator deals with the <code>foo</code> parameter.  Today the HELP gets a capture of these typeset blocks in the spec just for reference purposes.  But this would mean that what help used would concretely match what was in the spec.</p>
<h2>Challenge: Mutability of Referenced Type Words</h2>
<p>Let's imagine you did this:</p>
<pre><code>&gt;&gt; foo: func [name [text!]] [print [name]]
&gt;&gt; foo "before"
before

&gt;&gt; text!: integer!
&gt;&gt; foo "after"
after  ; did not reflect the change
</code></pre>
<p>Today it would not reflect the change.  This is because when that <code>TEXT!</code> word is looked up, it finds one of the built in DATATYPE!s for representing text, and sets the corresponding bit in the PARAM!.  No matter how you change TEXT!, it will only affect functions created after that point...not any that already set their bits.</p>
<p>We could address this by saying that if you use any WORD!s in the type spec of a function, then the binding of that word gets forcibly protected (if it isn't already).</p>
<pre><code>&gt;&gt; x!: text!

&gt;&gt; foo: func [name [x!]] [print [name]]

&gt;&gt; x!: integer!
** Access Error: variable x! locked
; ^-- it would be helpful to mention a "lock reason", though we are a bit short
; on bits for putting in these reasons...maybe only done in 64-bit builds?
</code></pre>
<p>This would give a persistence so the parameter description could store <strong><code>x!</code></strong> without worrying about its meaning changing.  That means you can do things like type check a parameter for a specialization at specialization time...and trust it doesn't need rechecking when used.  It also allows performance tricks that cache bits to make the check faster without having to look up the word every time (since you know it won't change).</p>
<p>It's a little harsh-seeming, but the type dialect has to be hardened somehow.  If you needed to use X! locally for something else, you've always got <strong>use [x!] [...]</strong> to create a new context for it.</p>
<h2>Challenge: Performance</h2>
<p>Checking a bit for a fundamental type in a typeset is pretty fast.  Matching a value against a rich type specification dialect isn't necessarily fast, and this is something every function (including natives) do.  It's particularly important for natives, because they interpret the bits of the cell assuming it has been checked...getting the wrong thing means it will crash.</p>
<p>This is where internal compactions could come into play.  Users might see the parameter spec as <strong>[text! integer!]</strong> but the system could recognize specific common patterns like that and compress them into something like today's PARAM! bits, behind the scenes.</p>
<p>We might want to rethink the usage of things like <code>&lt;end&gt;</code> to not use TAG!, but to use a type that can be interned for speed.  The problem with tags is that you could see <code>&lt;end&gt;</code> but actually have <code>next &lt;mend&gt;</code>...so if you had a process of locking down the symbol for speedy recognition you'd not be able to do it.  By contrast, ISSUE! (token) has no position and could be canonized to a word, so the process of checking could turn <code>#end</code> into something that is matched faster.</p>
<h2>Challenge: Mutability Part II - Type Predicates</h2>
<p>I've suggested essentially the end of the TYPESET! datatype as a concept; replacing it with functions.  This would mean something like:</p>
<pre><code>any-type!: :any-type?
</code></pre>
<p>This would have the same issue with locking, so once you used ANY-TYPE! in a function spec you couldn't change that particular binding's value of ANY-TYPE! to anything else.</p>
<p>But further, there needs to be a rule that ANY-TYPE? is a pure function.  It needs to give the same answers for the same input, and that answer cannot depend on anything about that input that can mutate.</p>
<p>Imagine that you specialized a function with a mutable BLOCK!, and the constraint was that it was a BLOCK! of length 2.  Then you append to the block, and call the specialization.  It no longer matches.</p>
<p>What you could ultimately end up with is a situation where you pay for type checking of specialized arguments every time (which would also mean you couldn't use the slot where the type information would have been for the specialized value...because you'll need both at the same time, an optimization loss)</p>
<h2>Challenge: Generics Throw A Wrench Into Types</h2>
<p>There has never been a good answer to how GENERICs (what Rebol2/Red called actions) work.  If you have something like APPEND that's defined to allow you to append to strings and blocks...but then later add an extension that implements GOB!s, how do you say that APPEND now accepts GOB!s...and how do you constrain the parameters to indicate that?</p>
<p>Historically, the grab bag of parameters for what these generic functions allow or don't is just updated in the bootstrap files.  But users and extensions can't really do this.</p>
<p>This is a topic in its own right--but it's worth mentioning.</p>
<h1>Inventory Of Parts to be Represented</h1>
<p>That's a lot to take in, but I'll close with the list of things that PARAM! bits currently encode:</p>
<p><strong>Some of these parts are on the element that names the parameter itself:</strong></p>
<ul>
<li>
<p>the spelling of the parameter's name (<a href="https://forum.rebol.info">currently case-sensitive, please read and discuss implications</a>)</p>
</li>
<li>
<p>its quoting status (WORD! -&gt; normal evaluation, QUOTED! WORD! -&gt; hard literal, GET-WORD! -&gt; soft literal)</p>
</li>
<li>
<p>if it's a refinement that outputs to a variable, which can also be used by multiple return...indicated by being a SET-WORD! if so</p>
</li>
<li>
<p>if it's a local, shown by a leading dot (it's possible to indicate that a range of ordinary words are all local by prefixing them with the <code>&lt;local&gt;</code> tag, e.g. <strong><code>&lt;local&gt; x y</code></strong> is the same as <strong><code>.x .y</code></strong>)</p>
</li>
<li>
<p>whether it is optional or not, denoted by a leading slash</p>
</li>
</ul>
<p><strong>The rest is in a BLOCK! which specifies what types the parameter accepts.</strong>  This includes other attributes of the parameter that don't fit on the first value:</p>
<ul>
<li>
<p>if it is willing to accept NULL or not--denoted by <code>&lt;opt&gt;</code>.  <em>(Note: this has been a gray area in "typesets" as NULL is not a value and "has no type")</em></p>
</li>
<li>
<p>if it is willing to treat the end of a series as if it had received NULL--denoted by <code>&lt;end&gt;</code>.  (to help with the conflation, a separate function allows to ask if a parameter's null actually came from reaching the end or not)</p>
</li>
<li>
<p>if the parameter will be skipped over and given as NULL if there is not a precisely matching type in that position slot, <a href="https://forum.rebol.info/t/skip-able-arguments/1013">denoted by <code>&lt;skip&gt;</code></a> <em>(Note: this is only available on hard literal parameters)</em></p>
</li>
<li>
<p>if the parameter is variadic, denoted by <code>&lt;variadic&gt;</code> <em>(Note: this was once <code>&lt;...&gt;</code> but that is now a 4-element TUPLE! corresponding to <code>[&lt; _ _ &gt;]</code>.  While it might seem like that "should be a tag!" that would be a broken interpretation since <code>&lt;</code> is a WORD! and if used for a function or object it would need <strong><code>&lt;/refinement</code></strong> or <strong><code>&lt;.field</code></strong> to be PATH! and TUPLE! respectively)</em></p>
</li>
<li>
<p>whether a parameter is modal, and controls the optional parameter directly after it in the parameter order.  <em>(Note: <a href="https://forum.rebol.info/t/new-parameter-convention-concept-modal-arguments-or-the-arg/1187">this is an experimental feature</a> that is weird and is still being studied, but it has some places where it's looking like it is fairly critical.)</em></p>
</li>
</ul>
<h2>Addendum: ...that's only information the evaluator uses...!</h2>
<p>That lengthy list doesn't include the HELP description string...which is just the tip of the iceberg for what a user might want to annotate arguments on a function with.</p>
<p>But Ren-C pushes all of the help information into a "meta" object.  Function makers have a low-level form that doesn't bother making this object (e.g. <strong><code>specialize*</code></strong>) and then a higher-level version that does.  There's a certain amount of default information put into the object:</p>
<pre><code>&gt;&gt; meta: meta-of :append
&gt;&gt; words of meta
== [description return-type return-note parameter-types parameter-notes

&gt;&gt; meta/parameter-notes/dup
== "Duplicates the insert a specified number of times"
</code></pre>
<p>You can tweak the object to your liking, and use FRAME!s as maps from parameter to value.  For example, you could track a property for each parameter being either <code>&lt;cool&gt;</code> or <code>&lt;uncool&gt;</code>:</p>
<pre><code> &gt;&gt; append meta compose [coolness: (make frame! :append)]
 &gt;&gt; meta/coolness/line: &lt;cool&gt;
 &gt;&gt; meta/coolness/part: &lt;uncool&gt;

&gt;&gt; meta/coolness
== make frame! [
    series: '~unset~
    value: '~unset~
    part: &lt;uncool&gt;
    only: '~unset~
    dup: '~unset~
    line: &lt;cool&gt;
]     
</code></pre>
<p>It's far from perfect, but it pushes the information out into the open where things like HELP can process it...and it's critical to writing code that inherits and manipulates the information.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/representing-everything-about-a-parameter-except-its-name/1459">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/representing-everything-about-a-parameter-except-its-name/1459</link>
          <pubDate>Wed, 06 Jan 2021 18:29:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1459</guid>
          <source url="https://forum.rebol.info/t/representing-everything-about-a-parameter-except-its-name/1459.rss">Representing Everything About A Parameter (...except its name)</source>
        </item>
        <item>
          <title>Notation for Outputs in Function Specs</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>The first cut at multiple return values made a multi-return output look like:</p>
<pre><code> func [/foo [&lt;output&gt; integer!]] [...]
</code></pre>
<p>Which was expedient to try it out.  <strong>But dialect-wise, I think a SET-WORD! makes more sense:</strong></p>
<pre><code> func [foo: [integer!]] [...]
</code></pre>
<h2>But What About The Deviant RETURN: ?</h2>
<p>It's a bit confusing to have RETURN: work different than other things specified by SET-WORD!.  This could be avoided by using a different convention, e.g. <strong><code>&lt;return&gt; [integer!]</code></strong> to stress the difference.</p>
<p>Or we could just say that it's "one of those things" and learnable, that the act of naming a return value "RETURN:" implies it's the main return...and gets special conventions and handling.</p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/notation-for-outputs-in-function-specs/1414">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/notation-for-outputs-in-function-specs/1414</link>
          <pubDate>Sun, 22 Nov 2020 19:21:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1414</guid>
          <source url="https://forum.rebol.info/t/notation-for-outputs-in-function-specs/1414.rss">Notation for Outputs in Function Specs</source>
        </item>
        <item>
          <title>Opportunistic Invisibility</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>When "Invisibles" were introduced, the evaluator had to establish if a function was either always-invisible or always-not-invisible.  You couldn't make a function that <em>"sometimes returned an INTEGER!, and sometimes was invisible."</em></p>
<p>This restriction was eventually lifted.  But then raised the question of how a RETURN statement would return invisibly.</p>
<p>The idea came along that RETURN would detect whether to return invisibly or not based on whether it was arity-0 or arity-1.  Here is the first version of what opportunistic invisibility looked like:</p>
<pre><code>&gt;&gt; vanish-if-odd: func [return: [&lt;invisible&gt; integer!] x] [
       if even? x [return x]
       return  ; arity-0 return meant invisible
   ]

&gt;&gt; &lt;test&gt; vanish-if-odd 2
== 2

&gt;&gt; &lt;test&gt; vanish-if-odd 1
== &lt;test&gt;
</code></pre>
<p>What was clever about the arity mechanic was that it could be chained.  If you RETURN'd the result of an opportunistic invisible, then if it happened to vanish you'd effectively make an arity-0 RETURN.</p>
<pre><code>&gt;&gt; vanish-if-even: func [return: [&lt;invisible&gt; integer!] y] [
       return vanish-if-odd y + 1  ; if vanishes, RETURN perceives arity-0
   ]

&gt;&gt; &lt;test&gt; vanish-if-even 2
== &lt;test&gt;

&gt;&gt; &lt;test&gt; vanish-if-even 1
== 2
</code></pre>
<h2>
<a name="alas-there-were-problems-1" class="anchor" href="https://forum.rebol.info#alas-there-were-problems-1"></a>Alas, There Were Problems</h2>
<p>One problem is that the variadic return was subject to <a href="https://forum.rebol.info/t/line-continuation-and-arity-bugs-thoughts/1965">line continuation "arity bugs"</a>.</p>
<p>For example, imagine trying to do a return in the middle of a block of code, with the intention to not running the ensuing code:</p>
<pre><code> foo: func [return: [&lt;invisible&gt; ...]] [
     ... some code here ...
     return  ; temporarily insert a return for debugging 
     ... some more code ...
 ]
</code></pre>
<p>A casual reader would think that would return invisibly, when it would actually <strong>return (... some more code ...)</strong>, picking up what's on the next lines.</p>
<p>Even trickier was that invisibility itself--and especially opportunistic invisibility--had the <a href="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405/9">power to wreck code structure</a> to where it was completely unpredictable.  The remedy was that invisibility could only apply in "interstitial slots", meaning that RETURN could not take an invisible as an argument.</p>
<h2>
<a name="new-mechanics-build-on-nihil-isotopic-empty-block-2" class="anchor" href="https://forum.rebol.info#new-mechanics-build-on-nihil-isotopic-empty-block-2"></a>New Mechanics Build On NIHIL (Isotopic Empty BLOCK!)</h2>
<p>Years of puzzling over the quirks of how to coherently wrap and process invisible functions led to rebuilding the feature on top of meta-representations and isotopes.  You can read all about that evolution in <strong><a href="https://forum.rebol.info/t/invisibility-reviewed-through-modern-eyes/2034">"Invisibility Viewed Through Modern Eyes"</a></strong>.  <img src="https://forum.rebol.info/images/emoji/twitter/eyes.png?v=12" title=":eyes:" class="emoji" alt=":eyes:" loading="lazy" width="20" height="20"></p>
<p>RETURN uses a special ^META parameter convention to allow it to accept the signal for invisibility as an argument.  (Under this convention it receives the quasiform <code>~[]~</code>, which is the meta of an empty unstable isotopic parameter pack used by multi-return.)</p>
<p>So an opportunistically invisible function would now look like this:</p>
<pre><code>&gt;&gt; vanish-if-odd: func [return: [&lt;nihil&gt; integer!] x] [
       if even? x [return x]
       return nihil
   ]

&gt;&gt; &lt;test&gt; vanish-if-odd 2
== 2

&gt;&gt; &lt;test&gt; vanish-if-odd 1
== &lt;test&gt;
</code></pre>
<p>While such constructs can still give rise to tricky situations in code, it's powerful while being much more under control.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/opportunistic-invisibility/1362">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/opportunistic-invisibility/1362</link>
          <pubDate>Fri, 09 Oct 2020 15:57:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1362</guid>
          <source url="https://forum.rebol.info/t/opportunistic-invisibility/1362.rss">Opportunistic Invisibility</source>
        </item>
        <item>
          <title>Weird Idea: TUPLE in Paths to Provide Refinement *AND* Value</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>People very frequently request seeing the connection between the refinement and its value more obviously, because the refinement argument is kind of far away:</p>
<pre><code>&gt;&gt; data: '(a b c)
&gt;&gt; append/dup data &lt;foo&gt; (1 + 2)
== (a b c &lt;foo&gt; &lt;foo&gt; &lt;foo&gt;)
</code></pre>
<p>So they make broken suggestions like <strong><code>append /dup 2 data &lt;foo&gt;</code></strong>, which we constantly have to debunk.</p>
<p>Nowadays <a href="https://forum.rebol.info/t/apply-ii-the-revenge/1834">we have "APPLY II"</a> which helps in more verbose cases:</p>
<pre><code>&gt;&gt; data: '(a b c)
&gt;&gt; apply :append [data &lt;foo&gt; /dup (1 + 2)]
== (a b c &lt;foo&gt; &lt;foo&gt; &lt;foo&gt;)
</code></pre>
<h2>
<a name="but-i-had-an-odd-idea-1" class="anchor" href="https://forum.rebol.info#but-i-had-an-odd-idea-1"></a>But I had an odd idea...</h2>
<p>What If You Could Directly Pass A Refinement Arg Via TUPLE?</p>
<pre><code>&gt;&gt; data: '(a b c)
&gt;&gt; append/dup.3 data &lt;foo&gt;
== (a b c &lt;foo&gt; &lt;foo&gt; &lt;foo&gt;)

&gt;&gt; data: '(a b c)
&gt;&gt; append/dup.(1 + 2) data &lt;foo&gt;
== (a b c &lt;foo&gt; &lt;foo&gt; &lt;foo&gt;)
</code></pre>
<p>It wouldn't be great for everything, but it could be convenient.  Not really hard to write, but is it compelling?  Are there other potentially interesting meanings for this notation?</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/weird-idea-tuple-in-paths-to-provide-refinement-and-value/1932">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/weird-idea-tuple-in-paths-to-provide-refinement-and-value/1932</link>
          <pubDate>Mon, 21 Sep 2020 05:38:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1932</guid>
          <source url="https://forum.rebol.info/t/weird-idea-tuple-in-paths-to-provide-refinement-and-value/1932.rss">Weird Idea: TUPLE in Paths to Provide Refinement *AND* Value</source>
        </item>
        <item>
          <title>Partial Specialization Syntax in a NULL-refinement world</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>SPECIALIZE is used to make a version of a function that has some of its arguments fixed.  The syntax I first came up with (which we have been using up to this day) takes a block that it would bind into a "FRAME!" for the function.  So:</p>
<pre><code>&gt;&gt; a10: specialize 'append [value: 4 + 6]

&gt;&gt; a10 [a b c]
== [a b c 10]
</code></pre>
<p>Not only do you get to set the parameters, you also have evaluation on your side... like when you make an object.  Here it does an addition for demonstration purposes, but it could be arbitrary code with branching and switching/etc.  The question is which parameters are assigned values and which are not.</p>
<p>Since frames are like OBJECT!s that contain keys that correspond to arguments, the idea was that anything in this frame that wound up NULL would be considered "unspecialized".  So function calls would gather such arguments at the callsite as normal (e.g. the SERIES parameter of append, taken here as [a b c] normally).  But since the VALUE parameter was set to 10 and hence not-NULL, it would not be gathered...nor typechecked.  (The type checking occurs only at specialization time, helping performance.)</p>
<h2>But...what about when arguments are <em>intentionally</em> NULL?</h2>
<p>Er, yeah.  There was no good answer for this, so you'd have to do tricks.  For example: first SPECIALIZE a parameter to a non-null value, and then ADAPT with code that turns around and nulls it out each time the function gets called:</p>
<pre><code>an: adapt (specialize 'append [value: _]) [value: null]
</code></pre>
<p>That's inefficient and not too pretty, but it didn't come up often.  With a few exceptions like REPLACE to a NULL being a way to delete things, you usually didn't want to pass null parameters.  So solving it was a back-burner issue.</p>
<p><strong>But refinements offered "partial" specializations.</strong>  This was the idea of saying that you had a routine like APPEND which might have a /PART parameter, and you wanted to say that there was a /PART <em>but not say what it is</em>.  The intent was a variant  of APPEND which took 3 arguments instead of 2, and just didn't require you to say /PART.</p>
<p>The notation for that had originally been:</p>
<pre><code>&gt;&gt; ap: specialize 'append [part: true]

&gt;&gt; ap [a b c] [d e f] 2
== [a b c d e]
</code></pre>
<p><strong>This worked because refinements used to have arguments.</strong> The argument to /PART (named LENGTH in R3-Alpha) was still NULL, even though PART was true.  So partial specialization was encoded by virtue of having a value for the refinement but not the argument.</p>
<p><strong>Even then, there were problems with <em>order</em></strong>.  If you partially specialized both <strong>part: true</strong> and <strong>dup: true</strong>, which would be gathered first at the callsite?  This was cleverly solved by offering an alternative way to do it, via specializing a PATH!:</p>
<pre><code> &gt;&gt; apd: specialize 'append/part/dup []

 &gt;&gt; apd [a b c] [d e f g] 2 3
 == [a b c d e d e d e]   ; /PART 2, /DUP 3

  &gt;&gt; adp: specialize 'append/dup/part []

  &gt;&gt; adp [a b c] [d e f g] 2 3
  == [a b c d e f d e f]  ; /DUP 2, /PART 3
</code></pre>
<p><strong>Now that <a href="https://forum.rebol.info/t/pure-and-refined-simplifying-refinements-to-one-or-zero-args/1120">refinements are their own arguments</a>, we're in a situation where this method for partial specialization still works, but the other doesn't.</strong>  You can't say <strong>part: true</strong> anymore because the PART argument itself holds the number or series position that the partial is calculated relative to.</p>
<p><em>(I will point out that killing off the other partial specialization method is a good example of how the new refinement model purifies things, by eliminating a fuzzy guessing model where it had to count how many refinements you had specialized inside the block and whether you'd also specialized the arguments, and error if you tried more than one partial specialization at a time.)</em></p>
<h2>How to remove a refinement from the interface but NULL it?</h2>
<p>Let's imagine now that we want to make a version  of append that does not offer a /PART refinement, and yet still hasn't pinned it down to a value.</p>
<p>We could try a riff on the adapt of a specialization.  Pick some random /PART that type checks to specialize with, and then null it out when the call happens:</p>
<pre><code> a-no-part: adapt (specialize 'append [part: 1020]) [part: null]
</code></pre>
<p>That will always act like APPEND with no /PART, and in the HELP it does not list /PART as an available refinement.</p>
<p><strong>This is a pain and not efficient.</strong>  You have to know the types the refinement takes, pick some arbitrary random value compatible with that (which could change if you change the legal types on the specialized function, and it doesn't seem that should break the intention of a specialization removal).  Then you're wasting runtime nulling it out on every call with a useless additional layer of ADAPT-ation.</p>
<p><strong>Worst case scenario, we need a counter to AUGMENT whose job is to <em>remove</em> parameters.</strong>  (ABRIDGE?  DIMINISH?)  But it seems like that is SPECIALIZE's domain, since it removes other parameters when it says what value they have...why can't we find a syntax to do it when it says it's "fixed at no value"?</p>
<p>As a random example, we might come up with a wacky variation on the path notation:</p>
<pre><code> a-no-part: specialize 'append/[part] []
</code></pre>
<p>So maybe if it sees a word in a BLOCK! in the path, that means "remove from the interface and set to null/unused".</p>
<p>We could be less creative e.g.:</p>
<pre><code>a-no-part: specialize/remove 'append [] [part]
</code></pre>
<h2>What about normal parameters (and reordering?)</h2>
<p>Whatever mechanism we come up with here needs to work with ordinary arguments, too.  And something I've wondered is if pathing with ordinary arguments might tie into some kind of reordering scheme:</p>
<pre><code>&gt;&gt; append/series 10 [a b c]  ; imagine pushes /SERIES to be last parameter
== [a b c] 10
</code></pre>
<p>If we accept this, then strange ideas like <strong>specialize 'append/[value] [...]</strong> meaning "remove value parameter but set it to NULL" folds into the notion that you can just name any argument like this.  We can also imagine the idea of creating variations of a function where a previously mandatory argument becomes optional.</p>
<pre><code>&gt;&gt; apmaybe: unrequire 'append [value]

&gt;&gt; apmaybe [a b c]
== [a b c]

&gt;&gt; apmaybe/value [a b c] 10
== [a b c 10]
</code></pre>
<p>My point in bringing this up is that the one-parameter-per-name concept makes refinements and ordinary arguments have more in common.  So we can imagine the mechanism to remove a refinement from the interface (while still leaving it null) working on ordinary arguments that want to be fixed at null as well.</p>
<p><em>This is by no means unsolvable and we have a lot of the mechanics for doing it.</em>  It's just a question of what you write at source level, and can we do something nice that finesses it instead of looking like a mess.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/partial-specialization-syntax-in-a-null-refinement-world/1266">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/partial-specialization-syntax-in-a-null-refinement-world/1266</link>
          <pubDate>Wed, 04 Mar 2020 15:24:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1266</guid>
          <source url="https://forum.rebol.info/t/partial-specialization-syntax-in-a-null-refinement-world/1266.rss">Partial Specialization Syntax in a NULL-refinement world</source>
        </item>
        <item>
          <title>Multiple Return Values Via Enfix</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <blockquote>
<p>Note: Before multi-returns had an implementation in the C code of the evaluator, I observed they could be implemented by means of enfix and skippable parameters.  This was that implementation.</p>
<p>It's still cool to look back at just in terms of the wild things you can prototype!</p>
</blockquote>
<hr>
<p>Imagine you want to make something where it returns the sum of two values and the difference...but only the sum if you aren't using a multi-return.</p>
<pre><code>sum-and-difference: enfixed func [:left [&lt;skip&gt; set-block!] arg1 arg2] [
    let sum: arg1 + arg2  ; always returned, only calculate once
    if set? 'left [
        switch length of left [
            1 [  ; we have `[x]: ...` act the same as `x: ...` 
               set left.1 sum
            ]
            2 [  ; only calculate difference for multiple returns
               set left.1 sum
               set left.2 arg1 - arg2
            ]
            fail "sum-and-difference can only return 1 or 2 values"
        ]
    ]
    return sum
]
</code></pre>
<h2>
<a name="and-presto-1" class="anchor" href="https://forum.rebol.info#and-presto-1"></a>and presto...</h2>
<pre><code>&gt;&gt; x: sum-and-difference 20 10
== 30  ; handled by plain evaluator mechanics

&gt;&gt; [y z]: sum-and-difference 20 10
== 30  ; handled by the enfix quoting

&gt;&gt; y
== 30

&gt;&gt; z
== 10
</code></pre>
<p>Notice that adopts the principle that it doesn't actually try to return a BLOCK! with the multiple return values, but only the first value.  But the interesting bit is that when you go about it this way, the convention is not really enforced.</p>
<h2>
<a name="whats-wrong-with-doing-it-this-way-2" class="anchor" href="https://forum.rebol.info#whats-wrong-with-doing-it-this-way-2"></a>What's Wrong With Doing It This Way?</h2>
<p>A disadvantage of this technique is it means you cannot make enfixed functions that have multiple return values (in the sense they've already used their enfixedness for the purpose of the multiple return value itself).</p>
<p>That may or may not be bad.  :-/  This offers a lot of flexibility to people for designing how their multiple return values work.</p>
<ul>
<li>
<p>They could decide that blanks mean skip the assignment, so for <strong>[_ z]: sum-and-difference 20 10</strong> it could be decided not to calculate the sum at all, and to return the difference.</p>
<ul>
<li>UPDATE: The information is not available in the system multi returns to know about whether the <em>main</em> result was requested or not...only the additional returns.  So the enfix function would have this edge.</li>
</ul>
</li>
<li>
<p>People who disagree with my philosophy about return the first thing could come up with their own rules...returning blocks that voidify, or maybe even the ability to mark which thing to return like <strong>[y <span class="mention">@z</span>]: sum-and-difference 20 10</strong> could calculate both but return the difference.</p>
<ul>
<li>UPDATE: <a href="https://forum.rebol.info/t/circling-multi-returns-choose-which-is-expression-result/1587">This feature exists in modern multi-returns offered by the system!</a>
</li>
</ul>
</li>
</ul>
<p>Telling people they are their own boss and can design multi return features however they want is a powerful idea that is a bit unnerving.  Though Rebol has a lot of those.  Truly a strange way of looking at multiple return value mechanics!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/multiple-return-values-via-enfix/1257">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/multiple-return-values-via-enfix/1257</link>
          <pubDate>Sat, 01 Feb 2020 05:04:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1257</guid>
          <source url="https://forum.rebol.info/t/multiple-return-values-via-enfix/1257.rss">Multiple Return Values Via Enfix</source>
        </item>
        <item>
          <title>Looking into a *usermode* POINTFREE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>The concept of <a href="https://en.wikipedia.org/wiki/Tacit_programming">"Point Free" or "Tacit Programming"</a> is that it's a way of relating functions to each other without mentioning their arguments.</p>
<p>So instead of writing something like:</p>
<pre><code> append-to-data: function [value] [append data value]
</code></pre>
<p>You'd have some way of avoiding the redundancy of having to say "value" twice.  So imagine declaring an identical function with a syntax like:</p>
<pre><code> append-to-data: pointfree [append data]
</code></pre>
<p>That would notice you didn't provide all the parameters to append, so an implicit parameter to the new function would be added.  But what if you wanted instead something like:</p>
<pre><code>append-10: function [series] [append series 10]
</code></pre>
<p>So maybe you would have some syntax in POINTFREE for that where you put a placeholder in spots that you wanted implicitly picked up.  Maybe BLANK! as a default:</p>
<pre><code>append-10: pointfree [append _ 10]
</code></pre>
<p><em>(Note: The name <strong>pointfree</strong> is deliberately chosen as bad, since it won't be taken for other reasons...and also reinforces the term for Rebol programmers unused to FP concepts.  What I'm actually thinking is that this will be folded into lambda as the behavior when you don't use a block.  So <strong>(-&gt; append _ 10)</strong> for example.)</em></p>
<blockquote>
<p><strong>UPDATE:</strong> To eliminate potential accidents, it was unbundled from lambda and uses the similar-but-notably-distinct notation <strong><code>&lt;-</code></strong> now.</p>
</blockquote>
<h2>
<a name="writing-this-in-usermode-in-historical-rebol-is-non-trivial-1" class="anchor" href="https://forum.rebol.info#writing-this-in-usermode-in-historical-rebol-is-non-trivial-1"></a>Writing This In Usermode In Historical Rebol Is Non-Trivial</h2>
<p>If you think writing a reliable POINTFREE yourself would be easy in Rebol2/Red, I would invite you to try.  There's a lot to get right with parameter analysis and ordering refinements; beyond the average user.  It doesn't get much easier if you are coding inside the system, either.</p>
<p>It would also be noticeably slower, using any method in near-reach.  The only mechanisms would involve creating a whole new function spec, where the evaluator would have to pass parameters to that function...then start evaluating again to make a nested call...type checking all over again.</p>
<p>Ren-C has several tricks up its sleeve, including a new tool introduced today for writing your own specializations.  That's the ability to MAKE ACTION! out of a FRAME! with some of its parameters filled.  And since you can MAKE FRAME! out of an ACTION!, this provides a convenient round-trip:</p>
<pre><code>&gt;&gt; data: [a b c]

&gt;&gt; f: make frame! :append
&gt;&gt; f/series: data

&gt;&gt; apd: make action! f
&gt;&gt; apd [d e f]

&gt;&gt; data
== [a b c d e f]
</code></pre>
<p>There's also a great convenience afforded by Ren-C's smart specialization handling.  Consider:</p>
<pre><code>&gt;&gt; parameters of :append
== [series value /part /only /dup /line]

&gt;&gt; apdup: :append/dup

&gt;&gt; parameters of :apdup
== [series value dup /part /only /line]
</code></pre>
<p>So if you have someone writing <strong>pointfree [append/dup ...]</strong> you don't worry...just GET the PATH!, and the function you are handed back doesn't even report DUP as a refinement.  It's a normal parameter now.</p>
<p>There's also more unlocked by the idea of <a href="https://forum.rebol.info/t/pure-and-refined-simplifying-refinements-to-one-or-zero-args/1120">refinements naming their 0-or-1 arguments</a>.  We've seen it open doors with <a href="https://forum.rebol.info/t/augment-add-parameters-and-refinements-after-the-fact/1216">AUGMENT</a>, but it helps here and elsewhere.</p>
<h2>
<a name="a-start-on-the-vision-of-pointfree-2" class="anchor" href="https://forum.rebol.info#a-start-on-the-vision-of-pointfree-2"></a>A Start on the Vision of POINTFREE</h2>
<p>This usermode implementation is incomplete and raises some issues (including that I'm not totally thrilled with the <span class="mention">@var</span> skippable syntax in EVALUATE).</p>
<p>But it shows relatively little code taking care of some rather complex acrobatics.  I'd hope it wouldn't be too far beyond the reach of a novice to write:</p>
<pre><code>pointfree: func [
    {Specialize by example: https://en.wikipedia.org/wiki/Tacit_programming}

    return: [action!]
    block [block!]
][
    let action: (match action! any [
        if match [word! path!] :block/1 [get block/1]
        :block/1
    ]) else [
        fail "POINTFREE requires ACTION! argument at head of block"
    ]
    block: next block  ; rest of block is invocation by example

    ; If we did a GET of a PATH! it will come back as a partially specialized
    ; function, where the refinements are reported as normal args at the
    ; right spot in the evaluation order.  (e.g. GET 'APPEND/DUP returns a
    ; function where DUP is a plain WORD! parameter in the third spot).
    ;
    ; We prune out any unused refinements for convenience.
    ;
    let params: map-each w parameters of :action [
        match [word! lit-word! get-word!] w  ; !!! what about skippable params?
    ]

    let frame: make frame! :action  ; all frame fields default to NULL

    ; Step through the block we are given--first looking to see if there is
    ; a BLANK! in the slot where a parameter was accepted.  If it is blank,
    ; then leave the parameter null in the frame.  Otherwise take one step
    ; of evaluation or literal (as appropriate) and put the parameter in the
    ; frame slot.
    ;
    let var
    iterate params [
        case [
            blank? :block/1 [block: next block]

            word? params/1 [
                if not block: evaluate @var block [
                    break  ; ran out of args, assume remaining unspecialized
                ]
                frame/(params/1): :var
            ]
            
            all [
                lit-word? params/1
                match [group! get-word! get-path!] :block/1
            ][
                frame/(params/1): reeval :block/1
                block: next block
            ]

            default [  ; hard literal argument or non-escaped soft literal
                frame/(params/1): :block/1
                block: next block
            ]
        ]
    ]

    ; We now create an action out of the frame.  NULL parameters are taken as
    ; being unspecialized and gathered at the callsite.
    ;
    return make action! :frame
]
</code></pre>
            <p><small>8 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/looking-into-a-usermode-pointfree/1236">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/looking-into-a-usermode-pointfree/1236</link>
          <pubDate>Wed, 30 Oct 2019 13:38:19 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1236</guid>
          <source url="https://forum.rebol.info/t/looking-into-a-usermode-pointfree/1236.rss">Looking into a *usermode* POINTFREE</source>
        </item>
        <item>
          <title>How Attached are we to Functions Return Last Result?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <blockquote>
<p>**UPDATE: 2021: Use LAMBDA if you want to return the last result; FUNC(TION) requires a RETURN statement and will return trash otherwise.  Full rationale:</p>
<p><a href="https://forum.rebol.info/t/implicit-execution-of-return-in-functions-bad/1656" class="inline-onebox">Implicit Execution of RETURN in functions = ...BAD (?)</a></p>
</blockquote>
<hr>
<p>In JavaScript, the failure to specify a RETURN statement is basically the way of saying you don't return anything.  Functions don't accidentally leak values, you just get undefined:</p>
<pre><code>&gt; function nada() { 1 + 2; }

&gt; nada()
&lt;- undefined

&gt; function three() { return 1 + 2; }

&gt; three()
3
</code></pre>
<p>I know this isn't how Rebol has historically operated.  But the historical operation of Rebol can lead to the accidental leakage of a lot of values which the caller wasn't necessarily meant to see.  There's currently a burden to annotate in the spec when a function doesn't return something.</p>
<p>So in the <em>"Let's not give JavaScript any upper hand"</em> line of thinking, should this be re-evaluated?  I must admit I kind of feel their way is clearer.  :-/</p>
            <p><small>12 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/how-attached-are-we-to-functions-return-last-result/1219">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-attached-are-we-to-functions-return-last-result/1219</link>
          <pubDate>Mon, 30 Sep 2019 10:24:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1219</guid>
          <source url="https://forum.rebol.info/t/how-attached-are-we-to-functions-return-last-result/1219.rss">How Attached are we to Functions Return Last Result?</source>
        </item>
        <item>
          <title>Idea for Naming Function Arguments Out of the Way</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>As part of Rebol's contention-for-short-names problem, there are many instances where refinements have names like /ALL where they conflict with common natives or lib functions.</p>
<p>When this happens, I tend to do something to name them out of the way and put the lib function back:</p>
<pre><code>foo: function [
    bar [block!]
    /all "foo all the bars"
][
    all_FOO: all
    all: :lib.all
    ...
]
</code></pre>
<p>Clearly we need a better pattern.</p>
<p>Maybe there could be two features that work together on this.  One would be the ability to ask that the function's frame be passed in as a variable, and another would be to suppress binding of an argument in the body.</p>
<pre><code>foo: function [
    bar [block!]
    /.all "foo all the bars"
    &lt;frame&gt; f
][
    all [...]  ; would be the ALL from LIB
    if f.all [print "Fooing all the bars"]
]
</code></pre>
<p>It's already kind of necessary to be able to get the FRAME! of a function into a variable <em>(asking for <strong>binding of 'return</strong> is clunky, and you have no way of doing it with a lambda that has no parameters or locals)</em>.  Then the dot could mark arguments as being "member-access-only" via the dot.</p>
<p>I think this is better than trying to name things out of the way.  It could work for normal arguments too:</p>
<pre><code>foo: function [
    .bar [block!]
    /.all "foo all the bars"
    &lt;frame&gt; f
][
    ; use f.bar and f.all, with BAR and ALL left as-is
]
</code></pre>
<p>It might not be the most beautiful thing in the world, but this is a real problem that is very frustrating when it comes up.  And when you encourage people to play with words, they shouldn't be afraid to reuse them in refinements if they make sense.</p>
<p>The only qualm I might have would be conflict with other meanings of BLANK!-headed TUPLE!s, but so far it seems like inertness is what we've got.</p>
<p>Objections?  Better ideas?  <img src="https://forum.rebol.info/images/emoji/twitter/cricket.png?v=12" title=":cricket:" class="emoji" alt=":cricket:" loading="lazy" width="20" height="20"> <img src="https://forum.rebol.info/images/emoji/twitter/cricket.png?v=12" title=":cricket:" class="emoji" alt=":cricket:" loading="lazy" width="20" height="20"></p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/idea-for-naming-function-arguments-out-of-the-way/1167">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/idea-for-naming-function-arguments-out-of-the-way/1167</link>
          <pubDate>Thu, 23 May 2019 14:22:52 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1167</guid>
          <source url="https://forum.rebol.info/t/idea-for-naming-function-arguments-out-of-the-way/1167.rss">Idea for Naming Function Arguments Out of the Way</source>
        </item>
        <item>
          <title>Wrapping And Forwarding Multi-Returns</title>
          <dc:creator><![CDATA[IngoHohmann]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1134">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134/1">The History of Multi-Return in Ren-C</a>
</div>
<blockquote>
<p>It seemed clearly preferable that rather than choose between <strong>[x]:</strong> and <strong>[x y]:</strong> and knowing in advance how many values you're taking or throwing away... someone who only asked for one value should be able to be blissfully ignorant. So the choice would be between:</p>
<pre><code>&gt;&gt; x: multi-return ...
&gt;&gt; [x y]: multi-return ...
</code></pre>
<p>Even though the first case is a multiple return, you wouldn't set x to a block of values, <em>but just get the first value</em>. An interface like this would also solve the issue of returning NULL.</p>
</blockquote>
</aside>
<p>Yup, sounds really useful.</p>
<p>One question, what do functions see?</p>
<pre><code>f: function [a][]
f multi-return
</code></pre>
<p>Does f get the return as a block, or the first value?</p>
<p>What happens with multiple parameters in f? With refinements? With variadics? When f is enfixed?</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/wrapping-and-forwarding-multi-returns/1926">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/wrapping-and-forwarding-multi-returns/1926</link>
          <pubDate>Thu, 28 Mar 2019 06:09:03 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1926</guid>
          <source url="https://forum.rebol.info/t/wrapping-and-forwarding-multi-returns/1926.rss">Wrapping And Forwarding Multi-Returns</source>
        </item>
        <item>
          <title>The History of Multi-Return in Ren-C</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p><em>This thread merges discussions of history across several threads to cover the key points, starting with material from the post announcing the addition of the SET-BLOCK! and GET-BLOCK!...and then folding in important points from later posts in the relative chronology of when they happened.  So it's broken up into sections by approximate date.</em></p>
<hr>
<h1>March 2019: SET-BLOCK! and GET-BLOCK! Added</h1>
<p>These were generic parts which you could use in dialects however you wanted...just like other types.</p>
<p><strong>But a key motivation was the concept that the evaluator would use them for some kind of multiple-return-value strategy.</strong>  Users of languages with the feature seemed to rave about it. And if you don't have it, they will complain and constantly try to find ways to work around it.</p>
<p>I had inklings that Rebol could do them in a way that is mindbending and original. But a dirt simple implementation of the idea in 2019 looked roughly like what people were used to with SET of BLOCK! from Rebol2, without needing to write the word SET:</p>
<pre><code>early-multi-concept: function [a b] [
    return :[(a * 3) (b - 16)]  ; e.g. :[...] would act like REDUCE [...]
]

&gt;&gt; [x y]: early-multi-concept 10 20
== [30 4]

&gt;&gt; x
== 30

&gt;&gt; y
== 4
</code></pre>
<p>So <strong><code>([x y]: foo)</code></strong> would act like <strong><code>(set [x y] foo)</code></strong>, including allowances to let you take fewer than one value:</p>
<pre><code>&gt;&gt; [x]: [10 20]
== [10 20]

&gt;&gt; x
== 10
</code></pre>
<h2>But the simplicity had obvious drawbacks</h2>
<p>First of all, Ren-C had NULL states that by design could not be put into blocks.  This approach wouldn't be able to return those without distorting them into some different reified value  than the intended NULL.</p>
<pre><code>&gt;&gt; [x y]: function-returning-null-and-30
== [&lt;null&gt; 30]  ; can't put null, so... "something else" in first slot?

&gt;&gt; x
== null  ; not the same thing as what the block said...seems bad, yes?

&gt;&gt; y
== 30
</code></pre>
<p>Also, you would have to know that what you were calling returned multiple values.  If you missed that and used a plain SET-WORD!, you'd just wind up with the block:</p>
<pre><code>&gt;&gt; x: some-function-i-didnt-know-was-multi-return ...
== [ret1 ret2 ret3]  ; the block! could easily be mistaken for single return
</code></pre>
<h2>I had one of those ideas that just wouldn't go away...</h2>
<p>It seemed clearly preferable that rather than choose between <strong>[x]:</strong> and <strong>[x y]:</strong> and knowing in advance how many values you're taking or throwing away... someone who only asked for one value should be able to be blissfully ignorant.  So the choice would be between:</p>
<pre><code>&gt;&gt; x: multi-return ...
&gt;&gt; [x y]: multi-return ...
</code></pre>
<p>Even though the first case is a multiple return, you wouldn't set x to a block of values, <em>but just get the first value</em>.  An interface like this would also solve the issue of returning NULL.</p>
<p>Not being forced to return a BLOCK! also made great sense... <em>because since BLOCK! is always truthy, you'd not really be able to make useful conditional behavior be based on a BLOCK! return anyway!</em></p>
<pre><code>&gt;&gt; [x y]: function-returning-null-and-30
== null  ; so you could meaningfully say `if [x y]: whatever [...]`

&gt;&gt; x
== null

&gt;&gt; y
== 30
</code></pre>
<p>Going even further, I suggested <em>"it would be important that if a function wanted to do multiple returns that it could know how many results it was assigning.  This could save calculation on things that aren't needed."</em></p>
<h3>
<em><strong>...but all this would require some kind of magic...</strong></em> <img src="https://forum.rebol.info/images/emoji/twitter/mage.png?v=9" title=":mage:" class="emoji" alt=":mage:">
</h3>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134</link>
          <pubDate>Thu, 28 Mar 2019 01:56:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1134</guid>
          <source url="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134.rss">The History of Multi-Return in Ren-C</source>
        </item>
        <item>
          <title>Variadic Return Values (not VARARGS! return values...)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Imagine the following:</p>
<pre><code>inline: function [
    return: [any-value! &lt;variadic&gt;]
    block [block!]
][
    return make varargs! block
]
</code></pre>
<p>With the desired behavior:</p>
<pre><code>&gt;&gt; 1 inline [+ 2 + 3]
== 6
</code></pre>
<p>This would be a very powerful macro-like mechanism.  (While not being done with any preprocessing step, and hence not a "macro" in the conventional sense).</p>
<p>One of the mechanical problems with such a construct is that when the evaluator is looking right from the 1, it has to know if the function it is seeing is enfix or not.  Unfortunately, INLINE doesn't have a generic answer...its answer depends on calculations it does once it is running, after its arguments are evaluated.  It depends on what's in the block it gets.</p>
<p>The evolving way of dealing with such situations is <em>left-variadic-enfix</em>.  This is to say that inline can defer its answer until when it runs...but by doing so it runs <em>before</em> its left hand side.</p>
<p>Here is simplified model of how that would work:</p>
<pre><code>inline: enfix function [
    return: [any-value! &lt;variadic&gt;]
    :look [&lt;opt&gt; any-value! &lt;variadic&gt;]
    block [block!]
][
    if enfix? w: match [word!] first block [
        return make varargs! compose/only [(take look) block]
    ]
    return make varargs! block
]
</code></pre>
<p>The moment of the TAKE (or the lack of a take) is how the evaluator gets its "are you enfix or not" answer from something whose left hand side is variadic.</p>
<p>While this looks very similar <a href="https://trello.com/c/Kg9A45b5/231-paths-can-be-dispatched-as-infix-and-provide-refinements-to-infix-operators-using-shove">to what SHOVE does</a>, SHOVE is actually implemented as an internal trick to the evaluator that is tailored to that particular case.  It doesn't run usermode code (or even plain code inside a native) to accomplish what it does.  It can't, because the variadic take of the left would require completing a higher stack level of code before a lower stack level.</p>
<p>It may seem variadics do this already (there's an ACTION! on the stack whose frame is running, and code is being processed from its "feed" to supply values to a variadic further on in the stack).  But that action is already running and has finished gathering its arguments--you're not interrupting the evaluator in mid-process, and hooking into the enfix mechanic itself.  I think it's possible though--it might need to use the same trick as ENCLOSE, which rearranges the stack in mid-run.</p>
<p>It would still be a little odd--in the same way that SHOVE is odd.  One odd thing is that <em>the evaluation of the block on the right has to happen before any evaluations on the left</em>:</p>
<pre><code>&gt;&gt; (print "left" 1) inline (print "right" [+ 2 + 3])
right
left
== 6
</code></pre>
<p>That's just the physics of the situation.  The left looking rightward needs the answer to a question that can't be answered until the right is evaluated.  But it's not just SHOVE that has this property, look at SET-PATH! operation... right before left:</p>
<pre><code>&gt;&gt; o: make object! [x: 10]
&gt;&gt; o/(print "left" x): (print "right" 20)
right
left
== 20
</code></pre>
<p>The reason for why it has to do that is similar.  I've made a <a href="https://github.com/rebol/rebol-issues/issues/2275#issuecomment-396708575">semi-convincing argument for why this is not a bug</a>, and if there are other constructs which have to do this then it seems less like an anomaly.</p>
<p>Reading between-the-lines, this would provide a highly generic tool for rewriting the stream of code...you could imagine things that take a VARARGS! in, and give a VARARGS! out.</p>
<h3>Avoiding Superfluous Stack Levels</h3>
<p>One area I'd like to see this applied is when you want to avoid introducing a stack level in the debugger.  e.g. the console has to run a block of code, but you don't want to see "DO BLOCK" putting DO on the stack.  Instead the API could just say:</p>
<pre><code>result = rebRun("inline", block);
</code></pre>
<p>This way, when the code inside the block is running, INLINE has already finished its work...handing the feed back to the evaluator.  It will appear there's nothing at all on the stack.</p>
<p>Because of the trickery involved, I <em>imagine</em> this would end up being slower than DO BLOCK (I'd basically be certain of it), so you wouldn't want to do it unless there was a good reason.  But there may be some cases where code is getting composed or wired up today to accomplish this where it would be faster.  Since it's a hypothetical feature at this point, it's probably best to wait to speculate too much on this.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/variadic-return-values-not-varargs-return-values/951">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/variadic-return-values-not-varargs-return-values/951</link>
          <pubDate>Sun, 09 Dec 2018 16:20:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-951</guid>
          <source url="https://forum.rebol.info/t/variadic-return-values-not-varargs-return-values/951.rss">Variadic Return Values (not VARARGS! return values...)</source>
        </item>
        <item>
          <title>Why No-Argument Refinements Are BLACKHOLE! or NULL</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>In Rebol2, a refinement's value would be #[true] or #[none]:</p>
<pre><code>rebol2&gt;&gt; show-me: func [/bar] [print mold bar]

rebol2&gt;&gt; show-me/bar
true  ; actually LOGIC! #[true], not the WORD! true

rebol2&gt;&gt; foo
none  ; actually a NONE! value, not the WORD! none
</code></pre>
<p><em>As a newbie, I was bothered by this from the get-go...</em> because I couldn't test refinements with AND/OR.  (they don't take #[none])  I hadn't drank the Kool-Aid that ANY/ALL were always a desirable substitute.</p>
<hr>
<blockquote>
<p><strong>NOTE: I never</strong> drank the ANY/ALL supremacy Kool-Aid.  Of course there are a lot of cool uses for them as larger scale control structures--and it's important to know how to use them for streamlining program flow.  But for testing flags?  The ability to do it infix and without delimiters can read much better in many places.</p>
<p>So Ren-C has adopted infix AND/OR that <a href="https://github.com/rebol/rebol-issues/issues/1879">operate conditionally on ANY-VALUE! and return LOGIC!</a> <em>(they also short-circuit)</em></p>
<pre><code>ren-c&gt;&gt; flag1: flag2: true

ren-c&gt;&gt; if flag1 and flag2 [print "It allows WORD!s, this comes up often"]
It allows WORD!s, this comes up often

ren-c&gt;&gt; if all [flag1 flag2] [print "Not everyone loves this (e.g. not me)"]
Not everyone loves this (e.g. not me)

ren-c&gt;&gt; if (block? flag1) and (empty? flag1) [print "Short-circuit avoids error"]
; to do this, the second argument to AND/OR is quoted behind the scenes 
</code></pre>
</blockquote>
<hr>
<p>There were countless debates over whether refinements should just be LOGIC! (as in Red), or if a used refinement should be the WORD! of the refinement (maybe useful for chaining?).  For a time, it seemed murkier when Ren-C introduced NULL...although it all tied up rather nicely in the end!</p>
<p><strong>But, 2022 UPDATE:</strong> I've cleaned up a bunch of historical rambling of me talking to myself in this thread to pare it down to what's useful.</p>
<hr>
<h2>Evolution Led Ren-C to <a href="https://forum.rebol.info/t/pure-and-refined-simplifying-refinements-to-one-or-zero-args/1120">Refinements As Their Own Arguments</a>
</h2>
<ul>
<li>
<p>Multiple-refinement arguments were a fringe feature, used almost nowhere.  Primarily it just created an inconvenience for 1-argument refinements having to come up with some random name for the argument.</p>
</li>
<li>
<p>With the existence of non-valued NULL, a single argument could represent the state of being used or not, along with the value itself.</p>
<ul>
<li>
<p>The "used" state would be able to hold ANY-VALUE! that could be put in a block.</p>
</li>
<li>
<p>NULL became falsey--so just testing it with IF could cover most "is the refinement used" questions...with specific tests for NULL? when there was risk of conflation with BLANK! or FALSE!</p>
</li>
</ul>
</li>
<li>
<p>It simplified the evaluator logic--removing the "refinements pick up every parameter after them" semantic.</p>
<ul>
<li>This paved the way for adding more arguments to functions after-the-fact, without worrying about them getting lumped in with the arguments of the existing last refinement.</li>
</ul>
</li>
</ul>
<h2>But What About Refinements That <em>Don't</em> Take Arguments?</h2>
<p>This question malingered along longer than I would have liked it to.  <img src="https://forum.rebol.info/images/emoji/twitter/zombie.png?v=9" title=":zombie:" class="emoji" alt=":zombie:"></p>
<p>For some time it would give you back a WORD! that was the name of the refinement itself:</p>
<pre><code>old-renc&gt;&gt; show-me: func [/bar] [print mold bar]

old-renc&gt;&gt; show-me/bar
bar

old-renc&gt;&gt; foo
; null
</code></pre>
<p>I'd advocated for this idea very early on:</p>
<ul>
<li>
<p>Imagine if one function took <code>/only</code> and wrapped another function that also took an <code>/only</code></p>
</li>
<li>
<p>If the wrapper got its ONLY variable for the refinement as the WORD! <code>only</code>...</p>
<ul>
<li>
<p>you could just say <strong><code>inner-function/(only)</code></strong></p>
<ul>
<li>
<p>If you got the refinement, that acts like <strong><code>inner-function/('only)</code></strong></p>
</li>
<li>
<p>If you didn't get the refinement, that would act like <strong><code>inner-function/(null)</code></strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If you squint your eyes and use your imagination a little, this might seem like a useful tool for chaining.</p>
</li>
</ul>
<p><strong>But the feature was a victim of Ren-C's other successes.</strong>  It's much easier and more efficient to wrap functions with things like ADAPT, ENCLOSE, SPECIALIZE.  The need to write this kind of "tunneling" function is rare: and refinement naming overlap is unlikely if the functions weren't somehow derived from each other.</p>
<p><em>(It also made building FRAME!s at a low-level more annoying...the value you put in the frames had to be contingent on the refinement name.  And it forced path dispatch steps to permit NULLs, when it didn't allow it anywhere else.  More complexity, for little benefit.)</em></p>
<h2>So Wouldn't LOGIC! For Argless Refinements be... <em>Logical?</em>
</h2>
<p>You might think so.  <img src="https://forum.rebol.info/images/emoji/twitter/robot.png?v=9" title=":robot:" class="emoji" alt=":robot:">  But actually... <em>no</em>.</p>
<p>There are a number of technical reasons.  Yet an intuitive angle might be to consider how an argument-less refinement contrasts with a refinement that takes an actual LOGIC! argument.</p>
<pre><code>foo: func [/mutate [logic!]] [...]
</code></pre>
<p>This refinement can be NULL (unspecified--e.g. the refinement was not used at all), or #[true] or #[false] when it is specified.  There's three states.</p>
<p>But an argument-less refinement is really just "used or unused".  So NULL and then a single truthy state... ideally a state that the system understands as meaning <em>"I'm opting in"</em>.</p>
<h2>The Modern Day: <a href="https://forum.rebol.info/t/sending-values-into-a-blackhole/1347">NULL or BLACKHOLE!</a>  <code>(#)</code>
</h2>
<p>While BLANK! has worked nicely as a falsey reified unit type, we've been lacking a truthy unit type.</p>
<p><strong>But with the unification of issues and characters, the appealing truthy "kind-of-a-unit-type" of # exists.</strong>  And its meaning of "please opt-in" is a good match for refinements.</p>
<ul>
<li>Space-wise fits in a single cell with no allocation, like BLANK!</li>
<li>It's not a series so it's not mutable and has very few operations it responds to.</li>
<li>It's one easily-visible character.</li>
<li>And again, it is truthy.</li>
</ul>
<h3>Simple To Set, Doesn't Depend on the Refinement Name</h3>
<pre><code> &gt;&gt; f: make frame! :some-function
 
 &gt;&gt; f.argless-refinement: if x = y [#]  ; slot will be either null or #
</code></pre>
<p>First reflex might be to make a TO-BLACKHOLE or similar:</p>
<pre><code> &gt;&gt; f.argless-refinement: to-blackhole x = y
</code></pre>
<p>But I actually think the <strong><code>if condition [#]</code></strong> looks pretty nice.  It's unambiguous and you get the idea.  "check this box, else leave it empty".  Short and obvious!</p>
<h3>Blackholes Are Fit For Purpose, and Aligns With Multi-Returns</h3>
<p>Blackholes were first invented to help "opt-in" scenarios with multi returns, with patterns like:</p>
<pre><code>if multireturn-var [  ; request for additional work made
    set multireturn-var do-additional-work
]
</code></pre>
<p>The truthy nature of <strong><code>#</code></strong>, along with being a no-op with SET, made it easy to request the additional work be done while not needing to name a variable to store the output.</p>
<p>That's no longer needed in multi-return, because <a href="https://forum.rebol.info/t/output-variables-in-multi-return/1859">it proxies variables for you automatically</a>, so you don't need the overhead of SET.</p>
<p>But it's still a useful feature, and can come in handy with # produced by used refinements!</p>
<h2>Higher Level Functions Can Add Conveniences!</h2>
<p>If you think it would be nice to be able to specify an argless refinement with a LOGIC!, guess what... you can!  <em>(Just not when building low-level frames...)</em></p>
<p>Higher level functions like APPLY are happy to turn a LOGIC! into a NULL or # for you.</p>
<pre><code>&gt;&gt; apply :append [[a b c] [d e] /only 1 = 1]
== [a b c [d e]]
</code></pre>
<p>SPECIALIZE doesn't do it at time of writing, but maybe it should...</p>
<pre><code>&gt;&gt; apo: specialize :append [only: 2 = 2]
** Script Error: Argless Refinement /only Must be either # or NULL
</code></pre>
<p>In any case, I just wanted to explain why an argless refinement to your function is going to be showing up as # or NULL, and that's more or less the final (?) answer.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/why-no-argument-refinements-are-blackhole-or-null/735">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/why-no-argument-refinements-are-blackhole-or-null/735</link>
          <pubDate>Thu, 12 Jul 2018 21:05:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-735</guid>
          <source url="https://forum.rebol.info/t/why-no-argument-refinements-are-blackhole-or-null/735.rss">Why No-Argument Refinements Are BLACKHOLE! or NULL</source>
        </item>
        <item>
          <title>METHOD and the argument against PROCEDURE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>I've an idea that METHOD be a left-quoting version of FUNCTION...looking for a SET-WORD! or SET-PATH! on its left, and doing the assignment.  The reason it would do this would be so that it had access to the word to read the binding out of it.  That means it can look to see what fields were in that object, to solve a problem today with using FUNCTION in objects:</p>
<pre><code>obj: make object! [
    x: 10
    f: function [] [
        x: 10 ;-- would assign a local, since it's gathered
        y: 20 ;-- would also assign a local
    ]
    f2: function [&lt;in&gt; obj] [ ;-- today's workaround
        x: 10 ;-- would assign obj/x
        y: 10 ;-- would assign a local
    ]
    m: method [] [
        x: 10 ;-- would assign obj/x, since it's in binding of `m:`
        y: 20 ;-- would assign a local, not in binding of `m:`
    ]
]
</code></pre>
<p><strong>This seems like a pretty darn cool idea to me.</strong>   The left quoting gives METHOD the missing piece of the binding it needs, so you don't need the workaround.</p>
<p>Cool as it is, it makes me wonder about the naming situation of having a PROCEDURE form.  If method needed a parallel to that, what would you call a method that doesn't return a value?  PROCMETHOD?  :-/</p>
<p>This leads me to feel that maybe PROCEDURE's semantics (0-arity "return", kill any result that might drop out) should be something you can indicate in either kind of spec easily.  And with <a href="https://forum.rebol.info/t/void-and-the-end-of-blankification/704">the new VOID! type</a>, we might have a coherent answer.  So...</p>
<p><em>Is there any really good reason why <strong><code>f: function [return: &lt;void&gt;] [...]</code></strong> couldn't be the signal to act like PROCEDURE does today, drop LEAVE, and just make RETURN not take an argument when that's that signature?</em></p>
<p>When definitional returns were being created, I was a bit worried about the idea that you might accidentally use a 0-arity RETURN with an argument.  But we are starting to need a test for "residual" execution anyway, to catch cases where you've got non-invisible content following something that RETURNs or throws, else we <a href="https://github.com/metaeducation/ren-c/issues/510">can't catch the "dark corner"</a> of <code>return if x [...] else [y]</code>.  So why not take a cue from C and just have a 0-arity RETURN in these cases?</p>
<p>People can still define PROCEDURE if they like it:</p>
<pre><code> procedure: func [spec body] [
     function compose [return: &lt;void&gt; (spec)]
         compose [leave: :return (body)]
 ]
</code></pre>
<p>To me it seems worth it to standardize so that METHOD can get the feature of auto-suppressing the result falling out of the bottom without needing another name, and it keeps from having to come up with two names for everything that wants to be function-like but do that.</p>
<p>There's technically no real reason why having this ability for FUNCTION needs to affect PROCEDURE.  It just may be more of a smooth transition to using METHOD to not teach people that a different action generator is how you get no-result.  Also, we could still say that <code>return: &lt;void&gt;</code> gives you a LEAVE instead of an arity-0 return if we wanted to.  It's perhaps no more of a non-sequitur than it was with PROCEDURE.  That's a separate decision... anyone have an opinion?</p>
            <p><small>10 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/method-and-the-argument-against-procedure/710">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/method-and-the-argument-against-procedure/710</link>
          <pubDate>Mon, 25 Jun 2018 04:02:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-710</guid>
          <source url="https://forum.rebol.info/t/method-and-the-argument-against-procedure/710.rss">METHOD and the argument against PROCEDURE</source>
        </item>
  </channel>
</rss>

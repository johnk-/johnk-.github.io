<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Development - AltRebol</title>
    <link>https://forum.rebol.info/c/development/8</link>
    <description>Topics in the &#39;Development&#39; category Discussion of the development of Rebol itself: language design, implementation and standard library.</description>
    
      <lastBuildDate>Sun, 25 Aug 2024 13:50:28 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/8.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Asking Claude.ai About Longstanding Naming Conflations</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p><em>Given the <a href="https://forum.rebol.info/t/any-array-vs-any-list/1384/10">good progress made on the ANY-ARRAY! vs ANY-LIST!</a> discussion, and having brought Claude up to speed with our domain problems, I thought to keep going with related problems from history...</em></p>
<hr>
<p>This has been very productive!</p>
<p>And it makes me realize that the memory-oriented structure for BINARY! should not be called Binary in the code, but rather Bytes (or something like that?)  For the same reasons.</p>
<pre><code>Bytes bytes = Make_Bytes(10, NODE_FLAG_MANAGED);
Init_Binary(OUT, bytes);
</code></pre>
<p>I'm not sure about what to do with String... :-/  All the strings are stored as UTF-8 but Utf8 means something else and I like how it's being used.  Right now it's Make_String() and Init_String(), but what else could it be?</p>
<pre><code>Heart heart = is_tag ? TYPE_TAG : TYPE_TEXT;
Xxx xxx = Make_Xxx(10, NODE_FLAG_MANAGED);
Init_String(OUT, heart, xxx);
</code></pre>
<p>Then there's a longstanding question of what the superclass of Array, Bytes, and Xxx for string would be.  It has been Series, with the same problem:</p>
<pre><code>void Some_Function(Yyy yyy) {  // Yyy is superclass of Array, Xxx, Bytes..
    Heart heart = is_array ? TYPE_BLOCK : TYPE_TEXT;
    Init_Series(OUT, heart, yyy);
}
</code></pre>
<p>Is it clear what I'm asking?</p>
<hr>
<blockquote>
<p>Yes, your question is clear, and it's an excellent extension of the naming considerations we've been discussing. Let's break this down:</p>
<ol>
<li>
<p>Binary / Bytes: Your suggestion to use <code>Bytes</code> for the memory-oriented structure of BINARY! is spot on. It follows the same logic as the Array/List distinction and improves clarity:</p>
<pre><code> Bytes bytes = Make_Bytes(10, NODE_FLAG_MANAGED);
 Init_Binary(OUT, bytes);
</code></pre>
</li>
</ol>
<p>This is a great improvement and consistent with the Array/List naming pattern.</p>
<ol start="2">
<li>String / Xxx: This is indeed trickier. Some possibilities to consider:</li>
</ol>
<ul>
<li>
<code>Chars</code>: Simple but might imply individual characters rather than a string.</li>
<li>
<code>Text</code>: Aligns with the TYPE_TEXT, but might be too high-level.</li>
<li>
<code>Utf8</code>: As you mentioned, it's already used for something else.</li>
<li>
<code>StringBuffer</code>: Descriptive but verbose.</li>
<li>
<code>Glyphs</code>: Emphasizes the visual representation, but might be too specific.</li>
</ul>
<p>Of these, I'm inclined towards <code>Text</code>, despite the potential confusion with TYPE_TEXT:</p>
<pre><code> Heart heart = is_tag ? TYPE_TAG : TYPE_TEXT;
 Text text = Make_Text(10, NODE_FLAG_MANAGED);
 Init_String(OUT, heart, text);
</code></pre>
<p>It's short, clear, and aligns well with the concept of a string. The potential confusion with TYPE_TEXT might actually be a feature, as it reinforces the relationship between the internal representation and the type.</p>
<ol start="3">
<li>Superclass for Array, Bytes, and Text (formerly Xxx): This is challenging because we want to avoid the term "Series" due to its historical baggage. Some options to consider:</li>
</ol>
<ul>
<li>
<code>Data</code>: Very generic, but could work as it encompasses all these types of data.</li>
<li>
<code>Buffer</code>: Emphasizes the idea of a contiguous memory area.</li>
<li>
<code>Sequence</code>: Similar to your use of ANY-SEQUENCE!, but for the internal representation.</li>
<li>
<code>Store</code>: Implies a place where data is held.</li>
<li>
<code>Span</code>: Suggests a contiguous range of memory.</li>
</ul>
<p>Of these, I'm leaning towards <code>Buffer</code> as it most accurately describes what these types have in common - a contiguous area of memory holding data:</p>
<pre><code>void Some_Function(Buffer buffer) {  // Buffer is superclass of Array, Text, Bytes
    Heart heart = is_array ? TYPE_BLOCK : TYPE_TEXT;
    Init_Series(OUT, heart, buffer);
}
</code></pre>
<p>You might even consider renaming <code>Init_Series</code> to <code>Init_Buffer</code> for consistency:</p>
<pre><code>void Some_Function(Buffer buffer) {
    Heart heart = is_array ? TYPE_BLOCK : TYPE_TEXT;
    Init_Buffer(OUT, heart, buffer);
}
</code></pre>
<p>This naming scheme provides a clear hierarchy:</p>
<ul>
<li>Buffer (low-level, contiguous memory)</li>
<li>Array (for Lists)</li>
<li>Text (for Strings)</li>
<li>Bytes (for Binaries)</li>
</ul>
<p>It maintains the distinction between implementation details and higher-level concepts while providing clear and consistent naming throughout the codebase.</p>
</blockquote>
<hr>
<p>One might call the actual dynamically allocated data structure a Deque (double ended queue), because that's what it is...but there's more baggage to it than that.  It has tons of fiddly properties.  It's truly a Rebol-specific concept.</p>
<p>I'm reminded of an old library I used called "flexlist".  Perhaps it could be a Flex?  Something like that... referring to its ability to be resized.  I used to work for Microsoft actually...and it was decades ago so I don't remember specifics anymore...but we had some weird names like that to try and avoid people making assumptions that they knew the properties of what they were dealing with.</p>
<p>And in fact I'm sort of feeling now that there's a bit of deception about the complexity of the abstraction by using simple terms like Bytes and Array.    (I'm a little nervous that Bytes sounds too much like a plain pointer to Byte and not a more interesting structure.)</p>
<p>But I don't like the idea of something like FlexString, FlexBinary, and FlexList because that would be almost as bad as the converse of dealing with the String/Init_Any_String distinction!  So compromising to say that within the domain of the source code of the project, Array is understood as being an Array of Rebol Cells built on top of the Flex seems reasonable.</p>
<hr>
<blockquote>
<p>Your thoughts on this are very insightful, and I agree that there's a balance to strike between simplicity and accuracy in naming these complex structures. The idea of using a term like "Flex" is intriguing, as it does capture the dynamic nature of these data structures without implying a specific implementation or set of properties. Let's explore this direction:</p>
<ol>
<li>Core dynamic structure: Flex</li>
</ol>
<p>This could be the superclass for all the dynamically resizable structures in Rebol. It conveys flexibility without tying to a specific implementation detail.</p>
<pre><code>void Some_Function(Flex flex) {
    Heart heart = is_array ? TYPE_BLOCK : TYPE_TEXT;
    Init_Value(OUT, heart, flex);
}
</code></pre>
<ol start="2">
<li>Specific types built on Flex:</li>
</ol>
<ul>
<li>For lists: ArrayFlex (or keep it as Array, understood to be built on Flex)</li>
<li>For strings: StringFlex (or TextFlex)</li>
<li>For binaries: BytesFlex (or BinaryFlex)</li>
</ul>
<p>This naming scheme acknowledges the complexity of these structures while maintaining a level of simplicity in day-to-day usage. It also provides a clear hint that these are not simple C arrays or strings, but more complex Rebol-specific structures.</p>
<p>So, the code might look like:</p>
<pre><code>ArrayFlex array = Make_ArrayFlex(10, NODE_FLAG_MANAGED);
Init_List(OUT, array);

StringFlex text = Make_StringFlex(10, NODE_FLAG_MANAGED);
Init_String(OUT, heart, text);

BytesFlex bytes = Make_BytesFlex(10, NODE_FLAG_MANAGED);
Init_Binary(OUT, bytes);
</code></pre>
<p>Or, if you prefer to keep the simpler names for daily use:</p>
<pre><code>Array array = Make_Array(10, NODE_FLAG_MANAGED);  // Understood to be a Flex-based Array
Init_List(OUT, array);

Text text = Make_Text(10, NODE_FLAG_MANAGED);  // Understood to be a Flex-based Text
Init_String(OUT, heart, text);

Bytes bytes = Make_Bytes(10, NODE_FLAG_MANAGED);  // Understood to be a Flex-based Bytes
Init_Binary(OUT, bytes);
</code></pre>
<p>This approach:</p>
<ol>
<li>Uses "Flex" to denote the core dynamic structure, hinting at its complexity and flexibility.</li>
<li>Allows for simpler names in daily use (Array, Text, Bytes) while understanding they're built on Flex.</li>
<li>Avoids confusion with plain C types.</li>
<li>Maintains the distinction between low-level structures and high-level types (List, String, Binary).</li>
</ol>
<p>The term "Flex" serves as a reminder that these are not simple data structures, but complex, Rebol-specific implementations with many properties. It's a good compromise between accuracy and simplicity, and it leaves room for future expansion or modification of the underlying implementation without breaking the conceptual model.</p>
</blockquote>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/asking-claude-ai-about-longstanding-naming-conflations/2221">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/asking-claude-ai-about-longstanding-naming-conflations/2221</link>
          <pubDate>Sun, 25 Aug 2024 13:50:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2221</guid>
          <source url="https://forum.rebol.info/t/asking-claude-ai-about-longstanding-naming-conflations/2221.rss">Asking Claude.ai About Longstanding Naming Conflations</source>
        </item>
        <item>
          <title>Wolfram Language</title>
          <dc:creator><![CDATA[vnzio]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Wolfram Mathematica = now called<br>
"Wolfram Language"</p>
<p>has some nice abreviation symbol/shortcuts  for typing</p>
<p>But all have the names visible when you invoke<br>
<strong>FullForm[]</strong><br>
and the good docs all suggest how to say them out loud<br>
Very nice &amp;important for teaching<br>
And or in any videos</p>
<p>Rebol I think was much inspired by Mathematica</p>
<p>(I don't know for sure)</p>
            <p><small>8 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/wolfram-language/2218">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/wolfram-language/2218</link>
          <pubDate>Sun, 25 Aug 2024 03:23:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2218</guid>
          <source url="https://forum.rebol.info/t/wolfram-language/2218.rss">Wolfram Language</source>
        </item>
        <item>
          <title>What to Call Lone Tilde (~)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>So this little guy doesn't have a name:</p>
<p><img src="https://forum.rebol.info/uploads/default/original/1X/98fe977bff93e2b3dfd91a030a3c088d925cc1ec.png" alt="1896_tilde" data-base62-sha1="lPs2dyWS6kN1weGeGoU7SyMbh5a" width="125" height="125"></p>
<p>Yes it's a "tilde", but if there's a TILDE definition I think it should be talking about the character.</p>
<pre><code>&gt;&gt; print ["name" tilde "me"]
name ~ me

&gt;&gt; char? tilde
== ~true~  ; anti
</code></pre>
<p>We're talking about something that evaluates to the antiform of blank (the contents of an unset variable):</p>
<pre><code>&gt;&gt; eval [~]
== ~  ; anti
</code></pre>
<h2>
<a name="quasi-blank-1" class="anchor" href="https://forum.rebol.info#quasi-blank-1"></a>QUASI-BLANK?</h2>
<p>It's an <em>accurate</em> name...</p>
<pre><code>&gt;&gt; quasi _
== ~
</code></pre>
<p>But if you're going to be testing for them easily in a block, you want something shorter.</p>
<p>Carl went on a bit of a bizarre track by deciding that #[none] was unweildy in blocks, and he liked zeros better... single characters... so <a href="http://www.rebol.net/r3blogs/0112.html">he started using zeros instead of nones, and made ZERO? accept everything</a>.</p>
<blockquote>
<p><em>I started using a lot more zeros in my data structures, especially those that had to be loaded from a file or database, because I knew that zero loaded more efficiently than NONE (no hash was required).</em></p>
<p><em>For example, where I would once create REBOL-stored DB records like this:</em></p>
<pre><code>["name" none none]
</code></pre>
<p><em>I would use:</em></p>
<pre><code>["name" 0 0]
</code></pre>
<p><em>Because using 0 does not require a hash-and-compare operation (as does the word NONE) nor does it require binding (as does the value NONE)... nor is it the long-form literal #[none], that seems just a bit too cumbersome to my coding style.</em></p>
</blockquote>
<p>You're getting a lot of single-character choices in Ren-C, and which one you use kind of depends on what you want.</p>
<p>QUASI-BLANK is as ornery as it can be while being legal to appear in a block.  e.g. if you try to ask it something like EMPTY? you'll get an error:</p>
<pre><code>&gt;&gt; block: ["name" ~ ~]

&gt;&gt; empty? second block
** Script Error: empty? expects [blank! any-series? object! port! bitset! map!]
      for its series argument
</code></pre>
<p>If you use BLANK! you have not just a different look, but more routines that are willing to think of it as being some kind of emptiness:</p>
<pre><code>&gt;&gt; block: ["name" _ _]

&gt;&gt; empty? second block
== ~true~  ; anti
</code></pre>
<p>There's also #, which is effectively the zero character.</p>
<pre><code>&gt;&gt; block: ["name" # #]

&gt;&gt; append #{DECAFBAD} second block
== #{DECAFBAD00}

&gt;&gt; append "Hello" second block
** Script Error: #{00} bytes illegal in ANY-STRING?, use BINARY!
</code></pre>
<h2>
<a name="does-it-need-a-name-2" class="anchor" href="https://forum.rebol.info#does-it-need-a-name-2"></a>Does It Need A Name?</h2>
<p>Something that makes it desirable for QUASI-BLANK to have a name is that because it's evaluative, you can't just compare to it directly without quoting it.</p>
<pre><code>if '~ = second block [...]
</code></pre>
<p>BLANK! and the NUL character don't have that problem.</p>
<pre><code>if _ = second block [...]

if # = second block [...]
</code></pre>
<p>But still, Rebol tries to reduce the symboly-ness, and that looks nicer if there's a test you're going to be performing a lot:</p>
<pre><code>if blank? second block [...]
</code></pre>
<p>So I think that QUASI-BLANK needs a nice short name, to help avoid people writing sequences like <strong><code>'~ =</code></strong> often in their code.</p>
<h2>
<a name="i-hate-to-suggest-it-but-what-about-none-3" class="anchor" href="https://forum.rebol.info#i-hate-to-suggest-it-but-what-about-none-3"></a>I Hate To Suggest It... But... What About NONE?</h2>
<p>I never liked the name NONE for what it was.  It's the wrong part of speech, and I want it to be like ANY and ALL to let you test a series of expressions for all of them being falsey.</p>
<pre><code>&gt;&gt; if none [1 &gt; 2, 3 &gt; 4, 5 &gt; 6] [print "Math is working"]
Math is working.
</code></pre>
<p>That's less awkward than <strong><code>all :: [/predicate :not, [1 &gt; 2, 3 &gt; 4, 5 &gt; 6]]</code></strong></p>
<p>But I'm having a hard time thinking of anything else short and good.  HOLE?  JUNK?</p>
<p>The AI <a href="https://forum.rebol.info/t/what-to-call-the-unstable-antiform-of-empty-block/2204">really want something to be called WISP?</a> for some reason.</p>
<p>Something related to QUASI... QUASAR?  That's actually kind of cool but ridiculous.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<p>I'm sad to think that the best name is NONE.  Hopefully it isn't.</p>
            <p><small>8 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/what-to-call-lone-tilde/2216">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-to-call-lone-tilde/2216</link>
          <pubDate>Sat, 24 Aug 2024 18:00:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2216</guid>
          <source url="https://forum.rebol.info/t/what-to-call-lone-tilde/2216.rss">What to Call Lone Tilde (~)</source>
        </item>
        <item>
          <title>Why @ Isn&#39;t A Precise Synonym For THE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>The SIGIL! @ has non-overrideable behavior in the evaluator.  It acts like THE (Ren-C's parallel to Redbol's QUOTE)</p>
<pre><code>&gt;&gt; @ foo
== foo

&gt;&gt; @ (1 + 2)
== (1 + 2)

&gt;&gt; the foo
== foo

&gt;&gt; the (1 + 2)
== (1 + 2)
</code></pre>
<p>But it does something a normal function can't...which is to effectively put antiforms in suspended animation in the API.</p>
<p>If it worked in the main language, it would be like this:</p>
<pre><code>&gt;&gt; eval impossible-compose [@ ('~null~)]
== ~null~

&gt;&gt; eval impossible-compose [@ (null)]
== ~null~  ; anti
</code></pre>
<p>You might imagine the @ operator doing a little cheat, by turning quasiform null into antiform null.  Then IMPOSSIBLE-COMPOSE could just do this:</p>
<pre><code>&gt;&gt; block: impossible-compose [@ (null)]
== [@ ~null~]

&gt;&gt; eval block
== ~null~  ; anti
</code></pre>
<p>For a time this is exactly what it did.  But then...how would you literally get a quasiform null?  It can't do both.</p>
<p>Today, using some magic in the evaluator, this API code works:</p>
<pre><code>Value* result1 = rebValue("eval [@", nullptr, "]);
assert(result1 == nullptr);

Value* result2 = rebValue("eval [@ ~null~"]);
rebElide("assert ['~null~ = first [", result2, "]]");
</code></pre>
<p>It depends on @ not being overrideable and always using the special evaluator magic that lets this work, when you can't do it inside Rebol.</p>
<h2>
<a name="why-let-the-api-do-something-the-language-cant-1" class="anchor" href="https://forum.rebol.info#why-let-the-api-do-something-the-language-cant-1"></a>Why Let The API Do Something The Language Can't?</h2>
<p>Because quite simply... <strong>rebQ(thing)</strong> in the API is uglier than <strong><code>'thing</code></strong> which you can do if you're in the language.</p>
<p>And which would you rather read?</p>
<pre><code>Value* result1 = rebValue("eval [", rebQ(nullptr), "]);

Value* result1 = rebValue("eval [@", nullptr, "]);
</code></pre>
<p>The second is also faster.</p>
<p>Anyway, there are other ways of doing it that don't use a literalizing operator.  But here, a literalizing operator is what we generally want.  We just want it to reconstruct antiforms, and a hack lets us do it.</p>
<h2>
<a name="is-this-dangerous-2" class="anchor" href="https://forum.rebol.info#is-this-dangerous-2"></a>Is This Dangerous?</h2>
<p>The hack has the slightly undesirable property that if you asked for the API code you are running as a block, you couldn't get a legitimate block out of it.</p>
<p>So if you were stepping in a debugger or something, there's an impossible situation in play... something that's not a legal array element is sitting in a slot where the antiform is.  And when the evaluator hits that thing it will almost always give an API error saying "you can't do that".</p>
<p>So this would fail:</p>
<pre><code>rebElide("block: [@", nullptr, "]")
</code></pre>
<p>There's no evaluation going on inside that block here, so no exception.  You can't put antiforms in blocks and receive that block as a normal value.</p>
<p>But as long as it is in an evaluative context immediately after @, then the action is to reconstitute the antiform as an evaluative product.</p>
<p>A debugger would have to have special awareness of this if it were to show you the array, and never let it leak out from the API feed.  If you copied it out you would have to get a warning that the antiforms had all been converted to quasiforms and the code wouldn't work.</p>
<p>My belief is that this is worth it.  I couldn't justify it (or even figure out how it would be done) when @ was just running an ordinary function, because it would create a crazy parameter convention exception, and leak the mechanic to places it should never be seen.  But this isolates it to where it's a built-in evaluator capability that you mostly don't need to know how it works.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/why-isnt-a-precise-synonym-for-the/2215">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/why-isnt-a-precise-synonym-for-the/2215</link>
          <pubDate>Sat, 24 Aug 2024 07:07:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2215</guid>
          <source url="https://forum.rebol.info/t/why-isnt-a-precise-synonym-for-the/2215.rss">Why @ Isn&#39;t A Precise Synonym For THE</source>
        </item>
        <item>
          <title>JUST the APOSTROPHE (&#39;) SIGIL!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Binding</category>
          <description><![CDATA[
            <p><em>This ties together quite nicely.  cc: <a class="mention" href="https://forum.rebol.info/u/bradrn">@bradrn</a></em></p>
<hr>
<p>So I'd been fretting over whether <strong><code>@</code></strong> would bind the thing you passed it or not.  It had to bind things for the system to work, so I went with that... even though it may not be what you want in all cases:</p>
<pre><code>&gt;&gt; abc: 10

&gt;&gt; word: @ abc
== abc

&gt;&gt; get word
== 10
</code></pre>
<p><strong><code>@foo</code></strong> is a THE-WORD! and so <strong><code>@</code></strong> makes sense as a synonym for an operator called THE.</p>
<pre><code>&gt;&gt; the abc
== abc ; bound
</code></pre>
<p>But what if you don't want a binding?  THE/UNBOUND?  Is there no symbol?</p>
<h2>
<a name="a-part-in-the-box-becomes-available-apostrophe-1" class="anchor" href="https://forum.rebol.info#a-part-in-the-box-becomes-available-apostrophe-1"></a>A Part In The Box Becomes Available: APOSTROPHE (')</h2>
<p>For a very long time, apostrophe was considered the quoted form of VOID (or NULL, before void existed).  So it evaluated to void, and voids were invisible in the console:</p>
<pre><code>&gt;&gt; if false [print "conditional returns void"]

&gt;&gt; meta if false [print "conditional returns void"]
'

&gt;&gt; quote void
== '

&gt;&gt; append [a b c] '
== [a b c]
</code></pre>
<p><em><strong>"Isn't that cool"</strong></em>, I thought.  <em><strong>"Void is the absence of anything, and so when you quote it you get just a lone apostrophe.  And when the lone apostrophe boils away after removing the quote in evaluation, you have nothingness!!!  It's perfect for displaying nothing as a result!"</strong></em></p>
<p>Slow clap.  <img src="https://forum.rebol.info/images/emoji/twitter/clap.png?v=12" title=":clap:" class="emoji" alt=":clap:" loading="lazy" width="20" height="20"></p>
<p>It was a cute idea in the pre-isotopic era.  But once we had quasiforms and antiforms, <strong><a href="https://forum.rebol.info/t/why-shouldnt-void-be-done-with-a-void-word-antiform/2160">making void the antiform of the word <code>void</code> has many more merits.</a></strong></p>
<p>So lone apostrophe went back into the "unused" bin, and I wondered what to do with it.  What type would it be?  Couldn't be a WORD!</p>
<h2>
<a name="but-sigil-were-invented-simultaneously-to-voidhttpsforumrebolinfotweird-word-s-allow-but-escape-them156010uhostilefork-2" class="anchor" href="https://forum.rebol.info#but-sigil-were-invented-simultaneously-to-voidhttpsforumrebolinfotweird-word-s-allow-but-escape-them156010uhostilefork-2"></a>But... <a href="https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560/10">SIGIL! Were Invented Simultaneously To ~void~</a>
</h2>
<p>They happened in basically the same week.  I'm not sure why it didn't occur to me to make <strong><code>'</code></strong> a SIGIL!</p>
<p>Why not?</p>
<pre><code>&gt;&gt; sigil of first [''a]
== '
</code></pre>
<p>Now we have our non-binding literal operator.</p>
<pre><code>&gt;&gt; abc: 10

&gt;&gt; word: ' abc

&gt;&gt; get word
** Script Error: abc word is not bound to a context
</code></pre>
<p>And I think a good name for it would be... JUST:</p>
<pre><code>&gt;&gt; just abc
== abc  ; not bound
</code></pre>
<ul>
<li>
<p>It's a good part of speech (LITERAL seems like a variable name)</p>
</li>
<li>
<p>It's short (LITERALLY would be obnoxious)</p>
</li>
<li>
<p>I think that JUST has a good shade of meaning of <em>"just give me the array element, I don't want the extras...no pickles, no lettuce, and no binding"</em></p>
</li>
</ul>
<h2>
<a name="seems-perfect-to-me-3" class="anchor" href="https://forum.rebol.info#seems-perfect-to-me-3"></a>Seems Perfect To Me</h2>
<p>This goes along with the idea of when you declare your function arguments as being literal, if you say <strong><code>'foo</code></strong> for the argument you will get it with no added binding, and if you say <strong><code>@foo</code></strong> it will bind in the context of the callsite.</p>
<p>Anyway, they're "literal arguments"... not "quoted arguments"... because no quoting level is added.  Except perhaps an imaginary quoting level added in your head at the callsite which the evaluator strips off, but that doesn't happen.  (In fact it can't happen for @, because for anything but a plain WORD!/BLOCK!/TUPLE!/etc. there's no way to add an @ onto something like an INTEGER! or the like.)</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/just-the-apostrophe-sigil/2213">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/just-the-apostrophe-sigil/2213</link>
          <pubDate>Sat, 24 Aug 2024 05:38:36 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2213</guid>
          <source url="https://forum.rebol.info/t/just-the-apostrophe-sigil/2213.rss">JUST the APOSTROPHE (&#39;) SIGIL!</source>
        </item>
        <item>
          <title>SET-WORD! To Initialize Locals In Function Specs?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p><em>(cc: <a class="mention" href="https://forum.rebol.info/u/ingohohmann">@IngoHohmann</a> as you have had opinions on these kinds of things.)</em></p>
<p>It seems it would be nice if you had the option of setting your locals when you define them.</p>
<pre><code>foo: func [
    arg1 [integer!]
    arg2 [text!]
    &lt;local&gt;
    local1 local2
    local3: 10
    local4: (20 * 30)
][
    ...
]
</code></pre>
<p>As it so happens, there's potential to exploit this for efficiency.  The frame mechanics have a slot for each local in the function archetype that currently just holds trash, and it could hold this default value / expression.  So it wouldn't just save on typing the local name and then later the name again and the expression...but you're avoiding the need to perform the evaluation to do the assignment on each call!</p>
<p>There's a lot of questions to answer:</p>
<ul>
<li>
<p>What binding rules is it using?  Could you initialize local3 and then say <strong><code>local4: (local2 * arg1)</code></strong>?</p>
<ul>
<li>Almost certainly not, and it would just be using the binding of the spec block</li>
</ul>
</li>
<li>
<p>Does the code run on each invocation, or is it run only once to calculate a fixed value?  e.g. if it was <strong><code>local4: (global-var * 30)</code></strong> would each invocation of FOO recalculate what <strong><code>(global-var * 30)</code></strong> was at that moment?</p>
<ul>
<li>Almost certainly would just calculate a fixed value and use that value on each call.</li>
</ul>
</li>
<li>
<p>Do you need parentheses directly after the SET-WORD!?</p>
<ul>
<li>
<p>If the expression were run on each invocation (which it probably shouldn't be) then it would be a requirement, because there'd be no way to find the start and the end of the right hand expression without evaluating it.</p>
</li>
<li>
<p>If plain words are being picked up as locals there's potential for error if you accidentally wrote an expression that didn't work, like:</p>
<pre><code>func [
   arg [integer!]
   &lt;local&gt;
   local1 local2
   local3: arity-2-but-I-think-it's-3 a b c
   local4: 10
][
    ...
]
</code></pre>
<p>That could wind up making a local <strong><code>c</code></strong> that you didn't intend.  But then again, sometimes it would be just a very obvious simple initialization, like <strong><code>local4: 10</code></strong>.  Forcing people to use parentheses could do more harm than good, vs. trusting them to use the parentheses if they feel it's warranted.</p>
</li>
</ul>
</li>
</ul>
<h2>
<a name="compare-to-static-not-initialized-with-set-word-atm-1" class="anchor" href="https://forum.rebol.info#compare-to-static-not-initialized-with-set-word-atm-1"></a>Compare to <code>&lt;static&gt;</code>: Not Initialized With SET-WORD! ATM</h2>
<p>Right now the <code>&lt;static&gt;</code> feature lets you assign your variables, but it uses a non-Reboly-notation to do so:</p>
<pre><code>accumulate: func [
    item [any-element?]
    &lt;static&gt;
    block ([])
][
    append block item
]
</code></pre>
<p>The parentheses are optional to hold the initializer.  But  it seems much more normal to say:</p>
<pre><code>accumulate: func [
    item [any-element?]
    &lt;static&gt;
    block: []
][
    append block item
]
</code></pre>
<p>One reason for the parentheses notation was to try and be consistent with the idea of defaulting refinements.</p>
<pre><code>&gt;&gt; foo: func [/string [text!] ("default")] [print string]

&gt;&gt; foo/string "hello"
hello

&gt;&gt; foo
default
</code></pre>
<p>But that feature was removed</p>
<p>There's another reason why just WORD! was used...</p>
<h2>
<a name="return-has-owned-set-word-in-the-spec-dialect-2" class="anchor" href="https://forum.rebol.info#return-has-owned-set-word-in-the-spec-dialect-2"></a>RETURN: Has "Owned" SET-WORD! In The Spec Dialect</h2>
<p>We have a little bit of friction in that the dialect has been using RETURN: to indicate what a function returns.  The choice has not much to do with what comes after a return being an assignment any more than anything else, it was picked for looks:</p>
<pre><code>double-multiply: func [
    return: [integer!]
    value1 [integer!]
    value2 [integer!]
][
    return 2 * value1 * value2
]
</code></pre>
<p>The issue is that historical Rebol2 (and R3-Alpha, and Red) allow this:</p>
<pre><code>rebol2&gt;&gt; print-sum: func [return break] [print ["Sum is" return + break]]

rebol2&gt;&gt; print-sum 10 20
Sum is 30
</code></pre>
<p>Ren-C only lets you do that in LAMBDA.  FUNC prohibits it:</p>
<pre><code>ren-c&gt;&gt; print-sum: func [return break] [print [return + break]]
** Error: Generator provides RETURN:, use LAMBDA if not desired
</code></pre>
<p>I think Red/System decided on RETURN: first.  <a href="https://static.red-lang.org/red-system-specs-light.html#section-3.3">But they put it at the end of the spec.</a>  Red errors if you try to put the return elsewhere:</p>
<pre><code>red&gt;&gt; stringy: func [a b return: [string!]] [a + b]
== func [a b return: [string!]][a + b]

red&gt;&gt; stringy: func [return: [string!] a  b] [a + b]
*** Script Error: invalid function definition: [return: [string!] a b]
</code></pre>
<p>But either way, it's not checked.  On the <a href="https://www.red-lang.org/2012/12/red-v031-functions-support-added.html">2012 announcement of function support in Red</a>, DocKimbel says: <em>"Note: argument and return value type checking have not been implemented yet, they need typeset! and error! datatypes to be implemented first."</em>  Parameter type checking works, but I guess return type checking was never added.  It does show up in the HELP though.</p>
<pre><code>red&gt;&gt; help stringy
USAGE:
     STRINGY a b

DESCRIPTION: 
     STRINGY is a function! value.

ARGUMENTS:
     a             
     b             

RETURNS:
     [string!]
</code></pre>
<p>Note that they also put the RETURNS: at the end there, too.  Most people would expect the return value for functions to be the first thing you put down.</p>
<h2>
<a name="ive-wondered-if-a-leading-block-would-suffice-3" class="anchor" href="https://forum.rebol.info#ive-wondered-if-a-leading-block-would-suffice-3"></a>I've Wondered If A Leading Block Would Suffice...</h2>
<p>Off and on, I've been willing to consider the idea that return typing is just implicitly what you get if you have a leading block:</p>
<pre><code>double-multiply: func [
    [integer!]
    value1 [integer!]
    value2 [integer!]
][
   return 2 * value1 * value2
]
</code></pre>
<p>Yet while it looks clean there, it causes some problems when you are filling in documentation strings.</p>
<p>I've become a pretty true believer in the idea that documentation strings for arguments come after the argument name (and that we may do a service to the userbase by standardizing this, rather than by letting it be done either way and have people fight about it):</p>
<pre><code> my-style: func [
     "Overall function description here"
     argument "Argument description here"
         [integer! text!]
     /refinement "Refinement description here"
 ][
    ...
 ]
</code></pre>
<p>The rationale is that any good function will put labels on all its arguments.  But not all arguments are type-constrained, in particular refinements are not.  So you wind up either being inconsistent</p>
<pre><code> variation1: func [
     "Overall function description here"
     argument [integer! text!]
         "Argument description here"
     /refinement "Refinement description here"  ; this feels inconsistent
 ][
    ...
 ]
</code></pre>
<p>Or you're throwing in newlines for no reason</p>
<pre><code> variation2: func [
     "Overall function description here"
     argument [integer! text!]
         "Argument description here"
     /refinement
         "Refinement description here"  ; consistent, but annoying
 ][
    ...
 ]
</code></pre>
<p>This is why I chose "MY-STYLE" above.  But if return becomes implicit on a leading block, you wind up back in inconsistent land:</p>
<pre><code>my-style-with-leading-block: func [
     "Overall function description here"
     [integer!] "Description here"
     argument "Argument description here"
         [integer! text!]
     /refinement "Refinement description here"
 ][
    ...
 ]
</code></pre>
<p>So one thing RETURN: has historically bought us is making that look better:</p>
<pre><code>my-style-with-leading-block: func [
     "Overall function description here"
     return: "Description here"
         [integer!] 
     argument "Argument description here"
         [integer! text!]
     /refinement "Refinement description here"
 ][
    ...
 ]
</code></pre>
<p>And I think having the word RETURN in there makes it better.  Note how it's less obvious when the word isn't there what that is.</p>
<h2>
<a name="but-set-word-is-that-best-4" class="anchor" href="https://forum.rebol.info#but-set-word-is-that-best-4"></a>But SET-WORD!... is that best?</h2>
<p>If we're going to be allowing SET-WORD! for locals and statics, does it make sense to have a stray SET-WORD! for RETURN?</p>
<p>And one outside-the-box thought... given that modern FUNC doesn't allow you to name parameters RETURN, why not just go with a plain WORD! ?</p>
<pre><code>what-about-plain-word: func [
    "Overall function description here"
    return "Description here"
        [integer!] 
    argument "Argument description here"
        [integer! text!]
    /refinement "Refinement description here"
 ][
    ...
 ]
</code></pre>
<p>If you try that with a LAMBDA you'll not get an error, and maybe suffer some confusion when the lambda gets its first argument as a variable named RETURN.  You'll figure it out pretty quickly, though.</p>
<p>Though I have wondered about questions like "what if you want the behavior of a lambda with the bottom expression dropping out, and no RETURN declared, but you still want type checking?"</p>
<p>You might say "just use ENSURE"</p>
<pre><code> my-lambda: lambda [
    "Overall function description here"
    argument "Argument description here"
        [integer! text!]
    /refinement "Refinement description here"
 ][
    ensure [integer!] [
        ...
    ]
 ]
</code></pre>
<p>The problem is that the return type and any description don't make it to the HELP.  This is one reason that I pretty much always use FUNC.</p>
<p>This makes one want to lean back to the return type being something nameless, like just a leading block.</p>
<h2>
<a name="not-sure-on-return-but-i-like-set-word-locals-5" class="anchor" href="https://forum.rebol.info#not-sure-on-return-but-i-like-set-word-locals-5"></a>Not Sure On RETURN, But I Like SET-WORD! Locals</h2>
<p>I definitely feel that finding a way to not be using SET-WORD! for RETURN: would be good.  It's not like it has anything to do with assignment.</p>
<p>Plain word RETURN in FUNC is not an idea that I'm feeling is as crazy as it might sound.</p>
<p>I do think that I like the idea of SET-WORD! for local initialization... that runs the right hand side without required parentheses, and that only runs the evaluation once in the environment of the spec block... stowing that value in the currently-just-trash slots of the frame archetype for the local.</p>
<p>And I like the idea of bringing <code>&lt;static&gt;</code> on board with the same rules.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/set-word-to-initialize-locals-in-function-specs/2210">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/set-word-to-initialize-locals-in-function-specs/2210</link>
          <pubDate>Sat, 24 Aug 2024 03:00:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2210</guid>
          <source url="https://forum.rebol.info/t/set-word-to-initialize-locals-in-function-specs/2210.rss">SET-WORD! To Initialize Locals In Function Specs?</source>
        </item>
        <item>
          <title>No Raised Errors in PACK! (But Feel The Power!)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>I haven't been completely thrilled about being able to put raised errors in parameter packs.  But initially, I allowed it:</p>
<pre><code>&gt;&gt; block: []
== []

&gt;&gt; pack [take block, 10 + 20]
; first in pack of length 2
== ~make error! [
    type: 'Script
    id: 'nothing-to-take
    message: "Can't TAKE, no value available (consider TRY TAKE)"
    near: '[take [] **]
    where: '[take reduce pack console]
    file: ~null~
    line: 1
]~  ; anti
</code></pre>
<p>Honestly this seems wrong. I allow you to PACK a PACK, and that's okay. But glossing over the error at time of packing I do not like.</p>
<p>I much prefer:</p>
<pre><code>&gt;&gt; pack [take block, 10 + 20]
** Script Error: Can't TAKE, no value available (consider TRY TAKE)
</code></pre>
<h2>
<a name="only-one-use-case-maxmatch-d-and-maxmatch-chttpsgithubcommetaeducationren-cblob8516f0fca8ddce40a97e7647a087dc55e065cf3btestsparseexamplesmaxmatchparsetestreb-1" class="anchor" href="https://forum.rebol.info#only-one-use-case-maxmatch-d-and-maxmatch-chttpsgithubcommetaeducationren-cblob8516f0fca8ddce40a97e7647a087dc55e065cf3btestsparseexamplesmaxmatchparsetestreb-1"></a>Only One Use Case: <a href="https://github.com/metaeducation/ren-c/blob/8516f0fca8ddce40a97e7647a087dc55e065cf3b/tests/parse/examples/maxmatch.parse.test.reb">MAXMATCH-D (and MAXMATCH-C)</a>
</h2>
<p>In practice, only one place was making use of the ability to put raised errors in packs:</p>
<pre><code>maxmatch-D: combinator [  ; "(D)efault"
    {Match maximum of two rules, keeping side effects of both if match}
    return: "Result of the longest match (favors first parser if equal)"
       [any-value? pack?]
    parser1 [action?]
    parser2 [action?]
    &lt;local&gt; result1' result2' remainder1 remainder2
][
    [~^result1'~ remainder1]: parser1 input except e -&gt; [
        pack [raise e, null]
    ]
    [~^result2'~ remainder2]: parser2 input except e -&gt; [
        pack [raise e, null]
    ]
    if raised? unmeta result2' [  ; parser2 didn't succeed
        if raised? unmeta result1' [
            return unmeta result1'  ; neither succeeded
        ]
    ] else [  ; parser2 succeeded
        any [
            raised? unmeta result1'
            (index of remainder1) &lt; (index of remainder2)
        ] then [
            remainder: remainder2
            return unmeta result2'
        ]
    ]
    remainder: remainder1
    return unmeta result1'
]
</code></pre>
<p>Two parsers here are called with two results, and this tries to handle the case of when one "result" is a raised error...putting it into the same slot where a result would be.</p>
<p>The problem is that the EXCEPT statement is producing an expression that is targeting a pack.  And in the first slot of that pack is a potentially-anything-value... anything but a raised error, that is.  If you try to cheat and put a non-raised error in that slot, how would you know the parser you called wasn't just generating an ERROR! value to pass around?  You need another state.</p>
<h2>
<a name="no-other-choice-or-is-there-2" class="anchor" href="https://forum.rebol.info#no-other-choice-or-is-there-2"></a>No Other Choice... Or... Is There?</h2>
<p>The second slot is a series position.  You could poke a plain error there, and by virtue of seeing the <code>remainder1</code> is an ERROR! and not an ANY-SERIES! you'll know that parser1 raised an error.</p>
<p>So instead of:</p>
<pre><code>[~^result1'~ remainder1]: parser1 input except e -&gt; [
    pack [raise e, null]
]
</code></pre>
<p>You'd do:</p>
<pre><code>[^result1' remainder1]: parser1 input except e -&gt; [
    pack [~, e]  ; say result1 is trash, and remainder1 is e
]
</code></pre>
<p>Your variable names are a bit weird here, because it's actually <strong><code>remainder-or-error-1</code></strong>.  But you've built an expression that targets the pack.</p>
<p><strong>But why are we being so stingy about variables?</strong>  Why not expand the pack to three items?</p>
<pre><code>[^result1' remainder1 /error1]: parser1 input except e -&gt; [
     pack [~, ~, e]
]
</code></pre>
<p>(You have to use the <strong><code>/error1</code></strong> syntax if the non-erroring parser case returns a pack with only two items in it.  The slash means you're okay with fewer items in the source pack and it will set error1 to null in that case.)</p>
<p>Or... why are we bothering to make the error case use EXCEPT?  You have TRAP for definitional errors as well.  It returns NULL if no raised error, and the non-raised form of the ERROR! if there was one:</p>
<pre><code>&gt;&gt; trap [1 + 2]
== ~null~  ; anti

&gt;&gt; trap [1 / 0]
== make error! [
    type: 'Math
    id: 'zero-divide
    message: "attempt to divide by zero"
    near: '[1 / 0 **]
    where: '[/ entrap trap console]
    file: ~null~
    line: 1
]
</code></pre>
<p>Leveraging that gives you basically the cleanest code you could ask for:</p>
<pre><code>error1: trap [[^result1' remainder1]: parser1 input]
</code></pre>
<p><em>(Let me point out that the ability to intercept a definitional error coming from PARSER1 by having it "pass through" a SET-BLOCK! (or a SET-WORD!) is a feature to enable precisely this scenario.  None of the assignments will be performed. And <strong>that is the limit</strong> of how far it will jump and be allowed to TRAP before it will be promoted to a failure.  If you're not up to speed on definitional errors, <a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-errors/1852">read up on them</a>, because they are absolutely critical to coherent error interception.)</em></p>
<h2>
<a name="so-forget-about-raised-errors-in-pack-3" class="anchor" href="https://forum.rebol.info#so-forget-about-raised-errors-in-pack-3"></a>So Forget About Raised Errors in PACK!</h2>
<p>It's a terrible idea.  I'm killing it off.</p>
<p>Compare the original maxmatch-D to this one using TRAP:</p>
<pre><code>maxmatch-D: combinator [  ; "(D)efault"
    {Match maximum of two rules, keeping side effects of both if match}
    return: "Result of the longest match (favors first parser if equal)"
       [any-value? pack?]
    parser1 [action?]
    parser2 [action?]
    &lt;local&gt; error1 error2 result1' result2' remainder1 remainder2
][
    error1: trap [[^result1' remainder1]: parser1 input]
    error2: trap [[^result2' remainder2]: parser2 input]
    if error2 [  ; parser2 didn't succeed
        if error1 [
            return raise error1  ; neither succeeded
        ]
    ] else [  ; parser2 succeeded
        any [
            error1
            (index of remainder1) &lt; (index of remainder2)
        ] then [
            remainder: remainder2
            return unmeta result2'
        ]
    ]
    remainder: remainder1
    return unmeta result1'
]
</code></pre>
<p>Ren-C gives you power and flexibility to solve your problems in better ways... take advantage of that!</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/facepunch.png?v=12" title=":facepunch:" class="emoji only-emoji" alt=":facepunch:" loading="lazy" width="20" height="20"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/no-raised-errors-in-pack-but-feel-the-power/2206">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/no-raised-errors-in-pack-but-feel-the-power/2206</link>
          <pubDate>Thu, 22 Aug 2024 19:13:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2206</guid>
          <source url="https://forum.rebol.info/t/no-raised-errors-in-pack-but-feel-the-power/2206.rss">No Raised Errors in PACK! (But Feel The Power!)</source>
        </item>
        <item>
          <title>Re-imagining EVAL/NEXT</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <blockquote>
<p><strong>NOTE:</strong> <a href="https://forum.rebol.info/t/do-of-text-as-synonym-of-do-of-file-containing-string/2125">The nature of DO is to deal with whole scripts</a>.  We know <strong><code>do/next %foo.r</code></strong> doesn't make any sense, and in fact having DO take a BLOCK! of Rebol code should be a dialect about how to load and bind what you pass it... not expressions like <strong><code>do [1 + 2]</code></strong>.</p>
<p>So in modern Ren-C, array evaluation is handled by a primitive called <strong>EVAL</strong>.  Hence the /NEXT refinement has been removed from DO, and for a transitional period DO will not take BLOCK! at all... until all such references are gone.  At which point it will take a dialected LOAD spec, probably aligning closely with what IMPORT takes.</p>
</blockquote>
<h3>
<a name="right-now-evalnext-takes-a-variable-to-store-the-new-position-1" class="anchor" href="https://forum.rebol.info#right-now-evalnext-takes-a-variable-to-store-the-new-position-1"></a>Right Now, EVAL/NEXT Takes A Variable To Store The New Position</h3>
<pre><code>&gt;&gt; result: eval/next [1 + 2 10 + 20] $pos
== 3

&gt;&gt; pos
== [10 + 20]
</code></pre>
<p>This is exactly how Red and R3-Alpha handle DO/NEXT.</p>
<p>It was considered more convenient than how Rebol2 gave you a block of both the result and the new position...which you had to pick apart:</p>
<pre><code>rebol2&gt;&gt; do/next [1 + 2 10 + 20]
== [3 [10 + 20]]
</code></pre>
<p><em>(That couldn't work at all in Ren-C, because evaluation can produce antiforms, and antiforms can't be put in blocks.)</em></p>
<h3>
<a name="one-twist-evalnext-of-returns-a-null-position-2" class="anchor" href="https://forum.rebol.info#one-twist-evalnext-of-returns-a-null-position-2"></a>One Twist: EVAL/NEXT of [] Returns A NULL Position</h3>
<p>If you try to step with /NEXT over a BLOCK! like <strong>[1 + 2 10 + 20]</strong>, then there are EXACTLY TWO steps with meaningful results of 3 and 30.</p>
<p>So if you're going to be doing the evaluations in a WHILE loop, you want the EVAL/NEXT position result to return success twice, and then have a third call that returns null to signal the looping is done.</p>
<p>This gives you the possibly surprising (or not?) result that <code>EVAL/NEXT []</code> doesn't take a step and doesn't synthesize VOID, even though <code>EVAL []</code> is VOID.  It's a terminal condition.  So if you're trying to take steps and generate an overall accumulated result, you have to seed your result with VOID... and then <code>EVAL/NEXT []</code> will tell you there was nothing to do and you return your seeded result.</p>
<p>Make sense?</p>
<p>Rebol2, Red, and R3-Alpha all require you to check for the TAIL? of the block as your terminal condition.  Because DO/NEXT on a tail position just produces an UNSET! and another tail position.</p>
<pre><code>rebol2&gt;&gt; do/next [10 + 20]
== [30 []]

rebol2&gt;&gt; do/next []
== [unset []]

rebol2&gt;&gt; do/next []
 == [unset []]
</code></pre>
<p>That's quite a lot more awkward to handle for a terminal condition.  In fact it forces you to check for TAIL? on the block you're evaluating <em>before</em> the first call to DO/NEXT (because seeing the tail afterward won't tell you if the previous step synthesized a valid UNSET!).</p>
<p>R3-Alpha and Red didn't change this, and still make you check for TAIL? before you take steps:</p>
<pre><code>r3-alpha/red&gt;&gt; do/next [10 + 20] 'pos
== 30

r3-alpha/red&gt;&gt; pos
== []

r3-alpha/red&gt;&gt; do/next [] 'pos
; no console result here means unset

r3-alpha/red&gt;&gt; pos
== []

r3-alpha/red&gt;&gt; do/next [] 'pos
; no console result here means unset

r3-alpha/red&gt;&gt; pos
== []
</code></pre>
<p>Still very awkward, and unclear why they did this instead of making the POS be #[none].</p>
<h2>
<a name="but-ren-c-can-do-even-better-multi-returns-3" class="anchor" href="https://forum.rebol.info#but-ren-c-can-do-even-better-multi-returns-3"></a>But Ren-C Can Do Even Better: Multi-Returns!</h2>
<p>What if EVAL/NEXT turned the return result into a parameter pack, where you get both the evaluation product and the new position?</p>
<p><em>(I'm going to make it so it switches the main return result to be the position, and the secondary result is the evaluation product.  Then I'll explain why.)</em></p>
<pre><code>&gt;&gt; block: [1 + 2 10 + 20]
== [1 + 2 10 + 20]

&gt;&gt; pos: eval/next block  ; don't have to heed both returns
== [10 + 20]

&gt;&gt; [pos /result]: eval/next pos  ; but you can heed both returns
== []

&gt;&gt; result
== 30

&gt;&gt; [pos /result]: eval/next pos
== ~null~  ; anti

&gt;&gt; result
== ~null~  ; anti &lt;- not meaningful, because POS was null
</code></pre>
<p>The reason you (often) need the slash on /RESULT is that when EVAL/NEXT is done, it returns a pure null... not a multi-return.  This makes it correctly reactive to THEN and ELSE, which consider nulls inside of parameter packs to be "something" instead of "nothing".  But if you try to unpack a single null into two slots that is considered not enough.</p>
<p>Using a leading slash on a multi-return unpack is indication that you accept there may not be enough items in the pack to have one for that variable.  We could choose to have the multi-return unpacker make it trash or null, but in general null is more useful.</p>
<p><em>(To distinguish from a null that was actually in a pack and unpacked, you'd have to use <strong><code>^/result</code></strong>...which would meta the value so an unpacked null would be a quasiform ~null~, while the null resulting from too few values in the pack would be the antiform.  Caring about this is rare, but good to have a way to tell the difference if you do care.)</em></p>
<h2>
<a name="why-did-i-make-position-the-primary-return-result-4" class="anchor" href="https://forum.rebol.info#why-did-i-make-position-the-primary-return-result-4"></a>Why Did I Make Position The Primary Return Result?</h2>
<ol>
<li>
<p><strong>It Makes It Easier to Loop Through an Evaluation</strong> - There are some situations where EVAL/NEXT doesn't care about the value synthesized, but pretty much no cases where you don't care about the new position.  Being able to conditionally test if the returned position reached the end of a loop is super convenient.</p>
<pre><code>block: [1 + 2 10 + 20]

while [[block /result]: eval/next block] [
    print ["Step result was:" result]
]
</code></pre>
<p>It's true that with Ren-C's super multi-return powers, you could ask for the second argument to be the overall main result.  But that's uglier, why be ugly?</p>
<pre><code>block: [1 + 2 10 + 20]

while [[result @/block]: eval/next block] [
    print ["Step result was:" result]
]
</code></pre>
</li>
<li>
<p><strong>Avoids Ambiguity When EVAL Result Is Itself A Multi-Return</strong> - Imagine the following kind of confusion if we made the evaluation product the first result instead of the second:</p>
<pre><code>&gt;&gt; block: [1 + 2 comment "I don't care about this"]

&gt;&gt; result: eval/next block  ; I just want the first thing!
== 3  ; great, I didn't want that position anyway

&gt;&gt; block: [pack [&lt;left&gt; &lt;right&gt;] comment "I don't care about this"]

&gt;&gt; [left right]: eval/next block  ; just want to unpack that first thing
== &lt;left&gt;  ; great, just what I expected

&gt;&gt; right
== [comment "I don't care about this"]  ; whaaa? I wanted &lt;right&gt;!
</code></pre>
<p>Encountering problems with this in the past has made me back off from using multi-returns in places they seemed like they would be perfect.  But what I now realize is you simply don't want your primary return result of a multi-return to be something that can itself be a multi-return... unless you <em>really</em> know what you are doing.</p>
<p>If you intend to do something with the evaluation product and want to be truly general, you of course have to be using ^META conventions:</p>
<pre><code>[pos ^result]: eval/next pos
</code></pre>
<p>Whether you need to do that or not depends on what you are doing.  Why are you stepping through arrays one step at a time, anyway?  Usually intermediate results are discarded.  What is it precisely you are looking for?  (Again on my point of why making the position the primary result makes sense... usually you aren't looking at the result at all, you're a dialect and looking at what you advance to at the next position.)</p>
</li>
</ol>
<h2>
<a name="lgtm-1-5" class="anchor" href="https://forum.rebol.info#lgtm-1-5"></a>LGTM <img src="https://forum.rebol.info/images/emoji/twitter/+1.png?v=12" title=":+1:" class="emoji" alt=":+1:" loading="lazy" width="20" height="20">
</h2>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/re-imagining-eval-next/767">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/re-imagining-eval-next/767</link>
          <pubDate>Thu, 22 Aug 2024 04:00:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-767</guid>
          <source url="https://forum.rebol.info/t/re-imagining-eval-next/767.rss">Re-imagining EVAL/NEXT</source>
        </item>
        <item>
          <title>What To Call the Unstable Antiform of Empty Block?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <blockquote>
<p>I realized that one name among the nothingness antiforms that I don't know is optimal is "NIHIL".</p>
<p>I'll throw it out to the forum to see if there are any better ideas.  But I framed the question for the chatbots to see what they would say.</p>
<p><em>(My question is actually a pretty succinct summary of the situation...probably easier to digest than reading all the rambling that led up to it.)</em></p>
<p>Note that TRASH as described at the outset here was changed to NOTHING, and TRASH is now quasi-blank... the meta-state of nothing (e.g. lone <code>~</code> in source)</p>
<p>Credit for NIHIL actually goes to <a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a> who suggested it a while back, when I was asking what to call an arity-zero COMMENT construct.</p>
</blockquote>
<h2>
<a name="heirarchical-nothingness-in-a-programming-language-1" class="anchor" href="https://forum.rebol.info#heirarchical-nothingness-in-a-programming-language-1"></a>Heirarchical Nothingness In A Programming Language</h2>
<p>I have a programming language in which I have several layers of concepts of "nothing", each with unique properties.</p>
<p><strong>NULL</strong> is like most languages' null in that it is falsey when tested conditionally by something like IF.  But in general, if you pass it in a slot that is not conditional it is considered an error.  It's kind of a "soft failure" signal returned by many routines saying "I couldn't find what you were asking for".</p>
<p><strong>VOID</strong> is a kind of intentional nothingness.  When passed as an argument, it opts out of things...frequently causing the function to return NULL.  If you pass it to a function that tests many things logically <em>(like "are these items all truthy" or "all these items all falsey")</em> it will opt out of voting on the result.  Hence a single conditional test (e.g. passing it to an IF) must error as it isn't definitively true or false in isolation.</p>
<p><strong>TRASH</strong> is used as the contents of an unset variable <em>(like an <code>undefined</code> in JavaScript, perhaps)</em>.  It is also the result of many functions that have no meaningful result to return, such as a PRINT statement <em>(unless you pass PRINT a VOID in which case it returns NULL)</em>.  Trying to reference a variable holding this state will trigger an error, and special operations must be used to test for or extract the state from a variable.  It is conditionally truthy, which comes in handy e.g. if you wish to test the result of a PRINT to know whether it was opted out of or not.</p>
<p>But there is one more kind of nothingness I have to account for, which is a very strange transient state.  It can be an evaluation product but attempting to store it in a variable will trigger an error.  But you don't try to assign it to anything and it's in the middle of a stream of evaluation, then it will just be ignored and you will get whatever the previous result would be.  This makes it useful as the result of things like COMMENT.</p>
<pre><code>&gt;&gt; var: comment "illegal"
** Error: Some Error Message Here

&gt;&gt; 1 + 1
== 2

&gt;&gt; 1 + 1, 10 + 10
== 20

&gt;&gt; 1 + 1 comment "ignore me"
== 2
</code></pre>
<p>This transient state returned from COMMENT needs a name.  Without biasing you on what I've been calling it so far, I'll ask if you have any ideas!</p>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/what-to-call-the-unstable-antiform-of-empty-block/2204">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-to-call-the-unstable-antiform-of-empty-block/2204</link>
          <pubDate>Wed, 21 Aug 2024 22:40:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2204</guid>
          <source url="https://forum.rebol.info/t/what-to-call-the-unstable-antiform-of-empty-block/2204.rss">What To Call the Unstable Antiform of Empty Block?</source>
        </item>
        <item>
          <title>Code Review Solicitation: C/C++ interface %rebol.h</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>The API has been relatively stable for a while, with the only major change this year <a href="https://forum.rebol.info/t/api-breakthrough-scope-detection-in-javascript-and-c/2157">being quite a good one</a>.</p>
<p>The actual %rebol.h file is generated by a <a href="https://github.com/metaeducation/ren-c/blob/master/tools/make-librebol.r">piece of Rebol code</a> that analyzes the <a href="https://github.com/metaeducation/ren-c/blob/master/src/core/a-lib.c">definitions in %a-lib.c</a>.</p>
<p>There I explain the premise of the API, and mention the trickery is accomplished via <a href="https://github.com/metaeducation/ren-c/blob/master/src/include/structs/struct-node.h">non-strict-alias endian-sensitive first-byte access</a>, where patterns are chosen for Cells and Stubs that do not overlap leading valid bytes for UTF-8.</p>
<p><em>(Also explained in the Rebol 2019 video: <strong><a href="http://2019.reb4.me/talks">Abusing UTF-8 For Fun And Profit</a></strong>)</em></p>
<hr>
<pre><code>This is the "external" API, and %rebol.h contains its exported
definitions.  That file (and %make-librebol.r which generates it) contains
comments and notes which will help understand it.

What characterizes the external API is that it is not necessary to #include
the extensive definitions of `struct Series` or the APIs for dealing with
all the internal details (e.g. Push_GC_Guard(), which are easy to get
wrong).  Not only does this simplify the interface, but it also means that
the C code using the library isn't competing as much for definitions in
the global namespace.

Also, due to the nature of the Node superclass (see %sys-node.h), it's
possible to feed the scanner with a list of pointers that may be to UTF-8
strings or to Rebol values.  The behavior is to "splice" in the values at
the point in the scan that they occur, e.g.

    RebolValue* item1 = ...;
    RebolValue* item2 = ...;
    RebolValue* item3 = ...;

    RebolValue* result = rebValue(
       "if not", item1, "[\n",
           item2, "| print {Close brace separate from content}\n",
        "] else [\n",
            item3, "| print {Close brace with content}]\n"
    );

 (Note: C can't count how many arguments a variadic takes, so this is done
 by making things like rebValue() a macro that uses __VA_ARGS__ and tacks
 a rebEND onto the tail of the list.  There's lots of tricks in play--see
 %make-librebol.r for the nitty-gritty details.)

 While the approach is flexible, any token must be completed within its
 UTF-8 string component.  So you can't--for instance--divide a scan up like
  ("{abc", "def", "ghi}") and get the TEXT! {abcdefghi}.  On that note,
 ("a", "/", "b") produces `a / b` and not the PATH! `a/b`.
</code></pre>
<hr>
<p>I think <a class="mention" href="https://forum.rebol.info/u/iarnold">@iArnold</a> may be the only person to have experienced the API at the C level besides myself.  But several people have engaged the JavaScript version, which bridges via WebAssembly to run the exact same code in %a-lib.c through some wrappers.</p>
<hr>
<p>I'm ready for feedback on it, and this post can be a thread for that.  (How's your C/C++, <a class="mention" href="https://forum.rebol.info/u/bradrn">@bradrn</a>?)</p>
<p>Since the <code>rebol.h</code> file is generated and not committed to the repository, I have made a gist of what it compiles to at this moment:</p>
<p><a href="https://gist.github.com/hostilefork/8a8cf776387e9b66fe99ca77f560b5a8" class="inline-onebox">Snapshot of auto-generated Ren-C rebol.h file, 20-Aug-2024 · GitHub</a></p>
<p>There are a couple of bad names (e.g. REBDNG) which are left bad as a reminder that those are parts that need review, so skip those.  The rest is about as good as I've been able to make it.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/code-review-solicitation-c-c-interface-rebol-h/2203">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/code-review-solicitation-c-c-interface-rebol-h/2203</link>
          <pubDate>Wed, 21 Aug 2024 02:05:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2203</guid>
          <source url="https://forum.rebol.info/t/code-review-solicitation-c-c-interface-rebol-h/2203.rss">Code Review Solicitation: C/C++ interface %rebol.h</source>
        </item>
        <item>
          <title>Usermode Multiple Dispatch in R and Common Lisp</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2190">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/member-functions-in-the-era-of-pure-virtual-binding/2190/1">"Member Functions" (in the era of Pure Virtual Binding)</a>
</div>
<blockquote>
<p>Rebol's style of data mutation is done as "generics", e.g.:</p>
<pre><code class="lang-plaintext">append block [1 2 3]
;
; ... NOT block/append [1 2 3]
</code></pre>
<p>This dynamically chooses the right kind of APPEND procedure based <em>entirely</em> on the type of the first argument (blocks, strings, etc.)</p>
<p>But you can't implement this generic for your own objects.</p>
</blockquote>
</aside>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2190">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/member-functions-in-the-era-of-pure-virtual-binding/2190/1">"Member Functions" (in the era of Pure Virtual Binding)</a>
</div>
<blockquote>
<p>It seems Rebol could use a better way of doing <a href="https://en.wikipedia.org/wiki/Multiple_dispatch">multiple dispatch</a> so that you could write things like <strong><code>append my-object [a b c]</code></strong> and get custom behavior for the "class".</p>
</blockquote>
</aside>
<p>The <a href="https://adv-r.hadley.nz/s3.html#s3-methods">R solution to this</a> is to make the function itself do the dispatch. A function like <code>append</code> would be defined as something which calls a different function name depending on the class of its argument: <code>append.matrix</code> for something of class <code>matrix</code>, <code>append.numeric</code> for something of class <code>numeric</code>, and so on. (Note that <code>.</code> in R is simply a normal character which can be used in identifier names.) I don’t know how well this would work for Ren-C, but it’s probably worth mentioning.</p>
<p>EDIT for clarification: the idea is that <code>append.matrix</code> etc. are completely normal functions which you can define yourself at any time. The generic method <code>append</code> simply dispatches to the relevant function based on its name. When defining a new class, you would also define whichever functions are relevant for use with that class.</p>
<p>(Also, for further inspiration, it may be worth looking at the <a href="https://lispcookbook.github.io/cl-cookbook/clos.html#methods">Common Lisp Object System</a>, though CL is less similar to Rebol than R is.)</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/usermode-multiple-dispatch-in-r-and-common-lisp/2193">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/usermode-multiple-dispatch-in-r-and-common-lisp/2193</link>
          <pubDate>Mon, 19 Aug 2024 05:40:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2193</guid>
          <source url="https://forum.rebol.info/t/usermode-multiple-dispatch-in-r-and-common-lisp/2193.rss">Usermode Multiple Dispatch in R and Common Lisp</source>
        </item>
        <item>
          <title>&quot;Member Functions&quot; (in the era of Pure Virtual Binding)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Binding</category>
          <description><![CDATA[
            <h2>
<a name="lets-start-with-member-variable-binding-1" class="anchor" href="https://forum.rebol.info#lets-start-with-member-variable-binding-1"></a>Let's Start With "Member Variable" Binding</h2>
<p>The properties of historical Rebol binding created a bizarre environment in which to implement objects with methods and member variable references.</p>
<p>There's a pretty basic question one can ask:</p>
<blockquote>
<p><strong>You: "It appears that every WORD! can bind to at most one object containing that word's symbol.  So if I write a FUNC intended to act as a member function... what are the member word references bound to in that function's body, that allows them to apply the code to the field values of a new instance of the object?"</strong></p>
</blockquote>
<p>To make a long story short:</p>
<blockquote>
<p><strong>Redbol: "For every field of an object that holds a FUNCTION! value, making a new object instance will <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/t-object.c#L338"><em>clone a new FUNCTION! value for the associated field in the copy</em></a>.  The original function's body is <em><a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/f-blocks.c#L139">copied deeply</a></em>, with any references to the original object's fields <em><a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/c-frame.c#L1040">rebound to the field of the new object.</a></em>"</strong></p>
</blockquote>
<p>This creates a pathological explosion.  Make an object with 20 methods, each of which has a body that is built up of... say... 10 blocks on average.  Now instantiate 10,000 of those objects.</p>
<p>Beyond the basic overhead you'd expect from a new object copy, <strong>you just allocated 200,000 new function identities... plus two million <em>nearly</em>-identical arrays for their bodies... <em>solely for the purpose of accomplishing what a single <code>this</code> or <code>self</code> pointer does in most OOP languages</em>.</strong></p>
<p>Those with non-trivial codebases (e.g. Atronix) who at first wrote code in this style...</p>
<pre><code>obj: make object! [
   x: 10
   f: func [y] [return x + y]
]

&gt;&gt; obj/f 20
== 30
</code></pre>
<p>...were forced to "de-methodize" it, passing the instance into a <a href="https://en.wikipedia.org/wiki/Free_function">"free function"</a>:</p>
<pre><code>free-f: func [o y] [return o/x + y]

obj: make object! [
   x: 10
]

&gt;&gt; free-f obj 20
== 30
</code></pre>
<hr>
<h2>
<a name="worth-noting-rebols-central-aesthetic-is-free-functions-2" class="anchor" href="https://forum.rebol.info#worth-noting-rebols-central-aesthetic-is-free-functions-2"></a>Worth Noting: Rebol's Central Aesthetic <em>is</em> "free functions"</h2>
<p>Rebol's style of data mutation is done as "generics", e.g.:</p>
<pre><code>append block [1 2 3]
;
; ... NOT block/append [1 2 3]
</code></pre>
<p>This dynamically chooses the right kind of APPEND procedure based <em>entirely</em> on the type of the first argument (blocks, strings, etc.)</p>
<p>But you can't implement this generic for your own objects.  Red doesn't let you APPEND to OBJECT! at all.  While in R3-Alpha if you APPEND to an OBJECT! it just adds fields--vs. delegate to any "append implementation" associated with some kind of object "class":</p>
<pre><code>r3-alpha&gt;&gt; obj: make object! [a: 10]
== make object! [
    a: 10
]

r3-alpha&gt;&gt; append obj [b: 20]
== make object! [
    a: 10
    b: 20
]
</code></pre>
<p>I will mention that if you had a PORT!, curiously there was a way to supply an "actor" to PORT!s that could implement a small set of "port actions".  For an example of this, see the original R3-Alpha ODBC extension:</p>
<p><a href="https://github.com/gurzgri/r3-odbc/blob/c15c70d61a2f5c39cb01f7c685c4310d4ee987de/src/boot/odbc.r3#L68" class="inline-onebox">r3-odbc/src/boot/odbc.r3 at c15c70d61a2f5c39cb01f7c685c4310d4ee987de · gurzgri/r3-odbc · GitHub</a></p>
<p>For the sake of documenting history, the list of "generic verbs" you can implement on a R3-Alpha are called "port actions" and <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/boot/actions.r#L361">limited to this arbitrary set</a>:</p>
<p>CREATE, DELETE, OPEN, CLOSE, READ, WRITE, OPEN?, QUERY, MODIFY, UPDATE, RENAME</p>
<p>So even that wouldn't help you with APPEND.</p>
<hr>
<h2>
<a name="were-classes-ever-on-the-table-in-r3-alpha-3" class="anchor" href="https://forum.rebol.info#were-classes-ever-on-the-table-in-r3-alpha-3"></a>Were "Classes" Ever On The Table in R3-Alpha?</h2>
<p>On Carl's blog, circa 2006, he wrote <strong><a href="http://www.rebol.net/r3blogs/0035.html">At a CLASS Crossroads?</a></strong>:</p>
<p>He said:</p>
<blockquote>
<p><em>"And, on top of all this, I've yet to mention the fact that <strong>REBOL 3.0 is likely to support object methods</strong> to make object function implementation more efficient (in memory usage). The implementing of methods in REBOL has always been considered difficult (mainly because there is no referential anchor for a group, a class, of objects -- they are prototypical and can be cloned from each other, not just a single parent). A class-based approach makes the implementation of methods much easier.</em>"</p>
</blockquote>
<p>The post wasn't without criticism in the comments, e.g. from "Pierre Johnson":</p>
<blockquote>
<p><em>"Class-based inheritance for REBOL? Why not just kill the product?"</em></p>
<p><em>"Class-based Aristotlean socialist thinking abounds in academic-based / near academic-based junk -- Java, C++, C#, Python."</em></p>
<p><em>"While not elegant, perhaps the <span class="hashtag">#1</span>, most used programming language of the world is Javascript. Why? Simpler, rapid prototyping using prototypes."</em></p>
</blockquote>
<p>You didn't really hear anything about it after that.  R3-Alpha got pretty bogged down just trying to be Rebol2 plus Unicode.</p>
<hr>
<h2>
<a name="how-about-red-any-ideas-there-4" class="anchor" href="https://forum.rebol.info#how-about-red-any-ideas-there-4"></a>How About Red?  Any Ideas There?</h2>
<p>When OBJECT! was first added to Red circa 2014, DocKimbel wrote the blog <strong><a href="https://www.red-lang.org/2014/12/050-objects-support.html">0.5.0: Objects support</a></strong>, and says (emphasis mine)</p>
<blockquote>
<p>"Red implements the same object concept as Rebol, called <a href="http://en.wikipedia.org/wiki/Prototype-based_programming">prototype-based</a> objects. Creating new objects is done by cloning existing objects or the base OBJECT! value. During the creation process, existing field values can be modified and new fields can be added. It is a very simple and efficient model to encapsulate your Red code. <strong>There is also a lot to say about words binding and contexts, but that topic is too long for this blog entry, we will address that in the future documentation.</strong>"</p>
</blockquote>
<p>Uh... I think I've said above pretty much all there has historically been to say... and it only took me... maybe an hour?</p>
<p>The big idea in Red is essentially to implement the <a href="https://en.wikipedia.org/wiki/Mutator_method">"setters"</a> half of "getters and setters".  If you have a field in an object with that the precise name ON-CHANGE*, it will get the name of a field... the old value... and the new value it takes on.  A lot of the code they seem to be interested in uses that instead of methods: just write a value to a field, and code executes.  If you can get your work done with just that, you won't have method binding problems.</p>
<p>Although, presumably every copy of your object duplicates the ON-CHANGE* method itself?</p>
<pre><code>red&gt;&gt; obj: make object! [
    a: 10
    on-change*: func [word old new] [print [word old new]]
]

red&gt;&gt; obj/a: 20
a 10 20

red&gt;&gt; obj2: make obj [a: 30]
a 20 30  ; note obj2 sees creation w/new field value as a "change"

red&gt;&gt; body-of :obj/on-change*
== [print [word old new]]

red&gt;&gt; append body-of :obj/on-change* [print "that figures."]
== [print [word old new] print "that figures."]

red&gt;&gt; body-of :obj2/on-change*
== [print [word old new]]
</code></pre>
<p>I take it back, this is way too complicated to address in a blog post.  <em>It's too deep.</em>  <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=12" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></p>
<hr>
<h2>
<a name="okay-ren-c-what-have-you-got-5" class="anchor" href="https://forum.rebol.info#okay-ren-c-what-have-you-got-5"></a><em>"Okay, Ren-C... What Have You Got?"</em>
</h2>
<p>Building up to the existence of <a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751/9">Pure Virtual Binding II</a>, Ren-C just kind of got waves of new tricks:</p>
<ul>
<li>
<p>First there were <strong><a href="https://forum.rebol.info/t/what-are-definitional-returns/2191">"definitional returns"</a></strong>, which gave each function a cell to store a local RETURN function.  While the behavior was unique to each function, no actual new identity was allocated.  Instead a slot in the 4-platform-pointer cell (known as the "coupling") was used to hold the FRAME! of the instance of the running function...so it was efficient at doing so.</p>
</li>
<li>
<p>Then there was <strong><a href="https://forum.rebol.info/t/relative-binding-and-frame-internals/1344">"(function-)relative binding"</a></strong>.  This started a separation in the type system of the interpreter code distinguishing a "Cell" (which hadn't had its binding fully resolved) from a "Value" (which did have a resolved binding).  Each function instantiation would slowly trickle down the FRAME! of the function during evaluation, such that the "relative" Cells would have to be paired with that frame before they could be passed to a routine doing non-structural Lookup to follow the word to a "specific" Value.</p>
</li>
<li>
<p>This laid the foundation for what I called <a href="https://forum.rebol.info/t/introducing-derived-binding/2192"><strong>"derived binding"</strong></a>, which actually mixed the two approaches together.  Just as any particular local variable named RETURN could hold a FRAME! in a cell's "coupling" slot (while reusing the same canon RETURN implementation), you could use that technique to store an OBJECT! in <em>any</em> function's coupling slot.  So the function call would not only trickle down the frame, but also this object... so there would be two contexts that were searched during derelativization.</p>
</li>
</ul>
<p>So under derived binding, making a new object doesn't require either a new function identity or a deep copy.  It just means that the new object receives its function cells with an effective "this" pointer in one of the 4 platform-pointer-sized slots.  That pointer is stowed in the FRAME! and trickles down via the cells instantiated by the evaluator as it descends the relativized arrays.</p>
<h3>
<a name="originally-derived-binding-did-not-blindly-override-6" class="anchor" href="https://forum.rebol.info#originally-derived-binding-did-not-blindly-override-6"></a>Originally, Derived Binding Did Not Blindly Override...</h3>
<p>Here's something that didn't work in derived binding as you'd expect given what I described:</p>
<pre><code>old-ren-c&gt;&gt; x: 42

old-ren-c&gt;&gt; obj: make object! [x: 10, f: null]

old-ren-c&gt;&gt; obj2: make obj [x: 20, f: null]

old-ren-c&gt;&gt; obj2.f: func [] [print ["x is" x]]

old-ren-c&gt;&gt; obj2.f: couple :obj2.f obj2

old-ren-c&gt;&gt; obj2.f
x is 42
</code></pre>
<p>The reason it didn't work was because this function was defined outside the scope of the MAKE OBJECT!, meaning the binding of the X was to 42.  When applying derived binding, Ren-C wouldn't do any overriding of any WORD! references that weren't bound to an object that was in the same "inheritance chain".</p>
<p>You'd have to do something like this to see the effect:</p>
<pre><code>old-ren-c&gt;&gt; x: 42

old-ren-c&gt;&gt; obj: make object! [x: 10, f: func [] [print ["x is" x]]]

old-ren-c&gt;&gt; obj2: make obj [x: 20, f: null]

old-ren-c&gt;&gt; obj2.f: couple :obj.f obj2

old-ren-c&gt;&gt; obj2.f
x is 20
</code></pre>
<p>Here, the X was deep walked during the MAKE OBJECT! and bound to OBJ's X.  When derived binding went to run the rebound function in OBJ2, it noticed that the binding to X was to a relative of OBJ2 in the inheritance chain... so it was willing to "forward" that binding to the object in the FRAME! it was relativizing against.</p>
<p>Note that the sort of virtual "this" pointer is not coming from the fact that OBJ2 is on the left hand side of the instantiation of the call to <strong>OBJ2.F</strong> -- it's solely coming from the coupling slot in the cell stored in that field.  You could make OBJ2.F be derived-bound to anything you want.</p>
<p>And now I can tell you that if you had used METHOD instead of FUNC... and hadn't said <strong><code>(f: null)</code></strong> when making OBJ2, then the above behavior is what you would get automatically.  The MAKE OBJECT! would simply notice when any of the fields it was copying had a stowed function with a coupling slot of itself, and update the cell in the new object with a coupling pointer to the new object.</p>
<p><em>(All METHOD is, is an enfix operator that steals the binding from the SET-WORD! on its left to poke into the cell of the generated function.)</em></p>
<h3>
<a name="but-with-virtual-binding-ii-the-object-wins-mostly-7" class="anchor" href="https://forum.rebol.info#but-with-virtual-binding-ii-the-object-wins-mostly-7"></a>But With Virtual Binding II, The Object Wins (Mostly)</h3>
<p>We're not in binding Kansas anymore... there is no "deep walk" when the FUNC is created that gives X an initial binding of 10.  As of this moment, bindings aren't ever overridden <em>(hole punching is still on the table, but let's not go there right now...)</em></p>
<pre><code>&gt;&gt; x: 10

&gt;&gt; obj: make object! [x: 20, f: null]

&gt;&gt; obj.f: func [] [print ["x is" x]]

&gt;&gt; obj.f: couple :obj.f obj

&gt;&gt; obj.f
x is 20
</code></pre>
<p>I actually didn't know what the following would do until I tried it:</p>
<pre><code>&gt;&gt; obj.f: func [x] [print ["x is" x]]

&gt;&gt; obj.f: couple :obj.f obj

&gt;&gt; obj.f 30
x is 30
</code></pre>
<p>I guess locals to the function are looked up first, before member variables.  Maybe I meant to do that <em>(C++ does it that way)</em>.</p>
<hr>
<h2>
<a name="what-have-we-learned-8" class="anchor" href="https://forum.rebol.info#what-have-we-learned-8"></a>What Have We Learned?</h2>
<ul>
<li>
<p>It seems Rebol could use a better way of doing <a href="https://en.wikipedia.org/wiki/Multiple_dispatch">multiple dispatch</a> so that you could write things like <strong><code>append my-object [a b c]</code></strong> and get custom behavior for the "class".</p>
<ul>
<li>
<p>The aesthetic of the system is supposed to promote that kind of free-function syntax</p>
</li>
<li>
<p>It doesn't make a lot of sense that you can only do this with PORT! and only for a handful of "generic verbs"</p>
</li>
</ul>
</li>
<li>
<p>But to the extent people have wanted to do traditional <code>obj/member</code> calls (in Ren-C <code>obj.member</code>), the historical implementation of the idea was catastrophically bad</p>
<ul>
<li>
<p>Without changing the overall usage experience (much), Ren-C wiped out the pathological implementation aspects</p>
</li>
<li>
<p>While Ren-C may be on the whole slower than its peers for many things at the moment, derived binding is one area where it blows them away.</p>
<ul>
<li>The <a href="https://github.com/metaeducation/ren-c/blob/199db785027eaec3132b2edbd42bdf6364f64e8d/tests/datatypes/object.test.reb#L140">"O-Big" example</a> I came up with is simply not runnable in R3-Alpha or Red.</li>
</ul>
</li>
</ul>
</li>
</ul>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/member-functions-in-the-era-of-pure-virtual-binding/2190">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/member-functions-in-the-era-of-pure-virtual-binding/2190</link>
          <pubDate>Mon, 19 Aug 2024 04:52:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2190</guid>
          <source url="https://forum.rebol.info/t/member-functions-in-the-era-of-pure-virtual-binding/2190.rss">&quot;Member Functions&quot; (in the era of Pure Virtual Binding)</source>
        </item>
        <item>
          <title>PicoLisp machine</title>
          <dc:creator><![CDATA[jjsullivan5196]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Pretty comprehensive reference on how picolisp's cons machine works <a href="https://software-lab.de/doc/ref.html#vm" class="inline-onebox" rel="noopener nofollow ugc">PicoLisp Reference</a></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/picolisp-machine/2185">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/picolisp-machine/2185</link>
          <pubDate>Thu, 23 May 2024 06:34:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2185</guid>
          <source url="https://forum.rebol.info/t/picolisp-machine/2185.rss">PicoLisp machine</source>
        </item>
        <item>
          <title>Om: concatenative homoiconic language</title>
          <dc:creator><![CDATA[jjsullivan5196]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p><a href="https://www.om-language.org/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://www.om-language.org/</a></p>
<p>This was a one hit wonder on hackernews a couple years ago. Probably the thing of greatest relevance is its "panmorphic" data representation: 3 terminal types of</p>
<ul>
<li>Separators, which compose any utf8 whitespace characters</li>
<li>Operator, essentially symbols of <code>any-other-utf8-text</code>.</li>
<li>Operand, a quoted program in <code>{curlie braces}</code> containing operators or <code>{{other} {operands} and operators}</code> with separators between.</li>
</ul>
<p>The evaluator can define a vocabulary of base "operations" tied to an operator symbol. Every operation takes the rest of the program as input and appends its output. For instance, <code>quote</code> and <code>dequote</code> wrap or unwrap the next term of the program in an enclosing operand. (using <code>-&gt;</code> to indicate output)</p>
<pre><code class="lang-plaintext">quote {A}
-&gt; {{A}}
</code></pre>
<pre><code class="lang-plaintext">dequote {A}
-&gt; A
</code></pre>
<p>More examples on the website</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/om-concatenative-homoiconic-language/2184">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/om-concatenative-homoiconic-language/2184</link>
          <pubDate>Thu, 23 May 2024 02:44:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2184</guid>
          <source url="https://forum.rebol.info/t/om-concatenative-homoiconic-language/2184.rss">Om: concatenative homoiconic language</source>
        </item>
        <item>
          <title>The Truthiness of Nothing</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p><strong>Does it really add value to consider <strong><a href="https://forum.rebol.info/t/why-nothing-is-the-name-for-unset-state/2078">the nothing state</a></strong> (an antiform blank held by unset variables) to be neither truthy nor falsey?</strong></p>
<p>Here's a quick survey of how UNSET! (the most nothing-like thing in historical Rebol) is handled:</p>
<h3>
<a name="rebol2-1" class="anchor" href="https://forum.rebol.info#rebol2-1"></a>Rebol2</h3>
<pre><code>rebol2&gt;&gt; either get/any 'asdf [print "truthy"] [print "falsey"]
** Script Error: either is missing its condition argument

rebol2&gt;&gt; unset? all [get/any 'asdf]
== true

rebol2&gt;&gt; unset? any [get/any 'asdf]
== true

rebol2&gt;&gt; case [get/any 'asdf [print "truthy"]]
** Script Error: Block did not return a value
</code></pre>
<h3>
<a name="r3-alpha-2" class="anchor" href="https://forum.rebol.info#r3-alpha-2"></a>R3-Alpha</h3>
<pre><code>r3-alpha&gt;&gt; either get/any 'asdf [print "truthy"] [print "falsey"]
** Script error: either does not allow unset! for its condition argument

r3-alpha&gt;&gt; unset? all [get/any 'asdf]
== true

r3-alpha&gt;&gt; unset? any [get/any 'asdf]
== false  ; ...huh?

r3-alpha&gt;&gt; any [get/any 'asdf 1020]   
== 1020

r3-alpha&gt;&gt; case [get/any 'asdf [print "truthy"]]
** Script error: block did not return a value
</code></pre>
<h3>
<a name="red-3" class="anchor" href="https://forum.rebol.info#red-3"></a>Red</h3>
<pre><code>red&gt;&gt; if get/any 'asdf [print "truthy"]
truthy

red&gt;&gt; either get/any 'asdf [print "truthy"] [print "falsey"]
*** Script Error: block did not return a value  ; &lt;-- huh?

red&gt;&gt; unset? all [get/any 'asdf]
== true

red&gt;&gt; unset? any [get/any 'asdf]
== true

red&gt;&gt; case [get/any 'asdf [print "truthy"]]
*** Script Error: block did not return a value  ; &lt;-- huh, again?
</code></pre>
<h2>
<a name="oldes-rebol3-4" class="anchor" href="https://forum.rebol.info#oldes-rebol3-4"></a>Oldes Rebol3</h2>
<p>Transparent in <a href="https://github.com/Oldes/Rebol3/commit/2ba01ead3b5da1ab609fa25a0c675b30e96bb163">ANY and ALL</a> (like a Ren-C void), but presumably still an error in plain IF or EITHER or CASE...</p>
<h2>
<a name="ren-cs-always-error-has-been-more-consistent-but-5" class="anchor" href="https://forum.rebol.info#ren-cs-always-error-has-been-more-consistent-but-5"></a>Ren-C's "Always Error" Has Been More <em>Consistent</em>, But...</h2>
<p>Clearly people have been pushing away from it being an error.</p>
<p>So does being "ornery" for conditional logic really help matters?  When we consider the dual role of nothing as an "uninteresting, but successful" result, might we get as much (or more?) value from considering it to be always truthy?</p>
<p>For example: Ren-C uses NOTHING as the result of PRINT when the print actually produces output.  Otherwise, you get NULL.</p>
<pre><code>&gt;&gt; message: "Hello"
== "Hello"

&gt;&gt; print message  ; won't have a console "==" due to being a nothing result
Hello

&gt;&gt; nothing? print message
Hello
== ~true~  ; anti

&gt;&gt; message: null
== ~null~  ; anti

&gt;&gt; print maybe message
== ~null~  ; anti

&gt;&gt; print []
== ~null~  ; anti
</code></pre>
<p>Nothing has the property of suppressing console output, which is desirable in most print cases--at least those that do print output.  And if you said <code>(x: print "Hello")</code> you'd get a variable that would create an error on access, which seems also desirable.</p>
<p>If nothing was truthy, that makes it easier to act on the nothing-vs-null distinction in something like an ANY or ALL construct.</p>
<h2>
<a name="should-meaningless-but-truthy-unset-variable-state-6" class="anchor" href="https://forum.rebol.info#should-meaningless-but-truthy-unset-variable-state-6"></a>Should "Meaningless but Truthy" = "Unset Variable State"?</h2>
<p>A related question may be if functions like PRINT should be returning the same value as what is held by an unset variable.</p>
<p>Now that non-antiform BLANK! itself is truthy, might it be a better choice?</p>
<pre><code>&gt;&gt; print "Hello"
Hello
== _
</code></pre>
<p>But then...</p>
<ul>
<li>
<p>For the visual we seek, the console would need to not print BLANK!.  But I find it unsatisfying to have a non-antiform be what has "no representation".</p>
</li>
<li>
<p>If you assigned the result of this "meaningless" value to a variable, you wouldn't have that added protection that the variable would appear unset.</p>
</li>
</ul>
<h2>
<a name="truthy-nothing-seems-to-have-more-pluses-than-minuses-7" class="anchor" href="https://forum.rebol.info#truthy-nothing-seems-to-have-more-pluses-than-minuses-7"></a>Truthy Nothing Seems To Have More Pluses than Minuses</h2>
<p>My "semantic safety" bias initially had made me think that when you have a function like PRINT, it's nice to catch potential mistakes when you tried to act like it was a function that could meaningfully be tested for some kind of logical result.  So I pushed R3-Alpha's error from IF and EITHER further into ANY and ALL.</p>
<p>Then I went and made it so that when the PRINT received an opted-out input, it gave back NULL instead of NOTHING.  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_diagonal_mouth.png?v=12" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20">  So it was something you could act on with ELSE, but not other conditional constructs.</p>
<p>The evolution from UNSET! to the blank-antiform that is today's NOTHING has been a long and winding one.  Working around its ornery-ness gave rise to all kinds of interesting designs like voids, and invisibles like ELIDE PRINT.</p>
<p>But though I'm sure that I haven't considered all the angles yet...having nothing be neither-true-nor-false is looking more like a dying historical artifact than something with a clear motivation applicable to the present.</p>
<p>Nothing being always truthy offers consistency...and it's possible to ELIDE it to get "no vote" so it won't affect an ANY or ALL (the way Oldes R3 treats unsets).  Yet having the vote isn't entirely useless either.  I can't think of a whole lot of downside, so I think it's worth trying.</p>
<hr>
<p>A better axis of orneryness that may actually catch more problems in practice is: <strong><a href="https://forum.rebol.info/t/making-call-raise-a-definitional-error-for-bad-exit-codes/2068/2">Should Nothing be Illegal in Comparisons</a></strong></p>
<p>(I point out in that discussion that simply disabling the ability to check nothing for truthiness/falseyness is kind of a strange counterpart to a routine that returns--say--an INTEGER! in all cases, where you get zero information from testing an integer conditionally but without anything to stop you...making the disablement of testing nothing conditionally seem like a fairly empty gesture.)</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-truthiness-of-nothing/2180">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-truthiness-of-nothing/2180</link>
          <pubDate>Fri, 03 May 2024 17:27:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2180</guid>
          <source url="https://forum.rebol.info/t/the-truthiness-of-nothing/2180.rss">The Truthiness of Nothing</source>
        </item>
        <item>
          <title>Should SET-WORD!s Propagate Undecayed Packs?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Packs are antiform blocks, which decay if not specifically handled.</p>
<pre><code>&gt;&gt; pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; a: pack [1 2]
== 1

&gt;&gt; a
== 1
</code></pre>
<p>From time to time, I've wondered if there's a good reason why the plain SET-WORD! shouldn't propagate the pack:</p>
<pre><code>&gt;&gt; a: pack [1 2]
== ~['1 '2]~  ; anti  (hypothetical)

&gt;&gt; a
== 1
</code></pre>
<p>One rationale is that intuitively, <strong>a:</strong> should be a synonym for <strong>[a]:</strong>, e.g. "unpack one item" is implicit.</p>
<p>But that just bumps the question to the next one we might ask: why doesn't a multi-return without a "circled" result just evaluate to the whole pack?</p>
<p>It looks to make some sense at first, it allows you to chain indefinitely:</p>
<pre><code>&gt;&gt; [a b]: [c d]: pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; a
== 1

&gt;&gt; b
== 2

&gt;&gt; c
== 1

&gt;&gt; d
== 2
</code></pre>
<p>Though it feels a little bit unsettling when you drop it down:</p>
<pre><code>&gt;&gt; [a b]: [c]: pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; a
== 1

&gt;&gt; b
== 2

&gt;&gt; c
== 1
</code></pre>
<p>But we could argue that if you're bothered, then you use circling (currently <code>@c</code>, but with FENCE! proposed to be <code>{c}</code>).  Note in the below example you'd have to use <code>/b</code> in order to indicate you were okay with unpacking more values than available.</p>
<pre><code>&gt;&gt; [a /b]: [{c}]: pack [1 2]
== 1

&gt;&gt; a
== 1

&gt;&gt; b
== ~null~  ; anti

&gt;&gt; c
== 1
</code></pre>
<p>We could then make a choice if <strong>a:</strong> was a synonym for <strong>[a]:</strong> or for <strong>[{a}]:</strong></p>
<h2>
<a name="most-recent-motivation-for-thinking-about-this-1" class="anchor" href="https://forum.rebol.info#most-recent-motivation-for-thinking-about-this-1"></a>Most Recent Motivation For Thinking About This</h2>
<p>I rewrote <a href="https://forum.rebol.info/t/speed-of-uparse/2177/3">some code in an example</a> from this:</p>
<pre><code>[^result' remainder]: parser input except e -&gt; [
    remainder: input  ; succeed on parser fail but don't advance input
    return null
]
return unmeta result'  ; return successful parser result
</code></pre>
<p>...to this:</p>
<pre><code>return [@ remainder]: parser input except [
    remainder: input  ; succeed on parser fail but don't advance input
    return null
]
</code></pre>
<p>The idea is that the parser being called has multiple return results... the first is the synthesized value, the second is the amount it advanced.  <em>(There's a third result on some parsers of "pending items", but this OPTIONAL combinator has an "autopipe" which is just bubbling the pending items through in the order of successful parsers called...so the third result is specialized out on its interface and on the parsers it calls.)</em></p>
<p><strong>However, the synthesized value can itself be a pack.</strong>  This means that if we named a variable in the slot where the <code>@</code> is, then that pack would be decayed to store in the variable unless we used a ^META result.</p>
<p>So does the act of not-naming and just circling subvert the decay?  Or should the circled result not be decayed even if the variable is?</p>
<pre><code>&gt;&gt; [{a} b]: pack [pack [1 2] 3]
== ~['1 '2]~  ; anti  (or should it be decayed to 1?)

&gt;&gt; a
== 1

&gt;&gt; b
== 3
</code></pre>
<p>It's a different--but related--question.  It seems it should align with the behavior of plain assignments:</p>
<pre><code>&gt;&gt; a: pack [1 2]
== ~['1 '2]~  ; anti  (implied if the above behavior is chosen)

&gt;&gt; a
== 1
</code></pre>
<h2>
<a name="not-100-certain-but-i-think-undecayed-propagation-is-good-2" class="anchor" href="https://forum.rebol.info#not-100-certain-but-i-think-undecayed-propagation-is-good-2"></a>Not 100% Certain, But I Think Undecayed Propagation Is Good</h2>
<p>I'll point out that it's possible to DECAY things pretty easily, but you can't recover a pack after it has been decayed.</p>
<p>So I'm getting the feeling that it's probably best to decay the assignments, but propagate the undecayed pack.  It looks like the more general and useful behavior...even if it seems a bit confusing.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-set-word-s-propagate-undecayed-packs/2178">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-set-word-s-propagate-undecayed-packs/2178</link>
          <pubDate>Fri, 29 Mar 2024 21:22:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2178</guid>
          <source url="https://forum.rebol.info/t/should-set-word-s-propagate-undecayed-packs/2178.rss">Should SET-WORD!s Propagate Undecayed Packs?</source>
        </item>
        <item>
          <title>Speed of UPARSE</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p>I’m just wondering if any benchmarking has been done on UPARSE. How does it compare to PARSE in Red or in Rebol? Or to parser combinators in Haskell? For that matter, how does it compare to an ordinary recursive-descent parser handwritten in Ren-C?</p>
<p>(Yes, I know UPARSE is unoptimised and slow. But it would be interesting to know <em>how</em> slow.)</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/speed-of-uparse/2177">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/speed-of-uparse/2177</link>
          <pubDate>Fri, 29 Mar 2024 06:47:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2177</guid>
          <source url="https://forum.rebol.info/t/speed-of-uparse/2177.rss">Speed of UPARSE</source>
        </item>
        <item>
          <title>VOID Branches (not branches that evaluate to void)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>I've mentioned before that <a href="https://forum.rebol.info/t/augment-add-parameters-and-refinements-after-the-fact/1216">AUGMENT can be used to implement the legacy SWITCH/DEFAULT behavior</a>.</p>
<p>But looking at what seems like the "correct" formulation of that code today, we get:</p>
<pre><code>switch-d: enclose (augment :switch [
    /default "Default case if no others are found"
        [block!]
]) lambda [f [frame!]] [
    let def: f.default
    eval f else (maybe def)
]
</code></pre>
<p>It points out the existence of <em>void branches</em>... so not branches that evaluate to void (e.g. <code>[void]</code>) but code that evaluates to a branch to run, and that branch is void.</p>
<p>Considering this specific usage only, it suggests a semantic for ELSE of a VOID branch, which is that you want it to act like there was no branch at all.  e.g. as if you'd written just <strong><code>eval f</code></strong> with no ELSE.</p>
<pre><code> &gt;&gt; if false [1 + 2]
 == ~void~  ; anti

 &gt;&gt; if false [1 + 2] else [10 + 20]
 == 30

 &gt;&gt; if false [1 + 2] else (void)
 == ~void~  ; anti
</code></pre>
<p>Would the same apply to THEN?</p>
<pre><code> &gt;&gt; if true [1 + 2]
 == 3

 &gt;&gt; if true [1 + 2] then [10 + 20]
 == 30

 &gt;&gt; if true [1 + 2] then (void)
 == 3
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>I don't know if it's great, but it's certainly better than evaluating to NULL (via some void-in-null-out rationale) because that would trigger an ELSE branch.</p>
<pre><code> &gt;&gt; if true [1 + 2] then (void) else [print "we don't want this."]
 we don't want this.
</code></pre>
<p>But what should other branching constructs do, like CASE or SWITCH?  Might a void branch suggest "opting out" of that particular branch?</p>
<pre><code> case [
     1 &lt; 2 (void)
     3 &lt; 4 [print "Should this run?"]
 ]
</code></pre>
<p>A CASE (at least CASE/ALL) is supposed to be synonymous with a series of IF statements.  And IF can't exactly do that, unless it decided to be NIHIL...</p>
<pre><code>&gt;&gt; 1 + 2 if false (void)
== 3
</code></pre>
<p>That would be a bit weird, but, it does sort of parallel what happens when ELSE and THEN effectively vaporize themselves.</p>
<p>As with most things on the edge of usefulness, I don't know about this... other than the situation of wanting to revoke the ELSE branch in SWITCH-D.  I'll keep an eye on it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/void-branches-not-branches-that-evaluate-to-void/2176">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/void-branches-not-branches-that-evaluate-to-void/2176</link>
          <pubDate>Thu, 28 Mar 2024 13:07:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2176</guid>
          <source url="https://forum.rebol.info/t/void-branches-not-branches-that-evaluate-to-void/2176.rss">VOID Branches (not branches that evaluate to void)</source>
        </item>
        <item>
          <title>Haskell parser combinators</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>I’ve seen a few parsing-related threads recently in this forum. I haven’t been commenting much on them, since I don’t have enough experience with UPARSE (or for that matter historical PARSE) to say anything helpful.</p>
<p>On the other hand, I <em>do</em> have a lot of experience with parser combinators in Haskell. In terms of structure and purpose, they’re probably the concept most similar to UPARSE that I’ve seen from another language. So I thought I’d write this post in the hope that something, somewhere, might eventually prove useful somehow.</p>
<h2>
<a name="high-level-overview-1" class="anchor" href="https://forum.rebol.info#high-level-overview-1"></a>High-level overview</h2>
<p>The first and most important thing to realise about parser combinators is that <strong>they’re not built into the language</strong>. They’re simply ordinary libraries which make it easy to construct parsers compositionally.</p>
<p>(I mean, for that matter, UPARSE isn’t built in either. But there’s a different level of integration with the rest of the language.)</p>
<p>The basic approach is to define a new datatype for parsers, usually called something like <code>Parser a</code>. This is a parser which can process a string (or other datatype), returning a result of type <code>a</code> if it succeeds. Alongside this there will be a set of primitive parsers, most notably <code>char</code> (to parse single characters), <code>return</code> (which always succeeds with a result), and <code>empty</code> (which always fails).</p>
<p>(Of course, practical libraries will have more primitives. <code>megaparsec</code> has <a href="https://hackage.haskell.org/package/megaparsec-9.6.1/docs/Text-Megaparsec.html#g:4">a nice selection</a>, with good comments.)</p>
<p>The most interesting bit is the way these parser combinators are combined to create larger parsers. This, of course, relies on the standard abstractions of Haskell. Two operators are particularly important:</p>
<ul>
<li>Sequencing: <code>p &gt;&gt;= f</code> is a parser which runs <code>p</code> and passes the result to function <code>f</code>, then runs the resulting parser.</li>
<li>Choice: <code>p &lt;|&gt; q</code> is a parser which runs <code>p</code>, then backtracks and runs <code>q</code> if that failed.</li>
</ul>
<p>From these basic elements you can define a very wide range of generic combinators, for instance these useful ones:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">-- sequencing ignoring result
(&gt;&gt;) :: Parser a -&gt; Parser b -&gt; Parser b
p &gt;&gt; q = p &gt;&gt;= \_ -&gt; q

-- Match a whole string
string :: String -&gt; Parser ()
string "" = return ()
string (c:cs) = char c &gt;&gt; string cs

-- 1 or more
some :: Parser a -&gt; Parser [a]
some p =
    p &gt;&gt;= \first -&gt;
    many p &gt;&gt;= \rest -&gt;
    return (first : rest)

-- 0 or more
many :: Parser a -&gt; Parser [a]
many p = some p &lt;|&gt; return []
</code></pre>
<h2>
<a name="a-basic-implementation-2" class="anchor" href="https://forum.rebol.info#a-basic-implementation-2"></a>A basic implementation</h2>
<p>This is all a little abstract, though. Probably the easiest way to understand parser combinators is to implement them.</p>
<p>A basic implementation is quite simple. A parser is just a function which takes in a string, and on success returns the result alongside the unparsed portion of the string:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">newtype Parser a = Parser (String -&gt; Maybe (String, a))
</code></pre>
<p>You then run the parser simply by unwrapping the function and applying it to your input:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">runParser :: Parser a -&gt; String -&gt; Maybe (String, a)
runParser (Parser p) input = p input
</code></pre>
<p>Simple parsers work as you’d expect:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">char :: Char -&gt; Parser ()
char c = Parser $ \input -&gt; case input of
    (c':cs) | c == c' -&gt; Just (cs, ())
    _ -&gt; Nothing

return :: a -&gt; Parser a
return a = Parser $ \input -&gt; Just (input, a)

empty :: Parser a
empty = Parser $ \_ -&gt; Nothing
</code></pre>
<p>The combinators require more elaborate state-threading, but are still straightforward:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">(&gt;&gt;=) :: Parser a -&gt; (a -&gt; Parser b) -&gt; Parser b
p &gt;&gt;= f = Parser $ \input -&gt;
    case runParser p input of
        Nothing -&gt; Nothing
        Just (partiallyParsed, a) -&gt;
            runParser (f a) partiallyParsed

(&lt;|&gt;) :: Parser a -&gt; Parser a -&gt; Parser a
p &lt;|&gt; q = Parser $ \input -&gt;
    case runParser p input of
        Just result -&gt; Just result
        Nothing -&gt; runParser q input
</code></pre>
<p>This simple code suffices for a surprisingly wide variety of tasks. For instance, a slight variant is present in the base library as <a href="https://hackage.haskell.org/package/base-4.16.3.0/docs/Text-Read.html#t:ReadS"><code>ReadS</code></a>. (The variation is that <code>ReadS</code> can produce multiple results.)</p>
<h2>
<a name="managing-backtracking-3" class="anchor" href="https://forum.rebol.info#managing-backtracking-3"></a>Managing backtracking</h2>
<p>Unfortunately, <strong>this has serious problems with any larger-scale use</strong>. For one thing, it can’t do error reporting beyond ‘it failed somewhere’. But there are even bigger problems with this implementation of the choice combinator <code>(&lt;|&gt;)</code>:</p>
<ol>
<li>It behaves unpredictably: any error anywhere will result in the parser backtracking to the last choice, and so on until every single choice has been exhausted. This is bad for the time complexity, plus it leaves you no chance of ever reporting errors nicely.</li>
<li>It holds onto the input string during the whole time <code>p</code> is executing. This creates a space leak, which grows larger the more nested choices you have.</li>
</ol>
<p>The first parser combinator library to solve these issues was <code>Parsec</code>. Its design is described in <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/parsec-paper-letter.pdf">this paper</a> (which seems very readable). I won’t describe its implementation here… but the basic idea is simple to summarise: each parser keeps track of what it’s consumed, and <strong>commits to a parser as soon as it’s consumed any characters</strong>.</p>
<p>Some parsers require no changes under this new semantics. For instance, <code>string "first word" &lt;|&gt; string "second word"</code> works without problems. If it sees an input character <code>f</code>, the first choice <code>string "first word"</code> matches immediately, meaning the library can commit to the first parser, and know that the second parser never needs to run. On the other hand, upon seeing an input character <code>'s'</code>, that first parser will fail on that very first character: since no characters have been consumed, control passes over to the second parser to succeed or fail.</p>
<p>On the other hand, more elaborate lookahead becomes more difficult. For instance, <code>string "word 1" &lt;|&gt; string "word 2"</code> no longer works: as soon as this parser sees <code>'w'</code>, it matches the first parser, so the second parser will never be run.</p>
<p>To solve this, Parsec introduces a new primitive combinator: <code>try</code>, which creates a parser which never consumes characters on failure. The effect of this is to allow backtracking over whatever is in the <code>try</code>. For this example, <code>try (string "word 1") &lt;|&gt; string "word 2"</code> would work as expected.</p>
<p>The nice thing about this approach is the control it gives you. For instance, I can write things like:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">(try (string "App") &gt;&gt; string "le") &lt;|&gt; string "Apricot"
</code></pre>
<p>Here, as soon as the parser reaches a second <code>'p'</code>, it can commit to the first branch. But if it sees another character, it’s still able to backtrack through the <code>string "App"</code> and move on to the second branch. Of course, this is a contrived example — but in general, being able to specify the control flow of your parser like this is exceedingly useful in larger parsers.</p>
<h2>
<a name="what-use-is-this-for-rebol-4" class="anchor" href="https://forum.rebol.info#what-use-is-this-for-rebol-4"></a>What use is this for Rebol?</h2>
<p>Quite probably, none at all.</p>
<p>But like I said, I’m hoping potentially some of this might end up useful somewhere. If it can act as inspiration which helps solve any problems, I’m happy.</p>
<p>And, of course, now that we have this thread for it, feel free to ask me any questions about parser combinators you might have!</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/haskell-parser-combinators/2173">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/haskell-parser-combinators/2173</link>
          <pubDate>Mon, 11 Mar 2024 15:08:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2173</guid>
          <source url="https://forum.rebol.info/t/haskell-parser-combinators/2173.rss">Haskell parser combinators</source>
        </item>
        <item>
          <title>-&gt; for LAMBDA (or... &quot;LAMBDA-Lite?&quot;)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>So I'm still shoring up a new bootstrap executable, patching around in a 6-years-out-of-date codebase.   It's in some ways a cruel and unusual punishment... but in other ways a good trip down memory lane to revisit decisions that were made, and ask "was that the right decision?"</p>
<p>The 6-year-old EXE defined an enfix form of lambda as <strong><code>=&gt;</code></strong>.  I shifted it to the lighter form as <strong><code>-&gt;</code></strong>.  Contrast:</p>
<pre><code>y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then (lambda [x] [
    assert [x = &lt;yes&gt;]
    1000 + 20
])
assert [y = 1020]

y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then x =&gt; [
    assert [x = &lt;yes&gt;]
    1000 + 20
]
assert [y = 1020]

y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then x -&gt; [
    assert [x = &lt;yes&gt;]
    1000 + 20
]
assert [y = 1020]
</code></pre>
<p><em>(Supplemental: Reddit post on <a href="https://www.reddit.com/r/ProgrammingLanguages/comments/shllr3/whats_the_syntax_of_lambda_expressions_in_your/">"What's the syntax of lambda expressions in your language"</a>)</em></p>
<p><strong>I like the <code>-&gt;</code> and don't think there's a greater purpose for it in the box.</strong>  As with everything else, overriding it is a personal choice.</p>
<h2>
<a name="a-speaking-with-ticshttpsforumrebolinfotspeaking-with-tics-should-quoted-arguments-always-be-apostrophed1359-note-1" class="anchor" href="https://forum.rebol.info#a-speaking-with-ticshttpsforumrebolinfotspeaking-with-tics-should-quoted-arguments-always-be-apostrophed1359-note-1"></a>A <a href="https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359">Speaking-With-Tics</a> Note</h2>
<p>Mechanically getting this to work is non-trivial:</p>
<p><a href="https://forum.rebol.info/t/the-most-vexing-evaluation-lambda-meets-then-else/1361" class="inline-onebox">The Most Vexing Evaluation: LAMBDA meets THEN/ELSE</a></p>
<p>Part of what makes it non-trivial is the "literal lookback" by which <strong><code>-&gt;</code></strong> infixedly snatches the X without letting it evaluate.</p>
<p><a class="mention" href="https://forum.rebol.info/u/bradrn">@bradrn</a> might argue such mechanics shouldn't be necessary, because source-level non-evaluation should be explicit, e.g. <strong><code>'x -&gt; [...]</code></strong></p>
<pre><code>y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then 'x -&gt; [
    assert [x = &lt;yes&gt;]
    1000 + 20
]
assert [y = 1020]
</code></pre>
<p>But that's one more stroke of key than I want, and one more piece of dirt than I want to see.  <em>I know from context that slot is a variable name, in the most common case.</em>  I'm not upset by intricate work to faciliate it, if it actually works (and empowers other creative things).  So I need to see hard disproofs before sacrificing what I consider to be "the point" of the design.</p>
<p>I'm always ready to look at it from a further perspective to see a "greater point".  But still--from where I stand--that apostrophe sucks relative to not having it.  (And if you read the details of the implementation post, the only reason it's allowed to work in a quoted slot is because of left literalism, so...)</p>
<h2>
<a name="what-about-multiple-arguments-2" class="anchor" href="https://forum.rebol.info#what-about-multiple-arguments-2"></a>What About Multiple Arguments?</h2>
<p>Notationally there are questions about this form of lambda.  Does it use a block for multiple arguments?</p>
<pre><code>&gt;&gt; foo: [a b] -&gt; [a + b + 20]

&gt;&gt; foo 400 600
== 1020
</code></pre>
<p>It could, but you could be weirder:</p>
<pre><code>foo: a.b -&gt; [a + b + 20]

foo: a/b -&gt; [a + b + 20]
</code></pre>
<p>This would look a little tighter with branching, I think, since it wouldn't compete with the branches:</p>
<pre><code>case [
    ...
] then [a b] -&gt; [
    ...
]

case [
    ...
] then a.b -&gt; [
    ...
]
</code></pre>
<p><em>But wait, you'd never use it with a branch... because a branch only produces one value.</em></p>
<p>UNLESS... what if what this form of lambda did was unpack packs?</p>
<pre><code>case [
    true [pack [10 + 20, 3 + 4]]  ; makes antiform ~['30 '7]~
    ...
] then [a b] -&gt; [
    assert [a = 30, b = 7]
]

case [
    true [pack [10 + 20, 3 + 4]]
    ...
] then a -&gt; [
    assert [a = 30]
]
</code></pre>
<p>So I've been thinking this is what it should actually do.  It means -&gt; won't be a good way to define functions or lambdas generally, but you have FUNC(TION) and LAMBDA for that.</p>
<p>I don't know that enabling a lighter notation like <strong><code>a.b</code></strong> or <strong><code>a/b</code></strong> is worth it.</p>
<pre><code>case [
    true [pack [10 + 20, 3 + 4]]
    ...
] then a.b -&gt; [
    assert [a = 30, b = 7]
]

case [
    true [pack [10 + 20, 3 + 4]]
    ...
] then a/b -&gt; [
    assert [a = 30, b = 7]
]
</code></pre>
<p>Maybe just confusing, and limits what you can put in the spec.  Easier to add later if it seems useful than put it in now and take out later.</p>
<h2>
<a name="is-there-a-good-name-for-lambda-lite-3" class="anchor" href="https://forum.rebol.info#is-there-a-good-name-for-lambda-lite-3"></a>Is There A Good Name For "Lambda Lite"?</h2>
<p>We could call it an "unpacking lambda".  Maybe it's controlled with a refinement:</p>
<pre><code> &gt;&gt; foo: lambda/unpack [a b] [a + b + 20]

 &gt;&gt; foo pack [400 600]
 == 1020
</code></pre>
<p>Then <strong><code>-&gt;: :lambda/unpack</code></strong></p>
<p>We could just call it <em>"an unpacker"</em>.</p>
<pre><code> &gt;&gt; foo: unpacker [a b] [a + b + 20]

 &gt;&gt; foo pack [400 600]
 == 1020
</code></pre>
<p>Then <strong><code>-&gt;: :unpacker</code></strong></p>
<p>The problem with calling it an "unpacker" is that 9 (or more) times out of 10 it will only take a single argument and not unpack anything.  So it seems better to classify it as a shade of distinction on lambda, but still when you point to an <code>-&gt;</code> on the screen say <em>"then it passes the argument to the lambda..."</em></p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/for-lambda-or-lambda-lite/2172">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/for-lambda-or-lambda-lite/2172</link>
          <pubDate>Sun, 10 Mar 2024 15:21:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2172</guid>
          <source url="https://forum.rebol.info/t/for-lambda-or-lambda-lite/2172.rss">-&gt; for LAMBDA (or... &quot;LAMBDA-Lite?&quot;)</source>
        </item>
        <item>
          <title>Antiform TAG! As &quot;Triggers an Error On Access&quot; Type</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>In the post <a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604">"Shades of Distinction In Non-Valued Intents"</a>, I had originally written:</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1604">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604/1">Shades of Distinction In Non-Valued Intents</a>
</div>
<blockquote>
<p>Eventually the NULL state became the isotopic status of the WORD! null, so a <strong>~null~</strong> antiform.</p>
<p>It joined <strong>~true~</strong> and <strong>~false~</strong> as being antiforms you could test for truthiness and falseyness. But if you were okay with getting an error on conditional testing, any other word could be used:</p>
<pre><code class="lang-plaintext">  config: ~initialize-system-not-called~

  initialize-system: func [
      {Let's say this function reads the config file}
  ][
      ...
      config: [...]
  ]
</code></pre>
<p>This usually causes a nice labeled message anytime someone tries to use CONFIG:</p>
<p>Going this route would create a pain point for anyone who thought they were going to test for whether you had a config initialized by testing <strong>if config [...]</strong>. So that has to be considered as whether it's what you want.</p>
</blockquote>
</aside>
<p>I've come to question this as things have gone on, to where I'm wondering if all antiform words should be reserved by the system (there are system purposes for the ~end~ antiform, for instance).</p>
<p>A generic "error trigger" might come from something like antiform TAG!, permitting spaces:</p>
<pre><code>config: ~&lt;INITIALIZE-SYSTEM not called&gt;~

initialize-system: func [
    {Let's say this function reads the config file}
][
    ...
    config: [...]
]

&gt;&gt; config
** Error: INITIALIZE-SYSTEM not called
</code></pre>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/antiform-tag-as-triggers-an-error-on-access-type/2170">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/antiform-tag-as-triggers-an-error-on-access-type/2170</link>
          <pubDate>Sat, 09 Mar 2024 08:49:19 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2170</guid>
          <source url="https://forum.rebol.info/t/antiform-tag-as-triggers-an-error-on-access-type/2170.rss">Antiform TAG! As &quot;Triggers an Error On Access&quot; Type</source>
        </item>
        <item>
          <title>Renaming SPECIFIER =&gt; CONTEXT ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>There was a typeset in historical Rebol that was called ANY-OBJECT!, that tried to pull together anything that had WORD! keys that could be used as a binding target:</p>
<pre><code>r3-alpha&gt;&gt; help any-object!
ANY-OBJECT! is a typeset of value: make typeset! [
    object! module! error! task! port!
]
</code></pre>
<p>I had sort of a naming philosophy (which I still have) that you shouldn't name the category based on one of its instances like this.  Several reasons, but one is that it certainly confuses the implementation when you extract the pointed-to entity out of a cell:</p>
<pre><code> if (Cell_Type(cell) == TYPE_ERROR) {
     Object* = Cell_Object(cell);  // wait, but it's an ERROR! not an OBJECT!
     ...
 }
</code></pre>
<p>You could call it <code>AnyObject</code>, I guess.  But that's not the direction I took... instead calling the category ANY-CONTEXT!, and if you saw <code>Context*</code> in the source you wouldn't get confused to thinking it was an extraction from a CONTEXT! cell, because there was no such thing.  You knew it was the implementation of a superclass.</p>
<h2>
<a name="enter-specifier-1" class="anchor" href="https://forum.rebol.info#enter-specifier-1"></a>Enter "Specifier"</h2>
<p>"Specifier"--the aggregated inheritance of binding candidates--has moved from an implementation detail to something which is rising to the surface of user awareness.  For that, it's a lousy name... and am near-certain I want to take "Context" for it.</p>
<p>I like Context better than Environment, as it's shorter and leaves environment for "environment variables" (which being a script-class language Ren-C needs to be better at interacting with than it is today).</p>
<p>We could say the other types are ANY-DICTIONARY!, although the name DICTIONARY! has been suggested as a replacement for MAP!, since we are thinking of MAP more as a function now.  But Dictionary may make more sense for things that only permit "words" as keys.</p>
<p>A CONTEXT! itself--as a composition of other dictionaries (and possibly even just programmatic code that answers value-for-WORD!)--may itself be categorized as an ANY-DICTIONARY!</p>
<h2>
<a name="implementation-variance-needs-work-2" class="anchor" href="https://forum.rebol.info#implementation-variance-needs-work-2"></a>Implementation Variance Needs Work</h2>
<p>So something that has happened in the messy evolution of the code is that the one-size-fits all <strong><code>Context*</code></strong> data structure that backed things like OBJECT!, ERROR!, MODULE! etc. became fractured around the time of Sea of Words and LET.</p>
<p>Modules do not use the same representation, and have to be enumerated completely differently.  There's not really a lot of generic code that acts the same way for OBJECT! and MODULE!, to the point that we'd be better off dispelling the illusion in the C sources and making <strong><code>Module*</code></strong> its own distinct type.</p>
<p>There's a lot to consider here about what the limits of "Amish" implementation are:</p>
<ul>
<li>
<p>I'm pretty much sold on the known-integer-values concept for Frame.  And if <em><strong>I</strong></em> say that drifting away from that destroys what the project <em>is</em>, then it almost certainly does--because I'm known for being iconoclastic about a fair number of Rebol sacred cows.</p>
</li>
<li>
<p>BUT taking a diverging approach for Module from "parallel arrays of Key and Value cell indexed by integer" has proven essential.  Floating variable stubs hanging off the word symbols themselves is an answer that has been critical in giving some legitimacy to modules, and it still passes the "simple" test for me.</p>
<ul>
<li>R3-Alpha was utterly hopeless, and Red will be too if they follow down that path (should they ever get modules).  I do not think this is a problem appropriate to approach with two-parallel-arrays.</li>
</ul>
</li>
<li>
<p>Objects are kind of a wild card.  Given their attempt to be dirt-simple, we might more accurately call the current version "Struct" or "Structure" instead (major annoyance in C naming the variables though, <code>Struct _struct</code>, to dodge the <code>struct</code> keyword?)</p>
<ul>
<li>
<p>People want to dynamically add and remove keys from objects.  Rebol2 and Red don't allow it, and R3-Alpha only permitted growth (so the index numbers stored in words that were bound at an index wouldn't be invalidated)</p>
</li>
<li>
<p>Moving to a more amortized implementation that spreads and shares keys gets you to something more like a database, where you can't point to little contiguous packets of memory and say "there is the object."</p>
</li>
<li>
<p>As I said above, I think this was a necessity for Modules.  But the simple implementation that works quite well for them wouldn't scale to tens of thousands of objects which have keys with the same name.</p>
</li>
<li>
<p>There's plenty of prior art and writeups of how JavaScript engines and others have approached this, and gotten it to be fast.</p>
</li>
</ul>
</li>
</ul>
<p>Anyway, this all kind of culminates in saying that objects are due for a reckoning at some point.  We want to err on the side of simplicity over optimized complexity, but there may be a sufficiently elegant way to attack objects that can grow and shrink effectively and having better code overall than we have today.</p>
<h2>
<a name="anyway-back-to-the-naming-issue-3" class="anchor" href="https://forum.rebol.info#anyway-back-to-the-naming-issue-3"></a>Anyway, Back To The Naming Issue...</h2>
<p>The above sort of reveals why ANY-OBJECT! isn't a good name for ANY-DICTIONARY or ANY-BINDTARGET?.</p>
<p>Hm, maybe we consider ANY-BINDABLE? to be the category for things that can be bound <em>to</em>, and come up with another name for anything that can be bound?  ANY-REFERENCE?</p>
<p>Eh, that sounds confusing.  Dictionary may be about as good as it gets (?)</p>
<p>So basically, Dictionary would be a superclass offering lookup from Word Symbol =&gt; Value.  If you wanted anything else from it, you would have to figure out what subclass it was, because how you do things like enumerate keys and values diverges significantly.</p>
<h2>
<a name="or-maybe-some-unifying-theory-will-come-along-4" class="anchor" href="https://forum.rebol.info#or-maybe-some-unifying-theory-will-come-along-4"></a>Or Maybe Some Unifying Theory Will Come Along?</h2>
<p>It could be, that everything--including OBJECT! and MODULE!, have the "inheritance" powers of what Specifier has today.</p>
<p>Which would mean that you wouldn't have Specifiers.  You'd just ask for the binding of a block and maybe get a MODULE! that inherits from an OBJECT!, or an OBJECT! that inherits from a MODULE!, or a LET! that inherits from a LET! that inherits from an OBJECT!, etc.</p>
<p>It all warrants more thought, and maybe a quick attempt to swap out the current OBJECT! implementation with something like V8's <a href="https://v8.dev/docs/hidden-classes">Hidden Classes</a> and see how it meshes with the system.  I've been so focused on the "bricks" in the language that these sorts of "boring" implementation details have just sort of been left alone while that's sorted out, but now it's getting to the point where there seem to be some answers to guide the shape.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/renaming-specifier-context/2168">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/renaming-specifier-context/2168</link>
          <pubDate>Wed, 06 Mar 2024 18:56:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2168</guid>
          <source url="https://forum.rebol.info/t/renaming-specifier-context/2168.rss">Renaming SPECIFIER =&gt; CONTEXT ?</source>
        </item>
        <item>
          <title>Mapping from Series =&gt; Series By Co-Opting The Key Series</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p>There was an unfinished idea in an old version of the interpreter.  It related to how to deal with problems like trying to make a copy of a block, and make sure any series with the same identity are only copied once in the new structure, and point to that one copied identity.</p>
<p>Rebol2 did not have this behavior:</p>
<pre><code>rebol2&gt;&gt; block: [a]
== [a]

rebol2&gt;&gt; original: reduce [block block]
== [[a] [a]]

rebol2&gt;&gt; append block 'b
== [a b]

rebol2&gt;&gt; original
== [[a b] [a b]]  ; both aliases see the append

rebol2&gt;&gt; duplicate: copy/deep original
== [[a b] [a b]]

rebol2&gt;&gt; append first duplicate 'c
== [a b c]

rebol2&gt;&gt; duplicate
== [[a b c] [a b]]  ; considered by many to be wrong: independent copies
</code></pre>
<p>This post isn't about whether that is right or wrong (and having such questions may seem to some as an indication of <em>"this language is madness! get me to Haskell"</em>, etc. But as I've said this is the game we're playing here so we roll with it.)</p>
<p>But to not get independent copies, you need a way to map series nodes to copies you've already created...so you can consult that mapping before making new copies.  And the direction that was being pursued by the old interpreter I am looking at was to actually do surgery on the originating series nodes, to alter them so they shifted out some of their content, such that they could be their own keys in the mapping.</p>
<p>Generally speaking, all the bits in a series stub are spoken for.  So it would seem there's nowhere to stow a pointer to the new series you are creating in it.  What the implementation was doing was pushing a 4 pointer cell on the data stack, writing one pointer's worth of information from the stub into that cell, then replacing that pointer slot in the stub with the stack index.  Then it wrote the new series into the cell...so the cell contained one stowed pointer from the original series and one pointer for the new series.</p>
<p>This meant the original series was now in a "weird" state, that things like the GC had to know about and tolerate.  Other operations looking for the missing information in the stub needed to be caught if they tried to get at it without following the stack index through to the stack cell.</p>
<p>Having the cells on the data stack meant it was not necessary to enumerate all the series stubs after a copy to "clean them up".  Otherwise, I'd imagine it may be possible to make some kind of guarantee that for any series appearing in source, the union of the bits in the source series and the bits of the copied series can hold all the information necessary to construct two valid series... e.g. one pointer's worth of information is always redundant in those two copies.  If you can get <em>two</em> pointers' worth of information redundant, the second could be used to chain a linked list as you go...removing the need for the stack cells to enumerate.</p>
<p>Though having the stack cells and no particular requirement of information redundancy in source series with their copies offers another benefit: being applicable for creating mappings that aren't copying-related.</p>
<p>Anyway, it was a little unfinished idea I ran across that I wanted to document.  I'm cleaning up the bootstrap executable to refresh it with something that will help <a href="https://forum.rebol.info/t/rethinking-braces-as-an-array-type/1727">in the FENCE! migration</a>, and mercilessly deleting any code in the bootstrap executable that does not specifically benefit bootstrap... to reduce the instability surface, speed things up, and make it easier to debug the 6-year old executable if worst comes to worst.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/mapping-from-series-series-by-co-opting-the-key-series/2166">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/mapping-from-series-series-by-co-opting-the-key-series/2166</link>
          <pubDate>Wed, 06 Mar 2024 15:24:07 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2166</guid>
          <source url="https://forum.rebol.info/t/mapping-from-series-series-by-co-opting-the-key-series/2166.rss">Mapping from Series =&gt; Series By Co-Opting The Key Series</source>
        </item>
        <item>
          <title>Revisiting a Maybe-Not-So-Weird Old Idea: &lt;- as IDENTITY</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>So at one point I had a kind of strange idea for what to do with <strong><code>&lt;-</code></strong>.</p>
<p>It would just pass through what you gave on its right.  And the idea was that you could use this in various situations as a kind of visual signal that you intended to produce a value that would be used by... something.</p>
<p>You could use it to hint when a line is being continued:</p>
<pre><code>browse join
    &lt;- https://github.com/metaeducation/ren-c/blob/master/CHANGES.md#
    &lt;- unspaced [system.version.1 "." system.version.2 "." system.version.3]
</code></pre>
<p>That JOIN is arity 2.   The arrows do nothing, but quickly pass through what they were passed.</p>
<p>The current alternative you might reach for are parentheses, but you can only put it around the outermost level, and it's noticeably inferior:</p>
<pre><code>browse (join
    https://github.com/metaeducation/ren-c/blob/master/CHANGES.md#
    unspaced [system.version.1 "." system.version.2 "." system.version.3]
)
</code></pre>
<p>I had another idea that the arrow might be nice for signaling when you're at the end of a branch to help hint that the branch result is actually used.</p>
<pre><code> something: case [
     ... [...]
     ... [...]
     ; lots of code to where SOMETHING: has scrolled off the screen
     ... [
         your code here
         more code here
         &lt;- append data "stuff"
     ]
 ]
</code></pre>
<p>It gives you a nice hint that the result of the append (the head of the appended series) is actually used.<br>
<strong>But, these two uses are in contention.</strong>  You can't use it to mean "continue the line above" and "pipe result out to some higher level.  Perhaps this is better done with an impromptu CATCH/THROW?</p>
<pre><code> something: catch [case [
     ... [... throw ...]
     ... [... throw ...]
     ; lots of code to where SOMETHING: has scrolled off the screen
     ... [
         your code here
         more code here
         throw append data "stuff"
     ]
 ]]
</code></pre>
<p>(Note that CATCH/THROW have nothing to do with errors in Rebol, it's a lightweight construct for doing this kind of manipulation.)</p>
<h2>
<a name="why-did-i-kill-off-the-as-identity-1" class="anchor" href="https://forum.rebol.info#why-did-i-kill-off-the-as-identity-1"></a>Why Did I Kill Off The &lt;- As Identity?</h2>
<p>It was changed shortly after deciding to take <strong>-&gt;</strong> for an infix lambda operation.</p>
<pre><code> foo: x -&gt; [print ["I'm a lambda" x]]

 &gt;&gt; foo 1020
 I'm a lambda 1020
</code></pre>
<p>This is particularly nice-looking in branching when you want to pass the branch result.</p>
<pre><code>all [
    1 &lt; 2
    3 &lt; 4
    #something
] then x -&gt; [
   print ["X is" mold x]  ; X is #something
]
</code></pre>
<p>The first incarnation used <strong><code>=&gt;</code></strong> as JavaScript did.  But not only is the arrow lighter, it doesn't weigh on the question of whether <strong><code>=&gt;</code></strong> is an "arrow", when <strong><code>&lt;=</code></strong> is not one.  (Debate has been had over whether =&gt; should be a synonym for &gt;=, and =&lt; a synonym for &lt;=, etc. but status quo has won out.)</p>
<p>So <strong><code>&lt;-</code></strong> was targeted as another function generator, namely for doing tacit programming as an alias for POINTFREE.</p>
<pre><code>foo: &lt;- [append [a b c]]

&gt;&gt; foo 'd
== [a b c d]
</code></pre>
<p>The attempt to write POINTFREE entirely in usermode stalled a bit in the face of other priorities, though it's still very much desired.  And it doesn't seem like a bad idea to have &lt;- and -&gt; both connected as fundamental convenient function generators.</p>
<p>I've not really questioned the decision to strike &lt;- as identity until I realized looking at some old code that it really is nice to have some alias for identity, used for one of the annotation purposes I mention.</p>
<p>Backtick is available, though backticks are kind of a blight in general:</p>
<pre><code>browse join
  ` https://github.com/metaeducation/ren-c/blob/master/CHANGES.md#
  ` unspaced [system.version.1 "." system.version.2 "." system.version.3]
</code></pre>
<p>There's a few other ugly options, e.g. backslash which we still haven't given meaning to either.</p>
<pre><code>browse join
  \ https://github.com/metaeducation/ren-c/blob/master/CHANGES.md#
  \ unspaced [system.version.1 "." system.version.2 "." system.version.3]
</code></pre>
<p><strong>Anyway, the cool idea here was just that line continuation not be a scanner feature, but be signaled by means of a normal token that ran the identity function... and you'd be cued into realizing that it was a continuation just because there's no point in calling the identity function in source unless you were applying it like this.</strong></p>
<p>We could throw in a little help by having the evaluator only allow this if it was--actually--an argument to a function.</p>
<p>Based on the above, I'm liking the backtick, and am not sure I'd want heavier for line continuation.</p>
<p>The idea of &lt;- being an alternate way of saying identity that is used for the other annotation purpose (this result is used by the higher up stack level) would then be a possibility.  The system could maybe help a little bit here too, by making sure the <strong>&lt;-</strong> <em>isn't</em> an argument to a function...</p>
<p>POINTFREE would need some other shorthand.  But maybe it's just an alternate mode of LAMBDA.  Or maybe it doesn't really need a shorthand.</p>
<pre><code>foo: ... -&gt; [append [a b c]]

foo: &lt;*&gt; -&gt; [append [a b c]]

foo: |-&gt; [append [a b c]]

foo: -|&gt; [append [a b c]]

foo: pointfree [append [a b c]]

&gt;&gt; foo 'd
== [a b c d]
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/revisiting-a-maybe-not-so-weird-old-idea-as-identity/2165">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/revisiting-a-maybe-not-so-weird-old-idea-as-identity/2165</link>
          <pubDate>Wed, 06 Mar 2024 14:20:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2165</guid>
          <source url="https://forum.rebol.info/t/revisiting-a-maybe-not-so-weird-old-idea-as-identity/2165.rss">Revisiting a Maybe-Not-So-Weird Old Idea: &lt;- as IDENTITY</source>
        </item>
        <item>
          <title>Header dialect and multiline strings</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Modules</category>
          <description><![CDATA[
            <p>I've been reading the threads about multiline strings and using {} for arrays, and I'm thinking that the header is going to look rather messy given that's it's not uncommon to have multiline statements there.</p>
<pre><code>Rebol [
    Title: "Your module title here"
    Type: module
    Name: your-module
    Rights: -{
        Copyright 2012 REBOL Technologies
        Copyright 2017-2021 Ren-C Open Source Contributors
    }-
    License: -{
        Licensed under the Apache License, Version 2.0
        See: http://www.apache.org/licenses/LICENSE-2.0
    }-
    Description: \{
       Weirdly this does not look as good, despite dropping a character.
       
            printf("The char is } and it need not be escaped\n");

       So that's good.  And here we can do \n\n\n for escaped lines.
   }\
]
</code></pre>
<p>As an alternative I quite like the way yaml is written, it's very clean without a lot of funny distracting escape characters.  Can we consider using a yaml dialect for the header?</p>
<pre><code>Rebol -{
    Title: Your module title here
    Type: module
    Name: your-module

    Rights: |
        Copyright 2012 REBOL Technologies
        Copyright 2017-2021 Ren-C Open Source Contributors

    License: |
        Licensed under the Apache License, Version 2.0
        See: http://www.apache.org/licenses/LICENSE-2.0

    Description: |
       This would be YAML-based.
       
            printf("The char is } and it need not be escaped\n");

       So that's good.  And here we can do \n\n\n for escaped lines.
}-
</code></pre>
            <p><small>8 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/header-dialect-and-multiline-strings/2159">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/header-dialect-and-multiline-strings/2159</link>
          <pubDate>Wed, 28 Feb 2024 07:17:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2159</guid>
          <source url="https://forum.rebol.info/t/header-dialect-and-multiline-strings/2159.rss">Header dialect and multiline strings</source>
        </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Development - AltRebol</title>
    <link>https://forum.rebol.info/c/development/8</link>
    <description>Topics in the &#39;Development&#39; category Discussion of the development of Rebol itself: language design, implementation and standard library.</description>
    
      <lastBuildDate>Thu, 21 Nov 2024 22:06:22 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/8.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Dropping `&lt;with&gt;`, `&lt;in&gt;`, `&lt;static&gt;`</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>In R3-Alpha, there was the idea that FUNC was lower-level, <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/mezz/base-funcs.r#L28C1-L56C2">and "FUNCTION" was built on top of it</a>.</p>
<p>Its principal difference was automatically collecting SET-WORD!s as locals.  But it added two refinements: <strong>/WITH</strong> and <strong>/EXTERN</strong>.</p>
<p>/EXTERN was a way of saying what shouldn't get collected as a local variable due to being a SET-WORD!:</p>
<pre><code>global-var: 10

foo: function/extern [arg1 arg2] [
    local-var: "hi"
    global-var: 20  ; /EXTERN protected this from being collected local
    return arg1 + arg2
] [global-var]
</code></pre>
<p>/WITH was a way of making static variables:</p>
<pre><code>accumulate: function/with [x] [
   return state: state + x
] [state: 0]
</code></pre>
<h2><a name="p-7923-early-on-ren-c-moved-everything-into-the-spec-1" class="anchor" href="https://forum.rebol.info#p-7923-early-on-ren-c-moved-everything-into-the-spec-1"></a>Early On, Ren-C Moved Everything Into The Spec</h2>
<p>I didn't like seeing the refinement arguments at the end (of what could be a very long function definition).</p>
<p>It didn't occur to me to suggest that <a href="https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331">refinement arguments be moved to the head</a> (which they probably should).  But what did occur to me was that the function spec could incorporate these properties.</p>
<p>I actually thought <code>&lt;with&gt;</code> seemed better than extern, as a nicer word for "Use these existing variables".  And <code>&lt;static&gt;</code> seemed like a well-known term for static variables:</p>
<pre><code>foo: function [arg1 arg2 &lt;with&gt; global-var] [
    local-var: "hi"
    global-var: 20
    return arg1 + arg2
]

accumulate: function [x &lt;static&gt; state (0)] [
   return state: state + x
]
</code></pre>
<p>The subtlety of wanting to use an object instance was also added, as <code>&lt;in&gt;</code>:</p>
<pre><code>obj: make object! [a: 10 b: 20]

bar: function [x &lt;in&gt; obj] [
   return a + b + x
]
</code></pre>
<p>To my eyes, that all seemed like improvement.</p>
<p><strong>But it didn't come without cost: The spec had to be transformed into something the lower-level FUNC could understand.</strong></p>
<p>This meant there was a layer of parsing and production of a new spec that was a tax on every function creation.</p>
<h2><a name="p-7923-time-passes-set-word-gathering-is-panned-2" class="anchor" href="https://forum.rebol.info#p-7923-time-passes-set-word-gathering-is-panned-2"></a>Time Passes, SET-WORD! Gathering Is Panned</h2>
<p>It didn't take long for me to decide that <a href="https://forum.rebol.info/t/rethinking-auto-gathered-set-word-locals/1150">SET-WORD! locals-gathering was bad</a>... a gimmick that only made sense in very limited domains (perhaps code-golf)</p>
<p>This motivated having an answer for how to implement LET, as "virtual binding" became the new plan.</p>
<p>Once that transition went through, the effect of <strong><code>&lt;with&gt;</code></strong> was to become commentary.  Since all it did was remove SET-WORD!s from the collection list, and there was no collection any longer.</p>
<p>Though virtual binding did open up a new possibility, that if your block had a different binding than the spec, then the WITH might import visibility of terms to that block:</p>
<pre><code>global-variable: 10

block: /get-block-from-somewhere ...  ; doesn't know about GLOBAL-VARIABLE

/foo: function [x &lt;with&gt; global-variable] block
</code></pre>
<p>But this would be a binding operation, that is better generalized as:</p>
<pre><code>/foo: function [x] (bind @global-variable block)
</code></pre>
<h2><a name="p-7923-pushing-the-features-to-bind-make-the-most-sense-3" class="anchor" href="https://forum.rebol.info#p-7923-pushing-the-features-to-bind-make-the-most-sense-3"></a>Pushing The Features To BIND Make The Most Sense</h2>
<p>Not just <code>&lt;with&gt;</code>, but the <code>&lt;static&gt;</code> and <code>&lt;in&gt;</code> features seemed to be better as BIND operations as well.</p>
<p>The static syntax of not using SET-WORD!s was based on the idea that SET-WORD!s were reserved for local variables (and RETURN: syntax).  So it was a WORD! followed by a GROUP! to initialize.</p>
<p>I think it's better done with just <a href="https://forum.rebol.info/t/rethinking-static-in-the-function-spec-dialect/2139">BIND to a FENCE!</a></p>
<pre><code>accumulate: function [
    x
] bind {state: 0} [
   return state: state + x
]
</code></pre>
<p><code>&lt;in&gt;</code> is similar.</p>
<pre><code>obj: make object! [a: 10 b: 20]

bar: function [
   x
] bind obj [
   return a + b + x
]
</code></pre>
<h2><a name="p-7923-uglier-maybe-more-general-yes-faster-definitely-4" class="anchor" href="https://forum.rebol.info#p-7923-uglier-maybe-more-general-yes-faster-definitely-4"></a>Uglier?  Maybe.  More General?  Yes.  Faster?  Definitely.</h2>
<p>Feature-wise, there's a slight loss of the commentary capacity of <code>&lt;with&gt;</code>.</p>
<pre><code>global-var: 10

foo: function [arg1 arg2 &lt;with&gt; global-var] [  ; no-op, but useful?
    global-var: 20
    return arg1 + arg2
]
</code></pre>
<p>But besides that, there's no loss of features to move everything to a BIND operation on the body.</p>
<p>Not having to PARSE the spec and generate a whole new one is a big performance win.</p>
<p>So I'm letting go of those features.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/dropping-with-in-static/2335">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dropping-with-in-static/2335</link>
          <pubDate>Thu, 21 Nov 2024 22:06:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2335</guid>
          <source url="https://forum.rebol.info/t/dropping-with-in-static/2335.rss">Dropping `&lt;with&gt;`, `&lt;in&gt;`, `&lt;static&gt;`</source>
        </item>
        <item>
          <title>The Semantics of JOIN</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p><strong>As <a class="mention" href="https://forum.rebol.info/u/brett">@Brett</a>'s critique of yesteryear pointed out, <a href="https://forum.rebol.info/t/rejoin-ugliness-and-the-usefulness-of-tests/248">REJOIN sucked</a>.</strong></p>
<p>If naming were consistent, you might think from this pattern:</p>
<pre><code>append a reduce b &lt;=&gt; repend a b
</code></pre>
<p>...that the following would have been true:</p>
<pre><code>join a reduce b &lt;=&gt; rejoin a b  ; one would have perhaps thought?
</code></pre>
<p>But no...REJOIN was single arity (and was a mess).</p>
<h2><a name="p-7907-so-rejoin-is-in-the-trash-heap-but-what-about-join-1" class="anchor" href="https://forum.rebol.info#p-7907-so-rejoin-is-in-the-trash-heap-but-what-about-join-1"></a>So REJOIN is in the trash heap, but what about JOIN?</h2>
<p>JOIN implicitly reduced, and was basically this:</p>
<pre><code>join a b &lt;=&gt; append copy a reduce b
</code></pre>
<p>But <strong>b</strong> didn't have to be a BLOCK!, so if it was not, it wasn't reduced and just left as-is.</p>
<pre><code>rebol2&gt;&gt; join "abc" [1 + 2 3 + 4]
== "abc37"  ; so the block was reduced

rebol2&gt;&gt; d: 10
rebol2&gt;&gt; join "abc" 'd
== "abcd"  ; not abc10, so the word was *not* reduced
</code></pre>
<p>Red did not carry forward this definition:</p>
<pre><code>&gt;&gt; join
*** Script Error: join has no value
</code></pre>
<h2><a name="p-7907-next-level-join-allow-join-datatype-2" class="anchor" href="https://forum.rebol.info#p-7907-next-level-join-allow-join-datatype-2"></a>Next-Level JOIN: Allow JOIN  DATATYPE</h2>
<p>At some point, it occurred to me that if you could use JOIN with a datatype, it could step in to fill in the desires of REJOIN more clearly:</p>
<pre><code>&gt;&gt; join binary! [1 + 2 #{DECAFBAD} 2 + 3]
== #{03DECAFBAD05}
</code></pre>
<p>There really had been expressions of this like:</p>
<pre><code>rebol2&gt;&gt; rejoin [#{} 1 + 2 #{DECAFBAD} 2 + 3]
== #{03DECAFBAD05}
</code></pre>
<p>But see Brett's critique, if the surface-level badness isn't enough to convince you!</p>
<p>I also wanted to support things that Rebol2 probably meant to, but did not.  This should give a WORD! back:</p>
<pre><code>rebol2&gt;&gt; join 'a 'b
== "ab"  ; should be word! `ab`
</code></pre>
<p>Plus, I thought it might be nice to have a non-reducing variant, done with <code>@[...]</code></p>
<pre><code>&gt;&gt; join word! @[a 1 + 2]
== a1+2
</code></pre>
<p>I've mentioned elsewhere that I think having <em>join-like</em> actions be done with JOIN is superior to being some form of MAKE, when there's nebulousness for what MAKE means.</p>
<h2><a name="p-7907-making-peace-with-uneasiness-about-list-ambiguity-3" class="anchor" href="https://forum.rebol.info#p-7907-making-peace-with-uneasiness-about-list-ambiguity-3"></a>Making Peace (?) With Uneasiness About List Ambiguity</h2>
<p>Ergonomically, it's nice for JOIN to be able to take either a BLOCK! or some other type.</p>
<p>One of the biggest uses of JOIN is with files:</p>
<pre><code>join directory %foo.txt
</code></pre>
<p>It would be annoying if you had to write:</p>
<pre><code>join directory [%foo.txt]
</code></pre>
<p>But then, you have the problem that if you're joining onto a BLOCK!, then a BLOCK! is a legitimate thing to join:</p>
<pre><code>&gt;&gt; join [a b] [1 + 2 10 + 20]
== [a b 3 30]  ; "traditional" behavior

&gt;&gt; join [a b] [1 + 2]
== [a b [1 + 2 10 + 20]]  ; ...but this could be valid
</code></pre>
<p>We could "fix" this by defining JOIN as a non-reducing construct, then have people use SPREAD and REDUCE:</p>
<pre><code>&gt;&gt; join [a b] spread reduce [1 + 2 10 + 20]
== [a b 3 30]

&gt;&gt; join [a b] [1 + 2 10 + 20]
== [a b [1 + 2 10 + 20]]

&gt;&gt; join [a b] reduce [1 + 2 10 + 20]
== [a b [3 30]]
</code></pre>
<p>But this doesn't exactly square with the JOIN of a DATATYPE! case, and the most common desires.</p>
<p>If anything, I'd rather make JOIN always take a <strong><code>[...]</code></strong> or <strong><code>@[...]</code></strong> in the second argument, and then create some other non-reducing construct that slaps two things together.</p>
<pre><code>&gt;&gt; block: [a b]

&gt;&gt; adjoin block [c d]
== [a b [c d]]

&gt;&gt; adjoin block spread [e f]
== [a b [c d] e f]

&gt;&gt; block
== [a b]  ; unmodified (difference from append)
</code></pre>
<p>But asking people to write <strong><code>(adjoin directory %foo.txt)</code></strong> is... ugly.</p>
<p>A compromise is to narrow it, so that you could only use it with single items when joining with non-lists...</p>
<pre><code>&gt;&gt; join "abc" "def"
== "abcdef"

&gt;&gt; join [a b c] "def"
** Error: JOIN with a list must use [...] or @[...]
</code></pre>
<p>This would help steer you away from writing code like <strong><code>join list value</code></strong> and think it works, to only find it falling down when value becomes a BLOCK!.</p>
<h2><a name="p-7907-is-reduce-just-join-block-4" class="anchor" href="https://forum.rebol.info#p-7907-is-reduce-just-join-block-4"></a>Is REDUCE just JOIN BLOCK! ?</h2>
<p>The implementation of JOIN that I'm working on seems like a more powerful REDUCE.</p>
<p>But questions start to arise about the binding... what should the binding be?</p>
<pre><code>&gt;&gt; join [add 1] ['multiply 2 3]
== [add 1 multiply 2 3]
</code></pre>
<p>In that case, I'm going to assume the produced block would have the binding of the [add 1] block.  Since multiply is <strong><code>'multiply</code></strong> and not <strong><code>$multiply</code></strong> it would be unbound and hence an evaluation would be driven by that first argument's binding.</p>
<p>But what if you just said:</p>
<pre><code>&gt;&gt; join block! ['add 1 'multiply 2 3]
== [add 1 multiply 2 3]
</code></pre>
<p>Before, the second block's binding was disregarded in the product.  But when there's no first block to get the binding from, does it assume the binding of the second block?  And how would you get an unbound block if you wanted it?</p>
<p>We could say that you get an unbound block, but if you want a bound block, you'd say:</p>
<pre><code>&gt;&gt; join $[] ['add 1 'multiply 2 3]
== [add 1 multiply 2 3]
</code></pre>
<p>Then we have similar questions for things like word!:</p>
<pre><code>&gt;&gt; join word! ["a" "b"]
== ab
</code></pre>
<p>I feel that pretty obviously should be unbound.  But words follow different rules:</p>
<pre><code>&gt;&gt; join $a ["b"]
== ab  ; can't necessarily be bound, just because a was...
</code></pre>
<p>That would suggest all words come back unbound from a joining process.</p>
<p>So no shortage of questions.  But in general, I think JOIN is on the right track, and splitting MAKE behaviors that are JOIN-like to it seems good.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-semantics-of-join/2333">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-semantics-of-join/2333</link>
          <pubDate>Sat, 16 Nov 2024 18:33:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2333</guid>
          <source url="https://forum.rebol.info/t/the-semantics-of-join/2333.rss">The Semantics of JOIN</source>
        </item>
        <item>
          <title>Refinement Arguments at Head of Args List, Not Tail</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>In the corpus of code we have so far, it seems to me that when a refinement adds an argument to a function that it would be preferable if that argument would become the first parameter... not tacked onto the end.</p>
<p>Some cases might not be completely obvious one way or another:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c [d e]]

&gt;&gt; append:dup [a b c] [d e] 2  ; old way
== [a b c [d e] [d e]] 

&gt;&gt; append:dup 2 [a b c] [d e]  ; new idea
== [a b c [d e] [d e]]
</code></pre>
<p>I think it's better if it's first, but it's not earth-shattering.</p>
<p>But in other cases it seems very much an improvement.  Consider the positioning of the argument to FAIL:BLAME...</p>
<pre><code>foo: func [arg thing] [
    if arg &lt; 0 [
        fail:blame [
           "Here is some long error message:" @thing
           "Whatever..."
        ] $arg
    ]
]

foo: func [arg thing] [
    if arg &lt; 0 [
        fail:blame $arg [
           "Here is some long error message:" @thing
           "Whatever..."
        ]
    ]
]
</code></pre>
<p>Or an argument to COMPOSE giving a pattern to use:</p>
<pre><code>compose:pattern [
    some bunch of {{code that}} &lt;spans&gt;
    #multiple lines
    [and could go on for pages]
] ${{}}  ; afterthought...

compose:pattern ${{}} [  ; forethought
    some bunch of {{code that}} &lt;spans&gt;
    #multiple {{lines}}
    [and could go on for pages]
]
</code></pre>
<p>This goes along with some Haskell philosophy I cited in <a href="https://forum.rebol.info/t/parameter-order-in-rebol/1238">Parameter Order in Rebol</a>:</p>
<blockquote>
<p><em>"It's common practice in Haskell to order function parameters so that parameters which "configure" an operation come first, and the "main thing being operated on" comes last. This is often counter intuitive coming from other languages, since it tends to mean you end up passing the "least important" information first. It's especially jarring coming from OO where the "main" argument is usually the object on which the method is being invoked, occurring so early in in the call that it's out of the parameter list entirely!"</em></p>
</blockquote>
<p>These refinements typically seem to be <em>configuring</em>, as if they are changing the function itself, and belong at the head.</p>
<p>e.g. above, the function you're conceptually applying is <strong><code>(compose:pattern ${{}})</code></strong></p>
<h2><a name="p-7889-history-didnt-do-it-this-way-with-some-reasons-1" class="anchor" href="https://forum.rebol.info#p-7889-history-didnt-do-it-this-way-with-some-reasons-1"></a>History Didn't Do It This Way, With Some Reasons</h2>
<p>Refinements are typically listed at the end of the function spec.</p>
<p>From an implementation standpoint, that's also where their "slots" are in the argument list.</p>
<p>This means that as you are walking the argument list and fulfilling arguments from the callsite, if refinements were used you would have to skip over the "normal" arguments in a first pass, and then come back and fill them later.</p>
<p>Historical Redbols only had to be worried about the order of usage of refinements... if you used them out of order from the declaration, a second pass would be needed.  But using them in order would not require it.</p>
<p>This isn't a problem for Ren-C...it's designed for generic parameter reordering (refinements or otherwise) and it has an efficient way to beeline back to slots it skipped on a second pass.</p>
<p>So really the only issue is the mismatch between the visual order in the spec (which may be exposed mechanically by fixed orders of enumeration of FRAME! keys and values), compared with the gathering behavior.  But the disconnect of that order has always been there, with <strong>foo/refine1/refine2</strong> vs. <strong>foo/refine2/refine1</strong> in Redbol... the callsite order may not match the frame order.</p>
<h2><a name="p-7889-is-it-worth-changing-2" class="anchor" href="https://forum.rebol.info#p-7889-is-it-worth-changing-2"></a>Is It Worth Changing?</h2>
<p>The competing (complementary) idea of <a href="https://forum.rebol.info/t/dialecting-function-calls-new-weird-powerful/2310">CHAIN! dialecting</a> offers something that's likely even more compelling:</p>
<pre><code>compose:pattern ${{}} [  ; better than today...
    some bunch of {{code that}} &lt;spans&gt;
    #multiple {{lines}}
    [and could go on for pages]
]

compose:${{}} [  ; ...but this surpasses even that
    some bunch of {{code that}} &lt;spans&gt;
    #multiple {{lines}}
    [and could go on for pages]
]
</code></pre>
<p>Though it's kind of up in the air if and when that's going to get attacked, and how well it will work (it may run afoul of problems in binding, etc.)</p>
<p>My instincts tell me that it's worth changing.  In practice, refinements that take arguments are not super common... but when they do happen, being up front seems to make the most sense.</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331</link>
          <pubDate>Tue, 12 Nov 2024 14:16:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2331</guid>
          <source url="https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331.rss">Refinement Arguments at Head of Args List, Not Tail</source>
        </item>
        <item>
          <title>Antiform Safety: Covariance and Contravariance</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Testing</category>
          <description><![CDATA[
            <p>Grafting antiforms onto a C codebase that had no such concept is fraught with disasters.</p>
<p>The semantics of unstable antiforms is particularly risky.  If you have a test like <strong><code>Is_Block(cell)</code></strong> that tells you whether a cell holds a BLOCK!, then what if that cell holds an antiform block?  Usermode code has the benefit of decay-by-default (unless you take a meta-parameter).  So if you ask <strong><code>BLOCK?</code></strong> on a parameter pack, it will decay to its first item and answer based on that.  The C implementation has no such "automatic" behavior.</p>
<p>Even "worse", what if <strong><code>cell</code></strong> contains an antiform error, and you quietly say "no it's not a block" and proceed on, ignoring situations when that should have raised an abrupt failure?</p>
<h2><a name="p-7886-creating-a-type-hierarchy-atom-value-element-1" class="anchor" href="https://forum.rebol.info#p-7886-creating-a-type-hierarchy-atom-value-element-1"></a>Creating A Type Hierarchy: Atom -&gt; Value -&gt; Element</h2>
<p>I've given names to the three broad categories of cells:</p>
<ul>
<li>
<p><strong>ELEMENT</strong> - anything that you can put in a List.  So this is "element" as in "array element".  Hence, no antiforms.  (It's not a perfect name in terms of correspondence to "chemical element" in terms of the abstract form that can come in isotopes, so think of it as array element)</p>
</li>
<li>
<p><strong>VALUE</strong> - anything that you can put in a Variable.  So it extends ELEMENT with stable antiforms.</p>
</li>
<li>
<p><strong>ATOM</strong> - anything, including unstable antiforms.</p>
</li>
</ul>
<p>Systemically, we want to stop antiforms from being put into the array elements of blocks, groups, paths, and tuples.  We also want to prevent unstable antiforms from being the values of variables.</p>
<p>To make it easier to do this, the C++ build offers the ability to make <code>Element</code> that can't hold any antiforms, <code>Value</code> that can hold stable antiforms, and <code>Atom</code> that can hold anything--including unstable isotopes.</p>
<ul>
<li>
<p><strong>Class Hierarchy:</strong> Atom as base, Value derived, Element derived (upside-down for compile-time error preferences--we want passing an Atom to a routine that expects only Element to fail)</p>
</li>
<li>
<p><strong>Primary Goal:</strong> Prevent passing Atoms/Values to Element-only routines, or Atoms to Value-only routines.</p>
</li>
<li>
<p><strong>Secondary Goal:</strong> Prevent things like passing Element cells to writing routines that may potentially produce antiforms in that cell.</p>
</li>
<li>
<p><strong>Tertiary Goal:</strong> Detect things like superfluous <code>Is_Antiform()</code> calls being made on Elements.</p>
</li>
</ul>
<p>The primary goal is achieved by choosing Element as a most-derived type instead of a base type.</p>
<p>The next two goals are somewhat maddeningly trickier... <img src="https://forum.rebol.info/images/emoji/twitter/pouting_cat.png?v=12" title=":pouting_cat:" class="emoji" alt=":pouting_cat:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-7886-sink-and-need-2" class="anchor" href="https://forum.rebol.info#p-7886-sink-and-need-2"></a><code>Sink(...)</code> and <code>Need(...)</code></h2>
<p>The idea behind a Sink() is to be able to mark on a function's interface when a function argument passed by pointer is intended as an output.</p>
<p>This has benefits of documentation, and can also be given some teeth by scrambling the memory that the pointer points at (so long as it isn't an "in-out" parameter).  But it also applied in CHECK_CELL_SUBCLASSES, by enforcing "covariance" for input parameters, and "contravariance" for output parameters.</p>
<p>If USE_CELL_SUBCLASSES is enabled, then the inheritance heirarchy has Atom at the base, with Element at the top.  Since what Elements can contain is more constrained than what Atoms can contain, this means you can pass Atom* to Element*, but not vice-versa.</p>
<p>However, when you have a Sink(Element) parameter instead of an Element*, the checking needs to be reversed.  You are -writing- an Element, so the receiving caller can pass an Atom* and it will be okay.  But if you were writing an Atom, then passing an Element* would not be okay, as after the initialization the Element could hold invalid states.</p>
<p>We use "SFINAE" to selectively enable the upside-down hierarchy, based on the <code>std::is_base_of&lt;&gt;</code> type trait.</p>
<h2><a name="p-7886-the-code-in-the-c-debug-build-3" class="anchor" href="https://forum.rebol.info#p-7886-the-code-in-the-c-debug-build-3"></a>The Code (in the C++ Debug Build)</h2>
<pre><code>template&lt;typename T, bool sink&gt;
struct NeedWrapper {
    T* p;
    mutable bool corruption_pending;  // can't corrupt on construct

  //=//// TYPE ALIASES ////////////////////////////////////////////////=//

    using MT = typename std::remove_const&lt;T&gt;::type;

    template&lt;typename U&gt;  // contravariance
    using IsReverseInheritable = typename std::enable_if&lt;
        std::is_same&lt;U,T&gt;::value or std::is_base_of&lt;U,T&gt;::value
    &gt;::type;

  //=//// CONSTRUCTORS ////////////////////////////////////////////////=//

    NeedWrapper() = default;  // or MSVC warns making Option(Sink(Value))

    NeedWrapper(nullptr_t) {
        p = nullptr;
        corruption_pending = false;
    }

    NeedWrapper (const NeedWrapper&lt;T,sink&gt;&amp; other) {
        p = other.p;
        corruption_pending = p and (other.corruption_pending or sink);
        other.corruption_pending = false;
    }

    template&lt;typename U, IsReverseInheritable&lt;U&gt;* = nullptr&gt;
    NeedWrapper(U* u) {
        p = u_cast(T*, u);
        corruption_pending = p and sink;
    }

    template&lt;typename U, bool B, IsReverseInheritable&lt;U&gt;* = nullptr&gt;
    NeedWrapper(const NeedWrapper&lt;U, B&gt;&amp; other) {
        p = u_cast(T*, other.p);
        corruption_pending = p and (other.corruption_pending or sink);
        other.corruption_pending = false;
    }

  //=//// ASSIGNMENT //////////////////////////////////////////////////=//

    NeedWrapper&amp; operator=(nullptr_t) {
        p = nullptr;
        corruption_pending = false;
        return *this;
    }

    NeedWrapper&amp; operator=(const NeedWrapper&lt;T,sink&gt; other) {
        if (this != &amp;other) {  // self-assignment possible
            p = other.p;
            corruption_pending = p and (other.corruption_pending or sink);
            other.corruption_pending = false;
        }
        return *this;
    }

    template&lt;typename U, IsReverseInheritable&lt;U&gt;* = nullptr&gt;
    NeedWrapper&amp; operator=(const NeedWrapper&amp; other) {
        if (this != &amp;other) {  // self-assignment possible
            p = other.p;
            corruption_pending = p and (other.corruption_pending or sink);
            other.corruption_pending = false;
        }
        return *this;
    }

    template&lt;typename U, IsReverseInheritable&lt;U&gt;* = nullptr&gt;
    NeedWrapper&amp; operator=(U* other) {
        p = u_cast(T*, other);
        corruption_pending = p and sink;
        return *this;
    }

  //=//// OPERATORS ///////////////////////////////////////////////////=//

    operator bool () const { return p != nullptr; }

    operator T* () const {
        if (corruption_pending) {
            Corrupt_If_Debug(*const_cast&lt;MT*&gt;(p));
            corruption_pending = false;
        }
        return p;
    }

    T* operator-&gt;() const {
        if (corruption_pending) {
            Corrupt_If_Debug(*const_cast&lt;MT*&gt;(p));
            corruption_pending = false;
        }
        return p;
    }

  //=//// DESTRUCTOR //////////////////////////////////////////////////=//

    ~NeedWrapper() {
        if (corruption_pending)
            Corrupt_If_Debug(*const_cast&lt;MT*&gt;(p));
    }
};
</code></pre>
<p>So then the <code>Sink(...)</code> and non-corrupting version <code>Need(...)</code> for in/out parameters with contravariance checking are:</p>
<pre><code>#define Sink(T) \
    NeedWrapper&lt;T, true&gt;

#define Need(TP) \
    NeedWrapper&lt;typename std::remove_pointer&lt;TP&gt;::type, false&gt;
</code></pre>
<h2><a name="p-7886-notes-on-corrupting-4" class="anchor" href="https://forum.rebol.info#p-7886-notes-on-corrupting-4"></a>Notes on Corrupting</h2>
<p>The original implementation was simpler, by just doing the corruption at the moment of construction.</p>
<p>But this faced a problem:</p>
<pre><code>    bool some_function(Sink(char*) out, char* in) { ... }

    if (some_function(&amp;ptr, ptr)) { ...}
</code></pre>
<p>If you corrupt the data at the address the sink points to, you can actually be corrupting the value of a stack variable being passed as another argument before it's calculated as an argument.  So deferring the corruption after construction is necessary.  It's a bit tricky in terms of the handoffs and such.</p>
<p><em>(While this could be factored, function calls aren't inlined in the debug build, so given the simplicity of the code, it's repeated.)</em></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/antiform-safety-covariance-and-contravariance/2330">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/antiform-safety-covariance-and-contravariance/2330</link>
          <pubDate>Mon, 11 Nov 2024 09:49:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2330</guid>
          <source url="https://forum.rebol.info/t/antiform-safety-covariance-and-contravariance/2330.rss">Antiform Safety: Covariance and Contravariance</source>
        </item>
        <item>
          <title>Full-Band Return Values from Generators/Yielders</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>Definitional Errors came into PARSE as an answer for how to make it possible to return any value... simply make a failed parse a definitional error.  Not only does it mean that NULL can be a legitimate synthesized product that you don't conflate with failure, but it also means that parse failures can give back more information in the error about what went wrong <em>(farthest parse point reached, etc.)</em>...</p>
<p>Looking at another problem where a sentinel NULL had been used... there's <a href="https://forum.rebol.info/t/yielder-and-generator-and-thinking-about-coroutines/1311">Generators and Yielders</a>:</p>
<pre><code>&gt;&gt; g: generator [print "A" yield 1, print "B" yield 2, print "C"]

&gt;&gt; g
A
== 1

&gt;&gt; g
B
== 2

&gt;&gt; g
C
== ~null~  ; anti

&gt;&gt; g
== ~null~  ; anti

&gt;&gt; g
== ~null~  ; anti
</code></pre>
<p>But Generators and Yielders predate antiforms in general... they came at a time where there were just two forms of NULL: "heavy" and "light".  So the thought was that if you wanted to actually yield null, it would be the heavy form.</p>
<pre><code>&gt;&gt; g: generator ["Start", yield null, print "Done"]

&gt;&gt; g
Start
== ~[~null~]~  ; anti

&gt;&gt; g
Done
== ~null~  ; anti
</code></pre>
<p>But this isn't nearly as good as using a specific raised error.  If NULL is truly out of band, then you could use <strong><code>try g</code></strong> to get null when there are no more values.</p>
<p>If you try to YIELD or RETURN a raised error, then it would become an abrupt failure.  So you'd be assured that the only time you'd ever get a definitional error back from a generator or yielder would be if it had been exhausted.</p>
<h2><a name="p-7884-pack-returns-for-things-like-key-and-value-in-objects-1" class="anchor" href="https://forum.rebol.info#p-7884-pack-returns-for-things-like-key-and-value-in-objects-1"></a>PACK returns for things like KEY and VALUE in objects?</h2>
<p>As the enumeration routines are retooled to be based on generator functions, it struck me as very cool if generators returned packs, which could be decayed:</p>
<pre><code>&gt;&gt; obj: make object! [a: 10 b: 20 c: 30]

&gt;&gt; g: each obj

&gt;&gt; g
; first in pack of 2 items
== a

&gt;&gt; meta g
== ~['b '20]~

&gt;&gt; [key {val}]: g
== 30

&gt;&gt; key
== c

&gt;&gt; g
** Error: Generator/Yielder exhausted

&gt;&gt; try g
== ~null~  ; anti
</code></pre>
<p>That's really cool, and seems like it would go along with decaying:</p>
<pre><code>for 'key each obj [...]

for [key val] each obj [...]
</code></pre>
<p>This looks pretty nice, however blocks used in FOR-EACH scenarios like this haven't meant "unpack", it has meant keep getting items and assign them to each.</p>
<p>It seems like it would be unfortunate if you had to write the object unpacking as:</p>
<pre><code>for [~[key val]~] each obj [...]
</code></pre>
<p>But that does seem sort of like what you'd have to do in order to make it generalized.  It doesn't look <em>that</em> bad, and it does have a theory behind it...</p>
<pre><code>&gt;&gt; obj: make object! [a: 10 b: 20 c: 30]

&gt;&gt; for [~[key val]~ :otherkey] each obj [  ; leading colon for optionality
       print ["key:" key]
       print ["val:" val]
       if otherkey [
           print ["otherkey:" otherkey]
       ]
   ]

key: a
val: 10
otherkey: b
key: c
val: 30
</code></pre>
<p>This assumes that plain blocks might be taken for some other intent in the FOR.  If it were not:</p>
<pre><code>for [[key val] :otherkey] each obj [...]
</code></pre>
<p>But I had been thinking that plain BLOCK! would likely be good for type checking (<span class="mention">@hiiamboris</span> has some experiments in this vein):</p>
<pre><code>for [x [integer!] y [tag!]] each [1 &lt;a&gt; 2 &lt;b&gt;] [....]
</code></pre>
<h2><a name="p-7884-big-design-space-but-full-band-returns-opens-it-up-2" class="anchor" href="https://forum.rebol.info#p-7884-big-design-space-but-full-band-returns-opens-it-up-2"></a>Big Design Space, but Full-Band Returns Opens It Up</h2>
<p>I'd let the Generator and Yielder experiments atrophy while working on other things.  But I stopped today to try and get the basics working again, and it's interesting to see how isotopes bring a lot to the table...as they seem to have done with nearly everything.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/full-band-return-values-from-generators-yielders/2329">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/full-band-return-values-from-generators-yielders/2329</link>
          <pubDate>Sun, 10 Nov 2024 19:25:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2329</guid>
          <source url="https://forum.rebol.info/t/full-band-return-values-from-generators-yielders/2329.rss">Full-Band Return Values from Generators/Yielders</source>
        </item>
        <item>
          <title>TAG!s Angle Brackets: *They Aren&#39;t There!*</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Implementation-wise, the delimiters of tag have been quite the thorn.</p>
<p>Are they there or not?</p>
<p>In Rebol2, Red, R3-Alpha...</p>
<pre><code>&gt;&gt; find &lt;abcd&gt; "c"
== &lt;cd&gt;

&gt;&gt; find &lt;abcd&gt; "&gt;"
== none
</code></pre>
<p>Not there!</p>
<p>Or are they?  Reverse the arguments, and in Rebol2 and Red, they seem to magically appear:</p>
<pre><code>&gt;&gt; find "ab&lt;c&gt;d" &lt;c&gt;
== "&lt;c&gt;d"
</code></pre>
<p>But... this was not the case in R3-Alpha...</p>
<pre><code>r3-alpha&gt;&gt; find "abcd" &lt;c&gt;
== "cd"

r3-alpha&gt;&gt; find "ab&lt;c&gt;d" &lt;c&gt;
== "c&gt;d"
</code></pre>
<p>I know things have gone back and forth with people believing deeply in their little hearts that they are happier when routines act like the delimiters are there...</p>
<p>But for the baseline behavior: <em>I have come to believe R3-Alpha is right.</em>  They're string delimiters, and incidental to the default purpose, just as quotes are.</p>
<p>If you start looking at TAG! as it truly is--just another string class with different delimiters--it simplifies the mental model and the implementation model.  You can truly just use it like another string, and it suddenly becomes consistent.</p>
<p>Of course, it's still nice to be able to match the molded form of a tag.</p>
<p>But... why stop at tags? <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"> Why not have a syntax to match the molded form of anything?</p>
<p>In strings, where you can't match list elements literally anyway:</p>
<pre><code>&gt;&gt; parse "&lt;a&gt; 100 (b c)" ['&lt;a&gt; space '100 space '(b c)]
== (b c)
</code></pre>
<p>(The synthesized product may be more interesting, too.  As a reminder, Ren-C has taken words that might be better as variable names like END and uses plain tag as  instead, or  to synthesize the parse input, etc.)</p>
<pre><code>&gt;&gt; parse "&lt;end&gt; asdf" ['&lt;end&gt; to &lt;end&gt; &lt;input&gt;]
== "&lt;end&gt; asdf"
</code></pre>
<p>I don't know whether that is best done as just a PARSE feature, or if quoted things need to be searched for literally by FIND.</p>
<pre><code>&gt;&gt; find "ab&lt;c&gt;d" &lt;c&gt;
== "c&gt;d"

&gt;&gt; quote &lt;c&gt;
== '&lt;c&gt;

&gt;&gt; find "ab&lt;c&gt;d" quote &lt;c&gt;
== "&lt;c&gt;d"

&gt;&gt; find "ab&lt;c&gt;d" mold &lt;c&gt;  ; one fewer character
== "&lt;c&gt;d"
</code></pre>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/tag-s-angle-brackets-they-arent-there/2326">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/tag-s-angle-brackets-they-arent-there/2326</link>
          <pubDate>Fri, 08 Nov 2024 18:12:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2326</guid>
          <source url="https://forum.rebol.info/t/tag-s-angle-brackets-they-arent-there/2326.rss">TAG!s Angle Brackets: *They Aren&#39;t There!*</source>
        </item>
        <item>
          <title>Embracing A &quot;Useless&quot; Definition of TO</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Many years ago, I thought about <strong><a href="https://forum.rebol.info/t/hacking-away-on-the-to-and-make-matrix/649">trying to untangle of the TO and MAKE matrix</a></strong>.  These operations are notoriously unpredictable in historical Redbol.</p>
<p>I tried putting some stakes in the ground about what I believed <em>had</em> to be true.  It was difficult because I could not think of too many.</p>
<p>One thing I said was that TO should always create a "new" value (if the value was not immediate).  And I felt like this should be true:</p>
<pre><code>to (type of value) value
; ...same as...
copy value
</code></pre>
<p>Grasping for any stake in the ground I could find, I was pretty sure that TO of a string representation of an integer to an integer should give you the integer:</p>
<pre><code>&gt;&gt; to integer! "1020"
== 1020  ; we know this, at least? (one hopes...)
</code></pre>
<p>And the reverse, one would think, as well:</p>
<pre><code>&gt;&gt; to text! 1020
== "1020"  ; what else *could* it be?  codepoint 1020? -&gt; "Ï¼"
</code></pre>
<p>But beyond that it was hard to think of the pattern.</p>
<h2><a name="p-7876-coming-back-to-an-old-idea-reversibility-1" class="anchor" href="https://forum.rebol.info#p-7876-coming-back-to-an-old-idea-reversibility-1"></a>Coming Back To An Old Idea: Reversibility</h2>
<p>When I first encountered Rebol and was made aware of these problems, I suggested TO should be reversible:</p>
<pre><code>value1 = to (type of value1) to type2 value1
</code></pre>
<p>However, this gave what <em>appeared</em> to be very "unexciting" options for behavior:</p>
<pre><code>&gt;&gt; to block! 1
== [1]

&gt;&gt; to integer! [1]
== 1

&gt;&gt; to integer! [...anything else in a block that's not integer...]
** Error.  Always.
</code></pre>
<p>That particular idea was was so long ago that I don't have direct quotes on hand of people saying "nah, that sucks, TO could barely do anything."  But I'm pretty sure it was panned by basically everyone I suggested it to.  I guess I agreed, because I dropped it.</p>
<p><strong>Coming back to it now, and seeing it in a new light, I see this as much more useful than I used to.</strong>  Especially when compared to the historical mess that makes TO nigh-unusable.</p>
<p>And in fact, it fits in with several Rebol2/Red behaviors that I'd thought were kind of pointless before:</p>
<pre><code>&gt;&gt; to integer! &lt;1&gt;
== 1

&gt;&gt; to tag! 1
== &lt;1&gt;
</code></pre>
<p>The use I didn't see at the time was the frequent need when dialecting to push values out of band, into some other type, without losing their meaning.  If you have a dialect in which integers already mean something, but you want a way of pushing some integer-oriented instruction in there...you can use these kinds of operations.</p>
<p>Definitional errors in Ren-C make this convenient, since checking if something fits the pattern is quick, you just throw in a TRY and the antiform error that's the return result of the TO will be suppressed, giving you a "falsey" null:</p>
<pre><code>&gt;&gt; thing: &lt;a b&gt;

&gt;&gt; to integer! thing
** Error: Cannot TO convert &lt;a b&gt; to integer

&gt;&gt; try to integer! thing
== ~null~  ; anti
</code></pre>
<p>The more I look at it the more useful it appears.  And it helps give clarity to the MAKE vs. TO division.  If you have something that isn't shaped like this, then <em>maybe</em> MAKE is the right place to put it.  For example:</p>
<pre><code>&gt;&gt; to percent! 1
== 1%

&gt;&gt; to integer! 1%
== 1

&gt;&gt; make percent! 1
== 100%
</code></pre>
<p><em>(Note: I think ENCODE + DECODE is a better place for binary conversions, e.g. ENCODE 'IEEE-754 is better than MAKE BINARY! of a decimal because that could mean many things, and ENCODE can have more parameterization for single vs. double precision, etc.  I don't know<br>
if TO BINARY! should work at all, but if it does, I'd probably agree with the Rebol2 choice to give the binary representation of the UTF-8 string... e.g. (to binary! 1020) as #{31303230} ... and use more explicit future-proof routines to encode with specified byte size and endianness.)</em></p>
<h2><a name="p-7876-reversibility-rules-out-rounding-2" class="anchor" href="https://forum.rebol.info#p-7876-reversibility-rules-out-rounding-2"></a>Reversibility Rules Out Rounding</h2>
<p>In order to get losslessness in the representation, you can't throw out information.</p>
<p>So this works:</p>
<pre><code>&gt;&gt; to integer! 1.0
== 1

&gt;&gt; to decimal! 1
== 1.0
</code></pre>
<p>But this does not:</p>
<pre><code> &gt;&gt; to integer! 1.5
 ** Error: Can't TO INTEGER! a DECIMAL! w/digits after decimal point
</code></pre>
<p>I don't think that's a problem, because that seems like a job for ROUND.  Unfortunately, R3-Alpha and Red do something dumb:</p>
<pre><code>rebol2&gt;&gt; round 1.5
== 2

red&gt;&gt; round 1.5
== 2.0

r3-alpha&gt;&gt; round 1.5
== 2.0
</code></pre>
<p>It seems this was part of a shift to try and preserve the input type, to facilitate things like rounding MONEY!:</p>
<pre><code>r3-alpha&gt;&gt; round $1.50
== $2
</code></pre>
<p>So I guess the way the thinking went was that if you want to keep MONEY! as MONEY! when you round it, all types should act that way.</p>
<p>I think the relationship between INTEGER! and DECIMAL!, which lack decoration, suggests something more intimate where the type can be lost.  If you don't want to lose it, ROUND:TO 1.0</p>
<pre><code>&gt;&gt; round 1.5
== 2

&gt;&gt; round:to 1.5 1
== 2

&gt;&gt; round:to 1.5 1.0
== 2.0
</code></pre>
<h2><a name="p-7876-blank-pretty-much-has-to-mean-empty-3" class="anchor" href="https://forum.rebol.info#p-7876-blank-pretty-much-has-to-mean-empty-3"></a>BLANK! Pretty Much Has To Mean Empty</h2>
<p>If we're talking about equivalencies, we now know this:</p>
<pre><code>&gt;&gt; for-each 'x _ [print "Doesn't run"]
== ~void~  ; anti

&gt;&gt; empty? _
== ~okay~  ; anti
</code></pre>
<p>And so really, it seems that the TO conversion of BLANK! has only one set of answers to fit into the family of reversibility:</p>
<pre><code>&gt;&gt; to block! _
== []

&gt;&gt; to text! _
== ""

&gt;&gt; to blank! &lt;&gt;
== _

&gt;&gt; to blank! #{}
== _
</code></pre>
<p>And if you try to TO BLANK! anything that's not conceptually empty, you'd get an error.</p>
<pre><code>&gt;&gt; to blank! &lt;a&gt;
** Error: ...
</code></pre>
<p>I don't know if there's a motivating case for saying <strong>to integer! _</strong> should pick something like 0 as an answer, though Rebol2 did something of that sort:</p>
<pre><code>rebol2&gt;&gt; to integer! none
== 0
</code></pre>
<p>Neither Red nor R3-Alpha carried that forward, <a href="https://github.com/metaeducation/rebol-issues/issues/1018">though it was discussed</a></p>
<h2><a name="p-7876-can-be-checked-in-the-implementation-4" class="anchor" href="https://forum.rebol.info#p-7876-can-be-checked-in-the-implementation-4"></a>Can Be Checked In The Implementation</h2>
<p>I've started hacking this through, and it's gone relatively well.  TO dispatches <em><strong>to the type it's converting from</strong></em>, with the type being converted to as the argument.</p>
<p>And it's nice in the sense that the TO native driving the process can also check the reversibility constraint in the debug build, to give it some teeth.</p>
<p><em>(I've rigged up some interesting frame mechanics to enable doing this reversal efficiently, that have sped up other parts of the system (like CASCADE) with "downlevel shifting", that can bypass a trampoline bounce...)</em></p>
<p>Anyway, things are a mess right now with a couple hundred broken tests to painfully sift through.  But I think the reversibility rule is good... biggest questions are whether that relaxes in terms of spacing...</p>
<pre><code>&gt;&gt; to block! "  1    2  "
== [1 2]  ; legal?
</code></pre>
<p>This would suggest you would have to compare with the trimmed/canonized version of your input.</p>
<p>Also, issues of string representations.</p>
<pre><code>&gt;&gt; b: to block! "--{1}--"
== ["1"]  ; legal?
</code></pre>
<p>So there are some pain points, but chipping away at them.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/embracing-a-useless-definition-of-to/2325">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/embracing-a-useless-definition-of-to/2325</link>
          <pubDate>Fri, 08 Nov 2024 17:57:07 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2325</guid>
          <source url="https://forum.rebol.info/t/embracing-a-useless-definition-of-to/2325.rss">Embracing A &quot;Useless&quot; Definition of TO</source>
        </item>
        <item>
          <title>Old Idea Revisited: DATATYPE as... Antiform?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>I've been suffering through an attempt to bring sanity to bear upon the MAKE and TO matrix.</p>
<p>While doing so, I noticed that there are a lot of MAKE instructions that do "joining".</p>
<p>In R3-Alpha and Red:</p>
<pre><code>&gt;&gt; make binary! [1 2 #{DECAFBAD} 3 4]   
== #{0102DECAFBAD0304}
</code></pre>
<p>Historical MAKE is so arbitrary in how it interprets its arguments that it made me feel that it would be better if JOIN allowed a datatype as its first argument...</p>
<p>JOIN typically makes a new series out of what you give it:</p>
<pre><code>&gt;&gt; bin: #{AABB}

&gt;&gt; join bin #{CCDD}
== #{AABBCCDD}  ; made new series, didn't impact BIN

&gt;&gt; bin
== #{AABB}
</code></pre>
<p>But if you could pass a datatype as the first argument, you could relieve MAKE of the behavior...and make it clearer in the source what's actually happening:</p>
<pre><code>&gt;&gt; join binary! [1 2 #{DECAFBAD} 3 4]
== #{0102DECAFBAD0304}
</code></pre>
<p>Since that seemed nice, I started to map it out, and ran into a bit of a problem:</p>
<p><strong>If "datatypes" are an ANY-WORD! or ANY-LIST! or anything like that, how do you know you're not trying to JOIN with it?</strong></p>
<p>A WORD! should be able to join:</p>
<pre><code>&gt;&gt; join 'var 10
== var10
</code></pre>
<p>A BLOCK! should be able to join...</p>
<pre><code>&gt;&gt; join [a b] 10
== [a b 10]
</code></pre>
<p>Okay, but when you say <strong>join binary!</strong> what is BINARY!?  Well right now, it's:</p>
<pre><code>&gt;&gt; binary!
== &amp;[binary]
</code></pre>
<p>Well that looks like it's in-band for the kinds of things JOIN operates on:</p>
<pre><code>&gt;&gt; join &amp;[binary] 10
== &amp;[binary 10]
</code></pre>
<h2><a name="p-7875-an-antiform-would-push-datatype-out-of-band-1" class="anchor" href="https://forum.rebol.info#p-7875-an-antiform-would-push-datatype-out-of-band-1"></a>An Antiform Would Push DATATYPE? Out-Of-Band...</h2>
<p>It's possible that we could come up with a new non-antiform for types.  But the lexical space is extremely saturated.</p>
<p>If we were just reaching for something on the basis of looks, antiform FENCE! is nice:</p>
<pre><code>&gt;&gt; binary!
== ~{binary}~  ; anti
</code></pre>
<h2><a name="p-7875-this-has-come-up-before-2" class="anchor" href="https://forum.rebol.info#p-7875-this-has-come-up-before-2"></a>This Has Come Up Before...</h2>
<p>Historical Rebol let you use datatypes in FIND:</p>
<pre><code>rebol2&gt;&gt; find [a b c 10 20] integer! 
== [10 20]
</code></pre>
<p>But then this conflates with when you actually literally have the INTEGER! datatype in the block.</p>
<pre><code>&gt;&gt; find compose [a (integer!) b c 10 20] integer!
== [integer! b c 10 20]
</code></pre>
<p>So in the early days of antiforms, I proposed antiform datatypes as a solution... but at that time I was thinking that there'd be non-antiform DATATYPE!, and it's just that when it was an antiform it would be a "MATCHER".</p>
<p>The proposal I'm thinking of now is different, in saying that DATATYPE? only exists as a (stable) antiform state.</p>
<p>There are tradeoffs, in that datatypes can't be put in blocks directly.  But the mechanics of working with quasiforms and antiforms via things like REIFY and DEGRADE are much smoother now.  And really, putting datatypes in blocks doesn't happen that often (I've had to put splices in blocks but really never datatypes).</p>
<p>Being completely out of band with things you can find in a block has advantages.  JOIN isn't unique in reaping benefits from being able to say that datatypes aren't things.</p>
<p>And it unifies datatypes with typecheckers being antiforms, because typecheckers are frame antiforms, e.g. actions:</p>
<pre><code>&gt;&gt; find [1 3 5 8 10] even?/
; first in pack of length 2
== [8 10]
</code></pre>
<p>So I don't think it's a crazy idea.</p>
<p>I'm hesitant to surrender FENCE! antiforms to the purpose so soon after their invention.  But there isn't anything undecorated left.</p>
<p>Not that "no decorated antiforms" is some unbreakable rule, it was a guideline.</p>
<p>Using &amp; would put it in the family of TYPE-XXX! and be cheaper than FENCE! if you made new instances:</p>
<pre><code>&gt;&gt; binary!
== ~&amp;binary~  ; anti
</code></pre>
<p>A random bad idea would be to make them keywords, and just have DATATYPE? be smart enough to filter out ~null~ or ~void~ or ~okay~ or whatever else (the symbol could carry a flag)</p>
<pre><code>&gt;&gt; binary!
== ~binary~  ; anti

&gt;&gt; null
== ~null~  ; anti

&gt;&gt; datatype? binary!
== ~okay~  ; anti

&gt;&gt; datatype? null
== ~null~  ; anti
</code></pre>
<p>I can pretty clearly say that's bad.</p>
<h2><a name="p-7875-or-pick-some-non-antiform-notation-3" class="anchor" href="https://forum.rebol.info#p-7875-or-pick-some-non-antiform-notation-3"></a>Or, Pick Some Non-Antiform Notation</h2>
<p>Status quo might look like:</p>
<pre><code>&gt;&gt; binary!
== #[binary]
</code></pre>
<p>Despite it looking sort of like a block, it wouldn't be.  But we're squandering some of our notational space no matter what.  The <strong><code>~&amp;type~</code></strong> is the discount route.</p>
<h2><a name="p-7875-either-way-datatype-cant-be-any-word-or-any-list-4" class="anchor" href="https://forum.rebol.info#p-7875-either-way-datatype-cant-be-any-word-or-any-list-4"></a>Either Way, DATATYPE? Can't be ANY-WORD! or ANY-LIST!</h2>
<p>It needs to be out of band one way or another.  I'll have to think about it.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/old-idea-revisited-datatype-as-antiform/2324">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/old-idea-revisited-datatype-as-antiform/2324</link>
          <pubDate>Fri, 08 Nov 2024 17:05:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2324</guid>
          <source url="https://forum.rebol.info/t/old-idea-revisited-datatype-as-antiform/2324.rss">Old Idea Revisited: DATATYPE as... Antiform?</source>
        </item>
        <item>
          <title>ENHEX and DEHEX testing, another &quot;Micro-Dialect&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Testing</category>
          <description><![CDATA[
            <p>Here's a little excerpt of testing <strong><a href="https://en.wikipedia.org/wiki/Percent-encoding">Percent Encoding</a></strong> <em>(which Rebol gives the poor names ENHEX and DEHEX to, and should probably be changed)</em>.</p>
<p>It started out just as a table of encoded and decoded forms, e.g.</p>
<pre><code>for-each [encoded decoded] [
    "a%20b" "a b"
    "a%25b" "a%b"
    "a%ce%b2c" "aÎ²c"
    ...
][
   ; test that it decodes
]
</code></pre>
<p>But the encoding produces uppercase hex digits (per <a href="https://datatracker.ietf.org/doc/html/rfc3986">RFC 3896</a>), while the decoding tolerates lowercase ones.  So you don't get the same thing back.</p>
<p>That led me to the "whimsical" choice to denote reversible <strong><code>&lt;-&gt;</code></strong> and non-reversible <strong><code>-&gt;</code></strong> transforms:</p>
<pre><code>"a%25b" &lt;-&gt; "a%b"
"a%ce%b2c" -&gt; "aÎ²c" -&gt; "a%CE%B2c"
</code></pre>
<p>This is strange in that <strong><code>-&gt;</code></strong> is a WORD!, while <strong><code>&lt;-&gt;</code></strong> is a TAG! (and I believe this is the correct design choice when all is said and done).</p>
<p>But in a dialect, having something <em>look like what you want</em> can be enough, as it's just being looked for literally.</p>
<p>I threw in an additional wrinkle by letting BLOCK! with an INTEGER! in it serve as a comment.  It looks visually better than having to throw in a semicolon.</p>
<p>It's satisfying when such things can be done in a matter of a few minutes:</p>
<pre><code>; 1. Accept lowercase, but canonize to uppercase, per RFC 3896 2.1
;
; 2. A case can be made for considering the encoding of characters that
;    don't need it to be an error by default.
;
parse compose [
    "a%20b" &lt;-&gt; "a b"
    "a%25b" &lt;-&gt; "a%b"
    "a%ce%b2c" -&gt; "aÎ²c" -&gt; "a%CE%B2c"  [1]
    "%2b%2b" -&gt; "++" -&gt; "++"  [2]
    "a%2Bb" -&gt; "a+b" -&gt; "a+b"  [2]
    "a%62c" -&gt; "abc" -&gt; "abc"  [2]
    "a%CE%B2c" &lt;-&gt; "aÎ²c"
    (as text! #{2F666F726D3F763D254335253939}) -&gt; "/form?v=Å"
][ some [
    let encoded: text!
    let arrow: ['&lt;-&gt; | '-&gt;]
    let decoded: text!
    let re-encoded: [when (arrow = '-&gt;) ['-&gt; text!] | (encoded)]
    optional block!  ; headnote comment
    (
        let de: dehex encoded
        if de != decoded [
            fail ["Decode of" @encoded "gave" @de "expected" @decoded]
        ]
        let en: enhex decoded
        if en != re-encoded [
            fail ["Encode of" @decoded "gave" @en "expected" @re-encoded]
        ]
    )
]]
</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/enhex-and-dehex-testing-another-micro-dialect/2323">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/enhex-and-dehex-testing-another-micro-dialect/2323</link>
          <pubDate>Fri, 08 Nov 2024 16:10:52 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2323</guid>
          <source url="https://forum.rebol.info/t/enhex-and-dehex-testing-another-micro-dialect/2323.rss">ENHEX and DEHEX testing, another &quot;Micro-Dialect&quot;</source>
        </item>
        <item>
          <title>Much Ado About A Tiny Email Test &quot;Micro-Dialect&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Testing</category>
          <description><![CDATA[
            <p>So there was a "micro dialect" for email address scanning.  A simple idea that you could intermix valid and invalid email addresses...to put groups of related emails together even though some in the group would fail and others would succeed.</p>
<p>It was something along these lines:</p>
<pre><code>for-each [mode text] [
    + {email@example.com}
    + {firstname.lastname@example.com}
    - {email@example@example.com}
    + {email@subdomain.example.com}
    + {firstname+lastname@example.com}
    - {email@example.com}
    + {email@123.123.123.123}
    - {email@[123.123.123.123]}
    ...
 ][
    assert [mode: select [+ valid - invalid] mode]
    if (mode = 'valid) != test-scan-email (...) [
        fail ["Expected" @text "to be" an mode "email"]
    ]
 ]
</code></pre>
<p>But for this post, I threw in a couple of "hey that's neat" aspects, like:</p>
<pre><code>&gt;&gt; an "valid"
== "a valid"

&gt;&gt; an "invalid"
== "an invalid"
</code></pre>
<h2><a name="p-7845-enter-dashed-strings-1" class="anchor" href="https://forum.rebol.info#p-7845-enter-dashed-strings-1"></a>Enter Dashed Strings</h2>
<p>I don't know that the <strong><code>+</code></strong> and <strong><code>-</code></strong> markers were ever the greatest, but they certainly lost their appeal with dashed strings.</p>
<pre><code>    + -{email@example.com}-
    + -{firstname.lastname@example.com}-
    - -{email@example@example.com}-
    + -{email@subdomain.example.com}-
</code></pre>
<p>At first I figured I'd just pick an alternative.  There's Y and N...</p>
<pre><code>    Y -{email@example.com}-
    Y -{firstname.lastname@example.com}-
    N -{email@example@example.com}-
    Y -{email@subdomain.example.com}-
</code></pre>
<p>Those are pretty big letterforms that blur together some.  Tilde for trash to differentiate carries the connotation of "something wrong"...</p>
<pre><code>    Y -{email@example.com}-
    Y -{firstname.lastname@example.com}-
    ~ -{email@example@example.com}-
    Y -{email@subdomain.example.com}-
</code></pre>
<p>...but it blurs here too much with the dash.</p>
<p><strong>Really we can ask: why are we decorating the valid things, and not just the invalid things?</strong></p>
<pre><code>      -{email@example.com}-
      -{firstname.lastname@example.com}-
    # -{email@example@example.com}-
      -{email@subdomain.example.com}-
</code></pre>
<p>You could use <strong><code>N</code></strong> or <strong><code>*</code></strong> or <strong><code>#</code></strong> or any other nasty here, and it sort of stands out.  Not as well as <strong><code>&lt;bad&gt;</code></strong> would.</p>
<pre><code>      -{email@example.com}-
      -{firstname.lastname@example.com}-
&lt;bad&gt; -{email@example@example.com}-
      -{email@subdomain.example.com}-
</code></pre>
<p><strong>But if you're going to break the regularity of the structure, you can't use (today's) FOR-EACH.</strong></p>
<p>If you want to regularize it a bit, you could use something like BLOCK! to mark the bad ones:</p>
<pre><code>      -{email@example.com}-
      -{firstname.lastname@example.com}-
     [-{email@example@example.com}-]
      -{email@subdomain.example.com}-
</code></pre>
<p>If that didn't stand out enough, you could use a double-block:</p>
<pre><code>      -{email@example.com}-
      -{firstname.lastname@example.com}-
    [[-{email@example@example.com}-]]
      -{email@subdomain.example.com}-
</code></pre>
<p>It's worth remembering such things are options in some cases, but I don't think that works very well here.</p>
<h2><a name="p-7845-bad-seems-good-but-could-it-be-easier-2" class="anchor" href="https://forum.rebol.info#p-7845-bad-seems-good-but-could-it-be-easier-2"></a><code>&lt;bad&gt;</code> Seems Good, But Could It Be Easier?</h2>
<p>It would be nice if there were some way to type the FOR-EACH variables, and denote their optionality.</p>
<p><span class="mention">@hiiamboris</span> has done some things in this vein, see his <a href="https://codeberg.org/hiiamboris/red-common/src/branch/master/foreach-design.md">type filter on FOR-EACH proposal</a>.  I feel like the concept of skipping and checking should be separate intents.  I can want to type check something but not want to skip it.</p>
<p>A leading colon could imply optionality, as it does with refinements now:</p>
<pre><code>for-each [:bad [tag!] text [text!]] [
        -{email@example.com}-
        -{firstname.lastname@example.com}-
  &lt;bad&gt; -{email@example@example.com}-
        -{email@subdomain.example.com}-
        ...
][
    ...
]
</code></pre>
<p>You can even use <code>&lt;bad&gt;</code> itself for the type check by quoting it, and enforce/document that more stringently.  Also, for the sake of "how does that look in the generator model" I'll write it out that way:</p>
<pre><code>for [:bad ['&lt;bad&gt;] text [text!]] each [
        -{email@example.com}-
        -{firstname.lastname@example.com}-
  &lt;bad&gt; -{email@example@example.com}-
        -{email@subdomain.example.com}-
        ...
][
    ...
]
</code></pre>
<p>Of course you can split this out to a table vs. having the tests inline like that.</p>
<p>Interpreting blocks as type checks seems pretty useful, but that takes away from some other applications which might be used for destructuring.</p>
<p>Anyway, this is just some thinking inspired by a very small example.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/much-ado-about-a-tiny-email-test-micro-dialect/2315">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/much-ado-about-a-tiny-email-test-micro-dialect/2315</link>
          <pubDate>Fri, 11 Oct 2024 21:29:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2315</guid>
          <source url="https://forum.rebol.info/t/much-ado-about-a-tiny-email-test-micro-dialect/2315.rss">Much Ado About A Tiny Email Test &quot;Micro-Dialect&quot;</source>
        </item>
        <item>
          <title>Should Strings Nest Levels To Avoid Escaping?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>There's a historically convenient feature in strings:</p>
<pre><code>str: {This was {a historically legal} string.}
</code></pre>
<p>Each time you used an open brace inside a string, it would increment a "nesting count".  And when you used a close brace it would drop the nesting count.  When you got to zero, your string was finished.</p>
<p>It works in a lot of cases, but not if you have unpaired braces in your content:</p>
<pre><code>c-code: { if char = '}' { printf("This won't work.\n"); } }
</code></pre>
<p>We're going to be getting some instant improvement here with the new string format, using dashes.  Since at least one dash is required (otherwise you'd get a fence), cases like the above will "just work":</p>
<pre><code>c-code: -{ if char = '}' { printf("This will work!\n"); } }-
</code></pre>
<p>But should we still support the nesting idea?</p>
<pre><code>str: -{Should this -{still be a legal}- string?}-
</code></pre>
<p>The alternative would be to force you to use more dashes:</p>
<pre><code>str: --{This -{is definitely a legal}- string.}--
</code></pre>
<p>As we can see from the above, that move from one dash to two dashes does lengthen things.  The tightness is appealing to have as an option.</p>
<h2><a name="p-7836-but-its-complicated-1" class="anchor" href="https://forum.rebol.info#p-7836-but-its-complicated-1"></a>But It's Complicated...</h2>
<p>Let's put aside equal counts for a moment.  What happens if you nest <em>higher</em> counts (which contain lower counts, by definition)</p>
<pre><code>str: -{What ---{do you think this}--- should do?}-  ; [1]
</code></pre>
<p>If it were rotely searching for <strong><code>}-</code></strong> then it would find it at <strong><code>this}-</code></strong> and consider that the end.</p>
<pre><code>str: -{To look at ---{another one, consider}- this...}-  ; [2]
</code></pre>
<p><strong>Do we want the rule that if you ever enclose code with the dashed brace style like <strong><code>--{</code></strong> and <strong><code>}--</code></strong> the enclosure will always need more dashes than what it encloses?</strong></p>
<p>When I put it that way, I think that we don't want to force that escalation.  You can always go there if you need to (case 2 above requires it, or using quotes on the outside instead).  But I think being able to dodge it in cases where things are paired (as in case 1) is worth the dodge.</p>
<p><em>(Note that if you are trying to analyze the inside of the string for matched pairs that are other than the ones you asked for from the outside delimiter, then suddenly you're maintaining a stack of quote levels where nest level has an independent associated number of dashes, instead of just maintaining a total nesting count.  Not that this is a difficult problem, but it's just "another thing".)</em></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-strings-nest-levels-to-avoid-escaping/2311">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-strings-nest-levels-to-avoid-escaping/2311</link>
          <pubDate>Thu, 10 Oct 2024 06:44:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2311</guid>
          <source url="https://forum.rebol.info/t/should-strings-nest-levels-to-avoid-escaping/2311.rss">Should Strings Nest Levels To Avoid Escaping?</source>
        </item>
        <item>
          <title>Should sequences permit non-head SIGILs?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Historically I was very much opposed to SET-WORD! and GET-WORD! being in paths, because the ergonomics were bad:</p>
<pre><code>red&gt;&gt; p: to path! reduce [first [:a] first [b:]]
== :a/b:

&gt;&gt; type? p
== path!
</code></pre>
<p>You have something that's neither a SET-PATH! nor a GET-PATH! but it has colons at the beginning and the end.  It's all kinds of confusing.</p>
<p>Ren-C has addressed that particular can of worms with a <a href="https://forum.rebol.info/t/introducingnew-chain-datatype/2226">full design for the CHAIN! sequence type</a>, and rules for its nesting in PATH! (and how TUPLE! nests in it).  So you can get these weird looking structures, but they destructure unambiguously.</p>
<h2><a name="p-7831-as-for-sigils-at-the-head-they-must-be-illegal-1" class="anchor" href="https://forum.rebol.info#p-7831-as-for-sigils-at-the-head-they-must-be-illegal-1"></a>As For Sigils... At The Head They Must Be Illegal</h2>
<p>You can't put a sigil in a sequence head position, because that would be ambiguous with wanting to apply the sigil to the path as a whole.</p>
<pre><code>&gt;&gt; to path! [$foo bar]
** Error: This needs to be an error
</code></pre>
<p>The only way to allow it would be if we invented <a href="https://forum.rebol.info/t/what-is-a-path-or-a-quasi-word/2292/2">some kind of lexical escaping</a> so we could tell the difference between $|foo/bar| and $|foo|/bar ... <em><strong>and I do not want lexical escaping of this kind</strong></em>.</p>
<h2><a name="p-7831-but-sigils-at-non-head-positions-maybe-roll_eyes-2" class="anchor" href="https://forum.rebol.info#p-7831-but-sigils-at-non-head-positions-maybe-roll_eyes-2"></a>But Sigils At Non-Head Positions... Maybe?  <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=12" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></h2>
<p>There's no fundamental reason why sigils couldn't be on non-head positions in sequences.  It works.</p>
<pre><code>&gt;&gt; $a:$b
== a:$b  ; bound
</code></pre>
<p>Part of me says <em>"ugh, no, it makes everything uglier, don't let people make these ugly things!"</em></p>
<p>But one very compelling reason just for the above syntax is what I've called "dialecting function calls", such as for pointing the blame to a callsite with a FAIL.</p>
<p>So instead of:</p>
<pre><code>my-api: func [x y z] [
    if true [
        if y &lt; 100 [
            fail:blame ["Value must be &gt;= 100, not" y] $y
        ]
     ]
 ]
</code></pre>
<p>You could write:</p>
<pre><code>my-api: func [x y z] [
    if true [
        if y &lt; 100 [
            fail:$y ["Value must be &gt;= 100, not" y]
        ]
     ]
 ]
</code></pre>
<p>When you look at it like that, it's hardly a monstrosity.  It's letting you push the variable to blame into the chain for invoking the function, in a way that's out-of-band with other refinements.</p>
<p>It could offer a cheaper way of asking to fetch variables, using @ to take the place of the old "get word" concept:</p>
<pre><code>&gt;&gt; block: [index offset pointer]
&gt;&gt; index: 3

&gt;&gt; block.index
== offset

&gt;&gt; block.(index)
== pointer

&gt;&gt; block.@index
== pointer
</code></pre>
<p>It's measurably less expensive (no array allocation, cheaper to naviate to on fetch).  It doesn't use a GROUP! so it doesn't get in the way of COMPOSE-ing.</p>
<h2><a name="p-7831-think-i-have-to-allow-it-3" class="anchor" href="https://forum.rebol.info#p-7831-think-i-have-to-allow-it-3"></a>Think I Have To Allow It...</h2>
<p>I'd originally thought that it would be cleaner to disallow it.  But seems to me there are too many interesting uses.</p>
<p>As a medium, Rebol is very free, and you have a lot of power to make hideous things.  So it's about using your judgment, and I think people should know when it's getting too crazy.</p>
<hr>
<h2><a name="p-7831-i-almost-hate-to-point-it-out-but-4" class="anchor" href="https://forum.rebol.info#p-7831-i-almost-hate-to-point-it-out-but-4"></a>I Almost Hate To Point It Out, But...</h2>
<p>This is true of quotes as well.</p>
<pre><code>&gt;&gt; 'a:''b:'''c
== a:''b:'''c
</code></pre>
<p>There's an unambiguous way of interpreting that.</p>
<pre><code>&gt;&gt; quote to chain! [a ''b '''c]
== 'a:''b:'''c
</code></pre>
<p>I don't love it, but, maybe there's cases where <strong><code>foo:'bar</code></strong> would be useful in a dialect, and if it's mechanically consistent I shouldn't prohibit it.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20">  I don't know.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-sequences-permit-non-head-sigils/2309">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-sequences-permit-non-head-sigils/2309</link>
          <pubDate>Mon, 07 Oct 2024 19:06:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2309</guid>
          <source url="https://forum.rebol.info/t/should-sequences-permit-non-head-sigils/2309.rss">Should sequences permit non-head SIGILs?</source>
        </item>
        <item>
          <title>:FOO is now a &quot;Refinement&quot;... so what is /FOO called?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>There are pieces of code that use leading-slash-words as dialect parts, without having anything to do with them being "refinements".</p>
<p>We might call them <strong><code>RUN-WORD</code></strong>, because that's what <strong><code>/FOO</code></strong> does in the evaluator... runs FOO if it's a function, and errors if not.</p>
<p>More visually they could be <strong><code>SLASH-WORD</code></strong> with the implied fact the "slash" comes before the word helping to distinguish it from <strong><code>FOO/</code></strong>.  But it seems that they both have equal claim on being slash words to me.</p>
<p>I'm going to call them RUN-WORD just to keep moving along, but think about it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/foo-is-now-a-refinement-so-what-is-foo-called/2308">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/foo-is-now-a-refinement-so-what-is-foo-called/2308</link>
          <pubDate>Mon, 07 Oct 2024 01:46:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2308</guid>
          <source url="https://forum.rebol.info/t/foo-is-now-a-refinement-so-what-is-foo-called/2308.rss">:FOO is now a &quot;Refinement&quot;... so what is /FOO called?</source>
        </item>
        <item>
          <title>SYSTEM.OPTIONS.ARGS vs. SYSTEM.SCRIPT.ARGS</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Modules</category>
          <description><![CDATA[
            <p><a href="https://forum.rebol.info/t/revisiting-a-maybe-not-so-weird-old-idea-as-identity/2165/2">I was looking at some code like</a>:</p>
<pre><code>tests: if try first system.options.args [
    local-to-file first system.options.args
] else [
    %core-tests.r
]
</code></pre>
<p>And it reminded me that I don't like the nuance between SYSTEM.OPTIONS.ARGS and SYSTEM.SCRIPT.ARGS.</p>
<p>One of them is supposed to capture the command line arguments that spawned the interpreter.  The other is the arguments to the currently running script.  If you spawn the interpreter in such a way that it runs a script, then the two will be the same when that script runs.</p>
<h2>
<a name="i-dont-like-the-naming-distinction-or-the-behavior-1" class="anchor" href="https://forum.rebol.info#i-dont-like-the-naming-distinction-or-the-behavior-1"></a>I Don't Like the Naming Distinction or the Behavior</h2>
<p>It seems flawed to me that you can confuse them (and many people do, in ways that break as their code gets more complex.)  One way to avoid confusion would be to say that all arguments should go one place or the other.</p>
<p>e.g. drop the idea of giving you verbatim what the command line was.  If you write the command line in such a way that some arguments are given to the script, then remove those from the place where you find the spawning arguments.</p>
<p>That would give us SYSTEM.BOOT.ARGS which is everything that didn't get picked off to pass to the script.  And the script gets SYSTEM.SCRIPT.ARGS.</p>
<h2>
<a name="should-there-be-systembootargs-at-all-2" class="anchor" href="https://forum.rebol.info#should-there-be-systembootargs-at-all-2"></a>Should There Be SYSTEM.BOOT.ARGS At All?</h2>
<p>I don't know if it's even a good idea.  Why should you be looking at that, vs. whatever was gleaned from it?  This just seems like a way to start building dependencies on the command line argument conventions of the executable that are none of your script's business.</p>
<p>Anyway, maybe I am wrong and SYSTEM.BOOT.ARGS giving you an exact capture of the arguments which started the executable is useful and should be preserved.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20">  I'm just annoyed at how often I've been bitten by this and maybe overreacting.</p>
<p>But at least renaming it to SYSTEM.BOOT.ARGS helps you avoid confusing it.  The SYSTEM.OPTIONS.ARGS vs. SYSTEM.SCRIPT.ARGS naming hath wrought nothing but pain.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/system-options-args-vs-system-script-args/2303">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/system-options-args-vs-system-script-args/2303</link>
          <pubDate>Mon, 30 Sep 2024 12:31:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2303</guid>
          <source url="https://forum.rebol.info/t/system-options-args-vs-system-script-args/2303.rss">SYSTEM.OPTIONS.ARGS vs. SYSTEM.SCRIPT.ARGS</source>
        </item>
        <item>
          <title>A Pattern-Matching Optimized MAP (?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p>In UPARSE, there's a MAP! of all the combinators.  You can map fundamental datatypes to combinator functions, or you can map literal elements to combinator functions (as keywords like SOME or ACROSS are)... or you can map literal elements to something to substitute as a rule.</p>
<p><em>(e.g. you can map a literal element to a parse rule block!, and it will use that block as the implementation of whatever you mapped.  You could map <strong><code>&lt;_&gt;</code></strong> to <strong><code>[opt some whitespace]</code></strong> if you wanted.)</em></p>
<h2>
<a name="but-now-foobar-foo-and-foo-are-all-becoming-chainhttpsforumrebolinfotintroducingnew-chain-datatype2226-1" class="anchor" href="https://forum.rebol.info#but-now-foobar-foo-and-foo-are-all-becoming-chainhttpsforumrebolinfotintroducingnew-chain-datatype2226-1"></a>But now <code>FOO:BAR</code>, <code>FOO:</code> and <code>:(FOO)</code> are all becoming <a href="https://forum.rebol.info/t/introducingnew-chain-datatype/2226">CHAIN!</a>
</h2>
<p>It's likely that <strong><code>foo:bar</code></strong> would be handled by the combinator mechanics themselves, to provide refinements to the combinator.  So it wouldn't be dispatched to the "CHAIN! combinator".</p>
<p>But we've been handling <strong><code>foo:</code></strong> and <strong><code>:(foo)</code></strong> very differently.  But they're both the same type: CHAIN!.</p>
<p>Problem is, there are no variadic combinators (yet?).  So you either map the CHAIN! to a combinator that takes an argument or you don't.  The <strong><code>foo:</code></strong> needs an argument, the <strong><code>:(foo)</code></strong> has been evaluating the group and splicing it as a rule to execute.</p>
<h2>
<a name="cheap-solution-of-the-moment-hack-the-dispatch-2" class="anchor" href="https://forum.rebol.info#cheap-solution-of-the-moment-hack-the-dispatch-2"></a>Cheap Solution of the Moment: Hack The Dispatch</h2>
<p>The terrible but "let's keep things moving" answer is that if you have any sequence with a leading blank, it will try dispatching to <strong><code>:*</code></strong> or <strong><code>/*</code></strong> or <strong><code>.*</code></strong> ... e.g. those literal sequence patterns are what you put in the combinator table.</p>
<p>And if it has a trailing blank, you put <strong><code>*:</code></strong> or <strong><code>*/</code></strong> or <strong><code>*.</code></strong> and give those a combinator.</p>
<p>If both of those fall through, it goes to the plain CHAIN! or PATH! or TUPLE! combinator.</p>
<p>Shoddy...of course.  How to do better?</p>
<h2>
<a name="could-a-map-like-structure-optimize-pattern-match-3" class="anchor" href="https://forum.rebol.info#could-a-map-like-structure-optimize-pattern-match-3"></a>Could A MAP!-Like Structure Optimize Pattern Match?</h2>
<p>As a non-compiled language, we can't do much to optimize <a href="https://forum.rebol.info/t/destructure-dialect/1877">something like DESTRUCTURE</a> if the moment we encounter it is the first time we've seen it.</p>
<p>We <em>could</em> have a data structure that is internally optimized to pattern matching.  e.g. something like a MAP! but that has architecture inside of itself as a data structure that groups patterns that are close to each other together, and branches off at the appropriate points.</p>
<p>I don't know how to implement it, but I do know that if we turned the combinator map into a list of destructure rules that it tested one at a time in order, that that would be really slow... even if destructure were native.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/a-pattern-matching-optimized-map/2302">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/a-pattern-matching-optimized-map/2302</link>
          <pubDate>Sat, 28 Sep 2024 23:35:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2302</guid>
          <source url="https://forum.rebol.info/t/a-pattern-matching-optimized-map/2302.rss">A Pattern-Matching Optimized MAP (?)</source>
        </item>
        <item>
          <title>Bitten By Right Side Evaluation First</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>I was writing some code like this:</p>
<pre><code>while [not tail? info] [
    if find leaders info.1.name [
        leader-protos.(info.1.name): take info
    ] else [
        info: next info
    ]
]
</code></pre>
<p>Due to the post title you probably already see the bug.  TAKE INFO on the right hand side runs <em>before</em> the <strong>info.1.name</strong>.  So it's inserting under the next name.</p>
<p>I think we can (and should) precalculate the groups on the left hand side.  Basically walk the tuple and push its elements to the stack before doing the right hand side evaluation.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/bitten-by-right-side-evaluation-first/2301">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/bitten-by-right-side-evaluation-first/2301</link>
          <pubDate>Sat, 28 Sep 2024 17:53:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2301</guid>
          <source url="https://forum.rebol.info/t/bitten-by-right-side-evaluation-first/2301.rss">Bitten By Right Side Evaluation First</source>
        </item>
        <item>
          <title>What Should &quot;New Refinements&quot; (e.g. :FOO) Evaluate To?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>We know what new refinements will do when you put them in a dialect like APPLY.:</p>
<pre><code>call:shell // [  ; infix APPLY
    [(system.options.boot) --suppress {"*"} print.reb 100]

    :input 'none      ; pipe input from /dev/null
    :output data: {}  ; write output to string
]
</code></pre>
<p>The <strong><code>:input</code></strong> and <strong><code>:output</code></strong> will be noticed literally by APPLY.  But this doesn't prescribe any particular evaluator meaning for them when not dialected.</p>
<p>Old refinements (e.g. <strong><code>/input</code></strong> and <strong><code>/output</code></strong>) would evaluate to bound versions of themselves... so effectively synonyms for <strong><code>$/input</code></strong> and <strong><code>$/output</code></strong>.</p>
<p><em>(This makes me aware of a likely bug in the optimization of paths (chains) of this size... they use a WORD! cell format.  Which means they only capture the binding of the specific word...while array-based sequences get a "whole specifier".  It doesn't seem to me that the length of the sequence should affect what kind of environment it captures.  e.g. <strong><code>[_ input]</code></strong> should capture the same amount of context as the path produced by it does...but if we forced embedded GROUP!s to be fixed in their biding on sequence creation that might be undesirable.  Review.)</em></p>
<p>Anyway...we know that <strong><code>.input</code></strong> is evaluative (picking the field out of the "current coupled context").  And <strong><code>/input</code></strong> will be evaluative (calling a function).  Then <strong><code>foo:bar</code></strong> will be evaluative, calling FOO with the refinement BAR.</p>
<p>So what of <strong><code>:foo</code></strong>?  Due to what we want it to do in APPLY, we know that giving it any active meaning in the evaluator would be a bad idea.  But maybe the best idea is to be conservative and error on it for now.  That won't stop you from creating unbound forms (<strong><code>':foo</code></strong>) or bound forms (<strong><code>$:foo</code></strong>)...and discouraging its use as a generic inert form probably has advantages in other contexts besides helping APPLY.</p>
<p>If it turns out that having it act as a generic unbound version of itself has some great application, I'll reconsider.  But error for now.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/what-should-new-refinements-e-g-foo-evaluate-to/2299">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-should-new-refinements-e-g-foo-evaluate-to/2299</link>
          <pubDate>Fri, 27 Sep 2024 18:11:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2299</guid>
          <source url="https://forum.rebol.info/t/what-should-new-refinements-e-g-foo-evaluate-to/2299.rss">What Should &quot;New Refinements&quot; (e.g. :FOO) Evaluate To?</source>
        </item>
        <item>
          <title>Typechecking Quoted forms / Quasiforms / Antiforms</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Asking questions about antiforms can be a bit tricky.</p>
<p>If you have a meta result that contains something that might be a pack, you'd have to say:</p>
<pre><code>if pack? unmeta result' [...]
</code></pre>
<p>But you're just asking a question.  What if it contained a meta of a raised error?   Should PACK? be willing to accept raised errors?  If not, that would cause an abrupt failure.</p>
<p>To dodge the need to do an UNMETA, you could say:</p>
<pre><code>all [
    quasiform? result'
    block! = heart of result'
] then [
   ...
]
</code></pre>
<p>And via such a mechanism, you could write a function META-PACK? that would not fail on META-RAISED:</p>
<pre><code>if meta-pack? result' [...]
</code></pre>
<p>That has the nice feature of not forcing you to perform an UNMETA just to answer the question.  You can narrowly ask "is this a meta pack".</p>
<p>But I think such things need to be in the box.  This question gets asked a lot, and I'm tired of asking it as the ugly and breakable <strong><code>pack? unmeta</code></strong>.</p>
<h2>
<a name="what-if-typecheck-functions-had-a-meta-refinement-1" class="anchor" href="https://forum.rebol.info#what-if-typecheck-functions-had-a-meta-refinement-1"></a>What If Typecheck Functions Had a :META refinement...?</h2>
<p>It doesn't seem like clogging up the namespace with more functions makes a lot of sense, so we might offer a refinement:</p>
<pre><code>if pack?/meta result' [...]
</code></pre>
<p>That puts some separation between the <strong>?</strong> and the thing you're testing.  It's a little less severe with the new format using a CHAIN!:</p>
<pre><code>if pack?:meta result' [...]
</code></pre>
<p>We could put a question mark on the refinement as well <img src="https://forum.rebol.info/images/emoji/twitter/face_with_diagonal_mouth.png?v=12" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20"></p>
<pre><code>if pack?:meta? result' [...]
</code></pre>
<p>Okay, no, we won't do that.</p>
<p>I kind of feel like putting the meta after makes it unclear.  You'd read it like <strong>pack? meta result'</strong>.  Does that mean it should just be UNMETA?</p>
<pre><code>if pack?:unmeta result' [...]
</code></pre>
<p>But at that point, people are probably not going to generally know what the difference is between that and <strong><code>pack? unmeta result</code></strong></p>
<p>None of this is as good as simply <strong><code>meta-pack?</code></strong>.  But we don't want to generate new words for every possible thing (and questions like <strong><code>meta-integer?</code></strong> are equally legitimate...)</p>
<h2>
<a name="what-about-arbitrary-chain-interpretation-2" class="anchor" href="https://forum.rebol.info#what-about-arbitrary-chain-interpretation-2"></a>What About Arbitrary CHAIN! Interpretation?</h2>
<p>Let's forget for a moment about the existing refinements to META and QUASI.  What if they--as functions--were willing to <em>take other functions as a refinement</em>?</p>
<pre><code>if meta:pack? result' [...]
</code></pre>
<p>This could be a general pattern of solution...</p>
<pre><code>if (quasi:group? first [~(a b c)~]) [...]

if (quote:word? first ['a b c:]) [...]  ; or quoted:word?
</code></pre>
<p>How would it work?  Well, I guess the basic idea would be that it would do a processing step on the argument before typechecking it and passing it to the constraint function.</p>
<p>So <strong><code>quoted:word?</code></strong> would run QUOTED, and it would be able to inspect the chain as containing WORD?.</p>
<ul>
<li>
<p>If it was passed something like <strong><code>&lt;foo&gt;</code></strong> it would say "I don't even have to ask, that's not a quoted anything".</p>
</li>
<li>
<p>If it was something like <strong><code>'&lt;foo&gt;</code></strong> it would say "okay that's quoted, I need to ask" and it would unquote the thing before passing it to WORD?, which would come back false.</p>
</li>
<li>
<p>If it was <strong><code>'bar</code></strong> it would do the same thing but this time WORD? would return true.</p>
</li>
</ul>
<p><em>It feels a little bit ad-hoc, but the ergonomics are certainly there.</em>  This would be tremendously useful and could create new and useful type constraints.  It's literate... and <strong><code>meta:pack?</code></strong> is going to look better in type specs than <strong><code>meta/pack?</code></strong></p>
<p>Not only that, but <a href="https://forum.rebol.info/t/intrinsics-functions-without-frames/2050">recognizing <strong>"intrinsics"</strong> in the chain</a> would mean this could be relatively fast--faster than <strong><code>pack? unmeta</code></strong> could be.</p>
<h2>
<a name="what-about-refinements-like-metalitehttpsforumrebolinfotmeta-lite-when-you-dont-want-quasiforms2296-3" class="anchor" href="https://forum.rebol.info#what-about-refinements-like-metalitehttpsforumrebolinfotmeta-lite-when-you-dont-want-quasiforms2296-3"></a>What About Refinements Like <a href="https://forum.rebol.info/t/meta-lite-when-you-dont-want-quasiforms/2296"><code>META:LITE</code></a>
</h2>
<p>Let's say there's a single-arity logic-bearing function someone makes called LITE, and they get mad that META:LITE doesn't call it to do a meta version of that test.</p>
<p>I don't know that I care a ton about that.  We have situations in PARSE where you might have a variable named ACROSS and it will ignore that variable if there's a keyword called ACROSS.  You have to escape your words when they run up against reserved dialect words.</p>
<p>So I guess you'd wind up with something like:</p>
<pre><code> if meta:(lite/) [...]
</code></pre>
<p>Otherwise the keyword would win.</p>
<h2>
<a name="what-about-cascading-the-functions-4" class="anchor" href="https://forum.rebol.info#what-about-cascading-the-functions-4"></a>What About Cascading The Functions?</h2>
<pre><code>if (quoted:quoted:quasi:block? first [''~[a b c]~]) [...]
</code></pre>
<p>Well I guess that could work if the rule was that if you used a function name as a refinement, that function would receive all the refinements after it.  Applying that recursively you'd get something that works.</p>
<p>There could be an optimization that functions like QUOTED would detect when the functions in the chain were ones they recognized, and they could do something optimal.</p>
<h2>
<a name="does-any-of-this-solve-the-unmeta-problem-5" class="anchor" href="https://forum.rebol.info#does-any-of-this-solve-the-unmeta-problem-5"></a>Does Any Of This Solve The UNMETA Problem?</h2>
<p>It's nice syntax, but remember the original issue...where you have a meta-raised-error, and you want to test it to see if it is or isn't a meta pack:</p>
<pre><code>if pack? unmeta result' [...]
</code></pre>
<p>I'm talking about redoing that:</p>
<pre><code>if meta:pack? result' [...]
</code></pre>
<p>But if META is unmeta'ing its argument, and passing it to PACK?, does that still have the same problem?</p>
<p>It doesn't have to.  META would see that the result is a quasiform, hence a candidate for any function to ask... then it needs to typecheck against what PACK? takes.  But if that typecheck fails, there's no need to raise the error.  You can just say "no, it's not a meta pack".  Done.</p>
<h2>
<a name="are-there-less-wacky-ways-to-do-it-6" class="anchor" href="https://forum.rebol.info#are-there-less-wacky-ways-to-do-it-6"></a>Are There Less Wacky Ways To Do It?</h2>
<p>I dunno.  It's admittedly a bit weird to put that much overloading on words like META and QUASI.  Their type signatures stop making sense (returning LOGIC?...sometimes?)</p>
<p>The overloading could be reduced if the weird modifiers were QUOTED, METAD, and QUASID.  :-/</p>
<pre><code>if metad:pack? result' [...]
</code></pre>
<p>Errr, no.  Didn't come this far to write things that look like garbage.</p>
<p>But oddly, quoted:xxx? looks better than quote:xxx?... does that suggest the operator should be called QUOTED too?  <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<pre><code>&gt;&gt; quoted 1 + 2
== '3
</code></pre>
<p>I've seen it as QUOTE for so long that it's hard to frame it.  It doesn't look <em>terrible</em>, and when you put them side by side the brevity has an advantage:</p>
<pre><code>if (quoted:quoted:quasi:block? first [''~[a b c]~]) [...]

if (quote:quote:quasi:block? first [''~[a b c]~]) [...]
</code></pre>
<p>To say that <strong><code>'a</code></strong> is a QUOTE-WORD! is a little bit caveman-ish, but better than calling it a LIT-WORD!, and it takes one less syllable to say "is a quote word" than to say "is a quote-uhd word".</p>
<p>Looking at it in that light, it's growing on me to dumb it down.  Maybe not in all circumstances.  Perhaps it could be left as a matter of taste with QUOTED and QUOTE being synonyms... like FUNC and FUNCTION, use whichever you want.</p>
<h2>
<a name="i-think-this-is-a-direction-worth-pursuing-7" class="anchor" href="https://forum.rebol.info#i-think-this-is-a-direction-worth-pursuing-7"></a>I Think This Is A Direction Worth Pursuing</h2>
<p>I've been looking for an answer to this question, and haven't thought of anything this good before.</p>
<p>Don't have a complete design for the "customized refinement dialect", but I can do some prototyping...</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/typechecking-quoted-forms-quasiforms-antiforms/2298">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/typechecking-quoted-forms-quasiforms-antiforms/2298</link>
          <pubDate>Tue, 24 Sep 2024 00:16:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2298</guid>
          <source url="https://forum.rebol.info/t/typechecking-quoted-forms-quasiforms-antiforms/2298.rss">Typechecking Quoted forms / Quasiforms / Antiforms</source>
        </item>
        <item>
          <title>Generalized Argument Removal - SPECIALIZE:RELAX</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Let's say you want a version of append that just appends random numbers to things:</p>
<pre><code>&gt;&gt; append-random: adapt get $append [
       value: random 10
   ]
</code></pre>
<p>This works, but the function interface still thinks it takes two arguments:</p>
<pre><code>&gt;&gt; append-random [a b c] [d e]
== [a b c 10]
</code></pre>
<p>So fine, you can just specialize out the argument.  Both ADAPT of a SPECIALIZE and SPECIALIZE of an ADAPT would remove an argument.  But you want the specialize to run first, otherwise it would overwrite the adapted value.  So SPECIALIZE the ADAPT, to put the specialize earlier in the composition process.</p>
<p><em><strong>But what value do you put in the specialized-out slot if you're just going to overwrite it?</strong></em></p>
<p>Today we have quite the awesome answer: <strong><a href="https://forum.rebol.info/t/tripwire-in-the-wild/2278">use a TRIPWIRE!</a></strong>  Sounds great!</p>
<pre><code>&gt;&gt; append-random: specialize (adapt get $append [
       value: random 10
   ]) [
       value: ~&lt;specialized out&gt;~
   ]
** Script Error: append expects [~void~ element? splice?] for its value argument
</code></pre>
<h2>
<a name="ooops-specialize-typechecked-that-1" class="anchor" href="https://forum.rebol.info#ooops-specialize-typechecked-that-1"></a>Ooops.  SPECIALIZE Typechecked That</h2>
<p>There are two good reasons for specialization to type check:</p>
<ul>
<li>
<p>You find out about bad types at the moment of specialization--instead of having to wait until the function is called to know there are problems.</p>
</li>
<li>
<p>It can speed up the system by not type checking those parameters again <em>(though it occurs to me this may be broken right now, and fixing it sooner than later would probably be smart)</em></p>
</li>
</ul>
<p>Historically what I've done just to get things going is to use some value that typechecks in the argument slot:</p>
<pre><code>&gt;&gt; append-random: specialize (adapt get $append [
       value: random 10
   ]) [
       value: [something that typechecks]
   ]

&gt;&gt; append-random [a b c]
== [a b c 7]

&gt;&gt; append-random [a b c]
== [a b c 9]

&gt;&gt; append-random [a b c]
== [a b c 7]
</code></pre>
<p>For the sake of education, notice what happens if you did it backwards and ADAPT the SPECIALIZE:</p>
<pre><code>&gt;&gt; append-random: adapt (specialize get $append [
       value: [something that typechecks]
   ]) [
       value: random 10
   ]

&gt;&gt; append-random [a b c]
== [a b c [something that typechecks]]
</code></pre>
<h2>
<a name="seems-we-need-specializerelax-2" class="anchor" href="https://forum.rebol.info#seems-we-need-specializerelax-2"></a>Seems We Need SPECIALIZE:RELAX</h2>
<p>Having to pick an arbitrary meaningless value that won't trip up the type checking is bad.</p>
<p>While we want to type check 99% of the time, this kind of scenario calls for a version of specialize that does not do typechecking.</p>
<p>Hence I propose <strong><code>SPECIALIZE:RELAX</code></strong>.</p>
<p>Tripwires seem like the go-to datatype to use for these specialized-out values.  Rather than just say <strong><code>~&lt;specialized out&gt;~</code></strong> you can be as detailed as you like, to help inform on what should happen:</p>
<pre><code>&gt;&gt; append-random: specialize:relax (adapt get $append [
       value: random 10
   ]) [
       value: ~&lt;ADAPT phase of APPEND-RANDOM puts INTEGER! here&gt;~
   ]
</code></pre>
<p>Tripwires are great!  <img src="https://forum.rebol.info/images/emoji/twitter/boom.png?v=12" title=":boom:" class="emoji" alt=":boom:" loading="lazy" width="20" height="20">  You don't have to stress too much about cost...the string inside the tag only exists as one instance in memory.</p>
<p>But you could be lazy and/or cheap, and just unset it. <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p>
<pre><code>&gt;&gt; append-random: specialize:relax (adapt get $append [
       value: random 10
   ]) [
       value: ~
   ]
</code></pre>
<p>There might be other uses for not typechecking at the moment of specialization, but I can't think of what they would be.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/generalized-argument-removal-specialize-relax/2297">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/generalized-argument-removal-specialize-relax/2297</link>
          <pubDate>Mon, 23 Sep 2024 17:37:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2297</guid>
          <source url="https://forum.rebol.info/t/generalized-argument-removal-specialize-relax/2297.rss">Generalized Argument Removal - SPECIALIZE:RELAX</source>
        </item>
        <item>
          <title>META:LITE - When You Don&#39;t Want Quasiforms</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>There was a time before quasiforms existed, but where there was generic quoting.</p>
<p>It was in this time that META was invented.  It did the only thing it could do:</p>
<ul>
<li>
<p>When you META'd a plain (or quoted) thing, it got one quote level added</p>
</li>
<li>
<p>When you META'd an "antiform" you would get a plain version of the thing</p>
</li>
</ul>
<p>So it worked like this:</p>
<pre><code>&gt;&gt; meta first [(d e f)]
== '(d e f)

&gt;&gt; meta first ['(d e f)]
== ''(d e f)

&gt;&gt; spread [a b c]
== (a b c)  ; "antiform"

&gt;&gt; meta spread [a b c]
== (a b c)
</code></pre>
<p><em>(That's not how it works now--for good reasons.  Not only is it a bit too easy to get confused about whether a meta protocol is in effect, the absence of quasiforms leaves a representational hole for values that produce antiforms under evaluation.  But I won't rewrite a <a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">A Justification Of Generalized Iostopes</a> here, this post has another purpose.)</em></p>
<h2>
<a name="another-historical-twist-meta-of-null-was-null-1" class="anchor" href="https://forum.rebol.info#another-historical-twist-meta-of-null-was-null-1"></a>Another Historical Twist: META of NULL was NULL</h2>
<p>NULL was an outlier--at various times having no quoted form (and at other times being considered a quote of nothingness, e.g. the lone apostrophe (<strong><code>'</code></strong>)).</p>
<p>I don't exactly remember what state NULL was in at the time META was being invented.  But regardless, it was initially decided that META and UNMETA of NULL could just give null back.</p>
<p>This actually turned out to frequently be useful...for instance <a href="https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833">when writing a loop wrapper like FOR-BOTH</a></p>
<pre><code>for-both: func [var blk1 blk2 body] [  ; the historical formulation
    return unmeta all [
        meta for-each var blk1 body  ; META NULL =&gt; NULL allows chaining BREAK
        meta for-each var blk2 body
    ]
]
</code></pre>
<p>Though while it was useful there, plenty of places needed to speak fully abstractly about all possible states.  So as the model shaped up, META of NULL fit into the regular pattern of all things having reified metaforms, giving <strong><code>~null~</code></strong>.</p>
<h2>
<a name="i-wanted-a-metalitehttpswwwyoutubecomwatchvimv0g-4cycw-2" class="anchor" href="https://forum.rebol.info#i-wanted-a-metalitehttpswwwyoutubecomwatchvimv0g-4cycw-2"></a><a href="https://www.youtube.com/watch?v=Imv0g-4cycw">I Wanted A META:LITE</a>
</h2>
<p>The idea of a META variation that passed through keywords as-is came along as <strong><code>meta:lite</code></strong>.</p>
<pre><code>&gt;&gt; meta:lite [a b c]
== '[a b c]

&gt;&gt; spread [a b c]
== ~(a b c)~  ; null

&gt;&gt; meta:lite spread [a b c]
== ~(a b c)~

&gt;&gt; meta:lite null
== ~null~  ; anti

&gt;&gt; meta:lite first [~null~ ~void~]
== '~null~
</code></pre>
<p>So today's META:LITE still produces quasiforms for antiforms--just not for the <code>~null~</code> and <code>~void~</code> antiforms (and I now imagine it should probably pass through <code>~okay~</code> and <code>~end~</code> and <code>~NaN~</code> as well):</p>
<pre><code>/for-both: func [var blk1 blk2 body] [
    return unmeta:lite all [
        meta:lite for-each var blk1 body  ; meta:lite null =&gt; ~null~ antiform
        meta:lite for-each var blk2 body  ; meta:lite void =&gt; ~void~ antiform
    ]
]
</code></pre>
<h2>
<a name="but-what-if-metalite-didnt-make-any-quasiforms-at-all-3" class="anchor" href="https://forum.rebol.info#but-what-if-metalite-didnt-make-any-quasiforms-at-all-3"></a>But What If META:LITE Didn't Make <em>Any</em> Quasiforms At All?</h2>
<p>By design, <a href="https://forum.rebol.info/t/quasiforms-arent-super-friendly-and-they-shouldnt-be/2273">quasiforms are not very friendly</a>.  So if you have an antiform in your hand... and you know you have an antiform in your hand... it's easy to take a step to a quasiform, but you need another step to get back to a plain form you can interact with.</p>
<p>So why not have META:LITE take care of it?</p>
<pre><code>&gt;&gt; meta:lite null
== ~null~  ; anti

&gt;&gt; meta:lite spread [a b c]
== (a b c)
</code></pre>
<p>This doesn't make a difference to things like FOR-BOTH.  They'll still work--plain forms are just as truthy as quasiforms for the meta states.  They just have to remember to use UNMETA:LITE on the reverse end.  <em>(If you use plain UNMETA it will catch your error, as UNMETA does not accept plain forms.)</em></p>
<p>It might seem random to pair up the feature of not making quasiforms with passing thru null and void.  But I actually think the kinds of places where you'd want one behavior do overlap significantly with the other.</p>
<p>And we're really just running out of terms, here.  Throwing another nuance in to say <em>"I want partial META, but only partial in the sense that I'm passing through null and void, not partial in terms of the other antiforms--make those quasiforms"</em> is just starting to go beyond the ability to give names to.</p>
<p>So in my head, having META:LITE be formulated as "do what META would do in a historical world where quasiforms and meta-nulls didn't exist" feels pretty good.</p>
<h2>
<a name="its-still-fundamentally-a-valid-meta-4" class="anchor" href="https://forum.rebol.info#its-still-fundamentally-a-valid-meta-4"></a>It's Still Fundamentally a "Valid META"</h2>
<p>I couldn't really think of a good name for the operation besides just saying it was an alternate behavior of META. "Lite" is a bit strange but I felt it fit.</p>
<p>Note that it doesn't make sense as a refinement to REIFY.  Because being willing to produce something that can't be put in a block fundamentally undermines what the word REIFY means.  (<strong><code>reify:...NOT!</code></strong>)</p>
<p>The thing about META:LITE is that it really is giving you a full-spectrum meta representation of what you had in your hand.  Every input state maps to a unique output state.  The default META happens to also be a fully reifying operation as well...but here we are saying that's not intrinsic to "a meta operation".</p>
<p><em>(Would there be any use for a META that passes through <em>all</em> antiforms--not just the antiform words--and just quotes everything else?  That's more a variation of QUOTE than it is a variation of META.  I can't offhand think of a case where that would ever be useful.)</em></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/meta-lite-when-you-dont-want-quasiforms/2296">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/meta-lite-when-you-dont-want-quasiforms/2296</link>
          <pubDate>Mon, 23 Sep 2024 13:42:44 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2296</guid>
          <source url="https://forum.rebol.info/t/meta-lite-when-you-dont-want-quasiforms/2296.rss">META:LITE - When You Don&#39;t Want Quasiforms</source>
        </item>
        <item>
          <title>What is ~/~ : A PATH! or a QUASI-WORD?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>I've mentioned that there are not going to be quasiform or antiform sequence types.</p>
<ul>
<li>
<p>We want tildes in paths <strong><code>~/home/whatever.txt</code></strong></p>
<ul>
<li>
<p>Paths in particular...but they could be useful in tuples (<strong><code>~.foo</code></strong>) or chains (<strong><code>[a]:~</code></strong>)</p>
</li>
<li>
<p>Quasiforms might be nice  for some purposes too (<strong><code>~null~/a/b/c), (foo:~[a]~</code></strong>)</p>
</li>
</ul>
</li>
<li>
<p>The known very important usage of tilde in paths, plus all the as-yet-unknown and untapped other uses, far outweigh any advantage I can think of for antiform/quasiform sequences.</p>
</li>
</ul>
<p>So that's settled.  But there's a bit of an edge case with the WORD!s like <strong><code>/</code></strong> or <strong>.</strong> or <strong>:</strong></p>
<p>And there, I'm going to have to say that <strong><code>~/~</code></strong> is a quasiword.</p>
<ul>
<li>
<p>I want all words to have quasiforms (though not antiforms... only system-blessed "keywords" will be allowed to become antiforms).  And so I don't want to exempt any words from that.</p>
</li>
<li>
<p>I don't think excluding <strong><code>~/~</code></strong> as a path form has any tremendous consequences</p>
</li>
<li>
<p>Allowing it to be a quasiword fits in with <strong><code>~///~</code></strong> and other such words being quasiwords, and those aren't valid paths.</p>
</li>
</ul>
<p>So we open up a wider field of parts, keep all words having quasiforms, and lose one weird path representation.</p>
<p>Though it's not "lost"--if you're writing dialect code that has some logic for what a PATH! of two tilde-trash would mean, you can specially recognize the quasiword.  You'll only run into representational trouble if in the same dialect you need a meaning for every possible quasiword that deviates from what the path interpretation would be.</p>
<p>(I'd say I'd bet money that's never going to happen, except I've seen exactly weird things like that happen often enough to know better.  So instead I'll say "it might happen someday, but I don't care.")</p>
<p>Anyway, trying to shore this up a bit, some sample errors:</p>
<pre><code>&gt;&gt; to path! [~ a]
== ~/a

&gt;&gt; to path! [~ ~]
** Script Error: Sequence would conflate with WORD! form: ~/~

&gt;&gt; to path! [a _]
== a/

&gt;&gt; to path! [_ _]
** Script Error: Sequence would conflate with WORD! form: /

&gt;&gt; to path! [_ a _]
== /a/

&gt;&gt; to path! [a _ b]
** Script Error: BLANK! only legal at head and tail of sequence
</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/what-is-a-path-or-a-quasi-word/2292">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-is-a-path-or-a-quasi-word/2292</link>
          <pubDate>Sun, 22 Sep 2024 13:15:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2292</guid>
          <source url="https://forum.rebol.info/t/what-is-a-path-or-a-quasi-word/2292.rss">What is ~/~ : A PATH! or a QUASI-WORD?</source>
        </item>
        <item>
          <title>DO/NEXT vs. EVAL/NEXT vs. EVAL:STEP</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>DO/NEXT was how you'd do a single step in historical Redbol</p>
<p>This is currently EVAL/NEXT (since DO is higher level and doesn't evaluate lists).  But it hadn't occurred to me to question /NEXT...</p>
<p>But I realized that within the code, I call it <strong><code>Eval_Step_XXX()</code></strong>.  And the level executor that runs a single evaluation step is called the <strong><code>Stepper_Executor()</code></strong></p>
<p>So <strong><code>EVAL:STEP</code></strong> (new refinement notation) seems better to me.</p>
<pre><code>&gt;&gt; [pos value]: eval:step [1 + 2 10 + 20]
== [10 + 20]

&gt;&gt; pos
== [10 + 20]

&gt;&gt; value
== 3
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/do-next-vs-eval-next-vs-eval-step/2291">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/do-next-vs-eval-next-vs-eval-step/2291</link>
          <pubDate>Sat, 21 Sep 2024 17:13:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2291</guid>
          <source url="https://forum.rebol.info/t/do-next-vs-eval-next-vs-eval-step/2291.rss">DO/NEXT vs. EVAL/NEXT vs. EVAL:STEP</source>
        </item>
        <item>
          <title>Implicit Escaping To Tiebreak Literal Arguments</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Imagine a situation where one function takes its right-hand side literally, and another takes its left-hand side literally:</p>
<pre><code>right-literal: func ['arg] [...]
left-literal: enfix func ['left right] [...]
</code></pre>
<p>What happens when I write:</p>
<pre><code> right-literal X left-literal Y
</code></pre>
<p>Seems like an unbreakable tie.  <img src="https://forum.rebol.info/images/emoji/twitter/necktie.png?v=12" title=":necktie:" class="emoji" alt=":necktie:" loading="lazy" width="20" height="20"></p>
<p>You're going to be lying to someone if you don't trigger an error.  It could be a pretty big lie...e.g. if you let one evaluate and pass their result to the other, then you might be giving an antiform to a function that specifically only expected source-representable things.</p>
<h2>
<a name="but-what-if-the-situation-was-a-bit-moremalleable-1" class="anchor" href="https://forum.rebol.info#but-what-if-the-situation-was-a-bit-moremalleable-1"></a>But what if the situation was a bit more...malleable...</h2>
<p>Let's say that one of these lets you escape the argument inside a GROUP! (currently thinking the most semiotic way to represent such a property of a parameter is by...putting it in a group).</p>
<pre><code>right-escapable: func ['(arg)] [...]  ; `right-esc ('X)` acts like `right-esc X` 
left-literal: enfix func ['left right] [...]
</code></pre>
<p>So this means that RIGHT-ESCAPABLE is geared up to accept evaluative products.  If that's the case, then we might think of ourselves as having a bit more liberty to tiebreak:</p>
<pre><code>right-escapable X left-literal Y
=&gt;
right-escapable (X left-literal Y)
</code></pre>
<p>Whether that seems presumptuous or not to you, it definitely is useful, e.g. with lambdas...where requiring a group would be ugly:</p>
<pre><code>case [...] then x -&gt; [...]
</code></pre>
<p>The interface on the function says it was "willing to accept a group at the callsite".  But it never actually received a group, just the evaluative product, which would then be typechecked.  Given that it's willing to take that evaluative product, why not throw in the group implicitly vs. giving an error?</p>
<p>You should be convinced.  It's a good thing.</p>
<h2>
<a name="another-case-study-infix-of-2" class="anchor" href="https://forum.rebol.info#another-case-study-infix-of-2"></a>Another Case Study: Infix "OF"</h2>
<p>First there was <strong><code>(type? x)</code></strong> in Rebol2</p>
<p>Then <strong><code>(type-of x)</code></strong> emerged, in the attempts to purge the blight of <em>"functions that return a result end in question mark"</em>, reserving it for LOGIC-bearing functions.</p>
<p>It then became <strong><code>(type of x)</code></strong> to be even more pleasing to the words-separated-by-spaces aesthetic.</p>
<p>But the infix properties of such a left-literal function can't be the same as ordinary evaluative infix, e.g. math:</p>
<pre><code>&gt;&gt; 1 + 2 * 3
== 9  ; e.g. (1 + 2) * 3
</code></pre>
<p>Because we used to be able to write:</p>
<pre><code>&gt;&gt; integer! = type-of 1
== ~okay~  ; anti
</code></pre>
<p>So we'd still like to be able to write:</p>
<pre><code>&gt;&gt; integer! = type of 1
== ~okay~  ; anti
</code></pre>
<p>Hence that can't be interpreted as <strong><code>(integer! = type) of 1</code></strong></p>
<p><em>"Easy enough"</em> you say... <em>"make it so literal left enfix wins over evaluative right enfix."</em></p>
<p>If you think it's easy, try writing this stuff yourself.  But yes--that is what I did.</p>
<p>However, OF is one of these "escapable" routines.  We want to be able to do this:</p>
<pre><code>&gt;&gt; integer! = (first [type length]) of 1
== ~okay~  ; anti
</code></pre>
<p>So how does this work out with our tie-breaking?</p>
<p><em>It doesn't count.</em>  There's no tie to break.  <strong><code>=</code></strong> isn't inescapably quoting its right.  If it <em>was</em> inescapably quoting its right, then the escapable left would mean the OF would yield to the hard rightward literal.</p>
<h2>
<a name="its-simpler-than-i-had-it-3" class="anchor" href="https://forum.rebol.info#its-simpler-than-i-had-it-3"></a>It's Simpler Than I Had It</h2>
<p>Due to some accidents of history and not really having clear thinking on this, there were more parameter conventions than were required... with one hacked in to specifically make the <strong>OF</strong> case work.</p>
<p>It turns out that using the rationale above, the extra parameter convention can be dropped.  It can all be done with just escapability-or-not meeting escapability-or-not.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/implicit-escaping-to-tiebreak-literal-arguments/2290">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/implicit-escaping-to-tiebreak-literal-arguments/2290</link>
          <pubDate>Fri, 20 Sep 2024 17:17:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2290</guid>
          <source url="https://forum.rebol.info/t/implicit-escaping-to-tiebreak-literal-arguments/2290.rss">Implicit Escaping To Tiebreak Literal Arguments</source>
        </item>
        <item>
          <title>The Meaning of the FORM String Operation</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>So FORM's vague job is to give a "human readable representation" of the data it's given.</p>
<p>So for TEXT!, it gives you a representation of the string without delimiters--in contrast to MOLD, which gives you the delimiters:</p>
<pre><code>&gt;&gt; form "hello world"
== "hello world"

&gt;&gt; mold "hello world"
== {"hello world"}
</code></pre>
<p>And you're probably thinking <em>"Uh...FORM of a text string is a no-op.  Why would you do that?"</em></p>
<p>The idea is that there are things other than text which do what the delimiters.  Such as TAG!</p>
<pre><code>&gt;&gt; form &lt;hello world&gt;
== "&lt;hello world&gt;"

&gt;&gt; mold &lt;hello world&gt;
== "&lt;hello world&gt;"
</code></pre>
<p>What if you don't want delimiters on your TAG!s and such?  Well... for any string-ish type, thanks to UTF-8 we have a <em>super efficient</em> operation called AS TEXT! which aliases any type as a string.  It reuses the memory:</p>
<pre><code>&gt;&gt; tag: &lt;hello world&gt;

&gt;&gt; text: as text! &lt;hello world&gt;
== "hello world"

&gt;&gt; append tag "ly Ren-C user"
== &lt;hello worldly Ren-C user&gt;

&gt;&gt; text
== "hello worldly Ren-C user"
</code></pre>
<p>You can use it on ANY-WORD! as well, and it will give you a read-only string... and not have the sigils:</p>
<pre><code>&gt;&gt; as text! '$var
== "var"
</code></pre>
<p>I have an inkling that over the subset of operations to which you can use both TO and AS, that you should get the same result... just a copy:</p>
<pre><code>&gt;&gt; tag: &lt;hello world&gt;

&gt;&gt; text: to text! &lt;hello world&gt;  ; TO TEXT!, not AS TEXT!
== "hello world"

&gt;&gt; append tag "ly Ren-C user"
== &lt;hello worldly Ren-C user&gt;

&gt;&gt; text
== "hello world"
</code></pre>
<h2>
<a name="so-form-adds-delimiters-and-toas-text-does-not-1" class="anchor" href="https://forum.rebol.info#so-form-adds-delimiters-and-toas-text-does-not-1"></a>So FORM adds delimiters, and TO+AS TEXT! Does Not...</h2>
<p>...BUT...let's go back:</p>
<pre><code>&gt;&gt; form "hello world"
== "hello world"

&gt;&gt; form &lt;hello world&gt;
== "&lt;hello world&gt;"
</code></pre>
<p>Why again is FORM a no-op on text, but adds delimiters to tags?</p>
<h2>
<a name="and-how-about-blocks-2" class="anchor" href="https://forum.rebol.info#and-how-about-blocks-2"></a>And How About Blocks?</h2>
<p>The block behavior of FORM historically strikes me as not terribly useful:</p>
<pre><code>rebol2/red&gt;&gt; form [I am [:a "block" that:] &lt;is&gt; (being formed)]
== "I am a block that &lt;is&gt; being formed"

r3-alpha&gt;&gt; form [I am [:a "block" that:] &lt;is&gt; (being formed)]
== "I am :a block that: &lt;is&gt; being formed"
</code></pre>
<p>How often do you want to take a bunch of material and throw away decorations from some of it, and flatten out all the lists with no processing but spaces?</p>
<p>I don't think I've ever used that.  I see more use in MOLD SPREAD, which it seems like R3-Alpha was edging toward and didn't quite get there.</p>
<pre><code>&gt;&gt; mold spread [I am [:a "block" that:] &lt;is&gt; (being "formed")]
== {(I am :a "block" that: &lt;is&gt; (being "formed"))}
</code></pre>
<h2>
<a name="who-is-calling-form-and-why-are-they-calling-it-3" class="anchor" href="https://forum.rebol.info#who-is-calling-form-and-why-are-they-calling-it-3"></a>Who is Calling FORM (and why are they calling it?)</h2>
<p>The variance in behaviors across R3-Alpha and Red show what is usually true when you see variation--<em>people don't know why the thing exists, find out it has random behavior, then avoid using it in favor of other things</em>.</p>
<p>Most uses seem to be turning WORD! to string, and turning TAG! to string with some assurance it will have the delimiters on it.  Nobody really uses it on blocks.</p>
<p>I don't yet have a complete answer for either getting rid of it, or defining it rigorously.  But I'm going to start paying more attention to it.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/the-meaning-of-the-form-string-operation/2288">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-meaning-of-the-form-string-operation/2288</link>
          <pubDate>Fri, 20 Sep 2024 09:16:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2288</guid>
          <source url="https://forum.rebol.info/t/the-meaning-of-the-form-string-operation/2288.rss">The Meaning of the FORM String Operation</source>
        </item>
        <item>
          <title>Making FAIL Stand Out With Antiform TAG!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2278">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"><a href="https://forum.rebol.info/t/tripwire-in-the-wild/2278/1">TRIPWIRE in The Wild</a></div>
<blockquote>
<p>But with <strong><a href="https://forum.rebol.info/t/antiform-tag-as-triggers-an-error-on-access-type/2170">antiform tags</a></strong>, you can embed a message into the unset variable:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; state: ~&lt;INITIALIZE-STATE hasn't been called yet&gt;~

&gt;&gt; state
** Script Error: state is ~&lt;INITIALIZE-STATE hasn't been called yet&gt;~ antiform
** See ^(...) and GET/ANY
</code></pre>
</blockquote>
</aside>
<p>I have another use of TRIPWIRE that I don't know if it's good or bad, but...</p>
<hr>
<p>I've always wanted FAIL to stand out more.  When it first was invented (and Ren-C was case-insensitive), I would type FAIL in uppercase to get it:</p>
<pre><code>foo: func [x [integer! text!]] [
    switch/type x [
        integer! [print "It's an integer"]
        text! [print "It's a text"]
        FAIL "unreachable"
    ]
]
</code></pre>
<p>Then I came up with the idea to use QUASI-WORD!s (that would evaluate to antiform words):</p>
<pre><code>foo: func [x [integer! text!]] [
    switch/type x [
        integer! [print "It's an integer"]
        text! [print "It's a text"]
        fail ~unreachable~
    ]
]
</code></pre>
<p>I thought it looked cool and drew attention more than <strong><code>fail "unreachable"</code></strong>, while being the same number of characters.  It acted the same, but cost a bit less due to the interning of the word.</p>
<p>But now, <a href="https://forum.rebol.info/t/renaming-antiword-time-to-call-it-keyword/2277">"keywords" are restricted to a finite system set</a>.   So by necessity, this has changed to use quasiform/antiform TAG!s:</p>
<pre><code>foo: func [x [integer! text!]] [
    switch/type x [
        integer! [print "It's an integer"]
        text! [print "It's a text"]
        fail ~&lt;unreachable&gt;~
    ]
]
</code></pre>
<p>Now it's two more characters, doesn't cost any less than a string, and at the moment still acts the same as a string.  Is it still a useful thing?  Compared with:</p>
<pre><code>foo: func [x [integer! text!]] [
    switch/type x [
        integer! [print "It's an integer"]
        text! [print "It's a text"]
        fail "unreachable"
    ]
]
</code></pre>
<p>I truly like that you can "see" the error better when it's <strong><code>~&lt;unreachable&gt;~</code></strong>...and go "oh, there's an error there".  I imagine this being particularly cool with syntax highlighting.</p>
<p>To make that visibility advantage systemic, would it be reasonable to say that all FAILs take antiform tags and not strings?  Then if you have a message in a text string you would have to say <strong><code>fail [msg]</code></strong> instead of just <strong><code>fail msg</code></strong>.  I don't think that's terribly oppressive.</p>
<p>I don't completely like the idea of it being a choice/synonym, because then people will just stylize their code differently and inconsistently...the same person even making different choices in the same file.  But it could just be a synonym and let you pick what you like for the situation, and maybe that's good.</p>
<p>Or maybe it's a dumb feature.  I don't know.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/making-fail-stand-out-with-antiform-tag/2282">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/making-fail-stand-out-with-antiform-tag/2282</link>
          <pubDate>Mon, 16 Sep 2024 13:31:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2282</guid>
          <source url="https://forum.rebol.info/t/making-fail-stand-out-with-antiform-tag/2282.rss">Making FAIL Stand Out With Antiform TAG!</source>
        </item>
  </channel>
</rss>

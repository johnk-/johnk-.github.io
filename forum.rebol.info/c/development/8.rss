<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Development - AltRebol</title>
    <link>https://forum.rebol.info/c/development/8</link>
    <description>Topics in the &#39;Development&#39; category Discussion of the development of Rebol itself: language design, implementation and standard library.</description>
    
      <lastBuildDate>Tue, 25 Oct 2022 04:07:17 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/8.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>The concept of having isotopic <strong>~true~</strong> and <strong>~false~</strong> as WORD! isotopes instead of having a distinct LOGIC! type is admittedly somewhat weird.  It means they can't be put in blocks and need some sort of transformation if they're going to be put into blocks.</p>
<ul>
<li>
<p>The generic and reversible way to make them real it is to META them and get <code>~true~</code> and <code>~false~</code> quasiforms, which you can UNMETA back to the isotopes</p>
</li>
<li>
<p>The readable way to make them real is to REIFY them and get <code>true</code> and <code>false</code> as plain WORD!, which only gets turned back into the isotope form if they are bound to variables that hold the isotopes, and you evaluate them.</p>
</li>
<li>
<p>Your circumstance may mean that neither of those choices are what you want when in a situation where the isotopes can't work...maybe it means you have to rethink what you're doing, or maybe you want some other transformation.  It's good to be alerted to the fact that it's dodgy to put what you think of as a "logic" in a reified context.</p>
</li>
</ul>
<p>One should note that Lisp has no false at all, only NIL for false (since everything else is truthy, you could use anything else for true, but they have T predefined).  But their NIL isn't isotopic--so it can appear in lists literally.</p>
<p>And as I've repeatedly pointed out, Redbol's historical choice to render LOGIC! conflated with the words <code>true</code> and <code>false</code> (instead of <code>#[true]</code> and <code>#[false]</code>) shows a desire to avoid the logic literals "escaping" into the reified consciousness of the user.  Making the logic forms actually impossible to put into blocks without a conscious transformation feels like it's good.</p>
<p>I know it's a strange choice, but it's seeming like it fits with the territory.  It's a sort of tradeoff you need when you choose to be firm that TRUE and FALSE are redefinable words and not lexical forms of logic constants.</p>
<h2>So... Why Shouldn't NULL Be Done With <code>~null~</code> isotope ?</h2>
<p>Right now what I call "null" is isotopic BLANK!.  It is not pretty looking:</p>
<pre><code>&gt;&gt; null
== ~_~  ; isotope

&gt;&gt; _
== ~_~  ; isotope
</code></pre>
<p>But what <em>is</em> pretty looking is that if you assign a bunch of variables to null, the fact that blanks evaluate to the null isotope gives a great visibility to where the actual values to pay attention to are:</p>
<pre><code>obj: make object! [
    alpha: _
    beta: _
    delta: true
    epsilon: ~
    gamma: "nutty"
    rho: _
    omega: 'now
 ]
</code></pre>
<p>If we used a word isotope, then at source level we're writing:</p>
<pre><code>obj: make object! [
    alpha: null
    beta: null
    delta: true
    epsilon: ~
    gamma: "nutty"
    rho: null
    omega: 'now
 ]
</code></pre>
<p>And if we view it after evaluation that fetches (<code>null</code> =&gt; <code>~null~  ; isotope</code>), it gets uglier:</p>
<pre><code>make object! [
    alpha: ~null~
    beta: ~null~
    delta: ~true~
    epsilon: ~
    gamma: "nutty"
    rho: ~null~
    omega: 'now
 ]
</code></pre>
<p>We can't show it as the WORD! null because there's no guarantee that word always will evaluate back to the null isotope.  But the concept is that since BLANK! can't be redefined, we can put it in an evaluative context as a substitute for <code>~_~</code> if we want.</p>
<p>If we were "more honest" and just META'd the isotopic blank, we'd get renders like:</p>
<pre><code>make object! [
    alpha: ~_~
    beta: ~_~
    delta: ~true~
    epsilon: ~
    gamma: "nutty"
    rho: ~_~
    omega: 'now
 ]
</code></pre>
<p>But I might actually like that less than seeing <strong><code>~null~</code></strong> there.</p>
<h2>Things To Weigh In This Consideration</h2>
<p>I'm really torn.  Certainly having people be able to see ~null~ written out as a word corresponds to what we want to refer to the state as.  We aren't going to replace people's vernacular to say "isotopic blank" instead of null.  And trying to teach people "isotopic blank is null" is an uphill battle.</p>
<p>Let's look back at that seemingly beautiful situation with all the blanks-to-nulls at source level:</p>
<pre><code>obj: make object! [
    alpha: _
    beta: _
    delta: true
    epsilon: ~
    gamma: "nutty"
    rho: _
    omega: 'now
 ]
</code></pre>
<p>But, hmmm.  The <strong><code>~</code></strong> is now an assignable state meaning variable is not set.  How often will you want to set something to NULL...which won't generate an error on access like being unset would, but is falsey and can't be passed to many routines without a MAYBE?</p>
<p><strong>Statistically, we might often have a situation where NULL is the minority initialization, more like this:</strong></p>
<pre><code>obj: make object! [
    alpha: ~
    beta: ~
    delta: true
    epsilon: null
    gamma: "nutty"
    rho: ~
    omega: 'now
 ]
</code></pre>
<p>My point is that intentionally initializing things to null may not be as common as setting to an error-provoking unset state.  And when null happens it may be just as noteworthy to call out as setting something to true or false.</p>
<h2>Are There Technical Barriers To This?</h2>
<p>It has some of the same problems as having to deal with the type checking of LOGIC! actually being an isotopic subclass of two words.  It means <code>&lt;opt&gt;</code> is an isotopic subclass of one word, so there's no specific null datatype.  :-/</p>
<p>I was already saying that TYPE OF NULL was probably an error, and TYPE OF MAYBE NULL would be void... anyway, this fits into some of the same type issues that logic has.</p>
<p>Previously NULL cells held nothing, so I'd put a payload of the file and line that were in effect in the evaluator.  This was supposed to give better errors about where a null originated from.  This could still be done if NULL was a special case of WORD! isotope that said it was null via a flag vs. storing the symbol, but could be complicated.  None of the better error mechanics were done yet.</p>
<p><strong>My general intuition is that from a user's standpoint, it's an uphill battle to teach them isotopic blank is something called "null"... and that the majority of technical problems that are involved in making NULL be a word isotope are problems that have to be tackled anyway with true and false as word isotopes.</strong></p>
<p>Additionally, I've written about my desire for BLANK!s to serve in dialects as spaces.  That gets very screwed by the (<strong><code>_</code></strong> =&gt; <strong><code>~_~</code>  ; isotope</strong>) evaluation.  Recovering blank for space intent would be good.</p>
<p>I'm going to likely give it a shot, when I get some programming time again, hopefully soon.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989</link>
          <pubDate>Tue, 25 Oct 2022 04:07:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1989</guid>
          <source url="https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989.rss">~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</source>
        </item>
        <item>
          <title>Haskell and Rust Error Handling</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Ren-C is shoring up Rebol's historically problematic exception-based error handling by blending together two mechanics: definitional returns and isotopic errors.  This gives what I'm calling "definitional failures":</p>
<p><a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852" class="inline-onebox">FAIL vs. RETURN RAISE: The New Age of Definitional Failures!</a></p>
<p>Pivoting to this line of thinking has some non-accidental similarity to <a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Data-Either.html">Haskell's <code>Either</code></a> and <a href="https://doc.rust-lang.org/std/result/">Rust's <code>Result</code></a>, which I mentioned when first sketching out the motivation for change:</p>
<p><a href="https://forum.rebol.info/t/the-need-to-rethink-error/1371" class="inline-onebox">The Need To Rethink ERROR!</a></p>
<p>I thought it would be worth it to make a thread for pointing out similarities and differences, and if there are libraries they use that might have relevant inspiration.</p>
<h2>An Out-Of-Band State On The Value Is... Like An Isotope?</h2>
<p>Either is fully generic beyond just allowing errors (and <a href="https://docs.rs/either/latest/either/">Rust has its own generic Either</a> as well).  So you can really say whatever you are returning can come in two forms: the left form vs. the right form.</p>
<p>But even Rust's <code>Result</code> container will permit you to make an Error class the "valid" result, as well as the "invalid" result.</p>
<p>So here we see generic way of letting a value carry a bit--independent of what the payload is--saying whether that is a "normal" state or a "weird" state.  Then, the system has an assortment of operations that are designed for directing program flow in different ways reacting to it.</p>
<p>Ren-C embraces this deeply: effectively saying that every variable and expression product has the potential of being in this "weird" state... and <em>no array can contain a value in the weird state</em>.  But you don't have to do anything special to a value that <em>isn't</em> weird to extract it... you just get runtime errors if you use the weird values where they're not expected.</p>
<h2>Rust Tackles Low-Hanging Fruit via <code>unwrap()</code> and <code>?</code>
</h2>
<p>In Ren-C, if you don't have handling at the callsite when a definitional error happens, it's promoted to being more like a throw--and most code should not intercept it.</p>
<p>Being more formal by nature, both Haskell and Rust force <em>some</em> handling at the callsite when an error result is possible.  You have to define a code path to take if there's an error, or a code path to take if there's not.</p>
<p>But Rust has a couple of conveniences.  If you want something like the Ren-C behavior, you can just call the <code>.unwrap()</code> method on the result.  It will give you the ordinary value if the function didn't return, otherwise raise the error as a "panic".</p>
<p>There's also a cool shortcut with a postfix operator of <strong>?</strong> on the call.  This makes it so that if you call a function that returns a <code>Result</code> type from inside another function that returns a <code>Result</code> type, it will automatically propagate the result if it's an error out of the calling function.</p>
<p>Getting this behavior is more laborious in Ren-C:</p>
<pre><code>foo: func [...] [
    x: bar (...) except e -&gt; [return raise e]
    ...
]
</code></pre>
<p>Implementing the feature as postfix raises its own problems, so let's just imagine we were trying it prefix:</p>
<pre><code>foo: func [...] [
    x: ? bar (...)  ; we want this to act the same as above
    ...
]
</code></pre>
<p>For this to work under the current system, each FUNC would have to define its own <strong>?</strong> operator... because much like definitional RETURN, it would have to know what it was returning <em>from</em> in case of a raised error.</p>
<h2>Haskell Has Generic Compositional Smarts</h2>
<p>As mentioned, the strict compile-time typing in Haskell forces you to be explicit about your reaction when a function returns one of these <code>Either</code> values.</p>
<p>But because Either fits in with monadic/applicative/functor stuff, you can have higher-order operations that <a href="https://lhbg-book.link/06-errors_and_files/01-either.html">can compose together</a> failure scenarios...and gather up failures from several functions or cascade the failure through to where you want.</p>
<p>Ren-C can do this kind of thing as well, such as how you can write higher-order functions like ATTEMPT in usermode, or REDUCE a block of values in one pass with META and get the errors, then react to them later.</p>
<p>But in practice, the lack of a static type system makes this more precarious.</p>
<h2>Links To Error Handling Libraries</h2>
<ul>
<li>Rust's ANYHOW!: <a href="https://docs.rs/anyhow/">https://docs.rs/anyhow/</a>
</li>
</ul>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/haskell-and-rust-error-handling/1987">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/haskell-and-rust-error-handling/1987</link>
          <pubDate>Sun, 16 Oct 2022 02:17:44 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1987</guid>
          <source url="https://forum.rebol.info/t/haskell-and-rust-error-handling/1987.rss">Haskell and Rust Error Handling</source>
        </item>
        <item>
          <title>Arrays For Composite Types</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <h2>First, There Was Quote "Protection"...</h2>
<p>An operating premise has been that this would be bad:</p>
<pre><code>&gt;&gt; (type of first [''a]) = (type of first [''''(x y z)])
== #[true]
</code></pre>
<p>You've got a double-quoted word going in on the left, and a quadruply-quoted group going in on the right.  They're both instances of QUOTED! but is it in any way useful to say they're the same type?</p>
<p>Of course, we do this with BLOCK! and don't blink:</p>
<pre><code>&gt;&gt; (type of [[a]]) = (type of [[[[(x y z)]]]])
== #[true]
</code></pre>
<p>We only look at the outermost container.</p>
<p>But following precedent from where LIT-PATH! and LIT-WORD! were seen as different types, the concept of folding not just quotedness but the actual quoting level into the type arose.</p>
<p>At first, Ren-C did a fairly cheap thing, by quoting the answer of TYPE OF by the number of quotes:</p>
<pre><code>&gt;&gt; type of first [a]
== #[datatype! word!]

&gt;&gt; type of first [''a]
== ''#[datatype! word!]
</code></pre>
<p><strong>But that won't be recognized as a DATATYPE!, because it's a QUOTED!</strong></p>
<p>This matters if you try something like:</p>
<pre><code>&gt;&gt; quoted-word!: first [''#[datatype! word!]]

&gt;&gt; did parse [''a] [quoted-word!]
== #[false]

&gt;&gt; did parse ['#[datatype! word!]] [quoted-word!]
== #[true]
</code></pre>
<p>The problem here is that PARSE already has an idea of how it handles QUOTED!s, e.g. to match something that is one quoting level lower than that thing.  So this quoted datatype isn't acting how you intended.</p>
<h2>So I Suggested Arrays To Wrap Quoted Types</h2>
<p>When the idea of using &amp;[...] arrays to represent types came along, I suggested this could be a solution:</p>
<pre><code>&gt;&gt; type of first [a]
== &amp;[word]

&gt;&gt; type of first [''a]
== &amp;[''word]
</code></pre>
<p>This gives us the nice properties we want of making these distinct "types" for purposes of comparison, while still both being of the same fundamental type for purposes of dispatch.</p>
<h2>Might Type Arrays Have Other Parameters?</h2>
<p>We could ask if all of these type arrays are just one element long--where that element is always a WORD!, quoted WORD!, or quasi WORD!...</p>
<p>Or might they have other parameters in them?  Would a vector say what they were vectors of:</p>
<pre><code> &gt;&gt; type of vec
 == &amp;[vector int32]
</code></pre>
<p>Would a matrix have its dimensions?</p>
<pre><code>&gt;&gt; type of mat
== &amp;[matrix (32 32)]
</code></pre>
<p>I've suggested that the narrower question of KIND might come back with a simpler answer:</p>
<pre><code>&gt;&gt; kind of mat
== &amp;matrix</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/arrays-for-composite-types/1979">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/arrays-for-composite-types/1979</link>
          <pubDate>Sun, 25 Sep 2022 00:48:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1979</guid>
          <source url="https://forum.rebol.info/t/arrays-for-composite-types/1979.rss">Arrays For Composite Types</source>
        </item>
        <item>
          <title>What Should TYPE OF an Isotope Be?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>At this exact moment...TYPE OF any isotope is an error, while both TYPE OF NULL and TYPE OF VOID give back NULL.</p>
<p>OF is a generic operation (the enfix form of REFLECT that quotes the word on its left.  It may be desirable to honor the VOID-in-NULL out convention for all the other reflectors that aren't TYPE... and it's desirable to error on NULL more generically.</p>
<pre><code>&gt;&gt; label of null
** Error: You didn't give anything

&gt;&gt; label of maybe null  ; MAYBE NULL is VOID 
; null
</code></pre>
<p>So if <strong>type of</strong> follows the same pattern as other <strong>xxx of</strong>, we'd surmise that you don't use TYPE OF to discern NULL and VOID.  It errors on NULL input and gives you back NULL if you MAYBE it.</p>
<p>But what happens when you ask:</p>
<pre><code>&gt;&gt; spread [d e]
== ~(d e)~  ; isotope

&gt;&gt; type of spread [d e]
???
</code></pre>
<h2>The Original Plan Was <em>No</em> Arguments Received Isotopes</h2>
<p>In the original conception, function frames weren't capable of holding isotopes in the arguments.  You physically could not receive a parameter that was an isotope.</p>
<p>I was also looking at the idea that some isotope forms--such as isotopic ERROR!--would be completely impossible to get into a variable, <em>ever</em>.</p>
<p>The only workaround was if a function used the ^META parameter convention, in which case an isotope would come in as a QUASI! form of the value...while normal values would come in as quoted:</p>
<pre><code> &gt;&gt; detector: func [^x] [print ["Meta of X:" mold x]]

 &gt;&gt; detector [d e]
 Meta of X: '[d e]

 &gt;&gt; detector spread [d e]
 Meta of X: ~(d e)~
</code></pre>
<p>Ultimately I backed down on this, instead allowing you to use type filtering to narrow which isotopes you'd be willing to accept:</p>
<pre><code>&gt;&gt; splicetaker: func [x [any-value! ~group!~]] [
       append [a b c] :x
   ]

&gt;&gt; splicetaker [d e]
== [a b c [d e]]

&gt;&gt; splicetaker spread [d e]
== [a b c d e]
</code></pre>
<p>So this creates a new typeset feature that is hacked in terribly <em>(the presence of any ~xxx!~ currently means the same thing as ~any-value!~, but it's documentation for when the feature gets better)</em>.  And it means that the ^META parameter convention is basically something that can be implemented on top of this, by doing something like <strong><code>x: my meta</code></strong> at the beginning of the function.</p>
<p>A primary driver behind this change was that operations which wanted to do things like ADAPT a function frame were having to become sensitive to whether a parameter was ^META or not, and it was more of a headache than having to use the <strong>:get-word</strong> accessors on variables.  It seemed that standardizing the frame in a way that permitted isotopes as currency made more sense than having arguments be sometimes-meta'd, sometimes not.</p>
<h2>What if OF (REFLECT) Didn't Take Isotopes?</h2>
<p>So we could say that if you think you have an isotope in your hand, you're responsible for ^META-ing it yourself:</p>
<pre><code>&gt;&gt; metatyper: func [x [any-value! ~group!~]] [
       print ["Metatype of X is" type of ^x]
   ]

&gt;&gt; metatyper [d e]
== @['block]  ; the TYPE OF received a QUOTED!, so e.g. answer incorporates quoted

&gt;&gt; metatyper spread [d e]
== @[~block~]  ; got QUASI!, so TYPE OF answer incorporates quasi
</code></pre>
<p>On the plus side of such an approach, we don't have to invent any type representations for isotopes.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/what-should-type-of-an-isotope-be/1983">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-should-type-of-an-isotope-be/1983</link>
          <pubDate>Sat, 24 Sep 2022 10:23:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1983</guid>
          <source url="https://forum.rebol.info/t/what-should-type-of-an-isotope-be/1983.rss">What Should TYPE OF an Isotope Be?</source>
        </item>
        <item>
          <title>Experiences While Paring Down DATATYPE!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>You likely know that DATATYPE! in R3-Alpha (Rebol 2, Red...) has a distinct "type byte" in the cell.  So you can tell it's a different thing, even if not all representations show that:</p>
<pre><code>r3-alpha&gt;&gt; block: reduce ['integer! integer!]
== [integer! integer!]

r3-alpha&gt;&gt; type? first block
== word!

r3-alpha&gt;&gt; type? second block
== datatype!
</code></pre>
<p>One way R3-Alpha has to see the difference is with MOLD/ALL</p>
<pre><code>r3-alpha&gt;&gt; mold/all block
== "[integer! #[datatype! integer!]]"
</code></pre>
<h2>But What's Actually <em>in</em> a DATATYPE! Cell?</h2>
<p>This was <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/include/sys-value.h#L106">the definition struct from R3-Alpha</a>:</p>
<pre><code>typedef struct Reb_Type {
    REBINT type;  // base type
    REBSER *spec;
    // REBINT min_type;
    // REBINT max_type;
} REBTYP;
</code></pre>
<p>So an integer to say what <strong><code>type</code></strong> it is (e.g. REB_INTEGER = 1, REB_LOGIC = 2, REB_BLOCK = 3 or whatever).  Note that this in the <em>payload</em> of the cell, not the header...because the type in the header is REB_DATATYPE to say it carries a "datatype payload".</p>
<p>Who knows what the commented-out <strong><code>min_type</code></strong> and <strong><code>max_type</code></strong> were.  But a remark says this payload is for a "Datatype or pseudo-datatype".  We can guess these were for pseudo-datatypes as a way of specifying a range of REB_XXX numbers to implement categories like ANY-SERIES!, as an alternative to typesets (?)</p>
<p>The <strong><code>spec</code></strong> is actually an object, that comes back as the answer to SPEC-OF:</p>
<pre><code>r3-alpha&gt;&gt; spec-of integer!
== make object! [
    title: "64 bit integer"
    type: 'scalar
]
</code></pre>
<p>This limited amount of information was built into the executable from the <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/boot/typespec.r#L24">Rebol-format table table in %typespec.r</a>.</p>
<p>You needed to use SPEC-OF to access these properties, but it could have been accessible with paths, e.g. <strong>integer!/title</strong>.  And it might have had more interesting properties:</p>
<pre><code>&gt;&gt; integer!/max-value
== 9223372036854775807
</code></pre>
<h2>Ren-C Had Actually Added More To DATATYPE!...</h2>
<p>Builtin types use a byte for the type in cells of the instances of values of that type.  This byte would index a static table of handlers that implement the datatype.  That would limit to you to 256 types...although for technical reasons the limit was actually 64.</p>
<p>Ren-C pushed <a href="https://forum.rebol.info/t/user-defined-datatype-discussion/1203/2">toward an implementation of extension types</a>.  This made it so if that byte was a special signal of "CUSTOM", it meant the implementation cells for that type must surrender one of their 4 platform-pointer-sized slots for a pointer to the method table.</p>
<p>A cool aspect of this generalization was that two bits in the cells started being used to flag whether the 2 out of the 4 remaining slots in the cell needed to be marked by the GC.  This generalized garbage collection to where a cell could be marked without having to customize the garbage collector for its type byte.  It just had to speak in the currency of "nodes".</p>
<p><em>(Doing this in a way that honors C's rules about strict aliasing was a little tricky, but possible.)</em></p>
<h2>All Redbols Conflated The Looks of DATATYPE! and WORD!</h2>
<p>In lockstep, they all did it:</p>
<pre><code>rebol2&gt;&gt; integer!
== integer!

r3-alpha&gt;&gt; integer!
== integer!

red&gt;&gt; integer!
== integer!
</code></pre>
<p>Since I have Boron built, I find it renames integer! to int!, but otherwise the same:</p>
<pre><code>)&gt; int!
== int!

)&gt; type? int!
== datatype!

)&gt; type? first [int!]
== word!
</code></pre>
<p><strong>It seemed to me that this conflation couldn't possibly be the best answer.</strong>  So I made Ren-C buck this trend to use the R3-Alpha construction syntax, because it was something that could LOAD back:</p>
<pre><code>&gt;&gt; integer!
== #[datatype! integer!]

&gt;&gt; load "#[datatype! integer!]"
== [#[datatype! integer!]]
</code></pre>
<p><strong>Rendering differently was good, but the specific different rendering wasn't all that palatable.</strong>  And it wasn't showing it as any complex object.</p>
<p>There seemed to be two directions to go with this:</p>
<ul>
<li>
<p>Accept DATATYPE! as some kind of alien complex type which has ugly rendering</p>
</li>
<li>
<p>Fit it into the lexical space somewhere.</p>
</li>
</ul>
<p>If it was going to be in the lexical space, that would mean the type would likely be coming from a symbol-bearing type.</p>
<h2>Paring It Down: Making DATATYPE! Hold Only A Symbol</h2>
<p>Ren-C doesn't use integers to refer to symbols like R3-Alpha and Red.  Instead, symbol table entries are series...like strings, which now hold UTF-8 data even when mutable.  (Frequently they are compact strings, whose UTF-8 spelling data fits in the space where tracking information for an allocation would live if an allocation were needed.)</p>
<p>So WORD! cells use pointers to refer to their symbols.  Despite that, <em>some</em> built-in symbols still are numbered.  These symbols have space statically allocated vs. allocated as series from the heap, and they can be indexed by number quickly.  Also, the symbols store their (16-bit) number in the series stub so you can go the other direction...from symbol to number.</p>
<p>The first 64 or so symbols are specifically chosen to be things like INTEGER!.  This means if a datatype just stored a symbol, it's easy to use that number to index into the builtin-type-hooks table.</p>
<p>If you refer to extension types by some arbitrary symbol which isn't predicted in those first 64 symbols, then it would likely have no number at all.  So with a DATATYPE! in your hand and that symbol, you'd have to look some extension type mapping table to get the hooks for that type.</p>
<p><em>But</em> I mentioned that instances of extension types gave up one of their 4 cell pointers to indicate this table.  And usually you need the dispatch table when you have an instance--not the datatype--so this isn't much of a problem.</p>
<h2>For Now, DATATYPE! Renders With An &amp;</h2>
<p>One step removed would be to say that as today, the WORD-ending-in-! is a layer of indirection over concrete types that use a sigil like &amp;.  This has been pitched as perhaps looking like:</p>
<pre><code>integer!: &amp;integer

any-word!: &amp;[word set-word get-word the-word meta-word]

is-even!: &amp;(#[action! {even?} [value]])
</code></pre>
<p>But the details are still being worked out.</p>
<p>What I will say is just that I think going in the direction toward where DATATYPE! goes toward "just being a symbol" and having everything else looked up feels correct.</p>
<p>I don't think making DATATYPE! itself a complex object was a direction we wanted to go further in.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/experiences-while-paring-down-datatype/1978">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/experiences-while-paring-down-datatype/1978</link>
          <pubDate>Sat, 24 Sep 2022 08:02:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1978</guid>
          <source url="https://forum.rebol.info/t/experiences-while-paring-down-datatype/1978.rss">Experiences While Paring Down DATATYPE!</source>
        </item>
        <item>
          <title>Boot Footprint: Giant String Literal vs. Encap?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p>One thing you can do with C is embed literal data.  This is how R3-Alpha ships with its mezzanine functions "built in", the prep process stores everything in a big compressed array of bytes called (misleadingly) <strong><code>Native_Specs</code></strong>:</p>
<p><a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/b-init.c#L166">https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/b-init.c#L166</a></p>
<p>The name being <code>Native_Specs</code> might suggest it was the contents of <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/boot/natives.r">%natives.r</a>.  But it's actually a lot more, with glued-together source code... including all of the contents of the <a href="https://github.com/rebol/rebol/tree/master/src/mezz">%base-xxx.r, %sys-xxx.r, and %mezz-xxx.r</a> files.  So I renamed it to <code>Boot_Block_Compressed</code>.</p>
<p>But it doesn't embed the files as-is... it LOADs them and SAVEs them using an already-built version of R3.  This round-tripping removes the comments and normalizes the spacing.  It also actually scrambled it with CLOAK for whatever reason--a waste of time because you could read all the code with SOURCE if you felt like it.  :-/</p>
<p><em>(Ren-C doesn't use an old-R3's LOAD+SAVE to strip out comments, because it would lock down the format.  Your hands would be tied on adding or changing lexical forms in the sys/base/mezzanine.  So it has its own STRIPLOAD function that does a light stripping out of comments and spaces for this glue-files-together purpose)</em></p>
<h2>Is Embedding Big Fat C Constants Supported By The Standard?</h2>
<p>C compilers are only <em>required</em> to allow you to build in string literals that are <a href="https://stackoverflow.com/a/11488687">509 characters in C89, and 4095 characters in C99</a>.  They can allow more, but don't have to.</p>
<p>So I recall R3-Alpha having problems when you turn up <code>--pedantic</code> warning levels by using a syntax like:</p>
<pre><code>const char Native_Specs[] = "\x01\x02\x03...";
</code></pre>
<p>That warning went away when I changed it to:</p>
<pre><code>const unsigned char Boot_Block_Compressed[] = { 0x01, 0x02, 0x03 ...};
</code></pre>
<p>Regarding the problem of hitting length limits, Ren-C actually breaks things up a bit more...because each extension has its own constant declaration like this for its Rebol portion.</p>
<p>Because this code is decompressed and scanned once--and then tossed--there's probably a number of experiments that could be done.  What if the blob were loaded as mutable data, and then used as some kind of buffer for another purpose?  Is there some way to help hint to the OS that you really are only going to use the information only once so it will throw out the page from memory?  Or will the right thing happen to scan it and use it just once?</p>
<p>Long story short--it hasn't been a problem, even with the TCC build.  So it has been taken for granted that it works acceptably.</p>
<h2>But Would Encapping Be Better?</h2>
<p>One vision of how the boot would work is that it would only load enough to get de-encapping working.  Then the de-encapping would be how all the blobs for the "built-in" extensions were extracted.</p>
<p><em>This seems like an interesting vision,</em> because if someone gave you a big fat Ren-C and you wanted any skinnier version, you could basically ask it to cut everything out you don't want and give you a new EXE.  You could roll it up with any customizations you like.</p>
<p>But if you're using any "real" form of encapping (e.g. manipulating the resource portions of a Linux ELF file or a Windows PE file) this gets complicated.  And Ren-C's encap facilities are <a href="https://github.com/metaeducation/ren-c/blob/master/scripts/encap.reb">written in usermode</a>...so that expects things like file I/O and PARSE of a BINARY!, etc.  I also assume that unzip facilities would be part of encapping.  So you need a reasonably runnable system just to get to that point.</p>
<p><strong>I've punted on worrying too much about this, because of the focus on the web build.</strong></p>
<p>It would be a bad investment of limited resources to handwrite and maintain encapping code in C, just so that encapping can be the means by which more of the bootstrap can be done with encap.</p>
<h2>Script Code Is Easy to Encap, EXE/DLL Code Is Not</h2>
<p>So the "easy" part would be changing the build to go in two steps.</p>
<p>The first step would make an r3-one.exe that is capable of augmenting itself with encapped data.  The second step would ask that r3 to fold in various scripts and resources to make an r3-two.exe that had more things in it...such as a console.</p>
<p>This isn't that far out to accomplish.  <strong>The hard part is when what you're encapping isn't script data, but compiled and executable C code...like bits from a DLL.</strong>  e.g. encapping "extensions".</p>
<p>What some people do in this situation is to actually glue the DLL file into the executable, but extract it to the filesystem and load the extracted version.  If you Google around for "using a DLL as an embedded resource" you'll find people who've done such things...but the answers you find will be from over a decade ago, because no one cares about how they ship such things anymore.</p>
<h2>Making Encap A Dependency Is Probably Unwise...</h2>
<p>It isn't going to be a terribly big win for bootstrap if it can't be used to pull out or put in extensions.</p>
<p>I don't think it's wise to pursue handcrafted C de-encapping.  In fact there's no way I'd be writing any kind of encap code right now if it weren't already made.  Kind of the only reason we have the usermode encapping around is because Atronix was using it, but I was trying to keep the feature but cut it out of the C.  It hasn't been tossed entirely because it functions as test code.</p>
<p>We <em>could</em> make a token two-step build (the phase one executable, that uses the phase one to build a phase two with encapped data in it).</p>
<p>But it seems what we might want more is an easy option to not build in encapping whatsoever, and have more control over options at build time than the current list of extensions.</p>
<p>For the limited audience looking at desktop builds--I imagine the answer will be that if you want a differently-sized r3.exe, you do it with a C compiler and ticking different boxes.  Or you build everything as a DLL and accept it's not all one file.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/boot-footprint-giant-string-literal-vs-encap/1977">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/boot-footprint-giant-string-literal-vs-encap/1977</link>
          <pubDate>Sat, 24 Sep 2022 01:57:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1977</guid>
          <source url="https://forum.rebol.info/t/boot-footprint-giant-string-literal-vs-encap/1977.rss">Boot Footprint: Giant String Literal vs. Encap?</source>
        </item>
        <item>
          <title>What If &quot;DATATYPE&quot; Was Isotopic (TL;DR: Bad Idea)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="1300">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>We now have isotopic types to sort out issues with nonliteral matching.</strong> So we could say:</p>
<pre><code>&gt;&gt; find ["a" @[integer!] 1 "b"] @[integer!]
== [@[integer!] 1 "b"]

&gt;&gt; matches @[integer!]
== ~@[integer!]~  ; isotope

&gt;&gt; find ["a" @[integer!] 1 "b"] matches @[integer!]
== [1 "b"]
</code></pre>
</blockquote>
</aside>
<p>Hey.  Waitasec...</p>
<p>...an unexplored idea here is if isotopic datatypes aren't just the <em>"I mean match the datatype, don't look for it literally"</em>... but what if it's more radical... to say <em><strong>that is what a datatype actually is</strong></em>.</p>
<p>In a nutshell, I'm saying this:</p>
<pre><code>&gt;&gt; integer!
== ~@[integer]~  ; isotope
</code></pre>
<p>This would lean more heavily into the idea of isotopes that don't trigger errors when you fetch them out of words, and would require friendlier handling in things like equality operators.</p>
<h2>Example Of Effects on FIND</h2>
<p>With the current implementation you'd thus get something like the historical behavior when using plain INTEGER!, and then get different results out of looking for the REIFY or META forms:</p>
<pre><code>&gt;&gt; find [a @[integer] ~@[integer]~ 1 b] integer!
== [1 b]

&gt;&gt; find [a @[integer] ~@[integer]~ 1 b] reify integer!
== [@[integer] ~@[integer]~ 1 b]

&gt;&gt; find [a @[integer] ~@[integer]~ 1 b] meta integer!
== [~@[integer]~ 1 b]
</code></pre>
<h2>The De-reification Of "DATATYPE!"</h2>
<p>So this would push our idea of what "DATATYPE?" is to being an isotopic THE-BLOCK! or whatever... in the same way that a SPLICE? is an isotopic group, and a PACK? is an isotopic block.</p>
<p>The "ugly-and-alarming QUASI!" form <em>could</em> be used to generate the datatype in a pinch:</p>
<pre><code> &gt;&gt; integer!
 == ~@[integer]~  ; isotope

 &gt;&gt; ~@[integer]~
 == ~@[integer]~  ; isotope

 &gt;&gt; switch type of 1020 [~@[integer]~ [print "It was an integer"]]
 It was an integer
</code></pre>
<p>But this kind of META/UNMETA would be a generic persistence tool that you'd reach for to be expedient.  Generally speaking the expectation would be that your source-level dialects that needed to represent types would work with another form.</p>
<h2>Downsides To Not Being Able to Put a "DATATYPE!" in a BLOCK?</h2>
<p>We're talking about a situation where if you write something like:</p>
<pre><code>reduce [1000 + 20 integer!]
</code></pre>
<p>You're going to get an error, because INTEGER! looks up to an isotope.  How you deal with this would be up to you, and I guess it all depends on what you're going to do with the block later.</p>
<p>Maybe you're putting something together for a kind of type test in the future?  You could leave the word around, either by quoting it or putting it in a BLOCK!, which is what is usually the mode of typeset representation in a dialect anyway:</p>
<pre><code>&gt;&gt; reduce [1000 + 20 'integer!]
== [1020 integer!]

&gt;&gt; reduce [1000 + 20 [integer!]]
== [1020 [integer!]]
</code></pre>
<p>If you're trying to "boil away" the word and get at the underlying type--maybe because you want to do a type test with it and have the meaning persist even if the word lookup changes, you've got the options of reifying or of meta'ing:</p>
<pre><code>&gt;&gt; reduce [1000 + 20 meta integer!]
== [1020 ~@[integer]~]

&gt;&gt; reduce [1000 + 20 reify integer!]
== [1020 @[integer]]
</code></pre>
<p>But the point is that these aren't the only options.  You might have other ideas for what @ types do, and so you might want to construct something entirely different:</p>
<pre><code>[1020 (&lt;type&gt; integer)]
</code></pre>
<p>However you'd need to get that transformed back before using it with FIND or a test against a TYPE OF.  The point of the <code>~@[...]~</code> and <code>@[...]</code> is that they are within close reach when you don't have a reason to overthink it and those cases don't collide with anything.</p>
<h2>Is This More Trouble Than Just DATATYPE!-Ends-In-(!)</h2>
<p>As things get shuffled around it's good to stop and ask back from first principles what the point is.</p>
<p>One point of having <em>an</em> isotopic form of a datatype is so that there's some non-reified signal to pass as a parameter that indicates you want to match the type vs. to look for it literally...as with the FIND example.</p>
<p>This could be done another way--with refinements or signals--just as splicing can be controlled by something like /ONLY instead of letting the value carry it.  But it's a neat feature that people had become attached to, and it's a kind of polymorphism that is pleasing.</p>
<p>That's part one...but then we can ask about the merits of this specific idea of having <em>only</em> an isotopic form.</p>
<p>There's the "representational greed" aspect--which basically says that if we can get away with having only an isotopic form carry the meaning of "datatype", the non-isotopic form becomes fair game for other things.</p>
<p>What's nice about this is that when I say:</p>
<pre><code> parse [1 2] [some integer!]
</code></pre>
<p>We're not giving anything up in the parse dialect box of parts related to @.  And we're not messing with words like <strong>!!WARNING!!</strong> or any other idea that might involve exclamation points.</p>
<p>I mentioned the fact that it was "no accident" that things like #[true] and #[false] were rendered as just the words true and false... because people didn't want something that wasn't the words "leaking".  I think that's true of the datatypes as well--it's a rare-if-ever situation that you want your mediums of exchange to have something gnarly like #[datatype! integer!] in them.  So with the "you can't put it in blocks" alert, you get to have that moment of triage.</p>
<p>Fitting into the whole puzzle of isotopes means they're just a stone's throw away from having a stock representation...but you'll need a step to bring it back to being a "datatype" again.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/what-if-datatype-was-isotopic-tl-dr-bad-idea/1982">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-if-datatype-was-isotopic-tl-dr-bad-idea/1982</link>
          <pubDate>Wed, 21 Sep 2022 08:45:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1982</guid>
          <source url="https://forum.rebol.info/t/what-if-datatype-was-isotopic-tl-dr-bad-idea/1982.rss">What If &quot;DATATYPE&quot; Was Isotopic (TL;DR: Bad Idea)</source>
        </item>
        <item>
          <title>ARRAY/INITIAL and ACTION! Isotopes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>So the ARRAY mezzanine from R3-Alpha allowed you to make an array with an initial value that could be a function...in which case it evaluated that function each time:</p>
<pre><code>r3-alpha&gt;&gt; array 3
== [none none none]

r3-alpha&gt;&gt; array/initial 3 10
== [10 10 10]

r3-alpha&gt;&gt; n: 0 array/initial 3 does [n: n + 1]
== [1 2 3]
</code></pre>
<p>This raises the question of how you would make an array whose initial value was itself a function.</p>
<p>If you're a loophole-minded person, you might notice you could trick <em>this particular case</em> by making a function that returns a function.</p>
<pre><code>r3-alpha&gt;&gt; array/initial 3 does [:append]
== [#[action! [...]] #[action! [...]] #[action! [...]]]
</code></pre>
<p>But that's not really a general answer for how to deal with this kind of polymorphism--it just works if you're using the result purely to do a substitution.</p>
<h2>Trying This With Isotopic ACTION!s</h2>
<p>I've loosened my stance on isotopes in function frames as parameters.  It's not a good idea to take them as default, but forcing you to make every parameter ^META just to get isotopes is limiting.</p>
<p>So I gave this a shot.  The notation I've got for now is that something like <code>[~action!~]</code> in a typeset says that parameter is willing to accept action isotopes.</p>
<pre><code>array: func [
    {Makes and initializes a block of a given size}

    return: "Generated block or null if blank input"
        [block!]
    size "Size or block of sizes for each dimension"
        [&lt;maybe&gt; integer! block!]
    /initial "Initial value (will be called each time if action isotope)"
        [any-value! ~action!~]
]
</code></pre>
<p>So that <strong>[any-value! ~action!~]</strong> leads to a willingness to accept function isotopes.  Having such an annotation leads you into the "danger zone" where if you don't prefix accesses to INITIAL with a colon, you run the risk of running a function.  But if you don't have the annotation, you don't have to be paranoid and decorate your references.</p>
<p>Here's how the INITIAL references wind up in the implementation:</p>
<pre><code>case [
    block? rest [
        repeat size [append block (array/initial rest :initial)]
    ]
    activation? :initial [
        repeat size [append block run :initial]  ; Called every time
    ]
    any-series? initial [
        repeat size [append block (copy/deep initial)]
    ]
] else [
    append/dup block initial size
]
</code></pre>
<p>So the BLOCK! case which recurses uses the :INITIAL for pass-thru.</p>
<p>I used <strong>RUN :INITIAL</strong> when I could have just used <strong>INITIAL</strong>, simply because it feels more clear.  If this wasn't already contained by being at the end of a block, it would be better to limit the parameterization by saying something like <strong><code>apply :initial []</code></strong> or the now-equivalent <strong><code>initial/ []</code></strong></p>
<p>Since the only isotope type in the typecheck is action, there's no need to use the leading colon for the other references.</p>
<h2>And It Works</h2>
<p>What we're kind of accepting as a default is that function generation produces isotopes.  So getting a plain action requires some kind of extra step, like REIFY</p>
<pre><code>&gt;&gt; func [x] []
== ~#[action! [x]]~  ; isotope

&gt;&gt; action: reify func [x] []
== #[action! {action} [x]]

&gt;&gt; action  ; not word!-active
== #[action! {action} [x]]

&gt;&gt; ap: reify :append
== #[action! {ap} [series value /part /dup /line]]

&gt;&gt; ap
== #[action! {ap} [series value /part /dup /line]]
</code></pre>
<p>What this means is that you get a similar behavior to before, where if you pass a "live" function you've fetched from a word or just generated, then it runs.  You have to do something extra to it to get it to be inert.</p>
<pre><code>&gt;&gt; array 3
== [_ _ _]

&gt;&gt; array/initial 3 10
== [10 10 10]

&gt;&gt; n: 0 array/initial 3 does [n: n + 1]
== [1 2 3]

&gt;&gt; array/initial 3 reify does [n: n + 1]
== [#[action! []] #[action! []] #[action! []]]
</code></pre>
<h2>That Looks Like A Polymorphism Success Story...</h2>
<p>It doesn't require any convoluted thinking to get the literal vs. non-literal distinction.  And you can apply this technique to cases that don't have a weird workaround.</p>
<p><strong>And of course what I really like here is how you have to explicitly indicate you tolerate function parameters that will execute if you don't use a GET-WORD! access.</strong></p>
<p>I wish I could say that all of ACTION! isotopes impacts were as well sorted out as this looks.  But it's a start, and it shows the potential.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/array-initial-and-action-isotopes/1975">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/array-initial-and-action-isotopes/1975</link>
          <pubDate>Tue, 20 Sep 2022 18:53:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1975</guid>
          <source url="https://forum.rebol.info/t/array-initial-and-action-isotopes/1975.rss">ARRAY/INITIAL and ACTION! Isotopes</source>
        </item>
        <item>
          <title>Influences On Startup Time And Memory Use</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p>Right now it's not ideal to be focusing on things like startup time and memory use.  There are a lot of fundamental features being rethought--and recall that rules of optimizing code at the cost of clarity and flexibility of design are:</p>
<ul>
<li>
<p>Rule <span class="hashtag">#1:</span> Don't Do It</p>
</li>
<li>
<p>Rule <span class="hashtag">#2</span> (Experts Only) Don't Do It... Yet.</p>
</li>
</ul>
<p>...BUT, the issues can't be ignored forever.  And it's reasonable for one to ask why there's been a dramatic increase in boot time and memory use between the build being used for bootstrap and a current commit.</p>
<p>So it's worth having a thread here to track some of what's involved.</p>
<h2>ENCAP Detection</h2>
<p>By default we still run encap detection on all desktop builds, scanning the executable.  On Windows I think Shixin's version loads the whole binary into memory, and on Linux it still does quite a lot.</p>
<p>You can skip the detection by using <code>--no-encap</code>.</p>
<p><a href="https://github.com/metaeducation/ren-c/blob/master/scripts/encap.reb">https://github.com/metaeducation/ren-c/blob/master/scripts/encap.reb</a></p>
<p>But the encap and de-encapping tools will still be bundled in the executable.  They're not an extension, so if you don't want to pay for that...you need to entirely remove <a href="https://forum.rebol.info/t/boot-footprint-giant-string-literal-vs-encap/1977">early-boot modules like encap and unzip</a> which are <a href="https://github.com/metaeducation/ren-c/blob/02d1ba2c6e2a8b5fc689d4d6684435ae369a528d/src/main/prep-main.reb#L45">built in another way</a></p>
<p>Obviously platform-specific C code would be faster and lighter than PARSE.  And there was some before, but it entangled things in the core with FILE I/O...and it was dedicated finicky C for a purpose we're not really focusing on, especially in the web build.</p>
<p>The decision to move encapping to userspace tools was mine, and not something I regret.  But since we're not using it, all it's really doing is acting as a test.  I've made a separate thread to talk about the fate of Encap, and whether we should depend on it more or distance from it further:</p>
<p><a href="https://forum.rebol.info/t/boot-footprint-giant-string-literal-vs-encap/1977" class="inline-onebox">Boot Footprint: Giant String Literal vs. Encap?</a></p>
<h2>A Big Cost Is Going To Come From UPARSE</h2>
<p>UPARSE right now is an elaborate exercise of the ability to build complex feature-filled dialects in userspace.  And it does so at great cost to the evaluator.</p>
<p>Of course the plan is to cut that down, because COMBINATORs are just functions.  They could be written as natives.  And even more importantly, the process of <em>combinating itself</em> needs to be native.</p>
<p>I have done some experiments with this:</p>
<p><a href="https://forum.rebol.info/t/progress-on-nativizing-parser-combinators/1636" class="inline-onebox">Progress on Nativizing Parser Combinators</a></p>
<p>But those experiments are currently inactive, because the design needed more work.  And it's easier to churn through that work with userspace code.</p>
<p>What can we do about it? Well until UPARSE goes through an optimization phase, we can just use PARSE3 in boot...or at least for whatever subsetted codebase is in this metric.  The main thing is just to get it measured so we know how much of this is known UPARSE-ism vs. other unknowns.  I'm going to bet it's a lot...even though it's not used all that terribly much in boot, it's going to be big.</p>
<p>Cutting it out for the moment would at least help focus on the next bigger things.</p>
<h2>Another Pain Point Is Going to be GET+SET Atop PICK+POKE</h2>
<p>I spent quite a while working through what a GET and SET and PICK and POKE actually were.  Ultimately I concluded:</p>
<ul>
<li>
<p>GETs are just sequences of individual PICK steps (where a GET of a WORD! starts the chain with the binding of the word, and PICKs the word out of that object)</p>
</li>
<li>
<p>SETs are a sequence of PICK steps which are kept track of...followed by POKE.  That POKE can return nothing (in which case you're done) or it can return an adjusted value.  If the value needed to be adjusted that means it then gets POKE'd back into the cell back in the chain, and this ripples back so long as the bitpattern in cells need to be adjusted.</p>
</li>
</ul>
<p>I haven't gone back to this prototype and optimized it.  That means it quite literally is building evaluation chains of PICK and POKE every time it does tuple processing (what would be "path picking", e.g. variables out of objects).  I wasn't sure if this was the answer or not, so it seemed best to keep it general to be able to play with it.</p>
<p>It's tough to know how much "hardening" should be done on this.  It's nice to be able to hijack and hook and bend things.  I think I still want to consider it to be calls to PICK and POKE, but we can do those calls via frames built just for those functions...and not generic evaluation.  I'll have to look at it.</p>
<h2>Each Extension Adds Memory Use, But Also Has Startup Code</h2>
<p>By default the desktop includes every extension, even for making animated GIFs...as well as currently</p>
<p>If one wants to make a non-kitchen-sink test build of Ren-C...obviously use <code>debug: none</code>, and <a href="https://github.com/metaeducation/ren-c/blob/02d1ba2c6e2a8b5fc689d4d6684435ae369a528d/configs/default-config.r#L23">chopping extensions out with <strong><code>-</code></strong> instead of <strong><code>+</code></strong></a>, for starters.  Note that extensions can be <a href="https://github.com/metaeducation/ren-c/actions/runs/3056527403/jobs/4930783888#step:22:3">built as separate DLL/.so with <strong><code>*</code></strong></a></p>
<h2>Other Factors Need Managing On a Case-by-Case Basis</h2>
<p>Those would be among the only things that can be done without <em>some</em> attention to the C, which hasn't been vetted for this metric in years.  But it isn't a priority right at this exact moment--there are much more important things.</p>
<p><em>(If you want some of my general philosophy about why Ren-C will be competitive with R3-Alpha despite "increased complexity", then seeing some <a href="https://forum.rebol.info/t/the-now-even-more-special-specialize/588">old stats on SPECIALIZE might be illuminating</a>)</em></p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/influences-on-startup-time-and-memory-use/1972">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/influences-on-startup-time-and-memory-use/1972</link>
          <pubDate>Sun, 18 Sep 2022 22:11:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1972</guid>
          <source url="https://forum.rebol.info/t/influences-on-startup-time-and-memory-use/1972.rss">Influences On Startup Time And Memory Use</source>
        </item>
        <item>
          <title>The Implications of ^META Producing QUASI! from Isotopes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <h2>TL;DR - GET-WORD! to Fetch ACTION!s Will Be Unchanged</h2>
<ul>
<li>
<p>In the beginnings of the action isotope proposal, I thought that it would be perfect to move away from GET-WORD! to ^META-WORD! to reconstitute actions.</p>
<ul>
<li>
<p>The ^META-WORD! would give back something you could put into variables that was not word-active...hence easier to work with.</p>
</li>
<li>
<p>At that time, what ^META of an action isotope gave back was a plain ACTION!</p>
</li>
</ul>
</li>
<li>
<p>With the rise of generic isotopes and more examples of their functionality, it became clear that ^META of an isotopic form would return a <em>quasiform</em>.</p>
<ul>
<li>
<p>Quasiforms have a unique place in the system as a representation of "isotopic status in suspended animation"</p>
</li>
<li>
<p>Higher-order manipulations are not supposed to disregard the QUASI!-ness as if it's not there.  (The form was initially even more pejorative, called "BAD", to draw attention.)</p>
</li>
</ul>
</li>
<li>
<p>The need to have generic operations on ACTION! that compose or manipulate them suggests the best ergonomic is to make isotopic actions able to decay to plain ACTION! to facilitate these compositions.</p>
<ul>
<li>
<p>QUASI!-forms will not (and should not) do this decay, leading to unpleasant patterns like <strong>apply unquasi ^add [1 2]</strong></p>
</li>
<li>
<p>The preferable syntax of <strong>apply :add [1 2]</strong> can leverage the more malleable idea of isotopic decay to allow APPLY to accept an action isotope as its applicand.</p>
</li>
</ul>
</li>
<li>
<p>This decision ripples out to other operations which may be on the fence, such as CHAIN, which is now decided to work as <strong>chain [:add, :negate]</strong> instead of as <strong>chain [^add, ^negate]</strong> as was prototyped in an early commit.</p>
</li>
</ul>
<hr>
<p>Here was the line of reasoning to get there, which says the same thing in many more words.</p>
<hr>
<h2>The Construction of Historical CHAIN</h2>
<p>So far, if you wrote something that chained two functions together, like:</p>
<pre><code>&gt;&gt; double-plus-twenty: chain [lambda [x] [2 * x], specialize :add [value2: 20]]

&gt;&gt; double-plus-twenty 500
== 1020
</code></pre>
<p>What actually happened was two steps.  CHAIN is a higher-level function, that calls REDUCE of the block to produce ACTION! values, followed by calling a lower-level CHAIN* native that expects a block of just actions.</p>
<p>This was nice because it meant that the mechanics inside of CHAIN* didn't have to worry about having some implementation of REDUCE inside of it.  It could focus on what it did...taking in a list of ACTION!s, and building an aggregate ACTION! that ran them as a pipeline.</p>
<h2>...Enter ACTION! Isotopes...</h2>
<p>The first experiment was that if you did something like <strong><code>^append</code></strong> on an action isotope (like the word APPEND would look up to), you would get a plain ACTION! back.</p>
<p>The previous CHAIN* would thus still work, so long as you changed it to ^META whatever you wanted to chain together:</p>
<pre><code>reversed-append: chain [^append, ^reverse]
</code></pre>
<p>But a design decision emerged that when you ^META an isotope, you get a QUASI! form.  This is one of the reasons that even though isotopes have "no representation", they are shown with the QUASI!-marks in the default terminal (plus a comment).</p>
<pre><code>&gt;&gt; spread [a b c]
== ~(a b c)~  ; isotope

&gt;&gt; ^ spread [a b c]
== ~(a b c)~
</code></pre>
<p>Generally speaking, this is a good thing.  If you have to ^META something just to reify it (with the intention to UNMETA it down the line and get the isotope back), then this is informative.  It's why you have to take special action to throw the quasi status away (UNQUASI).</p>
<p>But now if you feed the lower-level CHAIN with an array out of REDUCE of ^META forms, you'll have a block of QUASI!-actions:</p>
<pre><code>&gt;&gt; reduce [^append, ^reverse]
== [~#[action! {append} [...]]~ ~#[action! {reverse} [...]]~]
</code></pre>
<p>GET-WORD!s couldn't be handled by a plain REDUCE at all, because they'd give back isotopes--illegal in blocks.</p>
<h2>"So What's The Problem?  Make CHAIN Take QUASI-ACTION!"</h2>
<p>Mechanically, that would work.</p>
<p>But if it takes QUASI-ACTION!, should it still take plain ones too?</p>
<p>Let's stop and think about what the difference between an ACTION! and a QUASI-ACTION! represented in a block are.</p>
<p>A plain ACTION! in a block is something that when evaluated, will run the action.</p>
<pre><code>&gt;&gt; compose [(unquasi ^add) 1000 20]
== [#[action! {add} [...]] 1000 20]

&gt;&gt; do compose [(unquasi ^add) 1000 20]
== 1020
</code></pre>
<p>A QUASI! action will evaluate to produce an isotopic action.  The current proposal for isotopic actions is that they are unfriendly as most isotopes are, so that they are hard to assign to WORD!s.  But techniques would sneak past that...namely having purposeful function generators wrap them up in isotopic objects designed to communicate with SET-WORD!s/etc. and approve the assignment:</p>
<pre><code>&gt;&gt; ^add
== ~#[action! {add} [...]]~

&gt;&gt; do compose [(^add)]
== ~#[action! {add} [...]]~  ; isotope

&gt;&gt; do compose [(^add) 1000 20]
== 20  ; didn't run the action, it evaluated isotopically and vanished
</code></pre>
<p>So you'd use different pieces in different ways.</p>
<p>When you look at it this way, it kind of makes it seem like QUASI-ACTION! should be the currency of action that CHAIN would want.  Consider the difference between these two at-a-glance:</p>
<pre><code>[#[action! {append} [...]] #[action! {reverse} [...]]]

[~#[action! {append} [...]]~ ~#[action! {reverse} [...]]~]
</code></pre>
<p>The first array of plain ACTION!s comes off as something of an incomplete sentence.  It's like you've written <strong>[append reverse]</strong> and you're building up a statement where the first argument to an APPEND is being REVERSE'd:</p>
<pre><code>&gt;&gt; code: [#[action! {append} [...]] #[action! {reverse} [...]]]

&gt;&gt; append code [[a b c] [d e]]

&gt;&gt; do code
== [c b a [d e]]
</code></pre>
<p>The second array of QUASI!-actions is kind of clearly not a sentence.  It's more like a collection of isotopic actions in "suspended animation".  If you REDUCE-EACH it, you'll be able to digest it back into action isotopes.</p>
<p>Looked at in just this light, the QUASI! actions seem like a pretty good currency for CHAIN* to accept.  Though it's behind the scenes a bit.</p>
<h2>But Such Decisions Ripple...</h2>
<p>So now let's look at something that doesn't take its input in an array, like APPLY.  Today it takes an ACTION! as an argument:</p>
<pre><code>apply: func [
    applicand [action!]
    args [block!]
][...]
</code></pre>
<p>The goal of isotopic actions is to have a way that generic parameters or things that enumerate blocks don't have to worry about turning a WORD! into something that runs actions unexpectedly.  It's not really as relevant to things like APPLY, because they <em>know</em> things like their APPLICAND are an ACTION!.  This isn't a burden...and in fact, it can be annoying if you plan on calling the function in the body to receive it inertly.</p>
<p><em>(Quick reminder: it's also a solution to a problem <a href="https://gitter.im/red/red?at=631c6475999499629359f1ec">that Boris repeatedly mentions</a>, e.g. REPLACE can't distinguish between an action you pass it to look for literally vs. one you want to run as part of the replacement.  So it's more than just a safety tool.)</em></p>
<p>Anyway...things are all a bit turned on their head, because it's kind of not clear how to get a plain ACTION!.  Things like FUNC create action isotopes (wrapped up in an object to denote they were just generated, and so it's likely they were intended to be assigned somewhere soon).  And then ^META operations make quasi forms.  So you've got choices like:</p>
<pre><code>&gt;&gt; :append
== ~#[action! {append} [...]]~  ; isotope

&gt;&gt; ^append
== ~#[action! {append} [...]]~

 &gt;&gt; func [] [return 1020]
 == ~#[action! [...]]~  ; isotope
</code></pre>
<p>The only ways to make a regular-old ACTION! is "unquasi meta" or a "reify get"</p>
<pre><code>&gt;&gt; reify :append
== #[action! {append} [...]]

&gt;&gt; unquasi ^append
== #[action! {append} [...]]
</code></pre>
<p>This got me to wondering if one of the decaying behaviors of isotopes would be that action isotopes decay to normal actions when passed to function arguments that don't take isotopes (but that would be happy to take actions).  That's within the M.O. of isotopes, just generally.</p>
<p>(Decaying a QUASI!-ACTION! makes less sense.  All ANY-VALUE! types are supposed to be robust bricks and trustworthy, that includes QUASI! and QUOTED!--e.g. none of the infamous "lit-word decay").</p>
<p>So that suggests people would call APPLY with a traditional GET-WORD!, pass an isotope, let it decay:</p>
<pre><code>&gt;&gt; apply :add [300 4]
== 304
</code></pre>
<p>But then this gives us a bit of an incongruity.  You're ^META-ing functions to put them in a CHAIN, and :GET-ting them to use them with an APPLY.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p><em>This feels annoying.</em>  So what it makes me think is that the higher-level CHAIN itself processes the array with something besides a REDUCE.  e.g. it does some kind of REDUCE-EACH, and accepts either ACTION! values or ACTION! isotopes, the way something like APPLY would.  It canonizes them to something (either QUASI-ACTION! or plain ACTION!, probably plain ACTION at this point).  Then the lower-level CHAIN* runs on that.</p>
<p>It makes sense for CHAIN to process isotopes, due to the idea of putting FUNC [] definitions in the chain anyway.  So using GET-WORD!s to get isotopes out of WORD!s wins over using carets.</p>
<p>As for whether CHAIN* should take QUASI-ACTION!s or plain ACTION!s... it's an implementation detail.  I can't tell if bending that one way or the other makes more sense.  It's cleaner to write the wrapper taking quasiforms, and the array more obviously represents a collection and not code.  But maybe there are other concerns.  I'll wait until some other usage of CHAIN* arises to worry about it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-implications-of-meta-producing-quasi-from-isotopes/1967">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-implications-of-meta-producing-quasi-from-isotopes/1967</link>
          <pubDate>Fri, 16 Sep 2022 22:25:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1967</guid>
          <source url="https://forum.rebol.info/t/the-implications-of-meta-producing-quasi-from-isotopes/1967.rss">The Implications of ^META Producing QUASI! from Isotopes</source>
        </item>
        <item>
          <title>Getting Output From Rebol2 on Windows GitHub Actions</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Testing</category>
          <description><![CDATA[
            <p>For reasons of comparative testing or otherwise, it can be useful to run Rebol2.exe on something like GitHub Actions.  But it's tricky, since there's not support for interactivity from "plain" consoles...just the GUI.</p>
<ul>
<li>
<p>If you use the --nowindow option you can avoid a GUI Window, and then redirect Rebol2's output to a file.</p>
<ul>
<li>But then you don't get the output until it finishes--<em>if</em> it finishes.</li>
</ul>
</li>
<li>
<p>So the way to get a stream of output into the GitHub Actions log is to use piping.</p>
</li>
</ul>
<h2>But... What Do You Pipe <em>Into</em>?</h2>
<p>On UNIX you can pipe anything into <code>cat</code>, and it will "con-cat-enate" whatever it gets back to the terminal</p>
<pre><code>$ echo "CAT just repeats" | cat
CAT just repeats
</code></pre>
<p>Windows doesn't really have an analogue to that, because its seemingly-similar TYPE shell command can't be piped into.</p>
<p>The trick I came up with offhand was a batch file that pipes into FIND and excludes any line that contains the word "voodoo":</p>
<pre><code># Note: Writing a line from cmd.exe that contains quotes like this is
# seemingly impossible...escaping with ^" or "" or \" just don't work.
# Bash may be ugly, but at least it doesn't have so many glaring holes.
#
- name: Download And Wrap Rebol2 Interpreter
  run: |
    curl -o rebol2-core.exe -L http://www.rebol.com/downloads/v278/rebol-core-278-3-1.exe
    echo "rebol2-core.exe --nowindow %* | find /V \"voodoo\"" &gt; rebol2.bat
</code></pre>
<p>So that gives you a Rebol2 command that will behave as you would probably expect something on GitHub Actions to act.</p>
<pre><code># See notes above about why Rebol2 is a batch file that does piping.
#
- name: Demonstrate Rebol2 Working
  shell: cmd
  run: |
    rebol2 --do "print {Hello from Rebol2 Piping Batch Wrapper}"
</code></pre>
<p>Of course these days we can pipe into Ren-C and it can be made to work.  But this is a bit lighter weight.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/getting-output-from-rebol2-on-windows-github-actions/1966">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/getting-output-from-rebol2-on-windows-github-actions/1966</link>
          <pubDate>Thu, 15 Sep 2022 07:11:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1966</guid>
          <source url="https://forum.rebol.info/t/getting-output-from-rebol2-on-windows-github-actions/1966.rss">Getting Output From Rebol2 on Windows GitHub Actions</source>
        </item>
        <item>
          <title>Line Continuation and Arity Bugs: Thoughts?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>At one point in time, there was no way to pass something to RETURN that represented a VOID.  Because voids completely vanished.  If you had a function that took an argument--and a void thing came after it--the evaluator would just keep retriggering until it found a value or hit the end.</p>
<p>This led to the only way of being able to return a void to be to have truly nothing after it.  So RETURN became effectively arity-0 or arity-1.  If you passed it no argument, it would consider itself VOID.  It even had the nice property of being able to chain functions that themselves might be void.</p>
<p>Given that RETURN was doing this, some other functions followed suit.  QUIT could take an argument or not.  CONTINUE could as well.</p>
<h2>But I Just Got Bit By a Variadic QUIT Bug</h2>
<p>Without thinking about it, I tried to end some code prematurely by injecting a quit:</p>
<pre><code> some stuff I wanted to run

 quit  ; added this

 some stuff I wanted to avoid running
</code></pre>
<p>And that QUIT ran the stuff I didn't want to run anyway, because it was variadic.</p>
<h2>My Kneejerk Reaction Was To Kill The Variadicness</h2>
<p>The original case of RETURN has changed, because so-called "non-interstitial invisibility" is dead.  You can only make expressions void in their totality--not when used as arguments.  Doing otherwise caused more harm than good.</p>
<p>Hence <strong><code>return void</code></strong> is a perfectly fine thing to write <em>(or <strong><code>return ~</code></strong> if you prefer the quasiform of void, which you probably don't, but it might come in handy somewhere if you've defined VOID to mean something else)</em></p>
<p>I'd been thinking that argument-less RETURN would thus go back to returning the default unfriendly value (currently called NONE, a <strong><code>~[]~</code></strong> isotope, e.g. a parameter pack with absolutely no values in it).  But maybe we shouldn't support argument-less RETURN at all.</p>
<h2>But Variadics Can Be Neat</h2>
<p>I guess RETURN could always take an argument, and we go back to CONTINUE/WITH and QUIT/WITH.</p>
<p>But those are uglier.</p>
<p>We might question the behavior of the system just randomly slurping up arguments from enusing lines?  Especially when APPLY has such a convenient notation now, of <strong>some-func/ [...]</strong></p>
<p>From a usability perspective, there's certainly a lot of potential for error in getting the arity wrong.  Having it be more strict could catch bugs, and make it more likely that variadic arity is being used correctly.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/line-continuation-and-arity-bugs-thoughts/1965">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/line-continuation-and-arity-bugs-thoughts/1965</link>
          <pubDate>Wed, 14 Sep 2022 17:08:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1965</guid>
          <source url="https://forum.rebol.info/t/line-continuation-and-arity-bugs-thoughts/1965.rss">Line Continuation and Arity Bugs: Thoughts?</source>
        </item>
        <item>
          <title>Where Should Isotope Tolerance Begin (and End)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>Isotopes started small, but are now an integral part of the design.  (Give a close read to <strong><a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">"A Justification Of Generalized Isotopes"</a></strong> if you are skeptical of weird new things, until you realize their importance).</p>
<p>They're showing amazing results, but they do raise a number of questions.</p>
<p><strong>One thing is set in stone about them: <em>you can't store them in arrays</em>.</strong></p>
<p>Sometimes that's because storing operations will interpret them as a kind of "instruction".  For instance, isotopic GROUP!s are interpreted as "splices":</p>
<pre><code>&gt;&gt; spread [d e]
== ~(d e)~  ; isotope

&gt;&gt; append [a b c] spread [d e]
== [a b c d e]
</code></pre>
<p>Isotopic BLOCK!s are "packs"... which resolve to their first item unless used in contexts that specially understand how to unpack them (such as using them in combination with a SET-BLOCK!)</p>
<pre><code>&gt;&gt; pack [d e]
== ~['d 'e]~  ; isotope

&gt;&gt; append [a b c] pack [d e]
== [a b c d]

&gt;&gt; [x y]: pack [d e]
== d

&gt;&gt; x
== d

&gt;&gt; y
== e
</code></pre>
<p>But a generically weird isotope that the callee does not understand just gets rejected:</p>
<pre><code> &gt;&gt; unmeta '~something~
 == ~something~  ; isotope

 &gt;&gt; append [a b c] unmeta '~something~
 ** Error: APPEND doesn't know what to do with a ~something~ WORD! isotope
</code></pre>
<h2>First Question: Should Isotopes Be Assignable?</h2>
<p>There's a nice aspect to being able to void out variables like this:</p>
<pre><code>my-var: ~
</code></pre>
<p>That's prettier than <strong><code>unset 'my-var</code></strong>, and it is more obviously an assignment.</p>
<p>But what if you'd put a QUASI! of an isotopic block there?</p>
<pre><code>my-var: ~[d e]~
</code></pre>
<p>The idea is that QUASI! isn't inert, but that it <em>actually evaluates</em> to an isotopic form:</p>
<pre><code>&gt;&gt; ~[d e]~
== ~[d e]~  ; isotope

&gt;&gt; pack [d e]
== ~[d e]~  ; isotope
</code></pre>
<p>So the assignment would be like if you'd written <strong><code>my-var: pack [d e]</code></strong> ... which pretty clearly should set MY-VAR to D... not the isotope ~[d e]~.</p>
<p>Right now, the trick is that a special exception is made when a literal quasiform is to the right of a SET-WORD!, and it's meant as a SET/ANY that doesn't do this kind of decay.</p>
<p><em>I've found this trick is brittle and difficult to abstract.</em>  If you write something like the EXPORT keyword, and you want <strong><code>export var: ~foo~</code></strong> to be compatible with <strong><code>var: ~foo~</code></strong> then it becomes difficult to inherit that tolerance.   You can't get the SET-WORD! var, then evaluate the right hand side, and then expect a SET to tolerate the isotope assignments.</p>
<h2>Going Further... What About Type Tests...or Equality?</h2>
<p>If we look at historical Redbol, we can see there was some tolerance of "UNSET!" values by the type tests:</p>
<pre><code>rebol2&gt;&gt; type? print "HI"
HI
== unset!

rebol2&gt;&gt; integer? print "HI"
HI
== false
</code></pre>
<p>This tolerance did not extend to things like equality operators:</p>
<pre><code>rebol2&gt;&gt; (print "HI") = (print "HI")
HI
HI
** Script Error: Operator is missing an argument
</code></pre>
<p>Red and R3-Alpha deviate on this, allowing "unsets" to be compared for equality:</p>
<pre><code>r3-alpha/red&gt;&gt; (print "HI") = (print "HI")
HI
HI
== true
</code></pre>
<p><em>In the Ren-C world, it's a slippery slope to permit isotope comparisons.</em>  To see why... if you think about something like an isotopic block representing a parameter pack, the semantics for the comparison should be of the first item only.</p>
<pre><code>ren-c&gt;&gt; (pack [1 2]) = (pack [1 3])
== #[true]
</code></pre>
<p>My terminology would be <em>"comparison forces decay"</em>.  If you don't want that you need to ^META the things you are comparing, so you're comparing non-isotopic quasiforms:</p>
<pre><code>ren-c&gt;&gt; ^(pack [1 2])
== ~[1 2]~

ren-c&gt;&gt; ^(pack [1 3])
== ~[1 3]~

ren-c&gt;&gt; ^(pack [1 2]) = ^(pack [1 3])
== #[false]
</code></pre>
<p>It seems like if this kind of comparison does not have fidelity for one kind of isotope, it is suspect for other isotopic forms.  So it would not take its parameter as ^META, and thus error on non-decaying forms...although...</p>
<h2>The Isotopic LOGIC! Proposal Shakes All This Up</h2>
<p>I've proposed the idea that ~true~ and ~false~ isotopes are actually relatively friendly... as isotopes go.  They would not cause errors when accessed from WORD!s, they would need to be legal to assign to SET-WORD!, and we'd assume they'd have to compare as well.  But their inability to be put in BLOCK!s or similar would be an asset--stopping the accidental leakage of the "ugly" forms into data interchange...forcing resolution to WORD!s (or at least purposefully the quasi-words of ~true~ and ~false~)</p>
<p>It (probably?) doesn't seem like a great idea to have an exception for just those two WORD! isotopes...but to generalize the friendliness to any WORD! isotope.  They'd have the array unfriendliness, but also a type checking unfriendliness by not being in the ANY-VALUE! class...only functions that wanted them would take them.</p>
<h2>And Don't Forget ERROR!s...</h2>
<p>There's been a huge improvement from definitional error isotopes, with the impacts felt on a daily basis.  But of course, they throw some more curveballs in.</p>
<p>Assignment via SET-WORD! of an error isotope that hasn't been ^META'd needs to raise that error.</p>
<h1>How To Tame This Zoo?</h1>
<p>One idea I came up with was a notation for isotopic assignments:</p>
<pre><code>[~var~]: ...
</code></pre>
<p>That looks good at first... but what it's really saying is that if the right hand side was a pack with an isotope inside it, then the <em>inside</em> isotope would be tolerated in the assignment.</p>
<p>It gets a little more elaborate, but you can use this to represent any isotopic assignment.  Let's say that assignment of a splice directly wasn't legal, you could put the splice in a pack, and then assign through that:</p>
<pre><code>[~var~]: ~[~(d e)~]~
</code></pre>
<p>That may be convoluted, <em>but it's better than not being able to solve the representation problem at all!</em></p>
<p>We wouldn't see such things that often if we decided to cave and say that voiding variables or WORD! isotopes were going to be legal.  Much more common would be things like this:</p>
<pre><code>var1: ~
var2: ~true~
</code></pre>
<p>You'd only see them when "problematic" isotopes were held in variables, e.g. assigned via SET/ANY (or assigned via a pack to begin with).</p>
<p>It's just slightly dismaying to think of people trying to write truly general code...ending up having to hammer out that ugly pattern:</p>
<pre><code>compose/deep [
   [~(name)~]: ~[(meta ...whatever...)]~
]
</code></pre>
<p><em>I think that's just life.</em>  And really, it's the tip of the representational iceberg...we already know that you can't round-trip functions or objects or other things in this way.  It's exaggerated for me because I try to think of how MAKE OBJECT! [...] renders in a general sense.  But it's probably not the case that many people are going to need (or want) to do this kind of thing.</p>
<h2>Does That Answer Anything About Type Tests?</h2>
<p>What actually triggered me to write about this was dealing with some code like this:</p>
<pre><code> if null? do code [...]
</code></pre>
<p>The code was returning VOID...which is the isotopic state of NULL.  And the NULL? test was erroring, because it was only designed to operate on non-meta values.</p>
<p>Let's not consider the NULL? question as special--let's imagine it could have just as easily been INTEGER? or somesuch.</p>
<p>There is a bit of a problem with any function that takes an isotope as a parameter.  So think of:</p>
<pre><code>&gt;&gt; foo: func [x] [return pack [x + 1 x + 2]]

&gt;&gt; pack? foo 10
== #[true]

&gt;&gt; integer? foo 10
== #[true]

&gt;&gt; x: foo 10
== 11

&gt;&gt; y: ^ foo 10
== ~[11 12]~
</code></pre>
<p>Does it make <em>sense</em> for there to be something like PACK? which has the isotopic X-ray vision?  Or should PACK? only exist as a question you can ask of a meta-value ("metapack?")</p>
<p>Having more of the functions like INTEGER? and NULL? trigger alarms on more isotope types helps create a spectrum of warnings that guide generic code that it's likely asking dangerous questions.</p>
<p><strong>But it seems to me that anything which is tolerant in plain assignment without error should be tolerated in type testing without error.</strong></p>
<p>It looks to me like <strong>~</strong> and <strong>~word~</strong> fit into that set.</p>
<p>We know that packs decay, and errors will actively fail on those errors...without the "pack inside a pack" or "error inside a pack" loopholes.  <em>But is it worth it to stop other isotope classes, or should it be something that's only handled on the getting side?</em></p>
<p>A lot of this likely ties into the answer for how function isotopes pan out.  So that needs revisiting.</p>
<p>However, I'm glad for the singular pack solution to the edge cases!</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/where-should-isotope-tolerance-begin-and-end/1964">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/where-should-isotope-tolerance-begin-and-end/1964</link>
          <pubDate>Mon, 12 Sep 2022 23:01:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1964</guid>
          <source url="https://forum.rebol.info/t/where-should-isotope-tolerance-begin-and-end/1964.rss">Where Should Isotope Tolerance Begin (and End)</source>
        </item>
        <item>
          <title>Rethinking The Stale Bit: Invisibility In The Isotopic Age</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p>Every evaluation step is asked to target an output cell.  Before the evaluation, a single bit is set on that cell to say it is "stale".  So if the evaluation doesn't write to it--and confirms that wasn't a mistake--then the old result is left around to recover.</p>
<p>The ability to recover the previous result with the flip of a bit is used for invisibility.  It's used not just in the evaluator when it goes step by step, but also in things like ANY and ALL.</p>
<pre><code>&gt;&gt; 1 + 2 comment "in the evaluator"
== 3

&gt;&gt; all [1 + 2 comment "here too"]
== 3
</code></pre>
<p><em>Doing it this way has sacrificed some features.</em>  For instance, you can't make an "invisible" enfix function:</p>
<pre><code>&gt;&gt; foo: enfix func [left] [
       print ["Left was" left]
       return void
   ]

&gt;&gt; 304 1020 foo
Left was 1020
== 1020
</code></pre>
<p>The 1020 from the previous evaluation was used as an argument.  But after "consuming all its arguments" the product of FOO could not leave the 304 there.  If each evaluation step was to a temporary cell, that temporary cell could be used to fill the enfix slot of FOO... and 304 could be left.</p>
<p><em>Doing it this way has also required acrobatics to accomplish non-negotiable features.</em>  The related problem of making it possible for an enfix function to perceive voidness on the left hand side requires stale bit mechanics that aren't for the faint of heart... e.g. to differentiate these two cases:</p>
<pre><code>&gt;&gt; (else [print "Won't work"])
** Error

&gt;&gt; () else [print "Will work"]
Will work
</code></pre>
<h2>Is All The Bit-Fiddling Worth It Vs. Copying?</h2>
<p>Considering the small size of cells (4 platform pointers), the logic to test and clear the "stale" bit may seem to add overhead and complexity that isn't saving that much.  Instead, every evaluation could be done into a temporary slot...and then if not invisible, the 4 pointers could be moved.</p>
<p>This is actually a bit misleading--because copying cells is actually a bit more expensive in the general case.  Cell format flags have to be checked, bindings may need to be managed, and if a reference count mechanic is implemented this could make it all worse.</p>
<p>Less copying is desirable, and it seems neat to have achieved invisibility thus far without needing an extra eval per-eval-step.</p>
<blockquote>
<p><em>"So if the evaluation doesn't write to it--and confirms that wasn't a mistake..."</em></p>
</blockquote>
<p>This is one of the main reasons I've stuck with the current method.  It's useful for debug purposes to know if a native just forgot to write an output cell anyway.  So I figured: <em>"so long as the output cell is going to have a flag on it saying it hasn't been written to yet, why not make that flag able to coexist with the previous value...and hence avoid a mechanic of needing to copy every time?"</em></p>
<h2>But Isotopes Mean It's Time For Change</h2>
<p>Early on I observed that there was no way to get this to work:</p>
<pre><code>&gt;&gt; 1000 + 20 if true [comment "hi"]
== 1020  ; not possible
</code></pre>
<p>The IF had to produce something as a proxy for VOID that wasn't void... in order to signal a taken branch (we want THEN to run).</p>
<p>But even if that proxy was able to <em>decay</em> to a void state, it was too late.  It had overwritten the output.  Today that proxy is a parameter pack with a meta-void in it: <strong><code>~[~]~</code></strong>.</p>
<p>There's more stuff with parameter packs that <em>should</em> work, like this:</p>
<pre><code> &gt;&gt; 1000 + 20 [x @y]: pack [304 void]
 == 1020
</code></pre>
<p><em>And isotopic objects that represent lazy evaluations should be able to produce void, too.</em>  They're a proxy for behavior, and if you pick and choose behaviors that could be accomplished with a normal result that a REIFY method on a lazy object can't, you're saying they're not as powerful.</p>
<p><strong>These features tip the scales.</strong>  And really, the circuitous nature of void enfix handling was already tipping them.</p>
<p>The concerns over copying are mostly addressed by something I'm calling "cell movement"; this means we can really get closer to the 4 platform pointer copies, because you're destroying the old cell in the process.  So if techniques like reference counting came along, you're not adding and removing them--you're just letting the new cell take over the resources of the old.</p>
<p>Plus, detecting whether a cell has been written to or not is a generic debug feature now that has easy coverage.</p>
<p><em>The stale bit is thus on the chopping block.</em>  So expect more robust void-related behavior coming soonish.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/rethinking-the-stale-bit-invisibility-in-the-isotopic-age/1963">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rethinking-the-stale-bit-invisibility-in-the-isotopic-age/1963</link>
          <pubDate>Thu, 08 Sep 2022 21:34:36 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1963</guid>
          <source url="https://forum.rebol.info/t/rethinking-the-stale-bit-invisibility-in-the-isotopic-age/1963.rss">Rethinking The Stale Bit: Invisibility In The Isotopic Age</source>
        </item>
        <item>
          <title>Revisiting TO and THRU</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>If you asked someone to count "from 1 to 10", how many people would stop at 9?</p>
<p>I'd say most wouldn't.  So if you wrote:</p>
<pre><code>for x [1 to 10] [print [x]]
</code></pre>
<p>What should that do?  I think if you showed it to people they would expect 10 to be included.</p>
<p>But PARSE has historically discerned this via TO (not including the limit) and THRU (including the limit).</p>
<p>Is that right?  Should TO be inclusive, and some other word along the lines of "UPTO" be used?</p>
<p>I almost feel like the words are slippery enough that we could bend them so that THRU was the <em>non</em>-inclusive version.  :-/</p>
<p>In PARSE, if TO included the limit, you could go up-to-but-not-include by using AHEAD with it: <strong><code>to ahead "A"</code></strong></p>
<p>We could say that UNTIL would keep advancing until it hit the rule and then stopped short of it: <strong><code>until "A"</code></strong>.</p>
<p>Would that convey the right thing in the FOR case?</p>
<pre><code>&gt;&gt; for x [1 until 10] [print [x]]
1
2
3
4
5
6
7
8
9</code></pre>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/revisiting-to-and-thru/1961">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/revisiting-to-and-thru/1961</link>
          <pubDate>Tue, 06 Sep 2022 16:56:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1961</guid>
          <source url="https://forum.rebol.info/t/revisiting-to-and-thru/1961.rss">Revisiting TO and THRU</source>
        </item>
        <item>
          <title>Applications of Isotopic Objects</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Consider the example of a function that might want to have two modes... one that prints out readable information for the console, and another that keeps the data in easily processable form.</p>
<p>Traditionally you might think of controlling this with an assignment:</p>
<pre><code>&gt;&gt; stats
-------------------
Column 1   Column 2
-------------------
Alpha      10
Beta       20

&gt;&gt; stats/only
== [
    [Alpha 10]
    [Beta 20
]
</code></pre>
<p>But then I wondered: what if there was only one isotopic result...that wrapped the data with functions?  So long as things stayed isotopic, you'd be able to get at the functions.  But if it reified it would become the data.</p>
<pre><code>&gt;&gt; ^ stats
== ~#[object! [... reify: ... form: ...]]~  ; isotope

&gt;&gt; compose [statistics: (spread stats)]
== [statistics: [Alpha 10] [Beta 20]]

&gt;&gt; stats
-------------------
Column 1   Column 2
-------------------
Alpha      10
Beta       20

&gt;&gt; if true [print stats, &lt;PRINT could react to FORM also&gt;]
-------------------
Column 1   Column 2
-------------------
Alpha      10
Beta       20
== &lt;PRINT could react to FORM also&gt;
</code></pre>
<p>So PRINT would be special, and instead of allowing its argument to reify normally it would specifically examine isotopic arguments to see if they could FORM.</p>
<p>In this case, the isotopic thing needs to be able to do two things: FORM or REIFY.  But maybe it could do more things, if you asked it?  And maybe no particular methods are mandatory.  Something that doesn't know how to REIFY just won't do that.</p>
<p><strong>This looks kickass.</strong></p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/applications-of-isotopic-objects/1959">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/applications-of-isotopic-objects/1959</link>
          <pubDate>Sat, 03 Sep 2022 11:48:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1959</guid>
          <source url="https://forum.rebol.info/t/applications-of-isotopic-objects/1959.rss">Applications of Isotopic Objects</source>
        </item>
        <item>
          <title>Number of Files and Folders: More Is Okay</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>In the quest for simplicity, R3-Alpha had an aesthetic that tried to be very minimalist in the source tree.</p>
<p>The top level had only this:</p>
<pre><code>make/
src/
.gitattributes
.gitignore
LICENSE
NOTICE
README
</code></pre>
<p>The <strong>%make/</strong> directory contained:</p>
<pre><code>makefile
makefile.vc
vcbuild.bat
</code></pre>
<p>The <strong>%src/</strong> directory contained:</p>
<pre><code>boot/       20 files
core/       95 files
include/    31 files
mezz/       31 files
os/          7 files, with 2 directories of about 10 files each
tools/      10 files
</code></pre>
<p>The files themselves vary in size, but this just gives a perspective of about how many files there are.</p>
<h2>Ren-C and Red use <em>MANY</em> more files and directories, BUT...</h2>
<p><em><strong>Largely I think this is okay, moreover can be beneficial to understanding the code.</strong></em></p>
<p>While we should be skeptical of large amounts of complexity, I don't think there should be a kneejerk reaction to a lot of <em>files</em>.</p>
<p>Filesystems were invented for a reason: organization.  If arranging things in separate files makes the organization clear, it is good.</p>
<p>Yet there should be some justification for why a directory exists.  For instance: I think every directory should have a README.md in it, which explains why those files are grouped together.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/number-of-files-and-folders-more-is-okay/1958">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/number-of-files-and-folders-more-is-okay/1958</link>
          <pubDate>Sat, 03 Sep 2022 10:52:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1958</guid>
          <source url="https://forum.rebol.info/t/number-of-files-and-folders-more-is-okay/1958.rss">Number of Files and Folders: More Is Okay</source>
        </item>
        <item>
          <title>CLOCK as a Noun</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>Boris made a timing function called "CLOCK", as a sort of replacement for DELTA-TIME:</p>
<p><a href="https://github.com/red/red/blob/81ff4d605df371dfc430b92611605e80f5e5780b/environment/functions.red#L1126">https://github.com/red/red/blob/81ff4d605df371dfc430b92611605e80f5e5780b/environment/functions.red#L1126</a></p>
<pre><code>clock: function [
    "Display execution time of code, returning result of it's evaluation"
    code [block!]
    /times n [integer! float!]  ; float for e.g. `1e6` instead of `1'000'000`
        "Repeat N times (default: once); displayed time is per iteration"
    /delta "Don't print the result, return time delta per iteration (in msec)"
 ]
</code></pre>
<p>It builds in iteration...which is useful for timing, since you often want to loop over things they time.  And at least in theory it should be in the native timing construct--you'd prefer not to have an interpreted call to REPEAT being part of what you count in your time.</p>
<p>(Perhaps the repeat count should just be a required first argument--since CLOCK 1 is so easy to type, why make people fuss over CLOCK/TIMES and then putting the number of times all the way at the end somewhere?)</p>
<h2>
<em>But...</em> I Think CLOCK should be a Noun</h2>
<p><strong>clock/time</strong> and <strong>clock/date</strong> have many advantages over <strong>now/time</strong> and <strong>now/date</strong>.</p>
<p>It implies that you could pass a clock around or copy it...which is a good thing.  So by default the CLOCK could be UTC (for programming convenience).  But you could copy that clock and set your module's meaning of the word CLOCK to speak in terms of local time.</p>
<p>Also it resolves a big annoyance of mine: NOW being a function that has a lot of conflicting refinements.  If CLOCK were an object, then <strong>/time</strong> and <strong>/date</strong> would be separate methods of that object, so you couldn't say things like <code>clock/time/date</code>.</p>
<p>And then you could capture the current time into a variable as <strong><code>now: clock/time</code></strong> which makes more sense to me than saying "now" is itself a verb.  <em>(It then wouldn't stay current as "now" in the sense of "exactly this moment", but in language we're pretty comfortable saying "things are different now than they were in the '80s"...e.g. there can be a prolonged linguistic notion of now.  I prefer to use it in this sense.)</em></p>
<p>As far as functional programming goes: because code doesn't have an intrinsic notion of time, you can show that a piece of code is dependent on a clock by passing one as a parameter.</p>
<p>This would allow you also to have code run simulating at a different time.  You could see how a piece of code would perform if it thought it were running at some pathological date, while working alongside other code that was operating with the current notion of time--e.g. to communicate with some webservers to upload results from a test of something like a Y2K problem simulated by other code.</p>
<h2>What to Call The Timing Construct?</h2>
<p>To think in terms of super-powers, then you need...<em>a dialect</em> !</p>
<p>Perhaps it could be called "CHRONO"?</p>
<p>Maybe CHRONO quotes its argument, and if you give it a GROUP!, it thinks of that as something to time and run just once.</p>
<pre><code>&gt;&gt; chrono (my-function 1 2 3)
0.14 s
== &lt;result&gt;
</code></pre>
<p>But if you pass a BLOCK! it could permit more options, like saying what you wanted the timing in terms of:</p>
<pre><code>chrono [msec (my-function 1 2 3)]
chrono [usec (my-function 1 2 3)]
</code></pre>
<p>Or the repeat count (being a parameter to chrono means you're not timing a REPEAT inside your code, ideally).</p>
<pre><code>&gt;&gt; chrono [1e7 (1 + 2)]
0.14 s    [1 + 2]
== 3
</code></pre>
<p>I'm busy with other things and so I'm not going to go research all the possible features you might want from a timing dialect--I'm sure there's plenty of prior art in the domain.  Just wanted to get it started.  Use your imagination.  <img src="https://forum.rebol.info/images/emoji/twitter/unicorn.png?v=9" title=":unicorn:" class="emoji" alt=":unicorn:"></p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/clock-as-a-noun/1956">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/clock-as-a-noun/1956</link>
          <pubDate>Sat, 03 Sep 2022 06:47:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1956</guid>
          <source url="https://forum.rebol.info/t/clock-as-a-noun/1956.rss">CLOCK as a Noun</source>
        </item>
        <item>
          <title>Thought: Reimplementing Multi-Return via Isotopic BLOCK!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>With <a href="https://forum.rebol.info/t/canonizing-group-as-the-underlying-array-type-for-splices/1953">splices confined to isotopic GROUP!s</a>, it occurs to me that isotopic BLOCK! could be an angle to solving multi-returns.</p>
<p>The problem of not being able to return NULL or VOID would be solved by having the protocol speak in meta values:</p>
<pre><code>&gt;&gt; ^ transcode/one {abc def}
== ~['abc '{ def}]~  ; isotope

&gt;&gt; ^ transcode/one {}
 == ~[_ '{}]~  ; isotope
</code></pre>
<p>So that BLANK! would actually mean NULL.</p>
<p>It would sacrifice the sensitivity to asking how many return values were requested... a feature I felt pretty attached to.  But it would offer a solution to the piping problems that plague things like even simply putting a multi-return expression into a group.</p>
<p>It would mean that doing a ^META casually inline in expressions would be crazier, you'd tend to want to unpack things:</p>
<pre><code>&gt;&gt; x: multi-return-func
== &lt;result&gt;

&gt;&gt; x: ^ multi-return-func
== ~['&lt;result&gt; _ '*]~  ; wait a minute what is all this crap?

&gt;&gt; [^x]: multi-return-func
== '&lt;result&gt;
</code></pre>
<p><strong>Because I just had the idea, I don't know all the ramifications.</strong>  But it's clear this would solve the issues with APPLY and other piping scenarios.</p>
<p>Evaluator behavior would be that any slots not expecting a "pack" isotope would just become its first item UNMETA, but then a ^META slot can do other things.</p>
<p>This would mean it would be your choice to use the output variable proxying feature to get multi-return mechanics.  It would be a convenience feature of FUNC for those who wanted it, in order to give better documentation on the interface and to make it clearer in the code what you were assigning.</p>
<h2>It Wouldn't <em>Prevent</em> Enfix Detection...</h2>
<p>And it wouldn't rule out people who wanted to do cleverness detecting things on the left.  They could use mechanisms parallel to what exists today.  But that would defeat putting function calls in groups, etc.  Which may be the right tradeoff for some scenarios.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/thought-reimplementing-multi-return-via-isotopic-block/1955">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/thought-reimplementing-multi-return-via-isotopic-block/1955</link>
          <pubDate>Thu, 01 Sep 2022 13:19:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1955</guid>
          <source url="https://forum.rebol.info/t/thought-reimplementing-multi-return-via-isotopic-block/1955.rss">Thought: Reimplementing Multi-Return via Isotopic BLOCK!</source>
        </item>
        <item>
          <title>Should THROW and CATCH Be For Errors?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>The historical Rebolism of THROW and CATCH has nothing to do with error handling.</p>
<p>It's a generic way to move values up the stack.  It gives you a handy "out" from control flow:</p>
<pre><code>result: catch [
    if condition [throw result]
    some code
    case [
        condition [more code]
        condition [more code, throw result]
    ]
    additional code
    throw result
]
</code></pre>
<p>The implementation of the feature is lightweight, and built on the same mechanic as RETURN.  You could in fact use return to do this:</p>
<pre><code>result: do func [] [
    if condition [return result]
    some code
    case [
        condition [return code]
        condition [more code, return result]
    ]
    additional code
    return result
]
</code></pre>
<p>But that's more heavyweight, because it gets binding involved (although I've suggested that maybe CATCH and THROW should be definitional, and the "heaviness" is a feature... not a bug).</p>
<h2>It's A Neat Feature, But I Want THROW and CATCH For Errors</h2>
<p>Error handling is undergoing a renaissance in Ren-C, and it's becoming completely pervasive.</p>
<p>Despite its glory, it is currently tied in with the junky names RAISE and EXCEPT.</p>
<pre><code>case [
   ...code that may fail...
] then [
   ...stuff to do if non-NULL, non-VOID, non-RAISED error!...
] else [
   ... stuff to do if NULL or VOID or RAISED error!...
] except e -&gt; [
  ... error handling ...
]
</code></pre>
<p>The word EXCEPT is bad for several reasons:</p>
<ul>
<li>
<p>It implies "exception" handling, <em>which definitional errors are specifically not</em>...they can only be caught one stack step at a time.</p>
<ul>
<li>Arbitrary exception handling is taboo for very good reasons...and I've made it more taboo by <a href="https://forum.rebol.info/t/discouraging-use-of-trap/1871/3">moving that behavior to SYS.UTIL.RESCUE</a>
</li>
</ul>
</li>
<li>
<p>It's not really a "verb"</p>
</li>
<li>
<p>It often comes right after an ELSE, and I don't like the alliteration of E and E</p>
</li>
<li>
<p>Almost every other language uses CATCH there</p>
</li>
</ul>
<p>And RAISE isn't exactly my favorite word either.  <strong>return throw e</strong> vs. <strong>return raise e</strong> also has that alliteration issue.</p>
<h2>So What Can The Old THROW and CATCH Be Called?</h2>
<p>It's a lot less important than the error handling application, but I still use the old construct.</p>
<p>You can actually do it with CYCLE and STOP:</p>
<pre><code>result: cycle [
    if condition [throw result]
    some code
    case [
        condition [more code]
        condition [more code, stop result]
    ]
    additional code
    stop result
]
</code></pre>
<p>Being a looping construct, it has the side effect that it will keep repeating unless a value is emitted.</p>
<p>On the plus side...this helps resolve the semantic question of "what should a CATCH return when there's no THROW?"  If what you have is CYCLE then your answer is that it keeps going.  So you either put a FAIL at the bottom, a STOP at the bottom, or accept it will keep going.</p>
<p>On the minus side...if you use this inside a looping construct you'll be redefining BREAK, which historical CATCH would not do.  (Similarly, if you use FUNC and RETURN to do this you'd redefine RETURN.)</p>
<p>With definitional BREAK and RETURN there'd be workarounds for those cases--you'd simply give another name to the outer break and return if you needed them.  But that's not how things work today.</p>
<h2>While CYCLE is Not Perfect, It Would Work For The Moment</h2>
<p>We can meditate on what the ultimate answer would be.  But there's only a few cases, and CYCLE will do.</p>
<p>Errors need THROW and CATCH...they're now too fundamental to not use the good words for.</p>
<p>We now have the word TRAP for those who don't want to use enfix, so these are equivalent:</p>
<pre><code>if e: trap [some code] [
    handle e
]

(some code) catch e -&gt; [
   handle e
]
</code></pre>
<p>But you get some real benefits from the THEN + ELSE + CATCH, and I think the importance of these enfix constructs will become apparent to those who aren't on the bandwagon (yet).</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-throw-and-catch-be-for-errors/1954">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-throw-and-catch-be-for-errors/1954</link>
          <pubDate>Thu, 01 Sep 2022 11:50:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1954</guid>
          <source url="https://forum.rebol.info/t/should-throw-and-catch-be-for-errors/1954.rss">Should THROW and CATCH Be For Errors?</source>
        </item>
        <item>
          <title>Canonizing GROUP! as the Underlying Array Type for Splices</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>The first concept of representing splices out of isotopes was to make them as iostopic BLOCK!.</p>
<p>You'd get an isotopic block regardless of the input to SPREAD:</p>
<pre><code>&gt;&gt; spread [d e]
== ~[d e]~  ; isotope

&gt;&gt; spread '(d e)
== ~[d e]~  ; isotope

&gt;&gt; spread @[d e]
== ~[d e]~  ; isotope
</code></pre>
<p>From the perspective of things like APPEND, it doesn't matter:</p>
<pre><code>&gt;&gt; append [a b c] spread [d e]
== [a b c d e]

&gt;&gt; append [a b c] spread '(d e)
== [a b c d e]

&gt;&gt; append [a b c] spread @[d e]
== [a b c d e]
</code></pre>
<h2>I Think This Canonization of Splices Is Important</h2>
<p>By canonizing splices to just one type, we recover the other types for other meanings that have nothing to do with splicing.  That subtlety would be lost if people had to think of every array type as being a splice.</p>
<p>There's no real question in my mind that it needs to be canonized.  But which array form should it take?</p>
<h2>I Think GROUP! Is A  Better Choice</h2>
<ul>
<li>
<p><strong>It makes the canonization more obvious.</strong>  Since the input to SPREAD will typically be a BLOCK!, people will learn the type is not preserved quickly:</p>
<pre><code>&gt;&gt; spread [a b c]
== ~(a b c)~  ; isotope
</code></pre>
</li>
<li>
<p><strong>Parentheses look softer and more permeable.</strong>  They already are "weaker" in that they do not "block" evaluation in the way a BLOCK! does.  So their  softness makes it feel more reasonable to say that the edges aren't there.</p>
<p><em>(This semiotic permeability exists in other places where brackets and parentheses are juxtaposed... for instance in <a href="https://en.wikipedia.org/wiki/Interval_(mathematics)#Notations_for_intervals">interval notation</a>, where <strong>[10, 20)</strong> means "the numbers from 10 to 20 without including 20")</em></p>
</li>
<li>
<p><strong>The nothing state looks kind of like a zero.</strong>  I've proposed this "nothing" as the non-NULL, non-VOID state that empty branches could coerce to.  This has the nice property of signaling the branch was taken, while still being a no-op for things like appending:</p>
<pre><code>&gt;&gt; if true []
== ~()~   ; isotope

&gt;&gt; if true [] then [print "Not VOID, so we got the branch ran signal..."]
Not VOID, so we got the branch ran signal...

&gt;&gt; append [a b c] if true []
== [a b c]  ; damn, that's cool!
</code></pre>
</li>
</ul>
<p>Because they aren't void, they overwrite output cells...the information in that cell is lost:</p>
<pre><code>&gt;&gt; 1 + 2 if false [&lt;a&gt;]
== 3

&gt;&gt; 1 + 2 if true []
== ~()~  ; isotope
</code></pre>
<p>But I primitives like DECAY and MAYBE offer a trick, that their frame has a cell that gets written with the argument...and they don't have to write their output cell until after they make a decision on their argument.  So you can promote one of these "nothing" splices to invisibility that way:</p>
<pre><code>&gt;&gt; 1 + 2 decay if true []
== 3

&gt;&gt; 1 + 2 maybe if true []
== 3</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/canonizing-group-as-the-underlying-array-type-for-splices/1953">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/canonizing-group-as-the-underlying-array-type-for-splices/1953</link>
          <pubDate>Wed, 31 Aug 2022 21:11:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1953</guid>
          <source url="https://forum.rebol.info/t/canonizing-group-as-the-underlying-array-type-for-splices/1953.rss">Canonizing GROUP! as the Underlying Array Type for Splices</source>
        </item>
        <item>
          <title>Better Answers than TRY and OPT For BLANK! &lt;=&gt; NULL</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>Ever since the creation of null and blank, it's been desirable to go between them.</p>
<p>The word I first chose for NULL =&gt; BLANK! was TRY.  It would pass through anything else:</p>
<pre><code>&gt;&gt; try null
== _

&gt;&gt; try _
== _

&gt;&gt; try 1020
== 1020
</code></pre>
<p>The reverse operation of converting BLANK! =&gt; NULL was called OPT; again passing through everything else:</p>
<pre><code>&gt;&gt; opt _
; null

&gt;&gt; opt null
; null

&gt;&gt; opt 1020
== 1020
</code></pre>
<p>It may seem mysterious to ascribe such a trivial operation to a high-value word like TRY.  But it made sense at the time, because nulls were rather unfriendly:</p>
<pre><code>&gt;&gt; if not x: find "abc" "d" [print "Assignment goes okay..."]
Assignment goes okay...
; null

&gt;&gt; if not x [print "But word fetching has problems"]
** Error: X is NULL    
</code></pre>
<p>TRY provided a way to disarm the result:</p>
<pre><code>&gt;&gt; x: try find "abc" "d"
== _

&gt;&gt; if not x [print "Didn't find it"]
Didn't find it
</code></pre>
<p>But as it turned out: NULL was trying to do too many things, being fused with the notion of "unset variables".  It was a good start on having non-valued states... we just needed more!</p>
<p>Once VOID arrived it was no longer necessary to error on null variable accesses, and this particular usage of TRY was not necessary.</p>
<h2>But...It Was Actually On The Right Track...</h2>
<p>FIND is a bad demonstration.  But TAKE on empty block is actually a good one from that erroring-on-nulls era:</p>
<pre><code>&gt;&gt; x: take []
; null

&gt;&gt; if x [print "-some- error around here seems right..."]
** Error: X is NULL

&gt;&gt; x: try take []
== _

&gt;&gt; if x [print "-some- signal for saying it's okay seems right..."]
-some- signal for saying it's okay seems right...
</code></pre>
<p>But we see it's suboptimal, as now X is valued... and conflates with if we had written <strong><code>take [_]</code></strong>.  It also seems the need for the TRY in this case should have been independent of whether you stored the result in a variable or not.</p>
<p>Definitional errors come in and clean this mess up... so that TRY can defuse the take and give you the NULL state you want:</p>
<pre><code>&gt;&gt; x: take []
** Error: TAKE of EMPTY block, use TRY if you meant to do that

&gt;&gt; x: try take []
; null
</code></pre>
<h2>But Now How Do We Interconvert BLANK! and NULL?</h2>
<p>You're still going to come across situations where you pick a blank out of a block, where it's representing a null intent.  And it's illegal to compose or append nulls to blocks / etc, so how do you convert them?</p>
<p>Meet REIFY and DECAY.</p>
<pre><code>&gt;&gt; reify null
== _

&gt;&gt; decay _
; null
</code></pre>
<p>We actually have new members of this family: the conversion of isotopes to quasiforms.</p>
<pre><code>&gt;&gt; true
== ~true~  ;  isotope

&gt;&gt; append [a b c] true
** Error: Cannot append ~true~ isotope to block, use REIFY for quasiform

&gt;&gt; append [a b c] reify true
== [a b c ~true~]

&gt;&gt; append [a b c] as word! true
== [a b c true]
</code></pre>
<p>I think the words are a nice coupling...and even the same number of letters!</p>
<h2>What Will OPT Do Now?</h2>
<p>I'm not sure.  I'm actually pulling back a bit on the idea of saying that what happens in PARSE is a TRY... because in essence there's always a built-in "TRY" during parse.  Rules are raising definitional errors, but that's just swept under the rug by the parse process itself.  So OPT kind is kind of a different shade of meaning there.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/better-answers-than-try-and-opt-for-blank-null/1946">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/better-answers-than-try-and-opt-for-blank-null/1946</link>
          <pubDate>Sun, 28 Aug 2022 16:39:55 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1946</guid>
          <source url="https://forum.rebol.info/t/better-answers-than-try-and-opt-for-blank-null/1946.rss">Better Answers than TRY and OPT For BLANK! &lt;=&gt; NULL</source>
        </item>
        <item>
          <title>Thinking About Isotopes Logically: ~true~ and ~false~</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Here's an idea: what if <strong>~true~</strong> and <strong>~false~</strong> are examples of weird isotopic exceptions.</p>
<p>Let's say you could assign them to variables...and fetch them from variables...without erroring:</p>
<pre><code>&gt;&gt; true: ~true~
== ~true~  ; isotope

&gt;&gt; false: ~false~
== ~false~  ; isotope

&gt;&gt; obj: make object! [y: true, n: false]
== make object! [
     y: ~true~
     n: ~false~
]
</code></pre>
<p><em>(not being quoted in the assignment indicates they become their isotopic forms.)</em></p>
<p>This is typically not legal...accessing a WORD! isotope from a variable like true would be an error.  But these would be special (like how I'm suggesting isotopic ACTION! would be special in running the action from a word reference...)</p>
<p>Things that tested for truthiness would treat them as expected, considering the ~false~ isotope to be a falsey thing:</p>
<pre><code>&gt;&gt; any [true false]
== ~true~  ; isotope

&gt;&gt; all [true false]
; null
</code></pre>
<p><em>Being isotopes comes with a constraint</em>...you couldn't put them into blocks.  You'd have to ^META them (which would lose their special status, turning them into QUASI-WORD!s...that were truthy.</p>
<pre><code>&gt;&gt; ^ false
== ~false~

&gt;&gt; if ^ false [print "Meta false is truthy"]
Meta false is truthy
</code></pre>
<p>The functions TRUE? and FALSE? could then work on isotopic, non-isotopic, or word forms of TRUE and FALSE...but error if passed other values.</p>
<ul>
<li>
<p><strong>This should work for casual cases of just having variables that hold a true or false state...and gives a good appearance for knowing what you're looking at.</strong></p>
</li>
<li>
<p><strong>It builds on standard mechanisms, and hence if you need to promote the isotopic state into something that can be represented in a block you can do so... with the caveat that once you do, it will no longer reflect its logical property when used with IF and such.</strong></p>
<ul>
<li><strong>That's true for NULL being ^META promoted and put in blocks as well.</strong></li>
</ul>
</li>
</ul>
<p><strong>And crucially: Since you know isotopes can't be in blocks--and if we say BLANK! is truthy as well--then you'd be guaranteed to visit all the items in a block with code like this:</strong></p>
<pre><code>while [item: try take block] [
    print mold item
]
</code></pre>
<p>This is easily the best idea so far for dealing with the problem.</p>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944</link>
          <pubDate>Thu, 25 Aug 2022 23:34:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1944</guid>
          <source url="https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944.rss">Thinking About Isotopes Logically: ~true~ and ~false~</source>
        </item>
        <item>
          <title>BLANK! 2022: Revisiting The Datatype</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Long, long ago there was a datatype called NONE.  In historical Redbol, it had the bad habit of looking like a WORD!:</p>
<pre><code>rebol2&gt;&gt; 'none
== none

rebol2&gt;&gt; none
== none  ; same in R3-Alpha and Red
</code></pre>
<p>But it wasn't a word:</p>
<pre><code>rebol2&gt;&gt; type? 'none
== word!

rebol2&gt;&gt; type? none
== none!
</code></pre>
<p>It was a distinct type, which also happened to be falsey (while WORD!s are truthy):</p>
<pre><code>rebol2&gt;&gt; if 'none [print "Truthy word!"]
Truthy word!

rebol2&gt;&gt; if none [print "Falsey none!"]
== none
</code></pre>
<p>And as we can see, NONE!s served purposes of signaling "soft failures": branches that didn't run, or FINDs that didn't find, or SELECTs that didn't select... etc.</p>
<pre><code>rebol2&gt;&gt; find "abcd" "z"
== none

rebol2&gt;&gt; select [a 10 b 20] 'c
== none
</code></pre>
<h2>Ren-C Divided NONE!s roles across NULL, VOID, and BLANK!</h2>
<ul>
<li>
<p><strong>NULL</strong> - an "isotopic" state of WORD! that couldn't be put in BLOCK!s.  Anywhere that NONE! would be used to signal a soft failure operation--like FIND or SELECT--would use ~null~.</p>
<pre><code>&gt;&gt; null
== ~null~  ; isotope

&gt;&gt; find "abcd" "z"
== ~null~  ; isotope

&gt;&gt; select [a 10 b 20] 'c
== ~null~  ; isotope

&gt;&gt; append [a b c] null
** Error: APPEND doesn't allow ~null~ isotope
</code></pre>
</li>
<li>
<p><strong>VOID</strong> - the result of things that are effectively "no ops".  Unlike nulls, they will vanish in-between expressions, and when functions like APPEND get them as an argument they are treated as no-ops:</p>
<pre><code>&gt;&gt; void
; void

&gt;&gt; if null [print "Doesn't print as NULL is falsey"]
; void

&gt;&gt; 1 + 2 if null [print "Voids disappear..."]
== 3

&gt;&gt; append [a b c] void
== [a b c]
</code></pre>
<p>(At one time void was also the state of unset variables, but that is now the isotopic state of void...currently called "nihil")</p>
</li>
<li>
<p><strong>BLANK!</strong> was represented by a lone underscore ( <strong><code>_</code></strong> ) and could be put into blocks:</p>
<pre><code>&gt;&gt; append [a b c] _
== [a b c _]
</code></pre>
<p>It retained the choice to be falsey:</p>
<pre><code>&gt;&gt; if _ [print "Won't print because blanks are falsey"]
</code></pre>
</li>
</ul>
<h2>Question One: Could BLANK! Just Be A WORD! ?</h2>
<p>You might wonder if you could just say:</p>
<pre><code>&gt;&gt; _: '_
== _
</code></pre>
<p>This would give you BLANK! as a WORD! that had the behavior of reducing to itself.</p>
<pre><code>&gt;&gt; reduce [_ 1 + 2 _]
== [_ 3 _]
</code></pre>
<p>That could be just a default, and you could redefine it to anything you wanted.  Generally speaking, people do like being able to define words as operators... and _ has historically been a WORD! (Ren-C allows you to use underscores internally to words, so it feels a little bad to take away one word).</p>
<p>But outside of being hardcoded as falsey, what makes BLANK! fairly "built in" is that in the path mechanics, it fills in the empty slots:</p>
<pre><code>&gt;&gt; to path! [_ a]
== /a

&gt;&gt; as block! 'a//b//c
== [a _ b _ c]
</code></pre>
<p>Alternately, we could accomplish a "reified nothing" with a quoted null:</p>
<pre><code>&gt;&gt; to path! [' a]
== /a

&gt;&gt; as block! 'a//b//c
== [a ' b ' c]
</code></pre>
<p>But there's other places the blank is used, such as to opt-out of multi-returns.</p>
<pre><code>&gt;&gt; [_ pos]: transcode "abc def"
; void

&gt;&gt; pos
== " def"
</code></pre>
<p>So freeing it up to be an arbitrary variable feels kind of wrong, as if it were taken for dialects like multi-return you'd be unable to set it as a variable.</p>
<p>This may be an argument for using something like a TAG! instead, so you're not worrying about overlapping with user variables:</p>
<pre><code>[&lt;_&gt; pos]: transcode "abc def"
</code></pre>
<p>Similar arguments have led me to contemplate the dangers of using things like <strong><code>[a b ...]:</code></strong> in case someone has assigned a meaning to the ellipsis.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:">  That might be a good reason to keep <strong><code>...</code></strong>  as a TUPLE! instead of a WORD! exception, because no one could assign it.</p>
<p><strong>I'm pretty sure we should keep _ reserved as a BLANK! datatype, not a WORD!.</strong>  People can still give it arbitrary meanings in dialects, they just can't assign values to it as a variable... and they can't do that with <strong><code>#</code></strong> either or <strong><code>&lt;a&gt;</code></strong> so I can live with it.  Taking it away from the word pool does more good than harm.</p>
<h2>Question Two: Does BLANK! Still Need To Be Falsey?</h2>
<p><em>My feeling is that having blank be falsey doesn't have all that much benefit.</em>  NULL does a better job of it, and really what it does is mess with its usefulness as a placeholder:</p>
<pre><code>&gt;&gt; append [a b c] all [1 &lt; 2, 3 &lt; 4, _]
== [a b c _]  ; would seem nice, but gives error today since ALL is NULL
</code></pre>
<p>Thinking of BLANK! as being "null-like" in terms of non-valuedness is generally a hassle.  It makes you wonder about whether something like DEFAULT should think of it as being assigned or not:</p>
<pre><code>&gt;&gt; item: _

&gt;&gt; item: default [1 + 2]
== ???
</code></pre>
<p>In practice, I prefer the truly non-valued NULL being the only cases that DEFAULT overwrites.  This is because NULL is far more useful than BLANK! when it comes to representing something that you think of as "not being assigned"... as you'll get errors when you try to use it places (e.g. in APPEND).  Trying to use it to represent nothingness invariably leads to stray appearances in blocks (Shixin wrote a lot of code to try to filter them out in Rebmake, prior to it being switched to NULLs)</p>
<p>Also, the asymmetry between BLANK! and NULL were part of a scheme to try and solve what Redbols called "NONE! propagation":</p>
<pre><code>&gt;&gt; second null
** Error: SECOND doesn't take NULL

&gt;&gt; try null
== _

&gt;&gt; second try null
== null
</code></pre>
<p><strong>We still want this general concept, but <a href="https://forum.rebol.info/t/definitional-errors-as-blank-in-null-out-alternative/1880/7">the new idea is that it's VOID which opts out</a> cleanly from these operations, and MAYBE is the operator that produces them.</strong></p>
<p>This makes more sense, and I think it bolsters the argument that BLANK! is less of a falsey-NULL relative...but more of a placeholder value.  I've said "blanks are to blocks what space is to strings".  And space is truthy:</p>
<pre><code>&gt;&gt; if second "a b" [print "Space is truthy"]
Space is truthy

&gt;&gt; if second [a _ b] [print "So why shouldn't blank be truthy?"]
???
</code></pre>
<p><strong>So I Suggest The Removal of BLANK! From Being Falsey</strong>.  This creates some incompatibility in Redbol (which has been using NONE! as a blank substitute).  But it's something that can be worked around.</p>
            <p><small>7 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942</link>
          <pubDate>Thu, 25 Aug 2022 13:50:26 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1942</guid>
          <source url="https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942.rss">BLANK! 2022: Revisiting The Datatype</source>
        </item>
        <item>
          <title>Incomplete TRANSCODEs: Actually an Optimization Problem</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p><strong>Ren-C has a very slick multi-return interface for TRANSCODE.</strong>  The mere request of a "remainder" of data left indicates you're not trying to do a full scan.</p>
<p>Without the request, you get the whole thing:</p>
<pre><code>&gt;&gt; transcode "abc def"
== [abc def]

; ...or...

&gt;&gt; value: transcode "abc def"
== [abc def]

; ...or...

&gt;&gt; [value]: transcode "abc def"
== [abc def]
</code></pre>
<p>With the next position request, just one item and a remainder:</p>
<pre><code>&gt;&gt; [value pos]: transcode "abc def"
== abc

&gt;&gt; pos
== " def"

; ...or...

&gt;&gt; transcode/next "abc def" 'pos
== abc

&gt;&gt; pos
== " def"
</code></pre>
<p>You also know that you're at the end of the input when it returns null, with all the benefits of easy reactions to NULL with IF and ELSE and friends:</p>
<pre><code>&gt;&gt; [value pos]: transcode ""
; null
</code></pre>
<p>Writing foolproof loops to process items are a breeze:</p>
<pre><code>while [true]
    [item utf8]: transcode utf8 else [break]
    print mold item
 ]

; or for the THEN/ELSE haters out there (you know who you are :-P)

while [true]
    if null? [item utf8]: transcode utf8 [
        break
    ]
    print mold item
 ]
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/+1.png?v=9" title=":+1:" class="emoji only-emoji" alt=":+1:"></p>
<h2>This Runs Circles Around Red and R3-Alpha</h2>
<p>For starters: neither support strings as input--because the scanner is built for reading UTF-8 files...and both R3-Alpha and Red unpack strings into fixed-width encodings.  So if you have string input, you have to pay for a copy encoded as UTF-8 via TO BINARY!.  (<a href="https://forum.rebol.info/t/realistically-migrating-rebol-to-utf8-everywhere/374">Ren-C's UTF-8 Everywhere</a> wins again!)</p>
<p>R3-Alpha unconditionally returns a block with the last element as a remainder, whether you ask for one item via /NEXT or not:</p>
<pre><code>r3-alpha&gt;&gt; transcode to binary! "abc def"
== [abc def #{}]

r3-alpha&gt;&gt; transcode/next to binary! "abc def"
== [abc #{20646566}]

r3-alpha&gt;&gt; transcode/next to binary! ""
== [#{}]
</code></pre>
<p>So if you were transcoding an entire input, you have to TAKE/LAST an always-empty binary off of the result.</p>
<p>But you are using /NEXT you have to PICK out the element from the start of the array and the remainder from the end.  But you need to notice the exception of no-value-produced where the block is length 1 instead of 2.</p>
<p>That's awkward, but as usual... <em>Red somehow manages to make an incompatible interface that is as much worse as it is better:</em></p>
<p>The better part is that if you don't ask for /NEXT you just get the block back, like in Ren-C:</p>
<pre><code>red&gt;&gt; transcode to binary! "abc def"
== [abc def]
</code></pre>
<p>But the /NEXT interface is outright broken:</p>
<pre><code>red&gt;&gt; transcode/next to binary! "abc def"
== [abc #{20646566}]

red&gt;&gt; transcode/next to binary! ""
== [[] #{}]
</code></pre>
<p>It might look better because you don't have to guess about which position to find the remainder in--it's always in the second slot.  But it has a fatal flaw: you can't distinguish the result state of scanning <code>"[]"</code> and any string with nothing but comments and whitespace.</p>
<p>Consider this very basic loop to scan one item at a time and print it:</p>
<pre><code>red&gt;&gt; utf8: to binary! "abc def"

red&gt;&gt; while [not tail? utf8] [
     set [item utf8] transcode/next utf8
     print mold item
]
abc
def
</code></pre>
<p>You get two items.  But what if you had something that was--say--a comment:</p>
<pre><code>red&gt;&gt; utf8: to binary! "; I'm just a comment"

red&gt;&gt; while [not tail? utf8] [
     set [item utf8] transcode/next utf8
     print mold item
]
[]
</code></pre>
<p>You get one spurious item.  (They chose BLOCK! for the item, but it wouldn't matter what it was--a NONE! would be just as bad, you're just losing the distinction between empty strings and <code>"#[none]"</code> then.)</p>
<p>If I were prescribing a solution for Red I'd say:</p>
<ul>
<li>
<p>Make /NEXT take a variable to write the next position into</p>
</li>
<li>
<p>Error on <code>#{}</code> input, so anyone doing a TRANSCODE/NEXT knows they are responsible for testing for TAIL? before they call (if they're not sure their input is non-empty)</p>
<ul>
<li>This way an empty remainder returned in the /NEXT variable will uniquely signal the reached-end state</li>
</ul>
</li>
<li>
<p>Make the synthesized product at the tail something ugly but assignable (so not an unset!)</p>
<ul>
<li>an ERROR! saying "end of input" is at least informative in case it winds up getting treated as an actual value somewhere</li>
</ul>
</li>
</ul>
<p>That would at least give them patterns like:</p>
<pre><code>if not tail? utf8 [  ; needed if you're not sure it's non-empty
    while [true] [
        item: transcode/next utf8 'utf8
        if tail? utf8 [break]
        print mold item
    ]
]
</code></pre>
<p><em>(Having NULL is clearly better as a non-valued state (with isotope states fleshing out the picture)...and my <a href="https://forum.rebol.info/t/why-or-why-not-have-unset-in-rebol-like-languages/113/2">bafflement at Nenad's blindness</a> when confronted with what should be clear as day is as relevant as it was 6-plus-years ago.  And of course we see they'd actually need SET/ANY to do this right if you were allowing #[unset!]...but Ren-C's design has no need of that.)</em></p>
<h2>Ren-C Also <em>Thrashes</em> R3-Alpha and Red In Error Handling</h2>
<p>Ren-C TRANSCODE has these potential behaviors:</p>
<ul>
<li>
<p>RETURN a BLOCK! (if plain TRANSCODE)</p>
</li>
<li>
<p>RETURN an ANY-VALUE! or NULL (if TRANSCODE/NEXT)</p>
</li>
<li>
<p>It can do a "hard FAIL"</p>
<ul>
<li>
<p>This would happen if you asked something fundamentally incoherent...like asking to TRANSCODE a with input that was non-UTF-8...like a GOB!, or something like that</p>
</li>
<li>
<p>Such errors are only interceptible by a special SYS.UTIL.ENTRAP method--they are not supposed to be easy to gloss over and unlikely to have meaningful mitigation.  So only special sandboxing situations (like writing consoles that print out the error) are supposed to trap them.</p>
</li>
</ul>
</li>
<li>
<p>It can RETURN an <em>isotopic ERROR!</em> ("raised error") if something went wrong in the transcoding process itself</p>
<ul>
<li>
<p>This would be something like a syntax error, like  if you asked <strong>transcode "a bc 1&amp;x def"</strong></p>
</li>
<li>
<p>These will be promoted to a hard FAIL if the immediate caller doesn't do something to specially process them.</p>
</li>
<li>
<p>You can casually ignore or intercept these, because you can be confident that it was a formal return result of the thing you just called--not some deeper problem like a random typo or other issue.</p>
</li>
</ul>
</li>
</ul>
<p>I won't rehash the entire <a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852">"why definitional errors are foundational"</a> post, but TRANSCODE was one of the first functions that had to be retrofitted to use them.</p>
<pre><code>&gt;&gt; transcode "a bc 1&amp;x def" except e -&gt; [print ["Error:" e.id]]
Error: scan-invalid
</code></pre>
<p><strong>The definitionality is extremely important!</strong>  I spent a long time today because in the bootstrap shim I had a variation of transcode...parallel to this in R3-Alpha:</p>
<pre><code>r3-alpha&gt;&gt; transcode: func [input] [
               prnit "My Transcode Wrapper"  ; oops, typo
               return transcode input
           ]

r3-alpha&gt;&gt; if not attempt [transcode to binary! "abc def"] [print "Bad input"]
Bad input
</code></pre>
<p><em><strong>But the input isn't bad!!!</strong></em>  This leads to a nightmare of trying to figure out what was going wrong.  I had just one of those nightmares today in the bootstrap executable when tinkering with the shim implementation of TRANSCODE.  A bug in the shim was leading to silently skipping work that should have been done, because the caller wanted to be tolerant of bad transcode input.</p>
<p>There's simply no practical way of working on code of any complexity without something like definitional failures, and experience has proven this day after day.</p>
<h2>Getting Incomplete Results Via R3-Alpha's /ERROR</h2>
<p>R3-Alpha offered this feature:</p>
<pre><code>/error -- Do not cause errors - return error object as value in place
</code></pre>
<p>The intended use is that you might want the partial input of what had been successfully scanned so far.  If the code went and raised an error, you could trap that error.  But you wouldn't have any of the scanned items.</p>
<p>It would put it any ERROR! as the next-to-last item in the block, with the remainder after that:</p>
<pre><code>&gt;&gt; transcode/error to binary! "a bc 1&amp;x def"
== [abc make error! [
    code: 200
    type: 'Syntax
    id: 'invalid
    arg1: "pair"
    arg2: "1&amp;x"
    arg3: none
    near: "(line 1) a bc 1&amp;x def"
    where: [transcode]
] #{20646566}]

&gt;&gt; to string! #{20646566}
== " def"  ; wait...why isn't 1&amp;x part of the "remainder"
</code></pre>
<p>It's clumsy to write the calling code (or to read it...testing to see if the next-to-last-item is an ERROR! and reacting to that.</p>
<p><em>(Also: What if there was some way to represent ERROR! values literally in source?  This would conflate with such a block that was valid...but just incidentally had an ERROR! and then a BINARY! in the last positions.)</em></p>
<p>But the thing that had me most confused about it was the remainder.  Notice above you don't get  <code>1&amp;x</code> as the start of the stuff it couldn't understand.</p>
<p>Was it trying to implement some kind of recoverable scan?  What would that even mean?  <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=9" title=":thinking:" class="emoji" alt=":thinking:"></p>
<p><strong>Ultimately I think this was just a leaking of an implementation detail as opposed to any reasonable attempt at recoverable scanner.</strong>  It only didn't tell you where the exact tail of the successfully scanned material was because it did not know.</p>
<p>The scanning position is based on token consumptions, and so if you started something like a block scan and it saw a <strong>[</strong> then it forgets where it was before that.  Then if something inside the block goes bad, it will just give you a remainder position somewhere inside that--<em>completely forgetting about how many nesting levels it was in</em>.</p>
<p>So what you were getting was a crappier implementation of scanning one by one, and remembering where you were before the last bad scan:</p>
<pre><code>pos: input
error: null
block: collect [
   while [true] [
       keep [# pos]: transcode pos else [
           break
       ] except e -&gt; [
           error: e
           break
       ]
   ]
]
</code></pre>
<p>That gives you a proper version, setting error if something happened and giving you the block intact.</p>
<h2>So Finally... We See It's An Optimization Problem</h2>
<p>Question is if there's some way of folding this into TRANSCODE, so it's doing the looping and collecting efficiently for you.</p>
<p>But this interface wants to get back a "remainder".  And I kind of hate to sacrifice the property that TRANSCODE's asking for a remainder means scan one element.  :-/</p>
<p>I guess we <em>could</em> say that there's a logical process you follow:</p>
<ul>
<li>
<p>The output parameter is called REST (instead of NEXT)</p>
</li>
<li>
<p>An additional output parameter is added for ERROR</p>
</li>
<li>
<p>If you ask for the REST and <em>don't</em> ask for an ERROR, that suggests you want to encode a single item</p>
<ul>
<li>
<p>You could have just intercepted the error if you wanted it</p>
</li>
<li>
<p>Nothing is lost because there wouldn't be any partial results to miss (if you're only doing one item, there will always be zero items completed before it)</p>
</li>
</ul>
</li>
<li>
<p>If you ask for the REST and <em>do</em> ask for an error, then it assumes you must not want the one-item-only semantics after all.</p>
</li>
</ul>
<p>It's a little bit awkward because it conflates partial output with fully successful output</p>
<pre><code>&gt;&gt; [block rest error]: transcode "a bc"
== [a bc]

&gt;&gt; error
; null

&gt;&gt; [block rest error]: transcode "a bc 1&amp;x def"
== [a bc]  ; no indication something failed

&gt;&gt; error? error  ; you'd have to remember to check this
== #[true]
</code></pre>
<p>That's not a deal breaker, and Ren-C makes it easy to work with, using <a href="https://forum.rebol.info/t/circling-multi-returns-choose-which-is-expression-result/1587">circling an output in multi-return</a> to make it the primary return result:</p>
<pre><code>&gt;&gt; [block rest @error]: transcode "a bc"
; null

&gt;&gt; [block rest @error]: transcode "a bc 1&amp;x def"
== make error! [...]
</code></pre>
<p><strong>What's much more jarring to me is the flipping back and forth of whether you're asking for a full transcode or not.</strong></p>
<pre><code>&gt;&gt; x: transcode "abc def"
== [abc def]

&gt;&gt; [x y]: transcode "abc def"
== abc

&gt;&gt; [x y z]: transcode "abc def"
== [abc def]
</code></pre>
<p>Ick.  Should I be willing to bend on the transcode "requested parameter" behavior in this case, by adding a /ONE refinement?</p>
<pre><code>&gt;&gt; [block rest]: transcode "abc def"
== [abc def]

&gt;&gt; rest
== #{}  ; kind of useless, but honest

&gt;&gt; [block rest]: transcode/one "abc def"
== abc

&gt;&gt; rest
== " def"
</code></pre>
<p>That would make me feel grief, as it loses one of the first showcases of return value sensitivity.  <em>And it irks me to think that the beauty is ultimately being given up for the sake of what amounts to an optimization.</em></p>
<h2>Answer For Now: Kill Off /ERROR</h2>
<ul>
<li>
<p>The answer /ERROR has been giving back in error cases for the remainder is sketchy, and I don't want to figure out how to fix it.</p>
</li>
<li>
<p>You can get the behavior reliably just by intercepting errors going one transcode item at a time.</p>
</li>
<li>
<p>This is a good opportunity to write tests of item-by-item scanning with error handling</p>
</li>
<li>
<p>Red added a bunch of refinements on transcode [/next /one /prescan /scan /part /into /trace], and they didn't pick up /error themselves</p>
</li>
</ul>
<p>Speaking of adding lots of refinements: I also want to get away in general from investments in weird C scanner code and hooks (<em>especially</em> if it's just an optimization).</p>
<p>What we should be investing in is more fluid mixture of PARSE of strings/binary with the scanner.  e.g. we should have ways of knowing what line number you're at during the parse for any combinator, and just generally pushing on that.  Adding TRANSCODE parameters up the wazoo isn't a winning strategy.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/incomplete-transcodes-actually-an-optimization-problem/1940">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/incomplete-transcodes-actually-an-optimization-problem/1940</link>
          <pubDate>Mon, 22 Aug 2022 15:09:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1940</guid>
          <source url="https://forum.rebol.info/t/incomplete-transcodes-actually-an-optimization-problem/1940.rss">Incomplete TRANSCODEs: Actually an Optimization Problem</source>
        </item>
  </channel>
</rss>

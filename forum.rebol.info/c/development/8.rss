<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Development - AltRebol</title>
    <link>https://forum.rebol.info/c/development/8</link>
    <description>Topics in the &#39;Development&#39; category Discussion of the development of Rebol itself: language design, implementation and standard library.</description>
    
      <lastBuildDate>Fri, 29 Mar 2024 21:22:15 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/8.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Should SET-WORD!s Propagate Undecayed Packs?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Packs are antiform blocks, which decay if not specifically handled.</p>
<pre><code>&gt;&gt; pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; a: pack [1 2]
== 1

&gt;&gt; a
== 1
</code></pre>
<p>From time to time, I've wondered if there's a good reason why the plain SET-WORD! shouldn't propagate the pack:</p>
<pre><code>&gt;&gt; a: pack [1 2]
== ~['1 '2]~  ; anti  (hypothetical)

&gt;&gt; a
== 1
</code></pre>
<p>One rationale is that intuitively, <strong>a:</strong> should be a synonym for <strong>[a]:</strong>, e.g. "unpack one item" is implicit.</p>
<p>But that just bumps the question to the next one we might ask: why doesn't a multi-return without a "circled" result just evaluate to the whole pack?</p>
<p>It looks to make some sense at first, it allows you to chain indefinitely:</p>
<pre><code>&gt;&gt; [a b]: [c d]: pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; a
== 1

&gt;&gt; b
== 2

&gt;&gt; c
== 1

&gt;&gt; d
== 2
</code></pre>
<p>Though it feels a little bit unsettling when you drop it down:</p>
<pre><code>&gt;&gt; [a b]: [c]: pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; a
== 1

&gt;&gt; b
== 2

&gt;&gt; c
== 1
</code></pre>
<p>But we could argue that if you're bothered, then you use circling (currently <code>@c</code>, but with FENCE! proposed to be <code>{c}</code>).  Note in the below example you'd have to use <code>/b</code> in order to indicate you were okay with unpacking more values than available.</p>
<pre><code>&gt;&gt; [a /b]: [{c}]: pack [1 2]
== 1

&gt;&gt; a
== 1

&gt;&gt; b
== ~null~  ; anti

&gt;&gt; c
== 1
</code></pre>
<p>We could then make a choice if <strong>a:</strong> was a synonym for <strong>[a]:</strong> or for <strong>[{a}]:</strong></p>
<h2>
<a name="most-recent-motivation-for-thinking-about-this-1" class="anchor" href="https://forum.rebol.info#most-recent-motivation-for-thinking-about-this-1"></a>Most Recent Motivation For Thinking About This</h2>
<p>I rewrote <a href="https://forum.rebol.info/t/speed-of-uparse/2177/3">some code in an example</a> from this:</p>
<pre><code>[^result' remainder]: parser input except e -&gt; [
    remainder: input  ; succeed on parser fail but don't advance input
    return null
]
return unmeta result'  ; return successful parser result
</code></pre>
<p>...to this:</p>
<pre><code>return [@ remainder]: parser input except [
    remainder: input  ; succeed on parser fail but don't advance input
    return null
]
</code></pre>
<p>The idea is that the parser being called has multiple return results... the first is the synthesized value, the second is the amount it advanced.  <em>(There's a third result on some parsers of "pending items", but this OPTIONAL combinator has an "autopipe" which is just bubbling the pending items through in the order of successful parsers called...so the third result is specialized out on its interface and on the parsers it calls.)</em></p>
<p><strong>However, the synthesized value can itself be a pack.</strong>  This means that if we named a variable in the slot where the <code>@</code> is, then that pack would be decayed to store in the variable unless we used a ^META result.</p>
<p>So does the act of not-naming and just circling subvert the decay?  Or should the circled result not be decayed even if the variable is?</p>
<pre><code>&gt;&gt; [{a} b]: pack [pack [1 2] 3]
== ~['1 '2]~  ; anti  (or should it be decayed to 1?)

&gt;&gt; a
== 1

&gt;&gt; b
== 3
</code></pre>
<p>It's a different--but related--question.  It seems it should align with the behavior of plain assignments:</p>
<pre><code>&gt;&gt; a: pack [1 2]
== ~['1 '2]~  ; anti  (implied if the above behavior is chosen)

&gt;&gt; a
== 1
</code></pre>
<h2>
<a name="not-100-certain-but-i-think-undecayed-propagation-is-good-2" class="anchor" href="https://forum.rebol.info#not-100-certain-but-i-think-undecayed-propagation-is-good-2"></a>Not 100% Certain, But I Think Undecayed Propagation Is Good</h2>
<p>I'll point out that it's possible to DECAY things pretty easily, but you can't recover a pack after it has been decayed.</p>
<p>So I'm getting the feeling that it's probably best to decay the assignments, but propagate the undecayed pack.  It looks like the more general and useful behavior...even if it seems a bit confusing.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-set-word-s-propagate-undecayed-packs/2178">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-set-word-s-propagate-undecayed-packs/2178</link>
          <pubDate>Fri, 29 Mar 2024 21:22:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2178</guid>
          <source url="https://forum.rebol.info/t/should-set-word-s-propagate-undecayed-packs/2178.rss">Should SET-WORD!s Propagate Undecayed Packs?</source>
        </item>
        <item>
          <title>Speed of UPARSE</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p>Iâ€™m just wondering if any benchmarking has been done on UPARSE. How does it compare to PARSE in Red or in Rebol? Or to parser combinators in Haskell? For that matter, how does it compare to an ordinary recursive-descent parser handwritten in Ren-C?</p>
<p>(Yes, I know UPARSE is unoptimised and slow. But it would be interesting to know <em>how</em> slow.)</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/speed-of-uparse/2177">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/speed-of-uparse/2177</link>
          <pubDate>Fri, 29 Mar 2024 06:47:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2177</guid>
          <source url="https://forum.rebol.info/t/speed-of-uparse/2177.rss">Speed of UPARSE</source>
        </item>
        <item>
          <title>VOID Branches (not branches that evaluate to void)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>I've mentioned before that <a href="https://forum.rebol.info/t/augment-add-parameters-and-refinements-after-the-fact/1216">AUGMENT can be used to implement the legacy SWITCH/DEFAULT behavior</a>.</p>
<p>But looking at what seems like the "correct" formulation of that code today, we get:</p>
<pre><code>switch-d: enclose (augment :switch [
    /default "Default case if no others are found"
        [block!]
]) lambda [f [frame!]] [
    let def: f.default
    eval f else (maybe def)
]
</code></pre>
<p>It points out the existence of <em>void branches</em>... so not branches that evaluate to void (e.g. <code>[void]</code>) but code that evaluates to a branch to run, and that branch is void.</p>
<p>Considering this specific usage only, it suggests a semantic for ELSE of a VOID branch, which is that you want it to act like there was no branch at all.  e.g. as if you'd written just <strong><code>eval f</code></strong> with no ELSE.</p>
<pre><code> &gt;&gt; if false [1 + 2]
 == ~void~  ; anti

 &gt;&gt; if false [1 + 2] else [10 + 20]
 == 30

 &gt;&gt; if false [1 + 2] else (void)
 == ~void~  ; anti
</code></pre>
<p>Would the same apply to THEN?</p>
<pre><code> &gt;&gt; if true [1 + 2]
 == 3

 &gt;&gt; if true [1 + 2] then [10 + 20]
 == 30

 &gt;&gt; if true [1 + 2] then (void)
 == 3
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>I don't know if it's great, but it's certainly better than evaluating to NULL (via some void-in-null-out rationale) because that would trigger an ELSE branch.</p>
<pre><code> &gt;&gt; if true [1 + 2] then (void) else [print "we don't want this."]
 we don't want this.
</code></pre>
<p>But what should other branching constructs do, like CASE or SWITCH?  Might a void branch suggest "opting out" of that particular branch?</p>
<pre><code> case [
     1 &lt; 2 (void)
     3 &lt; 4 [print "Should this run?"]
 ]
</code></pre>
<p>A CASE (at least CASE/ALL) is supposed to be synonymous with a series of IF statements.  And IF can't exactly do that, unless it decided to be NIHIL...</p>
<pre><code>&gt;&gt; 1 + 2 if false (void)
== 3
</code></pre>
<p>That would be a bit weird, but, it does sort of parallel what happens when ELSE and THEN effectively vaporize themselves.</p>
<p>As with most things on the edge of usefulness, I don't know about this... other than the situation of wanting to revoke the ELSE branch in SWITCH-D.  I'll keep an eye on it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/void-branches-not-branches-that-evaluate-to-void/2176">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/void-branches-not-branches-that-evaluate-to-void/2176</link>
          <pubDate>Thu, 28 Mar 2024 13:07:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2176</guid>
          <source url="https://forum.rebol.info/t/void-branches-not-branches-that-evaluate-to-void/2176.rss">VOID Branches (not branches that evaluate to void)</source>
        </item>
        <item>
          <title>Haskell parser combinators</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Iâ€™ve seen a few parsing-related threads recently in this forum. I havenâ€™t been commenting much on them, since I donâ€™t have enough experience with UPARSE (or for that matter historical PARSE) to say anything helpful.</p>
<p>On the other hand, I <em>do</em> have a lot of experience with parser combinators in Haskell. In terms of structure and purpose, theyâ€™re probably the concept most similar to UPARSE that Iâ€™ve seen from another language. So I thought Iâ€™d write this post in the hope that something, somewhere, might eventually prove useful somehow.</p>
<h2>
<a name="high-level-overview-1" class="anchor" href="https://forum.rebol.info#high-level-overview-1"></a>High-level overview</h2>
<p>The first and most important thing to realise about parser combinators is that <strong>theyâ€™re not built into the language</strong>. Theyâ€™re simply ordinary libraries which make it easy to construct parsers compositionally.</p>
<p>(I mean, for that matter, UPARSE isnâ€™t built in either. But thereâ€™s a different level of integration with the rest of the language.)</p>
<p>The basic approach is to define a new datatype for parsers, usually called something like <code>Parser a</code>. This is a parser which can process a string (or other datatype), returning a result of type <code>a</code> if it succeeds. Alongside this there will be a set of primitive parsers, most notably <code>char</code> (to parse single characters), <code>return</code> (which always succeeds with a result), and <code>empty</code> (which always fails).</p>
<p>(Of course, practical libraries will have more primitives. <code>megaparsec</code> has <a href="https://hackage.haskell.org/package/megaparsec-9.6.1/docs/Text-Megaparsec.html#g:4">a nice selection</a>, with good comments.)</p>
<p>The most interesting bit is the way these parser combinators are combined to create larger parsers. This, of course, relies on the standard abstractions of Haskell. Two operators are particularly important:</p>
<ul>
<li>Sequencing: <code>p &gt;&gt;= f</code> is a parser which runs <code>p</code> and passes the result to function <code>f</code>, then runs the resulting parser.</li>
<li>Choice: <code>p &lt;|&gt; q</code> is a parser which runs <code>p</code>, then backtracks and runs <code>q</code> if that failed.</li>
</ul>
<p>From these basic elements you can define a very wide range of generic combinators, for instance these useful ones:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">-- sequencing ignoring result
(&gt;&gt;) :: Parser a -&gt; Parser b -&gt; Parser b
p &gt;&gt; q = p &gt;&gt;= \_ -&gt; q

-- Match a whole string
string :: String -&gt; Parser ()
string "" = return ()
string (c:cs) = char c &gt;&gt; string cs

-- 1 or more
some :: Parser a -&gt; Parser [a]
some p =
    p &gt;&gt;= \first -&gt;
    many p &gt;&gt;= \rest -&gt;
    return (first : rest)

-- 0 or more
many :: Parser a -&gt; Parser [a]
many p = some p &lt;|&gt; return []
</code></pre>
<h2>
<a name="a-basic-implementation-2" class="anchor" href="https://forum.rebol.info#a-basic-implementation-2"></a>A basic implementation</h2>
<p>This is all a little abstract, though. Probably the easiest way to understand parser combinators is to implement them.</p>
<p>A basic implementation is quite simple. A parser is just a function which takes in a string, and on success returns the result alongside the unparsed portion of the string:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">newtype Parser a = Parser (String -&gt; Maybe (String, a))
</code></pre>
<p>You then run the parser simply by unwrapping the function and applying it to your input:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">runParser :: Parser a -&gt; String -&gt; Maybe (String, a)
runParser (Parser p) input = p input
</code></pre>
<p>Simple parsers work as youâ€™d expect:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">char :: Char -&gt; Parser ()
char c = Parser $ \input -&gt; case input of
    (c':cs) | c == c' -&gt; Just (cs, ())
    _ -&gt; Nothing

return :: a -&gt; Parser a
return a = Parser $ \input -&gt; Just (input, a)

empty :: Parser a
empty = Parser $ \_ -&gt; Nothing
</code></pre>
<p>The combinators require more elaborate state-threading, but are still straightforward:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">(&gt;&gt;=) :: Parser a -&gt; (a -&gt; Parser b) -&gt; Parser b
p &gt;&gt;= f = Parser $ \input -&gt;
    case runParser p input of
        Nothing -&gt; Nothing
        Just (partiallyParsed, a) -&gt;
            runParser (f a) partiallyParsed

(&lt;|&gt;) :: Parser a -&gt; Parser a -&gt; Parser a
p &lt;|&gt; q = Parser $ \input -&gt;
    case runParser p input of
        Just result -&gt; Just result
        Nothing -&gt; runParser q input
</code></pre>
<p>This simple code suffices for a surprisingly wide variety of tasks. For instance, a slight variant is present in the base library as <a href="https://hackage.haskell.org/package/base-4.16.3.0/docs/Text-Read.html#t:ReadS"><code>ReadS</code></a>. (The variation is that <code>ReadS</code> can produce multiple results.)</p>
<h2>
<a name="managing-backtracking-3" class="anchor" href="https://forum.rebol.info#managing-backtracking-3"></a>Managing backtracking</h2>
<p>Unfortunately, <strong>this has serious problems with any larger-scale use</strong>. For one thing, it canâ€™t do error reporting beyond â€˜it failed somewhereâ€™. But there are even bigger problems with this implementation of the choice combinator <code>(&lt;|&gt;)</code>:</p>
<ol>
<li>It behaves unpredictably: any error anywhere will result in the parser backtracking to the last choice, and so on until every single choice has been exhausted. This is bad for the time complexity, plus it leaves you no chance of ever reporting errors nicely.</li>
<li>It holds onto the input string during the whole time <code>p</code> is executing. This creates a space leak, which grows larger the more nested choices you have.</li>
</ol>
<p>The first parser combinator library to solve these issues was <code>Parsec</code>. Its design is described in <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/parsec-paper-letter.pdf">this paper</a> (which seems very readable). I wonâ€™t describe its implementation hereâ€¦ but the basic idea is simple to summarise: each parser keeps track of what itâ€™s consumed, and <strong>commits to a parser as soon as itâ€™s consumed any characters</strong>.</p>
<p>Some parsers require no changes under this new semantics. For instance, <code>string "first word" &lt;|&gt; string "second word"</code> works without problems. If it sees an input character <code>f</code>, the first choice <code>string "first word"</code> matches immediately, meaning the library can commit to the first parser, and know that the second parser never needs to run. On the other hand, upon seeing an input character <code>'s'</code>, that first parser will fail on that very first character: since no characters have been consumed, control passes over to the second parser to succeed or fail.</p>
<p>On the other hand, more elaborate lookahead becomes more difficult. For instance, <code>string "word 1" &lt;|&gt; string "word 2"</code> no longer works: as soon as this parser sees <code>'w'</code>, it matches the first parser, so the second parser will never be run.</p>
<p>To solve this, Parsec introduces a new primitive combinator: <code>try</code>, which creates a parser which never consumes characters on failure. The effect of this is to allow backtracking over whatever is in the <code>try</code>. For this example, <code>try (string "word 1") &lt;|&gt; string "word 2"</code> would work as expected.</p>
<p>The nice thing about this approach is the control it gives you. For instance, I can write things like:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">(try (string "App") &gt;&gt; string "le") &lt;|&gt; string "Apricot"
</code></pre>
<p>Here, as soon as the parser reaches a second <code>'p'</code>, it can commit to the first branch. But if it sees another character, itâ€™s still able to backtrack through the <code>string "App"</code> and move on to the second branch. Of course, this is a contrived example â€” but in general, being able to specify the control flow of your parser like this is exceedingly useful in larger parsers.</p>
<h2>
<a name="what-use-is-this-for-rebol-4" class="anchor" href="https://forum.rebol.info#what-use-is-this-for-rebol-4"></a>What use is this for Rebol?</h2>
<p>Quite probably, none at all.</p>
<p>But like I said, Iâ€™m hoping potentially some of this might end up useful somewhere. If it can act as inspiration which helps solve any problems, Iâ€™m happy.</p>
<p>And, of course, now that we have this thread for it, feel free to ask me any questions about parser combinators you might have!</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/haskell-parser-combinators/2173">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/haskell-parser-combinators/2173</link>
          <pubDate>Mon, 11 Mar 2024 15:08:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2173</guid>
          <source url="https://forum.rebol.info/t/haskell-parser-combinators/2173.rss">Haskell parser combinators</source>
        </item>
        <item>
          <title>-&gt; for LAMBDA (or... &quot;LAMBDA-Lite?&quot;)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>So I'm still shoring up a new bootstrap executable, patching around in a 6-years-out-of-date codebase.   It's in some ways a cruel and unusual punishment... but in other ways a good trip down memory lane to revisit decisions that were made, and ask "was that the right decision?"</p>
<p>The 6-year-old EXE defined an enfix form of lambda as <strong><code>=&gt;</code></strong>.  I shifted it to the lighter form as <strong><code>-&gt;</code></strong>.  Contrast:</p>
<pre><code>y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then (lambda [x] [
    assert [x = &lt;yes&gt;]
    1000 + 20
])
assert [y = 1020]

y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then x =&gt; [
    assert [x = &lt;yes&gt;]
    1000 + 20
]
assert [y = 1020]

y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then x -&gt; [
    assert [x = &lt;yes&gt;]
    1000 + 20
]
assert [y = 1020]
</code></pre>
<p><em>(Supplemental: Reddit post on <a href="https://www.reddit.com/r/ProgrammingLanguages/comments/shllr3/whats_the_syntax_of_lambda_expressions_in_your/">"What's the syntax of lambda expressions in your language"</a>)</em></p>
<p><strong>I like the <code>-&gt;</code> and don't think there's a greater purpose for it in the box.</strong>  As with everything else, overriding it is a personal choice.</p>
<h2>
<a name="a-speaking-with-ticshttpsforumrebolinfotspeaking-with-tics-should-quoted-arguments-always-be-apostrophed1359-note-1" class="anchor" href="https://forum.rebol.info#a-speaking-with-ticshttpsforumrebolinfotspeaking-with-tics-should-quoted-arguments-always-be-apostrophed1359-note-1"></a>A <a href="https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359">Speaking-With-Tics</a> Note</h2>
<p>Mechanically getting this to work is non-trivial:</p>
<p><a href="https://forum.rebol.info/t/the-most-vexing-evaluation-lambda-meets-then-else/1361" class="inline-onebox">The Most Vexing Evaluation: LAMBDA meets THEN/ELSE</a></p>
<p>Part of what makes it non-trivial is the "literal lookback" by which <strong><code>-&gt;</code></strong> infixedly snatches the X without letting it evaluate.</p>
<p><a class="mention" href="https://forum.rebol.info/u/bradrn">@bradrn</a> might argue such mechanics shouldn't be necessary, because source-level non-evaluation should be explicit, e.g. <strong><code>'x -&gt; [...]</code></strong></p>
<pre><code>y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then 'x -&gt; [
    assert [x = &lt;yes&gt;]
    1000 + 20
]
assert [y = 1020]
</code></pre>
<p>But that's one more stroke of key than I want, and one more piece of dirt than I want to see.  <em>I know from context that slot is a variable name, in the most common case.</em>  I'm not upset by intricate work to faciliate it, if it actually works (and empowers other creative things).  So I need to see hard disproofs before sacrificing what I consider to be "the point" of the design.</p>
<p>I'm always ready to look at it from a further perspective to see a "greater point".  But still--from where I stand--that apostrophe sucks relative to not having it.  (And if you read the details of the implementation post, the only reason it's allowed to work in a quoted slot is because of left literalism, so...)</p>
<h2>
<a name="what-about-multiple-arguments-2" class="anchor" href="https://forum.rebol.info#what-about-multiple-arguments-2"></a>What About Multiple Arguments?</h2>
<p>Notationally there are questions about this form of lambda.  Does it use a block for multiple arguments?</p>
<pre><code>&gt;&gt; foo: [a b] -&gt; [a + b + 20]

&gt;&gt; foo 400 600
== 1020
</code></pre>
<p>It could, but you could be weirder:</p>
<pre><code>foo: a.b -&gt; [a + b + 20]

foo: a/b -&gt; [a + b + 20]
</code></pre>
<p>This would look a little tighter with branching, I think, since it wouldn't compete with the branches:</p>
<pre><code>case [
    ...
] then [a b] -&gt; [
    ...
]

case [
    ...
] then a.b -&gt; [
    ...
]
</code></pre>
<p><em>But wait, you'd never use it with a branch... because a branch only produces one value.</em></p>
<p>UNLESS... what if what this form of lambda did was unpack packs?</p>
<pre><code>case [
    true [pack [10 + 20, 3 + 4]]  ; makes antiform ~['30 '7]~
    ...
] then [a b] -&gt; [
    assert [a = 30, b = 7]
]

case [
    true [pack [10 + 20, 3 + 4]]
    ...
] then a -&gt; [
    assert [a = 30]
]
</code></pre>
<p>So I've been thinking this is what it should actually do.  It means -&gt; won't be a good way to define functions or lambdas generally, but you have FUNC(TION) and LAMBDA for that.</p>
<p>I don't know that enabling a lighter notation like <strong><code>a.b</code></strong> or <strong><code>a/b</code></strong> is worth it.</p>
<pre><code>case [
    true [pack [10 + 20, 3 + 4]]
    ...
] then a.b -&gt; [
    assert [a = 30, b = 7]
]

case [
    true [pack [10 + 20, 3 + 4]]
    ...
] then a/b -&gt; [
    assert [a = 30, b = 7]
]
</code></pre>
<p>Maybe just confusing, and limits what you can put in the spec.  Easier to add later if it seems useful than put it in now and take out later.</p>
<h2>
<a name="is-there-a-good-name-for-lambda-lite-3" class="anchor" href="https://forum.rebol.info#is-there-a-good-name-for-lambda-lite-3"></a>Is There A Good Name For "Lambda Lite"?</h2>
<p>We could call it an "unpacking lambda".  Maybe it's controlled with a refinement:</p>
<pre><code> &gt;&gt; foo: lambda/unpack [a b] [a + b + 20]

 &gt;&gt; foo pack [400 600]
 == 1020
</code></pre>
<p>Then <strong><code>-&gt;: :lambda/unpack</code></strong></p>
<p>We could just call it <em>"an unpacker"</em>.</p>
<pre><code> &gt;&gt; foo: unpacker [a b] [a + b + 20]

 &gt;&gt; foo pack [400 600]
 == 1020
</code></pre>
<p>Then <strong><code>-&gt;: :unpacker</code></strong></p>
<p>The problem with calling it an "unpacker" is that 9 (or more) times out of 10 it will only take a single argument and not unpack anything.  So it seems better to classify it as a shade of distinction on lambda, but still when you point to an <code>-&gt;</code> on the screen say <em>"then it passes the argument to the lambda..."</em></p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/for-lambda-or-lambda-lite/2172">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/for-lambda-or-lambda-lite/2172</link>
          <pubDate>Sun, 10 Mar 2024 15:21:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2172</guid>
          <source url="https://forum.rebol.info/t/for-lambda-or-lambda-lite/2172.rss">-&gt; for LAMBDA (or... &quot;LAMBDA-Lite?&quot;)</source>
        </item>
        <item>
          <title>Antiform TAG! As &quot;Triggers an Error On Access&quot; Type</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>In the post <a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604">"Shades of Distinction In Non-Valued Intents"</a>, I had originally written:</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1604">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604/1">Shades of Distinction In Non-Valued Intents</a>
</div>
<blockquote>
<p>Eventually the NULL state became the isotopic status of the WORD! null, so a <strong>~null~</strong> antiform.</p>
<p>It joined <strong>~true~</strong> and <strong>~false~</strong> as being antiforms you could test for truthiness and falseyness. But if you were okay with getting an error on conditional testing, any other word could be used:</p>
<pre><code class="lang-plaintext">  config: ~initialize-system-not-called~

  initialize-system: func [
      {Let's say this function reads the config file}
  ][
      ...
      config: [...]
  ]
</code></pre>
<p>This usually causes a nice labeled message anytime someone tries to use CONFIG:</p>
<p>Going this route would create a pain point for anyone who thought they were going to test for whether you had a config initialized by testing <strong>if config [...]</strong>. So that has to be considered as whether it's what you want.</p>
</blockquote>
</aside>
<p>I've come to question this as things have gone on, to where I'm wondering if all antiform words should be reserved by the system (there are system purposes for the ~end~ antiform, for instance).</p>
<p>A generic "error trigger" might come from something like antiform TAG!, permitting spaces:</p>
<pre><code>config: ~&lt;INITIALIZE-SYSTEM not called&gt;~

initialize-system: func [
    {Let's say this function reads the config file}
][
    ...
    config: [...]
]

&gt;&gt; config
** Error: INITIALIZE-SYSTEM not called
</code></pre>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/antiform-tag-as-triggers-an-error-on-access-type/2170">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/antiform-tag-as-triggers-an-error-on-access-type/2170</link>
          <pubDate>Sat, 09 Mar 2024 08:49:19 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2170</guid>
          <source url="https://forum.rebol.info/t/antiform-tag-as-triggers-an-error-on-access-type/2170.rss">Antiform TAG! As &quot;Triggers an Error On Access&quot; Type</source>
        </item>
        <item>
          <title>Renaming SPECIFIER =&gt; CONTEXT ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>There was a typeset in historical Rebol that was called ANY-OBJECT!, that tried to pull together anything that had WORD! keys that could be used as a binding target:</p>
<pre><code>r3-alpha&gt;&gt; help any-object!
ANY-OBJECT! is a typeset of value: make typeset! [
    object! module! error! task! port!
]
</code></pre>
<p>I had sort of a naming philosophy (which I still have) that you shouldn't name the category based on one of its instances like this.  Several reasons, but one is that it certainly confuses the implementation when you extract the pointed-to entity out of a cell:</p>
<pre><code> if (Cell_Type(cell) == TYPE_ERROR) {
     Object* = Cell_Object(cell);  // wait, but it's an ERROR! not an OBJECT!
     ...
 }
</code></pre>
<p>You could call it <code>AnyObject</code>, I guess.  But that's not the direction I took... instead calling the category ANY-CONTEXT!, and if you saw <code>Context*</code> in the source you wouldn't get confused to thinking it was an extraction from a CONTEXT! cell, because there was no such thing.  You knew it was the implementation of a superclass.</p>
<h2>
<a name="enter-specifier-1" class="anchor" href="https://forum.rebol.info#enter-specifier-1"></a>Enter "Specifier"</h2>
<p>"Specifier"--the aggregated inheritance of binding candidates--has moved from an implementation detail to something which is rising to the surface of user awareness.  For that, it's a lousy name... and am near-certain I want to take "Context" for it.</p>
<p>I like Context better than Environment, as it's shorter and leaves environment for "environment variables" (which being a script-class language Ren-C needs to be better at interacting with than it is today).</p>
<p>We could say the other types are ANY-DICTIONARY!, although the name DICTIONARY! has been suggested as a replacement for MAP!, since we are thinking of MAP more as a function now.  But Dictionary may make more sense for things that only permit "words" as keys.</p>
<p>A CONTEXT! itself--as a composition of other dictionaries (and possibly even just programmatic code that answers value-for-WORD!)--may itself be categorized as an ANY-DICTIONARY!</p>
<h2>
<a name="implementation-variance-needs-work-2" class="anchor" href="https://forum.rebol.info#implementation-variance-needs-work-2"></a>Implementation Variance Needs Work</h2>
<p>So something that has happened in the messy evolution of the code is that the one-size-fits all <strong><code>Context*</code></strong> data structure that backed things like OBJECT!, ERROR!, MODULE! etc. became fractured around the time of Sea of Words and LET.</p>
<p>Modules do not use the same representation, and have to be enumerated completely differently.  There's not really a lot of generic code that acts the same way for OBJECT! and MODULE!, to the point that we'd be better off dispelling the illusion in the C sources and making <strong><code>Module*</code></strong> its own distinct type.</p>
<p>There's a lot to consider here about what the limits of "Amish" implementation are:</p>
<ul>
<li>
<p>I'm pretty much sold on the known-integer-values concept for Frame.  And if <em><strong>I</strong></em> say that drifting away from that destroys what the project <em>is</em>, then it almost certainly does--because I'm known for being iconoclastic about a fair number of Rebol sacred cows.</p>
</li>
<li>
<p>BUT taking a diverging approach for Module from "parallel arrays of Key and Value cell indexed by integer" has proven essential.  Floating variable stubs hanging off the word symbols themselves is an answer that has been critical in giving some legitimacy to modules, and it still passes the "simple" test for me.</p>
<ul>
<li>R3-Alpha was utterly hopeless, and Red will be too if they follow down that path (should they ever get modules).  I do not think this is a problem appropriate to approach with two-parallel-arrays.</li>
</ul>
</li>
<li>
<p>Objects are kind of a wild card.  Given their attempt to be dirt-simple, we might more accurately call the current version "Struct" or "Structure" instead (major annoyance in C naming the variables though, <code>Struct _struct</code>, to dodge the <code>struct</code> keyword?)</p>
<ul>
<li>
<p>People want to dynamically add and remove keys from objects.  Rebol2 and Red don't allow it, and R3-Alpha only permitted growth (so the index numbers stored in words that were bound at an index wouldn't be invalidated)</p>
</li>
<li>
<p>Moving to a more amortized implementation that spreads and shares keys gets you to something more like a database, where you can't point to little contiguous packets of memory and say "there is the object."</p>
</li>
<li>
<p>As I said above, I think this was a necessity for Modules.  But the simple implementation that works quite well for them wouldn't scale to tens of thousands of objects which have keys with the same name.</p>
</li>
<li>
<p>There's plenty of prior art and writeups of how JavaScript engines and others have approached this, and gotten it to be fast.</p>
</li>
</ul>
</li>
</ul>
<p>Anyway, this all kind of culminates in saying that objects are due for a reckoning at some point.  We want to err on the side of simplicity over optimized complexity, but there may be a sufficiently elegant way to attack objects that can grow and shrink effectively and having better code overall than we have today.</p>
<h2>
<a name="anyway-back-to-the-naming-issue-3" class="anchor" href="https://forum.rebol.info#anyway-back-to-the-naming-issue-3"></a>Anyway, Back To The Naming Issue...</h2>
<p>The above sort of reveals why ANY-OBJECT! isn't a good name for ANY-DICTIONARY or ANY-BINDTARGET?.</p>
<p>Hm, maybe we consider ANY-BINDABLE? to be the category for things that can be bound <em>to</em>, and come up with another name for anything that can be bound?  ANY-REFERENCE?</p>
<p>Eh, that sounds confusing.  Dictionary may be about as good as it gets (?)</p>
<p>So basically, Dictionary would be a superclass offering lookup from Word Symbol =&gt; Value.  If you wanted anything else from it, you would have to figure out what subclass it was, because how you do things like enumerate keys and values diverges significantly.</p>
<h2>
<a name="or-maybe-some-unifying-theory-will-come-along-4" class="anchor" href="https://forum.rebol.info#or-maybe-some-unifying-theory-will-come-along-4"></a>Or Maybe Some Unifying Theory Will Come Along?</h2>
<p>It could be, that everything--including OBJECT! and MODULE!, have the "inheritance" powers of what Specifier has today.</p>
<p>Which would mean that you wouldn't have Specifiers.  You'd just ask for the binding of a block and maybe get a MODULE! that inherits from an OBJECT!, or an OBJECT! that inherits from a MODULE!, or a LET! that inherits from a LET! that inherits from an OBJECT!, etc.</p>
<p>It all warrants more thought, and maybe a quick attempt to swap out the current OBJECT! implementation with something like V8's <a href="https://v8.dev/docs/hidden-classes">Hidden Classes</a> and see how it meshes with the system.  I've been so focused on the "bricks" in the language that these sorts of "boring" implementation details have just sort of been left alone while that's sorted out, but now it's getting to the point where there seem to be some answers to guide the shape.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/renaming-specifier-context/2168">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/renaming-specifier-context/2168</link>
          <pubDate>Wed, 06 Mar 2024 18:56:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2168</guid>
          <source url="https://forum.rebol.info/t/renaming-specifier-context/2168.rss">Renaming SPECIFIER =&gt; CONTEXT ?</source>
        </item>
        <item>
          <title>Mapping from Series =&gt; Series By Co-Opting The Key Series</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p>There was an unfinished idea in an old version of the interpreter.  It related to how to deal with problems like trying to make a copy of a block, and make sure any series with the same identity are only copied once in the new structure, and point to that one copied identity.</p>
<p>Rebol2 did not have this behavior:</p>
<pre><code>rebol2&gt;&gt; block: [a]
== [a]

rebol2&gt;&gt; original: reduce [block block]
== [[a] [a]]

rebol2&gt;&gt; append block 'b
== [a b]

rebol2&gt;&gt; original
== [[a b] [a b]]  ; both aliases see the append

rebol2&gt;&gt; duplicate: copy/deep original
== [[a b] [a b]]

rebol2&gt;&gt; append first duplicate 'c
== [a b c]

rebol2&gt;&gt; duplicate
== [[a b c] [a b]]  ; considered by many to be wrong: independent copies
</code></pre>
<p>This post isn't about whether that is right or wrong (and having such questions may seem to some as an indication of <em>"this language is madness! get me to Haskell"</em>, etc. But as I've said this is the game we're playing here so we roll with it.)</p>
<p>But to not get independent copies, you need a way to map series nodes to copies you've already created...so you can consult that mapping before making new copies.  And the direction that was being pursued by the old interpreter I am looking at was to actually do surgery on the originating series nodes, to alter them so they shifted out some of their content, such that they could be their own keys in the mapping.</p>
<p>Generally speaking, all the bits in a series stub are spoken for.  So it would seem there's nowhere to stow a pointer to the new series you are creating in it.  What the implementation was doing was pushing a 4 pointer cell on the data stack, writing one pointer's worth of information from the stub into that cell, then replacing that pointer slot in the stub with the stack index.  Then it wrote the new series into the cell...so the cell contained one stowed pointer from the original series and one pointer for the new series.</p>
<p>This meant the original series was now in a "weird" state, that things like the GC had to know about and tolerate.  Other operations looking for the missing information in the stub needed to be caught if they tried to get at it without following the stack index through to the stack cell.</p>
<p>Having the cells on the data stack meant it was not necessary to enumerate all the series stubs after a copy to "clean them up".  Otherwise, I'd imagine it may be possible to make some kind of guarantee that for any series appearing in source, the union of the bits in the source series and the bits of the copied series can hold all the information necessary to construct two valid series... e.g. one pointer's worth of information is always redundant in those two copies.  If you can get <em>two</em> pointers' worth of information redundant, the second could be used to chain a linked list as you go...removing the need for the stack cells to enumerate.</p>
<p>Though having the stack cells and no particular requirement of information redundancy in source series with their copies offers another benefit: being applicable for creating mappings that aren't copying-related.</p>
<p>Anyway, it was a little unfinished idea I ran across that I wanted to document.  I'm cleaning up the bootstrap executable to refresh it with something that will help <a href="https://forum.rebol.info/t/rethinking-braces-as-an-array-type/1727">in the FENCE! migration</a>, and mercilessly deleting any code in the bootstrap executable that does not specifically benefit bootstrap... to reduce the instability surface, speed things up, and make it easier to debug the 6-year old executable if worst comes to worst.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/mapping-from-series-series-by-co-opting-the-key-series/2166">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/mapping-from-series-series-by-co-opting-the-key-series/2166</link>
          <pubDate>Wed, 06 Mar 2024 15:24:07 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2166</guid>
          <source url="https://forum.rebol.info/t/mapping-from-series-series-by-co-opting-the-key-series/2166.rss">Mapping from Series =&gt; Series By Co-Opting The Key Series</source>
        </item>
        <item>
          <title>Revisiting a Maybe-Not-So-Weird Old Idea: &lt;- as IDENTITY</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>So at one point I had a kind of strange idea for what to do with <strong><code>&lt;-</code></strong>.</p>
<p>It would just pass through what you gave on its right.  And the idea was that you could use this in various situations as a kind of visual signal that you intended to produce a value that would be used by... something.</p>
<p>You could use it to hint when a line is being continued:</p>
<pre><code>browse join
    &lt;- https://github.com/metaeducation/ren-c/blob/master/CHANGES.md#
    &lt;- unspaced [system.version.1 "." system.version.2 "." system.version.3]
</code></pre>
<p>That JOIN is arity 2.   The arrows do nothing, but quickly pass through what they were passed.</p>
<p>The current alternative you might reach for are parentheses, but you can only put it around the outermost level, and it's noticeably inferior:</p>
<pre><code>browse (join
    https://github.com/metaeducation/ren-c/blob/master/CHANGES.md#
    unspaced [system.version.1 "." system.version.2 "." system.version.3]
)
</code></pre>
<p>I had another idea that the arrow might be nice for signaling when you're at the end of a branch to help hint that the branch result is actually used.</p>
<pre><code> something: case [
     ... [...]
     ... [...]
     ; lots of code to where SOMETHING: has scrolled off the screen
     ... [
         your code here
         more code here
         &lt;- append data "stuff"
     ]
 ]
</code></pre>
<p>It gives you a nice hint that the result of the append (the head of the appended series) is actually used.<br>
<strong>But, these two uses are in contention.</strong>  You can't use it to mean "continue the line above" and "pipe result out to some higher level.  Perhaps this is better done with an impromptu CATCH/THROW?</p>
<pre><code> something: catch [case [
     ... [... throw ...]
     ... [... throw ...]
     ; lots of code to where SOMETHING: has scrolled off the screen
     ... [
         your code here
         more code here
         throw append data "stuff"
     ]
 ]]
</code></pre>
<p>(Note that CATCH/THROW have nothing to do with errors in Rebol, it's a lightweight construct for doing this kind of manipulation.)</p>
<h2>
<a name="why-did-i-kill-off-the-as-identity-1" class="anchor" href="https://forum.rebol.info#why-did-i-kill-off-the-as-identity-1"></a>Why Did I Kill Off The &lt;- As Identity?</h2>
<p>It was changed shortly after deciding to take <strong>-&gt;</strong> for an infix lambda operation.</p>
<pre><code> foo: x -&gt; [print ["I'm a lambda" x]]

 &gt;&gt; foo 1020
 I'm a lambda 1020
</code></pre>
<p>This is particularly nice-looking in branching when you want to pass the branch result.</p>
<pre><code>all [
    1 &lt; 2
    3 &lt; 4
    #something
] then x -&gt; [
   print ["X is" mold x]  ; X is #something
]
</code></pre>
<p>The first incarnation used <strong><code>=&gt;</code></strong> as JavaScript did.  But not only is the arrow lighter, it doesn't weigh on the question of whether <strong><code>=&gt;</code></strong> is an "arrow", when <strong><code>&lt;=</code></strong> is not one.  (Debate has been had over whether =&gt; should be a synonym for &gt;=, and =&lt; a synonym for &lt;=, etc. but status quo has won out.)</p>
<p>So <strong><code>&lt;-</code></strong> was targeted as another function generator, namely for doing tacit programming as an alias for POINTFREE.</p>
<pre><code>foo: &lt;- [append [a b c]]

&gt;&gt; foo 'd
== [a b c d]
</code></pre>
<p>The attempt to write POINTFREE entirely in usermode stalled a bit in the face of other priorities, though it's still very much desired.  And it doesn't seem like a bad idea to have &lt;- and -&gt; both connected as fundamental convenient function generators.</p>
<p>I've not really questioned the decision to strike &lt;- as identity until I realized looking at some old code that it really is nice to have some alias for identity, used for one of the annotation purposes I mention.</p>
<p>We do have single tick free, now <img src="https://forum.rebol.info/images/emoji/twitter/face_with_diagonal_mouth.png?v=12" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20"></p>
<pre><code>browse join
  ' https://github.com/metaeducation/ren-c/blob/master/CHANGES.md#
  ' unspaced [system.version.1 "." system.version.2 "." system.version.3]
</code></pre>
<p>That actually looks kind of decent.  It's not super consistent, because quoting implies not binding...and we'd want binding applied.  Can people mentally separate "the tick operator" as IDENTITY, from the non-bindingness of quoting?</p>
<p>Backtick is available, though backticks are kind of a blight in general:</p>
<pre><code>browse join
  ` https://github.com/metaeducation/ren-c/blob/master/CHANGES.md#
  ` unspaced [system.version.1 "." system.version.2 "." system.version.3]
</code></pre>
<p>Despite my hatred of backticks, I almost actually prefer that to the normal ticks in this narrow application.</p>
<p>There's a few other ugly options, e.g. backslash which we still haven't given meaning to either.</p>
<pre><code>browse join
  \ https://github.com/metaeducation/ren-c/blob/master/CHANGES.md#
  \ unspaced [system.version.1 "." system.version.2 "." system.version.3]
</code></pre>
<p><strong>Anyway, the cool idea here was just that line continuation not be a scanner feature, but be signaled by means of a normal token that ran the identity function... and you'd be cued into realizing that it was a continuation just because there's no point in calling the identity function in source unless you were applying it like this.</strong></p>
<p>We could throw in a little help by having the evaluator only allow this if it was--actually--an argument to a function.</p>
<p>Based on the above, I'm liking the backtick and apostrophe, and am not sure I'd want heavier for line continuation.</p>
<p>The idea of &lt;- being an alternate way of saying identity that is used for the other annotation purpose (this result is used by the higher up stack level) would then be a possibility.  The system could maybe help a little bit here too, by making sure the <strong>&lt;-</strong> <em>isn't</em> an argument to a function...</p>
<p>POINTFREE would need some other shorthand.  But maybe it's just an alternate mode of LAMBDA.  Or maybe it doesn't really need a shorthand.</p>
<pre><code>foo: ... -&gt; [append [a b c]]

foo: &lt;*&gt; -&gt; [append [a b c]]

foo: |-&gt; [append [a b c]]

foo: -|&gt; [append [a b c]]

foo: pointfree [append [a b c]]

&gt;&gt; foo 'd
== [a b c d]
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/revisiting-a-maybe-not-so-weird-old-idea-as-identity/2165">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/revisiting-a-maybe-not-so-weird-old-idea-as-identity/2165</link>
          <pubDate>Wed, 06 Mar 2024 14:20:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2165</guid>
          <source url="https://forum.rebol.info/t/revisiting-a-maybe-not-so-weird-old-idea-as-identity/2165.rss">Revisiting a Maybe-Not-So-Weird Old Idea: &lt;- as IDENTITY</source>
        </item>
        <item>
          <title>Header dialect and multiline strings</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Modules</category>
          <description><![CDATA[
            <p>I've been reading the threads about multiline strings and using {} for arrays, and I'm thinking that the header is going to look rather messy given that's it's not uncommon to have multiline statements there.</p>
<pre><code>Rebol [
    Title: "Your module title here"
    Type: module
    Name: your-module
    Rights: -{
        Copyright 2012 REBOL Technologies
        Copyright 2017-2021 Ren-C Open Source Contributors
    }-
    License: -{
        Licensed under the Apache License, Version 2.0
        See: http://www.apache.org/licenses/LICENSE-2.0
    }-
    Description: \{
       Weirdly this does not look as good, despite dropping a character.
       
            printf("The char is } and it need not be escaped\n");

       So that's good.  And here we can do \n\n\n for escaped lines.
   }\
]
</code></pre>
<p>As an alternative I quite like the way yaml is written, it's very clean without a lot of funny distracting escape characters.  Can we consider using a yaml dialect for the header?</p>
<pre><code>Rebol -{
    Title: Your module title here
    Type: module
    Name: your-module

    Rights: |
        Copyright 2012 REBOL Technologies
        Copyright 2017-2021 Ren-C Open Source Contributors

    License: |
        Licensed under the Apache License, Version 2.0
        See: http://www.apache.org/licenses/LICENSE-2.0

    Description: |
       This would be YAML-based.
       
            printf("The char is } and it need not be escaped\n");

       So that's good.  And here we can do \n\n\n for escaped lines.
}-
</code></pre>
            <p><small>8 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/header-dialect-and-multiline-strings/2159">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/header-dialect-and-multiline-strings/2159</link>
          <pubDate>Wed, 28 Feb 2024 07:17:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2159</guid>
          <source url="https://forum.rebol.info/t/header-dialect-and-multiline-strings/2159.rss">Header dialect and multiline strings</source>
        </item>
        <item>
          <title>API Breakthrough: Scope Detection In JavaScript and C !</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <h2>
<a name="background-1" class="anchor" href="https://forum.rebol.info#background-1"></a>Background</h2>
<p>When writing the implementation of a Rebol function using C or JavaScript code, getting at the arguments and locals of that function was something of an annoyance.</p>
<p>You had to use a separate <strong><code>rebArg()</code></strong> API that looked on the Rebol stack for the last Rebol function call, and retrieved arguments in that frame.  This broke the flow, generating an extra API handle that had to be released:</p>
<pre><code>quadrupler: js-native [num [integer!]] {
    let rebol_num = reb.Arg("num")
    let num = reb.UnboxInteger(rebol_num, "* 2")  // Rebol multiplying
    reb.Release(rebol_num)
    return reb.Integer(num * 2)  // JavaScript multiplying
}
</code></pre>
<p>Of course, you could have used <strong><code>reb.R()</code></strong> to make a "releasing" splice, so the variadic would release it as it went along:</p>
<pre><code>quadrupler: js-native [num [integer!]] {
    let num = reb.UnboxInteger(reb.R(reb.Arg("num")), "* 2")
    return reb.Integer(num * 2)
}
</code></pre>
<p>This was made "prettier" <sub>cough</sub> with a fused instruction called <strong><code>reb.ArgR()</code></strong></p>
<pre><code>quadrupler: js-native [num [integer!]] {
    let num = reb.UnboxInteger(reb.ArgR("num"), "* 2")
    return reb.Integer(num * 2)
}
</code></pre>
<p>Kind of a headache.  <strong>But even worse... what if it's a WORD! or something evaluative?</strong></p>
<pre><code>reverse-spell: js-native [
    {If REVERSE-SPELL 'FOO you get "OOF"}
    word [word!]
]{
    return reb.Spell("reverse to text!", reb.ArgR("word"));  // !!! WRONG
}
</code></pre>
<p>The TO TEXT! won't convert the word, because the word will be spliced into the instruction stream and looked up as a variable..  You need to quote it (or meta it, if it's an antiform):</p>
<pre><code>reverse-spell: js-native [word [word!]] {
    return reb.Spell("reverse to text!", reb.Q(reb.ArgR("word")));
}

reverse-spell: js-native [word [word!]] {
    return reb.Spell("reverse to text! @", reb.ArgR("word"));  // as good as it got
}
</code></pre>
<p>This problem comes from what I have described as saying that all API calls are effectively doing an EVAL COMPOSE, because the C variable name isn't something Rebol can see...hence it cannot "protect" the value it holds.  You'd have the same problem with:</p>
<pre><code> eval compose [reverse to text! (word)]
</code></pre>
<h2>
<a name="wouldnt-it-be-nice-if-the-api-knew-it-was-inside-a-native-2" class="anchor" href="https://forum.rebol.info#wouldnt-it-be-nice-if-the-api-knew-it-was-inside-a-native-2"></a>Wouldn't it be nice if the API <em>knew</em> it was inside a native?</h2>
<p>Then it could just do the lookup by name, with normal code...:</p>
<pre><code>quadrupler: js-native [num [integer!]] {
    let num = reb.UnboxInteger("num * 2")
    return reb.Integer(num * 2)
}

reverse-spell: js-native [word [word!]] {
    return reb.Spell("reverse to text! word");
}
</code></pre>
<p>But how would it know when you called out from the code for the native body to some service routine that also used the API... where the parameters should not be visible?</p>
<h2>
<a name="well-ive-solved-it-star-in-cc-and-javascript-3" class="anchor" href="https://forum.rebol.info#well-ive-solved-it-star-in-cc-and-javascript-3"></a><strong>Well, I've Solved It!</strong> <img src="https://forum.rebol.info/images/emoji/twitter/star.png?v=12" title=":star:" class="emoji" alt=":star:" loading="lazy" width="20" height="20">  In C/C++ and JavaScript</h2>
<p>It's the most significant API change in a while, and it has a big impact:</p>
<p><strong><a href="https://github.com/metaeducation/ren-c/commit/71d86b67c05dddf5c90aff044ca3fb5e1c14952a">C Improvements</a></strong></p>
<p><strong><a href="https://github.com/hostilefork/replpad-js/commit/b6978ec43f83a97aabb14c2efa218e5da5048e8f#diff-839c9f79a45893495f4bf96067d8c1567ccac664d09a265e299079862040f2f1L907">JavaScript Improvements</a></strong></p>
<h2>
<a name="hows-it-done-for-starters-pure-virtual-binding-4" class="anchor" href="https://forum.rebol.info#hows-it-done-for-starters-pure-virtual-binding-4"></a>How's It Done?  For Starters, Pure Virtual Binding...</h2>
<p><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751">"Pure Virtual Binding"</a> gives us the possibility finding function arguments and locals dynamically, once the function is already running...even if we just have text in our hand:</p>
<pre><code>demo: func [arg] [
    name: "arg"
    word: inside [] to word! name  ; BLOCK! evaluation captures specifier
    print ["The value of arg is" get word]
]

&gt;&gt; demo 1020
The value of arg is 1020
</code></pre>
<p>So that's how we're managing to look up the text.</p>
<h2>
<a name="capturing-shadowed-variables-as-a-proxy-for-stack-5" class="anchor" href="https://forum.rebol.info#capturing-shadowed-variables-as-a-proxy-for-stack-5"></a>Capturing Shadowed Variables As A Proxy For Stack</h2>
<p>The next trick is: how do functions like <strong>reb.UnboxInteger()</strong> or <strong>reb.Spell()</strong> (or their C equivalents <strong>rebUnboxInteger()</strong> or <strong>rebSpell()</strong>) know what Rebol function is currently executing... or if you're in the body of the implementation or not?</p>
<p>The variadic C API functions are actually macros that look like this:</p>
<pre><code>#define rebSpell(...) \
    rebSpell_helper( \
        LIBREBOL_SPECIFIER,  /* captured from callsite! */ \
        __VA_ARGS__, rebEND \
    )
</code></pre>
<p>LIBREBOL_SPECIFIER is something that is defined before you <code>#include "rebol.h"</code>, that gives the expression to evaluate which will give you the stack.  So when you see a native definition like:</p>
<pre><code>DECLARE_NATIVE(native_name_here) {
    INCLUDE_PARAMS_OF_NATIVE_NAME_HERE;
    ...
}
</code></pre>
<p>That expands to:</p>
<pre><code>RebolBounce N_native_name_here(RebolLevel* level_) {
    RebolSpecifier librebol_specifier;
    librebol_specifier = rebSpecifierFromLevel_internal(level_)
    ...
}
</code></pre>
<p>This overrides a global static.  If you're inside the function, the API macros will receive the specifier that's in the function, otherwise the static.  It drives its decision from there.</p>
<p>The JavaScript uses a similar technique, but in that case it can override the <strong>reb</strong> used in the <strong>reb.Xxx()</strong> functions.  There's a global <code>reb</code>, and then a <code>reb</code> that's tweaked which comes in as a parameter to the JavaScript function implementing the native.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/api-breakthrough-scope-detection-in-javascript-and-c/2157">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/api-breakthrough-scope-detection-in-javascript-and-c/2157</link>
          <pubDate>Mon, 26 Feb 2024 23:57:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2157</guid>
          <source url="https://forum.rebol.info/t/api-breakthrough-scope-detection-in-javascript-and-c/2157.rss">API Breakthrough: Scope Detection In JavaScript and C !</source>
        </item>
        <item>
          <title>Raku (Perl 6) Type System</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="19" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/19">Ugly Types: Less Ugly Than History, Can We Do Better?</a>
</div>
<blockquote>
<p>Thatâ€™s why I think itâ€™s a good idea to keep TYPE OF a direct reflection of the heart-byte, and use other constructions for code which needs other things.</p>
</blockquote>
</aside>
<p>Iâ€™ve just discovered a bit of prior art for this, in the form of Raku (i.e., the language formerly known as Perl 6). Its equivalent to TYPE OF, namely <a href="https://docs.raku.org/language/mop#WHAT">WHAT</a>, returns only the â€˜type objectâ€™ of which the value is an instance. By contrast, type matching (and pattern matching) is done using <a href="https://docs.raku.org/type/Mu#method_ACCEPTS">ACCEPTS</a> with a <a href="https://docs.raku.org/language/signatures">signature literal</a>, which is a much more flexible syntax allowing all kinds of constraints to be expressed.</p>
<p>Actually, now that I think of it, Raku signature literals strike me as quite a nice approach. For Ren-C, they suggest the idea of having a â€˜type-matching dialectâ€™â€¦ though, then again, I guess thatâ€™s something I <a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/2">already suggested above</a>.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/raku-perl-6-type-system/2156">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/raku-perl-6-type-system/2156</link>
          <pubDate>Sun, 25 Feb 2024 12:53:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2156</guid>
          <source url="https://forum.rebol.info/t/raku-perl-6-type-system/2156.rss">Raku (Perl 6) Type System</source>
        </item>
        <item>
          <title>What is the use of typesets?</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Recent discussions have brought the notion of â€˜typesetsâ€™ to my attention. On reading the source code, this confused me a bitâ€¦ they donâ€™t seem to be used all that much. Moreover, they seem to be subsumed by the idea of optimised constraint functions.</p>
<p>So I set out to try them myself. Only to find myself thoroughly confused, because typesets donâ€™t actually seem to be accessible from Ren-C itself. Or, at least, none seem to be defined â€” normal type names evaluate to TYPE-BLOCK!s as expected, but typeset names are unassigned:</p>
<pre><code class="lang-plaintext">&gt;&gt; word!
== &amp;[word]

&gt;&gt; text!
== &amp;[text]

&gt;&gt; any-utf8!
** Script Error: any-utf8! word is attached to a context, but unassigned
** Where: console
** Near: [any-utf8! **]
** Line: 1

&gt;&gt; any-type-value!
** Script Error: any-type-value! word is attached to a context, but unassigned
** Where: console
** Near: [any-type-value! **]
** Line: 1
</code></pre>
<p>[On which note, incidentally, let me yet again mention my conviction that the other TYPE-* datatypes are useless and should be removed.]</p>
<p>I expected to at least be able to use them in function signatures, but I canâ€™t even do that, since it crashes a program:</p>
<pre><code class="lang-plaintext">&gt;&gt; test: func [x [word!]] [return x]
== ~#[frame! {test} [x]]~  ; anti

&gt;&gt; test: func [x [any-utf8?]] [return x]
== ~#[frame! {test} [x]]~  ; anti

&gt;&gt; test: func [x [any-utf8!]] [return x]
Assertion failure: QUOTE_BYTE(v) == ANTIFORM_0
Line 165, File: /home/bradrn/Documents/red/ren-c/src/include/cells/cell-quoted.h
Trace/breakpoint trap (core dumped)
</code></pre>
<p>Soâ€¦ if they canâ€™t be accessed from Ren-C itself, then why does the interpreter have typesets at all?</p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/what-is-the-use-of-typesets/2153">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-is-the-use-of-typesets/2153</link>
          <pubDate>Tue, 20 Feb 2024 04:29:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2153</guid>
          <source url="https://forum.rebol.info/t/what-is-the-use-of-typesets/2153.rss">What is the use of typesets?</source>
        </item>
        <item>
          <title>Dropping the ANY-XXX! from (Some) Type Constraints?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>There was a slightly confusing aspect of historical Rebol where some typesets were named so that they looked just like a datatype:</p>
<pre><code>red&gt;&gt; help append
USAGE:
    APPEND series value

DESCRIPTION: 
    Inserts value(s) at series tail; returns series head. 
    APPEND is an action! value.

ARGUMENTS:
    series       [series! bitset! port!] 
    value        [any-type!] 
...
</code></pre>
<p>Here, we see SERIES! which is not named in a way that makes it obvious that it's not a fundamental type.  It's named the same as BLOCK! or WORD!.</p>
<p><span class="mention">@earl</span> and I agreed that this was a stumbling block, so we thought that ANY-SERIES! was a better name.  That way you wouldn't make the mistake of saying:</p>
<pre><code>if series! = type? x [...]
</code></pre>
<p>...and have it always fail.  You'd be cued by that ANY- to know that it was a set of many types.  (You still might think that you could use the equals operator to see if something was in a typeset and be wrong, but that's a different level).</p>
<p><a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151">But Ren-C has done away with typesets.</a>  They were too limited, and we now use arbitrary functions to do typechecking via predicates (with some various supporting optimizations so the common cases aren't horrifically slow).</p>
<p>So ANY-SERIES! is pretty much going away.  Most of the time you just use ANY-SERIES? (e.g. in a function spec or regular code), and then &amp;ANY-SERIES? if you're in something like a parse rule.</p>
<h2>
<a name="do-we-still-need-the-any-1" class="anchor" href="https://forum.rebol.info#do-we-still-need-the-any-1"></a>Do We Still Need The ANY-?</h2>
<p>I'm a little torn on the question of whether we need the ANY-.</p>
<p>Sometimes it's required (e.g. with ANY-WORD?) because WORD? means specifically "plain word".  (Note you'd use WORD! generally in type specs, though technically you can use either...performance should be identical).</p>
<p>But on ANY-SERIES? it's now a bit superfluous. And SERIES? is certainly shorter.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>It's not a slam dunk to take the ANY- off.  I kind of like the realization it gives you as a reader... "hey, we're talking about multiple things here"... and it makes you stop and consider "just how many series are there?  is ANY-SERIES? really what I mean?"</p>
<p>I kind of lean to keeping it.  And I prefer ANY-VALUE? to just VALUE? as well.</p>
<p>But it's definitely less important than it was.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/dropping-the-any-xxx-from-some-type-constraints/2152">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dropping-the-any-xxx-from-some-type-constraints/2152</link>
          <pubDate>Sat, 17 Feb 2024 06:47:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2152</guid>
          <source url="https://forum.rebol.info/t/dropping-the-any-xxx-from-some-type-constraints/2152.rss">Dropping the ANY-XXX! from (Some) Type Constraints?</source>
        </item>
        <item>
          <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <h2>
<a name="the-limited-and-ambiguous-historical-idea-1" class="anchor" href="https://forum.rebol.info#the-limited-and-ambiguous-historical-idea-1"></a>The Limited and Ambiguous Historical Idea</h2>
<p>People are used to being able to do things like:</p>
<pre><code> x: 10
 switch type? x [
     integer! [print "It's an integer"]
     block! [print "It's a block"]
 ]

 assert [parse [1 [second] 'foo] [integer! block! lit-word!]]

 assert [find any-word! (type? first [x:])]
</code></pre>
<p>But the historical DATATYPE! and TYPESET! were strange.</p>
<ul>
<li>
<p>DATATYPE! rendered as a WORD! but was really wrapping an integer of 0-63</p>
</li>
<li>
<p>TYPESET! was a 64-bit bitset, one bit for each type (this is where the 64 types limit came from)</p>
<ul>
<li>
<p>it lost its meaning in rendering (it kept no record of what the set actually was...just dumped words for each bit)</p>
</li>
<li>
<p>not preserving the name from a fixed list of typesets was based on the concept you could make your own or UNION/INTERSECT them</p>
</li>
</ul>
</li>
</ul>
<p>So it looked like this:</p>
<pre><code>red&gt;&gt; type? 1
== integer!

red&gt;&gt; type? type? 1
== datatype!

red&gt;&gt; print mold any-word!
make typeset! [word! set-word! lit-word! get-word!]

red&gt;&gt; print mold any-type!
make typeset! [datatype! unset! none! logic! block! paren! string! file! url!
    char! integer! float! word! set word! lit-word! get-word! refinement! issue!
    native! action! op! function! path! lit-path! set-path! get-path! routine!
    bitset! object! typeset! error! vector! hash! pair! percent! tuple! map!
    binary! time! tag! email! handle! date! port! money! ref! point2D! point3D!
    image! event!]
</code></pre>
<h2>
<a name="the-type-xxx-approach-2" class="anchor" href="https://forum.rebol.info#the-type-xxx-approach-2"></a>The TYPE-XXX! Approach</h2>
<p>So Ren-C attacked the ambiguity and extensibility with a new word type, TYPE-WORD!.  Then typesets used TYPE-GROUP! and TYPE-BLOCK!, referencing functions to act as type testing predicates, and using groups for intersections and blocks for unions:</p>
<pre><code>&gt;&gt; type of 1
== &amp;integer

&gt;&gt; type of type of 1
== &amp;type-word

&gt;&gt; print mold any-word!
&amp;(any-word?)

&gt;&gt; print mold any-value!
&amp;(any-value?)
</code></pre>
<p>This gives some realistic axis of extensibility, and gives distinguishable entities that can trigger behaviors in PARSE when something looks up to type-xxx!.  (this shows why using WORD! or URL! or ISSUE! wouldn't work, because the type intent has to be carried by what e.g. INTEGER! looks up to.)</p>
<p><strong>Calling functions to implement type checks vs. checks on a bitset, especially when an array of functions must be called when checking every parameter in every function call, is a difficult performance point.</strong></p>
<p><a href="https://forum.rebol.info/t/intrinsics-functions-without-frames/2050">Intrinsics and other magic are employed to rein it in.</a>  It's not particularly simple...but finding ways to speed up function calls where you can has systemic benefit.</p>
<h2>
<a name="new-consequence-find-must-find-type-word-normally-3" class="anchor" href="https://forum.rebol.info#new-consequence-find-must-find-type-word-normally-3"></a>New Consequence: FIND Must Find TYPE-WORD! Normally</h2>
<p>Being a legitimate datatype that can be stored in a block, some interpretations of datatype by functions like FIND were problematic:</p>
<pre><code>red&gt;&gt; block: reduce ["hello" integer! 1]
== ["hello" integer! 1]

red&gt;&gt; find block 'integer!
== none  ; rendering was a lie

red&gt;&gt; find block integer!
== [1]
</code></pre>
<p>You couldn't find a literal datatype in a block.  Ren-C is approaching this by saying FIND has to find the TYPE-WORD! (as it does for all non-antiforms), but that you can use antiform actions as predicates.</p>
<pre><code>&gt;&gt; block: reduce ["hello" integer! 1]
== ["hello" &amp;integer 1]

&gt;&gt; find block integer!
== [&amp;integer 1]

&gt;&gt; find block :integer?
== [1]
</code></pre>
<p>There was some thought that maybe you could create antiform TYPE-XXX! and call them "matchers", passing them to FIND.</p>
<ul>
<li>
<p>But this is an isotope for each TYPE-XXX!, so it's not even like there would be one "matcher"</p>
</li>
<li>
<p>It also would be the only instance of antiforms of types with sigils, which doubles the sigil to make <strong><code>~&amp;integer~</code></strong>, which I find kind of displeasing</p>
</li>
</ul>
<p>I feel that antiform actions cover it for FIND, and if you have higher level needs you should use something like PARSE which has richer options and isn't beholden to quite the "mechanical" answer that a series primitive like FIND has to abide by with its limited parameterization.</p>
<h2>
<a name="new-annoyance-type-of-quotes-and-antiforms-4" class="anchor" href="https://forum.rebol.info#new-annoyance-type-of-quotes-and-antiforms-4"></a>New Annoyance: TYPE OF Quotes And Antiforms</h2>
<p>When there were only two datatypes with quotedness, the quote was part of their datatype:</p>
<pre><code>red&gt;&gt; type? first ['a]
== lit-word!

red&gt;&gt; type? first ['a/b]
== lit-path!

red&gt;&gt; lit-word! = type? first ['a]
== true

red&gt;&gt; parse ['a 'a/b] [lit-word! lit-path!]
== true
</code></pre>
<p>Ren-C's approach affords the ability make type constraints to carry forward the PARSE behavior.  But the TYPE OF all quoteds is the same... &amp;QUOTED.</p>
<pre><code>&gt;&gt; lit-word?!
== &amp;(lit-word?)

&gt;&gt; lit-word?! = type of first ['a]
== ~false~  ; anti

&gt;&gt; type of first ['a]
== &amp;quoted
</code></pre>
<p>So perhaps you see the motivation to decorate as <strong>?!</strong> instead of just <strong>!</strong> for the type constraints.  People need to know that these aren't fundamental types.  You have to use e.g. MATCH with them:</p>
<pre><code> &gt;&gt; match lit-word?! first ['a]
 == 'a

 &gt;&gt; match lit-word?! 10
 == ~null~  ; anti

 &gt;&gt; match [lit-word?] first ['a]  ; alternative as 1st slot known "typelike"
 == 'a
</code></pre>
<p>This is something of a pain point, and I'm not entirely settled on whether it would be good to delve into some kind of ambiguity where we are actually allowed to get back constraint functions as the answer to TYPE OF, and make that the fundamental:</p>
<pre><code>&gt;&gt; type of 1
== &amp;integer?

&gt;&gt; type of spread [a b]
== &amp;splice?

&gt;&gt; type of ~true~
== &amp;logic?

&gt;&gt; type of first ['a]
== &amp;quoted? 
</code></pre>
<p>So I don't think this is a good idea for the quoted types, but for the antiforms it might be a narrow enough thing that it provides "what the people want".</p>
<pre><code>&gt;&gt; switch type of true [
     splice! [...]
     logic! [...]
     integer! [...]
  ]
</code></pre>
<p>Barring that, what we have to do today is flip SWITCH over into a MATCH mode (currently called SWITCH/TYPE but should probably be SWITCH/MATCH... or maybe it should take the MATCH name):</p>
<pre><code>&gt;&gt; switch/type true [
     splice?! [...]
     logic?! [...]
     integer! [...]
  ]
</code></pre>
<p>Note that the <code>?!</code> distinction is a new idea which hasn't made it to all type constraints yet, e.g. ANY-VALUE! is still as it was.  But because parameters use what is effectively a TYPE-BLOCK! you can say <strong><code>any-value?</code></strong> or <strong><code>splice?</code></strong> in them instead of going through the extra step.</p>
<h2>
<a name="should-type-be-a-bigger-concept-5" class="anchor" href="https://forum.rebol.info#should-type-be-a-bigger-concept-5"></a>Should TYPE Be A Bigger Concept?</h2>
<p>One thing that has nagged me is if when we ask for the fundamental "cell type" of something, if we should avoid using the word "TYPE" for that at all...</p>
<p>Maybe there's some bigger idea in an object/class system where TYPE is meaningful to say something more than "this is an object" but rather "this is a book", where you can ask also "is a book readable".  Etc.</p>
<p>Or maybe TYPE can be parameterized:</p>
<pre><code> &gt;&gt; type of matrix
 == &amp;[matrix 10x10]
</code></pre>
<p>So this would mean there's a smaller question about the fundamental type, maybe call it "KIND":</p>
<pre><code>&gt;&gt; kind of [a b c]
== &amp;block

&gt;&gt; kind of matrix
== &amp;object
</code></pre>
<p>It would be nice to just be able to say "64 types is enough for anyone" and say "there, it's done".  I'd be happy to do that if I felt that it was enough.  It wasn't, even when thinking along fairly limited lines that don't go in these fancier directions.</p>
<p><em>I don't think any near-term system will actualize on bigger visions of what TYPE might be, but it would help to know if that should be ruled out or not, just in order to pick the term KIND or TYPE!</em>  But even that question is murky.</p>
<h2>
<a name="some-related-reading-typesr-6" class="anchor" href="https://forum.rebol.info#some-related-reading-typesr-6"></a>Some Related Reading: %types.r</h2>
<p>The dialected table used to construct the type testing macros and other things is kind of neat, though some comments are out of date and parts of it need updating (it's getting upgraded in an upcoming commit which finally breaks the 64-type barrier and introduces the $ types):</p>
<p>See <a href="https://github.com/metaeducation/ren-c/blob/master/src/boot/types.r"><strong>%types.r</strong></a></p>
            <p><small>20 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151</link>
          <pubDate>Fri, 16 Feb 2024 23:29:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2151</guid>
          <source url="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
        </item>
        <item>
          <title>A proliferation of $#@^&#39;:~WORD~:s</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>One of the things which surprised me when I first looked into Ren-C was the number of WORD variants it has. By my count, this includes:</p>
<ul>
<li>plain WORD</li>
<li>:GET-WORD</li>
<li>SET-WORD:</li>
<li>
<code>@THE-WORD</code> *</li>
<li>^META-WORD</li>
<li>&amp;TYPE-WORD</li>
<li><span class="hashtag">#ISSUE</span></li>
<li>'QUOTED</li>
<li>~ANTIFORM~</li>
<li>â€¦and probably more that Iâ€™ve forgotten.</li>
</ul>
<p><small>* monospaced so Discourse doesnâ€™t think itâ€™s a ping</small></p>
<p>Now, in many ways this is perfectly expected for a language like Ren-C. Firstly, dialecting means we value having as many syntactic options as possible. Secondly, Ren-C has a lot of different kinds of values â€” plain, quoted, anti and quasi, and now bound and unbound versions of each â€” and most of these words are simply making it easier to deal with that huge variety.</p>
<p>But, on the other hand, I feel weâ€™re starting to encounter some problems with the current way of doing things. Most notably:</p>
<ol>
<li>None of this is compositional. When we <a href="https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359/7">run into a situation</a> where weâ€™d like to, say, have a word which is both META- and THE-, itâ€™s impossible.</li>
<li>Some dialects would like to use words outside this fixed inventory. For instance, it would be nice to have <a href="https://forum.rebol.info/t/upcoming-datatype-word-what-will-it-mean/2146">$WORDs to use in a shell dialect</a>.</li>
</ol>
<p>The root cause of both is the same: the inventory of word-like datatypes is hard-coded into the interpreter. If you want to use something outside that set, you canâ€™t, no matter how similar to the existing types it may seem.</p>
<p>I can imagine a hypothetical design which would avoid this. This would allow some characters to be freely added to the beginning and end of words â€” letâ€™s call those special characters â€˜sigilsâ€™, like in Perl. Every combination of sigils would then specify a separate datatype. So you would still have :WORDs and ^WORDs and ~WORD~s, but also $WORDs and ^@WORDs and ~#WORD&amp;s and whatever else you could imagine. This would quite easily solve both of the problems I mentioned.</p>
<p>One might even contemplate generalising this â€˜sigilâ€™ idea to non-word types. We already have {GET,SET,THE,META}-{BLOCK,GROUP}s, so it would make sense to allow arbitrary sigils on blocks and groups too.</p>
<p>Unfortunately, Iâ€™m not sure this would work with the current design of Ren-C. At the moment, there is currently a hard maximum of (as I recall) 256 possible datatypes, whereas this proposal obviously allows for an infinite amount of datatypes. However, I do think itâ€™s at least worth thinking about, for the simple reason that it would give us a lot more flexibility than we currently have.</p>
            <p><small>10 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/a-proliferation-of-word-s/2147">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/a-proliferation-of-word-s/2147</link>
          <pubDate>Tue, 13 Feb 2024 12:58:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2147</guid>
          <source url="https://forum.rebol.info/t/a-proliferation-of-word-s/2147.rss">A proliferation of $#@^&#39;:~WORD~:s</source>
        </item>
        <item>
          <title>Upcoming Datatype $WORD... What Will It Mean?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Something that has been nagging at me is that I've known I want to introduce <strong>$WORD</strong>, <strong>$(GR O UP)</strong>, <strong>$TU.P.LE</strong> etc. (tentative names VAR-WORD!, VAR-GROUP!, VAR-TUPLE!).</p>
<p>At first glance it seems like it would be a loss if $XXX didn't in the baseline evaluator evaluate to looking up environment variables.</p>
<p>But this would be a different behavior for an ANY-WORD!...which up until now, the type of word has not mattered.  Would it spread to SET?</p>
<pre><code>&gt;&gt; set-env "SOMETHING" "TRUE"

&gt;&gt; SOMETHING: 10

&gt;&gt; set (in [] '$SOMETHING) "FALSE"
== "FALSE"

&gt;&gt; SOMETHING
== 10

&gt;&gt; get-env "SOMETHING"
== "FALSE"
</code></pre>
<p>Hmmm.  Lots of issues there...including that Unix environment variables are case-sensitive, Windows ones are not.</p>
<p>The implementation mechanism of this would presumably have to introduce some sort of "pseudo-object" named <code>environment</code>/<code>env</code>, and then the "specifier" would have to say (in a similar way to which the ".WORD" lookups would say to look in a "current object") that the $ words should look up in env.   <em>(See related discussion about <a href="https://forum.rebol.info/t/binding-indirection/2112">"Binding Indirection"</a>)</em></p>
<h2>
<a name="simpler-thought-1" class="anchor" href="https://forum.rebol.info#simpler-thought-1"></a>Simpler Thought...</h2>
<p>A simpler thought (that doesn't rock the boat for one feature) would be that this is a bridge too far for an ANY-WORD!, and they should look up just like any other word, and it's only weird shell dialects that would think that a $WORD meant environment variables.</p>
<p>But then the question might be what the $ buys you.</p>
<p>Maybe I was too hasty in saying that the @ was the right thing to sacrifice for "get variable with binding", and $ should have done that?</p>
<pre><code>&gt;&gt; $word
== word  ; bound

&gt;&gt; @word
== @word  ; bound?
</code></pre>
<p>(A line of argumentation that <code>@word</code> should be bound, is that if you want an unbound one you can get it by quoting with <code>'@word</code>, but then again if the @ operator does not bind e.g. @ foo... but $ does, e.g. $ foo.  So maybe not affecting the binding is the better choice.)</p>
<p>This would let us put back the @ for "as-is" variable usage in parse.  And it would make more sense for a thing named VAR-WORD! (bound variable in evaluator, environment var in shell dialect...)</p>
<p>Urrrgh.  I hate that it seems like that's probably right.  :-/   <em>(Thankfully, git lets us audit/reverse such decisions...assuming you're diligent about not changing too many unrelated things in one commit, which I thankfully was careful about with the @ change.)</em></p>
<h2>
<a name="loss-of-for-weird-idea-i-had-2" class="anchor" href="https://forum.rebol.info#loss-of-for-weird-idea-i-had-2"></a>Loss of $ For Weird Idea I Had</h2>
<p>If the $ operator were used for binding that would be a bit sad, as I'd kind of hoped that could be a variadic function that could run the <a href="https://github.com/metaeducation/ren-c/blob/3e5f724197f55d2745436a52ca1dfa7c5d7e4db5/scripts/shell.r#L4">shell dialect</a>:</p>
<pre><code>extension: "txt"

$ ls -alF *.(extension)
</code></pre>
<p>But, maybe that's a bad way to package it in the box, and specialty scripts that don't care about a $ operator for binding purposes can override it, encouraging the more traditional:</p>
<pre><code>extension: "txt"

shell [ls -alF *.(extension), echo $SOMETHING]
</code></pre>
            <p><small>11 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/upcoming-datatype-word-what-will-it-mean/2146">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/upcoming-datatype-word-what-will-it-mean/2146</link>
          <pubDate>Tue, 13 Feb 2024 11:51:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2146</guid>
          <source url="https://forum.rebol.info/t/upcoming-datatype-word-what-will-it-mean/2146.rss">Upcoming Datatype $WORD... What Will It Mean?</source>
        </item>
        <item>
          <title>HTTPD Response Handler Hook</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Binding</category>
          <description><![CDATA[
            <p>As another instance of <em>"I want to augment this block as a function body, with some stuff"</em> there's this pattern in HTTPD.  Here is a usage:</p>
<p>The idea is that SERVER.SPEC.ACTIONS is a plain BLOCK! of what to do.  Here's a sample usage:</p>
<pre><code>    import %httpd.reb
    trap [
        str: {Test} n: 0
        wait srv: open [scheme: 'httpd 8000 [
            n: n + 1
            expected: copy str
            repeat n [append expected expected]
            lib.print [{SERVER} n {:} (length of as binary! expected) {bytes}]
            render expected
        ]]
    ] then (func [e] [print mold/limit e 2000])
</code></pre>
<p>If you do something like fetch %index.html, that BLOCK! after the 8000 is executed.  Here what's happening is it's just incrementing a number and doubling the length of the response sent back each time.</p>
<p>The implementation was like this:</p>
<pre><code>    server.locals.handler: func [
        return: [~]
        request [object!]
        response [object!]
    ] compose [
        render: :response.render
        redirect: :response.redirect
        print: :response.print

        (spread (
            match block! server.spec.actions else [default-response]
        ))
    ]
</code></pre>
<p>It wants to override PRINT so that what you print becomes part of the response.  So you're supposed to get these three service functions RENDER / REDIRECT / PRINT as well as access to the REQUEST and RESPONSE objects.</p>
<p>Now that SPREAD is spreading unbound material, this does not work.</p>
<p>PUNCH would be one way of doing this:</p>
<pre><code>    server.locals.handler: func [
        return: [~]
        request [object!]
        response [object!]
    ] compose [
        render: :response.render
        redirect: :response.redirect
        print: :response.print

        (punch [request response render redirect print] as group! (
            match block! server.spec.actions else [default-response]
        ))
    ]
</code></pre>
<p>Though if you had <a href="https://forum.rebol.info/t/hiiamboriss-with/2138">something like WITH</a> you could imagine it like:</p>
<pre><code>    server.locals.handler: func [
        return: [~]
        request [object!]
        response [object!]
    ] compose [
        do with [request response {  ; idea of FENCE! representing object
            render: :response.render
            redirect: :response.redirect
            print: :response.print
        }] (
            match block! server.spec.actions else [default-response]
        )
    ]
</code></pre>
<p>The COMPOSE is not strictly necessary there, but it lets you do at least a little work once vs. every time the function is called.</p>
<p>Which points to something useful about the PUNCH-based concept... beyond being <a href="https://forum.rebol.info/t/what-dialects-need-from-binding/2111">usable in dialects where things like DO WITH aren't available</a>... it has the potential to perform better (assuming punch-merges are faster than usermode function calls, which I believe they would be).</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/httpd-response-handler-hook/2144">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/httpd-response-handler-hook/2144</link>
          <pubDate>Mon, 05 Feb 2024 19:02:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2144</guid>
          <source url="https://forum.rebol.info/t/httpd-response-handler-hook/2144.rss">HTTPD Response Handler Hook</source>
        </item>
        <item>
          <title>Racket&#39;s Language-Oriented Programming</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Racket has something called <a href="https://school.racket-lang.org/2019/plan/mon-mor-lecture.html">"Language-Oriented Programming"</a>.  <a class="mention" href="https://forum.rebol.info/u/bradrn">@bradrn</a> brought it up, and wrote:</p>
<aside class="quote no-group" data-username="bradrn" data-post="10" data-topic="2136">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/fundamental-distinguishing-features-of-rebol/2136/10">Fundamental distinguishing features of Rebol</a>
</div>
<blockquote>
<p>I think thereâ€™s an interesting contrast to be made here to <a href="https://racket-lang.org/">Racket</a>â€™s â€˜language-orientated programmingâ€™ (basically a different name for dialecting). Racket people talk a lot about defining new languages to solve problems, just like Rebolâ€¦ but in practice, Iâ€™m not sure how much they actually do it. Part of the problem may be that those new languages <em>are</em> very different to base Racket â€” so not only do you have to write the interpreter, you have to write the parser as well. By contrast, since Rebol dialects have a similar free-form nature as Rebol code, you can get away with minimal parsing and no lexing, which in turn makes dialecting easier to achieve. (Still not as easy as macros, though.)</p>
</blockquote>
</aside>
<p>So I've moved that here to a thread to discuss Racket, if there are any interesting ideas there.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rackets-language-oriented-programming/2143">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rackets-language-oriented-programming/2143</link>
          <pubDate>Thu, 01 Feb 2024 00:54:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2143</guid>
          <source url="https://forum.rebol.info/t/rackets-language-oriented-programming/2143.rss">Racket&#39;s Language-Oriented Programming</source>
        </item>
        <item>
          <title>`import @json` broken under new @ rules, what now?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Modules</category>
          <description><![CDATA[
            <p>The IMPORT statement was using <code>@NAME</code> to mean "look up the module in the registry".  So you could just write something like:</p>
<pre><code>import @json
</code></pre>
<p>This was a replacement for the original syntax, of using TAG!.</p>
<pre><code>import &lt;json&gt;
</code></pre>
<p>The reason tag was replaced is because as a string type, it came to be in demand for relative-to-script paths, as opposed to relative-to-current-directory paths.</p>
<p>So if your file is in <code>C:\MyProject\something.reb</code> and you do:</p>
<pre><code>D:\Documents&gt; r3 ..\MyProject\something.reb
</code></pre>
<p>The system doesn't change the working directory to <code>C:\MyProject</code> any longer (it was decided that's an undesirable behavior).  So you'll still be in <code>D:\Documents\</code> and so <code>%libs/whatever.reb</code> would be relative to that.  But using TAG! lets you get the desired effect:</p>
<pre><code>Rebol [File: %something.reb]
import &lt;libs/whatever.reb&gt;  ; relative to C:\MyProject where %something.reb lives
</code></pre>
<p>Strings are still used for literal source if you want to put that right inline:</p>
<pre><code>import "Rebol [Title: &lt;{my module}&gt;] export foo: lambda [] [print &lt;{Foo}&gt;]"
</code></pre>
<p>(trying new string notation.. not that terrible...)</p>
<h2>
<a name="but-now-json-is-an-attempted-bound-wordhttpsforumrebolinfotrepurposing-the-xxx-xxx-for-undecorated-values2135-1" class="anchor" href="https://forum.rebol.info#but-now-json-is-an-attempted-bound-wordhttpsforumrebolinfotrepurposing-the-xxx-xxx-for-undecorated-values2135-1"></a><a href="https://forum.rebol.info/t/repurposing-the-xxx-xxx-for-undecorated-values/2135">But Now <code>@json</code> Is An (Attempted-Bound) Word</a>
</h2>
<p>We can change it so that the handling is for word, so it works... and <strong><code>import 'json</code></strong> would also work.</p>
<p>But then the binding is superfluous, and we should change the callsites to just use a plain tick mark.</p>
<p>There's nothing particularly <em>wrong</em> with just using a word here, but it kind of makes the import statement lose some of its... heft.  It doesn't stand out as much.</p>
<p>We could use an issue/token:</p>
<pre><code>import #json
</code></pre>
<p>But then we can't do tuple or path tricks and have them be actual tuples and paths.</p>
<pre><code>import 'json/1.2.20  ; path with two items, second is a 3-elemnent tuple
import #json/1.2.20  ; just a utf8 string
</code></pre>
<p>Anyway, I guess we should just have import take WORD!, and it's not a big deal.  In fact it will keep working, because since the argument to import isn't quoted we can't tell it had the @ on it.  But future IMPORTs should omit the @, because it's now superfluous.</p>
<p>(Though actually, should <code>@word</code> fail if it can't bind a word?  That's a question for the other thread, though...)</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/import-json-broken-under-new-rules-what-now/2141">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/import-json-broken-under-new-rules-what-now/2141</link>
          <pubDate>Wed, 31 Jan 2024 05:15:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2141</guid>
          <source url="https://forum.rebol.info/t/import-json-broken-under-new-rules-what-now/2141.rss">`import @json` broken under new @ rules, what now?</source>
        </item>
        <item>
          <title>Rethinking `&lt;static&gt;` in the Function Spec Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>In R3-Alpha, the FUNCTION construct was built on top of FUNC, and added features like statics as a refinement.  It looked pretty awkward, because the static was added at the end of the expression:</p>
<pre><code> r3-alpha&gt;&gt; foo: function/with [x] [return staticvar: add staticvar x] [staticvar: 0]

 r3-alpha&gt;&gt; foo 10
 == 10

 r3-alpha&gt;&gt; foo 20
 == 30
</code></pre>
<p>Ren-C tried extending the function spec dialect to support this in a nicer way:</p>
<pre><code> foo: function [x &lt;static&gt; staticvar (0)] [return staticvar: add staticvar x]
</code></pre>
<p>The low-level FUNC implementation doesn't know what <code>&lt;static&gt;</code> is, so it's added by a higher layer, that makes things slower... and since the function spec dialect is kind of foundational it may be the wrong place to be putting this for the core.</p>
<p><span class="mention">@hiiamboris</span> <a href="https://forum.rebol.info/t/hiiamboriss-with/2138">approaches this differently</a>:</p>
<aside class="quote no-group">
<blockquote>
<h4>create static storage for functions where existing literal forms don't allow you to:</h4>
<pre><code class="lang-plaintext">factorial: func [x] with [cache: make hash! [0 1]] [
    any [
        select/skip cache x 2
        put cache x x * factorial x - 1
    ]
]
</code></pre>
</blockquote>
</aside>
<p>It's not the first time I've thought it would be a better direction to break it out.  But putting it all as part of the function spec was supposed to have an advantage in that when the body was walked to create the copy, the binding to the static members would be done as well.  This is no longer applicable, because the bodies of functions are largely left unbound...</p>
<p>We do lose a feature of noticing when you are naming the static the same thing as something in your function frame and you don't get an error in that case, but maybe you don't want an error (perhaps you inherited the frame through an adaptation or something like that, and you don't care about the frame variable).</p>
<p>Boris's dialect is a bit overloaded, and Ren-C has more parts to help with that...<a href="https://forum.rebol.info/t/rethinking-braces-as-an-array-type/1727">but it would help even more if there were FENCE!</a></p>
<pre><code>foo: func [x] with [
    {staticvar: 0}
][
    return staticvar: add staticvar x
]

foo: func [x] with {staticvar: 0} [
    return staticvar: add staticvar x
]
</code></pre>
<p>So this wouldn't be confused with any other WITH things you were doing, like trying to use objects or words and add them to a block that already had a binding.</p>
<pre><code>&gt;&gt; body: [keep staticvar: staticvar + x]

&gt;&gt; collect [
       wrapper: func [x] with ['keep {staticvar: 0}] body
       wrapper 1
       wrapper 10
       wrapper 100
   ]
== [1 11 111]
</code></pre>
<p>(Just trying to drum up a little excitement for FENCE! there, but I think it's the tip of the iceberg.)</p>
<p>Anyway, there've been educational lessons from showing that you <em>can</em> extend the FUNC spec dialect and build higher level features... but I think we should probably tear those out of the core and move to something like this.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/rethinking-static-in-the-function-spec-dialect/2139">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rethinking-static-in-the-function-spec-dialect/2139</link>
          <pubDate>Tue, 30 Jan 2024 21:48:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2139</guid>
          <source url="https://forum.rebol.info/t/rethinking-static-in-the-function-spec-dialect/2139.rss">Rethinking `&lt;static&gt;` in the Function Spec Dialect</source>
        </item>
        <item>
          <title>How to Capture Binding Of PARSE Items</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Binding</category>
          <description><![CDATA[
            <p>Consider some simple code that used to "work" (in of course only the simplest of cases)</p>
<pre><code>&gt;&gt; parse [word: 10] [
       let word: set-word! let val: integer! (
           set word val
       )
   ]
</code></pre>
<p>We're getting some unbound values by structural extraction.  But now that structural extraction doesn't propagate bindings... how do we look those values up in an environment?</p>
<p>We'd get the wrong answer if we said <strong>set (inside [] word) val</strong>... that would try to bind the "word" word to the LET variable from the rule.  I made it conflict just to stress the point that the processing code is not the right environment to be looking up values in the data most of the time.</p>
<p>When PARSE is doing the processing (and recursions in our data for us), we're cut out of the loop on binding.</p>
<h2>
<a name="solution-tactics-1" class="anchor" href="https://forum.rebol.info#solution-tactics-1"></a>Solution Tactics</h2>
<p>You can use the <code>&lt;input&gt;</code> TAG! combinator to get the input, and if there were an IN combinator you could do this yourself... handling recursions</p>
<pre><code>&gt;&gt; parse [[word: 10]] [
       let i: &lt;input&gt;
       subparse in (i) block! [  ; make subparse input propagate specifier
           let sub: &lt;input&gt;
           let word: set-word! let val: integer! (
               set (in sub word) val 
           )
       ]
   ]
</code></pre>
<p>Making this a little easier might be a combinator for capturing the parse state object, for getting the input more easily at any time.</p>
<pre><code>&gt;&gt; parse [[word: 10]] [
       let s: &lt;state&gt;
       subparse in (s.input) block! [  ; subparse changes s.input
           let word: set-word! let val: integer! (
               set (in s.input word) val
           )
       ]
   ]
</code></pre>
<p>Certainly some pain involved here.  Perhaps <a class="mention" href="https://forum.rebol.info/u/bradrn">@bradrn</a> can appreciate the reason why propagating binding through structure automatically seemed necessary so things like this worked "like magic".</p>
<p><em>But it was bad magic.</em>  If the structural operations presume ideas about binding, that ties our hands in the interpretation of binding for the input block.  We have <strong>[[word: 10]]</strong> now, but what if we wanted something like <strong>[let word [word: 10]]</strong>?  It's up to the parse of this "dialect" to decide the bindings, not have it automatic.  It's only the refusal of the automaticness allowing the LET in PARSE above to be implemented!</p>
<p>Though actually in this simple case, you could just say:</p>
<pre><code>&gt;&gt; parse [[word: 10]] [
       subparse in &lt;input&gt; block! [  ; make subparse input propagate specifier
           let word: in &lt;input&gt; set-word! let val: integer! (
               set (in sub word) val 
           )
       ]
   ]
</code></pre>
<p>Even briefer, a TAG! combinator <code>&lt;in&gt;</code> that means <strong><code>in &lt;input&gt;</code></strong>:</p>
<pre><code>parse [[word: 10]] [
   subparse &lt;in&gt; block! [
       let word: &lt;in&gt; set-word! let val: integer! (
           set word val
       )
   ]
]
</code></pre>
<p>Not too arduous, and you have the necessary hook points for alternative binding interpretation when you need it.  And if you're just processing code structurally, you don't have to worry about it.</p>
<p><em>(Note: Trying this I remembered that TAG! combinators haven't been set up to take arguments.  Should they be able to?  Maybe not... none do at the moment, and it seems a reasonable policy to say they don't.  If not a TAG! then what should this be?  It could be the behavior of the <code>@</code> operator... which is a bit incongruous with how <code>@word</code> etc. are handled in PARSE, but lines up sort of with wanting to capture the current sense of binding on the next argument.  Something to think about, I'm calling it <strong><code>*in*</code></strong> as a placeholder just to move along)</em></p>
<h2>
<a name="other-places-this-pops-up-2" class="anchor" href="https://forum.rebol.info#other-places-this-pops-up-2"></a>Other Places This Pops Up</h2>
<p>If you're writing something like a FOR-EACH loop, and you want to get the bindings of things, you can look the thing up in an environment that you have on hand:</p>
<pre><code>&gt;&gt; block: [word: 10]
&gt;&gt; for-each [word val] block [
      set (in block word) val
   ]

&gt;&gt; word
== 10
</code></pre>
<p>It's manual, but it works.  But what if the block were literal, and you didn't have access to it?</p>
<pre><code>&gt;&gt; for-each [word val] [word: 10] [
      set (??? word) val
   ]
</code></pre>
<p>Where this may be pointing is that instead of trying to imagine weirdly designed FOR-EACH variants that incorporate binding, it may be that you should think in terms of PARSE as the tool for when you want to enumerate with binding...</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/how-to-capture-binding-of-parse-items/2137">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-to-capture-binding-of-parse-items/2137</link>
          <pubDate>Mon, 29 Jan 2024 19:44:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2137</guid>
          <source url="https://forum.rebol.info/t/how-to-capture-binding-of-parse-items/2137.rss">How to Capture Binding Of PARSE Items</source>
        </item>
        <item>
          <title>Meaning of META-BLOCK! ^[...]</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="2135">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/repurposing-the-xxx-xxx-for-undecorated-values/2135/1">Repurposing THE-XXX! (@xxx) For Undecorated Values</a>
</div>
<blockquote>
<p>In any case, preliminary looking at the results <strong><a href="https://forum.rebol.info/t/repurposing-the-xxx-xxx-for-undecorated-values/2135">(of repurposing the @xxx types)</a></strong>, I think this is a solid change and much needed in the new binding world.</p>
</blockquote>
</aside>
<p>Found one glitch... there was an idiom of using the inertness in some places with blocks.</p>
<pre><code>&gt;&gt; spaced ["Reduced" 1 + 2 "Content"]
== "Reduced 3 Content"

&gt;&gt; spaced @["Unreduced" 1 + 2 "Content"]
== "Unreduced 1 + 2 Content"

&gt;&gt; meta pack [1 + 2 10 + 20]
== ~['3 '30]~

&gt;&gt; meta pack @[1 + 2 10 + 20]
== ~['1 '+ '2 '10 '+ '20]~
</code></pre>
<p>This won't work anymore, as the evaluator isn't inert here.</p>
<p>HOWEVER... there is a construct that can pick up the slack.  The META-BLOCK!</p>
<pre><code>&gt;&gt; ^[1 + 2 10 + 20]
== '[1 + 2 10 + 20]
</code></pre>
<p>It produces a block which is quoted, and which captured a binding.  So it is suitable for this purpose.  It does raise questions like "what to do if the block is double or triple quoted" etc, but I think raising an error is fine for the moment.</p>
<hr>
<p>Coincidentally, I was thinking about my desire to have a proper FOR dialect.</p>
<pre><code> &gt;&gt; for x [1 to 3] [print x]
 1
 2
 3
</code></pre>
<p>And then, the concept of "going meta" struck me as interesting:</p>
<pre><code> &gt;&gt; for x meta [1 to 3] [print x]
 1
 to
 3
</code></pre>
<p>Which would mean that FOR when given a quoted block would enumerate its contents vs. run the dialect.  Then you could also write that as:</p>
<pre><code> &gt;&gt; for x ^[1 to 3] [print x]
 1
 to
 3
</code></pre>
<p>If you didn't want a binding you need a quoted block and a generator applied to the resulting unbound block:</p>
<pre><code> &gt;&gt; for x each '[1 to 3] [print x]
 1
 to
 3
</code></pre>
<p>It's interesting to see the parts coming together with some things not being as useless as first thought.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/meaning-of-meta-block/2145">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/meaning-of-meta-block/2145</link>
          <pubDate>Mon, 29 Jan 2024 08:50:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2145</guid>
          <source url="https://forum.rebol.info/t/meaning-of-meta-block/2145.rss">Meaning of META-BLOCK! ^[...]</source>
        </item>
        <item>
          <title>Repurposing THE-XXX! (@xxx) For Undecorated Values</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Historical Rebol used quoted words (LIT-WORD!) to pass variables to functions, with the idea the function could then later set or get those variables.  The quote level was removed under evaluation, meaning the function got a WORD!</p>
<pre><code>rebol2&gt;&gt; whatever: 10

rebol2&gt;&gt; foo: func [var [word!]] [print [var "is" get var]]

rebol2&gt;&gt; foo 'whatever
whatever is 10
</code></pre>
<p>But we now have a general rule that quoting insulates whatever you quote from binding.  So you have to add the binding, by saying something like <strong><code>foo in [] 'whatever</code></strong></p>
<p>This isn't the only option, if the callee was willing to receive something other than WORD!.  We also have THE-WORD!, which currently evaluates to the bound version of itself.</p>
<pre><code>&gt;&gt; @whatever
== @whatever

&gt;&gt; foo: func [var [the-word!]] [print [var "is" get var]]

&gt;&gt; foo @whatever
@whatever is 10
</code></pre>
<p>This gets you the binding you want, but now you have a decorated word, which would be annoying if FOO is trying to do something besides GET/SET the value.  Plain words are the norm.</p>
<p>If you wanted an undecorated word, you could use the standalone @ operator... which gives back its argument literally:</p>
<pre><code>&gt;&gt; @ a
== a
</code></pre>
<p><strong><code>@ a</code></strong> is a little bit uglier than <strong><code>'a</code></strong> but not as bad as <strong><code>in [] 'a</code></strong></p>
<pre><code>&gt;&gt; foo: func [var [word!]] [print [var "is" get var]]

&gt;&gt; foo @ whatever
whatever is 10
</code></pre>
<p>But the spacing just throws it off to where it no longer looks like a single argument.  And it doesn't look like one because it isn't (e.g. can't fill exactly one slot in the API or a COMPOSE).  @ is also a function under the current design (you can redefine it), so calling it incurs some overhead.</p>
<h2>
<a name="or-we-could-say-that-things-evaluate-and-drop-the-1" class="anchor" href="https://forum.rebol.info#or-we-could-say-that-things-evaluate-and-drop-the-1"></a>Or... We Could Say that @ Things Evaluate And Drop The @</h2>
<pre><code>&gt;&gt; @word
== word  ; bound

&gt;&gt; @(print "Hello")
== (print "Hello")  ; bound

&gt;&gt; @[print "Hello"]
== [print "Hello"]  ; bound, less useful as plain block would have done that
</code></pre>
<p>This would make <strong><code>@word</code></strong> and <strong><code>@ word</code></strong> symmetrical, which is appealing.</p>
<p>But it's at the cost of losing the idea of a category of ANY-WORD! that stays somewhat as-is.</p>
<h2>
<a name="how-big-a-loss-is-the-inert-wordgrouptuplepath-2" class="anchor" href="https://forum.rebol.info#how-big-a-loss-is-the-inert-wordgrouptuplepath-2"></a>How Big A Loss Is The "Inert" WORD!/GROUP!/TUPLE!/PATH!</h2>
<p>In practice, the idea of inert words hasn't lived up to my hopes for them.  I thought maybe since they would be shielded from multiple phases of reducing, they might become popular for some kind of enumerated types.  But being a bit ugly, that's not materialized.</p>
<p>If it gives you any idea of how not-popular the application has been, I changed the evaluator behavior and it <a href="https://github.com/metaeducation/ren-c/blob/0d2d7c39733f21e1088240ab2e5c7614072c8059/src/mezz/uparse.r#L151">only required <em>one</em> change in UPARSE to boot</a>:</p>
<pre><code>  (if spec.1 = '@pending [
        assert [spec.2 = [&lt;opt&gt; block!]]
        autopipe: false  ; they're asking to handle pending themselves
        spread reduce [@pending spec.2]  ; &lt;-- this has to be '@pending
        elide spec: my skip 2
    ] else [
        autopipe: true  ; they didn't mention pending, handle automatically
        spread [@pending [&lt;opt&gt; block!]]
    ])
</code></pre>
<p>They're still free to be used in dialects for whatever purpose (here we see them marking output parameters in the function spec dialect).  And they serve a good purpose in PARSE for "treat this value literally":</p>
<pre><code>&gt;&gt; block: [some "a"]

&gt;&gt; parse ["a" "a"] [block]
== "a"

&gt;&gt; parse [[some "a"] [some "a"]] [some @block]
== [some "a"]
</code></pre>
<p>But it seems that with the new binding model, they have a higher calling in the evaluator... for producing undecorated bound things!</p>
<p>If you want wordlike things that do not reduce, there's blank-headed paths like <strong><code>/FOO</code></strong> ("refinement").  They have a binding and can be looked up.  Today, blank-headed tuples like <strong><code>.FOO</code></strong> don't evaluate, but I'm aiming to say that they do--and that they do member lookup in methods.  Or... y'know... you could put the word in a block! <strong><code>[foo]</code></strong></p>
<h2>
<a name="note-that-decorated-types-have-to-use-3" class="anchor" href="https://forum.rebol.info#note-that-decorated-types-have-to-use-3"></a>Note That Decorated Types Have To Use @</h2>
<p>There's no such thing as a THE-SET-BLOCK! (and I don't imagine there ever will be).</p>
<pre><code> &gt;&gt; @[x y]:
 ** Error: That doesn't exist

 &gt;&gt; @ [x y]:
 == [x y]:
</code></pre>
<p>So it's only the plain WORD!, TUPLE!, PATH!, GROUP! and (redundantly) BLOCK! that you can do this without a space.</p>
<p>But it's likely much rarer to be generating such material bound in isolation.</p>
<p>In any case, preliminary looking at the results, I think this is a solid change and much needed in the new binding world.</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/repurposing-the-xxx-xxx-for-undecorated-values/2135">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/repurposing-the-xxx-xxx-for-undecorated-values/2135</link>
          <pubDate>Mon, 29 Jan 2024 06:12:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2135</guid>
          <source url="https://forum.rebol.info/t/repurposing-the-xxx-xxx-for-undecorated-values/2135.rss">Repurposing THE-XXX! (@xxx) For Undecorated Values</source>
        </item>
        <item>
          <title>Optimizing Environment Lookup</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <h2>
<a name="object-storage-object-frame-port-error-1" class="anchor" href="https://forum.rebol.info#object-storage-object-frame-port-error-1"></a>Object Storage (OBJECT!, FRAME!, PORT!, ERROR!)</h2>
<p>Rebol objects were designed as two parallel arrays, which we can call the "keylist" and the "varlist".  Originally these were entire cells, like this:</p>
<pre><code>obj: make object! [a: 10 b: 20]

            0     1     2
KEYLIST  [     |  a  |  b  ]   ; 4 platform pointers per cell

            0     1     2
VARLIST  [self |  10 |  20 ]   ; 4 platform pointers per cell
</code></pre>
<p>The idea is that the <code>[0]</code>th cell of the varlist contains an instance of the object itself.  This means if the implementation has a pointer to the varlist in its hand, it also has a cell instance of the object.  This also means you can find out from just the varlist what subtype it is (ERROR!, FRAME!, PORT!, etc.)</p>
<p>R3-Alpha used full 4-platform-pointer-sized WORD! cells for each element in the keylist, and left the [0]th cell empty.</p>
<p>Ren-C optimized this to just point to symbols.  So keylists are arrays of single pointers, and there is no [0]th element.</p>
<pre><code>                  0     1 
KEYLIST        [  a  |  b  ]   ; 1 platform pointer per cell

            0     1     2
VARLIST  [self |  10 |  20 ]   ; 4 platform pointers per cell
</code></pre>
<p>Keylists are shared among objects that are used as prototypes for each other, e.g. <strong>obj2: make obj [...]</strong>.  They will become un-shared if any of the objects are expanded.</p>
<p>(Object expansion is allowed in R3-Alpha and Ren-C, but not Rebol2 or Red).</p>
<h2>
<a name="module-storage-module-2" class="anchor" href="https://forum.rebol.info#module-storage-module-2"></a>Module Storage (MODULE!)</h2>
<p>R3-Alpha used the same layout for modules containing hundreds of items as it did for objects.</p>
<p>Ren-C instead allocates small variable "stubs" for each variable in a module.  Each stub is 8 platform pointers in size.</p>
<ul>
<li>4 of those platform pointers are for the cell of the variable's value</li>
<li>1 pointer is for the symbol of the variable</li>
<li>1 pointer is to the module the variable is for</li>
<li>1 pointer to the next stub with the same symbol for another module</li>
<li>1 pointer-sized slot unused at this time</li>
</ul>
<p>These form a linked list of all the same-named variable instances in modules.  This list is pointed to by the symbol itself.</p>
<p>If we want to check if a WORD! cell has a variable in a module, the cell contains a pointer to the word's symbol.  We follow that, and get to the list of variables.  We can walk that list and see if there is an instance matching the module we are looking for.</p>
<h2>
<a name="let-variables-3" class="anchor" href="https://forum.rebol.info#let-variables-3"></a>LET Variables</h2>
<p>At the moment, LET variables are similar to the stubs holding variables for a module... except they don't have an associated module.</p>
<h2>
<a name="specifier-chains-are-linked-lists-of-contexts-or-containers-4" class="anchor" href="https://forum.rebol.info#specifier-chains-are-linked-lists-of-contexts-or-containers-4"></a>Specifier Chains Are Linked Lists Of Contexts -or- Containers</h2>
<p>Things like FRAME! or OBJECT! or MODULE! have one pointer for their "parent specifier".  So when you do something like:</p>
<pre><code> let x: 10
 obj: make object! [y: x + 10, z: x + 20]
</code></pre>
<p>The BLOCK! that object receives has a specifier put onto it... in this case, it will be a LET variable.  That LET variable presumably points up to something else (an enclosing function frame, or a module, or whatever).</p>
<p>The object creates its varlist, and then that varlist has a pointer to the LET.  It uses this as the edited specifier when running the body block of the object.</p>
<p>But if you later try to leverage that object elsewhere e.g. with <strong>overbind obj [...]</strong>, it wants to chain that object onto some other specifier.  However its parent link is already in use for the other chain.  So this means a little stub USE container is needed... which points at the object and provides a new slot to put a pointer in.</p>
<h2>
<a name="looking-up-an-unbound-word-walks-this-chain-5" class="anchor" href="https://forum.rebol.info#looking-up-an-unbound-word-walks-this-chain-5"></a>Looking Up An Unbound Word Walks This Chain</h2>
<aside class="quote no-group quote-modified" data-username="bradrn" data-post="12" data-topic="1751">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751/12">Rebol And Scopes: Well, Why Not?</a>
</div>
<blockquote>
<p>Though I do spy one low-hanging fruitâ€¦</p>
<aside class="quote no-group" data-username="hostilefork" data-post="11" data-topic="1751">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751/11">Rebol And Scopes: Well, Why Not?</a>
</div>
<blockquote>
<p>a linked list of objects</p>
</blockquote>
</aside>
<p>Might it not be quicker to use a hashmap or similar data structure?</p>
</blockquote>
</aside>
<p>It's not entirely obvious what to hash, here.  And it's not so much that any particular lookup is all that slow.  It's just that there's lots of them, and you can't reliably cache the answer between runs.</p>
<p><a href="https://forum.rebol.info/t/semantics-and-optimization-of-copying-function-bodies/2119/2">One thing I cited to exploit</a> was the fact that when you copy a function body, you tend to wind up with elements that look up either in a module or in the frame of that function.</p>
<ul>
<li>
<p>Module lookup is relatively fast because there aren't all that many redundant names (e.g. there's typically only one APPEND and it's in LIB.)</p>
</li>
<li>
<p>Function frames are not allowed to expand.</p>
</li>
<li>
<p>You can use the space in the unbound elements to give an answer to something knowable--like "this isn't defined in the frame for function X" or "this is defined in the frame for function X at offset Y", that can let you skip along to searching in the module or beeline for the pointer to what you want in the frame.</p>
</li>
</ul>
<p>I'm sure this will help.  Will have to see how much.</p>
<h2>
<a name="gc-load-is-a-big-problem-6" class="anchor" href="https://forum.rebol.info#gc-load-is-a-big-problem-6"></a>GC Load Is A Big Problem</h2>
<p>Ren-C's garbage collector has some interesting points, but it's still a mark-and-sweep strategy.</p>
<p>These specifier chains are being allowed to leak out, with every function call producing tons of them... and function frames have to be GC'd because you can't assume there are no extant references.  (Natives are an exception, they will free their frames when they end, but you can't do that with usermode functions because they use frames as specifiers in the blocks they run... and you don't know what happens to that block).</p>
<p>LETs are pretty bad too... a LET inside a loop creates a little piece of junk each time that needs to get cleaned up.</p>
<p>I think reference counting would be helpful, because most of these aren't referenced very long and aren't involved in cycles.  So reaching a 0 refcount would be a moment the memory could be reclaimed.  My guess is it would outweigh the cost of the reference counting by a fair bit.  But it's difficult to do reference counting correctly in C-like code (although having a C++ build variant it could be double-checked).</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/optimizing-environment-lookup/2134">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/optimizing-environment-lookup/2134</link>
          <pubDate>Thu, 25 Jan 2024 03:27:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2134</guid>
          <source url="https://forum.rebol.info/t/optimizing-environment-lookup/2134.rss">Optimizing Environment Lookup</source>
        </item>
  </channel>
</rss>

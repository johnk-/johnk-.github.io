<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Development - AltRebol</title>
    <link>https://forum.rebol.info/c/development/8</link>
    <description>Topics in the &#39;Development&#39; category Discussion of the development of Rebol itself: language design, implementation and standard library.</description>
    
      <lastBuildDate>Sun, 28 Aug 2022 16:39:55 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/8.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Better Answers than TRY and OPT For BLANK! &lt;=&gt; NULL</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>Ever since the creation of null and blank, it's been desirable to go between them.</p>
<p>The word I first chose for NULL =&gt; BLANK! was TRY.  It would pass through anything else:</p>
<pre><code>&gt;&gt; try null
== _

&gt;&gt; try _
== _

&gt;&gt; try 1020
== 1020
</code></pre>
<p>The reverse operation of converting BLANK! =&gt; NULL was called OPT; again passing through everything else:</p>
<pre><code>&gt;&gt; opt _
; null

&gt;&gt; opt null
; null

&gt;&gt; opt 1020
== 1020
</code></pre>
<p>It may seem mysterious to ascribe such a trivial operation to a high-value word like TRY.  But it made sense at the time, because nulls were rather unfriendly:</p>
<pre><code>&gt;&gt; if not x: find "abc" "d" [print "Assignment goes okay..."]
Assignment goes okay...
; null

&gt;&gt; if not x [print "But word fetching has problems"]
** Error: X is NULL    
</code></pre>
<p>TRY provided a way to disarm the result:</p>
<pre><code>&gt;&gt; x: try find "abc" "d"
== _

&gt;&gt; if not x [print "Didn't find it"]
Didn't find it
</code></pre>
<p>But as it turned out: NULL was trying to do too many things, being fused with the notion of "unset variables".  It was a good start on having non-valued states... we just needed more!</p>
<p>Once VOID arrived it was no longer necessary to error on null variable accesses, and this particular usage of TRY was not necessary.</p>
<h2>But...It Was Actually On The Right Track...</h2>
<p>FIND is a bad demonstration.  But TAKE on empty block is actually a good one from that erroring-on-nulls era:</p>
<pre><code>&gt;&gt; x: take []
; null

&gt;&gt; if x [print "-some- error around here seems right..."]
** Error: X is NULL

&gt;&gt; x: try take []
== _

&gt;&gt; if x [print "-some- signal for saying it's okay seems right..."]
-some- signal for saying it's okay seems right...
</code></pre>
<p>But we see it's suboptimal, as now X is valued... and conflates with if we had written <strong><code>take [_]</code></strong>.  It also seems the need for the TRY in this case should have been independent of whether you stored the result in a variable or not.</p>
<p>Definitional errors come in and clean this mess up... so that TRY can defuse the take and give you the NULL state you want:</p>
<pre><code>&gt;&gt; x: take []
** Error: TAKE of EMPTY block, use TRY if you meant to do that

&gt;&gt; x: try take []
; null
</code></pre>
<h2>But Now How Do We Interconvert BLANK! and NULL?</h2>
<p>You're still going to come across situations where you pick a blank out of a block, where it's representing a null intent.  And it's illegal to compose or append nulls to blocks / etc, so how do you convert them?</p>
<p>Meet REIFY and DECAY.</p>
<pre><code>&gt;&gt; reify null
== _

&gt;&gt; decay _
; null
</code></pre>
<p>We actually have new members of this family: the conversion of isotopes to quasiforms.</p>
<pre><code>&gt;&gt; true
== ~true~  ;  isotope

&gt;&gt; append [a b c] true
** Error: Cannot append ~true~ isotope to block, use REIFY for quasiform

&gt;&gt; append [a b c] reify true
== [a b c ~true~]

&gt;&gt; append [a b c] as word! true
== [a b c true]
</code></pre>
<p>I think the words are a nice coupling...and even the same number of letters!</p>
<h2>What Will OPT Do Now?</h2>
<p>I'm not sure.  I'm actually pulling back a bit on the idea of saying that what happens in PARSE is a TRY... because in essence there's always a built-in "TRY" during parse.  Rules are raising definitional errors, but that's just swept under the rug by the parse process itself.  So OPT kind is kind of a different shade of meaning there.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/better-answers-than-try-and-opt-for-blank-null/1946">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/better-answers-than-try-and-opt-for-blank-null/1946</link>
          <pubDate>Sun, 28 Aug 2022 16:39:55 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1946</guid>
          <source url="https://forum.rebol.info/t/better-answers-than-try-and-opt-for-blank-null/1946.rss">Better Answers than TRY and OPT For BLANK! &lt;=&gt; NULL</source>
        </item>
        <item>
          <title>Thinking About Isotopes Logically: ~true~ and ~false~</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Here's an idea: what if <strong>~true~</strong> and <strong>~false~</strong> are examples of weird isotopic exceptions.</p>
<p>Let's say you could assign them to variables...and fetch them from variables...without erroring:</p>
<pre><code>&gt;&gt; true: ~true~
== ~true~  ; isotope

&gt;&gt; false: ~false~
== ~false~  ; isotope

&gt;&gt; obj: make object! [y: true, n: false]
== make object! [
     y: ~true~
     n: ~false~
]
</code></pre>
<p><em>(not being quoted in the assignment indicates they become their isotopic forms.)</em></p>
<p>This is typically not legal...accessing a WORD! isotope from a variable like true would be an error.  But these would be special (like how I'm suggesting isotopic ACTION! would be special in running the action from a word reference...)</p>
<p>Things that tested for truthiness would treat them as expected, considering the ~false~ isotope to be a falsey thing:</p>
<pre><code>&gt;&gt; any [true false]
== ~true~  ; isotope

&gt;&gt; all [true false]
; null
</code></pre>
<p><em>Being isotopes comes with a constraint</em>...you couldn't put them into blocks.  You'd have to ^META them (which would lose their special status, turning them into QUASI-WORD!s...that were truthy.</p>
<pre><code>&gt;&gt; ^ false
== ~false~

&gt;&gt; if ^ false [print "Meta false is truthy"]
Meta false is truthy
</code></pre>
<p>The functions TRUE? and FALSE? could then work on isotopic, non-isotopic, or word forms of TRUE and FALSE...but error if passed other values.</p>
<ul>
<li>
<p><strong>This should work for casual cases of just having variables that hold a true or false state...and gives a good appearance for knowing what you're looking at.</strong></p>
</li>
<li>
<p><strong>It builds on standard mechanisms, and hence if you need to promote the isotopic state into something that can be represented in a block you can do so... with the caveat that once you do, it will no longer reflect its logical property when used with IF and such.</strong></p>
<ul>
<li><strong>That's true for NULL being ^META promoted and put in blocks as well.</strong></li>
</ul>
</li>
</ul>
<p><strong>And crucially: Since you know isotopes can't be in blocks--and if we say BLANK! is truthy as well--then you'd be guaranteed to visit all the items in a block with code like this:</strong></p>
<pre><code>while [item: try take block] [
    print mold item
]
</code></pre>
<p>This is easily the best idea so far for dealing with the problem.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944</link>
          <pubDate>Thu, 25 Aug 2022 23:34:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1944</guid>
          <source url="https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944.rss">Thinking About Isotopes Logically: ~true~ and ~false~</source>
        </item>
        <item>
          <title>BLANK! 2022: Revisiting The Datatype</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Long, long ago there was a datatype called NONE.  In historical Redbol, it had the bad habit of looking like a WORD!:</p>
<pre><code>rebol2&gt;&gt; 'none
== none

rebol2&gt;&gt; none
== none  ; same in R3-Alpha and Red
</code></pre>
<p>But it wasn't a word:</p>
<pre><code>rebol2&gt;&gt; type? 'none
== word!

rebol2&gt;&gt; type? none
== none!
</code></pre>
<p>It was a distinct type, which also happened to be falsey (while WORD!s are truthy):</p>
<pre><code>rebol2&gt;&gt; if 'none [print "Truthy word!"]
Truthy word!

rebol2&gt;&gt; if none [print "Falsey none!"]
== none
</code></pre>
<p>And as we can see, NONE!s served purposes of signaling "soft failures": branches that didn't run, or FINDs that didn't find, or SELECTs that didn't select... etc.</p>
<pre><code>rebol2&gt;&gt; find "abcd" "z"
== none

rebol2&gt;&gt; select [a 10 b 20] 'c
== none
</code></pre>
<h2>Ren-C Divided NONE!s roles across NULL, VOID, and BLANK!</h2>
<ul>
<li>
<p><strong>NULL</strong> - a non-ANY-VALUE! state that couldn't be put in BLOCK!s.  Anywhere that NONE! would be used to signal a soft failure operation--like FIND or SELECT--would use NULL.</p>
<pre><code>&gt;&gt; find "abcd" "z"
; null

&gt;&gt; select [a 10 b 20] 'c
; null

&gt;&gt; append [a b c] null
** Error: APPEND doesn't allow NULL
</code></pre>
</li>
<li>
<p><strong>VOID</strong> - the "isotopic" form of NULL, which represents the result of things that are effectively "no ops".  Unlike nulls, they will vanish in-between expressions, and when functions like APPEND get them as an argument they are treated as no-ops:</p>
<pre><code>&gt;&gt; if null [print "Doesn't print as NULL is falsey"]
; void

&gt;&gt; 1 + 2 if null [print "Voids disappear..."]
== 3

&gt;&gt; append [a b c] void
== [a b c]
</code></pre>
<p>Void is also the state of unset variables.</p>
<pre><code>&gt;&gt; unset 'foo
; void

&gt;&gt; get/any 'foo
; void
</code></pre>
</li>
<li>
<p><strong>BLANK!</strong> was represented by a lone underscore ( <strong><code>_</code></strong> ) and could be put into blocks:</p>
<pre><code>&gt;&gt; append [a b c] _
== [a b c _]
</code></pre>
<p>It retained the choice to be falsey:</p>
<pre><code>&gt;&gt; if _ [print "Won't print because blanks are falsey"]
</code></pre>
</li>
</ul>
<h2>Question One: Could BLANK! Just Be A WORD! ?</h2>
<p>You might wonder if you could just say:</p>
<pre><code>&gt;&gt; _: '_
== _
</code></pre>
<p>This would give you BLANK! as a WORD! that had the behavior of reducing to itself.</p>
<pre><code>&gt;&gt; reduce [_ 1 + 2 _]
== [_ 3 _]
</code></pre>
<p>That could be just a default, and you could redefine it to anything you wanted.  Generally speaking, people do like being able to define words as operators... and _ has historically been a WORD! (Ren-C allows you to use underscores internally to words, so it feels a little bad to take away one word).</p>
<p>But outside of being hardcoded as falsey, what makes BLANK! fairly "built in" is that in the path mechanics, it fills in the empty slots:</p>
<pre><code>&gt;&gt; to path! [_ a]
== /a

&gt;&gt; as block! 'a//b//c
== [a _ b _ c]
</code></pre>
<p>Alternately, we could get a "reified nothing" with a quoted null:</p>
<pre><code>&gt;&gt; to path! [' a]
== /a

&gt;&gt; as block! 'a//b//c
== [a ' b ' c]
</code></pre>
<p>But there's other places the blank is used, such as to opt-out of multi-returns.</p>
<pre><code>&gt;&gt; [_ pos]: transcode "abc def"
; void

&gt;&gt; pos
== " def"
</code></pre>
<p>So freeing it up to be an arbitrary variable feels kind of wrong, as if it were taken for dialects like multi-return you'd be unable to set it as a variable.</p>
<p>This may be an argument for using something like a TAG! instead, so you're not worrying about overlapping with user variables:</p>
<pre><code>[&lt;_&gt; pos]: transcode "abc def"
</code></pre>
<p>Similar arguments have led me to contemplate the dangers of using things like <strong><code>[a b ...]:</code></strong> in case someone has assigned a meaning to the ellipsis.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:">  That might be a good reason to keep <strong><code>...</code></strong>  as a TUPLE! instead of a WORD! exception, because no one could assign it.</p>
<p><strong>I'm pretty sure we should keep _ reserved as a BLANK! datatype, not a WORD!.</strong>  People can still give it arbitrary meanings in dialects, they just can't assign values to it as a variable... and they can't do that with <strong><code>#</code></strong> either or <strong><code>&lt;a&gt;</code></strong> so I can live with it.  Taking it away from the word pool does more good than harm.</p>
<h2>Question Two: Does BLANK! Still Need To Be Falsey?</h2>
<p><em>My feeling is that having blank be falsey doesn't have all that much benefit.</em>  NULL does a better job of it, and really what it does is mess with its usefulness as a placeholder:</p>
<pre><code>&gt;&gt; append [a b c] all [1 &lt; 2, 3 &lt; 4, _]
== [a b c _]  ; would seem nice, but gives error today since ALL is NULL
</code></pre>
<p>Thinking of BLANK! as being "null-like" in terms of non-valuedness is generally a hassle.  It makes you wonder about whether something like DEFAULT should think of it as being assigned or not:</p>
<pre><code>&gt;&gt; item: _

&gt;&gt; item: default [1 + 2]
== ???
</code></pre>
<p>In practice, I prefer the truly non-valued NULL (and its isotopic state of VOID) being the only cases that DEFAULT overwrites.  This is because NULL is far more useful than BLANK! when it comes to representing something that you think of as "not being assigned"... as you'll get errors when you try to use it places (e.g. in APPEND).  Trying to use it to represent nothingness invariably leads to stray appearances in blocks (Shixin wrote a lot of code to try to filter them out in Rebmake, prior to it being switched to NULLs)</p>
<p>Also, the asymmetry between BLANK! and NULL were part of a scheme to try and solve what Redbols called "NONE! propagation":</p>
<pre><code>&gt;&gt; second null
** Error: SECOND doesn't take NULL

&gt;&gt; try null
== _

&gt;&gt; second try null
== null
</code></pre>
<p><strong>We still want this general concept, but <a href="https://forum.rebol.info/t/definitional-errors-as-blank-in-null-out-alternative/1880/7">the new idea is that it's VOID which opts out</a> cleanly from these operations, and MAYBE is the operator that produces them.</strong></p>
<p>This makes more sense, and I think it bolsters the argument that BLANK! is less of a falsey-NULL relative...but more of a placeholder value.  I've said "blanks are to blocks what space is to strings".  And space is truthy:</p>
<pre><code>&gt;&gt; if second "a b" [print "Space is truthy"]
Space is truthy

&gt;&gt; if second [a _ b] [print "So why shouldn't blank be truthy?"]
???
</code></pre>
<p><strong>So I Suggest The Removal of BLANK! From Being Falsey</strong>.  This creates some incompatibility in Redbol (which has been using NONE! as a blank substitute).  But it's something that can be worked around.</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942</link>
          <pubDate>Thu, 25 Aug 2022 13:50:26 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1942</guid>
          <source url="https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942.rss">BLANK! 2022: Revisiting The Datatype</source>
        </item>
        <item>
          <title>Incomplete TRANSCODEs: Actually an Optimization Problem</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p><strong>Ren-C has a very slick multi-return interface for TRANSCODE.</strong>  The mere request of a "remainder" of data left indicates you're not trying to do a full scan.</p>
<p>Without the request, you get the whole thing:</p>
<pre><code>&gt;&gt; transcode "abc def"
== [abc def]

; ...or...

&gt;&gt; value: transcode "abc def"
== [abc def]

; ...or...

&gt;&gt; [value]: transcode "abc def"
== [abc def]
</code></pre>
<p>With the next position request, just one item and a remainder:</p>
<pre><code>&gt;&gt; [value pos]: transcode "abc def"
== abc

&gt;&gt; pos
== " def"

; ...or...

&gt;&gt; transcode/next "abc def" 'pos
== abc

&gt;&gt; pos
== " def"
</code></pre>
<p>You also know that you're at the end of the input when it returns null, with all the benefits of easy reactions to NULL with IF and ELSE and friends:</p>
<pre><code>&gt;&gt; [value pos]: transcode ""
; null
</code></pre>
<p>Writing foolproof loops to process items are a breeze:</p>
<pre><code>while [true]
    [item utf8]: transcode utf8 else [break]
    print mold item
 ]

; or for the THEN/ELSE haters out there (you know who you are :-P)

while [true]
    if null? [item utf8]: transcode utf8 [
        break
    ]
    print mold item
 ]
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/+1.png?v=9" title=":+1:" class="emoji only-emoji" alt=":+1:"></p>
<h2>This Runs Circles Around Red and R3-Alpha</h2>
<p>For starters: neither support strings as input--because the scanner is built for reading UTF-8 files...and both R3-Alpha and Red unpack strings into fixed-width encodings.  So if you have string input, you have to pay for a copy encoded as UTF-8 via TO BINARY!.  (<a href="https://forum.rebol.info/t/realistically-migrating-rebol-to-utf8-everywhere/374">Ren-C's UTF-8 Everywhere</a> wins again!)</p>
<p>R3-Alpha unconditionally returns a block with the last element as a remainder, whether you ask for one item via /NEXT or not:</p>
<pre><code>r3-alpha&gt;&gt; transcode to binary! "abc def"
== [abc def #{}]

r3-alpha&gt;&gt; transcode/next to binary! "abc def"
== [abc #{20646566}]

r3-alpha&gt;&gt; transcode/next to binary! ""
== [#{}]
</code></pre>
<p>So if you were transcoding an entire input, you have to TAKE/LAST an always-empty binary off of the result.</p>
<p>But you are using /NEXT you have to PICK out the element from the start of the array and the remainder from the end.  But you need to notice the exception of no-value-produced where the block is length 1 instead of 2.</p>
<p>That's awkward, but as usual... <em>Red somehow manages to make an incompatible interface that is as much worse as it is better:</em></p>
<p>The better part is that if you don't ask for /NEXT you just get the block back, like in Ren-C:</p>
<pre><code>red&gt;&gt; transcode to binary! "abc def"
== [abc def]
</code></pre>
<p>But the /NEXT interface is outright broken:</p>
<pre><code>red&gt;&gt; transcode/next to binary! "abc def"
== [abc #{20646566}]

red&gt;&gt; transcode/next to binary! ""
== [[] #{}]
</code></pre>
<p>It might look better because you don't have to guess about which position to find the remainder in--it's always in the second slot.  But it has a fatal flaw: you can't distinguish the result state of scanning <code>"[]"</code> and any string with nothing but comments and whitespace.</p>
<p>Consider this very basic loop to scan one item at a time and print it:</p>
<pre><code>red&gt;&gt; utf8: to binary! "abc def"

red&gt;&gt; while [not tail? utf8] [
     set [item utf8] transcode/next utf8
     print mold item
]
abc
def
</code></pre>
<p>You get two items.  But what if you had something that was--say--a comment:</p>
<pre><code>red&gt;&gt; utf8: to binary! "; I'm just a comment"

red&gt;&gt; while [not tail? utf8] [
     set [item utf8] transcode/next utf8
     print mold item
]
[]
</code></pre>
<p>You get one spurious item.  (They chose BLOCK! for the item, but it wouldn't matter what it was--a NONE! would be just as bad, you're just losing the distinction between empty strings and <code>"#[none]"</code> then.)</p>
<p>If I were prescribing a solution for Red I'd say:</p>
<ul>
<li>
<p>Make /NEXT take a variable to write the next position into</p>
</li>
<li>
<p>Error on <code>#{}</code> input, so anyone doing a TRANSCODE/NEXT knows they are responsible for testing for TAIL? before they call (if they're not sure their input is non-empty)</p>
<ul>
<li>This way an empty remainder returned in the /NEXT variable will uniquely signal the reached-end state</li>
</ul>
</li>
<li>
<p>Make the synthesized product at the tail something ugly but assignable (so not an unset!)</p>
<ul>
<li>an ERROR! saying "end of input" is at least informative in case it winds up getting treated as an actual value somewhere</li>
</ul>
</li>
</ul>
<p>That would at least give them patterns like:</p>
<pre><code>if not tail? utf8 [  ; needed if you're not sure it's non-empty
    while [true] [
        item: transcode/next utf8 'utf8
        if tail? utf8 [break]
        print mold item
    ]
]
</code></pre>
<p><em>(Having NULL is clearly better as a non-valued state (with isotope states fleshing out the picture)...and my <a href="https://forum.rebol.info/t/why-or-why-not-have-unset-in-rebol-like-languages/113/2">bafflement at Nenad's blindness</a> when confronted with what should be clear as day is as relevant as it was 6-plus-years ago.  And of course we see they'd actually need SET/ANY to do this right if you were allowing #[unset!]...but Ren-C's design has no need of that.)</em></p>
<h2>Ren-C Also <em>Thrashes</em> R3-Alpha and Red In Error Handling</h2>
<p>Ren-C TRANSCODE has these potential behaviors:</p>
<ul>
<li>
<p>RETURN a BLOCK! (if plain TRANSCODE)</p>
</li>
<li>
<p>RETURN an ANY-VALUE! or NULL (if TRANSCODE/NEXT)</p>
</li>
<li>
<p>It can do a "hard FAIL"</p>
<ul>
<li>
<p>This would happen if you asked something fundamentally incoherent...like asking to TRANSCODE a with input that was non-UTF-8...like a GOB!, or something like that</p>
</li>
<li>
<p>Such errors are only interceptible by a special SYS.UTIL.ENTRAP method--they are not supposed to be easy to gloss over and unlikely to have meaningful mitigation.  So only special sandboxing situations (like writing consoles that print out the error) are supposed to trap them.</p>
</li>
</ul>
</li>
<li>
<p>It can RETURN an <em>isotopic ERROR!</em> ("raised error") if something went wrong in the transcoding process itself</p>
<ul>
<li>
<p>This would be something like a syntax error, like  if you asked <strong>transcode "a bc 1&amp;x def"</strong></p>
</li>
<li>
<p>These will be promoted to a hard FAIL if the immediate caller doesn't do something to specially process them.</p>
</li>
<li>
<p>You can casually ignore or intercept these, because you can be confident that it was a formal return result of the thing you just called--not some deeper problem like a random typo or other issue.</p>
</li>
</ul>
</li>
</ul>
<p>I won't rehash the entire <a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852">"why definitional errors are foundational"</a> post, but TRANSCODE was one of the first functions that had to be retrofitted to use them.</p>
<pre><code>&gt;&gt; transcode "a bc 1&amp;x def" except e -&gt; [print ["Error:" e.id]]
Error: scan-invalid
</code></pre>
<p><strong>The definitionality is extremely important!</strong>  I spent a long time today because in the bootstrap shim I had a variation of transcode...parallel to this in R3-Alpha:</p>
<pre><code>r3-alpha&gt;&gt; transcode: func [input] [
               prnit "My Transcode Wrapper"  ; oops, typo
               return transcode input
           ]

r3-alpha&gt;&gt; if not attempt [transcode to binary! "abc def"] [print "Bad input"]
Bad input
</code></pre>
<p><em><strong>But the input isn't bad!!!</strong></em>  This leads to a nightmare of trying to figure out what was going wrong.  I had just one of those nightmares today in the bootstrap executable when tinkering with the shim implementation of TRANSCODE.  A bug in the shim was leading to silently skipping work that should have been done, because the caller wanted to be tolerant of bad transcode input.</p>
<p>There's simply no practical way of working on code of any complexity without something like definitional failures, and experience has proven this day after day.</p>
<h2>Getting Incomplete Results Via R3-Alpha's /ERROR</h2>
<p>R3-Alpha offered this feature:</p>
<pre><code>/error -- Do not cause errors - return error object as value in place
</code></pre>
<p>The intended use is that you might want the partial input of what had been successfully scanned so far.  If the code went and raised an error, you could trap that error.  But you wouldn't have any of the scanned items.</p>
<p>It would put it any ERROR! as the next-to-last item in the block, with the remainder after that:</p>
<pre><code>&gt;&gt; transcode/error to binary! "a bc 1&amp;x def"
== [abc make error! [
    code: 200
    type: 'Syntax
    id: 'invalid
    arg1: "pair"
    arg2: "1&amp;x"
    arg3: none
    near: "(line 1) a bc 1&amp;x def"
    where: [transcode]
] #{20646566}]

&gt;&gt; to string! #{20646566}
== " def"  ; wait...why isn't 1&amp;x part of the "remainder"
</code></pre>
<p>It's clumsy to write the calling code (or to read it...testing to see if the next-to-last-item is an ERROR! and reacting to that.</p>
<p><em>(Also: What if there was some way to represent ERROR! values literally in source?  This would conflate with such a block that was valid...but just incidentally had an ERROR! and then a BINARY! in the last positions.)</em></p>
<p>But the thing that had me most confused about it was the remainder.  Notice above you don't get  <code>1&amp;x</code> as the start of the stuff it couldn't understand.</p>
<p>Was it trying to implement some kind of recoverable scan?  What would that even mean?  <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=9" title=":thinking:" class="emoji" alt=":thinking:"></p>
<p><strong>Ultimately I think this was just a leaking of an implementation detail as opposed to any reasonable attempt at recoverable scanner.</strong>  It only didn't tell you where the exact tail of the successfully scanned material was because it did not know.</p>
<p>The scanning position is based on token consumptions, and so if you started something like a block scan and it saw a <strong>[</strong> then it forgets where it was before that.  Then if something inside the block goes bad, it will just give you a remainder position somewhere inside that--<em>completely forgetting about how many nesting levels it was in</em>.</p>
<p>So what you were getting was a crappier implementation of scanning one by one, and remembering where you were before the last bad scan:</p>
<pre><code>pos: input
error: null
block: collect [
   while [true] [
       keep [# pos]: transcode pos else [
           break
       ] except e -&gt; [
           error: e
           break
       ]
   ]
]
</code></pre>
<p>That gives you a proper version, setting error if something happened and giving you the block intact.</p>
<h2>So Finally... We See It's An Optimization Problem</h2>
<p>Question is if there's some way of folding this into TRANSCODE, so it's doing the looping and collecting efficiently for you.</p>
<p>But this interface wants to get back a "remainder".  And I kind of hate to sacrifice the property that TRANSCODE's asking for a remainder means scan one element.  :-/</p>
<p>I guess we <em>could</em> say that there's a logical process you follow:</p>
<ul>
<li>
<p>The output parameter is called REST (instead of NEXT)</p>
</li>
<li>
<p>An additional output parameter is added for ERROR</p>
</li>
<li>
<p>If you ask for the REST and <em>don't</em> ask for an ERROR, that suggests you want to encode a single item</p>
<ul>
<li>
<p>You could have just intercepted the error if you wanted it</p>
</li>
<li>
<p>Nothing is lost because there wouldn't be any partial results to miss (if you're only doing one item, there will always be zero items completed before it)</p>
</li>
</ul>
</li>
<li>
<p>If you ask for the REST and <em>do</em> ask for an error, then it assumes you must not want the one-item-only semantics after all.</p>
</li>
</ul>
<p>It's a little bit awkward because it conflates partial output with fully successful output</p>
<pre><code>&gt;&gt; [block rest error]: transcode "a bc"
== [a bc]

&gt;&gt; error
; null

&gt;&gt; [block rest error]: transcode "a bc 1&amp;x def"
== [a bc]  ; no indication something failed

&gt;&gt; error? error  ; you'd have to remember to check this
== #[true]
</code></pre>
<p>That's not a deal breaker, and Ren-C makes it easy to work with, using <a href="https://forum.rebol.info/t/circling-multi-returns-choose-which-is-expression-result/1587">circling an output in multi-return</a> to make it the primary return result:</p>
<pre><code>&gt;&gt; [block rest @error]: transcode "a bc"
; null

&gt;&gt; [block rest @error]: transcode "a bc 1&amp;x def"
== make error! [...]
</code></pre>
<p><strong>What's much more jarring to me is the flipping back and forth of whether you're asking for a full transcode or not.</strong></p>
<pre><code>&gt;&gt; x: transcode "abc def"
== [abc def]

&gt;&gt; [x y]: transcode "abc def"
== abc

&gt;&gt; [x y z]: transcode "abc def"
== [abc def]
</code></pre>
<p>Ick.  Should I be willing to bend on the transcode "requested parameter" behavior in this case, by adding a /ONE refinement?</p>
<pre><code>&gt;&gt; [block rest]: transcode "abc def"
== [abc def]

&gt;&gt; rest
== #{}  ; kind of useless, but honest

&gt;&gt; [block rest]: transcode/one "abc def"
== abc

&gt;&gt; rest
== " def"
</code></pre>
<p>That would make me feel grief, as it loses one of the first showcases of return value sensitivity.  <em>And it irks me to think that the beauty is ultimately being given up for the sake of what amounts to an optimization.</em></p>
<h2>Answer For Now: Kill Off /ERROR</h2>
<ul>
<li>
<p>The answer /ERROR has been giving back in error cases for the remainder is sketchy, and I don't want to figure out how to fix it.</p>
</li>
<li>
<p>You can get the behavior reliably just by intercepting errors going one transcode item at a time.</p>
</li>
<li>
<p>This is a good opportunity to write tests of item-by-item scanning with error handling</p>
</li>
<li>
<p>Red added a bunch of refinements on transcode [/next /one /prescan /scan /part /into /trace], and they didn't pick up /error themselves</p>
</li>
</ul>
<p>Speaking of adding lots of refinements: I also want to get away in general from investments in weird C scanner code and hooks (<em>especially</em> if it's just an optimization).</p>
<p>What we should be investing in is more fluid mixture of PARSE of strings/binary with the scanner.  e.g. we should have ways of knowing what line number you're at during the parse for any combinator, and just generally pushing on that.  Adding TRANSCODE parameters up the wazoo isn't a winning strategy.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/incomplete-transcodes-actually-an-optimization-problem/1940">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/incomplete-transcodes-actually-an-optimization-problem/1940</link>
          <pubDate>Mon, 22 Aug 2022 15:09:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1940</guid>
          <source url="https://forum.rebol.info/t/incomplete-transcodes-actually-an-optimization-problem/1940.rss">Incomplete TRANSCODEs: Actually an Optimization Problem</source>
        </item>
        <item>
          <title>Optimizing TRANSCODE Usage in String/Binary PARSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p>As written, the DATATYPE! combinator in UPARSE may do wasteful value loading when operating on string input.</p>
<p>Consider this case.</p>
<pre><code>&gt;&gt; parse "[some big block ...] 10" [collect some [keep integer! | block!]]
== [10]
</code></pre>
<p><em>Pretty impressive that it works.</em>  (Red will only do this on BINARY! input, but Ren-C's UTF-8 everywhere allows it to do it on strings too!)</p>
<p>But at the combinator level, it's wasteful.  What happens is:</p>
<ul>
<li>
<p>Hitting the INTEGER! combinator, causing it to scan the next element, loading <strong><code>[some big block ...]</code></strong> as a series into memory.</p>
<ul>
<li>It then checks the type, notices it's not an integer, and the INTEGER! combinator gives back a rejection...so the BLOCK! combinator goes to the next alternate.</li>
</ul>
</li>
<li>
<p>It hits the BLOCK! combinator and scans the block again.</p>
<ul>
<li>
<p>This time it matches, so the parser returns success and the synthesized block</p>
</li>
<li>
<p><em>But the block isn't actually desired</em>, so it is thrown away</p>
</li>
</ul>
</li>
<li>
<p>The next iteration scans the INTEGER! and keeps it.</p>
</li>
</ul>
<h2>Why Does It Work This Way?</h2>
<p>It's based on TRANSCODE, and does basically exactly what I said:</p>
<pre><code>[item remainder]: transcode input except e -&gt; [return raise e]

if datatype != type of item [
    return raise ["Could not TRANSCODE" datatype "from input"]
]
return item
</code></pre>
<p>If we could pass in a datatype to TRANSCODE when using the /NEXT option (e.g. requesting a remainder, as we are above) then it could short-circuit and we wouldn't need that test.</p>
<h2>Red Has Looked At This Kind of Problem</h2>
<p>There are a bunch of new arguments to Red's TRANSCODE function:</p>
<pre><code>USAGE:
     TRANSCODE src

DESCRIPTION: 
     Translates UTF-8 binary source to values.
     Returns one or several values in a block. 

ARGUMENTS:
     src          [binary! string!]
     {UTF-8 input buffer; string argument will be UTF-8 encoded.}

REFINEMENTS:
     /next        =&gt; Translate next complete value (blocks as single value).
     /one         =&gt; Translate next complete value, returns the value only.
     /prescan     =&gt; Prescans only, do not load values. Returns guessed type.
     /scan        =&gt; Scans only, do not load values. Returns recognized type.
     /part        =&gt; Translates only part of the input buffer.
         length       [integer! binary!] "Length in bytes or tail position."
     /into        =&gt; Optionally provides an output block.
        dst          [block!] 
     /trace       =&gt; 
        callback     [function! [
                        event [word!]
                        input [binary! string!]
                        type [word! datatype!]
                        line [integer!]
                        token
                        return: [logic!]
                      ]] 

RETURNS:
    [block!]
</code></pre>
<p>I'm not sure exactly how useful the /PRESCAN option is (what good is a "guess" of the type?)  But the /SCAN option would offer some bit of efficiency.</p>
<p>It would mean instead of one call to TRANSCODE followed by a datatype test, there'd be two calls</p>
<ul>
<li>
<p>The first as TRANSCODE/SCAN to get the datatype (but not synthesize a value from it)</p>
</li>
<li>
<p>A second call to scan again and get the value</p>
</li>
</ul>
<p>We assume the idle mode of scanning without producing anything can be fast.</p>
<p>I would suggest the scan feature be <strong>transcode/types</strong> so it worked more generally, not just with /NEXT.</p>
<pre><code>&gt;&gt; transcode/types [1 a [b]]
== [#[datatype! integer!] #[datatype! word!] #[datatype! block!]]
</code></pre>
<p><sub><em>(When I figure out the story of datatypes, there are going to be a lot of forum posts fixing up the above ugly notation.)</em></sub></p>
<h2>But What About The Synthesis Of Unused Values?</h2>
<p>This is a bit of a pickle.  <em>We don't know if you're going to use the product or not.</em></p>
<p>UPARSE's design has values bubbling out the top, and no line of communication to be aware of whether what it produces will be used:</p>
<pre><code>&gt;&gt; uparse "[a] (b)" [block! group!] 
== (b)
</code></pre>
<p>You might think that when the block! rule is going to be run, UPARSE could notice it wasn't at the end and send some kind of signal to the BLOCK! combinator that it doesn't have to synthesize an output.  But there's no a-priori psychic power saying that GROUP! hasn't been configured to evaluate to void.  Until the combinator gets looked up and run, it's potentially the same situation as this:</p>
<pre><code>&gt;&gt; uparse "[a] (b)" [block! void] 
== [a]
</code></pre>
<h2>It Seems We Have Two Choices</h2>
<ol>
<li>
<p>We can assume that a plain DATATYPE! intends to synthesize a value, and use a different combinator to say you only want to match the type:</p>
<pre><code>&gt;&gt; uparse "[a b c]" [scan block!]
== #[datatype! block!]  ; cheap (but useful) return value, no series synthesis

&gt;&gt; uparse "[a b c]" [block!]
== [a b c]
</code></pre>
</li>
<li>
<p>We can reverse it and say that by default it does the cheap thing, and you have to explicitly ask to get the expensive thing:</p>
<pre><code>&gt;&gt; uparse "[a b c]" [block!]
== #[datatype! block!]

&gt;&gt; uparse "[a b c]" [scan block!]
== [a b c]
</code></pre>
</li>
</ol>
<p>Looked at in isolation, it might seem like (2) would be the obvious winner.</p>
<p>The thorn is that this would be a pretty notable divergence from how array parsing works, which I would basically call non-negotiable:</p>
<pre><code>&gt;&gt; uparse [[a b c]] [x: block!]

&gt;&gt; x
== [a b c]
</code></pre>
<p>So is there actually an option 3?</p>
<ol start="3">
<li>
<p>Make lone datatype! an error, and have two distinct operations for transcoding:</p>
<pre><code>&gt;&gt; uparse "[a b c]" [block!]
** Error: On string input, use either TRANSCODE BLOCK! or SCAN BLOCK!

&gt;&gt; uparse "[a b c]" [transcode block!]
== [a b c]

&gt;&gt; uparse "[a b c]" [scan block!]
== [a b c]
</code></pre>
</li>
</ol>
<p>Urg.  That kind of sucks.</p>
<p><strong>I think the answer is to accept option (1) being suboptimal performance, allowing those who are performance-minded to tune it.</strong>  There's no overt harm by scanning things you throw away, it's just wasteful.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/optimizing-transcode-usage-in-string-binary-parse/1939">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/optimizing-transcode-usage-in-string-binary-parse/1939</link>
          <pubDate>Sun, 21 Aug 2022 19:10:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1939</guid>
          <source url="https://forum.rebol.info/t/optimizing-transcode-usage-in-string-binary-parse/1939.rss">Optimizing TRANSCODE Usage in String/Binary PARSE</source>
        </item>
        <item>
          <title>Should RETURN be Assignable on Function Interfaces?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>When implementing multi-returns I had an idea, to think of <strong><code>[x]: negate 10</code></strong> in terms of slipping X into the RETURN: slot of NEGATE as an input.</p>
<p>On the surface that seems like it might even be useful more generally:</p>
<pre><code> &gt;&gt; f: make frame! :negate

 &gt;&gt; negate.return: 'x  ; X gets hidden, and RETURN is redefined during the call

 &gt;&gt; negate.value: 10

 &gt;&gt; do f  ; the hidden X is written back automatically
 == -10

 &gt;&gt; x
 == -10
</code></pre>
<h2>But Not Every Action is a FUNC/FUNCTION</h2>
<p>Not all functions are guaranteed to have something in their frame called RETURN (e.g. a LAMBDA does not).  And a non-FUNC ACTION! could have something in its frame called RETURN that wasn't used for anything pertaining to the return process.</p>
<p>This ruled it out from being a mechanic relied on by the multi-return machinery.  Because we want the following to work:</p>
<pre><code>&gt;&gt; test: lambda [x] [x + 20]

&gt;&gt; [y]: test 1000
== 1020

&gt;&gt; y
== 1020
</code></pre>
<h2>Nevertheless, People Can Implement It If They Want</h2>
<p>It's certainly something you could <em>choose</em> to do if you were writing your own function generator.</p>
<p>In fact, it's trivial to write a wrapper for it!  Just add a /RETURN to the public interface, and write back to it if it's supplied:</p>
<pre><code>returnproxy: lambda [action [action!]] [
    enclose (augment :action [/return [word!]]) f -&gt; [
        (maybe f.return): do f
    ]
]
</code></pre>
<p>That means you can pass it as a refinement:</p>
<pre><code>&gt;&gt; test: lambda [x] [x + 1000]

&gt;&gt; wrapper: returnproxy :test

&gt;&gt; wrapper/return 20 'y
== 1020

&gt;&gt; y
== 1020
</code></pre>
<p>Or you can use it with a frame:</p>
<pre><code>&gt;&gt; f: make frame! :wrapper
&gt;&gt; f.x: 20
&gt;&gt; f.return: 'out

&gt;&gt; do f
== 1020

&gt;&gt; out
== 1020
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/nut_and_bolt.png?v=9" title=":nut_and_bolt:" class="emoji only-emoji" alt=":nut_and_bolt:"></p>
<p><em>(Seeing superpowers like this work so clearly and obviously is what keeps me invested in this.)</em></p>
<h2>So Anyone CAN Do It, But Should FUNC/FUNCTION Do It?</h2>
<p>I lean toward not doing it with things implemented the way they are right now, because it would add overhead to every function with a RETURN:, due to needing to have a place to store the variable if you gave it one.</p>
<p>But it might be nice to give people an optimized version of the proxying wrapper above.  You could then convert any function to support it.</p>
<h2>But today RETURN is on the public interface of FUNC <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:">
</h2>
<pre><code>&gt;&gt; f: make frame! func [x] [return x + 1000]
== make frame! [
    return: ~
    x: ~
]
</code></pre>
<p><em>"Errr.  Why's it there?"</em>, you might ask.</p>
<p>The reason is that the return typeset information currently lives on that field.  So if you're going to ask about it, you get it from there.</p>
<p><strong>This is one of many good arguments for why this information should <em>not</em> live there.</strong></p>
<p>There's a long running body of evidence suggesting that the way return types are managed today is probably wrong.</p>
<ul>
<li>
<p><strong>LAMBDA Can't Currently Document Its Result Types</strong>.  There are a lot of actions out there that don't have a RETURN function, but nevertheless have something to say about what types they can produce.</p>
</li>
<li>
<p><strong>ENCLOSE Can't Change The Type Signature</strong>.  If you wrap a function, you're subject to its type checking rules.</p>
</li>
<li>
<p><strong>NATIVE Doesn't Want To Pay For A RETURN Slot</strong>.  The typechecking is only done in the debug build, so why should every native frame require a RETURN function?</p>
</li>
</ul>
<p>I think I've got some ideas coming together--mostly centering on factoring out typechecking to be another one of the little pieces you can build functions out of (like AUGMENT).  So when doing a composition you would just bolt on a typechecker if you wanted one.  Internal efficiencies could fold that in so it actually didn't generate a separate phase and action identity.  Pursing some inspiration on that as we speak...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-return-be-assignable-on-function-interfaces/1929">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-return-be-assignable-on-function-interfaces/1929</link>
          <pubDate>Sat, 20 Aug 2022 05:32:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1929</guid>
          <source url="https://forum.rebol.info/t/should-return-be-assignable-on-function-interfaces/1929.rss">Should RETURN be Assignable on Function Interfaces?</source>
        </item>
        <item>
          <title>Waforth: WebAssembly Forth</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>There may be some relevant or interesting things to learn by looking at this:</p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://el-tramo.be/favicon-32x32.png?v=1560365977" class="site-icon" width="32" height="32">
      <a href="https://el-tramo.be/blog/waforth/" target="_blank" rel="noopener" title="12:00AM - 24 May 2018">el-tramo.be – 24 May 18</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/271;"><img src="https://el-tramo.be/blog/waforth/header@2x.png" class="thumbnail" width="690" height="271"></div>

<h3><a href="https://el-tramo.be/blog/waforth/" target="_blank" rel="noopener">A Dynamic Forth Compiler for WebAssembly</a></h3>

<p>In yet another ‘probably-useless-but-interesting’ hobby project, I wrote a Forth compiler and interpreter targeting WebAssembly. It’s written entirely in WebAssembly, and comes with a compiler that dynamically emits WebAssembly code on the fly. The...</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>I've wanted to do some kind of dynamic Wasm generation--even very simple--so we can have something like the experience of the TCC natives, but on the web.  So seeing what they have to go through is probably informative.</p>
<p>Here are the design notes:</p>
<p><a href="https://github.com/remko/waforth/blob/master/doc/Design.md">https://github.com/remko/waforth/blob/master/doc/Design.md</a></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/waforth-webassembly-forth/1927">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/waforth-webassembly-forth/1927</link>
          <pubDate>Fri, 19 Aug 2022 15:22:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1927</guid>
          <source url="https://forum.rebol.info/t/waforth-webassembly-forth/1927.rss">Waforth: WebAssembly Forth</source>
        </item>
        <item>
          <title>JUST For Sale - Low Mileage, Original Owner, Like New</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>As the /ONLY debacle was chipped away at... slowly... the role of quoting came to the forefront.  Quotes were used to <em>suppress</em> splicing (in contrast with today's isotopic blocks through SPREAD, which <em>request</em> the splicing).</p>
<p>So the anti-spread behavior looked something like:</p>
<pre><code>&gt;&gt; append [a b c] first [[d e]]
== [a b c d e]

&gt;&gt; append [a b c] first ['[d e]]
== [a b c [d e]]
</code></pre>
<p>I'm picking out of an outer block there just to avoid confusion, because notice what happens when there's no container:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c d e]

&gt;&gt; append [a b c] '[d e]
== [a b c d e]
</code></pre>
<p>By design, the evaluator strips off quotes, leading to potential confusion when it comes to what people might think they could do with such a system.</p>
<p>You might think that this is all fine and you could just call the function QUOTE instead of putting a quote mark on the value.  Hence the quoted block is an evaluation <em>product</em> not an evaluation <em>input</em>...and so it makes it to the append:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c d e]

&gt;&gt; append [a b c] quote [d e]
== [a b c [d e]]
</code></pre>
<p>But there were protections that were added to try and discern if you were adding non-inert values without quoting them.</p>
<pre><code>&gt;&gt; append [a b c] "this was presumed okay since it was inert"
== [a b c "this was presumed okay since it was inert"]

&gt;&gt; append [a b c] 'd
** Error: d is a WORD! and evaluative...your callsite might accidentally lose an
    apostrophe if you didn't know what you were doing.  Quote it to be safe.
</code></pre>
<p><em>(Note: I always disliked how these errors were working, I just hadn't gotten to the isotope design yet.  They did afford some protection.)</em></p>
<p>This would lead you to a couple of bad options to work with the case when you had something evalutative at source level:</p>
<pre><code>&gt;&gt; append [a b c] quote 'd
== [a b c d]

&gt;&gt; append [a b c] ''d
== [a b c d]
</code></pre>
<p>In an attempt to make the "just add a thing at source level" case a slight bit easier, I made JUST.</p>
<pre><code>&gt;&gt; just d
== 'd

&gt;&gt; append [a b c] just d
== [a b c d]
</code></pre>
<h3>Let's Take A Moment To Be Thankful For Isotopes...</h3>
<p>All of this is behind us now.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/pray.png?v=9" title=":pray:" class="emoji only-emoji" alt=":pray:"></p>
<p>But of course, the mechanics are actually nearly identical.  Just subtract 1 from all the quoting levels, and allow -1 for BLOCK!s.  <em>(Then build upon years of diligence in bulletproofing the system from leaking -1 quotelevels where they shouldn't be.)</em></p>
<h2>But JUST is Free Again.  Now What?</h2>
<p>There was a time when JUST was what I now call THE.</p>
<pre><code>&gt;&gt; just x
== x

&gt;&gt; just ''[foo]
== ''[foo]
</code></pre>
<p>I thought it was a good word for it at the time.  But THE won me over:</p>
<pre><code>&gt;&gt; the x
== x

&gt;&gt; the ''[foo]
== ''[foo]
</code></pre>
<h3>Maybe Something That Limits to One Expression Only?</h3>
<pre><code>&gt;&gt; just add 1 2
== 3

&gt;&gt; just add 1 2 10
** FAIL: JUST code had residual material: 10
</code></pre>
<p>I've been wanting a syntax for this at the API level, when you think you're running one expression:</p>
<pre><code>REBVAL* sum = rebJust("add", value1, value2, "10");
</code></pre>
<p>In that world, it's not any more typing (actually less typing than rebValue)...but gives you an extra bit of safety.</p>
<p>With regular (non-API) code, I can see it being very useful in generated code scenarios.</p>
<h3>Perhaps A THE-like Operator With A Shade of Meaning In PARSE?</h3>
<p>PARSE needs to keep raw material sometimes, and I've pointed out some of the hazards in the past of making you do this with GROUP!s when nested compositions are involved.</p>
<p>So might these be different?  As an example:</p>
<pre><code>parse ... [x: the ''foo] =&gt; parse ... [x: (the ''foo)]

parse ... [x: just ''foo] =&gt; parse ... [x: '''foo]
</code></pre>
<p>So above, THE is synthesizing ''foo out of whole cloth with no need to match it in the input.  The other would require a ''foo in the input to be considered a match.</p>
<p>For WORD!s, the above sense of JUST isn't as necessary, as there's a decent visual trick:</p>
<pre><code>parse ... [x: just ''foo] =&gt; parse ... [x: '|''foo|]
</code></pre>
<p>But other datatypes would not have this out, and you'd always be reading the thing you see in the rule as having one more quote level than what you're matching.</p>
<p>There's the option of putting it in an @ group:</p>
<pre><code>parse ... [x: just ''foo] =&gt; parse ... [x: @(the ''foo)]
</code></pre>
<p>But this has the problems I mention about nested composition that can be a major hassle when writing rule genreators and you have to weasel something like <strong><code>''foo</code></strong> inside a group inside a composed block.</p>
<p>This definition might jibe with keeping the regular evaluator meaning of JUST as it is (literal but add a quoting level).</p>
<h3>Other Ideas?</h3>
<p>Hopefully no one wants to fight to swap JUST with THE, because I really like THE as it is.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/just-for-sale-low-mileage-original-owner-like-new/1923">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/just-for-sale-low-mileage-original-owner-like-new/1923</link>
          <pubDate>Fri, 19 Aug 2022 03:09:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1923</guid>
          <source url="https://forum.rebol.info/t/just-for-sale-low-mileage-original-owner-like-new/1923.rss">JUST For Sale - Low Mileage, Original Owner, Like New</source>
        </item>
        <item>
          <title>The FAIL That Wins Big: Combinator Definitional Errors</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <h2>Announcing Another Major Step Forward...</h2>
<p>As the wheels of thought began to churn around TRY, it came to seem clear that it had a higher purpose in defusing definitional errors.</p>
<p>This led to a thought about how if UPARSE were to allow calling arbitrary decoders (like DEBIN) that would deliver informative errors when the input wasn't a fit...that those errors would need to be interpreted as "soft" parse match failures...moving on to the next alternate.</p>
<p>That called back to another musing about why we don't use the readable word TRY instead of OPT in PARSE when we want to say a component of a parse is optional.</p>
<p>But so long as the combinator-skinned-decoders are communicating in errors, <strong>why not make combinators always indicate failure with definitional errors?</strong></p>
<ul>
<li>
<p>This would free up NULL as a synthesized product to just be an ordinary result, which had been a sticking point trying to wrangle the dual needs of isotopic nulls in a fully generic dialect.</p>
</li>
<li>
<p>The parsers would be able to generate diverse and informative errors, that in debug modes could be tagged with where they came from.  Parsers could distinguish between tunneling an error generated by another parser and emitting their own...providing more information for tracing tools.</p>
</li>
</ul>
<p><strong>It only took a couple of days to do...</strong> most of which was just sorting out a lot of edge cases from being a very thorough client of the relatively untested definitional error infrastructure.</p>
<p>But expect good things from this!</p>
<h2>A Bit Of History: How The Previous Model Came To Be</h2>
<p>When UPARSE was first conceived <em>(a mere year and a half ago)</em>, the combinators were responsible for returning three things:</p>
<ul>
<li>
<p>Whether the parser succeeded or not</p>
</li>
<li>
<p>A synthesized value</p>
</li>
<li>
<p>How much of the input was consumed (represented by a series position of the new "current" parse position, which could potentially be at the tail)</p>
</li>
</ul>
<p><em>(COLLECT and friends necessitated some more nuances, but you only have to worry about it manually if you need fine-grained control.  So most combinators look like these are the only results in play, with the other outputs being "autopiped" around by the machinery.)</em></p>
<p>The second two results would only be applicable if the parser succeeded.  So rather than return three results, it aimed to return just two... and fold together the success with some invalid state for the other result.</p>
<p>At first this seemed like it would be best to fold with the series position.  This would mean that the position could be either a series value or NULL.  That way, NULL could be a valid synthesized product.  This came in handy for things like OPT:</p>
<pre><code>&gt;&gt; x: y: &lt;before&gt;

&gt;&gt; did parse [1020] [x: integer! y: opt integer!]
== #[true]  ; parse succeeded

&gt;&gt; x
== 1020

&gt;&gt; y
; null
</code></pre>
<p>The first draft used the fledgling multi-return facility to do this, and it had the nice property of working with ELSE.  So when a combinator called a parser that failed, it was easy to handle that failure, e.g. to propagate that failure along:</p>
<pre><code>[pos synthesized]: parser input else [return null]
</code></pre>
<h2>But This Was Reversed... For... Reasons</h2>
<p>A mechanical issue came up that VOID could only be represented by the primary return result of a function.  If a multi-return argument was going to be returned and convey voids, it would have to use the ^META protocol... and the caller would have to be explicitly aware that the result they got would be pre-quoted by convention.</p>
<p>But I also noticed that some combinators didn't want to advance the input at all, only operate to transform one synthesized product into another.  Or that they didn't really need to plug into the overall parse architecture.  It seemed like making combinators match as closely to a "normal" function--by putting their synthesized result as the primary result--just made sense.</p>
<p>NULL isotopes were just coming on the scene, which gave a potential way to get out of this: a successful parser which wanted to return NULL would return the isotope form.  Pure NULL would be reserved as the signal for isotopic failure.  This meant the reversed parameters would be able to work:</p>
<pre><code>[synthesized pos]: parser input else [return null]
</code></pre>
<p>Internally, to OPT something like <strong><code>y: opt integer!</code></strong> would not return NULL, but a ~null~ isotope.</p>
<h2>But Now, It's Done With Definitional Errors!</h2>
<pre><code>[synthesized pos]: parser input except e -&gt; [return raise e]
</code></pre>
<p>Here you see the error being intercepted, and then passed on.  NULL is free to be dealt with as a normal product without interference.  And there's a difference between generating a new error (tagging it with the location in the parse rules and the context) vs. just passing on one that was generated by a subparser--you are actually keeping a record of what happened, to show in logs or otherwise.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-fail-that-wins-big-combinator-definitional-errors/1922">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-fail-that-wins-big-combinator-definitional-errors/1922</link>
          <pubDate>Fri, 19 Aug 2022 02:27:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1922</guid>
          <source url="https://forum.rebol.info/t/the-fail-that-wins-big-combinator-definitional-errors/1922.rss">The FAIL That Wins Big: Combinator Definitional Errors</source>
        </item>
        <item>
          <title>The ^META of NULL and VOID</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1915">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/q-should-be-the-unevaluated-form-of-void/1915/1">Q: Should ~ Be The Unevaluated Form of VOID ?</a>
</div>
<blockquote>
<p>That doesn't resolve saying what the ^META of an actual void state is. Of course it could just be some weird non-sequitur thing, like <strong><code>@void</code></strong> (that's what it currently is, not to be confused with the new <code>~@void~</code> which would be the meta of an inert word isotope)</p>
<p>One possibility that crossed my mind is that it could actually be an isotopic state, e.g. producing actual unset variables:</p>
<pre><code>&gt;&gt; ^(comment "hi")
== ~  ; isotope
</code></pre>
<p>This runs counter to the idea that ^META values are always non-ornery--to make them easy to pipe around.</p>
</blockquote>
</aside>
<p>I tried this out, and... <em>it was a terrible idea</em>.  I knew that would be bad, but it was worse than I thought.  It wrecks the whole thing.</p>
<h1>But there's a much better option!</h1>
<p>I've been creeping toward convergence of the "quoting ladder" and the "meta ladder".</p>
<p><strong>I now believe we should go whole hog with it, and say that the ^META of a NULL is the same answer as QUOTE NULL:</strong></p>
<pre><code>&gt;&gt; ^(null)
== '

&gt;&gt; meta null
== '

&gt;&gt; '
; null
</code></pre>
<p><strong>But even further, I believe the ^META of VOID should be a Quasi-NULL</strong></p>
<pre><code>&gt;&gt; quasi null
== ~

&gt;&gt; meta void
== ~

&gt;&gt; ~
; void

&gt;&gt; unquasi '~
; null
</code></pre>
<p><strong>When you look at this in the overall pattern it means...</strong></p>
<h1>...VOID is the isotope form of NULL!!!</h1>
<p>It's like everything inching up the reification scale by one notch.  <strong>And it's much better.</strong>  The way things cohere is instantly apparent.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/person_climbing.png?v=9" title=":person_climbing:" class="emoji only-emoji" alt=":person_climbing:"></p>
<h2>Why Was ^META of NULL Defined As NULL To Begin With?</h2>
<p>I thought that since NULL was being used as the signal of "soft failure" and ELSE was reacting to it, that it would be nice if you could react to it even if a value had been ^META'd.</p>
<p>UPARSE made use of this, e.g.</p>
<pre><code>([^synthesized remainder]: parser input) then [
    ; do stuff with synthesized' and remainder on parser success
] else [
    ; do stuff on failure, usually propagating the failure
    return null
]
</code></pre>
<p>The majority of the time, this pattern could have been done differently, simply by letting the ELSE branch run in the same operation as the parser, before the result is ^META'd:</p>
<pre><code>[^synthesized remainder]: parser input else [
    ; do stuff on failure, usually propagating the failure
    return null
]

; do stuff with synthesized' and remainder on parser success
</code></pre>
<p><em>But excitingly, this is changing so that NULL isn't the cue at all.</em>  Instead, definitional errors are being used...which can convey more information about why the parser failed and help diagnose the moments and contexts of failure!</p>
<pre><code>[^synthesized remainder]: parser input except e -&gt; [
    ; do stuff on failure, usually propagating the failure
    return raise e
]

; do stuff with synthesized' and remainder on parser success
</code></pre>
<p>With the synthesized NULL state recaptured, there's suddenly high value in having the null states quoted.  They're properly in the same family as all the other results.</p>
<p><em>This may seem like esoteric stuff but I can assure you it's incredibly foundational, and getting it right has extremely pleasing consequences!</em></p>
<h2>There's Still The Quandary of FOR-BOTH</h2>
<p>I've cited it a million times by now, but this means the resolution is that it will have to use some other operation besides meta and unmeta, which pass through void and null (if it's going to try the ALL trick):</p>
<pre><code>for-both: lambda ['var blk1 blk2 body] [
    unmeta* all [
        meta* for-each (var) blk1 body
        meta* for-each (var) blk2 body
    ]
]
</code></pre>
<p>Plain META of VOID would make ~, which is truthy and would corrupt any prior result.</p>
<p>Plain META of NULL would make a quoted null, which is truthy, and wouldn't break the ALL as desired.</p>
<p>At this point what it comes down to is we have a naming problem for whatever the versions that pass through void and null should be called.  <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=9" title=":thinking:" class="emoji" alt=":thinking:">   I'll keep pondering it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-meta-of-null-and-void/1941">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-meta-of-null-and-void/1941</link>
          <pubDate>Thu, 18 Aug 2022 15:23:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1941</guid>
          <source url="https://forum.rebol.info/t/the-meta-of-null-and-void/1941.rss">The ^META of NULL and VOID</source>
        </item>
        <item>
          <title>Should SET-WORD! Disallow Isotopic Assignments?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>Historically, Rebol2 and R3-Alpha wouldn't let you assign UNSET! via a SET-WORD!, regardless of whether it was provided literally or through an evaluation.  You had to use SET/ANY:</p>
<pre><code>rebol2&gt;&gt; x: #[unset!]
** Script error: x: needs a value

rebol2&gt;&gt; x: print "hi"
hi
** Script error: x: needs a value

rebol2&gt;&gt; set/any 'x #[unset!]

rebol2&gt;&gt; x
** Script Error: x has no value
</code></pre>
<p>At first, I thought Red made a concession in the direct assignment case:</p>
<pre><code>red&gt;&gt; x: #[unset!]
== unset!

red&gt;&gt; x: print "hi"
hi
*** Script Error: x: needs a value
</code></pre>
<p>However, that's not what's happening...it's an incompatible interpretation...where Red considers #[unset!] to be the datatype for unset!, and #[unset] (no exclamation point, illegal in Rebol2) is an actual unset value:</p>
<pre><code>red&gt;&gt; type? #[unset!]
== datatype!

red&gt;&gt; type? #[unset]
== unset!

red&gt;&gt; x: #[unset]
*** Script Error: x: needs a value
</code></pre>
<p><strong>But I bring it up because at one point in time, Ren-C actually had a specific behavior that it would only allow a SET-WORD! to assign an unset to a variable if it was <em>not</em> the product of a function call.</strong>  Today this would look something like:</p>
<pre><code>&gt;&gt; x: ~

&gt;&gt; x: print "hi"
** Error: Cannot assign evaluative isotopes to X

&gt;&gt; set/any 'x ~

&gt;&gt; x
** Error: X is ~ isotope (e.g. isotopic BLANK!, represents an unset state)
</code></pre>
<p><strong>I've wondered if this rule strikes the right balance.</strong>  If you really want to deal with isotopic values that are the result of an evaluation, you would use ^META, and get the non-isotopic (QUASI!) form.  There'd be several ways of saying it:</p>
<pre><code>&gt;&gt; x: ^ print "hi"
== ~

&gt;&gt; x: ^(print "hi")
== ~

&gt;&gt; x: meta print "hi"
== ~

&gt;&gt; [^x]: print "hi"
== ~
</code></pre>
<p>This makes much more sense now than when NULL and "unset" were the same state.  And it would help keep isotopes under control.</p>
<h2>Implications for the "Only Isotopic ACTION! Runs" Idea</h2>
<p>This would mess with my current experimental branch where <a href="https://forum.rebol.info/t/attack-of-the-activated-actions/1900">isotopic actions stored in variables are the WORD!-triggered kind</a> (while regular actions would be inert).</p>
<p>It has FUNC returning isotopic actions, and you'd get an error:</p>
<pre><code>&gt;&gt; foo: func [/refine] [...]
** Error: Cannot assign isotope to FOO with SET-WORD! (see SET/ANY)
</code></pre>
<p>Making an exception for action isotopes, and saying they could be assigned without an annotation really feels like it undermines the entire proposal and the safety you'd get from it.</p>
<p>I will note that I really did get a warm fuzzy feeling when the generators produced plain ACTION!, and something had to tip it into being isotopic.  But I had to pan <strong><code>/foo: func [... /refine] [...]</code></strong> in no small part due to leading-slash being "taken" by refinements in function spec and apply.</p>
<p>This made me take a more serious look at the concept of retaking something like <strong><code>-&gt;</code></strong>.  Under the new rules that wouldn't have to finesse the assignment as well:</p>
<pre><code>foo: -&gt; func [/refine] [...]

foo: runs func [/refine] [...]  ; for those who dislike symbols
</code></pre>
<p>So either of these would act like <strong><code>set/any 'foo isotopic func [/refine] [...]</code></strong>.</p>
<p>Wait... <em>UNLESS...</em> <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=9" title=":thinking:" class="emoji" alt=":thinking:"></p>
<p>I just had a rather compelling thought, that such a tool could <em>only accept isotopic ACTION!</em>, and that this would provide natural guidance not to screw it up... because a plain assignment would error:</p>
<pre><code>&gt;&gt; foo: func [/refine] [...]
** Error: Can't assign isotope ACTION! via SET-WORD!, use -&gt; or INERT
</code></pre>
<p><em>So if all the function generators were committed to returning isotopes, it would be self-correcting.</em>  You wouldn't be able to forget to triage the assignment.</p>
<pre><code>&gt;&gt; foo: inert func [x] [print ["x is" x]]
== #[action! [x]]

&gt;&gt; foo
== #[action! [x]]

&gt;&gt; foo: -&gt; func [x] [print ["x is" x]]
== ~#[action! [x]]~  ; isotope

&gt;&gt; foo 10
x is 10
</code></pre>
<p>Now THAT is clever.  You're forced into triage, and can't forget to do one or the other!  Forgetting the annotation was one of the big Achilles heels of making generator products inert by default (hard to find bugs) but this ties that up.</p>
<p>Very promising premise!  But there are tricky issues, like how today's METHOD needs to look back to quote what it's being assigned to, in order to know how to bind the value.  Maybe it wouldn't need to... if <strong><code>-&gt;</code></strong> also made that binding connection...and maybe there'd be no such thing as METHOD.  <img src="https://forum.rebol.info/images/emoji/twitter/exploding_head.png?v=9" title=":exploding_head:" class="emoji" alt=":exploding_head:"></p>
<h2>Related Question: What About VOID ?</h2>
<p>A corollary to this question is <strong>"Should SET-WORD! Stop Treating VOID Assignments as Unsetting Variables"</strong></p>
<p>It might seem obvious to say "yes, that should be an error too".  In fact...since I've vetoed the idea of variables actually being able to hold "voidness" it might seem like an <em>even worse sin</em> that should be prohibited... because you're not actually preserving the "integrity" of the assignment.</p>
<p><em>BUT</em>... when I tried to rule it out I noticed that it was used in frames for things like setting refinements, like:</p>
<pre><code>&gt;&gt; series [a b c]
&gt;&gt; value: 3

&gt;&gt; f: make frame! :append
&gt;&gt; f.series: series
&gt;&gt; f.value: value
&gt;&gt; f.dup: if integer? value [value]

&gt;&gt; do f
== [a b c 3 3 3]
</code></pre>
<p>But should the IF evaluate to void...the /DUP would not be set.  That not-set state was leading the default behavior for the refinement being not set (to coerce it to NULL in the call).</p>
<p>This is an interesting use case, and it arguably isn't "doing an isotopic assignment" (void is not an isotope, and it has no QUASI! form).  It's making a subtle judgment call, and it might be a good one.  I'll keep this as-is for now.</p>
<h2>Ultimate Goal: Freedom Of Choice  <img src="https://forum.rebol.info/images/emoji/twitter/statue_of_liberty.png?v=9" title=":statue_of_liberty:" class="emoji" alt=":statue_of_liberty:">
</h2>
<p>It's still definitely want to make it possible to override these behaviors if you find they get in your way.  Certainly we'd need it for Redbol...but it should work at other granularities.</p>
<p>Why shouldn't you be able to say <em>"hey, for just this function's body I want all the SET-WORD!s to assign isotopes without complaint"</em>?</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/should-set-word-disallow-isotopic-assignments/1919">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-set-word-disallow-isotopic-assignments/1919</link>
          <pubDate>Wed, 17 Aug 2022 08:32:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1919</guid>
          <source url="https://forum.rebol.info/t/should-set-word-disallow-isotopic-assignments/1919.rss">Should SET-WORD! Disallow Isotopic Assignments?</source>
        </item>
        <item>
          <title>Should REDUCE Heed SPREAD?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>When <a href="https://forum.rebol.info/t/putting-splicing-intent-on-appended-value/1873/9">suggesting the term SPREAD</a>, <a class="mention" href="/u/rgchris">@rgchris</a> gave this example for REDUCE behavior, which hadn't occurred to me previously:</p>
<pre><code>&gt;&gt; reduce [spread [a b c] [a b c]]
== [a b c [a b c]]
</code></pre>
<p>Nothing about the design makes this happen automatically.  REDUCE has historically errored on isotopes.  So code has to be added to override that.</p>
<p>I'm guessing most people would be in favor of having the splicing behavior.  Arguments that say that there should be a 1:1 correspondence between expressions and values in a REDUCE are already pretty much out the window, since VOID elements vanish (including conditionals that don't take any branch).</p>
<h2>DELIMIT Would Presumably Want It Too</h2>
<p>I've complained in the past that the often random-seeming treatments of blocks in Rebol2 functions like REJOIN lead to problems--and that it would be better if people had to be explicit about their intent.  This offers the ability to "inherit" whatever the enclosing delimiting strategy is, and fold into the existing operation (technically more efficient):</p>
<pre><code>&gt;&gt; block: ["c" "d"]

&gt;&gt; spaced ["a" "b" block]
** Error: BLOCK! not handled by DELIMIT, use SPREAD or desired string conversion

&gt;&gt; spaced ["a" "b" spread block]
== "a b c d"

&gt;&gt; spaced ["a" "b" unspaced block]  ; if you wanted another interpretation
== "a b cd"
</code></pre>
<p>I believe I prefer this over having some default way that blocks behave inside string conversions.  The odds of guessing right are low enough that it's better to have people be explicit.</p>
<p>So...presuming there's no objections....there's an agenda item to fuse together the stackless logic that performs a REDUCE so that it's the same code running in DELIMIT, so I'd probably go ahead and do that and make these things work.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-reduce-heed-spread/1917">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-reduce-heed-spread/1917</link>
          <pubDate>Tue, 16 Aug 2022 04:10:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1917</guid>
          <source url="https://forum.rebol.info/t/should-reduce-heed-spread/1917.rss">Should REDUCE Heed SPREAD?</source>
        </item>
        <item>
          <title>Asking Questions About &quot;Wrapped&quot; Things (QUOTED!, BAD!)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>I've been held up on the new generalized isotopes due to looking at examples like this one:</p>
<pre><code>attempt: func [
    return: [&lt;opt&gt; any-value!]
    code [block!]
    &lt;local&gt; last'
][
    last': the ~
    reduce-each ^result' code [
        if error? result' [return null]
        if @void = result' [continue]
        last': result'
    ]
    return unmeta last'
]
</code></pre>
<p>Here you see ATTEMPT running a REDUCE-EACH, but asking for the ^META of each expression.  Asking for the result in meta form suppresses the automatic promotion of a definitional error (isotopic) to a generic failure.  (Re-read the <a href="https://forum.rebol.info/t/fail-vs-return-fail-the-new-age-of-definitional-failures/1852">definitional failure post</a> for a refresher.)</p>
<p>The meta of the isotopic error was received as a plain ERROR!.  And it handles it by returning null.  A void state is handled by continuing--leaving the cumulative result as-is.</p>
<p><em>(<a href="https://forum.rebol.info/t/q-should-be-the-meta-of-void-a-no/1915">I've explained why the meta state for void is weird.</a>  For the sake of argument, let's say it doesn't change under the new rules.)</em></p>
<h2>The BAD! Touch</h2>
<p>I've <a href="https://forum.rebol.info/t/should-everything-have-an-isotopic-form/1889/7">enumerated the reasons</a> why having isotopes generate a ^META which is actually a "BAD! ERROR!" has several advantages.  Wrapping up meta in BAD! makes it a better generalized inverse evaluator (UNEVAL) as well as making all the meta states truthy.</p>
<p><strong>But I'm displeased with the impact this has here.</strong></p>
<pre><code>    last': the ~
    reduce-each ^result' code [
        all [
            bad? result'
            error? unbad result'
        ] then [
            return null
        ]
        if @void = result' [continue]
        last': result'
    ]
    return unmeta last'
</code></pre>
<p>Obviously the naming is... bad.  But I don't like not being able to ask it in a single step, as I could before.  It makes it tempting to introduce constructs like BAD-ERROR?</p>
<pre><code>    last': the ~
    reduce-each ^result' code [
        if bad-error? result' [return null]
        if @void = result' [continue]
        last': result'
    ]
    return unmeta last'
</code></pre>
<h2>Can We Avoid Making BAD-XXX? or QUOTED-XXX? Tests</h2>
<p>One strategy could be if there was some kind of arity-2 BAD test, like:</p>
<pre><code>&gt;&gt; badly? integer! (first [~10~])
== #[true]
</code></pre>
<p>This would avoid having to fill the global namespace with a bunch of things like BAD-INTEGER?</p>
<p>You might get the idea that a TYPE OF could encode this, like:</p>
<pre><code>'~integer!~ = type of (first [~10~])
</code></pre>
<p>But that's not a BAD! DATATYPE! you're getting on the left.  It's a BAD! WORD!, and we don't have any kind of WORD!-to-DATATYPE! equivalence (there are reasons for this, beyond the scope of this thread).</p>
<p>Maybe there's a dialect of containment of some kind (?) like:</p>
<pre><code> match [bad!.integer!] (first [~10~])
</code></pre>
<p>Given some recent suggestions, it might be possible to say something like:</p>
<pre><code>if integer? try unbad (first [~10~])
</code></pre>
<p>The concept being that if it wasn't wrapped up like ~10~, then you'd get the original value out of the TRY instead of a type error.  But then this would be conflated if your original input had been an integer.  It would work for the error case since things that aren't bad are quoted, but it doesn't feel good.</p>
<h2>It Seems We Should Have a Way Of Asking This...</h2>
<p>I look at the ^META code where it doesn't have the bad wrapper on it, and I think "that's so much cleaner".  When you multiply it across all the other places that want to process meta arguments, it just feels wrong to throw in all the extra complexity.</p>
<p>Yet it feels like something of a failure that we don't have an easy way of asking if a value is a datatype wrapped in tildes or not.  It's a weakness that exists in our ability to ask questions about quoted types as well.</p>
<p>Ultimately, is it the best solution to backpedal on the QUOTE/META unification and accept different tracks?</p>
<ul>
<li>
<p><strong>META &amp; UNMETA</strong> - promotes isotopes to undecorated form, NULL &lt;=&gt; NULL, promotes non-isotopes to one level quoted higher than they were.  Because it can generate blanks and logic false, NULL is <strong>not</strong> the only falsey result you can receive from a META operation.</p>
</li>
<li>
<p><strong>QUOTE &amp; UNQUOTE</strong> - promotes isotopes to their ~bad~ value forms, NULL &lt;=&gt; single apostrophe ('), quotes everything else.  Acts as a proxy for "UNEVAL/EVAL" of single values.</p>
</li>
</ul>
<p>Then the question remains about what construct something like FOR-BOTH should use.  It wants to act like QUOTE and UNQUOTE except with NULL and VOID passthrough.</p>
<p>Under these rules, it's really a special "don't quote quite everything" version of QUOTE so maybe less is more, and just give it an asterisk... to say "quote but with some kind of twist".</p>
<pre><code>for-both: lambda ['var blk1 blk2 body] [
    unquote* all [
        quote* for-each (var) blk1 body
        quote* for-each (var) blk2 body
    ]
]
</code></pre>
<p>I can't think of what this could be as a refinement.  QUOTE/PASSTHRU-NULL-AND-VOID?  QUOTE/WITH-HOLES-IN-IT?  QUOTE/LEAKY?  QUOTE/USUALLY?</p>
<p>Not sure, but I really feel like these should be true by default:</p>
<pre><code>&gt;&gt; quote null
== '

&gt;&gt; quote void
** Error: VOID has no quoted form, use META (or QUOTE* if you want to passthru)
</code></pre>
<p>Anyway, this is just the same thing from a week ago running around, and I can't make progress until I pin it down!  I'll sleep on it a bit.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/asking-questions-about-wrapped-things-quoted-bad/1916">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/asking-questions-about-wrapped-things-quoted-bad/1916</link>
          <pubDate>Mon, 15 Aug 2022 18:22:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1916</guid>
          <source url="https://forum.rebol.info/t/asking-questions-about-wrapped-things-quoted-bad/1916.rss">Asking Questions About &quot;Wrapped&quot; Things (QUOTED!, BAD!)</source>
        </item>
        <item>
          <title>Q: Should ~ Be The Unevaluated Form of VOID ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p><em>Void is an elusive concept.  Reasoning about it is difficult.  But it's one of the things that makes the evaluator special, and there are tons of creative applications.  So it's worth the effort.</em></p>
<p>Tonight the thought crossed my mind (certainly not for the first time) that in the generalized isotope world, we might say that ~ is the isotopic form of void:</p>
<pre><code>&gt;&gt; ^(comment "Hi")
== ~

&gt;&gt; 1 + 2 ~
== 3

&gt;&gt; x: ~
; void

&gt;&gt; x
** Error: X is void (a.k.a. the variable is not set)

&gt;&gt; unset? 'x  ; asks "is the variable unset" (there is no UNSET!) type
== #[true]
</code></pre>
<p>This has the somewhat questionable property that the traditional GET/ANY of such a variable would be invisible rather than raise an alarm:</p>
<pre><code>&gt;&gt; var: ~
; void 

&gt;&gt; compose [&lt;a&gt; (get/any 'var) &lt;b&gt;]
== [&lt;a&gt; &lt;b&gt;]
</code></pre>
<p>This still makes me uneasy, because it doesn't feel "ornery" enough.  You have a variable that may have potentially never been set, and are being very quiet about its usage.  I'd prefer people purposefully store NULL in their variables, and then use MAYBE on the NULL to make a VOID.  That's cleaner and more intentional.</p>
<p>But Rebol2/Red/R3-Alpha would say this is not a problem, all of them give this answer:</p>
<pre><code>redbol&gt;&gt; unset 'var

redbol&gt;&gt; compose [&lt;a&gt; (get/any 'var) &lt;b&gt;]
== [&lt;a&gt; &lt;b&gt;]
</code></pre>
<p><em>(Of course, in their world, #[unset] could legally be put in blocks...so they're missing a possibility here.  Ren-C's situation isn't as bad, but still bothers me.)</em></p>
<p>Someone might say I'm being too uptight, and this is fine.</p>
<h2>But... There's Other Implications</h2>
<p>Consider another case:</p>
<pre><code>&gt;&gt; all [&lt;a&gt; &lt;b&gt; if false [&lt;c&gt;]]
== &lt;b&gt;  ; this is today's behavior with void IF FALSE, and considered correct

&gt;&gt; all [&lt;a&gt; &lt;b&gt; x: if false [&lt;c&gt;]]
== &lt;b&gt;  ; today this is different, X becomes unset ("none" isotope) and error

&gt;&gt; x
** Error: X is void (a.k.a. the variable is not set)
</code></pre>
<p>You might ask why the following should be an error, if it wouldn't be an error if the assignment is inside the ALL:</p>
<pre><code>&gt;&gt; x: if false [&lt;c&gt;]
&gt;&gt; all [&lt;a&gt; &lt;b&gt; x]
** Error: X is void (a.k.a. the variable is not set)
</code></pre>
<p>Also: the evaluator mechanics become more inefficient if you're expected to preserve invisibility across an assignment.  You'll kind of have to take my word on that, but it's happier if we don't do this:</p>
<pre><code>&gt;&gt; 1 + 2 [a b c]: call-void-multireturn arg1 arg2
== 3
</code></pre>
<p>This means that the cell holding the 3 is not available for scratch use by things like the SET-WORD! or multi-return.</p>
<p>But beyond the mechanics, something about the assignment makes me feel like there's kind of a "wall" there.  I don't know if my feeling is justified, but it does seem like it might be justified when I say you cannot assign voids to variables.</p>
<h2>You'll Still Need A "Nothing" Isotope</h2>
<p>When ~ was a "BAD-WORD! with no name", I called its isotopic form "none".  If ~ was the meta of void, there really isn't any such thing as a "~ isotope".  You can never make one, because it needs to vaporize.</p>
<p>So in the first cut of generic isotopes, I said ~ was the isotopic form of BLANK! (as opposed to ~_~, which looks pretty bad).  And it became the new none...since no more BAD-WORD! meant a BAD! WORD! had to follow all the rules of words (no null spellings).</p>
<p>You can re-read my <strong><a href="https://forum.rebol.info/t/why-isnt-print-invisible-void/1466/4">explanation of why void is a bad return value for things like PRINT or HELP.</a></strong>  If you want to communicate to the console that it not print anything, then you need to do that communication through some kind of non-void thing, otherwise that signal is too slippery.</p>
<p>So the "none" concept of a ~ isotope felt like a good pick.  It's the ornery contents of an unset variable, it has no string label or otherwise that's being suppressed when it's not shown...so it feels like a natural for the purpose.</p>
<h2>Could We Pick A New UNSET?</h2>
<p>If ~ were retaken for the specific purpose of representing a void isotope, we'd need some other answer for what an unset variable looked like.  I've mentioned that I'm pretty attached to <strong><code>~</code></strong> for how clean it looks, letting you see the things you've set and haven't:</p>
<pre><code>&gt;&gt; f: make frame! :append

&gt;&gt; f.dup: 2
&gt;&gt; f.value: "a string"

&gt;&gt; f
== make frame! [
    series: ~
    value: "a string"
    part: ~
    dup: 2
    line: ~
]
</code></pre>
<p>If ~ represented voids and we had to change these to a new representation for blank isotopes, that would look significantly crappier:</p>
<pre><code>&gt;&gt; f
== make frame! [
    series: ~_~
    value: "a string"
    part: ~_~
    dup: 2
    line: ~_~
]
</code></pre>
<p>We could go back to a full word:</p>
<pre><code>&gt;&gt; f
== make frame! [
    series: ~unset~
    value: "a string"
    part: ~unset~
    dup: 2
    line: ~unset~
]
</code></pre>
<p>But it's not just in these printouts, it's also in source.  Being able to simply type <strong><code>(x: ~)</code></strong> to unset a variable and have that be the right way to do it...in an object field or just in code, is just too good.</p>
<p>This makes me feel pretty attached to the idea that ~ is the contents of an unset variable, which is not displayed by the terminal, and which is ornery to things like ANY or ALL, and it's called "NONE".</p>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/q-should-be-the-unevaluated-form-of-void/1915">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/q-should-be-the-unevaluated-form-of-void/1915</link>
          <pubDate>Mon, 15 Aug 2022 12:15:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1915</guid>
          <source url="https://forum.rebol.info/t/q-should-be-the-unevaluated-form-of-void/1915.rss">Q: Should ~ Be The Unevaluated Form of VOID ?</source>
        </item>
        <item>
          <title>Extending Contexts (OBJECT!, MODULE!, etc)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>In R3-Alpha, it is possible to append key/value pairs to objects via a block:</p>
<pre><code>&gt;&gt; obj: make object! [a: 10]
== make object! [
   a: 10
]

&gt;&gt; append obj [b: 20 c: 30]
== make object! [
    a: 10
    b: 20
    c: 30
]
</code></pre>
<p>You can't do that in Rebol2, and Red did not carry it forward.</p>
<p><strong>But in Ren-C, isotopes are not allowed in blocks.</strong>  It's more powerful if there is an operation which extends the object via a block which gets evaluated... much as the block in MAKE OBJECT! is evaluated.</p>
<p>As a general rule, APPEND should certainly not be REDUCE-ing block arguments.  So some other operation is needed</p>
<p>Red has an EXTEND operation, but it is "reserved for future use":</p>
<pre><code>USAGE:
     EXTEND obj spec

DESCRIPTION: 
     Extend an object or map value with list of key and value pairs. 
     EXTEND is a native! value.

ARGUMENTS:
     obj          [object! map!] 
     spec         [block! hash! map!] 

REFINEMENTS:
     /case        =&gt; Use case-sensitive comparison.
</code></pre>
<p>Given that it's not implemented, we don't know if that spec block is intended to be evaluated or not.  Also, we'd assume EXTEND would create a new object (since their objects don't expand).</p>
<p>Anyway, APPEND to an OBJECT! is something that probably doesn't make sense.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/extending-contexts-object-module-etc/1913">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/extending-contexts-object-module-etc/1913</link>
          <pubDate>Tue, 09 Aug 2022 22:00:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1913</guid>
          <source url="https://forum.rebol.info/t/extending-contexts-object-module-etc/1913.rss">Extending Contexts (OBJECT!, MODULE!, etc)</source>
        </item>
        <item>
          <title>Ideas About a More General Meaning for TRY</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>TRY was changed from a "blank-in, null-out" meaning to use definitional errors.  This allowed NULL to be both the input and the output...without risking inadvertently trapping errors from arbitrary depths.  You'll really be intercepting the error emitted by the function just called:</p>
<pre><code>&gt;&gt; first null
** Error: FIRST on NULL requires use of TRY

&gt;&gt; try first null
; null
</code></pre>
<p>I mentioned something, which was that a "You need a TRY" ERROR! was actually able to carry a payload, saying what the TRY'd outcome value should be.  <em>(The only rule would be that a function emitting such an error should not have any side effects if it emits one of these errors.)</em></p>
<p>If we embrace this, it could really open the doors to what TRY means.  Various constructs could offer meanings for what the TRY actually does:</p>
<pre><code>&gt;&gt; unquote first ['abc]
== abc

&gt;&gt; unquote first [def]
** Error: Can't Unquote Plain WORD!, use TRY if Intentional

&gt;&gt; try unquote first [def]
== def
</code></pre>
<p>I'm sort of leaning to believing that this more general meaning of TRY may be much more interesting than the "null propagating" sense.  There's kind of an explosion of potential for the "couldn't do what you asked me to do, but if that's what you meant..." outcomes.</p>
<p>At one point I suggested it would be nice to be able to have a COLLECT that didn't actually KEEP anything return NULL, so it could be ELSE-reactive.  That meant if you really wanted an empty block, you'd have to do something like <strong><code>any [collect [...], copy []]</code></strong> which was ugly.  But the error could hold a freshly-copied block to be the result of a TRY:</p>
<pre><code>&gt;&gt; collect [keep if false [&lt;not kept&gt;]]
** Error: COLLECT didn't KEEP anything, use TRY if intended

&gt;&gt; try collect [keep if false [&lt;not kept&gt;]]
== []
</code></pre>
<p>There are various technical reasons why ELSE can't be reactive to TRY-style errors.  One fairly important one would be that if you used ELSE with a branching construct, it wouldn't be able to tell the difference between a branch that had a TRY-error and no branch taken:</p>
<pre><code>&gt;&gt; case [true [unquote first [def]]] else [print "Took branch, runs due to UNQUOTE"]
Took branch, runs due to UNQUOTE  ; this would be bad
</code></pre>
<p>But... maybe the trick could be that if you pass ELSE a function that takes an argument, it assumes that means you handle TRY-style errors?  (Because otherwise it could only be void/null... why take an arg?)</p>
<pre><code>&gt;&gt; (unquote first [def]) else arg -&gt; [print ["TRY error" arg]]
TRY error def
</code></pre>
<p>It's a weird thought.  Anyway, just wanted to write up the TRY concept...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/ideas-about-a-more-general-meaning-for-try/1912">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/ideas-about-a-more-general-meaning-for-try/1912</link>
          <pubDate>Tue, 09 Aug 2022 13:28:03 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1912</guid>
          <source url="https://forum.rebol.info/t/ideas-about-a-more-general-meaning-for-try/1912.rss">Ideas About a More General Meaning for TRY</source>
        </item>
        <item>
          <title>&quot;I&#39;m not BAD!...I&#39;m just MOLD-ed that way...&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>I'm tinkering with an implementation of <a href="https://forum.rebol.info/t/should-everything-have-an-isotopic-form/1889/5">fully generic isotopes</a>.  The idea is that all types have an isotopic form, and routines can choose to react to this isotopic form giving it special meaning.</p>
<p>This means the tilde markings which used to designate a BAD-WORD! would be ways of making any value isotopic:</p>
<pre><code>&gt;&gt; ~foo~
== foo  ; isotope

&gt;&gt; ~[d e]~
== [d e]  ; isotope

&gt;&gt; ~1020~
== 1020  ; isotope

&gt;&gt; ~#[datatype word!]~
== #[datatype word!]  ; isotope
</code></pre>
<p>The notation is not an isotope itself, it's just used to produce them.  And if you're looking in an object and see it molds out fields that are these and non-quoted, that implies that the field itself actually holds an isotope.</p>
<pre><code>&gt;&gt; obj: make object! [x: spread [d e], y: ~[d e]~, z: '~[d e]~]
== make object! [
    x: ~[d e]~
    y: ~[d e]~
    z: '~[d e]~
]

&gt;&gt; obj.x
** Error: obj.x is a BLOCK! isotope, use ^META to access

&gt;&gt; obj.y
** Error: obj.y is a BLOCK! isotope, use ^META to access

&gt;&gt; obj.z
== ~[d e]~
</code></pre>
<p>So you can see how the notation works with the generic form, and can be quoted itself.</p>
<h2>I Kind Of Want To Curtail Use Of These In Source...</h2>
<p>The original thought about BAD-WORD! was that their ugly notation was supposed to be used to draw attention to them.  So like in the object molding above, you'd be able to see where the isotopes were and it would guide your eyes to the problem.</p>
<p><em>And in fact, I'm not even 100% sure that we want to support storing isotopes in variables unless we absolutely have to.</em>  Perhaps isotopic blocks would generate errors if you tried--and it would force you to use a ^META operation to persist it.  But a representation that evaluates to them is needed for mechanical reasons either way.</p>
<p>Nevertheless, you <em>could</em> use them to do things like splicing literal blocks:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c [d e]]

&gt;&gt; append [a b c] ~[d e]~
== [a b c d e]
</code></pre>
<p>It would actually be an efficient way to do it, but I feel like it might numb people to the squiggles...which are intended to draw attention to cases where the isotopes leaked through an operation and shouldn't have.  So best practices would suggest using operators instead</p>
<pre><code>&gt;&gt; append [a b c] spread [d e]
== [a b c d e]
</code></pre>
<h2>But The ~XXX~ Forms Need A Name... Is It BAD! ?</h2>
<p>I'd called ~xxx~ a BAD-WORD!.  Now that the tildes are a generic container kind of like QUOTED!, that would default to just being... BAD!</p>
<pre><code>&gt;&gt; type of fourth [a b c ~[d e]~]
== #[datatype! bad!]
</code></pre>
<p>So there's going to be a whole naming situation for operations to get the contained item out, and what to call this container.</p>
<p><em>(If it's so BAD, does it need to be... REFORMed?  <img src="https://forum.rebol.info/images/emoji/twitter/stuck_out_tongue.png?v=9" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"> )</em></p>
<p>I don't know how to fit this into the isotope naming scheme...it's a thing that generates isotopes when it evaluates.  The analogy breaks down if you try to call it a NUCLEUS or something odd like that.</p>
<p>Calling the ~xxx~ forms BAD! does have the advantage of being able to combine that and say ~[d e]~ is a "bad block" and ~1020~ is a "bad integer", but... you'll see these in well-formed programs.  It makes it sound like something is <em>corrupt</em>, when the real intent is different.</p>
<p>It could be called QUASI! which could related it to QUOTED!.  <em>"~[d e]~ is a quasi-block"</em></p>
<p>Bear in mind they can be quoted, so <code>'~[d e]~</code> would then be a "quoted quasi-block".  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>In some sense, [d e] and ~[d e]~ and '[d e] and ''[d e] could all be thought of as "isotopes" of blocks...in addition to what we call the "isotope" form (which has no representation, because it's something you can only measure by turning it into another form).</p>
<p>So we might call ~[d e]~ a "block isotope", and then give some other name to the invisible status that it produces...?</p>
<pre><code>&gt;&gt; ~[d e]~  ; call this a block isotope?
== [d e]  ; then this could be... a... ghost block?
</code></pre>
<p>But overall my leaning is that I like calling the ephemeral form "isotope", because I think that captures its weird invisible/reactivity/decaying character.</p>
<h2>The Pejorative "BAD!" May Seem Harsh, But May Be Good?</h2>
<p>If the name can scare people out of trying to use these too much at source level, that's not the worst outcome.</p>
<p>But then there still have to be ways of getting the contents out.  QUOTED! has UNQUOTE and NOQUOTE to take off quoting layers, and QUOTE to add them on.</p>
<p>Right now I've got MAKE BAD! to produce them:</p>
<pre><code>&gt;&gt; make bad! 1020
== ~1020~

&gt;&gt; make bad! [d e]
== ~[d e]~
</code></pre>
<p>If we called them something like TOXIC! then there could be detox and toxify.  <img src="https://forum.rebol.info/images/emoji/twitter/radioactive.png?v=9" title=":radioactive:" class="emoji" alt=":radioactive:"></p>
<p><strong>There's plenty to be involved with working out the mechanics and not worrying about the names, but wanted to put the naming issue out to be mulled over.</strong></p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/im-not-bad-im-just-mold-ed-that-way/1911">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/im-not-bad-im-just-mold-ed-that-way/1911</link>
          <pubDate>Fri, 05 Aug 2022 09:33:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1911</guid>
          <source url="https://forum.rebol.info/t/im-not-bad-im-just-mold-ed-that-way/1911.rss">&quot;I&#39;m not BAD!...I&#39;m just MOLD-ed that way...&quot;</source>
        </item>
        <item>
          <title>Big Alien Proposal :flying_saucer: &quot;/REFINEMENTS&quot; Run Functions</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <blockquote>
<p><strong>UPDATE</strong>...This was tried out, and while interesting things were learned it ultimately didn't "feel right" <em>(in particular the competition of <code>/slash</code> for refinement and <code>/slash:</code> for function definition was more annoying than anticipated, and SET-PATH!s introduce a lot of complexity in places it wasn't needed.)</em>  See further down the thread.  It's informing new designs being tried out.</p>
</blockquote>
<hr>
<p>So far, <strong><code>/leading</code></strong> <strong><code>/slash</code></strong> <strong><code>/notation</code></strong> has just been evaluator inert, lining up with Rebol2 and Red and R3-Alpha:</p>
<pre><code>redbol&gt;&gt; /foo
== /foo
</code></pre>
<p>That inertness doesn't seem to get leveraged much.  And in Ren-C it's a particularly weak choice, since the evaluator has generic quoting to get you the literal result:</p>
<pre><code>ren-c&gt;&gt; '/foo
== /foo
</code></pre>
<p>Also, leading slash is an actual PATH!...encompassing arbitrary patterns like <strong><code>/lib.append/dup/part</code></strong>.  So I've always been wondering if there was some interesting evaluator behavior for it, like...</p>
<ul>
<li>
<p>...asking to pick from "global scope": if your function has an argument called ALL then /ALL might get you the definition outside your function?  (Something like <strong><code>::foo</code></strong> in C++)</p>
</li>
<li>
<p>...maybe a shorthand for <strong><code>self/foo</code></strong> for picking members out of objects inside of methods?</p>
</li>
</ul>
<p>Yet nothing has ever really stuck.  But <a class="mention" href="/u/ingohohmann">@IngoHohmann</a> pointed out that there's a basic thing that leading slashes might do for us which may have been overlooked...</p>
<p>...<em>simply running functions</em>.</p>
<h2>"But WORD!s Run Functions, Why Should /FOO Do That?"</h2>
<p>There are many reasons, but the biggest one is...</p>
<hr>
<p><strong>I feel pretty much 100% certain it is time that we switched to a world <em>where not all WORD!s holding ACTION!s will run them.</em></strong></p>
<hr>
<p>It's too cumbersome when writing generic code to worry that a value you got "from somewhere" and put into a SET-WORD! has to be handled with special operators:</p>
<pre><code> &gt;&gt; var: select obj 'item
 &gt;&gt; if integer? var [print "INT"]
 Muhaha the next thing at your callsite was [print "INT"]  ; eek, VAR was action

 &gt;&gt; var: first block
 &gt;&gt; if integer? var [print "INT"]
 HAH! Did you think blocks were safe?  Not at all: [print "INT"]  ; in blocks too!
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/man_facepalming.png?v=9" title=":man_facepalming:" class="emoji only-emoji" alt=":man_facepalming:"></p>
<p>Whether you think of it in terms of "security"--or simply bugs and chaos--this <em>persistent tax</em> on Redbol code authors has lacked a palatable solution.  Putting a GET-XXX! on every access is ugly, and easy to forget.  What we've ended up with is a mishmash...where people are constantly forced to choose between deciding if the brokenness is likely enough to cause a problem that it's worth it to make the code ugly.</p>
<p>(When code ages, it's like it develops some sort of pox--as leading colons are added on an ad-hoc basis, then no one really knows if they're safe to remove.)</p>
<p><strong>I propose that only specially marked assignments would <em>automatically</em> run a function through a word reference, requiring a ^META access to get the action value literally.</strong></p>
<pre><code>&gt;&gt; /foo: func [x] [print ["X is" x]]

&gt;&gt; foo 10
X is 10

&gt;&gt; ^foo
== #[action! {foo} [x]]
</code></pre>
<p><strong>If a function is assigned through a plain SET-WORD!, then that would be inert by default...but able to take advantage of this new leading-slash execution.</strong></p>
<pre><code>&gt;&gt; foo: func [x] [print ["X is" x]]

&gt;&gt; foo
== #[action! {foo} [x]]

&gt;&gt; /foo 10
X is 10
</code></pre>
<h2>Compliance Isn't Actually That Ugly!</h2>
<p>If you look at the definition of an object, then annotating the member functions isn't really so bad:</p>
<pre><code>obj: make object! [
    data: 1
    /accessor: does [return data + 1]
]
</code></pre>
<p>This also gives us some extra ammo: <strong>it can explain why we would use OBJ/ACCESSOR to invoke the function, and why OBJ.ACCESSOR can act as an error</strong>.</p>
<p>That can clean up examples like this:</p>
<pre><code> &gt;&gt; error: trap [...]
 &gt;&gt; if integer? error.arg1 [print "INT"]
 You forgot to worry about TUPLE! too! [print "INT"]  ; aaaargh...
</code></pre>
<p>All we have to do is say that TUPLE! accesses like that can't run methods.  It would have to be <strong><code>error/arg1</code></strong> to run it... which would also confirm that it was actually defined as a method.  (Otherwise you'd run it with <strong><code>/error.arg1</code></strong> if it was just a random non-method field that happened to be a function.)</p>
<p>This would be a systemic solution to historical annoyances.</p>
<h2>It Can Be A Nice Dialecting Pattern</h2>
<p><strong>It's useful in dialects where plain WORD! references are taken for another meaning.</strong>  For instance, UPARSE by default assumes a word means a combinator, so if you want to run a function that uses parse rules to gather its arguments you need something else:</p>
<pre><code>&gt;&gt; parse [1] [/negate integer!]
== -1

&gt;&gt; parse [1 2] [/add integer! integer!]
== 3
</code></pre>
<p>Initially I tried this with terminal slashes, as <strong><code>negate/</code></strong> and <strong><code>add/</code></strong>, but that doesn't look as good (and separates the functions from their arguments).</p>
<h2>What Do We Lose?</h2>
<p>Because I was trying to think of a meaningful evaluator behavior for leading-slash values, I didn't do much with them.  But eventually I decided to use them in New Apply:</p>
<p><a href="https://forum.rebol.info/t/apply-ii-the-revenge/1834" class="inline-onebox">APPLY II: The Revenge!</a></p>
<p>They're nice because they break up the space:</p>
<pre><code>&gt;&gt; apply :append [[a b c] [d e] /dup 2]
== [a b c [d e] [d e]]
</code></pre>
<p>But SET-WORD! is reasonable at this, and commas can make it more visually separate if needed:</p>
<pre><code>&gt;&gt; apply :append [[a b c] [d e] dup: 2]
== [a b c [d e] [d e]]

&gt;&gt; apply :append [[a b c] [d e], dup: 2]
== [a b c [d e] [d e]]
</code></pre>
<p>Of course whatever we put here is being overloaded.  If you want a SET-WORD! for assignment purposes, you'd have to put it in a group:</p>
<pre><code>&gt;&gt; apply :append [(abc: [a b c]) [d e], dup: 2]
== [a b c [d e] [d e]]

&gt;&gt; abc
== [a b c]
</code></pre>
<p>So we could think of this similarly.  If you wanted to use a refinement-style path here, you just do it in a group:</p>
<pre><code>&gt;&gt; apply :append [(/reverse [a b c]) [d e], /dup 2]
== [c b a [d e] [d e]]
</code></pre>
<p><strong>APPLY is a dialect, and there are always going to be some tradeoffs made.</strong>   There's only so many parts.</p>
<p><strong>It's probably best to leave APPLY as it is.</strong>  I don't think we're going to be in the midst of some epidemic where suddenly every function invocation is done through a leading slash and it's going to be  contentious.  There will also be ways of running a function through REEVAL or maybe a dedicated RUN function that won't use the slash...</p>
<p>So nothing needs to be lost, really.</p>
<h2>The Big Win is that the <em>Obvious</em> Code is the <em>Correct</em> Code</h2>
<p>I've done some tentative implementation on all this, and all together, it seems pretty solid</p>
<p>Really all you're doing is paying the cost of an extra (easy-to-type) character to say that a word is intended to execute a function without needing to explicitly be told to.</p>
<p>There will be ways to subvert it, as of course you could do this:</p>
<pre><code>&gt;&gt; /func: enfix lambda [left [set-word!] spec body] [
       do compose [/(as word! left): lib/func (spec) (body)]
   ]

&gt;&gt; cheat: func [] [print "Breakin the law, breakin the law..."]

&gt;&gt; cheat
Breakin the law, breakin the law...
</code></pre>
<p>But we wouldn't make you do it that laboriously, if you're making something where words need to be associated with functions that run automatically.  And Redbol would do it through some evaluator parameterization as opposed to a mechanism like that.</p>
<p>However, the general expectation would be that most people would embrace the slash, as a useful piece of information...that makes everything work more coherently.</p>
            <p><small>12 posts - 5 participants</small></p>
            <p><a href="https://forum.rebol.info/t/big-alien-proposal-refinements-run-functions/1905">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/big-alien-proposal-refinements-run-functions/1905</link>
          <pubDate>Fri, 29 Jul 2022 08:34:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1905</guid>
          <source url="https://forum.rebol.info/t/big-alien-proposal-refinements-run-functions/1905.rss">Big Alien Proposal :flying_saucer: &quot;/REFINEMENTS&quot; Run Functions</source>
        </item>
        <item>
          <title>SQLite&#39;s &quot;sqlean&quot;: C code for SQLite Extension Stuff</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>SQLite is a pretty carefully put together piece of C code.  Seems they've factored out some bits of interesting functions in C to a common library:</p>
<aside class="onebox githubfolder">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="16" height="16">
      <a href="https://github.com/nalgeon/sqlean" target="_blank" rel="noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <img src="https://repository-images.githubusercontent.com/343191804/5e00d0fc-d757-440b-a837-b2798de8e113" class="thumbnail onebox-full-image" width="60" height="60">

<h3><a href="https://github.com/nalgeon/sqlean" target="_blank" rel="noopener">GitHub - nalgeon/sqlean: The ultimate set of SQLite extensions</a></h3>


  <p><span class="label1">The ultimate set of SQLite extensions. Contribute to nalgeon/sqlean development by creating an account on GitHub.</span></p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>So there's random stuff like <a href="https://github.com/nalgeon/sqlean/blob/main/src/fuzzy/translit.c">transliteration</a>, for example or fuzzy string matching.  It could be a place to look if that kind of need comes up...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/sqlites-sqlean-c-code-for-sqlite-extension-stuff/1904">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/sqlites-sqlean-c-code-for-sqlite-extension-stuff/1904</link>
          <pubDate>Fri, 29 Jul 2022 05:09:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1904</guid>
          <source url="https://forum.rebol.info/t/sqlites-sqlean-c-code-for-sqlite-extension-stuff/1904.rss">SQLite&#39;s &quot;sqlean&quot;: C code for SQLite Extension Stuff</source>
        </item>
        <item>
          <title>Weird Idea: LIB/APPEND Runs, but LIB.APPEND Doesn&#39;t?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Historical Redbol did not have generic TUPLE!.  So that meant it used paths for everything...whether you were specifying a refinement to a function, or doing a member selection out of an object, or coordinate out of a pair, or...whatever.</p>
<p>So far what Ren-C has done is to shift it such that tuples are for member selection, and pathing is for refinements only.</p>
<p>An additional twist is that a terminal-slash in a path (e.g. the last element is a BLANK!) means "run the action".  This is especially helpful when wanting to run a non-isotopic action in the new "activated actions" model:</p>
<pre><code>&gt;&gt; block: reduce [^print]

&gt;&gt; block.1
== #[action! {print} [line]]

&gt;&gt; block.1/ "The terminal slash comes in handy!"
The terminal slash comes in handy!
</code></pre>
<p>So if you have a non-isotopic action in your hand, the slash can run it.</p>
<p>It can also be helpful in a commentary sense--if you have some complex code and want to point out which bits are supposed to actually be actions getting invoked.</p>
<h2>Terminal Slashes Could Provide Safety...</h2>
<p>With the above, the pattern you would use to say you were going to run something like APPEND/DUP out of LIB would be this:</p>
<pre><code>&gt;&gt; lib.append/dup [a b c] [d e] 2
== [a b c [d e] [d e]]
</code></pre>
<p>But this means that you're on the hook for simple tuple references running, which you may not have expected:</p>
<pre><code>&gt;&gt; if integer? obj.something [print "What if SOMETHING is an ACTION! isotope?"]
Boo!
** Error: Some error coming from OBJ.SOMETHING running
</code></pre>
<p>One way of stopping this would be to say that if you were going to call a function that was a member of an object, you'd have to use a terminal slash, otherwise you'd get an error.</p>
<pre><code>&gt;&gt; if integer? obj.something [print "Clearer error if it's an ACTION! isotope"]
** Error: OBJ.SOMETHING is an ACTION! isotope, use OBJ.SOMETHING/ if intended
</code></pre>
<p>That would make field selection on the whole feel "safer".  But at the cost of looking at a lot of terminal slashes.</p>
<h2>More Succinct: Allow PATH!s to Pick The Action, Too</h2>
<p>If something like <strong>lib.append/dup</strong> is clearly an action (due to the use of refinements) it wouldn't need the terminal slash, like <strong>lib.append/dup/</strong>.  You already know an action is being run.</p>
<p>So what if you said <strong>lib/append</strong> instead of <strong>lib.append/</strong> ?</p>
<p>Of course, under such a rule, <strong>lib/append</strong> becomes conflated with a situation where LIB is a function and you're applying the <strong>/append</strong> refinement.  This does break away from a rule like "slashes always mean refinements".</p>
<p>That <em>kind of</em> sucks...BUT...it's still <em>far</em> less conflated than it was before.  Remember, historical Redbol used slashes for <em>EVERYTHING</em>.</p>
<p>The new rule could be "slashes always mean <em>from here on out, what we're talking about is function invocation"</em>.  So it's either picking a function to run, or narrowing it down by means of a refinement.</p>
<p>The advantage here system-wide would be that you could use field selection without worrying about it, as <strong>foo.bar</strong>, meaning "I want that field and I don't want any functions to run".  If there's no slash, there's no invocation.</p>
<p>I almost feel like the weird exception is worth it, because it would save a lot of bulletproofing that would otherwise be required on objects.  But it's also clearly a bit <em>bent</em>.</p>
<h2>The Other Direction: Terminal Dot as Invocation Suppressor</h2>
<p>With GET-WORD! changing its meaning, there's a possibility for saying "this reference is not an invocation", which could apply to WORD!s and to TUPLE!s alike.  That's the terminal dot.</p>
<pre><code>&gt;&gt; x: append.
** Error: APPEND. reference ends in dot but it's an ACTION! isotope
</code></pre>
<p>It has one downside of kind of being close to being a comma.</p>
<p>But the bigger reason I don't like this is just the mental tax that comes into effect.  It's the same as how I didn't like the creeping desire for correctness, meaning people putting colons in front of things in a fairly ad-hoc way.  We'd like the obvious code to just work.</p>
<p>I think the LIB/APPEND compromise may be worthwhile to get this correctness-by-default situation.</p>
<h2>Possible Objection: Value/Function Invariance?</h2>
<p>We might say that forcing you to distinguish at the callsite whether you are calling a function or not, prevents you from taking something that was a plain value previously, and substituting it with a function that calculates that value.</p>
<p>Under this principle, it's a feature that you "don't know" if <strong>obj.something</strong> is an action isotope or not...and making you commit to which it is by saying <strong>obj/something</strong> is bad.</p>
<p>It's kind of a narrow case--since you <em>have</em> to know at the callsite if it's a function that consumes arguments.  So it could only be argued for arity-0 functions.  And if the function doesn't return the same value every time, you're subject to some semantic questions.</p>
<p>I think that the answer here is that "accessor" functions (getter/setter) wouldn't count in this, if they existed.  They would use the tuple syntax but stay "behind the scenes".</p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/weird-idea-lib-append-runs-but-lib-append-doesnt/1902">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/weird-idea-lib-append-runs-but-lib-append-doesnt/1902</link>
          <pubDate>Thu, 28 Jul 2022 02:04:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1902</guid>
          <source url="https://forum.rebol.info/t/weird-idea-lib-append-runs-but-lib-append-doesnt/1902.rss">Weird Idea: LIB/APPEND Runs, but LIB.APPEND Doesn&#39;t?</source>
        </item>
        <item>
          <title>The Pending New Meaning of GET-XXX!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>If you've been following along with things like <a href="https://forum.rebol.info/t/the-long-awaited-death-of-only/1607">The Solution to Block Splicing</a> or <a href="https://forum.rebol.info/t/attack-of-the-activated-actions/1900">Activated Actions</a>, it seems to suggest that GET-WORD! and friends would no longer be necessary.</p>
<ul>
<li>
<p>If you have a non-isotopic value (including an ACTION!), you access it with a plain WORD! and it's fine--<em>the obvious code just works</em>.</p>
</li>
<li>
<p>If you have an isotopic value, you use a META-WORD! and get its non-isotopic form, and work with that.  (It will be inert, so you "won't need" GET-WORD! on it...)</p>
</li>
</ul>
<p><strong>So I'm going through all the non-Redbol code and eliminating the use of GET-WORD!, GET-PATH!, and GET-TUPLE!</strong></p>
<p>It's pleasing to see the improvement.</p>
<h2>But Like I Said, You Can't Wish Away Complexity...</h2>
<p>When you have a case that turns out to be complex, there's a new twist...you get quoted/meta items, not plain items:</p>
<pre><code>&gt;&gt; unsafeobj: make object! [x: 10, /y: func [] [print "Boo!"]]

&gt;&gt; for-each [key ^val] unsafeobj [print ["meta" key "is" mold val]]
meta x is '10
meta y is #[action! []]
</code></pre>
<p>Now you can no longer just test with INTEGER? VAL, because VAL is quoted.</p>
<p>So the new concept I have for <strong><code>:val</code></strong> is that it mean <strong>unmeta val</strong>.  This way you can say:</p>
<pre><code>if integer? :val [print "It was an INTEGER! before the ^META"]
</code></pre>
<h2>Wait, Isn't This The Same Situation As Before?</h2>
<p>You might ask if we've just come full circle, since you have to start using a mark on variables in order to correctly handle situations with active actions.</p>
<p>But you don't get into this situation unless you consciously ask for it... your code is correct by default, and the active actions can't just "sneak up on you".</p>
<p>And it's nice that the values aren't active...you're not risking a function being called without you knowing about it.  Instead you have a QUOTED! value, which has a weird type that will give more obvious errors if you forget to unmeta it.</p>
<h2>It Also Gives A Notation For Splices</h2>
<p>I mentioned we need some way to meta a splice, in such a way that it will evaluate back to a splice again.  The block form gives the answer for this:</p>
<pre><code>&gt;&gt; var: :[d e]
== :[d e]  ; isotope

&gt;&gt; temp: ^var
== :[d e]

&gt;&gt; do compose [var: (temp)]
== :[d e]  ; isotope

&gt;&gt; append [a b c] get/any 'var
== [a b c d e]
</code></pre>
<h2>Parameterized Evaluator Will Be Needed For Redbol</h2>
<p>I'm pretty gung-ho on keeping the Redbol tests running.  So this really lights a fire under the need to start acting on parameterized evaluation.</p>
<p>When the body of a Redbol "FUNC2" is evaluating, it needs to imbue that body with the behavior that the <strong><code>:word</code></strong> just gets the value.</p>
<p>I'm not sure what to do about isotopic actions and Redbol emulation.  :-/  It creates an interoperability issue when mixing code.  The "pure" way of doing it would give Redbol a truly separate context, where all of its LIB definitions were plain ACTION!s...that its evaluator would run from word references.  It's probably better to instead have Redbol only deal with ACTION! isotopes...telling it that they are plain ACTION!s.</p>
<h2>Necessitates A New Name?</h2>
<p>In a way, naming the parts for their behaviors has always been a bit of a bad idea.  Because you're supposed to be able to redefine them to do whatever you want.  (A SET-WORD! doesn't have to set anything, and a GET-WORD! doesn't have to get anything.  So why aren't they COLON-WORD! and WORD-COLON! ?)</p>
<p>And above I talk about Redbol behavior, where they'll act as before.  :-/</p>
<p>If I could, I've said that I'd rather the ^META and :UNMETA operations be noted with up arrows and down arrows, and perhaps be called "UP-WORD!" and "DOWN-WORD!".</p>
<pre><code>&gt;&gt; for-each [key ↑val] unsafeobj [if integer? ↓val [print "Integer found!"]]
Integer found!
</code></pre>
<p>But, the ASCII benefits win out:</p>
<pre><code>&gt;&gt; for-each [key ^val] unsafeobj [if integer? :val [print "Integer found!"]]
Integer found!
</code></pre>
<p>Anyway, the name isn't the most important thing... but just another thing to work through.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-pending-new-meaning-of-get-xxx/1901">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-pending-new-meaning-of-get-xxx/1901</link>
          <pubDate>Wed, 27 Jul 2022 22:06:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1901</guid>
          <source url="https://forum.rebol.info/t/the-pending-new-meaning-of-get-xxx/1901.rss">The Pending New Meaning of GET-XXX!</source>
        </item>
        <item>
          <title>Attack of the Activated Actions</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Here's something seemingly-simple that a newcomer to Redbol might attempt:</p>
<blockquote>
<p>TASK: Write a function TWOSIE? that...</p>
<ul>
<li>returns true if a value is the INTEGER! of 2, or a BLOCK! of length 2</li>
<li>returns false otherwise</li>
</ul>
</blockquote>
<hr>
<pre><code>twosie?: func [x] [          ; Ren-C calls this LAMBDA, due to no RETURN
    to-logic any [
        x = 2                ; will also pick up DECIMAL!, since 2 = 2.0
        all [
            block? x
            2 = length? x    ; length at current position, not total 
        ]
    ]
]
</code></pre>
<hr>
<p>An "experienced" Redbol user would point out what happens when you pass a FUNCTION!.</p>
<pre><code>red&gt;&gt; twosie? :append
*** Script Error: = operator is missing an argument
*** Where: =
*** Stack: twosie? to-logic 
</code></pre>
<p>If <strong>x</strong> turns out to be a FUNCTION!, it is invoked by the references inside the body.  Which can cause unwanted side effects, as well as arbitrarily cryptic errors.</p>
<h2>How Was This Mitigated?</h2>
<p>You <em>could</em> restrict the set of accepted types, and exclude functions.  But if you make it only accept INTEGER! and BLOCK! that undermines the aspect that the function's job is to do testing.</p>
<p>Doing it "right" is annoying, putting colons on every access...possibly omitting some when the value is in a context where the program logic would say it can't be a function at that point.</p>
<pre><code>twosie?: func [x] [
    to-logic any [
        :x = 2
        all [
            block? :x
            2 = length? :x       ; :x is optional, as known to be a BLOCK! here
        ]
    ]
]
</code></pre>
<p>Sometimes, people would minimize the number of GET-WORD!s needed by short-circuiting a test for FUNCTION! first:</p>
<pre><code>twosie?: func [x] [
    if function? :x [return false]
    to-logic any [
        x = 2
        all [
            block? x
            2 = length? x
        ]
    ]
]
</code></pre>
<p>This is fairly unsatisfying as well.  It breaks easily if someone reorganizes the code and doesn't realize the test has to come first, or if there has to be additional handling and skipping all the code that uses the variable isn't the desired semantic.</p>
<p><strong>This situation is a tax on users, who are continuously torn between writing obvious code that is broken... vs. cluttered code that winds up being made more brittle due to the maintenance of the clutter.</strong></p>
<p>It would clearly be ideal if the obvious code was also correct.</p>
<h2>The Nuanced Compromise Of Isotopic ACTION!s</h2>
<p>Something that occurred to me was to ask what would happen if there were two kinds of actions:</p>
<ul>
<li>
<p>ACTION! isotopes, which would run if they were referenced via a WORD! or TUPLE!</p>
</li>
<li>
<p>Plain ACTION!s, which would be inert when accessed by WORD!</p>
</li>
</ul>
<p><strong>An obvious <em>good</em> part of this idea would be that a "normal" argument to a function would never be able to be an isotope (solving the problems outlined above).</strong></p>
<p><strong>An obvious <em>questionable</em> part of this idea is introducing another state to worry about.</strong></p>
<p>I've implemented it--though it is a radical change affecting kind of everything.  :-/  There are certainly a lot of questions raised and details to come up.</p>
<p>Something to realize is that there's a fundamental complexity coming from the fact that Rebol wants WORD! references to execute actions automatically much of the time.  But you still have a lot of places that want to talk about values "as-is".  We cannot "wish away" that complexity...only reshape it.</p>
<p><strong>But I think the ability to have obviously-written code in cases like TWOSIE? tips the balance.</strong>  I don't know that meta-code gets truly any harder to write, it just gets <em>different</em>...while the simple examples work without GET-WORD!s.</p>
<p>I'll use this thread to document differences to know about.</p>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/attack-of-the-activated-actions/1900">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/attack-of-the-activated-actions/1900</link>
          <pubDate>Wed, 27 Jul 2022 05:01:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1900</guid>
          <source url="https://forum.rebol.info/t/attack-of-the-activated-actions/1900.rss">Attack of the Activated Actions</source>
        </item>
        <item>
          <title>Sample Custom Datatype Idea: Sound</title>
          <dc:creator><![CDATA[GiuseppeChillemi]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>As an example, lets build a simple custom structure:</p>
<pre><code>[[internal structures][data1][data2][data3][data4]]
</code></pre>
<p>I want that that <code>head</code> corresponds to <code>data1</code>, and <code>index?</code> returns1 when positioned there.</p>
<p>If you have an internal action called "reposition" and "get-position" belonging to that datatype, Ren-C should look at the block if it carries an additional management object. If it contains "reposition" and "get-position" it should use this custom functions to override the standard ones for the datatype. You code them so that they do not move before data1, and you have a special structure which acts transparently to the standard Ren-C working.</p>
<p>Now lets take:</p>
<pre><code>sound: [[header] size: 5000 modified-by: "HF" sound: #A45ACF...  [tail-data]]
</code></pre>
<p>It is your structure to store a sound.</p>
<p>you want that at set operation using ':' will be written <code>raster-image:</code> content, so that</p>
<pre><code>sound: load %mysong.wav
</code></pre>
<p>You add a custom management object with overwrites the set operation and also all the others regarding <code>pick/length?/poke...</code> and so on, so that your Ren-C script works with the usual syntax, which is internally manage by from you replacement actions, translating everything to the new coordinates and operation system</p>
<p>Obviously, you could have additional action to be available to the developers which do not replace the internal actions but they could be called with syntax like:</p>
<pre><code>do-custom data 'method [parameter parameter]
</code></pre>
<p>or having a special path like <code>sound/#/fourier-trasform</code></p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/sample-custom-datatype-idea-sound/1899">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/sample-custom-datatype-idea-sound/1899</link>
          <pubDate>Sun, 24 Jul 2022 10:23:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1899</guid>
          <source url="https://forum.rebol.info/t/sample-custom-datatype-idea-sound/1899.rss">Sample Custom Datatype Idea: Sound</source>
        </item>
        <item>
          <title>List of Port Verbs</title>
          <dc:creator><![CDATA[GiuseppeChillemi]]></dc:creator>
          <category>Ports</category>
          <description><![CDATA[
            <p>Are the port verbs the same as R3 "standard" or you have modified it?</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/list-of-port-verbs/1907">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/list-of-port-verbs/1907</link>
          <pubDate>Sun, 24 Jul 2022 09:59:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1907</guid>
          <source url="https://forum.rebol.info/t/list-of-port-verbs/1907.rss">List of Port Verbs</source>
        </item>
        <item>
          <title>FRAME! / ACTION! Duality Examined</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>The mechanics behind FRAME! and ACTION! have been mixed up and reshaped over time, to where they are very much tied together.</p>
<p>At times I've wondered if we need both types.  If ACTION!s become inert unless they are isotopic, then that would seem to blur the distinction even more... since FRAME!s have kind of been "inert actions".</p>
<p>So I thought I'd try writing up an explanation of the current state of things.</p>
<h2>First: What's a FRAME! ?</h2>
<p>You can think of a FRAME! as an object which has keys and values for the arguments and locals of a function.  There's a flag on each cell which indicates whether the object member has been "specialized out".  If the flag is set, the slot is presumed to contain the value it will have when the function runs.  Otherwise the object member is presumed to contain the type information for acquiring that parameter.</p>
<p>So when you make an ACTION! like:</p>
<pre><code>foo: func [x [integer!] y [text!] &lt;local&gt; z] [...]
</code></pre>
<p>It's internals are actually a FRAME! (called an "exemplar") that looks <em>something</em> like:</p>
<pre><code>make frame! [
    x: [integer!]  ; unspecialized
    y: [text!]  ; unspecialized
    z: ~   ; specialized
]
</code></pre>
<h2>What's The Difference Between ACTION! and FRAME!, Then?</h2>
<p>Looking at the above: <strong>you wouldn't want to try and DO a FRAME! which has type information in the argument slots</strong>.  When the code for the function runs, it's expected that X be <em>an integer instance</em>...not type information saying an integer is expected!</p>
<p>So when you MAKE FRAME! from an ACTION!, it goes through all the slots and wipes them out to be unset:</p>
<pre><code>&gt;&gt; make frame! :foo
== make frame! [
    x: ~
    y: ~
]  ; ^-- local z is not shown, as it was already specialized to a value
</code></pre>
<p>But it still has to maintain a link to the original information about the parameter types, in order to validate them.  So there's a pointer from each of these "non-exemplar" FRAME!s to the "exemplar" FRAME! with the type information.</p>
<h2>So ACTION!s are FRAME!s w/typesets in slots where args would be?</h2>
<p>Kind of.  I glossed over some details there (there's more information in the parameter description than the type block...you need to know if it's quoted, or if it's a refinement, etc.)</p>
<p>Right now every FRAME! points at an ACTION! instance.  So you can ask <strong>action of frame</strong> and get an answer.  That answer leads you to the thing that the system will use to do type checking on that frame (and you can in theory use it yourself).</p>
<p><strong>It could truthfully be said that you never execute ACTION!s, you only execute FRAME!s.</strong>  But when we say we "execute an action" all we mean is that a new frame is created for it, and then <em>that</em> frame is executed.</p>
<p>One might wonder why something like SPECIALIZE would create an ACTION! instead of just making a FRAME!.  One good reason is that this offers an opportunity to <em>completely erase</em> the specialized variables from the interface.  With the variables erased, the words become available again for use in AUGMENT-ing the composite function.</p>
<h2>So There's Some Info...</h2>
<p>Things are sort of stable with this, but a big thing on the horizon is the possibility that there might be FRAME! instances for evaluators besides actions.  So you could have a FRAME! representing just the evaluation of a BLOCK!.  (Today that's <em>sort of</em> what a VARARGS! is.)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/frame-action-duality-examined/1898">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/frame-action-duality-examined/1898</link>
          <pubDate>Sat, 23 Jul 2022 17:43:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1898</guid>
          <source url="https://forum.rebol.info/t/frame-action-duality-examined/1898.rss">FRAME! / ACTION! Duality Examined</source>
        </item>
  </channel>
</rss>

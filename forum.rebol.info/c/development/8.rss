<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Development - AltRebol</title>
    <link>https://forum.rebol.info/c/development/8</link>
    <description>Topics in the &#39;Development&#39; category Discussion of the development of Rebol itself: language design, implementation and standard library.</description>
    
      <lastBuildDate>Sat, 07 Dec 2024 20:48:23 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/8.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Default Values and MAKE FRAME! - 2024 Edition</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <blockquote>
<p><em><strong>NOTE:</strong> The below summarizes history with some adjustments made for simplification purposes.  See posts in <a href="https://forum.rebol.info/c/archive/61">Archive</a> regarding frames for all the exact detours.</em></p>
</blockquote>
<hr>
<p>Something like this has worked ever since the first FRAME!:</p>
<pre><code>f: make frame! append/
f.series: [a b c]
f.value: 10

&gt;&gt; eval f
== [a b c 10]
</code></pre>
<p>Notice that although APPEND has refinements, you don't have to explicitly go through and set them to NULL.  That was done for you.</p>
<p>That might make you think the result of <strong>(make frame! append/)</strong> looked like this:</p>
<pre><code>&gt;&gt; make frame! append/
== #[frame! [  ; you might think...
    series: ~null~
    value: ~null~
    part: ~null~
    dup: ~null~
    line: ~null~
]]
</code></pre>
<p>e.g. all fields defaulting to null, whether they are refinements or not.</p>
<h2><a name="p-7965-thats-not-what-it-did-here-is-why-1" class="anchor" href="https://forum.rebol.info#p-7965-thats-not-what-it-did-here-is-why-1"></a>That's Not What It Did... Here Is Why</h2>
<p>Even before the full-on unification of ACTION! and FRAME! into one datatype, there was a concept that you could make an action out of a frame.  This meant some state of the frame variables had to represent the idea that an argument was still to be gathered.</p>
<p>The goal was something like this:</p>
<pre><code>f: make frame! append/
f.value: 10
; don't assign f.series, leave it however it was

&gt;&gt; run f [a b c]
== [a b c 10]
</code></pre>
<p>If all the argument slots were eagerly set to <strong><code>~null~</code></strong> then you'd get something like:</p>
<pre><code>&gt;&gt; run f [a b c]
** Error: APPEND doesn't allow ~null~ for its VALUE argument
</code></pre>
<p>So instead, MAKE FRAME! would leave the slots all unset, to indicate they were unspecialized:</p>
<pre><code>&gt;&gt; make frame! append/
== #[frame! [
    series: ~
    value: ~
    part: ~
    dup: ~
    line: ~
]]
</code></pre>
<p>If it got to the point of execution, optional parameters (e.g. refinements) would be turned from NOTHING into NULL implicitly.  But if you didn't set a slot for a required parameter, it would give a helpful error:</p>
<pre><code>f: make frame! append/
f.value: 10

&gt;&gt; eval f
** Error: APPEND's SERIES argument is unspecified
</code></pre>
<h2><a name="p-7965-but-what-if-you-want-to-specialize-to-nothing-2" class="anchor" href="https://forum.rebol.info#p-7965-but-what-if-you-want-to-specialize-to-nothing-2"></a>But What If You Want To Specialize To Nothing?</h2>
<p>It might seem that "nothing" is a rare thing to want to specialize to.  But it's a legitimate value, and represents a valid frame state.</p>
<p>e.g. let's say you wanted to write UNSET as a specialization:</p>
<pre><code>/unset: specialize set/ [value: ~]
</code></pre>
<p>This would wind up making UNSET a synonym for SET.  Because it would think you were saying <em>"specialize SET's value to be unspecialized"</em>...which is what it was by default.</p>
<p>In this sense, using NOTHING as the unspecialized value just pushed the problem around a little bit.  No matter what you pick to represent the unspecialized state, you're going to have a problem.  It just happens that functions which take ~null~ antiforms are relatively common compared to those that take ~ antiforms.</p>
<h2><a name="p-7965-leveraging-meta-on-a-stable-antiform-3" class="anchor" href="https://forum.rebol.info#p-7965-leveraging-meta-on-a-stable-antiform-3"></a>Leveraging ^META On a Stable Antiform</h2>
<p>If you start thinking about being sneaky, you might imagine adding extra hidden bits somewhere to say <em>"no, this is a magic kind of specialized NOTHING"</em>.  But sneaky hidden bits are a tangled web, adding cost in the routines to manipulate them.</p>
<p>So the idea was to use a not-so-hidden bit: any function that could legitimately take "nothing" as an argument had to take it as a ^META parameter.</p>
<pre><code>x: 1020

f: make frame! set/
f.var: $x
f.value: first [~]  ; ~ is meta-NOTHING, aka "quasi-BLANK!", aka "TRASH"

&gt;&gt; eval f
== ~  ; anti

&gt;&gt; x
** Error: X is unset (antiform BLANK!)
</code></pre>
<p>This works, but creates an additional burden: functions that truly want to receive a value that can represent any stable form must take their arguments as ^META... which usually you'd think you only need for unstable forms.</p>
<h2><a name="p-7965-theres-still-an-ambiguity-gather-or-error-4" class="anchor" href="https://forum.rebol.info#p-7965-theres-still-an-ambiguity-gather-or-error-4"></a>There's Still an Ambiguity: Gather, Or Error?</h2>
<p>The above was the status quo for a couple of years: MAKE FRAME! gave you back a frame whose slots were all unset.  Those unset slots represented arguments that were unspecialized.</p>
<p>But still you have a question: should an unspecialized argument be gathered from a callsite, or should it trigger an error?</p>
<p>That decision came from the operation.  If you used EVAL on a FRAME!, it would assume all the frame slots were finalized...and any nothing cells would raise errors.  If you used RUN (or converted the FRAME! into an action) then it assumed the unspecialized slots meant you wanted to gather arguments.</p>
<h2><a name="p-7965-evolution-antiform-parameter-for-unspecialized-slots-5" class="anchor" href="https://forum.rebol.info#p-7965-evolution-antiform-parameter-for-unspecialized-slots-5"></a>Evolution: Antiform PARAMETER! For Unspecialized Slots</h2>
<p>A big change came through with a user exposure of the PARAMETER! type.  With antiform parameters representing unspecialized slots, you had the signal of "this is unspecialized", but also the information required to gather the parameter: what types it checked, whether it was a refinement or not, whether it should be taken literally from a callsite, etc.</p>
<p>This heralded even more exposure of the mechanics of function composition to user mode.  Instead of just specializing a function argument to a value, you could do things like "tweak" the argument's accepted types.</p>
<p>For instance: what if you wanted a version of APPEND that only appended integers?</p>
<pre><code>&gt;&gt; ap-int: make frame! append/

&gt;&gt; ap-int.value: anti make parameter! [integer!]  ; or whatever syntax
== ~#[parameter! [integer!]]~  ; anti

&gt;&gt; /ap-int: anti ap-int
== ~#[frame! ...]~  ; anti

&gt;&gt; ap-int [a b c] 1020
== [a b c 1020]

&gt;&gt; ap-int [a b c] "illegal"
** Error: AP-INT requires [integer!] for its value argument
</code></pre>
<p>This meant that MAKE FRAME! gave back something that looked rather weird:</p>
<pre><code>&gt;&gt; make frame! append/
== #[frame! [
    series: ~#[parameter! [
        ~void~ any-series? port! map! object! module! bitset!]
    ]~
    value: ~#[parameter! [~void~ element? splice?]]~
    part: ~#[parameter! :[any-number? any-series? pair!]]~
    dup: ~#[parameter! :[any-number? pair!]]~
    line: ~#[parameter! :[]]~
]]
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/face_with_diagonal_mouth.png?v=12" title=":face_with_diagonal_mouth:" class="emoji only-emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20"></p>
<p>Although this gives you a useful and actionable information about the parameters, that's fairly noisy for most purposes.  You haven't done any assignments to the frame, and yet it looks like it's "full".</p>
<p>Let's put a pin in that.</p>
<h2><a name="p-7965-are-meta-exceptions-still-needed-6" class="anchor" href="https://forum.rebol.info#p-7965-are-meta-exceptions-still-needed-6"></a>Are ^META Exceptions Still Needed?</h2>
<p>In this model, there is no way of expressing a specialization of a function to an antiform parameter unless that function defined the parameter as ^META.</p>
<p>That doesn't <em>necessarily</em> mean we'd have to be prescriptive.  I mentioned that EVAL expects all the arguments to be specified to their final values, while RUN accepts some will be unspecialized.  So EVAL <em>could</em> treat antiform parameters as the actual values to pass, while RUN would gather them from the callsite.</p>
<p>This would produce a strange conflation.  You couldn't tell by looking at a frame whether or not an antiform parameter was a legitimate argument, or an unspecialized parameter definition.</p>
<p>As an example, consider the HOLE? function, that tells you whether or not a value is an antiform parameter.  Let's assume it's operating in a world that it doesn't need to take the argument as ^META:</p>
<pre><code>&gt;&gt; f: make frame! hole/
== #[frame! [value: ~#[parameter! [any-value?]]~]
</code></pre>
<p>The interface says it takes ANY-VALUE? as the first parameter to HOLE?  Yet we don't have any mechanical way of telling that <strong><code>f2</code></strong> isn't a completed frame for calling HOLE?.  So if EVAL accepts this:</p>
<pre><code>&gt;&gt; eval f
== ~okay~  ; anti
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>It really seems the best plan is to keep erroring when you try to EVAL frames with antiform PARAMETER! in them, when those parameters are required:</p>
<pre><code>&gt;&gt; eval f2
** Error: HOLE?'s VALUE parameter is unspecified (antiform PARAMETER!)
</code></pre>
<p>It does require the ^META exception: functions which need to accept antiform arguments must take that parameter in a meta form.  A function like HOLE? would fit into this category, and so would SET (which has to take unstable antiforms anyway, e.g. to do SET of a BLOCK! to a PACK)</p>
<p>Under this design, any function that can accept antiform parameters at all, will also able to be specialized with antiform parameters.</p>
<h2><a name="p-7965-denoising-make-frame-different-frame-makers-7" class="anchor" href="https://forum.rebol.info#p-7965-denoising-make-frame-different-frame-makers-7"></a>Denoising MAKE FRAME!: Different Frame Makers?</h2>
<p>I pointed out that having antiform parameters in frame slots is a bit noisy.</p>
<p>So what if there were two ways of making frames: one that gives you the parameter antiforms (suitable for tweaking and writing your own specialization operations), and another that clears the fields out?</p>
<p>For instance, keeping the old behavior for MAKE FRAME!:</p>
<pre><code>&gt;&gt; make frame! append/
== #[frame! [
    series: ~
    value: ~
    part: ~
    dup: ~
    line: ~
]]
</code></pre>
<p>But if you wanted antiform parameters, you could just copy the non-antiform version of the FRAME!:</p>
<pre><code>&gt;&gt; copy unrun append/
== #[frame! [
    series: ~#[parameter! [
        ~void~ any-series? port! map! object! module! bitset!]
    ]~
    value: ~#[parameter! [~void~ element? splice?]]~
    part: ~#[parameter! :[any-number? any-series? pair!]]~
    dup: ~#[parameter! :[any-number? pair!]]~
    line: ~#[parameter! :[]]~
]]
</code></pre>
<p>In this design, you'd have <em>two</em> stable forms which you'd have to use ^META conventions to take as an argument.</p>
<p>Antiform ~ would still have to turn into ~null~ if EVAL found it in a refinement slot.  But I'm not sure PARAMETER! antiforms would need to do that too.  One could argue that you should never be EVAL'ing a frame with antiform parameters in it, so it could be a sort of safety mechanism (?).  I'm not sure if it's necessary to enable, so I'd probably just raise an error until I saw a compelling case.</p>
<h2><a name="p-7965-is-the-added-nuance-worth-it-8" class="anchor" href="https://forum.rebol.info#p-7965-is-the-added-nuance-worth-it-8"></a>Is The Added Nuance Worth It?</h2>
<p>Continuing to handle unset variables as placeholders is not strictly necessary, given that antiform parameters are the more fundamental "unspecialized" slot representation.</p>
<p>But it's definitely a lot better than something I tried that <em>sucked</em>: which was trying to make variables holding antiform PARAMETER! act like they were unset.  This made manipulating function interfaces programmatically <em>very</em> painful.</p>
<p>It would mean sacrificing another value to have to be passed ^META.  Though bear in mind, most of the damage is done from having one form: e.g. a function like SET is having to take its value ^META already in order to be able to set things to antiform PARAMETER!.  So it isn't like you'd be able to specialize SET with antiform <code>~</code> to get UNSET if this wasn't done... it would affect the NOTHING? function (and probably not a lot else).</p>
<p><strong>Having used MAKE FRAME! a fair bit, I am inclined to believe it's worth it.</strong>  It's a clear indicator of whether you've assigned fields or not, with some teeth by actually making the variables unset (erroring on use before assignment, and reacting to things like DEFAULT).</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/default-values-and-make-frame-2024-edition/2347">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/default-values-and-make-frame-2024-edition/2347</link>
          <pubDate>Sat, 07 Dec 2024 20:48:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2347</guid>
          <source url="https://forum.rebol.info/t/default-values-and-make-frame-2024-edition/2347.rss">Default Values and MAKE FRAME! - 2024 Edition</source>
        </item>
        <item>
          <title>Design for Something Like FLIP To Reverse Arguments</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="6" data-topic="1238">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/parameter-order-in-rebol/1238/6">Parameter Order in Rebol</a></div>
<blockquote>
<p>If someone wants to specify the second parameter first they can always write <code>flip cons</code> or <code>flip snoc</code>.</p>
</blockquote>
</aside>
<p>The design of a FLIP-like operation raises some questions.</p>
<p>If it were an operator that acted on functions, it wouldn't retrigger them.  You'd have to say:</p>
<pre><code>&gt;&gt; append 'd [a b c]
== [a b c d]

&gt;&gt; run flip append/ [a b c] 'd
== [a b c d]
</code></pre>
<p>Alternately, I guess you could use slash to run a GROUP!, but then you'd have a disabling slash and a running slash:</p>
<pre><code>&gt;&gt; /(flip append/) [a b c] 'd
== [a b c d]
</code></pre>
<p>If it were instead something along the lines of RUN, where applying the flipped function was implicit, you could write:</p>
<pre><code>&gt;&gt; flip append/ [a b c] 'd
== [a b c d]
</code></pre>
<p>I don't think <strong><code>flip/append</code></strong> being a synonym for <strong><code>/(flip append/)</code></strong> is a generically useful idea, compared to the likes of <strong><code>not/even?/</code></strong> for cascading.</p>
<p>But if the <a href="https://forum.rebol.info/t/dialecting-function-calls-new-weird-powerful/2310">weird idea of dialected CHAIN!</a> ever came to pass, FLIP could go into a distinct mode based on receiving a function in the place other functions have refinements...</p>
<pre><code>&gt;&gt; append/
== ~#[frame! [value series]]~

&gt;&gt; flip append/
== ~#[frame! [series value]]~

&gt;&gt; flip:append [a b c] 'd
== [a b c d]
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/design-for-something-like-flip-to-reverse-arguments/2345">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/design-for-something-like-flip-to-reverse-arguments/2345</link>
          <pubDate>Mon, 02 Dec 2024 14:41:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2345</guid>
          <source url="https://forum.rebol.info/t/design-for-something-like-flip-to-reverse-arguments/2345.rss">Design for Something Like FLIP To Reverse Arguments</source>
        </item>
        <item>
          <title>The Probably-False Economy of EVAL Consuming FRAME!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p>The earliest design usages for FRAME! were for things like ENCLOSE.</p>
<p>ENCLOSE builds the frame for the function you're enclosing, then passes the frame to a function that can manipulate the frame, and invoke it with EVAL (or not invoke it at all, if it wishes).</p>
<p>Here's a sort of simple historical example:</p>
<pre><code>/foo: func [a b] [
   let result: a + b
   a: b: ~&lt;whatever&gt;~  ; functions can modify args/locals for any reason
   return result
]

/bar: enclose foo/ (lambda [f [frame!]] [
    let b: f.b
    f.a: f.a * 10
    (eval f) + b
])

&gt;&gt; bar 100 10
== 1020  ; ((a * 10) + b) + b
</code></pre>
<p>You'll notice above that I didn't write:</p>
<pre><code>/bar: enclose foo/ (lambda [f [frame!]] [
    f.a: f.a * 10
    (eval f) + f.b
])
</code></pre>
<p>This is because EVAL of a FRAME! would "consume" the frame, and trying to use <strong><code>f.b</code></strong> after the EVAL would raise an error.  In other words, memory was not allocated as it usually would be for a new frame to do the call...but the fields of the frame were the actual values being used.</p>
<p>I overwrote <strong><code>a</code></strong> and <strong><code>b</code></strong> to make the point that once that EVAL is called, you can't rely on any particular state of a frame's variables.  In the general case, they can be changed to anything.</p>
<h2><a name="p-7936-eval-copy-f-is-easy-and-so-is-saving-variables-right-1" class="anchor" href="https://forum.rebol.info#p-7936-eval-copy-f-is-easy-and-so-is-saving-variables-right-1"></a><code>(eval copy f)</code> is Easy, and So Is Saving Variables, Right?</h2>
<p>The premise I was going on was that it seemed like it would be wasteful...especially in scenarios like an ENCLOSE, to make another copy of the frame's data.</p>
<p>And I figured usually you wouldn't need to refer to anything from the frame's input state after you called it.</p>
<p>So you had two choices: either evaluate a copy of the frame, or save any variables you were interested in as locals.</p>
<h2><a name="p-7936-it-turns-out-to-be-incredibly-common-to-save-variables-2" class="anchor" href="https://forum.rebol.info#p-7936-it-turns-out-to-be-incredibly-common-to-save-variables-2"></a>It Turns Out To Be Incredibly Common To Save Variables</h2>
<p>I didn't know when originally trying to optimize the feature how often an ENCLOSE would need to talk about the input fields after an EVAL call.</p>
<p>But empirically I'd say you need the fields at least half the time.  You actually want it more often than that when you consider debugging--you often want to print some information about the input parameters after you've done the EVAL.</p>
<h2><a name="p-7936-let-b-fb-costs-much-more-than-mallocmemcpy-3" class="anchor" href="https://forum.rebol.info#p-7936-let-b-fb-costs-much-more-than-mallocmemcpy-3"></a><code>(let b: f.b)</code> Costs Much More Than <code>malloc()+memcpy()</code></h2>
<p>When you come down to it, relatively speaking: <em>Evaluator cycles are expensive</em>.  <em>Tuple lookup is expensive</em>.  <em>Assignment is expensive</em>.  <em>LET statements are expensive</em>.</p>
<p>That's because this is an interpreted language, and running code in the interpreter involves pushing and popping entities that represent interpreter stack levels.  There's all kinds of C data structures and layers of C function calls as the gears of the machinery turn...whether your operation be simple or complex.  That's just the name of the game... <strong>a + b</strong> in a generalized evaluator is going to be at least 100x more costly than adding two integers in C, which is basically just a single CPU instruction.</p>
<p>So if you have to do <em>any</em> mitigation of losing the frame data by adding interpreted code, not only are you having to junk up what you're writing...but you're also paying much more than you would have if the system had just gone ahead and made a copy.</p>
<h2><a name="p-7936-explaining-why-you-cant-is-lamer-than-it-just-works-4" class="anchor" href="https://forum.rebol.info#p-7936-explaining-why-you-cant-is-lamer-than-it-just-works-4"></a>Explaining Why You Can't Is Lamer Than <em>"It Just Works"</em></h2>
<p>People understand that if they have a FRAME! for APPEND and they EVAL it, that the series is going to be mutated.</p>
<p>But they're going to understand less that the series field of the frame is not available at all to them after the call.</p>
<p>It's kind of a no-brainer to say that if the two approaches were at all comparable in speed or overall performance, that the more useful behavior should be the default.</p>
<p><em>And I actually believe the more useful behavior is faster in the general case...by avoiding additional intepreter cycles to save frame fields in variables.</em></p>
<h2><a name="p-7936-free-f-could-use-free-as-an-intrinsic-if-you-want-5" class="anchor" href="https://forum.rebol.info#p-7936-free-f-could-use-free-as-an-intrinsic-if-you-want-5"></a><code>(free f)</code> Could Use FREE As An Intrinsic If You Want</h2>
<p><strong><a href="https://forum.rebol.info/t/intrinsics-functions-without-frames/2050">FREE could be trivially made Intrinsic</a>.</strong></p>
<p>If profiling suggested that something like an ENCLOSE on a function with a large frame was affecting your bottom line by not freeing the frame, you could just free it after the EVAL.  That would leave behind nothing but a tiny useless stub (to avoid latent references in other cells from crashing the GC), so you'd get the same end result as the historical EVAL.</p>
<p>I'm betting that having EVAL be able to be intrinsic when it takes one argument, and making FREE intrinsic would be faster than trying to do some weird refinement like <strong><code>eval:free</code></strong> to fold both into one operation...because refinement processing has its own cost, which I <em>think</em> would be greater.</p>
<p>But an optimized <strong><code>eval-free</code></strong> might be worth making, I don't know.  However its mechanic would simply be to natively fold the free in after the EVAL, instead of trying to make EVAL take over the frame and use its memory.</p>
<p>My guess is that using EVAL-FREE won't be a benefit most of the time if you add any evaluator cycles to save a variable because of it.</p>
<h1><a name="p-7936-hence-eval-will-no-longer-consume-frame-6" class="anchor" href="https://forum.rebol.info#p-7936-hence-eval-will-no-longer-consume-frame-6"></a>Hence, EVAL Will No Longer Consume FRAME!</h1>
<p>This makes the "action-is-frame" duality even more solid, because as frames are passed around in the system there won't be "consume frame vs. don't" flags involved.</p>
<p>You'll just either free the frame after you've applied it, or you won't.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-probably-false-economy-of-eval-consuming-frame/2339">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-probably-false-economy-of-eval-consuming-frame/2339</link>
          <pubDate>Sun, 01 Dec 2024 00:50:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2339</guid>
          <source url="https://forum.rebol.info/t/the-probably-false-economy-of-eval-consuming-frame/2339.rss">The Probably-False Economy of EVAL Consuming FRAME!</source>
        </item>
        <item>
          <title>Simplifying Refinement Promotion</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>There are two modes of partial specialization which Ren-C has supported.</p>
<p>One form would be like if APPEND takes something like :DUP and fixes it to a value:</p>
<pre><code>&gt;&gt; append2: specialize append/ [dup: 2]

&gt;&gt; append2 [a b c] &lt;d&gt;
== [a b c &lt;d&gt; &lt;d&gt;]
</code></pre>
<p>Then there's a trickier kind of specialization, which is to ask for the parameter but not specify it... thus just increasing the arity:</p>
<pre><code>&gt;&gt; appenddup: append:dup/

&gt;&gt; appenddup [a b c] &lt;d&gt; 4
== [a b c &lt;d&gt; &lt;d&gt; &lt;d&gt; &lt;d&gt;]
</code></pre>
<p>The second form is pretty unusual in the language world.  There doesn't seem to be much prior art in "the conversion of optional parameters to required parameters" (at least I don't know any, and the AIs I asked don't know any).</p>
<p>Since it's pretty different from what what people think of as partial specialization, let's call it <strong>"refinement promotion"</strong>.</p>
<h2><a name="p-7935-refinement-promotion-is-tricky-1" class="anchor" href="https://forum.rebol.info#p-7935-refinement-promotion-is-tricky-1"></a>Refinement Promotion Is <em>Tricky</em></h2>
<p>Something that has been non-negotiable in the design is the straightforward array of parameters and locals that specify a function interface.</p>
<p>Refinements are defined in some order in that array.  But you are not required to use them in that order.</p>
<p>So consider a definition like:</p>
<pre><code> /foo: func [a [integer!] :b [integer!] :c [integer!]] [...]
</code></pre>
<p>Someone might do refinement promotion of this as <strong><code>foo:c:b/</code></strong> - this makes it seem to the caller a function originally written with spec:</p>
<pre><code> [a [integer!] c [integer!] b [integer!]]
</code></pre>
<p>The techniques so far have tried to mimic the way that refinements work.  So <strong><code>get $foo:c:b</code></strong> would produce a function that was accompanied by a <strong><code>[c b]</code></strong> array, that would get pushed when running the promoted function.  The elements in the array would not just have the words, but those words would have binding information to say what index those words were found at in the parameter array.</p>
<p>But since the underlying array is left the same, this means every time you want to know something like "what's the first unspecialized normal argument" you have to mimic the refinement gathering process.  It convoluted the process quite a lot, and really went against the idea of the implementation being "simple".</p>
<h2><a name="p-7935-q-is-this-really-required-to-support-a-yes-2" class="anchor" href="https://forum.rebol.info#p-7935-q-is-this-really-required-to-support-a-yes-2"></a>Q: Is This Really Required To Support?  (A: Yes)</h2>
<p>This may not seem like a super-common need.  But if you're implementing a dialect that wants to support calling functions with refinements, it's pretty important.</p>
<p>Let's say you're implementing something like <a href="https://forum.rebol.info/t/if-action-combinators-dont-impress-what-will/1608">the feature in UPARSE that lets you call functions</a>:</p>
<pre><code>&gt;&gt; data: copy ""

&gt;&gt; parse ["a" "b"] [some [/append:dup (data) text! (2)]]

&gt;&gt; data
== "aabb"
</code></pre>
<p>Basically, if <strong><code>(get $/append:dup)</code></strong> can come back with a function that you can query for its parameters and get answers just like it was any other function, then support for refinements comes basically for free.</p>
<h2><a name="p-7935-should-the-varlist-just-be-rewritten-3" class="anchor" href="https://forum.rebol.info#p-7935-should-the-varlist-just-be-rewritten-3"></a>Should The VarList Just Be Rewritten?</h2>
<p>If you look at what a modern SPECIALIZE followed by AUGMENT can do, they can hide parameters...and then add back parameters with the same name.  Which parameters are visible depend on the "phase" of the frame.</p>
<p>So why couldn't refinement promotion be done just by making a new function interface that removes the argument as a refinement, and adds it back as a regular argument... then has a dispatch phase that moves the argument data to its old position for the subsequent phases?</p>
<p>It's not particularly "cheap" to do that, space-wise.  You'd need a new VarList* and a new Phase*, and the Phase would have to remember the new and old positions to do the rewrite.  But it would make parameter enumeration blunt and simple, because you'd really just be enumerating the parameters in order.</p>
<p>There'd be some cases where the position of the refinement would allow it to just be naturally rewritten to be a regular argument, and that could be optimized for.</p>
<h2><a name="p-7935-what-about-when-you-have-lots-of-local-4" class="anchor" href="https://forum.rebol.info#p-7935-what-about-when-you-have-lots-of-local-4"></a>What About When You Have Lots of <code>&lt;local&gt;</code>?</h2>
<p>This is kind of the dark side of the simple FRAME! model, which is that if you use it to create a lot of local variables, then operations like SPECIALIZE and AUGMENT which do VarList manipulation have to make copies of everything for the new VarList...including a bunch of locals that aren't changing at all in each new form.</p>
<pre><code>/foo: func [x [text!] y [tag!] &lt;local&gt; a b c d e f g h i j k l m n o p] [
    ... 19 frame cells (includes RETURN) ...
]

/bar: augment foo/ [z [integer!]]  ; z is last item in new 20 item frame
</code></pre>
<p>Refinement promotion would become another one of these situations that would do seemingly unnecessary duplication.</p>
<p>It would be possible in cases like this to create smaller frames and then proxy the results into larger ones, essentially simulating what a user might do to manually call FOO from a new function BAR which had a frame with 3 elements.</p>
<pre><code>/bar: lambda [x [text!] y [tag!] z [integer!]] [
    foo x y  ; imagine doing this, but with faster internal mechanics
]
</code></pre>
<p>Some calculation could be done where the size of the frame justified it.  I have a feeling that the frame would have to be reasonably large before a technique like this would be beneficial.</p>
<h2><a name="p-7935-what-about-refinements-at-headhttpsforumrebolinfotrefinement-arguments-at-head-of-args-list-not-tail2331-5" class="anchor" href="https://forum.rebol.info#p-7935-what-about-refinements-at-headhttpsforumrebolinfotrefinement-arguments-at-head-of-args-list-not-tail2331-5"></a>What About <a href="https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331">Refinements At Head</a>?</h2>
<p>Well, in that case, you would <em>have</em> to build a new VarList* that extracted the arguments, and then proxy them into position for the new interface.</p>
<p>At least one wouldn't be worried about the "bloated copies of locals" situation.</p>
<h2><a name="p-7935-souse-the-auxiliary-array-simulating-refinements-6" class="anchor" href="https://forum.rebol.info#p-7935-souse-the-auxiliary-array-simulating-refinements-6"></a>So...Use The Auxiliary Array Simulating Refinements?</h2>
<p>The code for simulating refinements when asking simple questions like <em>"what's the first unspecialized normal arg"</em> is unappealingly complex. <img src="https://forum.rebol.info/images/emoji/twitter/nauseated_face.png?v=12" title=":nauseated_face:" class="emoji" alt=":nauseated_face:" loading="lazy" width="20" height="20"></p>
<p>Making it further unappealing is that when you have this array of refinements "off to the side" but still allow people to fill in slots in frames to specialize out arguments, you end up needing to have "reconciliation"...because those frame slots that are referenced by this out-of-band array are no longer part of the refinement promotion.</p>
<pre><code>&gt;&gt; f: make frame! append:dup:part/  ; has auxiliary [dup part]

&gt;&gt; f.dup: 3  ; what cleans up [dup part] to just [part] ?
</code></pre>
<p>I've talked about not knowing about what "moment" to do these kinds of fixes, and I'm increasingly looking for ways to avoid there being any such moment.  If the physical experience of the frame was that DUP and PART were ordinary parameters and not refinements, then it "just works".</p>
<h2><a name="p-7935-the-dumb-mechanical-answer-is-likely-best-7" class="anchor" href="https://forum.rebol.info#p-7935-the-dumb-mechanical-answer-is-likely-best-7"></a>The "Dumb" Mechanical Answer Is Likely Best</h2>
<p>I sometimes forget just how much I take for granted in Ren-C, regarding the ability to compose functions together.</p>
<p>The "inefficient" idea of making a new parameter list and then proxying the arguments into position would be more efficient than having to create and evaluate an interpreted function that had to manually copy the parameters.</p>
<p>There's a huge tax created by having to compose an off-to-the-side parameter reordering list in with the frame variables, and that tax is paid by <em>any code</em> that wants to interpret the list.  It's just too big a tax to pay.</p>
<p>It pains me a bit to delete it, because it was hard to write and seemed clever at the time.  But techniques have advanced...and while the auxiliary list may have seemed somewhat optimal for storage, it's no longer the right choice.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/simplifying-refinement-promotion/2338">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/simplifying-refinement-promotion/2338</link>
          <pubDate>Sat, 30 Nov 2024 21:20:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2338</guid>
          <source url="https://forum.rebol.info/t/simplifying-refinement-promotion/2338.rss">Simplifying Refinement Promotion</source>
        </item>
        <item>
          <title>Issues With Querying A Function&#39;s &quot;RETURN&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Each FUNCTION has a local variable named RETURN.  When it's running, the cell for that variable points at an "archetypal return function".  But that cell also holds a reference to that specific function instantiation's frame.  This way it knows how to return specifically from that invocation of that function.</p>
<p>This "definitional return" concept has worked quite well.  But there are some fiddly issues that arise from trying to make RETURN an ordinary local variable.</p>
<h2><a name="p-7931-it-was-hoped-return-would-not-be-special-1" class="anchor" href="https://forum.rebol.info#p-7931-it-was-hoped-return-would-not-be-special-1"></a>It Was Hoped RETURN Would Not Be Special</h2>
<p>The idea is that LAMBDA would be lower-level than FUNCTION, and permit you to have parameters or local variables named RETURN that had nothing to do with returning.</p>
<pre><code>/demo: lambda [return continue] [
    return + continue
]

&gt;&gt; demo 1 2
== 3
</code></pre>
<p>So an aspirational aspect of the design was that a user could create something that operated identically to the FUNCTION abstraction (just a bit slower, due to not being implemented natively).</p>
<p>It would use something like THROW and CATCH, to implement RETURN (or construct(s) in that family) itself, as LAMBDAs synthesized upon instantiation.</p>
<h2><a name="p-7931-return-as-local-hides-its-type-information-2" class="anchor" href="https://forum.rebol.info#p-7931-return-as-local-hides-its-type-information-2"></a>RETURN as Local Hides Its Type Information</h2>
<p>While it's not an argument to the function, RETURN still has associated type information.</p>
<p>Since RETURN is a local that will be filled with an action when the function runs, it isn't using its frame slot until that invocation happens.  That means it can store a PARAMETER! which says what return types are legal.  (It seems like a good use of an otherwise-unused slot otherwise you'd need a slot in the Phase to hold it.)</p>
<p>Functions like HELP want to know those types.  Yet locals and specialized arguments are traditionally considered implementation details, hidden from callers.  They're only visible  when frames are captured during the "phase" of being inside the function call:</p>
<pre><code>&gt;&gt; /foo: function [return: [integer!] x] [
     print mold words of binding of $x
]

&gt;&gt; words of foo/
== [x]

&gt;&gt; foo
== [return x]
</code></pre>
<p>Today's unsatisfying solution is that there's a flag on parameters that represent RETURN.  If you want the type information of that return, you can ask for it:</p>
<pre><code>&gt;&gt; return of foo/
== ~#[parameter! [integer!]]~  ; anti
</code></pre>
<p>But this flag is only applied by the FUNCTION native when its construction the parameter list.  So you wouldn't (for instance) get this behavior on a usermode re-implementation of FUNCTION based on LAMBDA.</p>
<h2><a name="p-7931-how-to-change-return-in-composition-3" class="anchor" href="https://forum.rebol.info#p-7931-how-to-change-return-in-composition-3"></a>How To Change RETURN In Composition?</h2>
<p>Let's say you're going to build a higher-level function with something like ENCLOSE:</p>
<pre><code>&gt;&gt; /bar: enclose foo/ func [return: [tag!] f [frame!]] [
       print "I'm an enclosure!"
       eval f
       return &lt;tag&gt;
   ] 
</code></pre>
<p>The interface of an enclosed function is the same parameter list as the original, and the same returns as the original.  The enclosure is implemented as a function that takes a frame, and it can be given a new return type.  But today that isn't reported as the return type if you asked for HELP of FOO.  It would look at the original parameter list, which in this case says its RETURN is <strong><code>[integer!]</code></strong>.</p>
<p><em>This suggests that the answer to the question <strong><code>return of</code></strong> has to be dispatcher-specific.</em></p>
<p>FUNCTION would say "it's the contents of the RETURN local in the archetype (not overwritten with return function, so still a PARAMETER!)".</p>
<p>ENCLOSE would say "it's the return type of the enclosure function that takes the frame" but then give back the original parameter list for everything else.  (This raises a question of how you would inherit the original function's return... it might be nice if you used a LAMBDA or something that reported no return constraint, that it would default to the constraints of the function you were enclosing.)</p>
<p>In any case, if it was answered by the dispatcher... then if LAMBDA says "I don't have a RETURN", you'd not have HELP information on your RETURN if you were trying to build your own FUNCTION on top of LAMBDA.</p>
<p><strong>The word RETURN may be a distraction, here.</strong>  Because if it's something like a GENERATOR, the products are coming from calls to YIELD.  Maybe <strong><code>(result of ...)</code></strong> or <strong><code>(synthesis of ...)</code></strong> would help stress that this question isn't tied up specifically with RETURN.</p>
<h2><a name="p-7931-lambda-semantics-may-want-result-specification-4" class="anchor" href="https://forum.rebol.info#p-7931-lambda-semantics-may-want-result-specification-4"></a>LAMBDA Semantics May Want Result Specification</h2>
<p>The idea of LAMBDA is that the evaluative product just drops out <a href="https://forum.rebol.info/t/implicit-execution-of-return-in-functions-bad/1656">(see various writings on why FUNCTION does not allow that)</a>.</p>
<p>But just because you want that semantic, doesn't mean you don't want the HELP to not give a return type.</p>
<p>However, LAMBDA doesn't have anywhere to store the type information the way FUNCTION does.  If it has a RETURN it may be using it for unrelated purposes.</p>
<p>Given what I've proposed for the dispatcher-specific RETURN, you could accomplish it with an ENCLOSE:</p>
<pre><code> enclose (lambda [...] [...]) func [return: [&lt;spec&gt;] f] [return eval f]
</code></pre>
<p>But it seems clearly better to have something specific to this purpose:</p>
<pre><code> returns [&lt;spec&gt;] lambda [...] [...]
</code></pre>
<p>Then the Returns_Dispatcher() would simply type check what you gave it.</p>
<p>Perhaps it could even accept a function as a first parameter, and then just say it returns whatever that function returns:</p>
<pre><code>returns add/ lambda [x] [x + 1]
</code></pre>
<p>Though that might be more confusing than writing it out:</p>
<pre><code>returns (return of add/) lambda [x] [x + 1]
</code></pre>
<p>Maybe a refinement should be used to bless that you're doing it on purpose:</p>
<pre><code>returns:same-as add/ lambda [x] [x + 1]
</code></pre>
<p>I guess the big question would be how to get the return's textual description in there.  Maybe it could assume if the format is TEXT! BLOCK! that's what you mean:</p>
<pre><code>/foo: returns [
   "The input plus one"
   [integer!]
] lambda [x] [
    x + 1
]
</code></pre>
<h2><a name="p-7931-well-theres-some-ideas-5" class="anchor" href="https://forum.rebol.info#p-7931-well-theres-some-ideas-5"></a>Well, There's Some Ideas</h2>
<p>I guess the idea here is that mechanics for answering "what do you return" come from the function's dispatcher, and maybe that becomes a chained question where if the dispatcher wraps something else, it has to ask the right parts of that thing.  There may be no user-exposed mechanic for building your own answer to the question beyond something like RETURNS, which is probably good enough.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/issues-with-querying-a-functions-return/2336">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/issues-with-querying-a-functions-return/2336</link>
          <pubDate>Thu, 28 Nov 2024 00:00:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2336</guid>
          <source url="https://forum.rebol.info/t/issues-with-querying-a-functions-return/2336.rss">Issues With Querying A Function&#39;s &quot;RETURN&quot;</source>
        </item>
        <item>
          <title>Dropping `&lt;with&gt;`, `&lt;in&gt;`, `&lt;static&gt;`</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>In R3-Alpha, there was the idea that FUNC was lower-level, <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/mezz/base-funcs.r#L28C1-L56C2">and "FUNCTION" was built on top of it</a>.</p>
<p>Its principal difference was automatically collecting SET-WORD!s as locals.  But it added two refinements: <strong>/WITH</strong> and <strong>/EXTERN</strong>.</p>
<p>/EXTERN was a way of saying what shouldn't get collected as a local variable due to being a SET-WORD!:</p>
<pre><code>global-var: 10

foo: function/extern [arg1 arg2] [
    local-var: "hi"
    global-var: 20  ; /EXTERN protected this from being collected local
    return arg1 + arg2
] [global-var]
</code></pre>
<p>/WITH was a way of making static variables:</p>
<pre><code>accumulate: function/with [x] [
   return state: state + x
] [state: 0]
</code></pre>
<h2><a name="p-7923-early-on-ren-c-moved-everything-into-the-spec-1" class="anchor" href="https://forum.rebol.info#p-7923-early-on-ren-c-moved-everything-into-the-spec-1"></a>Early On, Ren-C Moved Everything Into The Spec</h2>
<p>I didn't like seeing the refinement arguments at the end (of what could be a very long function definition).</p>
<p>It didn't occur to me to suggest that <a href="https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331">refinement arguments be moved to the head</a> (which they probably should).  But what did occur to me was that the function spec could incorporate these properties.</p>
<p>I actually thought <code>&lt;with&gt;</code> seemed better than extern, as a nicer word for "Use these existing variables".  And <code>&lt;static&gt;</code> seemed like a well-known term for static variables:</p>
<pre><code>foo: function [arg1 arg2 &lt;with&gt; global-var] [
    local-var: "hi"
    global-var: 20
    return arg1 + arg2
]

accumulate: function [x &lt;static&gt; state (0)] [
   return state: state + x
]
</code></pre>
<p>The subtlety of wanting to use an object instance was also added, as <code>&lt;in&gt;</code>:</p>
<pre><code>obj: make object! [a: 10 b: 20]

bar: function [x &lt;in&gt; obj] [
   return a + b + x
]
</code></pre>
<p>To my eyes, that all seemed like improvement.</p>
<p><strong>But it didn't come without cost: The spec had to be transformed into something the lower-level FUNC could understand.</strong></p>
<p>This meant there was a layer of parsing and production of a new spec that was a tax on every function creation.</p>
<h2><a name="p-7923-time-passes-set-word-gathering-is-panned-2" class="anchor" href="https://forum.rebol.info#p-7923-time-passes-set-word-gathering-is-panned-2"></a>Time Passes, SET-WORD! Gathering Is Panned</h2>
<p>It didn't take long for me to decide that <a href="https://forum.rebol.info/t/rethinking-auto-gathered-set-word-locals/1150">SET-WORD! locals-gathering was bad</a>... a gimmick that only made sense in very limited domains (perhaps code-golf)</p>
<p>This motivated having an answer for how to implement LET, as "virtual binding" became the new plan.</p>
<p>Once that transition went through, the effect of <strong><code>&lt;with&gt;</code></strong> was to become commentary.  Since all it did was remove SET-WORD!s from the collection list, and there was no collection any longer.</p>
<p>Though virtual binding did open up a new possibility, that if your block had a different binding than the spec, then the WITH might import visibility of terms to that block:</p>
<pre><code>global-variable: 10

block: /get-block-from-somewhere ...  ; doesn't know about GLOBAL-VARIABLE

/foo: function [x &lt;with&gt; global-variable] block
</code></pre>
<p>But this would be a binding operation, that is better generalized as:</p>
<pre><code>/foo: function [x] (bind @global-variable block)
</code></pre>
<h2><a name="p-7923-pushing-the-features-to-bind-make-the-most-sense-3" class="anchor" href="https://forum.rebol.info#p-7923-pushing-the-features-to-bind-make-the-most-sense-3"></a>Pushing The Features To BIND Make The Most Sense</h2>
<p>Not just <code>&lt;with&gt;</code>, but the <code>&lt;static&gt;</code> and <code>&lt;in&gt;</code> features seemed to be better as BIND operations as well.</p>
<p>The static syntax of not using SET-WORD!s was based on the idea that SET-WORD!s were reserved for local variables (and RETURN: syntax).  So it was a WORD! followed by a GROUP! to initialize.</p>
<p>I think it's better done with just <a href="https://forum.rebol.info/t/rethinking-static-in-the-function-spec-dialect/2139">BIND to a FENCE!</a></p>
<pre><code>accumulate: function [
    x
] bind {state: 0} [
   return state: state + x
]
</code></pre>
<p><code>&lt;in&gt;</code> is similar.</p>
<pre><code>obj: make object! [a: 10 b: 20]

bar: function [
   x
] bind obj [
   return a + b + x
]
</code></pre>
<h2><a name="p-7923-uglier-maybe-more-general-yes-faster-definitely-4" class="anchor" href="https://forum.rebol.info#p-7923-uglier-maybe-more-general-yes-faster-definitely-4"></a>Uglier?  Maybe.  More General?  Yes.  Faster?  Definitely.</h2>
<p>Feature-wise, there's a slight loss of the commentary capacity of <code>&lt;with&gt;</code>.</p>
<pre><code>global-var: 10

foo: function [arg1 arg2 &lt;with&gt; global-var] [  ; no-op, but useful?
    global-var: 20
    return arg1 + arg2
]
</code></pre>
<p>But besides that, there's no loss of features to move everything to a BIND operation on the body.</p>
<p>Not having to PARSE the spec and generate a whole new one is a big performance win.</p>
<p>So I'm letting go of those features.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/dropping-with-in-static/2335">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dropping-with-in-static/2335</link>
          <pubDate>Thu, 21 Nov 2024 22:06:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2335</guid>
          <source url="https://forum.rebol.info/t/dropping-with-in-static/2335.rss">Dropping `&lt;with&gt;`, `&lt;in&gt;`, `&lt;static&gt;`</source>
        </item>
        <item>
          <title>The Semantics of JOIN</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p><strong>As <a class="mention" href="https://forum.rebol.info/u/brett">@Brett</a>'s critique of yesteryear pointed out, <a href="https://forum.rebol.info/t/rejoin-ugliness-and-the-usefulness-of-tests/248">REJOIN sucked</a>.</strong></p>
<p>If naming were consistent, you might think from this pattern:</p>
<pre><code>append a reduce b &lt;=&gt; repend a b
</code></pre>
<p>...that the following would have been true:</p>
<pre><code>join a reduce b &lt;=&gt; rejoin a b  ; one would have perhaps thought?
</code></pre>
<p>But no...REJOIN was single arity (and was a mess).</p>
<h2><a name="p-7907-so-rejoin-is-in-the-trash-heap-but-what-about-join-1" class="anchor" href="https://forum.rebol.info#p-7907-so-rejoin-is-in-the-trash-heap-but-what-about-join-1"></a>So REJOIN is in the trash heap, but what about JOIN?</h2>
<p>JOIN implicitly reduced, and was basically this:</p>
<pre><code>join a b &lt;=&gt; append copy a reduce b
</code></pre>
<p>But <strong>b</strong> didn't have to be a BLOCK!, so if it was not, it wasn't reduced and just left as-is.</p>
<pre><code>rebol2&gt;&gt; join "abc" [1 + 2 3 + 4]
== "abc37"  ; so the block was reduced

rebol2&gt;&gt; d: 10
rebol2&gt;&gt; join "abc" 'd
== "abcd"  ; not abc10, so the word was *not* reduced
</code></pre>
<p>Red did not carry forward this definition:</p>
<pre><code>&gt;&gt; join
*** Script Error: join has no value
</code></pre>
<h2><a name="p-7907-next-level-join-allow-join-datatype-2" class="anchor" href="https://forum.rebol.info#p-7907-next-level-join-allow-join-datatype-2"></a>Next-Level JOIN: Allow JOIN  DATATYPE</h2>
<p>At some point, it occurred to me that if you could use JOIN with a datatype, it could step in to fill in the desires of REJOIN more clearly:</p>
<pre><code>&gt;&gt; join binary! [1 + 2 #{DECAFBAD} 2 + 3]
== #{03DECAFBAD05}
</code></pre>
<p>There really had been expressions of this like:</p>
<pre><code>rebol2&gt;&gt; rejoin [#{} 1 + 2 #{DECAFBAD} 2 + 3]
== #{03DECAFBAD05}
</code></pre>
<p>But see Brett's critique, if the surface-level badness isn't enough to convince you!</p>
<p>I also wanted to support things that Rebol2 probably meant to, but did not.  This should give a WORD! back:</p>
<pre><code>rebol2&gt;&gt; join 'a 'b
== "ab"  ; should be word! `ab`
</code></pre>
<p>Plus, I thought it might be nice to have a non-reducing variant, done with <code>@[...]</code></p>
<pre><code>&gt;&gt; join word! @[a 1 + 2]
== a1+2
</code></pre>
<p>I've mentioned elsewhere that I think having <em>join-like</em> actions be done with JOIN is superior to being some form of MAKE, when there's nebulousness for what MAKE means.</p>
<h2><a name="p-7907-making-peace-with-uneasiness-about-list-ambiguity-3" class="anchor" href="https://forum.rebol.info#p-7907-making-peace-with-uneasiness-about-list-ambiguity-3"></a>Making Peace (?) With Uneasiness About List Ambiguity</h2>
<p>Ergonomically, it's nice for JOIN to be able to take either a BLOCK! or some other type.</p>
<p>One of the biggest uses of JOIN is with files:</p>
<pre><code>join directory %foo.txt
</code></pre>
<p>It would be annoying if you had to write:</p>
<pre><code>join directory [%foo.txt]
</code></pre>
<p>But then, you have the problem that if you're joining onto a BLOCK!, then a BLOCK! is a legitimate thing to join:</p>
<pre><code>&gt;&gt; join [a b] [1 + 2 10 + 20]
== [a b 3 30]  ; "traditional" behavior

&gt;&gt; join [a b] [1 + 2]
== [a b [1 + 2 10 + 20]]  ; ...but this could be valid
</code></pre>
<p>We could "fix" this by defining JOIN as a non-reducing construct, then have people use SPREAD and REDUCE:</p>
<pre><code>&gt;&gt; join [a b] spread reduce [1 + 2 10 + 20]
== [a b 3 30]

&gt;&gt; join [a b] [1 + 2 10 + 20]
== [a b [1 + 2 10 + 20]]

&gt;&gt; join [a b] reduce [1 + 2 10 + 20]
== [a b [3 30]]
</code></pre>
<p>But this doesn't exactly square with the JOIN of a DATATYPE! case, and the most common desires.</p>
<p>If anything, I'd rather make JOIN always take a <strong><code>[...]</code></strong> or <strong><code>@[...]</code></strong> in the second argument, and then create some other non-reducing construct that slaps two things together.</p>
<pre><code>&gt;&gt; block: [a b]

&gt;&gt; adjoin block [c d]
== [a b [c d]]

&gt;&gt; adjoin block spread [e f]
== [a b [c d] e f]

&gt;&gt; block
== [a b]  ; unmodified (difference from append)
</code></pre>
<p>But asking people to write <strong><code>(adjoin directory %foo.txt)</code></strong> is... ugly.</p>
<p>A compromise is to narrow it, so that you could only use it with single items when joining with non-lists...</p>
<pre><code>&gt;&gt; join "abc" "def"
== "abcdef"

&gt;&gt; join [a b c] "def"
** Error: JOIN with a list must use [...] or @[...]
</code></pre>
<p>This would help steer you away from writing code like <strong><code>join list value</code></strong> and think it works, to only find it falling down when value becomes a BLOCK!.</p>
<h2><a name="p-7907-is-reduce-just-join-block-4" class="anchor" href="https://forum.rebol.info#p-7907-is-reduce-just-join-block-4"></a>Is REDUCE just JOIN BLOCK! ?</h2>
<p>The implementation of JOIN that I'm working on seems like a more powerful REDUCE.</p>
<p>But questions start to arise about the binding... what should the binding be?</p>
<pre><code>&gt;&gt; join [add 1] ['multiply 2 3]
== [add 1 multiply 2 3]
</code></pre>
<p>In that case, I'm going to assume the produced block would have the binding of the [add 1] block.  Since multiply is <strong><code>'multiply</code></strong> and not <strong><code>$multiply</code></strong> it would be unbound and hence an evaluation would be driven by that first argument's binding.</p>
<p>But what if you just said:</p>
<pre><code>&gt;&gt; join block! ['add 1 'multiply 2 3]
== [add 1 multiply 2 3]
</code></pre>
<p>Before, the second block's binding was disregarded in the product.  But when there's no first block to get the binding from, does it assume the binding of the second block?  And how would you get an unbound block if you wanted it?</p>
<p>We could say that you get an unbound block, but if you want a bound block, you'd say:</p>
<pre><code>&gt;&gt; join $[] ['add 1 'multiply 2 3]
== [add 1 multiply 2 3]
</code></pre>
<p>Then we have similar questions for things like word!:</p>
<pre><code>&gt;&gt; join word! ["a" "b"]
== ab
</code></pre>
<p>I feel that pretty obviously should be unbound.  But words follow different rules:</p>
<pre><code>&gt;&gt; join $a ["b"]
== ab  ; can't necessarily be bound, just because a was...
</code></pre>
<p>That would suggest all words come back unbound from a joining process.</p>
<p>So no shortage of questions.  But in general, I think JOIN is on the right track, and splitting MAKE behaviors that are JOIN-like to it seems good.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-semantics-of-join/2333">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-semantics-of-join/2333</link>
          <pubDate>Sat, 16 Nov 2024 18:33:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2333</guid>
          <source url="https://forum.rebol.info/t/the-semantics-of-join/2333.rss">The Semantics of JOIN</source>
        </item>
        <item>
          <title>Refinement Arguments at Head of Args List, Not Tail</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>In the corpus of code we have so far, it seems to me that when a refinement adds an argument to a function that it would be preferable if that argument would become the first parameter... not tacked onto the end.</p>
<p>Some cases might not be completely obvious one way or another:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c [d e]]

&gt;&gt; append:dup [a b c] [d e] 2  ; old way
== [a b c [d e] [d e]] 

&gt;&gt; append:dup 2 [a b c] [d e]  ; new idea
== [a b c [d e] [d e]]
</code></pre>
<p>I think it's better if it's first, but it's not earth-shattering.</p>
<p>But in other cases it seems very much an improvement.  Consider the positioning of the argument to FAIL:BLAME...</p>
<pre><code>foo: func [arg thing] [
    if arg &lt; 0 [
        fail:blame [
           "Here is some long error message:" @thing
           "Whatever..."
        ] $arg
    ]
]

foo: func [arg thing] [
    if arg &lt; 0 [
        fail:blame $arg [
           "Here is some long error message:" @thing
           "Whatever..."
        ]
    ]
]
</code></pre>
<p>Or an argument to COMPOSE giving a pattern to use:</p>
<pre><code>compose:pattern [
    some bunch of {{code that}} &lt;spans&gt;
    #multiple lines
    [and could go on for pages]
] ${{}}  ; afterthought...

compose:pattern ${{}} [  ; forethought
    some bunch of {{code that}} &lt;spans&gt;
    #multiple {{lines}}
    [and could go on for pages]
]
</code></pre>
<p>This goes along with some Haskell philosophy I cited in <a href="https://forum.rebol.info/t/parameter-order-in-rebol/1238">Parameter Order in Rebol</a>:</p>
<blockquote>
<p><em>"It's common practice in Haskell to order function parameters so that parameters which "configure" an operation come first, and the "main thing being operated on" comes last. This is often counter intuitive coming from other languages, since it tends to mean you end up passing the "least important" information first. It's especially jarring coming from OO where the "main" argument is usually the object on which the method is being invoked, occurring so early in in the call that it's out of the parameter list entirely!"</em></p>
</blockquote>
<p>These refinements typically seem to be <em>configuring</em>, as if they are changing the function itself, and belong at the head.</p>
<p>e.g. above, the function you're conceptually applying is <strong><code>(compose:pattern ${{}})</code></strong></p>
<h2><a name="p-7889-history-didnt-do-it-this-way-with-some-reasons-1" class="anchor" href="https://forum.rebol.info#p-7889-history-didnt-do-it-this-way-with-some-reasons-1"></a>History Didn't Do It This Way, With Some Reasons</h2>
<p>Refinements are typically listed at the end of the function spec.</p>
<p>From an implementation standpoint, that's also where their "slots" are in the argument list.</p>
<p>This means that as you are walking the argument list and fulfilling arguments from the callsite, if refinements were used you would have to skip over the "normal" arguments in a first pass, and then come back and fill them later.</p>
<p>Historical Redbols only had to be worried about the order of usage of refinements... if you used them out of order from the declaration, a second pass would be needed.  But using them in order would not require it.</p>
<p>This isn't a problem for Ren-C...it's designed for generic parameter reordering (refinements or otherwise) and it has an efficient way to beeline back to slots it skipped on a second pass.</p>
<p>So really the only issue is the mismatch between the visual order in the spec (which may be exposed mechanically by fixed orders of enumeration of FRAME! keys and values), compared with the gathering behavior.  But the disconnect of that order has always been there, with <strong>foo/refine1/refine2</strong> vs. <strong>foo/refine2/refine1</strong> in Redbol... the callsite order may not match the frame order.</p>
<h2><a name="p-7889-is-it-worth-changing-2" class="anchor" href="https://forum.rebol.info#p-7889-is-it-worth-changing-2"></a>Is It Worth Changing?</h2>
<p>The competing (complementary) idea of <a href="https://forum.rebol.info/t/dialecting-function-calls-new-weird-powerful/2310">CHAIN! dialecting</a> offers something that's likely even more compelling:</p>
<pre><code>compose:pattern ${{}} [  ; better than today...
    some bunch of {{code that}} &lt;spans&gt;
    #multiple {{lines}}
    [and could go on for pages]
]

compose:${{}} [  ; ...but this surpasses even that
    some bunch of {{code that}} &lt;spans&gt;
    #multiple {{lines}}
    [and could go on for pages]
]
</code></pre>
<p>Though it's kind of up in the air if and when that's going to get attacked, and how well it will work (it may run afoul of problems in binding, etc.)</p>
<p>My instincts tell me that it's worth changing.  In practice, refinements that take arguments are not super common... but when they do happen, being up front seems to make the most sense.</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331</link>
          <pubDate>Tue, 12 Nov 2024 14:16:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2331</guid>
          <source url="https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331.rss">Refinement Arguments at Head of Args List, Not Tail</source>
        </item>
        <item>
          <title>Antiform Safety: Covariance and Contravariance</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Testing</category>
          <description><![CDATA[
            <p>Grafting antiforms onto a C codebase that had no such concept is fraught with disasters.</p>
<p>The semantics of unstable antiforms is particularly risky.  If you have a test like <strong><code>Is_Block(cell)</code></strong> that tells you whether a cell holds a BLOCK!, then what if that cell holds an antiform block?  Usermode code has the benefit of decay-by-default (unless you take a meta-parameter).  So if you ask <strong><code>BLOCK?</code></strong> on a parameter pack, it will decay to its first item and answer based on that.  The C implementation has no such "automatic" behavior.</p>
<p>Even "worse", what if <strong><code>cell</code></strong> contains an antiform error, and you quietly say "no it's not a block" and proceed on, ignoring situations when that should have raised an abrupt failure?</p>
<h2><a name="p-7886-creating-a-type-hierarchy-atom-value-element-1" class="anchor" href="https://forum.rebol.info#p-7886-creating-a-type-hierarchy-atom-value-element-1"></a>Creating A Type Hierarchy: Atom -&gt; Value -&gt; Element</h2>
<p>I've given names to the three broad categories of cells:</p>
<ul>
<li>
<p><strong>ELEMENT</strong> - anything that you can put in a List.  So this is "element" as in "array element".  Hence, no antiforms.  (It's not a perfect name in terms of correspondence to "chemical element" in terms of the abstract form that can come in isotopes, so think of it as array element)</p>
</li>
<li>
<p><strong>VALUE</strong> - anything that you can put in a Variable.  So it extends ELEMENT with stable antiforms.</p>
</li>
<li>
<p><strong>ATOM</strong> - anything, including unstable antiforms.</p>
</li>
</ul>
<p>Systemically, we want to stop antiforms from being put into the array elements of blocks, groups, paths, and tuples.  We also want to prevent unstable antiforms from being the values of variables.</p>
<p>To make it easier to do this, the C++ build offers the ability to make <code>Element</code> that can't hold any antiforms, <code>Value</code> that can hold stable antiforms, and <code>Atom</code> that can hold anything--including unstable isotopes.</p>
<ul>
<li>
<p><strong>Class Hierarchy:</strong> Atom as base, Value derived, Element derived (upside-down for compile-time error preferences--we want passing an Atom to a routine that expects only Element to fail)</p>
</li>
<li>
<p><strong>Primary Goal:</strong> Prevent passing Atoms/Values to Element-only routines, or Atoms to Value-only routines.</p>
</li>
<li>
<p><strong>Secondary Goal:</strong> Prevent things like passing Element cells to writing routines that may potentially produce antiforms in that cell.</p>
</li>
<li>
<p><strong>Tertiary Goal:</strong> Detect things like superfluous <code>Is_Antiform()</code> calls being made on Elements.</p>
</li>
</ul>
<p>The primary goal is achieved by choosing Element as a most-derived type instead of a base type.</p>
<p>The next two goals are somewhat maddeningly trickier... <img src="https://forum.rebol.info/images/emoji/twitter/pouting_cat.png?v=12" title=":pouting_cat:" class="emoji" alt=":pouting_cat:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-7886-sink-and-need-2" class="anchor" href="https://forum.rebol.info#p-7886-sink-and-need-2"></a><code>Sink(...)</code> and <code>Need(...)</code></h2>
<p>The idea behind a Sink() is to be able to mark on a function's interface when a function argument passed by pointer is intended as an output.</p>
<p>This has benefits of documentation, and can also be given some teeth by scrambling the memory that the pointer points at (so long as it isn't an "in-out" parameter).  But it also applied in CHECK_CELL_SUBCLASSES, by enforcing "covariance" for input parameters, and "contravariance" for output parameters.</p>
<p>If USE_CELL_SUBCLASSES is enabled, then the inheritance heirarchy has Atom at the base, with Element at the top.  Since what Elements can contain is more constrained than what Atoms can contain, this means you can pass Atom* to Element*, but not vice-versa.</p>
<p>However, when you have a Sink(Element) parameter instead of an Element*, the checking needs to be reversed.  You are -writing- an Element, so the receiving caller can pass an Atom* and it will be okay.  But if you were writing an Atom, then passing an Element* would not be okay, as after the initialization the Element could hold invalid states.</p>
<p>We use "SFINAE" to selectively enable the upside-down hierarchy, based on the <code>std::is_base_of&lt;&gt;</code> type trait.</p>
<h2><a name="p-7886-the-code-in-the-c-debug-build-3" class="anchor" href="https://forum.rebol.info#p-7886-the-code-in-the-c-debug-build-3"></a>The Code (in the C++ Debug Build)</h2>
<pre><code>template&lt;typename T, bool sink&gt;
struct NeedWrapper {
    T* p;
    mutable bool corruption_pending;  // can't corrupt on construct

  //=//// TYPE ALIASES ////////////////////////////////////////////////=//

    using MT = typename std::remove_const&lt;T&gt;::type;

    template&lt;typename U&gt;  // contravariance
    using IsReverseInheritable = typename std::enable_if&lt;
        std::is_same&lt;U,T&gt;::value or std::is_base_of&lt;U,T&gt;::value
    &gt;::type;

  //=//// CONSTRUCTORS ////////////////////////////////////////////////=//

    NeedWrapper() = default;  // or MSVC warns making Option(Sink(Value))

    NeedWrapper(nullptr_t) {
        p = nullptr;
        corruption_pending = false;
    }

    NeedWrapper (const NeedWrapper&lt;T,sink&gt;&amp; other) {
        p = other.p;
        corruption_pending = p and (other.corruption_pending or sink);
        other.corruption_pending = false;
    }

    template&lt;typename U, IsReverseInheritable&lt;U&gt;* = nullptr&gt;
    NeedWrapper(U* u) {
        p = u_cast(T*, u);
        corruption_pending = p and sink;
    }

    template&lt;typename U, bool B, IsReverseInheritable&lt;U&gt;* = nullptr&gt;
    NeedWrapper(const NeedWrapper&lt;U, B&gt;&amp; other) {
        p = u_cast(T*, other.p);
        corruption_pending = p and (other.corruption_pending or sink);
        other.corruption_pending = false;
    }

  //=//// ASSIGNMENT //////////////////////////////////////////////////=//

    NeedWrapper&amp; operator=(nullptr_t) {
        p = nullptr;
        corruption_pending = false;
        return *this;
    }

    NeedWrapper&amp; operator=(const NeedWrapper&lt;T,sink&gt; other) {
        if (this != &amp;other) {  // self-assignment possible
            p = other.p;
            corruption_pending = p and (other.corruption_pending or sink);
            other.corruption_pending = false;
        }
        return *this;
    }

    template&lt;typename U, IsReverseInheritable&lt;U&gt;* = nullptr&gt;
    NeedWrapper&amp; operator=(const NeedWrapper&amp; other) {
        if (this != &amp;other) {  // self-assignment possible
            p = other.p;
            corruption_pending = p and (other.corruption_pending or sink);
            other.corruption_pending = false;
        }
        return *this;
    }

    template&lt;typename U, IsReverseInheritable&lt;U&gt;* = nullptr&gt;
    NeedWrapper&amp; operator=(U* other) {
        p = u_cast(T*, other);
        corruption_pending = p and sink;
        return *this;
    }

  //=//// OPERATORS ///////////////////////////////////////////////////=//

    operator bool () const { return p != nullptr; }

    operator T* () const {
        if (corruption_pending) {
            Corrupt_If_Debug(*const_cast&lt;MT*&gt;(p));
            corruption_pending = false;
        }
        return p;
    }

    T* operator-&gt;() const {
        if (corruption_pending) {
            Corrupt_If_Debug(*const_cast&lt;MT*&gt;(p));
            corruption_pending = false;
        }
        return p;
    }

  //=//// DESTRUCTOR //////////////////////////////////////////////////=//

    ~NeedWrapper() {
        if (corruption_pending)
            Corrupt_If_Debug(*const_cast&lt;MT*&gt;(p));
    }
};
</code></pre>
<p>So then the <code>Sink(...)</code> and non-corrupting version <code>Need(...)</code> for in/out parameters with contravariance checking are:</p>
<pre><code>#define Sink(T) \
    NeedWrapper&lt;T, true&gt;

#define Need(TP) \
    NeedWrapper&lt;typename std::remove_pointer&lt;TP&gt;::type, false&gt;
</code></pre>
<h2><a name="p-7886-notes-on-corrupting-4" class="anchor" href="https://forum.rebol.info#p-7886-notes-on-corrupting-4"></a>Notes on Corrupting</h2>
<p>The original implementation was simpler, by just doing the corruption at the moment of construction.</p>
<p>But this faced a problem:</p>
<pre><code>    bool some_function(Sink(char*) out, char* in) { ... }

    if (some_function(&amp;ptr, ptr)) { ...}
</code></pre>
<p>If you corrupt the data at the address the sink points to, you can actually be corrupting the value of a stack variable being passed as another argument before it's calculated as an argument.  So deferring the corruption after construction is necessary.  It's a bit tricky in terms of the handoffs and such.</p>
<p><em>(While this could be factored, function calls aren't inlined in the debug build, so given the simplicity of the code, it's repeated.)</em></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/antiform-safety-covariance-and-contravariance/2330">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/antiform-safety-covariance-and-contravariance/2330</link>
          <pubDate>Mon, 11 Nov 2024 09:49:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2330</guid>
          <source url="https://forum.rebol.info/t/antiform-safety-covariance-and-contravariance/2330.rss">Antiform Safety: Covariance and Contravariance</source>
        </item>
        <item>
          <title>Full-Band Return Values from Generators/Yielders</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>Definitional Errors came into PARSE as an answer for how to make it possible to return any value... simply make a failed parse a definitional error.  Not only does it mean that NULL can be a legitimate synthesized product that you don't conflate with failure, but it also means that parse failures can give back more information in the error about what went wrong <em>(farthest parse point reached, etc.)</em>...</p>
<p>Looking at another problem where a sentinel NULL had been used... there's <a href="https://forum.rebol.info/t/yielder-and-generator-and-thinking-about-coroutines/1311">Generators and Yielders</a>:</p>
<pre><code>&gt;&gt; g: generator [print "A" yield 1, print "B" yield 2, print "C"]

&gt;&gt; g
A
== 1

&gt;&gt; g
B
== 2

&gt;&gt; g
C
== ~null~  ; anti

&gt;&gt; g
== ~null~  ; anti

&gt;&gt; g
== ~null~  ; anti
</code></pre>
<p>But Generators and Yielders predate antiforms in general... they came at a time where there were just two forms of NULL: "heavy" and "light".  So the thought was that if you wanted to actually yield null, it would be the heavy form.</p>
<pre><code>&gt;&gt; g: generator ["Start", yield null, print "Done"]

&gt;&gt; g
Start
== ~[~null~]~  ; anti

&gt;&gt; g
Done
== ~null~  ; anti
</code></pre>
<p>But this isn't nearly as good as using a specific raised error.  If NULL is truly out of band, then you could use <strong><code>try g</code></strong> to get null when there are no more values.</p>
<p>If you try to YIELD or RETURN a raised error, then it would become an abrupt failure.  So you'd be assured that the only time you'd ever get a definitional error back from a generator or yielder would be if it had been exhausted.</p>
<h2><a name="p-7884-pack-returns-for-things-like-key-and-value-in-objects-1" class="anchor" href="https://forum.rebol.info#p-7884-pack-returns-for-things-like-key-and-value-in-objects-1"></a>PACK returns for things like KEY and VALUE in objects?</h2>
<p>As the enumeration routines are retooled to be based on generator functions, it struck me as very cool if generators returned packs, which could be decayed:</p>
<pre><code>&gt;&gt; obj: make object! [a: 10 b: 20 c: 30]

&gt;&gt; g: each obj

&gt;&gt; g
; first in pack of 2 items
== a

&gt;&gt; meta g
== ~['b '20]~

&gt;&gt; [key {val}]: g
== 30

&gt;&gt; key
== c

&gt;&gt; g
** Error: Generator/Yielder exhausted

&gt;&gt; try g
== ~null~  ; anti
</code></pre>
<p>That's really cool, and seems like it would go along with decaying:</p>
<pre><code>for 'key each obj [...]

for [key val] each obj [...]
</code></pre>
<p>This looks pretty nice, however blocks used in FOR-EACH scenarios like this haven't meant "unpack", it has meant keep getting items and assign them to each.</p>
<p>It seems like it would be unfortunate if you had to write the object unpacking as:</p>
<pre><code>for [~[key val]~] each obj [...]
</code></pre>
<p>But that does seem sort of like what you'd have to do in order to make it generalized.  It doesn't look <em>that</em> bad, and it does have a theory behind it...</p>
<pre><code>&gt;&gt; obj: make object! [a: 10 b: 20 c: 30]

&gt;&gt; for [~[key val]~ :otherkey] each obj [  ; leading colon for optionality
       print ["key:" key]
       print ["val:" val]
       if otherkey [
           print ["otherkey:" otherkey]
       ]
   ]

key: a
val: 10
otherkey: b
key: c
val: 30
</code></pre>
<p>This assumes that plain blocks might be taken for some other intent in the FOR.  If it were not:</p>
<pre><code>for [[key val] :otherkey] each obj [...]
</code></pre>
<p>But I had been thinking that plain BLOCK! would likely be good for type checking (<span class="mention">@hiiamboris</span> has some experiments in this vein):</p>
<pre><code>for [x [integer!] y [tag!]] each [1 &lt;a&gt; 2 &lt;b&gt;] [....]
</code></pre>
<h2><a name="p-7884-big-design-space-but-full-band-returns-opens-it-up-2" class="anchor" href="https://forum.rebol.info#p-7884-big-design-space-but-full-band-returns-opens-it-up-2"></a>Big Design Space, but Full-Band Returns Opens It Up</h2>
<p>I'd let the Generator and Yielder experiments atrophy while working on other things.  But I stopped today to try and get the basics working again, and it's interesting to see how isotopes bring a lot to the table...as they seem to have done with nearly everything.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/full-band-return-values-from-generators-yielders/2329">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/full-band-return-values-from-generators-yielders/2329</link>
          <pubDate>Sun, 10 Nov 2024 19:25:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2329</guid>
          <source url="https://forum.rebol.info/t/full-band-return-values-from-generators-yielders/2329.rss">Full-Band Return Values from Generators/Yielders</source>
        </item>
        <item>
          <title>TAG!s Angle Brackets: *They Aren&#39;t There!*</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Implementation-wise, the delimiters of tag have been quite the thorn.</p>
<p>Are they there or not?</p>
<p>In Rebol2, Red, R3-Alpha...</p>
<pre><code>&gt;&gt; find &lt;abcd&gt; "c"
== &lt;cd&gt;

&gt;&gt; find &lt;abcd&gt; "&gt;"
== none
</code></pre>
<p>Not there!</p>
<p>Or are they?  Reverse the arguments, and in Rebol2 and Red, they seem to magically appear:</p>
<pre><code>&gt;&gt; find "ab&lt;c&gt;d" &lt;c&gt;
== "&lt;c&gt;d"
</code></pre>
<p>But... this was not the case in R3-Alpha...</p>
<pre><code>r3-alpha&gt;&gt; find "abcd" &lt;c&gt;
== "cd"

r3-alpha&gt;&gt; find "ab&lt;c&gt;d" &lt;c&gt;
== "c&gt;d"
</code></pre>
<p>I know things have gone back and forth with people believing deeply in their little hearts that they are happier when routines act like the delimiters are there...</p>
<p>But for the baseline behavior: <em>I have come to believe R3-Alpha is right.</em>  They're string delimiters, and incidental to the default purpose, just as quotes are.</p>
<p>If you start looking at TAG! as it truly is--just another string class with different delimiters--it simplifies the mental model and the implementation model.  You can truly just use it like another string, and it suddenly becomes consistent.</p>
<p>Of course, it's still nice to be able to match the molded form of a tag.</p>
<p>But... why stop at tags? <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"> Why not have a syntax to match the molded form of anything?</p>
<p>In strings, where you can't match list elements literally anyway:</p>
<pre><code>&gt;&gt; parse "&lt;a&gt; 100 (b c)" ['&lt;a&gt; space '100 space '(b c)]
== (b c)
</code></pre>
<p>(The synthesized product may be more interesting, too.  As a reminder, Ren-C has taken words that might be better as variable names like END and uses plain tag as  instead, or  to synthesize the parse input, etc.)</p>
<pre><code>&gt;&gt; parse "&lt;end&gt; asdf" ['&lt;end&gt; to &lt;end&gt; &lt;input&gt;]
== "&lt;end&gt; asdf"
</code></pre>
<p>I don't know whether that is best done as just a PARSE feature, or if quoted things need to be searched for literally by FIND.</p>
<pre><code>&gt;&gt; find "ab&lt;c&gt;d" &lt;c&gt;
== "c&gt;d"

&gt;&gt; quote &lt;c&gt;
== '&lt;c&gt;

&gt;&gt; find "ab&lt;c&gt;d" quote &lt;c&gt;
== "&lt;c&gt;d"

&gt;&gt; find "ab&lt;c&gt;d" mold &lt;c&gt;  ; one fewer character
== "&lt;c&gt;d"
</code></pre>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/tag-s-angle-brackets-they-arent-there/2326">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/tag-s-angle-brackets-they-arent-there/2326</link>
          <pubDate>Fri, 08 Nov 2024 18:12:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2326</guid>
          <source url="https://forum.rebol.info/t/tag-s-angle-brackets-they-arent-there/2326.rss">TAG!s Angle Brackets: *They Aren&#39;t There!*</source>
        </item>
        <item>
          <title>Embracing A &quot;Useless&quot; Definition of TO</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Many years ago, I thought about <strong><a href="https://forum.rebol.info/t/hacking-away-on-the-to-and-make-matrix/649">trying to untangle of the TO and MAKE matrix</a></strong>.  These operations are notoriously unpredictable in historical Redbol.</p>
<p>I tried putting some stakes in the ground about what I believed <em>had</em> to be true.  It was difficult because I could not think of too many.</p>
<p>One thing I said was that TO should always create a "new" value (if the value was not immediate).  And I felt like this should be true:</p>
<pre><code>to (type of value) value
; ...same as...
copy value
</code></pre>
<p>Grasping for any stake in the ground I could find, I was pretty sure that TO of a string representation of an integer to an integer should give you the integer:</p>
<pre><code>&gt;&gt; to integer! "1020"
== 1020  ; we know this, at least? (one hopes...)
</code></pre>
<p>And the reverse, one would think, as well:</p>
<pre><code>&gt;&gt; to text! 1020
== "1020"  ; what else *could* it be?  codepoint 1020? -&gt; "ϼ"
</code></pre>
<p>But beyond that it was hard to think of the pattern.</p>
<h2><a name="p-7876-coming-back-to-an-old-idea-reversibility-1" class="anchor" href="https://forum.rebol.info#p-7876-coming-back-to-an-old-idea-reversibility-1"></a>Coming Back To An Old Idea: Reversibility</h2>
<p>When I first encountered Rebol and was made aware of these problems, I suggested TO should be reversible:</p>
<pre><code>value1 = to (type of value1) to type2 value1
</code></pre>
<p>However, this gave what <em>appeared</em> to be very "unexciting" options for behavior:</p>
<pre><code>&gt;&gt; to block! 1
== [1]

&gt;&gt; to integer! [1]
== 1

&gt;&gt; to integer! [...anything else in a block that's not integer...]
** Error.  Always.
</code></pre>
<p>That particular idea was was so long ago that I don't have direct quotes on hand of people saying "nah, that sucks, TO could barely do anything."  But I'm pretty sure it was panned by basically everyone I suggested it to.  I guess I agreed, because I dropped it.</p>
<p><strong>Coming back to it now, and seeing it in a new light, I see this as much more useful than I used to.</strong>  Especially when compared to the historical mess that makes TO nigh-unusable.</p>
<p>And in fact, it fits in with several Rebol2/Red behaviors that I'd thought were kind of pointless before:</p>
<pre><code>&gt;&gt; to integer! &lt;1&gt;
== 1

&gt;&gt; to tag! 1
== &lt;1&gt;
</code></pre>
<p>The use I didn't see at the time was the frequent need when dialecting to push values out of band, into some other type, without losing their meaning.  If you have a dialect in which integers already mean something, but you want a way of pushing some integer-oriented instruction in there...you can use these kinds of operations.</p>
<p>Definitional errors in Ren-C make this convenient, since checking if something fits the pattern is quick, you just throw in a TRY and the antiform error that's the return result of the TO will be suppressed, giving you a "falsey" null:</p>
<pre><code>&gt;&gt; thing: &lt;a b&gt;

&gt;&gt; to integer! thing
** Error: Cannot TO convert &lt;a b&gt; to integer

&gt;&gt; try to integer! thing
== ~null~  ; anti
</code></pre>
<p>The more I look at it the more useful it appears.  And it helps give clarity to the MAKE vs. TO division.  If you have something that isn't shaped like this, then <em>maybe</em> MAKE is the right place to put it.  For example:</p>
<pre><code>&gt;&gt; to percent! 1
== 1%

&gt;&gt; to integer! 1%
== 1

&gt;&gt; make percent! 1
== 100%
</code></pre>
<p><em>(Note: I think ENCODE + DECODE is a better place for binary conversions, e.g. ENCODE 'IEEE-754 is better than MAKE BINARY! of a decimal because that could mean many things, and ENCODE can have more parameterization for single vs. double precision, etc.  I don't know<br>
if TO BINARY! should work at all, but if it does, I'd probably agree with the Rebol2 choice to give the binary representation of the UTF-8 string... e.g. (to binary! 1020) as #{31303230} ... and use more explicit future-proof routines to encode with specified byte size and endianness.)</em></p>
<h2><a name="p-7876-reversibility-rules-out-rounding-2" class="anchor" href="https://forum.rebol.info#p-7876-reversibility-rules-out-rounding-2"></a>Reversibility Rules Out Rounding</h2>
<p>In order to get losslessness in the representation, you can't throw out information.</p>
<p>So this works:</p>
<pre><code>&gt;&gt; to integer! 1.0
== 1

&gt;&gt; to decimal! 1
== 1.0
</code></pre>
<p>But this does not:</p>
<pre><code> &gt;&gt; to integer! 1.5
 ** Error: Can't TO INTEGER! a DECIMAL! w/digits after decimal point
</code></pre>
<p>I don't think that's a problem, because that seems like a job for ROUND.  Unfortunately, R3-Alpha and Red do something dumb:</p>
<pre><code>rebol2&gt;&gt; round 1.5
== 2

red&gt;&gt; round 1.5
== 2.0

r3-alpha&gt;&gt; round 1.5
== 2.0
</code></pre>
<p>It seems this was part of a shift to try and preserve the input type, to facilitate things like rounding MONEY!:</p>
<pre><code>r3-alpha&gt;&gt; round $1.50
== $2
</code></pre>
<p>So I guess the way the thinking went was that if you want to keep MONEY! as MONEY! when you round it, all types should act that way.</p>
<p>I think the relationship between INTEGER! and DECIMAL!, which lack decoration, suggests something more intimate where the type can be lost.  If you don't want to lose it, ROUND:TO 1.0</p>
<pre><code>&gt;&gt; round 1.5
== 2

&gt;&gt; round:to 1.5 1
== 2

&gt;&gt; round:to 1.5 1.0
== 2.0
</code></pre>
<h2><a name="p-7876-blank-pretty-much-has-to-mean-empty-3" class="anchor" href="https://forum.rebol.info#p-7876-blank-pretty-much-has-to-mean-empty-3"></a>BLANK! Pretty Much Has To Mean Empty</h2>
<p>If we're talking about equivalencies, we now know this:</p>
<pre><code>&gt;&gt; for-each 'x _ [print "Doesn't run"]
== ~void~  ; anti

&gt;&gt; empty? _
== ~okay~  ; anti
</code></pre>
<p>And so really, it seems that the TO conversion of BLANK! has only one set of answers to fit into the family of reversibility:</p>
<pre><code>&gt;&gt; to block! _
== []

&gt;&gt; to text! _
== ""

&gt;&gt; to blank! &lt;&gt;
== _

&gt;&gt; to blank! #{}
== _
</code></pre>
<p>And if you try to TO BLANK! anything that's not conceptually empty, you'd get an error.</p>
<pre><code>&gt;&gt; to blank! &lt;a&gt;
** Error: ...
</code></pre>
<p>I don't know if there's a motivating case for saying <strong>to integer! _</strong> should pick something like 0 as an answer, though Rebol2 did something of that sort:</p>
<pre><code>rebol2&gt;&gt; to integer! none
== 0
</code></pre>
<p>Neither Red nor R3-Alpha carried that forward, <a href="https://github.com/metaeducation/rebol-issues/issues/1018">though it was discussed</a></p>
<h2><a name="p-7876-can-be-checked-in-the-implementation-4" class="anchor" href="https://forum.rebol.info#p-7876-can-be-checked-in-the-implementation-4"></a>Can Be Checked In The Implementation</h2>
<p>I've started hacking this through, and it's gone relatively well.  TO dispatches <em><strong>to the type it's converting from</strong></em>, with the type being converted to as the argument.</p>
<p>And it's nice in the sense that the TO native driving the process can also check the reversibility constraint in the debug build, to give it some teeth.</p>
<p><em>(I've rigged up some interesting frame mechanics to enable doing this reversal efficiently, that have sped up other parts of the system (like CASCADE) with "downlevel shifting", that can bypass a trampoline bounce...)</em></p>
<p>Anyway, things are a mess right now with a couple hundred broken tests to painfully sift through.  But I think the reversibility rule is good... biggest questions are whether that relaxes in terms of spacing...</p>
<pre><code>&gt;&gt; to block! "  1    2  "
== [1 2]  ; legal?
</code></pre>
<p>This would suggest you would have to compare with the trimmed/canonized version of your input.</p>
<p>Also, issues of string representations.</p>
<pre><code>&gt;&gt; b: to block! "--{1}--"
== ["1"]  ; legal?
</code></pre>
<p>So there are some pain points, but chipping away at them.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/embracing-a-useless-definition-of-to/2325">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/embracing-a-useless-definition-of-to/2325</link>
          <pubDate>Fri, 08 Nov 2024 17:57:07 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2325</guid>
          <source url="https://forum.rebol.info/t/embracing-a-useless-definition-of-to/2325.rss">Embracing A &quot;Useless&quot; Definition of TO</source>
        </item>
        <item>
          <title>Old Idea Revisited: DATATYPE as... Antiform?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>I've been suffering through an attempt to bring sanity to bear upon the MAKE and TO matrix.</p>
<p>While doing so, I noticed that there are a lot of MAKE instructions that do "joining".</p>
<p>In R3-Alpha and Red:</p>
<pre><code>&gt;&gt; make binary! [1 2 #{DECAFBAD} 3 4]   
== #{0102DECAFBAD0304}
</code></pre>
<p>Historical MAKE is so arbitrary in how it interprets its arguments that it made me feel that it would be better if JOIN allowed a datatype as its first argument...</p>
<p>JOIN typically makes a new series out of what you give it:</p>
<pre><code>&gt;&gt; bin: #{AABB}

&gt;&gt; join bin #{CCDD}
== #{AABBCCDD}  ; made new series, didn't impact BIN

&gt;&gt; bin
== #{AABB}
</code></pre>
<p>But if you could pass a datatype as the first argument, you could relieve MAKE of the behavior...and make it clearer in the source what's actually happening:</p>
<pre><code>&gt;&gt; join binary! [1 2 #{DECAFBAD} 3 4]
== #{0102DECAFBAD0304}
</code></pre>
<p>Since that seemed nice, I started to map it out, and ran into a bit of a problem:</p>
<p><strong>If "datatypes" are an ANY-WORD! or ANY-LIST! or anything like that, how do you know you're not trying to JOIN with it?</strong></p>
<p>A WORD! should be able to join:</p>
<pre><code>&gt;&gt; join 'var 10
== var10
</code></pre>
<p>A BLOCK! should be able to join...</p>
<pre><code>&gt;&gt; join [a b] 10
== [a b 10]
</code></pre>
<p>Okay, but when you say <strong>join binary!</strong> what is BINARY!?  Well right now, it's:</p>
<pre><code>&gt;&gt; binary!
== &amp;[binary]
</code></pre>
<p>Well that looks like it's in-band for the kinds of things JOIN operates on:</p>
<pre><code>&gt;&gt; join &amp;[binary] 10
== &amp;[binary 10]
</code></pre>
<h2><a name="p-7875-an-antiform-would-push-datatype-out-of-band-1" class="anchor" href="https://forum.rebol.info#p-7875-an-antiform-would-push-datatype-out-of-band-1"></a>An Antiform Would Push DATATYPE? Out-Of-Band...</h2>
<p>It's possible that we could come up with a new non-antiform for types.  But the lexical space is extremely saturated.</p>
<p>If we were just reaching for something on the basis of looks, antiform FENCE! is nice:</p>
<pre><code>&gt;&gt; binary!
== ~{binary}~  ; anti
</code></pre>
<h2><a name="p-7875-this-has-come-up-before-2" class="anchor" href="https://forum.rebol.info#p-7875-this-has-come-up-before-2"></a>This Has Come Up Before...</h2>
<p>Historical Rebol let you use datatypes in FIND:</p>
<pre><code>rebol2&gt;&gt; find [a b c 10 20] integer! 
== [10 20]
</code></pre>
<p>But then this conflates with when you actually literally have the INTEGER! datatype in the block.</p>
<pre><code>&gt;&gt; find compose [a (integer!) b c 10 20] integer!
== [integer! b c 10 20]
</code></pre>
<p>So in the early days of antiforms, I proposed antiform datatypes as a solution... but at that time I was thinking that there'd be non-antiform DATATYPE!, and it's just that when it was an antiform it would be a "MATCHER".</p>
<p>The proposal I'm thinking of now is different, in saying that DATATYPE? only exists as a (stable) antiform state.</p>
<p>There are tradeoffs, in that datatypes can't be put in blocks directly.  But the mechanics of working with quasiforms and antiforms via things like REIFY and DEGRADE are much smoother now.  And really, putting datatypes in blocks doesn't happen that often (I've had to put splices in blocks but really never datatypes).</p>
<p>Being completely out of band with things you can find in a block has advantages.  JOIN isn't unique in reaping benefits from being able to say that datatypes aren't things.</p>
<p>And it unifies datatypes with typecheckers being antiforms, because typecheckers are frame antiforms, e.g. actions:</p>
<pre><code>&gt;&gt; find [1 3 5 8 10] even?/
; first in pack of length 2
== [8 10]
</code></pre>
<p>So I don't think it's a crazy idea.</p>
<p>I'm hesitant to surrender FENCE! antiforms to the purpose so soon after their invention.  But there isn't anything undecorated left.</p>
<p>Not that "no decorated antiforms" is some unbreakable rule, it was a guideline.</p>
<p>Using &amp; would put it in the family of TYPE-XXX! and be cheaper than FENCE! if you made new instances:</p>
<pre><code>&gt;&gt; binary!
== ~&amp;binary~  ; anti
</code></pre>
<p>A random bad idea would be to make them keywords, and just have DATATYPE? be smart enough to filter out ~null~ or ~void~ or ~okay~ or whatever else (the symbol could carry a flag)</p>
<pre><code>&gt;&gt; binary!
== ~binary~  ; anti

&gt;&gt; null
== ~null~  ; anti

&gt;&gt; datatype? binary!
== ~okay~  ; anti

&gt;&gt; datatype? null
== ~null~  ; anti
</code></pre>
<p>I can pretty clearly say that's bad.</p>
<h2><a name="p-7875-or-pick-some-non-antiform-notation-3" class="anchor" href="https://forum.rebol.info#p-7875-or-pick-some-non-antiform-notation-3"></a>Or, Pick Some Non-Antiform Notation</h2>
<p>Status quo might look like:</p>
<pre><code>&gt;&gt; binary!
== #[binary]
</code></pre>
<p>Despite it looking sort of like a block, it wouldn't be.  But we're squandering some of our notational space no matter what.  The <strong><code>~&amp;type~</code></strong> is the discount route.</p>
<h2><a name="p-7875-either-way-datatype-cant-be-any-word-or-any-list-4" class="anchor" href="https://forum.rebol.info#p-7875-either-way-datatype-cant-be-any-word-or-any-list-4"></a>Either Way, DATATYPE? Can't be ANY-WORD! or ANY-LIST!</h2>
<p>It needs to be out of band one way or another.  I'll have to think about it.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/old-idea-revisited-datatype-as-antiform/2324">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/old-idea-revisited-datatype-as-antiform/2324</link>
          <pubDate>Fri, 08 Nov 2024 17:05:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2324</guid>
          <source url="https://forum.rebol.info/t/old-idea-revisited-datatype-as-antiform/2324.rss">Old Idea Revisited: DATATYPE as... Antiform?</source>
        </item>
        <item>
          <title>ENHEX and DEHEX testing, another &quot;Micro-Dialect&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Testing</category>
          <description><![CDATA[
            <p>Here's a little excerpt of testing <strong><a href="https://en.wikipedia.org/wiki/Percent-encoding">Percent Encoding</a></strong> <em>(which Rebol gives the poor names ENHEX and DEHEX to, and should probably be changed)</em>.</p>
<p>It started out just as a table of encoded and decoded forms, e.g.</p>
<pre><code>for-each [encoded decoded] [
    "a%20b" "a b"
    "a%25b" "a%b"
    "a%ce%b2c" "aβc"
    ...
][
   ; test that it decodes
]
</code></pre>
<p>But the encoding produces uppercase hex digits (per <a href="https://datatracker.ietf.org/doc/html/rfc3986">RFC 3896</a>), while the decoding tolerates lowercase ones.  So you don't get the same thing back.</p>
<p>That led me to the "whimsical" choice to denote reversible <strong><code>&lt;-&gt;</code></strong> and non-reversible <strong><code>-&gt;</code></strong> transforms:</p>
<pre><code>"a%25b" &lt;-&gt; "a%b"
"a%ce%b2c" -&gt; "aβc" -&gt; "a%CE%B2c"
</code></pre>
<p>This is strange in that <strong><code>-&gt;</code></strong> is a WORD!, while <strong><code>&lt;-&gt;</code></strong> is a TAG! (and I believe this is the correct design choice when all is said and done).</p>
<p>But in a dialect, having something <em>look like what you want</em> can be enough, as it's just being looked for literally.</p>
<p>I threw in an additional wrinkle by letting BLOCK! with an INTEGER! in it serve as a comment.  It looks visually better than having to throw in a semicolon.</p>
<p>It's satisfying when such things can be done in a matter of a few minutes:</p>
<pre><code>; 1. Accept lowercase, but canonize to uppercase, per RFC 3896 2.1
;
; 2. A case can be made for considering the encoding of characters that
;    don't need it to be an error by default.
;
parse compose [
    "a%20b" &lt;-&gt; "a b"
    "a%25b" &lt;-&gt; "a%b"
    "a%ce%b2c" -&gt; "aβc" -&gt; "a%CE%B2c"  [1]
    "%2b%2b" -&gt; "++" -&gt; "++"  [2]
    "a%2Bb" -&gt; "a+b" -&gt; "a+b"  [2]
    "a%62c" -&gt; "abc" -&gt; "abc"  [2]
    "a%CE%B2c" &lt;-&gt; "aβc"
    (as text! #{2F666F726D3F763D254335253939}) -&gt; "/form?v=ř"
][ some [
    let encoded: text!
    let arrow: ['&lt;-&gt; | '-&gt;]
    let decoded: text!
    let re-encoded: [when (arrow = '-&gt;) ['-&gt; text!] | (encoded)]
    optional block!  ; headnote comment
    (
        let de: dehex encoded
        if de != decoded [
            fail ["Decode of" @encoded "gave" @de "expected" @decoded]
        ]
        let en: enhex decoded
        if en != re-encoded [
            fail ["Encode of" @decoded "gave" @en "expected" @re-encoded]
        ]
    )
]]
</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/enhex-and-dehex-testing-another-micro-dialect/2323">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/enhex-and-dehex-testing-another-micro-dialect/2323</link>
          <pubDate>Fri, 08 Nov 2024 16:10:52 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2323</guid>
          <source url="https://forum.rebol.info/t/enhex-and-dehex-testing-another-micro-dialect/2323.rss">ENHEX and DEHEX testing, another &quot;Micro-Dialect&quot;</source>
        </item>
        <item>
          <title>Much Ado About A Tiny Email Test &quot;Micro-Dialect&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Testing</category>
          <description><![CDATA[
            <p>So there was a "micro dialect" for email address scanning.  A simple idea that you could intermix valid and invalid email addresses...to put groups of related emails together even though some in the group would fail and others would succeed.</p>
<p>It was something along these lines:</p>
<pre><code>for-each [mode text] [
    + {email@example.com}
    + {firstname.lastname@example.com}
    - {email@example@example.com}
    + {email@subdomain.example.com}
    + {firstname+lastname@example.com}
    - {email@example.com}
    + {email@123.123.123.123}
    - {email@[123.123.123.123]}
    ...
 ][
    assert [mode: select [+ valid - invalid] mode]
    if (mode = 'valid) != test-scan-email (...) [
        fail ["Expected" @text "to be" an mode "email"]
    ]
 ]
</code></pre>
<p>But for this post, I threw in a couple of "hey that's neat" aspects, like:</p>
<pre><code>&gt;&gt; an "valid"
== "a valid"

&gt;&gt; an "invalid"
== "an invalid"
</code></pre>
<h2><a name="p-7845-enter-dashed-strings-1" class="anchor" href="https://forum.rebol.info#p-7845-enter-dashed-strings-1"></a>Enter Dashed Strings</h2>
<p>I don't know that the <strong><code>+</code></strong> and <strong><code>-</code></strong> markers were ever the greatest, but they certainly lost their appeal with dashed strings.</p>
<pre><code>    + -{email@example.com}-
    + -{firstname.lastname@example.com}-
    - -{email@example@example.com}-
    + -{email@subdomain.example.com}-
</code></pre>
<p>At first I figured I'd just pick an alternative.  There's Y and N...</p>
<pre><code>    Y -{email@example.com}-
    Y -{firstname.lastname@example.com}-
    N -{email@example@example.com}-
    Y -{email@subdomain.example.com}-
</code></pre>
<p>Those are pretty big letterforms that blur together some.  Tilde for trash to differentiate carries the connotation of "something wrong"...</p>
<pre><code>    Y -{email@example.com}-
    Y -{firstname.lastname@example.com}-
    ~ -{email@example@example.com}-
    Y -{email@subdomain.example.com}-
</code></pre>
<p>...but it blurs here too much with the dash.</p>
<p><strong>Really we can ask: why are we decorating the valid things, and not just the invalid things?</strong></p>
<pre><code>      -{email@example.com}-
      -{firstname.lastname@example.com}-
    # -{email@example@example.com}-
      -{email@subdomain.example.com}-
</code></pre>
<p>You could use <strong><code>N</code></strong> or <strong><code>*</code></strong> or <strong><code>#</code></strong> or any other nasty here, and it sort of stands out.  Not as well as <strong><code>&lt;bad&gt;</code></strong> would.</p>
<pre><code>      -{email@example.com}-
      -{firstname.lastname@example.com}-
&lt;bad&gt; -{email@example@example.com}-
      -{email@subdomain.example.com}-
</code></pre>
<p><strong>But if you're going to break the regularity of the structure, you can't use (today's) FOR-EACH.</strong></p>
<p>If you want to regularize it a bit, you could use something like BLOCK! to mark the bad ones:</p>
<pre><code>      -{email@example.com}-
      -{firstname.lastname@example.com}-
     [-{email@example@example.com}-]
      -{email@subdomain.example.com}-
</code></pre>
<p>If that didn't stand out enough, you could use a double-block:</p>
<pre><code>      -{email@example.com}-
      -{firstname.lastname@example.com}-
    [[-{email@example@example.com}-]]
      -{email@subdomain.example.com}-
</code></pre>
<p>It's worth remembering such things are options in some cases, but I don't think that works very well here.</p>
<h2><a name="p-7845-bad-seems-good-but-could-it-be-easier-2" class="anchor" href="https://forum.rebol.info#p-7845-bad-seems-good-but-could-it-be-easier-2"></a><code>&lt;bad&gt;</code> Seems Good, But Could It Be Easier?</h2>
<p>It would be nice if there were some way to type the FOR-EACH variables, and denote their optionality.</p>
<p><span class="mention">@hiiamboris</span> has done some things in this vein, see his <a href="https://codeberg.org/hiiamboris/red-common/src/branch/master/foreach-design.md">type filter on FOR-EACH proposal</a>.  I feel like the concept of skipping and checking should be separate intents.  I can want to type check something but not want to skip it.</p>
<p>A leading colon could imply optionality, as it does with refinements now:</p>
<pre><code>for-each [:bad [tag!] text [text!]] [
        -{email@example.com}-
        -{firstname.lastname@example.com}-
  &lt;bad&gt; -{email@example@example.com}-
        -{email@subdomain.example.com}-
        ...
][
    ...
]
</code></pre>
<p>You can even use <code>&lt;bad&gt;</code> itself for the type check by quoting it, and enforce/document that more stringently.  Also, for the sake of "how does that look in the generator model" I'll write it out that way:</p>
<pre><code>for [:bad ['&lt;bad&gt;] text [text!]] each [
        -{email@example.com}-
        -{firstname.lastname@example.com}-
  &lt;bad&gt; -{email@example@example.com}-
        -{email@subdomain.example.com}-
        ...
][
    ...
]
</code></pre>
<p>Of course you can split this out to a table vs. having the tests inline like that.</p>
<p>Interpreting blocks as type checks seems pretty useful, but that takes away from some other applications which might be used for destructuring.</p>
<p>Anyway, this is just some thinking inspired by a very small example.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/much-ado-about-a-tiny-email-test-micro-dialect/2315">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/much-ado-about-a-tiny-email-test-micro-dialect/2315</link>
          <pubDate>Fri, 11 Oct 2024 21:29:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2315</guid>
          <source url="https://forum.rebol.info/t/much-ado-about-a-tiny-email-test-micro-dialect/2315.rss">Much Ado About A Tiny Email Test &quot;Micro-Dialect&quot;</source>
        </item>
        <item>
          <title>Should Strings Nest Levels To Avoid Escaping?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>There's a historically convenient feature in strings:</p>
<pre><code>str: {This was {a historically legal} string.}
</code></pre>
<p>Each time you used an open brace inside a string, it would increment a "nesting count".  And when you used a close brace it would drop the nesting count.  When you got to zero, your string was finished.</p>
<p>It works in a lot of cases, but not if you have unpaired braces in your content:</p>
<pre><code>c-code: { if char = '}' { printf("This won't work.\n"); } }
</code></pre>
<p>We're going to be getting some instant improvement here with the new string format, using dashes.  Since at least one dash is required (otherwise you'd get a fence), cases like the above will "just work":</p>
<pre><code>c-code: -{ if char = '}' { printf("This will work!\n"); } }-
</code></pre>
<p>But should we still support the nesting idea?</p>
<pre><code>str: -{Should this -{still be a legal}- string?}-
</code></pre>
<p>The alternative would be to force you to use more dashes:</p>
<pre><code>str: --{This -{is definitely a legal}- string.}--
</code></pre>
<p>As we can see from the above, that move from one dash to two dashes does lengthen things.  The tightness is appealing to have as an option.</p>
<h2><a name="p-7836-but-its-complicated-1" class="anchor" href="https://forum.rebol.info#p-7836-but-its-complicated-1"></a>But It's Complicated...</h2>
<p>Let's put aside equal counts for a moment.  What happens if you nest <em>higher</em> counts (which contain lower counts, by definition)</p>
<pre><code>str: -{What ---{do you think this}--- should do?}-  ; [1]
</code></pre>
<p>If it were rotely searching for <strong><code>}-</code></strong> then it would find it at <strong><code>this}-</code></strong> and consider that the end.</p>
<pre><code>str: -{To look at ---{another one, consider}- this...}-  ; [2]
</code></pre>
<p><strong>Do we want the rule that if you ever enclose code with the dashed brace style like <strong><code>--{</code></strong> and <strong><code>}--</code></strong> the enclosure will always need more dashes than what it encloses?</strong></p>
<p>When I put it that way, I think that we don't want to force that escalation.  You can always go there if you need to (case 2 above requires it, or using quotes on the outside instead).  But I think being able to dodge it in cases where things are paired (as in case 1) is worth the dodge.</p>
<p><em>(Note that if you are trying to analyze the inside of the string for matched pairs that are other than the ones you asked for from the outside delimiter, then suddenly you're maintaining a stack of quote levels where nest level has an independent associated number of dashes, instead of just maintaining a total nesting count.  Not that this is a difficult problem, but it's just "another thing".)</em></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-strings-nest-levels-to-avoid-escaping/2311">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-strings-nest-levels-to-avoid-escaping/2311</link>
          <pubDate>Thu, 10 Oct 2024 06:44:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2311</guid>
          <source url="https://forum.rebol.info/t/should-strings-nest-levels-to-avoid-escaping/2311.rss">Should Strings Nest Levels To Avoid Escaping?</source>
        </item>
        <item>
          <title>Should sequences permit non-head SIGILs?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Historically I was very much opposed to SET-WORD! and GET-WORD! being in paths, because the ergonomics were bad:</p>
<pre><code>red&gt;&gt; p: to path! reduce [first [:a] first [b:]]
== :a/b:

&gt;&gt; type? p
== path!
</code></pre>
<p>You have something that's neither a SET-PATH! nor a GET-PATH! but it has colons at the beginning and the end.  It's all kinds of confusing.</p>
<p>Ren-C has addressed that particular can of worms with a <a href="https://forum.rebol.info/t/introducingnew-chain-datatype/2226">full design for the CHAIN! sequence type</a>, and rules for its nesting in PATH! (and how TUPLE! nests in it).  So you can get these weird looking structures, but they destructure unambiguously.</p>
<h2><a name="p-7831-as-for-sigils-at-the-head-they-must-be-illegal-1" class="anchor" href="https://forum.rebol.info#p-7831-as-for-sigils-at-the-head-they-must-be-illegal-1"></a>As For Sigils... At The Head They Must Be Illegal</h2>
<p>You can't put a sigil in a sequence head position, because that would be ambiguous with wanting to apply the sigil to the path as a whole.</p>
<pre><code>&gt;&gt; to path! [$foo bar]
** Error: This needs to be an error
</code></pre>
<p>The only way to allow it would be if we invented <a href="https://forum.rebol.info/t/what-is-a-path-or-a-quasi-word/2292/2">some kind of lexical escaping</a> so we could tell the difference between $|foo/bar| and $|foo|/bar ... <em><strong>and I do not want lexical escaping of this kind</strong></em>.</p>
<h2><a name="p-7831-but-sigils-at-non-head-positions-maybe-roll_eyes-2" class="anchor" href="https://forum.rebol.info#p-7831-but-sigils-at-non-head-positions-maybe-roll_eyes-2"></a>But Sigils At Non-Head Positions... Maybe?  <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=12" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></h2>
<p>There's no fundamental reason why sigils couldn't be on non-head positions in sequences.  It works.</p>
<pre><code>&gt;&gt; $a:$b
== a:$b  ; bound
</code></pre>
<p>Part of me says <em>"ugh, no, it makes everything uglier, don't let people make these ugly things!"</em></p>
<p>But one very compelling reason just for the above syntax is what I've called "dialecting function calls", such as for pointing the blame to a callsite with a FAIL.</p>
<p>So instead of:</p>
<pre><code>my-api: func [x y z] [
    if true [
        if y &lt; 100 [
            fail:blame ["Value must be &gt;= 100, not" y] $y
        ]
     ]
 ]
</code></pre>
<p>You could write:</p>
<pre><code>my-api: func [x y z] [
    if true [
        if y &lt; 100 [
            fail:$y ["Value must be &gt;= 100, not" y]
        ]
     ]
 ]
</code></pre>
<p>When you look at it like that, it's hardly a monstrosity.  It's letting you push the variable to blame into the chain for invoking the function, in a way that's out-of-band with other refinements.</p>
<p>It could offer a cheaper way of asking to fetch variables, using @ to take the place of the old "get word" concept:</p>
<pre><code>&gt;&gt; block: [index offset pointer]
&gt;&gt; index: 3

&gt;&gt; block.index
== offset

&gt;&gt; block.(index)
== pointer

&gt;&gt; block.@index
== pointer
</code></pre>
<p>It's measurably less expensive (no array allocation, cheaper to naviate to on fetch).  It doesn't use a GROUP! so it doesn't get in the way of COMPOSE-ing.</p>
<h2><a name="p-7831-think-i-have-to-allow-it-3" class="anchor" href="https://forum.rebol.info#p-7831-think-i-have-to-allow-it-3"></a>Think I Have To Allow It...</h2>
<p>I'd originally thought that it would be cleaner to disallow it.  But seems to me there are too many interesting uses.</p>
<p>As a medium, Rebol is very free, and you have a lot of power to make hideous things.  So it's about using your judgment, and I think people should know when it's getting too crazy.</p>
<hr>
<h2><a name="p-7831-i-almost-hate-to-point-it-out-but-4" class="anchor" href="https://forum.rebol.info#p-7831-i-almost-hate-to-point-it-out-but-4"></a>I Almost Hate To Point It Out, But...</h2>
<p>This is true of quotes as well.</p>
<pre><code>&gt;&gt; 'a:''b:'''c
== a:''b:'''c
</code></pre>
<p>There's an unambiguous way of interpreting that.</p>
<pre><code>&gt;&gt; quote to chain! [a ''b '''c]
== 'a:''b:'''c
</code></pre>
<p>I don't love it, but, maybe there's cases where <strong><code>foo:'bar</code></strong> would be useful in a dialect, and if it's mechanically consistent I shouldn't prohibit it.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20">  I don't know.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-sequences-permit-non-head-sigils/2309">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-sequences-permit-non-head-sigils/2309</link>
          <pubDate>Mon, 07 Oct 2024 19:06:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2309</guid>
          <source url="https://forum.rebol.info/t/should-sequences-permit-non-head-sigils/2309.rss">Should sequences permit non-head SIGILs?</source>
        </item>
        <item>
          <title>:FOO is now a &quot;Refinement&quot;... so what is /FOO called?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>There are pieces of code that use leading-slash-words as dialect parts, without having anything to do with them being "refinements".</p>
<p>We might call them <strong><code>RUN-WORD</code></strong>, because that's what <strong><code>/FOO</code></strong> does in the evaluator... runs FOO if it's a function, and errors if not.</p>
<p>More visually they could be <strong><code>SLASH-WORD</code></strong> with the implied fact the "slash" comes before the word helping to distinguish it from <strong><code>FOO/</code></strong>.  But it seems that they both have equal claim on being slash words to me.</p>
<p>I'm going to call them RUN-WORD just to keep moving along, but think about it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/foo-is-now-a-refinement-so-what-is-foo-called/2308">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/foo-is-now-a-refinement-so-what-is-foo-called/2308</link>
          <pubDate>Mon, 07 Oct 2024 01:46:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2308</guid>
          <source url="https://forum.rebol.info/t/foo-is-now-a-refinement-so-what-is-foo-called/2308.rss">:FOO is now a &quot;Refinement&quot;... so what is /FOO called?</source>
        </item>
        <item>
          <title>SYSTEM.OPTIONS.ARGS vs. SYSTEM.SCRIPT.ARGS</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Modules</category>
          <description><![CDATA[
            <p><a href="https://forum.rebol.info/t/revisiting-a-maybe-not-so-weird-old-idea-as-identity/2165/2">I was looking at some code like</a>:</p>
<pre><code>tests: if try first system.options.args [
    local-to-file first system.options.args
] else [
    %core-tests.r
]
</code></pre>
<p>And it reminded me that I don't like the nuance between SYSTEM.OPTIONS.ARGS and SYSTEM.SCRIPT.ARGS.</p>
<p>One of them is supposed to capture the command line arguments that spawned the interpreter.  The other is the arguments to the currently running script.  If you spawn the interpreter in such a way that it runs a script, then the two will be the same when that script runs.</p>
<h2>
<a name="i-dont-like-the-naming-distinction-or-the-behavior-1" class="anchor" href="https://forum.rebol.info#i-dont-like-the-naming-distinction-or-the-behavior-1"></a>I Don't Like the Naming Distinction or the Behavior</h2>
<p>It seems flawed to me that you can confuse them (and many people do, in ways that break as their code gets more complex.)  One way to avoid confusion would be to say that all arguments should go one place or the other.</p>
<p>e.g. drop the idea of giving you verbatim what the command line was.  If you write the command line in such a way that some arguments are given to the script, then remove those from the place where you find the spawning arguments.</p>
<p>That would give us SYSTEM.BOOT.ARGS which is everything that didn't get picked off to pass to the script.  And the script gets SYSTEM.SCRIPT.ARGS.</p>
<h2>
<a name="should-there-be-systembootargs-at-all-2" class="anchor" href="https://forum.rebol.info#should-there-be-systembootargs-at-all-2"></a>Should There Be SYSTEM.BOOT.ARGS At All?</h2>
<p>I don't know if it's even a good idea.  Why should you be looking at that, vs. whatever was gleaned from it?  This just seems like a way to start building dependencies on the command line argument conventions of the executable that are none of your script's business.</p>
<p>Anyway, maybe I am wrong and SYSTEM.BOOT.ARGS giving you an exact capture of the arguments which started the executable is useful and should be preserved.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20">  I'm just annoyed at how often I've been bitten by this and maybe overreacting.</p>
<p>But at least renaming it to SYSTEM.BOOT.ARGS helps you avoid confusing it.  The SYSTEM.OPTIONS.ARGS vs. SYSTEM.SCRIPT.ARGS naming hath wrought nothing but pain.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/system-options-args-vs-system-script-args/2303">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/system-options-args-vs-system-script-args/2303</link>
          <pubDate>Mon, 30 Sep 2024 12:31:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2303</guid>
          <source url="https://forum.rebol.info/t/system-options-args-vs-system-script-args/2303.rss">SYSTEM.OPTIONS.ARGS vs. SYSTEM.SCRIPT.ARGS</source>
        </item>
        <item>
          <title>A Pattern-Matching Optimized MAP (?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p>In UPARSE, there's a MAP! of all the combinators.  You can map fundamental datatypes to combinator functions, or you can map literal elements to combinator functions (as keywords like SOME or ACROSS are)... or you can map literal elements to something to substitute as a rule.</p>
<p><em>(e.g. you can map a literal element to a parse rule block!, and it will use that block as the implementation of whatever you mapped.  You could map <strong><code>&lt;_&gt;</code></strong> to <strong><code>[opt some whitespace]</code></strong> if you wanted.)</em></p>
<h2>
<a name="but-now-foobar-foo-and-foo-are-all-becoming-chainhttpsforumrebolinfotintroducingnew-chain-datatype2226-1" class="anchor" href="https://forum.rebol.info#but-now-foobar-foo-and-foo-are-all-becoming-chainhttpsforumrebolinfotintroducingnew-chain-datatype2226-1"></a>But now <code>FOO:BAR</code>, <code>FOO:</code> and <code>:(FOO)</code> are all becoming <a href="https://forum.rebol.info/t/introducingnew-chain-datatype/2226">CHAIN!</a>
</h2>
<p>It's likely that <strong><code>foo:bar</code></strong> would be handled by the combinator mechanics themselves, to provide refinements to the combinator.  So it wouldn't be dispatched to the "CHAIN! combinator".</p>
<p>But we've been handling <strong><code>foo:</code></strong> and <strong><code>:(foo)</code></strong> very differently.  But they're both the same type: CHAIN!.</p>
<p>Problem is, there are no variadic combinators (yet?).  So you either map the CHAIN! to a combinator that takes an argument or you don't.  The <strong><code>foo:</code></strong> needs an argument, the <strong><code>:(foo)</code></strong> has been evaluating the group and splicing it as a rule to execute.</p>
<h2>
<a name="cheap-solution-of-the-moment-hack-the-dispatch-2" class="anchor" href="https://forum.rebol.info#cheap-solution-of-the-moment-hack-the-dispatch-2"></a>Cheap Solution of the Moment: Hack The Dispatch</h2>
<p>The terrible but "let's keep things moving" answer is that if you have any sequence with a leading blank, it will try dispatching to <strong><code>:*</code></strong> or <strong><code>/*</code></strong> or <strong><code>.*</code></strong> ... e.g. those literal sequence patterns are what you put in the combinator table.</p>
<p>And if it has a trailing blank, you put <strong><code>*:</code></strong> or <strong><code>*/</code></strong> or <strong><code>*.</code></strong> and give those a combinator.</p>
<p>If both of those fall through, it goes to the plain CHAIN! or PATH! or TUPLE! combinator.</p>
<p>Shoddy...of course.  How to do better?</p>
<h2>
<a name="could-a-map-like-structure-optimize-pattern-match-3" class="anchor" href="https://forum.rebol.info#could-a-map-like-structure-optimize-pattern-match-3"></a>Could A MAP!-Like Structure Optimize Pattern Match?</h2>
<p>As a non-compiled language, we can't do much to optimize <a href="https://forum.rebol.info/t/destructure-dialect/1877">something like DESTRUCTURE</a> if the moment we encounter it is the first time we've seen it.</p>
<p>We <em>could</em> have a data structure that is internally optimized to pattern matching.  e.g. something like a MAP! but that has architecture inside of itself as a data structure that groups patterns that are close to each other together, and branches off at the appropriate points.</p>
<p>I don't know how to implement it, but I do know that if we turned the combinator map into a list of destructure rules that it tested one at a time in order, that that would be really slow... even if destructure were native.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/a-pattern-matching-optimized-map/2302">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/a-pattern-matching-optimized-map/2302</link>
          <pubDate>Sat, 28 Sep 2024 23:35:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2302</guid>
          <source url="https://forum.rebol.info/t/a-pattern-matching-optimized-map/2302.rss">A Pattern-Matching Optimized MAP (?)</source>
        </item>
        <item>
          <title>Bitten By Right Side Evaluation First</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>I was writing some code like this:</p>
<pre><code>while [not tail? info] [
    if find leaders info.1.name [
        leader-protos.(info.1.name): take info
    ] else [
        info: next info
    ]
]
</code></pre>
<p>Due to the post title you probably already see the bug.  TAKE INFO on the right hand side runs <em>before</em> the <strong>info.1.name</strong>.  So it's inserting under the next name.</p>
<p>I think we can (and should) precalculate the groups on the left hand side.  Basically walk the tuple and push its elements to the stack before doing the right hand side evaluation.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/bitten-by-right-side-evaluation-first/2301">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/bitten-by-right-side-evaluation-first/2301</link>
          <pubDate>Sat, 28 Sep 2024 17:53:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2301</guid>
          <source url="https://forum.rebol.info/t/bitten-by-right-side-evaluation-first/2301.rss">Bitten By Right Side Evaluation First</source>
        </item>
        <item>
          <title>What Should &quot;New Refinements&quot; (e.g. :FOO) Evaluate To?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>We know what new refinements will do when you put them in a dialect like APPLY.:</p>
<pre><code>call:shell // [  ; infix APPLY
    [(system.options.boot) --suppress {"*"} print.reb 100]

    :input 'none      ; pipe input from /dev/null
    :output data: {}  ; write output to string
]
</code></pre>
<p>The <strong><code>:input</code></strong> and <strong><code>:output</code></strong> will be noticed literally by APPLY.  But this doesn't prescribe any particular evaluator meaning for them when not dialected.</p>
<p>Old refinements (e.g. <strong><code>/input</code></strong> and <strong><code>/output</code></strong>) would evaluate to bound versions of themselves... so effectively synonyms for <strong><code>$/input</code></strong> and <strong><code>$/output</code></strong>.</p>
<p><em>(This makes me aware of a likely bug in the optimization of paths (chains) of this size... they use a WORD! cell format.  Which means they only capture the binding of the specific word...while array-based sequences get a "whole specifier".  It doesn't seem to me that the length of the sequence should affect what kind of environment it captures.  e.g. <strong><code>[_ input]</code></strong> should capture the same amount of context as the path produced by it does...but if we forced embedded GROUP!s to be fixed in their biding on sequence creation that might be undesirable.  Review.)</em></p>
<p>Anyway...we know that <strong><code>.input</code></strong> is evaluative (picking the field out of the "current coupled context").  And <strong><code>/input</code></strong> will be evaluative (calling a function).  Then <strong><code>foo:bar</code></strong> will be evaluative, calling FOO with the refinement BAR.</p>
<p>So what of <strong><code>:foo</code></strong>?  Due to what we want it to do in APPLY, we know that giving it any active meaning in the evaluator would be a bad idea.  But maybe the best idea is to be conservative and error on it for now.  That won't stop you from creating unbound forms (<strong><code>':foo</code></strong>) or bound forms (<strong><code>$:foo</code></strong>)...and discouraging its use as a generic inert form probably has advantages in other contexts besides helping APPLY.</p>
<p>If it turns out that having it act as a generic unbound version of itself has some great application, I'll reconsider.  But error for now.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/what-should-new-refinements-e-g-foo-evaluate-to/2299">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-should-new-refinements-e-g-foo-evaluate-to/2299</link>
          <pubDate>Fri, 27 Sep 2024 18:11:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2299</guid>
          <source url="https://forum.rebol.info/t/what-should-new-refinements-e-g-foo-evaluate-to/2299.rss">What Should &quot;New Refinements&quot; (e.g. :FOO) Evaluate To?</source>
        </item>
        <item>
          <title>Typechecking Quoted forms / Quasiforms / Antiforms</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Asking questions about antiforms can be a bit tricky.</p>
<p>If you have a meta result that contains something that might be a pack, you'd have to say:</p>
<pre><code>if pack? unmeta result' [...]
</code></pre>
<p>But you're just asking a question.  What if it contained a meta of a raised error?   Should PACK? be willing to accept raised errors?  If not, that would cause an abrupt failure.</p>
<p>To dodge the need to do an UNMETA, you could say:</p>
<pre><code>all [
    quasiform? result'
    block! = heart of result'
] then [
   ...
]
</code></pre>
<p>And via such a mechanism, you could write a function META-PACK? that would not fail on META-RAISED:</p>
<pre><code>if meta-pack? result' [...]
</code></pre>
<p>That has the nice feature of not forcing you to perform an UNMETA just to answer the question.  You can narrowly ask "is this a meta pack".</p>
<p>But I think such things need to be in the box.  This question gets asked a lot, and I'm tired of asking it as the ugly and breakable <strong><code>pack? unmeta</code></strong>.</p>
<h2>
<a name="what-if-typecheck-functions-had-a-meta-refinement-1" class="anchor" href="https://forum.rebol.info#what-if-typecheck-functions-had-a-meta-refinement-1"></a>What If Typecheck Functions Had a :META refinement...?</h2>
<p>It doesn't seem like clogging up the namespace with more functions makes a lot of sense, so we might offer a refinement:</p>
<pre><code>if pack?/meta result' [...]
</code></pre>
<p>That puts some separation between the <strong>?</strong> and the thing you're testing.  It's a little less severe with the new format using a CHAIN!:</p>
<pre><code>if pack?:meta result' [...]
</code></pre>
<p>We could put a question mark on the refinement as well <img src="https://forum.rebol.info/images/emoji/twitter/face_with_diagonal_mouth.png?v=12" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20"></p>
<pre><code>if pack?:meta? result' [...]
</code></pre>
<p>Okay, no, we won't do that.</p>
<p>I kind of feel like putting the meta after makes it unclear.  You'd read it like <strong>pack? meta result'</strong>.  Does that mean it should just be UNMETA?</p>
<pre><code>if pack?:unmeta result' [...]
</code></pre>
<p>But at that point, people are probably not going to generally know what the difference is between that and <strong><code>pack? unmeta result</code></strong></p>
<p>None of this is as good as simply <strong><code>meta-pack?</code></strong>.  But we don't want to generate new words for every possible thing (and questions like <strong><code>meta-integer?</code></strong> are equally legitimate...)</p>
<h2>
<a name="what-about-arbitrary-chain-interpretation-2" class="anchor" href="https://forum.rebol.info#what-about-arbitrary-chain-interpretation-2"></a>What About Arbitrary CHAIN! Interpretation?</h2>
<p>Let's forget for a moment about the existing refinements to META and QUASI.  What if they--as functions--were willing to <em>take other functions as a refinement</em>?</p>
<pre><code>if meta:pack? result' [...]
</code></pre>
<p>This could be a general pattern of solution...</p>
<pre><code>if (quasi:group? first [~(a b c)~]) [...]

if (quote:word? first ['a b c:]) [...]  ; or quoted:word?
</code></pre>
<p>How would it work?  Well, I guess the basic idea would be that it would do a processing step on the argument before typechecking it and passing it to the constraint function.</p>
<p>So <strong><code>quoted:word?</code></strong> would run QUOTED, and it would be able to inspect the chain as containing WORD?.</p>
<ul>
<li>
<p>If it was passed something like <strong><code>&lt;foo&gt;</code></strong> it would say "I don't even have to ask, that's not a quoted anything".</p>
</li>
<li>
<p>If it was something like <strong><code>'&lt;foo&gt;</code></strong> it would say "okay that's quoted, I need to ask" and it would unquote the thing before passing it to WORD?, which would come back false.</p>
</li>
<li>
<p>If it was <strong><code>'bar</code></strong> it would do the same thing but this time WORD? would return true.</p>
</li>
</ul>
<p><em>It feels a little bit ad-hoc, but the ergonomics are certainly there.</em>  This would be tremendously useful and could create new and useful type constraints.  It's literate... and <strong><code>meta:pack?</code></strong> is going to look better in type specs than <strong><code>meta/pack?</code></strong></p>
<p>Not only that, but <a href="https://forum.rebol.info/t/intrinsics-functions-without-frames/2050">recognizing <strong>"intrinsics"</strong> in the chain</a> would mean this could be relatively fast--faster than <strong><code>pack? unmeta</code></strong> could be.</p>
<h2>
<a name="what-about-refinements-like-metalitehttpsforumrebolinfotmeta-lite-when-you-dont-want-quasiforms2296-3" class="anchor" href="https://forum.rebol.info#what-about-refinements-like-metalitehttpsforumrebolinfotmeta-lite-when-you-dont-want-quasiforms2296-3"></a>What About Refinements Like <a href="https://forum.rebol.info/t/meta-lite-when-you-dont-want-quasiforms/2296"><code>META:LITE</code></a>
</h2>
<p>Let's say there's a single-arity logic-bearing function someone makes called LITE, and they get mad that META:LITE doesn't call it to do a meta version of that test.</p>
<p>I don't know that I care a ton about that.  We have situations in PARSE where you might have a variable named ACROSS and it will ignore that variable if there's a keyword called ACROSS.  You have to escape your words when they run up against reserved dialect words.</p>
<p>So I guess you'd wind up with something like:</p>
<pre><code> if meta:(lite/) [...]
</code></pre>
<p>Otherwise the keyword would win.</p>
<h2>
<a name="what-about-cascading-the-functions-4" class="anchor" href="https://forum.rebol.info#what-about-cascading-the-functions-4"></a>What About Cascading The Functions?</h2>
<pre><code>if (quoted:quoted:quasi:block? first [''~[a b c]~]) [...]
</code></pre>
<p>Well I guess that could work if the rule was that if you used a function name as a refinement, that function would receive all the refinements after it.  Applying that recursively you'd get something that works.</p>
<p>There could be an optimization that functions like QUOTED would detect when the functions in the chain were ones they recognized, and they could do something optimal.</p>
<h2>
<a name="does-any-of-this-solve-the-unmeta-problem-5" class="anchor" href="https://forum.rebol.info#does-any-of-this-solve-the-unmeta-problem-5"></a>Does Any Of This Solve The UNMETA Problem?</h2>
<p>It's nice syntax, but remember the original issue...where you have a meta-raised-error, and you want to test it to see if it is or isn't a meta pack:</p>
<pre><code>if pack? unmeta result' [...]
</code></pre>
<p>I'm talking about redoing that:</p>
<pre><code>if meta:pack? result' [...]
</code></pre>
<p>But if META is unmeta'ing its argument, and passing it to PACK?, does that still have the same problem?</p>
<p>It doesn't have to.  META would see that the result is a quasiform, hence a candidate for any function to ask... then it needs to typecheck against what PACK? takes.  But if that typecheck fails, there's no need to raise the error.  You can just say "no, it's not a meta pack".  Done.</p>
<h2>
<a name="are-there-less-wacky-ways-to-do-it-6" class="anchor" href="https://forum.rebol.info#are-there-less-wacky-ways-to-do-it-6"></a>Are There Less Wacky Ways To Do It?</h2>
<p>I dunno.  It's admittedly a bit weird to put that much overloading on words like META and QUASI.  Their type signatures stop making sense (returning LOGIC?...sometimes?)</p>
<p>The overloading could be reduced if the weird modifiers were QUOTED, METAD, and QUASID.  :-/</p>
<pre><code>if metad:pack? result' [...]
</code></pre>
<p>Errr, no.  Didn't come this far to write things that look like garbage.</p>
<p>But oddly, quoted:xxx? looks better than quote:xxx?... does that suggest the operator should be called QUOTED too?  <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<pre><code>&gt;&gt; quoted 1 + 2
== '3
</code></pre>
<p>I've seen it as QUOTE for so long that it's hard to frame it.  It doesn't look <em>terrible</em>, and when you put them side by side the brevity has an advantage:</p>
<pre><code>if (quoted:quoted:quasi:block? first [''~[a b c]~]) [...]

if (quote:quote:quasi:block? first [''~[a b c]~]) [...]
</code></pre>
<p>To say that <strong><code>'a</code></strong> is a QUOTE-WORD! is a little bit caveman-ish, but better than calling it a LIT-WORD!, and it takes one less syllable to say "is a quote word" than to say "is a quote-uhd word".</p>
<p>Looking at it in that light, it's growing on me to dumb it down.  Maybe not in all circumstances.  Perhaps it could be left as a matter of taste with QUOTED and QUOTE being synonyms... like FUNC and FUNCTION, use whichever you want.</p>
<h2>
<a name="i-think-this-is-a-direction-worth-pursuing-7" class="anchor" href="https://forum.rebol.info#i-think-this-is-a-direction-worth-pursuing-7"></a>I Think This Is A Direction Worth Pursuing</h2>
<p>I've been looking for an answer to this question, and haven't thought of anything this good before.</p>
<p>Don't have a complete design for the "customized refinement dialect", but I can do some prototyping...</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/typechecking-quoted-forms-quasiforms-antiforms/2298">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/typechecking-quoted-forms-quasiforms-antiforms/2298</link>
          <pubDate>Tue, 24 Sep 2024 00:16:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2298</guid>
          <source url="https://forum.rebol.info/t/typechecking-quoted-forms-quasiforms-antiforms/2298.rss">Typechecking Quoted forms / Quasiforms / Antiforms</source>
        </item>
        <item>
          <title>Generalized Argument Removal - SPECIALIZE:RELAX</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Let's say you want a version of append that just appends random numbers to things:</p>
<pre><code>&gt;&gt; append-random: adapt get $append [
       value: random 10
   ]
</code></pre>
<p>This works, but the function interface still thinks it takes two arguments:</p>
<pre><code>&gt;&gt; append-random [a b c] [d e]
== [a b c 10]
</code></pre>
<p>So fine, you can just specialize out the argument.  Both ADAPT of a SPECIALIZE and SPECIALIZE of an ADAPT would remove an argument.  But you want the specialize to run first, otherwise it would overwrite the adapted value.  So SPECIALIZE the ADAPT, to put the specialize earlier in the composition process.</p>
<p><em><strong>But what value do you put in the specialized-out slot if you're just going to overwrite it?</strong></em></p>
<p>Today we have quite the awesome answer: <strong><a href="https://forum.rebol.info/t/tripwire-in-the-wild/2278">use a TRIPWIRE!</a></strong>  Sounds great!</p>
<pre><code>&gt;&gt; append-random: specialize (adapt get $append [
       value: random 10
   ]) [
       value: ~&lt;specialized out&gt;~
   ]
** Script Error: append expects [~void~ element? splice?] for its value argument
</code></pre>
<h2>
<a name="ooops-specialize-typechecked-that-1" class="anchor" href="https://forum.rebol.info#ooops-specialize-typechecked-that-1"></a>Ooops.  SPECIALIZE Typechecked That</h2>
<p>There are two good reasons for specialization to type check:</p>
<ul>
<li>
<p>You find out about bad types at the moment of specialization--instead of having to wait until the function is called to know there are problems.</p>
</li>
<li>
<p>It can speed up the system by not type checking those parameters again <em>(though it occurs to me this may be broken right now, and fixing it sooner than later would probably be smart)</em></p>
</li>
</ul>
<p>Historically what I've done just to get things going is to use some value that typechecks in the argument slot:</p>
<pre><code>&gt;&gt; append-random: specialize (adapt get $append [
       value: random 10
   ]) [
       value: [something that typechecks]
   ]

&gt;&gt; append-random [a b c]
== [a b c 7]

&gt;&gt; append-random [a b c]
== [a b c 9]

&gt;&gt; append-random [a b c]
== [a b c 7]
</code></pre>
<p>For the sake of education, notice what happens if you did it backwards and ADAPT the SPECIALIZE:</p>
<pre><code>&gt;&gt; append-random: adapt (specialize get $append [
       value: [something that typechecks]
   ]) [
       value: random 10
   ]

&gt;&gt; append-random [a b c]
== [a b c [something that typechecks]]
</code></pre>
<h2>
<a name="seems-we-need-specializerelax-2" class="anchor" href="https://forum.rebol.info#seems-we-need-specializerelax-2"></a>Seems We Need SPECIALIZE:RELAX</h2>
<p>Having to pick an arbitrary meaningless value that won't trip up the type checking is bad.</p>
<p>While we want to type check 99% of the time, this kind of scenario calls for a version of specialize that does not do typechecking.</p>
<p>Hence I propose <strong><code>SPECIALIZE:RELAX</code></strong>.</p>
<p>Tripwires seem like the go-to datatype to use for these specialized-out values.  Rather than just say <strong><code>~&lt;specialized out&gt;~</code></strong> you can be as detailed as you like, to help inform on what should happen:</p>
<pre><code>&gt;&gt; append-random: specialize:relax (adapt get $append [
       value: random 10
   ]) [
       value: ~&lt;ADAPT phase of APPEND-RANDOM puts INTEGER! here&gt;~
   ]
</code></pre>
<p>Tripwires are great!  <img src="https://forum.rebol.info/images/emoji/twitter/boom.png?v=12" title=":boom:" class="emoji" alt=":boom:" loading="lazy" width="20" height="20">  You don't have to stress too much about cost...the string inside the tag only exists as one instance in memory.</p>
<p>But you could be lazy and/or cheap, and just unset it. <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p>
<pre><code>&gt;&gt; append-random: specialize:relax (adapt get $append [
       value: random 10
   ]) [
       value: ~
   ]
</code></pre>
<p>There might be other uses for not typechecking at the moment of specialization, but I can't think of what they would be.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/generalized-argument-removal-specialize-relax/2297">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/generalized-argument-removal-specialize-relax/2297</link>
          <pubDate>Mon, 23 Sep 2024 17:37:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2297</guid>
          <source url="https://forum.rebol.info/t/generalized-argument-removal-specialize-relax/2297.rss">Generalized Argument Removal - SPECIALIZE:RELAX</source>
        </item>
        <item>
          <title>META:LITE - When You Don&#39;t Want Quasiforms</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>There was a time before quasiforms existed, but where there was generic quoting.</p>
<p>It was in this time that META was invented.  It did the only thing it could do:</p>
<ul>
<li>
<p>When you META'd a plain (or quoted) thing, it got one quote level added</p>
</li>
<li>
<p>When you META'd an "antiform" you would get a plain version of the thing</p>
</li>
</ul>
<p>So it worked like this:</p>
<pre><code>&gt;&gt; meta first [(d e f)]
== '(d e f)

&gt;&gt; meta first ['(d e f)]
== ''(d e f)

&gt;&gt; spread [a b c]
== (a b c)  ; "antiform"

&gt;&gt; meta spread [a b c]
== (a b c)
</code></pre>
<p><em>(That's not how it works now--for good reasons.  Not only is it a bit too easy to get confused about whether a meta protocol is in effect, the absence of quasiforms leaves a representational hole for values that produce antiforms under evaluation.  But I won't rewrite a <a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">A Justification Of Generalized Iostopes</a> here, this post has another purpose.)</em></p>
<h2>
<a name="another-historical-twist-meta-of-null-was-null-1" class="anchor" href="https://forum.rebol.info#another-historical-twist-meta-of-null-was-null-1"></a>Another Historical Twist: META of NULL was NULL</h2>
<p>NULL was an outlier--at various times having no quoted form (and at other times being considered a quote of nothingness, e.g. the lone apostrophe (<strong><code>'</code></strong>)).</p>
<p>I don't exactly remember what state NULL was in at the time META was being invented.  But regardless, it was initially decided that META and UNMETA of NULL could just give null back.</p>
<p>This actually turned out to frequently be useful...for instance <a href="https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833">when writing a loop wrapper like FOR-BOTH</a></p>
<pre><code>for-both: func [var blk1 blk2 body] [  ; the historical formulation
    return unmeta all [
        meta for-each var blk1 body  ; META NULL =&gt; NULL allows chaining BREAK
        meta for-each var blk2 body
    ]
]
</code></pre>
<p>Though while it was useful there, plenty of places needed to speak fully abstractly about all possible states.  So as the model shaped up, META of NULL fit into the regular pattern of all things having reified metaforms, giving <strong><code>~null~</code></strong>.</p>
<h2>
<a name="i-wanted-a-metalitehttpswwwyoutubecomwatchvimv0g-4cycw-2" class="anchor" href="https://forum.rebol.info#i-wanted-a-metalitehttpswwwyoutubecomwatchvimv0g-4cycw-2"></a><a href="https://www.youtube.com/watch?v=Imv0g-4cycw">I Wanted A META:LITE</a>
</h2>
<p>The idea of a META variation that passed through keywords as-is came along as <strong><code>meta:lite</code></strong>.</p>
<pre><code>&gt;&gt; meta:lite [a b c]
== '[a b c]

&gt;&gt; spread [a b c]
== ~(a b c)~  ; null

&gt;&gt; meta:lite spread [a b c]
== ~(a b c)~

&gt;&gt; meta:lite null
== ~null~  ; anti

&gt;&gt; meta:lite first [~null~ ~void~]
== '~null~
</code></pre>
<p>So today's META:LITE still produces quasiforms for antiforms--just not for the <code>~null~</code> and <code>~void~</code> antiforms (and I now imagine it should probably pass through <code>~okay~</code> and <code>~end~</code> and <code>~NaN~</code> as well):</p>
<pre><code>/for-both: func [var blk1 blk2 body] [
    return unmeta:lite all [
        meta:lite for-each var blk1 body  ; meta:lite null =&gt; ~null~ antiform
        meta:lite for-each var blk2 body  ; meta:lite void =&gt; ~void~ antiform
    ]
]
</code></pre>
<h2>
<a name="but-what-if-metalite-didnt-make-any-quasiforms-at-all-3" class="anchor" href="https://forum.rebol.info#but-what-if-metalite-didnt-make-any-quasiforms-at-all-3"></a>But What If META:LITE Didn't Make <em>Any</em> Quasiforms At All?</h2>
<p>By design, <a href="https://forum.rebol.info/t/quasiforms-arent-super-friendly-and-they-shouldnt-be/2273">quasiforms are not very friendly</a>.  So if you have an antiform in your hand... and you know you have an antiform in your hand... it's easy to take a step to a quasiform, but you need another step to get back to a plain form you can interact with.</p>
<p>So why not have META:LITE take care of it?</p>
<pre><code>&gt;&gt; meta:lite null
== ~null~  ; anti

&gt;&gt; meta:lite spread [a b c]
== (a b c)
</code></pre>
<p>This doesn't make a difference to things like FOR-BOTH.  They'll still work--plain forms are just as truthy as quasiforms for the meta states.  They just have to remember to use UNMETA:LITE on the reverse end.  <em>(If you use plain UNMETA it will catch your error, as UNMETA does not accept plain forms.)</em></p>
<p>It might seem random to pair up the feature of not making quasiforms with passing thru null and void.  But I actually think the kinds of places where you'd want one behavior do overlap significantly with the other.</p>
<p>And we're really just running out of terms, here.  Throwing another nuance in to say <em>"I want partial META, but only partial in the sense that I'm passing through null and void, not partial in terms of the other antiforms--make those quasiforms"</em> is just starting to go beyond the ability to give names to.</p>
<p>So in my head, having META:LITE be formulated as "do what META would do in a historical world where quasiforms and meta-nulls didn't exist" feels pretty good.</p>
<h2>
<a name="its-still-fundamentally-a-valid-meta-4" class="anchor" href="https://forum.rebol.info#its-still-fundamentally-a-valid-meta-4"></a>It's Still Fundamentally a "Valid META"</h2>
<p>I couldn't really think of a good name for the operation besides just saying it was an alternate behavior of META. "Lite" is a bit strange but I felt it fit.</p>
<p>Note that it doesn't make sense as a refinement to REIFY.  Because being willing to produce something that can't be put in a block fundamentally undermines what the word REIFY means.  (<strong><code>reify:...NOT!</code></strong>)</p>
<p>The thing about META:LITE is that it really is giving you a full-spectrum meta representation of what you had in your hand.  Every input state maps to a unique output state.  The default META happens to also be a fully reifying operation as well...but here we are saying that's not intrinsic to "a meta operation".</p>
<p><em>(Would there be any use for a META that passes through <em>all</em> antiforms--not just the antiform words--and just quotes everything else?  That's more a variation of QUOTE than it is a variation of META.  I can't offhand think of a case where that would ever be useful.)</em></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/meta-lite-when-you-dont-want-quasiforms/2296">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/meta-lite-when-you-dont-want-quasiforms/2296</link>
          <pubDate>Mon, 23 Sep 2024 13:42:44 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2296</guid>
          <source url="https://forum.rebol.info/t/meta-lite-when-you-dont-want-quasiforms/2296.rss">META:LITE - When You Don&#39;t Want Quasiforms</source>
        </item>
  </channel>
</rss>

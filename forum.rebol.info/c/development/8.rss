<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Development - AltRebol</title>
    <link>https://forum.rebol.info/c/development/8</link>
    <description>Topics in the &#39;Development&#39; category Discussion of the development of Rebol itself: language design, implementation and standard library.</description>
    
      <lastBuildDate>Sat, 14 May 2022 04:35:56 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/8.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Hex-Valued Integer Literals: Likely Not In Ren-C</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>On an old Trello there was a card about standardizing the differences between R3-Alpha and Red...and a checklist with only one item:</p>
<blockquote>
<p>Hex-valued literal notation (Rebol has none, Red used to use FFh, FFFFh, FFFFFFFFh), now using 0#FF</p>
</blockquote>
<p>The motivation was for purposes of Red/System, mostly.</p>
<p>In Ren-C this doesn't seem like a priority.  It has ISSUE! (TOKEN!) as a read-only data type that fits in a cell.  Hence a systems-oriented dialect already has an efficient way to represent these values.</p>
<p>For instance: it's not a big deal if your assembler says <strong>[mov ax, <span class="hashtag">#FE</span>]</strong> in its source... if it's generating machine code.</p>
<p>Of course, an ISSUE! in it isn't the same from a metaprogramming sense as a slot with an INTEGER! in it.  So you don't get the automatic advantage of <em>every</em> dialect that has INTEGER! support for a given slot working with a hex notation.  But isn't that what COMPOSE is for...?</p>
<pre><code>my-dialect [something-or-another 255]

my-dialect compose [whatever (debin [BE +] #FF)]
</code></pre>
<p><strong>Having more than one representation for the same type is generally bad, anyway.</strong>  Let's look at what Red does here:</p>
<pre><code>red&gt;&gt; FFh
== 255

red&gt;&gt; F0h + 0Fh
== 255
</code></pre>
<p>If it was so important that it had to be encoded in source, why is it thrown away immediately?</p>
<p>It's something about Red worth knowing exists, but off the radar for implementing, methinks.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/hex-valued-integer-literals-likely-not-in-ren-c/1815">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/hex-valued-integer-literals-likely-not-in-ren-c/1815</link>
          <pubDate>Sat, 14 May 2022 04:35:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1815</guid>
          <source url="https://forum.rebol.info/t/hex-valued-integer-literals-likely-not-in-ren-c/1815.rss">Hex-Valued Integer Literals: Likely Not In Ren-C</source>
        </item>
        <item>
          <title>Is GROUP! in PATH! for function invocations worth it?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>Back in the day, I thought it would be neat to allow you to put GROUP!s in paths.  So you could do things like this:</p>
<pre><code>append/(if condition ['only]) [a b c] [d e]
</code></pre>
<p>It turned out to be of fairly limited use.  Really you could only use it with refinements that didn't take parameters, because it changes the "shape" of the execution stream.  Consider how you would make the following sensible:</p>
<pre><code>append/(if condition ['dup]) [a b c] [d e] ???
</code></pre>
<p>When the condition is true you want something in the ??? spot.  When it's false you don't.  How can your code cover both cases?</p>
<p><em>We actually have some tools these days</em> that could use opportunistic invisibility to solve this.  But then you're testing the condition twice, and getting involved in some pretty wild mechanics for something trivial.</p>
<p>It also raised a lot of annoying questions about NULL/blank tolerance.  I didn't like NULL being allowed in the generic pathing, but it was ugly to require BLANK! for this task:</p>
<pre><code>append/(try if condition ['only]) [a b c] [d e]

append/(if condition ['only] else [_]) [a b c] [d e]
</code></pre>
<h2><strong><a href="https://forum.rebol.info/t/apply-ii-the-revenge/1406/3">Now we have a modern APPLY</a></strong></h2>
<p>It bends some of the raw frame rules, and lets you use LOGIC! for parameterless refinements:</p>
<pre><code>apply :append [[a b c] [d e] /only condition]
</code></pre>
<p>It's a bit longer.  And we haven't really firmed up questions like whether you need the GET-WORD! or if it's soft quoted by default.  Or if there might be some clever shorthand:</p>
<pre><code>($ append [a b c] [d e] /only condition)
</code></pre>
<h2>I'm In A Mood To Kill Off Lesser-Loved Features <img src="https://forum.rebol.info/images/emoji/twitter/hocho.png?v=9" title=":hocho:" class="emoji" alt=":hocho:">
</h2>
<p>All things being equal, it might seem nice to support.  But every feature has a cost!</p>
<p><strong>You'd still be able to put GROUP!s in paths for your own purposes, but refinement dispatch in functions wouldn't use it.</strong></p>
<p>You could also use DO of COMPOSE'd code if you really wanted to:</p>
<pre><code>do compose/deep [
    append/(if condition ['only]) [a b c] [d e]
]
</code></pre>
<p>So if anyone has a good argument for keeping the function dispatch behavior, speak up now!</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/is-group-in-path-for-function-invocations-worth-it/1813">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/is-group-in-path-for-function-invocations-worth-it/1813</link>
          <pubDate>Fri, 13 May 2022 04:35:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1813</guid>
          <source url="https://forum.rebol.info/t/is-group-in-path-for-function-invocations-worth-it/1813.rss">Is GROUP! in PATH! for function invocations worth it?</source>
        </item>
        <item>
          <title>DO vs. IMPORT and &quot;Console-Extending Applications&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Modules</category>
          <description><![CDATA[
            <p>During the module reworking, I roughly embraced the R3-Alpha distinction made in the header between two categories:</p>
<hr>
<pre><code>Rebol [Type: Script ...]  ; first category
</code></pre>
<ul>
<li>
<p>You would run these "Scripts" with DO</p>
</li>
<li>
<p>Performing a DO could have side effects, but should be isolated...not allowed to leak changes into the caller's environment</p>
<ul>
<li>This was a new rule I imposed as a default (because "Isolate" was made more economical, and I wanted to see how much we could get away with)</li>
</ul>
</li>
</ul>
<hr>
<pre><code>Rebol [Type: Module ...]  ; second category
</code></pre>
<ul>
<li>
<p>An "ideal" module would not have any "side-effects"...because the concept was that no matter how many times you run IMPORT you will only get one copy of that module in memory.</p>
<ul>
<li>Notably, if you run an IMPORT on a module that has already been loaded before...that will not run any code in the module body...it will just give you the MODULE! object that it already made.</li>
</ul>
</li>
</ul>
<hr>
<p><strong>We probably shouldn't be surprised that there are things that don't fit neatly into these categories!</strong></p>
<hr>
<h2>"Console-Extending Applications"</h2>
<p>So these add some functions to your environment, but also tend to have some side effects.  Like:</p>
<ul>
<li>
<p><strong><a class="mention" href="/u/gchiu">@gchiu</a>'s chess program</strong> - It wants to display a board, show you some help, and add various chess-related behaviors to the console.  But to add those commands which "contaminate" the calling environment, you have to say <strong>import</strong>.  On the other hand, by displaying a board and showing help, it sort of violates that "no side-effects" rule.</p>
<ul>
<li>He is working on another prescription-generating application that lets you automate a pop-up window that works in a similar way.</li>
</ul>
</li>
<li>
<p><strong>The ReplPad interactivity test</strong> - This test adds OKAY and NOPE to the vocabulary... where it's actually the typing of those words that runs commands which advance the console through steps in some way and instructs you on what to look for.</p>
<ul>
<li>
<p>If you don't use IMPORT, you don't get the commands added as commands to the context...</p>
</li>
<li>
<p>...but if you DO use IMPORT, you can only run through the test once... because doing it again will not load the code that prints out the instructions and launches it...</p>
</li>
</ul>
</li>
</ul>
<h2>Should DO allow you to EXPORT ?</h2>
<p>The nice thing about the word DO is it sounds pretty unambiguous, that you want to run something that has side effects.</p>
<p>But I do like the default of not leaking into the enclosing environment.</p>
<p>It seems like allowing scripts to export symbols could be a lazy compromise...which would let you ask to run something (vs. just bringing in a cached copy if previously loaded).</p>
<p>Yet this raises the question of what sort of behavior you'd expect from something that extends the console if you DO it multiple times.</p>
<p>There's also some things to think about regarding how modules will only load once, with respect to debugging.  If you have a complex multi-module project running and want to tweak something--reload it and retry without losing your current interpreter state, that's rather complicated semantically.</p>
<p>We might also consider the idea that there's a new script type.  Something like <strong><code>Rebol [Type: Commands ...]</code></strong> for lack of a better name.  Maybe this would by default give you a new console session separate from the one you were in?</p>
<p>Much more work is needed on binding and modules, to try and figure out how to deliver a good experience.  So hopefully if I don't die in a tornado here in Tennessee, I will work on that soon.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/do-vs-import-and-console-extending-applications/1802">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/do-vs-import-and-console-extending-applications/1802</link>
          <pubDate>Fri, 06 May 2022 19:42:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1802</guid>
          <source url="https://forum.rebol.info/t/do-vs-import-and-console-extending-applications/1802.rss">DO vs. IMPORT and &quot;Console-Extending Applications&quot;</source>
        </item>
        <item>
          <title>Suppressing verbosity in the replpad</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Emscripten</category>
          <description><![CDATA[
            <p>I am developing a replpad app but I want the users to go straight to a URL and start the app.  I'd rather that they didn't have to type</p>
<pre><code>import @rx
</code></pre>
<p>when a lot of module stuff is sent to the console interrupting the interface, eg</p>
<pre><code>`== make module! [
    alpha: make bitset! #{00000000000000007FFFFFE07FFFFFE0}  
    rx: '#[action! {rx} [drug]]  
    ...  
</code></pre>
<p>`</p>
<p>Maybe <code>http://hostilefork.com/media/shared/replpad-js/@rx</code> would be better and if a module is provided then verbose mode is automatically suppressed.</p>
<p>Anyway, suggestions for a standardised way to run our apps?</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/suppressing-verbosity-in-the-replpad/1801">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/suppressing-verbosity-in-the-replpad/1801</link>
          <pubDate>Thu, 28 Apr 2022 09:49:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1801</guid>
          <source url="https://forum.rebol.info/t/suppressing-verbosity-in-the-replpad/1801.rss">Suppressing verbosity in the replpad</source>
        </item>
        <item>
          <title>Conflation vs. Safety, RETURN and the Finer Points of ~null~ Isotopes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p><code>~null~</code> isotopes are a novel solution shaped to solve a specific problem.  As a reminder of what the goal is...</p>
<h1>The Goal is to Please <a class="mention" href="/u/rgchris">@rgchris</a> <em>AND</em> Please me</h1>
<p>NULL is the signal of "soft failure".  It's a unique result reserved for when a branch fails, or when a loop is halted by a BREAK, when PARSE fails...etc.</p>
<p>Its property of not being storable in blocks makes it critical to disambiguating this historical problem:</p>
<pre><code>redbol&gt;&gt; third [a b #[none]]
== #[none]

redbol&gt;&gt; third [a b]
== #[none]
</code></pre>
<p>In a language that prides itself on letting you work with code structure, <em>this is the tip of the iceberg of the problems that null solves</em>, and you will find the distinction's utility across the board (obviously, in tools like COMPOSE).  It facilitates rigorous analysis and rearrangements...without needing to drop to C or write convoluted code:</p>
<pre><code>&gt;&gt; third [a b _]
== _

&gt;&gt; third [a b]
; null
</code></pre>
<p>Hence NULL has taken the place of blank ("none!") in many places, one of which is the unique result of failed conditionals.</p>
<p>But unlike the elements in a block, a branch that evaluates isn't required to be non-NULL.  Which leads us to the long running question of what to bend NULL branches to so they don't conflate with the branch-not-taken result.</p>
<h2>Chris has (rightly) expressed concern</h2>
<p>At times I've said that it's not that big a deal that branches can't evaluate to NULL and get distorted.  "You didn't have a NULL before, so why get so worked up about control constructs not returning it?"</p>
<p>But the now-pervasive nature of NULL means it can't be avoided.  So:</p>
<p><em>"How do you express branching code which wants to do some work but also produce NULL as an evaluative product?"</em></p>
<p>Conflation was not a problem, e.g. in Rebol2:</p>
<pre><code>rebol2&gt;&gt; exampler: func [x] [
     print "returning sample or none if not found"
     case [
         x = &lt;string&gt; [print "sample string" {hello}]
         x = &lt;integer&gt; [print "sample integer" 3]
         x = &lt;none&gt; [print "sample none" none]
     ]
  ]

rebol2&gt;&gt; exampler &lt;string&gt;
returning sample or none if not found
sample string
== "hello"

rebol2&gt;&gt; exampler &lt;blatz&gt;
returning sample or none if not found
== #[none]

rebol2&gt;&gt; exampler &lt;none&gt;
returning sample or none if not found
sample none
== #[none]
</code></pre>
<p>However NULL is now the basic currency of "soft failure".  As such it would not be uncommon to be in the situation where a branching decision process would want to intentionally return NULL as part of the work it does.</p>
<p>Without something like the isotope decay mechanism, unpleasant convolutions would be needed, for instance surrounding anything that wanted to tunnel a NULL with a CATCH and THROW'ing it:</p>
<pre><code>x: catch [
    throw switch 1 + 2 [
        1 [print "one" 1]
        2 [print "two", &lt;two&gt;]
        3 [print "three", throw null]
     ]
]
</code></pre>
<p>Definitely not good.  But regarding the pleasing-me-part, remember I am trying to avoid this situation:</p>
<pre><code>&gt;&gt; case [
     true [
          print "case branch"
          if 1 &gt; 2 [print "failed inner"]
     ]
   ] else [
     print "else branch"
   ]

case branch
else branch  ; ugh
</code></pre>
<p>I don't want the CASE branch to evaluate to NULL just because the failed IF inside the branch was NULL.  That would mean the ELSE tied to the CASE runs even though the code for the branch ran.</p>
<h2>Enter Isotopes</h2>
<p>One thing null isotopes have in common with NULL (like all BAD-WORD! isotopes) is that they can't be put in blocks.  But they have been automatically "decaying" into regular NULL when stored into variables.</p>
<pre><code>&gt;&gt; ~null~
== ~null~  ; isotope

&gt;&gt; x: ~null~
== ~null~  ; isotope  &lt;-- note the overall expression is still an isotope

&gt;&gt; x
; null
</code></pre>
<p>The twist is that they are <em>different enough</em> from true NULL such that a THEN or an ELSE can consider them a situation where the branch did not run:</p>
<pre><code>&gt;&gt; if false [&lt;ignored&gt;]
; null

&gt;&gt; if true [null]
== ~null~  ; isotope

&gt;&gt; if true [null] else [print "This won't run"]
== ~null~  ; isotope
</code></pre>
<p>The reason functions like ELSE can "see" the isotope is that they don't take an ordinary parameter on their left.  They take a ^META argument.  These can see the distinction between a ~null~ isotope and a "true" NULL.</p>
<p><strong>I'd largely say this has been working well...certainly better than its conceptual predecessors.</strong>  It makes piping NULL out of branches trivially easy, when the fear of conflation is not a problem.</p>
<pre><code>&gt;&gt; x: switch 1 + 2 [
     1 [print "one" 1]
     2 [print "two", &lt;two&gt;]
     3 [print "three", null]
   ]
three
== ~null~

&gt;&gt; x
; null
</code></pre>
<p>The automatic decay in variable storage prevents you from needing an explicit operation to turn ~null~ isotopes into pure nulls:</p>
<pre><code>&gt;&gt; x: decay switch 1 + 2 [
     1 [print "one" 1]
     2 [print "two", &lt;two&gt;]
     3 [print "three", null]
   ]
three
; null
</code></pre>
<h1>But <a class="mention" href="/u/rgchris">@rgchris</a> Would Likely Want any <em>NORMAL</em> arg decay</h1>
<p>At the very moment I am writing this, ~null~ isotopes are like all other BAD-WORD! isotopes and not accepted as normal parameters.</p>
<p><strong>They <em>could</em> decay to pure NULL for all normal args.</strong>  But let me explain a bummer of what we lose in that bargain.</p>
<p>It takes away a safety idea I had with functions like MATCH.</p>
<pre><code>&gt;&gt; match [&lt;opt&gt; integer!] 3
== 3

&gt;&gt; match [&lt;opt&gt; integer!] "notaninteger"
; null

&gt;&gt; match [&lt;opt&gt; integer!] null
== ~null~  ; isotope
</code></pre>
<p>The idea was that it could say "yes, this matched" but if ~null~ isotopes were tested, they'd give an error:</p>
<pre><code>&gt;&gt; if (match [&lt;opt&gt; integer!] null) [print "Yes it matched!"]
** Error: IF does not accept ~null~ isotopes without a ^META condition
</code></pre>
<p>Were MATCH to have passed through a plain NULL it would have succeeded in the match but not run the branch.  So it's nice to get the warning on the isotope.</p>
<p><strong>Or it could just return a ~matched~ isotope</strong>.  But this loses the following nice isotopic property:</p>
<pre><code>&gt;&gt; x: match [&lt;opt&gt; integer!] null else [fail "NO MATCH"]
== ~null~  ; isotope

&gt;&gt; x
; null
</code></pre>
<p>In fact I instituted other decaying variants for ~blank~ and ~false~</p>
<pre><code>&gt;&gt; y: match [blank!] _ else [fail "NO MATCH!"]
== ~blank~  ; isotope

&gt;&gt; y
== _

&gt;&gt; z: match [logic!] 1 = 2 else [fail "NO MATCH!"]
== ~false~  ; isotope

&gt;&gt; z
== #[false]
</code></pre>
<h1>So What To Do About MATCH and its bretheren?</h1>
<p>Seems the options are:</p>
<ol>
<li>
<p><em>Don't worry about it.</em>  If you write <strong>match [logic!] 1 = 2</strong> you get back <strong>#[false]</strong> and should you write an expression like <strong>if (match [logic!] 1 = 2) [print "Match!]</strong> you get what you deserve.</p>
</li>
<li>
<p><em>Use a different isotope.</em>  Let's say that <strong><code>match [&lt;opt&gt;] null</code></strong> is simply <strong>~matched~ (isotope)</strong>.  It wouldn't have the decaying property, but would have the invalidness property.</p>
</li>
<li>
<p><em>Have a MATCH/FALSEY variant.</em>  Let plain <strong>match</strong> on a falsey thing trigger an error and if you write <strong>if match/falsey ...</strong> then you clearly do know what you're doing so it becomes like case (1).</p>
</li>
<li>
<p><em>Make all conditional arguments take ^META arguments for their conditions.</em>  This would put the responsibility for checking for isotopes on them, and they'd uniquely disallow them before UNMETA'ing them and then testing for truth/falsehood.</p>
</li>
</ol>
<p>Option (4) is too taxing...impacting not just the interface to IF but the implementation of CASE and any conditional construct.</p>
<p><strong>I think I like (3) because it punts the ball down the road a bit.</strong></p>
<p>But this might still not suit Chris.</p>
<h1>Should Non-Meta Arguments Decay Null isotopes?</h1>
<p>The "auto-decay" of ~null~ isotopes means no variable can ever hold a NULL isotope.  And there's also a rule that no <em>normal</em> parameter can ever be passed an isotope, only ^META parameters.</p>
<p>In the beginning, it seemed useful if normal arguments would automatically decay null isotopes:</p>
<pre><code>&gt;&gt; foo: func [x] [if null? x [print "Yup, it's null"]]

&gt;&gt; foo if true [null]
Yup it's null

&gt;&gt; metafoo: func [^x] [
    case [
        null? x [print "regular null"]
        x = '~null~ [print "null isotope"]
        true [print "something else"]
     ]
   ]

&gt;&gt; metafoo if false [null]
regular null

&gt;&gt; metafoo if true [null]
null isotope
</code></pre>
<p>There is a manual DECAY operator which could be used, but would not meet that wish:</p>
<pre><code>&gt;&gt; ~null~
== ~null~  ; isotope

&gt;&gt; decay ~null~
; null

&gt;&gt; ~blank~
== ~blank~  ; isotope

&gt;&gt; decay ~blank~
== _

&gt;&gt; ~false~
== ~false~  ; isotope

&gt;&gt; decay ~false~
== #[false]
</code></pre>
<h1>Should DECAY Conflation Be A Customization?</h1>
<p>Another avenue of satisfaction could be to say that you simply customize your environment with some definitions to make auto-decaying constructs:</p>
<pre><code>switch: chain [:switch | :decay]
case: chain [:case | :decay]
...

&gt;&gt; case [true [null]]
; null

&gt;&gt; case [false [10]]
; null
</code></pre>
<p>I don't like it, but if someone isn't going to use ELSE (or is willing to accept this very easily unintentional conflation if they do) it could be an option.</p>
<p><strong>I really do believe the ability to tell from outside the construct if a branch has been taken is an interesting property, which even those who think they won't use ELSE or THEN can leverage, especially when building constructs atop each other.</strong>  But this isn't something that can be appreciated without usage, or trying to write something like UPARSE generically in usermode.</p>
<h1>Should function RETURN decay by default?</h1>
<p>Continuing along these lines, this has to do with the pattern of:</p>
<pre><code>foo: func [x] [
    return switch x [
         1 [print "one", #one]
         2 [print "two", null]
         3 [print "three", &lt;three&gt;]
    ]
]

&gt;&gt; foo 1 + 2
two
== ???   ; should this be ~null~ isotope or just NULL
</code></pre>
<p>Also, should it matter whether there's a RETURN there or not?  Is this something the type spec should distinguish?</p>
<p>Right now there's a refinement called /ISOTOPE on RETURN which asks it not to decay.</p>
<p><strong>If all non-^META parameters decay by default, then it seems isotopic decay is the right default for RETURN even though it takes a ^META parameter and returns non-decaying isotopes.</strong></p>
<h2>As Always, A Lot To Think About</h2>
<p>Want to get this posted because it's preventing me from making new drafts (Discourse won't let you have multiple top-level post drafts in-flight for some reason).</p>
<p>Will keep mulling it all over.</p>
<p><em>"A designer knows he has achieved perfection not when there is nothing left to add, but when there is nothing left to take away."</em></p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/conflation-vs-safety-return-and-the-finer-points-of-null-isotopes/1799">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/conflation-vs-safety-return-and-the-finer-points-of-null-isotopes/1799</link>
          <pubDate>Thu, 07 Apr 2022 04:14:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1799</guid>
          <source url="https://forum.rebol.info/t/conflation-vs-safety-return-and-the-finer-points-of-null-isotopes/1799.rss">Conflation vs. Safety, RETURN and the Finer Points of ~null~ Isotopes</source>
        </item>
        <item>
          <title>Shall we CONTINUE?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>At some point I added the ability of CONTINUE to take a parameter.  The idea was that CONTINUE with a parameter would act the same as if the loop body had completed with that value.  One place this is most useful is MAP-EACH:</p>
<pre><code>&gt;&gt; map-each x [1 2 3] [
       if x = 2 [continue &lt;twenty&gt;] else [x * 10]
   ]
== [10 &lt;twenty&gt; 30]
</code></pre>
<p>But what should CONTINUE with no argument do?  In the MAP-EACH case, I think it should pretty obviously not add anything to the output.</p>
<pre><code>&gt;&gt; map-each x [1 2 3] [
       if x = 2 [continue] else [x * 10]
   ]
== [10 30]
</code></pre>
<h2>Nice.  But what about "ordinary" loops?</h2>
<p>How about WHILE or REPEAT or FOR-EACH?  If we wanted it to be novel, it could say "don't change the pending overall result from whatever the last loop iteration would have returned":</p>
<pre><code>&gt;&gt; for-each x [1 2 3] [
     if x = 3 [continue] else [x * 10]
]
== 20
</code></pre>
<p>Although I like that in theory, it would break the loop composition rules unless loops were allowed to be invisible.  :-/</p>
<p>Think about the <a href="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/18">code I've previously written down</a> to implement FOR-BOTH:</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    unmeta all [
        meta for-each var blk1 body
        meta for-each var blk2 body
    ]
]
</code></pre>
<p>That FOR-BOTH could not have a CONTINUE that would run in the body of the second FOR-EACH and carry over a value from the first FOR-EACH.</p>
<p>Given that we'd be setting a standard that would be difficult to follow, I think the answer has to be:</p>
<pre><code>&gt;&gt; for-each x [1 2 3] [
     if x = 3 [continue] else [x * 10]
   ]
== ~none~  ; isotope
</code></pre>
<h2>What about UNTIL and CONTINUE TRUE?</h2>
<p>I've given a rule that CONTINUE passed a parameter effectively jumps to the end of the loop body as if it had finished with that value.  But in UNTIL, the loop's body also is the condition.  So what about:</p>
<pre><code>&gt;&gt; until [print "A" if true [continue true] else [&lt;unreachable&gt;]] print "B"
A
B
</code></pre>
<p>It seems to make a certain amount of sense.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/shall-we-continue/1790">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/shall-we-continue/1790</link>
          <pubDate>Wed, 16 Feb 2022 04:10:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1790</guid>
          <source url="https://forum.rebol.info/t/shall-we-continue/1790.rss">Shall we CONTINUE?</source>
        </item>
        <item>
          <title>REBOL 1 Manual</title>
          <dc:creator><![CDATA[DefinitionalUsername]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>I was reading about some of the design choices in REBOL, and came upon Joe Marshall's writings where he talks about the changes between REBOL 1 and 2 (missing continuations, changed scoping rules, absence of tail recursion, etc.). This made me curious about the differences between the two version; however, I can't find anything related to REBOL 1 on the internet (save for a Scheme compiler).</p>
<p>Will it be possible to share the manual/guide/documentation for REBOL 1 here? It is a piece of history, and it'll be a shame if it just disappears.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rebol-1-manual/1788">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rebol-1-manual/1788</link>
          <pubDate>Mon, 14 Feb 2022 03:29:26 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1788</guid>
          <source url="https://forum.rebol.info/t/rebol-1-manual/1788.rss">REBOL 1 Manual</source>
        </item>
        <item>
          <title>Should END-able constructs all use ^META parameters?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>R3-Alpha and Rebol2 could only have functions that were "endable" if the argument they took was quoted.  This feature was added primarily for HELP, so that you could say either:</p>
<pre><code>&gt;&gt; help
; (would display generic HELP usage information)

&gt;&gt; help topic
; (would display help for the given topic)
</code></pre>
<p>It was a <em>very limited form of variadic-ness</em>...generally used only in console-oriented commands (HELP, LS).  You couldn't write a function that was evaluative, like:</p>
<pre><code>redbol&gt;&gt; printer 1 + 2
3

redbol&gt;&gt; printer
You called the PRINTER function with no arguments
    ; ^-- not possible to accomplish with an otherwise evaluative argument!
</code></pre>
<p>Being able to handle getting to the end of input was entwined with taking quoted arguments.</p>
<h2>Ren-C added <code>&lt;end&gt;</code>-able Evaluative Parameters</h2>
<p>To facilitate certain demos in Ren Garden, Ren-C could mark an ordinary parameter as being <code>&lt;end&gt;</code>-able.  This would mean that the argument would show up as being NULL if the end was reached before an argument was seen.</p>
<p>This was--however--ambiguous with if you actually passed an evaluative NULL.</p>
<pre><code>ren-c&gt;&gt; printer 1 + 2
3

ren-c&gt;&gt; printer
You called the PRINTER function with no arguments

ren-c&gt;&gt; printer null  
You called the PRINTER function with no arguments  ; d'oh
</code></pre>
<p><strong>This kind of ambiguity wasn't new...the Redbol version had it.</strong>  The signal for quoted parameters that were endable-and-missing was to make the parameter an UNSET!.  Which meant they couldn't tell the difference between <strong>help #[unset!]</strong> and just-plain-help:</p>
<pre><code>red&gt;&gt; help #[unset!]
To use HELP, supply a word or value as its
argument:

    help insert
    help system
    help system/script

To view all words that...
</code></pre>
<p><strong>Interestingly enough, Ren-C has a solution for this with quoted parameters, because NULL cannot appear literally in source...so it can't be at the callsite.  Thus NULL can represent a missing quoted argument.</strong>  Which is neat.</p>
<h2>^META parameters can do <code>&lt;end&gt;</code> another way...</h2>
<p>A meta parameter is quoted, but will be a plain non-quoted BAD-WORD! if the callsite was passing an isotope.  With the <a href="https://forum.rebol.info/t/pure-vs-impure-invisibility-do-we-need-both/1782">recent design concept that suggests ~void~ isotopes are "pure" and equivalent to the full absence of a value</a>, you get evaluative endability without needing a separate feature.</p>
<p>So if our PRINTER took a ^META argument:</p>
<pre><code>&gt;&gt; printer 1 + 2
3
; (it actually received '3, quoted)

&gt;&gt; printer
You called the PRINTER function with no arguments
; (it actually received ~void~, not quoted)
</code></pre>
<p>The ambiguity is still there, though...</p>
<pre><code>&gt;&gt; printer ~void~
You called the PRINTER function with no arguments
; (again, it actually received ~void~, not quoted)
</code></pre>
<p>If you're following the details then I pointed out that supermeta parameters would be necessary to implement something that would know the difference in the suggested model.</p>
<p><strong>But at least you could differentiate NULL from an end.</strong>  The conflation of an invisible argument with the end doesn't seem that troubling to me, as the problem with HELP is fixed since it quotes and can tell when you say <strong>help ~void~</strong> vs. plain <strong>help</strong></p>
<h2>Killing off <code>&lt;end&gt;</code> as a core parameter flag would simplify things...</h2>
<ul>
<li>
<p>If a quoted parameter tolerates NULL as one of its legal types that's sufficient to say it is "endable"</p>
</li>
<li>
<p>If an evaluative parameter needs to detect endability, it could be your job to make it a ^META parameter and look for void, and unquote it to handle other results.</p>
</li>
</ul>
<p>The code and typeset flags for <code>&lt;end&gt;</code> could then be scrapped.</p>
<p>If someone really liked the NULL conflating version of endability they could write something to do it in usermode.</p>
<p><strong>You'd have to see the code to understand why I would think throwing away <strong><code>&lt;end&gt;</code></strong> is worth it.</strong> The way the type checking is done frames have to be filled first, which means if a function doesn't want an actual null but wants just ends to reflect as null... or wants an actual null but doesn't want ends reflected as null... hidden bits need to be grafted onto these nulls at the time of frame fulfillment to say whether it's an "endish" null or a regular null.  Various parts of the system then need to test a NULL for this invisible property.  <strong>^META parameters pull such invisible state into the light.</strong></p>
<p><strong>Basically take my word for it: meta is much cleaner, and offers a way to expose these distinctions to the user--so I think the odds are that <code>&lt;end&gt;</code> and its current mechanics need to die.</strong></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-end-able-constructs-all-use-meta-parameters/1783">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-end-able-constructs-all-use-meta-parameters/1783</link>
          <pubDate>Fri, 21 Jan 2022 17:01:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1783</guid>
          <source url="https://forum.rebol.info/t/should-end-able-constructs-all-use-meta-parameters/1783.rss">Should END-able constructs all use ^META parameters?</source>
        </item>
        <item>
          <title>Pure vs. Impure Invisibility: Do We Need Both?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>"Invisibles" <a href="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405">were conceived 4 years ago</a>...long before BAD-WORD!s, isotopes, ^META parameters, etc.</p>
<p>The terminology needs a bit of an update, because I want to make a distinction between two different kinds:</p>
<ul>
<li>
<p><strong>IMPURE INVISIBLITY</strong> is when a special state (like a ~void~ isotope) is discarded in contexts where it's assumed to represent an invisible intent.</p>
<p>Remember that plain BAD-WORD!s (unevaluated) are normal values and can be in blocks.</p>
<pre><code>&gt;&gt; first [~void~]
== ~void~
</code></pre>
<p>But an evaluated ~void~ becomes an isotope, and operations like ALL are willing to tolerate that as a signal of invisible intent it should discard:</p>
<pre><code>&gt;&gt; ~void~
== ~void~  ; isotope

&gt;&gt; all [10 + 20, ~void~]
== 30
</code></pre>
<p>Unfortunately, this is extra work that ALL must do, since ~void~ isotopes are valid evaluative products.  Every construct that wants to integrate impure invisibility bears the burden.</p>
</li>
<li>
<p><strong>PURE INVISIBILITY</strong> is an evaluator feature when a function call can truly erase arbitrary code, such as to the right of a SET-WORD!:</p>
<pre><code>&gt;&gt; y: elide (1 + 2 print "Erased!" 3 + 4) 10 + 20
Erased!
== 30

&gt;&gt; y
== 30
</code></pre>
<p>This can only be done when a function like ELIDE specially says that it is not expected to return any result at all.  Otherwise it's not clear whether <strong>y:</strong> is supposed to get the <code>~void~</code> isotope or something after it.</p>
<p>(Over time I embraced the odd idea that just saying RETURN and not giving it an argument would be the way of being purely invisible...which has the interesting property that <strong><code>(return some-other-function ...)</code></strong> can actually chain cases where the other function is sometimes purely invisible and sometimes not!  This insight arose because of the frustrating fact that C/C++ cannot do such chains... if you say <strong><code>return some_other_function(...);</code></strong> and then change the other function from returning <code>int</code> to <code>void</code>, it will complain that you cannot use <code>return</code> with an argument inside of void functions...even if that function itself returns void.)</p>
</li>
</ul>
<h2>Why Not Make "Impure" Invisibility Act "Pure" ("Semipure?")</h2>
<p>The existence of the ^META types and operators raises an interesting theoretical option...that a ~void~ isotope could be treated as pure by the evaluator, and it's your responsibility to use meta operations if you wanted to see it:</p>
<pre><code>&gt;&gt; 1 + 2 ~void~
== 1 + 2

&gt;&gt; x: ~void~ 1 + 2
== 3

&gt;&gt; x
== 3

&gt;&gt; y: ^ ~void~ 1 + 2
== 3

&gt;&gt; y
== ~void~
    ; ^-- not an isotope
</code></pre>
<p>Pondering the potential implications of this form of thinking, it would mean there wouldn't be a form of invisibility that could beat a ^META operation:</p>
<pre><code>&gt;&gt; z: ^ comment ["hi"] ~something~
== ~something~  ; isotope

&gt;&gt; z
== ~void~
   ; ^-- the COMMENT was seen by the ^META, instead of bypassed
   ; (today COMMENT's status as a purely invisible construct means you
   ; would get Z as a non-isotope ~something~)
</code></pre>
<p><strong>Note that since parameters to functions are allowed to be meta if they need to be, changing a parameter from normal to meta would break commenting constructs.</strong>  This is not too surprising, as if you have <code>my-function comment "hi" 1 + 2</code> and change MY-FUNCTION's argument to be quoted instead of evaluated, that's another kind of parameter change that would break the commenting feature.</p>
<p>Meta parameters should be used very sparingly--far more sparingly than quoted parameters--so this may not be a problem.  I notice that a function like RETURN (which takes its argument meta so it can return isotopes) could still chain an invisible function, as it would receive ~void~ as a measure of what an isotope was.</p>
<h2>If Truly Pure Invisibility Is Not Implemented, Would People Just Reinvent it with Variadics in a Less Efficient Way Than The Current Evaluator Internals Do It?</h2>
<p>Let's say someone writes:</p>
<pre><code>foo: func [] [return comment "hi" 1 + 2]
</code></pre>
<p>Today this returns 3 due to comment's "purely invisible" status, RETURN takes its argument as a ^META parameter.  If we decide meta parameters are allowed to see the "semipure" void isotopes described above, then it would just be like you'd written:</p>
<pre><code>foo: func [] [return comment "hi"]
</code></pre>
<p><strong>That would make it seem like COMMENT is unreliable.</strong>  True, if you take a quoted argument you expect COMMENT to break in such cases as well...but meta parameters are evaluative and so it's a bit different.</p>
<p>Perhaps it should be just the <strong>^</strong> operator at the callsite that has the special vision, and meta parameters are evaluated and discard the void isotopes.  This would mean you only have to learn the rule that <strong>^ comment "hi"</strong> breaks the invisibility.</p>
<p><em>(Here we wind up with <strong>^</strong> either being a built-in thing the user has no way to write themselves, or invent a "supermeta" parameter flag to say "I can see void isotopes, too".)</em></p>
<h2>Either way, "Impure Invisibility" Is MUCH Easier To Work With</h2>
<p>The easy meta-transformations between ~void~ isotopes and plain ~void~ BAD-WORD! allow you to work with an invisible function gracefully...even when you don't know if it's invisible or not.</p>
<p>Early problems cropped up with pure invisible COMMENT like this:</p>
<pre><code>&gt;&gt; f: make frame! :comment
&gt;&gt; f.discarded: "Ignore Me"

&gt;&gt; x: do f   y: 1 + 2
== 3

&gt;&gt; x
== 3  ; this could seem surprising, but maybe not?
</code></pre>
<p>But the new world does have at least <em>an</em> answer, meta your result and you can test for void cases and handle them as you wish.</p>
<pre><code>&gt;&gt; x: ^ do f  y: 1 + 2
== 3

&gt;&gt; x
== ~void~

; alternately could have said `[^x]: do f  y: 1 + 2`
</code></pre>
<p>Yet it's still uncomfortable to imagine that an operation like DO could vanish, which is why DO tried to use void isotopes as a proxy for its return value.  A ~void~ isotope could then be semantically interpreted or converted to pure invisibility on an as-needed basis.</p>
<h2>"If You Don't Know What You're Doing, Then Do It Meta"</h2>
<p>My urge to build safety into the system is driven by wanting to enable people to write generic code.</p>
<p>...but... trying to protect people from <strong><code>do f</code></strong> from vanishing when <strong><code>f</code></strong> is a FRAME! for the COMMENT function may be misguided.  That protection could be breaking the very cool trick they are trying to perform.</p>
<p>And there's a real complexity cost to having a distinction between pure and impure invisibility.  If you allow that distinction then impure invisibility has a meta form (a plain ~void~ BAD-WORD!) while pure invisibility doesn't have one.  The powerful tool of META therefore offers no answers for a purely invisible function.</p>
<p>Maybe things like DO should have a switch to say <strong>do/vanishable</strong> and that's the right protection, otherwise they error if they could vanish.  Same with <strong>unmeta</strong>?</p>
<p>Or maybe there's a better finesse, to say that the evaluator has some generalized protection which notices when you might have meant for an invisible result to be used, and there's generic mitigation for such cases.  Like with <strong><code>x: do f  y: 1 + 2</code></strong>, if it notices the potential for misunderstanding you can say <strong><code>x: vanishable do f y: 1 + 2</code></strong>...and you'd be provoked to decide if you wanted to use VANISHABLE or ^ based on what you were actually trying to accomplish.</p>
<p><em>That actually sounds like a really clever mitigation, if a word or symbol were picked for it!</em></p>
<hr>
<p><strong>This post has been in draft form for a while, as I let it turn over in my head.  But I think I am turning to feeling that void isotopes cannot be stored in variables but are something whose existence can only be philosophically imagined by seeing a meta state register as a plain ~void~ BAD-WORD!.  This is bolstered by the idea that function frames cannot receive isotopes, and parallels to the idea that ~null~ isotopes cannot be stored in variables either (though they decay to ordinary NULL)</strong></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/pure-vs-impure-invisibility-do-we-need-both/1782">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/pure-vs-impure-invisibility-do-we-need-both/1782</link>
          <pubDate>Fri, 21 Jan 2022 09:19:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1782</guid>
          <source url="https://forum.rebol.info/t/pure-vs-impure-invisibility-do-we-need-both/1782.rss">Pure vs. Impure Invisibility: Do We Need Both?</source>
        </item>
        <item>
          <title>JS testing with Cypress.io</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Testing</category>
          <description><![CDATA[
            <p>I will eventually have to port my Red GUI database front end and so I was looking for testing tools.  I came across <a href="https://cypress.io">https://cypress.io</a> which seems to be fully featured though it may be more demanding of JS knowledge than I have.</p>
<p>Anyway, here's a short script to open up the replpad, and start the chess demo though I had to increase the default timeout from 4 to 5 seconds</p>
<blockquote>
<p>describe('Test the replpad', () =&gt; {<br>
it('Visits Replpad', () =&gt; {<br>
cy.visit(<code>'http://hostilefork.com/media/shared/replpad-js/'</code>)<br>
cy.get('.input').type('do &lt;chess&gt;{enter}')<br>
})<br>
})</p>
</blockquote>
<p>So, it opens a browser instance to the replpad, waits until loading is complete, and then waits until the dom has the <code>.input</code> element present.  It then types the chess command.  The chess board then pops up.</p>
<p>Here's a quick <a href="https://filiphric.com/cypress-basics-selecting-elements">tutorial</a> on how to select elements.</p>
<p>Installation is just simply</p>
<pre><code>npm install cypress --save-dev
</code></pre>
<p>but of course on Windows, you'll need to install node.js</p>
<p>And there's <a href="https://docs.cypress.io/guides/continuous-integration/github-actions#Basic-Setup">information</a> on how to use with GitHub actions</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/js-testing-with-cypress-io/1778">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/js-testing-with-cypress-io/1778</link>
          <pubDate>Tue, 21 Dec 2021 06:56:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1778</guid>
          <source url="https://forum.rebol.info/t/js-testing-with-cypress-io/1778.rss">JS testing with Cypress.io</source>
        </item>
        <item>
          <title>WHILE [Cold Feet]</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p><strong>I'm really certain that ANY should not be a looping construct in PARSE.</strong>  Rebol's use of ANY everywhere else means "any one of", not "any number of".  That applies to the ANY short-circuit-OR operation, to the ANY-XXX! types, and it can come up in PARSE such as:</p>
<pre><code>parse block [some any-value!]
</code></pre>
<p>I like the shorthand for this this that works across series types with the TAG! combinator:</p>
<pre><code>uparse block [some &lt;any&gt;]
</code></pre>
<p>This meaning <em>any one element</em>.  It gets at that English concept that operators like <strong><code>*</code></strong> (or <strong><code>&lt;*&gt;</code></strong>) just don't have.</p>
<p>Plus, the "zero-or-more matches of a rule" interpretation doesn't jibe with how we use ANY in English:</p>
<ul>
<li>"Do you have ANY bananas?"</li>
<li>"Yes."</li>
<li>"Cool.  Can I have one, then?"</li>
<li>"No, sorry.  I don't have ANY."</li>
</ul>
<h2>But I'm Not Happy With Bending WHILE For This</h2>
<p>It seemed appealing at first to say that WHILE would be standardized in the language as arity-1, both in PARSE and in ordinary code loops.  This would make UNTIL and WHILE line up, and LOOP could take the arity-2 role that WHILE used to have.</p>
<p>But I've been lamenting <strong><a href="https://en.wikipedia.org/wiki/While_loop">just how universally WHILE is arity-2 in pretty much every language</a></strong> and that LOOP doesn't really quite cut it while reading.  :-/</p>
<p>Sorry for the flux, but I want to move back to <strong>while [condition] [body]</strong> as it was.  However going through the process has spurred thought...</p>
<h2>An Observation: OPT SOME &lt;=&gt; WHILE</h2>
<p>It has in the past occurred to me that PARSE's WHILE (or ANY) was really OPT SOME.  It's three more characters to say it:</p>
<pre><code>while pattern
opt some pattern
</code></pre>
<p><em>(Note: This is only true in modern Ren-C, as previously the progress requirement differentiated these...that is now broken out into FURTHER.)</em></p>
<p>...but although it's more characters, "optionally some number of occurrences of the pattern" is pretty literally what you are talking about.  In the UPARSE model of synthesized values it's kind of less confusing, because it's clearer what it returns in the case of nothing...the same thing OPT always returns when a rule doesn't match: NULL.</p>
<p>Anyway, I'm feeling remorse and a wish to go back to WHILE for arity-2 loops in the language.  But I don't want to go back to ANY in PARSE.</p>
<h2>Is OPT SOME really so bad?</h2>
<p><strong>I've gotten to wondering if there is a reason we don't have a separate word for "zero or more" in English.  You actually have to write out "zero or more" to convey that intent... <em>maybe because the intent is too weird for a single word</em>.</strong></p>
<p>When you just write WHILE it may be that you have a case that's actually supposed to be a SOME but it hasn't really bit you yet.  If you're willing to tolerate between 1 and a million of something, the case of no things being there is distinguished...and calling attention to the fact that the rule you have may not match at all can be an asset.</p>
<p>I actually think OPT SOME offers an advantage, because it encourages you to look at it and decide if the OPT belongs there or not.  It may feel kind of like a wart, but maybe it's a helpful wart.</p>
<p>(It reminds me a bit of the UNLESS vs. IF NOT situation.  Many people felt UNLESS is actually obfuscating nearly everywhere it's used, and that it's better to break it apart even if that means two words instead of one.)</p>
<h2>Trying Out The Change, I Noticed...</h2>
<p>I actually did find a difference how I read the code.  "This entire next section may not be relevant... <em>none</em> of it could match and it would go on."  That weight of the OPT is felt more heavily when the word is there than the WHILE...which if you <em>frequently</em> expect the thing to be there, you may assume it will <em>always</em> be there for at least one instance.</p>
<p>You also can see redundancy in OPT more clearly.  Things like:</p>
<pre><code>opt [
    while [...]
]
</code></pre>
<p>Stand out more if they look like:</p>
<pre><code>opt [
   opt some [...]
]
</code></pre>
<p>I think some things really do read more clearly.  You can look at this as removing 0 or more newlines at the head of a series via a WHILE:</p>
<pre><code>parse series [
    remove [while newline]
    ...
]
</code></pre>
<p>Or rephrase that with OPT SOME:</p>
<pre><code>parse series [
    remove [opt some newline]
    ...
]
</code></pre>
<p>But I think it reads clearest when you bring the OPT outside, to say you're <em>optionally removing some newlines</em>:</p>
<pre><code>parse series [
    opt remove [some newline]
    ...
]
</code></pre>
<h2>More Distinct</h2>
<p>ANY and WHILE both had the problem that they had analogues in imperative code.  But if SOME remains a PARSE keyword, then this helps better intuit the difference...so the code looks more differentiable.</p>
<h2>Compression Is Possible By Other Avenues</h2>
<p>I noticed a particularly laborious substitution in %make-zlib.r which extracts the headers and code for zlib using parse, because it often was parsing C code and looking for the pattern <strong><code>while whitespace</code></strong>.  This would happen multiple lines in a row and multiple times on a line.  When it became <strong><code>opt some whitespace</code></strong> it got more annoying.</p>
<p>But this is kind of a problem anytime you repeat something over and over.  Maybe that pattern should have been <strong><code>ws*: [opt some whitespace]</code></strong> and then it would just be <strong><code>ws*</code></strong> to mean "any number of whitespace characters here, including zero".</p>
<h2>A Motivated Individual Can Overrule It</h2>
<p>Remember, UPARSE is going to let you be the judge.  If you want your own keywords, you can have them.  Maybe you like MANY (some parser combinators seem to think that 0...N is "many" and 1...N is "some").  Maybe you don't care if WHILE is different.  Maybe you don't want to use the ANY parse abstraction that I think is more interesting.</p>
<h2>I'm Trying It Out</h2>
<p>One can argue there's a bit of a 1984-newspeak to it ("you don't need words like better or worse, use plus-good and un-good and double-plus-ungood").  But we're sort of asking a programming language to be more "nuanced" in its wording than English, which has evolved to be pretty much where the brain is at.  I've shown some concrete benefits here to breaking out the OPT so you can see its relationship to the other OPTs you have and move it around.</p>
<p>I do know I'm getting cold feet on the WHILE &lt;=&gt; LOOP change.  And I don't think the arity of WHILE in PARSE should be different from the arity of WHILE in the language, it's jarring.</p>
<p>I'm giving it a shot in the bootstrap and rebmake to see what kind of thoughts it inspires.  So far it seems to be around equally good and bad...and since the bad is just largely unfamiliarity which should wear off...that points to a win, especially since it means retaking WHILE.</p>
            <p><small>6 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/while-cold-feet/1772">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/while-cold-feet/1772</link>
          <pubDate>Sun, 12 Dec 2021 05:02:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1772</guid>
          <source url="https://forum.rebol.info/t/while-cold-feet/1772.rss">WHILE [Cold Feet]</source>
        </item>
        <item>
          <title>DEFAULT with PATH!...What Does It *Mean*?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>The ability to have random side-effects in paths creates all kinds of nasty potentials.</p>
<p>That is why I made a way to say you only allow paths to contain evaluations if you also ask for an "invariant" representation of the path to be returned...that you could use in place of a path for further assignments.</p>
<pre><code>&gt;&gt; var: 'x

&gt;&gt; path: 'obj/(print "side effect" var)

&gt;&gt; set path 30
** Error: PATH contains GROUP!s, must request /STEPS output (can use #)

&gt;&gt; [value steps]: set path 30
side effect
== 30

&gt;&gt; steps
== @[obj x]
</code></pre>
<p>You can then use STEPS instead of the path.  e.g. <strong>set @[obj x]</strong> will act like <strong>set 'obj/x</strong>.  (The reason a BLOCK! is used is because not all datatypes would be legal in paths...a GROUP! could evaluate to anything, like an OBJECT!...which is a perfectly valid thing to set in a MAP! for instance.)</p>
<h2>This "Invariant" Form Was Intended For Things Like DEFAULT</h2>
<p>The concept was that even if you have evaluations on the left hand side, you will be able to capture where it got the value or absence-of-value from...and then in the event you need to write it back because a default is necessary, you don't have to run the evaluation again:</p>
<pre><code>&gt;&gt; n: 5

&gt;&gt; data.(n: n + 1): default [10]
</code></pre>
<p>Internally, DEFAULT can make a GET request of <strong>data.(n: n + 1)</strong> and get back STEPS with a fixed value for N, like <strong><code>@[data 6]</code></strong>.  If it discovers that the value is set to blank and needs defaulting, it can then use the steps instead of the path as the basis for the SET...so N is not changed twice.</p>
<h2>But Other Things Can Change...</h2>
<p>All kinds of changes can happen between the GET and the SET in DEFAULT.  What about this?</p>
<pre><code>&gt;&gt; data.(n: n + 1): default [data: ~gone~, 10]
</code></pre>
<p>We've prevented running imperative code and getting side effects from the path...but the side effects can come from other places.  <strong>Anything you do between the GET and the SET can make the "invariant" steps not so invariant.</strong></p>
<p>Let's say DATA was a BLOCK! at the outset.  Should the <strong><code>@[...]</code></strong> steps have actually stored a reference to the block instead of the WORD! data, so that changes to the variable couldn't redirect the invariant reference?</p>
<p>That doesn't work for immediate types.  Let's say you have:</p>
<pre><code>&gt;&gt; time: 4:00

&gt;&gt; path: 'time.(if true ['hour])

&gt;&gt; [# steps]: set path 12
== 12

&gt;&gt; steps
== @[4:00 hour]
</code></pre>
<p>Now you can't use that steps to go back and change the original time, because 4:00 is an immediate value.  You need to get at the object the time lives in.  You'd wind up with a 3-element steps in that case:</p>
<pre><code>&gt;&gt; steps
== @[make object! [...] time hour]
</code></pre>
<h2>If Nothing Is Going To Be Perfect... Should We Shortcut It?</h2>
<p>Let's say you have a path like:</p>
<pre><code>obj1.obj2.(if true [obj3]).obj4.date.time
</code></pre>
<p>We could say that the "steps" for this path are:</p>
<pre><code>@[obj1 obj2 obj3 obj4 date time]
</code></pre>
<p>But is that empirically more desirable than just noticing when we cross the line from non-immediate values into immediate values, and preserving only as much as we need?</p>
<pre><code>@[(make object! [...this is obj4...]) date time]
</code></pre>
<p>That's enough to write back to obj4...but it is fully disconnected from the path that was initially being represented.  <strong>But which is more suitable for the intent of something like DEFAULT?</strong></p>
<h2>My Head Hurts <img src="https://forum.rebol.info/images/emoji/twitter/face_with_head_bandage.png?v=9" title=":face_with_head_bandage:" class="emoji" alt=":face_with_head_bandage:">
</h2>
<p>...and it's not because of a booster shot.  It's because this is crazy, and way past the point of being fun.</p>
<p>What started out as a nice idea for taming GROUP!s in PATH!s becomes a real headache.</p>
<p><strong>So I'm going to leave well enough alone, and say that this does only that.</strong>  If you want to prune a path to get better invariants, that's on you:</p>
<p>For example:</p>
<pre><code>(obj1.obj2.obj3.obj4).date.time: default [...]
</code></pre>
<p>When you do this, then when DEFAULT asks for steps it will get 4 items in the block:</p>
<pre><code>&gt;&gt; steps
== @[(make object! [...]) date time]
</code></pre>
<p>It has latched onto the object, and so you can say inside the body of the defaulting code things like <strong><code>obj1: null</code></strong> or <strong>obj1.obj2.obj3: []</strong> and the assignment will apply to what it was looking at, because those names aren't in the steps.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/default-with-path-what-does-it-mean/1770">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/default-with-path-what-does-it-mean/1770</link>
          <pubDate>Sat, 11 Dec 2021 23:58:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1770</guid>
          <source url="https://forum.rebol.info/t/default-with-path-what-does-it-mean/1770.rss">DEFAULT with PATH!...What Does It *Mean*?</source>
        </item>
        <item>
          <title>SmartGit Free For Personal Use</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>GitHub</category>
          <description><![CDATA[
            <p>This isn't really advertised all that loudly.  But SmartGit is free for personal use now:</p>
<p><a href="https://www.syntevo.com/smartgit/" class="inline-onebox">SmartGit  Git Client for Windows, macOS, Linux</a></p>
<p>I've only been using it a little bit so far, but from the bit I've seen it seems to be a lot more functional than SourceTree.</p>
<p>I imagine that things like VSCode having pretty passable in-built version control and extensions is probably putting some pressure on these kinds of products.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/smartgit-free-for-personal-use/1769">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/smartgit-free-for-personal-use/1769</link>
          <pubDate>Sun, 05 Dec 2021 16:32:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1769</guid>
          <source url="https://forum.rebol.info/t/smartgit-free-for-personal-use/1769.rss">SmartGit Free For Personal Use</source>
        </item>
        <item>
          <title>Rye Language (?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>So here's another language which doesn't look very Rebol-like but is by Refaktor who is Rebol-inspired:</p>
<aside class="onebox githubfolder">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/refaktor/rye" target="_blank" rel="noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/345;"><img src="https://opengraph.githubassets.com/122f981b955a64e477a664f1404312f7b4587117bc60742da6aea9e4d871023a/refaktor/rye" class="thumbnail" width="690" height="345"></div>

<h3><a href="https://github.com/refaktor/rye" target="_blank" rel="noopener">GitHub - refaktor/rye: work in progress rebol+factor+shell inspired language</a></h3>


  <p><span class="label1">work in progress rebol+factor+shell inspired language</span></p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>Notably, it is written in Go.  <em>(I've mentioned that increasingly I have been leaning toward modeling things after Go for a runtime.  It would of course be easier to do by actually writing the runtime in Go, vs. trying to reproduce the effect in low-level C code.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"> )</em></p>
<p>It's probably very interesting, but I don't really feel like looking at it right at this moment.  Maybe someone else can study it and explain what it's about in a reply here.</p>
<p>The main carry-away I'll take for the moment is the 1:1 language-designer:user ratio that Rebol users are inevitably converging toward.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rye-language/1768">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rye-language/1768</link>
          <pubDate>Sun, 05 Dec 2021 16:21:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1768</guid>
          <source url="https://forum.rebol.info/t/rye-language/1768.rss">Rye Language (?)</source>
        </item>
        <item>
          <title>Reconsidering Return Values From IMPORT vs. DO</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Modules</category>
          <description><![CDATA[
            <p>The state of things <strong>right now</strong> is:</p>
<ul>
<li>
<p>DO returns the evaluative result of running a script, which can be any datatype.  It can return an INTEGER!, an ACTION!, an OBJECT!, or nothing at all <em>(e.g. a ~none~ or ~unset~ isotope)</em>.  If it wanted, it could also return a MODULE!...but this module could be unrelated to the context the script you are DO-ing is running in.</p>
</li>
<li>
<p>IMPORT will return the MODULE! of the script, <em>if you use an assignment form on its left</em>.</p>
<pre><code>module: import %some-library.r
</code></pre>
<p>This module is a way of accessing any of the EXPORTed things from the module, as <strong>module.exportedthing</strong> ... but you can't access definitions inside the module that are not exported in this way.  <em>(Or at least you shouldn't be able to.)</em></p>
<p>If you don't have a SET-WORD! on the left, it assumes you want to make all the exports of that module available in your current...uh, let's say "binding environment"...</p>
<pre><code>import %some-library.r
</code></pre>
</li>
</ul>
<p>I'm deliberately vague about what this is actually doing, because historical Rebol doesn't have answers to binding that demonstrate reasonable composability...and I'm dabbling in trying to make solutions that will work for bigger projects.</p>
<h2>IMPORT's SET-WORD! Lookback Is Probably A Bad Idea</h2>
<p>What if you wanted:</p>
<pre><code>func-that-takes-module (import %some-library.r)
</code></pre>
<p>You don't want to have to write:</p>
<pre><code>func-that-takes-module (dummy: import %some-library.r)
</code></pre>
<p>Or:</p>
<pre><code>func-that-takes-module ([@]: import %some-library.r)
</code></pre>
<p>The thing I've been leaning toward is a generalized operator which lets you pull an object's fields into the ensuing scope.  A prototype exists right now, it's called USING:</p>
<pre><code>obj: make object! [x: 10 y: 20]
using obj
print [x + y]  ; would print 30
</code></pre>
<p>So if you didn't want to get a module as a value but rather "use" that, you could say something more like:</p>
<pre><code>using import %some-library.r
</code></pre>
<p>And then we could offer a shorthand when USING received a file, like:</p>
<pre><code>using %some-library.r
</code></pre>
<p>In fact, I think this could be popular enough to warrant overtaking the name USE.</p>
<pre><code>use parse [10 "twenty"] [
    emit x: integer!
    emit y: text!
] else [
    fail "Expected integer followed by text"
]

print ["Integer was" x "and text was" mold y]
</code></pre>
<p>Though from an overloading standpoint, it's a bit shaky when you leverage the same name for both running already loaded code in your environment as pulling something off a network.    (Today's DO has this problem, that someone can wedge in a little bit of code to trick you into running arbitrary code off a network instead of a local BLOCK!)  So maybe having the FILE!-and-HTTP capable USING be distinct from USE would be a smart distinction.</p>
<p>That would mean that:</p>
<pre><code>using %some-library.r  &lt;=&gt;  use import %some-library.r
</code></pre>
<h2>How To Get More Granularity?</h2>
<p>I've pointed out the <a href="https://forum.rebol.info/t/design-for-import/1570">variations of import syntaxes in JavaScript before</a> when talking about a design for IMPORT:</p>
<pre><code>import defaultExport from "module-name";
import * as name from "module-name";
import { export1 } from "module-name";
import { export1 as alias1 } from "module-name";
import { export1 , export2 } from "module-name";
import { foo , bar } from "module-name/path/to/specific/un-exported/file";
import { export1 , export2 as alias2 , [...] } from "module-name";
import defaultExport, { export1 [ , [...] ] } from "module-name";
import defaultExport, * as name from "module-name";
import "module-name";
var promise = import("module-name");
</code></pre>
<p>Their <strong>import defaultExport from "module-name";</strong> case acts like what I'm proposing for <strong>using %module-name.r</strong> above.</p>
<p>In my other post I bring up these issues.  It seems like USE would want this too.  But as my other post argues, the dialecting is difficult to make look good.</p>
<h2>Extra Return Results</h2>
<p>The core routine that is behind both IMPORT and DO actually has two return results... it gives back both the context the code was run in and the final by-product of evaluating the script.  IMPORT only returns the module, and DO only returns the product.</p>
<p>It doesn't make a lot of sense to ask IMPORT for the evaluation product, because import caches the module.  So it may not run the code in response to the IMPORT, and wouldn't have the result available (unless it saved it somewhere?)  Right now you can ask it, but it might just give you back the BAD-WORD! of ~cached~ to tell you that no script code ran.  This indicates to me that you probably shouldn't be able to ask.</p>
<p>Perhaps there are more instances where asking DO for the module would make sense.  I don't know--and there is some friction with the question of this separation.  Should all DO be guaranteed to not contaminate the environment they are called from...forcing you to use an IMPORT if you want the contamination?  (This would mean Redbol's DO would have to be rigged up to actually be an IMPORT underneath.)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/reconsidering-return-values-from-import-vs-do/1767">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/reconsidering-return-values-from-import-vs-do/1767</link>
          <pubDate>Sat, 04 Dec 2021 20:38:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1767</guid>
          <source url="https://forum.rebol.info/t/reconsidering-return-values-from-import-vs-do/1767.rss">Reconsidering Return Values From IMPORT vs. DO</source>
        </item>
        <item>
          <title>Extensions as DLLs / Shared Libraries: Resurrected</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Modules</category>
          <description><![CDATA[
            <p>The initial concept Shixin and I talked about with extensions was essentially giving you three choices for each extension:</p>
<p><strong><code>[+]</code></strong> : Build the extension into the interpreter executable<br>
<strong><code>[-]</code></strong> : Don't build the extension at all.<br>
<strong><code>[*]</code></strong> : Build the extension as a separately loadable .dll or .so file</p>
<p>And supposedly it was at some point able to do that.  <strong>But I'd never seen it work.</strong>  Because it was a mixture of Rebmake and the R3 Historical Extension model and loading code.  Since it wasn't part of any testing regimen--and I never understood it to begin with--it probably only worked the day Shixin wrote it (if it would have worked for me at all, on another machine).</p>
<p>The mysterious feature atrophied, but I kept things related to it around.  Because we need this ability to load bits of "native" code dynamically...most especially on the web (where native=wasm).</p>
<p>I decided to spend some time attacking the desktop versions.  By no means was this fun, but, I did get it to work on Windows, Mac and Linux.</p>
<p>As a demonstration of it working, I made the UUID extension a DLL on all the platforms, and call it in a test:</p>
<ul>
<li>
<a href="https://github.com/metaeducation/ren-c/runs/4412834535?check_suite_focus=true#step:23:46">Windows</a> (<code>.DLL</code> file)</li>
<li>
<a href="https://github.com/metaeducation/ren-c/runs/4412352346?check_suite_focus=true#step:22:23">Linux</a> (<code>.so</code> file)</li>
<li>
<a href="https://github.com/metaeducation/ren-c/runs/4412835593?check_suite_focus=true#step:16:23">Mac</a> (<code>.dylib</code> file)</li>
</ul>
<p><em>(I'm fairly sure that the Mac version could not have worked prior to the development of the libRebol API and extension mechanics in their modern form.  So it probably was in an "almost working since it's a lot like the linux version--except for link errors" state at the time of Shixin's writing.)</em></p>
<h2>How Do You Use It?</h2>
<p>Right now you do LOAD-EXTENSION and pass it a path.  It gives you back a module, which you could then IMPORT or use directly as an object.</p>
<p>The UUID module was not designed to be IMPORT-friendly.  It calls its method "generate" which is generic, so it only makes sense as <code>mod-uuid.generate</code>.  So I just did:</p>
<pre><code> mod-uuid: load-extension %/path/to/r3-uuid.dll
 uuid: mod-uuid.generate
</code></pre>
<p>The way I've set up to think about extensions is that from a user's point of view, you can't tell the difference really from ordinary modules.  So really this should be folded into IMPORT.  You should be able to use a URL just as easily as you can use a FILE!.</p>
<p>Shorthand lookups present a bit of a problem, because since these contain native code there's not a single location that would work for all platforms.  We could perhaps adopt a standard naming strategy so that if you put all the extensions in the same directory alongside each other it would know how to pick the right one...</p>
<p>It is kind of neat to see the single file encapsulating script code and native code together.  But what would be really neat to see beyond this is having a form that works in the web browser.  But this was not fun and so I'm going to need to do something else for a bit.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/extensions-as-dlls-shared-libraries-resurrected/1766">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/extensions-as-dlls-shared-libraries-resurrected/1766</link>
          <pubDate>Fri, 03 Dec 2021 20:52:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1766</guid>
          <source url="https://forum.rebol.info/t/extensions-as-dlls-shared-libraries-resurrected/1766.rss">Extensions as DLLs / Shared Libraries: Resurrected</source>
        </item>
        <item>
          <title>DATE! + TIME! + DATETIME! (or TIMESTAMP! ?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>As we are familiar, DATE! can have a TIME! component:</p>
<pre><code>&gt;&gt; d: now
== 21-Nov-2021/18:56:45-5:00 

&gt;&gt; type of d
== #[datatype! date!]

&gt;&gt; t: d.time
== 18:56:45

&gt;&gt; type of t
== #[datatype! time!]
</code></pre>
<p>Although TIME! can exist as a separate cell and value type, <em>a DATE! doesn't store a time cell inside of it</em>.  It packs the date and time information into a single cell.</p>
<p>Hence when you say <strong>d.time</strong> above, a <em>new</em> TIME! value has to be synthesized.  There's not a whole cell worth of time to hand a pointer back to...its woven into the bits of the DATE!.</p>
<p><strong>That might not sound like much of an issue, but it creates the problem I refer to as <em>"sub-cell addressing"</em>.</strong></p>
<p><em>If you've missed everything I've griped about with this so far</em>, it means that when you want to see a behavior like the following:</p>
<pre><code>&gt;&gt; d.time.hour: 12
== 12

&gt;&gt; date
== 21-Nov-2021/12:56:45-5:00  ; we want hour updated
</code></pre>
<p>We run into the problem that if <strong>d.time</strong> <em>synthesizes</em> a value, then a naive picking process of <strong>(d.time).hour: 12</strong> would only be able to manipulate the bits in the synthesized time.  That wouldn't change <strong>d</strong>.  <em>What the user actually wanted was to update the bits of a time that was folded into the implementation of the date.</em></p>
<h2>Rebol Lacks The Vocabulary To Do This In An Obvious Way</h2>
<p>The smallest units that Rebol speaks in terms of are the <strong><code>cell</code></strong> and the <strong><code>node</code></strong>.</p>
<p><em>(If you need a refresher on these, my <a href="https://www.youtube.com/watch?v=6nsKTpArTCE">conference video tech talk</a> explains them.)</em></p>
<p><strong>It would appear we could be able to simplify matters if we changed the combination of DATE! and TIME! to point to a 2-cell node.</strong></p>
<pre><code>DATETIME! cell
[  ]                DATE!           TIME!
  --&gt; points to [ 21-Nov-2021 | 18:56:45-5:00 ]  (2 cells)
</code></pre>
<p><em>(Whether the "zone" is part of a time or lives in the datetime would depend on whether you wanted to write <code>d.zone: -5:00</code> or <code>d.time.zone: -5:00</code>, I don't know if it ever makes sense to speak of a time with a zone independent of a datetime or not.)</em></p>
<p>Breaking things up this way, we can say that <strong>d.time</strong> implicates a cell.  And we can have some operation that acts on a cell (let's say POKE) like:</p>
<pre><code> &gt;&gt; poke 18:56:45 'hour 12
 == 12:56:45
</code></pre>
<h2>Hang On: DATE!, TIME! (and DATETIME!) are IMMEDIATE!</h2>
<p>We still have a bit of a problem here with our smallest units of representation.  Presumably we don't want this:</p>
<pre><code> &gt;&gt; d1: 21-Nov-2021/18:56:45-5:00 

 &gt;&gt; d2: d1

 &gt;&gt; d1.time.hour: 12
 == 12

 &gt;&gt; d1
 == 21-Nov-2021/12:56:45-5:00

 &gt;&gt; d2
 == 21-Nov-2021/12:56:45-5:00  ; don't want d2 to change (right?)
</code></pre>
<p>But we also don't want to be needlessly copying the 2-cell node each time a date is assigned.  So it would be a <em>copy-on-write</em> mechanic.</p>
<p>If we're working with a cell-based granularity, then we wind up in a somewhat similar situation to what we had before...where the tuple processing has to propagate backwards.  e.g. when you have the POKE that changes the cell bits for the TIME! to make a new TIME! cell, there has to be some memory going back to the DATETIME! in order to tell it to make a new node and write the cell into the copy.</p>
<p>Does framing this in terms of cells offer any benefit over letting the DATETIME! be a higher-level entity that does a more specific folding of the TIME! cell into its bits?  This is a question I've been trying to answer, and haven't had an easy time of answering.</p>
<p><strong>One thing it would do to use a cell-based protocol is that it could generalize properties that had flags on cells, such as being PROTECT'ed.</strong>  Without the picking protocol requiring each step to go through a cell, the system cannot fiddle these bits in a known way.  So just as the DATE! folds the TIME! into it in some arbitrary way, the protect bit would have to go through this through a complex protocol also.</p>
<p>What I do know is that my current generalized solution is rather complex and slow--and doesn't answer how to do things like PROTECT.  We're seeing a slowdown from many different angles and I am trying to figure out what the best tradeoff is in terms of simplicity and generality.  It's not easy.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/date-time-datetime-or-timestamp/1765">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/date-time-datetime-or-timestamp/1765</link>
          <pubDate>Thu, 02 Dec 2021 16:57:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1765</guid>
          <source url="https://forum.rebol.info/t/date-time-datetime-or-timestamp/1765.rss">DATE! + TIME! + DATETIME! (or TIMESTAMP! ?)</source>
        </item>
        <item>
          <title>Web Testing Now Takes Screenshots </title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Testing</category>
          <description><![CDATA[
            <p>I don't particularly enjoy the process of making GitHub Actions...but...the time spent on making the reusable bits of code pays for itself quickly.</p>
<p>We had only one test of the Repl and it was rickety.  But I'd said from the beginning we should be testing things like <a class="mention" href="/u/gchiu">@gchiu</a>'s chess demo and power calculator...keeping them working.</p>
<p><strong>But if it doesn't work on the cloud--and works locally--what do you do?</strong></p>
<h1>Screenshots, of course!</h1>
<p>I made it so that you can ask for a screenshot when the run completes or times out.  Just give it a name and it will be uploaded as a <em>"GitHub Artifact"</em> for you.</p>
<p>Here are four little smoke tests in the browser for today's world, and what the screen would look like when they stopped (if there was a screen).  They are available on every test run as the <a href="https://github.com/metaeducation/ren-c/actions/runs/1515287464">artifacts</a> at the bottom of the page.  They expire after 7 days.</p>
<h2>Chess</h2>
<hr>
<pre><code>- name: Test Chess GUI Example
  uses: metaeducation/ren-c-action@release
  with:
    web: true
    timeout: 15
    screenshot: chess
    script: |
      animate-game: do @chess
      assert [
          comment [https://en.wikipedia.org/wiki/Fool%27s_mate]
          &lt;done&gt; = animate-game [
              f2f3 e7e6
              g2g4 d8h4
          ]
      ]
</code></pre>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/6cc23455cfc3da24ffd27291853be315f2845914.png" data-download-href="https://forum.rebol.info/uploads/default/6cc23455cfc3da24ffd27291853be315f2845914" title="image"><img src="https://forum.rebol.info/uploads/default/optimized/1X/6cc23455cfc3da24ffd27291853be315f2845914_2_690x345.png" alt="image" data-base62-sha1="fw7EauntVfjFXXfNHKdRyV35WKw" width="690" height="345" srcset="https://forum.rebol.info/uploads/default/optimized/1X/6cc23455cfc3da24ffd27291853be315f2845914_2_690x345.png, https://forum.rebol.info/uploads/default/optimized/1X/6cc23455cfc3da24ffd27291853be315f2845914_2_1035x517.png 1.5x, https://forum.rebol.info/uploads/default/original/1X/6cc23455cfc3da24ffd27291853be315f2845914.png 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/6cc23455cfc3da24ffd27291853be315f2845914_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">image</span><span class="informations">1366683 88.5 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<h2>LATEST-OF</h2>
<hr>
<pre><code>- name: LATEST-OF Smoke Test
  uses: metaeducation/ren-c-action@release
  with:
    web: true
    timeout: 15
    screenshot: latest-of
    script: |
      (url: latest-of)
      print ["Result was:" mold url]
      assert [url? url]
</code></pre>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/05b08ec27c845bbfc82ca5e942c24469db94ff18.png" data-download-href="https://forum.rebol.info/uploads/default/05b08ec27c845bbfc82ca5e942c24469db94ff18" title="image"><img src="https://forum.rebol.info/uploads/default/optimized/1X/05b08ec27c845bbfc82ca5e942c24469db94ff18_2_690x345.png" alt="image" data-base62-sha1="OkEWvWAPb7om7PlZ5THTqdJT3q" width="690" height="345" srcset="https://forum.rebol.info/uploads/default/optimized/1X/05b08ec27c845bbfc82ca5e942c24469db94ff18_2_690x345.png, https://forum.rebol.info/uploads/default/optimized/1X/05b08ec27c845bbfc82ca5e942c24469db94ff18_2_1035x517.png 1.5x, https://forum.rebol.info/uploads/default/original/1X/05b08ec27c845bbfc82ca5e942c24469db94ff18.png 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/05b08ec27c845bbfc82ca5e942c24469db94ff18_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">image</span><span class="informations">1366683 119 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<h2>WATCHLIST</h2>
<hr>
<pre><code>- name: Watchlist Smoke Test
  uses: metaeducation/ren-c-action@release
  with:
    web: true
    timeout: 15
    screenshot: watch
    script: |
      x: 10
      watch x
      assert [10 = watch 1]
</code></pre>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/7c3a3dc3179df208f61bad1b8fb42d70040c5b64.png" data-download-href="https://forum.rebol.info/uploads/default/7c3a3dc3179df208f61bad1b8fb42d70040c5b64" title="image"><img src="https://forum.rebol.info/uploads/default/optimized/1X/7c3a3dc3179df208f61bad1b8fb42d70040c5b64_2_690x345.png" alt="image" data-base62-sha1="hIXZey0OhgBlFTfo46tQLBZFBxG" width="690" height="345" srcset="https://forum.rebol.info/uploads/default/optimized/1X/7c3a3dc3179df208f61bad1b8fb42d70040c5b64_2_690x345.png, https://forum.rebol.info/uploads/default/optimized/1X/7c3a3dc3179df208f61bad1b8fb42d70040c5b64_2_1035x517.png 1.5x, https://forum.rebol.info/uploads/default/original/1X/7c3a3dc3179df208f61bad1b8fb42d70040c5b64.png 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/7c3a3dc3179df208f61bad1b8fb42d70040c5b64_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">image</span><span class="informations">1366683 73 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<h2>REDBOL</h2>
<hr>
<pre><code>- name: Redbol Smoke Test
  uses: metaeducation/ren-c-action@release
  with:
    web: true
    timeout: 15
    screenshot: redbol
    script: |
      redbol
      block: [b c]
      assert [[a b c d] = compose [a (block) d]]
</code></pre>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/c7ca24fcd4556a03349509c1139dd76a7c315848.png" data-download-href="https://forum.rebol.info/uploads/default/c7ca24fcd4556a03349509c1139dd76a7c315848" title="image"><img src="https://forum.rebol.info/uploads/default/optimized/1X/c7ca24fcd4556a03349509c1139dd76a7c315848_2_690x345.png" alt="image" data-base62-sha1="svq6LFOOe2vaqDYylmmkXtkMEQM" width="690" height="345" srcset="https://forum.rebol.info/uploads/default/optimized/1X/c7ca24fcd4556a03349509c1139dd76a7c315848_2_690x345.png, https://forum.rebol.info/uploads/default/optimized/1X/c7ca24fcd4556a03349509c1139dd76a7c315848_2_1035x517.png 1.5x, https://forum.rebol.info/uploads/default/original/1X/c7ca24fcd4556a03349509c1139dd76a7c315848.png 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/c7ca24fcd4556a03349509c1139dd76a7c315848_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">image</span><span class="informations">1366683 111 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<h1>It Really Is (Mostly) That Easy</h1>
<p>You can use it too.  So why not?  Remember it can run code on GitHub Actions Linux, Windows, and Mac containers too (just don't say <strong>web: true</strong> and it will detect the platform and download the right r3).</p>
<h1>...Web Automation Still Primitive, More Work To Do...</h1>
<p>You can see that it makes the last thing it does:</p>
<pre><code>print reverse {ETELPMOC TSET}
</code></pre>
<p>Then a setInterval()-based JavaScript timer kicks in every couple of seconds looking for the text "TEST COMPLETE".  This is not great for the long term.  We should be looking for something out of band (like the title bar of the browser, perhaps...<a href="http://titlewait.hostilefork.com/">I've done that before</a>)</p>
<p>The newlines are replaced with spaces because if the console gets a newline, it starts running code...and isn't responsive to keypresses until the prompt comes back again.  So characters get lost.  Stripping out the newlines is bad because if you have any semicolon comments to end of line, they will screw things up by turning the subsequent lines into comments.  Also it ruins multiline strings.</p>
<p>So a better way is needed to actually simulate hitting enter and then waiting (or the console needs to find a way to do keyboard buffering while code is running).</p>
<p>Deficiencies aside, it gives things more hope to have these kinds of tests.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/web-testing-now-takes-screenshots/1762">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/web-testing-now-takes-screenshots/1762</link>
          <pubDate>Mon, 29 Nov 2021 10:45:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1762</guid>
          <source url="https://forum.rebol.info/t/web-testing-now-takes-screenshots/1762.rss">Web Testing Now Takes Screenshots </source>
        </item>
        <item>
          <title>DO or IMPORT of GitHub/GitLab Decorated URLs on Desktop</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Modules</category>
          <description><![CDATA[
            <p>The "decorated" URL for a GitHub file looks like this:</p>
<p><a href="https://github.com/metaeducation/ren-c/blob/master/scripts/unzip.reb"><code>https://github.com/metaeducation/ren-c/blob/master/scripts/unzip.reb</code></a></p>
<p>And on GitLab, the "decorated" URLs looks like this:</p>
<p><a href="https://gitlab.com/Zhaoshirong/rebol-chess/-/blob/master/create-board.reb"><code>https://gitlab.com/Zhaoshirong/rebol-chess/-/blob/master/create-board.reb</code></a></p>
<p>I don't particularly like syntax highlighting (or at least not the kind done on Rebol files by these sites, which also happens to be buggy...so I turn it off on my repos).  But there are other good reasons to like using these links:</p>
<ul>
<li>
<p>It gives you context to see what project the file is in and to navigate around that project to see other related files.</p>
</li>
<li>
<p>You can click on a line number or line number range and then give that link to someone to point to a specific line you're talking to.</p>
</li>
<li>
<p>You have buttons for viewing the file history and "git blame" to see where changed lines came from.</p>
</li>
<li>
<p>If you're an owner on the repo, you can edit it right there in the browser and commit it.</p>
</li>
</ul>
<p><strong>But the HTML decorations mean these URLs give back code that the intepreter will choke on.</strong>  So historically, if you were going to DO or IMPORT them, you would have to translate them to raw links...which lack these conveniences:</p>
<p><a href="https://raw.githubusercontent.com/metaeducation/ren-c/master/scripts/unzip.reb"><code>https://raw.githubusercontent.com/metaeducation/ren-c/master/scripts/unzip.reb</code></a></p>
<p><a href="https://gitlab.com/Zhaoshirong/rebol-chess/-/raw/master/create-board.reb"><code>https://gitlab.com/Zhaoshirong/rebol-chess/-/raw/master/create-board.reb</code></a></p>
<p><em>(Interestingly the GitLab raw link is actually a character shorter than the decorated one, but the GitHub raw link is longer.)</em></p>
<p><strong>The web build has been willing to assume that when you say DO or IMPORT of the decorated link, what you want is the raw link.</strong></p>
<p>It wouldn't be good to redirect these URLs generally.  e.g. a READ might actually want to scrape the decorated HTML for something.  But since DO and IMPORT would just choke on the decorated URL, it's just helpful to automatically redirect them.</p>
<h2>Now This Feature is in the Desktop Builds Too</h2>
<p>By request from <a class="mention" href="/u/gchiu">@gchiu</a>, I moved the function that does this to <strong><code>sys.adjust-url-for-raw</code></strong> and it is run by the core DO and IMPORT functions on URLs.</p>
<p>It's a generic utility that can be used by similar functions.  So CSS-DO and JS-DO use the functions as well.</p>
<p>If a URL is adjusted it returns it, otherwise it returns NULL.  So this is used with MAYBE:</p>
<pre><code> url: maybe sys.adjust-url-for-raw url
</code></pre>
<p>As a reminder of what MAYBE does...it leaves the SET-WORD! on the left unchanged if the result on the right is NULL, otherwise sets it to the new value.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/do-or-import-of-github-gitlab-decorated-urls-on-desktop/1761">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/do-or-import-of-github-gitlab-decorated-urls-on-desktop/1761</link>
          <pubDate>Mon, 29 Nov 2021 09:33:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1761</guid>
          <source url="https://forum.rebol.info/t/do-or-import-of-github-gitlab-decorated-urls-on-desktop/1761.rss">DO or IMPORT of GitHub/GitLab Decorated URLs on Desktop</source>
        </item>
        <item>
          <title>Multi-Return: Deferred Enfix + Meta Returns</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>So multi-return is based on a (conceptually) simple trick for writing ordinary function calls.  The "extra returns" are really just refinements that are labeled as outputs, but you can invoke them normally as refinements that take a WORD!... as was done historically for extra outputs of a function.</p>
<p>Traditional code:</p>
<pre><code>&gt;&gt; block: transcode "1 2 3"
== [1 2 3]  ; defaults to assuming you want the whole thing transcoded

&gt;&gt; value: transcode/next "1 2 3" 'rest
== 1  ; asking for /next gives you just one value

&gt;&gt; rest
== " 2 3"  ; the REST word passed in gets assigned the remainder
</code></pre>
<p>Now for some  <img src="https://forum.rebol.info/images/emoji/twitter/candy.png?v=9" title=":candy:" class="emoji" alt=":candy:"> <a href="https://en.wikipedia.org/wiki/Syntactic_sugar"><strong>Syntactic Sugar</strong></a> <img src="https://forum.rebol.info/images/emoji/twitter/lollipop.png?v=9" title=":lollipop:" class="emoji" alt=":lollipop:"> that is enabled when NEXT is marked as an "output refinement" (<strong>next:</strong>) instead of an "ordinary refinement" (<strong>/next</strong>) in the function spec:</p>
<pre><code>&gt;&gt; [value rest]: transcode "1 2 3" 
== 1

&gt;&gt; value
== 1  ; the overall expression was 1, but value was also assigned 1

&gt;&gt; rest
== " 2 3"  ; just as if you'd named the /NEXT refinement and passed 'REST
</code></pre>
<h2>But There Have Been Enfix Complications...</h2>
<p>Though simple in concept, the multi-returns aren't completely simple in implementation...and at present run through a bit of different code than ordinary function calls (though of course most of the function execution, type checking, etc. are shared).</p>
<p>The parts that are different--however--were creating problems with enfix...which wasn't managed as part of the frame filling process.  So it just errored.</p>
<pre><code>&gt;&gt; [value rest]: transcode "1 2 3" then [&lt;item!&gt;]
** Script Error: Ambiguous infix expression--use GROUP! to clarify
</code></pre>
<p>You could get it to execute by putting the part before the THEN in a group:</p>
<pre><code>&gt;&gt; ([value rest]: transcode "1 2 3") then [&lt;item!&gt;]
== &lt;item!&gt;
</code></pre>
<p>Which works...<em>but what if that isn't the semantics you wanted?</em>  That means your overall expression evaluates to <code>&lt;item!&gt;</code> but value is still getting 1.</p>
<p>Consider that we usually want the result of an ELSE to get into the value of a variable:</p>
<pre><code>&gt;&gt; x: if 1 &gt; 2 [10] else [20]
== 20

&gt;&gt; x
== 20
</code></pre>
<p>If you had to write this with a GROUP! you'd get x as the result of the IF (null in this case, since 1 &lt; 2)</p>
<pre><code>&gt;&gt; (x: if 1 &gt; 2 [10]) else [20]
== 20

&gt;&gt; x
; null
</code></pre>
<p>So that's the situation we were in with multi-returns--not having a choice.  You'd wind up with the variable assigned the result of the original function...never being able to use the enfix product.</p>
<p><strong>It looks like I have a fix for this, so you'll be able to choose either way.</strong></p>
<h2>Recap of The No-Group-On-Right Limitation</h2>
<p>I've mentioned how being syntactic sugar kind of limits what we can do with multi-returns.  You can't put the right hand side in a group:</p>
<pre><code>[value rest]: (transcode "1 2 3")
</code></pre>
<p>This is because it could be more than one call, and you don't know what will come after it, and it could be arbitrarily deep:</p>
<pre><code>[value rest]: ((((transcode "1 2 3", ...))))
</code></pre>
<p>You <em>might</em> argue we could still allow it if the multi-returns are tunneled down to the function and the value gets assigned from the final product of the group.</p>
<p>But I don't like it because then you are talking about something that left quoting enfix couldn't do.  I like the idea that when you get in a pinch and want to override a multi-return assignment you could do it by declaring your function enfix and pick up the SET-BLOCK! on the left as a parameter.</p>
<p>That interchangeability offers a good dynamic, and it's how <a href="https://forum.rebol.info/t/a-lot-to-unpack-replacing-the-set-of-reduce-block-idiom/1634">things like UNPACK</a> fit into this universe...where they seem like first-class language features.  Doing crazy things that don't relate to what users could build themselves isn't the ergonomic we're looking for (e.g. "bad lego alligator" territory).</p>
<h2>The Meta Dilemma</h2>
<p>The hard rule that the thing on the right of the SET-BLOCK! be the function with the multi-returns caused a problem with wanting to ask for the "meta" result.</p>
<p>UPARSE has this desire often.  It may be that a parser returns something like an unset or a null isotope.  We want to handle those distinctly from nulls, as well as to not choke on them as invalid variables.  So we ask for the meta-result of the parser.</p>
<p>I wrote a special exemption to allow it, like this:</p>
<pre><code>([result progress]: ^ parser input) then [...]
</code></pre>
<p>Recognizing the <strong>^</strong> specially in the multi-return code felt wrong.  Where do such things stop...why not <strong>([...]: ^ ^ ^ parser input)</strong> ?  It has a similar arbitrariness to it that digging through parentheses seemed to have.</p>
<p>But with the META-WORD! we had a new option...to put the meta on the argument itself:</p>
<pre><code>([^result progress]: parser input) then [...]
</code></pre>
<p>To some people's tastes maybe that looks worse.  but it is more compact.  And it can work even if you don't name a variable:</p>
<pre><code>&gt;&gt; [^ rest]: transcode "1 2 3"
== '1
</code></pre>
<p>It feels more like things are in the right place this way.  Multi-return was prototyped as just an application of enfix quoting blocks on the left of a function...and I kind of like it not straying too far from what that could do.  This is within reach of that.</p>
<p>These might seem like small things, but, they are important.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/multi-return-deferred-enfix-meta-returns/1759">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/multi-return-deferred-enfix-meta-returns/1759</link>
          <pubDate>Fri, 26 Nov 2021 14:18:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1759</guid>
          <source url="https://forum.rebol.info/t/multi-return-deferred-enfix-meta-returns/1759.rss">Multi-Return: Deferred Enfix + Meta Returns</source>
        </item>
        <item>
          <title>Tuple Troubles: Version 0.3.01 vs 0.3.1</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>For better or worse, versioning in Rebol has used TUPLE!.  e.g. 0.3.1 is 32-bit Windows, and 0.3.40 is 64-bit Windows</p>
<p>If you go back and look at the old R3-Alpha file <strong><a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/tools/systems.r#L21">%systems.r</a></strong> you can see that it's pretty typical for Carl to have written the versions out with leading zeros...<em>but only in the third slot</em>.  So <code>0.3.01</code> but not <code>00.03.01</code></p>
<p>But ultimately the tuple discards this information.  And this has been the way it always worked:</p>
<pre><code>rebol2&gt;&gt; 0.3.01
== 0.3.1

red&gt;&gt; 0.3.01
== 0.3.1

ren-c&gt;&gt; 0.3.01
== 0.3.1
</code></pre>
<p>This leads to problems when you are working with string representations outside of Rebol (say in bash shell, something like "0.3.01") and you pass it into Rebol to process as a tuple.  If bash went and created a directory based on the string...you won't match if you FORM that tuple later.</p>
<p>You could insist on passing around the tuple as a string, but that undermines the value of having the version be in a tuple in the first place.</p>
<p>I'd say that the simplest solution is just to stop writing tuples with the leading zeros...instead keeping them in their canon form.  0.3.1 for 32-bit Windows, and 0.3.40 for 64-bit Windows.  Then make the directories reflect this, e.g.:</p>
<pre><code>https://dd498l1ilnrxu.cloudfront.net/travis-builds/0.3.1/r3-573037b-debug.exe
</code></pre>
<p>and not:</p>
<pre><code>https://dd498l1ilnrxu.cloudfront.net/travis-builds/0.3.01/r3-573037b-debug.exe
</code></pre>
<p>That leading zero comes with a whole lot of headaches, so I say hunt them down and get rid of them.  Because non-Rebol systems are going to only operate on them as strings and they'll leak.</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/tuple-troubles-version-0-3-01-vs-0-3-1/1755">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/tuple-troubles-version-0-3-01-vs-0-3-1/1755</link>
          <pubDate>Wed, 24 Nov 2021 13:28:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1755</guid>
          <source url="https://forum.rebol.info/t/tuple-troubles-version-0-3-01-vs-0-3-1/1755.rss">Tuple Troubles: Version 0.3.01 vs 0.3.1</source>
        </item>
        <item>
          <title>Kaj Gets on the Meta Train</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>So Kaj is still out there somewhere, working on a spiritual competitor to Red he is calling "Meta". <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=9" title=":roll_eyes:" class="emoji" alt=":roll_eyes:"></p>
<p><a href="https://language.metaproject.frl/">https://language.metaproject.frl/</a></p>
<p>His first target is the Atari 2600 <img src="https://forum.rebol.info/images/emoji/twitter/joystick.png?v=9" title=":joystick:" class="emoji" alt=":joystick:"><img src="https://forum.rebol.info/images/emoji/twitter/space_invader.png?v=9" title=":space_invader:" class="emoji" alt=":space_invader:">  so he's certainly starting from... the basics.</p>
<p><em>(For whatever it's worth, I actually am interested in things like Atari 2600 programming and seeing what you can do with modern tools.  e.g. there's a neat <a href="https://youtu.be/4X1NdKvNCYQ?t=459">reboot of PAC-MAN</a> and I think a lot of people would like to know what <strong>could</strong> have been done, theoretically.)</em></p>
<p>There's no source code by which to measure the amount of investment the project represents so far.  He's only giving out binaries, and says:</p>
<blockquote>
<p>"There will always be a free version of <em>Meta</em>. We will build a business on top of it, by offering paid premium versions and other products built with <em>Meta</em>."</p>
</blockquote>
<h2>What's The Mission Difference From Red?</h2>
<p>Seemingly not much.  But inevitably, one angle is going to be "faster":</p>
<blockquote>
<p>"Red/System is the wrong abstraction level and the wrong format for an intermediate language, certainly for a REBOL language. The abstraction level is that of C, which is too low for the intermediate layer. The format is that of REBOL, which is free form for human use. Red is parsed from free form to something more suitable for machine processing, then a lot of Red/System is generated, then all of that needs to be reparsed. The compiler is painfully slow."</p>
</blockquote>
<p>But he's willing to build on LLVM to start with.  I'd said that Red should aim for a LLVM-subset IR, that could then be built with either a simple/small custom emitter or the full "bloated" toolchain if one really wanted to.  That would have provided a fallback; but Nenad wasn't a fan of the LLVM instruction set for some reason, and had ideas about exposing lower-level CPU features (maybe that was why).</p>
<p>So at least in this sense Kaj's approach seems more pragmatic to me.</p>
<p>Also inevitably: having people to work with was slowing him down.  He'll make much more progress on his own, <a href="https://atariage.com/forums/topic/315558-a-new-language-for-the-atari/?tab=comments#comment-4719124">as we find from his Atari Forum post</a>:</p>
<blockquote>
<p>Red was launched on a REBOL conference of mine in the Netherlands. I helped launch the language and contributed to it for half a decade. After that I left the project, because I am disappointed that it hasn't fulfilled its promises.</p>
<p>Before all that, I contributed to the latest version of REBOL and lobbied its creator Carl Sassenrath to open-source it. It eventually was, and REBOL could have done most of what Red promised, but Carl abandoned it when his funding ran out. After the leader left, the project was torn apart by competing interests.</p>
<p>My language is meant to succeed both REBOL and Red.</p>
</blockquote>
<h2>There's only ONE Download for Windows, Linux, Mac...?</h2>
<p>On the surface this seems interesting: he's using something called the <a href="https://justine.lol/ape.html">"APE: Actually Portable Executable"</a> format.  You can use a single download for all platforms--the same single file.  It puts x86 code into a container that can run as either a Windows .COM file or a unix shell script.</p>
<p>It's a stunt which isn't really all <em>that</em> profound--though I'll admit I'd wondered if there was some polyglot trick that could do exactly this.  Turns out the answer is yes...so that's cool.  I'm glad someone did it.</p>
<p>But it has more relevance to writing viruses than it does to practical cross-platform development.  Launching the code is a drop in the bucket compared to all the other things you need to worry about in a useful platform abstraction layer.  Not to mention that obviously Macs are now on ARM, so the binaries would have to be emulated or include both instruction sets.</p>
<p>At this juncture, running WebAssembly in a browser is far more compelling a story...because you have the whole web runtime available.</p>
<p>Anyway I doubt he's married to the APE format and is just trying it out because it seems cool.  It's not something I want to worry over.  And for what it's worth, it doesn't work for me on Windows 11.  YMMV.</p>
<h2>Source Comparison?</h2>
<p>Not much is available to compare.  His examples don't have headers, which is one of the more defining historical properties of Rebol programs.  The word "header" is not mentioned in his manifesto, so it's not clear if that's temporary or permanent.</p>
<p>Here's a Fibonacci example:</p>
<pre><code>; Maximum 24 for natural16! result
; Max 47 for natural32! result
parameter= 24
 
print "Fibonacci "  print parameter  print ": "
 
natural! [Fibonacci previous]
; natural32! [Fibonacci previous]
 
either parameter &lt;= 1 [
    Fibonacci: parameter  ; Fibonacci 0 ... 1
][
    Fibonacci: previous: 1  ; Fibonacci 2

    loop parameter - 2 [
        previous: also
            Fibonacci
            Fibonacci: Fibonacci + previous
     ]
]
 
print/line Fibonacci 
</code></pre>
<p>So...</p>
<ul>
<li>
<p>It seems he wants PRINT to not include a newline, so you have to say PRINT/LINE to get it.</p>
<ul>
<li>I prefer the solution of asking those who really want partial line output (e.g. console prompts) to WRITE STDOUT directly...and that PRINT COLLECT be used as a pattern when your code is piecing together a full line from parts generated by distinct bits of code, KEEP-ing each part.</li>
</ul>
</li>
<li>
<p>Working on Atari means he's getting involved in things like INTEGER16!, and you optimize based on annotating datatypes like that.  I'm more of the "bignum by default" philosophy, so different indeed.</p>
<ul>
<li>Putting <strong>natural! [Fibonacci previous]</strong> in the middle of the code to constrain the type--not in a function spec--suggests this is really rather far afield from the evaluator-driven Rebol.</li>
</ul>
</li>
<li>
<p>He's trotting out historical ALSO in a first example.  No one in the Atari forum clapped with amazement at the genius several Rebolers seem to think it represents.  (So I feel pretty comfortable with <strong><a href="https://forum.rebol.info/t/enfixing-also-stylizing-it-after-then-and-else/402">Ren-C's ALSO and ELIDE</a></strong>.)</p>
</li>
</ul>
<p>Without more to look at I can't have more to say.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/kaj-gets-on-the-meta-train/1753">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/kaj-gets-on-the-meta-train/1753</link>
          <pubDate>Sat, 20 Nov 2021 23:44:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1753</guid>
          <source url="https://forum.rebol.info/t/kaj-gets-on-the-meta-train/1753.rss">Kaj Gets on the Meta Train</source>
        </item>
        <item>
          <title>Weird Dynamic Binding Idea: Climbing The Chain?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Binding</category>
          <description><![CDATA[
            <p>I've lamented the performance impacts of having to search "specifier" binding chains to look things up, and how it's nice that it finds newly emerging elements (like declarations that get added to modules) but how uncacheable it is...</p>
<p>But there's an odd thing about a chain of lookup that keeps compounding, in that you could ask not to take the <em>first</em> match, but to involve a count of how many times you've found it.</p>
<p><em>There are already some ideas for what leading tuple might mean, <strong>but</strong></em>... let's imagine it being used for this purpose.  It could be something else:</p>
<pre><code>x: 10

foo: func [x] [
    let x: 30
    print [x .x ..x]   ; What if this printed `30 20 10` ??
]

foo 20
</code></pre>
<p>Just a thought.  Things are pretty chaotic in binding, and having code demonstrate such a "meta-awareness" of what's going on in the binding above seems like it could be moreso.  But it's crossed my mind a couple times so I thought I'd mention it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/weird-dynamic-binding-idea-climbing-the-chain/1752">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/weird-dynamic-binding-idea-climbing-the-chain/1752</link>
          <pubDate>Wed, 27 Oct 2021 09:11:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1752</guid>
          <source url="https://forum.rebol.info/t/weird-dynamic-binding-idea-climbing-the-chain/1752.rss">Weird Dynamic Binding Idea: Climbing The Chain?</source>
        </item>
        <item>
          <title>Rebol And Scopes: Well, Why Not?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Binding</category>
          <description><![CDATA[
            <p>It's frequently said that Rebol "doesn't have scope".  Early examples of that premise might point to something like a block of:</p>
<pre><code>[x x x y y y]
</code></pre>
<p>Then people might say that the Xs and Ys can all resolve to something different.</p>
<pre><code>&gt;&gt; print [x x x y y y]
10 20 "foo" 30 40 "bar"
</code></pre>
<p>I find it personally frustrating when this is pronounced with glee (as per Red Gitter <em>"there is no spoon!"</em>)...vs. acknowledging that this should seem very alarming.  When you do something weird the burden of proof is on you to prove its benefit.</p>
<h2>Were Scopes Rejected Because They're Somehow Bad?</h2>
<p>No.</p>
<p><em>It's because Rebol's dynamic nature means there isn't a clear moment in time where code can be holistically analyzed to determine scopes</em>.  Code structures are always getting cobbled together from pieces...from disparate locations in the codebase, or sometimes fabricated from thin air with <em>no</em> context.</p>
<p>So it hasn't had scopes because it hasn't been able to.</p>
<p>BUT with the prototypes I've done with string interning, it integrates something like "scopes".</p>
<pre><code>&gt;&gt; print interpolate {Scopes? $x $x $x $y $y $y}
Scopes? 10 10 10 foo foo foo
</code></pre>
<p>When a string carries along a "binding", it only carries one.  And that effectively captures some map from words to values.  So the answer to "what is X" and "what is Y" will be the same each time you ask that mapping referenced by that string.</p>
<p>If that's not a "scope", what is it?  And is there a reason the system as a whole should not use them?</p>
<h2>Historical Rebol Used Mutable Binding</h2>
<p>Historical Rebol's idea of binding is that ANY-WORD!s get bits in the cell representing an object they are looked up in.  This process of gluing on bindings was done "every now and again" by code that walks around--usually deeply--and mutably changes data it is given.</p>
<p><strong>On the plus side: programmability.</strong>  If you received a BLOCK! and wanted to go through and say that every SET-WORD! that starts with a vowel is going to be bound to some new object, but others will be left as-is, you can do that.  You can examine not only the properties of the structure, but also make decisions on what the previous binding was...selecting to override some references of the same named variable while leaving others alone.</p>
<p>(Note: Some binding queries didn't give useful information.  If you asked for the binding of a word linked to a function argument or local, it would just say "true".)</p>
<p><strong>On the plus side: performance.</strong>  If you're dealing with a concept of binding that wants to freeze in time at the moment you run a bind pass, you can cache the notion of which object and which index in that object a word will be found at.  Although...</p>
<p>...<strong>On the minus side: requires lots of copies (adversely affects performance, and it's not clear when to make them).</strong> If you assume every value has a binding it can mutably disrupt, this complicates situations where a piece of code needs to be viewed in more than one way.  Just one example is the idea that every method in an object would need to be copied deeply so that its code could be rebound to that object's instance variables.</p>
<p><strong>Also on the minus side: no reaction to changes.</strong>  For instance, you might bind some code into a place like the LIB context...but later add a new declaration to LIB.  The addition will not be seen.</p>
<h2>Ren-C Began To "Virtualize" Binding</h2>
<p>A big focus in Ren-C has been experimenting with binding forms that don't a-priori walk deeply at the outset, but that trickle down and spread as you descend into array structures...each step propagating something called a "specifier".</p>
<p>One of the first instances was when you run a function body, a specifier would be added that would be the FRAME! of that function's variables.  It starts propagating by slipping a pointer into an extracted block cell for the body when it gets a DO at the top level.  That pointer travels along through nested blocks, so those become aware of the function instance it relates to...one extraction at a time.  Similar techniques allow object instance methods to be differentiated while running the same code used in other objects...the function bodies are the same arrays, but the specifier facilitates finding the object instance.</p>
<p>There are various incarnations of this technique of having binding be a "view" on an array of values, without having to actually touch the bits in arrays.  But the general name for these techniques I've adopted is <strong>virtual binding</strong>.</p>
<h2>String Interpolation Tries <em>Fully Virtualized Binding</em>
</h2>
<p>At first specifiers were just for functions and methods.  But the concept of making specifiers accrue a more complete map of a persistent binding environment is very tempting, allowing things like <a href="https://forum.rebol.info/t/could-strings-have-context/587/10">binding lookup in strings</a>.</p>
<p>The idea behind the prototype that lets you look up a map from WORD! =&gt; value on strings is that specifiers compound together in chains.  A new link is added each time something new to consider is added.</p>
<p>So let's look at that model of operation for something like:</p>
<pre><code> global: 10
 x: &lt;not an integer&gt;

 foo: func [x] [
     let local: 20
     return interpolate {The sum is $(x + local)}
 ]

 foo 30
</code></pre>
<p>The virtual bind chain starts out with a module context that has <code>global</code>, <code>x</code>, and <code>foo</code> in it.  This is all there is to stick on the BLOCK!s that gets passed to FUNC.  So the spec and body are blocks with a module as the specifier.</p>
<p>FUNC stows the body block away in an ACTION! that it generates.  Later when it gets invoked, it creates a FRAME! with <code>return</code> and <code>x</code> in it...and puts that in a chain <em>with</em> the module context.  So upon entry to the function body, that body is being executed with a specifier that looks in the frame first (would find that x) and then in the module second (would find <code>global</code> and <code>foo</code>).  This compound specifier is what the evaluator state initially has for that body block.</p>
<p>The module inherits from the LIB context, so things like LET and INTERPOLATE will be found by means of that inheritance.  So then LET runs...using a special ability to add another link in the chain to the specifier that the evaluator is using, for the word <code>local</code>.</p>
<p>Finally we get to the RETURN (it's in the frame) and INTERPOLATE (falling through to the module) and the whole specifier chain is stuck onto the string.  Because the specifier has snowballed all the information <em>the string could look up anything</em> (except the X in the module that's hidden).</p>
<p><strong>In simple cases like this, it's essentially just like scope.</strong>   There are no situations that introduce contention.  The flow of context is from the top to the bottom, and there's no parts being unplugged from one place and into another.</p>
<h2>But What If You Did Unplug and Replug Things?</h2>
<p>Let's just look at a <em>super simple</em> example of throwing a COMPOSE into the mix.  So instead of calling INTERPOLATE directly, you made a call to another function, WRAPPER:</p>
<pre><code> global: 10
 x: &lt;not an integer&gt;

 wrapper: func [string] [
     return do compose [interpolate (string)]
 ]

 foo: func [x] [
     let local: 20
     return wrapper {The sum is $(x + local)}
 ]

 foo 30
</code></pre>
<p>When wrapper runs, the same basic logic applies to how "scopes" are gathered...and applied to the body of the function when it executes.  But that COMPOSE is splicing in a string that already has a binding on it.  How does the specifier flowing downward (which has the module's X) interact with the specifier already on that string (which has FOO's X overriding the module's X)?</p>
<p><strong>A simple thought is a default of leaving bindings alone if they already have one.</strong> This seems obviously better than blindly overwriting, because it gives you a simple choice if you want overwriting to happen... you could just unbind the string:</p>
<pre><code> wrapper: func [string] [
     return do compose [interpolate (unbind string)]
 ]
</code></pre>
<p>But all-or-nothing doesn't cover a lot of scenarios.  If you're dynamically creating a function with some block material you got "from somewhere else", that material may have been written with the express knowledge that certain words were supposed to be overridden by the place it's being substituted, with others left alone.</p>
<p>Also, what if you had a rule like <em>"I want all the GROUP!s in this code to be bound to FOO but only inside the GROUP!s"</em>?</p>
<h2>Could Binding Be Functional?</h2>
<p>If you want a programmable sense of binding that doesn't resort to deep walking the structure and mutating it directly... you could allow the binding "specifier" to be (at least conceptually) a function.  That function could be passed the existing binding as an argument, and make a decision based on that of how to resolve it.</p>
<p>This would result in a kind of "programmable specifier", that only injects its influence <em>if and when</em> a descent into a block with the desire to execute it occurs.</p>
<p>Whether you could <em>actually</em> provide a function, or just speak in a "mini dialect" of merge and override instructions that behaved as a function, I don't know.  A real usermode function doing the bind merge logic sounds expensive (but would it be worse than deep walking and selectively binding a tree of code?  Who knows.)</p>
<h2>Pure Virtual Binding Has No Obvious Way To Cache</h2>
<p>One advantage to storing the "scope chain" is that if contexts in that chain have things added or removed, the evaluation can pick up the change...</p>
<p>...but a <em>disadvantage</em> is that it's hard to see any way to efficiently remember where to look up bindings.  Where you found a word on the last lookup might not be the same place that you would on the next lookup, if any objects/modules in the chain have changed.  Thinking of binding as some sort of black box function makes this even more intractable than it already is.</p>
<p><strong>But I really feel the deep walking with putting bindings on things is a dead end.</strong>  That just makes it feel like the focus needs to be on figuring out this means of dialecting the resolution of scopes at the merge points.  There needs to be a richer language than just "unbind" and "no-op" for what you do at these points...but I don't think walking the blocks and pasting bindings on particular items is viable.</p>
<h2>I Think "Scopes" Have To Come Into Play</h2>
<p>Rebol's word soup for binding has always been <a href="https://en.wikipedia.org/wiki/DWIM">DWIM technology</a>.  ("do what I mean")  So there's no schematic for how to do this.  It's fundamentally based on wishful thinking.</p>
<p>The concept of having a fully granular ability to go down to the WORD!-level in a structure of code and declare what <em>that one word</em> points to may seem like it puts all the power in your hands.  But that power has proven difficult or impossible to wield in non-trivial situations... runs afoul of blocks that are imaged multiple places in the source... and winds up leaving code stale and oblivious to when new declarations arise at moments they don't expect.</p>
<p><strong>What puts me over the top in thinking we need "scopes" is bindings in strings.</strong>  Features based on string interpolation are so undeniably useful that once the possibilities are seen, they can't be unseen.</p>
<p>But also, what about debuggers that might want to show you lists of what variables are "in scope" at a certain point of execution?  There are a lot of reasons to have a running tally of which contexts and declarations are visible.</p>
<p><strong>Yet it's important to realize this is kind of just kicking the can down the road a bit: There's no rigorous way to give meaning to word soup being arranged haphazardly.</strong>  What has been able to succeed in Rebol so far (to the extent you can call existing binding "success") is really just the by-product of fairly unambitious code.  "It looks like it works because nothing difficult is being tried."</p>
<p>Eliminating mutable binding and asking lookup to be accomplished by some nebulous "scope merging" language doesn't have an obvious magic to it.  Beyond that, I don't know how to cache it.  <strong>So this is a radical idea that may just lead to frustration and the slow death of the project.</strong>  <img src="https://forum.rebol.info/images/emoji/twitter/skull_and_crossbones.png?v=9" title=":skull_and_crossbones:" class="emoji" alt=":skull_and_crossbones:"></p>
<p>But I have said that before about other things that worked out okay.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=9" title=":man_shrugging:" class="emoji" alt=":man_shrugging:"></p>
<p>We'll see.</p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751</link>
          <pubDate>Wed, 27 Oct 2021 03:57:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1751</guid>
          <source url="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751.rss">Rebol And Scopes: Well, Why Not?</source>
        </item>
        <item>
          <title>&quot;Raw&quot; Strings</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>I'm now 99% sure that { } best serves its purpose as a string form.</p>
<p>But there were several talking points that came out of that discussion.  One was a desire for "raw" strings.</p>
<p>This is the idea that outside of the termination sequence, there's <em>no</em> escaping.  This means you can put pretty much anything in the string.  Backslashes, carets...it's all fair game.</p>
<h2>Two Very Different String Forms: When Are They Raw?</h2>
<p>To <em>me</em>, it made the most sense that the raw form be the braced form...because it is so frequently applied to sections of arbitrary documentation text (such as the Description: in module headers).</p>
<pre><code>Description: {
    If you call this from C, then write:

        if (a ^ b != 0) {  // bitwise XOR
            printf("This is an example\n");
        }

     So there you see carets and backslashes working.
}
</code></pre>
<p>With binding support for string interpolation, we can imagine this getting even more useful for representing snippets of other languages with escaped portions inside of them.</p>
<p>However, <a class="mention" href="/u/giuliolunati">@giuliolunati</a> favored the idea of making quoted strings <em>mostly-raw</em>, because there was an easy-seeming way to escape quotes using only the quote character.</p>
<pre><code>&gt;&gt; "This would be ""quotes"" inside a string"
== {This would be "quotes" inside a string}
</code></pre>
<p>How braces are escaped historically ( e.g. <code>^}</code> ) is messier.  That drags caret into it, so now you're worrying about needing to escape carets and braces.  A more uniform approach appealed to Giulio, so he favored the quotes form...and would prefer it to be able to represent characters "as-is" by default, with this exception for embedded quotes.</p>
<p>But from my point of view, I was seeking to avoid is any need to do search/replace on the embedded information.  So <em>mostly-raw</em> wasn't good enough; e.g. I'd like to copy and paste the C code out of the example above, not have its quotes doubled:</p>
<pre><code>Description: "
    if (a ^ b != 0) {  // bitwise XOR
        printf(""This is an example\n"");   &lt;-- doubled quotes not good
    }
"
</code></pre>
<p>We also discussed that I'm averse to having ordinary quotes as multi-line strings... though maybe we should allow them.  :-/  But even if we did, it feels unintentionally incomplete to see something like:</p>
<pre><code>Description: "
</code></pre>
<p>So for these reasons I wanted to focus the raw string effort on braced strings.  Yet there are a lot of things that it gets hard to represent in a raw string form when you try to use unmatched braces in the content.</p>
<p>After thinking about it a bit, we came up with the option of being able to set the delimiter according to a number of braces and a vertical bar.</p>
<pre><code>{...}  ; expects any { } inside to be matched pairs 
{|...|}  ; allows internal unpaired and mismatched { }, {| |} matched pairs
{{|...|}}  ; allows internal unpaired and mismatched {| |}, {{| |}} matched
</code></pre>
<p>etc. etc.</p>
<p>This can handle some pretty sticky strings like <strong><code>{|ab"c"} {"d"ef|}</code></strong> if need be, where the data extracted is:</p>
<pre><code>ab"c"} {"d"ef
</code></pre>
<p>The approach would allow any number of {{ }}, which sounds like it could get ugly.  But it's kind of like generic quoting, where I don't anticipate people using ridiculously high levels like {{{{|...|}}}}.  But having it be a general method has value--especially in generated code scenarios.</p>
<p>Strings starting or ending with vertical bar forms like <strong>{|}</strong> get sacrificed, so you'll have to use "|" instead.  But you would use "}" so this just moves | into the same category as } and {.</p>
<p>I also suggested an additional rule...that you don't terminate braced strings except as:</p>
<ul>
<li>{...} -space-</li>
<li>{...} -newline-</li>
<li>{...}]</li>
<li>{...})</li>
</ul>
<p>If we limit it to these possibilities, you can write things like:</p>
<pre><code> code: {char c = '}';}
</code></pre>
<p>It seems that a lot of unpaired brace cases are single character literals like this, which don't fall under the rule.  You might want to put the bars in for good measure anyway:</p>
<pre><code> code: {|char c = '}';|}
</code></pre>
<p>In any case, the other thing we were leaning toward here was that when quoted strings are escaped, they do so compatibility with the classical C backslashes, based on the idea that caret escaping hadn't done the language any particular favors.</p>
<p>Just wanted to write this up while I still was thinking about it... <img src="https://forum.rebol.info/images/emoji/twitter/zzz.png?v=9" title=":zzz:" class="emoji" alt=":zzz:"></p>
            <p><small>16 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/raw-strings/1750">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/raw-strings/1750</link>
          <pubDate>Sat, 23 Oct 2021 13:33:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1750</guid>
          <source url="https://forum.rebol.info/t/raw-strings/1750.rss">&quot;Raw&quot; Strings</source>
        </item>
  </channel>
</rss>

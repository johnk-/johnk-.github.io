<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>WebAssembly - AltRebol</title>
    <link>https://forum.rebol.info/c/development/emscripten/5</link>
    <description>Topics in the &#39;WebAssembly&#39; category There are currently two ways in which Ren-C is built to WebAssembly:</description>
    
      <lastBuildDate>Wed, 18 Oct 2023 01:41:17 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/emscripten/5.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Building C++ GUI Code that Calls Ren-C Wasm and Runs in Browser</title>
          <dc:creator><![CDATA[OneArb]]></dc:creator>
          <category>WebAssembly</category>
          <description><![CDATA[
            <p>There is a quite active <a href="https://github.com/ocornut/imgui" rel="noopener nofollow ugc">Dear ImGui immediate mode GUI library</a> running on Emscript: <a href="https://github.com/jnmaloney/WebGui" rel="noopener nofollow ugc">WebGui</a>.</p>
<p>Dear ImGui provides just about any widget one might wish for.</p>
<p><a href="https://jnmaloney.github.io/WebGui/imgui.html" rel="noopener nofollow ugc">Wasm WebGui demo</a> runs at 60 FPS.</p>
<p>My roadmap is to embed Ren-C and bind the ImGui functions I need. I already have a skeleton parser that converts text into ImGUI function calls.</p>
<p>The code allows creating / modifying windows along with a few widgets at runtime.</p>
<p><a href="https://github.com/ocornut/imgui/discussions/3890" rel="noopener nofollow ugc">Dear ImGUI uses a minimal C++ set</a> and remains class and standard container free.</p>
<p>The only piece I'd be missing is the RPL interpreter if I am comprehending Ren-C feature set.</p>
<p>I'd also like to be able to grant filesystem access for the Wasm web instance using WASI API.  Here's an example where WASI is already implements accessing an OS directory from a Web instance:</p>
<p><a href="https://www.perplexity.ai/search/C-example-of-4jA7fNiiQSWtKthpleu2pQ?s=c" rel="noopener nofollow ugc">https://www.perplexity.ai/search/C-example-of-4jA7fNiiQSWtKthpleu2pQ?s=c</a></p>
<p>The use case can be distributing a chat GUI application launched through a browser running from the Internet using <a href="https://gist.github.com/nus/564e9e57e4c107faa1a45b8332c265b9" rel="noopener nofollow ugc">emscripten WebSocket support</a> or even full TCP UDP connections.</p>
            <p><small>10 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/building-c-gui-code-that-calls-ren-c-wasm-and-runs-in-browser/2053">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/building-c-gui-code-that-calls-ren-c-wasm-and-runs-in-browser/2053</link>
          <pubDate>Wed, 18 Oct 2023 01:41:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2053</guid>
          <source url="https://forum.rebol.info/t/building-c-gui-code-that-calls-ren-c-wasm-and-runs-in-browser/2053.rss">Building C++ GUI Code that Calls Ren-C Wasm and Runs in Browser</source>
        </item>
        <item>
          <title>WASI Encap: Embedding Read-Only Filesystems in .wasm Blobs?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>WebAssembly</category>
          <description><![CDATA[
            <p>I found this project which looks promising:</p>
<p><a href="https://github.com/kateinoigakukun/wasi-vfs" class="inline-onebox">GitHub - kateinoigakukun/wasi-vfs: A virtual filesystem layer for WASI.</a></p>
<p>It includes a tool which can pack a directory into a .wasm file, and then you can read that directory from within the Wasm code itself.</p>
<p>Right now it's not a priority to look into, given that I added BASIC-READ and BASIC-WRITE to the WASI build.  If someone can prove the limit to using WASI effectively is that they have to distribute their project as a .zip and grant the runtime directory access (instead of as a single .wasm file) that seems like the time to attack it.</p>
<p>So... far future.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/wasi-encap-embedding-read-only-filesystems-in-wasm-blobs/2052">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/wasi-encap-embedding-read-only-filesystems-in-wasm-blobs/2052</link>
          <pubDate>Tue, 17 Oct 2023 13:39:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2052</guid>
          <source url="https://forum.rebol.info/t/wasi-encap-embedding-read-only-filesystems-in-wasm-blobs/2052.rss">WASI Encap: Embedding Read-Only Filesystems in .wasm Blobs?</source>
        </item>
        <item>
          <title>Networking Calls from Ren-C WASI Build?</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>WebAssembly</category>
          <description><![CDATA[
            <p>As far as I understand it, we need to wait until the hooks for WASI are built into the C/C++ compilers used to build Rebol so that not only can we print "EHLO world" but we can also do networking.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/networking-calls-from-ren-c-wasi-build/2054">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/networking-calls-from-ren-c-wasi-build/2054</link>
          <pubDate>Tue, 05 Jul 2022 02:40:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2054</guid>
          <source url="https://forum.rebol.info/t/networking-calls-from-ren-c-wasi-build/2054.rss">Networking Calls from Ren-C WASI Build?</source>
        </item>
        <item>
          <title>Ren-C is Now on the Clouds ☁️ with WASI</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>WebAssembly</category>
          <description><![CDATA[
            <blockquote>
<p>Note: WASI =&gt; WebAssembly System Interface</p>
</blockquote>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/26d1a0133b87b8f3ac7008467a4d6b29d6c21069.png" data-download-href="https://forum.rebol.info/uploads/default/26d1a0133b87b8f3ac7008467a4d6b29d6c21069" title="image"><img src="https://forum.rebol.info/uploads/default/optimized/1X/26d1a0133b87b8f3ac7008467a4d6b29d6c21069_2_207x108.png" alt="image" data-base62-sha1="5xpgmNShmHOnF7AMwpjAGNfL3v3" width="207" height="108" srcset="https://forum.rebol.info/uploads/default/optimized/1X/26d1a0133b87b8f3ac7008467a4d6b29d6c21069_2_207x108.png, https://forum.rebol.info/uploads/default/optimized/1X/26d1a0133b87b8f3ac7008467a4d6b29d6c21069_2_310x162.png 1.5x, https://forum.rebol.info/uploads/default/optimized/1X/26d1a0133b87b8f3ac7008467a4d6b29d6c21069_2_414x216.png 2x" data-dominant-color="7054BA"></a></div><p></p>
<p>We've been running in a browser for a while.  And over time, as that host environment has gotten better...we've been getting better, too.  (It can <sub>sometimes</sub> pay to be an early adopter and co-evolve with a platform.)</p>
<p>After several long days of nuanced work, I've been able to take another step...running in a WasmEdge VM!</p>
<p>Unlike the web version, this has the command-line processing built into it.  So you can pass <code>wasmedge</code> the %r3.wasm file, and say something like <strong><code>--do</code></strong> of the code you want to run:</p>
<pre><code>$ wasmedge r3.wasm --do \
      "print ['** uparse {Hello, Cloud} [thru space across to &lt;end&gt;] '**]"
</code></pre>
<p>Then you get your result:</p>
<pre><code>** Cloud **
</code></pre>
<p><strong><a href="https://github.com/metaeducation/ren-c/runs/7140995235?check_suite_focus=true#step:18:4">See for yourself, on the GitHub Workflow that builds it!!!!</a></strong></p>
<h1>
<a name="so-er-so-what-subsomeone-might-asksub-1" class="anchor" href="https://forum.rebol.info#so-er-so-what-subsomeone-might-asksub-1"></a>"So... er... so what?" <sub>(someone might ask)</sub>
</h1>
<p>... WH-</p>
<p>... WH- WHAT YOU DO MEAN, <em>"SO WHAT?"</em> ... YOU, you... <em>IGNORAMUS</em>!</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/angry.png?v=12" title=":angry:" class="emoji only-emoji" alt=":angry:" loading="lazy" width="20" height="20"><br>
...</p>
<p>Oh, all right, well.  Fine.  Let me try and break down what this is... and what it might mean for Ren-C's future in the cloud space (and elsewhere).</p>
<hr>
<h1>
<a name="first-lets-talk-about-the-dream-that-isnt-subyetsub-2" class="anchor" href="https://forum.rebol.info#first-lets-talk-about-the-dream-that-isnt-subyetsub-2"></a>First Let's Talk About <em>"The Dream That Isn't"</em> <sub>(yet)</sub>
</h1>
<p>...and that dream is "SERVERLESS"-ness.</p>
<ul>
<li>
<p>Picture if you will, the idea that we take <code>%httpd.reb</code> and shoot it into the sun... <img src="https://forum.rebol.info/images/emoji/twitter/rocket.png?v=12" title=":rocket:" class="emoji" alt=":rocket:" loading="lazy" width="20" height="20"> <img src="https://forum.rebol.info/images/emoji/twitter/sun_with_face.png?v=12" title=":sun_with_face:" class="emoji" alt=":sun_with_face:" loading="lazy" width="20" height="20"> ...vowing to never try and write another web server in a Redbol again.</p>
</li>
<li>
<p>INSTEAD we dial the clock back to how people responded to web requests in the 90's: we think of it that each request starts a whole new copy of %r3.exe, which does its work, and exits.</p>
<ul>
<li>
<p>...this really <em>is</em> how systems used to work, back when there were 5 people on the Internet.  (Modems were so slow that you couldn't get more than one request a week, anyway.)</p>
</li>
<li>
<p>But in the name of speed, webmastering became a mystical black art of figuring out how to force your PHP or Python or whatever to stay resident inside the Apache server and <em>not</em> exit.</p>
</li>
<li>
<p>The seeping complexity started to require watchdog processes to check to make sure your long-running process wasn't accruing memory across requests, or restarting it if it crashed.</p>
</li>
<li>
<p>Security was also being compromised, because bugs in your code could allow session data to seep between different requests...since the process was long-lived and kept memory open.</p>
</li>
</ul>
</li>
<li>
<p>THE UTOPIA WE ARE BEING SOLD is that IF we package our code as a blob-o-WebAssembly...</p>
<ul>
<li>
<p>We will get all the benefits of running fresh every request...</p>
</li>
<li>
<p>...but with a performance characteristic like if we'd rigged up a way to stay running the whole time.</p>
</li>
</ul>
</li>
<li>
<p>THERE WILL STILL BE A WEBSERVER RUNNING (of course)</p>
<ul>
<li>
<p>However: it will be <em>The One True Debugged WebServer</em> (compiled in something fully formal like Rust or Haskell, right?)...so it won't have the same security problems that your dirty Wasm blob would have if it tried to implement a long-running web server itself.</p>
</li>
<li>
<p>It will have lightning fast abilities to spin up and down the Wasm blobs, much faster than an OS shutdown and launch would ever be.</p>
</li>
</ul>
</li>
</ul>
<h2>
<a name="ive-now-made-us-one-of-those-wasm-blobs-3" class="anchor" href="https://forum.rebol.info#ive-now-made-us-one-of-those-wasm-blobs-3"></a>I've Now Made Us One Of Those Wasm Blobs!</h2>
<p>Hence we can focus our efforts on the high level logic of how to answer a web request without worrying about the details of writing, running, or administrating a web server.</p>
<p>If you've ever looked at some Platform as a Service (PaaS) like Heroku or AWS and seen a short list of languages supported, that's going to be a thing of the past.  Anyone who builds to WebAssembly can be hosted and just pay the price of their storage/CPU/network use.</p>
<ul>
<li>
<p>Yesterday we were a black sheep of languages...with a shoddy, slow, and insecure webserver.</p>
</li>
<li>
<p>Tomorrow... we'll still be a black sheep of languages.  But one that's on an even playing field for providing higher level logic for processing and serving data on the web.</p>
</li>
</ul>
<h2>
<a name="ah-now-i-see-the-what-of-the-so-what-4" class="anchor" href="https://forum.rebol.info#ah-now-i-see-the-what-of-the-so-what-4"></a><em>"Ah!  Now I See the What of the So What!"</em>
</h2>
<p><img src="https://forum.rebol.info/images/emoji/twitter/smiling_face_with_three_hearts.png?v=12" title=":smiling_face_with_three_hearts:" class="emoji only-emoji" alt=":smiling_face_with_three_hearts:" loading="lazy" width="20" height="20"></p>
<p>It's a quite compelling vision statement, and a lot of people are evangelical (you can tell by how many times people say the term "serverless" at conferences these days).</p>
<p>I'm definitely the sort of person this is an easy sell to. You should choose your battles when it comes to optimization, this is one of my favorite quotes:</p>
<blockquote>
<p><em>"90% of a program's execution time is spent in only 10% of its code. The standard inference from this rule is that programmers should find that 10% of the code and optimize it ... But a second inference is just as important: programmers can deoptimize the other 90% of the code (in order to make it easier to use, maintain, etc.)</em>   -- <a href="http://en.wikipedia.org/wiki/Richard_E._Pattis">Richard Pattis</a></p>
</blockquote>
<p>So focusing performance research on the spin-up and tear-down sounds 100% right.  Over the long run, the factors I mention probably mitigate any "catastrophic slowdown".  Your higher level program logic is starting from a clean slate every time.  There's no memory fragmentation or leaks, and all those security benefits I mentioned.</p>
<h2>
<a name="not-just-the-cloud-but-one-binary-for-all-desktops-5" class="anchor" href="https://forum.rebol.info#not-just-the-cloud-but-one-binary-for-all-desktops-5"></a>Not Just the Cloud, but <em>One Binary For All Desktops</em>
</h2>
<p>As WebAssembly has proven its mettle on the Web, people have asked why it couldn't be run from a terminal prompt.  All you'd need would be a runtime host--simpler than a browser--that provided basic file, I/O, and network services.</p>
<p>If you could do that, you'd be able to have one <strong><code>%r3.wasm</code></strong> file that you could download and use for Linux, Mac, Windows, on the cloud, and in your browser...</p>
<p>...in theory.  And that theory is almost practice.  (<a href="https://forum.rebol.info/t/wasmtime-and-wasi/1151/4">I've remarked on another thread about it</a> so take discussions of the non-cloud applications there.)</p>
<h2>
<a name="of-course-its-not-all-there-yet-6" class="anchor" href="https://forum.rebol.info#of-course-its-not-all-there-yet-6"></a>Of Course, It's Not All-There-Yet</h2>
<h3>
<a name="what-about-those-wasm-blob-server-providers-7" class="anchor" href="https://forum.rebol.info#what-about-those-wasm-blob-server-providers-7"></a>What about those Wasm blob server providers?</h3>
<p>They don't exist yet.</p>
<p>So if you're going to use the serverless methodology in the here and now, you're going to still be in the webmastering game.  Only now you're learning how to set up Docker instances and configure bleeding-edge Wasm runtimes.</p>
<h3>
<a name="what-about-that-one-true-webserver-8" class="anchor" href="https://forum.rebol.info#what-about-that-one-true-webserver-8"></a>What about that "One True Webserver?"</h3>
<p>Y'know, the webserver you're going to throw out yours for.  The one that's bulletproof and supersonic and Utopian--the kind Jesus would have written--the one that's going save us all?</p>
<p><em>It's NodeJS.</em>  <img src="https://forum.rebol.info/images/emoji/twitter/man_facepalming.png?v=12" title=":man_facepalming:" class="emoji" alt=":man_facepalming:" loading="lazy" width="20" height="20"><br>
<sub>at least for WasmEdge on AWS Lambda, for now</sub></p>
<p>So I hope you like setting up NodeJS in Docker.</p>
<h3>
<a name="what-about-the-language-agnosticism-in-hosting-9" class="anchor" href="https://forum.rebol.info#what-about-the-language-agnosticism-in-hosting-9"></a>What about the "Language Agnosticism" in hosting?</h3>
<p>The company behind WasmEdge talks a big game, and they have a platform for <a href="https://www.secondstate.io/faas/">Functions as a Service (FaaS)</a>.  But for various reasons this only works with Rust.</p>
<p>Kind of annoyingly, if you read the docs for <a href="https://wasmedge.org/book/en/dev.html">develop a WasmEdge app</a> you will see it say:</p>
<blockquote>
<p>For compiled languages (e.g., C and Rust), WasmEdge WebAssembly provides a safe, secure, isolated, and containerized runtime as opposed to Native Client (NaCl).</p>
</blockquote>
<p>Then you will see it list examples for <a href="https://wasmedge.org/book/en/dev/rust.html">Rust</a>, <a href="https://wasmedge.org/book/en/dev/js.html">JavaScript</a>, <a href="https://wasmedge.org/book/en/dev/go.html">Go</a>, <a href="https://wasmedge.org/book/en/dev/swift.html">Swift</a>, <a href="https://wasmedge.org/book/en/dev/as.html">AssemblyScript</a>, <a href="https://wasmedge.org/book/en/dev/kotlin.html">Kotlin</a>, <a href="https://wasmedge.org/book/en/dev/grain.html">Grain</a>, <a href="https://wasmedge.org/book/en/dev/python.html">Python</a></p>
<p><em>Noticeably missing is C.</em>  And that's the one we need.</p>
<p>Without C support for things like sockets, our Ren-C Wasm blob cannot make network requests.  We can do filesystem operations, but networking is just not there yet.</p>
<p><em>(The missing C bits relative to the other languages isn't technically WasmEdge's fault...it's just that the libc implementation for Wasi doesn't have some things that the Rust standard library does.  I just wish they'd explained the details of how they got the other languages to work built upon Rust...rather than leaving it as an exercise for the reader to delve into it all to figure out.)</em></p>
<h2>
<a name="but-stay-tuned-10" class="anchor" href="https://forum.rebol.info#but-stay-tuned-10"></a>But Stay Tuned...</h2>
<p>This is a pretty major development, and things are moving fast.  I want <a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a> to keep the eyes on the prize here, and we see what we can do to make sure we've got some demos rolled out in this space.  As we find ways to bring more features online, I'll let you know.</p>
            <p><small>8 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/ren-c-is-now-on-the-clouds-with-wasi/1854">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/ren-c-is-now-on-the-clouds-with-wasi/1854</link>
          <pubDate>Fri, 01 Jul 2022 00:52:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1854</guid>
          <source url="https://forum.rebol.info/t/ren-c-is-now-on-the-clouds-with-wasi/1854.rss">Ren-C is Now on the Clouds ☁️ with WASI</source>
        </item>
        <item>
          <title>Stackless Comes to the Web :spider_web: Build</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>WebAssembly</category>
          <description><![CDATA[
            <p>I made a beeline for us being able to use stackless in the web build, because that's a place where it can get us some benefits.  Much work has brought it there, and <strong>the ReplPad served up as of today is stackless!</strong>  No <strong><a href="https://emscripten.org/docs/porting/asyncify.html">Asyncify</a></strong> at all!</p>
<ul>
<li>
<p><strong>We get size benefits</strong> - Without the extra code generation added by Asyncify the <code>%libr3.wasm</code> file was down from ~1.8 megabytes to ~1.1 <em>(I'd said I recalled it made things about twice the size, and that's in the ballpark)</em></p>
<ul>
<li>
<p>There hasn't been any extreme push to optimize Ren-C on size, but I think it will be appealing when someone could have access to the functionality of the interpreter on their website for under a megabyte... when things like Golden Layout are a megabyte just for tabbed windows, a whole interpreter and PARSE doesn't seem a bad deal!</p>
</li>
<li>
<p>I want to push ever more of the features into little "WebAssembly DLLs" that you can pick from a-la-carte, and only pay for what you use.  How minimal a core we can get is a question to pursue.  But right now there's lots of stuffing (two PARSE implementations, for example) that hopefully the future can rein in.</p>
</li>
</ul>
</li>
<li>
<p><strong>We get speed benefits</strong> - Asyncify didn't just add bytes to the compiled code, those were bytes that were instructions that did stuff.  It added bookkeeping to know how to unwind stacks of generic code it didn't know anything about.</p>
<pre><code>ren-c-asyncify&gt;&gt; x: [] delta-time [repeat 10000 [append x [a b]]]
== 0:00:00.070

ren-c-stackless&gt;&gt; x: [] delta-time [repeat 10000 [append x [a b]]]
== 0:00:00.028
</code></pre>
<p>That comparison isn't 100% fair, because that asyncify version is post-stackless code, hence it was instrumenting the stackless trampoline.  <em>But I'd imagine that it's easily twice as fast, as well as being half the size!</em></p>
</li>
</ul>
<p><strong>In just this evening after the change, I've already done some performance work that makes the Web REPL feel significantly snappier...try it out!</strong></p>
<h2>
<a name="but-most-importantly-we-get-more-working-features-1" class="anchor" href="https://forum.rebol.info#but-most-importantly-we-get-more-working-features-1"></a>But Most Importantly, We Get More Working Features!</h2>
<p>Asyncify's big achilles heel is that when it suspends your codebase, it's suspended.  It can't do anything until it is fully resumed.*</p>
<p><sub>* You can actually put a few functions on a blacklist of things that can be called despite the stack being suspended.  But it's probably the case that the most important parts of your program need the asyncify treatment: in Ren-C's case, that was the evaluator.  There's things you can do without the evaluator <em>(scan code into array structures, for instance?)</em></sub></p>
<p>Stackless makes us masters of time and space as far as the stack is concerned.  <a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a> was trying to do something seemingly trivial, like attach some JavaScript to a button that would call:</p>
<pre><code> reb.Elide("write clipboard:// {hello}")
</code></pre>
<p>With all that's been accomplished so far you'd think that would have been relatively easy.  But the moment when you call it matters a lot. The Repl was rigged very carefully to work with Asyncify and be able to run code when it was "its turn"--e.g. when it wasn't sleeping, having passed the baton to the GUI to gather user input.</p>
<p>With stackless these things become unblocked, and a lot of the tricky manipulations that weren't under our control are coming under it.  Things should hopefully get better (!)</p>
<h2>
<a name="question-can-we-hang-onto-some-of-the-asyncify-knowledge-2" class="anchor" href="https://forum.rebol.info#question-can-we-hang-onto-some-of-the-asyncify-knowledge-2"></a>Question: Can We Hang Onto Some of the Asyncify Knowledge?</h2>
<p>Having been through the labor of making code that wasn't stackless interoperate in the browser, I can't help but wonder if there's some way that we can keep the functionality in our pocket in case some situation could be helped by it.</p>
<p><a href="https://www.youtube.com/watch?v=qQOP6jqZqf8">Pause and Resume WebAssembly with Asyncify, Alon Zakai</a></p>

<p>I don't completely understand the <a href="https://github.com/WebAssembly/binaryen/blob/5811c2c7d50c10327565a23e19bf39c105593710/src/passes/Asyncify.cpp#L130">custom unwinding concepts</a>, but Alon makes it <em>sound</em> like we might be able to take any non-stackless natives and specifically instrument them.  Like if when the Trampoline went to unwind it hit a stackful wall (a "root frame", as I call them) we might be able to selectively bundle the call stack between that wall and the next stackless point.</p>
<p>I'm not sure if it's worth weeks of effort to figure out if we can do it, but it's probably worth a bit.  There are codebases of WebAssembly stuff for doing graphics and music and things like that...and we might want to hook them in a way that they call into us, even if they rely on Asyncify to do their work.</p>
<p>We've talked about having more "technology demos" just to show the versatility (e.g. <a href="https://wasmedge.org/">integrating with WasmEdge</a>) and so I feel like the more the merrier on that.</p>
<p><em>(It's hard to prioritize when there's so many cool directions to take things!  But I continue to go after fundamentals, and try to stay the course on that...)</em></p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/stackless-comes-to-the-web-build/1848">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/stackless-comes-to-the-web-build/1848</link>
          <pubDate>Sat, 25 Jun 2022 23:04:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1848</guid>
          <source url="https://forum.rebol.info/t/stackless-comes-to-the-web-build/1848.rss">Stackless Comes to the Web :spider_web: Build</source>
        </item>
        <item>
          <title>Local ReplPad</title>
          <dc:creator><![CDATA[IngoHohmann]]></dc:creator>
          <category>WebAssembly</category>
          <description><![CDATA[
            <p>Just as a note ...</p>
<pre><code class="lang-auto">&gt; git clone https://github.com/hostilefork/replpad-js.git
&gt; cd replpad-js/
&gt; python -m SimpleHTTPServer 8000
</code></pre>
<p>This gives you a running local replpad. <img src="https://forum.rebol.info/images/emoji/twitter/+1.png?v=9" title=":+1:" class="emoji" alt=":+1:"><br>
No more excuses to not hack on it <img src="https://forum.rebol.info/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:"></p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/local-replpad/1838">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/local-replpad/1838</link>
          <pubDate>Wed, 08 Jun 2022 19:17:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1838</guid>
          <source url="https://forum.rebol.info/t/local-replpad/1838.rss">Local ReplPad</source>
        </item>
        <item>
          <title>Suppressing verbosity in the replpad</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>WebAssembly</category>
          <description><![CDATA[
            <p>I am developing a replpad app but I want the users to go straight to a URL and start the app.  I'd rather that they didn't have to type</p>
<pre><code>import @rx
</code></pre>
<p>when a lot of module stuff is sent to the console interrupting the interface, eg</p>
<pre><code>`== make module! [
    alpha: make bitset! #{00000000000000007FFFFFE07FFFFFE0}  
    rx: '#[action! {rx} [drug]]  
    ...  
</code></pre>
<p>`</p>
<p>Maybe <code>http://hostilefork.com/media/shared/replpad-js/@rx</code> would be better and if a module is provided then verbose mode is automatically suppressed.</p>
<p>Anyway, suggestions for a standardised way to run our apps?</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/suppressing-verbosity-in-the-replpad/1801">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/suppressing-verbosity-in-the-replpad/1801</link>
          <pubDate>Thu, 28 Apr 2022 09:49:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1801</guid>
          <source url="https://forum.rebol.info/t/suppressing-verbosity-in-the-replpad/1801.rss">Suppressing verbosity in the replpad</source>
        </item>
        <item>
          <title>Getting data into replpad-js</title>
          <dc:creator><![CDATA[johnk]]></dc:creator>
          <category>WebAssembly</category>
          <description><![CDATA[
            <p>Hi,<br>
What are the best options for getting data into the replpad-js build (<a href="http://hostilefork.com/media/shared/replpad-js/" class="inline-onebox">Ren Garden</a>)?<br>
Other than pasting data into the console, I am not clear on what other options exist and how to use them.<br>
Thanks, John</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/getting-data-into-replpad-js/1742">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/getting-data-into-replpad-js/1742</link>
          <pubDate>Wed, 13 Oct 2021 23:17:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1742</guid>
          <source url="https://forum.rebol.info/t/getting-data-into-replpad-js/1742.rss">Getting data into replpad-js</source>
        </item>
        <item>
          <title>Pros and Cons of the Pthread Web Build</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>WebAssembly</category>
          <description><![CDATA[
            <p>So... browsers aren't making it easy to use <code>SharedArrayBuffer</code>--a requirement for the pthreads web build.  This is due to something called COOP/COEP.  It's making what was already some tough work to turn on threads even tougher:</p>
<p><a href="https://web.dev/coop-coep/">https://web.dev/coop-coep/</a></p>
<p>My ranting response on the topic:</p>
<blockquote>
<p>(What I see is a lot of half-baked security theater, where the answer is putting flags on things saying <em>"yes, I meant to use that resource...the one I said to use"</em>.  You're not able to put this canon list of "I meant to do that" in a nice central location...instead you have to weave the list around piecemeal in various places that express the flag (sometimes <a href="https://stackoverflow.com/a/28907499">in different cases</a>).  Then some places just haven't been parameterized to allow the flag, which breaks the whole thing in a frustrating way.)</p>
</blockquote>
<p>At one time, the pthreads build was quite a lot faster than the "emterpreter" build.  But emterpreter was replaced with the much superior "asyncify" method (if you want to be more specific actually version 2 of it, called "bsyncify").  So right now the performance difference is negligible...and the principal advantage of the pthreads build is that the .wasm generated is less than half the size of the asyncify build.</p>
<p><em>But</em> if stackless is implemented (which I intend), even asyncify should not be necessary...because we'd be able to unwind our own stack.  We wouldn't need asyncify's magical backbone woven into the source that assists in teleporting out-of and back-into any point of the evaluator.  So the size difference would go in the reverse direction: pretty much all of the pthreads extra hassle would be make-work, and all those files and code would make it the bigger build.</p>
<p><strong>I'm seriously considering simplifying life and the build/test matrix by dropping the pthreads build.</strong> I believed it would be available in all browsers by default, and that part is shaping up to be true.  But what I didn't anticipate was the mire of serving concerns that makes it such a hassle--it won't get better, and it may get worse.</p>
<p>Whether it's jsfiddle or any other page where you can't bend every server in the chain to your will...you just couldn't use the pthreads.  We're going to need a non-pthreads build.  And if we make that the one build that we focus on, deploy, and test...it's just easier.</p>
<p><strong>Remember that pthreads was only a mechanical tool for switching stacks, it had nothing to do with concurrency.</strong>  You can't make a single-threaded interpreter suddenly able to run in parallel by linking it to a thread library.  We were only running one thread at a time: one for JavaScript, and one for Ren-C...so they could pass off to each other without losing their place in what they were doing.</p>
<p>This isn't to be confused with features related to <em>concurrency</em>...which <em>is</em> something being looked to.  But that would be with techniques like "green threading", that don't actually ever have multiple CPU cores potentially competing at a simultaneous moment for the same byte of memory.</p>
<p>JavaScript doesn't have "threads" either: it has "workers"...which are isolated from each other in most every way, to the point you can just about think of them as separate processes that just pass messages back and forth--without sharing data structures.  The single example of them <em>actually</em> sharing a data structure (SharedArrayBuffer) has created a lot of hullaballoo; getting disabled due to Spectre, and quarantined with all kinds of crazy flags that make it rather difficult to use.</p>
<p><strong>For the sake of sanity and ease of deployment, I'm leaning to the idea of killing off the pthreads build.</strong>  Asyncify changed the game by closing the performance gap, and Stackless will be an even better answer.  Let's make life (and testing) easier.</p>
<hr>
<h2>One Lingering Thought...</h2>
<p>The thing that pthreads actually gives us is not the ability to run Ren-C code in parallel, but to run Ren-C code in parallel with JavaScript code.  <em>We weren't doing that</em> with it.  But theoretically we could have.</p>
<p>We could still do it...if you load the library into a worker.  Then your main thread is all JavaScript, posting requests in JavaScript format that are picked up by the JavaScript in the worker...which then makes calls to the interpreter and proxies the answers back.</p>
<p>But this means the Rebol code would not have access to the DOM, and that's not a very interesting working model.  (That would be an issue anytime you are trying to run code concurrently...only one thread can access the DOM.)</p>
<p>Then another thing pthreads gives that stackless does not is the ability to "signal" code to wake up, instead of using a polling strategy.  That might sound more efficient, but unfortunately a of time when you look under the hood at how these "signals" are implemented actually involves a bunch of timeouts that are isomorphic to polling.</p>
<p><strong>I'm still hedging a bit.  What I'll probably do is start ripping out the pthreads code and then pause to reflect if I find anything and think "hmm, that's valuable and would be hard to put back".</strong></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/pros-and-cons-of-the-pthread-web-build/1425">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/pros-and-cons-of-the-pthread-web-build/1425</link>
          <pubDate>Fri, 04 Dec 2020 18:34:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1425</guid>
          <source url="https://forum.rebol.info/t/pros-and-cons-of-the-pthread-web-build/1425.rss">Pros and Cons of the Pthread Web Build</source>
        </item>
        <item>
          <title>DO vs. READ and URL translation</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>WebAssembly</category>
          <description><![CDATA[
            <p>In trying to make the Web Console as easy to use as possible, we have some magic that translates URLs on GitLab and GitHub into CORS ("Cross-Origin Resource Sharing") API requests.</p>
<p>For instance, take an example <a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a> is working with currently <sub><em>(despite being a forum absentee <img src="https://forum.rebol.info/images/emoji/twitter/angry.png?v=9" title=":angry:" class="emoji" alt=":angry:">)</em></sub>:</p>
<p><a href="https://gitlab.com/Zhaoshirong/docx-templating/-/blob/master/gmdocx.reb"><code>https://gitlab.com/Zhaoshirong/docx-templating/-/blob/master/gmdocx.reb</code></a></p>
<p>That GitLab URL indicates a document.  But what you get if you READ that URL is not the file contents of <code>gmdocx.reb</code>...because it is a web page with a lot of decorations.  You get line numbers and all that other HTML all around it.</p>
<p><strong>We don't want READ to do any magic to give anything different back that the browser wouldn't see for that URL.</strong>  If you READ it from the console, you should get all the HTML... line numbers and all.</p>
<p><strong>But the DO function can have different rules.</strong>  Since DO of a bunch of HTML would be meaningless, it seems that if you ask to DO that URL (which is convenient to exchange with people), it should be able to figure out how to extract the code and run it.</p>
<p>Now...we do that.  When you run DO, it first translates that link into a GitLab raw link:</p>
<p><a href="https://gitlab.com/Zhaoshirong/docx-templating/-/raw/master/gmdocx.reb"><code>https://gitlab.com/Zhaoshirong/docx-templating/-/raw/master/gmdocx.reb</code></a></p>
<p>Then <em>that</em> link is passed to READ.</p>
<p>But we're not done with magic.  When you're running in the browser, that link can't be fetched directly due to CORS rules.  You have to go through the GitLab API.</p>
<p>So there's a fiddling inside READ to do that, and pick apart the JSON to give you the data--even though you are in the browser.</p>
<h2>Are There Other Candidates for DO to do "magic"?</h2>
<p>Any URL could be taken as an instruction.  Is there any real reason to stop at code, or would data be acceptable too--if a URL format conveyed an obvious intention?  There's BROWSE if you want to open the URL, and READ if you want the HTML...so should there be other behaviors?</p>
<p>Random whimsical example: A DO of a Google Search could "know" to return a list of the results of that search as a BLOCK!.</p>
<p>There's JavaScript and CSS code URLs (as well as ones that decorate it, like CodePen, where the decorations could be removed).</p>
<p>Right now, there's a separate JS-DO, that you can use to run <code>.js</code> code</p>
<p>There's also CSS-DO, that will "execute" <code>.css</code> by loading it up.</p>
<p>I didn't make these overload DO (in part because that's harder...there'd have to be some generic hooking mechanism to allow all these different "do codecs" register themselves).</p>
<p>But think about the invariants.  If you're using DO inside an implemention where what you mean is "do block", is it appropriate for that DO to potentially have such wild behaviors as loading CSS code if you happen to pass it something that it interprets that way?</p>
<p>Maybe this should be a distinction like <strong>RUN</strong> (arbitrary tool) vs. <strong>DO</strong> (stay inside the language).  Or maybe other words.  Just something to think about.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/do-vs-read-and-url-translation/1402">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/do-vs-read-and-url-translation/1402</link>
          <pubDate>Sat, 14 Nov 2020 13:54:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1402</guid>
          <source url="https://forum.rebol.info/t/do-vs-read-and-url-translation/1402.rss">DO vs. READ and URL translation</source>
        </item>
        <item>
          <title>Wasmtime and Wasi</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>WebAssembly</category>
          <description><![CDATA[
            <p><a href="https://github.com/CraneStation/wasmtime" rel="nofollow noopener">Wasmtime</a> is a web assembly runtime that runs WebAssembly code outside of the web.  It supports the new spec, <a href="https://github.com/CraneStation/wasmtime/blob/master/docs/WASI-overview.md" rel="nofollow noopener">WASI: WebAssembly System Interface</a>.</p>
<p>Is thing going to be like node.js and allow us to run the Rebol WASM servers with full I/O ?</p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/wasmtime-and-wasi/1151">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/wasmtime-and-wasi/1151</link>
          <pubDate>Tue, 30 Apr 2019 04:57:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1151</guid>
          <source url="https://forum.rebol.info/t/wasmtime-and-wasi/1151.rss">Wasmtime and Wasi</source>
        </item>
        <item>
          <title>Licensing of the JavaScript Extension</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>WebAssembly</category>
          <description><![CDATA[
            <p>When I started the ReplPad, I went with a GPL License.  It's "strict" in terms of saying that whatever you do with it, you have to share the source.  Not much of a problem for today's usage, since it's all being delivered over the web anyway.  And it's nothing to do with Rebol scripts that <em>you're running</em>...just the support for the console itself.  e.g. if you make an improvement to the undo mechanism, you can't keep source for that to yourself...you have to publish it.</p>
<p>GPL has had success on desktop/servers with things like Linux (hard to argue that isn't doing pretty well).  And despite the MIT-licensing ethos of 10-line JavaScript modules, it's not unheard of for a web project of substance to use the GPL.  It discourages bad actors--and encourages sharing, plus avoids fragmentation.  One good example is RegExr <em>(which we might want to borrow from, heavily, for PARSE teaching!)</em>:</p>
<p><a href="https://regexr.com/" rel="nofollow noopener">https://regexr.com/</a><br>
<a href="https://github.com/gskinner/regexr/blob/master/LICENSE" rel="nofollow noopener">https://github.com/gskinner/regexr/blob/master/LICENSE</a></p>
<p>I'm a believer in Stallman-style philosophy of <a href="https://www.gnu.org/philosophy/why-free.en.html" rel="nofollow noopener">Why Software Should Not Have Owners</a>.  And so I don't really see why anyone should reasonably feel entitled to box up all the work of what the ReplPad may become, and not give anything back.  <em>Publishing their source code is not too much to ask.</em>  And I'm not worried about "losing customers"--if someone adds a great undo feature to open source software or fixes a bug and doesn't want to tell the people who made it, that person can take a hike.</p>
<h2>What about the JavaScript Extension itself?</h2>
<p><a class="mention" href="https://forum.rebol.info/u/giuliolunati">@giuliolunati</a> has pulled off a factoring so that you can load the JavaScript libRebol and all of its necessary pieces from a single loader file.  GREAT!  <img src="//forum.rebol.info/images/emoji/twitter/man_cartwheeling.png?v=7" title=":man_cartwheeling:" class="emoji" alt=":man_cartwheeling:"></p>
<p>To do so, he took code out of the ReplPad project and into the JavaScript extension.  (For convenience, extensions currently are living in the main repository to make them easier to build and keep in sync.)  And that starts what I think is going to be a trend...that it's going to get harder to tell what parts are "ReplPad" and what parts are "extension".</p>
<p>Right now the JavaScript extension's C code has a boilerplate "Apache 2.0" on it from the other files.<br>
Of course, it's had all of one contributor--me.  So between Giulio and I that means we can pick whatever license we want.  So, which one?</p>
<h2>ReplPad's License = JavaScript Extension License</h2>
<p>Using the same license for both means not having to worry about moving code between one and the other.  It looks like we'll be doing a lot of it, and that should not be a hassle.</p>
<p><strong>I'm going with LGPL 3.0</strong></p>
<p>The LGPL says that if you make a closed source program that uses the thing as a library...you aren't obligated to release the source to the program.  But if you modify the library itself, you have to publish/provide those modifications.  So basically if you change <code>mod-javascript.c</code> you have to show what you've changed.</p>
<p>Stallman argues that open source developers shouldn't pick this more liberal form of GPL license <a href="https://www.gnu.org/licenses/why-not-lgpl.html" rel="nofollow noopener">unless non-GPL solutions provide equivalent functionality</a>.  There's really only one "competitor" in the form of libRed, but they don't have any restrictions on commercial use <em>(and have disappeared down a non-open-source hole for some of their work: <a href="https://www.red-lang.org/2019/01/full-steam-ahead.html" rel="nofollow noopener">see <strong>"Red Pro"</strong>, where they have made the "community branch" a second class citizen</a>, and you have to pay them to get 64-bit support, or whatever...<code>&lt;eye-roll&gt;</code>)</em></p>
<p>In any case, saying closed-source apps can't use the JavaScript extension would put an advantage point in Red's column for some people.  I guess I don't see the point of giving Red that advantage.  However, asking people to publish modifications to the JS lib or console itself--ignoring what they connect it to--is fully reasonable--so I don't mind being lightly more restrictive in that sense.  That shouldn't bother anyone who matters.</p>
<p>Given my FSF biases, this is more liberal than I may like for the ReplPad.  I certainly don't <em>like</em> the idea of someone boxing it up in an Electron app, linked to proprietary software...aren't we done with these bad ideas?  But LGPL works for a lot of projects--<a href="https://doc.qt.io/qt-5/lgpl.html" rel="nofollow noopener">Qt for instance</a>.  And it's too inconvenient to think of worrying about moving code between the projects otherwise.</p>
<p>Stallman may disrecommend the LGPL, but he still made it.  So at one point he thought it was a reasonable compromise.  Can't be too bad, then.</p>
<h2>The code is still small, but that's why deciding now is important.</h2>
<p>Making a big deal about the license now might seem dumb.  Some might say <em>"it's too small to worry about, just make it MIT/BSD/Apache, why make it inconvenient for people?"</em></p>
<p>But that's exactly why now's the time.  Once it gets larger--and contributions are accepted--it will be too late to change our mind.  People will have committed bits and say they don't want it re-licensed.  Or even if they would be willing to re-license, you'd have to track them all down to ask (I've seen projects have to do this).</p>
<p>So what I'm proposing as a contributor agreement is that everyone agree that it can be re-licensed more liberally in the future, but that no "dual licenses" will be given.  So a company can't pay for a special arrangement for <em>them</em> to use and adapt the code, while it's still LGPL for everyone else.  But there could be a KickStarter and people could donate to fund some development contingent on relicensing as BSD (or whatever)...but the code is released under the new license for <em>everyone</em>, donor or not.</p>
<p>Anyway--maybe it won't matter in the scheme of things for this project.  But I think at minimum, it's important for developers to be having this conversation regularly.  Carl and Rebol asked people to try and get back to using their common sense about complexity.  Stallman and GPL asks people to get back to their common sense about where control and power should be when it comes to software.</p>
            <p><small>7 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/licensing-of-the-javascript-extension/1130">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/licensing-of-the-javascript-extension/1130</link>
          <pubDate>Sun, 24 Mar 2019 05:35:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1130</guid>
          <source url="https://forum.rebol.info/t/licensing-of-the-javascript-extension/1130.rss">Licensing of the JavaScript Extension</source>
        </item>
        <item>
          <title>Node.js Hello Rebol (and caveats)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>WebAssembly</category>
          <description><![CDATA[
            <p>Node.js comes up from time to time...and whether or not Rebol could run on something like a commodity Node.js server.</p>
<p>One of the selling points of Emscripten as a toolchain is that it can do the necessary things so WASM will run in Node.  I hadn't tried it.  But my impression was that if you had something working in the browser...it should be able to get working in Node also.</p>
<h2>After Some Hours of Fiddling...</h2>
<p>...I managed to get a test to work.  I'm looking at the fundamental issues of <a href="https://stackoverflow.com/questions/54713336/synchronous-require-so-entire-node-js-script-isnt-in-callback" rel="nofollow noopener">what might be done to make it less ugly</a>, but...here is Node calling into Rebol:</p>
<pre><code>var express = require('express')
var app = express();

var reb = require('rebol')

reb.onRuntimeInitialized = function() {
    reb.Startup()

    app.get('/', function (req, res) {
        let three = reb.Spell("to text! 1 + 2");
        res.send('One plus Two is ' + three)
    });

    app.listen(3000, function () {
        console.log('Example app listening on port 3000!')
    });
}
</code></pre>
<p>So it adds 1 and 2, turns the sum into a string, extracts that string as a JavaScript string, and serves you a page saying <strong>One plus Two is 3</strong>.</p>
<h2>Okay that's <em>something</em>... BUT...</h2>
<p>I think the more interesting story is Rebol-calling-JavaScript...as opposed to JavaScript-calling-Rebol.  But Node kind of sits as the gatekeeper at a top level.  I have a hard time seeing how to graft a Node program into an <code>app.reb</code> that "occasionally asks Node to do things".  But it seems a lot more clear with the browser.</p>
<p>There are some other points on why not to push on this too much right now:</p>
<ul>
<li>
<p>Though Node.js has caught up with V8 features over time, Emscripten hasn't yet taken advantage of their workers or shared memory.  That means that if you want rebPromise() and the other magic that makes libRebol cool, you'll have to use the emterpreter.  The above program needs over 1.5mb of build products, well more than twice the size of a pure webassembly build...and as I've said, it's about 30x slower.</p>
</li>
<li>
<p>There's a way to package cross-platform native C code and build it as part of a node package--sidestepping webassembly and emscripten altogether.  This would be the fastest option.  It wouldn't be impossible to do, but it would be a lot of work on a new codebase that there aren't resources to allocate to.  Waiting for emscripten to support WASM+pthreads on Node is probably a better bet, because it would mean being able to leverage common binding code with the browser--vs. a new project.</p>
</li>
<li>
<p>NPM modules deploy via GitHub.  I don't see a turnkey way to get a static resource of a large webassembly file to go along with that installation, other than putting it in the GitHub repository itself.  Strangely, if one ships native C code with a C++ binding to V8 (as described in the previous point), Node is set up to make <em>that</em> more turnkey.  :-/</p>
</li>
</ul>
<h2>It is worth scoping out and understanding, though</h2>
<p>It brings questions up, and they are good to think about:</p>
<ul>
<li>
<p>Should we aim for modules and call like <code>reb.Spell()</code> instead of <code>rebSpell()</code>, even in the web version where we don't have to?  (People talk about browsers getting a module model like Node's, so it would probably be forward-looking.)</p>
</li>
<li>
<p>Should <code>var reb = require('rebol')</code> give you back an interpreter instance, or should that get an "engine", so you say <code>var rebol = require('rebol')</code>, <code>var reb = new rebol.Interpreter(...)</code>, and you could make several of these as independent?</p>
</li>
<li>
<p>Should rebStartup() be a Promise, if we can't generically hide the WebAssembly load?  Will users of libRebol be expected to put all of their code in a callback?</p>
</li>
</ul>
<p>It's definitely forward-thinking to be working on answers to these questions.  But I think we should be looking more to Rebol-based %httpd.reb and other things like that for the server side.  Worth pointing out is that Node.js's creator has <a href="https://thenewstack.io/node-js-creator-blasts-node-js-offers-a-secure-typescript-based-alternative/" rel="nofollow noopener">decided it's too flawed, and has gone off to promote another project</a>...</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/node-js-hello-rebol-and-caveats/1072">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/node-js-hello-rebol-and-caveats/1072</link>
          <pubDate>Fri, 15 Feb 2019 16:54:19 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1072</guid>
          <source url="https://forum.rebol.info/t/node-js-hello-rebol-and-caveats/1072.rss">Node.js Hello Rebol (and caveats)</source>
        </item>
        <item>
          <title>Pure WASM + Pthreads: Faster, Better, Smaller</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>WebAssembly</category>
          <description><![CDATA[
            <p>In the web console demo, when running with the "emterpreter" build:</p>
<pre><code> &gt;&gt; ‌‌delta-time [x: 0 loop 1000000 [x: x + 1]]
== 0:00:28.202  ; that's 28 seconds, to count to a million
</code></pre>
<p>But when that same web console is running on the same machine, in the <a href="http://hostilefork.com/media/shared/replpad-js/" rel="nofollow noopener">new and bleeding edge pure WASM with Pthreads build</a>:</p>
<pre><code>&gt;&gt; ‌delta-time [x: 0 loop 1000000 [x: x + 1]]
== 0:00:00.863  ; more than THIRTY TIMES FASTER
</code></pre>
<p>Of course, we'd like to see that number go down too.  And you might not notice the console seeming all that much faster on printing lines...but that's a different problem to address (related to callbacks and context switches).</p>
<p>The point is: by its very nature, the emterpreter was painfully slow.  But now with pure WASM not only is it tremendously faster, the build products are <em>half the size</em>.</p>
<p>Try it out...but don't do stack overflows yet (that needs a different strategy than what R3-Alpha was using).</p>
<p>Note that if you're not using Chrome, you will have to enable SharedArrayBuffer and WASM threading.<br>
It's in the <a href="http://hostilefork.com/media/shared/replpad-js/shared-memory-firefox.png" rel="nofollow noopener"><code>about:config</code> settings of Firefox</a>.  And if you're on Android you'll need to <a href="http://hostilefork.com/media/shared/replpad-js/webassembly-chrome-android.png" rel="nofollow noopener">tick a couple of <code>chrome://flags</code></a>.  Browsers are aiming to have these on by default...once they get over whatever their Spectre bug concern is.  Odds are very high they'll be mainstream by the time any serious usage of Ren-C in browser happens.  Even still, there's always the emterpreter fallback...and we can make that fallback more automatic (while trying to lobby you to change your switches).  No shortage of options, here.</p>
<h2>FYI: this is NOT easy stuff to do</h2>
<p>Since not everyone completely understands the difficulty curve of various advancements, this one is <strong><a href="https://github.com/metaeducation/ren-c/blob/master/src/extensions/javascript/mod-javascript.c" rel="nofollow noopener">pretty hard</a></strong>.  Not as much that any particular line of code is hard to write in and of itself...but it's an intersection of a tremendous number of things:</p>
<ul>
<li>Trying to keep it all boxed up so that all the JavaScript pieces stay isolated to the JavaScript extension, and you can build without any of it contaminating anything else.</li>
<li>Keeping the emterpreter version still working--since not all environments support pthread+WASM (yet)</li>
<li>Writing complex, multithreaded C without being able to use a debugger on it</li>
<li>Understanding all the inter-related concerns of C, Rebol, and JavaScript</li>
<li>Planning for multiple deployment environments (Browser, Node) and multiple future paths for those environments</li>
<li>Just reasoning about and designing this whole API model in the first place</li>
</ul>
<h2>There's still a lot to do</h2>
<p>What's there now is a proof of concept.  It needs to be gone over--ideally that would include some people who aren't me.  :-/</p>
<p>Outside of stack overflows, there's still a whole slew of issues...regarding what to do about HALT and cancellation, as well as various other error/throw situations in the API.</p>
<p>But it's very encouraging, and I think there's a lot of potential in this direction.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/pure-wasm-pthreads-faster-better-smaller/1069">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/pure-wasm-pthreads-faster-better-smaller/1069</link>
          <pubDate>Thu, 14 Feb 2019 19:30:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1069</guid>
          <source url="https://forum.rebol.info/t/pure-wasm-pthreads-faster-better-smaller/1069.rss">Pure WASM + Pthreads: Faster, Better, Smaller</source>
        </item>
        <item>
          <title>About the WebAssembly category</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>WebAssembly</category>
          <description><![CDATA[
            <p>There are currently two ways in which Ren-C is built to WebAssembly:</p>
<ul>
<li>
<p>The "ReplPad" in-browser rich console experience.  It provides everything from <a href="https://forum.rebol.info/t/visual-parse-on-the-web-has-arrived/1837">docking windows to rich editors</a>, with the full power of the browser available.  This is built via Emscripten, and integrates with JavaScript.</p>
<ul>
<li>(See also <a href="https://forum.rebol.info/c/development/language-bridging">Language Bridging</a> category for discussions of JavaScript integration)</li>
</ul>
</li>
<li>
<p>As a <a href="https://forum.rebol.info/t/ren-c-is-now-on-the-clouds-with-wasi/1854">WASI blob of .wasm</a>, designed to run cross-platform in Wasm runtimes.</p>
</li>
</ul>
<p>While native builds for Windows/Mac/Linux are still pursued as a necessary part of the further development of Ren-C, these WebAssembly targets are the primary focus of Ren-C's "deliverables".</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/about-the-webassembly-category/16">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/about-the-webassembly-category/16</link>
          <pubDate>Wed, 17 May 2017 09:31:10 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-16</guid>
          <source url="https://forum.rebol.info/t/about-the-webassembly-category/16.rss">About the WebAssembly category</source>
        </item>
  </channel>
</rss>

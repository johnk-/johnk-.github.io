<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>C/C++ Implementation - AltRebol</title>
    <link>https://forum.rebol.info/c/development/c-cpp-implementation/62</link>
    <description>Topics in the &#39;C/C++ Implementation&#39; category This category is for discussing issues in the source code for the interpreter itself.</description>
    
      <lastBuildDate>Sun, 22 Dec 2024 16:29:39 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/c-cpp-implementation/62.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Get_Xxx_Flag() vs Has_Xxx_Flag() ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>C/C++ Implementation</category>
          <description><![CDATA[
            <p>Kind of a fiddly naming issue, but there are a lot of places where flag-testing helpers are defined, which usually have 4 variants like this:</p>
<pre><code>#define Set_Details_Flag(p,name) \
    Set_Flavor_Flag(DETAILS, ensure(Details*, (p)), name)

#define Get_Details_Flag(p,name) \
    Get_Flavor_Flag(DETAILS, ensure(Details*, (p)), name)

#define Clear_Details_Flag(p,name) \
    Clear_Flavor_Flag(DETAILS, ensure(Details*, (p)), name)

#define Not_Details_Flag(p,name) \
    Not_Flavor_Flag(DETAILS, ensure(Details*, (p)), name)
</code></pre>
<p>The savings add up for having things like the NOT form, it unclutters things pretty well:</p>
<pre><code>Not_Details_Flag(details, CAN_BE_DISPATCHED_AS_INTRINSIC)
// vs
not Get_Details_Flag(details, CAN_BE_DISPATCHED_AS_INTRINSIC)
</code></pre>
<p>I hadn't really questioned these.  But lately I've been wondering... would HAS be better than GET?</p>
<pre><code>if (Has_Details_Flag(...)) ...

if (Get_Details_Flag(...)) ...
</code></pre>
<p>It's a subtle semantics thing.  You could argue that even if a flag is not set, the structure still <em>has</em> the flag.</p>
<p>But is "if Get(...)" like asking if the get operation itself succeeded?  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=12" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>Of course, in the interpreter we have taken for granted that <strong><code>if get $var</code></strong> isn't asking if you successfully got the variable, but whether the variable's contents are null or not.  And <strong><code>has obj field</code></strong> is really asking about the presence or absence of the field.</p>
<p>When I first thought of it, I was thinking that HAS was better.  But after writing this I'm kind of thinking GET may be the more consistent choice after all.</p>
<p>To be painfully precise, we'd call it: <strong><code>Is_Details_Flag_Set(...)</code></strong>... but I certainly prefer <strong><code>Get_Details_Flag(...)</code></strong> to that.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/get-xxx-flag-vs-has-xxx-flag/2358">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/get-xxx-flag-vs-has-xxx-flag/2358</link>
          <pubDate>Sun, 22 Dec 2024 16:29:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2358</guid>
          <source url="https://forum.rebol.info/t/get-xxx-flag-vs-has-xxx-flag/2358.rss">Get_Xxx_Flag() vs Has_Xxx_Flag() ?</source>
        </item>
        <item>
          <title>C++ Magic for LVALUE Checking...or Use Functions?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>C/C++ Implementation</category>
          <description><![CDATA[
            <p>If you write traditional C like:</p>
<pre><code>BINDING(cellA) = BINDING(cellB);
</code></pre>
<p>Regardless of what the BINDING() macro expands to, there's no way to do any sort of validation in any build (debug or otherwise).  Whatever this becomes can only be a simple assignment.</p>
<p>But if you instead wrote:</p>
<pre><code>Tweak_Binding(cellA, Binding_Of(cellB));
</code></pre>
<p>Then even if the intent is just a simple assignment in a release build, you could define that in a checked build to something that runs arbitrary code :</p>
<pre><code>#if NO_RUNTIME_CHECKS
    #define Tweak_Binding(dest,src) \ 
        (dest)-&gt;extra.binding = (src)-&gt;extra.binding
#else
    #define Tweak_Binding(dest,src) \
        Tweak_Binding_With_Added_Checks((dest), (src))
#endif
</code></pre>
<p><strong>But if you're willing to confine your extra checks to C++ builds, you can leave the source looking like <code>BINDING(cellA) = BINDING(cellB)</code></strong></p>
<p>This is because C++ has operator overloading, and you can create a wrapper class which "does the right thing", e.g. notices whether a <code>BINDING(...)</code> is used as a left hand side operator or right side operator.</p>
<h2><a name="p-7972-just-because-i-can-does-that-mean-i-should-1" class="anchor" href="https://forum.rebol.info#p-7972-just-because-i-can-does-that-mean-i-should-1"></a>Just Because I Can, Does That Mean I Should?</h2>
<p>Most of my original rationale was that I didn't want the source to make it look like you were making a function call when you were not.</p>
<p>When you see something like <code>Tweak_Binding(...)</code> you don't know how many instructions that's going to be, or what side effects its going to have.  But when you see a plain assignment (that you know compiles in C to something quite simple), then that tells you not much is going on.</p>
<p>However...I specifically came up with the term <strong><code>"Tweak"</code></strong> as a convention for functions like this that do very little.  It's a pretty good name, and it's learnable to say "oh, if it says Tweak, that means it's as cheap as an assignment".</p>
<p>Here are some of the points to consider:</p>
<ol>
<li>
<p>Because things like BINDING() are doing weird magic allowing them to be on the left side of assignments, by convention I believe they must be in all caps.  This is kind of noisy.</p>
<ul>
<li>On the plus side, it can be brief, with the same term used for extracting and for tweaking.  Since datatypes use the leading-caps with no underscore convention, plain <strong><code>Binding()</code></strong> looks like a parameterized datatype, so it would have to be <strong><code>Binding_Of()</code></strong> for the extractor</li>
</ul>
</li>
<li>
<p>Using C++ magic to get the RUNTIME_CHECKS means the C build won't have assertion-parity with the C build.  Bugs that only happen in the C build (perhaps on platforms that only offer C) would thus be harder to find.</p>
</li>
<li>
<p>The C++ operator overloading is going to be over the heads of those reading the code who only know C.</p>
</li>
<li>
<p>In debug builds, the C++ compilers do not inline the operator overloading, constructors, etc. that are involved in making the weird objects that are behind the scenes making the trick work.  That means using the C++ debugger to step into an expression like <strong><code>BINDING(cellA) = BINDING(cellB)</code></strong> takes an annoying number of step-in and step-out operations.</p>
</li>
</ol>
<h2><a name="p-7972-heres-the-scary-implementation-2" class="anchor" href="https://forum.rebol.info#p-7972-heres-the-scary-implementation-2"></a>Here's The "Scary" Implementation</h2>
<p>It really isn't rocket science, but it is something.  And it's something that can't be compiled by plain C compilers, meaning you can't do DEBUG_CHECK_BINDING in C builds.</p>
<pre><code>#if (! DEBUG_CHECK_BINDING)
    #define BINDING(cell) \
        *x_cast(Context**, m_cast(Node**, &amp;(cell)-&gt;extra.node))
#else
    struct BindingHolder {
        Cell* &amp; ref;

        BindingHolder(const Cell* const&amp; ref)
            : ref (const_cast&lt;Cell* &amp;&gt;(ref))
        {
            assert(Is_Bindable_Heart(Cell_Heart(ref)));
        }

        void operator=(Stub* right) {
            Assert_Cell_Writable(ref);
            ref-&gt;extra.node = right;
            Assert_Cell_Binding_Valid(ref);
        }
        void operator=(BindingHolder const&amp; right) {
            Assert_Cell_Writable(ref);
            ref-&gt;extra.node = right.ref-&gt;extra.node;
            Assert_Cell_Binding_Valid(ref);
        }
        void operator=(nullptr_t) {
            Assert_Cell_Writable(ref);
            ref-&gt;extra.node = nullptr;
        }
        template&lt;typename T&gt;
        void operator=(Option(T) right) {
            Assert_Cell_Writable(ref);
            ref-&gt;extra.node = maybe right;
            Assert_Cell_Binding_Valid(ref);
        }

        Context* operator-&gt; () const
          { return x_cast(Context*, ref-&gt;extra.node); }

        operator Context* () const
          { return x_cast(Context*, ref-&gt;extra.node); }
    };

    #define BINDING(cell) \
        BindingHolder{cell}
#endif
</code></pre>
<h2><a name="p-7972-looking-at-them-side-by-side-3" class="anchor" href="https://forum.rebol.info#p-7972-looking-at-them-side-by-side-3"></a>Looking at them Side-By-Side</h2>
<pre><code>BINDING(cellA) = BINDING(cellB);

Tweak_Binding(cellA, Binding_Of(cellB));
</code></pre>
<p>I do feel a pretty strong bias for the briefer notation...</p>
<p>But I can see the argument for not doing the "weird" thing when there's no increase in functionality... in fact, only losing functionality in C builds.  <em>(Most C++-isms are there to add something that would be fundamentally not possible in C, vs. just syntax sugar like this.)</em></p>
<p>The invention of the "Tweak" term does change my calculation a little bit here.  Because if it's used only in these "single-assignment-equivalent" circumstances, you can comprehend it as a C assignment statement.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/c-magic-for-lvalue-checking-or-use-functions/2350">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/c-magic-for-lvalue-checking-or-use-functions/2350</link>
          <pubDate>Thu, 12 Dec 2024 13:07:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2350</guid>
          <source url="https://forum.rebol.info/t/c-magic-for-lvalue-checking-or-use-functions/2350.rss">C++ Magic for LVALUE Checking...or Use Functions?</source>
        </item>
        <item>
          <title>About the C/C++ Implementation category</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>C/C++ Implementation</category>
          <description><![CDATA[
            <p>This category is for discussing issues in the source code for the interpreter itself.</p>
<p>e.g. what versions of the C or C++ language spec are supported, or how variables are named, or anything pertinent to that.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/about-the-c-c-implementation-category/2349">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/about-the-c-c-implementation-category/2349</link>
          <pubDate>Thu, 12 Dec 2024 12:22:15 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2349</guid>
          <source url="https://forum.rebol.info/t/about-the-c-c-implementation-category/2349.rss">About the C/C++ Implementation category</source>
        </item>
        <item>
          <title>Renaming SPECIFIER =&gt; CONTEXT ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>C/C++ Implementation</category>
          <description><![CDATA[
            <p>There was a typeset in historical Rebol that was called ANY-OBJECT!, that tried to pull together anything that had WORD! keys that could be used as a binding target:</p>
<pre><code>r3-alpha&gt;&gt; help any-object!
ANY-OBJECT! is a typeset of value: make typeset! [
    object! module! error! task! port!
]
</code></pre>
<p>I had sort of a naming philosophy (which I still have) that you shouldn't name the category based on one of its instances like this.  Several reasons, but one is that it certainly confuses the implementation when you extract the pointed-to entity out of a cell:</p>
<pre><code> if (Cell_Type(cell) == TYPE_ERROR) {
     Object* = Cell_Object(cell);  // wait, but it's an ERROR! not an OBJECT!
     ...
 }
</code></pre>
<p>You could call it <code>AnyObject</code>, I guess.  But that's not the direction I took... instead calling the category ANY-CONTEXT!, and if you saw <code>Context*</code> in the source you wouldn't get confused to thinking it was an extraction from a CONTEXT! cell, because there was no such thing.  You knew it was the implementation of a superclass.</p>
<h2><a name="p-7223-enter-specifier-1" class="anchor" href="https://forum.rebol.info#p-7223-enter-specifier-1"></a>Enter "Specifier"</h2>
<p>"Specifier"--the aggregated inheritance of binding candidates--has moved from an implementation detail to something which is rising to the surface of user awareness.  For that, it's a lousy name... and am near-certain I want to take "Context" for it.</p>
<p>I like Context better than Environment, as it's shorter and leaves environment for "environment variables" (which being a script-class language Ren-C needs to be better at interacting with than it is today).</p>
<p>We could say the other types are ANY-DICTIONARY!, although the name DICTIONARY! has been suggested as a replacement for MAP!, since we are thinking of MAP more as a function now.  But Dictionary may make more sense for things that only permit "words" as keys.</p>
<p>A CONTEXT! itself--as a composition of other dictionaries (and possibly even just programmatic code that answers value-for-WORD!)--may itself be categorized as an ANY-DICTIONARY!</p>
<h2><a name="p-7223-implementation-variance-needs-work-2" class="anchor" href="https://forum.rebol.info#p-7223-implementation-variance-needs-work-2"></a>Implementation Variance Needs Work</h2>
<p>So something that has happened in the messy evolution of the code is that the one-size-fits all <strong><code>Context*</code></strong> data structure that backed things like OBJECT!, ERROR!, MODULE! etc. became fractured around the time of Sea of Words and LET.</p>
<p>Modules do not use the same representation, and have to be enumerated completely differently.  There's not really a lot of generic code that acts the same way for OBJECT! and MODULE!, to the point that we'd be better off dispelling the illusion in the C sources and making <strong><code>Module*</code></strong> its own distinct type.</p>
<p>There's a lot to consider here about what the limits of "Amish" implementation are:</p>
<ul>
<li>
<p>I'm pretty much sold on the known-integer-values concept for Frame.  And if <em><strong>I</strong></em> say that drifting away from that destroys what the project <em>is</em>, then it almost certainly does--because I'm known for being iconoclastic about a fair number of Rebol sacred cows.</p>
</li>
<li>
<p>BUT taking a diverging approach for Module from "parallel arrays of Key and Value cell indexed by integer" has proven essential.  Floating variable stubs hanging off the word symbols themselves is an answer that has been critical in giving some legitimacy to modules, and it still passes the "simple" test for me.</p>
<ul>
<li>R3-Alpha was utterly hopeless, and Red will be too if they follow down that path (should they ever get modules).  I do not think this is a problem appropriate to approach with two-parallel-arrays.</li>
</ul>
</li>
<li>
<p>Objects are kind of a wild card.  Given their attempt to be dirt-simple, we might more accurately call the current version "Struct" or "Structure" instead (major annoyance in C naming the variables though, <code>Struct _struct</code>, to dodge the <code>struct</code> keyword?)</p>
<ul>
<li>
<p>People want to dynamically add and remove keys from objects.  Rebol2 and Red don't allow it, and R3-Alpha only permitted growth (so the index numbers stored in words that were bound at an index wouldn't be invalidated)</p>
</li>
<li>
<p>Moving to a more amortized implementation that spreads and shares keys gets you to something more like a database, where you can't point to little contiguous packets of memory and say "there is the object."</p>
</li>
<li>
<p>As I said above, I think this was a necessity for Modules.  But the simple implementation that works quite well for them wouldn't scale to tens of thousands of objects which have keys with the same name.</p>
</li>
<li>
<p>There's plenty of prior art and writeups of how JavaScript engines and others have approached this, and gotten it to be fast.</p>
</li>
</ul>
</li>
</ul>
<p>Anyway, this all kind of culminates in saying that objects are due for a reckoning at some point.  We want to err on the side of simplicity over optimized complexity, but there may be a sufficiently elegant way to attack objects that can grow and shrink effectively and having better code overall than we have today.</p>
<h2><a name="p-7223-anyway-back-to-the-naming-issue-3" class="anchor" href="https://forum.rebol.info#p-7223-anyway-back-to-the-naming-issue-3"></a>Anyway, Back To The Naming Issue...</h2>
<p>The above sort of reveals why ANY-OBJECT! isn't a good name for ANY-DICTIONARY or ANY-BINDTARGET?.</p>
<p>Hm, maybe we consider ANY-BINDABLE? to be the category for things that can be bound <em>to</em>, and come up with another name for anything that can be bound?  ANY-REFERENCE?</p>
<p>Eh, that sounds confusing.  Dictionary may be about as good as it gets (?)</p>
<p>So basically, Dictionary would be a superclass offering lookup from Word Symbol =&gt; Value.  If you wanted anything else from it, you would have to figure out what subclass it was, because how you do things like enumerate keys and values diverges significantly.</p>
<h2><a name="p-7223-or-maybe-some-unifying-theory-will-come-along-4" class="anchor" href="https://forum.rebol.info#p-7223-or-maybe-some-unifying-theory-will-come-along-4"></a>Or Maybe Some Unifying Theory Will Come Along?</h2>
<p>It could be, that everything--including OBJECT! and MODULE!, have the "inheritance" powers of what Specifier has today.</p>
<p>Which would mean that you wouldn't have Specifiers.  You'd just ask for the binding of a block and maybe get a MODULE! that inherits from an OBJECT!, or an OBJECT! that inherits from a MODULE!, or a LET! that inherits from a LET! that inherits from an OBJECT!, etc.</p>
<p>It all warrants more thought, and maybe a quick attempt to swap out the current OBJECT! implementation with something like V8's <a href="https://v8.dev/docs/hidden-classes">Hidden Classes</a> and see how it meshes with the system.  I've been so focused on the "bricks" in the language that these sorts of "boring" implementation details have just sort of been left alone while that's sorted out, but now it's getting to the point where there seem to be some answers to guide the shape.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/renaming-specifier-context/2168">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/renaming-specifier-context/2168</link>
          <pubDate>Wed, 06 Mar 2024 18:56:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2168</guid>
          <source url="https://forum.rebol.info/t/renaming-specifier-context/2168.rss">Renaming SPECIFIER =&gt; CONTEXT ?</source>
        </item>
        <item>
          <title>QUOTE_BYTE Values (Antiform, Normal, Quasi, Quoted)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>C/C++ Implementation</category>
          <description><![CDATA[
            <p>The "game" of Rebol is played with cells that are the size of four platform pointers.  So on a 32-bit platform a cell is 16 bytes in size, and on a 64-bit platform they are 32 bytes in size.</p>
<p>I've illustrated Ren-C's spin on this "game" previously:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/198e92149d15782107ac8c2852d336c9cea200d1.png" data-download-href="https://forum.rebol.info/uploads/default/198e92149d15782107ac8c2852d336c9cea200d1" title="ren-c-cell"><img src="https://forum.rebol.info/uploads/default/optimized/1X/198e92149d15782107ac8c2852d336c9cea200d1_2_690x281.png" alt="ren-c-cell" data-base62-sha1="3E5omo3mg1b0FRQoFVFHU57OGqt" width="690" height="281" srcset="https://forum.rebol.info/uploads/default/optimized/1X/198e92149d15782107ac8c2852d336c9cea200d1_2_690x281.png, https://forum.rebol.info/uploads/default/optimized/1X/198e92149d15782107ac8c2852d336c9cea200d1_2_1035x421.png 1.5x, https://forum.rebol.info/uploads/default/original/1X/198e92149d15782107ac8c2852d336c9cea200d1.png 2x" data-dominant-color="EDEDED"></a></div><p></p>
<p>The bits and bytes in the header are arranged in a platform-independent way.  Regardless of the endianness of the machine, the bits in the header will be in the same order.  The first byte is chosen with a pattern that specifically will never occur as a leading byte in a UTF-8 sequence...allowing an arbitrary pointer to be discerned as pointing to a cell or to the beginning of a UTF-8 string.</p>
<p>The "payload" is specifically aligned to a 64-bit boundary on both 32-bit and 64-bit platforms.  This is important if it contains something like a double precision floating point number.  It is also a union, which means that if it has constituent fields, they must be read from exactly the same union definition which was used to assign them.  The "extra" is separate, meaning it is decoupled from the payload and can be assigned and read on its own terms (e.g. BLOCK! and WORD! could have a "binding" in extra that is read and written in common, without invalidating their payloads).</p>
<p>The HEART_BYTE encodes what we would think of as the underlying datatype, and cues the interpretation of the contents of the cell.  For instance the byte corresponding to a BLOCK! tells us that the payload consists of a pointer to an array of more cells as well as an index into the block.</p>
<h2><a name="p-6802-enter-the-quote_byte-1" class="anchor" href="https://forum.rebol.info#p-6802-enter-the-quote_byte-1"></a>Enter the QUOTE_BYTE</h2>
<p>Bits in the header are scarce.  And at one time, quoting was implemented by only two bits... for quoting levels of 0, 1, 2, or 3.  Higher quoting levels were achieved by changing the HEART_BYTE to indicate QUOTED!, and then the payload was changed to point to a single-element array that held the quoted cell, and an integer of the quoting level up beyond millions.  It was tricky to do, but it worked.</p>
<p>Eventually, the complex mechanics behind flipping to a different payload for higher levels of quoting was scrapped, and an entire byte in the header was sacrificed for the quote level.  This permitted from 0-255 levels of quoting, and I decided that was more than enough.</p>
<p>When isotopes were originally introduced, there was a flag taken to say something was an antiform.  However, I realized that something should not be quoted and be an antiform at the same time.  Hence the antiform state could be thought of as a special value of the QUOTE_BYTE.</p>
<p>Initially I chose 255 for antiforms, leaving 0-254 as the ordinary quoting levels.  But the theory of isotopes evolved to where not only were there antiforms, but there needed to be a form of quoting that would produce antiforms under evaluation...so-called <em>quasiforms</em>.  And it began to make sense to think of the antiform state as being obviously "less" than other quoting levels, so it became 0.</p>
<p>What it worked out to was:</p>
<ul>
<li>
<p>Quoting byte of 0 is an isotope: <strong><code>#define ANTIFORM_0 0</code></strong></p>
</li>
<li>
<p>Quoting byte of 1 is plain not-quoted: <strong><code>#define NOQUOTE_1 1</code></strong></p>
</li>
<li>
<p>Quoting byte of 2 is a quasiform: <strong><code>#define QUASI_2 2</code></strong></p>
</li>
<li>
<p>Quoting byte of 3 is single quoted plain form: <strong><code>#define ONEQUOTE_3 3</code></strong></p>
</li>
</ul>
<p>A quoting byte of 4 is a single-quoted quasiform.  e.g. there's no such thing as a quasi-quoted, just a quoted-quasi: <strong><code>'~foo~</code></strong> is legal but <strong><code>~'foo~</code></strong> is not.</p>
<p>So the interpretation of the QUOTE_BYTE proceeds like that.</p>
<ul>
<li>
<p>Quoting byte of 5 is a double quoted plain form</p>
</li>
<li>
<p>Quoting byte of 6 is a double quoted quasiform</p>
</li>
<li>
<p>Quoting byte of 7 is a triple quoted plain form</p>
</li>
<li>
<p>Quoting byte of 8 is a triple quoted quasiform</p>
</li>
</ul>
<p>etc.</p>
<p>So although mechanically the byte holds a value of 0 for antiform, it still conceptually is what we might call a quote level of "negative one".</p>
<p>Evaluator drops one level of quoting, with the base case that quasiforms produce antiform and the normal form does whatever its evaluator rule is (WORD! looks up, etc.)</p>
<p>The QUOTE operator won't work on antiforms and the UNQUOTE operator won't work on quasiforms.  Instead you have to use the META and UNMETA operations, which handle those exceptions but just act like QUOTE and UNQUOTE otherwise.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/quote-byte-values-antiform-normal-quasi-quoted/2091">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/quote-byte-values-antiform-normal-quasi-quoted/2091</link>
          <pubDate>Thu, 04 Jan 2024 18:16:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2091</guid>
          <source url="https://forum.rebol.info/t/quote-byte-values-antiform-normal-quasi-quoted/2091.rss">QUOTE_BYTE Values (Antiform, Normal, Quasi, Quoted)</source>
        </item>
        <item>
          <title>Compiling ren-c with zig?</title>
          <dc:creator><![CDATA[IngoHohmann]]></dc:creator>
          <category>C/C++ Implementation</category>
          <description><![CDATA[
            <p>Has anyone tried to compile ren-c with zig? ( <a href="https://www.ziglang.org">https://www.ziglang.org</a> ).</p>
<p>They claim to be able to compile c-code using zig cc , and have an impressive list of cross compilation targets, wasm among them.</p>
<p><a href="https://ziglang.org/learn/overview/#zig-is-also-a-c-compiler">https://ziglang.org/learn/overview/#zig-is-also-a-c-compiler</a></p>
<p><a href="https://ziglang.org/learn/overview/#cross-compiling-is-a-first-class-use-case">https://ziglang.org/learn/overview/#cross-compiling-is-a-first-class-use-case</a></p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/compiling-ren-c-with-zig/2017">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/compiling-ren-c-with-zig/2017</link>
          <pubDate>Wed, 22 Feb 2023 21:31:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2017</guid>
          <source url="https://forum.rebol.info/t/compiling-ren-c-with-zig/2017.rss">Compiling ren-c with zig?</source>
        </item>
        <item>
          <title>Over 20 Years of C99: Making a Concession</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>C/C++ Implementation</category>
          <description><![CDATA[
            <p>In the interest of bragging rights, we've tried to say that Ren-C builds on C89.</p>
<p>Not quite true, since we use <strong><code>//</code></strong> comments instead of just <strong><code>/* */</code></strong> comments.  But a lot of compilers before C99 supported that, and you could just strip them out.</p>
<p>Also not quite true because we don't declare all locals at the top of blocks in a function.  But a lot of compilers before C99 supported that, and if not you could write a preprocessor to do it.</p>
<p>But a big feature that would helps if we permitted using it is C99 variadic macros.  It means we can automatically add terminator signals to API calls:</p>
<p>So instead of writing things like:</p>
<pre><code>if (rebNot("action?", rebQ(main_startup), rebEND))
    rebJumps("panic-value", rebQ(main_startup), rebEND);
</code></pre>
<p>We can say:</p>
<pre><code>if (rebNot("action?", rebQ(main_startup)))
    rebJumps("panic-value", rebQ(main_startup));
</code></pre>
<p>Right now we support both modes, but hold off on using the nicer mode in the internal implementation.</p>
<p>The C++ build checks to make sure that the rebENDs are there if you mark a file as "C89-compatible" and that it should have them.  So that makes it easier to not forget them if you meant them to be there.  But they're still an eyesore.</p>
<h2><a name="p-4940-i-think-its-time-to-adjust-the-rule-1" class="anchor" href="https://forum.rebol.info#p-4940-i-think-its-time-to-adjust-the-rule-1"></a>I Think It's Time to Adjust The Rule</h2>
<p>The original idea was that "public-facing" code would all use the nice mode, but we would bear the burden of rebEND in the internal code for the sake of making it compile on older systems.</p>
<p>However, the code for the interpreter itself is supposed to be a showcase of its features.  If you are looking at the startup sequence in <code>main.c</code> and are hit with these rebEND-based API calls, that's will prevent appreciating it fully.</p>
<p><strong>We should preserve the ability to call these APIs from C89.</strong>   e.g. you should be able to include libRebol from a C89 compiler.  That API file should have a mode you can use to include it in a C89 program, where you have to provide the rebENDs explicitly.</p>
<p><strong>But the internal implementation should allow the usage of the macro form.</strong>  Not leveraging it makes reading the code for Ren-C itself not as pleasing as it should be.  I want the code for stepping through the boot process and extensions to make the best impression.  And rebEND detracts from an otherwise profoundly distinct experience.</p>
<p>The answer for people who want to build the sources on a very old compiler would be the same answer as for those who want to build it on a system that doesn't have <code>//</code>-comments...run the source through a preprocessor.  Expand the rebXXX() macros to make a new version of the source, <em>and then compile that</em>.</p>
<p>Seems fair.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/over-20-years-of-c99-making-a-concession/1554">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/over-20-years-of-c99-making-a-concession/1554</link>
          <pubDate>Fri, 12 Mar 2021 01:40:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1554</guid>
          <source url="https://forum.rebol.info/t/over-20-years-of-c99-making-a-concession/1554.rss">Over 20 Years of C99: Making a Concession</source>
        </item>
        <item>
          <title>Should the C sources say `++foo` or `++ foo` ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>C/C++ Implementation</category>
          <description><![CDATA[
            <p>Generally speaking, the Ren-C sources try to adhere to the same kind of rules that Rebol uses.  So instead of writing <code>(x+y)</code> the code uses <code>(x + y)</code>, believing this is more legible.</p>
<p>It also embraces the idea of macros that define <code>and</code> for <code>&amp;&amp;</code>, and <code>not</code> for <code>!</code>.  In addition to these being defined in C++ since the original C++98 standard as "alternative tokens", the C track has an ISO standard header for it, so you can <code>#include &lt;iso646.h&gt;</code> if you like:</p>
<p><a href="https://en.wikipedia.org/wiki/C_alternative_tokens">https://en.wikipedia.org/wiki/C_alternative_tokens</a></p>
<p>In the C++ world, there are good reasons for preferring pre-increment and pre-decrement to post (all things being equal).  While it doesn't matter in C it's good to stay in a good habit:</p>
<aside class="onebox stackexchange" data-onebox-src="https://stackoverflow.com/questions/30036749/is-it-still-better-to-prefer-pre-increment-over-post-increment">
  <header class="source">

      <a href="https://stackoverflow.com/questions/30036749/is-it-still-better-to-prefer-pre-increment-over-post-increment" target="_blank" rel="noopener">stackoverflow.com</a>
  </header>

  <article class="onebox-body">
      <a href="https://stackoverflow.com/users/315052/jxh" target="_blank" rel="noopener">
    <img alt="jxh" src="https://i.sstatic.net/AB5ST.png?s=256" class="thumbnail onebox-avatar" width="256" height="256">
  </a>

<h4>
  <a href="https://stackoverflow.com/questions/30036749/is-it-still-better-to-prefer-pre-increment-over-post-increment" target="_blank" rel="noopener">Is it still better to prefer pre-increment over post-increment?</a>
</h4>

<div class="tags">
  <strong>c++, optimization</strong>
</div>

<div class="date">
  asked by
  
  <a href="https://stackoverflow.com/users/315052/jxh" target="_blank" rel="noopener">
    jxh
  </a>
  on <a href="https://stackoverflow.com/questions/30036749/is-it-still-better-to-prefer-pre-increment-over-post-increment" target="_blank" rel="noopener">05:59PM - 04 May 15 UTC</a>
</div>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>So I've habitually changed <code>foo++</code> to <code>++foo</code> when I see it, assuming it doesn't change the semantics.</p>
<p>But another maybe-seemingly-frivolous question arises, of if it would be better to put a space there?  <code>++ foo</code>?  Is it a readability advantage that C programmers have been missing out on?  Or is it wasteful and out of touch?</p>
<p>Hard to tell, as many people do like to say <code>x=y+1020;</code>, where we say <code>x = y + 1020;</code>.  It seems natural that the sources for a language that believes in space significance would do so, I'm just curious what the operating rule for why this wouldn't apply to <code>++</code> and <code>--</code> would come from.</p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/should-the-c-sources-say-foo-or-foo/1200">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-the-c-sources-say-foo-or-foo/1200</link>
          <pubDate>Thu, 29 Aug 2019 08:53:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1200</guid>
          <source url="https://forum.rebol.info/t/should-the-c-sources-say-foo-or-foo/1200.rss">Should the C sources say `++foo` or `++ foo` ?</source>
        </item>
        <item>
          <title>&quot;On Building Ren-C With C++ Compilers&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>C/C++ Implementation</category>
          <description><![CDATA[
            <p>Ren-C is a C codebase, but it can optionally also be built with a C++ compiler.  Building as C++ adds extra checking at <em>compile-time</em> of the interpreter's implementation.  This helps catch bugs that a C compiler could only check at <em>runtime</em>.  Plus--in the debug build only--the C++ build adds some extra runtime assertions, that do not affect interpreter semantics.</p>
<p>This document attempts to outline reasons for the choices in tooling, as it pertains to C and C++.</p>
<h1><a name="p-4046-why-use-c-instead-of-requiring-c-and-using-the-c-standard-library-1" class="anchor" href="https://forum.rebol.info#p-4046-why-use-c-instead-of-requiring-c-and-using-the-c-standard-library-1"></a>Why use C instead of requiring C++ and using the C++ standard library?</h1>
<p>Basically all languages measure their success against others with things like:</p>
<ol>
<li>How large is the source code a user must write for a given problem</li>
<li>How big in bytes is the installation for a program made with the system</li>
<li>How fast are programs written in the idiomatic style of the language</li>
<li>How well does the language help protect against common mistakes or bugs</li>
</ol>
<p>If today's Rebol executable were written in C++, it would not affect (1) (since the interpreter would behave the same).  Leveraging the C++ language features and <a href="http://en.cppreference.com/w/cpp/container">the well-vetted C++ standard library</a> would very likely <em>improve</em> Rebol on points like (2), (3), and (4).  After all, C++ was designed to not mean compromises on performance or size.</p>
<p>But Rebol (and Red) languages have unusual ideas of what counts as a "metric of success" or "signal of failure".  One metric is <em>the total complexity of the system, when the toolchain used to build the system is included in the equation</em>.  This is to say that Rebol's "complexity footprint" size must account for the tools used to build it.  (This aspect of concern is one that can be found also in the <a href="https://en.wikipedia.org/wiki/Forth_(programming_language)">Forth</a> community.)</p>
<p>To understand a self-hosting C compiler, you really only have to understand something like <a href="https://en.wikipedia.org/wiki/Tiny_C_Compiler">"TCC"</a>.  Its modern forms are around 300 <em>kilobytes</em> on x86, and that is enough to build Ren-C.  Yet the smallest full C++ compiler executables are around 3 <em>megabytes</em>.  The size of C++ is directly in proportion to the depth of nuances, features, and understandings required.  Even very straightforward code, like the implementation of <a href="https://gcc.gnu.org/onlinedocs/gcc-4.6.3/libstdc++/api/a01115_source.html">std::vector for gcc</a>, is quite deep about the features of the compiler that it depends upon to work.  This is considered a "cost" to be avoided.</p>
<h1><a name="p-4046-why-worry-about-building-a-c-program-as-c-2" class="anchor" href="https://forum.rebol.info#p-4046-why-worry-about-building-a-c-program-as-c-2"></a>Why worry about building a C program as C++?</h1>
<p>The practice of building C programs as C++ may sound strange, but it is not.  In fact, the GCC compiler itself is written in a generally-compatible subset of C and C++.  It is also recommendation CPL.2 from the <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-cpl">C++ Core Guidelines</a>:</p>
<blockquote>
<p>C rule summary:</p>
<ul>
<li>CPL.1: Prefer C++ to C</li>
<li>CPL.2: <strong>If you must use C, use the common subset of C and C++, and compile the C code as C++</strong></li>
<li>CPL.3: If you must use C for interfaces, use C++ in the code using such interfaces</li>
</ul>
</blockquote>
<p>For Ren-C, the advantages started out small--with enhanced cases of type checking.  Eventually this grew into more serious usage as a static analysis tool.</p>
<p>Next some very selective runtime checks in the debug build which lean on C++ were added.  These checks take advantage of something C++ can do which some C developers hate: namely that you can write a simple thing like <code>*a = *b;</code> and it might actually insert a function call to implement overloaded assignment.  When this "hated" property is limited to only adding asserts, it saves the codebase from becoming littered with:</p>
<pre><code> assert(Can_Assign_Values_Debug(a, b));
 *a = *b;
</code></pre>
<p>Having the C++ build do it "invisibly" from just <code>*a = *b;</code> is lighter weight--and keeps the focus on the main program logic.  So some asserts do work like this, if they are not that critical.  However, the C build uses ordinary macros such as <code>CHECKED_ASSIGN(a, b)</code> if it's important enough to warrant disruption in the source at every callsite.</p>
<p>At this point, it would be fair to say that some critical Ren-C features (e.g. <a href="https://github.com/metaeducation/ren-c/wiki/Relative-Binding-and-FRAME!-Internals">Specific Binding</a> and its outgrowths) would have been impractical to implement without the extra compile-time checks from C++.  It has really been an interesting study in its own right, of how the benefits of C++ can be applied while sticking to the domain of C.  For instance, see <a href="http://blog.hostilefork.com/c-casts-for-the-masses/">C Casts for the Masses</a></p>
<h1><a name="p-4046-how-old-or-new-a-c-compiler-can-be-used-to-build-ren-c-3" class="anchor" href="https://forum.rebol.info#p-4046-how-old-or-new-a-c-compiler-can-be-used-to-build-ren-c-3"></a>How old (or new) a C compiler can be used to build Ren-C?</h1>
<p>When Rebol's "R3-Alpha" codebase was released 12-Dec-2012, it was billed as <em>mostly</em> C89-compatible...which is to say that it could be built with compilers that obeyed a specification formally published in 1989.  <em>(Some compilers had the features prior to that.)</em>  Yet immediately obvious was the use of "C++-style" comments, e.g. <code>// comment</code> instead of <code>/* comment */</code>, which was not adopted formally by C until 1999.</p>
<p>On the question, <a href="http://www.rebol.com/cgi-bin/blog.r?view=0515#comments">Carl Sassenrath said</a>:</p>
<blockquote>
<p><em>"In the past it's been determined by practicality: what actually works over the widest range. (I can usually port REBOL3/core to any target machine in 5 minutes.)"</em></p>
<p><em>"This hasn't been easy, and it's why there are various C restrictions. I agree... many of the C++isms are nice, but can dramatically reduce portability to older boxes. It's a balancing act."</em></p>
</blockquote>
<p>Since the decisions arose pragmatically, there was no standard to point to.  So when Ren-C was started, it whipped the code into shape for C89 compliance, which could be checked with GCC's <code>--std=c89 --pedantic</code> switch.  Every warning was attended to, and that included things like adhering to the <a href="http://stackoverflow.com/questions/11488616/">509 character maximum for string literals</a> in generated code.</p>
<p>There were two exceptions of features that are <em>not</em> in the C89 standard which were left in early Ren-C:</p>
<ul>
<li>C++-style <code>//</code> comments, mentioned above</li>
<li>The expectation that a <code>long long</code> datatype existed <em>(see <a href="http://stackoverflow.com/questions/4017621/">-Wno-long-long</a>)</em>, because of the requirement of a 64-bit integer type</li>
</ul>
<p>Despite attempts to keep these as the only two "non-C89" features, the <code>long long</code> requirement did set a sort of baseline "minimum era" for the expected compiler.  And one feature that one could reasonably assume of any 64-bit capable compiler would be assignments in mid-scope:</p>
<pre><code> void foo() {
     int x = 10; // legal in C89
     int y1;
     if (Some_Check()) {
         printf("no declarations after statements.\n");
         return;
     }
     y1 = 20;
     int y2 = 20; // illegal in C89
 }
</code></pre>
<p>R3-Alpha almost always used "y1-style" initialization, even though "x-style" was legal.  This was perhaps because it is a pain when adding and removing statements to have to switch assignments back and forth between "y1-style" and "y2-style", so just sticking to the always-legal form of separating declarations and assignments was preferred.  But not only was there a mixture, the lack of compiler enforcement meant a few cases of "y2-style" had crept in.</p>
<p>So Ren-C originally removed those few "y2-style" stragglers.  But it's preferable to do initialization at the point of declaration, and any compiler supporting 64-bit integers almost certainly would be able to do this too.  That led this to be one of the <code>-pedantic</code> C89 rules that is disregarded.</p>
<p>The other common C feature that isn't in C89 but exists in most older compilers is support for inline functions.  However, it was not until C99 that "inline" was standardized...MSVC used __inline, for instance.</p>
<p>R3-Alpha used a small amount of inlining, and preferred preprocessor macros.  But it is common knowledge that if a C macro is "function-like", e.g. <code>#define MIN(a,b) ((a) &lt; (b) ? (a) : (b))</code> then there can be problems if evaluating an argument has a side-effect.  And even if evaluating an argument twice doesn't have side effects, it could be computationally wasteful to evaluate it more than once.  It's also easy to forget parentheses around expressions, and long macros are ugly when broken across lines.  There are a lot of reasons why "preprocessor macros are bad".</p>
<p>Not all C function-like macros can be replaced by C inline functions.  Since C lacks templates you lose generality e.g. <code>inline min(int a, int b) { return a &lt; b ? a : b; }</code> only works for <code>int</code> and not <code>float</code>.  Yet avoiding inline functions in Rebol may have less to do with a lack of compiler support, and more to do with the fact that it is "only a hint".  (The ultimate decision of whether inline is used is left to the optimizer.)</p>
<p>Ren-C shifted to use of the specific combination <code>inline static</code>, which means if inline is not available as a language keyword then it can be defined even as nothing.  Then the functions are just static, and compiled into each translation unit.</p>
<p>So the full list of non-C89 features used are:</p>
<ul>
<li>C++ style comments <code>//</code></li>
<li><code>long long</code></li>
<li>Declarations after statements</li>
<li><code>inline</code></li>
</ul>
<p>Other C99 or C11 features are not used.</p>
<h2><a name="p-4046-how-old-a-c-compiler-can-build-ren-c-as-c-4" class="anchor" href="https://forum.rebol.info#p-4046-how-old-a-c-compiler-can-build-ren-c-as-c-4"></a>How old a C++ compiler can build Ren-C as C++?</h2>
<p>While the C build tries to support very old compilers, the C++ checks do not.  It is not worth it to maintain compatibility for C++98 for the debug checks that C++ odes.</p>
<p><em>(Note: It wouldn't necessarily be hard to have conditional usage of C++11 features to make most of it work in C++98, there's just little point in the added complexity and <code>#ifdef</code>s.  It is not intended that release builds be made using C++ compilation.)</em></p>
<p>In terms of newer compilers, C++14 and C++17 have been tested and work under GCC and Clang.</p>
<h2><a name="p-4046-can-a-c-built-ren-c-library-work-with-a-c-built-one-5" class="anchor" href="https://forum.rebol.info#p-4046-can-a-c-built-ren-c-library-work-with-a-c-built-one-5"></a>Can a C-built Ren-C library work with a C++-built one?</h2>
<p>The external library "libRebol" should not notice a difference.  But the system internals ("sys-core.h") do compile differently, so an extension which can pick apart cells and such must be compiled with C++ if the core it runs against is also compiled with C++.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/on-building-ren-c-with-c-compilers/1343">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/on-building-ren-c-with-c-compilers/1343</link>
          <pubDate>Mon, 23 May 2016 04:00:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1343</guid>
          <source url="https://forum.rebol.info/t/on-building-ren-c-with-c-compilers/1343.rss">&quot;On Building Ren-C With C++ Compilers&quot;</source>
        </item>
  </channel>
</rss>

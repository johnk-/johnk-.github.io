<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Datatypes - AltRebol</title>
    <link>https://forum.rebol.info/c/development/datatypes/45</link>
    <description>Topics in the &#39;Datatypes&#39; category The datatypes category is for the discussion of the specific properties of datatypes themselves.  Sample topics might include:</description>
    
      <lastBuildDate>Thu, 26 Jan 2023 18:42:40 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/datatypes/45.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Should Quasiform Parameters Accept as the Plain Form?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p><strong><a href="https://forum.rebol.info/t/attack-of-the-activated-actions/1900">I'm very confident of the goodness of "isotopic actions"</a></strong>.</p>
<p>Not being able to put them in blocks gives us the <a href="https://forum.rebol.info/t/the-canonical-list-of-non-negotiables/1244/9">nice, mechanical invariant</a> of being able to manipulate blocks without inadvertently running functions in the process.  It opens the doors to other guardrails against isotopes being in variables when it might surprise you.</p>
<p>But what happens when you write something like SPECIALIZE, with a spec that looks something like:</p>
<pre><code>//
//  specialize: native [
//
//  {Create a new action through partial or full specialization of another}
//
//      return: [~action!~]  ; ~ notation since an isotopic action is returned
//      action "Function whose parameters will be set to fixed values"
//          [action!]
//      def "Definition for FRAME! fields for args and refinements"
//          [block!]
//  ]
//
</code></pre>
<p>Should SPECIALIZE tolerate being passed an isotopic action, maybe with a spec that looks like:</p>
<pre><code>return: [~action!~]
action "Function whose parameters will be set to fixed values"
    [action! ~action!~]
def "Definition for FRAME! fields for args and refinements"
    [block!]
</code></pre>
<p>This would lead to complexity inside most function, because now if it references the <strong>action</strong> variable it might run.  And this lack of automatic canonization to the inert form creates hassles for both usermode and native code alike.</p>
<p>Another thing is that the meaning of isotopic actions is potentially <em>very</em> different from that of a plain action.  For instance: <strong><code>find block :even?</code></strong> might know that since blocks cannot contain isotopes, it should interpret it as a function to call to test the items in the block for evenness.</p>
<p>So this led me to a bit of a thought...</p>
<h2>What if QUASI!-forms typechecked as the plain form?</h2>
<p>The idea is that there's an initial type check done.  If that check fails and it's a quasiform, it is tested again as its plain form.  If that passes, the plain form is received.</p>
<p>Producing a quasiform of an action from an isotope is easy, just use a meta operation.  So <strong><code>^append</code></strong> instead of <strong><code>:append</code></strong>.  All meta forms are inert, so code using the meta is less likely to do wild things.</p>
<p><em>To me, this feels like a safer exception than letting isotopes pass for plain forms.</em>  Due to their alien-ness, an isotopic form could intend something quite far from a mechanical brick in a block.  But what a quasiform has in common with a plain form is that both are inert.</p>
<p>Also, even the name "quasi" suggests a possibly loose relationship.  It carries the same payload as the plain form.  What if this were legal:</p>
<pre><code>&gt;&gt; add first [~1~] first [~2~]
== 3
</code></pre>
<p>I'm suggesting a general-enough mechanism that would work... so long as ADD didn't widen its net to taking actual ANY-VALUE! (which would indicate it had an actual meaning that applied to quasiforms).</p>
<p>This may not be the most brilliant thought to ever be thunk.  But in this more complex world there need to be succinct answers.  We don't want to have to write things like <strong><code>apply concretize :append [...]</code></strong>, and I feel like glossing over the fact that something is an isotope is a worse move than glossing over that something is a quasiform.</p>
<p>I even may like <strong><code>apply ^append [...]</code></strong> a bit more than <strong><code>apply :append [...]</code></strong> for looks, too.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-quasiform-parameters-accept-as-the-plain-form/2012">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-quasiform-parameters-accept-as-the-plain-form/2012</link>
          <pubDate>Thu, 26 Jan 2023 18:42:40 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2012</guid>
          <source url="https://forum.rebol.info/t/should-quasiform-parameters-accept-as-the-plain-form/2012.rss">Should Quasiform Parameters Accept as the Plain Form?</source>
        </item>
        <item>
          <title>Should Isotopes Be Legal in MAP! (Keys, Values?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>In the pre-isotopic era, there was a concept that MAP! would not allow you to store nulls.  Because null was the signal of not being in a map.  Assigning a key null was a way of removing items from that map.</p>
<pre><code>&gt;&gt; m: make map! [x 20]
== make map! [
    x 20
]

&gt;&gt; m.x
== 20

&gt;&gt; m.y
; null

&gt;&gt; m.x: null
; null

&gt;&gt; m
== make map! [
]
</code></pre>
<p>Additionally, NULL was not allowed as a key.</p>
<h2>How Should This Change In The Isotopic Era?</h2>
<p>I'll make the point that not allowing you to store isotopes as keys or values isn't a fundamental problem, because you can META a value to put it in, and then UNMETA it when taking it out.</p>
<p>You wind up with a fundamental issue that actions from a MAP! won't be run implicitly this way, and you can't put any falsey values in a map this way (because false is the ~false~ word isotope, and ~null~ isotopes are representations of not being in the map).</p>
<p>But that limitation can be a benefit.  I already think of it as a benefit that you cannot run an action by doing access of items out of a block.  e.g. <strong>block.1</strong> could never run a function now (since blocks can't store isotopic actions).  If that was true of <strong>map.key</strong> as well, that could be seen as a good thing... you'd have to APPLY or RUN a plain ACTION! (or QUASI-ACTION!).</p>
<pre><code>&gt;&gt; m: make map! []

&gt;&gt; m.1: :append
** Error: Cannot put ACTION! isotope in map

&gt;&gt; m.1: ^append
== ~#[action! {append} [series value /part /dup /line]]~

&gt;&gt; m.1
== ~#[action! {append} [series value /part /dup /line]]~

&gt;&gt; run m.1 [a b c] [d e]
== [a b c [d e]]

&gt;&gt; apply m.1 [[a b c] [d e] /dup 2]
== [a b c [d e] [d e]

&gt;&gt; m.1/ [[a b c] [d e] /dup 2]
== [a b c [d e] [d e]
</code></pre>
<p>As with the peace of mind using BLOCK!, that seems like a good thing to me.</p>
<p><em>(I'm not entirely sure if RUN should allow QUASI-ACTION!s, or if you should have to UNQUASI it into a plain ACTION!.  Forcing the canonization might make more sane, so that routines that want to exchange actions as currency would have one standard they spoke.)</em></p>
<p>I also think it's likely a good thing that false isotopes wouldn't be in the map, only quasi-false and the word false.  So if you're putting logic into a map, you'd wind up writing <strong><code>if map.key = 'true [...]</code></strong> or <strong><code>if map.key = 'false [...]</code></strong> and save the <strong>if map.key</strong> and <strong>if not map.key</strong> for testing things being in the map.</p>
<h2>This Would Widen The Gap With Objects</h2>
<p>There have been questions about what the difference is between maps and objects, and this would be another: objects must be able to have members that are isotopes: action isotopes that can run implicitly, logic and null and other word isotopes, and I'm presuming splices and other stable forms as well.</p>
<p>It would mean a map has more in common with a block.</p>
<p>This doesn't strike me as being that much of a problem.</p>
<p><strong>So I'm going to be going ahead with the premise that isotopes can't be stored in maps, as either keys or values.</strong>  We'll see how it goes, but I think this is the right answer.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-isotopes-be-legal-in-map-keys-values/1995">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-isotopes-be-legal-in-map-keys-values/1995</link>
          <pubDate>Fri, 02 Dec 2022 09:28:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1995</guid>
          <source url="https://forum.rebol.info/t/should-isotopes-be-legal-in-map-keys-values/1995.rss">Should Isotopes Be Legal in MAP! (Keys, Values?)</source>
        </item>
        <item>
          <title>Arrays For Composite Types</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <h2>First, There Was Quote "Protection"...</h2>
<p>An operating premise has been that this would be bad:</p>
<pre><code>&gt;&gt; (type of first [''a]) = (type of first [''''(x y z)])
== #[true]
</code></pre>
<p>You've got a double-quoted word going in on the left, and a quadruply-quoted group going in on the right.  They're both instances of QUOTED! but is it in any way useful to say they're the same type?</p>
<p>Of course, we do this with BLOCK! and don't blink:</p>
<pre><code>&gt;&gt; (type of [[a]]) = (type of [[[[(x y z)]]]])
== #[true]
</code></pre>
<p>We only look at the outermost container.</p>
<p>But following precedent from where LIT-PATH! and LIT-WORD! were seen as different types, the concept of folding not just quotedness but the actual quoting level into the type arose.</p>
<p>At first, Ren-C did a fairly cheap thing, by quoting the answer of TYPE OF by the number of quotes:</p>
<pre><code>&gt;&gt; type of first [a]
== #[datatype! word!]

&gt;&gt; type of first [''a]
== ''#[datatype! word!]
</code></pre>
<p><strong>But that won't be recognized as a DATATYPE!, because it's a QUOTED!</strong></p>
<p>This matters if you try something like:</p>
<pre><code>&gt;&gt; quoted-word!: first [''#[datatype! word!]]

&gt;&gt; did parse [''a] [quoted-word!]
== #[false]

&gt;&gt; did parse ['#[datatype! word!]] [quoted-word!]
== #[true]
</code></pre>
<p>The problem here is that PARSE already has an idea of how it handles QUOTED!s, e.g. to match something that is one quoting level lower than that thing.  So this quoted datatype isn't acting how you intended.</p>
<h2>So I Suggested Arrays To Wrap Quoted Types</h2>
<p>When the idea of using &amp;[...] arrays to represent types came along, I suggested this could be a solution:</p>
<pre><code>&gt;&gt; type of first [a]
== &amp;[word]

&gt;&gt; type of first [''a]
== &amp;[''word]
</code></pre>
<p>This gives us the nice properties we want of making these distinct "types" for purposes of comparison, while still both being of the same fundamental type for purposes of dispatch.</p>
<h2>Might Type Arrays Have Other Parameters?</h2>
<p>We could ask if all of these type arrays are just one element long--where that element is always a WORD!, quoted WORD!, or quasi WORD!...</p>
<p>Or might they have other parameters in them?  Would a vector say what they were vectors of:</p>
<pre><code> &gt;&gt; type of vec
 == &amp;[vector int32]
</code></pre>
<p>Would a matrix have its dimensions?</p>
<pre><code>&gt;&gt; type of mat
== &amp;[matrix (32 32)]
</code></pre>
<p>I've suggested that the narrower question of KIND might come back with a simpler answer:</p>
<pre><code>&gt;&gt; kind of mat
== &amp;matrix</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/arrays-for-composite-types/1979">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/arrays-for-composite-types/1979</link>
          <pubDate>Sun, 25 Sep 2022 00:48:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1979</guid>
          <source url="https://forum.rebol.info/t/arrays-for-composite-types/1979.rss">Arrays For Composite Types</source>
        </item>
        <item>
          <title>What Should TYPE OF an Isotope Be?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>At this exact moment...TYPE OF any isotope is an error, while both TYPE OF NULL and TYPE OF VOID give back NULL.</p>
<p>OF is a generic operation (the enfix form of REFLECT that quotes the word on its left.  It may be desirable to honor the VOID-in-NULL out convention for all the other reflectors that aren't TYPE... and it's desirable to error on NULL more generically.</p>
<pre><code>&gt;&gt; label of null
** Error: You didn't give anything

&gt;&gt; label of maybe null  ; MAYBE NULL is VOID 
; null
</code></pre>
<p>So if <strong>type of</strong> follows the same pattern as other <strong>xxx of</strong>, we'd surmise that you don't use TYPE OF to discern NULL and VOID.  It errors on NULL input and gives you back NULL if you MAYBE it.</p>
<p>But what happens when you ask:</p>
<pre><code>&gt;&gt; spread [d e]
== ~(d e)~  ; isotope

&gt;&gt; type of spread [d e]
???
</code></pre>
<h2>The Original Plan Was <em>No</em> Arguments Received Isotopes</h2>
<p>In the original conception, function frames weren't capable of holding isotopes in the arguments.  You physically could not receive a parameter that was an isotope.</p>
<p>I was also looking at the idea that some isotope forms--such as isotopic ERROR!--would be completely impossible to get into a variable, <em>ever</em>.</p>
<p>The only workaround was if a function used the ^META parameter convention, in which case an isotope would come in as a QUASI! form of the value...while normal values would come in as quoted:</p>
<pre><code> &gt;&gt; detector: func [^x] [print ["Meta of X:" mold x]]

 &gt;&gt; detector [d e]
 Meta of X: '[d e]

 &gt;&gt; detector spread [d e]
 Meta of X: ~(d e)~
</code></pre>
<p>Ultimately I backed down on this, instead allowing you to use type filtering to narrow which isotopes you'd be willing to accept:</p>
<pre><code>&gt;&gt; splicetaker: func [x [any-value! ~group!~]] [
       append [a b c] :x
   ]

&gt;&gt; splicetaker [d e]
== [a b c [d e]]

&gt;&gt; splicetaker spread [d e]
== [a b c d e]
</code></pre>
<p>So this creates a new typeset feature that is hacked in terribly <em>(the presence of any ~xxx!~ currently means the same thing as ~any-value!~, but it's documentation for when the feature gets better)</em>.  And it means that the ^META parameter convention is basically something that can be implemented on top of this, by doing something like <strong><code>x: my meta</code></strong> at the beginning of the function.</p>
<p>A primary driver behind this change was that operations which wanted to do things like ADAPT a function frame were having to become sensitive to whether a parameter was ^META or not, and it was more of a headache than having to use the <strong>:get-word</strong> accessors on variables.  It seemed that standardizing the frame in a way that permitted isotopes as currency made more sense than having arguments be sometimes-meta'd, sometimes not.</p>
<h2>What if OF (REFLECT) Didn't Take Isotopes?</h2>
<p>So we could say that if you think you have an isotope in your hand, you're responsible for ^META-ing it yourself:</p>
<pre><code>&gt;&gt; metatyper: func [x [any-value! ~group!~]] [
       print ["Metatype of X is" type of ^x]
   ]

&gt;&gt; metatyper [d e]
== @['block]  ; the TYPE OF received a QUOTED!, so e.g. answer incorporates quoted

&gt;&gt; metatyper spread [d e]
== @[~block~]  ; got QUASI!, so TYPE OF answer incorporates quasi
</code></pre>
<p>On the plus side of such an approach, we don't have to invent any type representations for isotopes.</p>
            <p><small>7 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/what-should-type-of-an-isotope-be/1983">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-should-type-of-an-isotope-be/1983</link>
          <pubDate>Sat, 24 Sep 2022 10:23:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1983</guid>
          <source url="https://forum.rebol.info/t/what-should-type-of-an-isotope-be/1983.rss">What Should TYPE OF an Isotope Be?</source>
        </item>
        <item>
          <title>Experiences While Paring Down DATATYPE!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>You likely know that DATATYPE! in R3-Alpha (Rebol 2, Red...) has a distinct "type byte" in the cell.  So you can tell it's a different thing, even if not all representations show that:</p>
<pre><code>r3-alpha&gt;&gt; block: reduce ['integer! integer!]
== [integer! integer!]

r3-alpha&gt;&gt; type? first block
== word!

r3-alpha&gt;&gt; type? second block
== datatype!
</code></pre>
<p>One way R3-Alpha has to see the difference is with MOLD/ALL</p>
<pre><code>r3-alpha&gt;&gt; mold/all block
== "[integer! #[datatype! integer!]]"
</code></pre>
<h2>But What's Actually <em>in</em> a DATATYPE! Cell?</h2>
<p>This was <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/include/sys-value.h#L106">the definition struct from R3-Alpha</a>:</p>
<pre><code>typedef struct Reb_Type {
    REBINT type;  // base type
    REBSER *spec;
    // REBINT min_type;
    // REBINT max_type;
} REBTYP;
</code></pre>
<p>So an integer to say what <strong><code>type</code></strong> it is (e.g. REB_INTEGER = 1, REB_LOGIC = 2, REB_BLOCK = 3 or whatever).  Note that this in the <em>payload</em> of the cell, not the header...because the type in the header is REB_DATATYPE to say it carries a "datatype payload".</p>
<p>Who knows what the commented-out <strong><code>min_type</code></strong> and <strong><code>max_type</code></strong> were.  But a remark says this payload is for a "Datatype or pseudo-datatype".  We can guess these were for pseudo-datatypes as a way of specifying a range of REB_XXX numbers to implement categories like ANY-SERIES!, as an alternative to typesets (?)</p>
<p>The <strong><code>spec</code></strong> is actually an object, that comes back as the answer to SPEC-OF:</p>
<pre><code>r3-alpha&gt;&gt; spec-of integer!
== make object! [
    title: "64 bit integer"
    type: 'scalar
]
</code></pre>
<p>This limited amount of information was built into the executable from the <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/boot/typespec.r#L24">Rebol-format table table in %typespec.r</a>.</p>
<p>You needed to use SPEC-OF to access these properties, but it could have been accessible with paths, e.g. <strong>integer!/title</strong>.  And it might have had more interesting properties:</p>
<pre><code>&gt;&gt; integer!/max-value
== 9223372036854775807
</code></pre>
<h2>Ren-C Had Actually Added More To DATATYPE!...</h2>
<p>Builtin types use a byte for the type in cells of the instances of values of that type.  This byte would index a static table of handlers that implement the datatype.  That would limit to you to 256 types...although for technical reasons the limit was actually 64.</p>
<p>Ren-C pushed <a href="https://forum.rebol.info/t/user-defined-datatype-discussion/1203/2">toward an implementation of extension types</a>.  This made it so if that byte was a special signal of "CUSTOM", it meant the implementation cells for that type must surrender one of their 4 platform-pointer-sized slots for a pointer to the method table.</p>
<p>A cool aspect of this generalization was that two bits in the cells started being used to flag whether the 2 out of the 4 remaining slots in the cell needed to be marked by the GC.  This generalized garbage collection to where a cell could be marked without having to customize the garbage collector for its type byte.  It just had to speak in the currency of "nodes".</p>
<p><em>(Doing this in a way that honors C's rules about strict aliasing was a little tricky, but possible.)</em></p>
<h2>All Redbols Conflated The Looks of DATATYPE! and WORD!</h2>
<p>In lockstep, they all did it:</p>
<pre><code>rebol2&gt;&gt; integer!
== integer!

r3-alpha&gt;&gt; integer!
== integer!

red&gt;&gt; integer!
== integer!
</code></pre>
<p>Since I have Boron built, I find it renames integer! to int!, but otherwise the same:</p>
<pre><code>)&gt; int!
== int!

)&gt; type? int!
== datatype!

)&gt; type? first [int!]
== word!
</code></pre>
<p><strong>It seemed to me that this conflation couldn't possibly be the best answer.</strong>  So I made Ren-C buck this trend to use the R3-Alpha construction syntax, because it was something that could LOAD back:</p>
<pre><code>&gt;&gt; integer!
== #[datatype! integer!]

&gt;&gt; load "#[datatype! integer!]"
== [#[datatype! integer!]]
</code></pre>
<p><strong>Rendering differently was good, but the specific different rendering wasn't all that palatable.</strong>  And it wasn't showing it as any complex object.</p>
<p>There seemed to be two directions to go with this:</p>
<ul>
<li>
<p>Accept DATATYPE! as some kind of alien complex type which has ugly rendering</p>
</li>
<li>
<p>Fit it into the lexical space somewhere.</p>
</li>
</ul>
<p>If it was going to be in the lexical space, that would mean the type would likely be coming from a symbol-bearing type.</p>
<h2>Paring It Down: Making DATATYPE! Hold Only A Symbol</h2>
<p>Ren-C doesn't use integers to refer to symbols like R3-Alpha and Red.  Instead, symbol table entries are series...like strings, which now hold UTF-8 data even when mutable.  (Frequently they are compact strings, whose UTF-8 spelling data fits in the space where tracking information for an allocation would live if an allocation were needed.)</p>
<p>So WORD! cells use pointers to refer to their symbols.  Despite that, <em>some</em> built-in symbols still are numbered.  These symbols have space statically allocated vs. allocated as series from the heap, and they can be indexed by number quickly.  Also, the symbols store their (16-bit) number in the series stub so you can go the other direction...from symbol to number.</p>
<p>The first 64 or so symbols are specifically chosen to be things like INTEGER!.  This means if a datatype just stored a symbol, it's easy to use that number to index into the builtin-type-hooks table.</p>
<p>If you refer to extension types by some arbitrary symbol which isn't predicted in those first 64 symbols, then it would likely have no number at all.  So with a DATATYPE! in your hand and that symbol, you'd have to look some extension type mapping table to get the hooks for that type.</p>
<p><em>But</em> I mentioned that instances of extension types gave up one of their 4 cell pointers to indicate this table.  And usually you need the dispatch table when you have an instance--not the datatype--so this isn't much of a problem.</p>
<h2>For Now, DATATYPE! Renders With An &amp;</h2>
<p>One step removed would be to say that as today, the WORD-ending-in-! is a layer of indirection over concrete types that use a sigil like &amp;.  This has been pitched as perhaps looking like:</p>
<pre><code>integer!: &amp;integer

any-word!: &amp;[word set-word get-word the-word meta-word]

is-even!: &amp;(#[action! {even?} [value]])
</code></pre>
<p>But the details are still being worked out.</p>
<p>What I will say is just that I think going in the direction toward where DATATYPE! goes toward "just being a symbol" and having everything else looked up feels correct.</p>
<p>I don't think making DATATYPE! itself a complex object was a direction we wanted to go further in.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/experiences-while-paring-down-datatype/1978">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/experiences-while-paring-down-datatype/1978</link>
          <pubDate>Sat, 24 Sep 2022 08:02:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1978</guid>
          <source url="https://forum.rebol.info/t/experiences-while-paring-down-datatype/1978.rss">Experiences While Paring Down DATATYPE!</source>
        </item>
        <item>
          <title>What If &quot;DATATYPE&quot; Was Isotopic (TL;DR: Bad Idea)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="1300">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>We now have isotopic types to sort out issues with nonliteral matching.</strong> So we could say:</p>
<pre><code>&gt;&gt; find ["a" @[integer!] 1 "b"] @[integer!]
== [@[integer!] 1 "b"]

&gt;&gt; matches @[integer!]
== ~@[integer!]~  ; isotope

&gt;&gt; find ["a" @[integer!] 1 "b"] matches @[integer!]
== [1 "b"]
</code></pre>
</blockquote>
</aside>
<p>Hey.  Waitasec...</p>
<p>...an unexplored idea here is if isotopic datatypes aren't just the <em>"I mean match the datatype, don't look for it literally"</em>... but what if it's more radical... to say <em><strong>that is what a datatype actually is</strong></em>.</p>
<p>In a nutshell, I'm saying this:</p>
<pre><code>&gt;&gt; integer!
== ~@[integer]~  ; isotope
</code></pre>
<p>This would lean more heavily into the idea of isotopes that don't trigger errors when you fetch them out of words, and would require friendlier handling in things like equality operators.</p>
<h2>Example Of Effects on FIND</h2>
<p>With the current implementation you'd thus get something like the historical behavior when using plain INTEGER!, and then get different results out of looking for the REIFY or META forms:</p>
<pre><code>&gt;&gt; find [a @[integer] ~@[integer]~ 1 b] integer!
== [1 b]

&gt;&gt; find [a @[integer] ~@[integer]~ 1 b] reify integer!
== [@[integer] ~@[integer]~ 1 b]

&gt;&gt; find [a @[integer] ~@[integer]~ 1 b] meta integer!
== [~@[integer]~ 1 b]
</code></pre>
<h2>The De-reification Of "DATATYPE!"</h2>
<p>So this would push our idea of what "DATATYPE?" is to being an isotopic THE-BLOCK! or whatever... in the same way that a SPLICE? is an isotopic group, and a PACK? is an isotopic block.</p>
<p>The "ugly-and-alarming QUASI!" form <em>could</em> be used to generate the datatype in a pinch:</p>
<pre><code> &gt;&gt; integer!
 == ~@[integer]~  ; isotope

 &gt;&gt; ~@[integer]~
 == ~@[integer]~  ; isotope

 &gt;&gt; switch type of 1020 [~@[integer]~ [print "It was an integer"]]
 It was an integer
</code></pre>
<p>But this kind of META/UNMETA would be a generic persistence tool that you'd reach for to be expedient.  Generally speaking the expectation would be that your source-level dialects that needed to represent types would work with another form.</p>
<h2>Downsides To Not Being Able to Put a "DATATYPE!" in a BLOCK?</h2>
<p>We're talking about a situation where if you write something like:</p>
<pre><code>reduce [1000 + 20 integer!]
</code></pre>
<p>You're going to get an error, because INTEGER! looks up to an isotope.  How you deal with this would be up to you, and I guess it all depends on what you're going to do with the block later.</p>
<p>Maybe you're putting something together for a kind of type test in the future?  You could leave the word around, either by quoting it or putting it in a BLOCK!, which is what is usually the mode of typeset representation in a dialect anyway:</p>
<pre><code>&gt;&gt; reduce [1000 + 20 'integer!]
== [1020 integer!]

&gt;&gt; reduce [1000 + 20 [integer!]]
== [1020 [integer!]]
</code></pre>
<p>If you're trying to "boil away" the word and get at the underlying type--maybe because you want to do a type test with it and have the meaning persist even if the word lookup changes, you've got the options of reifying or of meta'ing:</p>
<pre><code>&gt;&gt; reduce [1000 + 20 meta integer!]
== [1020 ~@[integer]~]

&gt;&gt; reduce [1000 + 20 reify integer!]
== [1020 @[integer]]
</code></pre>
<p>But the point is that these aren't the only options.  You might have other ideas for what @ types do, and so you might want to construct something entirely different:</p>
<pre><code>[1020 (&lt;type&gt; integer)]
</code></pre>
<p>However you'd need to get that transformed back before using it with FIND or a test against a TYPE OF.  The point of the <code>~@[...]~</code> and <code>@[...]</code> is that they are within close reach when you don't have a reason to overthink it and those cases don't collide with anything.</p>
<h2>Is This More Trouble Than Just DATATYPE!-Ends-In-(!)</h2>
<p>As things get shuffled around it's good to stop and ask back from first principles what the point is.</p>
<p>One point of having <em>an</em> isotopic form of a datatype is so that there's some non-reified signal to pass as a parameter that indicates you want to match the type vs. to look for it literally...as with the FIND example.</p>
<p>This could be done another way--with refinements or signals--just as splicing can be controlled by something like /ONLY instead of letting the value carry it.  But it's a neat feature that people had become attached to, and it's a kind of polymorphism that is pleasing.</p>
<p>That's part one...but then we can ask about the merits of this specific idea of having <em>only</em> an isotopic form.</p>
<p>There's the "representational greed" aspect--which basically says that if we can get away with having only an isotopic form carry the meaning of "datatype", the non-isotopic form becomes fair game for other things.</p>
<p>What's nice about this is that when I say:</p>
<pre><code> parse [1 2] [some integer!]
</code></pre>
<p>We're not giving anything up in the parse dialect box of parts related to @.  And we're not messing with words like <strong>!!WARNING!!</strong> or any other idea that might involve exclamation points.</p>
<p>I mentioned the fact that it was "no accident" that things like #[true] and #[false] were rendered as just the words true and false... because people didn't want something that wasn't the words "leaking".  I think that's true of the datatypes as well--it's a rare-if-ever situation that you want your mediums of exchange to have something gnarly like #[datatype! integer!] in them.  So with the "you can't put it in blocks" alert, you get to have that moment of triage.</p>
<p>Fitting into the whole puzzle of isotopes means they're just a stone's throw away from having a stock representation...but you'll need a step to bring it back to being a "datatype" again.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/what-if-datatype-was-isotopic-tl-dr-bad-idea/1982">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-if-datatype-was-isotopic-tl-dr-bad-idea/1982</link>
          <pubDate>Wed, 21 Sep 2022 08:45:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1982</guid>
          <source url="https://forum.rebol.info/t/what-if-datatype-was-isotopic-tl-dr-bad-idea/1982.rss">What If &quot;DATATYPE&quot; Was Isotopic (TL;DR: Bad Idea)</source>
        </item>
        <item>
          <title>The Implications of ^META Producing QUASI! from Isotopes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <h2>TL;DR - GET-WORD! to Fetch ACTION!s Will Be Unchanged</h2>
<ul>
<li>
<p>In the beginnings of the action isotope proposal, I thought that it would be perfect to move away from GET-WORD! to ^META-WORD! to reconstitute actions.</p>
<ul>
<li>
<p>The ^META-WORD! would give back something you could put into variables that was not word-active...hence easier to work with.</p>
</li>
<li>
<p>At that time, what ^META of an action isotope gave back was a plain ACTION!</p>
</li>
</ul>
</li>
<li>
<p>With the rise of generic isotopes and more examples of their functionality, it became clear that ^META of an isotopic form would return a <em>quasiform</em>.</p>
<ul>
<li>
<p>Quasiforms have a unique place in the system as a representation of "isotopic status in suspended animation"</p>
</li>
<li>
<p>Higher-order manipulations are not supposed to disregard the QUASI!-ness as if it's not there.  (The form was initially even more pejorative, called "BAD", to draw attention.)</p>
</li>
</ul>
</li>
<li>
<p>The need to have generic operations on ACTION! that compose or manipulate them suggests the best ergonomic is to make isotopic actions able to decay to plain ACTION! to facilitate these compositions.</p>
<ul>
<li>
<p>QUASI!-forms will not (and should not) do this decay, leading to unpleasant patterns like <strong>apply unquasi ^add [1 2]</strong></p>
</li>
<li>
<p>The preferable syntax of <strong>apply :add [1 2]</strong> can leverage the more malleable idea of isotopic decay to allow APPLY to accept an action isotope as its applicand.</p>
</li>
</ul>
</li>
<li>
<p>This decision ripples out to other operations which may be on the fence, such as CHAIN, which is now decided to work as <strong>chain [:add, :negate]</strong> instead of as <strong>chain [^add, ^negate]</strong> as was prototyped in an early commit.</p>
</li>
</ul>
<hr>
<p>Here was the line of reasoning to get there, which says the same thing in many more words.</p>
<hr>
<h2>The Construction of Historical CHAIN</h2>
<p>So far, if you wrote something that chained two functions together, like:</p>
<pre><code>&gt;&gt; double-plus-twenty: chain [lambda [x] [2 * x], specialize :add [value2: 20]]

&gt;&gt; double-plus-twenty 500
== 1020
</code></pre>
<p>What actually happened was two steps.  CHAIN is a higher-level function, that calls REDUCE of the block to produce ACTION! values, followed by calling a lower-level CHAIN* native that expects a block of just actions.</p>
<p>This was nice because it meant that the mechanics inside of CHAIN* didn't have to worry about having some implementation of REDUCE inside of it.  It could focus on what it did...taking in a list of ACTION!s, and building an aggregate ACTION! that ran them as a pipeline.</p>
<h2>...Enter ACTION! Isotopes...</h2>
<p>The first experiment was that if you did something like <strong><code>^append</code></strong> on an action isotope (like the word APPEND would look up to), you would get a plain ACTION! back.</p>
<p>The previous CHAIN* would thus still work, so long as you changed it to ^META whatever you wanted to chain together:</p>
<pre><code>reversed-append: chain [^append, ^reverse]
</code></pre>
<p>But a design decision emerged that when you ^META an isotope, you get a QUASI! form.  This is one of the reasons that even though isotopes have "no representation", they are shown with the QUASI!-marks in the default terminal (plus a comment).</p>
<pre><code>&gt;&gt; spread [a b c]
== ~(a b c)~  ; isotope

&gt;&gt; ^ spread [a b c]
== ~(a b c)~
</code></pre>
<p>Generally speaking, this is a good thing.  If you have to ^META something just to reify it (with the intention to UNMETA it down the line and get the isotope back), then this is informative.  It's why you have to take special action to throw the quasi status away (UNQUASI).</p>
<p>But now if you feed the lower-level CHAIN with an array out of REDUCE of ^META forms, you'll have a block of QUASI!-actions:</p>
<pre><code>&gt;&gt; reduce [^append, ^reverse]
== [~#[action! {append} [...]]~ ~#[action! {reverse} [...]]~]
</code></pre>
<p>GET-WORD!s couldn't be handled by a plain REDUCE at all, because they'd give back isotopes--illegal in blocks.</p>
<h2>"So What's The Problem?  Make CHAIN Take QUASI-ACTION!"</h2>
<p>Mechanically, that would work.</p>
<p>But if it takes QUASI-ACTION!, should it still take plain ones too?</p>
<p>Let's stop and think about what the difference between an ACTION! and a QUASI-ACTION! represented in a block are.</p>
<p>A plain ACTION! in a block is something that when evaluated, will run the action.</p>
<pre><code>&gt;&gt; compose [(unquasi ^add) 1000 20]
== [#[action! {add} [...]] 1000 20]

&gt;&gt; do compose [(unquasi ^add) 1000 20]
== 1020
</code></pre>
<p>A QUASI! action will evaluate to produce an isotopic action.  The current proposal for isotopic actions is that they are unfriendly as most isotopes are, so that they are hard to assign to WORD!s.  But techniques would sneak past that...namely having purposeful function generators wrap them up in isotopic objects designed to communicate with SET-WORD!s/etc. and approve the assignment:</p>
<pre><code>&gt;&gt; ^add
== ~#[action! {add} [...]]~

&gt;&gt; do compose [(^add)]
== ~#[action! {add} [...]]~  ; isotope

&gt;&gt; do compose [(^add) 1000 20]
== 20  ; didn't run the action, it evaluated isotopically and vanished
</code></pre>
<p>So you'd use different pieces in different ways.</p>
<p>When you look at it this way, it kind of makes it seem like QUASI-ACTION! should be the currency of action that CHAIN would want.  Consider the difference between these two at-a-glance:</p>
<pre><code>[#[action! {append} [...]] #[action! {reverse} [...]]]

[~#[action! {append} [...]]~ ~#[action! {reverse} [...]]~]
</code></pre>
<p>The first array of plain ACTION!s comes off as something of an incomplete sentence.  It's like you've written <strong>[append reverse]</strong> and you're building up a statement where the first argument to an APPEND is being REVERSE'd:</p>
<pre><code>&gt;&gt; code: [#[action! {append} [...]] #[action! {reverse} [...]]]

&gt;&gt; append code [[a b c] [d e]]

&gt;&gt; do code
== [c b a [d e]]
</code></pre>
<p>The second array of QUASI!-actions is kind of clearly not a sentence.  It's more like a collection of isotopic actions in "suspended animation".  If you REDUCE-EACH it, you'll be able to digest it back into action isotopes.</p>
<p>Looked at in just this light, the QUASI! actions seem like a pretty good currency for CHAIN* to accept.  Though it's behind the scenes a bit.</p>
<h2>But Such Decisions Ripple...</h2>
<p>So now let's look at something that doesn't take its input in an array, like APPLY.  Today it takes an ACTION! as an argument:</p>
<pre><code>apply: func [
    applicand [action!]
    args [block!]
][...]
</code></pre>
<p>The goal of isotopic actions is to have a way that generic parameters or things that enumerate blocks don't have to worry about turning a WORD! into something that runs actions unexpectedly.  It's not really as relevant to things like APPLY, because they <em>know</em> things like their APPLICAND are an ACTION!.  This isn't a burden...and in fact, it can be annoying if you plan on calling the function in the body to receive it inertly.</p>
<p><em>(Quick reminder: it's also a solution to a problem <a href="https://gitter.im/red/red?at=631c6475999499629359f1ec">that Boris repeatedly mentions</a>, e.g. REPLACE can't distinguish between an action you pass it to look for literally vs. one you want to run as part of the replacement.  So it's more than just a safety tool.)</em></p>
<p>Anyway...things are all a bit turned on their head, because it's kind of not clear how to get a plain ACTION!.  Things like FUNC create action isotopes (wrapped up in an object to denote they were just generated, and so it's likely they were intended to be assigned somewhere soon).  And then ^META operations make quasi forms.  So you've got choices like:</p>
<pre><code>&gt;&gt; :append
== ~#[action! {append} [...]]~  ; isotope

&gt;&gt; ^append
== ~#[action! {append} [...]]~

 &gt;&gt; func [] [return 1020]
 == ~#[action! [...]]~  ; isotope
</code></pre>
<p>The only ways to make a regular-old ACTION! is "unquasi meta" or a "reify get"</p>
<pre><code>&gt;&gt; reify :append
== #[action! {append} [...]]

&gt;&gt; unquasi ^append
== #[action! {append} [...]]
</code></pre>
<p>This got me to wondering if one of the decaying behaviors of isotopes would be that action isotopes decay to normal actions when passed to function arguments that don't take isotopes (but that would be happy to take actions).  That's within the M.O. of isotopes, just generally.</p>
<p>(Decaying a QUASI!-ACTION! makes less sense.  All ANY-VALUE! types are supposed to be robust bricks and trustworthy, that includes QUASI! and QUOTED!--e.g. none of the infamous "lit-word decay").</p>
<p>So that suggests people would call APPLY with a traditional GET-WORD!, pass an isotope, let it decay:</p>
<pre><code>&gt;&gt; apply :add [300 4]
== 304
</code></pre>
<p>But then this gives us a bit of an incongruity.  You're ^META-ing functions to put them in a CHAIN, and :GET-ting them to use them with an APPLY.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p><em>This feels annoying.</em>  So what it makes me think is that the higher-level CHAIN itself processes the array with something besides a REDUCE.  e.g. it does some kind of REDUCE-EACH, and accepts either ACTION! values or ACTION! isotopes, the way something like APPLY would.  It canonizes them to something (either QUASI-ACTION! or plain ACTION!, probably plain ACTION at this point).  Then the lower-level CHAIN* runs on that.</p>
<p>It makes sense for CHAIN to process isotopes, due to the idea of putting FUNC [] definitions in the chain anyway.  So using GET-WORD!s to get isotopes out of WORD!s wins over using carets.</p>
<p>As for whether CHAIN* should take QUASI-ACTION!s or plain ACTION!s... it's an implementation detail.  I can't tell if bending that one way or the other makes more sense.  It's cleaner to write the wrapper taking quasiforms, and the array more obviously represents a collection and not code.  But maybe there are other concerns.  I'll wait until some other usage of CHAIN* arises to worry about it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-implications-of-meta-producing-quasi-from-isotopes/1967">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-implications-of-meta-producing-quasi-from-isotopes/1967</link>
          <pubDate>Fri, 16 Sep 2022 22:25:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1967</guid>
          <source url="https://forum.rebol.info/t/the-implications-of-meta-producing-quasi-from-isotopes/1967.rss">The Implications of ^META Producing QUASI! from Isotopes</source>
        </item>
        <item>
          <title>Applications of Isotopic Objects</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Consider the example of a function that might want to have two modes... one that prints out readable information for the console, and another that keeps the data in easily processable form.</p>
<p>Traditionally you might think of controlling this with a refinement:</p>
<pre><code>&gt;&gt; stats
-------------------
Column 1   Column 2
-------------------
Alpha      10
Beta       20

&gt;&gt; stats/only
== [
    [Alpha 10]
    [Beta 20]
]
</code></pre>
<p>But then I wondered: what if there was only one isotopic result...that wrapped the data with functions?  So long as things stayed isotopic, you'd be able to get at the functions.  But it could decay to be the data.</p>
<pre><code>&gt;&gt; ^ stats
== ~#[object! [... decay: ... form: ...]]~

&gt;&gt; compose [statistics: (spread stats)]
== [statistics: [Alpha 10] [Beta 20]]

&gt;&gt; stats
-------------------
Column 1   Column 2
-------------------
Alpha      10
Beta       20

&gt;&gt; if true [print stats, &lt;PRINT could react to FORM also&gt;]
-------------------
Column 1   Column 2
-------------------
Alpha      10
Beta       20
== &lt;PRINT could react to FORM also&gt;
</code></pre>
<p>So PRINT would be special, and instead of allowing its argument to reify normally it would specifically examine isotopic arguments to see if they could FORM.</p>
<p>In this case, the isotopic thing needs to be able to do two things: FORM or DECAY.  But maybe it could do more things, if you asked it?  And maybe no particular methods are mandatory.  Something that doesn't know how to DECAY just won't do that.</p>
<p><strong>This looks kickass.</strong></p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/applications-of-isotopic-objects/1959">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/applications-of-isotopic-objects/1959</link>
          <pubDate>Sat, 03 Sep 2022 11:48:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1959</guid>
          <source url="https://forum.rebol.info/t/applications-of-isotopic-objects/1959.rss">Applications of Isotopic Objects</source>
        </item>
        <item>
          <title>Canonizing GROUP! as the Underlying Array Type for Splices</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>The first concept of representing splices out of isotopes was to make them as iostopic BLOCK!.</p>
<p>You'd get an isotopic block regardless of the input to SPREAD:</p>
<pre><code>&gt;&gt; spread [d e]
== ~[d e]~  ; isotope

&gt;&gt; spread '(d e)
== ~[d e]~  ; isotope

&gt;&gt; spread @[d e]
== ~[d e]~  ; isotope
</code></pre>
<p>From the perspective of things like APPEND, it doesn't matter:</p>
<pre><code>&gt;&gt; append [a b c] spread [d e]
== [a b c d e]

&gt;&gt; append [a b c] spread '(d e)
== [a b c d e]

&gt;&gt; append [a b c] spread @[d e]
== [a b c d e]
</code></pre>
<h2>I Think This Canonization of Splices Is Important</h2>
<p>By canonizing splices to just one type, we recover the other types for other meanings that have nothing to do with splicing.  That subtlety would be lost if people had to think of every array type as being a splice.</p>
<p>There's no real question in my mind that it needs to be canonized.  But which array form should it take?</p>
<h2>I Think GROUP! Is A  Better Choice</h2>
<ul>
<li>
<p><strong>It makes the canonization more obvious.</strong>  Since the input to SPREAD will typically be a BLOCK!, people will learn the type is not preserved quickly:</p>
<pre><code>&gt;&gt; spread [a b c]
== ~(a b c)~  ; isotope
</code></pre>
</li>
<li>
<p><strong>Parentheses look softer and more permeable.</strong>  They already are "weaker" in that they do not "block" evaluation in the way a BLOCK! does.  So their  softness makes it feel more reasonable to say that the edges aren't there.</p>
<p><em>(This semiotic permeability exists in other places where brackets and parentheses are juxtaposed... for instance in <a href="https://en.wikipedia.org/wiki/Interval_(mathematics)#Notations_for_intervals">interval notation</a>, where <strong>[10, 20)</strong> means "the numbers from 10 to 20 without including 20")</em></p>
</li>
<li>
<p><strong>The nothing state looks kind of like a zero.</strong>  I've proposed this "nothing" as the non-NULL, non-VOID state that empty branches could coerce to.  This has the nice property of signaling the branch was taken, while still being a no-op for things like appending:</p>
<pre><code>&gt;&gt; if true []
== ~()~   ; isotope

&gt;&gt; if true [] then [print "Not VOID, so we got the branch ran signal..."]
Not VOID, so we got the branch ran signal...

&gt;&gt; append [a b c] if true []
== [a b c]  ; damn, that's cool!
</code></pre>
</li>
</ul>
<p>While they act similarly to void in cases like append, they aren't void.  Hence they overwrite output cells...the information in that cell is lost:</p>
<pre><code>&gt;&gt; 1 + 2 if false [&lt;a&gt;]
== 3

&gt;&gt; 1 + 2 if true []
== ~()~  ; isotope</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/canonizing-group-as-the-underlying-array-type-for-splices/1953">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/canonizing-group-as-the-underlying-array-type-for-splices/1953</link>
          <pubDate>Wed, 31 Aug 2022 21:11:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1953</guid>
          <source url="https://forum.rebol.info/t/canonizing-group-as-the-underlying-array-type-for-splices/1953.rss">Canonizing GROUP! as the Underlying Array Type for Splices</source>
        </item>
        <item>
          <title>Thinking About Isotopes Logically: ~true~ and ~false~</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Here's an idea: what if <strong>~true~</strong> and <strong>~false~</strong> are examples of weird isotopic exceptions.</p>
<p>Let's say you could assign them to variables...and fetch them from variables...without erroring:</p>
<pre><code>&gt;&gt; true: ~true~
== ~true~  ; isotope

&gt;&gt; false: ~false~
== ~false~  ; isotope

&gt;&gt; obj: make object! [y: true, n: false]
== make object! [
     y: ~true~
     n: ~false~
]
</code></pre>
<p><em>(not being quoted in the assignment indicates they become their isotopic forms.)</em></p>
<p>This is typically not legal...accessing a WORD! isotope from a variable like true would be an error.  But these would be special (like how I'm suggesting isotopic ACTION! would be special in running the action from a word reference...)</p>
<p>Things that tested for truthiness would treat them as expected, considering the ~false~ isotope to be a falsey thing:</p>
<pre><code>&gt;&gt; any [true false]
== ~true~  ; isotope

&gt;&gt; all [true false]
; null
</code></pre>
<p><em>Being isotopes comes with a constraint</em>...you couldn't put them into blocks.  You'd have to ^META them (which would lose their special status, turning them into QUASI-WORD!s...that were truthy.</p>
<pre><code>&gt;&gt; ^ false
== ~false~

&gt;&gt; if ^ false [print "Meta false is truthy"]
Meta false is truthy
</code></pre>
<p>The functions TRUE? and FALSE? could then work on isotopic, non-isotopic, or word forms of TRUE and FALSE...but error if passed other values.</p>
<ul>
<li>
<p><strong>This should work for casual cases of just having variables that hold a true or false state...and gives a good appearance for knowing what you're looking at.</strong></p>
</li>
<li>
<p><strong>It builds on standard mechanisms, and hence if you need to promote the isotopic state into something that can be represented in a block you can do so... with the caveat that once you do, it will no longer reflect its logical property when used with IF and such.</strong></p>
<ul>
<li><strong>That's true for NULL being ^META promoted and put in blocks as well.</strong></li>
</ul>
</li>
</ul>
<p><strong>And crucially: Since you know isotopes can't be in blocks--and if we say BLANK! is truthy as well--then you'd be guaranteed to visit all the items in a block with code like this:</strong></p>
<pre><code>while [item: try take block] [
    print mold item
]
</code></pre>
<p>This is easily the best idea so far for dealing with the problem.</p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944</link>
          <pubDate>Thu, 25 Aug 2022 23:34:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1944</guid>
          <source url="https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944.rss">Thinking About Isotopes Logically: ~true~ and ~false~</source>
        </item>
        <item>
          <title>BLANK! 2022: Revisiting The Datatype</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>In historical Redbol's meaning of the datatype NONE!, it had the bad habit of looking like a WORD!:</p>
<pre><code>rebol2&gt;&gt; 'none
== none

rebol2&gt;&gt; none
== none  ; same in R3-Alpha and Red
</code></pre>
<p>But it wasn't a word:</p>
<pre><code>rebol2&gt;&gt; type? 'none
== word!

rebol2&gt;&gt; type? none
== none!
</code></pre>
<p>It was a distinct type, which also happened to be falsey (while WORD!s are truthy):</p>
<pre><code>rebol2&gt;&gt; if 'none [print "Truthy word!"]
Truthy word!

rebol2&gt;&gt; if none [print "Falsey none!"]
== none
</code></pre>
<p>And as we can see, NONE!s served purposes of signaling "soft failures": branches that didn't run, or FINDs that didn't find, or SELECTs that didn't select... etc.</p>
<pre><code>rebol2&gt;&gt; find "abcd" "z"
== none

rebol2&gt;&gt; select [a 10 b 20] 'c
== none
</code></pre>
<h2>
<a name="ren-c-divided-nones-roles-across-null-void-and-blank-1" class="anchor" href="https://forum.rebol.info#ren-c-divided-nones-roles-across-null-void-and-blank-1"></a>Ren-C Divided NONE!s roles across NULL, VOID, and BLANK!</h2>
<ul>
<li>
<p><strong>NULL</strong> - an "isotopic" state of WORD! that couldn't be put in BLOCK!s.  Anywhere that NONE! would be used to signal a soft failure operation--like FIND or SELECT--would use ~null~.</p>
<pre><code>&gt;&gt; null
== ~null~  ; isotope

&gt;&gt; find "abcd" "z"
== ~null~  ; isotope

&gt;&gt; select [a 10 b 20] 'c
== ~null~  ; isotope

&gt;&gt; append [a b c] null
** Error: APPEND doesn't allow ~null~ isotope
</code></pre>
</li>
<li>
<p><strong>VOID</strong> - the result of things that are effectively "no ops".  Some contexts choose to make them vanish, and when functions like APPEND get them as an argument they are treated as no-ops:</p>
<pre><code>&gt;&gt; void  ; void results don't show anything in the console

&gt;&gt; if null [print "Doesn't print as NULL is falsey"]

&gt;&gt; 1 + 2 if null [print "Voids disappear..."]
== 3

&gt;&gt; append [a b c] void
== [a b c]
</code></pre>
<p>(At one time void was also the state of unset variables, but that is now isotopic void...which has reclaimed the name "none")</p>
</li>
<li>
<p><strong>BLANK!</strong> was represented by a lone underscore ( <strong><code>_</code></strong> ) and could be put into blocks:</p>
<pre><code>&gt;&gt; append [a b c] _
== [a b c _]
</code></pre>
<p>It retained the choice to be falsey:</p>
<pre><code>&gt;&gt; if _ [print "Won't print because blanks are falsey"]
</code></pre>
</li>
</ul>
<h2>
<a name="question-one-should-blank-just-be-a-word-2" class="anchor" href="https://forum.rebol.info#question-one-should-blank-just-be-a-word-2"></a>Question One: Should BLANK! Just Be A WORD! ?</h2>
<p>Ren-C allows you to use underscores internally to words, so it feels a little bad to take away one word.</p>
<p>Outside of historically being hardcoded as falsey, what makes BLANK! fairly "built in" is that in the path mechanics, it fills in the empty slots:</p>
<pre><code>&gt;&gt; to path! [_ a]
== /a

&gt;&gt; as block! 'a//b//c
== [a _ b _ c]
</code></pre>
<p>Alternately, we could accomplish a "reified nothing" with a quoted void:</p>
<pre><code>&gt;&gt; to path! [' a]
== /a

&gt;&gt; as block! 'a//b//c
== [a ' b ' c]
</code></pre>
<p>But there's other places the blank is used, such as to opt-out of multi-returns.</p>
<pre><code>&gt;&gt; [_ pos]: transcode "abc def"

&gt;&gt; pos
== " def"
</code></pre>
<p>Once again, quoted void could be used here...though it looks a bit slight to my eyes, I can also see the point of view that it's better:</p>
<pre><code>&gt;&gt; [' pos]: transcode "abc def"
</code></pre>
<p>Broadening the question, we could ask if blank is really the best choice for opting out of things like loop variables in FOR-EACH? Since VOID is used to opt-out, might a lone apostrophe be more coherent?</p>
<pre><code>&gt;&gt; for-each ' [1 2 3] [print "no variable"]
no variable
no variable
no variable
</code></pre>
<p>It's more visually slight than <strong><code>for-each _ [1 2 3]</code></strong>, but not awful. And since voids are used to opt-out in slots it actually dovetails nicely with if the evaluated forms were allowed to opt out via void:</p>
<pre><code>for-each (if false ['x]) [1 2 3] [print "no variable"]
</code></pre>
<p>If your expression produces no iterative variables to bind in the body assume that you didn't need them. The alternative of <strong><code>(if false ['x] else [_])</code></strong> or even <strong><code>(if false 'x else '_)</code></strong> seems like busywork.</p>
<p>This even would mean you could use <strong><code>()</code></strong> as a less slight alternative, if you didn't like the <strong><code>'</code></strong> syntax:</p>
<pre><code>for-each () [1 2 3] [print "no variable"]  ; actually pretty nice!
</code></pre>
<p>The premise may hold for multi-returns also:</p>
<pre><code>&gt;&gt; [a ' c]: pack [1 2 3]
== 1

&gt;&gt; c
== 3

&gt;&gt; [a () c]: pack [4 5 6]
== 4

&gt;&gt; c
== 6
</code></pre>
<p>I'm not sure it looks worse than <strong><code>[a _ c]: pack [...]</code></strong>, and would open up:</p>
<pre><code>&gt;&gt; [a _ c]: pack [8 9 10]
== 8

&gt;&gt; _
== 9

&gt;&gt; c
== 10
</code></pre>
<p>So can lone apostrophe paper over some of the system-level needs for reified nothingness... at least in enough cases that it's a good tradeoff to give underscore back to wordspace?</p>
<h2>
<a name="question-two-does-blank-still-need-to-be-falsey-3" class="anchor" href="https://forum.rebol.info#question-two-does-blank-still-need-to-be-falsey-3"></a>Question Two: Does BLANK! Still Need To Be Falsey?</h2>
<p><em>My feeling is that having blank be falsey doesn't have all that much benefit.</em>  NULL does a better job of it, and really what it does is mess with its usefulness as a placeholder:</p>
<pre><code>&gt;&gt; append [a b c] all [1 &lt; 2, 3 &lt; 4, _]
== [a b c _]  ; would seem nice, but gives error today since ALL is NULL
</code></pre>
<p>Thinking of BLANK! as being "null-like" in terms of non-valuedness is generally a hassle.  It makes you wonder about whether something like DEFAULT should think of it as being assigned or not:</p>
<pre><code>&gt;&gt; item: _

&gt;&gt; item: default [1 + 2]
== ???
</code></pre>
<p>In practice, I prefer the truly non-valued NULL being the only cases that DEFAULT overwrites.  This is because NULL is far more useful than BLANK! when it comes to representing something that you think of as "not being assigned"... as you'll get errors when you try to use it places (e.g. in APPEND).  Trying to use it to represent nothingness invariably leads to stray appearances in blocks (Shixin wrote a lot of code to try to filter them out in Rebmake, prior to it being switched to NULLs)</p>
<p>This makes more sense, and I think it bolsters the argument that BLANK! is less of a falsey-NULL relative...but more of a placeholder value.  I've said "blanks are to blocks what space is to strings".  And space is truthy:</p>
<pre><code>&gt;&gt; if second "a b" [print "Space is truthy"]
Space is truthy

&gt;&gt; if second [a _ b] [print "So why shouldn't blank be truthy?"]
???
</code></pre>
<p><strong>So Either Way, I Suggest The Removal of BLANK! From Being Falsey</strong>.  This creates some incompatibility in Redbol (which has been using NONE! as a blank substitute).  But it's something that can be worked around.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942</link>
          <pubDate>Thu, 25 Aug 2022 13:50:26 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1942</guid>
          <source url="https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942.rss">BLANK! 2022: Revisiting The Datatype</source>
        </item>
        <item>
          <title>Big Alien Proposal :flying_saucer: &quot;/REFINEMENTS&quot; Run Functions</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <blockquote>
<p><strong>UPDATE</strong>...This was tried out, and while interesting things were learned it ultimately didn't "feel right" <em>(in particular the competition of <code>/slash</code> for refinement and <code>/slash:</code> for function definition was more annoying than anticipated, and SET-PATH!s introduce a lot of complexity in places it wasn't needed.)</em>  See further down the thread.  It's informing new designs being tried out.</p>
</blockquote>
<hr>
<p>So far, <strong><code>/leading</code></strong> <strong><code>/slash</code></strong> <strong><code>/notation</code></strong> has just been evaluator inert, lining up with Rebol2 and Red and R3-Alpha:</p>
<pre><code>redbol&gt;&gt; /foo
== /foo
</code></pre>
<p>That inertness doesn't seem to get leveraged much.  And in Ren-C it's a particularly weak choice, since the evaluator has generic quoting to get you the literal result:</p>
<pre><code>ren-c&gt;&gt; '/foo
== /foo
</code></pre>
<p>Also, leading slash is an actual PATH!...encompassing arbitrary patterns like <strong><code>/lib.append/dup/part</code></strong>.  So I've always been wondering if there was some interesting evaluator behavior for it, like...</p>
<ul>
<li>
<p>...asking to pick from "global scope": if your function has an argument called ALL then /ALL might get you the definition outside your function?  (Something like <strong><code>::foo</code></strong> in C++)</p>
</li>
<li>
<p>...maybe a shorthand for <strong><code>self/foo</code></strong> for picking members out of objects inside of methods?</p>
</li>
</ul>
<p>Yet nothing has ever really stuck.  But <a class="mention" href="https://forum.rebol.info/u/ingohohmann">@IngoHohmann</a> pointed out that there's a basic thing that leading slashes might do for us which may have been overlooked...</p>
<p>...<em>simply running functions</em>.</p>
<h2>"But WORD!s Run Functions, Why Should /FOO Do That?"</h2>
<p>There are many reasons, but the biggest one is...</p>
<hr>
<p><strong>I feel pretty much 100% certain it is time that we switched to a world <em>where not all WORD!s holding ACTION!s will run them.</em></strong></p>
<hr>
<p>It's too cumbersome when writing generic code to worry that a value you got "from somewhere" and put into a SET-WORD! has to be handled with special operators:</p>
<pre><code> &gt;&gt; var: select obj 'item
 &gt;&gt; if integer? var [print "INT"]
 Muhaha the next thing at your callsite was [print "INT"]  ; eek, VAR was action

 &gt;&gt; var: first block
 &gt;&gt; if integer? var [print "INT"]
 HAH! Did you think blocks were safe?  Not at all: [print "INT"]  ; in blocks too!
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/man_facepalming.png?v=9" title=":man_facepalming:" class="emoji only-emoji" alt=":man_facepalming:"></p>
<p>Whether you think of it in terms of "security"--or simply bugs and chaos--this <em>persistent tax</em> on Redbol code authors has lacked a palatable solution.  Putting a GET-XXX! on every access is ugly, and easy to forget.  What we've ended up with is a mishmash...where people are constantly forced to choose between deciding if the brokenness is likely enough to cause a problem that it's worth it to make the code ugly.</p>
<p>(When code ages, it's like it develops some sort of pox--as leading colons are added on an ad-hoc basis, then no one really knows if they're safe to remove.)</p>
<p><strong>I propose that only specially marked assignments would <em>automatically</em> run a function through a word reference, requiring a ^META access to get the action value literally.</strong></p>
<pre><code>&gt;&gt; /foo: func [x] [print ["X is" x]]

&gt;&gt; foo 10
X is 10

&gt;&gt; ^foo
== #[action! {foo} [x]]
</code></pre>
<p><strong>If a function is assigned through a plain SET-WORD!, then that would be inert by default...but able to take advantage of this new leading-slash execution.</strong></p>
<pre><code>&gt;&gt; foo: func [x] [print ["X is" x]]

&gt;&gt; foo
== #[action! {foo} [x]]

&gt;&gt; /foo 10
X is 10
</code></pre>
<h2>Compliance Isn't Actually That Ugly!</h2>
<p>If you look at the definition of an object, then annotating the member functions isn't really so bad:</p>
<pre><code>obj: make object! [
    data: 1
    /accessor: does [return data + 1]
]
</code></pre>
<p>This also gives us some extra ammo: <strong>it can explain why we would use OBJ/ACCESSOR to invoke the function, and why OBJ.ACCESSOR can act as an error</strong>.</p>
<p>That can clean up examples like this:</p>
<pre><code> &gt;&gt; error: trap [...]
 &gt;&gt; if integer? error.arg1 [print "INT"]
 You forgot to worry about TUPLE! too! [print "INT"]  ; aaaargh...
</code></pre>
<p>All we have to do is say that TUPLE! accesses like that can't run methods.  It would have to be <strong><code>error/arg1</code></strong> to run it... which would also confirm that it was actually defined as a method.  (Otherwise you'd run it with <strong><code>/error.arg1</code></strong> if it was just a random non-method field that happened to be a function.)</p>
<p>This would be a systemic solution to historical annoyances.</p>
<h2>It Can Be A Nice Dialecting Pattern</h2>
<p><strong>It's useful in dialects where plain WORD! references are taken for another meaning.</strong>  For instance, UPARSE by default assumes a word means a combinator, so if you want to run a function that uses parse rules to gather its arguments you need something else:</p>
<pre><code>&gt;&gt; parse [1] [/negate integer!]
== -1

&gt;&gt; parse [1 2] [/add integer! integer!]
== 3
</code></pre>
<p>Initially I tried this with terminal slashes, as <strong><code>negate/</code></strong> and <strong><code>add/</code></strong>, but that doesn't look as good (and separates the functions from their arguments).</p>
<h2>What Do We Lose?</h2>
<p>Because I was trying to think of a meaningful evaluator behavior for leading-slash values, I didn't do much with them.  But eventually I decided to use them in New Apply:</p>
<p><a href="https://forum.rebol.info/t/apply-ii-the-revenge/1834" class="inline-onebox">APPLY II: The Revenge!</a></p>
<p>They're nice because they break up the space:</p>
<pre><code>&gt;&gt; apply :append [[a b c] [d e] /dup 2]
== [a b c [d e] [d e]]
</code></pre>
<p>But SET-WORD! is reasonable at this, and commas can make it more visually separate if needed:</p>
<pre><code>&gt;&gt; apply :append [[a b c] [d e] dup: 2]
== [a b c [d e] [d e]]

&gt;&gt; apply :append [[a b c] [d e], dup: 2]
== [a b c [d e] [d e]]
</code></pre>
<p>Of course whatever we put here is being overloaded.  If you want a SET-WORD! for assignment purposes, you'd have to put it in a group:</p>
<pre><code>&gt;&gt; apply :append [(abc: [a b c]) [d e], dup: 2]
== [a b c [d e] [d e]]

&gt;&gt; abc
== [a b c]
</code></pre>
<p>So we could think of this similarly.  If you wanted to use a refinement-style path here, you just do it in a group:</p>
<pre><code>&gt;&gt; apply :append [(/reverse [a b c]) [d e], /dup 2]
== [c b a [d e] [d e]]
</code></pre>
<p><strong>APPLY is a dialect, and there are always going to be some tradeoffs made.</strong>   There's only so many parts.</p>
<p><strong>It's probably best to leave APPLY as it is.</strong>  I don't think we're going to be in the midst of some epidemic where suddenly every function invocation is done through a leading slash and it's going to be  contentious.  There will also be ways of running a function through REEVAL or maybe a dedicated RUN function that won't use the slash...</p>
<p>So nothing needs to be lost, really.</p>
<h2>The Big Win is that the <em>Obvious</em> Code is the <em>Correct</em> Code</h2>
<p>I've done some tentative implementation on all this, and all together, it seems pretty solid</p>
<p>Really all you're doing is paying the cost of an extra (easy-to-type) character to say that a word is intended to execute a function without needing to explicitly be told to.</p>
<p>There will be ways to subvert it, as of course you could do this:</p>
<pre><code>&gt;&gt; /func: enfix lambda [left [set-word!] spec body] [
       do compose [/(as word! left): lib/func (spec) (body)]
   ]

&gt;&gt; cheat: func [] [print "Breakin the law, breakin the law..."]

&gt;&gt; cheat
Breakin the law, breakin the law...
</code></pre>
<p>But we wouldn't make you do it that laboriously, if you're making something where words need to be associated with functions that run automatically.  And Redbol would do it through some evaluator parameterization as opposed to a mechanism like that.</p>
<p>However, the general expectation would be that most people would embrace the slash, as a useful piece of information...that makes everything work more coherently.</p>
            <p><small>12 posts - 5 participants</small></p>
            <p><a href="https://forum.rebol.info/t/big-alien-proposal-refinements-run-functions/1905">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/big-alien-proposal-refinements-run-functions/1905</link>
          <pubDate>Fri, 29 Jul 2022 08:34:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1905</guid>
          <source url="https://forum.rebol.info/t/big-alien-proposal-refinements-run-functions/1905.rss">Big Alien Proposal :flying_saucer: &quot;/REFINEMENTS&quot; Run Functions</source>
        </item>
        <item>
          <title>Sample Custom Datatype Idea: Sound</title>
          <dc:creator><![CDATA[GiuseppeChillemi]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>As an example, lets build a simple custom structure:</p>
<pre><code>[[internal structures][data1][data2][data3][data4]]
</code></pre>
<p>I want that that <code>head</code> corresponds to <code>data1</code>, and <code>index?</code> returns1 when positioned there.</p>
<p>If you have an internal action called "reposition" and "get-position" belonging to that datatype, Ren-C should look at the block if it carries an additional management object. If it contains "reposition" and "get-position" it should use this custom functions to override the standard ones for the datatype. You code them so that they do not move before data1, and you have a special structure which acts transparently to the standard Ren-C working.</p>
<p>Now lets take:</p>
<pre><code>sound: [[header] size: 5000 modified-by: "HF" sound: #A45ACF...  [tail-data]]
</code></pre>
<p>It is your structure to store a sound.</p>
<p>you want that at set operation using ':' will be written <code>raster-image:</code> content, so that</p>
<pre><code>sound: load %mysong.wav
</code></pre>
<p>You add a custom management object with overwrites the set operation and also all the others regarding <code>pick/length?/poke...</code> and so on, so that your Ren-C script works with the usual syntax, which is internally manage by from you replacement actions, translating everything to the new coordinates and operation system</p>
<p>Obviously, you could have additional action to be available to the developers which do not replace the internal actions but they could be called with syntax like:</p>
<pre><code>do-custom data 'method [parameter parameter]
</code></pre>
<p>or having a special path like <code>sound/#/fourier-trasform</code></p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/sample-custom-datatype-idea-sound/1899">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/sample-custom-datatype-idea-sound/1899</link>
          <pubDate>Sun, 24 Jul 2022 10:23:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1899</guid>
          <source url="https://forum.rebol.info/t/sample-custom-datatype-idea-sound/1899.rss">Sample Custom Datatype Idea: Sound</source>
        </item>
        <item>
          <title>Could Each Datatype Have a &quot;Second&quot; (Hidden) &quot;Slot&quot;</title>
          <dc:creator><![CDATA[GiuseppeChillemi]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>From some time I am having the idea that each datatype could have a second value slot where you can set a context where I can store replacement handling methods for set/get and also other functions and any data you have, so you can patch the standard Rebol handlings and have also additional data/functions.</p>
            <p><small>7 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/could-each-datatype-have-a-second-hidden-slot/1908">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/could-each-datatype-have-a-second-hidden-slot/1908</link>
          <pubDate>Tue, 19 Jul 2022 21:36:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1908</guid>
          <source url="https://forum.rebol.info/t/could-each-datatype-have-a-second-hidden-slot/1908.rss">Could Each Datatype Have a &quot;Second&quot; (Hidden) &quot;Slot&quot;</source>
        </item>
        <item>
          <title>High-Level Parameterized Enums</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>So there's a neat feature in Haskell and Rust (and other languages) which is that you can make an enumerated type which takes parameters.  Here's Rust's version:</p>
<pre><code>enum Message {
    Quit,
    ChangeColor(i32, i32, i32),
    Move { x: i32, y: i32 },
    Write(String),
}
</code></pre>
<p>In C++ there's not built-in support for this.  You have to implement it as a "tagged union"...where you have a struct that has a plain enum integer in it, and then a union of all the possibilities of what could be in that spot.</p>
<p>So this made me wonder what we could do to support it.</p>
<h2>Fans of History May Recall I Made an Enumerated Type Once</h2>
<p>I wasn't much involved with the language until it was open-sourced.  But I did <a href="http://blog.hostilefork.com/enumerated-type-for-rebol2/">tinker with it in 2009</a></p>
<pre><code>&gt;&gt; fruit: make-enum-type [apple orange banana mango]

&gt;&gt; favorite_fruit: make-enum fruit 'apple

&gt;&gt; set-enum favorite_fruit 'shoe
** User Error: illegal enum value ( shoe ) when 
     possibilities are [ apple orange banana mango ]
</code></pre>
<p>Clearly we want better than that, which might look more like:</p>
<pre><code>fruit: new enum [apple [rotten: [logic!]] orange banana mango]

favorite-fruit: new fruit.apple false
</code></pre>
<p>It raises some questions about how SWITCH might be able to be hooked to have some augmented feature, where it enforces you covering all the cases for the ENUM.</p>
<p>I don't have any great ideas offhand...but I just was hearing a talk where this was brought up and it reminded me that maybe it would be a good example to try and think through, as a feature users could add after-the-fact.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/high-level-parameterized-enums/1894">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/high-level-parameterized-enums/1894</link>
          <pubDate>Tue, 19 Jul 2022 00:15:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1894</guid>
          <source url="https://forum.rebol.info/t/high-level-parameterized-enums/1894.rss">High-Level Parameterized Enums</source>
        </item>
        <item>
          <title>From (get-env &quot;FOO&quot;) to (environment.FOO) to (env.FOO) to $FOO</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>If you spend time in bash scripting or something like GitHub CI, you realize that environment variables are <em>really important</em>.</p>
<p>So it's a bit sad that Rebol has had the really ugly <strong>get-env</strong> and <strong>set-env</strong> functions as the interface to this.</p>
<p>I'd say it's pretty clear that we'd like for <strong>env.FOO</strong> to work.  I'm also leaning to thinking that at least in some dialected circumstances, <strong>$FOO</strong> should be interpreted as an environment variable as well...and we need these types:</p>
<ul>
<li><strong><code>$WORD</code></strong></li>
<li><strong><code>$TU.P.LE</code></strong></li>
<li><strong><code>$PA/TH</code></strong></li>
<li><strong><code>$[BL O CK]</code></strong></li>
<li><strong><code>$(GR O UP)</code></strong></li>
</ul>
<p><em>(I thought it might be interesting if the way the evaluator treated these types was to call whatever <strong><code>$</code></strong> was bound to, with the thing as an argument.  If that were viable, it could be applied to <strong><code>:</code></strong> and <strong><code>@</code></strong> as well.  But the thorn is that the value only has one binding for the word/path/tuple/etc....nowhere to put the binding for the operator in the cell.  New binding models could change that, so I'm keeping an open mind.)</em></p>
<h2>But How To Make An "ANY-CONTEXT!" That Calls Functions?</h2>
<p>Right now, the only way to get hooks into the system to run code when you use tuple access is by making a new datatype.  And that can only be done in the C code.</p>
<p>So if someone put a gun to my head and told me to make it work right now--<em>today</em>--the quickest path would be to make a new ANY-CONTEXT! type in C called an ENVIRONMENT!.  The flaky part is that environment variables come from an extension, and so it would be an "extension type" (like a GOB! or VECTOR!), and those are second-class citizens (they don't work in TYPESET! for instance, they're all considered the same CUSTOM! datatype for those purposes).</p>
<p>I resist the temptation to do this, because while it would be nice to write <strong>environment.FOO</strong> instead of <strong>get-env "FOO"</strong>, most of the uses are in the rebmake code...which needs to work in the bootstrap executable.  So no point in making an existing mess with extension types messier.</p>
<h2>Any Usermode Ideas?</h2>
<p>I think what we should be looking for is a way that someone without a C compiler could make something that looks like an object, but the behavior for handling the TUPLE! access comes from functions.</p>
<p>Right now you can't "dot an action"... actions only take PATH!s for refinements.  So we could say that if we get a dot, it looks to see if the function has a /DOT refinement, and if it does then it will call it accordingly with information from the context of the get or set:</p>
<pre><code>environment: func [variable [word! set-word!] value [&lt;end&gt; any-value!] /dot] [
    assert [dot]  ; let's say you always use with dot for now
    if set-word? variable [
       echo [You asked to set @variable to @value]
    ] else [
       echo [You asked to get @variable]
]

&gt;&gt; environment.FOO
You asked to get FOO

&gt;&gt; environment.FOO: 10
You asked to set FOO to 10
</code></pre>
<p>It's better than nothing.  But what I don't like about it is that I have the idea that tuple access on functions will be able to get and set properties stored on that function... e.g. that functions will be able to act as objects.  This would be where stuff like help informaiton is stored.  <em>(This was historically called the "meta object" but we have much more compelling uses for the word "meta" now.)</em></p>
<h2>So Probably Better to be a User-Defined Datatype</h2>
<p>Unfortunately these don't exist yet.  But I guess now we have a good example of ENVIRONMENT! as something that needs supporting.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/from-get-env-foo-to-environment-foo-to-env-foo-to-foo/1857">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/from-get-env-foo-to-environment-foo-to-env-foo-to-foo/1857</link>
          <pubDate>Mon, 04 Jul 2022 14:14:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1857</guid>
          <source url="https://forum.rebol.info/t/from-get-env-foo-to-environment-foo-to-env-foo-to-foo/1857.rss">From (get-env &quot;FOO&quot;) to (environment.FOO) to (env.FOO) to $FOO</source>
        </item>
        <item>
          <title>Hex-Valued Integer Literals: Likely Not In Ren-C</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>On an old Trello there was a card about standardizing the differences between R3-Alpha and Red...and a checklist with only one item:</p>
<blockquote>
<p>Hex-valued literal notation (Rebol has none, Red used to use FFh, FFFFh, FFFFFFFFh), now using 0#FF</p>
</blockquote>
<p>The motivation was for purposes of Red/System, mostly.</p>
<p>In Ren-C this doesn't seem like a priority.  It has ISSUE! (TOKEN!) as a read-only data type that fits in a cell.  Hence a systems-oriented dialect already has an efficient way to represent these values.</p>
<p>For instance: it's not a big deal if your assembler says <strong>[mov ax, <span class="hashtag">#FE</span>]</strong> in its source... if it's generating machine code.</p>
<p>Of course, an ISSUE! in it isn't the same from a metaprogramming sense as a slot with an INTEGER! in it.  So you don't get the automatic advantage of <em>every</em> dialect that has INTEGER! support for a given slot working with a hex notation.  But isn't that what COMPOSE is for...?</p>
<pre><code>my-dialect [something-or-another 255]

my-dialect compose [whatever (debin [BE +] #FF)]
</code></pre>
<p><strong>Having more than one representation for the same type is generally bad, anyway.</strong>  Let's look at what Red does here:</p>
<pre><code>red&gt;&gt; FFh
== 255

red&gt;&gt; F0h + 0Fh
== 255
</code></pre>
<p>If it was so important that it had to be encoded in source, why is it thrown away immediately?</p>
<p>It's something about Red worth knowing exists, but off the radar for implementing, methinks.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/hex-valued-integer-literals-likely-not-in-ren-c/1815">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/hex-valued-integer-literals-likely-not-in-ren-c/1815</link>
          <pubDate>Sat, 14 May 2022 04:35:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1815</guid>
          <source url="https://forum.rebol.info/t/hex-valued-integer-literals-likely-not-in-ren-c/1815.rss">Hex-Valued Integer Literals: Likely Not In Ren-C</source>
        </item>
        <item>
          <title>DATE! + TIME! + DATETIME! (or TIMESTAMP! ?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>As we are familiar, DATE! can have a TIME! component:</p>
<pre><code>&gt;&gt; d: now
== 21-Nov-2021/18:56:45-5:00 

&gt;&gt; type of d
== #[datatype! date!]

&gt;&gt; t: d.time
== 18:56:45

&gt;&gt; type of t
== #[datatype! time!]
</code></pre>
<p>Although TIME! can exist as a separate cell and value type, <em>a DATE! doesn't store a time cell inside of it</em>.  It packs the date and time information into a single cell.</p>
<p>Hence when you say <strong>d.time</strong> above, a <em>new</em> TIME! value has to be synthesized.  There's not a whole cell worth of time to hand a pointer back to...its woven into the bits of the DATE!.</p>
<p><strong>That might not sound like much of an issue, but it creates the problem I refer to as <em>"sub-cell addressing"</em>.</strong></p>
<p><em>If you've missed everything I've griped about with this so far</em>, it means that when you want to see a behavior like the following:</p>
<pre><code>&gt;&gt; d.time.hour: 12
== 12

&gt;&gt; date
== 21-Nov-2021/12:56:45-5:00  ; we want hour updated
</code></pre>
<p>We run into the problem that if <strong>d.time</strong> <em>synthesizes</em> a value, then a naive picking process of <strong>(d.time).hour: 12</strong> would only be able to manipulate the bits in the synthesized time.  That wouldn't change <strong>d</strong>.  <em>What the user actually wanted was to update the bits of a time that was folded into the implementation of the date.</em></p>
<h2>Rebol Lacks The Vocabulary To Do This In An Obvious Way</h2>
<p>The smallest units that Rebol speaks in terms of are the <strong><code>cell</code></strong> and the <strong><code>node</code></strong>.</p>
<p><em>(If you need a refresher on these, my <a href="https://www.youtube.com/watch?v=6nsKTpArTCE">conference video tech talk</a> explains them.)</em></p>
<p><strong>It would appear we could be able to simplify matters if we changed the combination of DATE! and TIME! to point to a 2-cell node.</strong></p>
<pre><code>DATETIME! cell
[  ]                DATE!           TIME!
  --&gt; points to [ 21-Nov-2021 | 18:56:45-5:00 ]  (2 cells)
</code></pre>
<p><em>(Whether the "zone" is part of a time or lives in the datetime would depend on whether you wanted to write <code>d.zone: -5:00</code> or <code>d.time.zone: -5:00</code>, I don't know if it ever makes sense to speak of a time with a zone independent of a datetime or not.)</em></p>
<p>Breaking things up this way, we can say that <strong>d.time</strong> implicates a cell.  And we can have some operation that acts on a cell (let's say POKE) like:</p>
<pre><code> &gt;&gt; poke 18:56:45 'hour 12
 == 12:56:45
</code></pre>
<h2>Hang On: DATE!, TIME! (and DATETIME!) are IMMEDIATE!</h2>
<p>We still have a bit of a problem here with our smallest units of representation.  Presumably we don't want this:</p>
<pre><code> &gt;&gt; d1: 21-Nov-2021/18:56:45-5:00 

 &gt;&gt; d2: d1

 &gt;&gt; d1.time.hour: 12
 == 12

 &gt;&gt; d1
 == 21-Nov-2021/12:56:45-5:00

 &gt;&gt; d2
 == 21-Nov-2021/12:56:45-5:00  ; don't want d2 to change (right?)
</code></pre>
<p>But we also don't want to be needlessly copying the 2-cell node each time a date is assigned.  So it would be a <em>copy-on-write</em> mechanic.</p>
<p>If we're working with a cell-based granularity, then we wind up in a somewhat similar situation to what we had before...where the tuple processing has to propagate backwards.  e.g. when you have the POKE that changes the cell bits for the TIME! to make a new TIME! cell, there has to be some memory going back to the DATETIME! in order to tell it to make a new node and write the cell into the copy.</p>
<p>Does framing this in terms of cells offer any benefit over letting the DATETIME! be a higher-level entity that does a more specific folding of the TIME! cell into its bits?  This is a question I've been trying to answer, and haven't had an easy time of answering.</p>
<p><strong>One thing it would do to use a cell-based protocol is that it could generalize properties that had flags on cells, such as being PROTECT'ed.</strong>  Without the picking protocol requiring each step to go through a cell, the system cannot fiddle these bits in a known way.  So just as the DATE! folds the TIME! into it in some arbitrary way, the protect bit would have to go through this through a complex protocol also.</p>
<p>What I do know is that my current generalized solution is rather complex and slow--and doesn't answer how to do things like PROTECT.  We're seeing a slowdown from many different angles and I am trying to figure out what the best tradeoff is in terms of simplicity and generality.  It's not easy.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/date-time-datetime-or-timestamp/1765">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/date-time-datetime-or-timestamp/1765</link>
          <pubDate>Thu, 02 Dec 2021 16:57:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1765</guid>
          <source url="https://forum.rebol.info/t/date-time-datetime-or-timestamp/1765.rss">DATE! + TIME! + DATETIME! (or TIMESTAMP! ?)</source>
        </item>
        <item>
          <title>Tuple Troubles: Version 0.3.01 vs 0.3.1</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>For better or worse, versioning in Rebol has used TUPLE!.  e.g. 0.3.1 is 32-bit Windows, and 0.3.40 is 64-bit Windows</p>
<p>If you go back and look at the old R3-Alpha file <strong><a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/tools/systems.r#L21">%systems.r</a></strong> you can see that it's pretty typical for Carl to have written the versions out with leading zeros...<em>but only in the third slot</em>.  So <code>0.3.01</code> but not <code>00.03.01</code></p>
<p>But ultimately the tuple discards this information.  And this has been the way it always worked:</p>
<pre><code>rebol2&gt;&gt; 0.3.01
== 0.3.1

red&gt;&gt; 0.3.01
== 0.3.1

ren-c&gt;&gt; 0.3.01
== 0.3.1
</code></pre>
<p>This leads to problems when you are working with string representations outside of Rebol (say in bash shell, something like "0.3.01") and you pass it into Rebol to process as a tuple.  If bash went and created a directory based on the string...you won't match if you FORM that tuple later.</p>
<p>You could insist on passing around the tuple as a string, but that undermines the value of having the version be in a tuple in the first place.</p>
<p>I'd say that the simplest solution is just to stop writing tuples with the leading zeros...instead keeping them in their canon form.  0.3.1 for 32-bit Windows, and 0.3.40 for 64-bit Windows.  Then make the directories reflect this, e.g.:</p>
<pre><code>https://dd498l1ilnrxu.cloudfront.net/travis-builds/0.3.1/r3-573037b-debug.exe
</code></pre>
<p>and not:</p>
<pre><code>https://dd498l1ilnrxu.cloudfront.net/travis-builds/0.3.01/r3-573037b-debug.exe
</code></pre>
<p>That leading zero comes with a whole lot of headaches, so I say hunt them down and get rid of them.  Because non-Rebol systems are going to only operate on them as strings and they'll leak.</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/tuple-troubles-version-0-3-01-vs-0-3-1/1755">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/tuple-troubles-version-0-3-01-vs-0-3-1/1755</link>
          <pubDate>Wed, 24 Nov 2021 13:28:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1755</guid>
          <source url="https://forum.rebol.info/t/tuple-troubles-version-0-3-01-vs-0-3-1/1755.rss">Tuple Troubles: Version 0.3.01 vs 0.3.1</source>
        </item>
        <item>
          <title>&quot;Raw&quot; Strings</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>I'm now 99% sure that { } best serves its purpose as a string form.</p>
<p>But there were several talking points that came out of that discussion.  One was a desire for "raw" strings.</p>
<p>This is the idea that outside of the termination sequence, there's <em>no</em> escaping.  This means you can put pretty much anything in the string.  Backslashes, carets...it's all fair game.</p>
<h2>Two Very Different String Forms: When Are They Raw?</h2>
<p>To <em>me</em>, it made the most sense that the raw form be the braced form...because it is so frequently applied to sections of arbitrary documentation text (such as the Description: in module headers).</p>
<pre><code>Description: {
    If you call this from C, then write:

        if (a ^ b != 0) {  // bitwise XOR
            printf("This is an example\n");
        }

     So there you see carets and backslashes working.
}
</code></pre>
<p>With binding support for string interpolation, we can imagine this getting even more useful for representing snippets of other languages with escaped portions inside of them.</p>
<p>However, <a class="mention" href="https://forum.rebol.info/u/giuliolunati">@giuliolunati</a> favored the idea of making quoted strings <em>mostly-raw</em>, because there was an easy-seeming way to escape quotes using only the quote character.</p>
<pre><code>&gt;&gt; "This would be ""quotes"" inside a string"
== {This would be "quotes" inside a string}
</code></pre>
<p>How braces are escaped historically ( e.g. <code>^}</code> ) is messier.  That drags caret into it, so now you're worrying about needing to escape carets and braces.  A more uniform approach appealed to Giulio, so he favored the quotes form...and would prefer it to be able to represent characters "as-is" by default, with this exception for embedded quotes.</p>
<p>But from my point of view, I was seeking to avoid is any need to do search/replace on the embedded information.  So <em>mostly-raw</em> wasn't good enough; e.g. I'd like to copy and paste the C code out of the example above, not have its quotes doubled:</p>
<pre><code>Description: "
    if (a ^ b != 0) {  // bitwise XOR
        printf(""This is an example\n"");   &lt;-- doubled quotes not good
    }
"
</code></pre>
<p>We also discussed that I'm averse to having ordinary quotes as multi-line strings... though maybe we should allow them.  :-/  But even if we did, it feels unintentionally incomplete to see something like:</p>
<pre><code>Description: "
</code></pre>
<p>So for these reasons I wanted to focus the raw string effort on braced strings.  Yet there are a lot of things that it gets hard to represent in a raw string form when you try to use unmatched braces in the content.</p>
<p>After thinking about it a bit, we came up with the option of being able to set the delimiter according to a number of braces and a vertical bar.</p>
<pre><code>{...}  ; expects any { } inside to be matched pairs 
{|...|}  ; allows internal unpaired and mismatched { }, {| |} matched pairs
{{|...|}}  ; allows internal unpaired and mismatched {| |}, {{| |}} matched
</code></pre>
<p>etc. etc.</p>
<p>This can handle some pretty sticky strings like <strong><code>{|ab"c"} {"d"ef|}</code></strong> if need be, where the data extracted is:</p>
<pre><code>ab"c"} {"d"ef
</code></pre>
<p>The approach would allow any number of {{ }}, which sounds like it could get ugly.  But it's kind of like generic quoting, where I don't anticipate people using ridiculously high levels like {{{{|...|}}}}.  But having it be a general method has value--especially in generated code scenarios.</p>
<p>Strings starting or ending with vertical bar forms like <strong>{|}</strong> get sacrificed, so you'll have to use "|" instead.  But you would use "}" so this just moves | into the same category as } and {.</p>
<p>I also suggested an additional rule...that you don't terminate braced strings except as:</p>
<ul>
<li>{...} -space-</li>
<li>{...} -newline-</li>
<li>{...}]</li>
<li>{...})</li>
</ul>
<p>If we limit it to these possibilities, you can write things like:</p>
<pre><code> code: {char c = '}';}
</code></pre>
<p>It seems that a lot of unpaired brace cases are single character literals like this, which don't fall under the rule.  You might want to put the bars in for good measure anyway:</p>
<pre><code> code: {|char c = '}';|}
</code></pre>
<p>In any case, the other thing we were leaning toward here was that when quoted strings are escaped, they do so compatibility with the classical C backslashes, based on the idea that caret escaping hadn't done the language any particular favors.</p>
<p>Just wanted to write this up while I still was thinking about it... <img src="https://forum.rebol.info/images/emoji/twitter/zzz.png?v=9" title=":zzz:" class="emoji" alt=":zzz:"></p>
            <p><small>16 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/raw-strings/1750">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/raw-strings/1750</link>
          <pubDate>Sat, 23 Oct 2021 13:33:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1750</guid>
          <source url="https://forum.rebol.info/t/raw-strings/1750.rss">&quot;Raw&quot; Strings</source>
        </item>
        <item>
          <title>Alternate String Forms if {...} Becomes An Array Type</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <blockquote>
<p>I've brought up in earnest something I call <strong><a href="https://forum.rebol.info/t/rethinking-braces-as-an-array-type/1727">"The FENCE! Proposal"</a></strong>.  It involves retaking <strong>{...}</strong> for an <em>object-like-purpose</em>.</p>
<p>The twist is that it's really another ANY-ARRAY! type, peer to [...] and (...) - but with the default evaluator behavior of MAKE OBJECT!.  Then as with [...] and (...), dialects would be free to override {...} in their own way.</p>
<p>A sad consequence of this would be the loss of the alternative string form {...}.  Discussions of what to use instead were lengthier than the discussion of the proposal itself, so I've moved them onto their own thread here...starting with my initial musing...</p>
</blockquote>
<h2>What Other Asymmetric String Technique Might Be Used?</h2>
<p>Some languages have weird techniques, like even letting you make up your own delimiters by whatever you use in front of the quote:</p>
<pre><code>str: ?"This says "quote followed by question mark" terminates"?
str: |"This says "quote followed by bar" terminates"|
str: xyz"This says "quote followed by zyx" terminates"zyx 
</code></pre>
<p>(Not making that up.)</p>
<p>The risk of using a symbol like | is that even if it looks good in isolation, you might not like it in a parse rule, like <strong>rule1 | |"some string"| | rule2</strong>.  A less-used character might be better:</p>
<pre><code>parse data [rule1 | ~"some string"~ | rule2]
</code></pre>
<p>Or perhaps those who really feel the need for another asymmetric string delimiter should assign a couple keys in their editor to unicode:</p>
<pre><code>str: Maybe People who really care could use "Chevrons"?
</code></pre>
<p>Who knows.  <strong><a href="https://en.wikipedia.org/wiki/Here_document">One place to look is the topic of "HEREDOC"</a></strong></p>
<p>Another place to look is the <strong><a href="https://stackoverflow.com/questions/13535172/list-of-all-unicodes-open-close-brackets">List of open/close paired braces/brackets/quotes in Unicode</a></strong></p>
            <p><small>22 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/alternate-string-forms-if-becomes-an-array-type/1743">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/alternate-string-forms-if-becomes-an-array-type/1743</link>
          <pubDate>Mon, 18 Oct 2021 01:06:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1743</guid>
          <source url="https://forum.rebol.info/t/alternate-string-forms-if-becomes-an-array-type/1743.rss">Alternate String Forms if {...} Becomes An Array Type</source>
        </item>
        <item>
          <title>If {Braced Were Arrays} What Should That Be Called</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>It's early yet in the discussion of <a href="https://forum.rebol.info/t/rethinking-braces-as-an-array-type/1727">whether to make braces a new array type</a>.  But people seem receptive and feel like maybe Rebol has put itself in a bad position by using that particularly valuable piece of keyboard real-estate for something "superficial" like making strings a little cleaner, sometimes.  :-/</p>
<p><em>(Note: Ultimately braces were decided to keep as strings, though having another array type is still a possibility...and maybe it will need a name.)</em></p>
<p>For lack of another name I had called it BRACED!.</p>
<p>But I don't like that much more than I would want to call <em>blocks</em> BRACKETED! (or BRACK! <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=9" title=":roll_eyes:" class="emoji" alt=":roll_eyes:">)... nor call <em>groups</em> PARENTHESIZED! (or PAREN! <img src="https://forum.rebol.info/images/emoji/twitter/face_vomiting.png?v=9" title=":face_vomiting:" class="emoji" alt=":face_vomiting:"> )</p>
<p>Here is my suggestion for the 3 array types:</p>
<h1>
<code>[block]</code> <code></code>  <code>(group)</code> <code></code> <code>{fence}</code>
</h1>
<hr>
<p>I like that FENCE is five letters...matching GROUP and BLOCK.  I like that it starts with a distinct character.</p>
<p><strong>I actually think having it be divorced from anything obvious about creating objects can be seen as an asset instead of a liability.</strong>  Because that's only what it's for <em>sometimes</em>.</p>
<ul>
<li>
<p><em>"In the PARSE dialect, blocks are used to represent subrules.  Groups switch over to running ordinary code as with DO.  While fences are used to... (insert your active imagination here)"</em></p>
</li>
<li>
<p><em>"If there's an integer inside of a pair of fences, such as <code>{{10}}</code>, then that represents a citation.  Citations can appear at either the beginning or end of a reference block."</em></p>
</li>
</ul>
<p>It's one of those things that might seem a little weird at first, but as you become accustomed to saying it then it becomes normal...and you're grateful to have such a convenient word at hand.</p>
<h2>Other Uses of "Fence" in Programming</h2>
<p>Dictionary definition of fence: <em>a barrier, railing, or other upright structure, typically of wood or wire, enclosing an area of ground to mark a boundary, control access, or prevent escape.</em></p>
<p>The term <em>fence</em> has only two meanings in programming that jump immediately to mind...the one most people would know are these three-backticks used to format code in MarkDown:</p>
<pre><code>When you are writing things in **MarkDown**
The following is a "code fence"
```
int main(int argc, char *argv) {
    printf("I'm not a huge fan of the ```, myself.\n");
    return EXIT_SUCCESS;
}
```
*(I myself prefer to indent by 4 spaces, instead.)*
</code></pre>
<p>Less well-known to the scripting world would be "fencing instructions" which are low-level processor stuff used to mitigate things like Spectre.</p>
<h2>Other Options?</h2>
<p><strong>{ CURLY! }</strong> is too goofy, immediate veto from me.</p>
<p>I've explained why I don't like <strong>{ BRACE! }</strong> or <strong>{ BRACED! }</strong>.  Plus brace has the problem of being singular like PAREN!, while BRACED! seems to talk about the <em>contents</em> vs. the actual structure of the container itself...which I guess might have to be "bracing" or "braces" or something.  FENCE! lets you mentally model it as actually referring to "the container in and of itself".</p>
<p>For terms that relate to "contained things" there might be the likes of <strong>{ CLAUSE! }</strong>...but that feels a bit more prescriptive to what it's for.  And object-making doesn't line up with that.  FENCE! is more abstract to me, somehow.</p>
<p>One could argue that <strong>{ CLUSTER }</strong> might sound more like an array that produced an object.  ("Hey, cluster these keys together, into a blob.")  You might similarly argue for <strong>{ AGGREGATE! }</strong> as being "more meaningful".</p>
<p>But I'm drawn to the viscerality of FENCE!.  It feels learnable within this vocabulary.  Especially when you see it lined up with GROUP! and BLOCK!.  I'm kind of attached to it now.  <img src="https://forum.rebol.info/images/emoji/twitter/two_hearts.png?v=9" title=":two_hearts:" class="emoji" alt=":two_hearts:"></p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/if-braced-were-arrays-what-should-that-be-called/1728">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/if-braced-were-arrays-what-should-that-be-called/1728</link>
          <pubDate>Thu, 30 Sep 2021 11:36:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1728</guid>
          <source url="https://forum.rebol.info/t/if-braced-were-arrays-what-should-that-be-called/1728.rss">If {Braced Were Arrays} What Should That Be Called</source>
        </item>
        <item>
          <title>{ Rethinking Braces }... as an array type?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>I've historically been pretty attached to braces for strings.  They sure can be nice.</p>
<p><em>But</em> I am increasingly thinking braces might be better applied as a new array type, we might call FENCE!:</p>
<pre><code>&gt;&gt; fence: first [{This [would] be @legal}]
== {This [would] be @legal}

&gt;&gt; length of fence
== 4

&gt;&gt; second fence
== [would]
</code></pre>
<p>So it would act like a BLOCK! or a GROUP! when it was inert.  But the real benefit would be the idea that if this braced form got evaluated, it would effectively do a MAKE MAP! or MAKE OBJECT! (or "something along those lines")</p>
<pre><code>&gt;&gt; obj: {x: 10 y: 20, z: 30}
== make object! [  ; whatever this representation is, it's not {x: 10...}
    x: 10
    y: 20
    z: 30
]
</code></pre>
<p>This kills two birds with one stone: <strong>A neat new dialecting part that would also give a better source notation for objects!</strong></p>
<p>Having its evaluator behavior be "make an object/map" pushes this from "frivolous third form of block" to being clearly useful on day 1.  But I think the block form would soon turn out to not be frivolous.</p>
<h2>Carl Himself Wants To Move Away From Braced Strings</h2>
<p>In Carl's "ASON" pitch, he <a href="https://altscript.com/?page_id=16">moves away from Rebol's choice to make braces an asymmetric string delimiter</a>:</p>
<blockquote>
<ul>
<li>
<p><em>"<strong>Braces {} are used to denote objects</strong>. They are lexical and may be used directly without evaluation (the <code>make</code> constructor is not necessary)."</em></p>
</li>
<li>
<p><em>"<strong>Braces {} are not used for multi-line strings</strong>. A single+double quote format is used for multi-line strings."</em></p>
</li>
</ul>
</blockquote>
<p>I must admit braced strings can make a lot of situations in the text programming world look better than they typically would.</p>
<p>But it comes at a cost for taking the asymmetric delimiter, and is a real weakness against JavaScript and JSON.  When rethought as this fun new dialecting part, it actually offers a new edge and plays to Rebol's strengths.</p>
<p>What might the new <strong>{...}</strong> type do in PARSE?  As a branch type?  In your own dialects?</p>
<h2>My {...} Proposal Is Arrays, Not Object Literals</h2>
<p>It might seem like having a source representation of objects that maps directly to the loaded/ in-memory representation would be better.  But in practice, you can't really get the loaded form to ever look completely like the source...there's so many issues with nested cyclical structures or things that just don't mold out.</p>
<p>It doesn't work in JavaScript either.  Note that you're not supposed to be loading JSON directly in any case into JavaScript...you're always supposed to go through parsers and serializers.  So that should be weighed here when looking at the suggestion of a structural type that happens to evaluate to give you an in-memory representation.</p>
<h2>Map Representation Via <code>:</code> ?</h2>
<p>There was another remark in the Altscript on the role of colon:</p>
<blockquote>
<p>For JSON compatiblity:</p>
<ul>
<li>Keys (word definitions) can be written with quotes (<code>"field":</code>)</li>
<li>A lone colon (<code>:</code>) will automatically associate to the word/string immediately before it.</li>
<li>Commas as element separators are allowed as long as they are not directly followed by a non-digit character (to avoid confusion with comma-based decimal values.)</li>
</ul>
</blockquote>
<p>The note about the colon seems like it might be good for maps.</p>
<pre><code>mapping: {
    1 : "One"
    "Two" : 2
}
</code></pre>
<p>This could help avoid the need for SET-INTEGER! or similar.</p>
            <p><small>11 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rethinking-braces-as-an-array-type/1727">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rethinking-braces-as-an-array-type/1727</link>
          <pubDate>Wed, 29 Sep 2021 00:30:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1727</guid>
          <source url="https://forum.rebol.info/t/rethinking-braces-as-an-array-type/1727.rss">{ Rethinking Braces }... as an array type?</source>
        </item>
        <item>
          <title>Should Different-Typed Comparisons Be Less Friendly?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>I've historically been on the side of saying that I don't think it's good for types of different categories to compare equally, e.g. <strong><code>&lt;foo&gt; = "foo"</code></strong> being true can cause some headaches.</p>
<p>But these headaches can work the other way as well.  I just had a bug where I was passing something as a string, but the caller was comparing it as a WORD!.</p>
<pre><code> if info.name = 'startup* [
     ...  ; it was a string, so actually "startup*"
 ]
</code></pre>
<p>This makes me wonder if different-typed comparisons need some distinction in the comparison, to help say that you know the type you're comparing against is completely different.</p>
<pre><code>if info.name =T 'startup* [
   ;
   ; ugly example... but imagine =T is a way of saying "I know the type
   ; should be the type on the right (e.g. WORD!), so tell me if it is
   ; not...
]

&gt;&gt; 'foo =T 'bar
== #[false]

&gt;&gt; "foo" =T 'bar
** Error: =T expected a WORD! on the left but got a TEXT!
</code></pre>
<p>It's always the latest such bug to bite you in languages of this nature that make you wish for stricter typing policies.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-different-typed-comparisons-be-less-friendly/1726">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-different-typed-comparisons-be-less-friendly/1726</link>
          <pubDate>Thu, 23 Sep 2021 11:17:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1726</guid>
          <source url="https://forum.rebol.info/t/should-different-typed-comparisons-be-less-friendly/1726.rss">Should Different-Typed Comparisons Be Less Friendly?</source>
        </item>
        <item>
          <title>Dissecting R3-Alpha&#39;s EVENT!: What Should We Think?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <h2>Quick Retrospective Look At EVENT!</h2>
<p>Not everyone had to deal with EVENT!.  But it's relatively easy to understand as a tiny and very-limited OBJECT!.  Here's what one being created looked like in R3-Alpha's %prot-http.r</p>
<pre><code>make event! [type: 'read port: http-port]
</code></pre>
<p>It looks a bit like a MAKE OBJECT!, with SET-WORD!s and expressions.  But what actually happened under the hood?</p>
<p>Datatypes in R3-Alpha had "MT" functions (e.g. MAKE TYPE).  So if you <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/t-event.c#L322">wanted to MT_Event()</a> it would take in a BLOCK! and then immediately call a function called <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/t-event.c#L168">Set_Event_Vars()</a>.</p>
<p>The code is pretty short:</p>
<pre><code>REBVAL *var;
REBVAL *val;

while (NOT_END(blk)) {
    var = blk++;
    val = blk++;
    if (IS_END(val))
        val = NONE_VALUE;
    else
        val = Get_Simple_Value(val);
    if (!Set_Event_Var(evt, var, val))
        Trap2(RE_BAD_FIELD_SET, var, Of_Type(val));
}
</code></pre>
<p>It walks through the block, gathering two items at a time.  (If it only sees one item without a second, it uses a global NONE! value as the second.)</p>
<p><strong>Immediately you notice that this is going to be a much more "scant" form of evaluation than in MAKE OBJECT!</strong>.  If you weren't tipped off by the calling of a function named "Get_Simple_Value()" then you could notice that if you are only processing two values at a time, that's going to rule out things like</p>
<pre><code>make event! [type: second [read write]]
</code></pre>
<p>...because it would only see <strong><code>type: second</code></strong> in the first pair, and then <strong><code>[read write] #[none]</code></strong> in the second.</p>
<p>It's worse than it sounds.  Let's jump directly to <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/c-do.c#L1858">Get_Simple_Value()</a> to look at its implementation:</p>
<pre><code>if (IS_WORD(val) || IS_GET_WORD(val))
    val = Get_Var(val);
else if (IS_PATH(val) || IS_GET_PATH(val)) { //val = Get_Path_Var(val);
    REBVAL *v = val;
    DS_PUSH_NONE;
    Do_Path(&amp;v, 0);
    val = DS_TOP;
}
return val;
</code></pre>
<p>It basically does a "GET" of a WORD! or PATH!.  But there's no evaluation.  So if you say:</p>
<pre><code>get-type-word: does [either reading ['read] ['write]]

make event! [type: get-type-word port: http-port]
</code></pre>
<p>It won't <em>call</em> the GET-TYPE-WORD function.  It will <strong>GET</strong> the GET-TYPE-WORD function, and try to set the TYPE: to that.</p>
<p>Other values act similarly perplexingly...whether it's a GROUP!, or whether it's a LIT-WORD! that doesn't get evaluated.  So the <strong>Set_Event_Var()</strong> function <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/t-event.c#L83">has to accept LIT-WORD!s as well as WORD!s</a>, making things just a little bit more confusing.</p>
<h2>Why Is MAKE EVENT! So Much "Lousier" Than MAKE OBJECT! ?</h2>
<p>What MAKE OBJECT! does is it gathers all the SET-WORD!s in a block up and creates an object with those keys.  Then it binds the block you gave it to that object, and runs the code.  Since the set-words are all bound to the object, it just naturally works that the evaluation of ordinary expressions will sink the evaluative results into those words.</p>
<p>But the idea behind EVENT! was that it would be a very compressed data structure, so small it fit into one value cell.  This means that when it stores that <strong>TYPE:</strong> it isn't storing a pointer to an arbitrary word symbol...it's storing a small number from a finite list.</p>
<p>So TYPE can't be "bound" in a conventional sense.  There's no cell in a context to bind the word to.  There's just a packed bit pattern in an EVENT! structure.</p>
<p>You were able to say things like <strong>(<code>event/type: 'read</code>)</strong> because the way path dispatch worked, only the first element of the path was "bound".  It would lookup the event and then send it a message "change the type"...which it would do in its specialized bit packing way.  But you wouldn't be able to say <strong>do (bind [type: 'read] event)</strong> and have that work.</p>
<h2>In My Opinion Get_Simple_Value() Should Not Exist</h2>
<p>In truth, R3-Alpha did not have to be so stingy with the evaluator.  It had the ability to DO_NEXT() in a block, and where it used Get_Simple_Value() it could have done an evaluation.  It was there in the pursuit of performance.</p>
<p>But this kind of opens up a bigger field of questioning for the language, just in terms of "What is setting?" and "What is getting?"  You might argue that Get_Simple_Value() was some weird anomaly, but here was the behavior of GET itself in R3-Alpha:</p>
<pre><code>r3-alpha&gt;&gt; get (1 + 2)
== 3

r3-alpha&gt;&gt; get quote (1 + 2)
== (1 + 2)
</code></pre>
<p>I tried to phrase some questions like "Are GET and SET supersets of PICK and POKE, or do they provide different functionality" and there really isn't an articulation of this.</p>
<p><strong>It's like Rebol made a relatively concrete definition of what a SET-WORD! and a GET-WORD! are, but any understanding of a connection of these things to some functions named SET and GET are kind of unknown.</strong></p>
<p>It's hard whenever looking at the fun parts of playing with Rebol design to come back and face the fact that it's really kind of sitting on a kind of zero-semantics language model.  I feel like I'm making some progress on it, but drawing clean lines that people can build on reliably often feels out of reach for this particular medium.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/dissecting-r3-alphas-event-what-should-we-think/1724">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dissecting-r3-alphas-event-what-should-we-think/1724</link>
          <pubDate>Wed, 22 Sep 2021 20:40:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1724</guid>
          <source url="https://forum.rebol.info/t/dissecting-r3-alphas-event-what-should-we-think/1724.rss">Dissecting R3-Alpha&#39;s EVENT!: What Should We Think?</source>
        </item>
  </channel>
</rss>

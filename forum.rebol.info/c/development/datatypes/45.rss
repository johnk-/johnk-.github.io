<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Datatypes - AltRebol</title>
    <link>https://forum.rebol.info/c/development/datatypes/45</link>
    <description>Topics in the &#39;Datatypes&#39; category The datatypes category is for the discussion of the specific properties of datatypes themselves.  Sample topics might include:</description>
    
      <lastBuildDate>Fri, 08 Nov 2024 18:12:09 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/datatypes/45.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>TAG!s Angle Brackets: *They Aren&#39;t There!*</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Implementation-wise, the delimiters of tag have been quite the thorn.</p>
<p>Are they there or not?</p>
<p>In Rebol2, Red, R3-Alpha...</p>
<pre><code>&gt;&gt; find &lt;abcd&gt; "c"
== &lt;cd&gt;

&gt;&gt; find &lt;abcd&gt; "&gt;"
== none
</code></pre>
<p>Not there!</p>
<p>Or are they?  Reverse the arguments, and in Rebol2 and Red, they seem to magically appear:</p>
<pre><code>&gt;&gt; find "ab&lt;c&gt;d" &lt;c&gt;
== "&lt;c&gt;d"
</code></pre>
<p>But... this was not the case in R3-Alpha...</p>
<pre><code>r3-alpha&gt;&gt; find "abcd" &lt;c&gt;
== "cd"

r3-alpha&gt;&gt; find "ab&lt;c&gt;d" &lt;c&gt;
== "c&gt;d"
</code></pre>
<p>I know things have gone back and forth with people believing deeply in their little hearts that they are happier when routines act like the delimiters are there...</p>
<p>But for the baseline behavior: <em>I have come to believe R3-Alpha is right.</em>  They're string delimiters, and incidental to the default purpose, just as quotes are.</p>
<p>If you start looking at TAG! as it truly is--just another string class with different delimiters--it simplifies the mental model and the implementation model.  You can truly just use it like another string, and it suddenly becomes consistent.</p>
<p>Of course, it's still nice to be able to match the molded form of a tag.</p>
<p>But... why stop at tags? <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"> Why not have a syntax to match the molded form of anything?</p>
<p>In strings, where you can't match list elements literally anyway:</p>
<pre><code>&gt;&gt; parse "&lt;a&gt; 100 (b c)" ['&lt;a&gt; space '100 space '(b c)]
== (b c)
</code></pre>
<p>(The synthesized product may be more interesting, too.  As a reminder, Ren-C has taken words that might be better as variable names like END and uses plain tag as  instead, or  to synthesize the parse input, etc.)</p>
<pre><code>&gt;&gt; parse "&lt;end&gt; asdf" ['&lt;end&gt; to &lt;end&gt; &lt;input&gt;]
== "&lt;end&gt; asdf"
</code></pre>
<p>I don't know whether that is best done as just a PARSE feature, or if quoted things need to be searched for literally by FIND.</p>
<pre><code>&gt;&gt; find "ab&lt;c&gt;d" &lt;c&gt;
== "c&gt;d"

&gt;&gt; quote &lt;c&gt;
== '&lt;c&gt;

&gt;&gt; find "ab&lt;c&gt;d" quote &lt;c&gt;
== "&lt;c&gt;d"

&gt;&gt; find "ab&lt;c&gt;d" mold &lt;c&gt;  ; one fewer character
== "&lt;c&gt;d"
</code></pre>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/tag-s-angle-brackets-they-arent-there/2326">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/tag-s-angle-brackets-they-arent-there/2326</link>
          <pubDate>Fri, 08 Nov 2024 18:12:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2326</guid>
          <source url="https://forum.rebol.info/t/tag-s-angle-brackets-they-arent-there/2326.rss">TAG!s Angle Brackets: *They Aren&#39;t There!*</source>
        </item>
        <item>
          <title>Old Idea Revisited: DATATYPE as... Antiform?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>I've been suffering through an attempt to bring sanity to bear upon the MAKE and TO matrix.</p>
<p>While doing so, I noticed that there are a lot of MAKE instructions that do "joining".</p>
<p>In R3-Alpha and Red:</p>
<pre><code>&gt;&gt; make binary! [1 2 #{DECAFBAD} 3 4]   
== #{0102DECAFBAD0304}
</code></pre>
<p>Historical MAKE is so arbitrary in how it interprets its arguments that it made me feel that it would be better if JOIN allowed a datatype as its first argument...</p>
<p>JOIN typically makes a new series out of what you give it:</p>
<pre><code>&gt;&gt; bin: #{AABB}

&gt;&gt; join bin #{CCDD}
== #{AABBCCDD}  ; made new series, didn't impact BIN

&gt;&gt; bin
== #{AABB}
</code></pre>
<p>But if you could pass a datatype as the first argument, you could relieve MAKE of the behavior...and make it clearer in the source what's actually happening:</p>
<pre><code>&gt;&gt; join binary! [1 2 #{DECAFBAD} 3 4]
== #{0102DECAFBAD0304}
</code></pre>
<p>Since that seemed nice, I started to map it out, and ran into a bit of a problem:</p>
<p><strong>If "datatypes" are an ANY-WORD! or ANY-LIST! or anything like that, how do you know you're not trying to JOIN with it?</strong></p>
<p>A WORD! should be able to join:</p>
<pre><code>&gt;&gt; join 'var 10
== var10
</code></pre>
<p>A BLOCK! should be able to join...</p>
<pre><code>&gt;&gt; join [a b] 10
== [a b 10]
</code></pre>
<p>Okay, but when you say <strong>join binary!</strong> what is BINARY!?  Well right now, it's:</p>
<pre><code>&gt;&gt; binary!
== &amp;[binary]
</code></pre>
<p>Well that looks like it's in-band for the kinds of things JOIN operates on:</p>
<pre><code>&gt;&gt; join &amp;[binary] 10
== &amp;[binary 10]
</code></pre>
<h2><a name="p-7875-an-antiform-would-push-datatype-out-of-band-1" class="anchor" href="https://forum.rebol.info#p-7875-an-antiform-would-push-datatype-out-of-band-1"></a>An Antiform Would Push DATATYPE? Out-Of-Band...</h2>
<p>It's possible that we could come up with a new non-antiform for types.  But the lexical space is extremely saturated.</p>
<p>If we were just reaching for something on the basis of looks, antiform FENCE! is nice:</p>
<pre><code>&gt;&gt; binary!
== ~{binary}~  ; anti
</code></pre>
<h2><a name="p-7875-this-has-come-up-before-2" class="anchor" href="https://forum.rebol.info#p-7875-this-has-come-up-before-2"></a>This Has Come Up Before...</h2>
<p>Historical Rebol let you use datatypes in FIND:</p>
<pre><code>rebol2&gt;&gt; find [a b c 10 20] integer! 
== [10 20]
</code></pre>
<p>But then this conflates with when you actually literally have the INTEGER! datatype in the block.</p>
<pre><code>&gt;&gt; find compose [a (integer!) b c 10 20] integer!
== [integer! b c 10 20]
</code></pre>
<p>So in the early days of antiforms, I proposed antiform datatypes as a solution... but at that time I was thinking that there'd be non-antiform DATATYPE!, and it's just that when it was an antiform it would be a "MATCHER".</p>
<p>The proposal I'm thinking of now is different, in saying that DATATYPE? only exists as a (stable) antiform state.</p>
<p>There are tradeoffs, in that datatypes can't be put in blocks directly.  But the mechanics of working with quasiforms and antiforms via things like REIFY and DEGRADE are much smoother now.  And really, putting datatypes in blocks doesn't happen that often (I've had to put splices in blocks but really never datatypes).</p>
<p>Being completely out of band with things you can find in a block has advantages.  JOIN isn't unique in reaping benefits from being able to say that datatypes aren't things.</p>
<p>And it unifies datatypes with typecheckers being antiforms, because typecheckers are frame antiforms, e.g. actions:</p>
<pre><code>&gt;&gt; find [1 3 5 8 10] even?/
; first in pack of length 2
== [8 10]
</code></pre>
<p>So I don't think it's a crazy idea.</p>
<p>I'm hesitant to surrender FENCE! antiforms to the purpose so soon after their invention.  But there isn't anything undecorated left.</p>
<p>Not that "no decorated antiforms" is some unbreakable rule, it was a guideline.</p>
<p>Using &amp; would put it in the family of TYPE-XXX! and be cheaper than FENCE! if you made new instances:</p>
<pre><code>&gt;&gt; binary!
== ~&amp;binary~  ; anti
</code></pre>
<p>A random bad idea would be to make them keywords, and just have DATATYPE? be smart enough to filter out ~null~ or ~void~ or ~okay~ or whatever else (the symbol could carry a flag)</p>
<pre><code>&gt;&gt; binary!
== ~binary~  ; anti

&gt;&gt; null
== ~null~  ; anti

&gt;&gt; datatype? binary!
== ~okay~  ; anti

&gt;&gt; datatype? null
== ~null~  ; anti
</code></pre>
<p>I can pretty clearly say that's bad.</p>
<h2><a name="p-7875-or-pick-some-non-antiform-notation-3" class="anchor" href="https://forum.rebol.info#p-7875-or-pick-some-non-antiform-notation-3"></a>Or, Pick Some Non-Antiform Notation</h2>
<p>Status quo might look like:</p>
<pre><code>&gt;&gt; binary!
== #[binary]
</code></pre>
<p>Despite it looking sort of like a block, it wouldn't be.  But we're squandering some of our notational space no matter what.  The <strong><code>~&amp;type~</code></strong> is the discount route.</p>
<h2><a name="p-7875-either-way-datatype-cant-be-any-word-or-any-list-4" class="anchor" href="https://forum.rebol.info#p-7875-either-way-datatype-cant-be-any-word-or-any-list-4"></a>Either Way, DATATYPE? Can't be ANY-WORD! or ANY-LIST!</h2>
<p>It needs to be out of band one way or another.  I'll have to think about it.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/old-idea-revisited-datatype-as-antiform/2324">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/old-idea-revisited-datatype-as-antiform/2324</link>
          <pubDate>Fri, 08 Nov 2024 17:05:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2324</guid>
          <source url="https://forum.rebol.info/t/old-idea-revisited-datatype-as-antiform/2324.rss">Old Idea Revisited: DATATYPE as... Antiform?</source>
        </item>
        <item>
          <title>Should Strings Nest Levels To Avoid Escaping?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>There's a historically convenient feature in strings:</p>
<pre><code>str: {This was {a historically legal} string.}
</code></pre>
<p>Each time you used an open brace inside a string, it would increment a "nesting count".  And when you used a close brace it would drop the nesting count.  When you got to zero, your string was finished.</p>
<p>It works in a lot of cases, but not if you have unpaired braces in your content:</p>
<pre><code>c-code: { if char = '}' { printf("This won't work.\n"); } }
</code></pre>
<p>We're going to be getting some instant improvement here with the new string format, using dashes.  Since at least one dash is required (otherwise you'd get a fence), cases like the above will "just work":</p>
<pre><code>c-code: -{ if char = '}' { printf("This will work!\n"); } }-
</code></pre>
<p>But should we still support the nesting idea?</p>
<pre><code>str: -{Should this -{still be a legal}- string?}-
</code></pre>
<p>The alternative would be to force you to use more dashes:</p>
<pre><code>str: --{This -{is definitely a legal}- string.}--
</code></pre>
<p>As we can see from the above, that move from one dash to two dashes does lengthen things.  The tightness is appealing to have as an option.</p>
<h2><a name="p-7836-but-its-complicated-1" class="anchor" href="https://forum.rebol.info#p-7836-but-its-complicated-1"></a>But It's Complicated...</h2>
<p>Let's put aside equal counts for a moment.  What happens if you nest <em>higher</em> counts (which contain lower counts, by definition)</p>
<pre><code>str: -{What ---{do you think this}--- should do?}-  ; [1]
</code></pre>
<p>If it were rotely searching for <strong><code>}-</code></strong> then it would find it at <strong><code>this}-</code></strong> and consider that the end.</p>
<pre><code>str: -{To look at ---{another one, consider}- this...}-  ; [2]
</code></pre>
<p><strong>Do we want the rule that if you ever enclose code with the dashed brace style like <strong><code>--{</code></strong> and <strong><code>}--</code></strong> the enclosure will always need more dashes than what it encloses?</strong></p>
<p>When I put it that way, I think that we don't want to force that escalation.  You can always go there if you need to (case 2 above requires it, or using quotes on the outside instead).  But I think being able to dodge it in cases where things are paired (as in case 1) is worth the dodge.</p>
<p><em>(Note that if you are trying to analyze the inside of the string for matched pairs that are other than the ones you asked for from the outside delimiter, then suddenly you're maintaining a stack of quote levels where nest level has an independent associated number of dashes, instead of just maintaining a total nesting count.  Not that this is a difficult problem, but it's just "another thing".)</em></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-strings-nest-levels-to-avoid-escaping/2311">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-strings-nest-levels-to-avoid-escaping/2311</link>
          <pubDate>Thu, 10 Oct 2024 06:44:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2311</guid>
          <source url="https://forum.rebol.info/t/should-strings-nest-levels-to-avoid-escaping/2311.rss">Should Strings Nest Levels To Avoid Escaping?</source>
        </item>
        <item>
          <title>Should sequences permit non-head SIGILs?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Historically I was very much opposed to SET-WORD! and GET-WORD! being in paths, because the ergonomics were bad:</p>
<pre><code>red&gt;&gt; p: to path! reduce [first [:a] first [b:]]
== :a/b:

&gt;&gt; type? p
== path!
</code></pre>
<p>You have something that's neither a SET-PATH! nor a GET-PATH! but it has colons at the beginning and the end.  It's all kinds of confusing.</p>
<p>Ren-C has addressed that particular can of worms with a <a href="https://forum.rebol.info/t/introducingnew-chain-datatype/2226">full design for the CHAIN! sequence type</a>, and rules for its nesting in PATH! (and how TUPLE! nests in it).  So you can get these weird looking structures, but they destructure unambiguously.</p>
<h2><a name="p-7831-as-for-sigils-at-the-head-they-must-be-illegal-1" class="anchor" href="https://forum.rebol.info#p-7831-as-for-sigils-at-the-head-they-must-be-illegal-1"></a>As For Sigils... At The Head They Must Be Illegal</h2>
<p>You can't put a sigil in a sequence head position, because that would be ambiguous with wanting to apply the sigil to the path as a whole.</p>
<pre><code>&gt;&gt; to path! [$foo bar]
** Error: This needs to be an error
</code></pre>
<p>The only way to allow it would be if we invented <a href="https://forum.rebol.info/t/what-is-a-path-or-a-quasi-word/2292/2">some kind of lexical escaping</a> so we could tell the difference between $|foo/bar| and $|foo|/bar ... <em><strong>and I do not want lexical escaping of this kind</strong></em>.</p>
<h2><a name="p-7831-but-sigils-at-non-head-positions-maybe-roll_eyes-2" class="anchor" href="https://forum.rebol.info#p-7831-but-sigils-at-non-head-positions-maybe-roll_eyes-2"></a>But Sigils At Non-Head Positions... Maybe?  <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=12" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></h2>
<p>There's no fundamental reason why sigils couldn't be on non-head positions in sequences.  It works.</p>
<pre><code>&gt;&gt; $a:$b
== a:$b  ; bound
</code></pre>
<p>Part of me says <em>"ugh, no, it makes everything uglier, don't let people make these ugly things!"</em></p>
<p>But one very compelling reason just for the above syntax is what I've called "dialecting function calls", such as for pointing the blame to a callsite with a FAIL.</p>
<p>So instead of:</p>
<pre><code>my-api: func [x y z] [
    if true [
        if y &lt; 100 [
            fail:blame ["Value must be &gt;= 100, not" y] $y
        ]
     ]
 ]
</code></pre>
<p>You could write:</p>
<pre><code>my-api: func [x y z] [
    if true [
        if y &lt; 100 [
            fail:$y ["Value must be &gt;= 100, not" y]
        ]
     ]
 ]
</code></pre>
<p>When you look at it like that, it's hardly a monstrosity.  It's letting you push the variable to blame into the chain for invoking the function, in a way that's out-of-band with other refinements.</p>
<p>It could offer a cheaper way of asking to fetch variables, using @ to take the place of the old "get word" concept:</p>
<pre><code>&gt;&gt; block: [index offset pointer]
&gt;&gt; index: 3

&gt;&gt; block.index
== offset

&gt;&gt; block.(index)
== pointer

&gt;&gt; block.@index
== pointer
</code></pre>
<p>It's measurably less expensive (no array allocation, cheaper to naviate to on fetch).  It doesn't use a GROUP! so it doesn't get in the way of COMPOSE-ing.</p>
<h2><a name="p-7831-think-i-have-to-allow-it-3" class="anchor" href="https://forum.rebol.info#p-7831-think-i-have-to-allow-it-3"></a>Think I Have To Allow It...</h2>
<p>I'd originally thought that it would be cleaner to disallow it.  But seems to me there are too many interesting uses.</p>
<p>As a medium, Rebol is very free, and you have a lot of power to make hideous things.  So it's about using your judgment, and I think people should know when it's getting too crazy.</p>
<hr>
<h2><a name="p-7831-i-almost-hate-to-point-it-out-but-4" class="anchor" href="https://forum.rebol.info#p-7831-i-almost-hate-to-point-it-out-but-4"></a>I Almost Hate To Point It Out, But...</h2>
<p>This is true of quotes as well.</p>
<pre><code>&gt;&gt; 'a:''b:'''c
== a:''b:'''c
</code></pre>
<p>There's an unambiguous way of interpreting that.</p>
<pre><code>&gt;&gt; quote to chain! [a ''b '''c]
== 'a:''b:'''c
</code></pre>
<p>I don't love it, but, maybe there's cases where <strong><code>foo:'bar</code></strong> would be useful in a dialect, and if it's mechanically consistent I shouldn't prohibit it.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20">  I don't know.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-sequences-permit-non-head-sigils/2309">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-sequences-permit-non-head-sigils/2309</link>
          <pubDate>Mon, 07 Oct 2024 19:06:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2309</guid>
          <source url="https://forum.rebol.info/t/should-sequences-permit-non-head-sigils/2309.rss">Should sequences permit non-head SIGILs?</source>
        </item>
        <item>
          <title>What Should &quot;New Refinements&quot; (e.g. :FOO) Evaluate To?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>We know what new refinements will do when you put them in a dialect like APPLY.:</p>
<pre><code>call:shell // [  ; infix APPLY
    [(system.options.boot) --suppress {"*"} print.reb 100]

    :input 'none      ; pipe input from /dev/null
    :output data: {}  ; write output to string
]
</code></pre>
<p>The <strong><code>:input</code></strong> and <strong><code>:output</code></strong> will be noticed literally by APPLY.  But this doesn't prescribe any particular evaluator meaning for them when not dialected.</p>
<p>Old refinements (e.g. <strong><code>/input</code></strong> and <strong><code>/output</code></strong>) would evaluate to bound versions of themselves... so effectively synonyms for <strong><code>$/input</code></strong> and <strong><code>$/output</code></strong>.</p>
<p><em>(This makes me aware of a likely bug in the optimization of paths (chains) of this size... they use a WORD! cell format.  Which means they only capture the binding of the specific word...while array-based sequences get a "whole specifier".  It doesn't seem to me that the length of the sequence should affect what kind of environment it captures.  e.g. <strong><code>[_ input]</code></strong> should capture the same amount of context as the path produced by it does...but if we forced embedded GROUP!s to be fixed in their biding on sequence creation that might be undesirable.  Review.)</em></p>
<p>Anyway...we know that <strong><code>.input</code></strong> is evaluative (picking the field out of the "current coupled context").  And <strong><code>/input</code></strong> will be evaluative (calling a function).  Then <strong><code>foo:bar</code></strong> will be evaluative, calling FOO with the refinement BAR.</p>
<p>So what of <strong><code>:foo</code></strong>?  Due to what we want it to do in APPLY, we know that giving it any active meaning in the evaluator would be a bad idea.  But maybe the best idea is to be conservative and error on it for now.  That won't stop you from creating unbound forms (<strong><code>':foo</code></strong>) or bound forms (<strong><code>$:foo</code></strong>)...and discouraging its use as a generic inert form probably has advantages in other contexts besides helping APPLY.</p>
<p>If it turns out that having it act as a generic unbound version of itself has some great application, I'll reconsider.  But error for now.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/what-should-new-refinements-e-g-foo-evaluate-to/2299">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-should-new-refinements-e-g-foo-evaluate-to/2299</link>
          <pubDate>Fri, 27 Sep 2024 18:11:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2299</guid>
          <source url="https://forum.rebol.info/t/what-should-new-refinements-e-g-foo-evaluate-to/2299.rss">What Should &quot;New Refinements&quot; (e.g. :FOO) Evaluate To?</source>
        </item>
        <item>
          <title>Typechecking Quoted forms / Quasiforms / Antiforms</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Asking questions about antiforms can be a bit tricky.</p>
<p>If you have a meta result that contains something that might be a pack, you'd have to say:</p>
<pre><code>if pack? unmeta result' [...]
</code></pre>
<p>But you're just asking a question.  What if it contained a meta of a raised error?   Should PACK? be willing to accept raised errors?  If not, that would cause an abrupt failure.</p>
<p>To dodge the need to do an UNMETA, you could say:</p>
<pre><code>all [
    quasiform? result'
    block! = heart of result'
] then [
   ...
]
</code></pre>
<p>And via such a mechanism, you could write a function META-PACK? that would not fail on META-RAISED:</p>
<pre><code>if meta-pack? result' [...]
</code></pre>
<p>That has the nice feature of not forcing you to perform an UNMETA just to answer the question.  You can narrowly ask "is this a meta pack".</p>
<p>But I think such things need to be in the box.  This question gets asked a lot, and I'm tired of asking it as the ugly and breakable <strong><code>pack? unmeta</code></strong>.</p>
<h2>
<a name="what-if-typecheck-functions-had-a-meta-refinement-1" class="anchor" href="https://forum.rebol.info#what-if-typecheck-functions-had-a-meta-refinement-1"></a>What If Typecheck Functions Had a :META refinement...?</h2>
<p>It doesn't seem like clogging up the namespace with more functions makes a lot of sense, so we might offer a refinement:</p>
<pre><code>if pack?/meta result' [...]
</code></pre>
<p>That puts some separation between the <strong>?</strong> and the thing you're testing.  It's a little less severe with the new format using a CHAIN!:</p>
<pre><code>if pack?:meta result' [...]
</code></pre>
<p>We could put a question mark on the refinement as well <img src="https://forum.rebol.info/images/emoji/twitter/face_with_diagonal_mouth.png?v=12" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20"></p>
<pre><code>if pack?:meta? result' [...]
</code></pre>
<p>Okay, no, we won't do that.</p>
<p>I kind of feel like putting the meta after makes it unclear.  You'd read it like <strong>pack? meta result'</strong>.  Does that mean it should just be UNMETA?</p>
<pre><code>if pack?:unmeta result' [...]
</code></pre>
<p>But at that point, people are probably not going to generally know what the difference is between that and <strong><code>pack? unmeta result</code></strong></p>
<p>None of this is as good as simply <strong><code>meta-pack?</code></strong>.  But we don't want to generate new words for every possible thing (and questions like <strong><code>meta-integer?</code></strong> are equally legitimate...)</p>
<h2>
<a name="what-about-arbitrary-chain-interpretation-2" class="anchor" href="https://forum.rebol.info#what-about-arbitrary-chain-interpretation-2"></a>What About Arbitrary CHAIN! Interpretation?</h2>
<p>Let's forget for a moment about the existing refinements to META and QUASI.  What if they--as functions--were willing to <em>take other functions as a refinement</em>?</p>
<pre><code>if meta:pack? result' [...]
</code></pre>
<p>This could be a general pattern of solution...</p>
<pre><code>if (quasi:group? first [~(a b c)~]) [...]

if (quote:word? first ['a b c:]) [...]  ; or quoted:word?
</code></pre>
<p>How would it work?  Well, I guess the basic idea would be that it would do a processing step on the argument before typechecking it and passing it to the constraint function.</p>
<p>So <strong><code>quoted:word?</code></strong> would run QUOTED, and it would be able to inspect the chain as containing WORD?.</p>
<ul>
<li>
<p>If it was passed something like <strong><code>&lt;foo&gt;</code></strong> it would say "I don't even have to ask, that's not a quoted anything".</p>
</li>
<li>
<p>If it was something like <strong><code>'&lt;foo&gt;</code></strong> it would say "okay that's quoted, I need to ask" and it would unquote the thing before passing it to WORD?, which would come back false.</p>
</li>
<li>
<p>If it was <strong><code>'bar</code></strong> it would do the same thing but this time WORD? would return true.</p>
</li>
</ul>
<p><em>It feels a little bit ad-hoc, but the ergonomics are certainly there.</em>  This would be tremendously useful and could create new and useful type constraints.  It's literate... and <strong><code>meta:pack?</code></strong> is going to look better in type specs than <strong><code>meta/pack?</code></strong></p>
<p>Not only that, but <a href="https://forum.rebol.info/t/intrinsics-functions-without-frames/2050">recognizing <strong>"intrinsics"</strong> in the chain</a> would mean this could be relatively fast--faster than <strong><code>pack? unmeta</code></strong> could be.</p>
<h2>
<a name="what-about-refinements-like-metalitehttpsforumrebolinfotmeta-lite-when-you-dont-want-quasiforms2296-3" class="anchor" href="https://forum.rebol.info#what-about-refinements-like-metalitehttpsforumrebolinfotmeta-lite-when-you-dont-want-quasiforms2296-3"></a>What About Refinements Like <a href="https://forum.rebol.info/t/meta-lite-when-you-dont-want-quasiforms/2296"><code>META:LITE</code></a>
</h2>
<p>Let's say there's a single-arity logic-bearing function someone makes called LITE, and they get mad that META:LITE doesn't call it to do a meta version of that test.</p>
<p>I don't know that I care a ton about that.  We have situations in PARSE where you might have a variable named ACROSS and it will ignore that variable if there's a keyword called ACROSS.  You have to escape your words when they run up against reserved dialect words.</p>
<p>So I guess you'd wind up with something like:</p>
<pre><code> if meta:(lite/) [...]
</code></pre>
<p>Otherwise the keyword would win.</p>
<h2>
<a name="what-about-cascading-the-functions-4" class="anchor" href="https://forum.rebol.info#what-about-cascading-the-functions-4"></a>What About Cascading The Functions?</h2>
<pre><code>if (quoted:quoted:quasi:block? first [''~[a b c]~]) [...]
</code></pre>
<p>Well I guess that could work if the rule was that if you used a function name as a refinement, that function would receive all the refinements after it.  Applying that recursively you'd get something that works.</p>
<p>There could be an optimization that functions like QUOTED would detect when the functions in the chain were ones they recognized, and they could do something optimal.</p>
<h2>
<a name="does-any-of-this-solve-the-unmeta-problem-5" class="anchor" href="https://forum.rebol.info#does-any-of-this-solve-the-unmeta-problem-5"></a>Does Any Of This Solve The UNMETA Problem?</h2>
<p>It's nice syntax, but remember the original issue...where you have a meta-raised-error, and you want to test it to see if it is or isn't a meta pack:</p>
<pre><code>if pack? unmeta result' [...]
</code></pre>
<p>I'm talking about redoing that:</p>
<pre><code>if meta:pack? result' [...]
</code></pre>
<p>But if META is unmeta'ing its argument, and passing it to PACK?, does that still have the same problem?</p>
<p>It doesn't have to.  META would see that the result is a quasiform, hence a candidate for any function to ask... then it needs to typecheck against what PACK? takes.  But if that typecheck fails, there's no need to raise the error.  You can just say "no, it's not a meta pack".  Done.</p>
<h2>
<a name="are-there-less-wacky-ways-to-do-it-6" class="anchor" href="https://forum.rebol.info#are-there-less-wacky-ways-to-do-it-6"></a>Are There Less Wacky Ways To Do It?</h2>
<p>I dunno.  It's admittedly a bit weird to put that much overloading on words like META and QUASI.  Their type signatures stop making sense (returning LOGIC?...sometimes?)</p>
<p>The overloading could be reduced if the weird modifiers were QUOTED, METAD, and QUASID.  :-/</p>
<pre><code>if metad:pack? result' [...]
</code></pre>
<p>Errr, no.  Didn't come this far to write things that look like garbage.</p>
<p>But oddly, quoted:xxx? looks better than quote:xxx?... does that suggest the operator should be called QUOTED too?  <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<pre><code>&gt;&gt; quoted 1 + 2
== '3
</code></pre>
<p>I've seen it as QUOTE for so long that it's hard to frame it.  It doesn't look <em>terrible</em>, and when you put them side by side the brevity has an advantage:</p>
<pre><code>if (quoted:quoted:quasi:block? first [''~[a b c]~]) [...]

if (quote:quote:quasi:block? first [''~[a b c]~]) [...]
</code></pre>
<p>To say that <strong><code>'a</code></strong> is a QUOTE-WORD! is a little bit caveman-ish, but better than calling it a LIT-WORD!, and it takes one less syllable to say "is a quote word" than to say "is a quote-uhd word".</p>
<p>Looking at it in that light, it's growing on me to dumb it down.  Maybe not in all circumstances.  Perhaps it could be left as a matter of taste with QUOTED and QUOTE being synonyms... like FUNC and FUNCTION, use whichever you want.</p>
<h2>
<a name="i-think-this-is-a-direction-worth-pursuing-7" class="anchor" href="https://forum.rebol.info#i-think-this-is-a-direction-worth-pursuing-7"></a>I Think This Is A Direction Worth Pursuing</h2>
<p>I've been looking for an answer to this question, and haven't thought of anything this good before.</p>
<p>Don't have a complete design for the "customized refinement dialect", but I can do some prototyping...</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/typechecking-quoted-forms-quasiforms-antiforms/2298">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/typechecking-quoted-forms-quasiforms-antiforms/2298</link>
          <pubDate>Tue, 24 Sep 2024 00:16:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2298</guid>
          <source url="https://forum.rebol.info/t/typechecking-quoted-forms-quasiforms-antiforms/2298.rss">Typechecking Quoted forms / Quasiforms / Antiforms</source>
        </item>
        <item>
          <title>What is ~/~ : A PATH! or a QUASI-WORD?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>I've mentioned that there are not going to be quasiform or antiform sequence types.</p>
<ul>
<li>
<p>We want tildes in paths <strong><code>~/home/whatever.txt</code></strong></p>
<ul>
<li>
<p>Paths in particular...but they could be useful in tuples (<strong><code>~.foo</code></strong>) or chains (<strong><code>[a]:~</code></strong>)</p>
</li>
<li>
<p>Quasiforms might be nice  for some purposes too (<strong><code>~null~/a/b/c), (foo:~[a]~</code></strong>)</p>
</li>
</ul>
</li>
<li>
<p>The known very important usage of tilde in paths, plus all the as-yet-unknown and untapped other uses, far outweigh any advantage I can think of for antiform/quasiform sequences.</p>
</li>
</ul>
<p>So that's settled.  But there's a bit of an edge case with the WORD!s like <strong><code>/</code></strong> or <strong>.</strong> or <strong>:</strong></p>
<p>And there, I'm going to have to say that <strong><code>~/~</code></strong> is a quasiword.</p>
<ul>
<li>
<p>I want all words to have quasiforms (though not antiforms... only system-blessed "keywords" will be allowed to become antiforms).  And so I don't want to exempt any words from that.</p>
</li>
<li>
<p>I don't think excluding <strong><code>~/~</code></strong> as a path form has any tremendous consequences</p>
</li>
<li>
<p>Allowing it to be a quasiword fits in with <strong><code>~///~</code></strong> and other such words being quasiwords, and those aren't valid paths.</p>
</li>
</ul>
<p>So we open up a wider field of parts, keep all words having quasiforms, and lose one weird path representation.</p>
<p>Though it's not "lost"--if you're writing dialect code that has some logic for what a PATH! of two tilde-trash would mean, you can specially recognize the quasiword.  You'll only run into representational trouble if in the same dialect you need a meaning for every possible quasiword that deviates from what the path interpretation would be.</p>
<p>(I'd say I'd bet money that's never going to happen, except I've seen exactly weird things like that happen often enough to know better.  So instead I'll say "it might happen someday, but I don't care.")</p>
<p>Anyway, trying to shore this up a bit, some sample errors:</p>
<pre><code>&gt;&gt; to path! [~ a]
== ~/a

&gt;&gt; to path! [~ ~]
** Script Error: Sequence would conflate with WORD! form: ~/~

&gt;&gt; to path! [a _]
== a/

&gt;&gt; to path! [_ _]
** Script Error: Sequence would conflate with WORD! form: /

&gt;&gt; to path! [_ a _]
== /a/

&gt;&gt; to path! [a _ b]
** Script Error: BLANK! only legal at head and tail of sequence
</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/what-is-a-path-or-a-quasi-word/2292">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-is-a-path-or-a-quasi-word/2292</link>
          <pubDate>Sun, 22 Sep 2024 13:15:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2292</guid>
          <source url="https://forum.rebol.info/t/what-is-a-path-or-a-quasi-word/2292.rss">What is ~/~ : A PATH! or a QUASI-WORD?</source>
        </item>
        <item>
          <title>Syntax for Typechecked Values</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>One of the things you can do with <a href="https://forum.rebol.info/t/a-dream-for-debugging-generalized-accessors/2259">Generalized Accessors</a>, is that assignments to any value can be typechecked.  You get this "for free" because accessors pair a function with a variable slot, and that function can use typechecking:</p>
<p>Writing the accessor boilerplate is laborious...</p>
<pre><code>checked: accessor lambda [^:value [your! types! here!] &lt;static&gt; actual] [
    either value [actual: value.] [actual.]  ; terminal dot allows unset vars
]
</code></pre>
<p>If you want to be truly generic and support storing actions in the variable, you need slashes:</p>
<pre><code>checked: accessor lambda [^:/value [your! types! here!] &lt;static&gt; actual] [
    either value [/actual: value.] [actual.]
]
</code></pre>
<p>Not only is that a nuisance to get typechecking, it's also not native code, so you're running that EITHER and its branches.</p>
<p>So we could make it a feature of ACCESSOR, maybe just when you give it a block...and it could do a particularly cheap and special form.  I think this is actually the right way to go about it... it would put a "pairing" cell in the variable's location, which would pair up the stored value with a PARAMETER! (which does preoptimized calculations on the typeset:</p>
<pre><code>checked: accessor [your! types! here!]
checked: initial-value
</code></pre>
<p>That's all fine and good but seems we need a shorter way to say it...that doesn't repeat the variable name and doesn't have to say ACCESSOR.</p>
<p>We want whatever this is to still get collected as a SET-WORD! (if it is one), so this probably has to be something like:</p>
<pre><code>checked: typed [your! types! here!] initial-value
</code></pre>
<p>I don't hate it.  Alternate ideas?</p>
<h2>
<a name="interaction-with-syntax-for-locals-1" class="anchor" href="https://forum.rebol.info#interaction-with-syntax-for-locals-1"></a>Interaction With Syntax For Locals</h2>
<p>This would now be able to work:</p>
<pre><code>foo: func [x [text!] &lt;local&gt; y [integer!]] [...]
</code></pre>
<p>This would need to be lenient in terms of letting the Y be unset prior to its first assignment.  So it can contain nothing at the outset, but any future assignments have to assign integers.</p>
<p>But this would get a bit of a problem if we want to mix it with a form that lets you assign the local:</p>
<pre><code>foo: func [x [text!] &lt;local&gt; y: [integer!]] [...]
</code></pre>
<p>That would give you Y with the BLOCK! [integer!] in it.  You'd have to say:</p>
<pre><code>foo: func [x [text!] &lt;local&gt; y: typed [integer!] 10] [...]
</code></pre>
<p>We could keep the historical "groups to initialize" idea</p>
<pre><code>foo: func [x [text!] &lt;local&gt; y (10)] [...]  ; not typechecked

foo: func [x [text!] &lt;local&gt; y [integer!] (10)] [...]  ; typechecked
</code></pre>
<p>And maybe the idea of making a place to put the type constraints vindicates that syntax for this context.</p>
<p><strong>Typechecking will slow down the code.</strong>  But it would be running through the same checking mechanisms that functions use.  As that code got better, so would this.</p>
<p>There could be some sort of "enable typechecking only in debug mode" property of functions where you could turn it on or off.</p>
            <p><small>11 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/syntax-for-typechecked-values/2260">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/syntax-for-typechecked-values/2260</link>
          <pubDate>Sun, 08 Sep 2024 00:45:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2260</guid>
          <source url="https://forum.rebol.info/t/syntax-for-typechecked-values/2260.rss">Syntax for Typechecked Values</source>
        </item>
        <item>
          <title>True, False, On, Off, Yes, No...?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p><em><strong>UPDATE:</strong> This thread led to the conclusion to not treat ON, OFF, YES, NO as synonyms for TRUE and FALSE, but instead rethink the paradigm as what we are calling <strong><a href="https://forum.rebol.info/t/flexible-logic-system-terminology/2252">"Flexible Logic"</a></strong>.  In this system, plain WORD!s are used to represent boolean states that indiscriminately take branches in things like IF...and NULL is the only state that inhibits branching.</em></p>
<hr>
<p>Historical Rebol does this definition:</p>
<pre><code>on:  true
off: false
yes: true
no:  false
</code></pre>
<p>And Red carried it forward.  Whether it's good or bad, I don't know (my instinct is to say bad).  I do know that it's lossy.</p>
<pre><code>red&gt;&gt; on
== true  ; not a word, but a misleading display of #[true]
</code></pre>
<p>Ren-C has the opportunity to do something different.</p>
<pre><code>&gt;&gt; on: ~on~
== ~on~  ; anti

&gt;&gt; off: ~off~
== ~off~  ; anti

&gt;&gt; yes: ~yes~
== ~yes~  ; anti

&gt;&gt; no: ~no~
== ~no~  ; anti
</code></pre>
<p>And then these WORD! antiforms could be treated as truthy and falsey as appropriate.  Negation could preserve the form:</p>
<pre><code>&gt;&gt; not yes
== ~no~ ; anti
</code></pre>
<p>Does it have value?  <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20">  Well, my instincts are that if there is any value to have in defining these, that value arises from having them be differently-typed logic-like things.  e.g. a function that took ON and OFF would <em>not</em> take YES and NO.</p>
<pre><code>&gt;&gt; security-system on
The security system is now activated.

&gt;&gt; security-system false
** Error: What are you talking about?
</code></pre>
<h2><a name="p-7560-does-this-buy-you-anything-1" class="anchor" href="https://forum.rebol.info#p-7560-does-this-buy-you-anything-1"></a>Does This Buy You Anything?</h2>
<p>What you get here is a little bit of friction on the callsite if your decision comes direct from math:</p>
<pre><code>&gt;&gt; security-system (user = 'Ron)
** Error: security-system requires TOGGLE! as enable argument, not ~true~
</code></pre>
<p>So you have to write something more laborious:</p>
<pre><code>&gt;&gt; security-system (either user = 'Ron [on] [off])
The security system is now activated.
</code></pre>
<p>At which point you might ask what the advantage is here over just using the words ON and OFF.</p>
<p>The advantages I see are:</p>
<ul>
<li>
<p>Callsite doesn't have to quote ON and OFF like <code>(either user = 'Ron ['on] ['off])</code></p>
</li>
<li>
<p>Once arguments are received, callee can use conditionals like IF and CASE and such directly:</p>
<pre><code>if enable [...]
</code></pre>
<p>...instead of...</p>
<pre><code>if enable = 'on [...]
</code></pre>
</li>
<li>
<p>You preserve the semantically correct word in the antiform, so you can see it in that form in debug output, and generalized print routines can extract them, e.g. TO WORD! gets you the word you want instead of just TRUE and FALSE</p>
</li>
<li>
<p>You're letting people guide the callsites to use clearer terms with some amount of enforcement, instead of permitting yes and true where ON is intended</p>
</li>
<li>
<p>FWIW the words are shorter.  <strong>false</strong> is 5 letters while <strong>no</strong> is just 2</p>
</li>
</ul>
<h2><a name="p-7560-how-valuable-is-it-2" class="anchor" href="https://forum.rebol.info#p-7560-how-valuable-is-it-2"></a>How Valuable Is It?</h2>
<p>Infinitely moreso than just defining them to true and false.  (Mostly because any amount is more useful than zero.)</p>
<p>I started this out as devil's advocacy, but I think I've actually talked myself into it.  It's pretty cool.</p>
<h2><a name="p-7560-naming-the-types-3" class="anchor" href="https://forum.rebol.info#p-7560-naming-the-types-3"></a>Naming The Types</h2>
<p>Uh, YES-NO? and ON-OFF? kind of suck, like calling logic TRUE-FALSE? would suck.  But they're clear.</p>
<p>I asked Claude for thoughts:</p>
<blockquote>
<p>These are some interesting ideas for expanding the concept of boolean types. Let's break down the potential names and rationales:</p>
<ol>
<li>
<p>BOOLEAN! or LOGIC! for TRUE/FALSE</p>
<ul>
<li>This is the standard name, representing traditional boolean logic.</li>
</ul>
</li>
<li>
<p>SWITCH! or TOGGLE! for ON/OFF</p>
<ul>
<li>
<p>These names capture the idea of a binary state that can be flipped.</p>
</li>
<li>
<p>SWITCH! might be slightly more intuitive as it's commonly used in programming and everyday language.</p>
</li>
</ul>
</li>
<li>
<p>CONFIRM! or RESPONSE! for YES/NO</p>
<ul>
<li>
<p>CONFIRM! does indeed capture the essence of affirmation or negation.</p>
</li>
<li>
<p>RESPONSE! could work too, as it implies an answer to a question.</p>
</li>
</ul>
</li>
</ol>
<p>Your suggestion of YES-NO! and ON-OFF! as type names is also valid, though they might be less conventional in programming language design.</p>
<p>The key aspect of your proposal is that these types, while similar in their binary nature, are distinct and not interchangeable. This could lead to more precise and context-specific code, but it might also increase complexity.</p>
</blockquote>
<p>I like <strong>[TOGGLE?]</strong> and <strong>[CONFIRM?]</strong></p>
<p>But your type check can use quasiforms as a proxy for antiforms, e.g. <strong>[~yes~ ~no~]</strong>, and that may be about as clear.</p>
            <p><small>7 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/true-false-on-off-yes-no/2250">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/true-false-on-off-yes-no/2250</link>
          <pubDate>Wed, 04 Sep 2024 10:38:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2250</guid>
          <source url="https://forum.rebol.info/t/true-false-on-off-yes-no/2250.rss">True, False, On, Off, Yes, No...?</source>
        </item>
        <item>
          <title>FILE! =&gt; FILE-WORD!, FILE-TUPLE!, FILE-PATH!..</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>I've never been quite on board with the FILE! datatype.</p>
<p>It displeased me that it was just a string, you couldn't really do too much with it.  Not a lot of magic.  It's burdened by representations of spaces in it, and hard to really say it gives coverage of any incoming file string.</p>
<p>Sample Rebol2 session on Windows:</p>
<pre><code class="lang-plaintext">&gt;&gt; cd /
== %/

&gt;&gt; ls
c/  d/

&gt;&gt; cd c
== %/c/

&gt;&gt; cd "Program Files"
== %/c/Program%20Files/
</code></pre>
<p>Are we really in the "actually good" territory of a problem space that can be reasonably tackled? If I'm a Windows user, I'd rather see that as {C:\Program Files} in my config files or scripts any day of the week.</p>
<h2>
<a name="ive-advocated-building-on-newpath-1" class="anchor" href="https://forum.rebol.info#ive-advocated-building-on-newpath-1"></a>I've Advocated Building on "NewPath"</h2>
<p>"NewPath" was able to do things like <strong><code>/foo/bar</code></strong> or <strong><code>baz/mumble/</code></strong>).  I advocated that FILE! build on that.</p>
<p>Now that we can have more basic types, I'm thinking that sounds pretty cool:</p>
<pre><code>%foo                             ; FILE-WORD!
%foo.c                           ; FILE-TUPLE!
%1-foo.txt                       ; FILE-FUSED!
%foo/bar/baz.txt                 ; FILE-PATH!
%["C:\File With\Spaces.txt"]     ; FILE-BLOCK!
</code></pre>
<p>You've got your coherence...enforcement of not having doubled-up slashes...able to use COMPOSE and such...</p>
<pre><code>&gt;&gt; dir: %foo/bar/

&gt;&gt; compose %(dir)/baz.txt
== %foo/bar/baz.txt
</code></pre>
<p>We could build the calculus-of-slashes that I've been demanding, so everything is on board with what's a directory and what's a file.</p>
<pre><code>&gt;&gt; dir: %foo/bar

&gt;&gt; compose %(dir)/baz.txt
** Error: compose into FILE-PATH! needs ending slash in non-terminal slot
</code></pre>
<p>And basically, we could punt on the question of how to deal with obnoxious filenames by telling people "if you aren't going to name your files like a sane person, use a string."  Spaces in filenames is one of the worst ideas ever, and I don't mind making those second-class citizens if it means we get good properties.</p>
<p>And of course, more parts for dialecting.</p>
<h2>
<a name="this-would-intern-a-lot-of-random-strings-2" class="anchor" href="https://forum.rebol.info#this-would-intern-a-lot-of-random-strings-2"></a>This Would Intern a lot of Random Strings</h2>
<p>One downside here is that if you have a bunch of filenames of varying lengths, and you make them these symbolic structures instead of just keeping them as strings, you'll explode the symbol table.</p>
<p>That seems like an argument to say that if you're making some kind of database where these scale problems are going to affect you, you might should use string instead.</p>
<p>That's just a general truth--while WORD!s may look nice, they do go in the symbol table and that table can get big if you decide you're going to go crazy storing your data as tons of long unique words because-you-can.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/file-file-word-file-tuple-file-path/2243">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/file-file-word-file-tuple-file-path/2243</link>
          <pubDate>Sun, 01 Sep 2024 21:49:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2243</guid>
          <source url="https://forum.rebol.info/t/file-file-word-file-tuple-file-path/2243.rss">FILE! =&gt; FILE-WORD!, FILE-TUPLE!, FILE-PATH!..</source>
        </item>
        <item>
          <title>Backtick Literals (and an Axis of Extensibility?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>I've been historically frustrated by the overlap between what I think make nicely regular language features (like TUPLE!, PATH!, and CHAIN!) running up against edges with literal representations.</p>
<ul>
<li>
<p><strong><code>version/1.2</code></strong> would be nice if that could be interpreted as a tuple, but people want to write their decimal representations as <strong><code>1.02</code></strong> etc.</p>
</li>
<li>
<p><strong><code>1:10</code></strong> would be nice as a CHAIN! to represent a range, but people want to write TIME! representations as <strong><code>10:20</code></strong> etc.</p>
</li>
<li>
<p><strong><code>31-Aug-2024/0:36:30-4:00</code></strong> is a DATE!, but sure looks like a PATH!</p>
</li>
</ul>
<p>Ad nauseum.</p>
<p>Because I think <strong><code>version/1.2</code></strong> has been genenerally the kind of thing that's more important to the domains Rebol is actually good for than math, I've been willing to throw things like DECIMAL! under the bus.  So over time I've suggested random things like <em>"<strong><code>&amp;1.02</code></strong> to represent DECIMAL!"</em>.  But not only have such ideas been loudly protested, the sigils have become pretty saturated to where everything has a meaning already.</p>
<p>But we do have one little crevice in notational space that isn't too hideous.</p>
<h2><a name="p-7485-enclosing-in-backticks-1" class="anchor" href="https://forum.rebol.info#p-7485-enclosing-in-backticks-1"></a>Enclosing In `Backticks`</h2>
<pre><code>adjusted-value: value / `1.02`

set alarm for `10:20`

[&lt;backdate-post&gt; `31-Aug-2024/0:36:30-4:00`]

set $(coefficient-name) `6.22e23`

[1020 : -304]  ; INTEGER! would of course be exempt.
</code></pre>
<p>The backticks are about as unobtrusive as this can get.</p>
<p>Having them on the start and end doesn't just make it look more balanced and symmetrical--it also lets the literal interpretation be sandboxed from the rest of the scanning.</p>
<h2><a name="p-7485-this-would-not-bother-me-2" class="anchor" href="https://forum.rebol.info#p-7485-this-would-not-bother-me-2"></a>This Would Not Bother Me</h2>
<p>Quite the contrary, I would be <em>thrilled</em> to see the regularity this would bring to the scanner.</p>
<p>It puts all the quirky exceptions in one place where they can fight amongst themselves, while the real work can proceed.</p>
<h2><a name="p-7485-a-place-for-parameterized-transcode-3" class="anchor" href="https://forum.rebol.info#p-7485-a-place-for-parameterized-transcode-3"></a>A Place For Parameterized TRANSCODE?</h2>
<p>When you call TRANSCODE it could offer you the ability to specify that file's interpretation of backtick'd portions.  This would give you a way to customize things, throwing in your own pecking order for the literals...then using TO INTEGER! and TO DATE! etc as you wish (or after you've picked over it, call some kind of generic TO-VALUE that goes through the default list).</p>
<p>Maybe.  I don't know.  It's a thought, that constraining these irregularities inside of a box could let that irregular space be what it wanted, while the rest of the scanner would be nailed down.</p>
<p>We could even say there's a mode you can load things in which it doesn't interpret the literals at all.  They'd just be LITERAL!.</p>
<pre><code>&gt;&gt; code: transcode/illiterate -{foo: `whatever*you*say`}-
== [foo: `whatever*you*say`]

&gt;&gt; type of second code
== &amp;[literal]

&gt;&gt; as text! second code
== "whatever*you*say"
</code></pre>
<h2><a name="p-7485-doesnt-necessarily-stop-use-of-unbackticked-forms-4" class="anchor" href="https://forum.rebol.info#p-7485-doesnt-necessarily-stop-use-of-unbackticked-forms-4"></a>Doesn't (Necessarily) Stop Use Of Unbackticked Forms</h2>
<p>You wouldn't be able to write plain <strong><code>1.02</code></strong> and get a TUPLE! that you could translate into a DECIMAL! (error, as an integer in the second slot would be loss of information).</p>
<p>But you could get away with some things.  More with something like the <strong><a href="https://forum.rebol.info/t/no-interstitial-delimiter-sequence-proposal-scrunch/1503">FUSED! Proposal</a></strong></p>
<p>If your notation is LOAD-able, and you're in a dialect context, you could transform what you got.</p>
<p>If people decide it's worth it to them to do transforms on <strong>1.2em</strong> to make it <strong>`1.2`em</strong> that's their dialect's business.  But we need to make leading-0s illegal in tuples, so you don't unwittingly lose information.</p>
<aside class="quote quote-modified" data-post="1" data-topic="1755">
  <div class="title">
    <div class="quote-controls"></div>
    <img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar">
    <a href="https://forum.rebol.info/t/tuple-troubles-version-0-3-01-vs-0-3-1/1755">Tuple Troubles: Version 0.3.01 vs 0.3.1</a> <a class="badge-category__wrapper " href="https://forum.rebol.info/c/development/datatypes/45"><span data-category-id="45" style="--category-badge-color: #25AAE2; --category-badge-text-color: #FFFFFF; --parent-category-badge-color: #25AAE2;" data-parent-category-id="8" data-drop-close="true" class="badge-category --has-parent" title="The datatypes category is for the discussion of the specific properties of datatypes themselves.  Sample topics might include:"><span class="badge-category__name">Datatypes</span></span></a>
  </div>
  <blockquote>
    For better or worse, versioning in Rebol has used TUPLE!.  e.g. 0.3.1 is 32-bit Windows, and 0.3.40 is 64-bit Windows 
If you go back and look at the old R3-Alpha file <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/tools/systems.r#L21">%systems.r</a> you can see that it's pretty typical for Carl to have written the versions out with leading zeros...but only in the third slot.  So 0.3.01 but not 00.03.01 
But ultimately the tuple discards this information.  And this has been the way it always worked: 
rebol2&gt;&gt; 0.3.01
== 0.3.1

red&gt;&gt; 0.3.01
== 0.3.1

ren-c&gt;&gt; 0.3.01
==…
  </blockquote>
</aside>

            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/backtick-literals-and-an-axis-of-extensibility/2235">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/backtick-literals-and-an-axis-of-extensibility/2235</link>
          <pubDate>Sat, 31 Aug 2024 04:54:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2235</guid>
          <source url="https://forum.rebol.info/t/backtick-literals-and-an-axis-of-extensibility/2235.rss">Backtick Literals (and an Axis of Extensibility?)</source>
        </item>
        <item>
          <title>Should NOTHING and NIHIL be Offered as Named Actions?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Sometimes it's nice to say things like <strong><code>return blank</code></strong> instead of <strong><code>return _</code></strong></p>
<p>It can just look better.  So there are named versions of a few symbolic things, like BLANK and TRASH.</p>
<pre><code>&gt;&gt; blank
== _

&gt;&gt; trash
== ~
</code></pre>
<p>But there are also named versions of NIHIL and NOTHING.</p>
<pre><code>&gt;&gt; nothing  ; no console display

&gt;&gt; nihil
== ~[]~  ; anti
</code></pre>
<p>But how does that work?  NIHIL can't be stored in a variable, it's an unstable isotope.  And NOTHING represents an unset variable, so variables containing it would error.</p>
<p>So of course, these aren't variables holding the states... they're variables holding actions, and they return the state.  So:</p>
<pre><code>&gt;&gt; nada: nothing  ; I'd like to alias this for spanish, please...

&gt;&gt; nada
** Script Error: nada is ~ antiform (see ^(...) and GET/ANY)
</code></pre>
<p>And you might be surprised at the result of GET:</p>
<pre><code>&gt;&gt; get $nihil
== ~#[frame! []]~ ; anti  (hey, that's not nihil!)
</code></pre>
<p>Does this sort of suggest that we're doing people a disservice by suggesting you can "name" these particular antiforms?</p>
<p>Would it be better if we just said you're supposed to use quasiforms if you want to generate these antiforms?</p>
<pre><code>&gt;&gt; ~

&gt;&gt; ~[]~
== ~[]~  ; anti
</code></pre>
<p>It's easier to not name them now, and add the name later, vs. provide the name and take it away.</p>
<p>Also--not that it really matters--but it's faster.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20">  The evaluator can tweak the quoting byte to antiform on those literals faster than making a function call.</p>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-nothing-and-nihil-be-offered-as-named-actions/2234">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-nothing-and-nihil-be-offered-as-named-actions/2234</link>
          <pubDate>Fri, 30 Aug 2024 18:12:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2234</guid>
          <source url="https://forum.rebol.info/t/should-nothing-and-nihil-be-offered-as-named-actions/2234.rss">Should NOTHING and NIHIL be Offered as Named Actions?</source>
        </item>
        <item>
          <title>Introducing:The:New:CHAIN!:Datatype</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>As part of a <a href="https://forum.rebol.info/t/big-alien-proposal-word-runs-functions/1905/13">giant overhaul of function application</a>, we're getting rid of SET-XXX! and GET-XXX! as fundamental types.  Instead, we'll have a new sequence that's like PATH! and TUPLE!...except that uses the colon character as its interstitial delimiter.</p>
<h2>
<a name="thesewill-be1020called-chain-1" class="anchor" href="https://forum.rebol.info#thesewill-be1020called-chain-1"></a><code>these:&lt;will be&gt;:1020:"called CHAIN!"</code>
</h2>
<p><img src="https://forum.rebol.info/images/emoji/twitter/alien.png?v=12" title=":alien:" class="emoji only-emoji" alt=":alien:" loading="lazy" width="20" height="20"></p>
<h2>
<a name="three-is-a-magic-numberhttpsyoutubej8lrkcw2_pkt21-2" class="anchor" href="https://forum.rebol.info#three-is-a-magic-numberhttpsyoutubej8lrkcw2_pkt21-2"></a><a href="https://youtu.be/J8lRKCw2_Pk?t=21"><img src="https://forum.rebol.info/images/emoji/twitter/three.png?v=12" title=":three:" class="emoji" alt=":three:" loading="lazy" width="20" height="20">  is a magic number.</a>
</h2>
<p>It gives us a nice symmetry of having three ANY-LIST! types, and three ANY-SEQUENCE! types</p>
<ul>
<li>
<p><strong><code>[BLOCK!] (GROUP!) {FENCE!}</code></strong></p>
</li>
<li>
<p><strong><code>/PATH!/ .TUPLE!. :CHAIN!:</code></strong></p>
</li>
</ul>
<h2>
<a name="chain-is-higher-precedence-than-tuple-lower-than-path-3" class="anchor" href="https://forum.rebol.info#chain-is-higher-precedence-than-tuple-lower-than-path-3"></a>CHAIN! is Higher Precedence Than TUPLE!, Lower Than PATH!</h2>
<p>Pleasingly, the hierarchy of the interstitials is in accordance with their "heft"... <strong><code>/</code></strong> is heftier than <strong><code>:</code></strong> which is heftier than <strong><code>.</code></strong></p>
<pre><code> foo/bar.baz:mumble:frotz
</code></pre>
<p>...that would be a 2-element PATH! with a 3-element CHAIN! in the second position that has a 2-element TUPLE! in its first position.</p>
<h2>
<a name="and-will-no-longer-be-sigil-4" class="anchor" href="https://forum.rebol.info#and-will-no-longer-be-sigil-4"></a><code>::</code> and <code>:</code> Will No Longer be SIGIL!</h2>
<p>This means sequences of all colons will be WORD!s, like <code>[/ // /// etc]</code> and <code>[. .. ... etc]</code></p>
<p>It was perhaps a bit suspicious that colons could appear on the beginning of a word or the end of the word.  That makes it seem more like an interstitial sequencing character than a SIGIL!</p>
<p>This means that you can put SIGILs on chains, including the trivial chains <strong><code>@:word</code></strong> or <strong><code>$(group):</code></strong> which previously needed two cells, e.g. <strong><code>(@ :word)</code></strong> or <strong><code>($ '(set-group):)</code></strong>.</p>
<ul>
<li>
<p>Looks tighter, evaluates faster, and you don't have to quote evaluative things</p>
</li>
<li>
<p>You can communicate more information with the single value if it can carry the sigil along</p>
</li>
</ul>
<h2>
<a name="notationally-competes-with-time-5" class="anchor" href="https://forum.rebol.info#notationally-competes-with-time-5"></a>Notationally Competes with TIME!</h2>
<p>We have to decide what <strong><code>10:20</code></strong> is.</p>
<p>When a parallel problem happened with <strong>1.2</strong> needing to be either DECIMAL! or TUPLE!, the decision was to make it a DECIMAL!.  So maybe CHAIN! reserves cases where numbers are at the head for other types?</p>
<p>But it's a shame because it seems this is made for dialecting on much more interesting level:</p>
<pre><code>for x 1:10 [print x]

for x 1:(end) [print x]

for x (start):10 [print x]

for x 0:10/2 [print x]   ; /2 could mean bump by 2
</code></pre>
<p>I wonder if TIME! could be moved out of the way somehow.  Maybe the weird forms that interfere with generality of sequences could be the syntaxes like <strong><code>#[10:00]</code></strong> or <strong><code>@time/&lt;10:00&gt;</code></strong> ... is TIME! really used so often and so critically that it can't be delimited out of band?  If contextually you know a spot should have time, <a href="https://forum.rebol.info/t/kinds-of-values/466">could it just be <strong><code>&lt;10:00&gt;</code></strong> and you add the <strong><code>@time/</code></strong> to it for processing</a>?</p>
<p>We can debate it.  The easiest compatibility rule would be just to know that there are no 2-element chains that start with numbers.</p>
<h2>
<a name="url-is-not-a-conflict-6" class="anchor" href="https://forum.rebol.info#url-is-not-a-conflict-6"></a>URL! is <strong>NOT</strong> a Conflict</h2>
<p>You might imagine <strong><code>http://example.com</code></strong> is a 3-element PATH!:</p>
<ul>
<li>
<p>First slot is a CHAIN! of <code>[http _]</code></p>
</li>
<li>
<p>Second slot is a BLANK!</p>
</li>
<li>
<p>Third slot is a TUPLE! of <code>[example com]</code></p>
</li>
</ul>
<p>But I think it's too valuable to be able to express URL!s easily.  So this seals the deal that you can't put BLANK!s internal to ANY-SEQUENCE!.  So there's no <strong>foo//bar</strong> paths or <strong>foo...bar</strong> tuples or <strong>foo:::::bar</strong> chains.  With // being illegal in path, it's free to be a URL!.</p>
<p>(We were already saying that <strong>/</strong> and <strong>//</strong> and <strong>...</strong> etc. are WORD!s, so the bias against doubling up these interstitial delimiters in sequences has been building up over time, and this just finalizes that.)</p>
<p>Yet strangely enough, <strong><code>http:/example.com</code></strong> with just one slash <em>is</em> a valid PATH! of 2 elements, with a CHAIN! in the first slot and a TUPLE! in the second.  Maybe this was destiny all along, and why URL!s have the two slashes.  <img src="https://forum.rebol.info/images/emoji/twitter/monkey_face.png?v=12" title=":monkey_face:" class="emoji" alt=":monkey_face:" loading="lazy" width="20" height="20">  <em>(I actually do believe the two slashes were chosen to make URL!s "stand out" visually, so it may not be a complete coincidence that it works out well for us here.)</em></p>
<h2>
<a name="but-no-more-urn-7" class="anchor" href="https://forum.rebol.info#but-no-more-urn-7"></a>But... no more URN!</h2>
<p>The subset of legal URN!s that we can represent would be CHAIN!.</p>
<p>How many URN!s would be ruled out?  Interestingly the first two examples I found off stackoverflow of URN!s would be valid chains:</p>
<pre><code>URN (not URL): urn:oasis:names:specification:docbook:dtd:xml:4.1.2
URN (not URL): tel:+1-816-555-1212 (disputed, see comments)
</code></pre>
<p>But I'm not really concerned if it can't represent all of them.  The world doesn't revolve around URNs anyway.  (Maybe they were supposed to be important at one point, but I haven't noticed them ever being so.)</p>
<p>We have things like <strong><code>@urn/"tel:1-816-555-1212"</code></strong> if we need them, as inert forms</p>
<h2>
<a name="cuts-down-on-total-number-of-fundamental-types-8" class="anchor" href="https://forum.rebol.info#cuts-down-on-total-number-of-fundamental-types-8"></a>Cuts Down On Total Number Of Fundamental Types</h2>
<p>What's added:</p>
<ul>
<li>
<code>a:b</code> ... CHAIN!</li>
<li>
<code>@a:b</code> ... THE-CHAIN!</li>
<li>
<code>$a:b</code> ... VAR-CHAIN! (should things like this be called e.g. BIND-CHAIN! ?)</li>
<li>
<code>^a:b</code> ... META-CHAIN!</li>
<li>
<code>&amp;a:b</code> ... TYPE-CHAIN!</li>
</ul>
<p><em>(I do think that perhaps calling e.g. $XXX a BIND-WORD! is better than VAR-WORD!, because VAR is an abbreviation and it doesn't look as classy.)</em></p>
<p>Compare that to what's removed:</p>
<ul>
<li>
<code>:[a b]</code> ... GET-BLOCK!</li>
<li>
<code>[a b]:</code> ... SET-BLOCK!</li>
<li>
<code>:(a b)</code> ... GET-GROUP!</li>
<li>
<code>(a b):</code> ... SET-GROUP!</li>
<li>
<code>:{a b}</code> ... GET-FENCE!</li>
<li>
<code>{a b}:</code> ... SET-FENCE!</li>
<li>
<code>:a</code> ... GET-WORD!</li>
<li>
<code>a:</code> ... SET-WORD!</li>
<li>
<code>:a/b</code> ... GET-PATH!</li>
<li>
<code>a/b:</code> ... SET-PATH!</li>
<li>
<code>:a.b</code> ... GET-TUPLE!</li>
<li>
<code>a.b:</code> ... SET-TUPLE!</li>
</ul>
<p>And despite sacrificing those types, due to past labors <a href="https://forum.rebol.info/t/path-and-tuple-compression-explained/1008">there's no loss in storage efficiency</a>.</p>
<p>Fewer basic types, but a lot more fun parts.</p>
<h2>
<a name="resolves-questions-that-have-plagued-rebol-for-decades-9" class="anchor" href="https://forum.rebol.info#resolves-questions-that-have-plagued-rebol-for-decades-9"></a>Resolves Questions That Have Plagued Rebol For Decades</h2>
<p>There was always this question about "why can't you put SET-WORD! or GET-WORD! in a PATH!", and people argued about it.</p>
<p>But now the answer is that they're not fundamental parts, and you're just dealing with the laws of interstitial delimiters.  You can't put a path "in" a path, but you can merge them.  So now it's just that you can't put a chain in a chain, only join them.</p>
<p>So this means a test like SET-PATH? doesn't make any sense.  Chains always live underneath paths!  But there <em>are</em> what are effectively SET-TUPLE (!) because with <strong><code>.a:</code></strong> you have the tuple under the chain.</p>
<p>Hence we're resurrecting things like <strong><code>a/:b</code></strong> but with a whole different logic behind it.  Because you can't run the risk of putting a GET-WORD in the first slot of a GET-PATH! <em>because there are no "GET-PATHs"</em>.</p>
<p>This <em>finally</em> makes perfect sense.</p>
<h2>
<a name="this-means-we-wont-have-undecorated-ipv6-literals-10" class="anchor" href="https://forum.rebol.info#this-means-we-wont-have-undecorated-ipv6-literals-10"></a>This Means We Won't Have Undecorated IPV6 Literals</h2>
<p>Red is pursuing the idea of IPV6 literals, but this won't work with that.  We'll need another way.</p>
<p>Since the @ sigil makes things evaluate to themselves, it's going to be the likely basis of extensible literals:</p>
<pre><code>&gt;&gt; @ipv6:&lt;FE80:CD00:0:CDE:1257:0:211E:729C&gt;
== @ipv6:&lt;FE80:CD00:0:CDE:1257:0:211E:729C&gt;
</code></pre>
<h2>
<a name="foo-actually-looks-kind-of-cool-11" class="anchor" href="https://forum.rebol.info#foo-actually-looks-kind-of-cool-11"></a><strong>:FOO:</strong> Actually Looks Kind of Cool</h2>
<p>When it comes to dialecting, <strong><code>.FOO.</code></strong> doesn't seem like something you'd use as a token.  It's more like a notation that would just sort of come up if your rules happened to intersect ("starting with a dot does X, ending with a dot does Y, starting and ending with a dot means you want both X and Y").</p>
<p><strong><code>/FOO/</code></strong> is a bit better.  I can imagine it labeling something, while not using up BLOCK! or GROUP! or FENCE! to get the look</p>
<pre><code>[
   /FIRST/ this could be (some code)
   You could do [something here]
   /SECOND/ more stuff.
   {your fence here}
]
</code></pre>
<p>But <strong><code>:FOO:</code></strong> seems like something you might use.  As does <strong><code>:[foo]:</code></strong>, <strong><code>-:[foo]:-</code></strong>, etc.  Neat things to have in the parts box.</p>
            <p><small>7 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/introducingnew-chain-datatype/2226">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/introducingnew-chain-datatype/2226</link>
          <pubDate>Thu, 29 Aug 2024 01:57:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2226</guid>
          <source url="https://forum.rebol.info/t/introducingnew-chain-datatype/2226.rss">Introducing:The:New:CHAIN!:Datatype</source>
        </item>
        <item>
          <title>Antiform TAG! As &quot;Triggers an Error On Access&quot; Type</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>In the post <a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604">"Shades of Distinction In Non-Valued Intents"</a>, I had originally written:</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="2283">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"><a href="https://forum.rebol.info/t/what-are-null-void-nothing-blank-and-nihil/2283/2">What Are NULL, VOID, NOTHING, BLANK, and NIHIL?</a></div>
<blockquote>
<p>Eventually the NULL state became the isotopic status of the WORD! null, so a <strong>~null~</strong> antiform.</p>
<p>It joined <strong>~true~</strong> and <strong>~false~</strong> as being antiforms you could test for truthiness and falseyness. But if you were okay with getting an error on conditional testing, any other word could be used:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">  config: ~initialize-system-not-called~

  initialize-system: func [
      {Let's say this function reads the config file}
  ][
      ...
      config: [...]
  ]
</code></pre>
<p>This usually causes a nice labeled message anytime someone tries to use CONFIG:</p>
<p>Going this route would create a pain point for anyone who thought they were going to test for whether you had a config initialized by testing <strong>if config [...]</strong>. So that has to be considered as whether it's what you want.</p>
</blockquote>
</aside>
<p>I've come to question this as things have gone on, to where I'm wondering if all antiform words should be reserved by the system (there are system purposes for the ~end~ antiform, for instance).</p>
<p>A generic "error trigger" might come from something like antiform TAG!, permitting spaces:</p>
<pre><code>config: ~&lt;INITIALIZE-SYSTEM not called&gt;~

initialize-system: func [
    {Let's say this function reads the config file}
][
    ...
    config: [...]
]

&gt;&gt; config
** Error: INITIALIZE-SYSTEM not called
</code></pre>
            <p><small>7 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/antiform-tag-as-triggers-an-error-on-access-type/2170">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/antiform-tag-as-triggers-an-error-on-access-type/2170</link>
          <pubDate>Sat, 09 Mar 2024 08:49:19 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2170</guid>
          <source url="https://forum.rebol.info/t/antiform-tag-as-triggers-an-error-on-access-type/2170.rss">Antiform TAG! As &quot;Triggers an Error On Access&quot; Type</source>
        </item>
        <item>
          <title>What is the use of typesets?</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Recent discussions have brought the notion of ‘typesets’ to my attention. On reading the source code, this confused me a bit… they don’t seem to be used all that much. Moreover, they seem to be subsumed by the idea of optimised constraint functions.</p>
<p>So I set out to try them myself. Only to find myself thoroughly confused, because typesets don’t actually seem to be accessible from Ren-C itself. Or, at least, none seem to be defined — normal type names evaluate to TYPE-BLOCK!s as expected, but typeset names are unassigned:</p>
<pre><code class="lang-plaintext">&gt;&gt; word!
== &amp;[word]

&gt;&gt; text!
== &amp;[text]

&gt;&gt; any-utf8!
** Script Error: any-utf8! word is attached to a context, but unassigned
** Where: console
** Near: [any-utf8! **]
** Line: 1

&gt;&gt; any-type-value!
** Script Error: any-type-value! word is attached to a context, but unassigned
** Where: console
** Near: [any-type-value! **]
** Line: 1
</code></pre>
<p>[On which note, incidentally, let me yet again mention my conviction that the other TYPE-* datatypes are useless and should be removed.]</p>
<p>I expected to at least be able to use them in function signatures, but I can’t even do that, since it crashes a program:</p>
<pre><code class="lang-plaintext">&gt;&gt; test: func [x [word!]] [return x]
== ~#[frame! {test} [x]]~  ; anti

&gt;&gt; test: func [x [any-utf8?]] [return x]
== ~#[frame! {test} [x]]~  ; anti

&gt;&gt; test: func [x [any-utf8!]] [return x]
Assertion failure: QUOTE_BYTE(v) == ANTIFORM_0
Line 165, File: /home/bradrn/Documents/red/ren-c/src/include/cells/cell-quoted.h
Trace/breakpoint trap (core dumped)
</code></pre>
<p>So… if they can’t be accessed from Ren-C itself, then why does the interpreter have typesets at all?</p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/what-is-the-use-of-typesets/2153">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-is-the-use-of-typesets/2153</link>
          <pubDate>Tue, 20 Feb 2024 04:29:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2153</guid>
          <source url="https://forum.rebol.info/t/what-is-the-use-of-typesets/2153.rss">What is the use of typesets?</source>
        </item>
        <item>
          <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <h2>
<a name="the-limited-and-ambiguous-historical-idea-1" class="anchor" href="https://forum.rebol.info#the-limited-and-ambiguous-historical-idea-1"></a>The Limited and Ambiguous Historical Idea</h2>
<p>People are used to being able to do things like:</p>
<pre><code> x: 10
 switch type? x [
     integer! [print "It's an integer"]
     block! [print "It's a block"]
 ]

 assert [parse [1 [second] 'foo] [integer! block! lit-word!]]

 assert [find any-word! (type? first [x:])]
</code></pre>
<p>But the historical DATATYPE! and TYPESET! were strange.</p>
<ul>
<li>
<p>DATATYPE! rendered as a WORD! but was really wrapping an integer of 0-63</p>
</li>
<li>
<p>TYPESET! was a 64-bit bitset, one bit for each type (this is where the 64 types limit came from)</p>
<ul>
<li>
<p>it lost its meaning in rendering (it kept no record of what the set actually was...just dumped words for each bit)</p>
</li>
<li>
<p>not preserving the name from a fixed list of typesets was based on the concept you could make your own or UNION/INTERSECT them</p>
</li>
</ul>
</li>
</ul>
<p>So it looked like this:</p>
<pre><code>red&gt;&gt; type? 1
== integer!

red&gt;&gt; type? type? 1
== datatype!

red&gt;&gt; print mold any-word!
make typeset! [word! set-word! lit-word! get-word!]

red&gt;&gt; print mold any-type!
make typeset! [datatype! unset! none! logic! block! paren! string! file! url!
    char! integer! float! word! set word! lit-word! get-word! refinement! issue!
    native! action! op! function! path! lit-path! set-path! get-path! routine!
    bitset! object! typeset! error! vector! hash! pair! percent! tuple! map!
    binary! time! tag! email! handle! date! port! money! ref! point2D! point3D!
    image! event!]
</code></pre>
<h2>
<a name="the-type-xxx-approach-2" class="anchor" href="https://forum.rebol.info#the-type-xxx-approach-2"></a>The TYPE-XXX! Approach</h2>
<p>So Ren-C attacked the ambiguity and extensibility with a new word type, TYPE-WORD!.  Then typesets used TYPE-GROUP! and TYPE-BLOCK!, referencing functions to act as type testing predicates, and using groups for intersections and blocks for unions:</p>
<pre><code>&gt;&gt; type of 1
== &amp;integer

&gt;&gt; type of type of 1
== &amp;type-word

&gt;&gt; print mold any-word!
&amp;(any-word?)

&gt;&gt; print mold any-value!
&amp;(any-value?)
</code></pre>
<p>This gives some realistic axis of extensibility, and gives distinguishable entities that can trigger behaviors in PARSE when something looks up to type-xxx!.  (this shows why using WORD! or URL! or ISSUE! wouldn't work, because the type intent has to be carried by what e.g. INTEGER! looks up to.)</p>
<p><strong>Calling functions to implement type checks vs. checks on a bitset, especially when an array of functions must be called when checking every parameter in every function call, is a difficult performance point.</strong></p>
<p><a href="https://forum.rebol.info/t/intrinsics-functions-without-frames/2050">Intrinsics and other magic are employed to rein it in.</a>  It's not particularly simple...but finding ways to speed up function calls where you can has systemic benefit.</p>
<h2>
<a name="new-consequence-find-must-find-type-word-normally-3" class="anchor" href="https://forum.rebol.info#new-consequence-find-must-find-type-word-normally-3"></a>New Consequence: FIND Must Find TYPE-WORD! Normally</h2>
<p>Being a legitimate datatype that can be stored in a block, some interpretations of datatype by functions like FIND were problematic:</p>
<pre><code>red&gt;&gt; block: reduce ["hello" integer! 1]
== ["hello" integer! 1]

red&gt;&gt; find block 'integer!
== none  ; rendering was a lie

red&gt;&gt; find block integer!
== [1]
</code></pre>
<p>You couldn't find a literal datatype in a block.  Ren-C is approaching this by saying FIND has to find the TYPE-WORD! (as it does for all non-antiforms), but that you can use antiform actions as predicates.</p>
<pre><code>&gt;&gt; block: reduce ["hello" integer! 1]
== ["hello" &amp;integer 1]

&gt;&gt; find block integer!
== [&amp;integer 1]

&gt;&gt; find block :integer?
== [1]
</code></pre>
<p>There was some thought that maybe you could create antiform TYPE-XXX! and call them "matchers", passing them to FIND.</p>
<ul>
<li>
<p>But this is an isotope for each TYPE-XXX!, so it's not even like there would be one "matcher"</p>
</li>
<li>
<p>It also would be the only instance of antiforms of types with sigils, which doubles the sigil to make <strong><code>~&amp;integer~</code></strong>, which I find kind of displeasing</p>
</li>
</ul>
<p>I feel that antiform actions cover it for FIND, and if you have higher level needs you should use something like PARSE which has richer options and isn't beholden to quite the "mechanical" answer that a series primitive like FIND has to abide by with its limited parameterization.</p>
<h2>
<a name="new-annoyance-type-of-quotes-and-antiforms-4" class="anchor" href="https://forum.rebol.info#new-annoyance-type-of-quotes-and-antiforms-4"></a>New Annoyance: TYPE OF Quotes And Antiforms</h2>
<p>When there were only two datatypes with quotedness, the quote was part of their datatype:</p>
<pre><code>red&gt;&gt; type? first ['a]
== lit-word!

red&gt;&gt; type? first ['a/b]
== lit-path!

red&gt;&gt; lit-word! = type? first ['a]
== true

red&gt;&gt; parse ['a 'a/b] [lit-word! lit-path!]
== true
</code></pre>
<p>Ren-C's approach affords the ability make type constraints to carry forward the PARSE behavior.  But the TYPE OF all quoteds is the same... &amp;QUOTED.</p>
<pre><code>&gt;&gt; lit-word?!
== &amp;(lit-word?)

&gt;&gt; lit-word?! = type of first ['a]
== ~false~  ; anti

&gt;&gt; type of first ['a]
== &amp;quoted
</code></pre>
<p>So perhaps you see the motivation to decorate as <strong>?!</strong> instead of just <strong>!</strong> for the type constraints.  People need to know that these aren't fundamental types.  You have to use e.g. MATCH with them:</p>
<pre><code> &gt;&gt; match lit-word?! first ['a]
 == 'a

 &gt;&gt; match lit-word?! 10
 == ~null~  ; anti

 &gt;&gt; match [lit-word?] first ['a]  ; alternative as 1st slot known "typelike"
 == 'a
</code></pre>
<p>This is something of a pain point, and I'm not entirely settled on whether it would be good to delve into some kind of ambiguity where we are actually allowed to get back constraint functions as the answer to TYPE OF, and make that the fundamental:</p>
<pre><code>&gt;&gt; type of 1
== &amp;integer?

&gt;&gt; type of spread [a b]
== &amp;splice?

&gt;&gt; type of ~true~
== &amp;logic?

&gt;&gt; type of first ['a]
== &amp;quoted? 
</code></pre>
<p>So I don't think this is a good idea for the quoted types, but for the antiforms it might be a narrow enough thing that it provides "what the people want".</p>
<pre><code>&gt;&gt; switch type of true [
     splice! [...]
     logic! [...]
     integer! [...]
  ]
</code></pre>
<p>Barring that, what we have to do today is flip SWITCH over into a MATCH mode (currently called SWITCH/TYPE but should probably be SWITCH/MATCH... or maybe it should take the MATCH name):</p>
<pre><code>&gt;&gt; switch/type true [
     splice?! [...]
     logic?! [...]
     integer! [...]
  ]
</code></pre>
<p>Note that the <code>?!</code> distinction is a new idea which hasn't made it to all type constraints yet, e.g. ANY-VALUE! is still as it was.  But because parameters use what is effectively a TYPE-BLOCK! you can say <strong><code>any-value?</code></strong> or <strong><code>splice?</code></strong> in them instead of going through the extra step.</p>
<h2>
<a name="should-type-be-a-bigger-concept-5" class="anchor" href="https://forum.rebol.info#should-type-be-a-bigger-concept-5"></a>Should TYPE Be A Bigger Concept?</h2>
<p>One thing that has nagged me is if when we ask for the fundamental "cell type" of something, if we should avoid using the word "TYPE" for that at all...</p>
<p>Maybe there's some bigger idea in an object/class system where TYPE is meaningful to say something more than "this is an object" but rather "this is a book", where you can ask also "is a book readable".  Etc.</p>
<p>Or maybe TYPE can be parameterized:</p>
<pre><code> &gt;&gt; type of matrix
 == &amp;[matrix 10x10]
</code></pre>
<p>So this would mean there's a smaller question about the fundamental type, maybe call it "KIND":</p>
<pre><code>&gt;&gt; kind of [a b c]
== &amp;block

&gt;&gt; kind of matrix
== &amp;object
</code></pre>
<p>It would be nice to just be able to say "64 types is enough for anyone" and say "there, it's done".  I'd be happy to do that if I felt that it was enough.  It wasn't, even when thinking along fairly limited lines that don't go in these fancier directions.</p>
<p><em>I don't think any near-term system will actualize on bigger visions of what TYPE might be, but it would help to know if that should be ruled out or not, just in order to pick the term KIND or TYPE!</em>  But even that question is murky.</p>
<h2>
<a name="some-related-reading-typesr-6" class="anchor" href="https://forum.rebol.info#some-related-reading-typesr-6"></a>Some Related Reading: %types.r</h2>
<p>The dialected table used to construct the type testing macros and other things is kind of neat, though some comments are out of date and parts of it need updating (it's getting upgraded in an upcoming commit which finally breaks the 64-type barrier and introduces the $ types):</p>
<p>See <a href="https://github.com/metaeducation/ren-c/blob/master/src/boot/types.r"><strong>%types.r</strong></a></p>
            <p><small>20 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151</link>
          <pubDate>Fri, 16 Feb 2024 23:29:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2151</guid>
          <source url="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
        </item>
        <item>
          <title>A proliferation of $#@^&#39;:~WORD~:s</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>One of the things which surprised me when I first looked into Ren-C was the number of WORD variants it has. By my count, this includes:</p>
<ul>
<li>plain WORD</li>
<li>:GET-WORD</li>
<li>SET-WORD:</li>
<li>
<code>@THE-WORD</code> *</li>
<li>^META-WORD</li>
<li>&amp;TYPE-WORD</li>
<li><span class="hashtag">#ISSUE</span></li>
<li>'QUOTED</li>
<li>~ANTIFORM~</li>
<li>…and probably more that I’ve forgotten.</li>
</ul>
<p><small>* monospaced so Discourse doesn’t think it’s a ping</small></p>
<p>Now, in many ways this is perfectly expected for a language like Ren-C. Firstly, dialecting means we value having as many syntactic options as possible. Secondly, Ren-C has a lot of different kinds of values — plain, quoted, anti and quasi, and now bound and unbound versions of each — and most of these words are simply making it easier to deal with that huge variety.</p>
<p>But, on the other hand, I feel we’re starting to encounter some problems with the current way of doing things. Most notably:</p>
<ol>
<li>None of this is compositional. When we <a href="https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359/7">run into a situation</a> where we’d like to, say, have a word which is both META- and THE-, it’s impossible.</li>
<li>Some dialects would like to use words outside this fixed inventory. For instance, it would be nice to have <a href="https://forum.rebol.info/t/upcoming-datatype-word-what-will-it-mean/2146">$WORDs to use in a shell dialect</a>.</li>
</ol>
<p>The root cause of both is the same: the inventory of word-like datatypes is hard-coded into the interpreter. If you want to use something outside that set, you can’t, no matter how similar to the existing types it may seem.</p>
<p>I can imagine a hypothetical design which would avoid this. This would allow some characters to be freely added to the beginning and end of words — let’s call those special characters ‘sigils’, like in Perl. Every combination of sigils would then specify a separate datatype. So you would still have :WORDs and ^WORDs and ~WORD~s, but also $WORDs and ^@WORDs and ~#WORD&amp;s and whatever else you could imagine. This would quite easily solve both of the problems I mentioned.</p>
<p>One might even contemplate generalising this ‘sigil’ idea to non-word types. We already have {GET,SET,THE,META}-{BLOCK,GROUP}s, so it would make sense to allow arbitrary sigils on blocks and groups too.</p>
<p>Unfortunately, I’m not sure this would work with the current design of Ren-C. At the moment, there is currently a hard maximum of (as I recall) 256 possible datatypes, whereas this proposal obviously allows for an infinite amount of datatypes. However, I do think it’s at least worth thinking about, for the simple reason that it would give us a lot more flexibility than we currently have.</p>
            <p><small>10 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/a-proliferation-of-word-s/2147">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/a-proliferation-of-word-s/2147</link>
          <pubDate>Tue, 13 Feb 2024 12:58:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2147</guid>
          <source url="https://forum.rebol.info/t/a-proliferation-of-word-s/2147.rss">A proliferation of $#@^&#39;:~WORD~:s</source>
        </item>
        <item>
          <title>Upcoming Datatype $WORD... What Will It Mean?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Something that has been nagging at me is that I've known I want to introduce <strong>$WORD</strong>, <strong>$(GR O UP)</strong>, <strong>$TU.P.LE</strong> etc. (tentative names VAR-WORD!, VAR-GROUP!, VAR-TUPLE!).</p>
<p>At first glance it seems like it would be a loss if $XXX didn't in the baseline evaluator evaluate to looking up environment variables.</p>
<p>But this would be a different behavior for an ANY-WORD!...which up until now, the type of word has not mattered.  Would it spread to SET?</p>
<pre><code>&gt;&gt; set-env "SOMETHING" "TRUE"

&gt;&gt; SOMETHING: 10

&gt;&gt; set (in [] '$SOMETHING) "FALSE"
== "FALSE"

&gt;&gt; SOMETHING
== 10

&gt;&gt; get-env "SOMETHING"
== "FALSE"
</code></pre>
<p>Hmmm.  Lots of issues there...including that Unix environment variables are case-sensitive, Windows ones are not.</p>
<p>The implementation mechanism of this would presumably have to introduce some sort of "pseudo-object" named <code>environment</code>/<code>env</code>, and then the "specifier" would have to say (in a similar way to which the ".WORD" lookups would say to look in a "current object") that the $ words should look up in env.   <em>(See related discussion about <a href="https://forum.rebol.info/t/binding-indirection/2112">"Binding Indirection"</a>)</em></p>
<h2>
<a name="simpler-thought-1" class="anchor" href="https://forum.rebol.info#simpler-thought-1"></a>Simpler Thought...</h2>
<p>A simpler thought (that doesn't rock the boat for one feature) would be that this is a bridge too far for an ANY-WORD!, and they should look up just like any other word, and it's only weird shell dialects that would think that a $WORD meant environment variables.</p>
<p>But then the question might be what the $ buys you.</p>
<p>Maybe I was too hasty in saying that the @ was the right thing to sacrifice for "get variable with binding", and $ should have done that?</p>
<pre><code>&gt;&gt; $word
== word  ; bound

&gt;&gt; @word
== @word  ; bound?
</code></pre>
<p>(A line of argumentation that <code>@word</code> should be bound, is that if you want an unbound one you can get it by quoting with <code>'@word</code>, but then again if the @ operator does not bind e.g. @ foo... but $ does, e.g. $ foo.  So maybe not affecting the binding is the better choice.)</p>
<p>This would let us put back the @ for "as-is" variable usage in parse.  And it would make more sense for a thing named VAR-WORD! (bound variable in evaluator, environment var in shell dialect...)</p>
<p>Urrrgh.  I hate that it seems like that's probably right.  :-/   <em>(Thankfully, git lets us audit/reverse such decisions...assuming you're diligent about not changing too many unrelated things in one commit, which I thankfully was careful about with the @ change.)</em></p>
<h2>
<a name="loss-of-for-weird-idea-i-had-2" class="anchor" href="https://forum.rebol.info#loss-of-for-weird-idea-i-had-2"></a>Loss of $ For Weird Idea I Had</h2>
<p>If the $ operator were used for binding that would be a bit sad, as I'd kind of hoped that could be a variadic function that could run the <a href="https://github.com/metaeducation/ren-c/blob/3e5f724197f55d2745436a52ca1dfa7c5d7e4db5/scripts/shell.r#L4">shell dialect</a>:</p>
<pre><code>extension: "txt"

$ ls -alF *.(extension)
</code></pre>
<p>But, maybe that's a bad way to package it in the box, and specialty scripts that don't care about a $ operator for binding purposes can override it, encouraging the more traditional:</p>
<pre><code>extension: "txt"

shell [ls -alF *.(extension), echo $SOMETHING]
</code></pre>
            <p><small>11 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/upcoming-datatype-word-what-will-it-mean/2146">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/upcoming-datatype-word-what-will-it-mean/2146</link>
          <pubDate>Tue, 13 Feb 2024 11:51:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2146</guid>
          <source url="https://forum.rebol.info/t/upcoming-datatype-word-what-will-it-mean/2146.rss">Upcoming Datatype $WORD... What Will It Mean?</source>
        </item>
        <item>
          <title>Meaning of META-BLOCK! ^[...]</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>META-GROUP! takes the evaluative behavior of GROUP! and metas the product:</p>
<pre><code>&gt;&gt; (1 + 2)
== 3

&gt;&gt; ^(1 + 2)
== '3

&gt;&gt; (find [a b c] 'd)
== ~null~  ; anti

&gt;&gt; ^(find [a b c] 'd)
== ~null~
</code></pre>
<p>That makes sense.  But what should META-BLOCK! do?</p>
<p>META-BLOCK! actually does something parallel to the evaluator's META-GROUP! in PARSE.  Because in PARSE, the blocks are not "inert".  It means give back the meta form of what the block rule synthesizes.</p>
<pre><code>&gt;&gt; parse "aaab" [some ^["a" | opt "b"]]
== ~null~
</code></pre>
<p>So there you got a quasiform and not an antiform of null (from the match of the optional "b" not being there).</p>
<p>But in the main evaluator, it currently just quotes the block:</p>
<pre><code>&gt;&gt; ^[a b c]
== '[a b c]
</code></pre>
<p>A synonym for <strong>quote [a b c]</strong>.  Pretty useless, right?</p>
<h2>
<a name="maybe-not-useless-1" class="anchor" href="https://forum.rebol.info#maybe-not-useless-1"></a>Maybe Not Useless...</h2>
<p>Consider my desire to have a proper FOR dialect.</p>
<pre><code> &gt;&gt; for x [1 to 3] [print x]
 1
 2
 3
</code></pre>
<p>And then, the concept of "going meta" struck me as interesting:</p>
<pre><code> &gt;&gt; for x meta [1 to 3] [print x]
 1
 to
 3
</code></pre>
<p>Which would mean that FOR when given a quoted block would enumerate its contents vs. run the dialect.  Then you could also write that as:</p>
<pre><code> &gt;&gt; for x ^[1 to 3] [print x]
 1
 to
 3
</code></pre>
<p>It would even be semantically different if it did not bind the block, e.g. acted as a synonym for <strong><code>meta '[1 to 3]</code></strong></p>
<p>Cute, but we don't want to generalize it to groups, <strong><code>^(...)</code></strong> needs to evaluate the group and give the meta result.  So this would be specifically for taking blocks up a meta level.</p>
<p>I guess we'll have to see how it plays out.  I can't think of another behavior at the moment.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/meaning-of-meta-block/2145">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/meaning-of-meta-block/2145</link>
          <pubDate>Mon, 29 Jan 2024 08:50:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2145</guid>
          <source url="https://forum.rebol.info/t/meaning-of-meta-block/2145.rss">Meaning of META-BLOCK! ^[...]</source>
        </item>
        <item>
          <title>Should ANY-VALUE! Include Stable Antiforms?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>If you don't put any type restrictions on a parameter, it will allow antiforms:</p>
<pre><code> &gt;&gt; foo: func [x] [probe x]

&gt;&gt; foo null
~null~  ; anti
</code></pre>
<p>And right now, that is a full synonym for ANY-VALUE!.</p>
<pre><code> &gt;&gt; foo: func [x [any-value!]] [probe x]

&gt;&gt; foo null
~null~  ; isotope
</code></pre>
<p><strong>But what if you want to exclude antiforms, and only accept things that can legally be put in blocks?</strong></p>
<p>We could have a name for the typeset excluding antiforms.  ANY-ARRAY-ITEM! would be pedantically explicit, but seems accurate enough.</p>
<p>Or we could say that ANY-VALUE! doesn't include antiforms by default, and so you have to write <strong>[any-value! antiform!]</strong> if you want them.  Or just include the specific ones you intend (like <strong>[null! any-value!]</strong>).</p>
<p>However, the code has a meaning for Value*, and it really is pretty much literally <em>"the kind of state that can be held by a variable"</em>.  So I think we need another name.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-any-value-include-stable-antiforms/2026">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-any-value-include-stable-antiforms/2026</link>
          <pubDate>Fri, 14 Apr 2023 21:37:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2026</guid>
          <source url="https://forum.rebol.info/t/should-any-value-include-stable-antiforms/2026.rss">Should ANY-VALUE! Include Stable Antiforms?</source>
        </item>
        <item>
          <title>Should Antiforms Be Legal in MAP! (Keys, Values?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>In the pre-isotopic era, there was a concept that MAP! would not allow you to store nulls.  Because null was the signal of not being in a map.  Assigning a key null was a way of removing items from that map.</p>
<pre><code>&gt;&gt; m: make map! [x 20]
== make map! [
    x 20
]

&gt;&gt; m.x
== 20

&gt;&gt; m.y
; null

&gt;&gt; m.x: null
; null

&gt;&gt; m
== make map! [
]
</code></pre>
<p>Additionally, NULL was not allowed as a key.</p>
<h2>
<a name="how-should-this-change-in-the-isotopic-era-1" class="anchor" href="https://forum.rebol.info#how-should-this-change-in-the-isotopic-era-1"></a>How Should This Change In The Isotopic Era?</h2>
<p>We still have the case that mapping to null (or void, that causes null retrieval?) would conflate with testing for presence or absence in the map.</p>
<p>I'll make the point that not allowing you to store antiforms as keys or values isn't a fundamental problem, because you can META a value to put it in, and then UNMETA it when taking it out.</p>
<h2>
<a name="disallowing-widens-the-gap-with-objects-2" class="anchor" href="https://forum.rebol.info#disallowing-widens-the-gap-with-objects-2"></a>Disallowing Widens The Gap With Objects</h2>
<p>There have been questions about what the difference is between maps and objects, and this would be another: objects must be able to have members that are isotopes: action isotopes that can run implicitly, logic and null and other word isotopes, and I'm presuming splices and other stable forms as well.</p>
<p>It would mean a map has more in common with a block...more easily being converted to or from it.</p>
<p><strong>I don't know right now whether to allow or disallow.  So for starters I am going ahead with the premise that antiforms can't be stored in maps, as either keys or values.</strong>  We'll see how it goes.  If it is relaxed, it will be relaxed only for the values...in order to have parity with objects.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-antiforms-be-legal-in-map-keys-values/1995">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-antiforms-be-legal-in-map-keys-values/1995</link>
          <pubDate>Fri, 02 Dec 2022 09:28:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1995</guid>
          <source url="https://forum.rebol.info/t/should-antiforms-be-legal-in-map-keys-values/1995.rss">Should Antiforms Be Legal in MAP! (Keys, Values?)</source>
        </item>
        <item>
          <title>Where to use BLANK vs TRASH</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>I realized while thinking about what the right default for ARRAY would be, that there are two potentially sensible choices for a default... both of them single-character reified placeholders:</p>
<pre><code>[1]  &gt;&gt; array 3
     == [_ _ _]  ; BLANK!s

[2]  &gt;&gt; array 3
     == [~ ~ ~]  ; Quasi-BLANK!s ("TRASH!")
</code></pre>
<h2>
<a name="this-offers-us-some-nuance-even-if-a-state-must-be-reified-1" class="anchor" href="https://forum.rebol.info#this-offers-us-some-nuance-even-if-a-state-must-be-reified-1"></a>This Offers Us Some Nuance Even If A State Must Be Reified!</h2>
<p>When it comes to the direct behavior of APPEND to a block, these states have to work the same.  In the era of isotopes, all reified values are appended as-is... it cannot (and should not) be any more complex:</p>
<pre><code>&gt;&gt; append [a b] second [c _]
== [a b _]

&gt;&gt; append [a b] second [c ~]
== [a b ~]

&gt;&gt; append [a b] second [c [d e]]
== [a b [d e]]
</code></pre>
<p><strong>But when we throw in an extra operation, we can imagine a difference.</strong>  For instance, we could make BLANK! semantically equivalent to an empty array for the purposes of things like SPREAD or EMPTY?</p>
<pre><code>&gt;&gt; spread second [c []]
== ~()~  ; anti

&gt;&gt; spread second [c _]
== ~()~  ; anti

&gt;&gt; append [a b] spread second [c _]
== [a b]

&gt;&gt; empty? second [c _]
== ~true~  ; anti
</code></pre>
<p>...and then we'd say that if you tried to do such things with a "meta-nothing" trash state, it would be an error:</p>
<pre><code>&gt;&gt; spread second [c ~]
** Error: SPREAD does not accept ~ as an argument
</code></pre>
<p><em>I think this suggests that <code>~</code> makes a better choice for the default value of ARRAY elements!</em>  We can't default to an antiform like the one representing unset variables, but it's the closest thing.</p>
<p><em>Ultimately it came to seem that having only the antiform ~null~ be a "branch inhibitor" was more valuable than having BLANK! be a "branch inhibitor".</em>  Simply being able to assume that anything you can find in an array will run a branch offered more leverage.  So blanks are "branch triggers" now, BUT they're empty.</p>
<h2>
<a name="what-about-opting-out-of-as-is-appends-etc-2" class="anchor" href="https://forum.rebol.info#what-about-opting-out-of-as-is-appends-etc-2"></a>What About Opting Out Of As-Is Appends, etc?</h2>
<p>I mentioned that all items that can be found in a block have to act mechanically identically when it comes to TAKE-ing and APPEND-ing them.  But what would XXX be if you wanted the following?</p>
<pre><code>&gt;&gt; append [a b] xxx second [c [d e]]
== [a b [d e]]

&gt;&gt; append [a b] xxx second [c _]
== [a b _]

&gt;&gt; append [a b] xxx second [c ~]
** Error: Cannot append NOTHING (~ antiform) to a block
</code></pre>
<p>I'm trying having this operator <a href="https://forum.rebol.info/t/reify-and-degrade-a-narrower-meta-and-unmeta/2163">be called DEGRADE</a>.  It would turn all quasiforms into their corresponding antiform:</p>
<pre><code>&gt;&gt; degrade first [~null~]
== ~null~  ; anti

&gt;&gt; degrade first ['foo]
== 'foo

&gt;&gt; degrade first [123]
== 123
</code></pre>
<p>The reverse of this operator would be REIFY.</p>
<h2>
<a name="what-about-for-each-variations-3" class="anchor" href="https://forum.rebol.info#what-about-for-each-variations-3"></a>What About FOR-EACH Variations?</h2>
<p>I think an additionally neat spin on how these can be treated differently can be how FOR-EACH responds.</p>
<pre><code>&gt;&gt; for-each x (second [c []]) [
       print "Loop never runs"
   ]
== ~void~  ; anti

&gt;&gt; for-each x (second [c _]) [
       print "Loop never runs"
   ]
== ~void~  ; anti

&gt;&gt; for-each x (degrade second [c ~void~]) [
       print "Loop never runs"
   ]
== ~null~  ; anti (like a void in, null out... or if a BREAK was hit)

&gt;&gt; for-each x (second [c ~]) [
       print "Loop never runs"
   ]
** Error: FOR-EACH does not accept TRASH as its data argument
</code></pre>
<p>This is a bit more speculative, but I like the general idea that a quasi void could let you have a kind of nothing that gave you the "opt out" ability in places where it could... and quasi blank could give you an error, while blank acts like an empty series.  This seems to offer some nice invariants that reduce overall code you have to write handling edge cases.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/where-to-use-blank-vs-trash/2285">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/where-to-use-blank-vs-trash/2285</link>
          <pubDate>Wed, 30 Nov 2022 04:00:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2285</guid>
          <source url="https://forum.rebol.info/t/where-to-use-blank-vs-trash/2285.rss">Where to use BLANK vs TRASH</source>
        </item>
        <item>
          <title>What Should TYPE OF an Antiform Be?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>At this exact moment (in Sep 2022)...TYPE OF any antiform is an error, while both TYPE OF NULL and TYPE OF VOID give back NULL.</p>
<p>OF is a generic operation (the enfix form of REFLECT that quotes the word on its left.  It may be desirable to honor the VOID-in-NULL out convention for all the other reflectors that aren't TYPE... and it's desirable to error on NULL more generically.</p>
<pre><code>&gt;&gt; label of null
** Error: You didn't give anything

&gt;&gt; label of maybe null  ; MAYBE NULL is VOID 
; null
</code></pre>
<p>So if <strong>type of</strong> follows the same pattern as other <strong>xxx of</strong>, we'd surmise that you don't use TYPE OF to discern NULL and VOID.  It errors on NULL input and gives you back NULL if you MAYBE it.</p>
<p>But what happens when you ask:</p>
<pre><code>&gt;&gt; spread [d e]
== ~(d e)~  ; anti

&gt;&gt; type of spread [d e]
???
</code></pre>
<h2>
<a name="the-original-plan-was-no-arguments-received-antiforms-1" class="anchor" href="https://forum.rebol.info#the-original-plan-was-no-arguments-received-antiforms-1"></a>The Original Plan Was <em>No</em> Arguments Received Antiforms</h2>
<p>In the original conception, function frames weren't capable of holding antiforms in the arguments.  You physically could not receive a parameter that was an antiform.</p>
<p>I was also looking at the idea that some antiforms--such as raised ERROR!--would be completely impossible to get into a variable, <em>ever</em>.</p>
<p>The only workaround was if a function used the ^META parameter convention, in which case an antiform would come in as a QUASI! form of the value...while normal values would come in as one level quoted higher than they were:</p>
<pre><code> &gt;&gt; detector: func [^x] [print ["Meta of X:" mold x]]

 &gt;&gt; detector [d e]
 Meta of X: '[d e]

 &gt;&gt; detector spread [d e]
 Meta of X: ~(d e)~
</code></pre>
<p>Ultimately I backed down on this, instead allowing you to use type predicates to narrow which antiforms you'd be willing to accept:</p>
<pre><code>&gt;&gt; splicetaker: func [x [any-value! splice?]] [
       append [a b c] :x
   ]

&gt;&gt; splicetaker [d e]
== [a b c [d e]]

&gt;&gt; splicetaker spread [d e]
== [a b c d e]
</code></pre>
<p>A primary driver behind this change was that operations which wanted to do things like ADAPT a function frame were having to become sensitive to whether a parameter was ^META or not.  It seemed that standardizing the frame in a way that permitted antiforms as currency made more sense than having arguments be sometimes-meta'd, sometimes not.</p>
<p><em>(Note: A later driver of this was that <a href="https://forum.rebol.info/t/why-theres-no-boolean-type-storable-in-a-block/2095">LOGIC became implemented with antiforms</a>, and needing to make a parameter meta to take logic was another bridge-too-far.)</em></p>
<h2>
<a name="what-if-of-reflect-didnt-take-antiforms-2" class="anchor" href="https://forum.rebol.info#what-if-of-reflect-didnt-take-antiforms-2"></a>What if OF (REFLECT) Didn't Take Antiforms?</h2>
<p>So we could say that if you think you have an antiform in your hand, you're responsible for ^META-ing it yourself:</p>
<pre><code>&gt;&gt; metatyper: func [x [any-value! splice?]] [
       print ["Metatype of X is" type of ^x]
   ]

&gt;&gt; metatyper [d e]
== &amp;['block]  ; the TYPE OF received a QUOTED!, so e.g. answer incorporates quoted

&gt;&gt; metatyper spread [d e]
== &amp;[~block~]  ; got QUASI!, so TYPE OF answer incorporates quasi
</code></pre>
<p>On the plus side of such an approach, we don't have to invent any type representations for antiforms.</p>
            <p><small>6 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/what-should-type-of-an-antiform-be/1983">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-should-type-of-an-antiform-be/1983</link>
          <pubDate>Sat, 24 Sep 2022 10:23:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1983</guid>
          <source url="https://forum.rebol.info/t/what-should-type-of-an-antiform-be/1983.rss">What Should TYPE OF an Antiform Be?</source>
        </item>
        <item>
          <title>Applications of Isotopic Objects</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Consider the example of a function that might want to have two modes... one that prints out readable information for the console, and another that keeps the data in easily processable form.</p>
<p>Traditionally you might think of controlling this with a refinement:</p>
<pre><code>&gt;&gt; stats
-------------------
Column 1   Column 2
-------------------
Alpha      10
Beta       20

&gt;&gt; stats/only
== [
    [Alpha 10]
    [Beta 20]
]
</code></pre>
<p>But then I wondered: what if there was only one isotopic result...that wrapped the data with functions?  So long as things stayed isotopic, you'd be able to get at the functions.  But it could decay to be the data.</p>
<pre><code>&gt;&gt; ^ stats
== ~#[object! [... decay: ... form: ...]]~

&gt;&gt; compose [statistics: (spread stats)]
== [statistics: [Alpha 10] [Beta 20]]

&gt;&gt; stats
-------------------
Column 1   Column 2
-------------------
Alpha      10
Beta       20

&gt;&gt; if true [print stats, &lt;PRINT could react to FORM also&gt;]
-------------------
Column 1   Column 2
-------------------
Alpha      10
Beta       20
== &lt;PRINT could react to FORM also&gt;
</code></pre>
<p>So PRINT would be special, and instead of allowing its argument to reify normally it would specifically examine isotopic arguments to see if they could FORM.</p>
<p>In this case, the isotopic thing needs to be able to do two things: FORM or DECAY.  But maybe it could do more things, if you asked it?  And maybe no particular methods are mandatory.  Something that doesn't know how to DECAY just won't do that.</p>
<p><strong>This looks kickass.</strong></p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/applications-of-isotopic-objects/1959">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/applications-of-isotopic-objects/1959</link>
          <pubDate>Sat, 03 Sep 2022 11:48:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1959</guid>
          <source url="https://forum.rebol.info/t/applications-of-isotopic-objects/1959.rss">Applications of Isotopic Objects</source>
        </item>
        <item>
          <title>Why Don&#39;t Splices Preserve Their List Type?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>The first concept of representing splices out of isotopes was actually to make them as antiform BLOCK!.</p>
<p>You'd get an antiform block regardless of the input to SPREAD:</p>
<pre><code>&gt;&gt; spread [d e]
== ~[d e]~  ; anti

&gt;&gt; spread '(d e)
== ~[d e]~  ; anti

&gt;&gt; spread @[d e]
== ~[d e]~  ; anti
</code></pre>
<p>From the perspective of things like APPEND, it doesn't matter:</p>
<pre><code>&gt;&gt; append [a b c] spread [d e]
== [a b c d e]

&gt;&gt; append [a b c] spread '(d e)
== [a b c d e]

&gt;&gt; append [a b c] spread @[d e]
== [a b c d e]
</code></pre>
<h2>
<a name="canonization-of-splices-is-important-1" class="anchor" href="https://forum.rebol.info#canonization-of-splices-is-important-1"></a>Canonization of Splices Is Important</h2>
<p>By canonizing splices to just one type, we recover the other list antiforms for other meanings that have nothing to do with splicing.  That subtlety would be lost if people had to think of every list type as being a splice.</p>
<p>It also helps you realize information is being thrown away.  Not only is the subclass of list forgotten, but any binding is removed too (!)</p>
<p>But which canon list form should it take?</p>
<h2>
<a name="group-seems-the-best-choice-2" class="anchor" href="https://forum.rebol.info#group-seems-the-best-choice-2"></a>GROUP! Seems The Best Choice</h2>
<ul>
<li>
<p><strong>It makes the canonization more obvious.</strong>  Since the input to SPREAD will typically be a BLOCK!, people will learn the type is not preserved quickly:</p>
<pre><code>&gt;&gt; spread [a b c]
== ~(a b c)~  ; anti
</code></pre>
</li>
<li>
<p><strong>Parentheses look softer and more permeable.</strong>  They already are "weaker" in that they do not "block" evaluation in the way a BLOCK! does.  So their softness makes it feel more reasonable to say that the edges aren't there.</p>
<p><em>(This semiotic permeability exists in other places where brackets and parentheses are juxtaposed... for instance in <a href="https://en.wikipedia.org/wiki/Interval_(mathematics)#Notations_for_intervals">interval notation</a>, where <strong>[10, 20)</strong> means "the numbers from 10 to 20 without including 20")</em></p>
</li>
</ul>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/why-dont-splices-preserve-their-list-type/1953">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/why-dont-splices-preserve-their-list-type/1953</link>
          <pubDate>Wed, 31 Aug 2022 21:11:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1953</guid>
          <source url="https://forum.rebol.info/t/why-dont-splices-preserve-their-list-type/1953.rss">Why Don&#39;t Splices Preserve Their List Type?</source>
        </item>
  </channel>
</rss>

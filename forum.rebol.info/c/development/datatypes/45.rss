<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Datatypes - AltRebol</title>
    <link>https://forum.rebol.info/c/development/datatypes/45</link>
    <description>Topics in the &#39;Datatypes&#39; category The datatypes category is for the discussion of the specific properties of datatypes themselves.  Sample topics might include:</description>
    
      <lastBuildDate>Thu, 25 Aug 2022 23:34:33 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/datatypes/45.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Thinking About Isotopes Logically: ~true~ and ~false~</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Here's an idea: what if <strong>~true~</strong> and <strong>~false~</strong> are examples of weird isotopic exceptions.</p>
<p>Let's say you could assign them to variables...and fetch them from variables...without erroring:</p>
<pre><code>&gt;&gt; true: ~true~
== ~true~  ; isotope

&gt;&gt; false: ~false~
== ~false~  ; isotope

&gt;&gt; obj: make object! [y: true, n: false]
== make object! [
     y: ~true~
     n: ~false~
]
</code></pre>
<p><em>(not being quoted in the assignment indicates they become their isotopic forms.)</em></p>
<p>This is typically not legal...accessing a WORD! isotope from a variable like true would be an error.  But these would be special (like how I'm suggesting isotopic ACTION! would be special in running the action from a word reference...)</p>
<p>Things that tested for truthiness would treat them as expected, considering the ~false~ isotope to be a falsey thing:</p>
<pre><code>&gt;&gt; any [true false]
== ~true~  ; isotope

&gt;&gt; all [true false]
; null
</code></pre>
<p><em>Being isotopes comes with a constraint</em>...you couldn't put them into blocks.  You'd have to ^META them (which would lose their special status, turning them into QUASI-WORD!s...that were truthy.</p>
<pre><code>&gt;&gt; ^ false
== ~false~

&gt;&gt; if ^ false [print "Meta false is truthy"]
Meta false is truthy
</code></pre>
<p>The functions TRUE? and FALSE? could then work on isotopic, non-isotopic, or word forms of TRUE and FALSE...but error if passed other values.</p>
<ul>
<li>
<p><strong>This should work for casual cases of just having variables that hold a true or false state...and gives a good appearance for knowing what you're looking at.</strong></p>
</li>
<li>
<p><strong>It builds on standard mechanisms, and hence if you need to promote the isotopic state into something that can be represented in a block you can do so... with the caveat that once you do, it will no longer reflect its logical property when used with IF and such.</strong></p>
<ul>
<li><strong>That's true for NULL being ^META promoted and put in blocks as well.</strong></li>
</ul>
</li>
</ul>
<p><strong>And crucially: Since you know isotopes can't be in blocks--and if we say BLANK! is truthy as well--then you'd be guaranteed to visit all the items in a block with code like this:</strong></p>
<pre><code>while [item: try take block] [
    print mold item
]
</code></pre>
<p>This is easily the best idea so far for dealing with the problem.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944</link>
          <pubDate>Thu, 25 Aug 2022 23:34:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1944</guid>
          <source url="https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944.rss">Thinking About Isotopes Logically: ~true~ and ~false~</source>
        </item>
        <item>
          <title>BLANK! 2022: Revisiting The Datatype</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Long, long ago there was a datatype called NONE.  In historical Redbol, it had the bad habit of looking like a WORD!:</p>
<pre><code>rebol2&gt;&gt; 'none
== none

rebol2&gt;&gt; none
== none  ; same in R3-Alpha and Red
</code></pre>
<p>But it wasn't a word:</p>
<pre><code>rebol2&gt;&gt; type? 'none
== word!

rebol2&gt;&gt; type? none
== none!
</code></pre>
<p>It was a distinct type, which also happened to be falsey (while WORD!s are truthy):</p>
<pre><code>rebol2&gt;&gt; if 'none [print "Truthy word!"]
Truthy word!

rebol2&gt;&gt; if none [print "Falsey none!"]
== none
</code></pre>
<p>And as we can see, NONE!s served purposes of signaling "soft failures": branches that didn't run, or FINDs that didn't find, or SELECTs that didn't select... etc.</p>
<pre><code>rebol2&gt;&gt; find "abcd" "z"
== none

rebol2&gt;&gt; select [a 10 b 20] 'c
== none
</code></pre>
<h2>Ren-C Divided NONE!s roles across NULL, VOID, and BLANK!</h2>
<ul>
<li>
<p><strong>NULL</strong> - a non-ANY-VALUE! state that couldn't be put in BLOCK!s.  Anywhere that NONE! would be used to signal a soft failure operation--like FIND or SELECT--would use NULL.</p>
<pre><code>&gt;&gt; find "abcd" "z"
; null

&gt;&gt; select [a 10 b 20] 'c
; null

&gt;&gt; append [a b c] null
** Error: APPEND doesn't allow NULL
</code></pre>
</li>
<li>
<p><strong>VOID</strong> - the "isotopic" form of NULL, which represents the result of things that are effectively "no ops".  Unlike nulls, they will vanish in-between expressions, and when functions like APPEND get them as an argument they are treated as no-ops:</p>
<pre><code>&gt;&gt; if null [print "Doesn't print as NULL is falsey"]
; void

&gt;&gt; 1 + 2 if null [print "Voids disappear..."]
== 3

&gt;&gt; append [a b c] void
== [a b c]
</code></pre>
<p>Void is also the state of unset variables.</p>
<pre><code>&gt;&gt; unset 'foo
; void

&gt;&gt; get/any 'foo
; void
</code></pre>
</li>
<li>
<p><strong>BLANK!</strong> was represented by a lone underscore ( <strong><code>_</code></strong> ) and could be put into blocks:</p>
<pre><code>&gt;&gt; append [a b c] _
== [a b c _]
</code></pre>
<p>It retained the choice to be falsey:</p>
<pre><code>&gt;&gt; if _ [print "Won't print because blanks are falsey"]
</code></pre>
</li>
</ul>
<h2>Question One: Could BLANK! Just Be A WORD! ?</h2>
<p>You might wonder if you could just say:</p>
<pre><code>&gt;&gt; _: '_
== _
</code></pre>
<p>This would give you BLANK! as a WORD! that had the behavior of reducing to itself.</p>
<pre><code>&gt;&gt; reduce [_ 1 + 2 _]
== [_ 3 _]
</code></pre>
<p>That could be just a default, and you could redefine it to anything you wanted.  Generally speaking, people do like being able to define words as operators... and _ has historically been a WORD! (Ren-C allows you to use underscores internally to words, so it feels a little bad to take away one word).</p>
<p>But outside of being hardcoded as falsey, what makes BLANK! fairly "built in" is that in the path mechanics, it fills in the empty slots:</p>
<pre><code>&gt;&gt; to path! [_ a]
== /a

&gt;&gt; as block! 'a//b//c
== [a _ b _ c]
</code></pre>
<p>Alternately, we could get a "reified nothing" with a quoted null:</p>
<pre><code>&gt;&gt; to path! [' a]
== /a

&gt;&gt; as block! 'a//b//c
== [a ' b ' c]
</code></pre>
<p>But there's other places the blank is used, such as to opt-out of multi-returns.</p>
<pre><code>&gt;&gt; [_ pos]: transcode "abc def"
; void

&gt;&gt; pos
== " def"
</code></pre>
<p>So freeing it up to be an arbitrary variable feels kind of wrong, as if it were taken for dialects like multi-return you'd be unable to set it as a variable.</p>
<p>This may be an argument for using something like a TAG! instead, so you're not worrying about overlapping with user variables:</p>
<pre><code>[&lt;_&gt; pos]: transcode "abc def"
</code></pre>
<p>Similar arguments have led me to contemplate the dangers of using things like <strong><code>[a b ...]:</code></strong> in case someone has assigned a meaning to the ellipsis.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:">  That might be a good reason to keep <strong><code>...</code></strong>  as a TUPLE! instead of a WORD! exception, because no one could assign it.</p>
<p><strong>I'm pretty sure we should keep _ reserved as a BLANK! datatype, not a WORD!.</strong>  People can still give it arbitrary meanings in dialects, they just can't assign values to it as a variable... and they can't do that with <strong><code>#</code></strong> either or <strong><code>&lt;a&gt;</code></strong> so I can live with it.  Taking it away from the word pool does more good than harm.</p>
<h2>Question Two: Does BLANK! Still Need To Be Falsey?</h2>
<p><em>My feeling is that having blank be falsey doesn't have all that much benefit.</em>  NULL does a better job of it, and really what it does is mess with its usefulness as a placeholder:</p>
<pre><code>&gt;&gt; append [a b c] all [1 &lt; 2, 3 &lt; 4, _]
== [a b c _]  ; would seem nice, but gives error today since ALL is NULL
</code></pre>
<p>Thinking of BLANK! as being "null-like" in terms of non-valuedness is generally a hassle.  It makes you wonder about whether something like DEFAULT should think of it as being assigned or not:</p>
<pre><code>&gt;&gt; item: _

&gt;&gt; item: default [1 + 2]
== ???
</code></pre>
<p>In practice, I prefer the truly non-valued NULL (and its isotopic state of VOID) being the only cases that DEFAULT overwrites.  This is because NULL is far more useful than BLANK! when it comes to representing something that you think of as "not being assigned"... as you'll get errors when you try to use it places (e.g. in APPEND).  Trying to use it to represent nothingness invariably leads to stray appearances in blocks (Shixin wrote a lot of code to try to filter them out in Rebmake, prior to it being switched to NULLs)</p>
<p>Also, the asymmetry between BLANK! and NULL were part of a scheme to try and solve what Redbols called "NONE! propagation":</p>
<pre><code>&gt;&gt; second null
** Error: SECOND doesn't take NULL

&gt;&gt; try null
== _

&gt;&gt; second try null
== null
</code></pre>
<p><strong>We still want this general concept, but <a href="https://forum.rebol.info/t/definitional-errors-as-blank-in-null-out-alternative/1880/7">the new idea is that it's VOID which opts out</a> cleanly from these operations, and MAYBE is the operator that produces them.</strong></p>
<p>This makes more sense, and I think it bolsters the argument that BLANK! is less of a falsey-NULL relative...but more of a placeholder value.  I've said "blanks are to blocks what space is to strings".  And space is truthy:</p>
<pre><code>&gt;&gt; if second "a b" [print "Space is truthy"]
Space is truthy

&gt;&gt; if second [a _ b] [print "So why shouldn't blank be truthy?"]
???
</code></pre>
<p><strong>So I Suggest The Removal of BLANK! From Being Falsey</strong>.  This creates some incompatibility in Redbol (which has been using NONE! as a blank substitute).  But it's something that can be worked around.</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942</link>
          <pubDate>Thu, 25 Aug 2022 13:50:26 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1942</guid>
          <source url="https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942.rss">BLANK! 2022: Revisiting The Datatype</source>
        </item>
        <item>
          <title>Big Alien Proposal :flying_saucer: &quot;/REFINEMENTS&quot; Run Functions</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <blockquote>
<p><strong>UPDATE</strong>...This was tried out, and while interesting things were learned it ultimately didn't "feel right" <em>(in particular the competition of <code>/slash</code> for refinement and <code>/slash:</code> for function definition was more annoying than anticipated, and SET-PATH!s introduce a lot of complexity in places it wasn't needed.)</em>  See further down the thread.  It's informing new designs being tried out.</p>
</blockquote>
<hr>
<p>So far, <strong><code>/leading</code></strong> <strong><code>/slash</code></strong> <strong><code>/notation</code></strong> has just been evaluator inert, lining up with Rebol2 and Red and R3-Alpha:</p>
<pre><code>redbol&gt;&gt; /foo
== /foo
</code></pre>
<p>That inertness doesn't seem to get leveraged much.  And in Ren-C it's a particularly weak choice, since the evaluator has generic quoting to get you the literal result:</p>
<pre><code>ren-c&gt;&gt; '/foo
== /foo
</code></pre>
<p>Also, leading slash is an actual PATH!...encompassing arbitrary patterns like <strong><code>/lib.append/dup/part</code></strong>.  So I've always been wondering if there was some interesting evaluator behavior for it, like...</p>
<ul>
<li>
<p>...asking to pick from "global scope": if your function has an argument called ALL then /ALL might get you the definition outside your function?  (Something like <strong><code>::foo</code></strong> in C++)</p>
</li>
<li>
<p>...maybe a shorthand for <strong><code>self/foo</code></strong> for picking members out of objects inside of methods?</p>
</li>
</ul>
<p>Yet nothing has ever really stuck.  But <a class="mention" href="/u/ingohohmann">@IngoHohmann</a> pointed out that there's a basic thing that leading slashes might do for us which may have been overlooked...</p>
<p>...<em>simply running functions</em>.</p>
<h2>"But WORD!s Run Functions, Why Should /FOO Do That?"</h2>
<p>There are many reasons, but the biggest one is...</p>
<hr>
<p><strong>I feel pretty much 100% certain it is time that we switched to a world <em>where not all WORD!s holding ACTION!s will run them.</em></strong></p>
<hr>
<p>It's too cumbersome when writing generic code to worry that a value you got "from somewhere" and put into a SET-WORD! has to be handled with special operators:</p>
<pre><code> &gt;&gt; var: select obj 'item
 &gt;&gt; if integer? var [print "INT"]
 Muhaha the next thing at your callsite was [print "INT"]  ; eek, VAR was action

 &gt;&gt; var: first block
 &gt;&gt; if integer? var [print "INT"]
 HAH! Did you think blocks were safe?  Not at all: [print "INT"]  ; in blocks too!
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/man_facepalming.png?v=9" title=":man_facepalming:" class="emoji only-emoji" alt=":man_facepalming:"></p>
<p>Whether you think of it in terms of "security"--or simply bugs and chaos--this <em>persistent tax</em> on Redbol code authors has lacked a palatable solution.  Putting a GET-XXX! on every access is ugly, and easy to forget.  What we've ended up with is a mishmash...where people are constantly forced to choose between deciding if the brokenness is likely enough to cause a problem that it's worth it to make the code ugly.</p>
<p>(When code ages, it's like it develops some sort of pox--as leading colons are added on an ad-hoc basis, then no one really knows if they're safe to remove.)</p>
<p><strong>I propose that only specially marked assignments would <em>automatically</em> run a function through a word reference, requiring a ^META access to get the action value literally.</strong></p>
<pre><code>&gt;&gt; /foo: func [x] [print ["X is" x]]

&gt;&gt; foo 10
X is 10

&gt;&gt; ^foo
== #[action! {foo} [x]]
</code></pre>
<p><strong>If a function is assigned through a plain SET-WORD!, then that would be inert by default...but able to take advantage of this new leading-slash execution.</strong></p>
<pre><code>&gt;&gt; foo: func [x] [print ["X is" x]]

&gt;&gt; foo
== #[action! {foo} [x]]

&gt;&gt; /foo 10
X is 10
</code></pre>
<h2>Compliance Isn't Actually That Ugly!</h2>
<p>If you look at the definition of an object, then annotating the member functions isn't really so bad:</p>
<pre><code>obj: make object! [
    data: 1
    /accessor: does [return data + 1]
]
</code></pre>
<p>This also gives us some extra ammo: <strong>it can explain why we would use OBJ/ACCESSOR to invoke the function, and why OBJ.ACCESSOR can act as an error</strong>.</p>
<p>That can clean up examples like this:</p>
<pre><code> &gt;&gt; error: trap [...]
 &gt;&gt; if integer? error.arg1 [print "INT"]
 You forgot to worry about TUPLE! too! [print "INT"]  ; aaaargh...
</code></pre>
<p>All we have to do is say that TUPLE! accesses like that can't run methods.  It would have to be <strong><code>error/arg1</code></strong> to run it... which would also confirm that it was actually defined as a method.  (Otherwise you'd run it with <strong><code>/error.arg1</code></strong> if it was just a random non-method field that happened to be a function.)</p>
<p>This would be a systemic solution to historical annoyances.</p>
<h2>It Can Be A Nice Dialecting Pattern</h2>
<p><strong>It's useful in dialects where plain WORD! references are taken for another meaning.</strong>  For instance, UPARSE by default assumes a word means a combinator, so if you want to run a function that uses parse rules to gather its arguments you need something else:</p>
<pre><code>&gt;&gt; parse [1] [/negate integer!]
== -1

&gt;&gt; parse [1 2] [/add integer! integer!]
== 3
</code></pre>
<p>Initially I tried this with terminal slashes, as <strong><code>negate/</code></strong> and <strong><code>add/</code></strong>, but that doesn't look as good (and separates the functions from their arguments).</p>
<h2>What Do We Lose?</h2>
<p>Because I was trying to think of a meaningful evaluator behavior for leading-slash values, I didn't do much with them.  But eventually I decided to use them in New Apply:</p>
<p><a href="https://forum.rebol.info/t/apply-ii-the-revenge/1834" class="inline-onebox">APPLY II: The Revenge!</a></p>
<p>They're nice because they break up the space:</p>
<pre><code>&gt;&gt; apply :append [[a b c] [d e] /dup 2]
== [a b c [d e] [d e]]
</code></pre>
<p>But SET-WORD! is reasonable at this, and commas can make it more visually separate if needed:</p>
<pre><code>&gt;&gt; apply :append [[a b c] [d e] dup: 2]
== [a b c [d e] [d e]]

&gt;&gt; apply :append [[a b c] [d e], dup: 2]
== [a b c [d e] [d e]]
</code></pre>
<p>Of course whatever we put here is being overloaded.  If you want a SET-WORD! for assignment purposes, you'd have to put it in a group:</p>
<pre><code>&gt;&gt; apply :append [(abc: [a b c]) [d e], dup: 2]
== [a b c [d e] [d e]]

&gt;&gt; abc
== [a b c]
</code></pre>
<p>So we could think of this similarly.  If you wanted to use a refinement-style path here, you just do it in a group:</p>
<pre><code>&gt;&gt; apply :append [(/reverse [a b c]) [d e], /dup 2]
== [c b a [d e] [d e]]
</code></pre>
<p><strong>APPLY is a dialect, and there are always going to be some tradeoffs made.</strong>   There's only so many parts.</p>
<p><strong>It's probably best to leave APPLY as it is.</strong>  I don't think we're going to be in the midst of some epidemic where suddenly every function invocation is done through a leading slash and it's going to be  contentious.  There will also be ways of running a function through REEVAL or maybe a dedicated RUN function that won't use the slash...</p>
<p>So nothing needs to be lost, really.</p>
<h2>The Big Win is that the <em>Obvious</em> Code is the <em>Correct</em> Code</h2>
<p>I've done some tentative implementation on all this, and all together, it seems pretty solid</p>
<p>Really all you're doing is paying the cost of an extra (easy-to-type) character to say that a word is intended to execute a function without needing to explicitly be told to.</p>
<p>There will be ways to subvert it, as of course you could do this:</p>
<pre><code>&gt;&gt; /func: enfix lambda [left [set-word!] spec body] [
       do compose [/(as word! left): lib/func (spec) (body)]
   ]

&gt;&gt; cheat: func [] [print "Breakin the law, breakin the law..."]

&gt;&gt; cheat
Breakin the law, breakin the law...
</code></pre>
<p>But we wouldn't make you do it that laboriously, if you're making something where words need to be associated with functions that run automatically.  And Redbol would do it through some evaluator parameterization as opposed to a mechanism like that.</p>
<p>However, the general expectation would be that most people would embrace the slash, as a useful piece of information...that makes everything work more coherently.</p>
            <p><small>12 posts - 5 participants</small></p>
            <p><a href="https://forum.rebol.info/t/big-alien-proposal-refinements-run-functions/1905">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/big-alien-proposal-refinements-run-functions/1905</link>
          <pubDate>Fri, 29 Jul 2022 08:34:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1905</guid>
          <source url="https://forum.rebol.info/t/big-alien-proposal-refinements-run-functions/1905.rss">Big Alien Proposal :flying_saucer: &quot;/REFINEMENTS&quot; Run Functions</source>
        </item>
        <item>
          <title>The Pending New Meaning of GET-XXX!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>If you've been following along with things like <a href="https://forum.rebol.info/t/the-long-awaited-death-of-only/1607">The Solution to Block Splicing</a> or <a href="https://forum.rebol.info/t/attack-of-the-activated-actions/1900">Activated Actions</a>, it seems to suggest that GET-WORD! and friends would no longer be necessary.</p>
<ul>
<li>
<p>If you have a non-isotopic value (including an ACTION!), you access it with a plain WORD! and it's fine--<em>the obvious code just works</em>.</p>
</li>
<li>
<p>If you have an isotopic value, you use a META-WORD! and get its non-isotopic form, and work with that.  (It will be inert, so you "won't need" GET-WORD! on it...)</p>
</li>
</ul>
<p><strong>So I'm going through all the non-Redbol code and eliminating the use of GET-WORD!, GET-PATH!, and GET-TUPLE!</strong></p>
<p>It's pleasing to see the improvement.</p>
<h2>But Like I Said, You Can't Wish Away Complexity...</h2>
<p>When you have a case that turns out to be complex, there's a new twist...you get quoted/meta items, not plain items:</p>
<pre><code>&gt;&gt; unsafeobj: make object! [x: 10, /y: func [] [print "Boo!"]]

&gt;&gt; for-each [key ^val] unsafeobj [print ["meta" key "is" mold val]]
meta x is '10
meta y is #[action! []]
</code></pre>
<p>Now you can no longer just test with INTEGER? VAL, because VAL is quoted.</p>
<p>So the new concept I have for <strong><code>:val</code></strong> is that it mean <strong>unmeta val</strong>.  This way you can say:</p>
<pre><code>if integer? :val [print "It was an INTEGER! before the ^META"]
</code></pre>
<h2>Wait, Isn't This The Same Situation As Before?</h2>
<p>You might ask if we've just come full circle, since you have to start using a mark on variables in order to correctly handle situations with active actions.</p>
<p>But you don't get into this situation unless you consciously ask for it... your code is correct by default, and the active actions can't just "sneak up on you".</p>
<p>And it's nice that the values aren't active...you're not risking a function being called without you knowing about it.  Instead you have a QUOTED! value, which has a weird type that will give more obvious errors if you forget to unmeta it.</p>
<h2>It Also Gives A Notation For Splices</h2>
<p>I mentioned we need some way to meta a splice, in such a way that it will evaluate back to a splice again.  The block form gives the answer for this:</p>
<pre><code>&gt;&gt; var: :[d e]
== :[d e]  ; isotope

&gt;&gt; temp: ^var
== :[d e]

&gt;&gt; do compose [var: (temp)]
== :[d e]  ; isotope

&gt;&gt; append [a b c] get/any 'var
== [a b c d e]
</code></pre>
<h2>Parameterized Evaluator Will Be Needed For Redbol</h2>
<p>I'm pretty gung-ho on keeping the Redbol tests running.  So this really lights a fire under the need to start acting on parameterized evaluation.</p>
<p>When the body of a Redbol "FUNC2" is evaluating, it needs to imbue that body with the behavior that the <strong><code>:word</code></strong> just gets the value.</p>
<p>I'm not sure what to do about isotopic actions and Redbol emulation.  :-/  It creates an interoperability issue when mixing code.  The "pure" way of doing it would give Redbol a truly separate context, where all of its LIB definitions were plain ACTION!s...that its evaluator would run from word references.  It's probably better to instead have Redbol only deal with ACTION! isotopes...telling it that they are plain ACTION!s.</p>
<h2>Necessitates A New Name?</h2>
<p>In a way, naming the parts for their behaviors has always been a bit of a bad idea.  Because you're supposed to be able to redefine them to do whatever you want.  (A SET-WORD! doesn't have to set anything, and a GET-WORD! doesn't have to get anything.  So why aren't they COLON-WORD! and WORD-COLON! ?)</p>
<p>And above I talk about Redbol behavior, where they'll act as before.  :-/</p>
<p>If I could, I've said that I'd rather the ^META and :UNMETA operations be noted with up arrows and down arrows, and perhaps be called "UP-WORD!" and "DOWN-WORD!".</p>
<pre><code>&gt;&gt; for-each [key ↑val] unsafeobj [if integer? ↓val [print "Integer found!"]]
Integer found!
</code></pre>
<p>But, the ASCII benefits win out:</p>
<pre><code>&gt;&gt; for-each [key ^val] unsafeobj [if integer? :val [print "Integer found!"]]
Integer found!
</code></pre>
<p>Anyway, the name isn't the most important thing... but just another thing to work through.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-pending-new-meaning-of-get-xxx/1901">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-pending-new-meaning-of-get-xxx/1901</link>
          <pubDate>Wed, 27 Jul 2022 22:06:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1901</guid>
          <source url="https://forum.rebol.info/t/the-pending-new-meaning-of-get-xxx/1901.rss">The Pending New Meaning of GET-XXX!</source>
        </item>
        <item>
          <title>Sample Custom Datatype Idea: Sound</title>
          <dc:creator><![CDATA[GiuseppeChillemi]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>As an example, lets build a simple custom structure:</p>
<pre><code>[[internal structures][data1][data2][data3][data4]]
</code></pre>
<p>I want that that <code>head</code> corresponds to <code>data1</code>, and <code>index?</code> returns1 when positioned there.</p>
<p>If you have an internal action called "reposition" and "get-position" belonging to that datatype, Ren-C should look at the block if it carries an additional management object. If it contains "reposition" and "get-position" it should use this custom functions to override the standard ones for the datatype. You code them so that they do not move before data1, and you have a special structure which acts transparently to the standard Ren-C working.</p>
<p>Now lets take:</p>
<pre><code>sound: [[header] size: 5000 modified-by: "HF" sound: #A45ACF...  [tail-data]]
</code></pre>
<p>It is your structure to store a sound.</p>
<p>you want that at set operation using ':' will be written <code>raster-image:</code> content, so that</p>
<pre><code>sound: load %mysong.wav
</code></pre>
<p>You add a custom management object with overwrites the set operation and also all the others regarding <code>pick/length?/poke...</code> and so on, so that your Ren-C script works with the usual syntax, which is internally manage by from you replacement actions, translating everything to the new coordinates and operation system</p>
<p>Obviously, you could have additional action to be available to the developers which do not replace the internal actions but they could be called with syntax like:</p>
<pre><code>do-custom data 'method [parameter parameter]
</code></pre>
<p>or having a special path like <code>sound/#/fourier-trasform</code></p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/sample-custom-datatype-idea-sound/1899">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/sample-custom-datatype-idea-sound/1899</link>
          <pubDate>Sun, 24 Jul 2022 10:23:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1899</guid>
          <source url="https://forum.rebol.info/t/sample-custom-datatype-idea-sound/1899.rss">Sample Custom Datatype Idea: Sound</source>
        </item>
        <item>
          <title>Could Each Datatype Have a &quot;Second&quot; (Hidden) &quot;Slot&quot;</title>
          <dc:creator><![CDATA[GiuseppeChillemi]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>From some time I am having the idea that each datatype could have a second value slot where you can set a context where I can store replacement handling methods for set/get and also other functions and any data you have, so you can patch the standard Rebol handlings and have also additional data/functions.</p>
            <p><small>7 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/could-each-datatype-have-a-second-hidden-slot/1908">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/could-each-datatype-have-a-second-hidden-slot/1908</link>
          <pubDate>Tue, 19 Jul 2022 21:36:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1908</guid>
          <source url="https://forum.rebol.info/t/could-each-datatype-have-a-second-hidden-slot/1908.rss">Could Each Datatype Have a &quot;Second&quot; (Hidden) &quot;Slot&quot;</source>
        </item>
        <item>
          <title>High-Level Parameterized Enums</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>So there's a neat feature in Haskell and Rust (and other languages) which is that you can make an enumerated type which takes parameters.  Here's Rust's version:</p>
<pre><code>enum Message {
    Quit,
    ChangeColor(i32, i32, i32),
    Move { x: i32, y: i32 },
    Write(String),
}
</code></pre>
<p>In C++ there's not built-in support for this.  You have to implement it as a "tagged union"...where you have a struct that has a plain enum integer in it, and then a union of all the possibilities of what could be in that spot.</p>
<p>So this made me wonder what we could do to support it.</p>
<h2>Fans of History May Recall I Made an Enumerated Type Once</h2>
<p>I wasn't much involved with the language until it was open-sourced.  But I did <a href="http://blog.hostilefork.com/enumerated-type-for-rebol2/">tinker with it in 2009</a></p>
<pre><code>&gt;&gt; fruit: make-enum-type [apple orange banana mango]

&gt;&gt; favorite_fruit: make-enum fruit 'apple

&gt;&gt; set-enum favorite_fruit 'shoe
** User Error: illegal enum value ( shoe ) when 
     possibilities are [ apple orange banana mango ]
</code></pre>
<p>Clearly we want better than that, which might look more like:</p>
<pre><code>fruit: new enum [apple [rotten: [logic!]] orange banana mango]

favorite-fruit: new fruit.apple false
</code></pre>
<p>It raises some questions about how SWITCH might be able to be hooked to have some augmented feature, where it enforces you covering all the cases for the ENUM.</p>
<p>I don't have any great ideas offhand...but I just was hearing a talk where this was brought up and it reminded me that maybe it would be a good example to try and think through, as a feature users could add after-the-fact.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/high-level-parameterized-enums/1894">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/high-level-parameterized-enums/1894</link>
          <pubDate>Tue, 19 Jul 2022 00:15:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1894</guid>
          <source url="https://forum.rebol.info/t/high-level-parameterized-enums/1894.rss">High-Level Parameterized Enums</source>
        </item>
        <item>
          <title>Should Everything Have an Isotopic Form?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>A little too soon to declare victory, but... we may have a solution in our hands for the historical problem of splicing arrays, <strong><a href="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/18">by allowing BLOCK! isotopes</a></strong> to convey the splicing intent.</p>
<p>Isotopes are essentially <em>"quote level -1"</em> ... if you take something at quote level 0 and UNMETA it, you're allowed precisely one level of  below-rock-bottom.</p>
<p>The isotopes are unfriendly: normal function parameters won't accept them, you cannot put them in arrays, and some of them have strange behaviors when assigned to variables.</p>
<p>So what would an isotopic block look like?</p>
<p>A thought I had inspired by BAD-WORD!s was that they might use tildes on the outsides:</p>
<pre><code>&gt;&gt; unmeta [a b c]
== ~[a b c]~
</code></pre>
<p>But that's used for normal BAD-WORD! today, that you unmeta to make isotopes.</p>
<p>Which made me wonder, what if what we call BAD-WORD! today was actually a BAD-WORD! isotope, and you got them from unmeta'ing WORD! ?</p>
<pre><code>&gt;&gt; unmeta 'something
== ~something~
    ; ^-- ornery, how what we call `~something~ isotope` is today
</code></pre>
<p>And then, what if you could make anything isotopic:</p>
<pre><code>&gt;&gt; unmeta 1020
== ~1020~
</code></pre>
<p>This would break a number of things--and we've come to depend on reified BAD-WORD!s for some reasonably important purposes.  But it crossed my mind and I tend to jot notes here for every single whim that comes to my mind, so there it is.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<h2>Storing Isotopic Blocks In Variables?</h2>
<p>If you go back and review <a href="https://forum.rebol.info/t/generic-quoting-makes-headway-on-make-object/997">"Generic Quoting Makes Headway on MAKE OBJECT!"</a> you'll see that we've been getting by not needing quotes on items that are inert.</p>
<p>You have to have a quote on (1 + 2) if the intent is to store a GROUP! in a variable, because it will evaluate otherwise:</p>
<pre><code>make object! [group: '(1 + 2)]
</code></pre>
<p>But things like BLOCK! haven't needed them (and shouldn't):</p>
<pre><code>make object! [block: [1 + 2]]
</code></pre>
<p>However, I think that BLOCK! isotopes are likely going to need to be stored in variables.  You'll have to use ^META operations to get the value out of the variable.</p>
<p>Why couldn't it be an error to try and store an isotopic block in a variable?  Well, there is some attempts to be friendly by higher-level operations like SPECIALIZE.  So when you say</p>
<pre><code>append-a-b-c: specialize :append [value: spread [a b c]]  ; or whatever...
</code></pre>
<p>What happened was that everything in the frame was marked as holding a special identity for unspecialized-ness.  When the code block finishes running, it looks and notices value is a ^META parameter, and does the isotopic quoting for you.</p>
<p>If you don't have that feature, you have to know the convention of the parameter in order to assign it.  That's not the end of the world, but it feels like a hassle.  Being able to store an isotopic block in a variable enables that feature--as well as others.</p>
<h2>So I Think Isotopes Are In For Some Kind of Reckoning</h2>
<p>There's a lot of pieces to the puzzle, and they're all tied in together.  But the good news is that the corpus of code is so big that the impacts of any change are seen, and so I can try to make sure nothing of value gets lost.</p>
            <p><small>7 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-everything-have-an-isotopic-form/1889">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-everything-have-an-isotopic-form/1889</link>
          <pubDate>Sat, 16 Jul 2022 22:41:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1889</guid>
          <source url="https://forum.rebol.info/t/should-everything-have-an-isotopic-form/1889.rss">Should Everything Have an Isotopic Form?</source>
        </item>
        <item>
          <title>From (get-env &quot;FOO&quot;) to (environment.FOO) to (env.FOO) to $FOO</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>If you spend time in bash scripting or something like GitHub CI, you realize that environment variables are <em>really important</em>.</p>
<p>So it's a bit sad that Rebol has had the really ugly <strong>get-env</strong> and <strong>set-env</strong> functions as the interface to this.</p>
<p>I'd say it's pretty clear that we'd like for <strong>env.FOO</strong> to work.  I'm also leaning to thinking that at least in some dialected circumstances, <strong>$FOO</strong> should be interpreted as an environment variable as well...and we need these types:</p>
<ul>
<li><strong><code>$WORD</code></strong></li>
<li><strong><code>$TU.P.LE</code></strong></li>
<li><strong><code>$PA/TH</code></strong></li>
<li><strong><code>$[BL O CK]</code></strong></li>
<li><strong><code>$(GR O UP)</code></strong></li>
</ul>
<p><em>(I thought it might be interesting if the way the evaluator treated these types was to call whatever <strong><code>$</code></strong> was bound to, with the thing as an argument.  If that were viable, it could be applied to <strong><code>:</code></strong> and <strong><code>@</code></strong> as well.  But the thorn is that the value only has one binding for the word/path/tuple/etc....nowhere to put the binding for the operator in the cell.  New binding models could change that, so I'm keeping an open mind.)</em></p>
<h2>But How To Make An "ANY-CONTEXT!" That Calls Functions?</h2>
<p>Right now, the only way to get hooks into the system to run code when you use tuple access is by making a new datatype.  And that can only be done in the C code.</p>
<p>So if someone put a gun to my head and told me to make it work right now--<em>today</em>--the quickest path would be to make a new ANY-CONTEXT! type in C called an ENVIRONMENT!.  The flaky part is that environment variables come from an extension, and so it would be an "extension type" (like a GOB! or VECTOR!), and those are second-class citizens (they don't work in TYPESET! for instance, they're all considered the same CUSTOM! datatype for those purposes).</p>
<p>I resist the temptation to do this, because while it would be nice to write <strong>environment.FOO</strong> instead of <strong>get-env "FOO"</strong>, most of the uses are in the rebmake code...which needs to work in the bootstrap executable.  So no point in making an existing mess with extension types messier.</p>
<h2>Any Usermode Ideas?</h2>
<p>I think what we should be looking for is a way that someone without a C compiler could make something that looks like an object, but the behavior for handling the TUPLE! access comes from functions.</p>
<p>Right now you can't "dot an action"... actions only take PATH!s for refinements.  So we could say that if we get a dot, it looks to see if the function has a /DOT refinement, and if it does then it will call it accordingly with information from the context of the get or set:</p>
<pre><code>environment: func [variable [word! set-word!] value [&lt;end&gt; any-value!] /dot] [
    assert [dot]  ; let's say you always use with dot for now
    if set-word? variable [
       echo [You asked to set @variable to @value]
    ] else [
       echo [You asked to get @variable]
]

&gt;&gt; environment.FOO
You asked to get FOO

&gt;&gt; environment.FOO: 10
You asked to set FOO to 10
</code></pre>
<p>It's better than nothing.  But what I don't like about it is that I have the idea that tuple access on functions will be able to get and set properties stored on that function... e.g. that functions will be able to act as objects.  This would be where stuff like help informaiton is stored.  <em>(This was historically called the "meta object" but we have much more compelling uses for the word "meta" now.)</em></p>
<h2>So Probably Better to be a User-Defined Datatype</h2>
<p>Unfortunately these don't exist yet.  But I guess now we have a good example of ENVIRONMENT! as something that needs supporting.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/from-get-env-foo-to-environment-foo-to-env-foo-to-foo/1857">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/from-get-env-foo-to-environment-foo-to-env-foo-to-foo/1857</link>
          <pubDate>Mon, 04 Jul 2022 14:14:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1857</guid>
          <source url="https://forum.rebol.info/t/from-get-env-foo-to-environment-foo-to-env-foo-to-foo/1857.rss">From (get-env &quot;FOO&quot;) to (environment.FOO) to (env.FOO) to $FOO</source>
        </item>
        <item>
          <title>Hex-Valued Integer Literals: Likely Not In Ren-C</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>On an old Trello there was a card about standardizing the differences between R3-Alpha and Red...and a checklist with only one item:</p>
<blockquote>
<p>Hex-valued literal notation (Rebol has none, Red used to use FFh, FFFFh, FFFFFFFFh), now using 0#FF</p>
</blockquote>
<p>The motivation was for purposes of Red/System, mostly.</p>
<p>In Ren-C this doesn't seem like a priority.  It has ISSUE! (TOKEN!) as a read-only data type that fits in a cell.  Hence a systems-oriented dialect already has an efficient way to represent these values.</p>
<p>For instance: it's not a big deal if your assembler says <strong>[mov ax, <span class="hashtag">#FE</span>]</strong> in its source... if it's generating machine code.</p>
<p>Of course, an ISSUE! in it isn't the same from a metaprogramming sense as a slot with an INTEGER! in it.  So you don't get the automatic advantage of <em>every</em> dialect that has INTEGER! support for a given slot working with a hex notation.  But isn't that what COMPOSE is for...?</p>
<pre><code>my-dialect [something-or-another 255]

my-dialect compose [whatever (debin [BE +] #FF)]
</code></pre>
<p><strong>Having more than one representation for the same type is generally bad, anyway.</strong>  Let's look at what Red does here:</p>
<pre><code>red&gt;&gt; FFh
== 255

red&gt;&gt; F0h + 0Fh
== 255
</code></pre>
<p>If it was so important that it had to be encoded in source, why is it thrown away immediately?</p>
<p>It's something about Red worth knowing exists, but off the radar for implementing, methinks.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/hex-valued-integer-literals-likely-not-in-ren-c/1815">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/hex-valued-integer-literals-likely-not-in-ren-c/1815</link>
          <pubDate>Sat, 14 May 2022 04:35:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1815</guid>
          <source url="https://forum.rebol.info/t/hex-valued-integer-literals-likely-not-in-ren-c/1815.rss">Hex-Valued Integer Literals: Likely Not In Ren-C</source>
        </item>
        <item>
          <title>DATE! + TIME! + DATETIME! (or TIMESTAMP! ?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>As we are familiar, DATE! can have a TIME! component:</p>
<pre><code>&gt;&gt; d: now
== 21-Nov-2021/18:56:45-5:00 

&gt;&gt; type of d
== #[datatype! date!]

&gt;&gt; t: d.time
== 18:56:45

&gt;&gt; type of t
== #[datatype! time!]
</code></pre>
<p>Although TIME! can exist as a separate cell and value type, <em>a DATE! doesn't store a time cell inside of it</em>.  It packs the date and time information into a single cell.</p>
<p>Hence when you say <strong>d.time</strong> above, a <em>new</em> TIME! value has to be synthesized.  There's not a whole cell worth of time to hand a pointer back to...its woven into the bits of the DATE!.</p>
<p><strong>That might not sound like much of an issue, but it creates the problem I refer to as <em>"sub-cell addressing"</em>.</strong></p>
<p><em>If you've missed everything I've griped about with this so far</em>, it means that when you want to see a behavior like the following:</p>
<pre><code>&gt;&gt; d.time.hour: 12
== 12

&gt;&gt; date
== 21-Nov-2021/12:56:45-5:00  ; we want hour updated
</code></pre>
<p>We run into the problem that if <strong>d.time</strong> <em>synthesizes</em> a value, then a naive picking process of <strong>(d.time).hour: 12</strong> would only be able to manipulate the bits in the synthesized time.  That wouldn't change <strong>d</strong>.  <em>What the user actually wanted was to update the bits of a time that was folded into the implementation of the date.</em></p>
<h2>Rebol Lacks The Vocabulary To Do This In An Obvious Way</h2>
<p>The smallest units that Rebol speaks in terms of are the <strong><code>cell</code></strong> and the <strong><code>node</code></strong>.</p>
<p><em>(If you need a refresher on these, my <a href="https://www.youtube.com/watch?v=6nsKTpArTCE">conference video tech talk</a> explains them.)</em></p>
<p><strong>It would appear we could be able to simplify matters if we changed the combination of DATE! and TIME! to point to a 2-cell node.</strong></p>
<pre><code>DATETIME! cell
[  ]                DATE!           TIME!
  --&gt; points to [ 21-Nov-2021 | 18:56:45-5:00 ]  (2 cells)
</code></pre>
<p><em>(Whether the "zone" is part of a time or lives in the datetime would depend on whether you wanted to write <code>d.zone: -5:00</code> or <code>d.time.zone: -5:00</code>, I don't know if it ever makes sense to speak of a time with a zone independent of a datetime or not.)</em></p>
<p>Breaking things up this way, we can say that <strong>d.time</strong> implicates a cell.  And we can have some operation that acts on a cell (let's say POKE) like:</p>
<pre><code> &gt;&gt; poke 18:56:45 'hour 12
 == 12:56:45
</code></pre>
<h2>Hang On: DATE!, TIME! (and DATETIME!) are IMMEDIATE!</h2>
<p>We still have a bit of a problem here with our smallest units of representation.  Presumably we don't want this:</p>
<pre><code> &gt;&gt; d1: 21-Nov-2021/18:56:45-5:00 

 &gt;&gt; d2: d1

 &gt;&gt; d1.time.hour: 12
 == 12

 &gt;&gt; d1
 == 21-Nov-2021/12:56:45-5:00

 &gt;&gt; d2
 == 21-Nov-2021/12:56:45-5:00  ; don't want d2 to change (right?)
</code></pre>
<p>But we also don't want to be needlessly copying the 2-cell node each time a date is assigned.  So it would be a <em>copy-on-write</em> mechanic.</p>
<p>If we're working with a cell-based granularity, then we wind up in a somewhat similar situation to what we had before...where the tuple processing has to propagate backwards.  e.g. when you have the POKE that changes the cell bits for the TIME! to make a new TIME! cell, there has to be some memory going back to the DATETIME! in order to tell it to make a new node and write the cell into the copy.</p>
<p>Does framing this in terms of cells offer any benefit over letting the DATETIME! be a higher-level entity that does a more specific folding of the TIME! cell into its bits?  This is a question I've been trying to answer, and haven't had an easy time of answering.</p>
<p><strong>One thing it would do to use a cell-based protocol is that it could generalize properties that had flags on cells, such as being PROTECT'ed.</strong>  Without the picking protocol requiring each step to go through a cell, the system cannot fiddle these bits in a known way.  So just as the DATE! folds the TIME! into it in some arbitrary way, the protect bit would have to go through this through a complex protocol also.</p>
<p>What I do know is that my current generalized solution is rather complex and slow--and doesn't answer how to do things like PROTECT.  We're seeing a slowdown from many different angles and I am trying to figure out what the best tradeoff is in terms of simplicity and generality.  It's not easy.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/date-time-datetime-or-timestamp/1765">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/date-time-datetime-or-timestamp/1765</link>
          <pubDate>Thu, 02 Dec 2021 16:57:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1765</guid>
          <source url="https://forum.rebol.info/t/date-time-datetime-or-timestamp/1765.rss">DATE! + TIME! + DATETIME! (or TIMESTAMP! ?)</source>
        </item>
        <item>
          <title>Tuple Troubles: Version 0.3.01 vs 0.3.1</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>For better or worse, versioning in Rebol has used TUPLE!.  e.g. 0.3.1 is 32-bit Windows, and 0.3.40 is 64-bit Windows</p>
<p>If you go back and look at the old R3-Alpha file <strong><a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/tools/systems.r#L21">%systems.r</a></strong> you can see that it's pretty typical for Carl to have written the versions out with leading zeros...<em>but only in the third slot</em>.  So <code>0.3.01</code> but not <code>00.03.01</code></p>
<p>But ultimately the tuple discards this information.  And this has been the way it always worked:</p>
<pre><code>rebol2&gt;&gt; 0.3.01
== 0.3.1

red&gt;&gt; 0.3.01
== 0.3.1

ren-c&gt;&gt; 0.3.01
== 0.3.1
</code></pre>
<p>This leads to problems when you are working with string representations outside of Rebol (say in bash shell, something like "0.3.01") and you pass it into Rebol to process as a tuple.  If bash went and created a directory based on the string...you won't match if you FORM that tuple later.</p>
<p>You could insist on passing around the tuple as a string, but that undermines the value of having the version be in a tuple in the first place.</p>
<p>I'd say that the simplest solution is just to stop writing tuples with the leading zeros...instead keeping them in their canon form.  0.3.1 for 32-bit Windows, and 0.3.40 for 64-bit Windows.  Then make the directories reflect this, e.g.:</p>
<pre><code>https://dd498l1ilnrxu.cloudfront.net/travis-builds/0.3.1/r3-573037b-debug.exe
</code></pre>
<p>and not:</p>
<pre><code>https://dd498l1ilnrxu.cloudfront.net/travis-builds/0.3.01/r3-573037b-debug.exe
</code></pre>
<p>That leading zero comes with a whole lot of headaches, so I say hunt them down and get rid of them.  Because non-Rebol systems are going to only operate on them as strings and they'll leak.</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/tuple-troubles-version-0-3-01-vs-0-3-1/1755">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/tuple-troubles-version-0-3-01-vs-0-3-1/1755</link>
          <pubDate>Wed, 24 Nov 2021 13:28:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1755</guid>
          <source url="https://forum.rebol.info/t/tuple-troubles-version-0-3-01-vs-0-3-1/1755.rss">Tuple Troubles: Version 0.3.01 vs 0.3.1</source>
        </item>
        <item>
          <title>&quot;Raw&quot; Strings</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>I'm now 99% sure that { } best serves its purpose as a string form.</p>
<p>But there were several talking points that came out of that discussion.  One was a desire for "raw" strings.</p>
<p>This is the idea that outside of the termination sequence, there's <em>no</em> escaping.  This means you can put pretty much anything in the string.  Backslashes, carets...it's all fair game.</p>
<h2>Two Very Different String Forms: When Are They Raw?</h2>
<p>To <em>me</em>, it made the most sense that the raw form be the braced form...because it is so frequently applied to sections of arbitrary documentation text (such as the Description: in module headers).</p>
<pre><code>Description: {
    If you call this from C, then write:

        if (a ^ b != 0) {  // bitwise XOR
            printf("This is an example\n");
        }

     So there you see carets and backslashes working.
}
</code></pre>
<p>With binding support for string interpolation, we can imagine this getting even more useful for representing snippets of other languages with escaped portions inside of them.</p>
<p>However, <a class="mention" href="/u/giuliolunati">@giuliolunati</a> favored the idea of making quoted strings <em>mostly-raw</em>, because there was an easy-seeming way to escape quotes using only the quote character.</p>
<pre><code>&gt;&gt; "This would be ""quotes"" inside a string"
== {This would be "quotes" inside a string}
</code></pre>
<p>How braces are escaped historically ( e.g. <code>^}</code> ) is messier.  That drags caret into it, so now you're worrying about needing to escape carets and braces.  A more uniform approach appealed to Giulio, so he favored the quotes form...and would prefer it to be able to represent characters "as-is" by default, with this exception for embedded quotes.</p>
<p>But from my point of view, I was seeking to avoid is any need to do search/replace on the embedded information.  So <em>mostly-raw</em> wasn't good enough; e.g. I'd like to copy and paste the C code out of the example above, not have its quotes doubled:</p>
<pre><code>Description: "
    if (a ^ b != 0) {  // bitwise XOR
        printf(""This is an example\n"");   &lt;-- doubled quotes not good
    }
"
</code></pre>
<p>We also discussed that I'm averse to having ordinary quotes as multi-line strings... though maybe we should allow them.  :-/  But even if we did, it feels unintentionally incomplete to see something like:</p>
<pre><code>Description: "
</code></pre>
<p>So for these reasons I wanted to focus the raw string effort on braced strings.  Yet there are a lot of things that it gets hard to represent in a raw string form when you try to use unmatched braces in the content.</p>
<p>After thinking about it a bit, we came up with the option of being able to set the delimiter according to a number of braces and a vertical bar.</p>
<pre><code>{...}  ; expects any { } inside to be matched pairs 
{|...|}  ; allows internal unpaired and mismatched { }, {| |} matched pairs
{{|...|}}  ; allows internal unpaired and mismatched {| |}, {{| |}} matched
</code></pre>
<p>etc. etc.</p>
<p>This can handle some pretty sticky strings like <strong><code>{|ab"c"} {"d"ef|}</code></strong> if need be, where the data extracted is:</p>
<pre><code>ab"c"} {"d"ef
</code></pre>
<p>The approach would allow any number of {{ }}, which sounds like it could get ugly.  But it's kind of like generic quoting, where I don't anticipate people using ridiculously high levels like {{{{|...|}}}}.  But having it be a general method has value--especially in generated code scenarios.</p>
<p>Strings starting or ending with vertical bar forms like <strong>{|}</strong> get sacrificed, so you'll have to use "|" instead.  But you would use "}" so this just moves | into the same category as } and {.</p>
<p>I also suggested an additional rule...that you don't terminate braced strings except as:</p>
<ul>
<li>{...} -space-</li>
<li>{...} -newline-</li>
<li>{...}]</li>
<li>{...})</li>
</ul>
<p>If we limit it to these possibilities, you can write things like:</p>
<pre><code> code: {char c = '}';}
</code></pre>
<p>It seems that a lot of unpaired brace cases are single character literals like this, which don't fall under the rule.  You might want to put the bars in for good measure anyway:</p>
<pre><code> code: {|char c = '}';|}
</code></pre>
<p>In any case, the other thing we were leaning toward here was that when quoted strings are escaped, they do so compatibility with the classical C backslashes, based on the idea that caret escaping hadn't done the language any particular favors.</p>
<p>Just wanted to write this up while I still was thinking about it... <img src="https://forum.rebol.info/images/emoji/twitter/zzz.png?v=9" title=":zzz:" class="emoji" alt=":zzz:"></p>
            <p><small>16 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/raw-strings/1750">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/raw-strings/1750</link>
          <pubDate>Sat, 23 Oct 2021 13:33:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1750</guid>
          <source url="https://forum.rebol.info/t/raw-strings/1750.rss">&quot;Raw&quot; Strings</source>
        </item>
        <item>
          <title>Alternate String Forms if {...} Becomes An Array Type</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <blockquote>
<p>I've brought up in earnest something I call <strong><a href="https://forum.rebol.info/t/rethinking-braces-as-an-array-type/1727">"The FENCE! Proposal"</a></strong>.  It involves retaking <strong>{...}</strong> for an <em>object-like-purpose</em>.</p>
<p>The twist is that it's really another ANY-ARRAY! type, peer to [...] and (...) - but with the default evaluator behavior of MAKE OBJECT!.  Then as with [...] and (...), dialects would be free to override {...} in their own way.</p>
<p>A sad consequence of this would be the loss of the alternative string form {...}.  Discussions of what to use instead were lengthier than the discussion of the proposal itself, so I've moved them onto their own thread here...starting with my initial musing...</p>
</blockquote>
<h2>What Other Asymmetric String Technique Might Be Used?</h2>
<p>Some languages have weird techniques, like even letting you make up your own delimiters by whatever you use in front of the quote:</p>
<pre><code>str: ?"This says "quote followed by question mark" terminates"?
str: |"This says "quote followed by bar" terminates"|
str: xyz"This says "quote followed by zyx" terminates"zyx 
</code></pre>
<p>(Not making that up.)</p>
<p>The risk of using a symbol like | is that even if it looks good in isolation, you might not like it in a parse rule, like <strong>rule1 | |"some string"| | rule2</strong>.  A less-used character might be better:</p>
<pre><code>parse data [rule1 | ~"some string"~ | rule2]
</code></pre>
<p>Or perhaps those who really feel the need for another asymmetric string delimiter should assign a couple keys in their editor to unicode:</p>
<pre><code>str: «Maybe People «who really care» could use "Chevrons"?»
</code></pre>
<p>Who knows.  <strong><a href="https://en.wikipedia.org/wiki/Here_document">One place to look is the topic of "HEREDOC"</a></strong></p>
<p>Another place to look is the <strong><a href="https://stackoverflow.com/questions/13535172/list-of-all-unicodes-open-close-brackets">List of open/close paired braces/brackets/quotes in Unicode</a></strong></p>
            <p><small>22 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/alternate-string-forms-if-becomes-an-array-type/1743">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/alternate-string-forms-if-becomes-an-array-type/1743</link>
          <pubDate>Mon, 18 Oct 2021 01:06:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1743</guid>
          <source url="https://forum.rebol.info/t/alternate-string-forms-if-becomes-an-array-type/1743.rss">Alternate String Forms if {...} Becomes An Array Type</source>
        </item>
        <item>
          <title>If {Braced Were Arrays} What Should That Be Called</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>It's early yet in the discussion of <a href="https://forum.rebol.info/t/rethinking-braces-as-an-array-type/1727">whether to make braces a new array type</a>.  But people seem receptive and feel like maybe Rebol has put itself in a bad position by using that particularly valuable piece of keyboard real-estate for something "superficial" like making strings a little cleaner, sometimes.  :-/</p>
<p><em>(Note: Ultimately braces were decided to keep as strings, though having another array type is still a possibility...and maybe it will need a name.)</em></p>
<p>For lack of another name I had called it BRACED!.</p>
<p>But I don't like that much more than I would want to call <em>blocks</em> BRACKETED! (or BRACK! <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=9" title=":roll_eyes:" class="emoji" alt=":roll_eyes:">)... nor call <em>groups</em> PARENTHESIZED! (or PAREN! <img src="https://forum.rebol.info/images/emoji/twitter/face_vomiting.png?v=9" title=":face_vomiting:" class="emoji" alt=":face_vomiting:"> )</p>
<p>Here is my suggestion for the 3 array types:</p>
<h1>
<code>[block]</code> <code>•</code>  <code>(group)</code> <code>•</code> <code>{fence}</code>
</h1>
<hr>
<p>I like that FENCE is five letters...matching GROUP and BLOCK.  I like that it starts with a distinct character.</p>
<p><strong>I actually think having it be divorced from anything obvious about creating objects can be seen as an asset instead of a liability.</strong>  Because that's only what it's for <em>sometimes</em>.</p>
<ul>
<li>
<p><em>"In the PARSE dialect, blocks are used to represent subrules.  Groups switch over to running ordinary code as with DO.  While fences are used to... (insert your active imagination here)"</em></p>
</li>
<li>
<p><em>"If there's an integer inside of a pair of fences, such as <code>{{10}}</code>, then that represents a citation.  Citations can appear at either the beginning or end of a reference block."</em></p>
</li>
</ul>
<p>It's one of those things that might seem a little weird at first, but as you become accustomed to saying it then it becomes normal...and you're grateful to have such a convenient word at hand.</p>
<h2>Other Uses of "Fence" in Programming</h2>
<p>Dictionary definition of fence: <em>a barrier, railing, or other upright structure, typically of wood or wire, enclosing an area of ground to mark a boundary, control access, or prevent escape.</em></p>
<p>The term <em>fence</em> has only two meanings in programming that jump immediately to mind...the one most people would know are these three-backticks used to format code in MarkDown:</p>
<pre><code>When you are writing things in **MarkDown**
The following is a "code fence"
```
int main(int argc, char *argv) {
    printf("I'm not a huge fan of the ```, myself.\n");
    return EXIT_SUCCESS;
}
```
*(I myself prefer to indent by 4 spaces, instead.)*
</code></pre>
<p>Less well-known to the scripting world would be "fencing instructions" which are low-level processor stuff used to mitigate things like Spectre.</p>
<h2>Other Options?</h2>
<p><strong>{ CURLY! }</strong> is too goofy, immediate veto from me.</p>
<p>I've explained why I don't like <strong>{ BRACE! }</strong> or <strong>{ BRACED! }</strong>.  Plus brace has the problem of being singular like PAREN!, while BRACED! seems to talk about the <em>contents</em> vs. the actual structure of the container itself...which I guess might have to be "bracing" or "braces" or something.  FENCE! lets you mentally model it as actually referring to "the container in and of itself".</p>
<p>For terms that relate to "contained things" there might be the likes of <strong>{ CLAUSE! }</strong>...but that feels a bit more prescriptive to what it's for.  And object-making doesn't line up with that.  FENCE! is more abstract to me, somehow.</p>
<p>One could argue that <strong>{ CLUSTER }</strong> might sound more like an array that produced an object.  ("Hey, cluster these keys together, into a blob.")  You might similarly argue for <strong>{ AGGREGATE! }</strong> as being "more meaningful".</p>
<p>But I'm drawn to the viscerality of FENCE!.  It feels learnable within this vocabulary.  Especially when you see it lined up with GROUP! and BLOCK!.  I'm kind of attached to it now.  <img src="https://forum.rebol.info/images/emoji/twitter/two_hearts.png?v=9" title=":two_hearts:" class="emoji" alt=":two_hearts:"></p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/if-braced-were-arrays-what-should-that-be-called/1728">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/if-braced-were-arrays-what-should-that-be-called/1728</link>
          <pubDate>Thu, 30 Sep 2021 11:36:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1728</guid>
          <source url="https://forum.rebol.info/t/if-braced-were-arrays-what-should-that-be-called/1728.rss">If {Braced Were Arrays} What Should That Be Called</source>
        </item>
        <item>
          <title>{ Rethinking Braces }... as an array type?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>I've historically been pretty attached to braces for strings.  They sure can be nice.</p>
<p><em>But</em> I am increasingly thinking braces might be better applied as a new array type:</p>
<pre><code>&gt;&gt; bracey: first [{This [would] be @legal}]
== {This [would] be @legal}

&gt;&gt; length of bracey
== 4

&gt;&gt; second bracey
== [would]
</code></pre>
<blockquote>
<p><em>(<strong>UPDATE:</strong> I think this idea received its due consideration over the span of a couple of weeks...but doesn't weigh in as worth it to change what we use for strings.  Explanations laid out in the thread below.  But keeping the proposal intact for historical reference.)</em></p>
</blockquote>
<p>So it would act like a BLOCK! or a GROUP! when it was inert.  But the real benefit would be the idea that if this braced form got evaluated, it would effectively do a MAKE MAP! or MAKE OBJECT! (or "something along those lines")</p>
<pre><code>&gt;&gt; obj: {x: 10 y: 20, z: 30}
== make object! [  ; whatever this representation is, it's not {x: 10...}
    x: 10
    y: 20
    z: 30
]
</code></pre>
<p>This kills two birds with one stone: <strong>A neat new dialecting part that would also give a better source notation for objects!</strong></p>
<p>Having its evaluator behavior be "make an object/map" pushes this from "frivolous third form of block" to being clearly useful on day 1.  But I think the block form would soon turn out to not be frivolous.</p>
<h2>Carl Himself Wants To Move Away From Braced Strings</h2>
<p>In Carl's "ASON" pitch, he <a href="https://altscript.com/?page_id=16">moves away from Rebol's choice to make braces an asymmetric string delimiter</a>:</p>
<blockquote>
<ul>
<li>
<p><em>"<strong>Braces {} are used to denote objects</strong>. They are lexical and may be used directly without evaluation (the <code>make</code> constructor is not necessary)."</em></p>
</li>
<li>
<p><em>"<strong>Braces {} are not used for multi-line strings</strong>. A single+double quote format is used for multi-line strings."</em></p>
</li>
</ul>
</blockquote>
<p>I must admit braced strings can make a lot of situations in the text programming world look better than they typically would.</p>
<p>But it comes at a cost for taking the asymmetric delimiter, and is a real weakness against JavaScript and JSON.  When rethought as this fun new dialecting part, it actually offers a new edge and plays to Rebol's strengths.</p>
<p>What might the new <strong>{...}</strong> type do in PARSE?  As a branch type?  In your own dialects?</p>
<h2>My {...} Proposal Is Arrays, Not Object Literals</h2>
<p>It might seem like having a source representation of objects that maps directly to the loaded/ in-memory representation would be better.  But in practice, you can't really get the loaded form to ever look completely like the source...there's so many issues with nested cyclical structures or things that just don't mold out.</p>
<p>It doesn't work in JavaScript either.  Note that you're not supposed to be loading JSON directly in any case into JavaScript...you're always supposed to go through parsers and serializers.  So that should be weighed here when looking at the suggestion of a structural type that happens to evaluate to give you an in-memory representation.</p>
<h2>Map Representation Via <code>:</code> ?</h2>
<p>There was another remark in the Altscript on the role of colon:</p>
<blockquote>
<p>For JSON compatiblity:</p>
<ul>
<li>Keys (word definitions) can be written with quotes (<code>"field":</code>)</li>
<li>A lone colon (<code>:</code>) will automatically associate to the word/string immediately before it.</li>
<li>Commas as element separators are allowed as long as they are not directly followed by a non-digit character (to avoid confusion with comma-based decimal values.)</li>
</ul>
</blockquote>
<p>The note about the colon seems like it might be good for maps.</p>
<pre><code>mapping: {
    1 : "One"
    "Two" : 2
}
</code></pre>
<p>This could help avoid the need for SET-INTEGER! or similar.</p>
            <p><small>10 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rethinking-braces-as-an-array-type/1727">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rethinking-braces-as-an-array-type/1727</link>
          <pubDate>Wed, 29 Sep 2021 00:30:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1727</guid>
          <source url="https://forum.rebol.info/t/rethinking-braces-as-an-array-type/1727.rss">{ Rethinking Braces }... as an array type?</source>
        </item>
        <item>
          <title>Should Different-Typed Comparisons Be Less Friendly?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>I've historically been on the side of saying that I don't think it's good for types of different categories to compare equally, e.g. <strong><code>&lt;foo&gt; = "foo"</code></strong> being true can cause some headaches.</p>
<p>But these headaches can work the other way as well.  I just had a bug where I was passing something as a string, but the caller was comparing it as a WORD!.</p>
<pre><code> if info.name = 'startup* [
     ...  ; it was a string, so actually "startup*"
 ]
</code></pre>
<p>This makes me wonder if different-typed comparisons need some distinction in the comparison, to help say that you know the type you're comparing against is completely different.</p>
<pre><code>if info.name =T 'startup* [
   ;
   ; ugly example... but imagine =T is a way of saying "I know the type
   ; should be the type on the right (e.g. WORD!), so tell me if it is
   ; not...
]

&gt;&gt; 'foo =T 'bar
== #[false]

&gt;&gt; "foo" =T 'bar
** Error: =T expected a WORD! on the left but got a TEXT!
</code></pre>
<p>It's always the latest such bug to bite you in languages of this nature that make you wish for stricter typing policies.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-different-typed-comparisons-be-less-friendly/1726">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-different-typed-comparisons-be-less-friendly/1726</link>
          <pubDate>Thu, 23 Sep 2021 11:17:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1726</guid>
          <source url="https://forum.rebol.info/t/should-different-typed-comparisons-be-less-friendly/1726.rss">Should Different-Typed Comparisons Be Less Friendly?</source>
        </item>
        <item>
          <title>Dissecting R3-Alpha&#39;s EVENT!: What Should We Think?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <h2>Quick Retrospective Look At EVENT!</h2>
<p>Not everyone had to deal with EVENT!.  But it's relatively easy to understand as a tiny and very-limited OBJECT!.  Here's what one being created looked like in R3-Alpha's %prot-http.r</p>
<pre><code>make event! [type: 'read port: http-port]
</code></pre>
<p>It looks a bit like a MAKE OBJECT!, with SET-WORD!s and expressions.  But what actually happened under the hood?</p>
<p>Datatypes in R3-Alpha had "MT" functions (e.g. MAKE TYPE).  So if you <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/t-event.c#L322">wanted to MT_Event()</a> it would take in a BLOCK! and then immediately call a function called <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/t-event.c#L168">Set_Event_Vars()</a>.</p>
<p>The code is pretty short:</p>
<pre><code>REBVAL *var;
REBVAL *val;

while (NOT_END(blk)) {
    var = blk++;
    val = blk++;
    if (IS_END(val))
        val = NONE_VALUE;
    else
        val = Get_Simple_Value(val);
    if (!Set_Event_Var(evt, var, val))
        Trap2(RE_BAD_FIELD_SET, var, Of_Type(val));
}
</code></pre>
<p>It walks through the block, gathering two items at a time.  (If it only sees one item without a second, it uses a global NONE! value as the second.)</p>
<p><strong>Immediately you notice that this is going to be a much more "scant" form of evaluation than in MAKE OBJECT!</strong>.  If you weren't tipped off by the calling of a function named "Get_Simple_Value()" then you could notice that if you are only processing two values at a time, that's going to rule out things like</p>
<pre><code>make event! [type: second [read write]]
</code></pre>
<p>...because it would only see <strong><code>type: second</code></strong> in the first pair, and then <strong><code>[read write] #[none]</code></strong> in the second.</p>
<p>It's worse than it sounds.  Let's jump directly to <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/c-do.c#L1858">Get_Simple_Value()</a> to look at its implementation:</p>
<pre><code>if (IS_WORD(val) || IS_GET_WORD(val))
    val = Get_Var(val);
else if (IS_PATH(val) || IS_GET_PATH(val)) { //val = Get_Path_Var(val);
    REBVAL *v = val;
    DS_PUSH_NONE;
    Do_Path(&amp;v, 0);
    val = DS_TOP;
}
return val;
</code></pre>
<p>It basically does a "GET" of a WORD! or PATH!.  But there's no evaluation.  So if you say:</p>
<pre><code>get-type-word: does [either reading ['read] ['write]]

make event! [type: get-type-word port: http-port]
</code></pre>
<p>It won't <em>call</em> the GET-TYPE-WORD function.  It will <strong>GET</strong> the GET-TYPE-WORD function, and try to set the TYPE: to that.</p>
<p>Other values act similarly perplexingly...whether it's a GROUP!, or whether it's a LIT-WORD! that doesn't get evaluated.  So the <strong>Set_Event_Var()</strong> function <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/t-event.c#L83">has to accept LIT-WORD!s as well as WORD!s</a>, making things just a little bit more confusing.</p>
<h2>Why Is MAKE EVENT! So Much "Lousier" Than MAKE OBJECT! ?</h2>
<p>What MAKE OBJECT! does is it gathers all the SET-WORD!s in a block up and creates an object with those keys.  Then it binds the block you gave it to that object, and runs the code.  Since the set-words are all bound to the object, it just naturally works that the evaluation of ordinary expressions will sink the evaluative results into those words.</p>
<p>But the idea behind EVENT! was that it would be a very compressed data structure, so small it fit into one value cell.  This means that when it stores that <strong>TYPE:</strong> it isn't storing a pointer to an arbitrary word symbol...it's storing a small number from a finite list.</p>
<p>So TYPE can't be "bound" in a conventional sense.  There's no cell in a context to bind the word to.  There's just a packed bit pattern in an EVENT! structure.</p>
<p>You were able to say things like <strong>(<code>event/type: 'read</code>)</strong> because the way path dispatch worked, only the first element of the path was "bound".  It would lookup the event and then send it a message "change the type"...which it would do in its specialized bit packing way.  But you wouldn't be able to say <strong>do (bind [type: 'read] event)</strong> and have that work.</p>
<h2>In My Opinion Get_Simple_Value() Should Not Exist</h2>
<p>In truth, R3-Alpha did not have to be so stingy with the evaluator.  It had the ability to DO_NEXT() in a block, and where it used Get_Simple_Value() it could have done an evaluation.  It was there in the pursuit of performance.</p>
<p>But this kind of opens up a bigger field of questioning for the language, just in terms of "What is setting?" and "What is getting?"  You might argue that Get_Simple_Value() was some weird anomaly, but here was the behavior of GET itself in R3-Alpha:</p>
<pre><code>r3-alpha&gt;&gt; get (1 + 2)
== 3

r3-alpha&gt;&gt; get quote (1 + 2)
== (1 + 2)
</code></pre>
<p>I tried to phrase some questions like "Are GET and SET supersets of PICK and POKE, or do they provide different functionality" and there really isn't an articulation of this.</p>
<p><strong>It's like Rebol made a relatively concrete definition of what a SET-WORD! and a GET-WORD! are, but any understanding of a connection of these things to some functions named SET and GET are kind of unknown.</strong></p>
<p>It's hard whenever looking at the fun parts of playing with Rebol design to come back and face the fact that it's really kind of sitting on a kind of zero-semantics language model.  I feel like I'm making some progress on it, but drawing clean lines that people can build on reliably often feels out of reach for this particular medium.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/dissecting-r3-alphas-event-what-should-we-think/1724">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dissecting-r3-alphas-event-what-should-we-think/1724</link>
          <pubDate>Wed, 22 Sep 2021 20:40:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1724</guid>
          <source url="https://forum.rebol.info/t/dissecting-r3-alphas-event-what-should-we-think/1724.rss">Dissecting R3-Alpha&#39;s EVENT!: What Should We Think?</source>
        </item>
        <item>
          <title>A New, More Limited &quot;Word&quot; Type: SYMBOL! ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p><strong>Recently I decided <a href="https://forum.rebol.info/t/lexical-conflicts-back-to-bite-us-dots-in-tags/1702">it was more important to let TAG! have dots and slashes in it</a>, than it was to let "arrow words" be in paths or tuples.</strong></p>
<p>This felt a bit uncomfortable because it's creating a second-class citizen of WORD!... things like <strong><code>&lt;</code></strong> and <strong><code>&gt;</code></strong> and <strong><code>&gt;&gt;=</code></strong> and all their bretheren don't have the same abilities.</p>
<p>Maybe it just feels uncomfortable because it isn't being done more decisively...</p>
<h2>What If They Weren't WORD!s?</h2>
<p>If these were in a different category, like SYMBOL!, we could just say that they don't come in GET-WORD! or SET-WORD! or META-WORD! or THE-WORD! variations.  They don't go in TUPLE! and they don't go in PATH!.</p>
<p>They could still dispatch like WORD!s in the evaluator.  And they'd come in QUOTED! forms, so you could SET and GET them.  But also... look, multi-return can help, with single return!</p>
<pre><code>[::]: enfix :join
</code></pre>
<p>Put it in a SET-BLOCK! and there you go.  GET doesn't really have a parallel, but it's done more rarely and so things like <strong><code>get '::</code></strong> seems it's good enough.</p>
<h2>Opening Things Up</h2>
<p>With this new category, it seems like the doors are open to picking things that just don't play well with colons, slashes, or dots.  It wouldn't matter because they wouldn't have to.</p>
<p>I've been wanting <strong><code>:</code></strong> and <strong><code>::</code></strong> for a while now.  If they didn't have the burden of being WORD!s, then no one would ask questions like <em>"what does the SET-WORD! form of those things look like?"</em></p>
<p>It would mean that <strong><code>@</code></strong> and <strong><code>^</code></strong> could free up from being their own types, and just be symbols.</p>
<p>We wouldn't need to worry about the ambiguity of <strong><code>%</code></strong>, and it could be used to make paths...if that seemed like a good idea:</p>
<pre><code>&gt;&gt; % /some/(reverse "htap")
== %/some/path
</code></pre>
<p>I don't know if bringing <strong>/</strong> and <strong>//</strong> and <strong>.</strong> and <strong>...</strong> in as symbols vs paths/tuples is ideal.  Maybe there's some duality between them, where they're both somehow?  I'd have to think about it.</p>
<h2>What Should Be A Symbol?  = + - ?</h2>
<p>The "arrow words" came out of a mixture of <strong>&lt;</strong> and <strong>&gt;</strong> with characters that could be put into WORD!s, like <strong>-</strong> and <strong>+</strong> and <strong>|</strong> and <strong>=</strong>.</p>
<p>So if we're contemplating <strong><code>::</code></strong>, does that open up things like  <strong><code>:-:</code></strong>   It certainly seems like maybe <strong><code>:=</code></strong> would be more useful as a symbol than as the GET variation of equals.</p>
<p>But here are some thoughts:</p>
<ul>
<li>
<p>When it comes to mixing with words... I'll say that I've actually found that + in words can be useful, like <strong>file+extension</strong> to name a variable that is composed of more than one part.</p>
<ul>
<li>I've never felt tempted to do anything similar with =</li>
</ul>
</li>
<li>
<p>I have valued being able to put + and - in PATH!.  I used it for <strong><code>+/-</code></strong> to denote "signed" in ENBIN and DEBIN.</p>
<ul>
<li>Some similar situation might apply with <strong><code>=/=</code></strong>
</li>
</ul>
</li>
<li>
<p>Anything demoted to symbol status couldn't be used as a refinement either.  So there'd not eb any <strong><code>foo/=</code></strong> refinements</p>
</li>
</ul>
<p>Conservatively I'd imagine we wouldn't be seeing any mixing of <strong>+</strong> or <strong>-</strong> with <strong>:</strong> to make a symbol.  But I might leave <strong><code>:=</code></strong> on the table, partially because I feel = is less of a natural fit for being in words in the first place.</p>
<p>Then there's more to think about with whether <strong><code>&lt;:&gt;</code></strong> is valuable enough as an operator to outweigh being able to make a TAG! like <strong><code>&lt;:foo&gt;</code></strong> (if those things are truly in contention)</p>
<h2>But SYMBOL! Functions Can't Have Refinements...</h2>
<p>Can't be in paths means they can't have things after them to be refinements.</p>
<p>Oh well.  Tough luck.</p>
<p>As it happens they kind of couldn't have refinements anyway, because most symbols were winding up as infix functions.</p>
<h2>No Matter What, There's Only So Many Keys</h2>
<p>It may not sound like a big deal, but there's only so many symbols on the keyboard.  This will bring in a few symbols, but if anyone wants a lot more they'll have to go to unicode.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/a-new-more-limited-word-type-symbol/1709">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/a-new-more-limited-word-type-symbol/1709</link>
          <pubDate>Fri, 10 Sep 2021 01:56:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1709</guid>
          <source url="https://forum.rebol.info/t/a-new-more-limited-word-type-symbol/1709.rss">A New, More Limited &quot;Word&quot; Type: SYMBOL! ?</source>
        </item>
        <item>
          <title>Generalized Inertness with @</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="1634">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'm thinking this idea of <strong>"@[...] represents an already reduced block"</strong> is probably something we put in systemically:</p>
<pre><code>&gt;&gt; any [1 + 1 = 2]
== #[true]

&gt;&gt; any @[1 + 1 = 2]
== 1
</code></pre>
</blockquote>
</aside>
<p>So this is an important thought, but it runs up against the problem that we don't have a good operator for putting @ on things...whereas with quotes, we have that operator.</p>
<p>I'm kind of attached to this:</p>
<pre><code>&gt;&gt; @ block
== block
</code></pre>
<p>As opposed to this:</p>
<pre><code>&gt;&gt; block: [a b c]

&gt;&gt; @ block
== @[a b c]
</code></pre>
<p>The reason I'm attached to it is because of the API, largely.</p>
<pre><code>rebValue("append data", rebQ(value));
// vs...
rebValue("append data @", value);
</code></pre>
<p>So this was an advantage that quoted blocks had...which is that there <em>is</em> an operator for adding quote levels...and a word for it, too.  QUOTE.</p>
<pre><code>&gt;&gt; block: [1 + 2]

&gt;&gt; any quote block
== 1

&gt;&gt; any ^block
== 1

&gt;&gt; any ^ block
== 1
</code></pre>
<p>Several choices there.  But nothing to turn [1 + 2] into @[1 + 2]</p>
<p>There's the option of @(block)...</p>
<pre><code>&gt;&gt; block: [1 + 2]

&gt;&gt; @(block)
== @[1 + 2]

&gt;&gt; word: 'a

&gt;&gt; @(word)
== @a
</code></pre>
<p>This complicates the evaluator a bit, by making one of the @ types non-inert.  But beyond complicating the evaluator, I rather like the idea that @ means "no evaluation" and it applies to the GROUP! form too.</p>
<p>Maybe the operator could be called INERT?</p>
<pre><code>&gt;&gt; block: [1 + 2]

&gt;&gt; inert block
== @[1 + 2]

&gt;&gt; any inert block
== 1
</code></pre>
<p>That actually seems... fairly coherent.  I guess this is a better name for "THEIFY".</p>
<p>Anyway, the concept would be that it would offer a twist for any function that automatically reduced its argument...like SPACED.</p>
<pre><code>&gt;&gt; spaced @["hello" 1 + 2]
== "hello 1 + 2"

&gt;&gt; spaced ["hello" 1 + 2]
== "hello 3"
</code></pre>
<p>And UNPACK would be another instance of this.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/generalized-inertness-with/1707">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/generalized-inertness-with/1707</link>
          <pubDate>Wed, 08 Sep 2021 05:43:03 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1707</guid>
          <source url="https://forum.rebol.info/t/generalized-inertness-with/1707.rss">Generalized Inertness with @</source>
        </item>
        <item>
          <title>Lexical Conflicts Back To Bite Us: Dots In Tags</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>So I've been torn by the question of dots in tags, ever since the loss of <strong><code>&lt;...&gt;</code></strong> to mean variadics.</p>
<p>But that was how the scanner rules clanked together.  And since <strong>&lt;</strong> is a WORD!, if we assign that to an OBJECT! how do we get fields out of it?</p>
<pre><code>&gt;&gt; &lt;: make object! [x: 10]

&gt;&gt; &lt;.x
== 10
</code></pre>
<h2>But Something Has To Give</h2>
<p>I've been convinced.  Dots in tags have to win.</p>
<p>It's too useful to be able to say <strong><code>&lt;../foo.r&gt;</code></strong> as a file path.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>The state of the system is different now: PATH!s and TUPLE!s are immutable, so they can be checked for disallowed patterns.  We can set a bit on the special-cased words that contain <strong>&lt;</strong> or <strong>&gt;</strong> and then quickly check at path creation time that they contain none of these "arrow words".</p>
<p>This means any &lt; or &gt; that you see in a path or tuple are guaranteed to be part of a TAG!.</p>
<p>You can still make some confusing-looking things:</p>
<pre><code>..&lt;..&gt;..
</code></pre>
<p>But with the rule of "no &lt; or &gt; words inside a path or tuple", you can confidently read that as a 5-element TUPLE with a TAG! in the middle of it.</p>
<pre><code>&gt;&gt; as block! ..&lt;..&gt;..
[_ _ &lt;..&gt; _ _]
</code></pre>
<h2>How Will You Pick Fields Out of Objects In Arrow Words?</h2>
<p>For purely evaluative purposes, you could just use a GROUP!:</p>
<pre><code>('&lt;).field
</code></pre>
<p>We <em>could</em> try and make some kind of escaping syntax so the literal value could actually be represented in the path.  This would help generic code that took an ANY-WORD! and wanted to make a PATH! out of it:</p>
<pre><code>#[word! "&lt;"].field
</code></pre>
<p>But if we prohibited it, I'm not sure how bad that would be.  It could be a <a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it">"yagni"</a> situation.  :-/</p>
<p>For now, I'm just going to hack on the scanner and path mechanics a bit and get us the tags.  This will please those who would like the idea of <strong><code>&lt;/&gt;</code></strong> and <strong><code>&lt;//&gt;</code></strong> and <strong><code>&lt;.&gt;</code></strong> and <strong><code>&lt;..&gt;</code></strong> being a TAG!</p>
<p>I don't know whether this concession is going to wind up turning into backing off <strong>&lt;:</strong> and <strong>&gt;:</strong> or not.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<pre><code>('&lt;): does [print "Is this good enough, now?"]
</code></pre>
<p>It would open up <strong><code>&lt;:&gt;</code></strong> and <strong><code>&lt;::&gt;</code></strong> and <strong><code>&lt;:/some/thing&gt;</code></strong> and a lot more tags of that nature, for what may seem like a pretty negligible loss.</p>
<h2>Has The History of This Topic Been Churn With No Benefit?</h2>
<p><img src="https://forum.rebol.info/images/emoji/twitter/no_entry.png?v=9" title=":no_entry:" class="emoji" alt=":no_entry:">  <strong>NO</strong>.</p>
<p>Because when you look systemically at all the parts, generic TUPLE! and generic PATH! are showing great promise.  I think this world in which things like <strong>/foo</strong> are PATH! and <strong>a.(b).10</strong> is a TUPLE! are really the right way to go.</p>
<p>For that matter, I don't actually think it's so crazy to put on the lenses where <strong><code>&lt;../foo.r&gt;</code></strong> is a PATH! containing two tuples.</p>
<p>Consider another very similar looking example of <strong><code>+../foo.r+</code></strong>.  That's:</p>
<pre><code> as path! reduce [
     as tuple! [+ _ _]
     as tuple! [foo r+]
 ]
</code></pre>
<p>I actually think that line of thinking has a lot of interesting dialecting possibilities.  The thing that makes the example with &lt; and &gt; in it trip up is that it treads on the usefulness of tags...and you wind up where <strong>r&gt;</strong> isn't even a valid tuple component.  More is being sacrificed and less is being gained.</p>
<p>All in all, it's progress.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/lexical-conflicts-back-to-bite-us-dots-in-tags/1702">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/lexical-conflicts-back-to-bite-us-dots-in-tags/1702</link>
          <pubDate>Fri, 03 Sep 2021 11:45:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1702</guid>
          <source url="https://forum.rebol.info/t/lexical-conflicts-back-to-bite-us-dots-in-tags/1702.rss">Lexical Conflicts Back To Bite Us: Dots In Tags</source>
        </item>
        <item>
          <title>Separate Back-Tick String Type?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>The ability to represent most english and programming-speak in LOAD-able source is cool, and something I've encouraged taking advantage of:</p>
<pre><code>=== With COMMA! and generic tuple, we can do this.  (Cool, huh?) ===
</code></pre>
<p>There's a couple of hiccups.  Like you can't say <strong><code>4chan</code></strong>, but maybe you shouldn't anyway.  By making semicolons flush against things like <strong><code>abc;</code></strong> illegal, we help avoid bad English usages of semicolon... and also avoid the easy confusion that might cause with a SET-WORD! or other colon-ended type.</p>
<p>One thing I find myself wanting to do that I can't is use backticks to call things out:</p>
<pre><code>var: 20

=== I sometimes like to say that `var + 1000` would be 1020 ===
</code></pre>
<p>That's a standard usage of backticks in markdown.  But shell scripts use them for running commands in mid script and evaluating their results:</p>
<pre><code>set dircontents=$(ls)  # runs the ls command and gives back result

set dircontents=`ls`  # synonym
</code></pre>
<p>I really only use the <strong>$()</strong> form in my scripts, because I like to save the backticks for comments.  But it's a matter of taste, I guess.</p>
<h2>Notably... JavaScript uses it for String Interpolation</h2>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://developer.mozilla.org/favicon-48x48.97046865.png" class="site-icon" width="16" height="16">
      <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="noopener">developer.mozilla.org</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:123/69;"><img src="https://developer.mozilla.org/mdn-social-share.0ca9dbda.png" class="thumbnail" width="123" height="69"></div>

<h3><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="noopener">Template literals (Template strings) - JavaScript | MDN</a></h3>

<p>Template literals are literals delimited with backticks (`), allowing embedded expressions called substitutions.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>In the case that there is some harsh cost associated in binding with providing string interpolation, perhaps we could limit the binding penalty to only this string type...leaving the other TEXT! strings and such more efficient?</p>
<h2>This Seems Worth Considering</h2>
<p>I just thought of it because I was trying to do a code comment in one of my <code>===</code> headers as I point out above, and felt like I should be able to.</p>
<p>I might try it as an experiment.  Any name suggestions?</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/separate-back-tick-string-type/1676">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/separate-back-tick-string-type/1676</link>
          <pubDate>Sat, 21 Aug 2021 21:54:03 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1676</guid>
          <source url="https://forum.rebol.info/t/separate-back-tick-string-type/1676.rss">Separate Back-Tick String Type?</source>
        </item>
        <item>
          <title>Killing off Floating Point PAIR!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Rebol2 did not have floating point pairs:</p>
<pre><code>rebol2&gt;&gt; 10.20x3.04
** Syntax Error: Invalid tuple -- 10.20x3.04
</code></pre>
<p>Red is very focused on graphics and making PAIR! play a central role.  <em>Despite that, it also does not have floating point pairs</em>:</p>
<pre><code>red&gt;&gt; 10.20x3.04
*** Syntax Error: (line 1) invalid pair at 10.20x3.04
</code></pre>
<p>A particularly irksome aspect of the R3-Alpha implementation of PAIR! was that it used 32-bit floating point numbers in its math, while 64-bit double precision integers were behind DECIMAL!.  This meant you had two different precisions of math being implemented.  And you would lose information picking the decimal numbers out of pairs and putting them back in.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>That was also true of the integer form of PAIR! too.  You couldn't store an arbitrary 64-bit INTEGER! into a PAIR!, because it only had room for 2 32-bit integers in the cell.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>I fixed these issues by making a fully generic optimized mechanic that could store any two cells together.  This wound up being fairly relevant in other ways that have nothing to do with PAIR!.</p>
<p><strong>In any case, in the ever present drive to simplify anything that is not mission critical, I think decimal point pairs will probably get the axe.</strong>  They raise questions I simply do not feel are worth answering.</p>
<p><em>If not even Red can bring themselves to care, why on earth should I?</em></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/killing-off-floating-point-pair/1666">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/killing-off-floating-point-pair/1666</link>
          <pubDate>Mon, 16 Aug 2021 02:19:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1666</guid>
          <source url="https://forum.rebol.info/t/killing-off-floating-point-pair/1666.rss">Killing off Floating Point PAIR!</source>
        </item>
        <item>
          <title>SET-GROUP! Finds its Groove</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Having seen the slick multi-return behavior for SET-BLOCK!, I wondered if there was a better purpose for SET-GROUP! than merely a synonym for SET.</p>
<pre><code>(word): value
set word value
</code></pre>
<p>That felt a bit anticlimactic.  You save one character, but you add three non-alphabetic symbols.</p>
<p>If these were equivalent, were we really getting the bang for the buck we would want out of a sparkly new datatype?</p>
<p>So I hesitated to declare that to be the meaning.</p>
<h2>But I've Found The Reason <em>Why</em> It Needs To Be The Meaning...</h2>
<p><strong>It fills the role of being a <em>SINGLE</em> value, that can sit in literal slots to represent an assignment.</strong></p>
<p>That means you can say things like:</p>
<pre><code>(var): default [10]
</code></pre>
<p>It's impossible for this to work with:</p>
<pre><code>set var default [10]
</code></pre>
<p>Because it splits the intent to set the word pointed to by the variable into a function call to SET and a WORD! reference to VAR.  <em>DEFAULT can only quote value left, and it has to pack up all the information it needs to do its job.</em></p>
<p>So it really is a missing piece.  And really, I think there are a lot of cases where I'm just going to like <strong>(word):</strong> it better than <strong>set word</strong>.  It may be a bit more symbolic, but by not being wordy it could blend in better.</p>
<pre><code>var1: blah blah blah
var2: blah blah blah
(word): blah blah blah  ; doesn't break the rhythm as much as SET WORD
</code></pre>
<h2>I'll Start Patching In Behaviors For It... The First Is UPARSE EMIT!</h2>
<p>Right now, if you know the name you're going to emit for a variable, you can use it literally in GATHER:</p>
<pre><code>&gt;&gt; uparse [10 20] [gather [emit x: integer!, emit y: integer!]]
== make object! [
    x: 10
    y: 20
]
</code></pre>
<p>But what if the field's name is dynamic (maybe even captured from the parsed material itself?)  Well, SET-GROUP! seems the obvious answer, doesn't it?</p>
<pre><code>&gt;&gt; word: 'xxx

&gt;&gt; uparse "a" [gather [emit (word): &lt;any&gt;]]
== make object! [
    xxx: #a
]</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/set-group-finds-its-groove/1663">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/set-group-finds-its-groove/1663</link>
          <pubDate>Sun, 15 Aug 2021 01:20:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1663</guid>
          <source url="https://forum.rebol.info/t/set-group-finds-its-groove/1663.rss">SET-GROUP! Finds its Groove</source>
        </item>
        <item>
          <title>Using URL! for an IPv6 Type</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>TUPLE! is now generalized, and can be mixed with paths, which I think is a good direction.  It's also encouraging that it is mostly compatible with the previous kind of tuple.</p>
<p>However, those who think tuples were primarily for representing IP addresses will note that this doesn't really help you with representing IPv6 addresses.</p>
<p>I was closing some old rebol-issues and noticed there was a suggestion from earl of tackling this via the URL! type.</p>
<p>I thought I would link to that discussion and the points it raises:</p>
<p><a href="https://github.com/metaeducation/rebol-issues/issues/1976" class="inline-onebox">Revisit, refactor or rename tuple! · Issue #1976 · metaeducation/rebol-issues · GitHub</a></p>
<p>One of the points is that URL!s aren't checked for validity, so it doesn't have the "rigor" that a notational IPV6! datatype might have.  Which may displease some people, as not being much better than a string.</p>
<p>In any case, I'm closing the original issue itself, as I feel the broad issue of TUPLE!s is solved.  But wanted something to come up here if a search were done on "IPv6".</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/using-url-for-an-ipv6-type/1627">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/using-url-for-an-ipv6-type/1627</link>
          <pubDate>Thu, 17 Jun 2021 22:33:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1627</guid>
          <source url="https://forum.rebol.info/t/using-url-for-an-ipv6-type/1627.rss">Using URL! for an IPv6 Type</source>
        </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Datatypes - AltRebol</title>
    <link>https://forum.rebol.info/c/development/datatypes/45</link>
    <description>Topics in the &#39;Datatypes&#39; category The datatypes category is for the discussion of the specific properties of datatypes themselves.  Sample topics might include:</description>
    
      <lastBuildDate>Sat, 09 Mar 2024 08:49:19 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/datatypes/45.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Antiform TAG! As &quot;Triggers an Error On Access&quot; Type</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>In the post <a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604">"Shades of Distinction In Non-Valued Intents"</a>, I had originally written:</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1604">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604/1">Shades of Distinction In Non-Valued Intents</a>
</div>
<blockquote>
<p>Eventually the NULL state became the isotopic status of the WORD! null, so a <strong>~null~</strong> antiform.</p>
<p>It joined <strong>~true~</strong> and <strong>~false~</strong> as being antiforms you could test for truthiness and falseyness. But if you were okay with getting an error on conditional testing, any other word could be used:</p>
<pre><code class="lang-plaintext">  config: ~initialize-system-not-called~

  initialize-system: func [
      {Let's say this function reads the config file}
  ][
      ...
      config: [...]
  ]
</code></pre>
<p>This usually causes a nice labeled message anytime someone tries to use CONFIG:</p>
<p>Going this route would create a pain point for anyone who thought they were going to test for whether you had a config initialized by testing <strong>if config [...]</strong>. So that has to be considered as whether it's what you want.</p>
</blockquote>
</aside>
<p>I've come to question this as things have gone on, to where I'm wondering if all antiform words should be reserved by the system (there are system purposes for the ~end~ antiform, for instance).</p>
<p>A generic "error trigger" might come from something like antiform TAG!, permitting spaces:</p>
<pre><code>config: ~&lt;INITIALIZE-SYSTEM not called&gt;~

initialize-system: func [
    {Let's say this function reads the config file}
][
    ...
    config: [...]
]

&gt;&gt; config
** Error: INITIALIZE-SYSTEM not called
</code></pre>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/antiform-tag-as-triggers-an-error-on-access-type/2170">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/antiform-tag-as-triggers-an-error-on-access-type/2170</link>
          <pubDate>Sat, 09 Mar 2024 08:49:19 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2170</guid>
          <source url="https://forum.rebol.info/t/antiform-tag-as-triggers-an-error-on-access-type/2170.rss">Antiform TAG! As &quot;Triggers an Error On Access&quot; Type</source>
        </item>
        <item>
          <title>What is the use of typesets?</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Recent discussions have brought the notion of ‘typesets’ to my attention. On reading the source code, this confused me a bit… they don’t seem to be used all that much. Moreover, they seem to be subsumed by the idea of optimised constraint functions.</p>
<p>So I set out to try them myself. Only to find myself thoroughly confused, because typesets don’t actually seem to be accessible from Ren-C itself. Or, at least, none seem to be defined — normal type names evaluate to TYPE-BLOCK!s as expected, but typeset names are unassigned:</p>
<pre><code class="lang-plaintext">&gt;&gt; word!
== &amp;[word]

&gt;&gt; text!
== &amp;[text]

&gt;&gt; any-utf8!
** Script Error: any-utf8! word is attached to a context, but unassigned
** Where: console
** Near: [any-utf8! **]
** Line: 1

&gt;&gt; any-type-value!
** Script Error: any-type-value! word is attached to a context, but unassigned
** Where: console
** Near: [any-type-value! **]
** Line: 1
</code></pre>
<p>[On which note, incidentally, let me yet again mention my conviction that the other TYPE-* datatypes are useless and should be removed.]</p>
<p>I expected to at least be able to use them in function signatures, but I can’t even do that, since it crashes a program:</p>
<pre><code class="lang-plaintext">&gt;&gt; test: func [x [word!]] [return x]
== ~#[frame! {test} [x]]~  ; anti

&gt;&gt; test: func [x [any-utf8?]] [return x]
== ~#[frame! {test} [x]]~  ; anti

&gt;&gt; test: func [x [any-utf8!]] [return x]
Assertion failure: QUOTE_BYTE(v) == ANTIFORM_0
Line 165, File: /home/bradrn/Documents/red/ren-c/src/include/cells/cell-quoted.h
Trace/breakpoint trap (core dumped)
</code></pre>
<p>So… if they can’t be accessed from Ren-C itself, then why does the interpreter have typesets at all?</p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/what-is-the-use-of-typesets/2153">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-is-the-use-of-typesets/2153</link>
          <pubDate>Tue, 20 Feb 2024 04:29:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2153</guid>
          <source url="https://forum.rebol.info/t/what-is-the-use-of-typesets/2153.rss">What is the use of typesets?</source>
        </item>
        <item>
          <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <h2>
<a name="the-limited-and-ambiguous-historical-idea-1" class="anchor" href="https://forum.rebol.info#the-limited-and-ambiguous-historical-idea-1"></a>The Limited and Ambiguous Historical Idea</h2>
<p>People are used to being able to do things like:</p>
<pre><code> x: 10
 switch type? x [
     integer! [print "It's an integer"]
     block! [print "It's a block"]
 ]

 assert [parse [1 [second] 'foo] [integer! block! lit-word!]]

 assert [find any-word! (type? first [x:])]
</code></pre>
<p>But the historical DATATYPE! and TYPESET! were strange.</p>
<ul>
<li>
<p>DATATYPE! rendered as a WORD! but was really wrapping an integer of 0-63</p>
</li>
<li>
<p>TYPESET! was a 64-bit bitset, one bit for each type (this is where the 64 types limit came from)</p>
<ul>
<li>
<p>it lost its meaning in rendering (it kept no record of what the set actually was...just dumped words for each bit)</p>
</li>
<li>
<p>not preserving the name from a fixed list of typesets was based on the concept you could make your own or UNION/INTERSECT them</p>
</li>
</ul>
</li>
</ul>
<p>So it looked like this:</p>
<pre><code>red&gt;&gt; type? 1
== integer!

red&gt;&gt; type? type? 1
== datatype!

red&gt;&gt; print mold any-word!
make typeset! [word! set-word! lit-word! get-word!]

red&gt;&gt; print mold any-type!
make typeset! [datatype! unset! none! logic! block! paren! string! file! url!
    char! integer! float! word! set word! lit-word! get-word! refinement! issue!
    native! action! op! function! path! lit-path! set-path! get-path! routine!
    bitset! object! typeset! error! vector! hash! pair! percent! tuple! map!
    binary! time! tag! email! handle! date! port! money! ref! point2D! point3D!
    image! event!]
</code></pre>
<h2>
<a name="the-type-xxx-approach-2" class="anchor" href="https://forum.rebol.info#the-type-xxx-approach-2"></a>The TYPE-XXX! Approach</h2>
<p>So Ren-C attacked the ambiguity and extensibility with a new word type, TYPE-WORD!.  Then typesets used TYPE-GROUP! and TYPE-BLOCK!, referencing functions to act as type testing predicates, and using groups for intersections and blocks for unions:</p>
<pre><code>&gt;&gt; type of 1
== &amp;integer

&gt;&gt; type of type of 1
== &amp;type-word

&gt;&gt; print mold any-word!
&amp;(any-word?)

&gt;&gt; print mold any-value!
&amp;(any-value?)
</code></pre>
<p>This gives some realistic axis of extensibility, and gives distinguishable entities that can trigger behaviors in PARSE when something looks up to type-xxx!.  (this shows why using WORD! or URL! or ISSUE! wouldn't work, because the type intent has to be carried by what e.g. INTEGER! looks up to.)</p>
<p><strong>Calling functions to implement type checks vs. checks on a bitset, especially when an array of functions must be called when checking every parameter in every function call, is a difficult performance point.</strong></p>
<p><a href="https://forum.rebol.info/t/intrinsics-functions-without-frames/2050">Intrinsics and other magic are employed to rein it in.</a>  It's not particularly simple...but finding ways to speed up function calls where you can has systemic benefit.</p>
<h2>
<a name="new-consequence-find-must-find-type-word-normally-3" class="anchor" href="https://forum.rebol.info#new-consequence-find-must-find-type-word-normally-3"></a>New Consequence: FIND Must Find TYPE-WORD! Normally</h2>
<p>Being a legitimate datatype that can be stored in a block, some interpretations of datatype by functions like FIND were problematic:</p>
<pre><code>red&gt;&gt; block: reduce ["hello" integer! 1]
== ["hello" integer! 1]

red&gt;&gt; find block 'integer!
== none  ; rendering was a lie

red&gt;&gt; find block integer!
== [1]
</code></pre>
<p>You couldn't find a literal datatype in a block.  Ren-C is approaching this by saying FIND has to find the TYPE-WORD! (as it does for all non-antiforms), but that you can use antiform actions as predicates.</p>
<pre><code>&gt;&gt; block: reduce ["hello" integer! 1]
== ["hello" &amp;integer 1]

&gt;&gt; find block integer!
== [&amp;integer 1]

&gt;&gt; find block :integer?
== [1]
</code></pre>
<p>There was some thought that maybe you could create antiform TYPE-XXX! and call them "matchers", passing them to FIND.</p>
<ul>
<li>
<p>But this is an isotope for each TYPE-XXX!, so it's not even like there would be one "matcher"</p>
</li>
<li>
<p>It also would be the only instance of antiforms of types with sigils, which doubles the sigil to make <strong><code>~&amp;integer~</code></strong>, which I find kind of displeasing</p>
</li>
</ul>
<p>I feel that antiform actions cover it for FIND, and if you have higher level needs you should use something like PARSE which has richer options and isn't beholden to quite the "mechanical" answer that a series primitive like FIND has to abide by with its limited parameterization.</p>
<h2>
<a name="new-annoyance-type-of-quotes-and-antiforms-4" class="anchor" href="https://forum.rebol.info#new-annoyance-type-of-quotes-and-antiforms-4"></a>New Annoyance: TYPE OF Quotes And Antiforms</h2>
<p>When there were only two datatypes with quotedness, the quote was part of their datatype:</p>
<pre><code>red&gt;&gt; type? first ['a]
== lit-word!

red&gt;&gt; type? first ['a/b]
== lit-path!

red&gt;&gt; lit-word! = type? first ['a]
== true

red&gt;&gt; parse ['a 'a/b] [lit-word! lit-path!]
== true
</code></pre>
<p>Ren-C's approach affords the ability make type constraints to carry forward the PARSE behavior.  But the TYPE OF all quoteds is the same... &amp;QUOTED.</p>
<pre><code>&gt;&gt; lit-word?!
== &amp;(lit-word?)

&gt;&gt; lit-word?! = type of first ['a]
== ~false~  ; anti

&gt;&gt; type of first ['a]
== &amp;quoted
</code></pre>
<p>So perhaps you see the motivation to decorate as <strong>?!</strong> instead of just <strong>!</strong> for the type constraints.  People need to know that these aren't fundamental types.  You have to use e.g. MATCH with them:</p>
<pre><code> &gt;&gt; match lit-word?! first ['a]
 == 'a

 &gt;&gt; match lit-word?! 10
 == ~null~  ; anti

 &gt;&gt; match [lit-word?] first ['a]  ; alternative as 1st slot known "typelike"
 == 'a
</code></pre>
<p>This is something of a pain point, and I'm not entirely settled on whether it would be good to delve into some kind of ambiguity where we are actually allowed to get back constraint functions as the answer to TYPE OF, and make that the fundamental:</p>
<pre><code>&gt;&gt; type of 1
== &amp;integer?

&gt;&gt; type of spread [a b]
== &amp;splice?

&gt;&gt; type of ~true~
== &amp;logic?

&gt;&gt; type of first ['a]
== &amp;quoted? 
</code></pre>
<p>So I don't think this is a good idea for the quoted types, but for the antiforms it might be a narrow enough thing that it provides "what the people want".</p>
<pre><code>&gt;&gt; switch type of true [
     splice! [...]
     logic! [...]
     integer! [...]
  ]
</code></pre>
<p>Barring that, what we have to do today is flip SWITCH over into a MATCH mode (currently called SWITCH/TYPE but should probably be SWITCH/MATCH... or maybe it should take the MATCH name):</p>
<pre><code>&gt;&gt; switch/type true [
     splice?! [...]
     logic?! [...]
     integer! [...]
  ]
</code></pre>
<p>Note that the <code>?!</code> distinction is a new idea which hasn't made it to all type constraints yet, e.g. ANY-VALUE! is still as it was.  But because parameters use what is effectively a TYPE-BLOCK! you can say <strong><code>any-value?</code></strong> or <strong><code>splice?</code></strong> in them instead of going through the extra step.</p>
<h2>
<a name="should-type-be-a-bigger-concept-5" class="anchor" href="https://forum.rebol.info#should-type-be-a-bigger-concept-5"></a>Should TYPE Be A Bigger Concept?</h2>
<p>One thing that has nagged me is if when we ask for the fundamental "cell type" of something, if we should avoid using the word "TYPE" for that at all...</p>
<p>Maybe there's some bigger idea in an object/class system where TYPE is meaningful to say something more than "this is an object" but rather "this is a book", where you can ask also "is a book readable".  Etc.</p>
<p>Or maybe TYPE can be parameterized:</p>
<pre><code> &gt;&gt; type of matrix
 == &amp;[matrix 10x10]
</code></pre>
<p>So this would mean there's a smaller question about the fundamental type, maybe call it "KIND":</p>
<pre><code>&gt;&gt; kind of [a b c]
== &amp;block

&gt;&gt; kind of matrix
== &amp;object
</code></pre>
<p>It would be nice to just be able to say "64 types is enough for anyone" and say "there, it's done".  I'd be happy to do that if I felt that it was enough.  It wasn't, even when thinking along fairly limited lines that don't go in these fancier directions.</p>
<p><em>I don't think any near-term system will actualize on bigger visions of what TYPE might be, but it would help to know if that should be ruled out or not, just in order to pick the term KIND or TYPE!</em>  But even that question is murky.</p>
<h2>
<a name="some-related-reading-typesr-6" class="anchor" href="https://forum.rebol.info#some-related-reading-typesr-6"></a>Some Related Reading: %types.r</h2>
<p>The dialected table used to construct the type testing macros and other things is kind of neat, though some comments are out of date and parts of it need updating (it's getting upgraded in an upcoming commit which finally breaks the 64-type barrier and introduces the $ types):</p>
<p>See <a href="https://github.com/metaeducation/ren-c/blob/master/src/boot/types.r"><strong>%types.r</strong></a></p>
            <p><small>20 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151</link>
          <pubDate>Fri, 16 Feb 2024 23:29:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2151</guid>
          <source url="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
        </item>
        <item>
          <title>A proliferation of $#@^&#39;:~WORD~:s</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>One of the things which surprised me when I first looked into Ren-C was the number of WORD variants it has. By my count, this includes:</p>
<ul>
<li>plain WORD</li>
<li>:GET-WORD</li>
<li>SET-WORD:</li>
<li>
<code>@THE-WORD</code> *</li>
<li>^META-WORD</li>
<li>&amp;TYPE-WORD</li>
<li><span class="hashtag">#ISSUE</span></li>
<li>'QUOTED</li>
<li>~ANTIFORM~</li>
<li>…and probably more that I’ve forgotten.</li>
</ul>
<p><small>* monospaced so Discourse doesn’t think it’s a ping</small></p>
<p>Now, in many ways this is perfectly expected for a language like Ren-C. Firstly, dialecting means we value having as many syntactic options as possible. Secondly, Ren-C has a lot of different kinds of values — plain, quoted, anti and quasi, and now bound and unbound versions of each — and most of these words are simply making it easier to deal with that huge variety.</p>
<p>But, on the other hand, I feel we’re starting to encounter some problems with the current way of doing things. Most notably:</p>
<ol>
<li>None of this is compositional. When we <a href="https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359/7">run into a situation</a> where we’d like to, say, have a word which is both META- and THE-, it’s impossible.</li>
<li>Some dialects would like to use words outside this fixed inventory. For instance, it would be nice to have <a href="https://forum.rebol.info/t/upcoming-datatype-word-what-will-it-mean/2146">$WORDs to use in a shell dialect</a>.</li>
</ol>
<p>The root cause of both is the same: the inventory of word-like datatypes is hard-coded into the interpreter. If you want to use something outside that set, you can’t, no matter how similar to the existing types it may seem.</p>
<p>I can imagine a hypothetical design which would avoid this. This would allow some characters to be freely added to the beginning and end of words — let’s call those special characters ‘sigils’, like in Perl. Every combination of sigils would then specify a separate datatype. So you would still have :WORDs and ^WORDs and ~WORD~s, but also $WORDs and ^@WORDs and ~#WORD&amp;s and whatever else you could imagine. This would quite easily solve both of the problems I mentioned.</p>
<p>One might even contemplate generalising this ‘sigil’ idea to non-word types. We already have {GET,SET,THE,META}-{BLOCK,GROUP}s, so it would make sense to allow arbitrary sigils on blocks and groups too.</p>
<p>Unfortunately, I’m not sure this would work with the current design of Ren-C. At the moment, there is currently a hard maximum of (as I recall) 256 possible datatypes, whereas this proposal obviously allows for an infinite amount of datatypes. However, I do think it’s at least worth thinking about, for the simple reason that it would give us a lot more flexibility than we currently have.</p>
            <p><small>10 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/a-proliferation-of-word-s/2147">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/a-proliferation-of-word-s/2147</link>
          <pubDate>Tue, 13 Feb 2024 12:58:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2147</guid>
          <source url="https://forum.rebol.info/t/a-proliferation-of-word-s/2147.rss">A proliferation of $#@^&#39;:~WORD~:s</source>
        </item>
        <item>
          <title>Upcoming Datatype $WORD... What Will It Mean?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Something that has been nagging at me is that I've known I want to introduce <strong>$WORD</strong>, <strong>$(GR O UP)</strong>, <strong>$TU.P.LE</strong> etc. (tentative names VAR-WORD!, VAR-GROUP!, VAR-TUPLE!).</p>
<p>At first glance it seems like it would be a loss if $XXX didn't in the baseline evaluator evaluate to looking up environment variables.</p>
<p>But this would be a different behavior for an ANY-WORD!...which up until now, the type of word has not mattered.  Would it spread to SET?</p>
<pre><code>&gt;&gt; set-env "SOMETHING" "TRUE"

&gt;&gt; SOMETHING: 10

&gt;&gt; set (in [] '$SOMETHING) "FALSE"
== "FALSE"

&gt;&gt; SOMETHING
== 10

&gt;&gt; get-env "SOMETHING"
== "FALSE"
</code></pre>
<p>Hmmm.  Lots of issues there...including that Unix environment variables are case-sensitive, Windows ones are not.</p>
<p>The implementation mechanism of this would presumably have to introduce some sort of "pseudo-object" named <code>environment</code>/<code>env</code>, and then the "specifier" would have to say (in a similar way to which the ".WORD" lookups would say to look in a "current object") that the $ words should look up in env.   <em>(See related discussion about <a href="https://forum.rebol.info/t/binding-indirection/2112">"Binding Indirection"</a>)</em></p>
<h2>
<a name="simpler-thought-1" class="anchor" href="https://forum.rebol.info#simpler-thought-1"></a>Simpler Thought...</h2>
<p>A simpler thought (that doesn't rock the boat for one feature) would be that this is a bridge too far for an ANY-WORD!, and they should look up just like any other word, and it's only weird shell dialects that would think that a $WORD meant environment variables.</p>
<p>But then the question might be what the $ buys you.</p>
<p>Maybe I was too hasty in saying that the @ was the right thing to sacrifice for "get variable with binding", and $ should have done that?</p>
<pre><code>&gt;&gt; $word
== word  ; bound

&gt;&gt; @word
== @word  ; bound?
</code></pre>
<p>(A line of argumentation that <code>@word</code> should be bound, is that if you want an unbound one you can get it by quoting with <code>'@word</code>, but then again if the @ operator does not bind e.g. @ foo... but $ does, e.g. $ foo.  So maybe not affecting the binding is the better choice.)</p>
<p>This would let us put back the @ for "as-is" variable usage in parse.  And it would make more sense for a thing named VAR-WORD! (bound variable in evaluator, environment var in shell dialect...)</p>
<p>Urrrgh.  I hate that it seems like that's probably right.  :-/   <em>(Thankfully, git lets us audit/reverse such decisions...assuming you're diligent about not changing too many unrelated things in one commit, which I thankfully was careful about with the @ change.)</em></p>
<h2>
<a name="loss-of-for-weird-idea-i-had-2" class="anchor" href="https://forum.rebol.info#loss-of-for-weird-idea-i-had-2"></a>Loss of $ For Weird Idea I Had</h2>
<p>If the $ operator were used for binding that would be a bit sad, as I'd kind of hoped that could be a variadic function that could run the <a href="https://github.com/metaeducation/ren-c/blob/3e5f724197f55d2745436a52ca1dfa7c5d7e4db5/scripts/shell.r#L4">shell dialect</a>:</p>
<pre><code>extension: "txt"

$ ls -alF *.(extension)
</code></pre>
<p>But, maybe that's a bad way to package it in the box, and specialty scripts that don't care about a $ operator for binding purposes can override it, encouraging the more traditional:</p>
<pre><code>extension: "txt"

shell [ls -alF *.(extension), echo $SOMETHING]
</code></pre>
            <p><small>11 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/upcoming-datatype-word-what-will-it-mean/2146">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/upcoming-datatype-word-what-will-it-mean/2146</link>
          <pubDate>Tue, 13 Feb 2024 11:51:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2146</guid>
          <source url="https://forum.rebol.info/t/upcoming-datatype-word-what-will-it-mean/2146.rss">Upcoming Datatype $WORD... What Will It Mean?</source>
        </item>
        <item>
          <title>Meaning of META-BLOCK! ^[...]</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="2135">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/repurposing-the-xxx-xxx-for-undecorated-values/2135/1">Repurposing THE-XXX! (@xxx) For Undecorated Values</a>
</div>
<blockquote>
<p>In any case, preliminary looking at the results <strong><a href="https://forum.rebol.info/t/repurposing-the-xxx-xxx-for-undecorated-values/2135">(of repurposing the @xxx types)</a></strong>, I think this is a solid change and much needed in the new binding world.</p>
</blockquote>
</aside>
<p>Found one glitch... there was an idiom of using the inertness in some places with blocks.</p>
<pre><code>&gt;&gt; spaced ["Reduced" 1 + 2 "Content"]
== "Reduced 3 Content"

&gt;&gt; spaced @["Unreduced" 1 + 2 "Content"]
== "Unreduced 1 + 2 Content"

&gt;&gt; meta pack [1 + 2 10 + 20]
== ~['3 '30]~

&gt;&gt; meta pack @[1 + 2 10 + 20]
== ~['1 '+ '2 '10 '+ '20]~
</code></pre>
<p>This won't work anymore, as the evaluator isn't inert here.</p>
<p>HOWEVER... there is a construct that can pick up the slack.  The META-BLOCK!</p>
<pre><code>&gt;&gt; ^[1 + 2 10 + 20]
== '[1 + 2 10 + 20]
</code></pre>
<p>It produces a block which is quoted, and which captured a binding.  So it is suitable for this purpose.  It does raise questions like "what to do if the block is double or triple quoted" etc, but I think raising an error is fine for the moment.</p>
<hr>
<p>Coincidentally, I was thinking about my desire to have a proper FOR dialect.</p>
<pre><code> &gt;&gt; for x [1 to 3] [print x]
 1
 2
 3
</code></pre>
<p>And then, the concept of "going meta" struck me as interesting:</p>
<pre><code> &gt;&gt; for x meta [1 to 3] [print x]
 1
 to
 3
</code></pre>
<p>Which would mean that FOR when given a quoted block would enumerate its contents vs. run the dialect.  Then you could also write that as:</p>
<pre><code> &gt;&gt; for x ^[1 to 3] [print x]
 1
 to
 3
</code></pre>
<p>If you didn't want a binding you need a quoted block and a generator applied to the resulting unbound block:</p>
<pre><code> &gt;&gt; for x each '[1 to 3] [print x]
 1
 to
 3
</code></pre>
<p>It's interesting to see the parts coming together with some things not being as useless as first thought.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/meaning-of-meta-block/2145">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/meaning-of-meta-block/2145</link>
          <pubDate>Mon, 29 Jan 2024 08:50:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2145</guid>
          <source url="https://forum.rebol.info/t/meaning-of-meta-block/2145.rss">Meaning of META-BLOCK! ^[...]</source>
        </item>
        <item>
          <title>Repurposing THE-XXX! (@xxx) For Undecorated Values</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Historical Rebol used quoted words (LIT-WORD!) to pass variables to functions, with the idea the function could then later set or get those variables.  The quote level was removed under evaluation, meaning the function got a WORD!</p>
<pre><code>rebol2&gt;&gt; whatever: 10

rebol2&gt;&gt; foo: func [var [word!]] [print [var "is" get var]]

rebol2&gt;&gt; foo 'whatever
whatever is 10
</code></pre>
<p>But we now have a general rule that quoting insulates whatever you quote from binding.  So you have to add the binding, by saying something like <strong><code>foo in [] 'whatever</code></strong></p>
<p>This isn't the only option, if the callee was willing to receive something other than WORD!.  We also have THE-WORD!, which currently evaluates to the bound version of itself.</p>
<pre><code>&gt;&gt; @whatever
== @whatever

&gt;&gt; foo: func [var [the-word!]] [print [var "is" get var]]

&gt;&gt; foo @whatever
@whatever is 10
</code></pre>
<p>This gets you the binding you want, but now you have a decorated word, which would be annoying if FOO is trying to do something besides GET/SET the value.  Plain words are the norm.</p>
<p>If you wanted an undecorated word, you could use the standalone @ operator... which gives back its argument literally:</p>
<pre><code>&gt;&gt; @ a
== a
</code></pre>
<p><strong><code>@ a</code></strong> is a little bit uglier than <strong><code>'a</code></strong> but not as bad as <strong><code>in [] 'a</code></strong></p>
<pre><code>&gt;&gt; foo: func [var [word!]] [print [var "is" get var]]

&gt;&gt; foo @ whatever
whatever is 10
</code></pre>
<p>But the spacing just throws it off to where it no longer looks like a single argument.  And it doesn't look like one because it isn't (e.g. can't fill exactly one slot in the API or a COMPOSE).  @ is also a function under the current design (you can redefine it), so calling it incurs some overhead.</p>
<h2>
<a name="or-we-could-say-that-things-evaluate-and-drop-the-1" class="anchor" href="https://forum.rebol.info#or-we-could-say-that-things-evaluate-and-drop-the-1"></a>Or... We Could Say that @ Things Evaluate And Drop The @</h2>
<pre><code>&gt;&gt; @word
== word  ; bound

&gt;&gt; @(print "Hello")
== (print "Hello")  ; bound

&gt;&gt; @[print "Hello"]
== [print "Hello"]  ; bound, less useful as plain block would have done that
</code></pre>
<p>This would make <strong><code>@word</code></strong> and <strong><code>@ word</code></strong> symmetrical, which is appealing.</p>
<p>But it's at the cost of losing the idea of a category of ANY-WORD! that stays somewhat as-is.</p>
<h2>
<a name="how-big-a-loss-is-the-inert-wordgrouptuplepath-2" class="anchor" href="https://forum.rebol.info#how-big-a-loss-is-the-inert-wordgrouptuplepath-2"></a>How Big A Loss Is The "Inert" WORD!/GROUP!/TUPLE!/PATH!</h2>
<p>In practice, the idea of inert words hasn't lived up to my hopes for them.  I thought maybe since they would be shielded from multiple phases of reducing, they might become popular for some kind of enumerated types.  But being a bit ugly, that's not materialized.</p>
<p>If it gives you any idea of how not-popular the application has been, I changed the evaluator behavior and it <a href="https://github.com/metaeducation/ren-c/blob/0d2d7c39733f21e1088240ab2e5c7614072c8059/src/mezz/uparse.r#L151">only required <em>one</em> change in UPARSE to boot</a>:</p>
<pre><code>  (if spec.1 = '@pending [
        assert [spec.2 = [&lt;opt&gt; block!]]
        autopipe: false  ; they're asking to handle pending themselves
        spread reduce [@pending spec.2]  ; &lt;-- this has to be '@pending
        elide spec: my skip 2
    ] else [
        autopipe: true  ; they didn't mention pending, handle automatically
        spread [@pending [&lt;opt&gt; block!]]
    ])
</code></pre>
<p>They're still free to be used in dialects for whatever purpose (here we see them marking output parameters in the function spec dialect).  And they serve a good purpose in PARSE for "treat this value literally":</p>
<pre><code>&gt;&gt; block: [some "a"]

&gt;&gt; parse ["a" "a"] [block]
== "a"

&gt;&gt; parse [[some "a"] [some "a"]] [some @block]
== [some "a"]
</code></pre>
<p>But it seems that with the new binding model, they have a higher calling in the evaluator... for producing undecorated bound things!</p>
<p>If you want wordlike things that do not reduce, there's blank-headed paths like <strong><code>/FOO</code></strong> ("refinement").  They have a binding and can be looked up.  Today, blank-headed tuples like <strong><code>.FOO</code></strong> don't evaluate, but I'm aiming to say that they do--and that they do member lookup in methods.  Or... y'know... you could put the word in a block! <strong><code>[foo]</code></strong></p>
<h2>
<a name="note-that-decorated-types-have-to-use-3" class="anchor" href="https://forum.rebol.info#note-that-decorated-types-have-to-use-3"></a>Note That Decorated Types Have To Use @</h2>
<p>There's no such thing as a THE-SET-BLOCK! (and I don't imagine there ever will be).</p>
<pre><code> &gt;&gt; @[x y]:
 ** Error: That doesn't exist

 &gt;&gt; @ [x y]:
 == [x y]:
</code></pre>
<p>So it's only the plain WORD!, TUPLE!, PATH!, GROUP! and (redundantly) BLOCK! that you can do this without a space.</p>
<p>But it's likely much rarer to be generating such material bound in isolation.</p>
<p>In any case, preliminary looking at the results, I think this is a solid change and much needed in the new binding world.</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/repurposing-the-xxx-xxx-for-undecorated-values/2135">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/repurposing-the-xxx-xxx-for-undecorated-values/2135</link>
          <pubDate>Mon, 29 Jan 2024 06:12:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2135</guid>
          <source url="https://forum.rebol.info/t/repurposing-the-xxx-xxx-for-undecorated-values/2135.rss">Repurposing THE-XXX! (@xxx) For Undecorated Values</source>
        </item>
        <item>
          <title>Why There&#39;s No Boolean Type Storable in a BLOCK!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2094">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/which-isotopes-are-currently-in-use/2094/1">Which isotopes are currently in use?</a>
</div>
<blockquote>
<p>Isotopic WORD!s seem to be error states of some description, as well as booleans — except that makes no sense to me, since surely booleans should be storable in blocks‽</p>
</blockquote>
</aside>
<p>Rebol made an unusual choice in deciding that all things that "look like" words would be words, and reassignable.  So <strong>true</strong> and <strong>false</strong> were kept following the general rules of words.  Including that all words are truthy.</p>
<pre><code>&gt;&gt; code: [flag: false]

&gt;&gt; second code
== false

&gt;&gt; if second code [print "the word false is truthy"]
the word false is truthy
</code></pre>
<p>There was a LOGIC! type, and it could be made via the <code>#[true]</code> and <code>#[false]</code> notation:</p>
<pre><code>rebol2&gt;&gt; code: [flag: #[false]]

rebol2&gt;&gt; if not second code [print "the literal #[false] is falsey"]
the literal #[false] is falsey
</code></pre>
<p>So the default definitions are <strong>true: #[true]</strong> and <strong>false: #[false]</strong>.  But the rendering would conflate with the word, despite not being a word:</p>
<pre><code>rebol2&gt;&gt; code: [flag: #[false]]

rebol2&gt;&gt; code
== [flag: false]

rebol2&gt;&gt; type? second code
== logic!

rebol2&gt;&gt; true
== true

rebol2&gt;&gt; word? true
== false
</code></pre>
<p>There was puzzling about wondering what a better notation for LOGIC! literals might be.  Considerations included things like <strong>$true</strong> and <strong>$false</strong>, among others.</p>
<p>I wanted to see there be <strong><code>$word $(gr o up) $[bl o ck] $tu.p.le $pa/th</code></strong> as additional pieces in the box of parts...so sacrificing $ for this wasn't appealing to me.</p>
<p>Hence for a long time, Ren-C just rendered them as #[true] and #[false].</p>
<h2>
<a name="rebolreds-bad-rendering-reveals-a-subliminal-truth-1" class="anchor" href="https://forum.rebol.info#rebolreds-bad-rendering-reveals-a-subliminal-truth-1"></a>Rebol/Red's Bad Rendering Reveals a Subliminal Truth</h2>
<p>As it turns out, a lot of places where you're building up structures you don't want an ugly literal (however it looks).  For a lot of scenarios you want to reconstitute the word.</p>
<p>When isotopes came on the scene it afforded the interesting choice to say that the logic-reactive ~true~ and ~false~ isotopes couldn't be put into blocks... and would have to be triaged.</p>
<pre><code>&gt;&gt; false
== ~false~  ; isotope

&gt;&gt; append [flag:] false
** Error

&gt;&gt; append [flag:] meta false
== [flag: ~false~]  ; evaluates to the right thing under DO

&gt;&gt; append [flag:] logic-to-word false
== [flag: false]
</code></pre>
<h2>
<a name="all-block-items-truthy-out-of-bounds-null-2" class="anchor" href="https://forum.rebol.info#all-block-items-truthy-out-of-bounds-null-2"></a>All BLOCK! Items Truthy, Out-of-Bounds NULL</h2>
<p>This gives another benefit, which is that the null returned from out-of-bounds access of arrays gives the unique falsey result for various enumerations.  For example:</p>
<pre><code> &gt;&gt; block: [a b ~false~ c]

 &gt;&gt; while [value: try take block] [print mold value]
 a
 b
 ~false~
 c
</code></pre>
<p>Or:</p>
<pre><code>&gt;&gt; block: [a b ~false~ c]

&gt;&gt; third block
== ~false~

&gt;&gt; if third block [print "There's a third element in block"]
There's a third element in block

&gt;&gt; fifth block
== ~null~  ; isotope

&gt;&gt; if not fifth block [print "No fifth element in block"]
No fifth element in block
</code></pre>
<p>These kinds of scenarios present classic problems in Rebol and Red, because people will write code assuming that they can use conditional logic to decide if a value is there... but then one day they hit a LOGIC! or a NONE! literal and it breaks.  Having nothing that's actually in a block be falsey is a good thing.</p>
<h2>
<a name="no-answer-is-perfect-but-this-has-solid-benefits-3" class="anchor" href="https://forum.rebol.info#no-answer-is-perfect-but-this-has-solid-benefits-3"></a>No Answer is Perfect, But This Has Solid Benefits</h2>
<p>The need to store things in blocks that are themselves directly testable as falsey isn't all that valuable in practice.  And it frequently led to broken code when people were assuming a conditional test could be used to know whether an element was in a block or not.</p>
<p>Encouraging discipline in triage with whether you want a word or a meta-representation of a logic (which evaluates to something that has the truthy/falsey property) has--in my opinion--turned out to be a net benefit.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/why-theres-no-boolean-type-storable-in-a-block/2095">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/why-theres-no-boolean-type-storable-in-a-block/2095</link>
          <pubDate>Sun, 07 Jan 2024 06:12:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2095</guid>
          <source url="https://forum.rebol.info/t/why-theres-no-boolean-type-storable-in-a-block/2095.rss">Why There&#39;s No Boolean Type Storable in a BLOCK!</source>
        </item>
        <item>
          <title>Should Isotopes Be Legal in MAP! (Keys, Values?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>In the pre-isotopic era, there was a concept that MAP! would not allow you to store nulls.  Because null was the signal of not being in a map.  Assigning a key null was a way of removing items from that map.</p>
<pre><code>&gt;&gt; m: make map! [x 20]
== make map! [
    x 20
]

&gt;&gt; m.x
== 20

&gt;&gt; m.y
; null

&gt;&gt; m.x: null
; null

&gt;&gt; m
== make map! [
]
</code></pre>
<p>Additionally, NULL was not allowed as a key.</p>
<h2>How Should This Change In The Isotopic Era?</h2>
<p>I'll make the point that not allowing you to store isotopes as keys or values isn't a fundamental problem, because you can META a value to put it in, and then UNMETA it when taking it out.</p>
<p>You wind up with a fundamental issue that actions from a MAP! won't be run implicitly this way, and you can't put any falsey values in a map this way (because false is the ~false~ word isotope, and ~null~ isotopes are representations of not being in the map).</p>
<p>But that limitation can be a benefit.  I already think of it as a benefit that you cannot run an action by doing access of items out of a block.  e.g. <strong>block.1</strong> could never run a function now (since blocks can't store isotopic actions).  If that was true of <strong>map.key</strong> as well, that could be seen as a good thing... you'd have to APPLY or RUN a plain ACTION! (or QUASI-ACTION!).</p>
<pre><code>&gt;&gt; m: make map! []

&gt;&gt; m.1: :append
** Error: Cannot put ACTION! isotope in map

&gt;&gt; m.1: ^append
== ~#[action! {append} [series value /part /dup /line]]~

&gt;&gt; m.1
== ~#[action! {append} [series value /part /dup /line]]~

&gt;&gt; run m.1 [a b c] [d e]
== [a b c [d e]]

&gt;&gt; apply m.1 [[a b c] [d e] /dup 2]
== [a b c [d e] [d e]

&gt;&gt; m.1/ [[a b c] [d e] /dup 2]
== [a b c [d e] [d e]
</code></pre>
<p>As with the peace of mind using BLOCK!, that seems like a good thing to me.</p>
<p><em>(I'm not entirely sure if RUN should allow QUASI-ACTION!s, or if you should have to UNQUASI it into a plain ACTION!.  Forcing the canonization might make more sane, so that routines that want to exchange actions as currency would have one standard they spoke.)</em></p>
<p>I also think it's likely a good thing that false isotopes wouldn't be in the map, only quasi-false and the word false.  So if you're putting logic into a map, you'd wind up writing <strong><code>if map.key = 'true [...]</code></strong> or <strong><code>if map.key = 'false [...]</code></strong> and save the <strong>if map.key</strong> and <strong>if not map.key</strong> for testing things being in the map.</p>
<h2>This Would Widen The Gap With Objects</h2>
<p>There have been questions about what the difference is between maps and objects, and this would be another: objects must be able to have members that are isotopes: action isotopes that can run implicitly, logic and null and other word isotopes, and I'm presuming splices and other stable forms as well.</p>
<p>It would mean a map has more in common with a block.</p>
<p>This doesn't strike me as being that much of a problem.</p>
<p><strong>So I'm going to be going ahead with the premise that isotopes can't be stored in maps, as either keys or values.</strong>  We'll see how it goes, but I think this is the right answer.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-isotopes-be-legal-in-map-keys-values/1995">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-isotopes-be-legal-in-map-keys-values/1995</link>
          <pubDate>Fri, 02 Dec 2022 09:28:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1995</guid>
          <source url="https://forum.rebol.info/t/should-isotopes-be-legal-in-map-keys-values/1995.rss">Should Isotopes Be Legal in MAP! (Keys, Values?)</source>
        </item>
        <item>
          <title>Arrays For Composite Types</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <h2>First, There Was Quote "Protection"...</h2>
<p>An operating premise has been that this would be bad:</p>
<pre><code>&gt;&gt; (type of first [''a]) = (type of first [''''(x y z)])
== #[true]
</code></pre>
<p>You've got a double-quoted word going in on the left, and a quadruply-quoted group going in on the right.  They're both instances of QUOTED! but is it in any way useful to say they're the same type?</p>
<p>Of course, we do this with BLOCK! and don't blink:</p>
<pre><code>&gt;&gt; (type of [[a]]) = (type of [[[[(x y z)]]]])
== #[true]
</code></pre>
<p>We only look at the outermost container.</p>
<p>But following precedent from where LIT-PATH! and LIT-WORD! were seen as different types, the concept of folding not just quotedness but the actual quoting level into the type arose.</p>
<p>At first, Ren-C did a fairly cheap thing, by quoting the answer of TYPE OF by the number of quotes:</p>
<pre><code>&gt;&gt; type of first [a]
== #[datatype! word!]

&gt;&gt; type of first [''a]
== ''#[datatype! word!]
</code></pre>
<p><strong>But that won't be recognized as a DATATYPE!, because it's a QUOTED!</strong></p>
<p>This matters if you try something like:</p>
<pre><code>&gt;&gt; quoted-word!: first [''#[datatype! word!]]

&gt;&gt; did parse [''a] [quoted-word!]
== #[false]

&gt;&gt; did parse ['#[datatype! word!]] [quoted-word!]
== #[true]
</code></pre>
<p>The problem here is that PARSE already has an idea of how it handles QUOTED!s, e.g. to match something that is one quoting level lower than that thing.  So this quoted datatype isn't acting how you intended.</p>
<h2>So I Suggested Arrays To Wrap Quoted Types</h2>
<p>When the idea of using &amp;[...] arrays to represent types came along, I suggested this could be a solution:</p>
<pre><code>&gt;&gt; type of first [a]
== &amp;[word]

&gt;&gt; type of first [''a]
== &amp;[''word]
</code></pre>
<p>This gives us the nice properties we want of making these distinct "types" for purposes of comparison, while still both being of the same fundamental type for purposes of dispatch.</p>
<h2>Might Type Arrays Have Other Parameters?</h2>
<p>We could ask if all of these type arrays are just one element long--where that element is always a WORD!, quoted WORD!, or quasi WORD!...</p>
<p>Or might they have other parameters in them?  Would a vector say what they were vectors of:</p>
<pre><code> &gt;&gt; type of vec
 == &amp;[vector int32]
</code></pre>
<p>Would a matrix have its dimensions?</p>
<pre><code>&gt;&gt; type of mat
== &amp;[matrix (32 32)]
</code></pre>
<p>I've suggested that the narrower question of KIND might come back with a simpler answer:</p>
<pre><code>&gt;&gt; kind of mat
== &amp;matrix</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/arrays-for-composite-types/1979">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/arrays-for-composite-types/1979</link>
          <pubDate>Sun, 25 Sep 2022 00:48:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1979</guid>
          <source url="https://forum.rebol.info/t/arrays-for-composite-types/1979.rss">Arrays For Composite Types</source>
        </item>
        <item>
          <title>What Should TYPE OF an Antiform Be?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>At this exact moment (in Sep 2022)...TYPE OF any antiform is an error, while both TYPE OF NULL and TYPE OF VOID give back NULL.</p>
<p>OF is a generic operation (the enfix form of REFLECT that quotes the word on its left.  It may be desirable to honor the VOID-in-NULL out convention for all the other reflectors that aren't TYPE... and it's desirable to error on NULL more generically.</p>
<pre><code>&gt;&gt; label of null
** Error: You didn't give anything

&gt;&gt; label of maybe null  ; MAYBE NULL is VOID 
; null
</code></pre>
<p>So if <strong>type of</strong> follows the same pattern as other <strong>xxx of</strong>, we'd surmise that you don't use TYPE OF to discern NULL and VOID.  It errors on NULL input and gives you back NULL if you MAYBE it.</p>
<p>But what happens when you ask:</p>
<pre><code>&gt;&gt; spread [d e]
== ~(d e)~  ; anti

&gt;&gt; type of spread [d e]
???
</code></pre>
<h2>
<a name="the-original-plan-was-no-arguments-received-antiforms-1" class="anchor" href="https://forum.rebol.info#the-original-plan-was-no-arguments-received-antiforms-1"></a>The Original Plan Was <em>No</em> Arguments Received Antiforms</h2>
<p>In the original conception, function frames weren't capable of holding antiforms in the arguments.  You physically could not receive a parameter that was an antiform.</p>
<p>I was also looking at the idea that some antiforms--such as raised ERROR!--would be completely impossible to get into a variable, <em>ever</em>.</p>
<p>The only workaround was if a function used the ^META parameter convention, in which case an antiform would come in as a QUASI! form of the value...while normal values would come in as one level quoted higher than they were:</p>
<pre><code> &gt;&gt; detector: func [^x] [print ["Meta of X:" mold x]]

 &gt;&gt; detector [d e]
 Meta of X: '[d e]

 &gt;&gt; detector spread [d e]
 Meta of X: ~(d e)~
</code></pre>
<p>Ultimately I backed down on this, instead allowing you to use type predicates to narrow which antiforms you'd be willing to accept:</p>
<pre><code>&gt;&gt; splicetaker: func [x [any-value! splice?]] [
       append [a b c] :x
   ]

&gt;&gt; splicetaker [d e]
== [a b c [d e]]

&gt;&gt; splicetaker spread [d e]
== [a b c d e]
</code></pre>
<p>A primary driver behind this change was that operations which wanted to do things like ADAPT a function frame were having to become sensitive to whether a parameter was ^META or not.  It seemed that standardizing the frame in a way that permitted antiforms as currency made more sense than having arguments be sometimes-meta'd, sometimes not.</p>
<p><em>(Note: A later driver of this was that <a href="https://forum.rebol.info/t/why-theres-no-boolean-type-storable-in-a-block/2095">LOGIC became implemented with antiforms</a>, and needing to make a parameter meta to take logic was another bridge-too-far.)</em></p>
<h2>
<a name="what-if-of-reflect-didnt-take-antiforms-2" class="anchor" href="https://forum.rebol.info#what-if-of-reflect-didnt-take-antiforms-2"></a>What if OF (REFLECT) Didn't Take Antiforms?</h2>
<p>So we could say that if you think you have an antiform in your hand, you're responsible for ^META-ing it yourself:</p>
<pre><code>&gt;&gt; metatyper: func [x [any-value! splice?]] [
       print ["Metatype of X is" type of ^x]
   ]

&gt;&gt; metatyper [d e]
== &amp;['block]  ; the TYPE OF received a QUOTED!, so e.g. answer incorporates quoted

&gt;&gt; metatyper spread [d e]
== &amp;[~block~]  ; got QUASI!, so TYPE OF answer incorporates quasi
</code></pre>
<p>On the plus side of such an approach, we don't have to invent any type representations for antiforms.</p>
            <p><small>6 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/what-should-type-of-an-antiform-be/1983">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-should-type-of-an-antiform-be/1983</link>
          <pubDate>Sat, 24 Sep 2022 10:23:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1983</guid>
          <source url="https://forum.rebol.info/t/what-should-type-of-an-antiform-be/1983.rss">What Should TYPE OF an Antiform Be?</source>
        </item>
        <item>
          <title>The Implications of ^META Producing QUASI! from Isotopes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <h2>TL;DR - GET-WORD! to Fetch ACTION!s Will Be Unchanged</h2>
<ul>
<li>
<p>In the beginnings of the action isotope proposal, I thought that it would be perfect to move away from GET-WORD! to ^META-WORD! to reconstitute actions.</p>
<ul>
<li>
<p>The ^META-WORD! would give back something you could put into variables that was not word-active...hence easier to work with.</p>
</li>
<li>
<p>At that time, what ^META of an action isotope gave back was a plain ACTION!</p>
</li>
</ul>
</li>
<li>
<p>With the rise of generic isotopes and more examples of their functionality, it became clear that ^META of an isotopic form would return a <em>quasiform</em>.</p>
<ul>
<li>
<p>Quasiforms have a unique place in the system as a representation of "isotopic status in suspended animation"</p>
</li>
<li>
<p>Higher-order manipulations are not supposed to disregard the QUASI!-ness as if it's not there.  (The form was initially even more pejorative, called "BAD", to draw attention.)</p>
</li>
</ul>
</li>
<li>
<p>The need to have generic operations on ACTION! that compose or manipulate them suggests the best ergonomic is to make isotopic actions able to decay to plain ACTION! to facilitate these compositions.</p>
<ul>
<li>
<p>QUASI!-forms will not (and should not) do this decay, leading to unpleasant patterns like <strong>apply unquasi ^add [1 2]</strong></p>
</li>
<li>
<p>The preferable syntax of <strong>apply :add [1 2]</strong> can leverage the more malleable idea of isotopic decay to allow APPLY to accept an action isotope as its applicand.</p>
</li>
</ul>
</li>
<li>
<p>This decision ripples out to other operations which may be on the fence, such as CHAIN, which is now decided to work as <strong>chain [:add, :negate]</strong> instead of as <strong>chain [^add, ^negate]</strong> as was prototyped in an early commit.</p>
</li>
</ul>
<hr>
<p>Here was the line of reasoning to get there, which says the same thing in many more words.</p>
<hr>
<h2>The Construction of Historical CHAIN</h2>
<p>So far, if you wrote something that chained two functions together, like:</p>
<pre><code>&gt;&gt; double-plus-twenty: chain [lambda [x] [2 * x], specialize :add [value2: 20]]

&gt;&gt; double-plus-twenty 500
== 1020
</code></pre>
<p>What actually happened was two steps.  CHAIN is a higher-level function, that calls REDUCE of the block to produce ACTION! values, followed by calling a lower-level CHAIN* native that expects a block of just actions.</p>
<p>This was nice because it meant that the mechanics inside of CHAIN* didn't have to worry about having some implementation of REDUCE inside of it.  It could focus on what it did...taking in a list of ACTION!s, and building an aggregate ACTION! that ran them as a pipeline.</p>
<h2>...Enter ACTION! Isotopes...</h2>
<p>The first experiment was that if you did something like <strong><code>^append</code></strong> on an action isotope (like the word APPEND would look up to), you would get a plain ACTION! back.</p>
<p>The previous CHAIN* would thus still work, so long as you changed it to ^META whatever you wanted to chain together:</p>
<pre><code>reversed-append: chain [^append, ^reverse]
</code></pre>
<p>But a design decision emerged that when you ^META an isotope, you get a QUASI! form.  This is one of the reasons that even though isotopes have "no representation", they are shown with the QUASI!-marks in the default terminal (plus a comment).</p>
<pre><code>&gt;&gt; spread [a b c]
== ~(a b c)~  ; isotope

&gt;&gt; ^ spread [a b c]
== ~(a b c)~
</code></pre>
<p>Generally speaking, this is a good thing.  If you have to ^META something just to reify it (with the intention to UNMETA it down the line and get the isotope back), then this is informative.  It's why you have to take special action to throw the quasi status away (UNQUASI).</p>
<p>But now if you feed the lower-level CHAIN with an array out of REDUCE of ^META forms, you'll have a block of QUASI!-actions:</p>
<pre><code>&gt;&gt; reduce [^append, ^reverse]
== [~#[action! {append} [...]]~ ~#[action! {reverse} [...]]~]
</code></pre>
<p>GET-WORD!s couldn't be handled by a plain REDUCE at all, because they'd give back isotopes--illegal in blocks.</p>
<h2>"So What's The Problem?  Make CHAIN Take QUASI-ACTION!"</h2>
<p>Mechanically, that would work.</p>
<p>But if it takes QUASI-ACTION!, should it still take plain ones too?</p>
<p>Let's stop and think about what the difference between an ACTION! and a QUASI-ACTION! represented in a block are.</p>
<p>A plain ACTION! in a block is something that when evaluated, will run the action.</p>
<pre><code>&gt;&gt; compose [(unquasi ^add) 1000 20]
== [#[action! {add} [...]] 1000 20]

&gt;&gt; do compose [(unquasi ^add) 1000 20]
== 1020
</code></pre>
<p>A QUASI! action will evaluate to produce an isotopic action.  The current proposal for isotopic actions is that they are unfriendly as most isotopes are, so that they are hard to assign to WORD!s.  But techniques would sneak past that...namely having purposeful function generators wrap them up in isotopic objects designed to communicate with SET-WORD!s/etc. and approve the assignment:</p>
<pre><code>&gt;&gt; ^add
== ~#[action! {add} [...]]~

&gt;&gt; do compose [(^add)]
== ~#[action! {add} [...]]~  ; isotope

&gt;&gt; do compose [(^add) 1000 20]
== 20  ; didn't run the action, it evaluated isotopically and vanished
</code></pre>
<p>So you'd use different pieces in different ways.</p>
<p>When you look at it this way, it kind of makes it seem like QUASI-ACTION! should be the currency of action that CHAIN would want.  Consider the difference between these two at-a-glance:</p>
<pre><code>[#[action! {append} [...]] #[action! {reverse} [...]]]

[~#[action! {append} [...]]~ ~#[action! {reverse} [...]]~]
</code></pre>
<p>The first array of plain ACTION!s comes off as something of an incomplete sentence.  It's like you've written <strong>[append reverse]</strong> and you're building up a statement where the first argument to an APPEND is being REVERSE'd:</p>
<pre><code>&gt;&gt; code: [#[action! {append} [...]] #[action! {reverse} [...]]]

&gt;&gt; append code [[a b c] [d e]]

&gt;&gt; do code
== [c b a [d e]]
</code></pre>
<p>The second array of QUASI!-actions is kind of clearly not a sentence.  It's more like a collection of isotopic actions in "suspended animation".  If you REDUCE-EACH it, you'll be able to digest it back into action isotopes.</p>
<p>Looked at in just this light, the QUASI! actions seem like a pretty good currency for CHAIN* to accept.  Though it's behind the scenes a bit.</p>
<h2>But Such Decisions Ripple...</h2>
<p>So now let's look at something that doesn't take its input in an array, like APPLY.  Today it takes an ACTION! as an argument:</p>
<pre><code>apply: func [
    applicand [action!]
    args [block!]
][...]
</code></pre>
<p>The goal of isotopic actions is to have a way that generic parameters or things that enumerate blocks don't have to worry about turning a WORD! into something that runs actions unexpectedly.  It's not really as relevant to things like APPLY, because they <em>know</em> things like their APPLICAND are an ACTION!.  This isn't a burden...and in fact, it can be annoying if you plan on calling the function in the body to receive it inertly.</p>
<p><em>(Quick reminder: it's also a solution to a problem <a href="https://gitter.im/red/red?at=631c6475999499629359f1ec">that Boris repeatedly mentions</a>, e.g. REPLACE can't distinguish between an action you pass it to look for literally vs. one you want to run as part of the replacement.  So it's more than just a safety tool.)</em></p>
<p>Anyway...things are all a bit turned on their head, because it's kind of not clear how to get a plain ACTION!.  Things like FUNC create action isotopes (wrapped up in an object to denote they were just generated, and so it's likely they were intended to be assigned somewhere soon).  And then ^META operations make quasi forms.  So you've got choices like:</p>
<pre><code>&gt;&gt; :append
== ~#[action! {append} [...]]~  ; isotope

&gt;&gt; ^append
== ~#[action! {append} [...]]~

 &gt;&gt; func [] [return 1020]
 == ~#[action! [...]]~  ; isotope
</code></pre>
<p>The only ways to make a regular-old ACTION! is "unquasi meta" or a "reify get"</p>
<pre><code>&gt;&gt; reify :append
== #[action! {append} [...]]

&gt;&gt; unquasi ^append
== #[action! {append} [...]]
</code></pre>
<p>This got me to wondering if one of the decaying behaviors of isotopes would be that action isotopes decay to normal actions when passed to function arguments that don't take isotopes (but that would be happy to take actions).  That's within the M.O. of isotopes, just generally.</p>
<p>(Decaying a QUASI!-ACTION! makes less sense.  All ANY-VALUE! types are supposed to be robust bricks and trustworthy, that includes QUASI! and QUOTED!--e.g. none of the infamous "lit-word decay").</p>
<p>So that suggests people would call APPLY with a traditional GET-WORD!, pass an isotope, let it decay:</p>
<pre><code>&gt;&gt; apply :add [300 4]
== 304
</code></pre>
<p>But then this gives us a bit of an incongruity.  You're ^META-ing functions to put them in a CHAIN, and :GET-ting them to use them with an APPLY.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p><em>This feels annoying.</em>  So what it makes me think is that the higher-level CHAIN itself processes the array with something besides a REDUCE.  e.g. it does some kind of REDUCE-EACH, and accepts either ACTION! values or ACTION! isotopes, the way something like APPLY would.  It canonizes them to something (either QUASI-ACTION! or plain ACTION!, probably plain ACTION at this point).  Then the lower-level CHAIN* runs on that.</p>
<p>It makes sense for CHAIN to process isotopes, due to the idea of putting FUNC [] definitions in the chain anyway.  So using GET-WORD!s to get isotopes out of WORD!s wins over using carets.</p>
<p>As for whether CHAIN* should take QUASI-ACTION!s or plain ACTION!s... it's an implementation detail.  I can't tell if bending that one way or the other makes more sense.  It's cleaner to write the wrapper taking quasiforms, and the array more obviously represents a collection and not code.  But maybe there are other concerns.  I'll wait until some other usage of CHAIN* arises to worry about it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-implications-of-meta-producing-quasi-from-isotopes/1967">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-implications-of-meta-producing-quasi-from-isotopes/1967</link>
          <pubDate>Fri, 16 Sep 2022 22:25:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1967</guid>
          <source url="https://forum.rebol.info/t/the-implications-of-meta-producing-quasi-from-isotopes/1967.rss">The Implications of ^META Producing QUASI! from Isotopes</source>
        </item>
        <item>
          <title>Applications of Isotopic Objects</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Consider the example of a function that might want to have two modes... one that prints out readable information for the console, and another that keeps the data in easily processable form.</p>
<p>Traditionally you might think of controlling this with a refinement:</p>
<pre><code>&gt;&gt; stats
-------------------
Column 1   Column 2
-------------------
Alpha      10
Beta       20

&gt;&gt; stats/only
== [
    [Alpha 10]
    [Beta 20]
]
</code></pre>
<p>But then I wondered: what if there was only one isotopic result...that wrapped the data with functions?  So long as things stayed isotopic, you'd be able to get at the functions.  But it could decay to be the data.</p>
<pre><code>&gt;&gt; ^ stats
== ~#[object! [... decay: ... form: ...]]~

&gt;&gt; compose [statistics: (spread stats)]
== [statistics: [Alpha 10] [Beta 20]]

&gt;&gt; stats
-------------------
Column 1   Column 2
-------------------
Alpha      10
Beta       20

&gt;&gt; if true [print stats, &lt;PRINT could react to FORM also&gt;]
-------------------
Column 1   Column 2
-------------------
Alpha      10
Beta       20
== &lt;PRINT could react to FORM also&gt;
</code></pre>
<p>So PRINT would be special, and instead of allowing its argument to reify normally it would specifically examine isotopic arguments to see if they could FORM.</p>
<p>In this case, the isotopic thing needs to be able to do two things: FORM or DECAY.  But maybe it could do more things, if you asked it?  And maybe no particular methods are mandatory.  Something that doesn't know how to DECAY just won't do that.</p>
<p><strong>This looks kickass.</strong></p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/applications-of-isotopic-objects/1959">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/applications-of-isotopic-objects/1959</link>
          <pubDate>Sat, 03 Sep 2022 11:48:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1959</guid>
          <source url="https://forum.rebol.info/t/applications-of-isotopic-objects/1959.rss">Applications of Isotopic Objects</source>
        </item>
        <item>
          <title>Canonizing GROUP! as the Underlying Array Type for Splices</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>The first concept of representing splices out of isotopes was to make them as iostopic BLOCK!.</p>
<p>You'd get an isotopic block regardless of the input to SPREAD:</p>
<pre><code>&gt;&gt; spread [d e]
== ~[d e]~  ; isotope

&gt;&gt; spread '(d e)
== ~[d e]~  ; isotope

&gt;&gt; spread @[d e]
== ~[d e]~  ; isotope
</code></pre>
<p>From the perspective of things like APPEND, it doesn't matter:</p>
<pre><code>&gt;&gt; append [a b c] spread [d e]
== [a b c d e]

&gt;&gt; append [a b c] spread '(d e)
== [a b c d e]

&gt;&gt; append [a b c] spread @[d e]
== [a b c d e]
</code></pre>
<h2>I Think This Canonization of Splices Is Important</h2>
<p>By canonizing splices to just one type, we recover the other types for other meanings that have nothing to do with splicing.  That subtlety would be lost if people had to think of every array type as being a splice.</p>
<p>There's no real question in my mind that it needs to be canonized.  But which array form should it take?</p>
<h2>I Think GROUP! Is A  Better Choice</h2>
<ul>
<li>
<p><strong>It makes the canonization more obvious.</strong>  Since the input to SPREAD will typically be a BLOCK!, people will learn the type is not preserved quickly:</p>
<pre><code>&gt;&gt; spread [a b c]
== ~(a b c)~  ; isotope
</code></pre>
</li>
<li>
<p><strong>Parentheses look softer and more permeable.</strong>  They already are "weaker" in that they do not "block" evaluation in the way a BLOCK! does.  So their  softness makes it feel more reasonable to say that the edges aren't there.</p>
<p><em>(This semiotic permeability exists in other places where brackets and parentheses are juxtaposed... for instance in <a href="https://en.wikipedia.org/wiki/Interval_(mathematics)#Notations_for_intervals">interval notation</a>, where <strong>[10, 20)</strong> means "the numbers from 10 to 20 without including 20")</em></p>
</li>
<li>
<p><strong>The nothing state looks kind of like a zero.</strong>  I've proposed this "nothing" as the non-NULL, non-VOID state that empty branches could coerce to.  This has the nice property of signaling the branch was taken, while still being a no-op for things like appending:</p>
<pre><code>&gt;&gt; if true []
== ~()~   ; isotope

&gt;&gt; if true [] then [print "Not VOID, so we got the branch ran signal..."]
Not VOID, so we got the branch ran signal...

&gt;&gt; append [a b c] if true []
== [a b c]  ; damn, that's cool!
</code></pre>
</li>
</ul>
<p>While they act similarly to void in cases like append, they aren't void.  Hence they overwrite output cells...the information in that cell is lost:</p>
<pre><code>&gt;&gt; 1 + 2 if false [&lt;a&gt;]
== 3

&gt;&gt; 1 + 2 if true []
== ~()~  ; isotope</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/canonizing-group-as-the-underlying-array-type-for-splices/1953">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/canonizing-group-as-the-underlying-array-type-for-splices/1953</link>
          <pubDate>Wed, 31 Aug 2022 21:11:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1953</guid>
          <source url="https://forum.rebol.info/t/canonizing-group-as-the-underlying-array-type-for-splices/1953.rss">Canonizing GROUP! as the Underlying Array Type for Splices</source>
        </item>
        <item>
          <title>Thinking About Isotopes Logically: ~true~ and ~false~</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Here's an idea: what if <strong>~true~</strong> and <strong>~false~</strong> are examples of weird isotopic exceptions.</p>
<p>Let's say you could assign them to variables...and fetch them from variables...without erroring:</p>
<pre><code>&gt;&gt; true: ~true~
== ~true~  ; isotope

&gt;&gt; false: ~false~
== ~false~  ; isotope

&gt;&gt; obj: make object! [y: true, n: false]
== make object! [
     y: ~true~
     n: ~false~
]
</code></pre>
<p><em>(not being quoted in the assignment indicates they become their isotopic forms.)</em></p>
<p>This is typically not legal...accessing a WORD! isotope from a variable like true would be an error.  But these would be special (like how I'm suggesting isotopic ACTION! would be special in running the action from a word reference...)</p>
<p>Things that tested for truthiness would treat them as expected, considering the ~false~ isotope to be a falsey thing:</p>
<pre><code>&gt;&gt; any [true false]
== ~true~  ; isotope

&gt;&gt; all [true false]
; null
</code></pre>
<p><em>Being isotopes comes with a constraint</em>...you couldn't put them into blocks.  You'd have to ^META them (which would lose their special status, turning them into QUASI-WORD!s...that were truthy.</p>
<pre><code>&gt;&gt; ^ false
== ~false~

&gt;&gt; if ^ false [print "Meta false is truthy"]
Meta false is truthy
</code></pre>
<p>The functions TRUE? and FALSE? could then work on isotopic, non-isotopic, or word forms of TRUE and FALSE...but error if passed other values.</p>
<ul>
<li>
<p><strong>This should work for casual cases of just having variables that hold a true or false state...and gives a good appearance for knowing what you're looking at.</strong></p>
</li>
<li>
<p><strong>It builds on standard mechanisms, and hence if you need to promote the isotopic state into something that can be represented in a block you can do so... with the caveat that once you do, it will no longer reflect its logical property when used with IF and such.</strong></p>
<ul>
<li><strong>That's true for NULL being ^META promoted and put in blocks as well.</strong></li>
</ul>
</li>
</ul>
<p><strong>And crucially: Since you know isotopes can't be in blocks--and if we say BLANK! is truthy as well--then you'd be guaranteed to visit all the items in a block with code like this:</strong></p>
<pre><code>while [item: try take block] [
    print mold item
]
</code></pre>
<p>This is easily the best idea so far for dealing with the problem.</p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944</link>
          <pubDate>Thu, 25 Aug 2022 23:34:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1944</guid>
          <source url="https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944.rss">Thinking About Isotopes Logically: ~true~ and ~false~</source>
        </item>
        <item>
          <title>BLANK! 2022: Revisiting The Datatype</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>In historical Redbol's meaning of the datatype NONE!, it had the bad habit of looking like a WORD!:</p>
<pre><code>rebol2&gt;&gt; 'none
== none

rebol2&gt;&gt; none
== none  ; same in R3-Alpha and Red
</code></pre>
<p>But it wasn't a word:</p>
<pre><code>rebol2&gt;&gt; type? 'none
== word!

rebol2&gt;&gt; type? none
== none!
</code></pre>
<p>It was a distinct type, which also happened to be falsey (while WORD!s are truthy):</p>
<pre><code>rebol2&gt;&gt; if 'none [print "Truthy word!"]
Truthy word!

rebol2&gt;&gt; if none [print "Falsey none!"]
== none
</code></pre>
<p>And as we can see, NONE!s served purposes of signaling "soft failures": branches that didn't run, or FINDs that didn't find, or SELECTs that didn't select... etc.</p>
<pre><code>rebol2&gt;&gt; find "abcd" "z"
== none

rebol2&gt;&gt; select [a 10 b 20] 'c
== none
</code></pre>
<h2>
<a name="ren-c-divided-nones-roles-across-null-void-and-blank-1" class="anchor" href="https://forum.rebol.info#ren-c-divided-nones-roles-across-null-void-and-blank-1"></a>Ren-C Divided NONE!s roles across NULL, VOID, and BLANK!</h2>
<ul>
<li>
<p><strong>NULL</strong> - an "antiform" state of WORD! that couldn't be put in BLOCK!s.  Anywhere that NONE! would be used to signal a soft failure operation--like FIND or SELECT--would use ~null~.</p>
<pre><code>&gt;&gt; null
== ~null~  ; anti

&gt;&gt; find "abcd" "z"
== ~null~  ; anti

&gt;&gt; select [a 10 b 20] 'c
== ~null~  ; anti

&gt;&gt; append [a b c] null
** Error: APPEND doesn't allow ~null~ isotope
</code></pre>
</li>
<li>
<p><strong>BLANK!</strong> was represented by a lone underscore ( <strong><code>_</code></strong> ) and could be put into blocks:</p>
<pre><code>&gt;&gt; append [a b c] _
== [a b c _]
</code></pre>
<p>It retained the choice to be falsey:</p>
<pre><code>&gt;&gt; if _ [print "Won't print because blanks are falsey"]
</code></pre>
</li>
<li>
<p><strong>VOID</strong> - another "antiform" state of WORD!, that's the result of things that are effectively "no ops".  Some contexts choose to make them vanish, and when functions like APPEND get them as an argument they are treated as no-ops:</p>
<pre><code>&gt;&gt; void  ; void results don't show anything in the console

&gt;&gt; if null [print "Doesn't print as NULL is falsey"]

&gt;&gt; compose [abc (if false ['def]) ghi]
== [abc ghi]

&gt;&gt; append [a b c] void
== [a b c]

&gt;&gt; for-each void [1 2 3] [print "no variable"]
no variable
no variable
no variable
</code></pre>
<p>(At one time void was also the state of unset variables, but that is now antiform BLANK!, which is called "trash")</p>
</li>
</ul>
<h2>
<a name="question-one-should-blank-just-be-a-word-2" class="anchor" href="https://forum.rebol.info#question-one-should-blank-just-be-a-word-2"></a>Question One: Should BLANK! Just Be A WORD! ?</h2>
<p>Ren-C allows you to use underscores internally to words, so it feels a little bad to take away one word.</p>
<p>Outside of historically being hardcoded as falsey, what makes BLANK! fairly "built in" is that in the path mechanics, it fills in the empty slots:</p>
<pre><code>&gt;&gt; to path! [_ a]
== /a

&gt;&gt; as block! 'a//b//c
== [a _ b _ c]
</code></pre>
<p>There's other places the blank is used, such as to opt-out of multi-returns.</p>
<pre><code>&gt;&gt; [_ pos]: transcode "abc def"

&gt;&gt; pos
== " def"
</code></pre>
<h2>
<a name="question-two-does-blank-still-need-to-be-falsey-3" class="anchor" href="https://forum.rebol.info#question-two-does-blank-still-need-to-be-falsey-3"></a>Question Two: Does BLANK! Still Need To Be Falsey?</h2>
<p><em>My feeling is that having blank be falsey doesn't have all that much benefit.</em>  NULL does a better job of it, and really what it does is mess with its usefulness as a placeholder:</p>
<pre><code>&gt;&gt; append [a b c] maybe all [1 &gt; 2, 3 &gt; 4, _]
== [a b c]

&gt;&gt; append [a b c] maybe all [1 &lt; 2, 3 &lt; 4, _]
== [a b c _]  ; this makes sense to me
</code></pre>
<p>Thinking of BLANK! as being "null-like" in terms of non-valuedness is generally a hassle.  It makes you wonder about whether something like DEFAULT should think of it as being assigned or not:</p>
<pre><code>&gt;&gt; item: _

&gt;&gt; item: default [1 + 2]
== ???
</code></pre>
<p>In practice, I prefer the truly non-valued NULL being the only cases that DEFAULT overwrites.  This is because NULL is far more useful than BLANK! when it comes to representing something that you think of as "not being assigned"... as you'll get errors when you try to use it places (e.g. in APPEND).  Trying to use it to represent nothingness invariably leads to stray appearances in blocks (Shixin wrote a lot of code to try to filter them out in Rebmake, prior to it being switched to NULLs)</p>
<p>This makes more sense, and I think it bolsters the argument that BLANK! is less of a falsey-NULL relative...but more of a placeholder value.  I've said "blanks are to blocks what space is to strings".  And space is truthy:</p>
<pre><code>&gt;&gt; if second "a b" [print "Space is truthy"]
Space is truthy

&gt;&gt; if second [a _ b] [print "So why shouldn't blank be truthy?"]
???
</code></pre>
<p><strong>So Either Way, I Suggest The Removal of BLANK! From Being Falsey</strong>.  This creates some incompatibility in Redbol (which has been using NONE! as a blank substitute).  But it's something that can be worked around.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942</link>
          <pubDate>Thu, 25 Aug 2022 13:50:26 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1942</guid>
          <source url="https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942.rss">BLANK! 2022: Revisiting The Datatype</source>
        </item>
        <item>
          <title>Big Alien Proposal :flying_saucer: &quot;/REFINEMENTS&quot; Run Functions</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <blockquote>
<p><strong>UPDATE</strong>...This was tried out, and while interesting things were learned it ultimately didn't "feel right" <em>(in particular the competition of <code>/slash</code> for refinement and <code>/slash:</code> for function definition was more annoying than anticipated, and SET-PATH!s introduce a lot of complexity in places it wasn't needed.)</em>  See further down the thread.  It's informing new designs being tried out.</p>
</blockquote>
<hr>
<p>So far, <strong><code>/leading</code></strong> <strong><code>/slash</code></strong> <strong><code>/notation</code></strong> has just been evaluator inert, lining up with Rebol2 and Red and R3-Alpha:</p>
<pre><code>redbol&gt;&gt; /foo
== /foo
</code></pre>
<p>That inertness doesn't seem to get leveraged much.  And in Ren-C it's a particularly weak choice, since the evaluator has generic quoting to get you the literal result:</p>
<pre><code>ren-c&gt;&gt; '/foo
== /foo
</code></pre>
<p>Also, leading slash is an actual PATH!...encompassing arbitrary patterns like <strong><code>/lib.append/dup/part</code></strong>.  So I've always been wondering if there was some interesting evaluator behavior for it, like...</p>
<ul>
<li>
<p>...asking to pick from "global scope": if your function has an argument called ALL then /ALL might get you the definition outside your function?  (Something like <strong><code>::foo</code></strong> in C++)</p>
</li>
<li>
<p>...maybe a shorthand for <strong><code>self/foo</code></strong> for picking members out of objects inside of methods?</p>
</li>
</ul>
<p>Yet nothing has ever really stuck.  But <a class="mention" href="https://forum.rebol.info/u/ingohohmann">@IngoHohmann</a> pointed out that there's a basic thing that leading slashes might do for us which may have been overlooked...</p>
<p>...<em>simply running functions</em>.</p>
<h2>"But WORD!s Run Functions, Why Should /FOO Do That?"</h2>
<p>There are many reasons, but the biggest one is...</p>
<hr>
<p><strong>I feel pretty much 100% certain it is time that we switched to a world <em>where not all WORD!s holding ACTION!s will run them.</em></strong></p>
<hr>
<p>It's too cumbersome when writing generic code to worry that a value you got "from somewhere" and put into a SET-WORD! has to be handled with special operators:</p>
<pre><code> &gt;&gt; var: select obj 'item
 &gt;&gt; if integer? var [print "INT"]
 Muhaha the next thing at your callsite was [print "INT"]  ; eek, VAR was action

 &gt;&gt; var: first block
 &gt;&gt; if integer? var [print "INT"]
 HAH! Did you think blocks were safe?  Not at all: [print "INT"]  ; in blocks too!
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/man_facepalming.png?v=9" title=":man_facepalming:" class="emoji only-emoji" alt=":man_facepalming:"></p>
<p>Whether you think of it in terms of "security"--or simply bugs and chaos--this <em>persistent tax</em> on Redbol code authors has lacked a palatable solution.  Putting a GET-XXX! on every access is ugly, and easy to forget.  What we've ended up with is a mishmash...where people are constantly forced to choose between deciding if the brokenness is likely enough to cause a problem that it's worth it to make the code ugly.</p>
<p>(When code ages, it's like it develops some sort of pox--as leading colons are added on an ad-hoc basis, then no one really knows if they're safe to remove.)</p>
<p><strong>I propose that only specially marked assignments would <em>automatically</em> run a function through a word reference, requiring a ^META access to get the action value literally.</strong></p>
<pre><code>&gt;&gt; /foo: func [x] [print ["X is" x]]

&gt;&gt; foo 10
X is 10

&gt;&gt; ^foo
== #[action! {foo} [x]]
</code></pre>
<p><strong>If a function is assigned through a plain SET-WORD!, then that would be inert by default...but able to take advantage of this new leading-slash execution.</strong></p>
<pre><code>&gt;&gt; foo: func [x] [print ["X is" x]]

&gt;&gt; foo
== #[action! {foo} [x]]

&gt;&gt; /foo 10
X is 10
</code></pre>
<h2>Compliance Isn't Actually That Ugly!</h2>
<p>If you look at the definition of an object, then annotating the member functions isn't really so bad:</p>
<pre><code>obj: make object! [
    data: 1
    /accessor: does [return data + 1]
]
</code></pre>
<p>This also gives us some extra ammo: <strong>it can explain why we would use OBJ/ACCESSOR to invoke the function, and why OBJ.ACCESSOR can act as an error</strong>.</p>
<p>That can clean up examples like this:</p>
<pre><code> &gt;&gt; error: trap [...]
 &gt;&gt; if integer? error.arg1 [print "INT"]
 You forgot to worry about TUPLE! too! [print "INT"]  ; aaaargh...
</code></pre>
<p>All we have to do is say that TUPLE! accesses like that can't run methods.  It would have to be <strong><code>error/arg1</code></strong> to run it... which would also confirm that it was actually defined as a method.  (Otherwise you'd run it with <strong><code>/error.arg1</code></strong> if it was just a random non-method field that happened to be a function.)</p>
<p>This would be a systemic solution to historical annoyances.</p>
<h2>It Can Be A Nice Dialecting Pattern</h2>
<p><strong>It's useful in dialects where plain WORD! references are taken for another meaning.</strong>  For instance, UPARSE by default assumes a word means a combinator, so if you want to run a function that uses parse rules to gather its arguments you need something else:</p>
<pre><code>&gt;&gt; parse [1] [/negate integer!]
== -1

&gt;&gt; parse [1 2] [/add integer! integer!]
== 3
</code></pre>
<p>Initially I tried this with terminal slashes, as <strong><code>negate/</code></strong> and <strong><code>add/</code></strong>, but that doesn't look as good (and separates the functions from their arguments).</p>
<h2>What Do We Lose?</h2>
<p>Because I was trying to think of a meaningful evaluator behavior for leading-slash values, I didn't do much with them.  But eventually I decided to use them in New Apply:</p>
<p><a href="https://forum.rebol.info/t/apply-ii-the-revenge/1834" class="inline-onebox">APPLY II: The Revenge!</a></p>
<p>They're nice because they break up the space:</p>
<pre><code>&gt;&gt; apply :append [[a b c] [d e] /dup 2]
== [a b c [d e] [d e]]
</code></pre>
<p>But SET-WORD! is reasonable at this, and commas can make it more visually separate if needed:</p>
<pre><code>&gt;&gt; apply :append [[a b c] [d e] dup: 2]
== [a b c [d e] [d e]]

&gt;&gt; apply :append [[a b c] [d e], dup: 2]
== [a b c [d e] [d e]]
</code></pre>
<p>Of course whatever we put here is being overloaded.  If you want a SET-WORD! for assignment purposes, you'd have to put it in a group:</p>
<pre><code>&gt;&gt; apply :append [(abc: [a b c]) [d e], dup: 2]
== [a b c [d e] [d e]]

&gt;&gt; abc
== [a b c]
</code></pre>
<p>So we could think of this similarly.  If you wanted to use a refinement-style path here, you just do it in a group:</p>
<pre><code>&gt;&gt; apply :append [(/reverse [a b c]) [d e], /dup 2]
== [c b a [d e] [d e]]
</code></pre>
<p><strong>APPLY is a dialect, and there are always going to be some tradeoffs made.</strong>   There's only so many parts.</p>
<p><strong>It's probably best to leave APPLY as it is.</strong>  I don't think we're going to be in the midst of some epidemic where suddenly every function invocation is done through a leading slash and it's going to be  contentious.  There will also be ways of running a function through REEVAL or maybe a dedicated RUN function that won't use the slash...</p>
<p>So nothing needs to be lost, really.</p>
<h2>The Big Win is that the <em>Obvious</em> Code is the <em>Correct</em> Code</h2>
<p>I've done some tentative implementation on all this, and all together, it seems pretty solid</p>
<p>Really all you're doing is paying the cost of an extra (easy-to-type) character to say that a word is intended to execute a function without needing to explicitly be told to.</p>
<p>There will be ways to subvert it, as of course you could do this:</p>
<pre><code>&gt;&gt; /func: enfix lambda [left [set-word!] spec body] [
       do compose [/(as word! left): lib/func (spec) (body)]
   ]

&gt;&gt; cheat: func [] [print "Breakin the law, breakin the law..."]

&gt;&gt; cheat
Breakin the law, breakin the law...
</code></pre>
<p>But we wouldn't make you do it that laboriously, if you're making something where words need to be associated with functions that run automatically.  And Redbol would do it through some evaluator parameterization as opposed to a mechanism like that.</p>
<p>However, the general expectation would be that most people would embrace the slash, as a useful piece of information...that makes everything work more coherently.</p>
            <p><small>12 posts - 5 participants</small></p>
            <p><a href="https://forum.rebol.info/t/big-alien-proposal-refinements-run-functions/1905">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/big-alien-proposal-refinements-run-functions/1905</link>
          <pubDate>Fri, 29 Jul 2022 08:34:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1905</guid>
          <source url="https://forum.rebol.info/t/big-alien-proposal-refinements-run-functions/1905.rss">Big Alien Proposal :flying_saucer: &quot;/REFINEMENTS&quot; Run Functions</source>
        </item>
        <item>
          <title>Sample Custom Datatype Idea: Sound</title>
          <dc:creator><![CDATA[GiuseppeChillemi]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>As an example, lets build a simple custom structure:</p>
<pre><code>[[internal structures][data1][data2][data3][data4]]
</code></pre>
<p>I want that that <code>head</code> corresponds to <code>data1</code>, and <code>index?</code> returns1 when positioned there.</p>
<p>If you have an internal action called "reposition" and "get-position" belonging to that datatype, Ren-C should look at the block if it carries an additional management object. If it contains "reposition" and "get-position" it should use this custom functions to override the standard ones for the datatype. You code them so that they do not move before data1, and you have a special structure which acts transparently to the standard Ren-C working.</p>
<p>Now lets take:</p>
<pre><code>sound: [[header] size: 5000 modified-by: "HF" sound: #A45ACF...  [tail-data]]
</code></pre>
<p>It is your structure to store a sound.</p>
<p>you want that at set operation using ':' will be written <code>raster-image:</code> content, so that</p>
<pre><code>sound: load %mysong.wav
</code></pre>
<p>You add a custom management object with overwrites the set operation and also all the others regarding <code>pick/length?/poke...</code> and so on, so that your Ren-C script works with the usual syntax, which is internally manage by from you replacement actions, translating everything to the new coordinates and operation system</p>
<p>Obviously, you could have additional action to be available to the developers which do not replace the internal actions but they could be called with syntax like:</p>
<pre><code>do-custom data 'method [parameter parameter]
</code></pre>
<p>or having a special path like <code>sound/#/fourier-trasform</code></p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/sample-custom-datatype-idea-sound/1899">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/sample-custom-datatype-idea-sound/1899</link>
          <pubDate>Sun, 24 Jul 2022 10:23:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1899</guid>
          <source url="https://forum.rebol.info/t/sample-custom-datatype-idea-sound/1899.rss">Sample Custom Datatype Idea: Sound</source>
        </item>
        <item>
          <title>Could Each Datatype Have a &quot;Second&quot; (Hidden) &quot;Slot&quot;</title>
          <dc:creator><![CDATA[GiuseppeChillemi]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>From some time I am having the idea that each datatype could have a second value slot where you can set a context where I can store replacement handling methods for set/get and also other functions and any data you have, so you can patch the standard Rebol handlings and have also additional data/functions.</p>
            <p><small>7 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/could-each-datatype-have-a-second-hidden-slot/1908">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/could-each-datatype-have-a-second-hidden-slot/1908</link>
          <pubDate>Tue, 19 Jul 2022 21:36:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1908</guid>
          <source url="https://forum.rebol.info/t/could-each-datatype-have-a-second-hidden-slot/1908.rss">Could Each Datatype Have a &quot;Second&quot; (Hidden) &quot;Slot&quot;</source>
        </item>
        <item>
          <title>High-Level Parameterized Enums</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>So there's a neat feature in Haskell and Rust (and other languages) which is that you can make an enumerated type which takes parameters.  Here's Rust's version:</p>
<pre><code>enum Message {
    Quit,
    ChangeColor(i32, i32, i32),
    Move { x: i32, y: i32 },
    Write(String),
}
</code></pre>
<p>In C++ there's not built-in support for this.  You have to implement it as a "tagged union"...where you have a struct that has a plain enum integer in it, and then a union of all the possibilities of what could be in that spot.</p>
<p>So this made me wonder what we could do to support it.</p>
<h2>Fans of History May Recall I Made an Enumerated Type Once</h2>
<p>I wasn't much involved with the language until it was open-sourced.  But I did <a href="http://blog.hostilefork.com/enumerated-type-for-rebol2/">tinker with it in 2009</a></p>
<pre><code>&gt;&gt; fruit: make-enum-type [apple orange banana mango]

&gt;&gt; favorite_fruit: make-enum fruit 'apple

&gt;&gt; set-enum favorite_fruit 'shoe
** User Error: illegal enum value ( shoe ) when 
     possibilities are [ apple orange banana mango ]
</code></pre>
<p>Clearly we want better than that, which might look more like:</p>
<pre><code>fruit: new enum [apple [rotten: [logic!]] orange banana mango]

favorite-fruit: new fruit.apple false
</code></pre>
<p>It raises some questions about how SWITCH might be able to be hooked to have some augmented feature, where it enforces you covering all the cases for the ENUM.</p>
<p>I don't have any great ideas offhand...but I just was hearing a talk where this was brought up and it reminded me that maybe it would be a good example to try and think through, as a feature users could add after-the-fact.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/high-level-parameterized-enums/1894">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/high-level-parameterized-enums/1894</link>
          <pubDate>Tue, 19 Jul 2022 00:15:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1894</guid>
          <source url="https://forum.rebol.info/t/high-level-parameterized-enums/1894.rss">High-Level Parameterized Enums</source>
        </item>
        <item>
          <title>Should Everything Have an Isotopic Form?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <blockquote>
<p><strong>This thread is locked and preserved for its historical significance, and to show just how much progress was made in about 4 months in the establishment of <a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">generalized isotopes</a>.</strong></p>
<p>For context while reading: isotopes started as a cell flag on the nulls that carried them, to denote they were "heavy nulls".</p>
<ul>
<li>
<p>Around June 9, 2022 I had a Eureka moment on how isotopic errors <a href="https://forum.rebol.info/t/the-need-to-rethink-error/1371/3">could be used to implement "definitional failure"</a>, which gave the isotope bit meaning on errors.</p>
</li>
<li>
<p>This was followed soon around July 16, to seeing isotopes as the answer to <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a>'s question of <a href="https://forum.rebol.info/t/putting-splicing-intent-on-appended-value/1873/9">what the product of a SPREAD intent should be</a>... which effectively subtracted a quote level from the semantics I'd been using to eliminate the need for /ONLY, motivating a generalized <em>"quoting level of -1"</em>.</p>
</li>
</ul>
<p>So isotopes were no longer implemented with a flag, but a unique quote state (making it impossible to have an isotopic quoted WORD!, for instance...only an isotopic plain WORD!).  It became clear that isotopes could be applied to more types, and in this post I argued for generalizing it... pointing out that we could make the "automatically run from words" behavior come only from the isotopic form of ACTION!.</p>
<ul>
<li>
<p>By August 4th I was building up to the idea of quasiforms--but not knowing what to call them yet, I suggest in this thread these items are "antiquoted".</p>
</li>
<li>
<p>By August 25th I realized isotopic words could serve the needs of <a href="https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944">representing ~true~ and ~false~</a>.</p>
</li>
<li>
<p>By September 1 I'd applied <a href="https://forum.rebol.info/t/thought-reimplementing-multi-return-via-isotopic-block/1955">isotopic packs to multi-return</a>, and <a href="https://forum.rebol.info/t/applications-of-isotopic-objects/1959">isotopic objects began developing</a> as a nuanced alternative to things like JavaScript "thenables", promises, and other super powers...</p>
</li>
</ul>
<p><em>We now take you back to July 16, 2022...</em></p>
</blockquote>
<p><img src="https://forum.rebol.info/images/emoji/twitter/hourglass.png?v=12" title=":hourglass:" class="emoji only-emoji" alt=":hourglass:" loading="lazy" width="20" height="20"></p>
<p>A little too soon to declare victory, but... we may have a solution in our hands for the historical problem of splicing arrays, <strong><a href="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/18">by allowing GROUP! isotopes</a></strong> to convey the splicing intent.</p>
<p>Isotopes are essentially <em>"quote level -1"</em> ... if you take something at quote level 0 and UNMETA it, you're allowed precisely one level of  below-rock-bottom.</p>
<p>The isotopes are unfriendly: normal function parameters won't accept them, you cannot put them in arrays, and some of them have strange behaviors when assigned to variables.</p>
<p>So what would an isotopic group look like?</p>
<p>A thought I had inspired by BAD-WORD!s was that they might use tildes on the outsides:</p>
<pre><code>&gt;&gt; unmeta [a b c]
== ~(a b c)~
</code></pre>
<p>But that's used for normal BAD-WORD! today, that you unmeta to make isotopes.</p>
<p>Which made me wonder, what if what we call BAD-WORD! today was actually a BAD-WORD! isotope, and you got them from unmeta'ing WORD! ?</p>
<pre><code>&gt;&gt; unmeta 'something
== ~something~
    ; ^-- ornery, how what we call `~something~ isotope` is today
</code></pre>
<p>And then, what if you could make anything isotopic:</p>
<pre><code>&gt;&gt; unmeta 1020
== ~1020~
</code></pre>
<p>This would break a number of things--and we've come to depend on reified BAD-WORD!s for some reasonably important purposes.  But it crossed my mind and I tend to jot notes here for every single whim that comes to my mind, so there it is.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<h2>
<a name="storing-isotopic-groups-in-variables-1" class="anchor" href="https://forum.rebol.info#storing-isotopic-groups-in-variables-1"></a>Storing Isotopic Groups In Variables?</h2>
<p>If you go back and review <a href="https://forum.rebol.info/t/generic-quoting-makes-headway-on-make-object/997">"Generic Quoting Makes Headway on MAKE OBJECT!"</a> you'll see that we've been getting by not needing quotes on items that are inert.</p>
<p>You have to have a quote on (1 + 2) if the intent is to store a GROUP! in a variable, because it will evaluate otherwise:</p>
<pre><code>make object! [group: '(1 + 2)]
</code></pre>
<p>But things like BLOCK! haven't needed them (and shouldn't):</p>
<pre><code>make object! [block: [1 + 2]]
</code></pre>
<p>However, I think that isotopes are likely going to need to be stored in variables.  You'll have to use ^META operations to get the value out of the variable.</p>
<p>Why couldn't it be an error to try and store an isotopic block in a variable?  Well, there is some attempts to be friendly by higher-level operations like SPECIALIZE.  So when you say</p>
<pre><code>append-a-b-c: specialize :append [value: spread [a b c]]  ; or whatever...
</code></pre>
<p>What happened was that everything in the frame was marked as holding a special identity for unspecialized-ness.  When the code block finishes running, it looks and notices value is a ^META parameter, and does the isotopic quoting for you.</p>
<p>If you don't have that feature, you have to know the convention of the parameter in order to assign it.  That's not the end of the world, but it feels like a hassle.  Being able to store an isotopic block in a variable enables that feature--as well as others.</p>
<h2>
<a name="so-i-think-isotopes-are-in-for-some-kind-of-reckoning-2" class="anchor" href="https://forum.rebol.info#so-i-think-isotopes-are-in-for-some-kind-of-reckoning-2"></a>So I Think Isotopes Are In For Some Kind of Reckoning</h2>
<p>There's a lot of pieces to the puzzle, and they're all tied in together.  But the good news is that the corpus of code is so big that the impacts of any change are seen, and so I can try to make sure nothing of value gets lost.</p>
            <p><small>8 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-everything-have-an-isotopic-form/1889">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-everything-have-an-isotopic-form/1889</link>
          <pubDate>Sat, 16 Jul 2022 22:41:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1889</guid>
          <source url="https://forum.rebol.info/t/should-everything-have-an-isotopic-form/1889.rss">Should Everything Have an Isotopic Form?</source>
        </item>
        <item>
          <title>From (get-env &quot;FOO&quot;) to (environment.FOO) to (env.FOO) to $FOO</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>If you spend time in bash scripting or something like GitHub CI, you realize that environment variables are <em>really important</em>.</p>
<p>So it's a bit sad that Rebol has had the really ugly <strong>get-env</strong> and <strong>set-env</strong> functions as the interface to this.</p>
<p>I'd say it's pretty clear that we'd like for <strong>env.FOO</strong> to work.  I'm also leaning to thinking that at least in some dialected circumstances, <strong>$FOO</strong> should be interpreted as an environment variable as well...and we need these types:</p>
<ul>
<li><strong><code>$WORD</code></strong></li>
<li><strong><code>$TU.P.LE</code></strong></li>
<li><strong><code>$PA/TH</code></strong></li>
<li><strong><code>$[BL O CK]</code></strong></li>
<li><strong><code>$(GR O UP)</code></strong></li>
</ul>
<p><em>(I thought it might be interesting if the way the evaluator treated these types was to call whatever <strong><code>$</code></strong> was bound to, with the thing as an argument.  If that were viable, it could be applied to <strong><code>:</code></strong> and <strong><code>@</code></strong> as well.  But the thorn is that the value only has one binding for the word/path/tuple/etc....nowhere to put the binding for the operator in the cell.  New binding models could change that, so I'm keeping an open mind.)</em></p>
<h2>But How To Make An "ANY-CONTEXT!" That Calls Functions?</h2>
<p>Right now, the only way to get hooks into the system to run code when you use tuple access is by making a new datatype.  And that can only be done in the C code.</p>
<p>So if someone put a gun to my head and told me to make it work right now--<em>today</em>--the quickest path would be to make a new ANY-CONTEXT! type in C called an ENVIRONMENT!.  The flaky part is that environment variables come from an extension, and so it would be an "extension type" (like a GOB! or VECTOR!), and those are second-class citizens (they don't work in TYPESET! for instance, they're all considered the same CUSTOM! datatype for those purposes).</p>
<p>I resist the temptation to do this, because while it would be nice to write <strong>environment.FOO</strong> instead of <strong>get-env "FOO"</strong>, most of the uses are in the rebmake code...which needs to work in the bootstrap executable.  So no point in making an existing mess with extension types messier.</p>
<h2>Any Usermode Ideas?</h2>
<p>I think what we should be looking for is a way that someone without a C compiler could make something that looks like an object, but the behavior for handling the TUPLE! access comes from functions.</p>
<p>Right now you can't "dot an action"... actions only take PATH!s for refinements.  So we could say that if we get a dot, it looks to see if the function has a /DOT refinement, and if it does then it will call it accordingly with information from the context of the get or set:</p>
<pre><code>environment: func [variable [word! set-word!] value [&lt;end&gt; any-value!] /dot] [
    assert [dot]  ; let's say you always use with dot for now
    if set-word? variable [
       echo [You asked to set @variable to @value]
    ] else [
       echo [You asked to get @variable]
]

&gt;&gt; environment.FOO
You asked to get FOO

&gt;&gt; environment.FOO: 10
You asked to set FOO to 10
</code></pre>
<p>It's better than nothing.  But what I don't like about it is that I have the idea that tuple access on functions will be able to get and set properties stored on that function... e.g. that functions will be able to act as objects.  This would be where stuff like help informaiton is stored.  <em>(This was historically called the "meta object" but we have much more compelling uses for the word "meta" now.)</em></p>
<h2>So Probably Better to be a User-Defined Datatype</h2>
<p>Unfortunately these don't exist yet.  But I guess now we have a good example of ENVIRONMENT! as something that needs supporting.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/from-get-env-foo-to-environment-foo-to-env-foo-to-foo/1857">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/from-get-env-foo-to-environment-foo-to-env-foo-to-foo/1857</link>
          <pubDate>Mon, 04 Jul 2022 14:14:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1857</guid>
          <source url="https://forum.rebol.info/t/from-get-env-foo-to-environment-foo-to-env-foo-to-foo/1857.rss">From (get-env &quot;FOO&quot;) to (environment.FOO) to (env.FOO) to $FOO</source>
        </item>
        <item>
          <title>Hex-Valued Integer Literals: Likely Not In Ren-C</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>On an old Trello there was a card about standardizing the differences between R3-Alpha and Red...and a checklist with only one item:</p>
<blockquote>
<p>Hex-valued literal notation (Rebol has none, Red used to use FFh, FFFFh, FFFFFFFFh), now using 0#FF</p>
</blockquote>
<p>The motivation was for purposes of Red/System, mostly.</p>
<p>In Ren-C this doesn't seem like a priority.  It has ISSUE! (TOKEN!) as a read-only data type that fits in a cell.  Hence a systems-oriented dialect already has an efficient way to represent these values.</p>
<p>For instance: it's not a big deal if your assembler says <strong>[mov ax, <span class="hashtag">#FE</span>]</strong> in its source... if it's generating machine code.</p>
<p>Of course, an ISSUE! in it isn't the same from a metaprogramming sense as a slot with an INTEGER! in it.  So you don't get the automatic advantage of <em>every</em> dialect that has INTEGER! support for a given slot working with a hex notation.  But isn't that what COMPOSE is for...?</p>
<pre><code>my-dialect [something-or-another 255]

my-dialect compose [whatever (debin [BE +] #FF)]
</code></pre>
<p><strong>Having more than one representation for the same type is generally bad, anyway.</strong>  Let's look at what Red does here:</p>
<pre><code>red&gt;&gt; FFh
== 255

red&gt;&gt; F0h + 0Fh
== 255
</code></pre>
<p>If it was so important that it had to be encoded in source, why is it thrown away immediately?</p>
<p>It's something about Red worth knowing exists, but off the radar for implementing, methinks.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/hex-valued-integer-literals-likely-not-in-ren-c/1815">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/hex-valued-integer-literals-likely-not-in-ren-c/1815</link>
          <pubDate>Sat, 14 May 2022 04:35:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1815</guid>
          <source url="https://forum.rebol.info/t/hex-valued-integer-literals-likely-not-in-ren-c/1815.rss">Hex-Valued Integer Literals: Likely Not In Ren-C</source>
        </item>
        <item>
          <title>DATE! + TIME! + DATETIME! (or TIMESTAMP! ?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>As we are familiar, DATE! can have a TIME! component:</p>
<pre><code>&gt;&gt; d: now
== 21-Nov-2021/18:56:45-5:00 

&gt;&gt; type of d
== #[datatype! date!]

&gt;&gt; t: d.time
== 18:56:45

&gt;&gt; type of t
== #[datatype! time!]
</code></pre>
<p>Although TIME! can exist as a separate cell and value type, <em>a DATE! doesn't store a time cell inside of it</em>.  It packs the date and time information into a single cell.</p>
<p>Hence when you say <strong>d.time</strong> above, a <em>new</em> TIME! value has to be synthesized.  There's not a whole cell worth of time to hand a pointer back to...its woven into the bits of the DATE!.</p>
<p><strong>That might not sound like much of an issue, but it creates the problem I refer to as <em>"sub-cell addressing"</em>.</strong></p>
<p><em>If you've missed everything I've griped about with this so far</em>, it means that when you want to see a behavior like the following:</p>
<pre><code>&gt;&gt; d.time.hour: 12
== 12

&gt;&gt; date
== 21-Nov-2021/12:56:45-5:00  ; we want hour updated
</code></pre>
<p>We run into the problem that if <strong>d.time</strong> <em>synthesizes</em> a value, then a naive picking process of <strong>(d.time).hour: 12</strong> would only be able to manipulate the bits in the synthesized time.  That wouldn't change <strong>d</strong>.  <em>What the user actually wanted was to update the bits of a time that was folded into the implementation of the date.</em></p>
<h2>Rebol Lacks The Vocabulary To Do This In An Obvious Way</h2>
<p>The smallest units that Rebol speaks in terms of are the <strong><code>cell</code></strong> and the <strong><code>node</code></strong>.</p>
<p><em>(If you need a refresher on these, my <a href="https://www.youtube.com/watch?v=6nsKTpArTCE">conference video tech talk</a> explains them.)</em></p>
<p><strong>It would appear we could be able to simplify matters if we changed the combination of DATE! and TIME! to point to a 2-cell node.</strong></p>
<pre><code>DATETIME! cell
[  ]                DATE!           TIME!
  --&gt; points to [ 21-Nov-2021 | 18:56:45-5:00 ]  (2 cells)
</code></pre>
<p><em>(Whether the "zone" is part of a time or lives in the datetime would depend on whether you wanted to write <code>d.zone: -5:00</code> or <code>d.time.zone: -5:00</code>, I don't know if it ever makes sense to speak of a time with a zone independent of a datetime or not.)</em></p>
<p>Breaking things up this way, we can say that <strong>d.time</strong> implicates a cell.  And we can have some operation that acts on a cell (let's say POKE) like:</p>
<pre><code> &gt;&gt; poke 18:56:45 'hour 12
 == 12:56:45
</code></pre>
<h2>Hang On: DATE!, TIME! (and DATETIME!) are IMMEDIATE!</h2>
<p>We still have a bit of a problem here with our smallest units of representation.  Presumably we don't want this:</p>
<pre><code> &gt;&gt; d1: 21-Nov-2021/18:56:45-5:00 

 &gt;&gt; d2: d1

 &gt;&gt; d1.time.hour: 12
 == 12

 &gt;&gt; d1
 == 21-Nov-2021/12:56:45-5:00

 &gt;&gt; d2
 == 21-Nov-2021/12:56:45-5:00  ; don't want d2 to change (right?)
</code></pre>
<p>But we also don't want to be needlessly copying the 2-cell node each time a date is assigned.  So it would be a <em>copy-on-write</em> mechanic.</p>
<p>If we're working with a cell-based granularity, then we wind up in a somewhat similar situation to what we had before...where the tuple processing has to propagate backwards.  e.g. when you have the POKE that changes the cell bits for the TIME! to make a new TIME! cell, there has to be some memory going back to the DATETIME! in order to tell it to make a new node and write the cell into the copy.</p>
<p>Does framing this in terms of cells offer any benefit over letting the DATETIME! be a higher-level entity that does a more specific folding of the TIME! cell into its bits?  This is a question I've been trying to answer, and haven't had an easy time of answering.</p>
<p><strong>One thing it would do to use a cell-based protocol is that it could generalize properties that had flags on cells, such as being PROTECT'ed.</strong>  Without the picking protocol requiring each step to go through a cell, the system cannot fiddle these bits in a known way.  So just as the DATE! folds the TIME! into it in some arbitrary way, the protect bit would have to go through this through a complex protocol also.</p>
<p>What I do know is that my current generalized solution is rather complex and slow--and doesn't answer how to do things like PROTECT.  We're seeing a slowdown from many different angles and I am trying to figure out what the best tradeoff is in terms of simplicity and generality.  It's not easy.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/date-time-datetime-or-timestamp/1765">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/date-time-datetime-or-timestamp/1765</link>
          <pubDate>Thu, 02 Dec 2021 16:57:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1765</guid>
          <source url="https://forum.rebol.info/t/date-time-datetime-or-timestamp/1765.rss">DATE! + TIME! + DATETIME! (or TIMESTAMP! ?)</source>
        </item>
        <item>
          <title>Tuple Troubles: Version 0.3.01 vs 0.3.1</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>For better or worse, versioning in Rebol has used TUPLE!.  e.g. 0.3.1 is 32-bit Windows, and 0.3.40 is 64-bit Windows</p>
<p>If you go back and look at the old R3-Alpha file <strong><a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/tools/systems.r#L21">%systems.r</a></strong> you can see that it's pretty typical for Carl to have written the versions out with leading zeros...<em>but only in the third slot</em>.  So <code>0.3.01</code> but not <code>00.03.01</code></p>
<p>But ultimately the tuple discards this information.  And this has been the way it always worked:</p>
<pre><code>rebol2&gt;&gt; 0.3.01
== 0.3.1

red&gt;&gt; 0.3.01
== 0.3.1

ren-c&gt;&gt; 0.3.01
== 0.3.1
</code></pre>
<p>This leads to problems when you are working with string representations outside of Rebol (say in bash shell, something like "0.3.01") and you pass it into Rebol to process as a tuple.  If bash went and created a directory based on the string...you won't match if you FORM that tuple later.</p>
<p>You could insist on passing around the tuple as a string, but that undermines the value of having the version be in a tuple in the first place.</p>
<p>I'd say that the simplest solution is just to stop writing tuples with the leading zeros...instead keeping them in their canon form.  0.3.1 for 32-bit Windows, and 0.3.40 for 64-bit Windows.  Then make the directories reflect this, e.g.:</p>
<pre><code>https://dd498l1ilnrxu.cloudfront.net/travis-builds/0.3.1/r3-573037b-debug.exe
</code></pre>
<p>and not:</p>
<pre><code>https://dd498l1ilnrxu.cloudfront.net/travis-builds/0.3.01/r3-573037b-debug.exe
</code></pre>
<p>That leading zero comes with a whole lot of headaches, so I say hunt them down and get rid of them.  Because non-Rebol systems are going to only operate on them as strings and they'll leak.</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/tuple-troubles-version-0-3-01-vs-0-3-1/1755">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/tuple-troubles-version-0-3-01-vs-0-3-1/1755</link>
          <pubDate>Wed, 24 Nov 2021 13:28:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1755</guid>
          <source url="https://forum.rebol.info/t/tuple-troubles-version-0-3-01-vs-0-3-1/1755.rss">Tuple Troubles: Version 0.3.01 vs 0.3.1</source>
        </item>
  </channel>
</rss>

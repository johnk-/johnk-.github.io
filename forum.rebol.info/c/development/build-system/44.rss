<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Build System - AltRebol</title>
    <link>https://forum.rebol.info/c/development/build-system/44</link>
    <description>Topics in the &#39;Build System&#39; category Discuss rebol-make and other build systems.</description>
    
      <lastBuildDate>Thu, 07 Dec 2023 18:40:22 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/build-system/44.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Accepting the availability of stdint.h and stdbool.h</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>One of Carl's comments in R3-Alpha complained about the lack of a standardization of integer sizes in C:</p>
<blockquote>
<p><em>"One of the biggest flaws in the C language was not to indicate bitranges of integers. So, we do that here.  You cannot 'abstractly remove' the range of a number.  It is a critical part of its definition."</em></p>
</blockquote>
<p>So he did some empirical platform detection to define things like REBI32 for a signed 32-bit integer, REBU64 for an unsigned 64-bit integer, etc.</p>
<p>But once C99 arrived, the file &lt;stdint.h&gt; offered several basic types, and basically covered the needs with types that had names like <strong>int32_t</strong> and <strong>uint64_t</strong>:</p>
<p><a href="http://en.cppreference.com/w/c/types/integer" class="inline-onebox">Fixed width integer types (since C99) - cppreference.com</a></p>
<p>So Ren-C was changed to use the C99 names and include <code>&lt;stdint.h&gt;</code>.  For pre-C99 compilers, it used a portable shim called "pstdint", which it maintained its own copy of in the repository:</p>
<p><strong><a href="https://github.com/metaeducation/ren-c/blob/e6e3e7fe0fcff165557f9ffc3de3e6713a50f99a/src/include/pstdint.h">src/include/pstdint.h</a></strong></p>
<p>By similar reasoning, booleans were shimmed with another found-file:</p>
<p><strong><a href="https://github.com/metaeducation/ren-c/blob/e6e3e7fe0fcff165557f9ffc3de3e6713a50f99a/src/include/pstdbool.h">src/include/pstdbool.h</a></strong></p>
<h2><a name="p-6739-ren-c-has-embraced-c99-so-why-keep-these-shims-1" class="anchor" href="https://forum.rebol.info#p-6739-ren-c-has-embraced-c99-so-why-keep-these-shims-1"></a>Ren-C Has Embraced C99, So Why Keep These Shims?</h2>
<p>C99 is now a prerequisite for building the system.</p>
<p>It may be that some pre-C99 standards compiler <em>could</em> still build Ren-C with these shims, though it would need variadic macro support.  The odds of a compiler having that support yet lacking things like <strong>bool</strong> and <strong>int32_t</strong> are fairly slim.</p>
<p>In any case, these esoteric compilation environments could be "shimmed" by hacking in versions of stdint.h and stdbool.h to their include directories.  I feel like that's the responsibility of the build environment at this point... and that the Ren-C codebase need not be carrying the baggage.</p>
<p>So I'm pulling the files out.  If anyone is on an esoteric platform and trying to build but finds these definitions being missing is the only problem, then they should dig up pstdint and pstdbool.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/accepting-the-availability-of-stdint-h-and-stdbool-h/2067">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/accepting-the-availability-of-stdint-h-and-stdbool-h/2067</link>
          <pubDate>Thu, 07 Dec 2023 18:40:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2067</guid>
          <source url="https://forum.rebol.info/t/accepting-the-availability-of-stdint-h-and-stdbool-h/2067.rss">Accepting the availability of stdint.h and stdbool.h</source>
        </item>
        <item>
          <title>VSCode Files</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>There are some not-checked-in files that are used for building and editing in VSCode.  Every now and again, when I wipe out a ren-c clone, this information is lost.</p>
<p>Posting it here is as good as anywhere:</p>
<p><strong>.vscode/c_cpp_properties.json</strong></p>
<pre><code class="lang-auto">{
    "configurations": [
        {
            "name": "Win32",
            "includePath": [
                "C:/Projects/ren-c/build/prep/**",
                "C:/Projects/ren-c/**"
            ],
            "defines": [
                "_DEBUG",
                "UNICODE",
                "_UNICODE",
                "CPLUSPLUS_11=1",
                "ENDIAN_LITTLE"
            ],
            "windowsSdkVersion": "10.0.18362.0",
            "compilerPath": "C:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.32.31326/bin/Hostx86/x86/cl.exe",
            "compilerArgs": [],
            "cStandard": "c11",
            "cppStandard": "c++17",
            "intelliSenseMode": "msvc-x64"
        }
    ],
    "version": 4
}
</code></pre>
<p><strong>.vscode/launch.json</strong></p>
<pre><code class="lang-auto">{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "name": "(Windows) Launch",
            "type": "cppvsdbg",
            //"type": "cppdbg",
            "request": "launch",
            //"request": "attach",
            //"processId": "${command:pickProcess}"
            "program": "C:/Projects/ren-c/build/r3.exe",
            //"program": "/home/hostilefork/ren-c-linux/r3",
            "args": [],
            "stopAtEntry": false,
            "cwd": "C:/Projects/rebol-whitespacers/",
            //"cwd": "/home/hostilefork/Projects/ren-c/tests/",
            "environment": [],
            "console": "newExternalWindow"
            //"externalConsole": true
        }
    ]
}
</code></pre>
<p><strong>.vscode/settings.json</strong></p>
<pre><code class="lang-auto">{
    "files.associations": {
        "*.c": "cpp",
        "*.r": "plaintext"
    }
}
</code></pre>
<p><strong>.vscode/tasks.json</strong></p>
<pre><code class="lang-auto">{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "Build With JOM",
            "type": "shell",
            // nmake is slow but coherent errors, make is fast with jom
            "command": "make clean &amp;&amp; make prep &amp;&amp; make folders &amp;&amp; make",
            "options": {
                "cwd": "/Projects/ren-c/build/",
                "shell": {
                    "executable": "cmd.exe",
                    "args": [
                      "/C",
                      "\"C:/PROGRA~1/Microsoft Visual Studio/2022/Community/Common7/Tools/VsDevCmd.bat\"",
                      "&amp;&amp;"
                    ]
                }
            },
            "problemMatcher": {
                "base": "$msCompile"
            },

            "group": {
                "kind": "build",
                "isDefault": true
            },

            "presentation": {
                "clear": true // &lt;-- this line
            }
       }
    ]
}
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/vscode-files/2048">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/vscode-files/2048</link>
          <pubDate>Sun, 17 Sep 2023 09:56:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2048</guid>
          <source url="https://forum.rebol.info/t/vscode-files/2048.rss">VSCode Files</source>
        </item>
        <item>
          <title>Compiling ren-c with zig?</title>
          <dc:creator><![CDATA[IngoHohmann]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>Has anyone tried to compile ren-c with zig? ( <a href="https://www.ziglang.org">https://www.ziglang.org</a> ).</p>
<p>They claim to be able to compile c-code using zig cc , and have an impressive list of cross compilation targets, wasm among them.</p>
<p><a href="https://ziglang.org/learn/overview/#zig-is-also-a-c-compiler">https://ziglang.org/learn/overview/#zig-is-also-a-c-compiler</a></p>
<p><a href="https://ziglang.org/learn/overview/#cross-compiling-is-a-first-class-use-case">https://ziglang.org/learn/overview/#cross-compiling-is-a-first-class-use-case</a></p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/compiling-ren-c-with-zig/2017">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/compiling-ren-c-with-zig/2017</link>
          <pubDate>Wed, 22 Feb 2023 21:31:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2017</guid>
          <source url="https://forum.rebol.info/t/compiling-ren-c-with-zig/2017.rss">Compiling ren-c with zig?</source>
        </item>
        <item>
          <title>Number of Files and Folders: More Is Okay</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>In the quest for simplicity, R3-Alpha had an aesthetic that tried to be very minimalist in the source tree.</p>
<p>The top level had only this:</p>
<pre><code>make/
src/
.gitattributes
.gitignore
LICENSE
NOTICE
README
</code></pre>
<p>The <strong>%make/</strong> directory contained:</p>
<pre><code>makefile
makefile.vc
vcbuild.bat
</code></pre>
<p>The <strong>%src/</strong> directory contained:</p>
<pre><code>boot/       20 files
core/       95 files
include/    31 files
mezz/       31 files
os/          7 files, with 2 directories of about 10 files each
tools/      10 files
</code></pre>
<p>The files themselves vary in size, but this just gives a perspective of about how many files there are.</p>
<h2>Ren-C and Red use <em>MANY</em> more files and directories, BUT...</h2>
<p><em><strong>Largely I think this is okay, moreover can be beneficial to understanding the code.</strong></em></p>
<p>While we should be skeptical of large amounts of complexity, I don't think there should be a kneejerk reaction to a lot of <em>files</em>.</p>
<p>Filesystems were invented for a reason: organization.  If arranging things in separate files makes the organization clear, it is good.</p>
<p>Yet there should be some justification for why a directory exists.  For instance: I think every directory should have a README.md in it, which explains why those files are grouped together.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/number-of-files-and-folders-more-is-okay/1958">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/number-of-files-and-folders-more-is-okay/1958</link>
          <pubDate>Sat, 03 Sep 2022 10:52:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1958</guid>
          <source url="https://forum.rebol.info/t/number-of-files-and-folders-more-is-okay/1958.rss">Number of Files and Folders: More Is Okay</source>
        </item>
        <item>
          <title>On how to build REN-C on Windows</title>
          <dc:creator><![CDATA[iArnold]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>The build on Linux is according to the description in the Readme.md file. Now I needed to build on another machine, which happens to be a Windows box.<br>
I ran the build script in my r3 downloaded executable after which it became clear there was no gcc installed.<br>
How to proceed now? Is the TCC alternative available and even preferrable over gcc? Or is gcc the way to go and how to go on with installing that? Perhaps even use Visual Code?</p>
            <p><small>11 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/on-how-to-build-ren-c-on-windows/1845">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/on-how-to-build-ren-c-on-windows/1845</link>
          <pubDate>Mon, 20 Jun 2022 05:45:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1845</guid>
          <source url="https://forum.rebol.info/t/on-how-to-build-ren-c-on-windows/1845.rss">On how to build REN-C on Windows</source>
        </item>
        <item>
          <title>Android AAB?</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>Android's APK is now being replaced with AAB.</p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://www.thurrott.com/wp-content/themes/theme/assets/media/logo-favicon-thurrott.png?v=@@version" class="site-icon" width="128" height="128">
      <a href="https://www.thurrott.com/dev/252614/google-is-replacing-android-apk-with-aab" target="_blank" rel="noopener" title="11:23AM - 30 June 2021">Thurrott.com – 30 Jun 21</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/388;"><img src="https://www.thurrott.com/wp-content/uploads/sites/2/2021/06/google-play-aab.jpg" class="thumbnail" width="690" height="388"></div>

<h3><a href="https://www.thurrott.com/dev/252614/google-is-replacing-android-apk-with-aab" target="_blank" rel="noopener">Google is Replacing Android APK with AAB - Thurrott.com</a></h3>

<p>And if you don’t know what that means, that’s OK, it probably just means that you’re not an Android developer.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>Is anyone doing any work on this?<br>
And is there an AAB based on Ren-c that I can use to keep the RebolFoundation developer account alive?  Google wants proof we are alive.</p>
<p>Thanks,</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/android-aab/1731">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/android-aab/1731</link>
          <pubDate>Sat, 02 Oct 2021 07:42:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1731</guid>
          <source url="https://forum.rebol.info/t/android-aab/1731.rss">Android AAB?</source>
        </item>
        <item>
          <title>Ren-C Builds With 20 Year Old Compiler on Haiku!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>I didn't realize bringing this up to date would take as long to tinker around with as it did (~ 8 hours), but...</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/1702f61a03d022ee405643e5defaa1521f3b7dd5.png" data-download-href="https://forum.rebol.info/uploads/default/1702f61a03d022ee405643e5defaa1521f3b7dd5" title="ren-c-haiku-2021"><img src="https://forum.rebol.info/uploads/default/optimized/1X/1702f61a03d022ee405643e5defaa1521f3b7dd5_2_610x500.png" alt="ren-c-haiku-2021" data-base62-sha1="3hzkeScW0sVzoA6Gja01IpM2cT3" width="610" height="500" srcset="https://forum.rebol.info/uploads/default/optimized/1X/1702f61a03d022ee405643e5defaa1521f3b7dd5_2_610x500.png, https://forum.rebol.info/uploads/default/optimized/1X/1702f61a03d022ee405643e5defaa1521f3b7dd5_2_915x750.png 1.5x, https://forum.rebol.info/uploads/default/optimized/1X/1702f61a03d022ee405643e5defaa1521f3b7dd5_2_1220x1000.png 2x" data-dominant-color="A4B9CA"></a></div><br>
<strong>Why was it such a pain?...</strong><p></p>
<h1><a name="p-5485-gcc-2953-was-released-in-march-2001httpsgccgnuorgreleaseshtml-1" class="anchor" href="https://forum.rebol.info#p-5485-gcc-2953-was-released-in-march-2001httpsgccgnuorgreleaseshtml-1"></a>GCC 2.95.3 was Released <a href="https://gcc.gnu.org/releases.html">in March 2001</a></h1>
<p><strong>Don't let the 2017 build date fool you.</strong>  That's a 20-year old compiler, which we assume has the occasional Haiku patch here and there.</p>
<p>I knew the compiler that came with Haiku had been old.  But when I was making decisions about letting go of C89 support (in the core) I figured that Haiku would be bumping their versions to support C99 at some point...</p>
<p><em>Nope.</em></p>
<p>The reason Haiku is still so far back appears to be because they depend on GCC 2.95 features that enable them to get binary compatibility with old BeOS packages.</p>
<p>You can install a more modern GCC if you like--but then you're off in the concerns of having multiple toolchains on your system.  And presumably it's harder to link up against the HaikuOS C++ platform APIs.  So I thought it would be a good proof of our light dependencies to build on what's there.</p>
<h2><a name="p-5485-note-not-just-us-mbedtls-dropped-their-c89-support-2" class="anchor" href="https://forum.rebol.info#p-5485-note-not-just-us-mbedtls-dropped-their-c89-support-2"></a>Note: Not Just Us, mbedTLS Dropped Their C89 Support</h2>
<p>Even the most die -hard of low-dependency systems have let go of the 80s.  In 2019, mbedTLS <a href="https://github.com/ARMmbed/mbedtls/issues/1484">ceased supporting C89</a>:</p>
<blockquote>
<p><em>"We've internally decided to drop support for C89 in the development branch. We've removed <code>-Wdeclaration-after-statement</code> to our build options in <code>CMakeLists.txt</code>. We run some builds with <code>gcc -std=c99 -pedantic</code> so we do test C99 compliance to a reasonable extent. Thus this issue is resolved."</em></p>
</blockquote>
<h2><a name="p-5485-options-were-either-give-up-or-revive-the-c98-build-3" class="anchor" href="https://forum.rebol.info#p-5485-options-were-either-give-up-or-revive-the-c98-build-3"></a>Options Were Either Give Up, Or Revive the C++98 Build</h2>
<p>At one point Ren-C was able to build as C++98.  I stopped seeing the point of maintaining this option...as it was silly to be keeping track of which features I could use from C++11 in which permutations.  So it was either you build as C or you build as C++11 (or higher).</p>
<p>But there really is no other choice with this GCC 2.95.  The code is now styled:</p>
<pre><code>printf("Here's a statement\n");

const char *str = "Here's a declaration after a statement";
</code></pre>
<p>The Haiku C compilation mode requires all your definitions to be before the statements:</p>
<pre><code>const char *str; 

printf("Here's a statement\n");

str = "Here's a declaration after a statement";
</code></pre>
<p><em>(Note: I hate that, because it makes maintenance much harder.  But <a href="https://rdrr.io/cran/httpuv/f/src/libuv/CONTRIBUTING.md">libuv is actually a holdout here</a>...they're carrying the torch for C89 and committers still have to code in that style.)</em></p>
<p>In any case, C++98 was able to do that.  So I revived the setting.  It wasn't too hard...I just made it act like the C build <em>almost all of the time</em>.  Hence no use of inheritance in REBVAL or anything like that.  It deviates only when it has to for compiler semantics.</p>
<h2><a name="p-5485-building-mbedtls-was-saved-by-a-pedantic-quirk-4" class="anchor" href="https://forum.rebol.info#p-5485-building-mbedtls-was-saved-by-a-pedantic-quirk-4"></a>Building mbedTLS Was Saved By A --pedantic Quirk</h2>
<p>While Ren-C was designed to compile as C or C++, mbedTLS is plain C.  C++ compilers will choke on some of the permissive treatment of <code>void*</code>.</p>
<p>I thought there'd be no way around this; because C++ compilers have no way to disable these errors.  <em>...or so I thought...</em>!</p>
<p>As it turns out, if you <em>raise</em> the error reporting level with "pedantic" warnings, the warning machinery notices the problems before the error!  And you can ignore warnings!</p>
<p>So oddly enough, I actually could compile the encryption code on Haiku (without having to go in and edit it).</p>
<h2><a name="p-5485-small-rewrites-needed-to-dodge-compiler-bugs-5" class="anchor" href="https://forum.rebol.info#p-5485-small-rewrites-needed-to-dodge-compiler-bugs-5"></a>Small Rewrites Needed To Dodge Compiler Bugs</h2>
<p>Minor changes were required to code that was triggering GCC 2.95 bugs that prevented the build.  I wouldn't be happy if I had to make a dozen changes for it, but it was a few.</p>
<p>I guess even if you write code that is correct, if you notice it triggering a compiler bug that may be a sign that it involves something hard for compilers to get right.  One might be able to balance the annoyance of having to make the change with the potential that maybe fewer compilers would be getting that bit wrong.</p>
<h2><a name="p-5485-networking-doesnt-work-but-after-libuv-switch-it-might-6" class="anchor" href="https://forum.rebol.info#p-5485-networking-doesnt-work-but-after-libuv-switch-it-might-6"></a>Networking Doesn't Work, But After LibUV Switch, It Might!</h2>
<p>I built the entirety of LibUV into the executable (even though I didn't technically have to).  And the filesystem code--which is now on libuv--seems to be working.</p>
<p>The networking isn't on libuv yet, and isn't seeming to work.  But maybe once it switches over, it will.  I mentioned that Haiku was one of the explicitly supported platforms of libuv.  So if all goes smoothly in that conversion, I imagine this will work!</p>
<h2><a name="p-5485-no-action-item-here-just-proving-it-could-be-done-7" class="anchor" href="https://forum.rebol.info#p-5485-no-action-item-here-just-proving-it-could-be-done-7"></a>No Action Item Here, Just Proving It Could Be Done</h2>
<p>This was a good head-check of what exactly has changed as Ren-C has refactored and evolved.  Letting certain dependencies creep in can make your source less adaptable and agile...and this helps be assured that things are still on track.</p>
<p>What's important here isn't "oh, now we can have millions of HaikuOS users".  Rather it serves as another example of managed dependency control--to lend confidence to the idea that porting to other new ones should be easy enough.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/ren-c-builds-with-20-year-old-compiler-on-haiku/1710">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/ren-c-builds-with-20-year-old-compiler-on-haiku/1710</link>
          <pubDate>Fri, 10 Sep 2021 17:28:40 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1710</guid>
          <source url="https://forum.rebol.info/t/ren-c-builds-with-20-year-old-compiler-on-haiku/1710.rss">Ren-C Builds With 20 Year Old Compiler on Haiku!</source>
        </item>
        <item>
          <title>Siskin-Builder (Rebol-based build tool by Oldes)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>Oldes apparently has undertaken the task of making a <a href="https://github.com/Siskin-framework/Builder">build dialect/tool for his branch of Rebol3</a>.  This animated GIF makes it seem pretty slick looking in the console:</p>
<p>                    <a href="https://raw.githubusercontent.com/Oldes/media/master/screens/build-siskin.gif" target="_blank" rel="noopener" class="onebox">
            <img src="https://raw.githubusercontent.com/Oldes/media/master/screens/build-siskin.gif" width="690" height="457">
          </a>

</p>
<p>The makefiles are called ".nest" files, and here's the one in his R3 repository:</p>
<p><strong><a href="https://github.com/Oldes/Rebol3/blob/master/make/rebol3.nest" class="inline-onebox">Rebol3/rebol3.nest at master · Oldes/Rebol3 · GitHub</a></strong></p>
<h2>New Ideas?</h2>
<p>Looking past the nice colors and presentation, I don't know if any "big new ideas" jump out at me in terms of a dialect.</p>
<p><strong>Preprocessor Usage</strong></p>
<p>The primary thing that does jump out at me is use of a preprocessor.  He has branches for <strong><span class="hashtag">#if</span> Windows [...]</strong> that let you ask for transformations and selections in the middle of lists that are data.  Less cluttered than going through and COMPOSE-ing everything, and lets you stay in the declarative domain.</p>
<p>Seems he's using a generic preprocessing script--not one that's specific to just this tool--and that's probably a good idea.  Though now that <strong><span class="hashtag">#a</span></strong> is used for characters this gets a bit stickier... even if you were previously willing to sacrifice ISSUE! in your file so you could do preprocessing, you now would be sacrificing your notation for characters too.</p>
<p><em>(I should point out that with generic quoting, you do have <strong><code>'#a</code></strong>, so at least in evaluative circumstances you'd have a way to escape out of the preprocessor.  It might be that if you use a preprocessor on the file, all your #... that you don't want to represent preprocessing instructions are just quoted out?)</em></p>
<p><strong>Requiring the % on File Paths</strong></p>
<p>He does use <strong>%file/path.c</strong> instead of <strong>file/path.c</strong> -- and that's a case where I've pointed out that Carl chose to use the lighter notation without the %.</p>
<p>I think that designing a dialect that is heavily dealing with paths as data, that if you can dodge the % then it makes it nicer to look at and edit.  If you want to allow for evaluations, you would use GROUP!s or <span class="mention">@vars</span> or something else.</p>
<h2>Our Nightmare Build System Is Still Upping My Game</h2>
<p>Oldes's makefile here, and one that Giulio made...as well as Carl's original, are all a far cry from the mind-bending behemoth that is Rebmake.</p>
<p>Not only is Rebmake a beast, we have a bootstrap compatibility layer for morphing a several year old interpreter into a common subset to run it.  It's a mind-bending challenge...the details of which I generally spare you from.  <img src="https://forum.rebol.info/images/emoji/twitter/exploding_head.png?v=9" title=":exploding_head:" class="emoji" alt=":exploding_head:"></p>
<p>It's nice to be reminded that we can do a lot smaller than that.  But oddly enough, the challenges of working with Rebmake and the %bootstrap-shim have been forcing more and more inventions in how to make the bendiest language ever.</p>
<p>And Rebmake isn't overtly unreasonable; its the kind of approach that someone who's thinking in OOP terms would think if they were trying to clone CMake's object model in a 1:1 fashion.  So it has been the mother of invention for complexity-taming tools...and stressing the language in areas that someone with a pure Rebol mindset wouldn't think to stress it in.</p>
<p>Which may explain why I'm not as urgently trying to jettison Rebmake or run on a modern Ren-C as one might think.  Because forcing a new Ren-C to be able to meet an old one in the middle to run a crazy codebase is hardening the system.</p>
<p>But... definitely, yes, someday we're going to pitch the thing and get something lighter.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/recycle.png?v=9" title=":recycle:" class="emoji only-emoji" alt=":recycle:"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/siskin-builder-rebol-based-build-tool-by-oldes/1672">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/siskin-builder-rebol-based-build-tool-by-oldes/1672</link>
          <pubDate>Thu, 19 Aug 2021 06:56:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1672</guid>
          <source url="https://forum.rebol.info/t/siskin-builder-rebol-based-build-tool-by-oldes/1672.rss">Siskin-Builder (Rebol-based build tool by Oldes)</source>
        </item>
        <item>
          <title>The New Ren-C GitHub Action: Run Natively, Run on Web!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1547">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"><a href="https://forum.rebol.info/t/using-ren-c-as-the-shell-in-github-ci/1547/1">Using Ren-C As The Shell In GitHub CI</a></div>
<blockquote>
<p>A GitHub Action can make including the feature as easy as one line for users. And we have the advantage of being able to make single-exe tools that could install on all the container types. <em>(All of them are 64-bit. Sorry, Red...)</em></p>
</blockquote>
</aside>
<p>So I went through the pain and suffering of learning how to do this.</p>
<p><em>It's a small thing in some sense, but very high leverage!</em></p>
<p><strong><a href="https://github.com/metaeducation/ren-c-action">A First Draft of a Quite Useful Ren-C Action</a></strong></p>
<ul>
<li>
<p><strong>It auto-detects your platform (Windows, Linux, MacOS) and downloads an R3 Executable for that platform</strong></p>
</li>
<li>
<p><strong>It uses GitHub Actions caching to remember where it installed itself, so multiple steps can use the executable without doing multiple downloads</strong></p>
</li>
<li>
<p><strong>It adds the r3 executable to your path, so you can use it from bash as well as with inline script code</strong></p>
</li>
<li>
<p>...and as a bonus feature... <strong>It can run script code in the web build via browser automation, so you can use it to test scripts intended to be run on the web as well</strong>.</p>
</li>
</ul>
<p>You can see <a href="https://github.com/metaeducation/ren-c/commit/f6b3411abf367be47d05e5ce58ea2de117255cc5">how much nicer the web build test</a> got by using it.  The Python code that lived in the ReplPad tests directory as well as the shell code for the web build are now both moved into the <code>ren-c-action</code>, and it's generalized. This should make it easy to add the action to a repository that is something like <a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a>'s NZPower.</p>
<p>There are <a href="https://github.com/metaeducation/ren-c-action/tree/main/src">a bunch of comments in the source</a> so you should be able to get the idea.  There's a few sticks and glue holding it together, but I think the basic approach is sound.</p>
<p>The main problem it has right now is that we don't have the latest builds getting uploaded.  So the next step for this to be useful will be to restore the uploading for OS X / Linux / Win32 builds.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-new-ren-c-github-action-run-natively-run-on-web/1562">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-new-ren-c-github-action-run-natively-run-on-web/1562</link>
          <pubDate>Tue, 16 Mar 2021 06:52:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1562</guid>
          <source url="https://forum.rebol.info/t/the-new-ren-c-github-action-run-natively-run-on-web/1562.rss">The New Ren-C GitHub Action: Run Natively, Run on Web!</source>
        </item>
        <item>
          <title>Setting VSCode Up for Syntax Highlighting</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>I've completely abandoned Visual Studio on Windows, and I'm phasing out Sublime Text use...so I'm thus committing to a VSCode-based workflow.</p>
<p>I wanted to get very basic syntax highlighting...where SET-WORD!s are bold, and comments are a different color.</p>
<p>The shortest path to having something right now seems to be to use the <a href="https://github.com/red/VScode-extension">VSCode extension for Red</a>.  You can install it from the extensions marketplace.  The extensions icon is on the left sidebar, the four little boxes with the box in the upper right hand corner popped out.</p>
<h2>
<a name="change-the-file-associations-for-rebol-and-red-1" class="anchor" href="https://forum.rebol.info#change-the-file-associations-for-rebol-and-red-1"></a>Change the File Associations for Rebol and Red</h2>
<p>It won't by default recognize .rebol, .r, or .reb files.  It thinks .r is R language.</p>
<p>So you have to open a file of with the suffix you want to remap.</p>
<p>With a file of your target type open, do <strong>Control-Shift-P</strong> and type in <strong>"Change Language Mode"</strong> (it will autocomplete).  Run the command, and you will get a drop down menu.  Say it's Red.</p>
<p>You should get the syntax highlighting.</p>
<h2>
<a name="customize-any-colors-in-your-settingsjson-2" class="anchor" href="https://forum.rebol.info#customize-any-colors-in-your-settingsjson-2"></a>Customize Any Colors In Your <code>settings.json</code>
</h2>
<p>I've made my opinion known that it's not good to be colorizing the likes of IF and RETURN specially from other WORD!s.  There are not supposed to be keywords, this undermines the message.</p>
<p>So getting rid of the Froot Loops colors is the first order of business.  There's no UI to speak of for configuring the colors in VSCode.  You have to edit a JSON file.</p>
<p>Again with <strong>Control-Shift-P</strong> but type in <strong>"Preferences: Open Settings (JSON)"</strong> (it will autocomplete).  A JSON file will open.</p>
<p>You can customize the environment itself (toolbars, etc.) or you can customize the syntax in the file.  For the syntax in the file, that's done under <strong>editor.tokenColorCustomizations</strong>.  For example:</p>
<pre><code>"editor.tokenColorCustomizations": {
    "comments": {  // gray is more subtle than the garish "green" comment
        "foreground": "#919191",
        "fontStyle": ""
    },
    "strings": {  // darken the shade of red used for strings
        "foreground": "#7c2424",
        "fontStyle": ""
    },
    "textMateRules": [
        {  // make SET-WORD!s bold, dark blue seems a bit subtler than black
            "scope": ["variable.name.red"],
            "settings": {
                "foreground": "#242650",
                "fontStyle": "bold"
            }
        },
        {  // Ren-C has no keywords, don't highlight "Red/System words"
            "scope": ["storage.type.function.reds.red"],
            "settings": {
                "foreground": "#000000",
                "fontStyle": ""
            }
        },
        {  // Ren-C has no keywords, don't highlight "Red words"
            "scope": ["storage.type.function.red"],
            "settings": {
                "foreground": "#000000",
                "fontStyle": ""
            }
        },
        {  // So long as ending in ! still makes words, don't colorize
            "scope": ["storage.type.cs.red"],  // word ending in !
            "settings": {
                "foreground": "#000000",
                "fontStyle": ""
            }
        },
		{  // Can't figure out how to recolor tags, it ignores this
            "scope": ["meta.tag.red"],
            "settings": {
                "foreground": "#22492e",
                "fontStyle": ""
            }
        },
        {  // Tag color doesn't seem to come from HTML
            "scope": ["entity.name.tag.html"],
            "settings": {
                "foreground": "#4a9ec5"
            }
        }
    ]
</code></pre>
<p>Autocompletion will hint you about things like comments and strings that are basic across all grammars.  But if you're wondering how to know the list of things like <strong>variable.name.red</strong> to colorize just for Redbols, you have to look at this file from the extension:</p>
<p><a href="https://github.com/red/VScode-extension/blob/master/syntaxes/Red.tmLanguage.json">syntaxes/Red.tmLanguage.json</a></p>
<p>Poke around there for anything that says <strong>name:</strong>, e.g. <code>"name": "variable.name.red"</code> to find the possibilities.</p>
<p>I can't figure out how to override the color of tags, however.  I can make them bold, but it seems to be getting the color from somewhere else.</p>
<h2>
<a name="hacking-on-the-rules-3" class="anchor" href="https://forum.rebol.info#hacking-on-the-rules-3"></a>Hacking On The Rules</h2>
<p>If one wants to hack on the syntax highlighting file, it's stored locally under the .vscode directory of your home directory, e.g.</p>
<pre><code>\.vscode\extensions\red-auto.red-0.4.3\syntaxes\Red.tmLanguage.json
</code></pre>
<p>Edits to that file seem to be picked up on restart.  You can back up a local copy, or just restore it from the web if you mess it up.</p>
<p>I'm not that big of a fan of syntax highlighting, so it probably won't be me who makes a fork of this extension to have support for things like COMMA! or SYM-XXX!  But, who knows, maybe I'll get inspired sometime.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/setting-vscode-up-for-syntax-highlighting/1559">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/setting-vscode-up-for-syntax-highlighting/1559</link>
          <pubDate>Sun, 14 Mar 2021 08:36:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1559</guid>
          <source url="https://forum.rebol.info/t/setting-vscode-up-for-syntax-highlighting/1559.rss">Setting VSCode Up for Syntax Highlighting</source>
        </item>
        <item>
          <title>Over 20 Years of C99: Making a Concession</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>In the interest of bragging rights, we've tried to say that Ren-C builds on C89.</p>
<p>Not quite true, since we use <strong><code>//</code></strong> comments instead of just <strong><code>/* */</code></strong> comments.  But a lot of compilers before C99 supported that, and you could just strip them out.</p>
<p>Also not quite true because we don't declare all locals at the top of blocks in a function.  But a lot of compilers before C99 supported that, and if not you could write a preprocessor to do it.</p>
<p>But a big feature that would helps if we permitted using it is C99 variadic macros.  It means we can automatically add terminator signals to API calls:</p>
<p>So instead of writing things like:</p>
<pre><code>if (rebNot("action?", rebQ(main_startup), rebEND))
    rebJumps("panic-value", rebQ(main_startup), rebEND);
</code></pre>
<p>We can say:</p>
<pre><code>if (rebNot("action?", rebQ(main_startup)))
    rebJumps("panic-value", rebQ(main_startup));
</code></pre>
<p>Right now we support both modes, but hold off on using the nicer mode in the internal implementation.</p>
<p>The C++ build checks to make sure that the rebENDs are there if you mark a file as "C89-compatible" and that it should have them.  So that makes it easier to not forget them if you meant them to be there.  But they're still an eyesore.</p>
<h2>I Think It's Time to Adjust The Rule</h2>
<p>The original idea was that "public-facing" code would all use the nice mode, but we would bear the burden of rebEND in the internal code for the sake of making it compile on older systems.</p>
<p>However, the code for the interpreter itself is supposed to be a showcase of its features.  If you are looking at the startup sequence in <code>main.c</code> and are hit with these rebEND-based API calls, that's will prevent appreciating it fully.</p>
<p><strong>We should preserve the ability to call these APIs from C89.</strong>   e.g. you should be able to include libRebol from a C89 compiler.  That API file should have a mode you can use to include it in a C89 program, where you have to provide the rebENDs explicitly.</p>
<p><strong>But the internal implementation should allow the usage of the macro form.</strong>  Not leveraging it makes reading the code for Ren-C itself not as pleasing as it should be.  I want the code for stepping through the boot process and extensions to make the best impression.  And rebEND detracts from an otherwise profoundly distinct experience.</p>
<p>The answer for people who want to build the sources on a very old compiler would be the same answer as for those who want to build it on a system that doesn't have <code>//</code>-comments...run the source through a preprocessor.  Expand the rebXXX() macros to make a new version of the source, <em>and then compile that</em>.</p>
<p>Seems fair.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/over-20-years-of-c99-making-a-concession/1554">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/over-20-years-of-c99-making-a-concession/1554</link>
          <pubDate>Fri, 12 Mar 2021 01:40:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1554</guid>
          <source url="https://forum.rebol.info/t/over-20-years-of-c99-making-a-concession/1554.rss">Over 20 Years of C99: Making a Concession</source>
        </item>
        <item>
          <title>Using Ren-C As The Shell In GitHub CI</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p><em>(Check this out, <a class="mention" href="https://forum.rebol.info/u/giuliolunati">@giuliolunati</a> ...!)</em></p>
<p>There's a feature in GitHub CI which lets you override the shell used in a workflow.  You can do it for the whole workflow, or even on a step-by-step basis.</p>
<p>This got me to wondering what it would be like to use Ren-C as the shell for a step.  It took a little tinkering, but I got it to work!</p>
<p>Here it is using an executable for Windows (that it just built) to test HTTPS reads:</p>
<pre><code>- name: HTTPS Read Test
  shell: r3 --fragment {0}
  run: |
    print {== Hello From R3 HTTPS Read Test! ==}
    parse as text! read https://example.com [
        thru &lt;h1&gt; copy header: to &lt;/h1&gt; to end
    ] else [
        fail "Couldn't Capture Page Title"
    ]
    assert [header = "Example Domain"]
    print ["Succeeded:" header]
</code></pre>
<p><strong><a href="https://github.com/metaeducation/ren-c/runs/2066230493?check_suite_focus=true#step:16:40">And it works!!</a></strong></p>
<p>What GitHub is doing is it's taking the body of what's in the <strong><code>run</code></strong> section and writing it to a temporary file with a random name off in some weird directory.  Then it substitutes that weird name in for the <code>{0}</code> in the shell expression.</p>
<h2>The New <code>--fragment</code> Option</h2>
<p>There were a lot of details on the path to getting that working.  But I'll just focus here on the new feature of saying that a script is a "fragment".</p>
<ul>
<li>
<p><strong>We Don't Want To Change Into the Temporary Directory The Fragment Lives In</strong>.  Rebol has historically switched to the directory a script lives in, and on balance I think that's the right default.  It helps the script find its own resources, where it has the most likely ability to neatly refer to files by short paths.  But this is a lone file...there's nothing to gain by doing that, and it's a disruption.</p>
</li>
<li>
<p><strong>I Don't Think It Should Need A Header, Either</strong>.  It would be a competitive disadvantage in this scenario--compared to other shells--if you had to put a dummy header in there.  By using a special name and a setting for "fragment" we have a way on the command line of saying "hey, this has no header, and I meant that".</p>
</li>
<li>
<p><strong>GitHub CI Threw In CR LF, we need an excuse to tolerate it</strong>.  Even though the YAML for the original code had just LF, the temp file for the run lines got CRs added.  I'm still pretty bullish on saying we need to consider this just like a syntax error or any other illegal sequence of characters.  If a strong stance isn't taken, then it screws everyone forever.  But here the compromise is that you have declared this isn't the kind of file you'd be sharing...not a "full script"...so it makes it a bit more okay to strip the CR LF silently (On Windows only, though!)</p>
</li>
</ul>
<h2>
<img src="https://forum.rebol.info/images/emoji/twitter/bulb.png?v=9" title=":bulb:" class="emoji" alt=":bulb:"> GitHub Action Dialects Might Have A Lot Of Potential <img src="https://forum.rebol.info/images/emoji/twitter/bulb.png?v=9" title=":bulb:" class="emoji" alt=":bulb:">
</h2>
<p>Not everyone has figured out that this is possible, yet.  But I found <a href="https://discourse.julialang.org/t/tip-use-julia-as-custom-shell-in-github-actions/53377">a post on the Julia forum</a> while I was doing it, showing that a few people are catching on to the idea.</p>
<p>But what we can do in customization could potentially go quite a lot farther than "Bash control structures but in a language you are more familiar with".  What the code does can be creatively tailored to the domain being solved.</p>
<p>A GitHub Action can make including the feature as easy as one line for users.  And we have the advantage of being able to make single-exe tools that could install on all the container types.  <em>(All of them are 64-bit.  Sorry, Red...)</em></p>
<p>Could be interesting.  We'll see!</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/using-ren-c-as-the-shell-in-github-ci/1547">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/using-ren-c-as-the-shell-in-github-ci/1547</link>
          <pubDate>Tue, 09 Mar 2021 12:37:07 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1547</guid>
          <source url="https://forum.rebol.info/t/using-ren-c-as-the-shell-in-github-ci/1547.rss">Using Ren-C As The Shell In GitHub CI</source>
        </item>
        <item>
          <title>Android&#39;s Back! Modernized, and With Continuous Integration</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>Since I was on a roll with the TCC Bootstrap and the Windows Builds on GitHub Actions, I decided to take a crack at bringing the Android builds back.</p>
<p>It would be underwhelming if I didn't bring things somewhat up-to-date in the process.  Android NDK versions are numbered by [r]evisions, and we had been on "r13" from October 2016.  Five years ago is basically eternity in cell phone time...and the revisions have counted up steadily since then, currently at "r21" (!)</p>
<p>So I dug in and suffered for another long continuous day-and-night to make it happen.</p>
<p><strong><a href="https://github.com/metaeducation/ren-c/runs/2050208508?check_suite_focus=true">And They're Back!!!</a></strong></p>
<h2>Big Change: Toolchain Switch to Clang</h2>
<p>The Android toolset was originally based on GCC.  But they wound up switching to Clang...starting by making it available in revision r16, and then removing the GCC support altogether in r18.</p>
<p>This may seem like a minor change for us (and it probably would have been easier if I knew more about the NDK to start with).  But cross compilation is never "simple", and Android is a particularly crazy combinatoric monster.  When the .zipped file for installing the SDK is 500MB--with executables for only <em>one</em> of the cross-compiling platforms--you can bet there's a lot in there to trip up.</p>
<p>I'll spare you the details, but you can read <strong><a href="https://github.com/metaeducation/ren-c/blob/master/configs/android-common.r">config/android-common.r</a></strong> if you want to see comments I wrote to document the process.</p>
<h2>Still Supporting The Older NDKs!</h2>
<p>The Google Play store will only accept apps that are built with very recent API Levels!</p>
<p>But I think it's interesting to be in the position that we can still build against older NDKs, perhaps for older hardware.  It's a distinguishing feature.</p>
<p>Anyway, I made the script detect the version and react accordingly.  Maybe there will be a time when it's not worth it to support the older NDKs, but for now it doesn't cost much...and it helps keep a check on making sure that if we use any "newfangled" APIs that only exist on certain modern devices, we do so consciously.</p>
<h2>Next Steps... CI Testing!</h2>
<p>So I said that I wanted anything we thought was important to be rigged up with automated testing.  I did some research into Android emulators that could run "headlessly" with no screen...let you install apps on a virtual phone, and run tests.  Such things do exist, and we could run them on GitHub Actions!</p>
<aside class="onebox githubfolder">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/marketplace/actions/android-emulator-runner" target="_blank" rel="noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:400/400;"><img src="https://avatars.githubusercontent.com/u/51352484?s=400&amp;amp;v=4" class="thumbnail" width="400" height="400"></div>

<h3><a href="https://github.com/marketplace/actions/android-emulator-runner" target="_blank" rel="noopener">Android Emulator Runner - GitHub Marketplace</a></h3>


  <p><span class="label1">Installs, configures and starts an Android Emulator directly on macOS virtual machines</span></p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>They say it only runs on Mac hosts.  So that incentivizes hammering on the cross-compile script until it's able to use platforms other than Linux to build for Android.  It may not actually be all that hard to do (will have to find out...)  Of course we could build on Linux and then just send that product to a mac to run the emulator.</p>
<p>Getting that ability to run a simulator that can test the built Android executable is a priority.</p>
<h2>Revive Building the APK</h2>
<p>So we definitely want to have the process from <strong><a href="https://www.youtube.com/watch?v=r5kccBehMMg">@giuliolunati's conference demo</a></strong> be automated and tested.  That means building the .APK file which bundles together both the native interpreter (as a backdoor to phone services) along with a WASM interpreter (to live in a webpage and be able to communicate with the native interpreter).</p>
<p>Maybe Giulio can speak to how far we are from having that work again... or if he's busy, I guess I can just go through the video... that's what it's for!  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<h2>Bring Back TCC Extension</h2>
<p>I <a href="https://forum.rebol.info/t/doubling-down-on-tcc-bootstrap-conference-demo-expanded/1542">resurrected the TCC bootstrapping</a> because I think it is an impressive demo, and it speaks to an important spiritual point about the project.</p>
<p>It's pretty easy to get the ball rolling for TCC on Linux.  But a bit more work when you're cross-compiling it, or making it for Windows.</p>
<p>I never tried it, but it seemed like we had TCC working on Android.  It would probably be worth doing it again, and interesting if we could see the TCC bootstrap demo work on a phone too (!)  We'll have to consult the old Travis build script to see how the ARM configuration was done.</p>
<h2>Revisiting This Gives Me More Motivation</h2>
<p>Slogging through the nightmare of the Android NDK reminds me that <em>we are really doing something that almost no one does anymore</em>.  They just sign away their lives to something like Android Studio and are so far away from the actual mechanical levels that they don't know what the dependencies are.  Most people probably wouldn't know <em>how</em> to do any different...and among those who know, it's simply too frustrating to work through the details.</p>
<p>When you add up all the platforms and parts that we have, this is probably a more compelling story than I give it credit for.  So we should definitely not take for granted what we've got...and get the great demos like the AndroidNative+WASM packaging back up and running!</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/rocket.png?v=9" title=":rocket:" class="emoji only-emoji" alt=":rocket:"></p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/androids-back-modernized-and-with-continuous-integration/1544">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/androids-back-modernized-and-with-continuous-integration/1544</link>
          <pubDate>Sun, 07 Mar 2021 12:17:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1544</guid>
          <source url="https://forum.rebol.info/t/androids-back-modernized-and-with-continuous-integration/1544.rss">Android&#39;s Back! Modernized, and With Continuous Integration</source>
        </item>
        <item>
          <title>New Build Executables, New Build Strategy</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>I mention that it's time to make a new batch of build executables.  I think it can no longer be avoided that we need a simplified build process, and having new and recent executables provides a big bag of tricks for writing a new one.  But first, let's just review a little history.</p>
<p>The story of the build system goes like this:</p>
<h2><a name="p-4448-r3-alpha-1" class="anchor" href="https://forum.rebol.info#p-4448-r3-alpha-1"></a>R3-Alpha</h2>
<p><strong>R3-Alpha's build was driven by a slightly templated GNU makefile.</strong>  You can see the text of the makefile template in <strong><a href="https://github.com/rebol/rebol/blob/master/src/tools/make-make.r"><code>%make-make.r</code></a></strong>, which you would run with what OS_ID system you wanted to build for.  It pulled together a list of files from <strong><a href="https://github.com/rebol/rebol/blob/master/src/tools/file-base.r"><code>%file-base.r</code></a></strong> and made you a <strong><code>makefile</code></strong>.</p>
<p>It's a simple approach.  It means you have to have GNU make on your platform, which meant it wasn't a workable way to build on Windows.   The README said:</p>
<blockquote>
<p>This first release is intended for non-Windows systems like Linux, Mac, BSD,<br>
Android, etc. However, it will build for Windows, but I've not included the<br>
typical MSVC project files. I'll try to get that added, but it's not that<br>
tough to create one yourself.</p>
</blockquote>
<p><strong>One of the steps run by the makefile was called "prep".</strong>  This ran Rebol script code that generated a bunch of files to support the build.  Responsibilities of this step were:</p>
<ul>
<li>
<p>Pack up all the mezzanine Rebol text sources--with comments removed--into a compressed blob of data in a <code>.c</code> file.  The C array of bytes in that file was effectively an embedded resource, used to bootstrap the system.</p>
</li>
<li>
<p>Look through the C sources of the interpreter and find function definitions.  Then automatically generate an aggregate<code> .h</code> header file with those definitions.  This keeps you from having to update function prototypes in more than one place.  One downside of having everything automatically glommed into one big header is that the architectural lines between files aren't as clear as they would be if the headers were more granular...but overall I'd say it works out as an advantage.</p>
</li>
<li>
<p>Take some Rebol-structured memoizations and transform them into C code.  Plenty of projects have similar steps to convert tabular data in whatever format into <code>.h</code> and <code>.c</code>.  Rebol is a better medium for representing freeform intent than what most people use.</p>
</li>
</ul>
<p>The "prep step" has evolved over time, but all of the "make" processes run it in the same way.  So what we're talking about changing here is really just about how the invocation of the compiler and linker is done.</p>
<h2><a name="p-4448-atronix-r3-2" class="anchor" href="https://forum.rebol.info#p-4448-atronix-r3-2"></a>Atronix R3</h2>
<p>Atronix builds against a lot of dependencies, and thus uses CMake.  CMake is a beast with a kind of archaic syntax.  But if you have a complex cross-platform C or C++ project...you don't really have much in the way of better options.  It has widely supported plugins for making sure your system pulls together the prerequisites it needs.</p>
<p>They used CMakeLists.txt files...written and maintained by hand.  No generation process, and they did not use the makefile.</p>
<h2><a name="p-4448-earls-buildreb-demo-3" class="anchor" href="https://forum.rebol.info#p-4448-earls-buildreb-demo-3"></a>Earl's %build.reb Demo</h2>
<p>The concept of using Rebol to build itself came up, by using CALL to invoke the compiler.  earl made a quick and dirty example of this, called <strong><a href="https://gist.github.com/earl/180d761ce5d27e411a6f">%build.reb</a></strong>.  It showed a promising and brief idea.</p>
<p>A disadvantage it had was that it could only do full builds. GNU make and CMake senses which files change.  Doing full builds on every change is not viable for day to day operation.</p>
<p>Another disadvantage is that this couldn't be used to bootstrap onto a new platform.  You can't have the only way an executable can be made be if you have one already.</p>
<p>But this was a promising idea...and being able to build without needing GNU make, especially on Windows, was an idea that stuck.</p>
<h2><a name="p-4448-rebmake-4" class="anchor" href="https://forum.rebol.info#p-4448-rebmake-4"></a>Rebmake</h2>
<p>Shixin didn't care for maintaining the handwritten CMakeLists.txt in parallel to changes with the <code>%make-make.r</code> process.  So he wanted a unified build.</p>
<p>But rather than thinking of the build as abstracting a <code>makefile</code> as R3-Alpha was doing, he thought of it as abstracting a CMake file...which is much more complex.  He wanted something that was "meta" enough that it could build to a <code>CMakeLists.txt</code>, a GNU <code>makefile</code>, a Visual Studio <code>.app</code> file, a command-line MSVC <code>nmake</code> file... or just drive the process through CALL as %build.reb had done.</p>
<p>The result of this ambitious process was the generalized engine of <strong><a href="https://github.com/metaeducation/ren-c/blob/9dc8ca2786ff57f9e4fc579e7a14623b014e4ce2/tools/rebmake.r"><code>%rebmake.r</code></a></strong>.  But that was a generic framework which then needed to be customized specifically to build a project...giving rise to the client script using the library <strong><a href="https://github.com/metaeducation/ren-c/blob/master/make.r"><code>%make.r</code></a></strong> (the names are arguably backwards... that make.r would be the framework, and rebmake.r would be the script for building Rebol).</p>
<p>Additionally, rebmake tried to accommodate two important new features:</p>
<ul>
<li>
<p>Per-OS or build type configuration files (<strong><a href="https://github.com/metaeducation/ren-c/tree/master/configs"><code>%configs/</code></a></strong>) to help with common builds</p>
</li>
<li>
<p>Having make specifications in the folders of extensions, so that their build recipes could be broken out from the main file.  Here's for instance today's Crypt module's <a href="https://github.com/metaeducation/ren-c/blob/9dc8ca2786ff57f9e4fc579e7a14623b014e4ce2/extensions/crypt/make-spec.r"><strong><code>extensions/crypt/%make-spec.r</code></strong></a></p>
</li>
</ul>
<p>To most observers (including myself), Rebmake is way too big.  It makes sense if you think the goal is to generate CMake files or Visual Studio files.  But what you wind up with in this line of thinking is kind the direct opposite of Rebol's goals: <em>instead of making a thing that is significantly less complicated than those systems, you have something that inherits all their complexity and then layers on more</em>.</p>
<h2><a name="p-4448-giulios-makefilereb-experiment-5" class="anchor" href="https://forum.rebol.info#p-4448-giulios-makefilereb-experiment-5"></a>Giulio's makefile.reb experiment</h2>
<p>We pretty much all agree Rebmake has to go, but build systems are just naturally difficult...and not a lot of fun.</p>
<p><a class="mention" href="https://forum.rebol.info/u/giuliolunati">@giuliolunati</a> recently took a stab at seeing what kind of a minimal direction might be taken, and generated a <strong><a href="https://github.com/metaeducation/ren-c/blob/5e56c3b946807f70fcfe6c1c190b6aa49c5b0cd7/makefile.reb">%makefile.reb</a></strong> that steered back closer to the ideas of R3-Alpha.  But there's a complicated set of requirements in this problem, so it's easy to see it stalled.</p>
<p>His file is a good reminder of the kind of scale we're looking for the build solution to be on.  To think smaller and simpler, and cut things back.</p>
<h2><a name="p-4448-pulling-together-a-new-design-6" class="anchor" href="https://forum.rebol.info#p-4448-pulling-together-a-new-design-6"></a>Pulling Together A New Design</h2>
<p>So taking all this experience into account, I'm ready to take a stab at starting anew.  I want to back off from thinking of this as building a generic make system you'd use for other C projects...I think that's a bad idea.</p>
<p>Here's my rough strategy:</p>
<ul>
<li>
<p><strong>Make the main build system we use day-to-day driven by Ren-C using CALL.</strong>  That means it needs to check object file time stamps vs. the source files, and be incremental.</p>
</li>
<li>
<p><strong>Forget about makefiles or Visual Studio projects or otherwise.</strong>  For bootstrap, just have a way that the list of command lines which would be run by CALL can be output to a <code>.bat</code> or <code>.sh</code> file.  A full build is good enough...then once you're bootstrapped, use the executable from then on.</p>
</li>
<li>
<p><strong>Use a circa 2021 Ren-C to do the builds, unlocking more superpower in the make script design.</strong>  Hopefully <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> and I can <a href="https://forum.rebol.info/t/the-r3c-branch-chriss-rebol-or-rebol-3-conservative/1284/4">coordinate that this is "R3C"</a>...with a maintenance contract and quality control.  That's something that the haphazard build-picking process hasn't done before in the history of Rebol, and would in itself be refreshing.</p>
</li>
<li>
<p><strong>Make Building as a C library the Main Mission</strong>.  Strangely enough, the web build has been made available as a library with no included "main()" before offering a similar static library for C.  That's kind of silly.  If a C library were enabled, we could break out the console into its own repository...or put together things like demo projects on GitHub that offered desktop GUIs.  This was the original concept and it just never happened.  If not now, when?</p>
</li>
<li>
<p><strong>Revive Granular Extensions, in Particular Wasm Side-Modules ("the DLLs of Wasm")</strong>.  There was a nice concept in Rebmake that extensions could be not built (<code>-</code>), included statically in the executable (<code>+</code>), or made as a DLL/shared-library (<code>*</code>).  The DLL option did not really get tested and hasn't worked for a while.  It needs to...and with the primacy of the web build, we have to get that working for loading extensions as little Wasm fragments.  We also need to make it easier for extensions to live in their own git projects, vs. in the interpreter master git.</p>
</li>
<li>
<p><strong>Try building using the TCC extension in a web browser.</strong> This isn't necessarily as far fetched as it sounds.  Ren-C running in wasm in the browser could pull a .ZIP of the sources, let you click some customizations, and using the person's own CPU power in the browser build an x86 executable that you could then download.  It's really just a recycling of <a href="https://youtu.be/PT3GOe1pj9I?t=182">the conference demo</a>.</p>
</li>
</ul>
<p>As usual, this is all daunting stuff, but with some focus it may be realistically doable.  There's a lot of experience here to draw from...at least to know what NOT to do...!</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/new-build-executables-new-build-strategy/1432">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/new-build-executables-new-build-strategy/1432</link>
          <pubDate>Sat, 12 Dec 2020 12:11:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1432</guid>
          <source url="https://forum.rebol.info/t/new-build-executables-new-build-strategy/1432.rss">New Build Executables, New Build Strategy</source>
        </item>
        <item>
          <title>How to set a compile variable?</title>
          <dc:creator><![CDATA[iArnold]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>I want to set a variable so I can compile C code depending on if this variable is defined or not.</p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/how-to-set-a-compile-variable/1366">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-to-set-a-compile-variable/1366</link>
          <pubDate>Wed, 14 Oct 2020 20:34:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1366</guid>
          <source url="https://forum.rebol.info/t/how-to-set-a-compile-variable/1366.rss">How to set a compile variable?</source>
        </item>
        <item>
          <title>A Separate and Simpler C89 Build</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>Now and again the idea comes up to switch to take C99 features for granted, given that standard is now... over 20 years old.</p>
<p><strong>The principal benefit of stepping up from C89 to C99 is in libRebol, so that it automatically terminates the variadic APIs.  It is a <em>SIGNIFICANT</em> benefit!</strong></p>
<p>As libRebol usage is on the rise, I'm finding my productivity adversely affected by the usability factors of not having termination be implicit.  It's easy to make mistakes, kind of like messing up a printf()'s arguments...but a worse version of that, because of how nested libRebol expressions often are.</p>
<p>But even more importantly: <em>I don't think the <em>truly innovative</em> aspects of the API show off as well when they are contaminated with the rebEND "tics" and other workarounds.</em>  That makes me sad.  <img src="https://forum.rebol.info/images/emoji/twitter/crying_cat_face.png?v=9" title=":crying_cat_face:" class="emoji" alt=":crying_cat_face:"></p>
<h2>Is it Time for a Compromise?</h2>
<p>As the system has become more granular with ~30 extensions, it gets easier to pick some of those as "C99 and above only".  For instance: what C89-only system can run ZeroMQ...which presumably can't be built for such a system in the first place?</p>
<p>But some extensions are mandatory to get a baseline usable system.  You can't do much without file I/O.  So if a system supports C89 and POSIX it seems disingenuous to say "There's no FILESYSTEM extension, but you can still compile the core..."</p>
<p>Right now I'm dealing with the suboptimal situation of expressing the C portion of the "rich console" in C89.  And it makes me wonder:</p>
<p><strong>Could we say that C89 platforms <em>work</em>, but just don't have a rich console?</strong>  e.g. they would read one line at a time with scanf(), run it, and print the result out with printf().</p>
<p>Hence in a C89 build, you would un-include the "modern" CONSOLE extension and use the CONSOLE-C89 extension, or somesuch.  This would have the advantage of keeping us from making the modern codebase look like it's contaminated with archaic concerns.  We don't at this point have any platforms or clients that are "real" that only have C89...and I gather if we did, people would be happy to have scripts run on them at all.</p>
<p><strong>In the near term, the odds are we're only going to be seeing these C89 build modes on Travis or wherever we force the issue... as a matter of principle.</strong>  We could also say "to heck with it, don't waste the time up front...let someone else do it if and when it comes up".  But I think I'd rather keep it going.</p>
<p>I just want us to be putting our best face forward with the code most people see and hack on. And it's pretty clear that C89 isn't giving us that (due to fundamentally missing the feature of variadic macros).</p>
<p><em>(FWIW, pre-C99 compilers did often support variadic macros... but with a gnarly non-standard syntax that only worked in their compiler.  So it's not unlikely that someone could hack in a way to make libRebol work on their older compilers without rebEND, if they were motivated...or just do a little custom preprocessing step of their own.)</em></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/a-separate-and-simpler-c89-build/1268">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/a-separate-and-simpler-c89-build/1268</link>
          <pubDate>Thu, 05 Mar 2020 22:09:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1268</guid>
          <source url="https://forum.rebol.info/t/a-separate-and-simpler-c89-build/1268.rss">A Separate and Simpler C89 Build</source>
        </item>
        <item>
          <title>command line options as `target: makefile` vs `target=makefile`</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>It is traditional for programs that take command-line options in one of the following ways:</p>
<pre><code>my-program optionname=option
my-program --optionname option
my-program --optionname=option
my-program /optionname option
</code></pre>
<p>R3-Alpha's %make-make.r had code for the first case, so you would say <code>make-make OS_ID=1.2.3</code>, or whatever.  This was presumably just going with the flow of how options to GNU make were specified.</p>
<p><a class="mention" href="https://forum.rebol.info/u/giuliolunati">@giuliolunati</a> had an interesting idea of using a more Rebol-like syntax:</p>
<pre><code>my-program optionname: option
</code></pre>
<p>This not only is "more Rebolish", but you get filename completion on your options in most shells (because it's not trying to do the completion with <code>optionname=</code> glued to the front of it).</p>
<p>At the moment, you can use either <code>--optionname=</code> or <code>optionname:</code> with %make.r.  I've been using the colon form for a while, and like it.  For the sake of simplicity, I'm wondering if it should be the <em>only</em> option format that <code>make.r</code> supports.</p>
<p>I can't think of any <em>technical</em> reason not to do it.  One could argue that it will look unfamiliar.  But I think it's easier to read this way.</p>
<p>Is there any reason not to standardize to this?</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/command-line-options-as-target-makefile-vs-target-makefile/1132">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/command-line-options-as-target-makefile-vs-target-makefile/1132</link>
          <pubDate>Mon, 25 Mar 2019 16:25:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1132</guid>
          <source url="https://forum.rebol.info/t/command-line-options-as-target-makefile-vs-target-makefile/1132.rss">command line options as `target: makefile` vs `target=makefile`</source>
        </item>
        <item>
          <title>About the Build System category</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>Discuss rebol-make and other build systems.</p>
            <p><small>6 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/about-the-build-system-category/1131">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/about-the-build-system-category/1131</link>
          <pubDate>Mon, 25 Mar 2019 16:11:05 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1131</guid>
          <source url="https://forum.rebol.info/t/about-the-build-system-category/1131.rss">About the Build System category</source>
        </item>
        <item>
          <title>Ownership of GitHub by Microsoft - risk assessment</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>Currently the whole project and all ancillary projects are hosted on GitHub, the proverbial eggs all in one basket scenario.  This is something we should consider even without the change of ownership.</p>
<p>Should we consider mirroring to GitLab?<br>
Or is the sky never falling?</p>
            <p><small>6 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/ownership-of-github-by-microsoft-risk-assessment/672">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/ownership-of-github-by-microsoft-risk-assessment/672</link>
          <pubDate>Sat, 09 Jun 2018 01:34:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-672</guid>
          <source url="https://forum.rebol.info/t/ownership-of-github-by-microsoft-risk-assessment/672.rss">Ownership of GitHub by Microsoft - risk assessment</source>
        </item>
        <item>
          <title>What Should the Experience of Building Rebol Be Like?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>When R3-Alpha was open-sourced, the make directory contained <a href="https://github.com/rebol/rebol/tree/c99039c37d7bbff8b5f901c593f5c3e4398b84c4/make">one GNU makefile</a>, and Carl gave these instructions:</p>
<blockquote>
<p>About the Makefile:</p>
<p>You might notice that the makefile is a bit old-fashioned. That's because I still support REBOL on some very old systems that don't offer newer makefile features. So, please keep that in mind and stick with this simple format.</p>
<p>Also, the makefile is built by REBOL. Typing "make make" will rebuild it, and you can also select a different platform target the same way by providing the REBOL platform identifiers (the last two parts of the version string).</p>
<p>Build Instructions:</p>
<p>Parts of REBOL are built by REBOL. So, to build it, you'll need to download a running binary into the local make directory. Call it r3-make.</p>
<p>The build happens in the make directory. It will create an obj sub-dir for storing the object files. I prefer this over mixing the source and object files into the same directory.</p>
<p>The biggest step is to do the "make prep" which will use REBOL to configure and build a number of important C header files.</p>
<p>If you are building for a new platform that has no existing REBOL, you can use "make prep" to build all the files you need on an existing platform and copy them to the new platform.</p>
<p>After the prep, just run "make" and the rest of the system will build.</p>
</blockquote>
<p>One might ask: if the makefile is built by Rebol, <em>why would it be committed in the repository</em>?  What platform is this makefile for?  What happens if you just say <code>make</code>?</p>
<p>The answer is that the makefile was generated for <a href="https://github.com/rebol/rebol/blob/c99039c37d7bbff8b5f901c593f5c3e4398b84c4/make/makefile#L32">32-bit Linux (0.4.4)</a>, so it was produced by running the command <code>r3-make %../src/tools/make-make.r OS_ID=0.4.4</code>.  However, it contains a trick: it has a target itself called "make" such that once generated, running <code>make make OS_ID=0.X.Y</code> will <em>overwrite the makefile itself</em> with an updated version for that OS.</p>
<p>We found this annoying, because the committed <code>makefile</code> would appear dirty in version control if you are using another system.  And also, one could streamline this process a bit for the average person if instead of them having to go <a href="https://github.com/rebol/rebol/blob/c99039c37d7bbff8b5f901c593f5c3e4398b84c4/src/tools/systems.r#L21">look at the %systems.r table and find their platform</a>, if the <code>r3-make</code> could inspect its own <code>system/version</code> and <em>assume</em> you wanted to build that same OS_ID.</p>
<p>And so <a href="https://github.com/metaeducation/ren-c/blob/e6cab210d6355f50b36fe6e15acc1f5859a95c30/make/makefile.boot">%make/makefile.boot</a> was born.  It was a committed file which saved you all the trouble of typing <code>./r3-make ../src/tools/make-make.r</code> followed by <code>make r3</code>.  Instead you could now type <code>make -f makefile.boot</code>.</p>
<p>If it sounds stupid, it kind of is.  But it wasn't rocket science to write, and you could also think of it as a kind of an interactive README file...if you didn't have something you needed, it could tell you.  And given that the build process was already dependent on you having GNU make, it could also catch you on that "meta-step" of needing make in the first place.</p>
<p><strong>But we live in a different world now.</strong>  You no longer need GNU make to build Ren-C.  You can still target it, but you can also generate files for Microsoft's NMAKE, or a Visual Studio project file.  And you can even forego the idea of a makefile altogether--instead having the Rebol executable drive the build process using <code>CALL</code> on the C compiler directly.  So it's time to scrap %makefile.boot and let a Rebol script be the entry point to the process.</p>
<p>I'm going to be talking about platforms, building, extensions in some more technical posts.  But this is more a philosophy post, or user-experience question.  Maybe any points people want to raise about building a system where it's been done right?</p>
<p>One thing we definitely should make easier is bootstrapping to new platforms.  The generated products of a Rebol "prep" process need to be in one central place to be grabbed and moved over.  Bootstrapping in this way should be part of the test process, e.g. one of the Travis instances that does a Win32 build on Linux could do the Win32 prep using the native Linux executable.  And then make sure it can just move the one folder with prep products into a completely fresh git install and still build with the cross-compiler...</p>
            <p><small>11 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/what-should-the-experience-of-building-rebol-be-like/334">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-should-the-experience-of-building-rebol-be-like/334</link>
          <pubDate>Wed, 11 Oct 2017 19:16:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-334</guid>
          <source url="https://forum.rebol.info/t/what-should-the-experience-of-building-rebol-be-like/334.rss">What Should the Experience of Building Rebol Be Like?</source>
        </item>
        <item>
          <title>Obtaining a static url for the latest builds?</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>Just wondering how feasible it is for Travis to also upload the latest build in a latest folder so that the URL remains fixed</p>
<p>So, instead of going, for example, to</p>
<pre><code>http://metaeducation.s3.amazonaws.com/travis-builds/0.3.40/r3-4f44c19-debug-cpp.exe
</code></pre>
<p>for the current latest build, we can go to</p>
<pre><code>http://metaeducation.s3.amazonaws.com/travis-builds/latest/0.3.40/r3.exe
</code></pre>
<p>This would make things easier to publish documents in case people need to use <code>wget</code> etc.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/obtaining-a-static-url-for-the-latest-builds/245">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/obtaining-a-static-url-for-the-latest-builds/245</link>
          <pubDate>Tue, 08 Aug 2017 07:09:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-245</guid>
          <source url="https://forum.rebol.info/t/obtaining-a-static-url-for-the-latest-builds/245.rss">Obtaining a static url for the latest builds?</source>
        </item>
        <item>
          <title>&quot;On Building Ren-C With C++ Compilers&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>Ren-C is a C codebase, but it can optionally also be built with a C++ compiler.  Building as C++ adds extra checking at <em>compile-time</em> of the interpreter's implementation.  This helps catch bugs that a C compiler could only check at <em>runtime</em>.  Plus--in the debug build only--the C++ build adds some extra runtime assertions, that do not affect interpreter semantics.</p>
<p>This document attempts to outline reasons for the choices in tooling, as it pertains to C and C++.</p>
<h1><a name="p-4046-why-use-c-instead-of-requiring-c-and-using-the-c-standard-library-1" class="anchor" href="https://forum.rebol.info#p-4046-why-use-c-instead-of-requiring-c-and-using-the-c-standard-library-1"></a>Why use C instead of requiring C++ and using the C++ standard library?</h1>
<p>Basically all languages measure their success against others with things like:</p>
<ol>
<li>How large is the source code a user must write for a given problem</li>
<li>How big in bytes is the installation for a program made with the system</li>
<li>How fast are programs written in the idiomatic style of the language</li>
<li>How well does the language help protect against common mistakes or bugs</li>
</ol>
<p>If today's Rebol executable were written in C++, it would not affect (1) (since the interpreter would behave the same).  Leveraging the C++ language features and <a href="http://en.cppreference.com/w/cpp/container">the well-vetted C++ standard library</a> would very likely <em>improve</em> Rebol on points like (2), (3), and (4).  After all, C++ was designed to not mean compromises on performance or size.</p>
<p>But Rebol (and Red) languages have unusual ideas of what counts as a "metric of success" or "signal of failure".  One metric is <em>the total complexity of the system, when the toolchain used to build the system is included in the equation</em>.  This is to say that Rebol's "complexity footprint" size must account for the tools used to build it.  (This aspect of concern is one that can be found also in the <a href="https://en.wikipedia.org/wiki/Forth_(programming_language)">Forth</a> community.)</p>
<p>To understand a self-hosting C compiler, you really only have to understand something like <a href="https://en.wikipedia.org/wiki/Tiny_C_Compiler">"TCC"</a>.  Its modern forms are around 300 <em>kilobytes</em> on x86, and that is enough to build Ren-C.  Yet the smallest full C++ compiler executables are around 3 <em>megabytes</em>.  The size of C++ is directly in proportion to the depth of nuances, features, and understandings required.  Even very straightforward code, like the implementation of <a href="https://gcc.gnu.org/onlinedocs/gcc-4.6.3/libstdc++/api/a01115_source.html">std::vector for gcc</a>, is quite deep about the features of the compiler that it depends upon to work.  This is considered a "cost" to be avoided.</p>
<h1><a name="p-4046-why-worry-about-building-a-c-program-as-c-2" class="anchor" href="https://forum.rebol.info#p-4046-why-worry-about-building-a-c-program-as-c-2"></a>Why worry about building a C program as C++?</h1>
<p>The practice of building C programs as C++ may sound strange, but it is not.  In fact, the GCC compiler itself is written in a generally-compatible subset of C and C++.  It is also recommendation CPL.2 from the <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-cpl">C++ Core Guidelines</a>:</p>
<blockquote>
<p>C rule summary:</p>
<ul>
<li>CPL.1: Prefer C++ to C</li>
<li>CPL.2: <strong>If you must use C, use the common subset of C and C++, and compile the C code as C++</strong></li>
<li>CPL.3: If you must use C for interfaces, use C++ in the code using such interfaces</li>
</ul>
</blockquote>
<p>For Ren-C, the advantages started out small--with enhanced cases of type checking.  Eventually this grew into more serious usage as a static analysis tool.</p>
<p>Next some very selective runtime checks in the debug build which lean on C++ were added.  These checks take advantage of something C++ can do which some C developers hate: namely that you can write a simple thing like <code>*a = *b;</code> and it might actually insert a function call to implement overloaded assignment.  When this "hated" property is limited to only adding asserts, it saves the codebase from becoming littered with:</p>
<pre><code> assert(Can_Assign_Values_Debug(a, b));
 *a = *b;
</code></pre>
<p>Having the C++ build do it "invisibly" from just <code>*a = *b;</code> is lighter weight--and keeps the focus on the main program logic.  So some asserts do work like this, if they are not that critical.  However, the C build uses ordinary macros such as <code>CHECKED_ASSIGN(a, b)</code> if it's important enough to warrant disruption in the source at every callsite.</p>
<p>At this point, it would be fair to say that some critical Ren-C features (e.g. <a href="https://github.com/metaeducation/ren-c/wiki/Relative-Binding-and-FRAME!-Internals">Specific Binding</a> and its outgrowths) would have been impractical to implement without the extra compile-time checks from C++.  It has really been an interesting study in its own right, of how the benefits of C++ can be applied while sticking to the domain of C.  For instance, see <a href="http://blog.hostilefork.com/c-casts-for-the-masses/">C Casts for the Masses</a></p>
<h1><a name="p-4046-how-old-or-new-a-c-compiler-can-be-used-to-build-ren-c-3" class="anchor" href="https://forum.rebol.info#p-4046-how-old-or-new-a-c-compiler-can-be-used-to-build-ren-c-3"></a>How old (or new) a C compiler can be used to build Ren-C?</h1>
<p>When Rebol's "R3-Alpha" codebase was released 12-Dec-2012, it was billed as <em>mostly</em> C89-compatible...which is to say that it could be built with compilers that obeyed a specification formally published in 1989.  <em>(Some compilers had the features prior to that.)</em>  Yet immediately obvious was the use of "C++-style" comments, e.g. <code>// comment</code> instead of <code>/* comment */</code>, which was not adopted formally by C until 1999.</p>
<p>On the question, <a href="http://www.rebol.com/cgi-bin/blog.r?view=0515#comments">Carl Sassenrath said</a>:</p>
<blockquote>
<p><em>"In the past it's been determined by practicality: what actually works over the widest range. (I can usually port REBOL3/core to any target machine in 5 minutes.)"</em></p>
<p><em>"This hasn't been easy, and it's why there are various C restrictions. I agree... many of the C++isms are nice, but can dramatically reduce portability to older boxes. It's a balancing act."</em></p>
</blockquote>
<p>Since the decisions arose pragmatically, there was no standard to point to.  So when Ren-C was started, it whipped the code into shape for C89 compliance, which could be checked with GCC's <code>--std=c89 --pedantic</code> switch.  Every warning was attended to, and that included things like adhering to the <a href="http://stackoverflow.com/questions/11488616/">509 character maximum for string literals</a> in generated code.</p>
<p>There were two exceptions of features that are <em>not</em> in the C89 standard which were left in early Ren-C:</p>
<ul>
<li>C++-style <code>//</code> comments, mentioned above</li>
<li>The expectation that a <code>long long</code> datatype existed <em>(see <a href="http://stackoverflow.com/questions/4017621/">-Wno-long-long</a>)</em>, because of the requirement of a 64-bit integer type</li>
</ul>
<p>Despite attempts to keep these as the only two "non-C89" features, the <code>long long</code> requirement did set a sort of baseline "minimum era" for the expected compiler.  And one feature that one could reasonably assume of any 64-bit capable compiler would be assignments in mid-scope:</p>
<pre><code> void foo() {
     int x = 10; // legal in C89
     int y1;
     if (Some_Check()) {
         printf("no declarations after statements.\n");
         return;
     }
     y1 = 20;
     int y2 = 20; // illegal in C89
 }
</code></pre>
<p>R3-Alpha almost always used "y1-style" initialization, even though "x-style" was legal.  This was perhaps because it is a pain when adding and removing statements to have to switch assignments back and forth between "y1-style" and "y2-style", so just sticking to the always-legal form of separating declarations and assignments was preferred.  But not only was there a mixture, the lack of compiler enforcement meant a few cases of "y2-style" had crept in.</p>
<p>So Ren-C originally removed those few "y2-style" stragglers.  But it's preferable to do initialization at the point of declaration, and any compiler supporting 64-bit integers almost certainly would be able to do this too.  That led this to be one of the <code>-pedantic</code> C89 rules that is disregarded.</p>
<p>The other common C feature that isn't in C89 but exists in most older compilers is support for inline functions.  However, it was not until C99 that "inline" was standardized...MSVC used __inline, for instance.</p>
<p>R3-Alpha used a small amount of inlining, and preferred preprocessor macros.  But it is common knowledge that if a C macro is "function-like", e.g. <code>#define MIN(a,b) ((a) &lt; (b) ? (a) : (b))</code> then there can be problems if evaluating an argument has a side-effect.  And even if evaluating an argument twice doesn't have side effects, it could be computationally wasteful to evaluate it more than once.  It's also easy to forget parentheses around expressions, and long macros are ugly when broken across lines.  There are a lot of reasons why "preprocessor macros are bad".</p>
<p>Not all C function-like macros can be replaced by C inline functions.  Since C lacks templates you lose generality e.g. <code>inline min(int a, int b) { return a &lt; b ? a : b; }</code> only works for <code>int</code> and not <code>float</code>.  Yet avoiding inline functions in Rebol may have less to do with a lack of compiler support, and more to do with the fact that it is "only a hint".  (The ultimate decision of whether inline is used is left to the optimizer.)</p>
<p>Ren-C shifted to use of the specific combination <code>inline static</code>, which means if inline is not available as a language keyword then it can be defined even as nothing.  Then the functions are just static, and compiled into each translation unit.</p>
<p>So the full list of non-C89 features used are:</p>
<ul>
<li>C++ style comments <code>//</code></li>
<li><code>long long</code></li>
<li>Declarations after statements</li>
<li><code>inline</code></li>
</ul>
<p>Other C99 or C11 features are not used.</p>
<h2><a name="p-4046-how-old-a-c-compiler-can-build-ren-c-as-c-4" class="anchor" href="https://forum.rebol.info#p-4046-how-old-a-c-compiler-can-build-ren-c-as-c-4"></a>How old a C++ compiler can build Ren-C as C++?</h2>
<p>While the C build tries to support very old compilers, the C++ checks do not.  It is not worth it to maintain compatibility for C++98 for the debug checks that C++ odes.</p>
<p><em>(Note: It wouldn't necessarily be hard to have conditional usage of C++11 features to make most of it work in C++98, there's just little point in the added complexity and <code>#ifdef</code>s.  It is not intended that release builds be made using C++ compilation.)</em></p>
<p>In terms of newer compilers, C++14 and C++17 have been tested and work under GCC and Clang.</p>
<h2><a name="p-4046-can-a-c-built-ren-c-library-work-with-a-c-built-one-5" class="anchor" href="https://forum.rebol.info#p-4046-can-a-c-built-ren-c-library-work-with-a-c-built-one-5"></a>Can a C-built Ren-C library work with a C++-built one?</h2>
<p>The external library "libRebol" should not notice a difference.  But the system internals ("sys-core.h") do compile differently, so an extension which can pick apart cells and such must be compiled with C++ if the core it runs against is also compiled with C++.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/on-building-ren-c-with-c-compilers/1343">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/on-building-ren-c-with-c-compilers/1343</link>
          <pubDate>Mon, 23 May 2016 04:00:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1343</guid>
          <source url="https://forum.rebol.info/t/on-building-ren-c-with-c-compilers/1343.rss">&quot;On Building Ren-C With C++ Compilers&quot;</source>
        </item>
  </channel>
</rss>

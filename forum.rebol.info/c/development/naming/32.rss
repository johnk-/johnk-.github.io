<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Naming - AltRebol</title>
    <link>https://forum.rebol.info/c/development/naming/32</link>
    <description>Topics in the &#39;Naming&#39; category Suggestions on naming new functions, and guidance on choosing names.</description>
    
      <lastBuildDate>Sat, 17 Feb 2024 06:47:12 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/naming/32.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Dropping the ANY-XXX! from (Some) Type Constraints?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>There was a slightly confusing aspect of historical Rebol where some typesets were named so that they looked just like a datatype:</p>
<pre><code>red&gt;&gt; help append
USAGE:
    APPEND series value

DESCRIPTION: 
    Inserts value(s) at series tail; returns series head. 
    APPEND is an action! value.

ARGUMENTS:
    series       [series! bitset! port!] 
    value        [any-type!] 
...
</code></pre>
<p>Here, we see SERIES! which is not named in a way that makes it obvious that it's not a fundamental type.  It's named the same as BLOCK! or WORD!.</p>
<p><span class="mention">@earl</span> and I agreed that this was a stumbling block, so we thought that ANY-SERIES! was a better name.  That way you wouldn't make the mistake of saying:</p>
<pre><code>if series! = type? x [...]
</code></pre>
<p>...and have it always fail.  You'd be cued by that ANY- to know that it was a set of many types.  (You still might think that you could use the equals operator to see if something was in a typeset and be wrong, but that's a different level).</p>
<p><a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151">But Ren-C has done away with typesets.</a>  They were too limited, and we now use arbitrary functions to do typechecking via predicates (with some various supporting optimizations so the common cases aren't horrifically slow).</p>
<p>So ANY-SERIES! is pretty much going away.  Most of the time you just use ANY-SERIES? (e.g. in a function spec or regular code), and then &amp;ANY-SERIES? if you're in something like a parse rule.</p>
<h2>
<a name="do-we-still-need-the-any-1" class="anchor" href="https://forum.rebol.info#do-we-still-need-the-any-1"></a>Do We Still Need The ANY-?</h2>
<p>I'm a little torn on the question of whether we need the ANY-.</p>
<p>Sometimes it's required (e.g. with ANY-WORD?) because WORD? means specifically "plain word".  (Note you'd use WORD! generally in type specs, though technically you can use either...performance should be identical).</p>
<p>But on ANY-SERIES? it's now a bit superfluous. And SERIES? is certainly shorter.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>It's not a slam dunk to take the ANY- off.  I kind of like the realization it gives you as a reader... "hey, we're talking about multiple things here"... and it makes you stop and consider "just how many series are there?  is ANY-SERIES? really what I mean?"</p>
<p>I kind of lean to keeping it.  And I prefer ANY-VALUE? to just VALUE? as well.</p>
<p>But it's definitely less important than it was.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/dropping-the-any-xxx-from-some-type-constraints/2152">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dropping-the-any-xxx-from-some-type-constraints/2152</link>
          <pubDate>Sat, 17 Feb 2024 06:47:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2152</guid>
          <source url="https://forum.rebol.info/t/dropping-the-any-xxx-from-some-type-constraints/2152.rss">Dropping the ANY-XXX! from (Some) Type Constraints?</source>
        </item>
        <item>
          <title>Naming for Line and Space Adders and Removers</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p><a href="https://forum.rebol.info/t/introducing-delimit-plus-spaced-and-unspaced/2102">(DELIMIT, SPACED, UNSPACED) [are] very nice!</a> Might I suggest that you could add to this set of functions <code>unlines</code>, an immensely useful function from Haskell:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">ghci&gt; unlines ["a list","of lines","of text"]
"a list\nof lines\nof text\n"
</code></pre>
<p>(Haskell also has the reverse function <code>lines</code>, which splits up a string into a list of lines. There’s also <code>unwords</code>/<code>words</code>, which do the same thing for all whitespace.)</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/naming-for-line-and-space-adders-and-removers/2104">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/naming-for-line-and-space-adders-and-removers/2104</link>
          <pubDate>Thu, 11 Jan 2024 07:10:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2104</guid>
          <source url="https://forum.rebol.info/t/naming-for-line-and-space-adders-and-removers/2104.rss">Naming for Line and Space Adders and Removers</source>
        </item>
        <item>
          <title>Why &quot;TRASH&quot; Is The Name For &quot;Unset State&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>As isotope design became refined, I became very pleased with the choice for what unset variables hold being the <em>isotopic void</em>.</p>
<pre><code>&gt;&gt; x: ~
== ~  ; isotope

&gt;&gt; unset? 'x
== ~true~  ; isotope
</code></pre>
<p>The alternative of using the isotopic word <strong><code>~unset~</code></strong> was available.  But isotopic voids are a particularly pleasing choice, due to their succinct representation...which helps assigned variables stand out better in lists of mostly-unset variables.  And it's hard to think of what isotopic voids would mean if they were <em>not</em> the unset state!</p>
<p>Also, if ~unset~ were used then people would probably expect <strong>unset? ~unset~</strong> to be true.  But I've held pretty strongly to my general terminology:</p>
<blockquote>
<p>"There is no such thing as an 'unset value'.  But <em>variables</em> can be considered unset...when they hold a value that is an isotopic void."</p>
</blockquote>
<p>I'm pleased with this and have <em>almost</em> no complaints.</p>
<p>The problem is that ISOTOPIC-VOID is a mouthful.  It needed a short name.</p>
<h2>
<a name="javascript-dont-care-1" class="anchor" href="https://forum.rebol.info#javascript-dont-care-1"></a>JavaScript Don't Care</h2>
<p>JavaScript went with the idea that unset variables hold "undefined", and you can test for it using the typeof operator to subvert the error that is raised on access for variables that are never declared (what we might think of as unbound):</p>
<pre><code>&gt;&gt; typeof asdf == 'undefined'
&lt;- true
</code></pre>
<p>But if you define a variable, then it will retrieve the undefined state without error:</p>
<pre><code>&gt;&gt; let jkl
&lt;- undefined

&gt;&gt; jkl
&lt;- undefined
</code></pre>
<p>Whatever.  Point is, they don't have any crisis of conscience on whether "variables are undefined, not values".  They just go with it, as historical Redbol did with UNSET!.</p>
<p>But I don't like it.</p>
<h2>
<a name="trash-came-to-seem-the-best-option-2" class="anchor" href="https://forum.rebol.info#trash-came-to-seem-the-best-option-2"></a>TRASH Came To Seem The Best Option</h2>
<p>"trash" isn't a new idea--<a href="https://forum.rebol.info/t/the-naming-of-null-vs-the-meaningless-value/1427/2">I suggested it way back when the unset state was being changed away from being called VOID</a>.</p>
<p>Inside the codebase I use the term "trash" to mean corrupting memory, e.g. setting pointers to 0xDECAFBAD so they'll generate errors if accessed in the debug build.</p>
<p>The concept of putting "trash" in a variable to disrupt accesses to it is kind of similar.</p>
<pre><code>&gt;&gt; var: ~
== ~  ; isotope

&gt;&gt; var
** Error: var is ~ isotope
</code></pre>
<p><em>"Unset variables hold trash"</em> comes across cohesively.</p>
<p>The more I thought about it, the more I liked it... because it kind of takes things a "notch up" from null.  What's more ornery than a null?  Something that's actually "garbage".  In this way the pejorative sound of trash is actually kind of consistent with "hey, you can't reference that variable from a word because it's trash".</p>
<p>The initial roadblock I had was how jarring it might seem to people reading source for something that returns trash...which is the default prescribed return value when you don't have any specific idea:</p>
<pre><code>foo: func [
    return: [trash?]  ; weird!
    bar [block!]
][
    append bar [a b c]
    return trash  ; also... weird!
]
</code></pre>
<p>But there's a reasonable answer in the modern type checking world for these cases which is semiotically consistent... use a tilde.  The type spec accepts it (and assumes you mean an isotope), and RETURN will accept it (where the evaluator will turn the quasiform into an isotope):</p>
<pre><code>foo: func [
    return: [~]
    bar [block!]
][
    append bar [a b c]
    return ~
]
</code></pre>
<p>As it happens, the default return result from functions is trash.  I've also proposed it might be good to make the assumption that a function without a RETURN: spec is a procedure with no return result (as opposed to an unconstrained result).</p>
<pre><code>foo: func [
    bar [block!]
][
    append bar [a b c]
]
</code></pre>
<p>You can still say <strong><code>return ~</code></strong> or <strong><code>return trash</code></strong> if you want in such functions if you want to return early.</p>
<h2>
<a name="in-short-its-a-weird-name-but-we-dont-have-to-use-it-often-3" class="anchor" href="https://forum.rebol.info#in-short-its-a-weird-name-but-we-dont-have-to-use-it-often-3"></a>In Short: It's A Weird Name, But We Don't Have To Use It Often</h2>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/why-trash-is-the-name-for-unset-state/2078">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/why-trash-is-the-name-for-unset-state/2078</link>
          <pubDate>Tue, 12 Dec 2023 15:38:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2078</guid>
          <source url="https://forum.rebol.info/t/why-trash-is-the-name-for-unset-state/2078.rss">Why &quot;TRASH&quot; Is The Name For &quot;Unset State&quot;</source>
        </item>
        <item>
          <title>Should ANY-VALUE! Include Isotopes?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>So if you don't put any type restrictions on a parameter, it will allow isotopes:</p>
<pre><code> &gt;&gt; foo: func [x] [probe x]

&gt;&gt; foo null
~null~  ; isotope
</code></pre>
<p>And right now, that is a synonym for ANY-VALUE!.</p>
<pre><code> &gt;&gt; foo: func [x [any-value!]] [probe x]

&gt;&gt; foo null
~null~  ; isotope
</code></pre>
<p><strong>But what if you want to exclude isotopes?</strong>  We could have a name for the typeset excluding isotopes (perhaps ANY-CELL!).  Or we could say that ANY-VALUE! doesn't include isotopes by default, and so you have to write <strong>[any-value! isotope!]</strong> if you want them... or just include the specific ones you intend (like <strong>[null! any-value!]</strong>.</p>
<p>Right now I'm going the route of saying ANY-CELL! is the narrower set of values that do not include isotopes.  Is there a better term for saying something can be put into an array vs. not?</p>
<p><em>"10 is an integer! which is legal to use as a cell, while ~null~ isotopes are not legal as cells, but can be variable values"</em></p>
<p>It seems shorter and cleaner than ANY-REIFIED!  or something like that.  I don't know any better options.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-any-value-include-isotopes/2026">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-any-value-include-isotopes/2026</link>
          <pubDate>Fri, 14 Apr 2023 21:37:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2026</guid>
          <source url="https://forum.rebol.info/t/should-any-value-include-isotopes/2026.rss">Should ANY-VALUE! Include Isotopes?</source>
        </item>
        <item>
          <title>TRY... *again* :roll_eyes:</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>I have proposed a concept for TRY as trapping definitional errors and turning them into nulls, like this:</p>
<pre><code>&gt;&gt; take []
** Error: you can't take from an empty block (stopping further code)

&gt;&gt; try take []
== ~null~  ; isotope
</code></pre>
<p>And I'll just give a reminder that as this is trapping <a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852">definitional errors</a>.  So failures from deeper inside code would not be caught... only errors that are returned by contract from the function being called.</p>
<pre><code>&gt;&gt; try compose [(1 / 0)]
** Error: division by zero (e.g. COMPOSE itself didn't raise the error)
</code></pre>
<p><em>I'll remind everyone that it's a very slippery slope to trap "deep errors", and this is why the deep error trapping concept is <a href="https://forum.rebol.info/t/discouraging-use-of-trap/1871/3">hidden away as <code>sys.util.rescue</code></a>)</em></p>
<h2>Why Return NULL From TRY (vs. void) ?</h2>
<p>The decision to return null is to make the result falsey so it can be acted on:</p>
<pre><code>while [item: try take block] [
    ...
]

all [
    try take block  ; if this fails we don't want to keep going
    ...
]
</code></pre>
<p>In the vernacular I use, I call NULL "soft failure".  So TRY "converts a definitional failure into soft failure", passing through all other results as-is.</p>
<h2>Comparison with similar word MAYBE</h2>
<p>The MAYBE operation was defined as something that converts nulls to voids, and passes through everything else.  If you didn't know that, it's easy to see not intuiting what the difference between <strong>try take block</strong> and <strong>maybe take block</strong> would be.</p>
<p>You can get some odd-looking combinations with this, e.g.</p>
<pre><code> &gt;&gt; block1: [a b c]
 &gt;&gt; block2: []

 &gt;&gt; append block1 maybe try take block2
 == [a b c]
</code></pre>
<p>Which makes one wonder if MAYBE could be used to trap definitional errors as well as nulls and turn them into voids, so you could just write <strong>append block1 maybe take block2</strong>.</p>
<p>So it raises the question: are there null-returning operations that also return definitional errors, where one would want to suppress the null but not the error?  There's not enough experience for me to say yet.</p>
<h2>Usage in PARSE as opposed to OPT?</h2>
<p>I've wondered if TRY and MAYBE could have parallel meanings in PARSE, where you use TRY to continue but get NULL and MAYBE to skip things:</p>
<pre><code>&gt;&gt; parse "aaa" [some "a" maybe some "b"]
== "a"

&gt;&gt; parse "aaa" [some "a" var: try some "b"]
; first in pack of length 1
== ~null~  ; isotope

&gt;&gt; var
== ~null~  ; isotope
</code></pre>
<p>Seeing the two operations as being very similar--only one voids while the other one nulls--feels interesting.  I just hadn't thought of MAYBE as a definitional-error-suppressor before.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/try-again/2025">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/try-again/2025</link>
          <pubDate>Fri, 14 Apr 2023 21:22:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2025</guid>
          <source url="https://forum.rebol.info/t/try-again/2025.rss">TRY... *again* :roll_eyes:</source>
        </item>
        <item>
          <title>&quot;Quasiforms&quot;, &quot;Stable/Unstable Isotopes&quot;: Simpler Terminology?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>It's no secret that I'm proud of the way the <a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">design for generalized isotopes</a> is tearing through classic problems in Rebol.</p>
<p>At the same time, people's eyes can glaze over when you find yourself writing sentences like:</p>
<blockquote>
<p><em>"All quasiforms become isotopic forms when evaluated, and when going the other way through a meta operation on an isotope, you'll get a quasiform back."</em></p>
</blockquote>
<p>It all makes sense to me.  But I don't want to overlook better terms, if they exist.</p>
<h2>How Did "Isotopes" Come To Be Called That?</h2>
<p>The term isotope originated from the "decaying" behavior, where a special form of null would run a THEN branch.  But this special form would not be something you could store in a variable...it would become an ordinary null at that point.  So getting stored in a variable would cause "decay".</p>
<pre><code>&gt;&gt; null
; null

&gt;&gt; if true [null]
; null isotope

&gt;&gt; x: if true [null]
; null isotope

&gt;&gt; x
; null
</code></pre>
<p>The decay means variables captured from expressions would have a different behavior when substituted for the expressions.  That was deemed to be an acceptable cost.</p>
<pre><code>&gt;&gt; if true [print "then", null] else [print "else"]
then

&gt;&gt; temp: if true [print "then", null]
then

&gt;&gt; temp else [print "else"]
else
</code></pre>
<p>The parallel with decay of atomic isotopes seemed pretty clear, at least to me.  Many places would see it as a normal null, but a few special sites could use a "sensor" to detect the difference.  ELSE was an example of something that could detect.</p>
<p>As things moved forward, and when logic variables became ~true~ and ~false~ isotopes, it became clear these isotopic states would need to be able to stored in variables.  That meant there were "unstable isotopes" and "stable isotopes"... e.g. WORD! isotopes were stable, ERROR! isotopes were not.</p>
<p><em><strong>Having these stable isotopes actually strengthened the analogy.</strong></em>  Because some atomic isotopes are stable, while others are not.</p>
<h2>How Did "QUASI" Become Called That?</h2>
<p>Originally, things like <code>~foo~</code> were called "bad words", designed to cause errors when accessed through a variable by default.  They were like an old-school UNSET! where you could give it a custom label.  But eventually everything was generalized so that everything had an isotopic form.</p>
<p>The fact that these forms stopped conveying an error condition meant considering them "bad" wasn't sensible.  I kind of latched onto "quasi" in part because of the tilde's use in approximation, e.g. (3.0001 ~= 3).</p>
<p>(It also sounds a little like "queasy" and the squigglies look wavy and maybe a bit uncomfortable.  <img src="https://forum.rebol.info/images/emoji/twitter/nauseated_face.png?v=9" title=":nauseated_face:" class="emoji" alt=":nauseated_face:">)</p>
<h2>So... Speak Now Or Hold Your Peace?</h2>
<p>Bad naming can have an impact.  I think calling complex numbers "imaginary" is a good example of a bad name that probably caused a few problems.</p>
<p>But I think the names here are good.  It's just going to be a matter of figuring out how to teach people to not be afraid of them.</p>
            <p><small>10 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/quasiforms-stable-unstable-isotopes-simpler-terminology/2005">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/quasiforms-stable-unstable-isotopes-simpler-terminology/2005</link>
          <pubDate>Sun, 08 Jan 2023 21:18:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2005</guid>
          <source url="https://forum.rebol.info/t/quasiforms-stable-unstable-isotopes-simpler-terminology/2005.rss">&quot;Quasiforms&quot;, &quot;Stable/Unstable Isotopes&quot;: Simpler Terminology?</source>
        </item>
        <item>
          <title>REIFY vs. META vs. SOMETHING</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>Originally I suggested that REIFY of an isotope would give its plain form, and you would META it if you wanted a quasiform:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1989">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989/1">~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</a>
</div>
<blockquote>
<ul>
<li>The generic and reversible way to make them real it is to META them and get <code>~true~</code> and <code>~false~</code> quasiforms, which you can UNMETA back to the isotopes</li>
<li>The readable way to make them real is to REIFY them and get <code>true</code> and <code>false</code> as plain WORD!, which only gets turned back into the isotope form if they are bound to variables that hold the isotopes, and you evaluate them.</li>
</ul>
</blockquote>
</aside>
<p><em>But that's not a full coverage answer.</em></p>
<ul>
<li>
<p>An operator that takes everything "one level up", where isotopes become quasiforms and everything else gets a quote level added.</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; meta true
== ~true~

&gt;&gt; meta 10
== '10
</code></pre>
</li>
<li>
<p>An operator that leaves non-isotopes as they are, but turns isotopes into their quasiforms (and I think this probably is best called REIFY):</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; reify true
== ~true~

&gt;&gt; reify 10
== 10
</code></pre>
</li>
<li>
<p>An operator that leaves non-isotopes as they are, but turns isotopes into their plain forms:</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; something true
== true

&gt;&gt; something 10
== 10
</code></pre>
</li>
</ul>
<p>Specifically for ACTION! isotopes being turned into plain actions, I used an interim term UNRUN, but that's pretty awful.</p>
<p>Making things into isotopes is done with ISOTOPIC:</p>
<pre><code>&gt;&gt; isotopic 10
== ~10~  ; isotope
</code></pre>
<p>It could be a refinement to REIFY, like REIFY/PLAIN.  But at that point it could be two steps that might be clearer: NOQUASI REIFY, where NOQUASI would be like NOQUOTE and not complain if the thing you passed it was not a quasiform.</p>
<p>Maybe... CONCRETIZE?  That sounds like it might do a bit more work than what REIFY does :-/</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; concretize true
== true

&gt;&gt; concretize 10
== 10
</code></pre>
<p>It's not awful.  Main thing is just to have <em>a</em> name for it while the gears turn.  But as usual, throw out suggestions if you have them...</p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/reify-vs-meta-vs-something/2001">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/reify-vs-meta-vs-something/2001</link>
          <pubDate>Thu, 05 Jan 2023 21:26:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2001</guid>
          <source url="https://forum.rebol.info/t/reify-vs-meta-vs-something/2001.rss">REIFY vs. META vs. SOMETHING</source>
        </item>
        <item>
          <title>~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>The concept of having isotopic <strong>~true~</strong> and <strong>~false~</strong> as WORD! isotopes instead of having a distinct LOGIC! type was admittedly somewhat weird.  It meant they couldn't be put in blocks and need some sort of transformation if they're going to be put into blocks.</p>
<ul>
<li>
<p>The generic and reversible way to make them real it is to META them and get <code>~true~</code> and <code>~false~</code> quasiforms, which you can UNMETA back to the isotopes</p>
</li>
<li>
<p>The readable way to make them real is to REIFY them and get <code>true</code> and <code>false</code> as plain WORD!, which only gets turned back into the isotope form if they are bound to variables that hold the isotopes, and you evaluate them.</p>
</li>
<li>
<p>Your circumstance may mean that neither of those choices are what you want when in a situation where the isotopes can't work...maybe it means you have to rethink what you're doing, or maybe you want some other transformation.  It's good to be alerted to the fact that it's dodgy to put what you think of as a "logic" in a reified context.</p>
</li>
</ul>
<p>One should note that Lisp has no false at all, only NIL for false (since everything else is truthy, you could use anything else for true, but they have T predefined).  But their NIL isn't isotopic--so it can appear in lists literally.</p>
<p>And as I've repeatedly pointed out, Redbol's historical choice to render LOGIC! conflated with the words <code>true</code> and <code>false</code> (instead of <code>#[true]</code> and <code>#[false]</code>) shows a desire to avoid the logic literals "escaping" into the reified consciousness of the user.  Making the logic forms actually impossible to put into blocks without a conscious transformation feels like it's good.</p>
<p>I know it's a strange choice, but it's seeming like it fits with the territory.  It's a sort of tradeoff you need when you choose to be firm that TRUE and FALSE are redefinable words and not lexical forms of logic constants.</p>
<h2>
<a name="null-was-once-_-isotope-but-now-null-isotope-1" class="anchor" href="https://forum.rebol.info#null-was-once-_-isotope-but-now-null-isotope-1"></a>NULL Was Once ~_~ Isotope, But Now <code>~null~</code> isotope</h2>
<p>Once upon a time I called isotopic BLANK! null.  It was not pretty looking:</p>
<pre><code>&gt;&gt; null
== ~_~  ; isotope

&gt;&gt; _
== ~_~  ; isotope
</code></pre>
<p>It was because I made BLANK! evaluate to its isotope.  This meant if you assign a bunch of variables to null, it gave a pretty visibility to the actual values to pay attention to:</p>
<pre><code>obj: make object! [
    alpha: _
    beta: _
    delta: true
    epsilon: ~
    gamma: "nutty"
    rho: _
    omega: 'now
 ]
</code></pre>
<p>I was reticent about using the word isotope ~null~, because at source level we're writing:</p>
<pre><code>obj: make object! [
    alpha: null
    beta: null
    delta: true
    epsilon: ~
    gamma: "nutty"
    rho: null
    omega: 'now
 ]
</code></pre>
<p>And if we view it after evaluation that fetches (<code>null</code> =&gt; <code>~null~  ; isotope</code>), it <em>seemed</em> uglier:</p>
<pre><code>make object! [
    alpha: ~null~
    beta: ~null~
    delta: ~true~
    epsilon: ~
    gamma: "nutty"
    rho: ~null~
    omega: 'now
 ]
</code></pre>
<p>We can't show it as the WORD! null because there's no guarantee that word always will evaluate back to the null isotope.  But the concept was that since BLANK! can't be redefined, we can put it in an evaluative context as a substitute for <code>~_~</code> if we want.</p>
<p>If we were "more honest" and just META'd the isotopic blank, we'd get renders like:</p>
<pre><code>make object! [
    alpha: ~_~
    beta: ~_~
    delta: ~true~
    epsilon: ~
    gamma: "nutty"
    rho: ~_~
    omega: 'now
 ]
</code></pre>
<p>Which I actually liked that less than seeing <strong><code>~null~</code></strong> there.</p>
<h2>
<a name="i-was-torn-but-chose-the-word-isotope-null-2" class="anchor" href="https://forum.rebol.info#i-was-torn-but-chose-the-word-isotope-null-2"></a>I was torn, but Chose The WORD! Isotope ~null~</h2>
<p>Certainly having people be able to see ~null~ written out as a word corresponds to what we want to refer to the state as.  We aren't going to replace people's vernacular to say "isotopic blank" instead of null.  And trying to teach people "isotopic blank is null" is an uphill battle.</p>
<p>Let's look back at that seemingly beautiful situation with all the blanks-to-nulls at source level:</p>
<pre><code>obj: make object! [
    alpha: _
    beta: _
    delta: true
    epsilon: ~
    gamma: "nutty"
    rho: _
    omega: 'now
 ]
</code></pre>
<p>The <strong><code>~</code></strong> is now an assignable state meaning variable is not set.  How often will you want to set something to NULL...which won't generate an error on access like being unset would, but is falsey and can't be passed to many routines without a MAYBE?</p>
<p><strong>Statistically, we might often have a situation where NULL is the minority initialization, more like this:</strong></p>
<pre><code>obj: make object! [
    alpha: ~
    beta: ~
    delta: true
    epsilon: null
    gamma: "nutty"
    rho: ~
    omega: 'now
 ]
</code></pre>
<p>My point is that intentionally initializing things to null may not be as common as setting to an error-provoking unset state.  And when null happens it may be just as noteworthy to call out as setting something to true or false.</p>
<p><strong>My general intuition was that from a user's standpoint, it's an uphill battle to teach them isotopic blank is something called "null"... and that the majority of technical problems that are involved in making NULL be a word isotope are problems that have to be tackled anyway with true and false as word isotopes.</strong></p>
<p>Additionally, I've written about my desire for BLANK!s to serve in dialects as spaces.  That gets very screwed by the (<strong><code>_</code></strong> =&gt; <strong><code>~_~</code>  ; isotope</strong>) evaluation.  Recovering blank for space intent and having them be unevaluated was good</p>
<h2>
<a name="some-technical-difficulties-of-null-3" class="anchor" href="https://forum.rebol.info#some-technical-difficulties-of-null-3"></a>Some Technical Difficulties of ~null~</h2>
<p>It had some of the same problems as having to deal with the type checking of LOGIC! actually being an isotopic subclass of two words.  It means <code>&lt;opt&gt;</code> is an isotopic subclass of one word, so there's no specific null datatype.</p>
<p>Previously NULL cells held nothing, so I'd put a payload of the file and line that were in effect in the evaluator.  This was supposed to give better errors about where a null originated from.  This could still be done if NULL was a special case of WORD! isotope that said it was null via a flag vs. storing the symbol, but could be complicated.  None of the better error mechanics were done yet.</p>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989</link>
          <pubDate>Tue, 25 Oct 2022 04:07:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1989</guid>
          <source url="https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989.rss">~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</source>
        </item>
        <item>
          <title>CLOCK as a Noun</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>Boris made a timing function called "CLOCK", as a sort of replacement for DELTA-TIME:</p>
<p><a href="https://github.com/red/red/blob/81ff4d605df371dfc430b92611605e80f5e5780b/environment/functions.red#L1126">https://github.com/red/red/blob/81ff4d605df371dfc430b92611605e80f5e5780b/environment/functions.red#L1126</a></p>
<pre><code>clock: function [
    "Display execution time of code, returning result of it's evaluation"
    code [block!]
    /times n [integer! float!]  ; float for e.g. `1e6` instead of `1'000'000`
        "Repeat N times (default: once); displayed time is per iteration"
    /delta "Don't print the result, return time delta per iteration (in msec)"
 ]
</code></pre>
<p>It builds in iteration...which is useful for timing, since you often want to loop over things they time.  And at least in theory it should be in the native timing construct--you'd prefer not to have an interpreted call to REPEAT being part of what you count in your time.</p>
<p>(Perhaps the repeat count should just be a required first argument--since CLOCK 1 is so easy to type, why make people fuss over CLOCK/TIMES and then putting the number of times all the way at the end somewhere?)</p>
<h2>
<a name="but-i-think-clock-should-be-a-noun-1" class="anchor" href="https://forum.rebol.info#but-i-think-clock-should-be-a-noun-1"></a><em>But...</em> I Think CLOCK should be a Noun</h2>
<p><strong>clock.time</strong> and <strong>clock.date</strong> have many advantages over <strong>now/time</strong> and <strong>now/date</strong>.</p>
<p>It implies that you could pass a clock around or copy it...which is a good thing.  So by default the CLOCK could be UTC (for programming convenience).  But you could copy that clock and set your module's meaning of the word CLOCK to speak in terms of local time.</p>
<p>Also it resolves a big annoyance of mine: NOW being a function that has a lot of conflicting refinements.  If CLOCK were an object, then <strong>.time</strong> and <strong>.date</strong> would be separate methods of that object, so you couldn't say things like <code>clock.time.date</code>.</p>
<p>And then you could capture the current time into a variable as <strong><code>now: clock.time</code></strong> which makes more sense to me than saying "now" is itself a verb.  <em>(It then wouldn't stay current as "now" in the sense of "exactly this moment", but in language we're pretty comfortable saying "things are different now than they were in the '80s"...e.g. there can be a prolonged linguistic notion of now.  I prefer to use it in this sense.)</em></p>
<p>As far as functional programming goes: because code doesn't have an intrinsic notion of time, you can show that a piece of code is dependent on a clock by passing one as a parameter.</p>
<p>This would allow you also to have code run simulating at a different time.  You could see how a piece of code would perform if it thought it were running at some pathological date, while working alongside other code that was operating with the current notion of time--e.g. to communicate with some webservers to upload results from a test of something like a Y2K problem simulated by other code.</p>
<h2>
<a name="what-to-call-the-timing-construct-2" class="anchor" href="https://forum.rebol.info#what-to-call-the-timing-construct-2"></a>What to Call The Timing Construct?</h2>
<p>To think in terms of super-powers, then you need...<em>a dialect</em> !</p>
<p>Perhaps it could be called "CHRONO"?</p>
<p>Maybe CHRONO quotes its argument, and if you give it a GROUP!, it thinks of that as something to time and run just once.</p>
<pre><code>&gt;&gt; chrono (my-function 1 2 3)
0.14 μs
== &lt;result&gt;
</code></pre>
<p>But if you pass a BLOCK! it could permit more options, like saying what you wanted the timing in terms of:</p>
<pre><code>chrono [msec (my-function 1 2 3)]
chrono [usec (my-function 1 2 3)]
</code></pre>
<p>Or the repeat count (being a parameter to chrono means you're not timing a REPEAT inside your code, ideally).</p>
<pre><code>&gt;&gt; chrono [1e7 (1 + 2)]
0.14 μs    [1 + 2]
== 3
</code></pre>
<p>I'm busy with other things and so I'm not going to go research all the possible features you might want from a timing dialect--I'm sure there's plenty of prior art in the domain.  Just wanted to get it started.  Use your imagination.  <img src="https://forum.rebol.info/images/emoji/twitter/unicorn.png?v=12" title=":unicorn:" class="emoji" alt=":unicorn:" loading="lazy" width="20" height="20"></p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/clock-as-a-noun/1956">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/clock-as-a-noun/1956</link>
          <pubDate>Sat, 03 Sep 2022 06:47:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1956</guid>
          <source url="https://forum.rebol.info/t/clock-as-a-noun/1956.rss">CLOCK as a Noun</source>
        </item>
        <item>
          <title>Should THROW and CATCH Be For Errors?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>The historical Rebolism of THROW and CATCH has nothing to do with error handling.</p>
<p>It's a generic way to move values up the stack.  It gives you a handy "out" from control flow:</p>
<pre><code>result: catch [
    if condition [throw result]
    some code
    case [
        condition [more code]
        condition [more code, throw result]
    ]
    additional code
    throw result
]
</code></pre>
<p>The implementation of the feature is lightweight, and built on the same mechanic as RETURN.  You could in fact use return to do this:</p>
<pre><code>result: do func [] [
    if condition [return result]
    some code
    case [
        condition [return code]
        condition [more code, return result]
    ]
    additional code
    return result
]
</code></pre>
<p>But that's more heavyweight, because it gets binding involved (although I've suggested that maybe CATCH and THROW should be definitional, and the "heaviness" is a feature... not a bug).</p>
<h2>It's A Neat Feature, But I Want THROW and CATCH For Errors</h2>
<p>Error handling is undergoing a renaissance in Ren-C, and it's becoming completely pervasive.</p>
<p>Despite its glory, it is currently tied in with the junky names RAISE and EXCEPT.</p>
<pre><code>case [
   ...code that may fail...
] then [
   ...stuff to do if non-NULL, non-VOID, non-RAISED error!...
] else [
   ... stuff to do if NULL or VOID or RAISED error!...
] except e -&gt; [
  ... error handling ...
]
</code></pre>
<p>The word EXCEPT is bad for several reasons:</p>
<ul>
<li>
<p>It implies "exception" handling, <em>which definitional errors are specifically not</em>...they can only be caught one stack step at a time.</p>
<ul>
<li>Arbitrary exception handling is taboo for very good reasons...and I've made it more taboo by <a href="https://forum.rebol.info/t/discouraging-use-of-trap/1871/3">moving that behavior to SYS.UTIL.RESCUE</a>
</li>
</ul>
</li>
<li>
<p>It's not really a "verb"</p>
</li>
<li>
<p>It often comes right after an ELSE, and I don't like the alliteration of E and E</p>
</li>
<li>
<p>Almost every other language uses CATCH there</p>
</li>
</ul>
<p>And RAISE isn't exactly my favorite word either.  <strong>return throw e</strong> vs. <strong>return raise e</strong> also has that alliteration issue.</p>
<h2>So What Can The Old THROW and CATCH Be Called?</h2>
<p>It's a lot less important than the error handling application, but I still use the old construct.</p>
<p>You can actually do it with CYCLE and STOP:</p>
<pre><code>result: cycle [
    if condition [throw result]
    some code
    case [
        condition [more code]
        condition [more code, stop result]
    ]
    additional code
    stop result
]
</code></pre>
<p>Being a looping construct, it has the side effect that it will keep repeating unless a value is emitted.</p>
<p>On the plus side...this helps resolve the semantic question of "what should a CATCH return when there's no THROW?"  If what you have is CYCLE then your answer is that it keeps going.  So you either put a FAIL at the bottom, a STOP at the bottom, or accept it will keep going.</p>
<p>On the minus side...if you use this inside a looping construct you'll be redefining BREAK, which historical CATCH would not do.  (Similarly, if you use FUNC and RETURN to do this you'd redefine RETURN.)</p>
<p>With definitional BREAK and RETURN there'd be workarounds for those cases--you'd simply give another name to the outer break and return if you needed them.  But that's not how things work today.</p>
<h2>While CYCLE is Not Perfect, It Would Work For The Moment</h2>
<p>We can meditate on what the ultimate answer would be.  But there's only a few cases, and CYCLE will do.</p>
<p>Errors need THROW and CATCH...they're now too fundamental to not use the good words for.</p>
<p>We now have the word TRAP for those who don't want to use enfix, so these are equivalent:</p>
<pre><code>if e: trap [some code] [
    handle e
]

(some code) catch e -&gt; [
   handle e
]
</code></pre>
<p>But you get some real benefits from the THEN + ELSE + CATCH, and I think the importance of these enfix constructs will become apparent to those who aren't on the bandwagon (yet).</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-throw-and-catch-be-for-errors/1954">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-throw-and-catch-be-for-errors/1954</link>
          <pubDate>Thu, 01 Sep 2022 11:50:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1954</guid>
          <source url="https://forum.rebol.info/t/should-throw-and-catch-be-for-errors/1954.rss">Should THROW and CATCH Be For Errors?</source>
        </item>
        <item>
          <title>JUST For Sale - Low Mileage, Original Owner, Like New</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>As the /ONLY debacle was chipped away at... slowly... the role of quoting came to the forefront.  Quotes were used to <em>suppress</em> splicing (in contrast with today's isotopic blocks through SPREAD, which <em>request</em> the splicing).</p>
<p>So the anti-spread behavior looked something like:</p>
<pre><code>&gt;&gt; append [a b c] first [[d e]]
== [a b c d e]

&gt;&gt; append [a b c] first ['[d e]]
== [a b c [d e]]
</code></pre>
<p>I'm picking out of an outer block there just to avoid confusion, because notice what happens when there's no container:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c d e]

&gt;&gt; append [a b c] '[d e]
== [a b c d e]
</code></pre>
<p>By design, the evaluator strips off quotes, leading to potential confusion when it comes to what people might think they could do with such a system.</p>
<p>You might think that this is all fine and you could just call the function QUOTE instead of putting a quote mark on the value.  Hence the quoted block is an evaluation <em>product</em> not an evaluation <em>input</em>...and so it makes it to the append:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c d e]

&gt;&gt; append [a b c] quote [d e]
== [a b c [d e]]
</code></pre>
<p>But there were protections that were added to try and discern if you were adding non-inert values without quoting them.</p>
<pre><code>&gt;&gt; append [a b c] "this was presumed okay since it was inert"
== [a b c "this was presumed okay since it was inert"]

&gt;&gt; append [a b c] 'd
** Error: d is a WORD! and evaluative...your callsite might accidentally lose an
    apostrophe if you didn't know what you were doing.  Quote it to be safe.
</code></pre>
<p><em>(Note: I always disliked how these errors were working, I just hadn't gotten to the isotope design yet.  They did afford some protection.)</em></p>
<p>This would lead you to a couple of bad options to work with the case when you had something evalutative at source level:</p>
<pre><code>&gt;&gt; append [a b c] quote 'd
== [a b c d]

&gt;&gt; append [a b c] ''d
== [a b c d]
</code></pre>
<p>In an attempt to make the "just add a thing at source level" case a slight bit easier, I made JUST.</p>
<pre><code>&gt;&gt; just d
== 'd

&gt;&gt; append [a b c] just d
== [a b c d]
</code></pre>
<h3>Let's Take A Moment To Be Thankful For Isotopes...</h3>
<p>All of this is behind us now.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/pray.png?v=9" title=":pray:" class="emoji only-emoji" alt=":pray:"></p>
<p>But of course, the mechanics are actually nearly identical.  Just subtract 1 from all the quoting levels, and allow -1 for BLOCK!s.  <em>(Then build upon years of diligence in bulletproofing the system from leaking -1 quotelevels where they shouldn't be.)</em></p>
<h2>But JUST is Free Again.  Now What?</h2>
<p>There was a time when JUST was what I now call THE.</p>
<pre><code>&gt;&gt; just x
== x

&gt;&gt; just ''[foo]
== ''[foo]
</code></pre>
<p>I thought it was a good word for it at the time.  But THE won me over:</p>
<pre><code>&gt;&gt; the x
== x

&gt;&gt; the ''[foo]
== ''[foo]
</code></pre>
<h3>Maybe Something That Limits to One Expression Only?</h3>
<pre><code>&gt;&gt; just add 1 2
== 3

&gt;&gt; just add 1 2 10
** FAIL: JUST code had residual material: 10
</code></pre>
<p>I've been wanting a syntax for this at the API level, when you think you're running one expression:</p>
<pre><code>REBVAL* sum = rebJust("add", value1, value2, "10");
</code></pre>
<p>In that world, it's not any more typing (actually less typing than rebValue)...but gives you an extra bit of safety.</p>
<p>With regular (non-API) code, I can see it being very useful in generated code scenarios.</p>
<h3>Perhaps A THE-like Operator With A Shade of Meaning In PARSE?</h3>
<p>PARSE needs to keep raw material sometimes, and I've pointed out some of the hazards in the past of making you do this with GROUP!s when nested compositions are involved.</p>
<p>So might these be different?  As an example:</p>
<pre><code>parse ... [x: the ''foo] =&gt; parse ... [x: (the ''foo)]

parse ... [x: just ''foo] =&gt; parse ... [x: '''foo]
</code></pre>
<p>So above, THE is synthesizing ''foo out of whole cloth with no need to match it in the input.  The other would require a ''foo in the input to be considered a match.</p>
<p>For WORD!s, the above sense of JUST isn't as necessary, as there's a decent visual trick:</p>
<pre><code>parse ... [x: just ''foo] =&gt; parse ... [x: '|''foo|]
</code></pre>
<p>But other datatypes would not have this out, and you'd always be reading the thing you see in the rule as having one more quote level than what you're matching.</p>
<p>There's the option of putting it in an @ group:</p>
<pre><code>parse ... [x: just ''foo] =&gt; parse ... [x: @(the ''foo)]
</code></pre>
<p>But this has the problems I mention about nested composition that can be a major hassle when writing rule genreators and you have to weasel something like <strong><code>''foo</code></strong> inside a group inside a composed block.</p>
<p>This definition might jibe with keeping the regular evaluator meaning of JUST as it is (literal but add a quoting level).</p>
<h3>Other Ideas?</h3>
<p>Hopefully no one wants to fight to swap JUST with THE, because I really like THE as it is.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/just-for-sale-low-mileage-original-owner-like-new/1923">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/just-for-sale-low-mileage-original-owner-like-new/1923</link>
          <pubDate>Fri, 19 Aug 2022 03:09:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1923</guid>
          <source url="https://forum.rebol.info/t/just-for-sale-low-mileage-original-owner-like-new/1923.rss">JUST For Sale - Low Mileage, Original Owner, Like New</source>
        </item>
        <item>
          <title>&quot;I&#39;m not BAD!...I&#39;m just MOLD-ed that way...&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>I'm tinkering with an implementation of <a href="https://forum.rebol.info/t/should-everything-have-an-isotopic-form/1889/5">fully generic isotopes</a>.  The idea is that all types have an isotopic form, and routines can choose to react to this isotopic form giving it special meaning.</p>
<p>This means the tilde markings which used to designate a BAD-WORD! would be ways of making any value isotopic:</p>
<pre><code>&gt;&gt; ~foo~
== foo  ; isotope

&gt;&gt; ~[d e]~
== [d e]  ; isotope

&gt;&gt; ~1020~
== 1020  ; isotope

&gt;&gt; ~#[datatype word!]~
== #[datatype word!]  ; isotope
</code></pre>
<p>The notation is not an isotope itself, it's just used to produce them.  And if you're looking in an object and see it molds out fields that are these and non-quoted, that implies that the field itself actually holds an isotope.</p>
<pre><code>&gt;&gt; obj: make object! [x: spread [d e], y: ~[d e]~, z: '~[d e]~]
== make object! [
    x: ~[d e]~
    y: ~[d e]~
    z: '~[d e]~
]

&gt;&gt; obj.x
** Error: obj.x is a BLOCK! isotope, use ^META to access

&gt;&gt; obj.y
** Error: obj.y is a BLOCK! isotope, use ^META to access

&gt;&gt; obj.z
== ~[d e]~
</code></pre>
<p>So you can see how the notation works with the generic form, and can be quoted itself.</p>
<h2>I Kind Of Want To Curtail Use Of These In Source...</h2>
<p>The original thought about BAD-WORD! was that their ugly notation was supposed to be used to draw attention to them.  So like in the object molding above, you'd be able to see where the isotopes were and it would guide your eyes to the problem.</p>
<p><em>And in fact, I'm not even 100% sure that we want to support storing isotopes in variables unless we absolutely have to.</em>  Perhaps isotopic blocks would generate errors if you tried--and it would force you to use a ^META operation to persist it.  But a representation that evaluates to them is needed for mechanical reasons either way.</p>
<p>Nevertheless, you <em>could</em> use them to do things like splicing literal blocks:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c [d e]]

&gt;&gt; append [a b c] ~[d e]~
== [a b c d e]
</code></pre>
<p>It would actually be an efficient way to do it, but I feel like it might numb people to the squiggles...which are intended to draw attention to cases where the isotopes leaked through an operation and shouldn't have.  So best practices would suggest using operators instead</p>
<pre><code>&gt;&gt; append [a b c] spread [d e]
== [a b c d e]
</code></pre>
<h2>But The ~XXX~ Forms Need A Name... Is It BAD! ?</h2>
<p>I'd called ~xxx~ a BAD-WORD!.  Now that the tildes are a generic container kind of like QUOTED!, that would default to just being... BAD!</p>
<pre><code>&gt;&gt; type of fourth [a b c ~[d e]~]
== #[datatype! bad!]
</code></pre>
<p>So there's going to be a whole naming situation for operations to get the contained item out, and what to call this container.</p>
<p><em>(If it's so BAD, does it need to be... REFORMed?  <img src="https://forum.rebol.info/images/emoji/twitter/stuck_out_tongue.png?v=9" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"> )</em></p>
<p>I don't know how to fit this into the isotope naming scheme...it's a thing that generates isotopes when it evaluates.  The analogy breaks down if you try to call it a NUCLEUS or something odd like that.</p>
<p>Calling the ~xxx~ forms BAD! does have the advantage of being able to combine that and say ~[d e]~ is a "bad block" and ~1020~ is a "bad integer", but... you'll see these in well-formed programs.  It makes it sound like something is <em>corrupt</em>, when the real intent is different.</p>
<p>It could be called QUASI! which could related it to QUOTED!.  <em>"~[d e]~ is a quasi-block"</em></p>
<p>Bear in mind they can be quoted, so <code>'~[d e]~</code> would then be a "quoted quasi-block".  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>In some sense, [d e] and ~[d e]~ and '[d e] and ''[d e] could all be thought of as "isotopes" of blocks...in addition to what we call the "isotope" form (which has no representation, because it's something you can only measure by turning it into another form).</p>
<p>So we might call ~[d e]~ a "block isotope", and then give some other name to the invisible status that it produces...?</p>
<pre><code>&gt;&gt; ~[d e]~  ; call this a block isotope?
== [d e]  ; then this could be... a... ghost block?
</code></pre>
<p>But overall my leaning is that I like calling the ephemeral form "isotope", because I think that captures its weird invisible/reactivity/decaying character.</p>
<h2>The Pejorative "BAD!" May Seem Harsh, But May Be Good?</h2>
<p>If the name can scare people out of trying to use these too much at source level, that's not the worst outcome.</p>
<p>But then there still have to be ways of getting the contents out.  QUOTED! has UNQUOTE and NOQUOTE to take off quoting layers, and QUOTE to add them on.</p>
<p>Right now I've got MAKE BAD! to produce them:</p>
<pre><code>&gt;&gt; make bad! 1020
== ~1020~

&gt;&gt; make bad! [d e]
== ~[d e]~
</code></pre>
<p>If we called them something like TOXIC! then there could be detox and toxify.  <img src="https://forum.rebol.info/images/emoji/twitter/radioactive.png?v=9" title=":radioactive:" class="emoji" alt=":radioactive:"></p>
<p><strong>There's plenty to be involved with working out the mechanics and not worrying about the names, but wanted to put the naming issue out to be mulled over.</strong></p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/im-not-bad-im-just-mold-ed-that-way/1911">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/im-not-bad-im-just-mold-ed-that-way/1911</link>
          <pubDate>Fri, 05 Aug 2022 09:33:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1911</guid>
          <source url="https://forum.rebol.info/t/im-not-bad-im-just-mold-ed-that-way/1911.rss">&quot;I&#39;m not BAD!...I&#39;m just MOLD-ed that way...&quot;</source>
        </item>
        <item>
          <title>ALL [...] vs. CASE/ALL</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <blockquote>
<p><em>(Note: This is from an old post 4 years ago that was bundled with <a href="https://forum.rebol.info/t/any-vs-parses-any-can-we-have-consistency/741">complaints about PARSE's ANY</a>.  The ANY issue turned into its own whole universe of study...however, this question got brushed aside.  I'm making it it's own thread, now.)</em></p>
</blockquote>
<p>ALL is a <em>short-circuit</em> construct. The first time it sees a falsey thing, it stops.</p>
<pre><code>&gt;&gt; all [(probe 1) (probe 2 false) (probe 3)]
1
2
; null
</code></pre>
<p>But CASE/ALL is <em>explicitly not short-circuit</em>.  It takes away CASE's short-circuiting...where the /ALL makes it evaluate <em>every</em> condition.  So it will potentially run branches even after it has seen falsey conditions:</p>
<pre><code>&gt;&gt; case/all [true [probe 1] false [probe 2] true [probe 3]]
1
3
== 3
</code></pre>
<p>Ren-C chose to make CASE/ALL return <em>the evaluation of the branch associated with the last truthy condition</em>. (Rebol2 and Red just return false if the last condition was falsey.) That aside, both of them evaluate "all of the cases".</p>
<p>This also applies to SWITCH, which has an /ALL refinement as well.</p>
<p><strong>Could we have a word for something that wasn't short-circuit, yet evaluated "all" of the conditions...and just returned the last truthy one or NULL?</strong></p>
<h2>
<code>CASE/MULTI</code> ? <code>CASE/MANY</code> ?</h2>
<p>I just think that using CASE/ALL is misleading when put up against ALL, which is another native control structure...defined in the same file.  Having ALL mean something entirely opposite irks me.</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/all-vs-case-all/1874">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/all-vs-case-all/1874</link>
          <pubDate>Tue, 12 Jul 2022 04:30:55 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1874</guid>
          <source url="https://forum.rebol.info/t/all-vs-case-all/1874.rss">ALL [...] vs. CASE/ALL</source>
        </item>
        <item>
          <title>Discouraging use of TRAP</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>With <a href="https://forum.rebol.info/t/fail-vs-return-fail-the-new-age-of-definitional-failures/1852">definitional errors</a>, the landscape changes considerably for how we think about error handling.</p>
<p><strong>In this world, there are <em>not a lot of good reasons</em> to use what we've been calling "TRAP".</strong> (historical Redbol's TRY)</p>
<p>By its design, TRAP will intercept <em>any</em> error in code at <em>any</em> depth.  I've shown that when ATTEMPT was based on this, it was not good:</p>
<pre><code>&gt;&gt; attempt [print "Attempting to read file" read %nonexistent-file.txt]
Attempting to read file
; null

&gt;&gt; attempt [print "Attempting but made typos" rread %nonexistent-file.txt]
; null
</code></pre>
<p>That's fixed now, because ATTEMPT is based on REDUCE-EACH with a ^META variable.</p>
<p>But back to TRAP.  The problem isn't just about typos.  It's about the illusion that there's something you can do to react to an arbitrary error...when the constructs you were using didn't even understand it well enough to pipe it through to their output.</p>
<p><strong>In almost all cases, a "TRAP"'d error cannot be reacted to sanely...it has to be reported.</strong></p>
<p>It's for this reason that languages like Rust pretty much enforce a panic</p>
<p>And our case is even more compelling.  For example: How many places is it ever a good idea to sweep a typo under the rug, and just run some other code?</p>
<p>The few cases it's legitimate are things like the console...where you trap the error and present it, so the user knows it happens and can do something about it.  <em>This sort of thing is nearly the only legitimate usage of TRAP.</em></p>
<h2>Might We Make It Look More "Special" To Discourage Use?</h2>
<p>I thought at minimum we should move it to a place that shows it's more of a "system utility" than a "language feature".</p>
<p>So calling it <strong><code>SYS.UTIL.TRAP</code></strong> would be a step in that direction.</p>
<p>And as long as we're discouraging use of this, it seems a bit of a waste to take such a short name.  It could be <strong><code>SYS.UTIL.TRAP-ANY-ERROR</code></strong> or similar, and then TRAP could be used for something should be used more often.</p>
<p>(It could act like ATTEMPT, but evaluate to the error as its primary result instead of the body of the block.)</p>
<p>Things to think about.  Anyway, I've made some progress on definitional errors in the scanner and with TO and MAKE operations, so some of the things people like to trap (like conversions) should work correctly with attempt now.</p>
<p>For instance, in this finite-integer world... an out of range error:</p>
<pre><code>&gt;&gt; attempt [to integer! "10483143873258978444434343"]
; null

&gt;&gt; attempt [to intgeer! "10483143873258978444434343"]
** Script Error: intgeer! word is attached to a context, but unassigned

&gt;&gt; to integer! "10483143873258978444434343" except e -&gt; [print ["Error:" mold e]]
Error: make error! [
    type: 'Script
    id: 'bad-make-arg
    message: ["cannot MAKE/TO" :arg1 "from:" :arg2]
    near: [to integer! "10483143873258978444434343" ** except e -&gt; ***]
    where: [to args]
    file: '
    line: 1
    arg1: #[datatype! integer!]
    arg2: "10483143873258978444434343"
]
</code></pre>
<p>Should be a more specific error, now that I look at that.  But I guess it just wasn't.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/discouraging-use-of-trap/1871">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/discouraging-use-of-trap/1871</link>
          <pubDate>Sun, 10 Jul 2022 16:05:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1871</guid>
          <source url="https://forum.rebol.info/t/discouraging-use-of-trap/1871.rss">Discouraging use of TRAP</source>
        </item>
        <item>
          <title>Renaming MAP! to DICTIONARY!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>Rebol's historical leaning was to give things "plain names", even when that ran counter to computing tradition.</p>
<p>(For instance DECIMAL! was called that instead of what it really was... a FLOAT!, because "floating point" is too techie a concept.  Yet "decimal" means a different type of numeric representation underlying the math.  Red reversed this decision, and calls floating point numbers FLOAT!)</p>
<p><strong>There has been rough consensus that MAP should be a verb, for applying an operation across a data structure.</strong></p>
<p>To recap, with Ren-C's concept of generators, we could make a generator called EACH</p>
<pre><code>&gt;&gt; gen: each [1 2]

&gt;&gt; gen
== 1

&gt;&gt; gen
== 2

&gt;&gt; gen
; null
</code></pre>
<p>And then we've talked about how FOR would call the generator repeatedly until it hit NULL, returning the last body result:</p>
<pre><code>&gt;&gt; for x each [1 2] [print [x], x * 10]
1
2
== 20
</code></pre>
<p>So MAP has been suggested as being the version that collects the body results as you go:</p>
<pre><code>&gt;&gt; map x each [1 2] [print [x], x * 10]
== [10 20]
</code></pre>
<p>Seems pretty neat and composable, huh?</p>
<p>But this makes it feel like calling a datatype MAP! just muddles things.</p>
<p>DICTIONARY! is a bit long to write out, but... people seemed to tolerate "refinement".  Same number of letters (and wider in a non-fixed width font...)</p>
<pre><code>DICTIONARY!
REFINEMENT!
</code></pre>
<p>DICTIONARY<br>
REFINEMENT</p>
<p>...so dictionary doesn't really seem so bad, if you ask me.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/renaming-map-to-dictionary/1856">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/renaming-map-to-dictionary/1856</link>
          <pubDate>Fri, 01 Jul 2022 16:06:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1856</guid>
          <source url="https://forum.rebol.info/t/renaming-map-to-dictionary/1856.rss">Renaming MAP! to DICTIONARY!</source>
        </item>
        <item>
          <title>What to call an Arity-1 wget or curl-like function?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1840">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>At first I just did a <strong>wget</strong> of the scripts:</p>
</blockquote>
</aside>
<p>I've felt for a while we need something parallel to wget where you just specify a URL! of what you want and it writes it.</p>
<p>Calling it <strong>wget</strong> or <strong>curl</strong> would come with expectations that it would have all the options of those programs <em>(I think we could/should make variadic WGET and CURL functions that emulate a useful subset of those options!)</em></p>
<p>Is there a good name for a simpler arity-1 function that just does the above?</p>
<pre><code>xxx: func [filename [file! url!]] [
    write (second split-path filename) (read filename)
]</code></pre>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/what-to-call-an-arity-1-wget-or-curl-like-function/1841">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-to-call-an-arity-1-wget-or-curl-like-function/1841</link>
          <pubDate>Tue, 14 Jun 2022 11:46:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1841</guid>
          <source url="https://forum.rebol.info/t/what-to-call-an-arity-1-wget-or-curl-like-function/1841.rss">What to call an Arity-1 wget or curl-like function?</source>
        </item>
        <item>
          <title>Singular ANY-SPACE vs. Plural WHITESPACE?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>Transitions have made some parse rules get longer:</p>
<pre><code> [any whitespace]  ; being repurposed--seems like "pick one" not a loop construct
 =&gt;
 [while whitespace]  ; being repurposed to arity-2; arity-1 form is unsettling
 =&gt;
 [try some whitespace]
</code></pre>
<p>But this seems a bit overlong...especially considering that whitespace is such a long word.</p>
<p>It occurs to me that "whitespace" can be itself plural.  Might we say that ANY-SPACE is a character set, and then <strong><code>whitespace: [some any-space]</code></strong> ?</p>
<p>This at least gets you down to <strong><code>whitespace</code></strong> or <strong><code>try whitespace</code></strong>...which seems pretty minimal for the intent (unless you're going to go with abbreviations like <strong><code>ws*</code></strong> or similar).</p>
<p>I really don't know how many cases there are where you are willing to tolerate only a single unit of an arbitrary whitespace character.  When does that come up?  Usually if you're matching a single whitespace character you know which one you're reacting to...and the only time you'd ever bundle up a collection of them together is when you're willing to skip a lot of it.</p>
<p>I doubt there'd be many uses of ANY-SPACE in a rule, and that it would just be used to compound other character collections.</p>
<p>It means WHITESPACE would be a parse rule--not a charset--so you would have to use ANY-SPACE for character set in non-PARSE code, but that doesn't seem so bad.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/singular-any-space-vs-plural-whitespace/1828">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/singular-any-space-vs-plural-whitespace/1828</link>
          <pubDate>Thu, 19 May 2022 09:05:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1828</guid>
          <source url="https://forum.rebol.info/t/singular-any-space-vs-plural-whitespace/1828.rss">Singular ANY-SPACE vs. Plural WHITESPACE?</source>
        </item>
        <item>
          <title>Construct For Updating Variable With Value (If It&#39;s Not Void)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>This is a construct that I think <a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a> originally suggested, which is kind of a reverse-DEFAULT.  A variable is optionally updated, but left as-is if the value you try to update to is void.</p>
<pre><code>&gt;&gt; x: &lt;a&gt;
== &lt;a&gt;

&gt;&gt; x: perhaps if false [&lt;b&gt;]
== &lt;a&gt;

&gt;&gt; x
== &lt;a&gt;

&gt;&gt; x: perhaps if true [&lt;c&gt;]
== &lt;c&gt;

&gt;&gt; x
== &lt;c&gt;
</code></pre>
<p>An implementation of this would look something like:</p>
<pre><code>perhaps: enfixed func* [
    "Set word or path to a default value if that value is a value"
    return: [&lt;opt&gt; any-value!]
    'target [set-word! set-path!]
        "The word to which might be set"
    optional [&lt;opt&gt; &lt;void&gt; any-value!]
        "Value to assign only if it is not void"
][
    if semiquoted? 'optional [
        ;
        ; DEFAULT requires a BLOCK!, PERHAPS does not.  Catch `x: perhaps [...]`
        ;
        fail 'optional [
            "Literal" type of :optional "used w/PERHAPS, use () if intentional"
        ]
    ]

    ; Note that right evaluates before left here:
    ; https://github.com/rebol/rebol-issues/issues/2275
    ;
    if null? :optional [return get/any target]
    return set target :optional
]
</code></pre>
<p><strong>It's a nice thing to have, but I'm not sure what to call it.</strong>  Once upon a time it was called MAYBE, before the term was taken for the purpose of converting nulls to voids (which I think is a good fit).</p>
<p>PERHAPS seems too indistinguishable from MAYBE, and I don't know there's any clear reasoning as to why it would be called that.</p>
<p>I think UPDATE was suggested:</p>
<pre><code> &gt;&gt; x: 10
 == 10

 &gt;&gt; x: update void
 == 10

&gt;&gt; x 
== 10

&gt;&gt; x: update 20
== 20

&gt;&gt; x
== 20
</code></pre>
<p>But I dunno about that either.  Ideas?</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/construct-for-updating-variable-with-value-if-its-not-void/2037">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/construct-for-updating-variable-with-value-if-its-not-void/2037</link>
          <pubDate>Tue, 17 May 2022 03:39:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2037</guid>
          <source url="https://forum.rebol.info/t/construct-for-updating-variable-with-value-if-its-not-void/2037.rss">Construct For Updating Variable With Value (If It&#39;s Not Void)</source>
        </item>
        <item>
          <title>&quot;DEBUG&quot; builds vs &quot;CHECKED&quot; builds</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>Since this is a language project, the term "Debug" winds up having a bit of an overloaded meaning.</p>
<p>In an ideal world--and this ideal world will hopefully come to pass--the system will have a debugger in the interpreter for helping people diagnose their code.</p>
<p>But then, there is instrumentation added to the system itself--for its own debugging.  Today we call that "a debug build" of the interpreter.</p>
<p>This is pretty standard--when you ask for a debug build of something, that means it has symbols and asserts in it.  It's a known term in the development culture.  Julia or Python or whoever calls their instrumented version <em>"The Debug Build"</em></p>
<p><a href="https://pythonextensionpatterns.readthedocs.io/en/latest/debugging/debug_python.html" class="inline-onebox">10.2. Building and Using a Debug Version of Python — Python Extension Patterns 0.1.0 documentation</a></p>
<p>But there is another term used in the kernel and OS world called a "checked build".</p>
<h2>Would Calling It A "Checked Build" Be Clarifying or Confusing?</h2>
<p>I feel like reserving the term "debug" to use for features related to what the user would call debugging of <em>their</em> code may make more sense--even though this may be a bit odd for a language project vs. an OS one.</p>
<p>Plus the flag names make more sense.  Take a flag with a name like DEBUG_UTF8_EVERYWHERE... if it were CHECK_UTF8_EVERYWHERE that sort of gives a better impression of what's going on.  <em>You're asking for instrumentation</em> that runs independent of whether you actually are debugging anything.  In fact, you can add these checks while not having any "debug symbols" in your build.</p>
<p>I happen to be doing some tweaks that make this a good time for such changes if they are to be made.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/debug-builds-vs-checked-builds/1708">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/debug-builds-vs-checked-builds/1708</link>
          <pubDate>Thu, 09 Sep 2021 14:53:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1708</guid>
          <source url="https://forum.rebol.info/t/debug-builds-vs-checked-builds/1708.rss">&quot;DEBUG&quot; builds vs &quot;CHECKED&quot; builds</source>
        </item>
        <item>
          <title>Casting vs. SPELL</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>With my bolstered confidence that FILE! best serves as a non-string, I feel like it gives a certain amount of irresistable power.</p>
<pre><code>&gt;&gt; size of %foo.dat
== 143983  ; size of the foo.dat file on disk
</code></pre>
<p><em>(Note: My thinking on SIZE with strings is that it gives you a count in bytes, whereas LENGTH gives you a count in codepoints.  This distinction of "length is logical units" and "size is a byte count" has precedent in other systems...but I'd like to go through and make sure that it's being used consistently everywhere.  A BINARY! can use either since its logical size is 1, but I'd prefer to speak in terms of the size where possible...e.g. when the binary is not being discussed in the context of a generic length that would apply to any series)</em></p>
<p>Somewhat extremely, this would suggest I'd be saying that <strong>length of %foo.dat</strong> would be something that would delegate to whatever the port type was for that file...and give back the logical length of the contents.</p>
<pre><code>; contents of %foo.myformat
[record 1 "foo" #bar]
[record 2 "baz" #mumble]

&gt;&gt; length of %foo.myformat
== 2
</code></pre>
<p>We're imagining here that you're living in a world where a "myformat" port would act something like:</p>
<pre><code>&gt;&gt; p: open %foo.myformat

&gt;&gt; read/part p 1
== make object! [
    x: "foo"
    y: #bar
]

&gt;&gt; read/part p 1
== make object! [
    x: "baz"
    y: #mumble
]

&gt;&gt; read/part p 1
; null
</code></pre>
<p><strong>Of course I am making this all up.</strong>  But what I'm trying to get at is that when you want to talk about the attributes of something that is a representation of some grand thing, the number of characters in its name is potentially much less interesting than all the logical things you can ask about it.</p>
<p>That said...it should be easy to ask how long the name is.  And this is a little bit ugly:</p>
<pre><code>&gt;&gt; length of as text! %foo.dat
== 7
</code></pre>
<p>In the API I've used the word "spell" to talk about string extraction.  Might that look nicer?</p>
<pre><code>&gt;&gt; spell %foo.dat
== "foo.dat"

&gt;&gt; length of spell %foo.dat
== 7
</code></pre>
<p>I guess it could also be FORM.  Though FORM never quite sat right with me, I don't think of it so much as a verb in computer programming as a noun for "form you fill out".</p>
<p>Anyway, this is just to throw out there the idea of SPELL as a way to ask for the underlying string of something that may look a bit better than AS TEXT!.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/casting-vs-spell/1693">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/casting-vs-spell/1693</link>
          <pubDate>Mon, 30 Aug 2021 12:50:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1693</guid>
          <source url="https://forum.rebol.info/t/casting-vs-spell/1693.rss">Casting vs. SPELL</source>
        </item>
        <item>
          <title>Revisiting The Riddle of the .r</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>When Rebol was thinking about coming out of the shadows and participating in the greater programming community, it seemed like trying to own the <strong><code>.r</code></strong> file extension was a bit misguided.</p>
<p>After all: a well established and much more popular statistical language was using it.  It was also out first--it came out in 1993, 4 years before Rebol's 1997.</p>
<p>...aaand the name of the language <em>actually was "R"</em>.  Which isn't a name to get very excited about, so it's not like there was going to be some argument like <em>"no, WE want to call our language R!"</em></p>
<p>It seemed syntax highlighters on programming sites were not going to be allocating <strong>.r</strong> to Rebol.</p>
<p>Hence it seemed no problem to just go with changing to <strong><code>.reb</code></strong> - an improvement, even.  Communicated more.</p>
<h2>...But In The Timeless World...</h2>
<p>Since that time, things have changed:</p>
<ul>
<li>
<p>I've become more partial to the lack of "noise" when listing files in a directory when they end in <strong>.r</strong> ... it makes the important part of the filename pop more.</p>
</li>
<li>
<p>I had to help someone with their school project a couple years ago written in R.  I was not impressed with it.  While it has had growth lately, I think that growth just has more to do with the importance of data science... and does not reflect on the language itself (syntax/paradigm) having any particular merit.  It's just been around a long time and people are looking at data more.</p>
</li>
<li>
<p>Collisions in file extensions have led syntax highlighters to use more heuristics, driven by the file content as well as the overall content of a source repository.  It looks like this will only become more the way things work in the future.</p>
</li>
<li>
<p>Ren-C is renaming, to another name, which starts with R...  <img src="https://forum.rebol.info/images/emoji/twitter/rabbit.png?v=9" title=":rabbit:" class="emoji" alt=":rabbit:"> <img src="https://forum.rebol.info/images/emoji/twitter/raccoon.png?v=9" title=":raccoon:" class="emoji" alt=":raccoon:"> <img src="https://forum.rebol.info/images/emoji/twitter/recycle.png?v=9" title=":recycle:" class="emoji" alt=":recycle:"> <img src="https://forum.rebol.info/images/emoji/twitter/rocket.png?v=9" title=":rocket:" class="emoji" alt=":rocket:"> <img src="https://forum.rebol.info/images/emoji/twitter/robot.png?v=9" title=":robot:" class="emoji" alt=":robot:"></p>
</li>
<li>
<p>The strength of Ren-C's hand has been growing, and I think if it keeps going it might have strength to impose some aspect of its will.  Sharing the .r file extension may be something people are ready to just accept.  <em>(With a much weaker hand, Red managed to push along a claim on the choice of "red"...though it does seem to screw them a bit on searchability.)</em></p>
</li>
</ul>
<h2>So What Do People Think?</h2>
<p>Is rolling back to the historical <strong><code>.r</code></strong> a good way to detach a little more from the "Rebol" brand name, while still fitting into the ecology?</p>
<p>It's a thought.  No rush, just wanted to put the question out there.</p>
            <p><small>5 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/revisiting-the-riddle-of-the-r/1664">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/revisiting-the-riddle-of-the-r/1664</link>
          <pubDate>Sun, 15 Aug 2021 10:23:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1664</guid>
          <source url="https://forum.rebol.info/t/revisiting-the-riddle-of-the-r/1664.rss">Revisiting The Riddle of the .r</source>
        </item>
        <item>
          <title>Revisiting `&lt;opt&gt;` in the Func Spec Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <h2>First, Let's Look Briefly At The History Of <code>&lt;opt&gt;</code>
</h2>
<p>It was many years ago when <code>&lt;opt&gt;</code> first came on the scene as a way to say that a function argument would allow "NULL" as a possibility.</p>
<p>The reasoning was that there was a certain "state" which can be synthesized that represents a <em>non-value</em>.</p>
<blockquote>
<p>Note: Back then, the state was the result of excising reified UNSET! from the system--and it was called VOID--a term that means something rather different today.  <strong>To make things clearer I'm going to sanitize history here a bit and pretend like it was always called NULL.</strong></p>
</blockquote>
<p><strong>Meanness Level Alpha: You Can't Even ASK What Type a NULL Is</strong></p>
<p>In the earliest days, not only did NULL "not have a type"...it was not truthy or falsey...it generated errors when you tried to access it through words.  It went through several iterations of meanness.</p>
<p>This is basically where things started:</p>
<pre><code>&gt;&gt; select [a 10 b 20] 'c
; null

&gt;&gt; type of select [a 10 b 20] 'c
** Error: NULL Values Do Not Have Types
</code></pre>
<p>But that was a pain.</p>
<p><strong>Meanness Level Beta: You Can Ask, But The Answer Is Still A Mean NULL</strong></p>
<p><em>I was steadfast that there wasn't going to be a NULL! "datatype".</em>  But since NULL was the "non-answer" given back for a "non-valued" state...what if the TYPE OF a NULL was just... NULL?</p>
<pre><code>&gt;&gt; select [a 10 b 20] 'c
; null

&gt;&gt; type of select [a 10 b 20] 'c
; null
</code></pre>
<p>While it was pleasing at some level, it didn't change the fact that NULL was still mean, and not accepted a lot of places...much like an UNSET! had been in Rebol2:</p>
<pre><code>rebol2&gt;&gt; switch print "Rebol2" [10 [print "Disliked UNSET!s"]]
Rebol2
** Script Error: switch is missing its value argument
</code></pre>
<p>So the same problem would hit you all around the system if you were trying to do something with that NULL answer you got for types:</p>
<pre><code>&gt;&gt; switch type of select [a 10 b 20] 'c [
     integer! [...]
     block! [...]
]
** Error: SWITCH does not allow NULL as its VALUE argument
</code></pre>
<p><strong>Meanness Level Gamma: NULL Becomes Friendly</strong></p>
<p>Today we've gotten to a situation where NULL is generally pretty friendly and accepted a lot of places.  WORD!s can look up to NULL without erroring, so NULL doesn't need to be a "function that returns NULL".</p>
<pre><code>&gt;&gt; switch type of select [a 10 b 20] 'c [
     null [print "Everything works just fine!"]
     integer! [...]
     block! [...]
]
Everything works just fine!
</code></pre>
<p>The whole paradigm surrounding unsetness has gone through a great rethinking with BAD-WORD!s and isotopes that I'm still discovering the interesting nuances of, but it's light-years ahead of old methods.</p>
<h2>So...Back To TYPESET! Representation</h2>
<p>From the beginning I knew there was not going to be a NULL! "datatype".  And using NULL itself in a type block would be a bad idea.  It was too easy to wind up with NULL values on accident...they were used to represent unset values!</p>
<p>In those days, imagine if this had been the way to say "the typeset can include NULL":</p>
<pre><code>foo: func [arg [null integer! block!]] [...]
</code></pre>
<p>All right, but what if you had just some typo and a variable was <em>incidentally</em> null?</p>
<pre><code>foo: func [arg [intteger! block!]] [...]
</code></pre>
<p>Would you want that function to now accepts nulls and blocks?  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>Even though NULL no longer corresponds to "typo" states, it still is a state that values can be in for all kinds of reasons.  I think <strong>null = type of null</strong> is the right answer, but that doesn't mean that the way to indicate a function is willing to accept null as an argument is if any variable that happens to be NULL appears in the type spec.</p>
<p><strong>And NULL couldn't be in TYPESET! because you would have no way to FIND it -- FIND won't look for "NULL" in <em>anything</em>...and if it ever returns NULL that means the thing wasn't found.</strong></p>
<h2>So Why Exactly Have I Been So Opposed to a NULL! Datatype?</h2>
<p><em>I feel like I've always had a good reason.</em>  If a TYPE OF operation can make a reified thing spring into existence out of the absence of a thing, I feel like something is out of whack.</p>
<p>There's a clear advantage if you're going to be chaining things.</p>
<pre><code>x: (type of select data item) else [
    fail "A reified NULL! datatype doesn't permit this kind of handling"
]
</code></pre>
<p>Though that's a more modern intuition about it; I wasn't thinking about that when <code>&lt;opt&gt;</code> was made.</p>
<p>I think one angle is that I felt like the optionalness was somehow a "big deal" and needed to jump off the page for the spec more.  NULL! just blended in.</p>
<pre><code>foo: func [arg [null! integer! block!]] [...]
bar: func [arg [integer! block! group! path! null! word!]] [...]
</code></pre>
<h2>Modern Thought: <code>&lt;opt&gt;</code> =&gt; <code>[&lt;null&gt; any-value!]</code>
</h2>
<p>With the introduction of <a href="https://forum.rebol.info/t/implicit-execution-of-return-in-functions-bad/1656">new rules surrounding RETURN</a>, I've made it more painful to get the "default" return behavior of being able to RETURN whatever you want.</p>
<p>This made me think it might be nice to build on the PARSE meaning of <code>&lt;any&gt;</code> as a replacement for "SKIP" (e.g. match one ANY-VALUE!) to get an easy RETURN spec:</p>
<pre><code>foo: func [return: &lt;any&gt; ...] [...]
</code></pre>
<p>Then, <code>&lt;opt&gt;</code> could be shorthand for <code>[&lt;null&gt; any-value!]</code></p>
<pre><code>bar: func [return: &lt;opt&gt; ...] [...]
</code></pre>
<blockquote>
<p>I can also imagine <code>&lt;opt&gt;</code> being a UPARSE tag as a shorthand for <strong><code>opt &lt;any&gt;</code></strong>.</p>
<pre><code>&gt;&gt; uparse? [x: (stuff)] [sw: set-word!, g: group!, x: &lt;opt&gt;]
== #[true]

&gt;&gt; x
; null

&gt;&gt; uparse? [x: (stuff) "extra"] [sw: set-word!, g: group!, x: &lt;opt&gt;]
== #[true]

&gt;&gt; x
== "extra"
</code></pre>
</blockquote>
<p>In any case, <code>&lt;any&gt;</code> and <code>&lt;opt&gt;</code> would thus join the other "top-level" shorthands <code>&lt;none&gt;</code> and <code>&lt;void&gt;</code> for function typeset specs.  <strong>Such a shorthand feels pressing given my new strict rule regarding returns, I don't like having to type <code>[return: [&lt;null&gt; any-value!]]</code> just to be able to use RETURN.  I can put up with <code>[return: &lt;opt&gt;]</code> and <code>[return: &lt;any&gt;]</code></strong></p>
<h2>Newer, Weirder Options with More Datatypes</h2>
<p>There are actually more wacky and crazy ideas possible these days.  <img src="https://forum.rebol.info/images/emoji/twitter/crazy_face.png?v=9" title=":crazy_face:" class="emoji" alt=":crazy_face:"></p>
<p>We know that refinements like /ARG are optional, they may be NULL in which case that means they were not supplied.  <a href="https://forum.rebol.info/t/word-some-path-some-group-and-some-block/1125/21">I was just suggesting they might be the better branch notation for allow pure NULL to escape a branch.</a>  We could also make the type blocks build on this notation:</p>
<pre><code>foo: func [
    return: /[integer!]  ; alternative to today's [&lt;opt&gt; integer!]
    arg1 [block!]
    arg2 /[logic!]  ; alternative to today's [&lt;opt&gt; logic!]
][
    ...
]
</code></pre>
<p>But looking at it, I don't feel it communicates as well.  The tags just seem more literate.</p>
<p>For some reason, <code>&lt;null&gt;</code> looks oddly heavy though:</p>
<pre><code>foo: func [
    return: [&lt;null&gt; integer!]
    arg1 [block!]
    arg2 [&lt;null&gt; logic!]
][
    ...
]
</code></pre>
<p>I guess a lot of it is what you're used to, but null is such a "vertical" word, it's like it has two !! in it:</p>
<pre><code>foo: func [
    return: [&lt;opt&gt; integer!]
    arg1 [block!]
    arg2 [&lt;opt&gt; logic!]
][
    ...
]
</code></pre>
<p>I'm probably just being silly due to what I'm used to.  The <code>&lt;null&gt;</code> is clearer, and I kind of like my suggestion that <code>&lt;opt&gt;</code> be shorthand for <code>[&lt;null&gt; any-value!]</code>.</p>
<h2>I Know This Is Long, Just Thinking Out Loud</h2>
<p>I don't want to change anything until TYPESET! and DATATYPE! have more understanding.  But as it so happens, I think that the change to RETURN to make it the locus of typechecking on functions <em>is</em> a step forward in the type system conception.</p>
<p>Design happens one step at a time, folks.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/revisiting-opt-in-the-func-spec-dialect/1658">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/revisiting-opt-in-the-func-spec-dialect/1658</link>
          <pubDate>Fri, 13 Aug 2021 02:50:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1658</guid>
          <source url="https://forum.rebol.info/t/revisiting-opt-in-the-func-spec-dialect/1658.rss">Revisiting `&lt;opt&gt;` in the Func Spec Dialect</source>
        </item>
        <item>
          <title>Efficient Consuming Append-Like Operator... GLOM ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>So I'm looking at the question of how to take bits of material that may or may not be produced, that become owned by the recipient...and accumulate them.</p>
<p>For efficiency, I'd like an operator that will be null tolerant.  Like this:</p>
<pre><code>&gt;&gt; accumulator: null

&gt;&gt; result: make-some-stuff arg1 arg2 arg3
== ~null~  ; isotope (let's say it produced nothing)

&gt;&gt; accumulator: glom accumulator result
== ~null~  ; isotope (okay, that's a no-op)

&gt;&gt; result: make-more-stuff arg4 arg5 arg6
== [a b c]

&gt;&gt; accumulator: glom accumulator result
== [a b c]  ; since there was nothing in the accumulator, we take it

&gt;&gt; append accumulator [d]
== [a b c d]

&gt;&gt; result
== [a b c d]  ; it's okay to reuse result, protocol was we "own" it
</code></pre>
<p>This kind of operator is handy when synthesizing results up the stack.  Because it has carte-blanche to tear up the series its given, it could notice when the result array was larger than the accumulator and steal its memory to slide results into...rather than do a new allocation.</p>
<p>So after a GLOM the thing being appended (<code>result</code> above) will either be equivalent to the accumulator or it will appear to have been FREE'd.</p>
<p>The specific feature I'm looking to support with this is the "third result" I've been talking about for combinators, of their "pending" items...this would include collected things.  I don't want to have to be making new empty blocks with <code>copy []</code> just in case combinators want to add to the collection something...they may just come back with blanks.  So if the accumulator could start off as blank that would avoid these stray series creations most of the time.</p>
<p>I don't think allowing you to JOIN to a NULL and get a new series is a good idea, and it wouldn't be able to do the other optimizations either (since JOIN does not assume you are giving it ownership of the appended data to destroy as you wish).  So this is a distinct operator, and calling it <strong>GLOM</strong> is probably fine for now.  But thought I'd describe what it did just to put that out there.</p>
<p>Here is a usermode prototype:</p>
<pre><code>glom: func [
    return: "New accumulator value (may be blank or reused)"
        [blank! block!]
    accumulator [blank! block!]
    result
][
    if accumulator [
        append accumulator result
        elide if block? result [free result]  ; placeholder for stealing memory
    ] else [
        case [
            null? result [null]
            block? result [result]
            (append copy [] :result)
        ]
    ]
]
</code></pre>
<blockquote>
<p>Note that I'm using CASE fallout above, where if you don't pair up the clauses in a case it will just evaluate to the last condition:</p>
<pre><code>&gt;&gt; case [
      1 = 2 [print "math is broken"]
      10 + 20
   ]
== 30
</code></pre>
<p>Rebol2 and R3-Alpha report #[true] for that, while Red says #[none].  The only answers I'd consider for this would be 30 or raise an error.  I definitely like just being able to write a FAIL in that spot without having to say <strong><code>true [fail "..."]</code></strong>, and I guess that "laxness" makes me feel it's a nice place to put a default as well.  This is still an open question.</p>
</blockquote>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/efficient-consuming-append-like-operator-glom/1647">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/efficient-consuming-append-like-operator-glom/1647</link>
          <pubDate>Thu, 05 Aug 2021 09:36:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1647</guid>
          <source url="https://forum.rebol.info/t/efficient-consuming-append-like-operator-glom/1647.rss">Efficient Consuming Append-Like Operator... GLOM ?</source>
        </item>
        <item>
          <title>Verbing Nouns Revisited: COMBINATOR and COMB</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>We've long lamented the unfortunate nature of "verbing" nouns like FUNCTION.</p>
<p>And again, we have this situation where if we use COMBINATOR as the way of declaring a combinator, what do we call instances?  C?  COMB?</p>
<p>It feels a bit sad that we can't just write something like:</p>
<pre><code>combinator: select state.combinators group!  ; get the GROUP! combinator
</code></pre>
<p>If you do that, you're overwriting the function you use to make combinators.  And that's no good.</p>
<p>So I wind up writing:</p>
<pre><code>comb: select state.combinators group!  ; get the GROUP! combinator
</code></pre>
<p>But it seems that COMBINATOR rightly belongs to the <em>instance</em>, and the thing that makes combinators should be called something like MAKE-COMBINATOR.  If anything, COMB should be the shorthand for MAKE-COMBINATOR and we allow the word COMBINATOR for instances of combinators.</p>
<p>I got to wondering why we don't like MAKE-FUNCTION or MAKE-COMBINATOR.  <em>Is it the hyphen?</em>  What if it were <strong>make function</strong> and <strong>make combinator</strong> and it dispatched to the "makers" based on quoting the words?</p>
<p>This would create a little bit of confusion, but we've gotten used to:</p>
<pre><code>length: length of block
</code></pre>
<p>Why can't we accept:</p>
<pre><code>combinator: make combinator [...] [...]
</code></pre>
<p>I hate to beat this old dead horse again.  But FUNCTION is a noun.  COMBINATOR is a noun.  It still feels like something is wrong with verbing these nouns just for the sake of brevity and familiarity, and then having to contort the names of instances to avoid overwriting the verb.</p>
<p>NEW is shorter and not contentious with the historical meaning of MAKE:</p>
<pre><code>combinator: new combinator [...] [...]
</code></pre>
<p>It just seems like we're fighting against the English language to be using nouns wrong, just because other languages have done it.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/verbing-nouns-revisited-combinator-and-comb/1646">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/verbing-nouns-revisited-combinator-and-comb/1646</link>
          <pubDate>Thu, 05 Aug 2021 09:09:03 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1646</guid>
          <source url="https://forum.rebol.info/t/verbing-nouns-revisited-combinator-and-comb/1646.rss">Verbing Nouns Revisited: COMBINATOR and COMB</source>
        </item>
        <item>
          <title>Disambiguating `META OF` and the META-XXX! (^) Types</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>An idea that emerged early on in Ren-C was that there was often a need to associate an object with another object (or action), to give more information about it.</p>
<p>You could do this with a global MAP!.  But a built-in mechanism could be cheaper--and I foresaw the feature being foundational enough that efficiency would matter.  This would likely be needed for every ACTION!, every ERROR!, every MODULE!, and many other places...</p>
<p>This mechanism was called the "meta" information of the object or action.</p>
<h2>A New META in Town...</h2>
<p>But now, the existence of the new <strong>^word</strong>, <strong>^pa/th</strong>, <strong>^tu.p.le</strong>, <strong>^(gr o up)</strong>, <strong>^[bl o ck]</strong> types give a category known as META-WORD!, META-PATH!, META-TUPLE!, etc.</p>
<p>I'm confident that calling that META is good.  Given how foundational the technique is, I don't want to make understanding any harder by reusing the word for something completely unrelated.</p>
<p>It is likely that the lone word META will be a synonym for <strong>^</strong>, for those who don't like symbols.  Recall that it is lightly distinguished from QUOTE, e.g. that <strong>^ null</strong> is null (not <strong>'</strong>) and it tolerates isotopes, returning the non-quoted BAD-WORD!:</p>
<pre><code>&gt;&gt; ~asdf~
== ~asdf~  ; isotope

&gt;&gt; first [~asdf~]
== ~asdf~

&gt;&gt; meta ~asdf~
== ~asdf~

&gt;&gt; meta first [~asdf~]
== '~asdf~

&gt;&gt; meta null
; null
</code></pre>
<p>So what do we call the associated object?</p>
<ul>
<li>
<p><strong>auxiliary of ...</strong></p>
</li>
<li>
<p><strong>linked of ...</strong></p>
</li>
</ul>
<h2>Bigger Question: Is One Linked Object Enough?</h2>
<p>Over time I've come to wonder if keyed access is more important.  For instance, in JavaScript you are able to assign arbitrary field members to a function:</p>
<pre><code>&gt; function foo() {console.log("foo.x is " + foo.x + " and foo.y is " + foo.y)}
&gt; foo.x = 10
&gt; foo.y = 20

&gt; foo()
&lt;- foo.x is 10 and foo.y is 20
</code></pre>
<p>Now that we can discern field access (foo.x) from refinement usage (foo/x), it makes it very tempting to follow suit and say that actions have arbitrary keyed fields like this.  This could be where the help lives.</p>
<p>If this was the case, then there's no need for a "meta" object or naming it.  You simply use dots.</p>
<p>This would require a re-imagining of how MODULE! works, but that's already happening in "Sea of Words".  So it might mean that you can't link an arbitrary object to another object...you'd make maps...which is what every other language does instead of having a "secret" place to scribble on.</p>
<p>In any case, it is likely that the old sense of META is going away entirely (though the mechanic it relies on would be exposed another way).  We'll see...</p>
<p>Internally in the macros I'm thinking of calling it something like AUX_OF() to replace macros like META_OF().  You run out of these words eventually.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/disambiguating-meta-of-and-the-meta-xxx-types/1631">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/disambiguating-meta-of-and-the-meta-xxx-types/1631</link>
          <pubDate>Thu, 01 Jul 2021 16:37:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1631</guid>
          <source url="https://forum.rebol.info/t/disambiguating-meta-of-and-the-meta-xxx-types/1631.rss">Disambiguating `META OF` and the META-XXX! (^) Types</source>
        </item>
  </channel>
</rss>

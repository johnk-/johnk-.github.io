<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Naming - AltRebol</title>
    <link>https://forum.rebol.info/c/development/naming/32</link>
    <description>Topics in the &#39;Naming&#39; category Suggestions on naming new functions, and guidance on choosing names.</description>
    
      <lastBuildDate>Fri, 14 Apr 2023 21:37:51 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/naming/32.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Should ANY-VALUE! Include Isotopes?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>So if you don't put any type restrictions on a parameter, it will allow isotopes:</p>
<pre><code> &gt;&gt; foo: func [x] [probe x]

&gt;&gt; foo null
~null~  ; isotope
</code></pre>
<p>And right now, that is a synonym for ANY-VALUE!.</p>
<pre><code> &gt;&gt; foo: func [x [any-value!]] [probe x]

&gt;&gt; foo null
~null~  ; isotope
</code></pre>
<p><strong>But what if you want to exclude isotopes?</strong>  We could have a name for the typeset excluding isotopes (perhaps ANY-CELL!).  Or we could say that ANY-VALUE! doesn't include isotopes by default, and so you have to write <strong>[any-value! isotope!]</strong> if you want them... or just include the specific ones you intend (like <strong>[null! any-value!]</strong>.</p>
<p>Right now I'm going the route of saying ANY-CELL! is the narrower set of values that do not include isotopes.  Is there a better term for saying something can be put into an array vs. not?</p>
<p><em>"10 is an integer! which is legal to use as a cell, while ~null~ isotopes are not legal as cells, but can be variable values"</em></p>
<p>It seems shorter and cleaner than ANY-REIFIED!  or something like that.  I don't know any better options.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-any-value-include-isotopes/2026">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-any-value-include-isotopes/2026</link>
          <pubDate>Fri, 14 Apr 2023 21:37:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2026</guid>
          <source url="https://forum.rebol.info/t/should-any-value-include-isotopes/2026.rss">Should ANY-VALUE! Include Isotopes?</source>
        </item>
        <item>
          <title>TRY... *again* :roll_eyes:</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>I have proposed a concept for TRY as trapping definitional errors and turning them into nulls, like this:</p>
<pre><code>&gt;&gt; take []
** Error: you can't take from an empty block (stopping further code)

&gt;&gt; try take []
== ~null~  ; isotope
</code></pre>
<p>And I'll just give a reminder that as this is trapping <a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852">definitional errors</a>.  So failures from deeper inside code would not be caught... only errors that are returned by contract from the function being called.</p>
<pre><code>&gt;&gt; try compose [(1 / 0)]
** Error: division by zero (e.g. COMPOSE itself didn't raise the error)
</code></pre>
<p><em>I'll remind everyone that it's a very slippery slope to trap "deep errors", and this is why the deep error trapping concept is <a href="https://forum.rebol.info/t/discouraging-use-of-trap/1871/3">hidden away as <code>sys.util.rescue</code></a>)</em></p>
<h2>Why Return NULL From TRY (vs. void) ?</h2>
<p>The decision to return null is to make the result falsey so it can be acted on:</p>
<pre><code>while [item: try take block] [
    ...
]

all [
    try take block  ; if this fails we don't want to keep going
    ...
]
</code></pre>
<p>In the vernacular I use, I call NULL "soft failure".  So TRY "converts a definitional failure into soft failure", passing through all other results as-is.</p>
<h2>Comparison with similar word MAYBE</h2>
<p>The MAYBE operation was defined as something that converts nulls to voids, and passes through everything else.  If you didn't know that, it's easy to see not intuiting what the difference between <strong>try take block</strong> and <strong>maybe take block</strong> would be.</p>
<p>You can get some odd-looking combinations with this, e.g.</p>
<pre><code> &gt;&gt; block1: [a b c]
 &gt;&gt; block2: []

 &gt;&gt; append block1 maybe try take block2
 == [a b c]
</code></pre>
<p>Which makes one wonder if MAYBE could be used to trap definitional errors as well as nulls and turn them into voids, so you could just write <strong>append block1 maybe take block2</strong>.</p>
<p>So it raises the question: are there null-returning operations that also return definitional errors, where one would want to suppress the null but not the error?  There's not enough experience for me to say yet.</p>
<h2>Usage in PARSE as opposed to OPT?</h2>
<p>I've wondered if TRY and MAYBE could have parallel meanings in PARSE, where you use TRY to continue but get NULL and MAYBE to skip things:</p>
<pre><code>&gt;&gt; parse "aaa" [some "a" maybe some "b"]
== "a"

&gt;&gt; parse "aaa" [some "a" var: try some "b"]
; first in pack of length 1
== ~null~  ; isotope

&gt;&gt; var
== ~null~  ; isotope
</code></pre>
<p>Seeing the two operations as being very similar--only one voids while the other one nulls--feels interesting.  I just hadn't thought of MAYBE as a definitional-error-suppressor before.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/try-again/2025">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/try-again/2025</link>
          <pubDate>Fri, 14 Apr 2023 21:22:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2025</guid>
          <source url="https://forum.rebol.info/t/try-again/2025.rss">TRY... *again* :roll_eyes:</source>
        </item>
        <item>
          <title>Naming void&#39;s isotopic, quoted, and quasi forms</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>I've called the state of unset variables "nihil"... <strong>this is the isotopic state of void</strong>.  I don't know if it's the best name but I definitely know I don't like calling it "unset" (I always say "variables are unset, not values").</p>
<p>The meta state of void is just a single apostrophe.  Evaluating it produces void:</p>
<pre><code>&gt;&gt; '
; void
</code></pre>
<p>The quasi state of void is a single tilde, and it evaluates to nihil:</p>
<pre><code>&gt;&gt; ~
== ~  ; isotope  &lt;-- a.k.a. nihil
</code></pre>
<p>I mentioned that I prefer this to be the default for making an ARRAY if you don't specify an /INITIAL value because it is the reified stand-in for uninitialized-ness.  Unlike blanks, it would error if you try to SPREAD it:</p>
<pre><code>&gt;&gt; block: array 10
== [~ ~ ~ ~ ~ ~ ~ ~ ~ ~]

&gt;&gt; spread block.2
** Error...
</code></pre>
<p>This seems to me a better default than blank for any slots that you miss filling in for your arrays.</p>
<p><strong>So what do we call <code>[']</code> and <code>[~]</code></strong>?  Metavoid and Quasivoid?  Tick and tilde?  Is tilde a Metanihil?</p>
<p>I've also wondered if there's any better name for nihil.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/naming-voids-isotopic-quoted-and-quasi-forms/2021">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/naming-voids-isotopic-quoted-and-quasi-forms/2021</link>
          <pubDate>Fri, 03 Mar 2023 21:55:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2021</guid>
          <source url="https://forum.rebol.info/t/naming-voids-isotopic-quoted-and-quasi-forms/2021.rss">Naming void&#39;s isotopic, quoted, and quasi forms</source>
        </item>
        <item>
          <title>&quot;Quasiforms&quot;, &quot;Stable/Unstable Isotopes&quot;: Simpler Terminology?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>It's no secret that I'm proud of the way the <a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">design for generalized isotopes</a> is tearing through classic problems in Rebol.</p>
<p>At the same time, people's eyes can glaze over when you find yourself writing sentences like:</p>
<blockquote>
<p><em>"All quasiforms become isotopic forms when evaluated, and when going the other way through a meta operation on an isotope, you'll get a quasiform back."</em></p>
</blockquote>
<p>It all makes sense to me.  But I don't want to overlook better terms, if they exist.</p>
<h2>How Did "Isotopes" Come To Be Called That?</h2>
<p>The term isotope originated from the "decaying" behavior, where a special form of null would run a THEN branch.  But this special form would not be something you could store in a variable...it would become an ordinary null at that point.  So getting stored in a variable would cause "decay".</p>
<pre><code>&gt;&gt; null
; null

&gt;&gt; if true [null]
; null isotope

&gt;&gt; x: if true [null]
; null isotope

&gt;&gt; x
; null
</code></pre>
<p>The decay means variables captured from expressions would have a different behavior when substituted for the expressions.  That was deemed to be an acceptable cost.</p>
<pre><code>&gt;&gt; if true [print "then", null] else [print "else"]
then

&gt;&gt; temp: if true [print "then", null]
then

&gt;&gt; temp else [print "else"]
else
</code></pre>
<p>The parallel with decay of atomic isotopes seemed pretty clear, at least to me.  Many places would see it as a normal null, but a few special sites could use a "sensor" to detect the difference.  ELSE was an example of something that could detect.</p>
<p>As things moved forward, and when logic variables became ~true~ and ~false~ isotopes, it became clear these isotopic states would need to be able to stored in variables.  That meant there were "unstable isotopes" and "stable isotopes"... e.g. WORD! isotopes were stable, ERROR! isotopes were not.</p>
<p><em><strong>Having these stable isotopes actually strengthened the analogy.</strong></em>  Because some atomic isotopes are stable, while others are not.</p>
<h2>How Did "QUASI" Become Called That?</h2>
<p>Originally, things like <code>~foo~</code> were called "bad words", designed to cause errors when accessed through a variable by default.  They were like an old-school UNSET! where you could give it a custom label.  But eventually everything was generalized so that everything had an isotopic form.</p>
<p>The fact that these forms stopped conveying an error condition meant considering them "bad" wasn't sensible.  I kind of latched onto "quasi" in part because of the tilde's use in approximation, e.g. (3.0001 ~= 3).</p>
<p>(It also sounds a little like "queasy" and the squigglies look wavy and maybe a bit uncomfortable.  <img src="https://forum.rebol.info/images/emoji/twitter/nauseated_face.png?v=9" title=":nauseated_face:" class="emoji" alt=":nauseated_face:">)</p>
<h2>So... Speak Now Or Hold Your Peace?</h2>
<p>Bad naming can have an impact.  I think calling complex numbers "imaginary" is a good example of a bad name that probably caused a few problems.</p>
<p>But I think the names here are good.  It's just going to be a matter of figuring out how to teach people to not be afraid of them.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/quasiforms-stable-unstable-isotopes-simpler-terminology/2005">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/quasiforms-stable-unstable-isotopes-simpler-terminology/2005</link>
          <pubDate>Sun, 08 Jan 2023 21:18:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2005</guid>
          <source url="https://forum.rebol.info/t/quasiforms-stable-unstable-isotopes-simpler-terminology/2005.rss">&quot;Quasiforms&quot;, &quot;Stable/Unstable Isotopes&quot;: Simpler Terminology?</source>
        </item>
        <item>
          <title>REIFY vs. META vs. SOMETHING</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>Originally I suggested that REIFY of an isotope would give its plain form, and you would META it if you wanted a quasiform:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1989">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989/1">~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</a>
</div>
<blockquote>
<ul>
<li>The generic and reversible way to make them real it is to META them and get <code>~true~</code> and <code>~false~</code> quasiforms, which you can UNMETA back to the isotopes</li>
<li>The readable way to make them real is to REIFY them and get <code>true</code> and <code>false</code> as plain WORD!, which only gets turned back into the isotope form if they are bound to variables that hold the isotopes, and you evaluate them.</li>
</ul>
</blockquote>
</aside>
<p><em>But that's not a full coverage answer.</em></p>
<ul>
<li>
<p>An operator that takes everything "one level up", where isotopes become quasiforms and everything else gets a quote level added.</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; meta true
== ~true~

&gt;&gt; meta 10
== '10
</code></pre>
</li>
<li>
<p>An operator that leaves non-isotopes as they are, but turns isotopes into their quasiforms (and I think this probably is best called REIFY):</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; reify true
== ~true~

&gt;&gt; reify 10
== 10
</code></pre>
</li>
<li>
<p>An operator that leaves non-isotopes as they are, but turns isotopes into their plain forms:</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; something true
== true

&gt;&gt; something 10
== 10
</code></pre>
</li>
</ul>
<p>Specifically for ACTION! isotopes being turned into plain actions, I used an interim term UNRUN, but that's pretty awful.</p>
<p>Making things into isotopes is done with ISOTOPIC:</p>
<pre><code>&gt;&gt; isotopic 10
== ~10~  ; isotope
</code></pre>
<p>It could be a refinement to REIFY, like REIFY/PLAIN.  But at that point it could be two steps that might be clearer: NOQUASI REIFY, where NOQUASI would be like NOQUOTE and not complain if the thing you passed it was not a quasiform.</p>
<p>Maybe... CONCRETIZE?  That sounds like it might do a bit more work than what REIFY does :-/</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; concretize true
== true

&gt;&gt; concretize 10
== 10
</code></pre>
<p>It's not awful.  Main thing is just to have <em>a</em> name for it while the gears turn.  But as usual, throw out suggestions if you have them...</p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/reify-vs-meta-vs-something/2001">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/reify-vs-meta-vs-something/2001</link>
          <pubDate>Thu, 05 Jan 2023 21:26:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2001</guid>
          <source url="https://forum.rebol.info/t/reify-vs-meta-vs-something/2001.rss">REIFY vs. META vs. SOMETHING</source>
        </item>
        <item>
          <title>~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>The concept of having isotopic <strong>~true~</strong> and <strong>~false~</strong> as WORD! isotopes instead of having a distinct LOGIC! type is admittedly somewhat weird.  It means they can't be put in blocks and need some sort of transformation if they're going to be put into blocks.</p>
<ul>
<li>
<p>The generic and reversible way to make them real it is to META them and get <code>~true~</code> and <code>~false~</code> quasiforms, which you can UNMETA back to the isotopes</p>
</li>
<li>
<p>The readable way to make them real is to REIFY them and get <code>true</code> and <code>false</code> as plain WORD!, which only gets turned back into the isotope form if they are bound to variables that hold the isotopes, and you evaluate them.</p>
</li>
<li>
<p>Your circumstance may mean that neither of those choices are what you want when in a situation where the isotopes can't work...maybe it means you have to rethink what you're doing, or maybe you want some other transformation.  It's good to be alerted to the fact that it's dodgy to put what you think of as a "logic" in a reified context.</p>
</li>
</ul>
<p>One should note that Lisp has no false at all, only NIL for false (since everything else is truthy, you could use anything else for true, but they have T predefined).  But their NIL isn't isotopic--so it can appear in lists literally.</p>
<p>And as I've repeatedly pointed out, Redbol's historical choice to render LOGIC! conflated with the words <code>true</code> and <code>false</code> (instead of <code>#[true]</code> and <code>#[false]</code>) shows a desire to avoid the logic literals "escaping" into the reified consciousness of the user.  Making the logic forms actually impossible to put into blocks without a conscious transformation feels like it's good.</p>
<p>I know it's a strange choice, but it's seeming like it fits with the territory.  It's a sort of tradeoff you need when you choose to be firm that TRUE and FALSE are redefinable words and not lexical forms of logic constants.</p>
<h2>So... Why Shouldn't NULL Be Done With <code>~null~</code> isotope ?</h2>
<p>Right now what I call "null" is isotopic BLANK!.  It is not pretty looking:</p>
<pre><code>&gt;&gt; null
== ~_~  ; isotope

&gt;&gt; _
== ~_~  ; isotope
</code></pre>
<p>But what <em>is</em> pretty looking is that if you assign a bunch of variables to null, the fact that blanks evaluate to the null isotope gives a great visibility to where the actual values to pay attention to are:</p>
<pre><code>obj: make object! [
    alpha: _
    beta: _
    delta: true
    epsilon: ~
    gamma: "nutty"
    rho: _
    omega: 'now
 ]
</code></pre>
<p>If we used a word isotope, then at source level we're writing:</p>
<pre><code>obj: make object! [
    alpha: null
    beta: null
    delta: true
    epsilon: ~
    gamma: "nutty"
    rho: null
    omega: 'now
 ]
</code></pre>
<p>And if we view it after evaluation that fetches (<code>null</code> =&gt; <code>~null~  ; isotope</code>), it gets uglier:</p>
<pre><code>make object! [
    alpha: ~null~
    beta: ~null~
    delta: ~true~
    epsilon: ~
    gamma: "nutty"
    rho: ~null~
    omega: 'now
 ]
</code></pre>
<p>We can't show it as the WORD! null because there's no guarantee that word always will evaluate back to the null isotope.  But the concept is that since BLANK! can't be redefined, we can put it in an evaluative context as a substitute for <code>~_~</code> if we want.</p>
<p>If we were "more honest" and just META'd the isotopic blank, we'd get renders like:</p>
<pre><code>make object! [
    alpha: ~_~
    beta: ~_~
    delta: ~true~
    epsilon: ~
    gamma: "nutty"
    rho: ~_~
    omega: 'now
 ]
</code></pre>
<p>But I might actually like that less than seeing <strong><code>~null~</code></strong> there.</p>
<h2>Things To Weigh In This Consideration</h2>
<p>I'm really torn.  Certainly having people be able to see ~null~ written out as a word corresponds to what we want to refer to the state as.  We aren't going to replace people's vernacular to say "isotopic blank" instead of null.  And trying to teach people "isotopic blank is null" is an uphill battle.</p>
<p>Let's look back at that seemingly beautiful situation with all the blanks-to-nulls at source level:</p>
<pre><code>obj: make object! [
    alpha: _
    beta: _
    delta: true
    epsilon: ~
    gamma: "nutty"
    rho: _
    omega: 'now
 ]
</code></pre>
<p>But, hmmm.  The <strong><code>~</code></strong> is now an assignable state meaning variable is not set.  How often will you want to set something to NULL...which won't generate an error on access like being unset would, but is falsey and can't be passed to many routines without a MAYBE?</p>
<p><strong>Statistically, we might often have a situation where NULL is the minority initialization, more like this:</strong></p>
<pre><code>obj: make object! [
    alpha: ~
    beta: ~
    delta: true
    epsilon: null
    gamma: "nutty"
    rho: ~
    omega: 'now
 ]
</code></pre>
<p>My point is that intentionally initializing things to null may not be as common as setting to an error-provoking unset state.  And when null happens it may be just as noteworthy to call out as setting something to true or false.</p>
<h2>Are There Technical Barriers To This?</h2>
<p>It has some of the same problems as having to deal with the type checking of LOGIC! actually being an isotopic subclass of two words.  It means <code>&lt;opt&gt;</code> is an isotopic subclass of one word, so there's no specific null datatype.  :-/</p>
<p>I was already saying that TYPE OF NULL was probably an error, and TYPE OF MAYBE NULL would be void... anyway, this fits into some of the same type issues that logic has.</p>
<p>Previously NULL cells held nothing, so I'd put a payload of the file and line that were in effect in the evaluator.  This was supposed to give better errors about where a null originated from.  This could still be done if NULL was a special case of WORD! isotope that said it was null via a flag vs. storing the symbol, but could be complicated.  None of the better error mechanics were done yet.</p>
<p><strong>My general intuition is that from a user's standpoint, it's an uphill battle to teach them isotopic blank is something called "null"... and that the majority of technical problems that are involved in making NULL be a word isotope are problems that have to be tackled anyway with true and false as word isotopes.</strong></p>
<p>Additionally, I've written about my desire for BLANK!s to serve in dialects as spaces.  That gets very screwed by the (<strong><code>_</code></strong> =&gt; <strong><code>~_~</code>  ; isotope</strong>) evaluation.  Recovering blank for space intent would be good.</p>
<p>I'm going to likely give it a shot, when I get some programming time again, hopefully soon.</p>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989</link>
          <pubDate>Tue, 25 Oct 2022 04:07:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1989</guid>
          <source url="https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989.rss">~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</source>
        </item>
        <item>
          <title>CLOCK as a Noun</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>Boris made a timing function called "CLOCK", as a sort of replacement for DELTA-TIME:</p>
<p><a href="https://github.com/red/red/blob/81ff4d605df371dfc430b92611605e80f5e5780b/environment/functions.red#L1126">https://github.com/red/red/blob/81ff4d605df371dfc430b92611605e80f5e5780b/environment/functions.red#L1126</a></p>
<pre><code>clock: function [
    "Display execution time of code, returning result of it's evaluation"
    code [block!]
    /times n [integer! float!]  ; float for e.g. `1e6` instead of `1'000'000`
        "Repeat N times (default: once); displayed time is per iteration"
    /delta "Don't print the result, return time delta per iteration (in msec)"
 ]
</code></pre>
<p>It builds in iteration...which is useful for timing, since you often want to loop over things they time.  And at least in theory it should be in the native timing construct--you'd prefer not to have an interpreted call to REPEAT being part of what you count in your time.</p>
<p>(Perhaps the repeat count should just be a required first argument--since CLOCK 1 is so easy to type, why make people fuss over CLOCK/TIMES and then putting the number of times all the way at the end somewhere?)</p>
<h2>
<em>But...</em> I Think CLOCK should be a Noun</h2>
<p><strong>clock/time</strong> and <strong>clock/date</strong> have many advantages over <strong>now/time</strong> and <strong>now/date</strong>.</p>
<p>It implies that you could pass a clock around or copy it...which is a good thing.  So by default the CLOCK could be UTC (for programming convenience).  But you could copy that clock and set your module's meaning of the word CLOCK to speak in terms of local time.</p>
<p>Also it resolves a big annoyance of mine: NOW being a function that has a lot of conflicting refinements.  If CLOCK were an object, then <strong>/time</strong> and <strong>/date</strong> would be separate methods of that object, so you couldn't say things like <code>clock/time/date</code>.</p>
<p>And then you could capture the current time into a variable as <strong><code>now: clock/time</code></strong> which makes more sense to me than saying "now" is itself a verb.  <em>(It then wouldn't stay current as "now" in the sense of "exactly this moment", but in language we're pretty comfortable saying "things are different now than they were in the '80s"...e.g. there can be a prolonged linguistic notion of now.  I prefer to use it in this sense.)</em></p>
<p>As far as functional programming goes: because code doesn't have an intrinsic notion of time, you can show that a piece of code is dependent on a clock by passing one as a parameter.</p>
<p>This would allow you also to have code run simulating at a different time.  You could see how a piece of code would perform if it thought it were running at some pathological date, while working alongside other code that was operating with the current notion of time--e.g. to communicate with some webservers to upload results from a test of something like a Y2K problem simulated by other code.</p>
<h2>What to Call The Timing Construct?</h2>
<p>To think in terms of super-powers, then you need...<em>a dialect</em> !</p>
<p>Perhaps it could be called "CHRONO"?</p>
<p>Maybe CHRONO quotes its argument, and if you give it a GROUP!, it thinks of that as something to time and run just once.</p>
<pre><code>&gt;&gt; chrono (my-function 1 2 3)
0.14 μs
== &lt;result&gt;
</code></pre>
<p>But if you pass a BLOCK! it could permit more options, like saying what you wanted the timing in terms of:</p>
<pre><code>chrono [msec (my-function 1 2 3)]
chrono [usec (my-function 1 2 3)]
</code></pre>
<p>Or the repeat count (being a parameter to chrono means you're not timing a REPEAT inside your code, ideally).</p>
<pre><code>&gt;&gt; chrono [1e7 (1 + 2)]
0.14 μs    [1 + 2]
== 3
</code></pre>
<p>I'm busy with other things and so I'm not going to go research all the possible features you might want from a timing dialect--I'm sure there's plenty of prior art in the domain.  Just wanted to get it started.  Use your imagination.  <img src="https://forum.rebol.info/images/emoji/twitter/unicorn.png?v=9" title=":unicorn:" class="emoji" alt=":unicorn:"></p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/clock-as-a-noun/1956">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/clock-as-a-noun/1956</link>
          <pubDate>Sat, 03 Sep 2022 06:47:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1956</guid>
          <source url="https://forum.rebol.info/t/clock-as-a-noun/1956.rss">CLOCK as a Noun</source>
        </item>
        <item>
          <title>Should THROW and CATCH Be For Errors?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>The historical Rebolism of THROW and CATCH has nothing to do with error handling.</p>
<p>It's a generic way to move values up the stack.  It gives you a handy "out" from control flow:</p>
<pre><code>result: catch [
    if condition [throw result]
    some code
    case [
        condition [more code]
        condition [more code, throw result]
    ]
    additional code
    throw result
]
</code></pre>
<p>The implementation of the feature is lightweight, and built on the same mechanic as RETURN.  You could in fact use return to do this:</p>
<pre><code>result: do func [] [
    if condition [return result]
    some code
    case [
        condition [return code]
        condition [more code, return result]
    ]
    additional code
    return result
]
</code></pre>
<p>But that's more heavyweight, because it gets binding involved (although I've suggested that maybe CATCH and THROW should be definitional, and the "heaviness" is a feature... not a bug).</p>
<h2>It's A Neat Feature, But I Want THROW and CATCH For Errors</h2>
<p>Error handling is undergoing a renaissance in Ren-C, and it's becoming completely pervasive.</p>
<p>Despite its glory, it is currently tied in with the junky names RAISE and EXCEPT.</p>
<pre><code>case [
   ...code that may fail...
] then [
   ...stuff to do if non-NULL, non-VOID, non-RAISED error!...
] else [
   ... stuff to do if NULL or VOID or RAISED error!...
] except e -&gt; [
  ... error handling ...
]
</code></pre>
<p>The word EXCEPT is bad for several reasons:</p>
<ul>
<li>
<p>It implies "exception" handling, <em>which definitional errors are specifically not</em>...they can only be caught one stack step at a time.</p>
<ul>
<li>Arbitrary exception handling is taboo for very good reasons...and I've made it more taboo by <a href="https://forum.rebol.info/t/discouraging-use-of-trap/1871/3">moving that behavior to SYS.UTIL.RESCUE</a>
</li>
</ul>
</li>
<li>
<p>It's not really a "verb"</p>
</li>
<li>
<p>It often comes right after an ELSE, and I don't like the alliteration of E and E</p>
</li>
<li>
<p>Almost every other language uses CATCH there</p>
</li>
</ul>
<p>And RAISE isn't exactly my favorite word either.  <strong>return throw e</strong> vs. <strong>return raise e</strong> also has that alliteration issue.</p>
<h2>So What Can The Old THROW and CATCH Be Called?</h2>
<p>It's a lot less important than the error handling application, but I still use the old construct.</p>
<p>You can actually do it with CYCLE and STOP:</p>
<pre><code>result: cycle [
    if condition [throw result]
    some code
    case [
        condition [more code]
        condition [more code, stop result]
    ]
    additional code
    stop result
]
</code></pre>
<p>Being a looping construct, it has the side effect that it will keep repeating unless a value is emitted.</p>
<p>On the plus side...this helps resolve the semantic question of "what should a CATCH return when there's no THROW?"  If what you have is CYCLE then your answer is that it keeps going.  So you either put a FAIL at the bottom, a STOP at the bottom, or accept it will keep going.</p>
<p>On the minus side...if you use this inside a looping construct you'll be redefining BREAK, which historical CATCH would not do.  (Similarly, if you use FUNC and RETURN to do this you'd redefine RETURN.)</p>
<p>With definitional BREAK and RETURN there'd be workarounds for those cases--you'd simply give another name to the outer break and return if you needed them.  But that's not how things work today.</p>
<h2>While CYCLE is Not Perfect, It Would Work For The Moment</h2>
<p>We can meditate on what the ultimate answer would be.  But there's only a few cases, and CYCLE will do.</p>
<p>Errors need THROW and CATCH...they're now too fundamental to not use the good words for.</p>
<p>We now have the word TRAP for those who don't want to use enfix, so these are equivalent:</p>
<pre><code>if e: trap [some code] [
    handle e
]

(some code) catch e -&gt; [
   handle e
]
</code></pre>
<p>But you get some real benefits from the THEN + ELSE + CATCH, and I think the importance of these enfix constructs will become apparent to those who aren't on the bandwagon (yet).</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-throw-and-catch-be-for-errors/1954">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-throw-and-catch-be-for-errors/1954</link>
          <pubDate>Thu, 01 Sep 2022 11:50:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1954</guid>
          <source url="https://forum.rebol.info/t/should-throw-and-catch-be-for-errors/1954.rss">Should THROW and CATCH Be For Errors?</source>
        </item>
        <item>
          <title>Better Answers than TRY and OPT For BLANK! &lt;=&gt; NULL</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>Ever since the creation of null and blank, it's been desirable to go between them.</p>
<p>The word I first chose for NULL =&gt; BLANK! was TRY.  It would pass through anything else:</p>
<pre><code>&gt;&gt; try null
== _

&gt;&gt; try _
== _

&gt;&gt; try 1020
== 1020
</code></pre>
<p>The reverse operation of converting BLANK! =&gt; NULL was called OPT; again passing through everything else:</p>
<pre><code>&gt;&gt; opt _
; null

&gt;&gt; opt null
; null

&gt;&gt; opt 1020
== 1020
</code></pre>
<p>It may seem mysterious to ascribe such a trivial operation to a high-value word like TRY.  But it made sense at the time, because nulls were rather unfriendly:</p>
<pre><code>&gt;&gt; if not x: find "abc" "d" [print "Assignment goes okay..."]
Assignment goes okay...
; null

&gt;&gt; if not x [print "But word fetching has problems"]
** Error: X is NULL    
</code></pre>
<p>TRY provided a way to disarm the result:</p>
<pre><code>&gt;&gt; x: try find "abc" "d"
== _

&gt;&gt; if not x [print "Didn't find it"]
Didn't find it
</code></pre>
<p>But as it turned out: NULL was trying to do too many things, being fused with the notion of "unset variables".  It was a good start on having non-valued states... we just needed more!</p>
<p>Once VOID arrived it was no longer necessary to error on null variable accesses, and this particular usage of TRY was not necessary.</p>
<h2>But...It Was Actually On The Right Track...</h2>
<p>FIND is a bad demonstration.  But TAKE on empty block is actually a good one from that erroring-on-nulls era:</p>
<pre><code>&gt;&gt; x: take []
; null

&gt;&gt; if x [print "-some- error around here seems right..."]
** Error: X is NULL

&gt;&gt; x: try take []
== _

&gt;&gt; if x [print "-some- signal for saying it's okay seems right..."]
-some- signal for saying it's okay seems right...
</code></pre>
<p>But we see it's suboptimal, as now X is valued... and conflates with if we had written <strong><code>take [_]</code></strong>.  It also seems the need for the TRY in this case should have been independent of whether you stored the result in a variable or not.</p>
<p>Definitional errors come in and clean this mess up... so that TRY can defuse the take and give you the NULL state you want:</p>
<pre><code>&gt;&gt; x: take []
** Error: TAKE of EMPTY block, use TRY if you meant to do that

&gt;&gt; x: try take []
; null
</code></pre>
<h2>But Now How Do We Interconvert BLANK! and NULL?</h2>
<p>You're still going to come across situations where you pick a blank out of a block, where it's representing a null intent.  And it's illegal to compose or append nulls to blocks / etc, so how do you convert them?</p>
<p>Meet REIFY and DECAY.</p>
<pre><code>&gt;&gt; reify null
== _

&gt;&gt; decay _
; null
</code></pre>
<p>We actually have new members of this family: the conversion of isotopes to quasiforms.</p>
<pre><code>&gt;&gt; true
== ~true~  ;  isotope

&gt;&gt; append [a b c] true
** Error: Cannot append ~true~ isotope to block, use REIFY for quasiform

&gt;&gt; append [a b c] reify true
== [a b c ~true~]

&gt;&gt; append [a b c] as word! true
== [a b c true]
</code></pre>
<p>I think the words are a nice coupling...and even the same number of letters!</p>
<h2>What Will OPT Do Now?</h2>
<p>I'm not sure.  I'm actually pulling back a bit on the idea of saying that what happens in PARSE is a TRY... because in essence there's always a built-in "TRY" during parse.  Rules are raising definitional errors, but that's just swept under the rug by the parse process itself.  So OPT kind is kind of a different shade of meaning there.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/better-answers-than-try-and-opt-for-blank-null/1946">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/better-answers-than-try-and-opt-for-blank-null/1946</link>
          <pubDate>Sun, 28 Aug 2022 16:39:55 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1946</guid>
          <source url="https://forum.rebol.info/t/better-answers-than-try-and-opt-for-blank-null/1946.rss">Better Answers than TRY and OPT For BLANK! &lt;=&gt; NULL</source>
        </item>
        <item>
          <title>JUST For Sale - Low Mileage, Original Owner, Like New</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>As the /ONLY debacle was chipped away at... slowly... the role of quoting came to the forefront.  Quotes were used to <em>suppress</em> splicing (in contrast with today's isotopic blocks through SPREAD, which <em>request</em> the splicing).</p>
<p>So the anti-spread behavior looked something like:</p>
<pre><code>&gt;&gt; append [a b c] first [[d e]]
== [a b c d e]

&gt;&gt; append [a b c] first ['[d e]]
== [a b c [d e]]
</code></pre>
<p>I'm picking out of an outer block there just to avoid confusion, because notice what happens when there's no container:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c d e]

&gt;&gt; append [a b c] '[d e]
== [a b c d e]
</code></pre>
<p>By design, the evaluator strips off quotes, leading to potential confusion when it comes to what people might think they could do with such a system.</p>
<p>You might think that this is all fine and you could just call the function QUOTE instead of putting a quote mark on the value.  Hence the quoted block is an evaluation <em>product</em> not an evaluation <em>input</em>...and so it makes it to the append:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c d e]

&gt;&gt; append [a b c] quote [d e]
== [a b c [d e]]
</code></pre>
<p>But there were protections that were added to try and discern if you were adding non-inert values without quoting them.</p>
<pre><code>&gt;&gt; append [a b c] "this was presumed okay since it was inert"
== [a b c "this was presumed okay since it was inert"]

&gt;&gt; append [a b c] 'd
** Error: d is a WORD! and evaluative...your callsite might accidentally lose an
    apostrophe if you didn't know what you were doing.  Quote it to be safe.
</code></pre>
<p><em>(Note: I always disliked how these errors were working, I just hadn't gotten to the isotope design yet.  They did afford some protection.)</em></p>
<p>This would lead you to a couple of bad options to work with the case when you had something evalutative at source level:</p>
<pre><code>&gt;&gt; append [a b c] quote 'd
== [a b c d]

&gt;&gt; append [a b c] ''d
== [a b c d]
</code></pre>
<p>In an attempt to make the "just add a thing at source level" case a slight bit easier, I made JUST.</p>
<pre><code>&gt;&gt; just d
== 'd

&gt;&gt; append [a b c] just d
== [a b c d]
</code></pre>
<h3>Let's Take A Moment To Be Thankful For Isotopes...</h3>
<p>All of this is behind us now.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/pray.png?v=9" title=":pray:" class="emoji only-emoji" alt=":pray:"></p>
<p>But of course, the mechanics are actually nearly identical.  Just subtract 1 from all the quoting levels, and allow -1 for BLOCK!s.  <em>(Then build upon years of diligence in bulletproofing the system from leaking -1 quotelevels where they shouldn't be.)</em></p>
<h2>But JUST is Free Again.  Now What?</h2>
<p>There was a time when JUST was what I now call THE.</p>
<pre><code>&gt;&gt; just x
== x

&gt;&gt; just ''[foo]
== ''[foo]
</code></pre>
<p>I thought it was a good word for it at the time.  But THE won me over:</p>
<pre><code>&gt;&gt; the x
== x

&gt;&gt; the ''[foo]
== ''[foo]
</code></pre>
<h3>Maybe Something That Limits to One Expression Only?</h3>
<pre><code>&gt;&gt; just add 1 2
== 3

&gt;&gt; just add 1 2 10
** FAIL: JUST code had residual material: 10
</code></pre>
<p>I've been wanting a syntax for this at the API level, when you think you're running one expression:</p>
<pre><code>REBVAL* sum = rebJust("add", value1, value2, "10");
</code></pre>
<p>In that world, it's not any more typing (actually less typing than rebValue)...but gives you an extra bit of safety.</p>
<p>With regular (non-API) code, I can see it being very useful in generated code scenarios.</p>
<h3>Perhaps A THE-like Operator With A Shade of Meaning In PARSE?</h3>
<p>PARSE needs to keep raw material sometimes, and I've pointed out some of the hazards in the past of making you do this with GROUP!s when nested compositions are involved.</p>
<p>So might these be different?  As an example:</p>
<pre><code>parse ... [x: the ''foo] =&gt; parse ... [x: (the ''foo)]

parse ... [x: just ''foo] =&gt; parse ... [x: '''foo]
</code></pre>
<p>So above, THE is synthesizing ''foo out of whole cloth with no need to match it in the input.  The other would require a ''foo in the input to be considered a match.</p>
<p>For WORD!s, the above sense of JUST isn't as necessary, as there's a decent visual trick:</p>
<pre><code>parse ... [x: just ''foo] =&gt; parse ... [x: '|''foo|]
</code></pre>
<p>But other datatypes would not have this out, and you'd always be reading the thing you see in the rule as having one more quote level than what you're matching.</p>
<p>There's the option of putting it in an @ group:</p>
<pre><code>parse ... [x: just ''foo] =&gt; parse ... [x: @(the ''foo)]
</code></pre>
<p>But this has the problems I mention about nested composition that can be a major hassle when writing rule genreators and you have to weasel something like <strong><code>''foo</code></strong> inside a group inside a composed block.</p>
<p>This definition might jibe with keeping the regular evaluator meaning of JUST as it is (literal but add a quoting level).</p>
<h3>Other Ideas?</h3>
<p>Hopefully no one wants to fight to swap JUST with THE, because I really like THE as it is.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/just-for-sale-low-mileage-original-owner-like-new/1923">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/just-for-sale-low-mileage-original-owner-like-new/1923</link>
          <pubDate>Fri, 19 Aug 2022 03:09:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1923</guid>
          <source url="https://forum.rebol.info/t/just-for-sale-low-mileage-original-owner-like-new/1923.rss">JUST For Sale - Low Mileage, Original Owner, Like New</source>
        </item>
        <item>
          <title>&quot;I&#39;m not BAD!...I&#39;m just MOLD-ed that way...&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>I'm tinkering with an implementation of <a href="https://forum.rebol.info/t/should-everything-have-an-isotopic-form/1889/5">fully generic isotopes</a>.  The idea is that all types have an isotopic form, and routines can choose to react to this isotopic form giving it special meaning.</p>
<p>This means the tilde markings which used to designate a BAD-WORD! would be ways of making any value isotopic:</p>
<pre><code>&gt;&gt; ~foo~
== foo  ; isotope

&gt;&gt; ~[d e]~
== [d e]  ; isotope

&gt;&gt; ~1020~
== 1020  ; isotope

&gt;&gt; ~#[datatype word!]~
== #[datatype word!]  ; isotope
</code></pre>
<p>The notation is not an isotope itself, it's just used to produce them.  And if you're looking in an object and see it molds out fields that are these and non-quoted, that implies that the field itself actually holds an isotope.</p>
<pre><code>&gt;&gt; obj: make object! [x: spread [d e], y: ~[d e]~, z: '~[d e]~]
== make object! [
    x: ~[d e]~
    y: ~[d e]~
    z: '~[d e]~
]

&gt;&gt; obj.x
** Error: obj.x is a BLOCK! isotope, use ^META to access

&gt;&gt; obj.y
** Error: obj.y is a BLOCK! isotope, use ^META to access

&gt;&gt; obj.z
== ~[d e]~
</code></pre>
<p>So you can see how the notation works with the generic form, and can be quoted itself.</p>
<h2>I Kind Of Want To Curtail Use Of These In Source...</h2>
<p>The original thought about BAD-WORD! was that their ugly notation was supposed to be used to draw attention to them.  So like in the object molding above, you'd be able to see where the isotopes were and it would guide your eyes to the problem.</p>
<p><em>And in fact, I'm not even 100% sure that we want to support storing isotopes in variables unless we absolutely have to.</em>  Perhaps isotopic blocks would generate errors if you tried--and it would force you to use a ^META operation to persist it.  But a representation that evaluates to them is needed for mechanical reasons either way.</p>
<p>Nevertheless, you <em>could</em> use them to do things like splicing literal blocks:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c [d e]]

&gt;&gt; append [a b c] ~[d e]~
== [a b c d e]
</code></pre>
<p>It would actually be an efficient way to do it, but I feel like it might numb people to the squiggles...which are intended to draw attention to cases where the isotopes leaked through an operation and shouldn't have.  So best practices would suggest using operators instead</p>
<pre><code>&gt;&gt; append [a b c] spread [d e]
== [a b c d e]
</code></pre>
<h2>But The ~XXX~ Forms Need A Name... Is It BAD! ?</h2>
<p>I'd called ~xxx~ a BAD-WORD!.  Now that the tildes are a generic container kind of like QUOTED!, that would default to just being... BAD!</p>
<pre><code>&gt;&gt; type of fourth [a b c ~[d e]~]
== #[datatype! bad!]
</code></pre>
<p>So there's going to be a whole naming situation for operations to get the contained item out, and what to call this container.</p>
<p><em>(If it's so BAD, does it need to be... REFORMed?  <img src="https://forum.rebol.info/images/emoji/twitter/stuck_out_tongue.png?v=9" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"> )</em></p>
<p>I don't know how to fit this into the isotope naming scheme...it's a thing that generates isotopes when it evaluates.  The analogy breaks down if you try to call it a NUCLEUS or something odd like that.</p>
<p>Calling the ~xxx~ forms BAD! does have the advantage of being able to combine that and say ~[d e]~ is a "bad block" and ~1020~ is a "bad integer", but... you'll see these in well-formed programs.  It makes it sound like something is <em>corrupt</em>, when the real intent is different.</p>
<p>It could be called QUASI! which could related it to QUOTED!.  <em>"~[d e]~ is a quasi-block"</em></p>
<p>Bear in mind they can be quoted, so <code>'~[d e]~</code> would then be a "quoted quasi-block".  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>In some sense, [d e] and ~[d e]~ and '[d e] and ''[d e] could all be thought of as "isotopes" of blocks...in addition to what we call the "isotope" form (which has no representation, because it's something you can only measure by turning it into another form).</p>
<p>So we might call ~[d e]~ a "block isotope", and then give some other name to the invisible status that it produces...?</p>
<pre><code>&gt;&gt; ~[d e]~  ; call this a block isotope?
== [d e]  ; then this could be... a... ghost block?
</code></pre>
<p>But overall my leaning is that I like calling the ephemeral form "isotope", because I think that captures its weird invisible/reactivity/decaying character.</p>
<h2>The Pejorative "BAD!" May Seem Harsh, But May Be Good?</h2>
<p>If the name can scare people out of trying to use these too much at source level, that's not the worst outcome.</p>
<p>But then there still have to be ways of getting the contents out.  QUOTED! has UNQUOTE and NOQUOTE to take off quoting layers, and QUOTE to add them on.</p>
<p>Right now I've got MAKE BAD! to produce them:</p>
<pre><code>&gt;&gt; make bad! 1020
== ~1020~

&gt;&gt; make bad! [d e]
== ~[d e]~
</code></pre>
<p>If we called them something like TOXIC! then there could be detox and toxify.  <img src="https://forum.rebol.info/images/emoji/twitter/radioactive.png?v=9" title=":radioactive:" class="emoji" alt=":radioactive:"></p>
<p><strong>There's plenty to be involved with working out the mechanics and not worrying about the names, but wanted to put the naming issue out to be mulled over.</strong></p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/im-not-bad-im-just-mold-ed-that-way/1911">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/im-not-bad-im-just-mold-ed-that-way/1911</link>
          <pubDate>Fri, 05 Aug 2022 09:33:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1911</guid>
          <source url="https://forum.rebol.info/t/im-not-bad-im-just-mold-ed-that-way/1911.rss">&quot;I&#39;m not BAD!...I&#39;m just MOLD-ed that way...&quot;</source>
        </item>
        <item>
          <title>ALL [...] vs. CASE/ALL</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <blockquote>
<p><em>(Note: This is from an old post 4 years ago that was bundled with <a href="https://forum.rebol.info/t/any-vs-parses-any-can-we-have-consistency/741">complaints about PARSE's ANY</a>.  The ANY issue turned into its own whole universe of study...however, this question got brushed aside.  I'm making it it's own thread, now.)</em></p>
</blockquote>
<p>ALL is a <em>short-circuit</em> construct. The first time it sees a falsey thing, it stops.</p>
<pre><code>&gt;&gt; all [(probe 1) (probe 2 false) (probe 3)]
1
2
; null
</code></pre>
<p>But CASE/ALL is <em>explicitly not short-circuit</em>.  It takes away CASE's short-circuiting...where the /ALL makes it evaluate <em>every</em> condition.  So it will potentially run branches even after it has seen falsey conditions:</p>
<pre><code>&gt;&gt; case/all [true [probe 1] false [probe 2] true [probe 3]]
1
3
== 3
</code></pre>
<p>Ren-C chose to make CASE/ALL return <em>the evaluation of the branch associated with the last truthy condition</em>. (Rebol2 and Red just return false if the last condition was falsey.) That aside, both of them evaluate "all of the cases".</p>
<p>This also applies to SWITCH, which has an /ALL refinement as well.</p>
<p><strong>Could we have a word for something that wasn't short-circuit, yet evaluated "all" of the conditions...and just returned the last truthy one or NULL?</strong></p>
<h2>
<code>CASE/MULTI</code> ? <code>CASE/MANY</code> ?</h2>
<p>I just think that using CASE/ALL is misleading when put up against ALL, which is another native control structure...defined in the same file.  Having ALL mean something entirely opposite irks me.</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/all-vs-case-all/1874">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/all-vs-case-all/1874</link>
          <pubDate>Tue, 12 Jul 2022 04:30:55 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1874</guid>
          <source url="https://forum.rebol.info/t/all-vs-case-all/1874.rss">ALL [...] vs. CASE/ALL</source>
        </item>
        <item>
          <title>Discouraging use of TRAP</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>With <a href="https://forum.rebol.info/t/fail-vs-return-fail-the-new-age-of-definitional-failures/1852">definitional errors</a>, the landscape changes considerably for how we think about error handling.</p>
<p><strong>In this world, there are <em>not a lot of good reasons</em> to use what we've been calling "TRAP".</strong> (historical Redbol's TRY)</p>
<p>By its design, TRAP will intercept <em>any</em> error in code at <em>any</em> depth.  I've shown that when ATTEMPT was based on this, it was not good:</p>
<pre><code>&gt;&gt; attempt [print "Attempting to read file" read %nonexistent-file.txt]
Attempting to read file
; null

&gt;&gt; attempt [print "Attempting but made typos" rread %nonexistent-file.txt]
; null
</code></pre>
<p>That's fixed now, because ATTEMPT is based on REDUCE-EACH with a ^META variable.</p>
<p>But back to TRAP.  The problem isn't just about typos.  It's about the illusion that there's something you can do to react to an arbitrary error...when the constructs you were using didn't even understand it well enough to pipe it through to their output.</p>
<p><strong>In almost all cases, a "TRAP"'d error cannot be reacted to sanely...it has to be reported.</strong></p>
<p>It's for this reason that languages like Rust pretty much enforce a panic</p>
<p>And our case is even more compelling.  For example: How many places is it ever a good idea to sweep a typo under the rug, and just run some other code?</p>
<p>The few cases it's legitimate are things like the console...where you trap the error and present it, so the user knows it happens and can do something about it.  <em>This sort of thing is nearly the only legitimate usage of TRAP.</em></p>
<h2>Might We Make It Look More "Special" To Discourage Use?</h2>
<p>I thought at minimum we should move it to a place that shows it's more of a "system utility" than a "language feature".</p>
<p>So calling it <strong><code>SYS.UTIL.TRAP</code></strong> would be a step in that direction.</p>
<p>And as long as we're discouraging use of this, it seems a bit of a waste to take such a short name.  It could be <strong><code>SYS.UTIL.TRAP-ANY-ERROR</code></strong> or similar, and then TRAP could be used for something should be used more often.</p>
<p>(It could act like ATTEMPT, but evaluate to the error as its primary result instead of the body of the block.)</p>
<p>Things to think about.  Anyway, I've made some progress on definitional errors in the scanner and with TO and MAKE operations, so some of the things people like to trap (like conversions) should work correctly with attempt now.</p>
<p>For instance, in this finite-integer world... an out of range error:</p>
<pre><code>&gt;&gt; attempt [to integer! "10483143873258978444434343"]
; null

&gt;&gt; attempt [to intgeer! "10483143873258978444434343"]
** Script Error: intgeer! word is attached to a context, but unassigned

&gt;&gt; to integer! "10483143873258978444434343" except e -&gt; [print ["Error:" mold e]]
Error: make error! [
    type: 'Script
    id: 'bad-make-arg
    message: ["cannot MAKE/TO" :arg1 "from:" :arg2]
    near: [to integer! "10483143873258978444434343" ** except e -&gt; ***]
    where: [to args]
    file: '
    line: 1
    arg1: #[datatype! integer!]
    arg2: "10483143873258978444434343"
]
</code></pre>
<p>Should be a more specific error, now that I look at that.  But I guess it just wasn't.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/discouraging-use-of-trap/1871">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/discouraging-use-of-trap/1871</link>
          <pubDate>Sun, 10 Jul 2022 16:05:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1871</guid>
          <source url="https://forum.rebol.info/t/discouraging-use-of-trap/1871.rss">Discouraging use of TRAP</source>
        </item>
        <item>
          <title>Renaming MAP! to DICTIONARY!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>Rebol's historical leaning was to give things "plain names", even when that ran counter to computing tradition.</p>
<p>(For instance DECIMAL! was called that instead of what it really was... a FLOAT!, because "floating point" is too techie a concept.  Yet "decimal" means a different type of numeric representation underlying the math.  Red reversed this decision, and calls floating point numbers FLOAT!)</p>
<p><strong>There has been rough consensus that MAP should be a verb, for applying an operation across a data structure.</strong></p>
<p>To recap, with Ren-C's concept of generators, we could make a generator called EACH</p>
<pre><code>&gt;&gt; gen: each [1 2]

&gt;&gt; gen
== 1

&gt;&gt; gen
== 2

&gt;&gt; gen
; null
</code></pre>
<p>And then we've talked about how FOR would call the generator repeatedly until it hit NULL, returning the last body result:</p>
<pre><code>&gt;&gt; for x each [1 2] [print [x], x * 10]
1
2
== 20
</code></pre>
<p>So MAP has been suggested as being the version that collects the body results as you go:</p>
<pre><code>&gt;&gt; map x each [1 2] [print [x], x * 10]
== [10 20]
</code></pre>
<p>Seems pretty neat and composable, huh?</p>
<p>But this makes it feel like calling a datatype MAP! just muddles things.</p>
<p>DICTIONARY! is a bit long to write out, but... people seemed to tolerate "refinement".  Same number of letters (and wider in a non-fixed width font...)</p>
<pre><code>DICTIONARY!
REFINEMENT!
</code></pre>
<p>DICTIONARY<br>
REFINEMENT</p>
<p>...so dictionary doesn't really seem so bad, if you ask me.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/renaming-map-to-dictionary/1856">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/renaming-map-to-dictionary/1856</link>
          <pubDate>Fri, 01 Jul 2022 16:06:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1856</guid>
          <source url="https://forum.rebol.info/t/renaming-map-to-dictionary/1856.rss">Renaming MAP! to DICTIONARY!</source>
        </item>
        <item>
          <title>What to call an Arity-1 wget or curl-like function?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1840">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>At first I just did a <strong>wget</strong> of the scripts:</p>
</blockquote>
</aside>
<p>I've felt for a while we need something parallel to wget where you just specify a URL! of what you want and it writes it.</p>
<p>Calling it <strong>wget</strong> or <strong>curl</strong> would come with expectations that it would have all the options of those programs <em>(I think we could/should make variadic WGET and CURL functions that emulate a useful subset of those options!)</em></p>
<p>Is there a good name for a simpler arity-1 function that just does the above?</p>
<pre><code>xxx: func [filename [file! url!]] [
    write (second split-path filename) (read filename)
]</code></pre>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/what-to-call-an-arity-1-wget-or-curl-like-function/1841">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-to-call-an-arity-1-wget-or-curl-like-function/1841</link>
          <pubDate>Tue, 14 Jun 2022 11:46:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1841</guid>
          <source url="https://forum.rebol.info/t/what-to-call-an-arity-1-wget-or-curl-like-function/1841.rss">What to call an Arity-1 wget or curl-like function?</source>
        </item>
        <item>
          <title>Singular ANY-SPACE vs. Plural WHITESPACE?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>Transitions have made some parse rules get longer:</p>
<pre><code> [any whitespace]  ; being repurposed--seems like "pick one" not a loop construct
 =&gt;
 [while whitespace]  ; being repurposed to arity-2; arity-1 form is unsettling
 =&gt;
 [opt some whitespace]  ; null if rule doesn't match, a little ugly
 =&gt;
 [maybe some whitespace]  ; void if rule doesn't match, longer but prettier
</code></pre>
<p>I like MAYBE and I've explained the reasons why I like pulling the optionality out from the looping construct.</p>
<p>But this seems a bit overlong...especially considering that whitespace is such a long word.</p>
<p>It occurs to me that "whitespace" can be itself plural.  Might we say that ANY-SPACE is a character set, and then <strong><code>whitespace: [some any-space]</code></strong> ?</p>
<p>This at least gets you down to <strong><code>[maybe whitespace]</code></strong> or <strong><code>[opt whitespace]</code></strong>...which seems pretty minimal for the intent (unless you're going to go with abbreviations like <strong><code>ws*</code></strong> or similar).</p>
<p>I really don't know how many cases there are where you are willing to tolerate only a single unit of an arbitrary whitespace character.  When does that come up?  Usually if you're matching a single whitespace character you know which one you're reacting to...and the only time you'd ever bundle up a collection of them together is when you're willing to skip a lot of it.</p>
<p>I doubt there'd be many uses of ANY-SPACE in a rule, and that it would just be used to compound other character collections.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/singular-any-space-vs-plural-whitespace/1828">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/singular-any-space-vs-plural-whitespace/1828</link>
          <pubDate>Thu, 19 May 2022 09:05:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1828</guid>
          <source url="https://forum.rebol.info/t/singular-any-space-vs-plural-whitespace/1828.rss">Singular ANY-SPACE vs. Plural WHITESPACE?</source>
        </item>
        <item>
          <title>WHILE [Cold Feet]</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p><strong>I'm really certain that ANY should not be a looping construct in PARSE.</strong>  Rebol's use of ANY everywhere else means "any one of", not "any number of".  That applies to the ANY short-circuit-OR operation, to the ANY-XXX! types, and it can come up in PARSE such as:</p>
<pre><code>parse block [some any-value!]
</code></pre>
<p>I like the shorthand for this this that works across series types with the TAG! combinator:</p>
<pre><code>uparse block [some &lt;any&gt;]
</code></pre>
<p>This meaning <em>any one element</em>.  It gets at that English concept that operators like <strong><code>*</code></strong> (or <strong><code>&lt;*&gt;</code></strong>) just don't have.</p>
<p>Plus, the "zero-or-more matches of a rule" interpretation doesn't jibe with how we use ANY in English:</p>
<ul>
<li>"Do you have ANY bananas?"</li>
<li>"Yes."</li>
<li>"Cool.  Can I have one, then?"</li>
<li>"No, sorry.  I don't have ANY."</li>
</ul>
<h2>But I'm Not Happy With Bending WHILE For This</h2>
<p>It seemed appealing at first to say that WHILE would be standardized in the language as arity-1, both in PARSE and in ordinary code loops.  This would make UNTIL and WHILE line up, and LOOP could take the arity-2 role that WHILE used to have.</p>
<p>But I've been lamenting <strong><a href="https://en.wikipedia.org/wiki/While_loop">just how universally WHILE is arity-2 in pretty much every language</a></strong> and that LOOP doesn't really quite cut it while reading.  :-/</p>
<p>Sorry for the flux, but I want to move back to <strong>while [condition] [body]</strong> as it was.  However going through the process has spurred thought...</p>
<h2>An Observation: OPT SOME &lt;=&gt; WHILE</h2>
<p>It has in the past occurred to me that PARSE's WHILE (or ANY) was really OPT SOME.  It's three more characters to say it:</p>
<pre><code>while pattern
opt some pattern
</code></pre>
<p><em>(Note: This is only true in modern Ren-C, as previously the progress requirement differentiated these...that is now broken out into FURTHER.)</em></p>
<p>...but although it's more characters, "optionally some number of occurrences of the pattern" is pretty literally what you are talking about.  In the UPARSE model of synthesized values it's kind of less confusing, because it's clearer what it returns in the case of nothing...the same thing OPT always returns when a rule doesn't match: NULL.</p>
<p>Anyway, I'm feeling remorse and a wish to go back to WHILE for arity-2 loops in the language.  But I don't want to go back to ANY in PARSE.</p>
<h2>Is OPT SOME really so bad?</h2>
<p><strong>I've gotten to wondering if there is a reason we don't have a separate word for "zero or more" in English.  You actually have to write out "zero or more" to convey that intent... <em>maybe because the intent is too weird for a single word</em>.</strong></p>
<p>When you just write WHILE it may be that you have a case that's actually supposed to be a SOME but it hasn't really bit you yet.  If you're willing to tolerate between 1 and a million of something, the case of no things being there is distinguished...and calling attention to the fact that the rule you have may not match at all can be an asset.</p>
<p>I actually think OPT SOME offers an advantage, because it encourages you to look at it and decide if the OPT belongs there or not.  It may feel kind of like a wart, but maybe it's a helpful wart.</p>
<p>(It reminds me a bit of the UNLESS vs. IF NOT situation.  Many people felt UNLESS is actually obfuscating nearly everywhere it's used, and that it's better to break it apart even if that means two words instead of one.)</p>
<h2>Trying Out The Change, I Noticed...</h2>
<p>I actually did find a difference how I read the code.  "This entire next section may not be relevant... <em>none</em> of it could match and it would go on."  That weight of the OPT is felt more heavily when the word is there than the WHILE...which if you <em>frequently</em> expect the thing to be there, you may assume it will <em>always</em> be there for at least one instance.</p>
<p>You also can see redundancy in OPT more clearly.  Things like:</p>
<pre><code>opt [
    while [...]
]
</code></pre>
<p>Stand out more if they look like:</p>
<pre><code>opt [
   opt some [...]
]
</code></pre>
<p>I think some things really do read more clearly.  You can look at this as removing 0 or more newlines at the head of a series via a WHILE:</p>
<pre><code>parse series [
    remove [while newline]
    ...
]
</code></pre>
<p>Or rephrase that with OPT SOME:</p>
<pre><code>parse series [
    remove [opt some newline]
    ...
]
</code></pre>
<p>But I think it reads clearest when you bring the OPT outside, to say you're <em>optionally removing some newlines</em>:</p>
<pre><code>parse series [
    opt remove [some newline]
    ...
]
</code></pre>
<h2>More Distinct</h2>
<p>ANY and WHILE both had the problem that they had analogues in imperative code.  But if SOME remains a PARSE keyword, then this helps better intuit the difference...so the code looks more differentiable.</p>
<h2>Compression Is Possible By Other Avenues</h2>
<p>I noticed a particularly laborious substitution in %make-zlib.r which extracts the headers and code for zlib using parse, because it often was parsing C code and looking for the pattern <strong><code>while whitespace</code></strong>.  This would happen multiple lines in a row and multiple times on a line.  When it became <strong><code>opt some whitespace</code></strong> it got more annoying.</p>
<p>But this is kind of a problem anytime you repeat something over and over.  Maybe that pattern should have been <strong><code>ws*: [opt some whitespace]</code></strong> and then it would just be <strong><code>ws*</code></strong> to mean "any number of whitespace characters here, including zero".</p>
<h2>A Motivated Individual Can Overrule It</h2>
<p>Remember, UPARSE is going to let you be the judge.  If you want your own keywords, you can have them.  Maybe you like MANY (some parser combinators seem to think that 0...N is "many" and 1...N is "some").  Maybe you don't care if WHILE is different.  Maybe you don't want to use the ANY parse abstraction that I think is more interesting.</p>
<h2>I'm Trying It Out</h2>
<p>One can argue there's a bit of a 1984-newspeak to it ("you don't need words like better or worse, use plus-good and un-good and double-plus-ungood").  But we're sort of asking a programming language to be more "nuanced" in its wording than English, which has evolved to be pretty much where the brain is at.  I've shown some concrete benefits here to breaking out the OPT so you can see its relationship to the other OPTs you have and move it around.</p>
<p>I do know I'm getting cold feet on the WHILE &lt;=&gt; LOOP change.  And I don't think the arity of WHILE in PARSE should be different from the arity of WHILE in the language, it's jarring.</p>
<p>I'm giving it a shot in the bootstrap and rebmake to see what kind of thoughts it inspires.  So far it seems to be around equally good and bad...and since the bad is just largely unfamiliarity which should wear off...that points to a win, especially since it means retaking WHILE.</p>
            <p><small>8 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/while-cold-feet/1772">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/while-cold-feet/1772</link>
          <pubDate>Sun, 12 Dec 2021 05:02:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1772</guid>
          <source url="https://forum.rebol.info/t/while-cold-feet/1772.rss">WHILE [Cold Feet]</source>
        </item>
        <item>
          <title>&quot;DEBUG&quot; builds vs &quot;CHECKED&quot; builds</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>Since this is a language project, the term "Debug" winds up having a bit of an overloaded meaning.</p>
<p>In an ideal world--and this ideal world will hopefully come to pass--the system will have a debugger in the interpreter for helping people diagnose their code.</p>
<p>But then, there is instrumentation added to the system itself--for its own debugging.  Today we call that "a debug build" of the interpreter.</p>
<p>This is pretty standard--when you ask for a debug build of something, that means it has symbols and asserts in it.  It's a known term in the development culture.  Julia or Python or whoever calls their instrumented version <em>"The Debug Build"</em></p>
<p><a href="https://pythonextensionpatterns.readthedocs.io/en/latest/debugging/debug_python.html" class="inline-onebox">10.2. Building and Using a Debug Version of Python — Python Extension Patterns 0.1.0 documentation</a></p>
<p>But there is another term used in the kernel and OS world called a "checked build".</p>
<h2>Would Calling It A "Checked Build" Be Clarifying or Confusing?</h2>
<p>I feel like reserving the term "debug" to use for features related to what the user would call debugging of <em>their</em> code may make more sense--even though this may be a bit odd for a language project vs. an OS one.</p>
<p>Plus the flag names make more sense.  Take a flag with a name like DEBUG_UTF8_EVERYWHERE... if it were CHECK_UTF8_EVERYWHERE that sort of gives a better impression of what's going on.  <em>You're asking for instrumentation</em> that runs independent of whether you actually are debugging anything.  In fact, you can add these checks while not having any "debug symbols" in your build.</p>
<p>I happen to be doing some tweaks that make this a good time for such changes if they are to be made.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/debug-builds-vs-checked-builds/1708">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/debug-builds-vs-checked-builds/1708</link>
          <pubDate>Thu, 09 Sep 2021 14:53:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1708</guid>
          <source url="https://forum.rebol.info/t/debug-builds-vs-checked-builds/1708.rss">&quot;DEBUG&quot; builds vs &quot;CHECKED&quot; builds</source>
        </item>
        <item>
          <title>Casting vs. SPELL</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>With my bolstered confidence that FILE! best serves as a non-string, I feel like it gives a certain amount of irresistable power.</p>
<pre><code>&gt;&gt; size of %foo.dat
== 143983  ; size of the foo.dat file on disk
</code></pre>
<p><em>(Note: My thinking on SIZE with strings is that it gives you a count in bytes, whereas LENGTH gives you a count in codepoints.  This distinction of "length is logical units" and "size is a byte count" has precedent in other systems...but I'd like to go through and make sure that it's being used consistently everywhere.  A BINARY! can use either since its logical size is 1, but I'd prefer to speak in terms of the size where possible...e.g. when the binary is not being discussed in the context of a generic length that would apply to any series)</em></p>
<p>Somewhat extremely, this would suggest I'd be saying that <strong>length of %foo.dat</strong> would be something that would delegate to whatever the port type was for that file...and give back the logical length of the contents.</p>
<pre><code>; contents of %foo.myformat
[record 1 "foo" #bar]
[record 2 "baz" #mumble]

&gt;&gt; length of %foo.myformat
== 2
</code></pre>
<p>We're imagining here that you're living in a world where a "myformat" port would act something like:</p>
<pre><code>&gt;&gt; p: open %foo.myformat

&gt;&gt; read/part p 1
== make object! [
    x: "foo"
    y: #bar
]

&gt;&gt; read/part p 1
== make object! [
    x: "baz"
    y: #mumble
]

&gt;&gt; read/part p 1
; null
</code></pre>
<p><strong>Of course I am making this all up.</strong>  But what I'm trying to get at is that when you want to talk about the attributes of something that is a representation of some grand thing, the number of characters in its name is potentially much less interesting than all the logical things you can ask about it.</p>
<p>That said...it should be easy to ask how long the name is.  And this is a little bit ugly:</p>
<pre><code>&gt;&gt; length of as text! %foo.dat
== 7
</code></pre>
<p>In the API I've used the word "spell" to talk about string extraction.  Might that look nicer?</p>
<pre><code>&gt;&gt; spell %foo.dat
== "foo.dat"

&gt;&gt; length of spell %foo.dat
== 7
</code></pre>
<p>I guess it could also be FORM.  Though FORM never quite sat right with me, I don't think of it so much as a verb in computer programming as a noun for "form you fill out".</p>
<p>Anyway, this is just to throw out there the idea of SPELL as a way to ask for the underlying string of something that may look a bit better than AS TEXT!.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/casting-vs-spell/1693">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/casting-vs-spell/1693</link>
          <pubDate>Mon, 30 Aug 2021 12:50:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1693</guid>
          <source url="https://forum.rebol.info/t/casting-vs-spell/1693.rss">Casting vs. SPELL</source>
        </item>
        <item>
          <title>Revisiting The Riddle of the .r</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>When Rebol was thinking about coming out of the shadows and participating in the greater programming community, it seemed like trying to own the <strong><code>.r</code></strong> file extension was a bit misguided.</p>
<p>After all: a well established and much more popular statistical language was using it.  It was also out first--it came out in 1993, 4 years before Rebol's 1997.</p>
<p>...aaand the name of the language <em>actually was "R"</em>.  Which isn't a name to get very excited about, so it's not like there was going to be some argument like <em>"no, WE want to call our language R!"</em></p>
<p>It seemed syntax highlighters on programming sites were not going to be allocating <strong>.r</strong> to Rebol.</p>
<p>Hence it seemed no problem to just go with changing to <strong><code>.reb</code></strong> - an improvement, even.  Communicated more.</p>
<h2>...But In The Timeless World...</h2>
<p>Since that time, things have changed:</p>
<ul>
<li>
<p>I've become more partial to the lack of "noise" when listing files in a directory when they end in <strong>.r</strong> ... it makes the important part of the filename pop more.</p>
</li>
<li>
<p>I had to help someone with their school project a couple years ago written in R.  I was not impressed with it.  While it has had growth lately, I think that growth just has more to do with the importance of data science... and does not reflect on the language itself (syntax/paradigm) having any particular merit.  It's just been around a long time and people are looking at data more.</p>
</li>
<li>
<p>Collisions in file extensions have led syntax highlighters to use more heuristics, driven by the file content as well as the overall content of a source repository.  It looks like this will only become more the way things work in the future.</p>
</li>
<li>
<p>Ren-C is renaming, to another name, which starts with R...  <img src="https://forum.rebol.info/images/emoji/twitter/rabbit.png?v=9" title=":rabbit:" class="emoji" alt=":rabbit:"> <img src="https://forum.rebol.info/images/emoji/twitter/raccoon.png?v=9" title=":raccoon:" class="emoji" alt=":raccoon:"> <img src="https://forum.rebol.info/images/emoji/twitter/recycle.png?v=9" title=":recycle:" class="emoji" alt=":recycle:"> <img src="https://forum.rebol.info/images/emoji/twitter/rocket.png?v=9" title=":rocket:" class="emoji" alt=":rocket:"> <img src="https://forum.rebol.info/images/emoji/twitter/robot.png?v=9" title=":robot:" class="emoji" alt=":robot:"></p>
</li>
<li>
<p>The strength of Ren-C's hand has been growing, and I think if it keeps going it might have strength to impose some aspect of its will.  Sharing the .r file extension may be something people are ready to just accept.  <em>(With a much weaker hand, Red managed to push along a claim on the choice of "red"...though it does seem to screw them a bit on searchability.)</em></p>
</li>
</ul>
<h2>So What Do People Think?</h2>
<p>Is rolling back to the historical <strong><code>.r</code></strong> a good way to detach a little more from the "Rebol" brand name, while still fitting into the ecology?</p>
<p>It's a thought.  No rush, just wanted to put the question out there.</p>
            <p><small>5 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/revisiting-the-riddle-of-the-r/1664">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/revisiting-the-riddle-of-the-r/1664</link>
          <pubDate>Sun, 15 Aug 2021 10:23:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1664</guid>
          <source url="https://forum.rebol.info/t/revisiting-the-riddle-of-the-r/1664.rss">Revisiting The Riddle of the .r</source>
        </item>
        <item>
          <title>Revisiting `&lt;opt&gt;` in the Func Spec Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <h2>First, Let's Look Briefly At The History Of <code>&lt;opt&gt;</code>
</h2>
<p>It was many years ago when <code>&lt;opt&gt;</code> first came on the scene as a way to say that a function argument would allow "NULL" as a possibility.</p>
<p>The reasoning was that there was a certain "state" which can be synthesized that represents a <em>non-value</em>.</p>
<blockquote>
<p>Note: Back then, the state was the result of excising reified UNSET! from the system--and it was called VOID--a term that means something rather different today.  <strong>To make things clearer I'm going to sanitize history here a bit and pretend like it was always called NULL.</strong></p>
</blockquote>
<p><strong>Meanness Level Alpha: You Can't Even ASK What Type a NULL Is</strong></p>
<p>In the earliest days, not only did NULL "not have a type"...it was not truthy or falsey...it generated errors when you tried to access it through words.  It went through several iterations of meanness.</p>
<p>This is basically where things started:</p>
<pre><code>&gt;&gt; select [a 10 b 20] 'c
; null

&gt;&gt; type of select [a 10 b 20] 'c
** Error: NULL Values Do Not Have Types
</code></pre>
<p>But that was a pain.</p>
<p><strong>Meanness Level Beta: You Can Ask, But The Answer Is Still A Mean NULL</strong></p>
<p><em>I was steadfast that there wasn't going to be a NULL! "datatype".</em>  But since NULL was the "non-answer" given back for a "non-valued" state...what if the TYPE OF a NULL was just... NULL?</p>
<pre><code>&gt;&gt; select [a 10 b 20] 'c
; null

&gt;&gt; type of select [a 10 b 20] 'c
; null
</code></pre>
<p>While it was pleasing at some level, it didn't change the fact that NULL was still mean, and not accepted a lot of places...much like an UNSET! had been in Rebol2:</p>
<pre><code>rebol2&gt;&gt; switch print "Rebol2" [10 [print "Disliked UNSET!s"]]
Rebol2
** Script Error: switch is missing its value argument
</code></pre>
<p>So the same problem would hit you all around the system if you were trying to do something with that NULL answer you got for types:</p>
<pre><code>&gt;&gt; switch type of select [a 10 b 20] 'c [
     integer! [...]
     block! [...]
]
** Error: SWITCH does not allow NULL as its VALUE argument
</code></pre>
<p><strong>Meanness Level Gamma: NULL Becomes Friendly</strong></p>
<p>Today we've gotten to a situation where NULL is generally pretty friendly and accepted a lot of places.  WORD!s can look up to NULL without erroring, so NULL doesn't need to be a "function that returns NULL".</p>
<pre><code>&gt;&gt; switch type of select [a 10 b 20] 'c [
     null [print "Everything works just fine!"]
     integer! [...]
     block! [...]
]
Everything works just fine!
</code></pre>
<p>The whole paradigm surrounding unsetness has gone through a great rethinking with BAD-WORD!s and isotopes that I'm still discovering the interesting nuances of, but it's light-years ahead of old methods.</p>
<h2>So...Back To TYPESET! Representation</h2>
<p>From the beginning I knew there was not going to be a NULL! "datatype".  And using NULL itself in a type block would be a bad idea.  It was too easy to wind up with NULL values on accident...they were used to represent unset values!</p>
<p>In those days, imagine if this had been the way to say "the typeset can include NULL":</p>
<pre><code>foo: func [arg [null integer! block!]] [...]
</code></pre>
<p>All right, but what if you had just some typo and a variable was <em>incidentally</em> null?</p>
<pre><code>foo: func [arg [intteger! block!]] [...]
</code></pre>
<p>Would you want that function to now accepts nulls and blocks?  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>Even though NULL no longer corresponds to "typo" states, it still is a state that values can be in for all kinds of reasons.  I think <strong>null = type of null</strong> is the right answer, but that doesn't mean that the way to indicate a function is willing to accept null as an argument is if any variable that happens to be NULL appears in the type spec.</p>
<p><strong>And NULL couldn't be in TYPESET! because you would have no way to FIND it -- FIND won't look for "NULL" in <em>anything</em>...and if it ever returns NULL that means the thing wasn't found.</strong></p>
<h2>So Why Exactly Have I Been So Opposed to a NULL! Datatype?</h2>
<p><em>I feel like I've always had a good reason.</em>  If a TYPE OF operation can make a reified thing spring into existence out of the absence of a thing, I feel like something is out of whack.</p>
<p>There's a clear advantage if you're going to be chaining things.</p>
<pre><code>x: (type of select data item) else [
    fail "A reified NULL! datatype doesn't permit this kind of handling"
]
</code></pre>
<p>Though that's a more modern intuition about it; I wasn't thinking about that when <code>&lt;opt&gt;</code> was made.</p>
<p>I think one angle is that I felt like the optionalness was somehow a "big deal" and needed to jump off the page for the spec more.  NULL! just blended in.</p>
<pre><code>foo: func [arg [null! integer! block!]] [...]
bar: func [arg [integer! block! group! path! null! word!]] [...]
</code></pre>
<h2>Modern Thought: <code>&lt;opt&gt;</code> =&gt; <code>[&lt;null&gt; any-value!]</code>
</h2>
<p>With the introduction of <a href="https://forum.rebol.info/t/implicit-execution-of-return-in-functions-bad/1656">new rules surrounding RETURN</a>, I've made it more painful to get the "default" return behavior of being able to RETURN whatever you want.</p>
<p>This made me think it might be nice to build on the PARSE meaning of <code>&lt;any&gt;</code> as a replacement for "SKIP" (e.g. match one ANY-VALUE!) to get an easy RETURN spec:</p>
<pre><code>foo: func [return: &lt;any&gt; ...] [...]
</code></pre>
<p>Then, <code>&lt;opt&gt;</code> could be shorthand for <code>[&lt;null&gt; any-value!]</code></p>
<pre><code>bar: func [return: &lt;opt&gt; ...] [...]
</code></pre>
<blockquote>
<p>I can also imagine <code>&lt;opt&gt;</code> being a UPARSE tag as a shorthand for <strong><code>opt &lt;any&gt;</code></strong>.</p>
<pre><code>&gt;&gt; uparse? [x: (stuff)] [sw: set-word!, g: group!, x: &lt;opt&gt;]
== #[true]

&gt;&gt; x
; null

&gt;&gt; uparse? [x: (stuff) "extra"] [sw: set-word!, g: group!, x: &lt;opt&gt;]
== #[true]

&gt;&gt; x
== "extra"
</code></pre>
</blockquote>
<p>In any case, <code>&lt;any&gt;</code> and <code>&lt;opt&gt;</code> would thus join the other "top-level" shorthands <code>&lt;none&gt;</code> and <code>&lt;void&gt;</code> for function typeset specs.  <strong>Such a shorthand feels pressing given my new strict rule regarding returns, I don't like having to type <code>[return: [&lt;null&gt; any-value!]]</code> just to be able to use RETURN.  I can put up with <code>[return: &lt;opt&gt;]</code> and <code>[return: &lt;any&gt;]</code></strong></p>
<h2>Newer, Weirder Options with More Datatypes</h2>
<p>There are actually more wacky and crazy ideas possible these days.  <img src="https://forum.rebol.info/images/emoji/twitter/crazy_face.png?v=9" title=":crazy_face:" class="emoji" alt=":crazy_face:"></p>
<p>We know that refinements like /ARG are optional, they may be NULL in which case that means they were not supplied.  <a href="https://forum.rebol.info/t/word-some-path-some-group-and-some-block/1125/21">I was just suggesting they might be the better branch notation for allow pure NULL to escape a branch.</a>  We could also make the type blocks build on this notation:</p>
<pre><code>foo: func [
    return: /[integer!]  ; alternative to today's [&lt;opt&gt; integer!]
    arg1 [block!]
    arg2 /[logic!]  ; alternative to today's [&lt;opt&gt; logic!]
][
    ...
]
</code></pre>
<p>But looking at it, I don't feel it communicates as well.  The tags just seem more literate.</p>
<p>For some reason, <code>&lt;null&gt;</code> looks oddly heavy though:</p>
<pre><code>foo: func [
    return: [&lt;null&gt; integer!]
    arg1 [block!]
    arg2 [&lt;null&gt; logic!]
][
    ...
]
</code></pre>
<p>I guess a lot of it is what you're used to, but null is such a "vertical" word, it's like it has two !! in it:</p>
<pre><code>foo: func [
    return: [&lt;opt&gt; integer!]
    arg1 [block!]
    arg2 [&lt;opt&gt; logic!]
][
    ...
]
</code></pre>
<p>I'm probably just being silly due to what I'm used to.  The <code>&lt;null&gt;</code> is clearer, and I kind of like my suggestion that <code>&lt;opt&gt;</code> be shorthand for <code>[&lt;null&gt; any-value!]</code>.</p>
<h2>I Know This Is Long, Just Thinking Out Loud</h2>
<p>I don't want to change anything until TYPESET! and DATATYPE! have more understanding.  But as it so happens, I think that the change to RETURN to make it the locus of typechecking on functions <em>is</em> a step forward in the type system conception.</p>
<p>Design happens one step at a time, folks.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/revisiting-opt-in-the-func-spec-dialect/1658">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/revisiting-opt-in-the-func-spec-dialect/1658</link>
          <pubDate>Fri, 13 Aug 2021 02:50:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1658</guid>
          <source url="https://forum.rebol.info/t/revisiting-opt-in-the-func-spec-dialect/1658.rss">Revisiting `&lt;opt&gt;` in the Func Spec Dialect</source>
        </item>
        <item>
          <title>Efficient Consuming Append-Like Operator... GLOM ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>So I'm looking at the question of how to take bits of material that may or may not be produced, that become owned by the recipient...and accumulate them.</p>
<p>For efficiency, I'd like an operator that will be null tolerant.  Like this:</p>
<pre><code>&gt;&gt; accumulator: null

&gt;&gt; result: make-some-stuff arg1 arg2 arg3
== ~null~  ; isotope (let's say it produced nothing)

&gt;&gt; accumulator: glom accumulator result
== ~null~  ; isotope (okay, that's a no-op)

&gt;&gt; result: make-more-stuff arg4 arg5 arg6
== [a b c]

&gt;&gt; accumulator: glom accumulator result
== [a b c]  ; since there was nothing in the accumulator, we take it

&gt;&gt; append accumulator [d]
== [a b c d]

&gt;&gt; result
== [a b c d]  ; it's okay to reuse result, protocol was we "own" it
</code></pre>
<p>This kind of operator is handy when synthesizing results up the stack.  Because it has carte-blanche to tear up the series its given, it could notice when the result array was larger than the accumulator and steal its memory to slide results into...rather than do a new allocation.</p>
<p>So after a GLOM the thing being appended (<code>result</code> above) will either be equivalent to the accumulator or it will appear to have been FREE'd.</p>
<p>The specific feature I'm looking to support with this is the "third result" I've been talking about for combinators, of their "pending" items...this would include collected things.  I don't want to have to be making new empty blocks with <code>copy []</code> just in case combinators want to add to the collection something...they may just come back with blanks.  So if the accumulator could start off as blank that would avoid these stray series creations most of the time.</p>
<p>I don't think allowing you to JOIN to a NULL and get a new series is a good idea, and it wouldn't be able to do the other optimizations either (since JOIN does not assume you are giving it ownership of the appended data to destroy as you wish).  So this is a distinct operator, and calling it <strong>GLOM</strong> is probably fine for now.  But thought I'd describe what it did just to put that out there.</p>
<p>Here is a usermode prototype:</p>
<pre><code>glom: func [
    return: "New accumulator value (may be blank or reused)"
        [blank! block!]
    accumulator [blank! block!]
    result
][
    if accumulator [
        append accumulator result
        elide if block? result [free result]  ; placeholder for stealing memory
    ] else [
        case [
            null? result [null]
            block? result [result]
            (append copy [] :result)
        ]
    ]
]
</code></pre>
<blockquote>
<p>Note that I'm using CASE fallout above, where if you don't pair up the clauses in a case it will just evaluate to the last condition:</p>
<pre><code>&gt;&gt; case [
      1 = 2 [print "math is broken"]
      10 + 20
   ]
== 30
</code></pre>
<p>Rebol2 and R3-Alpha report #[true] for that, while Red says #[none].  The only answers I'd consider for this would be 30 or raise an error.  I definitely like just being able to write a FAIL in that spot without having to say <strong><code>true [fail "..."]</code></strong>, and I guess that "laxness" makes me feel it's a nice place to put a default as well.  This is still an open question.</p>
</blockquote>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/efficient-consuming-append-like-operator-glom/1647">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/efficient-consuming-append-like-operator-glom/1647</link>
          <pubDate>Thu, 05 Aug 2021 09:36:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1647</guid>
          <source url="https://forum.rebol.info/t/efficient-consuming-append-like-operator-glom/1647.rss">Efficient Consuming Append-Like Operator... GLOM ?</source>
        </item>
        <item>
          <title>Verbing Nouns Revisited: COMBINATOR and COMB</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>We've long lamented the unfortunate nature of "verbing" nouns like FUNCTION.</p>
<p>And again, we have this situation where if we use COMBINATOR as the way of declaring a combinator, what do we call instances?  C?  COMB?</p>
<p>It feels a bit sad that we can't just write something like:</p>
<pre><code>combinator: select state.combinators group!  ; get the GROUP! combinator
</code></pre>
<p>If you do that, you're overwriting the function you use to make combinators.  And that's no good.</p>
<p>So I wind up writing:</p>
<pre><code>comb: select state.combinators group!  ; get the GROUP! combinator
</code></pre>
<p>But it seems that COMBINATOR rightly belongs to the <em>instance</em>, and the thing that makes combinators should be called something like MAKE-COMBINATOR.  If anything, COMB should be the shorthand for MAKE-COMBINATOR and we allow the word COMBINATOR for instances of combinators.</p>
<p>I got to wondering why we don't like MAKE-FUNCTION or MAKE-COMBINATOR.  <em>Is it the hyphen?</em>  What if it were <strong>make function</strong> and <strong>make combinator</strong> and it dispatched to the "makers" based on quoting the words?</p>
<p>This would create a little bit of confusion, but we've gotten used to:</p>
<pre><code>length: length of block
</code></pre>
<p>Why can't we accept:</p>
<pre><code>combinator: make combinator [...] [...]
</code></pre>
<p>I hate to beat this old dead horse again.  But FUNCTION is a noun.  COMBINATOR is a noun.  It still feels like something is wrong with verbing these nouns just for the sake of brevity and familiarity, and then having to contort the names of instances to avoid overwriting the verb.</p>
<p>NEW is shorter and not contentious with the historical meaning of MAKE:</p>
<pre><code>combinator: new combinator [...] [...]
</code></pre>
<p>It just seems like we're fighting against the English language to be using nouns wrong, just because other languages have done it.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/verbing-nouns-revisited-combinator-and-comb/1646">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/verbing-nouns-revisited-combinator-and-comb/1646</link>
          <pubDate>Thu, 05 Aug 2021 09:09:03 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1646</guid>
          <source url="https://forum.rebol.info/t/verbing-nouns-revisited-combinator-and-comb/1646.rss">Verbing Nouns Revisited: COMBINATOR and COMB</source>
        </item>
        <item>
          <title>Disambiguating `META OF` and the META-XXX! (^) Types</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>An idea that emerged early on in Ren-C was that there was often a need to associate an object with another object (or action), to give more information about it.</p>
<p>You could do this with a global MAP!.  But a built-in mechanism could be cheaper--and I foresaw the feature being foundational enough that efficiency would matter.  This would likely be needed for every ACTION!, every ERROR!, every MODULE!, and many other places...</p>
<p>This mechanism was called the "meta" information of the object or action.</p>
<h2>A New META in Town...</h2>
<p>But now, the existence of the new <strong>^word</strong>, <strong>^pa/th</strong>, <strong>^tu.p.le</strong>, <strong>^(gr o up)</strong>, <strong>^[bl o ck]</strong> types give a category known as META-WORD!, META-PATH!, META-TUPLE!, etc.</p>
<p>I'm confident that calling that META is good.  Given how foundational the technique is, I don't want to make understanding any harder by reusing the word for something completely unrelated.</p>
<p>It is likely that the lone word META will be a synonym for <strong>^</strong>, for those who don't like symbols.  Recall that it is lightly distinguished from QUOTE, e.g. that <strong>^ null</strong> is null (not <strong>'</strong>) and it tolerates isotopes, returning the non-quoted BAD-WORD!:</p>
<pre><code>&gt;&gt; ~asdf~
== ~asdf~  ; isotope

&gt;&gt; first [~asdf~]
== ~asdf~

&gt;&gt; meta ~asdf~
== ~asdf~

&gt;&gt; meta first [~asdf~]
== '~asdf~

&gt;&gt; meta null
; null
</code></pre>
<p>So what do we call the associated object?</p>
<ul>
<li>
<p><strong>auxiliary of ...</strong></p>
</li>
<li>
<p><strong>linked of ...</strong></p>
</li>
</ul>
<h2>Bigger Question: Is One Linked Object Enough?</h2>
<p>Over time I've come to wonder if keyed access is more important.  For instance, in JavaScript you are able to assign arbitrary field members to a function:</p>
<pre><code>&gt; function foo() {console.log("foo.x is " + foo.x + " and foo.y is " + foo.y)}
&gt; foo.x = 10
&gt; foo.y = 20

&gt; foo()
&lt;- foo.x is 10 and foo.y is 20
</code></pre>
<p>Now that we can discern field access (foo.x) from refinement usage (foo/x), it makes it very tempting to follow suit and say that actions have arbitrary keyed fields like this.  This could be where the help lives.</p>
<p>If this was the case, then there's no need for a "meta" object or naming it.  You simply use dots.</p>
<p>This would require a re-imagining of how MODULE! works, but that's already happening in "Sea of Words".  So it might mean that you can't link an arbitrary object to another object...you'd make maps...which is what every other language does instead of having a "secret" place to scribble on.</p>
<p>In any case, it is likely that the old sense of META is going away entirely (though the mechanic it relies on would be exposed another way).  We'll see...</p>
<p>Internally in the macros I'm thinking of calling it something like AUX_OF() to replace macros like META_OF().  You run out of these words eventually.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/disambiguating-meta-of-and-the-meta-xxx-types/1631">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/disambiguating-meta-of-and-the-meta-xxx-types/1631</link>
          <pubDate>Thu, 01 Jul 2021 16:37:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1631</guid>
          <source url="https://forum.rebol.info/t/disambiguating-meta-of-and-the-meta-xxx-types/1631.rss">Disambiguating `META OF` and the META-XXX! (^) Types</source>
        </item>
        <item>
          <title>UNQUOTE and DEQUOTE too similar</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>I created two separate terms regarding removing quoting levels.</p>
<p>One was unquote, e.g. it removes one level:</p>
<pre><code> &gt;&gt; unquote first ['''a]
 == ''a
</code></pre>
<p>It has a /DEPTH refinement where you can say how many levels to remove (so the default depth is 1).  If there aren't enough levels it will error.</p>
<p>The other operation was DEQUOTE, which would remove all the quoting levels...it would not complain if something was not quoted:</p>
<pre><code> &gt;&gt; dequote first ['''a]
 == a

 &gt;&gt; dequote first [a]
 == a
</code></pre>
<p><strong>I've messed this up a lot and used the word DEQUOTE where I meant to say UNQUOTE.</strong> So those words are too close to each other.  There's really no great argument for why the meanings wouldn't be the same or swapped.  (e.g. "Why would something called UNQUOTE return a thing that still has quotes on it?")</p>
<p>Regardless of any counter-arguments, I do feel that UNQUOTE makes sense at the end of the day as removing one level of quote.</p>
<p>A refinement to UNQUOTE as something like UNQUOTE/FULLY (more descriptive) or UNQUOTE/ALL (shorter at the cost of clarity) might work:</p>
<pre><code>&gt;&gt; unquote/fully first ['''a]
== a
</code></pre>
<p>But it's always a bit unpleasing when you offer refinements that can't be mixed, like /DEPTH and /FULLY would be incompatible.</p>
<p>Also I think this might be kind of a common operation, to ask for the non-quoted essence of a value.</p>
<p>Perhaps NONQUOTED?</p>
<pre><code>&gt;&gt; nonquoted first ['''a]
== a
</code></pre>
<p>But I had aimed that QUOTED and such would be <em>type modifiers</em>, so QUOTED INTEGER! would give you a datatype representing quoted integers.</p>
<p>While all this makes me feel a bit more like excusing DEQUOTE, I have made too many mistakes mixing them up, and if I make them then other people certainly will...</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/unquote-and-dequote-too-similar/1626">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/unquote-and-dequote-too-similar/1626</link>
          <pubDate>Thu, 17 Jun 2021 18:57:19 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1626</guid>
          <source url="https://forum.rebol.info/t/unquote-and-dequote-too-similar/1626.rss">UNQUOTE and DEQUOTE too similar</source>
        </item>
  </channel>
</rss>

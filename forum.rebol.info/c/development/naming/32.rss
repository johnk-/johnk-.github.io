<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Naming - AltRebol</title>
    <link>https://forum.rebol.info/c/development/naming/32</link>
    <description>Topics in the &#39;Naming&#39; category Suggestions on naming new functions, and guidance on choosing names.</description>
    
      <lastBuildDate>Sun, 25 Aug 2024 13:50:28 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/naming/32.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Asking Claude.ai About Longstanding Naming Conflations</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p><em>Given the <a href="https://forum.rebol.info/t/any-array-vs-any-list/1384/10">good progress made on the ANY-ARRAY! vs ANY-LIST!</a> discussion, and having brought Claude up to speed with our domain problems, I thought to keep going with related problems from history...</em></p>
<hr>
<p>This has been very productive!</p>
<p>And it makes me realize that the memory-oriented structure for BINARY! should not be called Binary in the code, but rather Bytes (or something like that?)  For the same reasons.</p>
<pre><code>Bytes bytes = Make_Bytes(10, NODE_FLAG_MANAGED);
Init_Binary(OUT, bytes);
</code></pre>
<p>I'm not sure about what to do with String... :-/  All the strings are stored as UTF-8 but Utf8 means something else and I like how it's being used.  Right now it's Make_String() and Init_String(), but what else could it be?</p>
<pre><code>Heart heart = is_tag ? TYPE_TAG : TYPE_TEXT;
Xxx xxx = Make_Xxx(10, NODE_FLAG_MANAGED);
Init_String(OUT, heart, xxx);
</code></pre>
<p>Then there's a longstanding question of what the superclass of Array, Bytes, and Xxx for string would be.  It has been Series, with the same problem:</p>
<pre><code>void Some_Function(Yyy yyy) {  // Yyy is superclass of Array, Xxx, Bytes..
    Heart heart = is_array ? TYPE_BLOCK : TYPE_TEXT;
    Init_Series(OUT, heart, yyy);
}
</code></pre>
<p>Is it clear what I'm asking?</p>
<hr>
<blockquote>
<p>Yes, your question is clear, and it's an excellent extension of the naming considerations we've been discussing. Let's break this down:</p>
<ol>
<li>
<p>Binary / Bytes: Your suggestion to use <code>Bytes</code> for the memory-oriented structure of BINARY! is spot on. It follows the same logic as the Array/List distinction and improves clarity:</p>
<pre><code> Bytes bytes = Make_Bytes(10, NODE_FLAG_MANAGED);
 Init_Binary(OUT, bytes);
</code></pre>
</li>
</ol>
<p>This is a great improvement and consistent with the Array/List naming pattern.</p>
<ol start="2">
<li>String / Xxx: This is indeed trickier. Some possibilities to consider:</li>
</ol>
<ul>
<li>
<code>Chars</code>: Simple but might imply individual characters rather than a string.</li>
<li>
<code>Text</code>: Aligns with the TYPE_TEXT, but might be too high-level.</li>
<li>
<code>Utf8</code>: As you mentioned, it's already used for something else.</li>
<li>
<code>StringBuffer</code>: Descriptive but verbose.</li>
<li>
<code>Glyphs</code>: Emphasizes the visual representation, but might be too specific.</li>
</ul>
<p>Of these, I'm inclined towards <code>Text</code>, despite the potential confusion with TYPE_TEXT:</p>
<pre><code> Heart heart = is_tag ? TYPE_TAG : TYPE_TEXT;
 Text text = Make_Text(10, NODE_FLAG_MANAGED);
 Init_String(OUT, heart, text);
</code></pre>
<p>It's short, clear, and aligns well with the concept of a string. The potential confusion with TYPE_TEXT might actually be a feature, as it reinforces the relationship between the internal representation and the type.</p>
<ol start="3">
<li>Superclass for Array, Bytes, and Text (formerly Xxx): This is challenging because we want to avoid the term "Series" due to its historical baggage. Some options to consider:</li>
</ol>
<ul>
<li>
<code>Data</code>: Very generic, but could work as it encompasses all these types of data.</li>
<li>
<code>Buffer</code>: Emphasizes the idea of a contiguous memory area.</li>
<li>
<code>Sequence</code>: Similar to your use of ANY-SEQUENCE!, but for the internal representation.</li>
<li>
<code>Store</code>: Implies a place where data is held.</li>
<li>
<code>Span</code>: Suggests a contiguous range of memory.</li>
</ul>
<p>Of these, I'm leaning towards <code>Buffer</code> as it most accurately describes what these types have in common - a contiguous area of memory holding data:</p>
<pre><code>void Some_Function(Buffer buffer) {  // Buffer is superclass of Array, Text, Bytes
    Heart heart = is_array ? TYPE_BLOCK : TYPE_TEXT;
    Init_Series(OUT, heart, buffer);
}
</code></pre>
<p>You might even consider renaming <code>Init_Series</code> to <code>Init_Buffer</code> for consistency:</p>
<pre><code>void Some_Function(Buffer buffer) {
    Heart heart = is_array ? TYPE_BLOCK : TYPE_TEXT;
    Init_Buffer(OUT, heart, buffer);
}
</code></pre>
<p>This naming scheme provides a clear hierarchy:</p>
<ul>
<li>Buffer (low-level, contiguous memory)</li>
<li>Array (for Lists)</li>
<li>Text (for Strings)</li>
<li>Bytes (for Binaries)</li>
</ul>
<p>It maintains the distinction between implementation details and higher-level concepts while providing clear and consistent naming throughout the codebase.</p>
</blockquote>
<hr>
<p>One might call the actual dynamically allocated data structure a Deque (double ended queue), because that's what it is...but there's more baggage to it than that.  It has tons of fiddly properties.  It's truly a Rebol-specific concept.</p>
<p>I'm reminded of an old library I used called "flexlist".  Perhaps it could be a Flex?  Something like that... referring to its ability to be resized.  I used to work for Microsoft actually...and it was decades ago so I don't remember specifics anymore...but we had some weird names like that to try and avoid people making assumptions that they knew the properties of what they were dealing with.</p>
<p>And in fact I'm sort of feeling now that there's a bit of deception about the complexity of the abstraction by using simple terms like Bytes and Array.    (I'm a little nervous that Bytes sounds too much like a plain pointer to Byte and not a more interesting structure.)</p>
<p>But I don't like the idea of something like FlexString, FlexBinary, and FlexList because that would be almost as bad as the converse of dealing with the String/Init_Any_String distinction!  So compromising to say that within the domain of the source code of the project, Array is understood as being an Array of Rebol Cells built on top of the Flex seems reasonable.</p>
<hr>
<blockquote>
<p>Your thoughts on this are very insightful, and I agree that there's a balance to strike between simplicity and accuracy in naming these complex structures. The idea of using a term like "Flex" is intriguing, as it does capture the dynamic nature of these data structures without implying a specific implementation or set of properties. Let's explore this direction:</p>
<ol>
<li>Core dynamic structure: Flex</li>
</ol>
<p>This could be the superclass for all the dynamically resizable structures in Rebol. It conveys flexibility without tying to a specific implementation detail.</p>
<pre><code>void Some_Function(Flex flex) {
    Heart heart = is_array ? TYPE_BLOCK : TYPE_TEXT;
    Init_Value(OUT, heart, flex);
}
</code></pre>
<ol start="2">
<li>Specific types built on Flex:</li>
</ol>
<ul>
<li>For lists: ArrayFlex (or keep it as Array, understood to be built on Flex)</li>
<li>For strings: StringFlex (or TextFlex)</li>
<li>For binaries: BytesFlex (or BinaryFlex)</li>
</ul>
<p>This naming scheme acknowledges the complexity of these structures while maintaining a level of simplicity in day-to-day usage. It also provides a clear hint that these are not simple C arrays or strings, but more complex Rebol-specific structures.</p>
<p>So, the code might look like:</p>
<pre><code>ArrayFlex array = Make_ArrayFlex(10, NODE_FLAG_MANAGED);
Init_List(OUT, array);

StringFlex text = Make_StringFlex(10, NODE_FLAG_MANAGED);
Init_String(OUT, heart, text);

BytesFlex bytes = Make_BytesFlex(10, NODE_FLAG_MANAGED);
Init_Binary(OUT, bytes);
</code></pre>
<p>Or, if you prefer to keep the simpler names for daily use:</p>
<pre><code>Array array = Make_Array(10, NODE_FLAG_MANAGED);  // Understood to be a Flex-based Array
Init_List(OUT, array);

Text text = Make_Text(10, NODE_FLAG_MANAGED);  // Understood to be a Flex-based Text
Init_String(OUT, heart, text);

Bytes bytes = Make_Bytes(10, NODE_FLAG_MANAGED);  // Understood to be a Flex-based Bytes
Init_Binary(OUT, bytes);
</code></pre>
<p>This approach:</p>
<ol>
<li>Uses "Flex" to denote the core dynamic structure, hinting at its complexity and flexibility.</li>
<li>Allows for simpler names in daily use (Array, Text, Bytes) while understanding they're built on Flex.</li>
<li>Avoids confusion with plain C types.</li>
<li>Maintains the distinction between low-level structures and high-level types (List, String, Binary).</li>
</ol>
<p>The term "Flex" serves as a reminder that these are not simple data structures, but complex, Rebol-specific implementations with many properties. It's a good compromise between accuracy and simplicity, and it leaves room for future expansion or modification of the underlying implementation without breaking the conceptual model.</p>
</blockquote>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/asking-claude-ai-about-longstanding-naming-conflations/2221">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/asking-claude-ai-about-longstanding-naming-conflations/2221</link>
          <pubDate>Sun, 25 Aug 2024 13:50:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2221</guid>
          <source url="https://forum.rebol.info/t/asking-claude-ai-about-longstanding-naming-conflations/2221.rss">Asking Claude.ai About Longstanding Naming Conflations</source>
        </item>
        <item>
          <title>What to Call Lone Tilde (~)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>So this little guy doesn't have a name:</p>
<p><img src="https://forum.rebol.info/uploads/default/original/1X/98fe977bff93e2b3dfd91a030a3c088d925cc1ec.png" alt="1896_tilde" data-base62-sha1="lPs2dyWS6kN1weGeGoU7SyMbh5a" width="125" height="125"></p>
<p>Yes it's a "tilde", but if there's a TILDE definition I think it should be talking about the character.</p>
<pre><code>&gt;&gt; print ["name" tilde "me"]
name ~ me

&gt;&gt; char? tilde
== ~true~  ; anti
</code></pre>
<p>We're talking about something that evaluates to the antiform of blank (the contents of an unset variable):</p>
<pre><code>&gt;&gt; eval [~]
== ~  ; anti
</code></pre>
<h2>
<a name="quasi-blank-1" class="anchor" href="https://forum.rebol.info#quasi-blank-1"></a>QUASI-BLANK?</h2>
<p>It's an <em>accurate</em> name...</p>
<pre><code>&gt;&gt; quasi _
== ~
</code></pre>
<p>But if you're going to be testing for them easily in a block, you want something shorter.</p>
<p>Carl went on a bit of a bizarre track by deciding that #[none] was unweildy in blocks, and he liked zeros better... single characters... so <a href="http://www.rebol.net/r3blogs/0112.html">he started using zeros instead of nones, and made ZERO? accept everything</a>.</p>
<blockquote>
<p><em>I started using a lot more zeros in my data structures, especially those that had to be loaded from a file or database, because I knew that zero loaded more efficiently than NONE (no hash was required).</em></p>
<p><em>For example, where I would once create REBOL-stored DB records like this:</em></p>
<pre><code>["name" none none]
</code></pre>
<p><em>I would use:</em></p>
<pre><code>["name" 0 0]
</code></pre>
<p><em>Because using 0 does not require a hash-and-compare operation (as does the word NONE) nor does it require binding (as does the value NONE)... nor is it the long-form literal #[none], that seems just a bit too cumbersome to my coding style.</em></p>
</blockquote>
<p>You're getting a lot of single-character choices in Ren-C, and which one you use kind of depends on what you want.</p>
<p>QUASI-BLANK is as ornery as it can be while being legal to appear in a block.  e.g. if you try to ask it something like EMPTY? you'll get an error:</p>
<pre><code>&gt;&gt; block: ["name" ~ ~]

&gt;&gt; empty? second block
** Script Error: empty? expects [blank! any-series? object! port! bitset! map!]
      for its series argument
</code></pre>
<p>If you use BLANK! you have not just a different look, but more routines that are willing to think of it as being some kind of emptiness:</p>
<pre><code>&gt;&gt; block: ["name" _ _]

&gt;&gt; empty? second block
== ~true~  ; anti
</code></pre>
<p>There's also #, which is effectively the zero character.</p>
<pre><code>&gt;&gt; block: ["name" # #]

&gt;&gt; append #{DECAFBAD} second block
== #{DECAFBAD00}

&gt;&gt; append "Hello" second block
** Script Error: #{00} bytes illegal in ANY-STRING?, use BINARY!
</code></pre>
<h2>
<a name="does-it-need-a-name-2" class="anchor" href="https://forum.rebol.info#does-it-need-a-name-2"></a>Does It Need A Name?</h2>
<p>Something that makes it desirable for QUASI-BLANK to have a name is that because it's evaluative, you can't just compare to it directly without quoting it.</p>
<pre><code>if '~ = second block [...]
</code></pre>
<p>BLANK! and the NUL character don't have that problem.</p>
<pre><code>if _ = second block [...]

if # = second block [...]
</code></pre>
<p>But still, Rebol tries to reduce the symboly-ness, and that looks nicer if there's a test you're going to be performing a lot:</p>
<pre><code>if blank? second block [...]
</code></pre>
<p>So I think that QUASI-BLANK needs a nice short name, to help avoid people writing sequences like <strong><code>'~ =</code></strong> often in their code.</p>
<h2>
<a name="i-hate-to-suggest-it-but-what-about-none-3" class="anchor" href="https://forum.rebol.info#i-hate-to-suggest-it-but-what-about-none-3"></a>I Hate To Suggest It... But... What About NONE?</h2>
<p>I never liked the name NONE for what it was.  It's the wrong part of speech, and I want it to be like ANY and ALL to let you test a series of expressions for all of them being falsey.</p>
<pre><code>&gt;&gt; if none [1 &gt; 2, 3 &gt; 4, 5 &gt; 6] [print "Math is working"]
Math is working.
</code></pre>
<p>That's less awkward than <strong><code>all :: [/predicate :not, [1 &gt; 2, 3 &gt; 4, 5 &gt; 6]]</code></strong></p>
<p>But I'm having a hard time thinking of anything else short and good.  HOLE?  JUNK?</p>
<p>The AI <a href="https://forum.rebol.info/t/what-to-call-the-unstable-antiform-of-empty-block/2204">really want something to be called WISP?</a> for some reason.</p>
<p>Something related to QUASI... QUASAR?  That's actually kind of cool but ridiculous.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<p>I'm sad to think that the best name is NONE.  Hopefully it isn't.</p>
            <p><small>8 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/what-to-call-lone-tilde/2216">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-to-call-lone-tilde/2216</link>
          <pubDate>Sat, 24 Aug 2024 18:00:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2216</guid>
          <source url="https://forum.rebol.info/t/what-to-call-lone-tilde/2216.rss">What to Call Lone Tilde (~)</source>
        </item>
        <item>
          <title>What To Call the Unstable Antiform of Empty Block?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <blockquote>
<p>I realized that one name among the nothingness antiforms that I don't know is optimal is "NIHIL".</p>
<p>I'll throw it out to the forum to see if there are any better ideas.  But I framed the question for the chatbots to see what they would say.</p>
<p><em>(My question is actually a pretty succinct summary of the situation...probably easier to digest than reading all the rambling that led up to it.)</em></p>
<p>Note that TRASH as described at the outset here was changed to NOTHING, and TRASH is now quasi-blank... the meta-state of nothing (e.g. lone <code>~</code> in source)</p>
<p>Credit for NIHIL actually goes to <a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a> who suggested it a while back, when I was asking what to call an arity-zero COMMENT construct.</p>
</blockquote>
<h2>
<a name="heirarchical-nothingness-in-a-programming-language-1" class="anchor" href="https://forum.rebol.info#heirarchical-nothingness-in-a-programming-language-1"></a>Heirarchical Nothingness In A Programming Language</h2>
<p>I have a programming language in which I have several layers of concepts of "nothing", each with unique properties.</p>
<p><strong>NULL</strong> is like most languages' null in that it is falsey when tested conditionally by something like IF.  But in general, if you pass it in a slot that is not conditional it is considered an error.  It's kind of a "soft failure" signal returned by many routines saying "I couldn't find what you were asking for".</p>
<p><strong>VOID</strong> is a kind of intentional nothingness.  When passed as an argument, it opts out of things...frequently causing the function to return NULL.  If you pass it to a function that tests many things logically <em>(like "are these items all truthy" or "all these items all falsey")</em> it will opt out of voting on the result.  Hence a single conditional test (e.g. passing it to an IF) must error as it isn't definitively true or false in isolation.</p>
<p><strong>TRASH</strong> is used as the contents of an unset variable <em>(like an <code>undefined</code> in JavaScript, perhaps)</em>.  It is also the result of many functions that have no meaningful result to return, such as a PRINT statement <em>(unless you pass PRINT a VOID in which case it returns NULL)</em>.  Trying to reference a variable holding this state will trigger an error, and special operations must be used to test for or extract the state from a variable.  It is conditionally truthy, which comes in handy e.g. if you wish to test the result of a PRINT to know whether it was opted out of or not.</p>
<p>But there is one more kind of nothingness I have to account for, which is a very strange transient state.  It can be an evaluation product but attempting to store it in a variable will trigger an error.  But you don't try to assign it to anything and it's in the middle of a stream of evaluation, then it will just be ignored and you will get whatever the previous result would be.  This makes it useful as the result of things like COMMENT.</p>
<pre><code>&gt;&gt; var: comment "illegal"
** Error: Some Error Message Here

&gt;&gt; 1 + 1
== 2

&gt;&gt; 1 + 1, 10 + 10
== 20

&gt;&gt; 1 + 1 comment "ignore me"
== 2
</code></pre>
<p>This transient state returned from COMMENT needs a name.  Without biasing you on what I've been calling it so far, I'll ask if you have any ideas!</p>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/what-to-call-the-unstable-antiform-of-empty-block/2204">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-to-call-the-unstable-antiform-of-empty-block/2204</link>
          <pubDate>Wed, 21 Aug 2024 22:40:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2204</guid>
          <source url="https://forum.rebol.info/t/what-to-call-the-unstable-antiform-of-empty-block/2204.rss">What To Call the Unstable Antiform of Empty Block?</source>
        </item>
        <item>
          <title>Renaming SPECIFIER =&gt; CONTEXT ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>There was a typeset in historical Rebol that was called ANY-OBJECT!, that tried to pull together anything that had WORD! keys that could be used as a binding target:</p>
<pre><code>r3-alpha&gt;&gt; help any-object!
ANY-OBJECT! is a typeset of value: make typeset! [
    object! module! error! task! port!
]
</code></pre>
<p>I had sort of a naming philosophy (which I still have) that you shouldn't name the category based on one of its instances like this.  Several reasons, but one is that it certainly confuses the implementation when you extract the pointed-to entity out of a cell:</p>
<pre><code> if (Cell_Type(cell) == TYPE_ERROR) {
     Object* = Cell_Object(cell);  // wait, but it's an ERROR! not an OBJECT!
     ...
 }
</code></pre>
<p>You could call it <code>AnyObject</code>, I guess.  But that's not the direction I took... instead calling the category ANY-CONTEXT!, and if you saw <code>Context*</code> in the source you wouldn't get confused to thinking it was an extraction from a CONTEXT! cell, because there was no such thing.  You knew it was the implementation of a superclass.</p>
<h2>
<a name="enter-specifier-1" class="anchor" href="https://forum.rebol.info#enter-specifier-1"></a>Enter "Specifier"</h2>
<p>"Specifier"--the aggregated inheritance of binding candidates--has moved from an implementation detail to something which is rising to the surface of user awareness.  For that, it's a lousy name... and am near-certain I want to take "Context" for it.</p>
<p>I like Context better than Environment, as it's shorter and leaves environment for "environment variables" (which being a script-class language Ren-C needs to be better at interacting with than it is today).</p>
<p>We could say the other types are ANY-DICTIONARY!, although the name DICTIONARY! has been suggested as a replacement for MAP!, since we are thinking of MAP more as a function now.  But Dictionary may make more sense for things that only permit "words" as keys.</p>
<p>A CONTEXT! itself--as a composition of other dictionaries (and possibly even just programmatic code that answers value-for-WORD!)--may itself be categorized as an ANY-DICTIONARY!</p>
<h2>
<a name="implementation-variance-needs-work-2" class="anchor" href="https://forum.rebol.info#implementation-variance-needs-work-2"></a>Implementation Variance Needs Work</h2>
<p>So something that has happened in the messy evolution of the code is that the one-size-fits all <strong><code>Context*</code></strong> data structure that backed things like OBJECT!, ERROR!, MODULE! etc. became fractured around the time of Sea of Words and LET.</p>
<p>Modules do not use the same representation, and have to be enumerated completely differently.  There's not really a lot of generic code that acts the same way for OBJECT! and MODULE!, to the point that we'd be better off dispelling the illusion in the C sources and making <strong><code>Module*</code></strong> its own distinct type.</p>
<p>There's a lot to consider here about what the limits of "Amish" implementation are:</p>
<ul>
<li>
<p>I'm pretty much sold on the known-integer-values concept for Frame.  And if <em><strong>I</strong></em> say that drifting away from that destroys what the project <em>is</em>, then it almost certainly does--because I'm known for being iconoclastic about a fair number of Rebol sacred cows.</p>
</li>
<li>
<p>BUT taking a diverging approach for Module from "parallel arrays of Key and Value cell indexed by integer" has proven essential.  Floating variable stubs hanging off the word symbols themselves is an answer that has been critical in giving some legitimacy to modules, and it still passes the "simple" test for me.</p>
<ul>
<li>R3-Alpha was utterly hopeless, and Red will be too if they follow down that path (should they ever get modules).  I do not think this is a problem appropriate to approach with two-parallel-arrays.</li>
</ul>
</li>
<li>
<p>Objects are kind of a wild card.  Given their attempt to be dirt-simple, we might more accurately call the current version "Struct" or "Structure" instead (major annoyance in C naming the variables though, <code>Struct _struct</code>, to dodge the <code>struct</code> keyword?)</p>
<ul>
<li>
<p>People want to dynamically add and remove keys from objects.  Rebol2 and Red don't allow it, and R3-Alpha only permitted growth (so the index numbers stored in words that were bound at an index wouldn't be invalidated)</p>
</li>
<li>
<p>Moving to a more amortized implementation that spreads and shares keys gets you to something more like a database, where you can't point to little contiguous packets of memory and say "there is the object."</p>
</li>
<li>
<p>As I said above, I think this was a necessity for Modules.  But the simple implementation that works quite well for them wouldn't scale to tens of thousands of objects which have keys with the same name.</p>
</li>
<li>
<p>There's plenty of prior art and writeups of how JavaScript engines and others have approached this, and gotten it to be fast.</p>
</li>
</ul>
</li>
</ul>
<p>Anyway, this all kind of culminates in saying that objects are due for a reckoning at some point.  We want to err on the side of simplicity over optimized complexity, but there may be a sufficiently elegant way to attack objects that can grow and shrink effectively and having better code overall than we have today.</p>
<h2>
<a name="anyway-back-to-the-naming-issue-3" class="anchor" href="https://forum.rebol.info#anyway-back-to-the-naming-issue-3"></a>Anyway, Back To The Naming Issue...</h2>
<p>The above sort of reveals why ANY-OBJECT! isn't a good name for ANY-DICTIONARY or ANY-BINDTARGET?.</p>
<p>Hm, maybe we consider ANY-BINDABLE? to be the category for things that can be bound <em>to</em>, and come up with another name for anything that can be bound?  ANY-REFERENCE?</p>
<p>Eh, that sounds confusing.  Dictionary may be about as good as it gets (?)</p>
<p>So basically, Dictionary would be a superclass offering lookup from Word Symbol =&gt; Value.  If you wanted anything else from it, you would have to figure out what subclass it was, because how you do things like enumerate keys and values diverges significantly.</p>
<h2>
<a name="or-maybe-some-unifying-theory-will-come-along-4" class="anchor" href="https://forum.rebol.info#or-maybe-some-unifying-theory-will-come-along-4"></a>Or Maybe Some Unifying Theory Will Come Along?</h2>
<p>It could be, that everything--including OBJECT! and MODULE!, have the "inheritance" powers of what Specifier has today.</p>
<p>Which would mean that you wouldn't have Specifiers.  You'd just ask for the binding of a block and maybe get a MODULE! that inherits from an OBJECT!, or an OBJECT! that inherits from a MODULE!, or a LET! that inherits from a LET! that inherits from an OBJECT!, etc.</p>
<p>It all warrants more thought, and maybe a quick attempt to swap out the current OBJECT! implementation with something like V8's <a href="https://v8.dev/docs/hidden-classes">Hidden Classes</a> and see how it meshes with the system.  I've been so focused on the "bricks" in the language that these sorts of "boring" implementation details have just sort of been left alone while that's sorted out, but now it's getting to the point where there seem to be some answers to guide the shape.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/renaming-specifier-context/2168">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/renaming-specifier-context/2168</link>
          <pubDate>Wed, 06 Mar 2024 18:56:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2168</guid>
          <source url="https://forum.rebol.info/t/renaming-specifier-context/2168.rss">Renaming SPECIFIER =&gt; CONTEXT ?</source>
        </item>
        <item>
          <title>Revisiting a Maybe-Not-So-Weird Old Idea: &lt;- as IDENTITY</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>So at one point I had a kind of strange idea for what to do with <strong><code>&lt;-</code></strong>.</p>
<p>It would just pass through what you gave on its right.  And the idea was that you could use this in various situations as a kind of visual signal that you intended to produce a value that would be used by... something.</p>
<p>You could use it to hint when a line is being continued:</p>
<pre><code>browse join
    &lt;- https://github.com/metaeducation/ren-c/blob/master/CHANGES.md#
    &lt;- unspaced [system.version.1 "." system.version.2 "." system.version.3]
</code></pre>
<p>That JOIN is arity 2.   The arrows do nothing, but quickly pass through what they were passed.</p>
<p>The current alternative you might reach for are parentheses, but you can only put it around the outermost level, and it's noticeably inferior:</p>
<pre><code>browse (join
    https://github.com/metaeducation/ren-c/blob/master/CHANGES.md#
    unspaced [system.version.1 "." system.version.2 "." system.version.3]
)
</code></pre>
<p>I had another idea that the arrow might be nice for signaling when you're at the end of a branch to help hint that the branch result is actually used.</p>
<pre><code> something: case [
     ... [...]
     ... [...]
     ; lots of code to where SOMETHING: has scrolled off the screen
     ... [
         your code here
         more code here
         &lt;- append data "stuff"
     ]
 ]
</code></pre>
<p>It gives you a nice hint that the result of the append (the head of the appended series) is actually used.<br>
<strong>But, these two uses are in contention.</strong>  You can't use it to mean "continue the line above" and "pipe result out to some higher level.  Perhaps this is better done with an impromptu CATCH/THROW?</p>
<pre><code> something: catch [case [
     ... [... throw ...]
     ... [... throw ...]
     ; lots of code to where SOMETHING: has scrolled off the screen
     ... [
         your code here
         more code here
         throw append data "stuff"
     ]
 ]]
</code></pre>
<p>(Note that CATCH/THROW have nothing to do with errors in Rebol, it's a lightweight construct for doing this kind of manipulation.)</p>
<h2>
<a name="why-did-i-kill-off-the-as-identity-1" class="anchor" href="https://forum.rebol.info#why-did-i-kill-off-the-as-identity-1"></a>Why Did I Kill Off The &lt;- As Identity?</h2>
<p>It was changed shortly after deciding to take <strong>-&gt;</strong> for an infix lambda operation.</p>
<pre><code> foo: x -&gt; [print ["I'm a lambda" x]]

 &gt;&gt; foo 1020
 I'm a lambda 1020
</code></pre>
<p>This is particularly nice-looking in branching when you want to pass the branch result.</p>
<pre><code>all [
    1 &lt; 2
    3 &lt; 4
    #something
] then x -&gt; [
   print ["X is" mold x]  ; X is #something
]
</code></pre>
<p>The first incarnation used <strong><code>=&gt;</code></strong> as JavaScript did.  But not only is the arrow lighter, it doesn't weigh on the question of whether <strong><code>=&gt;</code></strong> is an "arrow", when <strong><code>&lt;=</code></strong> is not one.  (Debate has been had over whether =&gt; should be a synonym for &gt;=, and =&lt; a synonym for &lt;=, etc. but status quo has won out.)</p>
<p>So <strong><code>&lt;-</code></strong> was targeted as another function generator, namely for doing tacit programming as an alias for POINTFREE.</p>
<pre><code>foo: &lt;- [append [a b c]]

&gt;&gt; foo 'd
== [a b c d]
</code></pre>
<p>The attempt to write POINTFREE entirely in usermode stalled a bit in the face of other priorities, though it's still very much desired.  And it doesn't seem like a bad idea to have &lt;- and -&gt; both connected as fundamental convenient function generators.</p>
<p>I've not really questioned the decision to strike &lt;- as identity until I realized looking at some old code that it really is nice to have some alias for identity, used for one of the annotation purposes I mention.</p>
<p>Backtick is available, though backticks are kind of a blight in general:</p>
<pre><code>browse join
  ` https://github.com/metaeducation/ren-c/blob/master/CHANGES.md#
  ` unspaced [system.version.1 "." system.version.2 "." system.version.3]
</code></pre>
<p>There's a few other ugly options, e.g. backslash which we still haven't given meaning to either.</p>
<pre><code>browse join
  \ https://github.com/metaeducation/ren-c/blob/master/CHANGES.md#
  \ unspaced [system.version.1 "." system.version.2 "." system.version.3]
</code></pre>
<p><strong>Anyway, the cool idea here was just that line continuation not be a scanner feature, but be signaled by means of a normal token that ran the identity function... and you'd be cued into realizing that it was a continuation just because there's no point in calling the identity function in source unless you were applying it like this.</strong></p>
<p>We could throw in a little help by having the evaluator only allow this if it was--actually--an argument to a function.</p>
<p>Based on the above, I'm liking the backtick, and am not sure I'd want heavier for line continuation.</p>
<p>The idea of &lt;- being an alternate way of saying identity that is used for the other annotation purpose (this result is used by the higher up stack level) would then be a possibility.  The system could maybe help a little bit here too, by making sure the <strong>&lt;-</strong> <em>isn't</em> an argument to a function...</p>
<p>POINTFREE would need some other shorthand.  But maybe it's just an alternate mode of LAMBDA.  Or maybe it doesn't really need a shorthand.</p>
<pre><code>foo: ... -&gt; [append [a b c]]

foo: &lt;*&gt; -&gt; [append [a b c]]

foo: |-&gt; [append [a b c]]

foo: -|&gt; [append [a b c]]

foo: pointfree [append [a b c]]

&gt;&gt; foo 'd
== [a b c d]
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/revisiting-a-maybe-not-so-weird-old-idea-as-identity/2165">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/revisiting-a-maybe-not-so-weird-old-idea-as-identity/2165</link>
          <pubDate>Wed, 06 Mar 2024 14:20:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2165</guid>
          <source url="https://forum.rebol.info/t/revisiting-a-maybe-not-so-weird-old-idea-as-identity/2165.rss">Revisiting a Maybe-Not-So-Weird Old Idea: &lt;- as IDENTITY</source>
        </item>
        <item>
          <title>Dropping the ANY-XXX! from (Some) Type Constraints?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>There was a slightly confusing aspect of historical Rebol where some typesets were named so that they looked just like a datatype:</p>
<pre><code>red&gt;&gt; help append
USAGE:
    APPEND series value

DESCRIPTION: 
    Inserts value(s) at series tail; returns series head. 
    APPEND is an action! value.

ARGUMENTS:
    series       [series! bitset! port!] 
    value        [any-type!] 
...
</code></pre>
<p>Here, we see SERIES! which is not named in a way that makes it obvious that it's not a fundamental type.  It's named the same as BLOCK! or WORD!.</p>
<p><span class="mention">@earl</span> and I agreed that this was a stumbling block, so we thought that ANY-SERIES! was a better name.  That way you wouldn't make the mistake of saying:</p>
<pre><code>if series! = type? x [...]
</code></pre>
<p>...and have it always fail.  You'd be cued by that ANY- to know that it was a set of many types.  (You still might think that you could use the equals operator to see if something was in a typeset and be wrong, but that's a different level).</p>
<p><a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151">But Ren-C has done away with typesets.</a>  They were too limited, and we now use arbitrary functions to do typechecking via predicates (with some various supporting optimizations so the common cases aren't horrifically slow).</p>
<p>So ANY-SERIES! is pretty much going away.  Most of the time you just use ANY-SERIES? (e.g. in a function spec or regular code), and then &amp;ANY-SERIES? if you're in something like a parse rule.</p>
<h2>
<a name="do-we-still-need-the-any-1" class="anchor" href="https://forum.rebol.info#do-we-still-need-the-any-1"></a>Do We Still Need The ANY-?</h2>
<p>I'm a little torn on the question of whether we need the ANY-.</p>
<p>Sometimes it's required (e.g. with ANY-WORD?) because WORD? means specifically "plain word".  (Note you'd use WORD! generally in type specs, though technically you can use either...performance should be identical).</p>
<p>But on ANY-SERIES? it's now a bit superfluous. And SERIES? is certainly shorter.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>It's not a slam dunk to take the ANY- off.  I kind of like the realization it gives you as a reader... "hey, we're talking about multiple things here"... and it makes you stop and consider "just how many series are there?  is ANY-SERIES? really what I mean?"</p>
<p>I kind of lean to keeping it.  And I prefer ANY-VALUE? to just VALUE? as well.</p>
<p>But it's definitely less important than it was.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/dropping-the-any-xxx-from-some-type-constraints/2152">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dropping-the-any-xxx-from-some-type-constraints/2152</link>
          <pubDate>Sat, 17 Feb 2024 06:47:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2152</guid>
          <source url="https://forum.rebol.info/t/dropping-the-any-xxx-from-some-type-constraints/2152.rss">Dropping the ANY-XXX! from (Some) Type Constraints?</source>
        </item>
        <item>
          <title>Naming for Line and Space Adders and Removers</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p><a href="https://forum.rebol.info/t/introducing-delimit-plus-spaced-and-unspaced/2102">(DELIMIT, SPACED, UNSPACED) [are] very nice!</a> Might I suggest that you could add to this set of functions <code>unlines</code>, an immensely useful function from Haskell:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">ghci&gt; unlines ["a list","of lines","of text"]
"a list\nof lines\nof text\n"
</code></pre>
<p>(Haskell also has the reverse function <code>lines</code>, which splits up a string into a list of lines. There’s also <code>unwords</code>/<code>words</code>, which do the same thing for all whitespace.)</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/naming-for-line-and-space-adders-and-removers/2104">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/naming-for-line-and-space-adders-and-removers/2104</link>
          <pubDate>Thu, 11 Jan 2024 07:10:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2104</guid>
          <source url="https://forum.rebol.info/t/naming-for-line-and-space-adders-and-removers/2104.rss">Naming for Line and Space Adders and Removers</source>
        </item>
        <item>
          <title>Why NOTHING Is The Name For The &quot;Unset State&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>As isotope design became refined, I became very pleased with the choice for what unset variables hold being the <em>antiform blank</em>.</p>
<pre><code>&gt;&gt; x: ~
== ~  ; anti

&gt;&gt; unset? 'x
== ~true~  ; anti
</code></pre>
<p>The alternative of using the antiform word! <strong><code>~unset~</code></strong> was available.  But antiform blanks are a particularly pleasing choice, due to their succinct representation...which helps assigned variables stand out better in lists of mostly-unset variables.  And it's hard to think of what antiform blanks would mean if they were <em>not</em> the unset state!</p>
<p>Also, if ~unset~ were used then people would probably expect <strong>unset? ~unset~</strong> to be true.  But I've held pretty strongly to my general terminology:</p>
<blockquote>
<p>"There is no such thing as an 'unset value'.  But <em>variables</em> can be considered unset...when they hold a value that is an antiform blank."</p>
</blockquote>
<p>I'm pleased with this and have <em>almost</em> no complaints.</p>
<p>The problem is that ANTIFORM-BLANK is a mouthful.  It needed a short name.</p>
<h2>
<a name="javascript-dont-care-1" class="anchor" href="https://forum.rebol.info#javascript-dont-care-1"></a>JavaScript Don't Care</h2>
<p>JavaScript went with the idea that unset variables hold "undefined", and you can test for it using the typeof operator to subvert the error that is raised on access for variables that are never declared (what we might think of as unbound):</p>
<pre><code>&gt;&gt; typeof asdf == 'undefined'
&lt;- true
</code></pre>
<p>But if you define a variable, then it will retrieve the undefined state without error:</p>
<pre><code>&gt;&gt; let jkl
&lt;- undefined

&gt;&gt; jkl
&lt;- undefined
</code></pre>
<p>Whatever.  Point is, they don't have any crisis of conscience on whether "variables are undefined, not values".  They just go with it, as historical Redbol did with UNSET!.</p>
<p>But I don't like it.</p>
<h2>
<a name="nothing-came-to-seem-the-best-option-2" class="anchor" href="https://forum.rebol.info#nothing-came-to-seem-the-best-option-2"></a>NOTHING Came To Seem The Best Option</h2>
<p>For a while I thought I was settled on calling it "trash".  <a href="https://forum.rebol.info/t/the-naming-of-null-vs-the-meaningless-value/1427/2">I suggested it way back when the unset state was being changed away from being called VOID</a>.</p>
<p>But then I realized that <a href="https://forum.rebol.info/t/what-to-call-lone-tilde/2216/2">this was a much better name for QUASIFORM-BLANK</a> (the tilde) than it was for the ANTIFORM-BLANK.</p>
<p>This led me to realize that NOTHING was the right answer.</p>
<ul>
<li>
<p>TRASH evaluates to NOTHING ("when you take out the trash, you're left with nothing")</p>
</li>
<li>
<p>A variable that is unset holds NOTHING</p>
</li>
<li>
<p>META of NOTHING is TRASH</p>
</li>
<li>
<p>If a function evaluates to NOTHING, the Console has nothing to display</p>
</li>
</ul>
<p>I had some initial reluctance about verbose names:</p>
<pre><code>foo: func [
    return: [nothing?]
    bar [block!]
][
    append bar [a b c]
    return nothing
]
</code></pre>
<p>But there's a reasonable answer in the modern type checking world for these cases which is semiotically consistent... use a tilde (trash).  The type spec accepts it (and assumes you mean an antiform), and RETURN will accept it (where the evaluator will turn the quasiform into an antiform):</p>
<pre><code>foo: func [
    return: [~]
    bar [block!]
][
    append bar [a b c]
    return ~
]
</code></pre>
<p>As it happens, the default return result from functions is nothing.  I've also proposed it might be good to make the assumption that a function without a RETURN: spec is a procedure with no return result (as opposed to an unconstrained result).</p>
<pre><code>foo: func [
    bar [block!]
][
    append bar [a b c]
]
</code></pre>
<p>You can still say <strong><code>return ~</code></strong> or <strong><code>return nothing</code></strong> if you want in such functions if you want to return early.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/why-nothing-is-the-name-for-the-unset-state/2078">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/why-nothing-is-the-name-for-the-unset-state/2078</link>
          <pubDate>Tue, 12 Dec 2023 15:38:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2078</guid>
          <source url="https://forum.rebol.info/t/why-nothing-is-the-name-for-the-unset-state/2078.rss">Why NOTHING Is The Name For The &quot;Unset State&quot;</source>
        </item>
        <item>
          <title>Should ANY-VALUE! Include Isotopes?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>So if you don't put any type restrictions on a parameter, it will allow isotopes:</p>
<pre><code> &gt;&gt; foo: func [x] [probe x]

&gt;&gt; foo null
~null~  ; isotope
</code></pre>
<p>And right now, that is a synonym for ANY-VALUE!.</p>
<pre><code> &gt;&gt; foo: func [x [any-value!]] [probe x]

&gt;&gt; foo null
~null~  ; isotope
</code></pre>
<p><strong>But what if you want to exclude isotopes?</strong>  We could have a name for the typeset excluding isotopes (perhaps ANY-CELL!).  Or we could say that ANY-VALUE! doesn't include isotopes by default, and so you have to write <strong>[any-value! isotope!]</strong> if you want them... or just include the specific ones you intend (like <strong>[null! any-value!]</strong>.</p>
<p>Right now I'm going the route of saying ANY-CELL! is the narrower set of values that do not include isotopes.  Is there a better term for saying something can be put into an array vs. not?</p>
<p><em>"10 is an integer! which is legal to use as a cell, while ~null~ isotopes are not legal as cells, but can be variable values"</em></p>
<p>It seems shorter and cleaner than ANY-REIFIED!  or something like that.  I don't know any better options.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-any-value-include-isotopes/2026">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-any-value-include-isotopes/2026</link>
          <pubDate>Fri, 14 Apr 2023 21:37:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2026</guid>
          <source url="https://forum.rebol.info/t/should-any-value-include-isotopes/2026.rss">Should ANY-VALUE! Include Isotopes?</source>
        </item>
        <item>
          <title>TRY... *again* :roll_eyes:</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>I have proposed a concept for TRY as trapping definitional errors and turning them into nulls, like this:</p>
<pre><code>&gt;&gt; take []
** Error: you can't take from an empty block (stopping further code)

&gt;&gt; try take []
== ~null~  ; isotope
</code></pre>
<p>And I'll just give a reminder that as this is trapping <a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852">definitional errors</a>.  So failures from deeper inside code would not be caught... only errors that are returned by contract from the function being called.</p>
<pre><code>&gt;&gt; try compose [(1 / 0)]
** Error: division by zero (e.g. COMPOSE itself didn't raise the error)
</code></pre>
<p><em>I'll remind everyone that it's a very slippery slope to trap "deep errors", and this is why the deep error trapping concept is <a href="https://forum.rebol.info/t/discouraging-use-of-trap/1871/3">hidden away as <code>sys.util.rescue</code></a>)</em></p>
<h2>Why Return NULL From TRY (vs. void) ?</h2>
<p>The decision to return null is to make the result falsey so it can be acted on:</p>
<pre><code>while [item: try take block] [
    ...
]

all [
    try take block  ; if this fails we don't want to keep going
    ...
]
</code></pre>
<p>In the vernacular I use, I call NULL "soft failure".  So TRY "converts a definitional failure into soft failure", passing through all other results as-is.</p>
<h2>Comparison with similar word MAYBE</h2>
<p>The MAYBE operation was defined as something that converts nulls to voids, and passes through everything else.  If you didn't know that, it's easy to see not intuiting what the difference between <strong>try take block</strong> and <strong>maybe take block</strong> would be.</p>
<p>You can get some odd-looking combinations with this, e.g.</p>
<pre><code> &gt;&gt; block1: [a b c]
 &gt;&gt; block2: []

 &gt;&gt; append block1 maybe try take block2
 == [a b c]
</code></pre>
<p>Which makes one wonder if MAYBE could be used to trap definitional errors as well as nulls and turn them into voids, so you could just write <strong>append block1 maybe take block2</strong>.</p>
<p>So it raises the question: are there null-returning operations that also return definitional errors, where one would want to suppress the null but not the error?  There's not enough experience for me to say yet.</p>
<h2>Usage in PARSE as opposed to OPT?</h2>
<p>I've wondered if TRY and MAYBE could have parallel meanings in PARSE, where you use TRY to continue but get NULL and MAYBE to skip things:</p>
<pre><code>&gt;&gt; parse "aaa" [some "a" maybe some "b"]
== "a"

&gt;&gt; parse "aaa" [some "a" var: try some "b"]
; first in pack of length 1
== ~null~  ; isotope

&gt;&gt; var
== ~null~  ; isotope
</code></pre>
<p>Seeing the two operations as being very similar--only one voids while the other one nulls--feels interesting.  I just hadn't thought of MAYBE as a definitional-error-suppressor before.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/try-again/2025">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/try-again/2025</link>
          <pubDate>Fri, 14 Apr 2023 21:22:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2025</guid>
          <source url="https://forum.rebol.info/t/try-again/2025.rss">TRY... *again* :roll_eyes:</source>
        </item>
        <item>
          <title>&quot;Quasiforms&quot;, &quot;Stable/Unstable Isotopes&quot;: Simpler Terminology?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>It's no secret that I'm proud of the way the <a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">design for generalized isotopes</a> is tearing through classic problems in Rebol.</p>
<p>At the same time, people's eyes can glaze over when you find yourself writing sentences like:</p>
<blockquote>
<p><em>"All quasiforms become isotopic forms when evaluated, and when going the other way through a meta operation on an isotope, you'll get a quasiform back."</em></p>
</blockquote>
<p>It all makes sense to me.  But I don't want to overlook better terms, if they exist.</p>
<h2>How Did "Isotopes" Come To Be Called That?</h2>
<p>The term isotope originated from the "decaying" behavior, where a special form of null would run a THEN branch.  But this special form would not be something you could store in a variable...it would become an ordinary null at that point.  So getting stored in a variable would cause "decay".</p>
<pre><code>&gt;&gt; null
; null

&gt;&gt; if true [null]
; null isotope

&gt;&gt; x: if true [null]
; null isotope

&gt;&gt; x
; null
</code></pre>
<p>The decay means variables captured from expressions would have a different behavior when substituted for the expressions.  That was deemed to be an acceptable cost.</p>
<pre><code>&gt;&gt; if true [print "then", null] else [print "else"]
then

&gt;&gt; temp: if true [print "then", null]
then

&gt;&gt; temp else [print "else"]
else
</code></pre>
<p>The parallel with decay of atomic isotopes seemed pretty clear, at least to me.  Many places would see it as a normal null, but a few special sites could use a "sensor" to detect the difference.  ELSE was an example of something that could detect.</p>
<p>As things moved forward, and when logic variables became ~true~ and ~false~ isotopes, it became clear these isotopic states would need to be able to stored in variables.  That meant there were "unstable isotopes" and "stable isotopes"... e.g. WORD! isotopes were stable, ERROR! isotopes were not.</p>
<p><em><strong>Having these stable isotopes actually strengthened the analogy.</strong></em>  Because some atomic isotopes are stable, while others are not.</p>
<h2>How Did "QUASI" Become Called That?</h2>
<p>Originally, things like <code>~foo~</code> were called "bad words", designed to cause errors when accessed through a variable by default.  They were like an old-school UNSET! where you could give it a custom label.  But eventually everything was generalized so that everything had an isotopic form.</p>
<p>The fact that these forms stopped conveying an error condition meant considering them "bad" wasn't sensible.  I kind of latched onto "quasi" in part because of the tilde's use in approximation, e.g. (3.0001 ~= 3).</p>
<p>(It also sounds a little like "queasy" and the squigglies look wavy and maybe a bit uncomfortable.  <img src="https://forum.rebol.info/images/emoji/twitter/nauseated_face.png?v=9" title=":nauseated_face:" class="emoji" alt=":nauseated_face:">)</p>
<h2>So... Speak Now Or Hold Your Peace?</h2>
<p>Bad naming can have an impact.  I think calling complex numbers "imaginary" is a good example of a bad name that probably caused a few problems.</p>
<p>But I think the names here are good.  It's just going to be a matter of figuring out how to teach people to not be afraid of them.</p>
            <p><small>10 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/quasiforms-stable-unstable-isotopes-simpler-terminology/2005">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/quasiforms-stable-unstable-isotopes-simpler-terminology/2005</link>
          <pubDate>Sun, 08 Jan 2023 21:18:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2005</guid>
          <source url="https://forum.rebol.info/t/quasiforms-stable-unstable-isotopes-simpler-terminology/2005.rss">&quot;Quasiforms&quot;, &quot;Stable/Unstable Isotopes&quot;: Simpler Terminology?</source>
        </item>
        <item>
          <title>REIFY vs. META vs. SOMETHING</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>Originally I suggested that REIFY of an isotope would give its plain form, and you would META it if you wanted a quasiform:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1989">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989/1">~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</a>
</div>
<blockquote>
<ul>
<li>The generic and reversible way to make them real it is to META them and get <code>~true~</code> and <code>~false~</code> quasiforms, which you can UNMETA back to the isotopes</li>
<li>The readable way to make them real is to REIFY them and get <code>true</code> and <code>false</code> as plain WORD!, which only gets turned back into the isotope form if they are bound to variables that hold the isotopes, and you evaluate them.</li>
</ul>
</blockquote>
</aside>
<p><em>But that's not a full coverage answer.</em></p>
<ul>
<li>
<p>An operator that takes everything "one level up", where isotopes become quasiforms and everything else gets a quote level added.</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; meta true
== ~true~

&gt;&gt; meta 10
== '10
</code></pre>
</li>
<li>
<p>An operator that leaves non-isotopes as they are, but turns isotopes into their quasiforms (and I think this probably is best called REIFY):</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; reify true
== ~true~

&gt;&gt; reify 10
== 10
</code></pre>
</li>
<li>
<p>An operator that leaves non-isotopes as they are, but turns isotopes into their plain forms:</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; something true
== true

&gt;&gt; something 10
== 10
</code></pre>
</li>
</ul>
<p>Specifically for ACTION! isotopes being turned into plain actions, I used an interim term UNRUN, but that's pretty awful.</p>
<p>Making things into isotopes is done with ISOTOPIC:</p>
<pre><code>&gt;&gt; isotopic 10
== ~10~  ; isotope
</code></pre>
<p>It could be a refinement to REIFY, like REIFY/PLAIN.  But at that point it could be two steps that might be clearer: NOQUASI REIFY, where NOQUASI would be like NOQUOTE and not complain if the thing you passed it was not a quasiform.</p>
<p>Maybe... CONCRETIZE?  That sounds like it might do a bit more work than what REIFY does :-/</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; concretize true
== true

&gt;&gt; concretize 10
== 10
</code></pre>
<p>It's not awful.  Main thing is just to have <em>a</em> name for it while the gears turn.  But as usual, throw out suggestions if you have them...</p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/reify-vs-meta-vs-something/2001">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/reify-vs-meta-vs-something/2001</link>
          <pubDate>Thu, 05 Jan 2023 21:26:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2001</guid>
          <source url="https://forum.rebol.info/t/reify-vs-meta-vs-something/2001.rss">REIFY vs. META vs. SOMETHING</source>
        </item>
        <item>
          <title>~null~ WORD! antiform vs. BLANK! antiform ~_~ as NULL</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>The concept of having isotopic <strong>~true~</strong> and <strong>~false~</strong> as WORD! antiforms instead of having a distinct LOGIC! type <a href="https://forum.rebol.info/t/why-theres-no-boolean-type-storable-in-a-block/2095">is admittedly somewhat weird</a>.  It meant they couldn't be put in blocks and need some sort of transformation if they're going to be put into blocks.</p>
<ul>
<li>
<p>The generic and reversible way to make them real it is to META them and get <code>~true~</code> and <code>~false~</code> quasiforms, which you can UNMETA back to the antiforms</p>
</li>
<li>
<p>The readable way to make them real is LOGIC-TO-WORD them and get <code>true</code> and <code>false</code> as plain WORD!, which only gets turned back into the antiforms if they are bound to variables that hold the antiforms, and you evaluate them.</p>
</li>
<li>
<p>Your circumstance may mean that neither of those choices are what you want when in a situation where the antiforms can't work...maybe it means you have to rethink what you're doing, or maybe you want some other transformation.  It's good to be alerted to the fact that it's dodgy to put what you think of as a "logic" in a reified context.</p>
</li>
</ul>
<p>One should note that Lisp has no false at all, only NIL for false (since everything else is truthy, you could use anything else for true, but they have T predefined).  But their NIL isn't an antiform--so it can appear in lists literally.</p>
<p>And as I've repeatedly pointed out, Redbol's historical choice to render LOGIC! conflated with the words <code>true</code> and <code>false</code> (instead of <code>#[true]</code> and <code>#[false]</code>) shows a desire to avoid the logic literals "escaping" into the reified consciousness of the user.  Making the logic forms actually impossible to put into blocks without a conscious transformation feels like it's good.</p>
<p>I know it's a strange choice, but it's seeming like it fits with the territory.  It's a sort of tradeoff you need when you choose to be firm that TRUE and FALSE are redefinable words and not lexical forms of logic constants.</p>
<h2>
<a name="null-was-once-_-antiform-but-now-null-antiform-1" class="anchor" href="https://forum.rebol.info#null-was-once-_-antiform-but-now-null-antiform-1"></a>NULL Was Once ~_~ Antiform, But Now <code>~null~</code> antiform</h2>
<p>Once upon a time I called antiform BLANK! null.  It was not pretty looking:</p>
<pre><code>&gt;&gt; null
== ~_~  ; anti

&gt;&gt; _
== ~_~  ; anti
</code></pre>
<p>It was because I made BLANK! evaluate to its antiform.  This meant if you assign a bunch of variables to null, it gave a pretty visibility to the actual values to pay attention to:</p>
<pre><code>obj: make object! [
    alpha: _
    beta: _
    delta: true
    epsilon: ~
    gamma: "nutty"
    rho: _
    omega: 'now
 ]
</code></pre>
<p>I was reticent about using the word antiform ~null~, because at source level we're writing:</p>
<pre><code>obj: make object! [
    alpha: null
    beta: null
    delta: true
    epsilon: ~
    gamma: "nutty"
    rho: null
    omega: 'now
 ]
</code></pre>
<p>And if we view it after evaluation that fetches (<code>null</code> =&gt; <code>~null~  ; anti</code>), it <em>seemed</em> uglier:</p>
<pre><code>make object! [
    alpha: ~null~
    beta: ~null~
    delta: ~true~
    epsilon: ~
    gamma: "nutty"
    rho: ~null~
    omega: 'now
 ]
</code></pre>
<p>We can't show it as the WORD! null because there's no guarantee that word always will evaluate back to the null isotope.  But the concept was that since BLANK! can't be redefined, we can put it in an evaluative context as a substitute for <code>~_~</code> if we want.</p>
<p>If we were "more honest" and just META'd the antiform blank, we'd get renders like:</p>
<pre><code>make object! [
    alpha: ~_~
    beta: ~_~
    delta: ~true~
    epsilon: ~
    gamma: "nutty"
    rho: ~_~
    omega: 'now
 ]
</code></pre>
<p>Which I actually liked that less than seeing <strong><code>~null~</code></strong> there.</p>
<h2>
<a name="i-was-torn-but-chose-the-word-antiform-null-2" class="anchor" href="https://forum.rebol.info#i-was-torn-but-chose-the-word-antiform-null-2"></a>I was torn, but Chose The WORD! Antiform ~null~</h2>
<p>Certainly having people be able to see ~null~ written out as a word corresponds to what we want to refer to the state as.  We aren't going to replace people's vernacular to say "antiform blank" instead of null.  And trying to teach people "antiform blank is null" is an uphill battle.</p>
<p>Let's look back at that seemingly beautiful situation with all the blanks-to-nulls at source level:</p>
<pre><code>obj: make object! [
    alpha: _
    beta: _
    delta: true
    epsilon: ~
    gamma: "nutty"
    rho: _
    omega: 'now
 ]
</code></pre>
<p>The <strong><code>~</code></strong> is now an assignable state meaning variable is not set.  How often will you want to set something to NULL...which won't generate an error on access like being unset would, but is falsey and can't be passed to many routines without a MAYBE?</p>
<p><strong>Statistically, we might often have a situation where NULL is the minority initialization, more like this:</strong></p>
<pre><code>obj: make object! [
    alpha: ~
    beta: ~
    delta: true
    epsilon: null
    gamma: "nutty"
    rho: ~
    omega: 'now
 ]
</code></pre>
<p>My point is that intentionally initializing things to null may not be as common as setting to an error-provoking unset state.  And when null happens it may be just as noteworthy to call out as setting something to true or false.</p>
<p><strong>My general intuition was that from a user's standpoint, it's an uphill battle to teach them antiform blank is something called "null"... and that the majority of technical problems that are involved in making NULL be a word isotope are problems that have to be tackled anyway with true and false as word isotopes.</strong></p>
<p>Additionally, I've written about my desire for BLANK!s to serve in dialects as spaces.  That gets very screwed by the (<strong><code>_</code></strong> =&gt; <strong><code>~_~</code>  ; anti</strong>) evaluation.  Recovering blank for space intent and having them be unevaluated was good</p>
<h2>
<a name="some-technical-difficulties-of-null-3" class="anchor" href="https://forum.rebol.info#some-technical-difficulties-of-null-3"></a>Some Technical Difficulties of ~null~</h2>
<p>It had some of the same problems as having to deal with the type checking of LOGIC! actually being an antiform subclass of two words.  It means "NULL!" is an isotopic subclass of one word, so there's no specific null datatype.</p>
<p>Previously NULL cells held nothing, so I'd put a payload of the file and line that were in effect in the evaluator.  This was supposed to give better errors about where a null originated from.  This could still be done if NULL was a special case of WORD! antiform that said it was null via a flag vs. storing the symbol, but could be complicated.  None of the better error mechanics were done yet.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/null-word-antiform-vs-blank-antiform-as-null/1989">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/null-word-antiform-vs-blank-antiform-as-null/1989</link>
          <pubDate>Tue, 25 Oct 2022 04:07:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1989</guid>
          <source url="https://forum.rebol.info/t/null-word-antiform-vs-blank-antiform-as-null/1989.rss">~null~ WORD! antiform vs. BLANK! antiform ~_~ as NULL</source>
        </item>
        <item>
          <title>CLOCK as a Noun</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>Boris made a timing function called "CLOCK", as a sort of replacement for DELTA-TIME:</p>
<p><a href="https://github.com/red/red/blob/81ff4d605df371dfc430b92611605e80f5e5780b/environment/functions.red#L1126">https://github.com/red/red/blob/81ff4d605df371dfc430b92611605e80f5e5780b/environment/functions.red#L1126</a></p>
<pre><code>clock: function [
    "Display execution time of code, returning result of it's evaluation"
    code [block!]
    /times n [integer! float!]  ; float for e.g. `1e6` instead of `1'000'000`
        "Repeat N times (default: once); displayed time is per iteration"
    /delta "Don't print the result, return time delta per iteration (in msec)"
 ]
</code></pre>
<p>It builds in iteration...which is useful for timing, since you often want to loop over things they time.  And at least in theory it should be in the native timing construct--you'd prefer not to have an interpreted call to REPEAT being part of what you count in your time.</p>
<p>(Perhaps the repeat count should just be a required first argument--since CLOCK 1 is so easy to type, why make people fuss over CLOCK/TIMES and then putting the number of times all the way at the end somewhere?)</p>
<h2>
<a name="but-i-think-clock-should-be-a-noun-1" class="anchor" href="https://forum.rebol.info#but-i-think-clock-should-be-a-noun-1"></a><em>But...</em> I Think CLOCK should be a Noun</h2>
<p><strong>clock.time</strong> and <strong>clock.date</strong> have many advantages over <strong>now/time</strong> and <strong>now/date</strong>.</p>
<p>It implies that you could pass a clock around or copy it...which is a good thing.  So by default the CLOCK could be UTC (for programming convenience).  But you could copy that clock and set your module's meaning of the word CLOCK to speak in terms of local time.</p>
<p>Also it resolves a big annoyance of mine: NOW being a function that has a lot of conflicting refinements.  If CLOCK were an object, then <strong>.time</strong> and <strong>.date</strong> would be separate methods of that object, so you couldn't say things like <code>clock.time.date</code>.</p>
<p>And then you could capture the current time into a variable as <strong><code>now: clock.time</code></strong> which makes more sense to me than saying "now" is itself a verb.  <em>(It then wouldn't stay current as "now" in the sense of "exactly this moment", but in language we're pretty comfortable saying "things are different now than they were in the '80s"...e.g. there can be a prolonged linguistic notion of now.  I prefer to use it in this sense.)</em></p>
<p>As far as functional programming goes: because code doesn't have an intrinsic notion of time, you can show that a piece of code is dependent on a clock by passing one as a parameter.</p>
<p>This would allow you also to have code run simulating at a different time.  You could see how a piece of code would perform if it thought it were running at some pathological date, while working alongside other code that was operating with the current notion of time--e.g. to communicate with some webservers to upload results from a test of something like a Y2K problem simulated by other code.</p>
<h2>
<a name="what-to-call-the-timing-construct-2" class="anchor" href="https://forum.rebol.info#what-to-call-the-timing-construct-2"></a>What to Call The Timing Construct?</h2>
<p>To think in terms of super-powers, then you need...<em>a dialect</em> !</p>
<p>Perhaps it could be called "CHRONO"?</p>
<p>Maybe CHRONO quotes its argument, and if you give it a GROUP!, it thinks of that as something to time and run just once.</p>
<pre><code>&gt;&gt; chrono (my-function 1 2 3)
0.14 μs
== &lt;result&gt;
</code></pre>
<p>But if you pass a BLOCK! it could permit more options, like saying what you wanted the timing in terms of:</p>
<pre><code>chrono [msec (my-function 1 2 3)]
chrono [usec (my-function 1 2 3)]
</code></pre>
<p>Or the repeat count (being a parameter to chrono means you're not timing a REPEAT inside your code, ideally).</p>
<pre><code>&gt;&gt; chrono [1e7 (1 + 2)]
0.14 μs    [1 + 2]
== 3
</code></pre>
<p>I'm busy with other things and so I'm not going to go research all the possible features you might want from a timing dialect--I'm sure there's plenty of prior art in the domain.  Just wanted to get it started.  Use your imagination.  <img src="https://forum.rebol.info/images/emoji/twitter/unicorn.png?v=12" title=":unicorn:" class="emoji" alt=":unicorn:" loading="lazy" width="20" height="20"></p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/clock-as-a-noun/1956">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/clock-as-a-noun/1956</link>
          <pubDate>Sat, 03 Sep 2022 06:47:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1956</guid>
          <source url="https://forum.rebol.info/t/clock-as-a-noun/1956.rss">CLOCK as a Noun</source>
        </item>
        <item>
          <title>Should THROW and CATCH Be For Errors?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>The historical Rebolism of THROW and CATCH has nothing to do with error handling.</p>
<p>It's a generic way to move values up the stack.  It gives you a handy "out" from control flow:</p>
<pre><code>result: catch [
    if condition [throw result]
    some code
    case [
        condition [more code]
        condition [more code, throw result]
    ]
    additional code
    throw result
]
</code></pre>
<p>The implementation of the feature is lightweight, and built on the same mechanic as RETURN.  You could in fact use return to do this:</p>
<pre><code>result: do func [] [
    if condition [return result]
    some code
    case [
        condition [return code]
        condition [more code, return result]
    ]
    additional code
    return result
]
</code></pre>
<p>But that's more heavyweight, because it gets binding involved (although I've suggested that maybe CATCH and THROW should be definitional, and the "heaviness" is a feature... not a bug).</p>
<h2>It's A Neat Feature, But I Want THROW and CATCH For Errors</h2>
<p>Error handling is undergoing a renaissance in Ren-C, and it's becoming completely pervasive.</p>
<p>Despite its glory, it is currently tied in with the junky names RAISE and EXCEPT.</p>
<pre><code>case [
   ...code that may fail...
] then [
   ...stuff to do if non-NULL, non-VOID, non-RAISED error!...
] else [
   ... stuff to do if NULL or VOID or RAISED error!...
] except e -&gt; [
  ... error handling ...
]
</code></pre>
<p>The word EXCEPT is bad for several reasons:</p>
<ul>
<li>
<p>It implies "exception" handling, <em>which definitional errors are specifically not</em>...they can only be caught one stack step at a time.</p>
<ul>
<li>Arbitrary exception handling is taboo for very good reasons...and I've made it more taboo by <a href="https://forum.rebol.info/t/discouraging-use-of-trap/1871/3">moving that behavior to SYS.UTIL.RESCUE</a>
</li>
</ul>
</li>
<li>
<p>It's not really a "verb"</p>
</li>
<li>
<p>It often comes right after an ELSE, and I don't like the alliteration of E and E</p>
</li>
<li>
<p>Almost every other language uses CATCH there</p>
</li>
</ul>
<p>And RAISE isn't exactly my favorite word either.  <strong>return throw e</strong> vs. <strong>return raise e</strong> also has that alliteration issue.</p>
<h2>So What Can The Old THROW and CATCH Be Called?</h2>
<p>It's a lot less important than the error handling application, but I still use the old construct.</p>
<p>You can actually do it with CYCLE and STOP:</p>
<pre><code>result: cycle [
    if condition [throw result]
    some code
    case [
        condition [more code]
        condition [more code, stop result]
    ]
    additional code
    stop result
]
</code></pre>
<p>Being a looping construct, it has the side effect that it will keep repeating unless a value is emitted.</p>
<p>On the plus side...this helps resolve the semantic question of "what should a CATCH return when there's no THROW?"  If what you have is CYCLE then your answer is that it keeps going.  So you either put a FAIL at the bottom, a STOP at the bottom, or accept it will keep going.</p>
<p>On the minus side...if you use this inside a looping construct you'll be redefining BREAK, which historical CATCH would not do.  (Similarly, if you use FUNC and RETURN to do this you'd redefine RETURN.)</p>
<p>With definitional BREAK and RETURN there'd be workarounds for those cases--you'd simply give another name to the outer break and return if you needed them.  But that's not how things work today.</p>
<h2>While CYCLE is Not Perfect, It Would Work For The Moment</h2>
<p>We can meditate on what the ultimate answer would be.  But there's only a few cases, and CYCLE will do.</p>
<p>Errors need THROW and CATCH...they're now too fundamental to not use the good words for.</p>
<p>We now have the word TRAP for those who don't want to use enfix, so these are equivalent:</p>
<pre><code>if e: trap [some code] [
    handle e
]

(some code) catch e -&gt; [
   handle e
]
</code></pre>
<p>But you get some real benefits from the THEN + ELSE + CATCH, and I think the importance of these enfix constructs will become apparent to those who aren't on the bandwagon (yet).</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-throw-and-catch-be-for-errors/1954">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-throw-and-catch-be-for-errors/1954</link>
          <pubDate>Thu, 01 Sep 2022 11:50:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1954</guid>
          <source url="https://forum.rebol.info/t/should-throw-and-catch-be-for-errors/1954.rss">Should THROW and CATCH Be For Errors?</source>
        </item>
        <item>
          <title>JUST For Sale - Low Mileage, Original Owner, Like New</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>As the /ONLY debacle was chipped away at... slowly... the role of quoting came to the forefront.  Quotes were used to <em>suppress</em> splicing (in contrast with today's isotopic blocks through SPREAD, which <em>request</em> the splicing).</p>
<p>So the anti-spread behavior looked something like:</p>
<pre><code>&gt;&gt; append [a b c] first [[d e]]
== [a b c d e]

&gt;&gt; append [a b c] first ['[d e]]
== [a b c [d e]]
</code></pre>
<p>I'm picking out of an outer block there just to avoid confusion, because notice what happens when there's no container:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c d e]

&gt;&gt; append [a b c] '[d e]
== [a b c d e]
</code></pre>
<p>By design, the evaluator strips off quotes, leading to potential confusion when it comes to what people might think they could do with such a system.</p>
<p>You might think that this is all fine and you could just call the function QUOTE instead of putting a quote mark on the value.  Hence the quoted block is an evaluation <em>product</em> not an evaluation <em>input</em>...and so it makes it to the append:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c d e]

&gt;&gt; append [a b c] quote [d e]
== [a b c [d e]]
</code></pre>
<p>But there were protections that were added to try and discern if you were adding non-inert values without quoting them.</p>
<pre><code>&gt;&gt; append [a b c] "this was presumed okay since it was inert"
== [a b c "this was presumed okay since it was inert"]

&gt;&gt; append [a b c] 'd
** Error: d is a WORD! and evaluative...your callsite might accidentally lose an
    apostrophe if you didn't know what you were doing.  Quote it to be safe.
</code></pre>
<p><em>(Note: I always disliked how these errors were working, I just hadn't gotten to the isotope design yet.  They did afford some protection.)</em></p>
<p>This would lead you to a couple of bad options to work with the case when you had something evalutative at source level:</p>
<pre><code>&gt;&gt; append [a b c] quote 'd
== [a b c d]

&gt;&gt; append [a b c] ''d
== [a b c d]
</code></pre>
<p>In an attempt to make the "just add a thing at source level" case a slight bit easier, I made JUST.</p>
<pre><code>&gt;&gt; just d
== 'd

&gt;&gt; append [a b c] just d
== [a b c d]
</code></pre>
<h3>Let's Take A Moment To Be Thankful For Isotopes...</h3>
<p>All of this is behind us now.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/pray.png?v=9" title=":pray:" class="emoji only-emoji" alt=":pray:"></p>
<p>But of course, the mechanics are actually nearly identical.  Just subtract 1 from all the quoting levels, and allow -1 for BLOCK!s.  <em>(Then build upon years of diligence in bulletproofing the system from leaking -1 quotelevels where they shouldn't be.)</em></p>
<h2>But JUST is Free Again.  Now What?</h2>
<p>There was a time when JUST was what I now call THE.</p>
<pre><code>&gt;&gt; just x
== x

&gt;&gt; just ''[foo]
== ''[foo]
</code></pre>
<p>I thought it was a good word for it at the time.  But THE won me over:</p>
<pre><code>&gt;&gt; the x
== x

&gt;&gt; the ''[foo]
== ''[foo]
</code></pre>
<h3>Maybe Something That Limits to One Expression Only?</h3>
<pre><code>&gt;&gt; just add 1 2
== 3

&gt;&gt; just add 1 2 10
** FAIL: JUST code had residual material: 10
</code></pre>
<p>I've been wanting a syntax for this at the API level, when you think you're running one expression:</p>
<pre><code>REBVAL* sum = rebJust("add", value1, value2, "10");
</code></pre>
<p>In that world, it's not any more typing (actually less typing than rebValue)...but gives you an extra bit of safety.</p>
<p>With regular (non-API) code, I can see it being very useful in generated code scenarios.</p>
<h3>Perhaps A THE-like Operator With A Shade of Meaning In PARSE?</h3>
<p>PARSE needs to keep raw material sometimes, and I've pointed out some of the hazards in the past of making you do this with GROUP!s when nested compositions are involved.</p>
<p>So might these be different?  As an example:</p>
<pre><code>parse ... [x: the ''foo] =&gt; parse ... [x: (the ''foo)]

parse ... [x: just ''foo] =&gt; parse ... [x: '''foo]
</code></pre>
<p>So above, THE is synthesizing ''foo out of whole cloth with no need to match it in the input.  The other would require a ''foo in the input to be considered a match.</p>
<p>For WORD!s, the above sense of JUST isn't as necessary, as there's a decent visual trick:</p>
<pre><code>parse ... [x: just ''foo] =&gt; parse ... [x: '|''foo|]
</code></pre>
<p>But other datatypes would not have this out, and you'd always be reading the thing you see in the rule as having one more quote level than what you're matching.</p>
<p>There's the option of putting it in an @ group:</p>
<pre><code>parse ... [x: just ''foo] =&gt; parse ... [x: @(the ''foo)]
</code></pre>
<p>But this has the problems I mention about nested composition that can be a major hassle when writing rule genreators and you have to weasel something like <strong><code>''foo</code></strong> inside a group inside a composed block.</p>
<p>This definition might jibe with keeping the regular evaluator meaning of JUST as it is (literal but add a quoting level).</p>
<h3>Other Ideas?</h3>
<p>Hopefully no one wants to fight to swap JUST with THE, because I really like THE as it is.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/just-for-sale-low-mileage-original-owner-like-new/1923">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/just-for-sale-low-mileage-original-owner-like-new/1923</link>
          <pubDate>Fri, 19 Aug 2022 03:09:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1923</guid>
          <source url="https://forum.rebol.info/t/just-for-sale-low-mileage-original-owner-like-new/1923.rss">JUST For Sale - Low Mileage, Original Owner, Like New</source>
        </item>
        <item>
          <title>&quot;I&#39;m not BAD!...I&#39;m just MOLD-ed that way...&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>I'm tinkering with an implementation of <a href="https://forum.rebol.info/t/should-everything-have-an-isotopic-form/1889/5">fully generic isotopes</a>.  The idea is that all types have an isotopic form, and routines can choose to react to this isotopic form giving it special meaning.</p>
<p>This means the tilde markings which used to designate a BAD-WORD! would be ways of making any value isotopic:</p>
<pre><code>&gt;&gt; ~foo~
== foo  ; isotope

&gt;&gt; ~[d e]~
== [d e]  ; isotope

&gt;&gt; ~1020~
== 1020  ; isotope

&gt;&gt; ~#[datatype word!]~
== #[datatype word!]  ; isotope
</code></pre>
<p>The notation is not an isotope itself, it's just used to produce them.  And if you're looking in an object and see it molds out fields that are these and non-quoted, that implies that the field itself actually holds an isotope.</p>
<pre><code>&gt;&gt; obj: make object! [x: spread [d e], y: ~[d e]~, z: '~[d e]~]
== make object! [
    x: ~[d e]~
    y: ~[d e]~
    z: '~[d e]~
]

&gt;&gt; obj.x
** Error: obj.x is a BLOCK! isotope, use ^META to access

&gt;&gt; obj.y
** Error: obj.y is a BLOCK! isotope, use ^META to access

&gt;&gt; obj.z
== ~[d e]~
</code></pre>
<p>So you can see how the notation works with the generic form, and can be quoted itself.</p>
<h2>I Kind Of Want To Curtail Use Of These In Source...</h2>
<p>The original thought about BAD-WORD! was that their ugly notation was supposed to be used to draw attention to them.  So like in the object molding above, you'd be able to see where the isotopes were and it would guide your eyes to the problem.</p>
<p><em>And in fact, I'm not even 100% sure that we want to support storing isotopes in variables unless we absolutely have to.</em>  Perhaps isotopic blocks would generate errors if you tried--and it would force you to use a ^META operation to persist it.  But a representation that evaluates to them is needed for mechanical reasons either way.</p>
<p>Nevertheless, you <em>could</em> use them to do things like splicing literal blocks:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c [d e]]

&gt;&gt; append [a b c] ~[d e]~
== [a b c d e]
</code></pre>
<p>It would actually be an efficient way to do it, but I feel like it might numb people to the squiggles...which are intended to draw attention to cases where the isotopes leaked through an operation and shouldn't have.  So best practices would suggest using operators instead</p>
<pre><code>&gt;&gt; append [a b c] spread [d e]
== [a b c d e]
</code></pre>
<h2>But The ~XXX~ Forms Need A Name... Is It BAD! ?</h2>
<p>I'd called ~xxx~ a BAD-WORD!.  Now that the tildes are a generic container kind of like QUOTED!, that would default to just being... BAD!</p>
<pre><code>&gt;&gt; type of fourth [a b c ~[d e]~]
== #[datatype! bad!]
</code></pre>
<p>So there's going to be a whole naming situation for operations to get the contained item out, and what to call this container.</p>
<p><em>(If it's so BAD, does it need to be... REFORMed?  <img src="https://forum.rebol.info/images/emoji/twitter/stuck_out_tongue.png?v=9" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"> )</em></p>
<p>I don't know how to fit this into the isotope naming scheme...it's a thing that generates isotopes when it evaluates.  The analogy breaks down if you try to call it a NUCLEUS or something odd like that.</p>
<p>Calling the ~xxx~ forms BAD! does have the advantage of being able to combine that and say ~[d e]~ is a "bad block" and ~1020~ is a "bad integer", but... you'll see these in well-formed programs.  It makes it sound like something is <em>corrupt</em>, when the real intent is different.</p>
<p>It could be called QUASI! which could related it to QUOTED!.  <em>"~[d e]~ is a quasi-block"</em></p>
<p>Bear in mind they can be quoted, so <code>'~[d e]~</code> would then be a "quoted quasi-block".  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>In some sense, [d e] and ~[d e]~ and '[d e] and ''[d e] could all be thought of as "isotopes" of blocks...in addition to what we call the "isotope" form (which has no representation, because it's something you can only measure by turning it into another form).</p>
<p>So we might call ~[d e]~ a "block isotope", and then give some other name to the invisible status that it produces...?</p>
<pre><code>&gt;&gt; ~[d e]~  ; call this a block isotope?
== [d e]  ; then this could be... a... ghost block?
</code></pre>
<p>But overall my leaning is that I like calling the ephemeral form "isotope", because I think that captures its weird invisible/reactivity/decaying character.</p>
<h2>The Pejorative "BAD!" May Seem Harsh, But May Be Good?</h2>
<p>If the name can scare people out of trying to use these too much at source level, that's not the worst outcome.</p>
<p>But then there still have to be ways of getting the contents out.  QUOTED! has UNQUOTE and NOQUOTE to take off quoting layers, and QUOTE to add them on.</p>
<p>Right now I've got MAKE BAD! to produce them:</p>
<pre><code>&gt;&gt; make bad! 1020
== ~1020~

&gt;&gt; make bad! [d e]
== ~[d e]~
</code></pre>
<p>If we called them something like TOXIC! then there could be detox and toxify.  <img src="https://forum.rebol.info/images/emoji/twitter/radioactive.png?v=9" title=":radioactive:" class="emoji" alt=":radioactive:"></p>
<p><strong>There's plenty to be involved with working out the mechanics and not worrying about the names, but wanted to put the naming issue out to be mulled over.</strong></p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/im-not-bad-im-just-mold-ed-that-way/1911">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/im-not-bad-im-just-mold-ed-that-way/1911</link>
          <pubDate>Fri, 05 Aug 2022 09:33:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1911</guid>
          <source url="https://forum.rebol.info/t/im-not-bad-im-just-mold-ed-that-way/1911.rss">&quot;I&#39;m not BAD!...I&#39;m just MOLD-ed that way...&quot;</source>
        </item>
        <item>
          <title>ALL [...] vs. CASE/ALL</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <blockquote>
<p><em>(Note: This is from an old post 4 years ago that was bundled with <a href="https://forum.rebol.info/t/any-vs-parses-any-can-we-have-consistency/741">complaints about PARSE's ANY</a>.  The ANY issue turned into its own whole universe of study...however, this question got brushed aside.  I'm making it it's own thread, now.)</em></p>
</blockquote>
<p>ALL is a <em>short-circuit</em> construct. The first time it sees a falsey thing, it stops.</p>
<pre><code>&gt;&gt; all [(probe 1) (probe 2 false) (probe 3)]
1
2
; null
</code></pre>
<p>But CASE/ALL is <em>explicitly not short-circuit</em>.  It takes away CASE's short-circuiting...where the /ALL makes it evaluate <em>every</em> condition.  So it will potentially run branches even after it has seen falsey conditions:</p>
<pre><code>&gt;&gt; case/all [true [probe 1] false [probe 2] true [probe 3]]
1
3
== 3
</code></pre>
<p>Ren-C chose to make CASE/ALL return <em>the evaluation of the branch associated with the last truthy condition</em>. (Rebol2 and Red just return false if the last condition was falsey.) That aside, both of them evaluate "all of the cases".</p>
<p>This also applies to SWITCH, which has an /ALL refinement as well.</p>
<p><strong>Could we have a word for something that wasn't short-circuit, yet evaluated "all" of the conditions...and just returned the last truthy one or NULL?</strong></p>
<h2>
<code>CASE/MULTI</code> ? <code>CASE/MANY</code> ?</h2>
<p>I just think that using CASE/ALL is misleading when put up against ALL, which is another native control structure...defined in the same file.  Having ALL mean something entirely opposite irks me.</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/all-vs-case-all/1874">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/all-vs-case-all/1874</link>
          <pubDate>Tue, 12 Jul 2022 04:30:55 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1874</guid>
          <source url="https://forum.rebol.info/t/all-vs-case-all/1874.rss">ALL [...] vs. CASE/ALL</source>
        </item>
        <item>
          <title>Discouraging use of TRAP</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>With <a href="https://forum.rebol.info/t/fail-vs-return-fail-the-new-age-of-definitional-failures/1852">definitional errors</a>, the landscape changes considerably for how we think about error handling.</p>
<p><strong>In this world, there are <em>not a lot of good reasons</em> to use what we've been calling "TRAP".</strong> (historical Redbol's TRY)</p>
<p>By its design, TRAP will intercept <em>any</em> error in code at <em>any</em> depth.  I've shown that when ATTEMPT was based on this, it was not good:</p>
<pre><code>&gt;&gt; attempt [print "Attempting to read file" read %nonexistent-file.txt]
Attempting to read file
; null

&gt;&gt; attempt [print "Attempting but made typos" rread %nonexistent-file.txt]
; null
</code></pre>
<p>That's fixed now, because ATTEMPT is based on REDUCE-EACH with a ^META variable.</p>
<p>But back to TRAP.  The problem isn't just about typos.  It's about the illusion that there's something you can do to react to an arbitrary error...when the constructs you were using didn't even understand it well enough to pipe it through to their output.</p>
<p><strong>In almost all cases, a "TRAP"'d error cannot be reacted to sanely...it has to be reported.</strong></p>
<p>It's for this reason that languages like Rust pretty much enforce a panic</p>
<p>And our case is even more compelling.  For example: How many places is it ever a good idea to sweep a typo under the rug, and just run some other code?</p>
<p>The few cases it's legitimate are things like the console...where you trap the error and present it, so the user knows it happens and can do something about it.  <em>This sort of thing is nearly the only legitimate usage of TRAP.</em></p>
<h2>Might We Make It Look More "Special" To Discourage Use?</h2>
<p>I thought at minimum we should move it to a place that shows it's more of a "system utility" than a "language feature".</p>
<p>So calling it <strong><code>SYS.UTIL.TRAP</code></strong> would be a step in that direction.</p>
<p>And as long as we're discouraging use of this, it seems a bit of a waste to take such a short name.  It could be <strong><code>SYS.UTIL.TRAP-ANY-ERROR</code></strong> or similar, and then TRAP could be used for something should be used more often.</p>
<p>(It could act like ATTEMPT, but evaluate to the error as its primary result instead of the body of the block.)</p>
<p>Things to think about.  Anyway, I've made some progress on definitional errors in the scanner and with TO and MAKE operations, so some of the things people like to trap (like conversions) should work correctly with attempt now.</p>
<p>For instance, in this finite-integer world... an out of range error:</p>
<pre><code>&gt;&gt; attempt [to integer! "10483143873258978444434343"]
; null

&gt;&gt; attempt [to intgeer! "10483143873258978444434343"]
** Script Error: intgeer! word is attached to a context, but unassigned

&gt;&gt; to integer! "10483143873258978444434343" except e -&gt; [print ["Error:" mold e]]
Error: make error! [
    type: 'Script
    id: 'bad-make-arg
    message: ["cannot MAKE/TO" :arg1 "from:" :arg2]
    near: [to integer! "10483143873258978444434343" ** except e -&gt; ***]
    where: [to args]
    file: '
    line: 1
    arg1: #[datatype! integer!]
    arg2: "10483143873258978444434343"
]
</code></pre>
<p>Should be a more specific error, now that I look at that.  But I guess it just wasn't.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/discouraging-use-of-trap/1871">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/discouraging-use-of-trap/1871</link>
          <pubDate>Sun, 10 Jul 2022 16:05:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1871</guid>
          <source url="https://forum.rebol.info/t/discouraging-use-of-trap/1871.rss">Discouraging use of TRAP</source>
        </item>
        <item>
          <title>Renaming MAP! to DICTIONARY!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>Rebol's historical leaning was to give things "plain names", even when that ran counter to computing tradition.</p>
<p>(For instance DECIMAL! was called that instead of what it really was... a FLOAT!, because "floating point" is too techie a concept.  Yet "decimal" means a different type of numeric representation underlying the math.  Red reversed this decision, and calls floating point numbers FLOAT!)</p>
<p><strong>There has been rough consensus that MAP should be a verb, for applying an operation across a data structure.</strong></p>
<p>To recap, with Ren-C's concept of generators, we could make a generator called EACH</p>
<pre><code>&gt;&gt; gen: each [1 2]

&gt;&gt; gen
== 1

&gt;&gt; gen
== 2

&gt;&gt; gen
; null
</code></pre>
<p>And then we've talked about how FOR would call the generator repeatedly until it hit NULL, returning the last body result:</p>
<pre><code>&gt;&gt; for x each [1 2] [print [x], x * 10]
1
2
== 20
</code></pre>
<p>So MAP has been suggested as being the version that collects the body results as you go:</p>
<pre><code>&gt;&gt; map x each [1 2] [print [x], x * 10]
== [10 20]
</code></pre>
<p>Seems pretty neat and composable, huh?</p>
<p>But this makes it feel like calling a datatype MAP! just muddles things.</p>
<p>DICTIONARY! is a bit long to write out, but... people seemed to tolerate "refinement".  Same number of letters (and wider in a non-fixed width font...)</p>
<pre><code>DICTIONARY!
REFINEMENT!
</code></pre>
<p>DICTIONARY<br>
REFINEMENT</p>
<p>...so dictionary doesn't really seem so bad, if you ask me.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/renaming-map-to-dictionary/1856">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/renaming-map-to-dictionary/1856</link>
          <pubDate>Fri, 01 Jul 2022 16:06:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1856</guid>
          <source url="https://forum.rebol.info/t/renaming-map-to-dictionary/1856.rss">Renaming MAP! to DICTIONARY!</source>
        </item>
        <item>
          <title>What to call an Arity-1 wget or curl-like function?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1840">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>At first I just did a <strong>wget</strong> of the scripts:</p>
</blockquote>
</aside>
<p>I've felt for a while we need something parallel to wget where you just specify a URL! of what you want and it writes it.</p>
<p>Calling it <strong>wget</strong> or <strong>curl</strong> would come with expectations that it would have all the options of those programs <em>(I think we could/should make variadic WGET and CURL functions that emulate a useful subset of those options!)</em></p>
<p>Is there a good name for a simpler arity-1 function that just does the above?</p>
<pre><code>xxx: func [filename [file! url!]] [
    write (second split-path filename) (read filename)
]</code></pre>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/what-to-call-an-arity-1-wget-or-curl-like-function/1841">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-to-call-an-arity-1-wget-or-curl-like-function/1841</link>
          <pubDate>Tue, 14 Jun 2022 11:46:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1841</guid>
          <source url="https://forum.rebol.info/t/what-to-call-an-arity-1-wget-or-curl-like-function/1841.rss">What to call an Arity-1 wget or curl-like function?</source>
        </item>
        <item>
          <title>Singular ANY-SPACE vs. Plural WHITESPACE?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>Transitions have made some parse rules get longer:</p>
<pre><code> [any whitespace]  ; being repurposed--seems like "pick one" not a loop construct
 =&gt;
 [while whitespace]  ; being repurposed to arity-2; arity-1 form is unsettling
 =&gt;
 [try some whitespace]
</code></pre>
<p>But this seems a bit overlong...especially considering that whitespace is such a long word.</p>
<p>It occurs to me that "whitespace" can be itself plural.  Might we say that ANY-SPACE is a character set, and then <strong><code>whitespace: [some any-space]</code></strong> ?</p>
<p>This at least gets you down to <strong><code>whitespace</code></strong> or <strong><code>try whitespace</code></strong>...which seems pretty minimal for the intent (unless you're going to go with abbreviations like <strong><code>ws*</code></strong> or similar).</p>
<p>I really don't know how many cases there are where you are willing to tolerate only a single unit of an arbitrary whitespace character.  When does that come up?  Usually if you're matching a single whitespace character you know which one you're reacting to...and the only time you'd ever bundle up a collection of them together is when you're willing to skip a lot of it.</p>
<p>I doubt there'd be many uses of ANY-SPACE in a rule, and that it would just be used to compound other character collections.</p>
<p>It means WHITESPACE would be a parse rule--not a charset--so you would have to use ANY-SPACE for character set in non-PARSE code, but that doesn't seem so bad.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/singular-any-space-vs-plural-whitespace/1828">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/singular-any-space-vs-plural-whitespace/1828</link>
          <pubDate>Thu, 19 May 2022 09:05:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1828</guid>
          <source url="https://forum.rebol.info/t/singular-any-space-vs-plural-whitespace/1828.rss">Singular ANY-SPACE vs. Plural WHITESPACE?</source>
        </item>
        <item>
          <title>Construct For Updating Variable With Value (If It&#39;s Not Void)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>This is a construct that I think <a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a> originally suggested, which is kind of a reverse-DEFAULT.  A variable is optionally updated, but left as-is if the value you try to update to is void.</p>
<pre><code>&gt;&gt; x: &lt;a&gt;
== &lt;a&gt;

&gt;&gt; x: perhaps if false [&lt;b&gt;]
== &lt;a&gt;

&gt;&gt; x
== &lt;a&gt;

&gt;&gt; x: perhaps if true [&lt;c&gt;]
== &lt;c&gt;

&gt;&gt; x
== &lt;c&gt;
</code></pre>
<p>An implementation of this would look something like:</p>
<pre><code>perhaps: enfixed func* [
    "Set word or path to a default value if that value is a value"
    return: [&lt;opt&gt; any-value!]
    'target [set-word! set-path!]
        "The word to which might be set"
    optional [&lt;opt&gt; &lt;void&gt; any-value!]
        "Value to assign only if it is not void"
][
    if semiquoted? 'optional [
        ;
        ; DEFAULT requires a BLOCK!, PERHAPS does not.  Catch `x: perhaps [...]`
        ;
        fail 'optional [
            "Literal" type of :optional "used w/PERHAPS, use () if intentional"
        ]
    ]

    ; Note that right evaluates before left here:
    ; https://github.com/rebol/rebol-issues/issues/2275
    ;
    if null? :optional [return get/any target]
    return set target :optional
]
</code></pre>
<p><strong>It's a nice thing to have, but I'm not sure what to call it.</strong>  Once upon a time it was called MAYBE, before the term was taken for the purpose of converting nulls to voids (which I think is a good fit).</p>
<p>PERHAPS seems too indistinguishable from MAYBE, and I don't know there's any clear reasoning as to why it would be called that.</p>
<p>I think UPDATE was suggested:</p>
<pre><code> &gt;&gt; x: 10
 == 10

 &gt;&gt; x: update void
 == 10

&gt;&gt; x 
== 10

&gt;&gt; x: update 20
== 20

&gt;&gt; x
== 20
</code></pre>
<p>But I dunno about that either.  Ideas?</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/construct-for-updating-variable-with-value-if-its-not-void/2037">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/construct-for-updating-variable-with-value-if-its-not-void/2037</link>
          <pubDate>Tue, 17 May 2022 03:39:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2037</guid>
          <source url="https://forum.rebol.info/t/construct-for-updating-variable-with-value-if-its-not-void/2037.rss">Construct For Updating Variable With Value (If It&#39;s Not Void)</source>
        </item>
        <item>
          <title>Naming The Infix APPLY Operator</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>Now that we have the <strong><a href="https://forum.rebol.info/t/apply-ii-the-revenge/1834">Super Duper APPLY Operator Version 2.0</a></strong>, what's next...?</p>
<h1>
<a name="making-it-easier-to-use-1" class="anchor" href="https://forum.rebol.info#making-it-easier-to-use-1"></a>Making It Easier To Use!</h1>
<p>Imagine if we let <strong><code>&lt;-</code></strong> be an infix operator...taking the name of the function to apply on the left, and a block on the right:</p>
<pre><code>&lt;-: enfix func [
    'action [word! tuple! path! group!]
    args [block]
][
    apply (if group? action [do action] else [get action]) args
]
</code></pre>
<p>It's rather slick!</p>
<pre><code>&gt;&gt; append &lt;- [[a b c] &lt;d&gt; /dup 2]
== [a b c &lt;d&gt; &lt;d&gt;]

&gt;&gt; append/only &lt;- [[a b c] [e f] /dup 2]
== [a b c [e f] [e f]]
</code></pre>
<p>Of course, you can mix it up with your own freaky ideas, even variadic ones!</p>
<pre><code>&gt;&gt; $: enfixed func ['name [word!] 'args [&lt;variadic&gt; &lt;end&gt; any-value!]] [
    args: make block! args
    apply :(get name) args
]

&gt;&gt; data: [a b c]

&gt;&gt; (append $ /dup 2, data [d e])

&gt;&gt; print ["data is" mold data]
data is [a b c d e d e]
</code></pre>
<p>While that might kind of suck, it just was to get the point that there are options.  The choice is up to you.</p>
<h2>
<a name="we-will-need-an-apply-operator-we-just-have-to-decide-on-it-2" class="anchor" href="https://forum.rebol.info#we-will-need-an-apply-operator-we-just-have-to-decide-on-it-2"></a>We Will Need An Apply Operator, We Just Have To Decide On It</h2>
<p>I think the floodgates are pretty much open on "weird words" now.  The fact that you can't make them into SET-WORD!s or put them in PATH!s will just be life.  Maybe they'll be their own category distinct from WORD!, like SYMBOL! ?</p>
<p>Among things we'll get sooner or later are <strong>:</strong> and <strong>::</strong></p>
<pre><code>append :: [data [d e] /dup 2]
</code></pre>
<p>That's good-looking, but maybe too good looking...I think it should be saved for something in the type system as in other languages.</p>
<p>Arrows are associated with functions, and since <strong><code>-&gt;</code></strong> was being used for lambdas, I said that using leftward arrow for something "function related" made more sense than other things.  Well... APPLY is function-related, is it not?</p>
<pre><code>append &lt;- [data [d e] /dup 2]
</code></pre>
<p>Maybe POINTFREE could be shorthanded with lambda pointing at a GROUP! instead of a BLOCK!, or something along those lines?</p>
<pre><code>&gt;&gt; ap10: -&gt; (append _ 10)

&gt;&gt; ap10 [a b c]
== [a b c 10]

&gt;&gt; mp2: -&gt; (multiply 2)

&gt;&gt; mp2 10
== 20
</code></pre>
<p>It seems to me that if we're concerned that someone wants to actually calculate a body to use for a function, they wouldn't be using the shorthand lambda notation to do that and would use full FUNC.  Or those oddballs would be all right using <strong>-&gt; :(...)</strong> if they wanted that.</p>
<p>There's only so many keys on the keyboard in this universe.  How about it, &lt;- for APPLY?</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/naming-the-infix-apply-operator/2195">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/naming-the-infix-apply-operator/2195</link>
          <pubDate>Thu, 09 Sep 2021 22:52:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2195</guid>
          <source url="https://forum.rebol.info/t/naming-the-infix-apply-operator/2195.rss">Naming The Infix APPLY Operator</source>
        </item>
        <item>
          <title>&quot;DEBUG&quot; builds vs &quot;CHECKED&quot; builds</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>Since this is a language project, the term "Debug" winds up having a bit of an overloaded meaning.</p>
<p>In an ideal world--and this ideal world will hopefully come to pass--the system will have a debugger in the interpreter for helping people diagnose their code.</p>
<p>But then, there is instrumentation added to the system itself--for its own debugging.  Today we call that "a debug build" of the interpreter.</p>
<p>This is pretty standard--when you ask for a debug build of something, that means it has symbols and asserts in it.  It's a known term in the development culture.  Julia or Python or whoever calls their instrumented version <em>"The Debug Build"</em></p>
<p><a href="https://pythonextensionpatterns.readthedocs.io/en/latest/debugging/debug_python.html" class="inline-onebox">10.2. Building and Using a Debug Version of Python — Python Extension Patterns 0.1.0 documentation</a></p>
<p>But there is another term used in the kernel and OS world called a "checked build".</p>
<h2>Would Calling It A "Checked Build" Be Clarifying or Confusing?</h2>
<p>I feel like reserving the term "debug" to use for features related to what the user would call debugging of <em>their</em> code may make more sense--even though this may be a bit odd for a language project vs. an OS one.</p>
<p>Plus the flag names make more sense.  Take a flag with a name like DEBUG_UTF8_EVERYWHERE... if it were CHECK_UTF8_EVERYWHERE that sort of gives a better impression of what's going on.  <em>You're asking for instrumentation</em> that runs independent of whether you actually are debugging anything.  In fact, you can add these checks while not having any "debug symbols" in your build.</p>
<p>I happen to be doing some tweaks that make this a good time for such changes if they are to be made.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/debug-builds-vs-checked-builds/1708">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/debug-builds-vs-checked-builds/1708</link>
          <pubDate>Thu, 09 Sep 2021 14:53:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1708</guid>
          <source url="https://forum.rebol.info/t/debug-builds-vs-checked-builds/1708.rss">&quot;DEBUG&quot; builds vs &quot;CHECKED&quot; builds</source>
        </item>
  </channel>
</rss>

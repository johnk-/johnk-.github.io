<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Errors - AltRebol</title>
    <link>https://forum.rebol.info/c/development/errors/54</link>
    <description>Topics in the &#39;Errors&#39; category For discussion of error handling and error mechanisms.</description>
    
      <lastBuildDate>Sun, 10 Nov 2024 19:25:54 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/errors/54.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Full-Band Return Values from Generators/Yielders</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>Definitional Errors came into PARSE as an answer for how to make it possible to return any value... simply make a failed parse a definitional error.  Not only does it mean that NULL can be a legitimate synthesized product that you don't conflate with failure, but it also means that parse failures can give back more information in the error about what went wrong <em>(farthest parse point reached, etc.)</em>...</p>
<p>Looking at another problem where a sentinel NULL had been used... there's <a href="https://forum.rebol.info/t/yielder-and-generator-and-thinking-about-coroutines/1311">Generators and Yielders</a>:</p>
<pre><code>&gt;&gt; g: generator [print "A" yield 1, print "B" yield 2, print "C"]

&gt;&gt; g
A
== 1

&gt;&gt; g
B
== 2

&gt;&gt; g
C
== ~null~  ; anti

&gt;&gt; g
== ~null~  ; anti

&gt;&gt; g
== ~null~  ; anti
</code></pre>
<p>But Generators and Yielders predate antiforms in general... they came at a time where there were just two forms of NULL: "heavy" and "light".  So the thought was that if you wanted to actually yield null, it would be the heavy form.</p>
<pre><code>&gt;&gt; g: generator ["Start", yield null, print "Done"]

&gt;&gt; g
Start
== ~[~null~]~  ; anti

&gt;&gt; g
Done
== ~null~  ; anti
</code></pre>
<p>But this isn't nearly as good as using a specific raised error.  If NULL is truly out of band, then you could use <strong><code>try g</code></strong> to get null when there are no more values.</p>
<p>If you try to YIELD or RETURN a raised error, then it would become an abrupt failure.  So you'd be assured that the only time you'd ever get a definitional error back from a generator or yielder would be if it had been exhausted.</p>
<h2><a name="p-7884-pack-returns-for-things-like-key-and-value-in-objects-1" class="anchor" href="https://forum.rebol.info#p-7884-pack-returns-for-things-like-key-and-value-in-objects-1"></a>PACK returns for things like KEY and VALUE in objects?</h2>
<p>As the enumeration routines are retooled to be based on generator functions, it struck me as very cool if generators returned packs, which could be decayed:</p>
<pre><code>&gt;&gt; obj: make object! [a: 10 b: 20 c: 30]

&gt;&gt; g: each obj

&gt;&gt; g
; first in pack of 2 items
== a

&gt;&gt; meta g
== ~['b '20]~

&gt;&gt; [key {val}]: g
== 30

&gt;&gt; key
== c

&gt;&gt; g
** Error: Generator/Yielder exhausted

&gt;&gt; try g
== ~null~  ; anti
</code></pre>
<p>That's really cool, and seems like it would go along with decaying:</p>
<pre><code>for 'key each obj [...]

for [key val] each obj [...]
</code></pre>
<p>This looks pretty nice, however blocks used in FOR-EACH scenarios like this haven't meant "unpack", it has meant keep getting items and assign them to each.</p>
<p>It seems like it would be unfortunate if you had to write the object unpacking as:</p>
<pre><code>for [~[key val]~] each obj [...]
</code></pre>
<p>But that does seem sort of like what you'd have to do in order to make it generalized.  It doesn't look <em>that</em> bad, and it does have a theory behind it...</p>
<pre><code>&gt;&gt; obj: make object! [a: 10 b: 20 c: 30]

&gt;&gt; for [~[key val]~ :otherkey] each obj [  ; leading colon for optionality
       print ["key:" key]
       print ["val:" val]
       if otherkey [
           print ["otherkey:" otherkey]
       ]
   ]

key: a
val: 10
otherkey: b
key: c
val: 30
</code></pre>
<p>This assumes that plain blocks might be taken for some other intent in the FOR.  If it were not:</p>
<pre><code>for [[key val] :otherkey] each obj [...]
</code></pre>
<p>But I had been thinking that plain BLOCK! would likely be good for type checking (<span class="mention">@hiiamboris</span> has some experiments in this vein):</p>
<pre><code>for [x [integer!] y [tag!]] each [1 &lt;a&gt; 2 &lt;b&gt;] [....]
</code></pre>
<h2><a name="p-7884-big-design-space-but-full-band-returns-opens-it-up-2" class="anchor" href="https://forum.rebol.info#p-7884-big-design-space-but-full-band-returns-opens-it-up-2"></a>Big Design Space, but Full-Band Returns Opens It Up</h2>
<p>I'd let the Generator and Yielder experiments atrophy while working on other things.  But I stopped today to try and get the basics working again, and it's interesting to see how isotopes bring a lot to the table...as they seem to have done with nearly everything.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/full-band-return-values-from-generators-yielders/2329">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/full-band-return-values-from-generators-yielders/2329</link>
          <pubDate>Sun, 10 Nov 2024 19:25:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2329</guid>
          <source url="https://forum.rebol.info/t/full-band-return-values-from-generators-yielders/2329.rss">Full-Band Return Values from Generators/Yielders</source>
        </item>
        <item>
          <title>Making FAIL Stand Out With Antiform TAG!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2278">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"><a href="https://forum.rebol.info/t/tripwire-in-the-wild/2278/1">TRIPWIRE in The Wild</a></div>
<blockquote>
<p>But with <strong><a href="https://forum.rebol.info/t/antiform-tag-as-triggers-an-error-on-access-type/2170">antiform tags</a></strong>, you can embed a message into the unset variable:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; state: ~&lt;INITIALIZE-STATE hasn't been called yet&gt;~

&gt;&gt; state
** Script Error: state is ~&lt;INITIALIZE-STATE hasn't been called yet&gt;~ antiform
** See ^(...) and GET/ANY
</code></pre>
</blockquote>
</aside>
<p>I have another use of TRIPWIRE that I don't know if it's good or bad, but...</p>
<hr>
<p>I've always wanted FAIL to stand out more.  When it first was invented (and Ren-C was case-insensitive), I would type FAIL in uppercase to get it:</p>
<pre><code>foo: func [x [integer! text!]] [
    switch/type x [
        integer! [print "It's an integer"]
        text! [print "It's a text"]
        FAIL "unreachable"
    ]
]
</code></pre>
<p>Then I came up with the idea to use QUASI-WORD!s (that would evaluate to antiform words):</p>
<pre><code>foo: func [x [integer! text!]] [
    switch/type x [
        integer! [print "It's an integer"]
        text! [print "It's a text"]
        fail ~unreachable~
    ]
]
</code></pre>
<p>I thought it looked cool and drew attention more than <strong><code>fail "unreachable"</code></strong>, while being the same number of characters.  It acted the same, but cost a bit less due to the interning of the word.</p>
<p>But now, <a href="https://forum.rebol.info/t/renaming-antiword-time-to-call-it-keyword/2277">"keywords" are restricted to a finite system set</a>.   So by necessity, this has changed to use quasiform/antiform TAG!s:</p>
<pre><code>foo: func [x [integer! text!]] [
    switch/type x [
        integer! [print "It's an integer"]
        text! [print "It's a text"]
        fail ~&lt;unreachable&gt;~
    ]
]
</code></pre>
<p>Now it's two more characters, doesn't cost any less than a string, and at the moment still acts the same as a string.  Is it still a useful thing?  Compared with:</p>
<pre><code>foo: func [x [integer! text!]] [
    switch/type x [
        integer! [print "It's an integer"]
        text! [print "It's a text"]
        fail "unreachable"
    ]
]
</code></pre>
<p>I truly like that you can "see" the error better when it's <strong><code>~&lt;unreachable&gt;~</code></strong>...and go "oh, there's an error there".  I imagine this being particularly cool with syntax highlighting.</p>
<p>To make that visibility advantage systemic, would it be reasonable to say that all FAILs take antiform tags and not strings?  Then if you have a message in a text string you would have to say <strong><code>fail [msg]</code></strong> instead of just <strong><code>fail msg</code></strong>.  I don't think that's terribly oppressive.</p>
<p>I don't completely like the idea of it being a choice/synonym, because then people will just stylize their code differently and inconsistently...the same person even making different choices in the same file.  But it could just be a synonym and let you pick what you like for the situation, and maybe that's good.</p>
<p>Or maybe it's a dumb feature.  I don't know.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/making-fail-stand-out-with-antiform-tag/2282">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/making-fail-stand-out-with-antiform-tag/2282</link>
          <pubDate>Mon, 16 Sep 2024 13:31:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2282</guid>
          <source url="https://forum.rebol.info/t/making-fail-stand-out-with-antiform-tag/2282.rss">Making FAIL Stand Out With Antiform TAG!</source>
        </item>
        <item>
          <title>Avoid Raised Errors in PACK! (But Feel The Power!)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>I haven't been completely thrilled about being able to put raised errors in parameter packs.  But initially, I allowed it:</p>
<pre><code>&gt;&gt; block: []
== []

&gt;&gt; pack [take block, 10 + 20]
; first in pack of length 2
== ~make error! [
    type: 'Script
    id: 'nothing-to-take
    message: "Can't TAKE, no value available (consider TRY TAKE)"
    near: '[take [] **]
    where: '[take reduce pack console]
    file: ~null~
    line: 1
]~  ; anti
</code></pre>
<p>Honestly this seems wrong. I allow you to PACK a PACK, and that's okay. But glossing over the error at time of packing I do not like.</p>
<p>I much prefer:</p>
<pre><code>&gt;&gt; pack [take block, 10 + 20]
** Script Error: Can't TAKE, no value available (consider TRY TAKE)
</code></pre>
<h2>
<a name="only-one-use-case-maxmatch-d-and-maxmatch-chttpsgithubcommetaeducationren-cblob8516f0fca8ddce40a97e7647a087dc55e065cf3btestsparseexamplesmaxmatchparsetestreb-1" class="anchor" href="https://forum.rebol.info#only-one-use-case-maxmatch-d-and-maxmatch-chttpsgithubcommetaeducationren-cblob8516f0fca8ddce40a97e7647a087dc55e065cf3btestsparseexamplesmaxmatchparsetestreb-1"></a>Only One Use Case: <a href="https://github.com/metaeducation/ren-c/blob/8516f0fca8ddce40a97e7647a087dc55e065cf3b/tests/parse/examples/maxmatch.parse.test.reb">MAXMATCH-D (and MAXMATCH-C)</a>
</h2>
<p>In practice, only one place was making use of the ability to put raised errors in packs:</p>
<pre><code>maxmatch-D: combinator [  ; "(D)efault"
    {Match maximum of two rules, keeping side effects of both if match}
    return: "Result of the longest match (favors first parser if equal)"
       [any-value? pack?]
    parser1 [action?]
    parser2 [action?]
    &lt;local&gt; result1' result2' remainder1 remainder2
][
    [~^result1'~ remainder1]: parser1 input except e -&gt; [
        pack [raise e, null]
    ]
    [~^result2'~ remainder2]: parser2 input except e -&gt; [
        pack [raise e, null]
    ]
    if raised? unmeta result2' [  ; parser2 didn't succeed
        if raised? unmeta result1' [
            return unmeta result1'  ; neither succeeded
        ]
    ] else [  ; parser2 succeeded
        any [
            raised? unmeta result1'
            (index of remainder1) &lt; (index of remainder2)
        ] then [
            remainder: remainder2
            return unmeta result2'
        ]
    ]
    remainder: remainder1
    return unmeta result1'
]
</code></pre>
<p>Two parsers here are called with two results, and this tries to handle the case of when one "result" is a raised error...putting it into the same slot where a result would be.</p>
<p>The problem is that the EXCEPT statement is producing an expression that is targeting a pack.  And in the first slot of that pack is a potentially-anything-value... anything but a raised error, that is.  If you try to cheat and put a non-raised error in that slot, how would you know the parser you called wasn't just generating an ERROR! value to pass around?  You need another state.</p>
<h2>
<a name="no-other-choice-or-is-there-2" class="anchor" href="https://forum.rebol.info#no-other-choice-or-is-there-2"></a>No Other Choice... Or... Is There?</h2>
<p>The second slot is a series position.  You could poke a plain error there, and by virtue of seeing the <code>remainder1</code> is an ERROR! and not an ANY-SERIES! you'll know that parser1 raised an error.</p>
<p>So instead of:</p>
<pre><code>[~^result1'~ remainder1]: parser1 input except e -&gt; [
    pack [raise e, null]
]
</code></pre>
<p>You'd do:</p>
<pre><code>[^result1' remainder1]: parser1 input except e -&gt; [
    pack [~, e]  ; say result1 is trash, and remainder1 is e
]
</code></pre>
<p>Your variable names are a bit weird here, because it's actually <strong><code>remainder-or-error-1</code></strong>.  But you've built an expression that targets the pack.</p>
<p><strong>But why are we being so stingy about variables?</strong>  Why not expand the pack to three items?</p>
<pre><code>[^result1' remainder1 /error1]: parser1 input except e -&gt; [
     pack [~, ~, e]
]
</code></pre>
<p>(You have to use the <strong><code>/error1</code></strong> syntax if the non-erroring parser case returns a pack with only two items in it.  The slash means you're okay with fewer items in the source pack and it will set error1 to null in that case.)</p>
<p>Or... why are we bothering to make the error case use EXCEPT?  You have TRAP for definitional errors as well.  It returns NULL if no raised error, and the non-raised form of the ERROR! if there was one:</p>
<pre><code>&gt;&gt; trap [1 + 2]
== ~null~  ; anti

&gt;&gt; trap [1 / 0]
== make error! [
    type: 'Math
    id: 'zero-divide
    message: "attempt to divide by zero"
    near: '[1 / 0 **]
    where: '[/ entrap trap console]
    file: ~null~
    line: 1
]
</code></pre>
<p>Leveraging that gives you basically the cleanest code you could ask for:</p>
<pre><code>error1: trap [[^result1' remainder1]: parser1 input]
</code></pre>
<p><em>(Let me point out that the ability to intercept a definitional error coming from PARSER1 by having it "pass through" a SET-BLOCK! (or a SET-WORD!) is a feature to enable precisely this scenario.  None of the assignments will be performed. And <strong>that is the limit</strong> of how far it will jump and be allowed to TRAP before it will be promoted to a failure.  If you're not up to speed on definitional errors, <a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-errors/1852">read up on them</a>, because they are absolutely critical to coherent error interception.)</em></p>
<h2>
<a name="so-forget-about-raised-errors-in-pack-3" class="anchor" href="https://forum.rebol.info#so-forget-about-raised-errors-in-pack-3"></a>So Forget About Raised Errors in PACK!</h2>
<p>It's a terrible idea.  I'm making PACK abrupt fail if you try to put a raised error in it.</p>
<p>Compare the original maxmatch-D to this one using TRAP:</p>
<pre><code>maxmatch-D: combinator [  ; "(D)efault"
    {Match maximum of two rules, keeping side effects of both if match}
    return: "Result of the longest match (favors first parser if equal)"
       [any-value? pack?]
    parser1 [action?]
    parser2 [action?]
    &lt;local&gt; error1 error2 result1' result2' remainder1 remainder2
][
    error1: trap [[^result1' remainder1]: parser1 input]
    error2: trap [[^result2' remainder2]: parser2 input]
    if error2 [  ; parser2 didn't succeed
        if error1 [
            return raise error1  ; neither succeeded
        ]
    ] else [  ; parser2 succeeded
        any [
            error1
            (index of remainder1) &lt; (index of remainder2)
        ] then [
            remainder: remainder2
            return unmeta result2'
        ]
    ]
    remainder: remainder1
    return unmeta result1'
]
</code></pre>
<p>Ren-C gives you power and flexibility to solve your problems in better ways... take advantage of that!</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/facepunch.png?v=12" title=":facepunch:" class="emoji only-emoji" alt=":facepunch:" loading="lazy" width="20" height="20"></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/avoid-raised-errors-in-pack-but-feel-the-power/2206">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/avoid-raised-errors-in-pack-but-feel-the-power/2206</link>
          <pubDate>Thu, 22 Aug 2024 19:13:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2206</guid>
          <source url="https://forum.rebol.info/t/avoid-raised-errors-in-pack-but-feel-the-power/2206.rss">Avoid Raised Errors in PACK! (But Feel The Power!)</source>
        </item>
        <item>
          <title>Making CALL Raise a (definitional) Error For Bad Exit Codes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>Before definitional errors existed, I noticed that <a href="https://forum.rebol.info/t/the-need-to-rethink-error/1371/2">@gchiu had some uses of CALL</a> that weren't checking the return code.</p>
<pre><code>call [
    gs -sDEVICE=pngmono -o (join root "-%02d.png") -r600 (pdfname)
]

call [
    gs -sDEVICE=eps2write -sPAPERSIZE=a4
        -o (join root "-%02d.eps") (pdfname)
]
</code></pre>
<p>I wanted the default to raise an error if the <strong>gs</strong> (GhostScript) process did not return a 0 exit code.  But I wanted that error to be a result of CALL... so it would be distinct from other errors (like a typo in the code in the groups inside, <code>pfdname</code> instead of <code>pdfname</code> or whatever).</p>
<p><code>CALL</code> was already a wrapper on top of an internal <code>CALL*</code> function, so I thought "why not expand upon that?"</p>
<h2><a name="p-6741-a-cool-enclose-of-an-augment-of-a-specialize-1" class="anchor" href="https://forum.rebol.info#p-6741-a-cool-enclose-of-an-augment-of-a-specialize-1"></a>A Cool ENCLOSE of an AUGMENT of a SPECIALIZE!</h2>
<pre><code>call: enclose (
    augment (specialize :call* [wait: #]) [
        /relax "If exit code is non-zero, return the integer vs. raising error"
    ]
) func [f [frame!]] [
    let relax: f.relax
    let result: do f
    if relax or (result = 0) [
        return result
    ]
    return raise make error! compose [
        message: ["Process returned non-zero exit code:" exit-code]
        exit-code: (result)
    ]
]
</code></pre>
<p>I think that's pretty neat.</p>
<p>It twists the CALL* function so that it always waits (vs. spawn a separate process and return a process ID to wait on).</p>
<p>Then it offers a /RELAX setting for getting the exit code back, if you don't want the definitional error behavior.</p>
<p>But then, by default it will RAISE an error.   You can get that error via EXCEPT or you can do TRY CALL if you just want to ignore any errors.</p>
<h2><a name="p-6741-issue-exposed-whos-actually-to-blame-2" class="anchor" href="https://forum.rebol.info#p-6741-issue-exposed-whos-actually-to-blame-2"></a>Issue Exposed: Who's Actually To Blame?</h2>
<p>While making this I noticed that there were actually several points of failure:</p>
<ul>
<li>
<p>The guts of CALL might not be able to find the file you're asking to execute</p>
</li>
<li>
<p>The executable may run, but return a non-zero exit code</p>
</li>
<li>
<p>If you're running through CALL/SHELL and delegating to it to call a process, then the shell may have its own exit status distinct from the process you tried to call</p>
</li>
</ul>
<p>It seems there's not really any great way to untangle the return results of a shell from that of a process it executes.  <a href="https://en.wikipedia.org/wiki/Exit_status">Here's some of the informal conventions of UNIX shells</a>:</p>
<blockquote>
<p><em>"When a command is terminated by a signal whose number is N, a shell sets the variable $? to a value greater than 128. Most shells use 128+N, while ksh93 uses 256+N."</em></p>
<p><em>"If a command is not found, the shell should return a status of 127. If a command is found but is not executable, the return status should be 126."</em></p>
</blockquote>
<p>So I'm a little shaky on what exactly a TRY CALL should be ignoring.  It's one thing to ignore a program's exit status, and another to ignore whether the program was on disk at all.</p>
<p>TAKE of a BLOCK only has a definitional failure when the block is empty, so you know what TRY TAKE means.  But it may be that you should more or less never say TRY CALL, and always specifically handle the errors that arise from it.  I think this may be a common theme of definitional errors coming out of complicated functions which have more than a single way to fail.</p>
<p>But... in any case, it's progress.  Because we're not conflating typos or other incidental errors to those that are coming from CALL.  And I like the default that it has an error on non-zero exit statuses.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/making-call-raise-a-definitional-error-for-bad-exit-codes/2068">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/making-call-raise-a-definitional-error-for-bad-exit-codes/2068</link>
          <pubDate>Fri, 08 Dec 2023 02:49:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2068</guid>
          <source url="https://forum.rebol.info/t/making-call-raise-a-definitional-error-for-bad-exit-codes/2068.rss">Making CALL Raise a (definitional) Error For Bad Exit Codes</source>
        </item>
        <item>
          <title>Should SET-WORD!s Have &quot;Raised Error Interception&quot;?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>Division by zero is a simple example of something that produces a "definitional error".  <em>It's considered to be "emitted" by the division</em>, and if you try to "move on" without handling it, the raised error becomes a failure that <a href="https://forum.rebol.info/t/discouraging-use-of-trap/1871">you can only catch at some top level by SYS.UTIL.RESCUE</a>.</p>
<p>For instance:</p>
<pre><code>&gt;&gt; 1 / 0, 2 + 0
** Math Error: attempt to divide by zero
** Where: / console
** Near: [1 / 0 **, 2 + ***]
</code></pre>
<p>What happened was that <strong>1 / 0</strong> evaluated, but rather than forcing a "hard failure" (e.g. running FAIL) it instead <em>returned a raised error</em>.  There's an opportunity if that raised error were to be intercepted, but in this case it just moseyed along to the next expression... so the raised error was promoted to a failure.</p>
<p>However a ^META oriented function can trap that, and react to it, allowing you to continue.  EXCEPT is such a function:</p>
<pre><code>&gt;&gt; 1 / 0 except e -&gt; [print ["The error was" e.id]], 2 + 0
The error was zero-divide
== 2
</code></pre>
<p>One thing that pretty obviously shouldn't count as "moving on" would be parentheses.  Adding parentheses shouldn't change the situation, they just pass any raised errors through:</p>
<pre><code>&gt;&gt; (1 / 0) except e -&gt; [print ["The error was" e.id]], 2 + 0
The error was zero-divide
== 2

&gt;&gt; ((((1 / 0)))) except e -&gt; [print ["The error was" e.id]], 2 + 0
The error was zero-divide
== 2
</code></pre>
<p><strong>But what about things like SET-WORD!s?</strong>  Right now, it does not raise an error and just skips the assignment, and lets the code continue:</p>
<pre><code>&gt;&gt; num: &lt;before&gt;

&gt;&gt; (num: 1 / 0) except e -&gt; [print ["The error was" e.id]], 2 + 0
The error was zero-divide
== 2

&gt;&gt; num
== &lt;before&gt;
</code></pre>
<p><strong>This is a useful pattern, but if we do it for SET-WORD!s then we have to ask whether it should be done for SET the function as well...</strong></p>
<pre><code>&gt;&gt; (set 'num 1 / 0) except e -&gt; [print ["The error was" e.id]], 2 + 0
The error was zero-divide
== 2
</code></pre>
<p>If we do this then the SET function has to take its argument of the value to assign as a ^META argument.  Because raised errors can't be stored in variables, and function parameters are communicated via variables.</p>
<p>This does make SET a more complicated function, and any functions like it might also become complicated.  It's a hard decision to condemn all SET-like functions to take their arguments as ^META so they can proxy any errors and not perform the assignment.</p>
<p>I'll probably have more to say about this, but for the moment both SET and SET-WORD! react to definitional failures by <em>not performing the assignment</em> and <em>propagating the raised error</em>.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-set-word-s-have-raised-error-interception/2015">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-set-word-s-have-raised-error-interception/2015</link>
          <pubDate>Tue, 07 Feb 2023 02:52:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2015</guid>
          <source url="https://forum.rebol.info/t/should-set-word-s-have-raised-error-interception/2015.rss">Should SET-WORD!s Have &quot;Raised Error Interception&quot;?</source>
        </item>
        <item>
          <title>The FAIL That Wins Big: Combinator Definitional Errors</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <h2>Announcing Another Major Step Forward...</h2>
<p>As the wheels of thought began to churn around TRY, it came to seem clear that it had a higher purpose in defusing definitional errors.</p>
<p>This led to a thought about how if UPARSE were to allow calling arbitrary decoders (like DEBIN) that would deliver informative errors when the input wasn't a fit...that those errors would need to be interpreted as "soft" parse match failures...moving on to the next alternate.</p>
<p>That called back to another musing about why we don't use the readable word TRY instead of OPT in PARSE when we want to say a component of a parse is optional.</p>
<p>But so long as the combinator-skinned-decoders are communicating in errors, <strong>why not make combinators always indicate failure with definitional errors?</strong></p>
<ul>
<li>
<p>This would free up NULL as a synthesized product to just be an ordinary result, which had been a sticking point trying to wrangle the dual needs of isotopic nulls in a fully generic dialect.</p>
</li>
<li>
<p>The parsers would be able to generate diverse and informative errors, that in debug modes could be tagged with where they came from.  Parsers could distinguish between tunneling an error generated by another parser and emitting their own...providing more information for tracing tools.</p>
</li>
</ul>
<p><strong>It only took a couple of days to do...</strong> most of which was just sorting out a lot of edge cases from being a very thorough client of the relatively untested definitional error infrastructure.</p>
<p>But expect good things from this!</p>
<h2>A Bit Of History: How The Previous Model Came To Be</h2>
<p>When UPARSE was first conceived <em>(a mere year and a half ago)</em>, the combinators were responsible for returning three things:</p>
<ul>
<li>
<p>Whether the parser succeeded or not</p>
</li>
<li>
<p>A synthesized value</p>
</li>
<li>
<p>How much of the input was consumed (represented by a series position of the new "current" parse position, which could potentially be at the tail)</p>
</li>
</ul>
<p><em>(COLLECT and friends necessitated some more nuances, but you only have to worry about it manually if you need fine-grained control.  So most combinators look like these are the only results in play, with the other outputs being "autopiped" around by the machinery.)</em></p>
<p>The second two results would only be applicable if the parser succeeded.  So rather than return three results, it aimed to return just two... and fold together the success with some invalid state for the other result.</p>
<p>At first this seemed like it would be best to fold with the series position.  This would mean that the position could be either a series value or NULL.  That way, NULL could be a valid synthesized product.  This came in handy for things like OPT:</p>
<pre><code>&gt;&gt; x: y: &lt;before&gt;

&gt;&gt; did parse [1020] [x: integer! y: opt integer!]
== #[true]  ; parse succeeded

&gt;&gt; x
== 1020

&gt;&gt; y
; null
</code></pre>
<p>The first draft used the fledgling multi-return facility to do this, and it had the nice property of working with ELSE.  So when a combinator called a parser that failed, it was easy to handle that failure, e.g. to propagate that failure along:</p>
<pre><code>[pos synthesized]: parser input else [return null]
</code></pre>
<h2>But This Was Reversed... For... Reasons</h2>
<p>A mechanical issue came up that VOID could only be represented by the primary return result of a function.  If a multi-return argument was going to be returned and convey voids, it would have to use the ^META protocol... and the caller would have to be explicitly aware that the result they got would be pre-quoted by convention.</p>
<p>But I also noticed that some combinators didn't want to advance the input at all, only operate to transform one synthesized product into another.  Or that they didn't really need to plug into the overall parse architecture.  It seemed like making combinators match as closely to a "normal" function--by putting their synthesized result as the primary result--just made sense.</p>
<p>NULL isotopes were just coming on the scene, which gave a potential way to get out of this: a successful parser which wanted to return NULL would return the isotope form.  Pure NULL would be reserved as the signal for isotopic failure.  This meant the reversed parameters would be able to work:</p>
<pre><code>[synthesized pos]: parser input else [return null]
</code></pre>
<p>Internally, to OPT something like <strong><code>y: opt integer!</code></strong> would not return NULL, but a ~null~ isotope.</p>
<h2>But Now, It's Done With Definitional Errors!</h2>
<pre><code>[synthesized pos]: parser input except e -&gt; [return raise e]
</code></pre>
<p>Here you see the error being intercepted, and then passed on.  NULL is free to be dealt with as a normal product without interference.  And there's a difference between generating a new error (tagging it with the location in the parse rules and the context) vs. just passing on one that was generated by a subparser--you are actually keeping a record of what happened, to show in logs or otherwise.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-fail-that-wins-big-combinator-definitional-errors/1922">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-fail-that-wins-big-combinator-definitional-errors/1922</link>
          <pubDate>Fri, 19 Aug 2022 02:27:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1922</guid>
          <source url="https://forum.rebol.info/t/the-fail-that-wins-big-combinator-definitional-errors/1922.rss">The FAIL That Wins Big: Combinator Definitional Errors</source>
        </item>
        <item>
          <title>Recovering Values From A Raised Definitional Error</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>So TRY is a way to convert definitional errors into soft failure, e.g. a NULL</p>
<pre><code>&gt;&gt; first null
** Error: FIRST on NULL requires use of TRY

&gt;&gt; try first null
== ~null~  ; anti
</code></pre>
<p>I had a thought that instead of just always returning NULL, there might be a way to have constructs raise errors that carried a payload... which would give a "fallback" value that represented something you might want vs. NULL in the case of acknowledging the error.  <em>(The only rule would be that a function emitting such an error should not have any side effects if it emits one of these errors.)</em></p>
<p>So various constructs could offer meanings for what the TRY actually does:</p>
<pre><code>&gt;&gt; unquote first ['abc]
== abc

&gt;&gt; unquote first [def]
** Error: Can't Unquote Plain WORD!, use TRY if Intentional

&gt;&gt; try unquote first [def]
== def
</code></pre>
<p>Another application: at one point I suggested it would be nice to be able to have a COLLECT that didn't actually KEEP anything return NULL, so it could be ELSE-reactive.  That meant if you really wanted an empty block, you'd have to do something like <strong><code>any [collect [...], copy []]</code></strong> which was ugly.  But the error could hold a freshly-copied block to be the result of a TRY:</p>
<pre><code>&gt;&gt; collect [keep if false [&lt;not kept&gt;]]
** Error: COLLECT didn't KEEP anything, use TRY if intended

&gt;&gt; try collect [keep if false [&lt;not kept&gt;]]
== []
</code></pre>
<p>There are various technical reasons why ELSE can't be reactive to TRY-style errors.  One fairly important one would be that if you used ELSE with a branching construct, it wouldn't be able to tell the difference between a branch that had a TRY-error and no branch taken:</p>
<pre><code>&gt;&gt; case [true [unquote first [def]]] else [print "Took branch, runs due to UNQUOTE"]
Took branch, runs due to UNQUOTE  ; this would be bad
</code></pre>
<p>But... maybe the trick could be that if you pass ELSE a function that takes an argument, it assumes that means you handle TRY-style errors?  (Because otherwise it could only be void/null... why take an arg?)</p>
<pre><code>&gt;&gt; (unquote first [def]) else arg -&gt; [print ["TRY error" arg]]
TRY error def
</code></pre>
<p>It's a weird thought.  Anyway, just wanted to write up this parallel-universe TRY concept...</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/recovering-values-from-a-raised-definitional-error/1912">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/recovering-values-from-a-raised-definitional-error/1912</link>
          <pubDate>Tue, 09 Aug 2022 13:28:03 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1912</guid>
          <source url="https://forum.rebol.info/t/recovering-values-from-a-raised-definitional-error/1912.rss">Recovering Values From A Raised Definitional Error</source>
        </item>
        <item>
          <title>The VOID-in-NULL-out Protocol</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>In traditional Redbol, if you wrote a random chain like like <strong>first select block second options</strong>, there was the question of how you would manage the situation of any of these things failing.</p>
<p>People would request lenience... to say more operations should assume that if they got a NONE! input that they should just return a NONE! output.  But this would give those chains no error locality... you'd get a NONE! at the output and not know what failed.  The FIRST?  The SELECT?  The SECOND...?</p>
<p>You can see <a href="https://github.com/red/red/issues/3144">DocKimbel's response to a request that INDEX? NONE be NONE</a>:</p>
<blockquote>
<blockquote>
<p><strong>meijeru</strong><br>
<em>"There are precedents for built-in functions on series which yield none for none."</em></p>
</blockquote>
<p><strong>DocKimbel</strong><br>
<em>"Yes, but the less of them we have, the better, as they lower the robustness of user code, by making some error cases passing silently. The goal of such none-transparency is to be able to chain calls and do nothing in case of <code>none</code>, avoiding an extra <code>either</code> construct. In the above case, it still requires an extra conditional construct (<code>any</code>), so that is not the same use-case as for other none-transparent functions (like <code>remove</code>)."</em></p>
</blockquote>
<h2><a name="p-6059-but-i-didnt-give-up-so-easily-1" class="anchor" href="https://forum.rebol.info#p-6059-but-i-didnt-give-up-so-easily-1"></a>But I Didn't Give Up So Easily...</h2>
<p>The strategy cooked up for Ren-C is called "VOID-in-NULL-out".</p>
<p>There is an asymmetry created, in which certain functions take VOID as input, but then just return NULL out.</p>
<p>Then MAYBE can turn nulls into VOID.</p>
<p>Since (nearly) no function naturally takes NULL as an input, this creates a dynamic where you'd put as many MAYBE in a chain as you felt was warranted, if you expected any steps could fail.  So perhaps <strong>first maybe select block maybe second options</strong>.  A reader could tell which operations could potentially fail using this method.</p>
<p>It has shown systemic success:</p>
<pre><code>&gt;&gt; case [false [[a b c]]]

&gt;&gt; second case [false [[a b c]]]  ; "opt out" gives you a first step w/o error
== ~null~  ; isotope

&gt;&gt; first second case [false [[a b c]]]
** Error: FIRST doesn't take NULL as input (use MAYBE to opt out via VOID)

&gt;&gt; first maybe second case [false [[a b c]]]
== ~null~  ; isotope

&gt;&gt; first second case [true [[a [b] c]]]
== b
</code></pre>
<h2><a name="p-6059-void-is-a-better-choice-than-null-blank-etc-2" class="anchor" href="https://forum.rebol.info#p-6059-void-is-a-better-choice-than-null-blank-etc-2"></a>VOID is a Better Choice Than NULL, BLANK!, etc.</h2>
<p>Prior to the invention of void, the strategy was tried as "BLANK!-in-NULL-out".  But this created problems since sometimes blank was meaningful as input.</p>
<p>VOID has all the properties we're looking for, here.  It's basically about as out-of-band as you can get.</p>
<ul>
<li>
<p>Like NULL, it can't be stored in blocks</p>
</li>
<li>
<p>There's a nice operator for turning NULL into VOID and pass everything else through called MAYBE.</p>
</li>
<li>
<p>The majority of routines don't have natural meanings for void arguments, so "no op" is <em>usually</em> the best reaction to "hey, you got a void".</p>
<ul>
<li>
<p>There are exceptions, e.g. functions like REPLACE which receive voids can interpret them as a desire to use an empty replacement vs. a no-op:</p>
<pre><code>&gt;&gt; replace [a b c] 'b void
== [a c]

&gt;&gt; replace "abc" "b" void
== "ac"
</code></pre>
</li>
</ul>
</li>
<li>
<p>Void has the appealing character of being able to polymorphically mean nothing regardless of what it's substituting in, so you don't have to switch between <strong><code>spread []</code></strong> and <strong><code>""</code></strong> when working on blocks vs. strings.</p>
</li>
</ul>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-void-in-null-out-protocol/1880">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-void-in-null-out-protocol/1880</link>
          <pubDate>Thu, 14 Jul 2022 04:21:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1880</guid>
          <source url="https://forum.rebol.info/t/the-void-in-null-out-protocol/1880.rss">The VOID-in-NULL-out Protocol</source>
        </item>
        <item>
          <title>Discouraging The Interception of Abrupt Failures</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>With <a href="https://forum.rebol.info/t/fail-vs-return-fail-the-new-age-of-definitional-failures/1852">definitional errors</a>, the landscape changes considerably for how we think about error handling.</p>
<p><strong>In this world, there are <em>not a lot of good reasons</em> to use what we've been calling "TRAP".</strong> (historical Redbol's TRY).  I will call it TRAP/ABRUPT for clarity, since we now have definitional TRAP.</p>
<p>By its design, TRAP/ABRUPT will intercept <em>any</em> error in code at <em>any</em> depth.  I've shown that when ATTEMPT was based on this, it was not good:</p>
<pre><code>&gt;&gt; attempt [print "Attempting to read file" read %nonexistent-file.txt]
Attempting to read file
== ~null~  ; anti

&gt;&gt; attempt [print "Attempting but made typos" rread %nonexistent-file.txt]
== ~null~  ; anti
</code></pre>
<p>That's fixed now, because ATTEMPT is based on REDUCE-EACH with a ^META variable.</p>
<p>But back to TRAP/ABRUPT.  The problem isn't just about typos.  It's about the illusion that there's something you can do to react to an arbitrary error...when the constructs you were using didn't even understand it well enough to pipe it through to their output.</p>
<p><strong>In almost all cases, an error intercepted by "TRAP/ABRUPT" cannot be reacted to sanely...it has to be reported.</strong></p>
<p>It's for this reason that languages like Rust pretty much enforce a panic</p>
<p>And our case is even more compelling.  For example: How many places is it ever a good idea to sweep a typo under the rug, and just run some other code?</p>
<p>The few cases it's legitimate are things like the console...where you intercept the error and present it, so the user knows it happens and can do something about it.  <em>This sort of thing is nearly the only legitimate usage of TRAP/ABRUPT.</em></p>
<h2>
<a name="might-we-make-it-look-more-special-to-discourage-use-1" class="anchor" href="https://forum.rebol.info#might-we-make-it-look-more-special-to-discourage-use-1"></a>Might We Make It Look More "Special" To Discourage Use?</h2>
<p>I thought at minimum we should move it to a place that shows it's more of a "system utility" than a "language feature".</p>
<p>So calling it <strong><code>SYS.UTIL.RESCUE</code></strong> would be a step in that direction.</p>
<p>Things to think about.  Anyway, I've made some progress on definitional errors in the scanner and with TO and MAKE operations, so some of the things people like to intercept (like conversions) should work correctly with attempt now.</p>
<p>For instance, in this finite-integer world... an out of range error:</p>
<pre><code>&gt;&gt; attempt [to integer! "10483143873258978444434343"]
== ~null~  ; anti

&gt;&gt; attempt [to intgeer! "10483143873258978444434343"]
** Script Error: intgeer! word is attached to a context, but unassigned

&gt;&gt; to integer! "10483143873258978444434343" except e -&gt; [print ["Error:" mold e]]
Error: make error! [
    type: 'Script
    id: 'bad-make-arg
    message: ["cannot MAKE/TO" :arg1 "from:" :arg2]
    near: [to integer! "10483143873258978444434343" ** except e -&gt; ***]
    where: [to args]
    file: '
    line: 1
    arg1: #[datatype! integer!]
    arg2: "10483143873258978444434343"
]
</code></pre>
<p>Should be a more specific error, now that I look at that.  But I guess it just wasn't.</p>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/discouraging-the-interception-of-abrupt-failures/1871">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/discouraging-the-interception-of-abrupt-failures/1871</link>
          <pubDate>Sun, 10 Jul 2022 16:05:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1871</guid>
          <source url="https://forum.rebol.info/t/discouraging-the-interception-of-abrupt-failures/1871.rss">Discouraging The Interception of Abrupt Failures</source>
        </item>
        <item>
          <title>FAIL vs. RETURN RAISE: The New Age of Definitional Errors!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>The latest groundbreaking isotope-powered concept of Ren-C is... <em><strong>the definitional error</strong></em></p>
<h2><a name="p-5959-but-first-we-have-to-define-failure-1" class="anchor" href="https://forum.rebol.info#p-5959-but-first-we-have-to-define-failure-1"></a>But First, We Have To Define Failure...</h2>
<p>Definitional ("raised") errors are the antiform state.  It's what you would get if you UNMETA a QUASI! ERROR!</p>
<pre><code>&gt;&gt; quasi 'foo
== ~foo~

&gt;&gt; unmeta quasi 'foo
== ~foo~  ; anti

&gt;&gt; unmeta quasi make error! "foo"
** Error: foo
** Near: [*** make error! "foo" **]
</code></pre>
<p>Or just ANTI it, which does the same thing.</p>
<p>Being an <em>unstable</em> isotope, you can't store raised errors in variables directly.  But if you try to, <em>it reports the error! as it is in the antiform itself</em>.  This is a what we call an "abrupt failure".</p>
<pre><code>&gt;&gt; var: anti make error! "foo"
** Error: foo
** Near: [*** make error! "foo" **]
</code></pre>
<p>There's also a special behavior that they cannot occur in generic midstream evaluations:</p>
<pre><code>&gt;&gt; (1 + 2 anti make error! "foo" 3 + 4)
** Error: foo
** Near: [*** make error! "foo" ** 3 + 4]
</code></pre>
<p>So far this doesn't seem so profound.  Rebol2 and Red can DO an ERROR! and get a failure, which you also can't store in a variable or keep going in the middle of an expression.</p>
<p>BUT here's the twist:</p>
<pre><code>&gt;&gt; ^ anti make error! "foo"
== ~make error! [
    type: '
    id: '
    message: "foo"
    near: [*** make error! "foo" **]
    where: [unmeta args]
    file: '
    line: 1
]~
</code></pre>
<ul>
<li>
<p>The ANTI did not raise an irrecoverable error.</p>
</li>
<li>
<p>It created an antiform error state, and then waited to see if something would ^META it or not.</p>
</li>
<li>
<p>There was a ^META and so it gave you back the QUASIFORM! error state</p>
</li>
</ul>
<p>This is a crucial difference, as we will see.  But first...</p>
<p><strong>NOTE: I will be using the operation RAISE in the remaining text, instead of ANTI on ERROR!</strong>  So approximately this:</p>
<pre><code>raise: lambda [e [text! block! error!]] [anti make error! e]
</code></pre>
<h2><a name="p-5959-lets-address-the-definitional-part-2" class="anchor" href="https://forum.rebol.info#p-5959-lets-address-the-definitional-part-2"></a>Let's Address the "Definitional" Part</h2>
<p>What I mean when I say "definitional" is that there's a difference between these two cases:</p>
<pre><code>bigtest: func [n] [
   if n &lt; 1020 [raise [n "is not big"]]
   print [n "sure is a big number"]
] 

definitional-bigtest: func [n] [
   if n &lt; 1020 [return raise [n "is not big"]]
   print [n "sure is a big number"]
] 
</code></pre>
<p>You won't notice a difference if you call them directly</p>
<pre><code>&gt;&gt; bigtest 304
** Error: 304 is not big
** Where: raise if bigtest args
** Near: [raise [n "is not big"] **]

&gt;&gt; definitional-bigtest 304
** Error: 304 is not big
** Where: raise if definitional-bigtest args
** Near: [return raise [n "is not big"] **]
</code></pre>
<p>But try using ^META and you'll see they are different:</p>
<pre><code>&gt;&gt; ^ bigtest 304
** Error: 304 is not big
** Where: raise if bigtest args
** Near: [raise [n "is not big"] **]

&gt;&gt; ^ definitional-bigtest 304
== ~make error! [
    type: '
    id: '
    message: "304 is not big"
    near: [return raise [n "is not big"] **]
    where: [raise if definitional-bigtest args]
    file: '
    line: 1
]~
</code></pre>
<p><strong>Functions can now choose to tell us when an error was something <em>they</em> knew about and engaged, vs. something incidental that could have come from any call beneath them in the stack.</strong></p>
<p>Sound important?  <em>It should.</em></p>
<h2><a name="p-5959-now-blast-some-musichttpswwwyoutubecomwatchvygp0nsnslg4-for-this-watershed-moment-3" class="anchor" href="https://forum.rebol.info#p-5959-now-blast-some-musichttpswwwyoutubecomwatchvygp0nsnslg4-for-this-watershed-moment-3"></a>NOW <a href="https://www.youtube.com/watch?v=YGP0nsnSlg4">BLAST SOME MUSIC</a> FOR THIS WATERSHED MOMENT</h2>
<p>I've added EXCEPT, which is an enfix operation that reacts to failures...while THEN and ELSE just pass them on.</p>
<pre><code>&gt;&gt; raise "foo" then [print "THEN"] else [print "ELSE"] except [print "EXCEPT"]
EXCEPT
</code></pre>
<p>As we saw in the beginning, if <em>someone</em> doesn't handle the failure it gets raised eventually:</p>
<pre><code>&gt;&gt; raise "foo" then [print "THEN"] else [print "ELSE"]
** Error: foo
** Near: [raise "foo" ** then [print "THEN"] else [print "ELSE"]]
</code></pre>
<p>Remember the old, bad ATTEMPT?</p>
<pre><code>rebol2&gt;&gt; attempt [print "Attempting to read file" read %nonexistent-file.txt]
Attempting to read file
== none

rebol2&gt;&gt; attempt [print "Attempting but made typos" rread %nonexistent-file.txt]
== none
</code></pre>
<p>It was too dangerous to use.  With READ upgraded to turn its file-not-found error to be definitional, and a new ATTEMPT that's based on ^META and not TRAP, we get safety!</p>
<pre><code>attempt: lambda [
    -{Evaluate a block and returns result or NULL if an expression fails}-
    code [block!]
][
    reduce-each ^result code [
        if (quasi? result) and (error? unquasi result) [
            break  ; BREAK will mean overall result is NULL
        ]
        unmeta result
    ]
]

&gt;&gt; attempt [print "Attempting to read file" read %nonexistent-file.txt]
Attempting to read file
== ~null~  ; anti

&gt;&gt; attempt [print "Attempting but made typos" rread %nonexistent-file.txt]
Attempting but made typos
** Script Error: rread word is attached to a context, but unassigned
** Near: [rread ** %nonexistent-file.txt]
</code></pre>
<p>For another example, see <a href="https://forum.rebol.info/t/making-use-of-definitional-errors-curtail/2118">CURTAIL</a></p>
<p>It will take time for natives to be audited and have their random fail()s turned to be definitional-RAISE-when-applicable.  Until then, most won't have errors that can be intercepted like this.  I added the error for file not found and the NEED-NON-NULL for COMPOSE and DELIMIT and REDUCE, but it will take a while.</p>
<p>But other than that...</p>
<h1><a name="p-5959-its-here-its-now-its-committed-4" class="anchor" href="https://forum.rebol.info#p-5959-its-here-its-now-its-committed-4"></a>It's Here.  It's Now.  It's Committed!</h1>
<p><img src="https://forum.rebol.info/images/emoji/twitter/boom.png?v=12" title=":boom:" class="emoji only-emoji" alt=":boom:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-5959-note-that-non-definitional-fail-still-exists-5" class="anchor" href="https://forum.rebol.info#p-5959-note-that-non-definitional-fail-still-exists-5"></a>Note That Non-Definitional Fail Still Exists...</h2>
<p>If you want to immediately go to the failure state, use FAIL as you historically would.</p>
<p>That's clearer than calling RAISE with no RETURN, where a reader can't tell if it's going to be piped along and eventually RETURN'd or ^META'd somewhere.</p>
<pre><code>return case [
    ... many pages of code ...
    ... [raise "Some error"]  ; need to be able to choose FAIL here if you meant that
    ... many pages of code ...
 ]
</code></pre>
<p>When writing a function and deciding if an error should be RETURN RAISE or FAIL, think about the use case.  Do you feel that the call is fundamentally malformed (in the way a type checking error on a parameter would be thought of as a mistake), or did you understand what was asked clearly...but just couldn't do it?</p>
<p>It's subtle, but I think the pattern is emerging pretty clearly of when you should FAIL vs. RETURN RAISE.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-errors/1852">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-errors/1852</link>
          <pubDate>Tue, 28 Jun 2022 02:17:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1852</guid>
          <source url="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-errors/1852.rss">FAIL vs. RETURN RAISE: The New Age of Definitional Errors!</source>
        </item>
        <item>
          <title>About the Errors category</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>For discussion of error handling and error mechanisms.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/about-the-errors-category/1734">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/about-the-errors-category/1734</link>
          <pubDate>Sat, 02 Oct 2021 19:54:57 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1734</guid>
          <source url="https://forum.rebol.info/t/about-the-errors-category/1734.rss">About the Errors category</source>
        </item>
        <item>
          <title>Should EVALUATE/NEXT bomb on an error?</title>
          <dc:creator><![CDATA[rgchris]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>Currently if you try something bad in EVALUATE/NEXT, it throws an error:</p>
<pre><code>&gt;&gt; evaluate/next [unspaced null]
** Script Error: unspaced requires line argument to not be null
</code></pre>
<p>As EVALUATE/NEXT is a relatively low-level service, it would seem more likely one would want to handle the error on the same basis as other possible return values:</p>
<pre><code>&gt;&gt; [position product]: evaluate/next [unspaced null foo bar]
== [foo bar]

&gt;&gt; product
== &lt;&lt;unspaced-null&gt;&gt;  ; some error you can handle
</code></pre>
<p>In this case, the bomb isn't particularly informative and seems reasonable to say <em>'user bewareassume errors will happen'</em>. It's kind of difficult to work around too.</p>
<p>This sort of puts it in the same class as TRAP with different semantics:</p>
<pre><code class="lang-plaintext">trap [ok ok something bad] =&gt; [**something-bad null]
trap [ok ok] =&gt; [null ok]
evaluate [something bad ok ok] =&gt; [[ok ok] **something-bad ]
evaluate [ok ok] =&gt; [ok [ok]]
</code></pre>
<p>I guess the wrinkle here is how do you determine where <code>something bad</code> ends and <code>ok ok</code> resumes? That may or may not be obvious.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/should-evaluate-next-bomb-on-an-error/1491">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-evaluate-next-bomb-on-an-error/1491</link>
          <pubDate>Sat, 06 Feb 2021 06:24:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1491</guid>
          <source url="https://forum.rebol.info/t/should-evaluate-next-bomb-on-an-error/1491.rss">Should EVALUATE/NEXT bomb on an error?</source>
        </item>
        <item>
          <title>The Need To Rethink ERROR!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>Looking around at how people deal with failure conditions, <em>there's a pretty strong trend against exceptions--a trend which has grown stronger in the last batch of popular languages</em>.</p>
<p>Exceptions operate on a dubious principle: that a trigger condition originating transitively in a deep stack of code can be meaningfully handled when passed up through intermediary stacks.  There's an uncomfortable violation of abstraction: you are no longer dealing with a return result that was clearly formalized in the contract between caller-and-callee.  <em>"The function you called couldn't handle an error... but you're trying to do it without even knowing what that function called that failed...?"</em></p>
<p>Even exception advocates agree that they should not be used lightly...the name suggests it is only for "exceptional" circumstances.  So things that are very reasonable to expect to occur during operation--like a filesystem API trying to open the file and it not being there--should fit into the normal return results.  This is a slippery slope and subject to what your program considers "normal"...but the intent is that it's supposed to be more for things like "ran out of memory" or "network cable was unplugged during transfer".</p>
<p>But there are many who are against exceptions.  e.g. Google's is against them: <a href="https://google.github.io/styleguide/cppguide.html#Exceptions"><em>"We do not use C++ exceptions."</em></a>  When the pros and cons are weighed, they think it's just not worth it.</p>
<p>Rebol code that uses TRAP (old TRY) or ATTEMPT frequently shows that Rebol has an even greater weakness of the approach than usual: any arbitrary typo inside the executing code can be interpreted as the wrong kind of failure.  Conflating a syntax error with something like file-not-found is much too easy.</p>
<p>Another key contributor to exception unpopularity is <strong>exceptions don't work well with asynchronous programming</strong>.  Code that triggered a request can be off the stack while a handler is running.  So there is nowhere to put a <code>catch {}</code> above the stack for the problem.</p>
<h2>Emergent Pattern: Branching Returns</h2>
<p>Across languages you see a consistent pattern of functions formalizing the return of a branched result: either a "successful" return or an "error" return...and labeling the return value as such.</p>
<ul>
<li>
<p>Haskell has "the <a href="https://wiki.haskell.org/Handling_errors_in_Haskell#Error_using_the_Either_type"><code>Either</code></a> monad"...which bundles a value with a label of "left" and "right".  By convention, if the value is labeled "left" it is an error value...and if it is labeled "right" it is a successful return.  There is no "umbrella" error datatype--so strings labeled "left" or other common tuples are typically used.</p>
</li>
<li>
<p>Haskell-inspired Rust has <a href="https://doc.rust-lang.org/stable/rust-by-example/error/result.html"><code>result</code></a>, which has a similar labeling scheme...though it specializes the purpose and gives the labels the names "Ok" and "Err".  It suggests (but does not enforce) that Err-labeled values be instances of the <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a> datatype...which meets the basic expectations of what an error should be able to do (e.g. print itself out, show a call stack of where it originated).</p>
</li>
<li>
<p>JavaScript ES6 handles asynchronous scenarios by making it so that <code>async</code> functions don't return their result with <code>return</code>, but with either <code>resolve()</code> or <code>reject()</code>.  If resolve is called, then callsites will trigger <code>then()</code> handling, otherwise they will trigger <code>catch()</code> handling.  If <code>await</code> is used vs. then/catch, a failed promise will resort to throwing the error (e.g. an exception).</p>
</li>
<li>
<p>Node.js used the <a href="https://nodejs.org/en/knowledge/errors/what-are-the-error-conventions/">"callback convention"</a> where asynchronous functions return errors as the first parameter to a callback, and if that is null the other arguments are assumed valid...but this is now typically <a href="https://medium.com/better-programming/converting-callbacks-to-promises-like-a-pro-in-node-js-f5d4d466a1a7">converted into ES6 promises</a> where errors produce</p>
</li>
<li>
<p>Go uses <a href="https://www.digitalocean.com/community/tutorials/handling-errors-in-go#:~:text=When%20a%20function%20returns%20multiple,value%20to%20a%20zero%20value.">multiple return values for errors</a>, with a convention that the <em>last</em> value in the return sequence is the error...with all other values being "zero values" of their type.</p>
</li>
</ul>
<p>So if your own unsatisfying experiences with "throw/catch" and "fail/trap" solutions isn't enough to convince you...there's a pretty strong batch of added evidence.</p>
<h2>Using The Parts In The Box Effectively</h2>
<p>Something I had in the back of my mind ever since THEN could conveniently take a parameter value via lambdas, was what if ELSE could too.</p>
<p>At the moment ELSE only triggers on NULL.  But what might happen if THEN didn't take ERROR!s or nulls, but ELSE did.  Something like:</p>
<pre><code> (make error! "how about this?") then value -&gt; [
     print ["This would not run:" value]
 ] else error -&gt; [
     print ["This would run:" error]
 ]
</code></pre>
<p>But that crude sketch shows a weak basis for doing error handling:</p>
<ul>
<li>
<p>It operates in the "single return result" realm...so to use it, you'd have to conflate ERROR! values in with a function's ordinary return values.  That would be tricky to avoid including ERROR! itself, if it can return ANY-VALUE! (e.g. you can PICK an ERROR! out of an array)</p>
</li>
<li>
<p>There's nothing guaranteeing you handle an error...you could just forget and leave off the ELSE  (The "good" versions of the branched error approaches make sure you never accidentally ignore them, you have to consciously throw them away.)</p>
</li>
<li>
<p>It may be (probably is?) a bad fit to fold this into ELSE...which isn't really about error handling, but whether branches are taken.</p>
</li>
</ul>
<p>Using SET-BLOCK! for <a href="https://forum.rebol.info/t/forward-to-multiple-return-values-and-return-value-forwarding/1271">multiple return values</a> wedged open the door for being more effective in this space.  But we can think through this some more.</p>
<p>One thing I notice in JavaScript and Go is that the error result is distinguished, but positioning is set by convention instead of by name.  As a random sample thought, we could syntactically push errors out somehow, e.g. with a TUPLE!</p>
<pre><code>; function that returns 3 values and a possible error
;
[a b c].err: some-func arg1 arg2 arg3
</code></pre>
<p>I didn't say it was a great idea--just pointing out a degree of freedom.</p>
<h2>Could We Get More Mileage Out Of ERROR!</h2>
<p>Rebol2's ERROR! had an interesting aspect to it, as being an "ornery" value...like a VOID!...that you couldn't inspect normally.  You had to DISARM it and view it as an object in order to pick apart its properties.</p>
<p>R3-Alpha's ERROR! was neutered and became just another flavor of OBJECT!.  It carries a bit of standardized information about what line and location it originated from...but arguably this could be a useful feature for any value <em>(internally to the system for debugging, I have functions like Touch() which will tag a value with the last place that modified it...and it comes in handy a lot)</em>.</p>
<p>Maybe it's all right as it is... and what we're missing is more like Rust's <strong><code>result</code></strong>.  But I can't help but feel that in a universe of possible designs...that "OBJECT! that reports a different type" is weak.</p>
<p>Again: I don't have any great ideas right now.  This is just noticing something and brainstorming.  Having multiple returns in the mix is good, but I'd like to see something that's at least as good as what other languages have.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-need-to-rethink-error/1371">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-need-to-rethink-error/1371</link>
          <pubDate>Fri, 23 Oct 2020 07:48:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1371</guid>
          <source url="https://forum.rebol.info/t/the-need-to-rethink-error/1371.rss">The Need To Rethink ERROR!</source>
        </item>
        <item>
          <title>More Comprehensible Errors With per-Cell Labeling!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>There's been a long-running complaint in the Redbol world that if you don't run a function directly from a WORD! or PATH!, it doesn't know a name for it:</p>
<pre><code>r3-alpha&gt;&gt; append 1 &lt;d&gt;  ; dispatched as WORD!
** Script error: append does not allow integer! for its series argument

r3-alpha&gt;&gt; do compose [(:append) 1 &lt;d&gt;]  ; dispatched as ACTION!
** Script error: -unnamed- does not allow integer! for its series argument
</code></pre>
<p>To try and improve on this, Red climbs the stack a bit to find something with a name...but the resulting error is gibberish:</p>
<pre><code>red&gt;&gt; do compose [(:append) 1 &lt;d&gt;]
*** Script Error: do does not allow integer for its series argument
</code></pre>
<p>The problem this is showing is that ACTION!s are things that can be known by many names, and when they get "extracted" from a WORD! they lose the label.</p>
<p>Today I did something that's kind of obvious-seeming: <em>to make it so that GET-WORD! and GET-PATH! evaluations cache the name in the action cell instance</em>.  This isn't doing anything to the shared data for the action, just poking a pointer to the word's spelling data in the cell.</p>
<p>It's a welcome improvement:</p>
<pre><code>&gt;&gt; do compose [(:append) 1 &lt;d&gt;]
** Script Error: append does not allow #[datatype! integer!]
     for its series argument

&gt;&gt; do compose [(:append/only) 1 &lt;d&gt;]
** Script Error: append does not allow #[datatype! integer!]
    for its series argument
</code></pre>
<p>The details of why this would be tricky just relate to the fact that bits don't grow on trees...and the "rules of the game" limit cells to 4 platform pointers in size.  To make a long-story-short: while ACTION! "archetypes" can't spare a pointer at this time, ACTION! <em>instances</em> can...and the distinction of whether an action is an archetype or not is made by detecting the properties of the pointed-to-series being a WORD-spelling or action-descriptor-array.</p>
<p>If you write a function that processes a function to create a derived one, you'll need some tools for working with this cached symbol...otherwise you'd lose it just by storing actions in temporary variables.  Expect to see a few cases of that.  I'll look into it when time permits.  But this is already a <em>lot</em> better.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/more-comprehensible-errors-with-per-cell-labeling/1357">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/more-comprehensible-errors-with-per-cell-labeling/1357</link>
          <pubDate>Mon, 05 Oct 2020 22:53:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1357</guid>
          <source url="https://forum.rebol.info/t/more-comprehensible-errors-with-per-cell-labeling/1357.rss">More Comprehensible Errors With per-Cell Labeling!</source>
        </item>
        <item>
          <title>Safety Concept: Error on discarded plain BLOCK! ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>I just had a bug that was rather frustrating to find.  I changed:</p>
<pre><code>foo: func [
    {Description}
    param [...]
    /refine
][
    ...
]
</code></pre>
<p>into:</p>
<pre><code>foo-core: func [
    {Description}
    param [...]
    /refine
][
    ...
]

foo: adapt 'foo-core [
    {Description}
][
    ...
]
</code></pre>
<p><strong>But ADAPT doesn't take two parameters.</strong>  I should have eliminated the "spec" block from the ADAPT entirely, but I only deleted the parameters.  This effectively gave me:</p>
<pre><code>foo: adapt 'foo-core [
    {Description}
]  ; "spec" block treated as the adapt "prelude"

[...]  ; stray random block, thrown out
</code></pre>
<p>There's no warning in this case, because a plain BLOCK! evaluates to a plain BLOCK! and gets thrown out.</p>
<h2>There's nothing we can do.  Or... is there?</h2>
<p>This kind of thing almost always represents an error.  This got me to wondering about generalized quoting.  Might it help us?</p>
<p><em>What if plain unevaluated BLOCK! was an error in evaluation if it was not a parameter to anything, and not a result of anything</em>...?</p>
<p>So maybe this would be an error:</p>
<pre><code>all [
    a = b
    c = d
    [this block does nothing]
]
</code></pre>
<p>But this would not:</p>
<pre><code>data: all [
    a = b
    c = d
    [assignment target, it's okay]
]
</code></pre>
<p>And this would also be fine:</p>
<pre><code>foo: func [return: [block!] a b c d] [
    all [
        a = b
        c = d
        [result of function so it gets used]
    ]
]
</code></pre>
<p>Maybe quoting could let you subvert the rule:</p>
<pre><code> all [
    a = b
    c = d
    '[just throw this out, don't complain]
]
</code></pre>
<p>Note COMPOSE has power for this kind of thing built-in:</p>
<pre><code> block: [thing to throw out]
 data: all compose [
    a = b
    c = d
    '(block)  ; the tick would also suppress ACTION! evaluation, etc.
]
</code></pre>
<p>I don't know if the QUOTED! exemption is necessary or not, because this could run into problems as well of throwing out a quoted thing.</p>
<p><strong>Challenge: when is non-evaluation utilized?</strong></p>
<p>There's been some play with the fact that things don't evaluate to make constructs that have markup in them.  Think of for example a modification of EITHER that lets you label the branches:</p>
<pre><code> my-either condition [&lt;tag&gt; ...code...] [&lt;tag&gt; ...code...]
</code></pre>
<p>Skipping the tag silently might be considered a feature, because the code is looked at.  I don't know, maybe having to skip that tag before executing is better practice.</p>
<p>Just asking the philosophical question here of "why is throwing away inert interstitial expressions of great value".  We have ELIDE and COMMENT.  Might we do more for the sanity of the language if we noticed and errored if values were being silently discarded?</p>
<p><em>Usually trying to implement a rule like this shows problematic cases, but I tend to write it up as a way of seeing if I can talk myself out of it by coming up with a disproof before bothering to try writing it...</em></p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/safety-concept-error-on-discarded-plain-block/1305">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/safety-concept-error-on-discarded-plain-block/1305</link>
          <pubDate>Sat, 18 Jul 2020 19:16:03 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1305</guid>
          <source url="https://forum.rebol.info/t/safety-concept-error-on-discarded-plain-block/1305.rss">Safety Concept: Error on discarded plain BLOCK! ?</source>
        </item>
        <item>
          <title>Pointing the Blame In FAIL</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>If you haven't been using FAIL, you should!  I've pointed out in the past you can just say <strong>case [... fail]</strong> and that's enough to get a failure and point to that location.  But it now lets you just point at any arbitrary value via a quoted word and it will complain about that word and its value:</p>
<pre><code>&gt;&gt; foo: 10

&gt;&gt; fail 'foo
** Error: foo is invalid: 10
** Where: fail console
** Near: [fail 'foo ~~]
</code></pre>
<p>It works for tuples too:</p>
<pre><code>&gt;&gt; obj: make object! [field: &lt;I've been a bad, bad field...&gt;]

&gt;&gt; fail 'obj.field
** Error: obj.field is invalid: &lt;I've been a bad, bad field...&gt;
** Where: fail console
** Near: [fail 'obj.field ~~]
</code></pre>
<p>So this should be your lazy go-to for reporting errors, you get more information and type less than using PRINTs or longer-winded messages.</p>
<h2>
<a name="but-the-real-strength-is-implicating-callsites-vs-fails-1" class="anchor" href="https://forum.rebol.info#but-the-real-strength-is-implicating-callsites-vs-fails-1"></a>But the real strength is implicating callsites, vs FAILs</h2>
<p>If you don't provide a place to blame, the only thing the evaluator knows is the whole stack and the place the failure was.</p>
<pre><code> my-api: func [x y z] [
     if true [
         if y &lt; 100 [
              fail "Who's failing?  one of those IFs?  Or MY-API?"
        ]
     ]
 ]

&gt;&gt; my-api 1 2 3
** Error: Who's failing?  one of those IFs?  Or MY-API?
** Where: fail if if my-api console
** Near: [
    fail "Who's failing?  one of those IFs?  Or MY-API?" ~...
</code></pre>
<p>That's not a terribly informative error message, but the evaluator doesn't know any more unless you tell it.</p>
<p>This is a job for FAIL/BLAME!  Just pass it a WORD! from the frame you wanted to complain about.</p>
<pre><code>my-api: func [x y z] [
     if true [
         if y &lt; 100 [
              fail/blame ["Value must be &gt;= 100, not" y] 'y
        ]
     ]
 ]

&gt;&gt; my-api 1 2 3
** Error: Value must be &gt;= 100, not 2
** Where: my-api console
** Near: [... 1 2 3 ~~]
</code></pre>
<p>Now the IFs are gone from the reporting stack, and you're indicating the callsite but not the FAIL itself.  <em>(Ideally the error message would point to the exact block position where the parameter you are complaining about originated from.  But that information is not preserved at the moment.  In the future it might be kept...maybe in a special slot that would go unused otherwise in 64-bit builds.  So the error report would improve!)</em></p>
<p>Again, you could be lazy and just say <code>fail 'y</code> and get a fair amount of information.  In this case a bit of better information than in the custom message provided--in terms of the right name of the bad parameter!</p>
<h2>
<a name="this-isnt-arcane-c-magic-its-usermode-rebol-2" class="anchor" href="https://forum.rebol.info#this-isnt-arcane-c-magic-its-usermode-rebol-2"></a>This isn't arcane C magic, it's usermode Rebol!</h2>
<p>You can read and help improve FAIL any day you feel like it!  Please do!</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/pointing-the-blame-in-fail/1027">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/pointing-the-blame-in-fail/1027</link>
          <pubDate>Tue, 22 Jan 2019 09:33:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1027</guid>
          <source url="https://forum.rebol.info/t/pointing-the-blame-in-fail/1027.rss">Pointing the Blame In FAIL</source>
        </item>
        <item>
          <title>WORD!, PATH!, and URL!s as ERROR! ids</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>R3-Alpha gave all the built in errors categories and a WORD! for an id.  These were established in the %errors.r file:</p>
<p><a href="https://github.com/rebol/rebol/blob/master/src/boot/errors.r"><code>https://github.com/rebol/rebol/blob/master/src/boot/errors.r</code></a></p>
<p>Each category had an integer "base" number, and the errors were numbered according to that.  Adding and removing errors would disrupt these numbers... so the idea was presumably that these would settle over time.  At some point of stability, errors removed from the middle would not have their numbers reused, while new errors would be added at the end of their groups.</p>
<p>But the usage of integers for error codes isn't very "ecology friendly".  I question the wisdom of even having <em>error numbers</em> in Rebol...IDs may collide, but numbers will do so even quicker.  A lot of places you might imagine they'd be useful they aren't really; for instance, exit status codes for processes on UNIX are <a href="https://en.wikipedia.org/wiki/Exit_status">limited to bytes</a>...and even in that limited range they use conventions other than Rebol's numbers.</p>
<p>To mitigate collisions, I've wondered if errors might be based on some kind of hierarchy, in which you could choose to refer to errors by WORD!, PATH!, or URL!.</p>
<pre><code>error.id ~= 'missing-delimiter
error.id ~= 'syntax/missing-delimiter
error.id ~= http://rebol.info/e/syntax/missing-delimiter
</code></pre>
<p>So the idea being that the error IDs would be fully qualified somehow, but when you trapped them you could use a level of specificity that met your particular desires for rigor.  If you were worried there was some other kind of 'missing-delimiter error that could be thrown affecting your particular code, you might use a full URL.  I made up the <code>~=</code> operator here as something you might use which would gloss this difference.</p>
<p>This isn't really a concrete proposal...just pointing out that I don't think numbering errors has a lot of point.  While the names have changed here and there, the numbers have thus far had basically no meaning.  It seems to me any future-forward strategy would avoid inventing error numbers entirely (an error of course might include a number as part of its parameterization if it's referring to a non-Rebol system, e.g. HTTP error codes).</p>
<p>So if we killed the numbering, would anyone notice?</p>
            <p><small>8 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/word-path-and-url-s-as-error-ids/559">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/word-path-and-url-s-as-error-ids/559</link>
          <pubDate>Wed, 07 Mar 2018 21:23:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-559</guid>
          <source url="https://forum.rebol.info/t/word-path-and-url-s-as-error-ids/559.rss">WORD!, PATH!, and URL!s as ERROR! ids</source>
        </item>
        <item>
          <title>Embracing Host Language Exception Model in the API</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>When first adding the variadic rebDo() <em>(now, <code>rebRun()</code>)</em>, it would return a value "handle" of the evaluative result.  As a first attempt of defining what it would do about errors, it returned NULL in that case.  Those who were interested in bulletproofing their code could add in check for NULL and then call a function for fetching the last error.</p>
<p>But a handle has a NULL state as an option.  What if the result was just a boolean, like with the proposed behavior of <code>rebDid()</code>?  The idea of being able to write:</p>
<pre><code>if (rebDid("all [", rebEval(fun), val, 3, "empty? block]")) {
    ...
}
</code></pre>
<p>...seems far preferable to:</p>
<pre><code>REBVAL *all_result = rebRun("all [", rebEval(fun), val, 3, "empty? block]");
if (all_result != NULL) { // value handle, must be released or has GC cost
    if (rebUnboxLogic(all_result)) {
        ...
    }
    rebRelease(all_result);
}
else { ... }
</code></pre>
<p>Yet if rebDid() was executor of code, logic unboxer, and automatic releaser of values...it had no way to return a result besides TRUE or FALSE.  So no channel to inform you about an error.</p>
<p>This makes it seem desirable to work within the exception-handling model of the host language.  So you want to see things like:</p>
<pre><code>try { 
     var three = rebInteger(3); 
     var block = rebRun("[1 (2", three, ") 4 5]"); 
     rebElide("append/dup", block, "{string literal} 2"); 
     ... 
 } catch (e) { 
     if (e instanceof RebolError) { 
         console.log(e); 
         ... 
     } 
 } 
</code></pre>
<p>There are a couple of issues, though:</p>
<ol>
<li>
<p>While C++ and JavaScript have a standard exception-handling model (try/catch)...C doesn't have one.</p>
</li>
<li>
<p>Even if a "standard"-seeming exception is thrown from the guts of code running on the behalf of an API call, <em>the API must catch it for processing</em> before passing it on.  This is because it has to clean up the Rebol stack levels that were crossed, because the next thing that might happen to the error once it's returned is it might be caught by the API caller and not processed further.</p>
</li>
</ol>
<p>The first point can really only be addressed with a specialized routine for C API clients.  Ruby has <a href="http://silverhammermba.github.io/emberb/c/#rescue">something called "rescue"</a> which is basically what's needed.  If you promise that you're a C client--no one has to worry about you catching an exception before processing--because you can't.  You either set up a top-level trap or you crash (same as in Ruby).</p>
<p>The second point could be fixed by a contract that says "if you are going to catch a Rebol error yourself, instead of letting it propagate to a stack higher than yourself, you have to call rebCleanupAfterError()".  But that sounds like a bad contract.</p>
<p>It's a little bit unfortunate to think that <em>every</em> operation needs to be guarded--down to extracting the index out of a value <em>(INDEX-OF $10 raises an error...)</em>.  However:</p>
<ul>
<li>
<p>There could be a mode you ask to put the API in that says you will not be catching any Rebol exceptions (or exceptions like stack overflows) yourself using a catch()...or that if you did, you would call rebCleanupAfterError().  Sounds like it would be easy to screw up, but it's easier to add this kind of thing on top of an otherwise working model than to add a working model on top of something broken.</p>
</li>
<li>
<p>Modern C++ try/catch has what's called <a href="https://stackoverflow.com/a/13836329/211160">zero-cost exceptions</a>, you only pay for the try/catch if the exception occurs.</p>
</li>
<li>
<p>The focus of this API is on readability and usability for the crossover points into Rebol that are made, while keeping as much of the logic separated into host and Rebol as possible. The crossover points shouldn't be the bottleneck.  If it is, then probably another approach is needed (like writing your own native).</p>
</li>
</ul>
<p>So it's not insurmountable, just something that has to be kept in mind.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/embracing-host-language-exception-model-in-the-api/555">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/embracing-host-language-exception-model-in-the-api/555</link>
          <pubDate>Sun, 04 Mar 2018 23:21:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-555</guid>
          <source url="https://forum.rebol.info/t/embracing-host-language-exception-model-in-the-api/555.rss">Embracing Host Language Exception Model in the API</source>
        </item>
        <item>
          <title>Hooking FAIL and PANIC...should DO of an ERROR! be &quot;unhookable&quot;?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>One interesting feature that's coming online a bit here and there is the ability to hook <em>some</em> panics and <em>some</em> errors.</p>
<p>The way the hook is done is that there are native PANIC and FAIL functions which have trivial implementations.  C code calls out to these natives by using the evaluator.  Then, early in the bootstrap process these natives are HIJACK'd with usermode implementations.  If your app then desires, it can further HIJACK those hijackings with adaptations that augment or replace the functionality with additional code.</p>
<p>In the case of panics, I say only "some" are hookable, because panics originating from the core need to terminate the executable.  <em>(They're a sort of "blue screen of death", implying that continuing to run Rebol code would be unwise due to some fundamental corruption or problem.)</em>  But there are also panics which could be safely recovered from, or have things write to log files before exiting, e.g. direct calls to the PANIC or PANIC-VALUE natives from usermode code.</p>
<p><em>(It may be that extensions using the rebPanic() API would mean the "softer" form of panic, or maybe they too have some kind of corruption of their state they don't want you to recover from.  Maybe there need to be two different APIs...what's more serious than a failure, but less serious than a panic?  rebProblem()?)</em></p>
<p>In the case of errors, I say only "some" are hookable because there <strong>must</strong> be a way to invoke an error without it being hooked.  Consider today's implementation of FAIL, which will construct an error object out of whatever you pass it (if it isn't an ERROR! in the first place) and calls DO on it.  If that DO turned around and called into the fail hook again, you'd have an infinite regress.</p>
<p>One simple answer is to say that DO of an ERROR! is an <em>unhookable failure</em>.  That would mean no longer casually writing <strong>do make error! ...</strong>.  But if we assume those people are willing to change that to <strong>fail make error! ...</strong> then this seems the easiest way to get the baseline unhookable error.  And since there's no appearance of FAIL at the callsite, people wouldn't be too surprised that hijacking FAIL wouldn't find out about these particular errors.</p>
<p>At one point, I'd made DO not accept ERROR!s, because FAIL seemed much better at the callsite.  But I realized the only thing taking the ERROR! parameter away would be doing would be raising an "invalid type" error, obscuring what the error was.  :-/  So when that was combined ultimately with the idea that FAIL needed some way to invoke the errors that it was building, I put it back.</p>
<p>So is this a good answer?  That DO of an ERROR! is the low level mechanic for error delivery used in functions like FAIL which you will not get hooked when you HIJACK fail?  It makes some sense to me, but it means that almost no one should be using DO of an ERROR!, unless you are writing a FAIL implementation.</p>
<p>What worries me is if people don't get on board with this, or find it too hard to understand that DO of an ERROR! is not how you should be error'ing, then someone who wants to hook just FAIL would start hooking DO "just to be sure" in case it was passed an ERROR!.  :-/</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/hooking-fail-and-panic-should-do-of-an-error-be-unhookable/484">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/hooking-fail-and-panic-should-do-of-an-error-be-unhookable/484</link>
          <pubDate>Sun, 21 Jan 2018 12:53:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-484</guid>
          <source url="https://forum.rebol.info/t/hooking-fail-and-panic-should-do-of-an-error-be-unhookable/484.rss">Hooking FAIL and PANIC...should DO of an ERROR! be &quot;unhookable&quot;?</source>
        </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Internals - AltRebol</title>
    <link>https://forum.rebol.info/c/development/internals/9</link>
    <description>Topics in the &#39;Internals&#39; category Internals of the Rebol language</description>
    
      <lastBuildDate>Tue, 20 Sep 2022 18:53:49 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/internals/9.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>ARRAY/INITIAL and ACTION! Isotopes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>So the ARRAY mezzanine from R3-Alpha allowed you to make an array with an initial value that could be a function...in which case it evaluated that function each time:</p>
<pre><code>r3-alpha&gt;&gt; array 3
== [none none none]

r3-alpha&gt;&gt; array/initial 3 10
== [10 10 10]

r3-alpha&gt;&gt; n: 0 array/initial 3 does [n: n + 1]
== [1 2 3]
</code></pre>
<p>This raises the question of how you would make an array whose initial value was itself a function.</p>
<p>If you're a loophole-minded person, you might notice you could trick <em>this particular case</em> by making a function that returns a function.</p>
<pre><code>r3-alpha&gt;&gt; array/initial 3 does [:append]
== [#[action! [...]] #[action! [...]] #[action! [...]]]
</code></pre>
<p>But that's not really a general answer for how to deal with this kind of polymorphism--it just works if you're using the result purely to do a substitution.</p>
<h2>Trying This With Isotopic ACTION!s</h2>
<p>I've loosened my stance on isotopes in function frames as parameters.  It's not a good idea to take them as default, but forcing you to make every parameter ^META just to get isotopes is limiting.</p>
<p>So I gave this a shot.  The notation I've got for now is that something like <code>[~action!~]</code> in a typeset says that parameter is willing to accept action isotopes.</p>
<pre><code>array: func [
    {Makes and initializes a block of a given size}

    return: "Generated block or null if blank input"
        [block!]
    size "Size or block of sizes for each dimension"
        [&lt;maybe&gt; integer! block!]
    /initial "Initial value (will be called each time if action isotope)"
        [any-value! ~action!~]
]
</code></pre>
<p>So that <strong>[any-value! ~action!~]</strong> leads to a willingness to accept function isotopes.  Having such an annotation leads you into the "danger zone" where if you don't prefix accesses to INITIAL with a colon, you run the risk of running a function.  But if you don't have the annotation, you don't have to be paranoid and decorate your references.</p>
<p>Here's how the INITIAL references wind up in the implementation:</p>
<pre><code>case [
    block? rest [
        repeat size [append block (array/initial rest :initial)]
    ]
    activation? :initial [
        repeat size [append block run :initial]  ; Called every time
    ]
    any-series? initial [
        repeat size [append block (copy/deep initial)]
    ]
] else [
    append/dup block initial size
]
</code></pre>
<p>So the BLOCK! case which recurses uses the :INITIAL for pass-thru.</p>
<p>I used <strong>RUN :INITIAL</strong> when I could have just used <strong>INITIAL</strong>, simply because it feels more clear.  If this wasn't already contained by being at the end of a block, it would be better to limit the parameterization by saying something like <strong><code>apply :initial []</code></strong> or the now-equivalent <strong><code>initial/ []</code></strong></p>
<p>Since the only isotope type in the typecheck is action, there's no need to use the leading colon for the other references.</p>
<h2>And It Works</h2>
<p>What we're kind of accepting as a default is that function generation produces isotopes.  So getting a plain action requires some kind of extra step, like REIFY</p>
<pre><code>&gt;&gt; func [x] []
== ~#[action! [x]]~  ; isotope

&gt;&gt; action: reify func [x] []
== #[action! {action} [x]]

&gt;&gt; action  ; not word!-active
== #[action! {action} [x]]

&gt;&gt; ap: reify :append
== #[action! {ap} [series value /part /dup /line]]

&gt;&gt; ap
== #[action! {ap} [series value /part /dup /line]]
</code></pre>
<p>What this means is that you get a similar behavior to before, where if you pass a "live" function you've fetched from a word or just generated, then it runs.  You have to do something extra to it to get it to be inert.</p>
<pre><code>&gt;&gt; array 3
== [_ _ _]

&gt;&gt; array/initial 3 10
== [10 10 10]

&gt;&gt; n: 0 array/initial 3 does [n: n + 1]
== [1 2 3]

&gt;&gt; array/initial 3 reify does [n: n + 1]
== [#[action! []] #[action! []] #[action! []]]
</code></pre>
<h2>That Looks Like A Polymorphism Success Story...</h2>
<p>It doesn't require any convoluted thinking to get the literal vs. non-literal distinction.  And you can apply this technique to cases that don't have a weird workaround.</p>
<p><strong>And of course what I really like here is how you have to explicitly indicate you tolerate function parameters that will execute if you don't use a GET-WORD! access.</strong></p>
<p>I wish I could say that all of ACTION! isotopes impacts were as well sorted out as this looks.  But it's a start, and it shows the potential.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/array-initial-and-action-isotopes/1975">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/array-initial-and-action-isotopes/1975</link>
          <pubDate>Tue, 20 Sep 2022 18:53:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1975</guid>
          <source url="https://forum.rebol.info/t/array-initial-and-action-isotopes/1975.rss">ARRAY/INITIAL and ACTION! Isotopes</source>
        </item>
        <item>
          <title>Where Should Isotope Tolerance Begin (and End)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>Isotopes started small, but are now an integral part of the design.  (Give a close read to <strong><a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">"A Justification Of Generalized Isotopes"</a></strong> if you are skeptical of weird new things, until you realize their importance).</p>
<p>They're showing amazing results, but they do raise a number of questions.</p>
<p><strong>One thing is set in stone about them: <em>you can't store them in arrays</em>.</strong></p>
<p>Sometimes that's because storing operations will interpret them as a kind of "instruction".  For instance, isotopic GROUP!s are interpreted as "splices":</p>
<pre><code>&gt;&gt; spread [d e]
== ~(d e)~  ; isotope

&gt;&gt; append [a b c] spread [d e]
== [a b c d e]
</code></pre>
<p>Isotopic BLOCK!s are "packs"... which resolve to their first item unless used in contexts that specially understand how to unpack them (such as using them in combination with a SET-BLOCK!)</p>
<pre><code>&gt;&gt; pack [d e]
== ~['d 'e]~  ; isotope

&gt;&gt; append [a b c] pack [d e]
== [a b c d]

&gt;&gt; [x y]: pack [d e]
== d

&gt;&gt; x
== d

&gt;&gt; y
== e
</code></pre>
<p>But a generically weird isotope that the callee does not understand just gets rejected:</p>
<pre><code> &gt;&gt; unmeta '~something~
 == ~something~  ; isotope

 &gt;&gt; append [a b c] unmeta '~something~
 ** Error: APPEND doesn't know what to do with a ~something~ WORD! isotope
</code></pre>
<h2>First Question: Should Isotopes Be Assignable?</h2>
<p>There's a nice aspect to being able to void out variables like this:</p>
<pre><code>my-var: ~
</code></pre>
<p>That's prettier than <strong><code>unset 'my-var</code></strong>, and it is more obviously an assignment.</p>
<p>But what if you'd put a QUASI! of an isotopic block there?</p>
<pre><code>my-var: ~[d e]~
</code></pre>
<p>The idea is that QUASI! isn't inert, but that it <em>actually evaluates</em> to an isotopic form:</p>
<pre><code>&gt;&gt; ~[d e]~
== ~[d e]~  ; isotope

&gt;&gt; pack [d e]
== ~[d e]~  ; isotope
</code></pre>
<p>So the assignment would be like if you'd written <strong><code>my-var: pack [d e]</code></strong> ... which pretty clearly should set MY-VAR to D... not the isotope ~[d e]~.</p>
<p>Right now, the trick is that a special exception is made when a literal quasiform is to the right of a SET-WORD!, and it's meant as a SET/ANY that doesn't do this kind of decay.</p>
<p><em>I've found this trick is brittle and difficult to abstract.</em>  If you write something like the EXPORT keyword, and you want <strong><code>export var: ~foo~</code></strong> to be compatible with <strong><code>var: ~foo~</code></strong> then it becomes difficult to inherit that tolerance.   You can't get the SET-WORD! var, then evaluate the right hand side, and then expect a SET to tolerate the isotope assignments.</p>
<h2>Going Further... What About Type Tests...or Equality?</h2>
<p>If we look at historical Redbol, we can see there was some tolerance of "UNSET!" values by the type tests:</p>
<pre><code>rebol2&gt;&gt; type? print "HI"
HI
== unset!

rebol2&gt;&gt; integer? print "HI"
HI
== false
</code></pre>
<p>This tolerance did not extend to things like equality operators:</p>
<pre><code>rebol2&gt;&gt; (print "HI") = (print "HI")
HI
HI
** Script Error: Operator is missing an argument
</code></pre>
<p>Red and R3-Alpha deviate on this, allowing "unsets" to be compared for equality:</p>
<pre><code>r3-alpha/red&gt;&gt; (print "HI") = (print "HI")
HI
HI
== true
</code></pre>
<p><em>In the Ren-C world, it's a slippery slope to permit isotope comparisons.</em>  To see why... if you think about something like an isotopic block representing a parameter pack, the semantics for the comparison should be of the first item only.</p>
<pre><code>ren-c&gt;&gt; (pack [1 2]) = (pack [1 3])
== #[true]
</code></pre>
<p>My terminology would be <em>"comparison forces decay"</em>.  If you don't want that you need to ^META the things you are comparing, so you're comparing non-isotopic quasiforms:</p>
<pre><code>ren-c&gt;&gt; ^(pack [1 2])
== ~[1 2]~

ren-c&gt;&gt; ^(pack [1 3])
== ~[1 3]~

ren-c&gt;&gt; ^(pack [1 2]) = ^(pack [1 3])
== #[false]
</code></pre>
<p>It seems like if this kind of comparison does not have fidelity for one kind of isotope, it is suspect for other isotopic forms.  So it would not take its parameter as ^META, and thus error on non-decaying forms...although...</p>
<h2>The Isotopic LOGIC! Proposal Shakes All This Up</h2>
<p>I've proposed the idea that ~true~ and ~false~ isotopes are actually relatively friendly... as isotopes go.  They would not cause errors when accessed from WORD!s, they would need to be legal to assign to SET-WORD!, and we'd assume they'd have to compare as well.  But their inability to be put in BLOCK!s or similar would be an asset--stopping the accidental leakage of the "ugly" forms into data interchange...forcing resolution to WORD!s (or at least purposefully the quasi-words of ~true~ and ~false~)</p>
<p>It (probably?) doesn't seem like a great idea to have an exception for just those two WORD! isotopes...but to generalize the friendliness to any WORD! isotope.  They'd have the array unfriendliness, but also a type checking unfriendliness by not being in the ANY-VALUE! class...only functions that wanted them would take them.</p>
<h2>And Don't Forget ERROR!s...</h2>
<p>There's been a huge improvement from definitional error isotopes, with the impacts felt on a daily basis.  But of course, they throw some more curveballs in.</p>
<p>Assignment via SET-WORD! of an error isotope that hasn't been ^META'd needs to raise that error.</p>
<h1>How To Tame This Zoo?</h1>
<p>One idea I came up with was a notation for isotopic assignments:</p>
<pre><code>[~var~]: ...
</code></pre>
<p>That looks good at first... but what it's really saying is that if the right hand side was a pack with an isotope inside it, then the <em>inside</em> isotope would be tolerated in the assignment.</p>
<p>It gets a little more elaborate, but you can use this to represent any isotopic assignment.  Let's say that assignment of a splice directly wasn't legal, you could put the splice in a pack, and then assign through that:</p>
<pre><code>[~var~]: ~[~(d e)~]~
</code></pre>
<p>That may be convoluted, <em>but it's better than not being able to solve the representation problem at all!</em></p>
<p>We wouldn't see such things that often if we decided to cave and say that voiding variables or WORD! isotopes were going to be legal.  Much more common would be things like this:</p>
<pre><code>var1: ~
var2: ~true~
</code></pre>
<p>You'd only see them when "problematic" isotopes were held in variables, e.g. assigned via SET/ANY (or assigned via a pack to begin with).</p>
<p>It's just slightly dismaying to think of people trying to write truly general code...ending up having to hammer out that ugly pattern:</p>
<pre><code>compose/deep [
   [~(name)~]: ~[(meta ...whatever...)]~
]
</code></pre>
<p><em>I think that's just life.</em>  And really, it's the tip of the representational iceberg...we already know that you can't round-trip functions or objects or other things in this way.  It's exaggerated for me because I try to think of how MAKE OBJECT! [...] renders in a general sense.  But it's probably not the case that many people are going to need (or want) to do this kind of thing.</p>
<h2>Does That Answer Anything About Type Tests?</h2>
<p>What actually triggered me to write about this was dealing with some code like this:</p>
<pre><code> if null? do code [...]
</code></pre>
<p>The code was returning VOID...which is the isotopic state of NULL.  And the NULL? test was erroring, because it was only designed to operate on non-meta values.</p>
<p>Let's not consider the NULL? question as special--let's imagine it could have just as easily been INTEGER? or somesuch.</p>
<p>There is a bit of a problem with any function that takes an isotope as a parameter.  So think of:</p>
<pre><code>&gt;&gt; foo: func [x] [return pack [x + 1 x + 2]]

&gt;&gt; pack? foo 10
== #[true]

&gt;&gt; integer? foo 10
== #[true]

&gt;&gt; x: foo 10
== 11

&gt;&gt; y: ^ foo 10
== ~[11 12]~
</code></pre>
<p>Does it make <em>sense</em> for there to be something like PACK? which has the isotopic X-ray vision?  Or should PACK? only exist as a question you can ask of a meta-value ("metapack?")</p>
<p>Having more of the functions like INTEGER? and NULL? trigger alarms on more isotope types helps create a spectrum of warnings that guide generic code that it's likely asking dangerous questions.</p>
<p><strong>But it seems to me that anything which is tolerant in plain assignment without error should be tolerated in type testing without error.</strong></p>
<p>It looks to me like <strong>~</strong> and <strong>~word~</strong> fit into that set.</p>
<p>We know that packs decay, and errors will actively fail on those errors...without the "pack inside a pack" or "error inside a pack" loopholes.  <em>But is it worth it to stop other isotope classes, or should it be something that's only handled on the getting side?</em></p>
<p>A lot of this likely ties into the answer for how function isotopes pan out.  So that needs revisiting.</p>
<p>However, I'm glad for the singular pack solution to the edge cases!</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/where-should-isotope-tolerance-begin-and-end/1964">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/where-should-isotope-tolerance-begin-and-end/1964</link>
          <pubDate>Mon, 12 Sep 2022 23:01:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1964</guid>
          <source url="https://forum.rebol.info/t/where-should-isotope-tolerance-begin-and-end/1964.rss">Where Should Isotope Tolerance Begin (and End)</source>
        </item>
        <item>
          <title>Thought: Reimplementing Multi-Return via Isotopic BLOCK!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>With <a href="https://forum.rebol.info/t/canonizing-group-as-the-underlying-array-type-for-splices/1953">splices confined to isotopic GROUP!s</a>, it occurs to me that isotopic BLOCK! could be an angle to solving multi-returns.</p>
<p>The problem of not being able to return NULL or VOID would be solved by having the protocol speak in meta values:</p>
<pre><code>&gt;&gt; ^ transcode/one {abc def}
== ~['abc '{ def}]~  ; isotope

&gt;&gt; ^ transcode/one {}
 == ~[_ '{}]~  ; isotope
</code></pre>
<p>So that BLANK! would actually mean NULL.</p>
<p>It would sacrifice the sensitivity to asking how many return values were requested... a feature I felt pretty attached to.  But it would offer a solution to the piping problems that plague things like even simply putting a multi-return expression into a group.</p>
<p>It would mean that doing a ^META casually inline in expressions would be crazier, you'd tend to want to unpack things:</p>
<pre><code>&gt;&gt; x: multi-return-func
== &lt;result&gt;

&gt;&gt; x: ^ multi-return-func
== ~['&lt;result&gt; _ '*]~  ; wait a minute what is all this crap?

&gt;&gt; [^x]: multi-return-func
== '&lt;result&gt;
</code></pre>
<p><strong>Because I just had the idea, I don't know all the ramifications.</strong>  But it's clear this would solve the issues with APPLY and other piping scenarios.</p>
<p>Evaluator behavior would be that any slots not expecting a "pack" isotope would just become its first item UNMETA, but then a ^META slot can do other things.</p>
<p>This would mean it would be your choice to use the output variable proxying feature to get multi-return mechanics.  It would be a convenience feature of FUNC for those who wanted it, in order to give better documentation on the interface and to make it clearer in the code what you were assigning.</p>
<h2>It Wouldn't <em>Prevent</em> Enfix Detection...</h2>
<p>And it wouldn't rule out people who wanted to do cleverness detecting things on the left.  They could use mechanisms parallel to what exists today.  But that would defeat putting function calls in groups, etc.  Which may be the right tradeoff for some scenarios.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/thought-reimplementing-multi-return-via-isotopic-block/1955">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/thought-reimplementing-multi-return-via-isotopic-block/1955</link>
          <pubDate>Thu, 01 Sep 2022 13:19:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1955</guid>
          <source url="https://forum.rebol.info/t/thought-reimplementing-multi-return-via-isotopic-block/1955.rss">Thought: Reimplementing Multi-Return via Isotopic BLOCK!</source>
        </item>
        <item>
          <title>Should SET-WORD! Disallow Isotopic Assignments?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>Historically, Rebol2 and R3-Alpha wouldn't let you assign UNSET! via a SET-WORD!, regardless of whether it was provided literally or through an evaluation.  You had to use SET/ANY:</p>
<pre><code>rebol2&gt;&gt; x: #[unset!]
** Script error: x: needs a value

rebol2&gt;&gt; x: print "hi"
hi
** Script error: x: needs a value

rebol2&gt;&gt; set/any 'x #[unset!]

rebol2&gt;&gt; x
** Script Error: x has no value
</code></pre>
<p>At first, I thought Red made a concession in the direct assignment case:</p>
<pre><code>red&gt;&gt; x: #[unset!]
== unset!

red&gt;&gt; x: print "hi"
hi
*** Script Error: x: needs a value
</code></pre>
<p>However, that's not what's happening...it's an incompatible interpretation...where Red considers #[unset!] to be the datatype for unset!, and #[unset] (no exclamation point, illegal in Rebol2) is an actual unset value:</p>
<pre><code>red&gt;&gt; type? #[unset!]
== datatype!

red&gt;&gt; type? #[unset]
== unset!

red&gt;&gt; x: #[unset]
*** Script Error: x: needs a value
</code></pre>
<p><strong>But I bring it up because at one point in time, Ren-C actually had a specific behavior that it would only allow a SET-WORD! to assign an unset to a variable if it was <em>not</em> the product of a function call.</strong>  Today this would look something like:</p>
<pre><code>&gt;&gt; x: ~

&gt;&gt; x: print "hi"
** Error: Cannot assign evaluative isotopes to X

&gt;&gt; set/any 'x ~

&gt;&gt; x
** Error: X is ~ isotope (e.g. isotopic BLANK!, represents an unset state)
</code></pre>
<p><strong>I've wondered if this rule strikes the right balance.</strong>  If you really want to deal with isotopic values that are the result of an evaluation, you would use ^META, and get the non-isotopic (QUASI!) form.  There'd be several ways of saying it:</p>
<pre><code>&gt;&gt; x: ^ print "hi"
== ~

&gt;&gt; x: ^(print "hi")
== ~

&gt;&gt; x: meta print "hi"
== ~

&gt;&gt; [^x]: print "hi"
== ~
</code></pre>
<p>This makes much more sense now than when NULL and "unset" were the same state.  And it would help keep isotopes under control.</p>
<h2>Implications for the "Only Isotopic ACTION! Runs" Idea</h2>
<p>This would mess with my current experimental branch where <a href="https://forum.rebol.info/t/attack-of-the-activated-actions/1900">isotopic actions stored in variables are the WORD!-triggered kind</a> (while regular actions would be inert).</p>
<p>It has FUNC returning isotopic actions, and you'd get an error:</p>
<pre><code>&gt;&gt; foo: func [/refine] [...]
** Error: Cannot assign isotope to FOO with SET-WORD! (see SET/ANY)
</code></pre>
<p>Making an exception for action isotopes, and saying they could be assigned without an annotation really feels like it undermines the entire proposal and the safety you'd get from it.</p>
<p>I will note that I really did get a warm fuzzy feeling when the generators produced plain ACTION!, and something had to tip it into being isotopic.  But I had to pan <strong><code>/foo: func [... /refine] [...]</code></strong> in no small part due to leading-slash being "taken" by refinements in function spec and apply.</p>
<p>This made me take a more serious look at the concept of retaking something like <strong><code>-&gt;</code></strong>.  Under the new rules that wouldn't have to finesse the assignment as well:</p>
<pre><code>foo: -&gt; func [/refine] [...]

foo: runs func [/refine] [...]  ; for those who dislike symbols
</code></pre>
<p>So either of these would act like <strong><code>set/any 'foo isotopic func [/refine] [...]</code></strong>.</p>
<p>Wait... <em>UNLESS...</em> <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=9" title=":thinking:" class="emoji" alt=":thinking:"></p>
<p>I just had a rather compelling thought, that such a tool could <em>only accept isotopic ACTION!</em>, and that this would provide natural guidance not to screw it up... because a plain assignment would error:</p>
<pre><code>&gt;&gt; foo: func [/refine] [...]
** Error: Can't assign isotope ACTION! via SET-WORD!, use -&gt; or INERT
</code></pre>
<p><em>So if all the function generators were committed to returning isotopes, it would be self-correcting.</em>  You wouldn't be able to forget to triage the assignment.</p>
<pre><code>&gt;&gt; foo: inert func [x] [print ["x is" x]]
== #[action! [x]]

&gt;&gt; foo
== #[action! [x]]

&gt;&gt; foo: -&gt; func [x] [print ["x is" x]]
== ~#[action! [x]]~  ; isotope

&gt;&gt; foo 10
x is 10
</code></pre>
<p>Now THAT is clever.  You're forced into triage, and can't forget to do one or the other!  Forgetting the annotation was one of the big Achilles heels of making generator products inert by default (hard to find bugs) but this ties that up.</p>
<p>Very promising premise!  But there are tricky issues, like how today's METHOD needs to look back to quote what it's being assigned to, in order to know how to bind the value.  Maybe it wouldn't need to... if <strong><code>-&gt;</code></strong> also made that binding connection...and maybe there'd be no such thing as METHOD.  <img src="https://forum.rebol.info/images/emoji/twitter/exploding_head.png?v=9" title=":exploding_head:" class="emoji" alt=":exploding_head:"></p>
<h2>Related Question: What About VOID ?</h2>
<p>A corollary to this question is <strong>"Should SET-WORD! Stop Treating VOID Assignments as Unsetting Variables"</strong></p>
<p>It might seem obvious to say "yes, that should be an error too".  In fact...since I've vetoed the idea of variables actually being able to hold "voidness" it might seem like an <em>even worse sin</em> that should be prohibited... because you're not actually preserving the "integrity" of the assignment.</p>
<p><em>BUT</em>... when I tried to rule it out I noticed that it was used in frames for things like setting refinements, like:</p>
<pre><code>&gt;&gt; series [a b c]
&gt;&gt; value: 3

&gt;&gt; f: make frame! :append
&gt;&gt; f.series: series
&gt;&gt; f.value: value
&gt;&gt; f.dup: if integer? value [value]

&gt;&gt; do f
== [a b c 3 3 3]
</code></pre>
<p>But should the IF evaluate to void...the /DUP would not be set.  That not-set state was leading the default behavior for the refinement being not set (to coerce it to NULL in the call).</p>
<p>This is an interesting use case, and it arguably isn't "doing an isotopic assignment" (void is not an isotope, and it has no QUASI! form).  It's making a subtle judgment call, and it might be a good one.  I'll keep this as-is for now.</p>
<h2>Ultimate Goal: Freedom Of Choice  <img src="https://forum.rebol.info/images/emoji/twitter/statue_of_liberty.png?v=9" title=":statue_of_liberty:" class="emoji" alt=":statue_of_liberty:">
</h2>
<p>It's still definitely want to make it possible to override these behaviors if you find they get in your way.  Certainly we'd need it for Redbol...but it should work at other granularities.</p>
<p>Why shouldn't you be able to say <em>"hey, for just this function's body I want all the SET-WORD!s to assign isotopes without complaint"</em>?</p>
            <p><small>7 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/should-set-word-disallow-isotopic-assignments/1919">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-set-word-disallow-isotopic-assignments/1919</link>
          <pubDate>Wed, 17 Aug 2022 08:32:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1919</guid>
          <source url="https://forum.rebol.info/t/should-set-word-disallow-isotopic-assignments/1919.rss">Should SET-WORD! Disallow Isotopic Assignments?</source>
        </item>
        <item>
          <title>Questions About &quot;Wrapped&quot; Things (QUOTED!, QUASI!)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>I've been held up on the new generalized isotopes due to looking at examples like this one:</p>
<pre><code>attempt: func [
    return: [&lt;opt&gt; any-value!]
    code [block!]
    &lt;local&gt; last'
][
    last': the ~
    reduce-each ^result' code [
        if error? result' [return null]
        if @void = result' [continue]
        last': result'
    ]
    return unmeta last'
]
</code></pre>
<p>Here you see ATTEMPT running a REDUCE-EACH, but asking for the ^META of each expression.  Asking for the result in meta form suppresses the automatic promotion of a definitional error (isotopic) to a generic failure.  (Re-read the <a href="https://forum.rebol.info/t/fail-vs-return-fail-the-new-age-of-definitional-failures/1852">definitional failure post</a> for a refresher.)</p>
<p>The meta of the isotopic error was received as a plain ERROR!.  And it handles it by returning null.  A void state is handled by continuing--leaving the cumulative result as-is.</p>
<p><em>(<a href="https://forum.rebol.info/t/q-should-be-the-meta-of-void-a-no/1915">I've explained why the meta state for void is weird.</a>  For the sake of argument, let's say it doesn't change under the new rules.)</em></p>
<h2>The BAD! Touch</h2>
<p>I've <a href="https://forum.rebol.info/t/should-everything-have-an-isotopic-form/1889/7">enumerated the reasons</a> why having isotopes generate a ^META which is actually a "BAD! ERROR!" has several advantages.  Wrapping up meta in BAD! makes it a better generalized inverse evaluator (UNEVAL) as well as making all the meta states truthy.</p>
<p><strong>But I'm displeased with the impact this has here.</strong></p>
<pre><code>    last': the ~
    reduce-each ^result' code [
        all [
            bad? result'
            error? unbad result'
        ] then [
            return null
        ]
        if @void = result' [continue]
        last': result'
    ]
    return unmeta last'
</code></pre>
<p>Obviously the naming is... bad.  But I don't like not being able to ask it in a single step, as I could before.  It makes it tempting to introduce constructs like BAD-ERROR?</p>
<pre><code>    last': the ~
    reduce-each ^result' code [
        if bad-error? result' [return null]
        if @void = result' [continue]
        last': result'
    ]
    return unmeta last'
</code></pre>
<h2>Can We Avoid Making BAD-XXX? or QUOTED-XXX? Tests</h2>
<p>One strategy could be if there was some kind of arity-2 BAD test, like:</p>
<pre><code>&gt;&gt; badly? integer! (first [~10~])
== #[true]
</code></pre>
<p>This would avoid having to fill the global namespace with a bunch of things like BAD-INTEGER?</p>
<p>You might get the idea that a TYPE OF could encode this, like:</p>
<pre><code>'~integer!~ = type of (first [~10~])
</code></pre>
<p>But that's not a BAD! DATATYPE! you're getting on the left.  It's a BAD! WORD!, and we don't have any kind of WORD!-to-DATATYPE! equivalence (there are reasons for this, beyond the scope of this thread).</p>
<p>Maybe there's a dialect of containment of some kind (?) like:</p>
<pre><code> match [bad!.integer!] (first [~10~])
</code></pre>
<p>Given some recent suggestions, it might be possible to say something like:</p>
<pre><code>if integer? try unbad (first [~10~])
</code></pre>
<p>The concept being that if it wasn't wrapped up like ~10~, then you'd get the original value out of the TRY instead of a type error.  But then this would be conflated if your original input had been an integer.  It would work for the error case since things that aren't bad are quoted, but it doesn't feel good.</p>
<h2>It Seems We Should Have a Way Of Asking This...</h2>
<p>I look at the ^META code where it doesn't have the bad wrapper on it, and I think "that's so much cleaner".  When you multiply it across all the other places that want to process meta arguments, it just feels wrong to throw in all the extra complexity.</p>
<p>Yet it feels like something of a failure that we don't have an easy way of asking if a value is a datatype wrapped in tildes or not.  It's a weakness that exists in our ability to ask questions about quoted types as well.</p>
<p>Ultimately, is it the best solution to backpedal on the QUOTE/META unification and accept different tracks?</p>
<ul>
<li>
<p><strong>META &amp; UNMETA</strong> - promotes isotopes to undecorated form, NULL &lt;=&gt; NULL, promotes non-isotopes to one level quoted higher than they were.  Because it can generate blanks and logic false, NULL is <strong>not</strong> the only falsey result you can receive from a META operation.</p>
</li>
<li>
<p><strong>QUOTE &amp; UNQUOTE</strong> - promotes isotopes to their ~bad~ value forms, NULL &lt;=&gt; single apostrophe ('), quotes everything else.  Acts as a proxy for "UNEVAL/EVAL" of single values.</p>
</li>
</ul>
<p>Then the question remains about what construct something like FOR-BOTH should use.  It wants to act like QUOTE and UNQUOTE except with NULL and VOID passthrough.</p>
<p>Under these rules, it's really a special "don't quote quite everything" version of QUOTE so maybe less is more, and just give it an asterisk... to say "quote but with some kind of twist".</p>
<pre><code>for-both: lambda ['var blk1 blk2 body] [
    unquote* all [
        quote* for-each (var) blk1 body
        quote* for-each (var) blk2 body
    ]
]
</code></pre>
<p>I can't think of what this could be as a refinement.  QUOTE/PASSTHRU-NULL-AND-VOID?  QUOTE/WITH-HOLES-IN-IT?  QUOTE/LEAKY?  QUOTE/USUALLY?</p>
<p>Not sure, but I really feel like these should be true by default:</p>
<pre><code>&gt;&gt; quote null
== '

&gt;&gt; quote void
** Error: VOID has no quoted form, use META (or QUOTE* if you want to passthru)
</code></pre>
<p>Anyway, this is just the same thing from a week ago running around, and I can't make progress until I pin it down!  I'll sleep on it a bit.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/questions-about-wrapped-things-quoted-quasi/1916">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/questions-about-wrapped-things-quoted-quasi/1916</link>
          <pubDate>Mon, 15 Aug 2022 18:22:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1916</guid>
          <source url="https://forum.rebol.info/t/questions-about-wrapped-things-quoted-quasi/1916.rss">Questions About &quot;Wrapped&quot; Things (QUOTED!, QUASI!)</source>
        </item>
        <item>
          <title>How &#39; Became Quoted-Void (and ~ Became Quasi-Void)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>Prior to modern quasiforms, <code>~</code> was a special "BAD-WORD! with no name", e.g. a null spelling:</p>
<pre><code>&gt;&gt; type of '~
== #[datatype! bad-word!]

&gt;&gt; as text! '~
; null
</code></pre>
<p>So unlike regular WORD!, it was possible to have a BAD-WORD! that had no UTF-8 representation.  (Yes, this was a sign that something was amiss.)</p>
<p>However, I liked having <strong><code>~</code></strong> be something that could be reserved by the system, and I thought the "bad-wordness" plus the lack of any associated text made it a good choice for being what we'd call "none"</p>
<pre><code>&gt;&gt; if none? '~ [print "Yup, that's a none"]
Yup, that's a none.

&gt;&gt; '~  ; console would not show by default

&gt;&gt; mold print "So ~ was the result of things like PRINT"
So ~ was the result of things like PRINT
== "~"
</code></pre>
<p><em>(You can re-read my <strong><a href="https://forum.rebol.info/t/why-isnt-print-invisible-void/1466/4">explanation of why void is a bad return value for things like PRINT or HELP.</a></strong>  If you want to communicate to the console that it not print anything, then you need to do that communication through some kind of non-void thing, otherwise that signal is too slippery.)</em></p>
<p>You could put these BAD-WORD!s in blocks, which made them kind of a lousy choice for the result of a PRINT.  So when isotopes came on the scene, it seemed a much better idea to say that none was the <em>isotopic</em> form of something.</p>
<p>So in the first cut of generic isotopes, I said ~ was the quasiform of BLANK! (as opposed to ~_~, which looks pretty bad):</p>
<pre><code>&gt;&gt; quasi _
== ~

&gt;&gt; ~
== ~  ; isotope

&gt;&gt; quasi? '~
== ~true~  ; isotope

&gt;&gt; none? ~
== ~true~  ; isotope
</code></pre>
<h2>But... Would It Make More Sense Related to Void?</h2>
<p>Initially I was at something of a loss for how void fit into the isotopic world.</p>
<p>One of my early reasonings was that VOID was more "etheric" than NULL.  <em>So perhaps void was actually the isotopic form of null,</em> and ~ could be null's quasiform:</p>
<pre><code> &gt;&gt; quasi null
 == ~

 &gt;&gt; ~
 ; void
</code></pre>
<p>But this was confusing, since if <code>~</code> was the meta of void, there really isn't any such thing as a "~ isotope".  You could never make one, because I thought it needed to vaporize.</p>
<pre><code>&gt;&gt; 1 + 2 ~
== 3
</code></pre>
<p>I was bothered by taking it for this purpose, because I was pretty attached to <strong><code>~</code></strong> for representing unset variables.  It looked clean, letting you see the things you've set and haven't:</p>
<pre><code>&gt;&gt; f: make frame! :append

&gt;&gt; f.dup: 2
&gt;&gt; f.value: "a string"

&gt;&gt; f
== make frame! [
    series: ~
    value: "a string"
    part: ~
    dup: 2
    line: ~
]
</code></pre>
<p>If ~ represented voids then unset variables would be something like isotopic blanks, and look significantly crappier:</p>
<pre><code>&gt;&gt; f
== make frame! [
    series: ~_~
    value: "a string"
    part: ~_~
    dup: 2
    line: ~_~
]
</code></pre>
<p>But it wasn't just in these printouts, also in source.  Being able to simply type <strong><code>(x: ~)</code></strong> to unset a variable and have that be the right way to do it...in an object field or just in code, was just too good.</p>
<p>That made me feel pretty attached to the idea that ~ is the contents of an unset variable, which is not displayed by the terminal, and which is ornery to things like ANY or ALL.</p>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/how-became-quoted-void-and-became-quasi-void/1915">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-became-quoted-void-and-became-quasi-void/1915</link>
          <pubDate>Mon, 15 Aug 2022 12:15:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1915</guid>
          <source url="https://forum.rebol.info/t/how-became-quoted-void-and-became-quasi-void/1915.rss">How &#39; Became Quoted-Void (and ~ Became Quasi-Void)</source>
        </item>
        <item>
          <title>Extending Contexts (OBJECT!, MODULE!, etc)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>In R3-Alpha, it is possible to append key/value pairs to objects via a block:</p>
<pre><code>&gt;&gt; obj: make object! [a: 10]
== make object! [
   a: 10
]

&gt;&gt; append obj [b: 20 c: 30]
== make object! [
    a: 10
    b: 20
    c: 30
]
</code></pre>
<p>You can't do that in Rebol2, and Red did not carry it forward.</p>
<p><strong>But in Ren-C, isotopes are not allowed in blocks.</strong>  It's more powerful if there is an operation which extends the object via a block which gets evaluated... much as the block in MAKE OBJECT! is evaluated.</p>
<p>As a general rule, APPEND should certainly not be REDUCE-ing block arguments.  So some other operation is needed</p>
<p>Red has an EXTEND operation, but it is "reserved for future use":</p>
<pre><code>USAGE:
     EXTEND obj spec

DESCRIPTION: 
     Extend an object or map value with list of key and value pairs. 
     EXTEND is a native! value.

ARGUMENTS:
     obj          [object! map!] 
     spec         [block! hash! map!] 

REFINEMENTS:
     /case        =&gt; Use case-sensitive comparison.
</code></pre>
<p>Given that it's not implemented, we don't know if that spec block is intended to be evaluated or not.  Also, we'd assume EXTEND would create a new object (since their objects don't expand).</p>
<p>Anyway, APPEND to an OBJECT! is something that probably doesn't make sense.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/extending-contexts-object-module-etc/1913">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/extending-contexts-object-module-etc/1913</link>
          <pubDate>Tue, 09 Aug 2022 22:00:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1913</guid>
          <source url="https://forum.rebol.info/t/extending-contexts-object-module-etc/1913.rss">Extending Contexts (OBJECT!, MODULE!, etc)</source>
        </item>
        <item>
          <title>FRAME! / ACTION! Duality Examined</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>The mechanics behind FRAME! and ACTION! have been mixed up and reshaped over time, to where they are very much tied together.</p>
<p>At times I've wondered if we need both types.  If ACTION!s become inert unless they are isotopic, then that would seem to blur the distinction even more... since FRAME!s have kind of been "inert actions".</p>
<p>So I thought I'd try writing up an explanation of the current state of things.</p>
<h2>First: What's a FRAME! ?</h2>
<p>You can think of a FRAME! as an object which has keys and values for the arguments and locals of a function.  There's a flag on each cell which indicates whether the object member has been "specialized out".  If the flag is set, the slot is presumed to contain the value it will have when the function runs.  Otherwise the object member is presumed to contain the type information for acquiring that parameter.</p>
<p>So when you make an ACTION! like:</p>
<pre><code>foo: func [x [integer!] y [text!] &lt;local&gt; z] [...]
</code></pre>
<p>It's internals are actually a FRAME! (called an "exemplar") that looks <em>something</em> like:</p>
<pre><code>make frame! [
    x: [integer!]  ; unspecialized
    y: [text!]  ; unspecialized
    z: ~   ; specialized
]
</code></pre>
<h2>What's The Difference Between ACTION! and FRAME!, Then?</h2>
<p>Looking at the above: <strong>you wouldn't want to try and DO a FRAME! which has type information in the argument slots</strong>.  When the code for the function runs, it's expected that X be <em>an integer instance</em>...not type information saying an integer is expected!</p>
<p>So when you MAKE FRAME! from an ACTION!, it goes through all the slots and wipes them out to be unset:</p>
<pre><code>&gt;&gt; make frame! :foo
== make frame! [
    x: ~
    y: ~
]  ; ^-- local z is not shown, as it was already specialized to a value
</code></pre>
<p>But it still has to maintain a link to the original information about the parameter types, in order to validate them.  So there's a pointer from each of these "non-exemplar" FRAME!s to the "exemplar" FRAME! with the type information.</p>
<h2>So ACTION!s are FRAME!s w/typesets in slots where args would be?</h2>
<p>Kind of.  I glossed over some details there (there's more information in the parameter description than the type block...you need to know if it's quoted, or if it's a refinement, etc.)</p>
<p>Right now every FRAME! points at an ACTION! instance.  So you can ask <strong>action of frame</strong> and get an answer.  That answer leads you to the thing that the system will use to do type checking on that frame (and you can in theory use it yourself).</p>
<p><strong>It could truthfully be said that you never execute ACTION!s, you only execute FRAME!s.</strong>  But when we say we "execute an action" all we mean is that a new frame is created for it, and then <em>that</em> frame is executed.</p>
<p>One might wonder why something like SPECIALIZE would create an ACTION! instead of just making a FRAME!.  One good reason is that this offers an opportunity to <em>completely erase</em> the specialized variables from the interface.  With the variables erased, the words become available again for use in AUGMENT-ing the composite function.</p>
<h2>So There's Some Info...</h2>
<p>Things are sort of stable with this, but a big thing on the horizon is the possibility that there might be FRAME! instances for evaluators besides actions.  So you could have a FRAME! representing just the evaluation of a BLOCK!.  (Today that's <em>sort of</em> what a VARARGS! is.)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/frame-action-duality-examined/1898">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/frame-action-duality-examined/1898</link>
          <pubDate>Sat, 23 Jul 2022 17:43:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1898</guid>
          <source url="https://forum.rebol.info/t/frame-action-duality-examined/1898.rss">FRAME! / ACTION! Duality Examined</source>
        </item>
        <item>
          <title>Stackless Is Here, Today, Now! :pancakes:</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>As proof that it's real, you can try this:</p>
<pre><code>&gt;&gt; counter: func [value] [
      if 0 = modulo value 1000 [print [value]]
      counter value + 1
  ]
</code></pre>
<p>How many stack levels you get will depend on the available memory of your platform--not your CPU stack.</p>
<p>I got this on Chromium on Linux:</p>
<pre><code>&gt;&gt; counter 0
0
1000
2000
3000
4000
5000
6000
7000
8000
9000
10000
11000
12000
13000
14000
15000
16000
17000
</code></pre>
<p>It just terminates, but the error that shows up in the browser console is:</p>
<blockquote>
<p>Uncaught RuntimeError: Aborted(Cannot enlarge memory arrays to size 16867328 bytes (OOM). Either (1) compile with -sINITIAL_MEMORY=X with X higher than the current value 16777216, (2) compile with -sALLOW_MEMORY_GROWTH which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with -sABORTING_MALLOC=0)</p>
</blockquote>
<p>The same amount was gotten on Firefox, probably because emscripten requests the same amount of Wasm memory space on each.</p>
<h2>Point Is, It Ran Out of Memory... not Stack!</h2>
<p>We can see there's work to do on responding to out-of-memory errors (we've never really had a great story for that).  <em>But at least we can (!)</em> -- I've explained already that stack overflows can't be caught the way a failed memory allocation can.  That's a huge motivator for the change.</p>
<p>But still, over 17000 stack levels is kind of neat in and of itself!</p>
<p>So how do desktop executables "stack up", on my 16-core Lenovo ThinkPad i7 with 64GB of memory...?</p>
<p>As a quick comparison: for Red on Windows, it doesn't make it to 2000:</p>
<pre><code>red&gt;&gt; counter 0
0
1000
*** Internal Error: stack overflow
*** Where: %
*** Stack: counter counter counter counter counter counter counter counter coun
ter counter counter counter counter counter counter counter counter counter cou
nter counter counter counter counter counter counter counter counter counter co
unter counter counter coun...
</code></pre>
<p>Running an actual count got me to 1943 and then it crashed.</p>
<p><em>(I take it that encountering a stack overflow -during- a PRINT leads them to a harsher situation than just during a recursion.  But this is all the more reason you can't play fast-and-loose with the CPU stack, it cannot be trapped like an out of memory error!  Right now we may be crashing too, but it's substantially closer to being managed.)</em></p>
<p>For Rebol2 on Windows it makes it to 14262, and does not crash.  (So Red's an order of magnitude worse, and crashes.)</p>
<p>I hadn't built a 32-bit optimized Windows executable for a while (and actually had to fix a couple of compiler warnings to get one).  But I figured I'd do so for an apples-to-apples comparison with the Rebol2 and Red EXEs.</p>
<p>32-bit Ren-C makes it to...well, jeez.  Printing it out one by one could go on forever, so I tried only doing a print on modulo 10,000.  It starts to slow down a bit around 2 million, but ticks past 3 million pretty easily...and makes it to 4 million.  It eventually terminates without a message at 4780000 (it's an optimized build, and our out-of memory handling needs work...this would likely be an assert in a debug build).</p>
<p>So generously rounding Red up to 2,000... Ren-C can handle over 2000x the stack levels, at least.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<h2>Now, To Reap The Benefits...</h2>
<ul>
<li>
<p><strike>I need to rework the JavaScript extension to use this intrinsic stackless property, instead of "Asyncify".</strike>  DONE!</p>
<ul>
<li>
<p>Asyncify gave us the pseudo-stackless ability of suspending arbitrary non-stackless code in order to run browser events.  This let us do things like ASK for input while in the middle of a loop.  With real stackless, we (shouldn't) need that.</p>
</li>
<li>
<p>Asyncify added bloat to our code generation that I recall making the .wasm about double the size.  We'll see how accurate my memory is on that, but hopefully the size of libr3.wasm will go way down.</p>
</li>
</ul>
</li>
<li>
<p><strike>One by one the natives have to be redone to stackless.  Only then can we truly ditch Asyncify, because if something like FOR-EACH isn't stackless we wouldn't be able to do something like PRINT or ASK inside of that kind of loop... it would raise an error.</strike>  MOSTLY DONE!</p>
<ul>
<li>
<p>We can probably punt on some things and drop asyncify even if not everything is stackless yet.</p>
</li>
<li>
<p>You might not be able to do something like <strong><code>foo.(ask "Field Name?"): 10</code></strong> until TUPLE! lookup has stackless processing bubble up through its GROUP! evaluations, but I think we can live with that being an error for a while--if it halves the size of the wasm.</p>
</li>
</ul>
</li>
<li>
<p>Generators and Yielders need to be resurrected.  They were pretty well designed before, but locking issues created headaches...and it's time to attack those again.</p>
</li>
<li>
<p>Out-of-memory errors have to be reined in--not just so stack overflows can be handled gracefully, but that any kind of out-of-memory is handled gracefully!</p>
<ul>
<li>We also might want users to be able to set a policy (if they wish) to limit the stack before memory runs out, just so that infinite recursions get caught earlier in casual programs that aren't intentionally using big stacks.</li>
</ul>
</li>
</ul>
<p>In any case, it feels good to get the core of the work done two years ago hammered into shape...and see it running in the browser!</p>
            <p><small>5 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/stackless-is-here-today-now/1844">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/stackless-is-here-today-now/1844</link>
          <pubDate>Fri, 17 Jun 2022 14:58:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1844</guid>
          <source url="https://forum.rebol.info/t/stackless-is-here-today-now/1844.rss">Stackless Is Here, Today, Now! :pancakes:</source>
        </item>
        <item>
          <title>Is GROUP! in PATH! for function invocations worth it?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>Back in the day, I thought it would be neat to allow you to put GROUP!s in paths.  So you could do things like this:</p>
<pre><code>append/(if condition ['only]) [a b c] [d e]
</code></pre>
<p>It turned out to be of fairly limited use.  Really you could only use it with refinements that didn't take parameters, because it changes the "shape" of the execution stream.  Consider how you would make the following sensible:</p>
<pre><code>append/(if condition ['dup]) [a b c] [d e] ???
</code></pre>
<p>When the condition is true you want something in the ??? spot.  When it's false you don't.  How can your code cover both cases?</p>
<h2><strong><a href="https://forum.rebol.info/t/apply-ii-the-revenge/1406/3">Now we have a modern APPLY</a></strong></h2>
<p>It bends some of the raw frame rules, and lets you use LOGIC! for parameterless refinements:</p>
<pre><code>apply :append [[a b c] [d e] /only condition]
</code></pre>
<p>It's a bit longer.  And we haven't really firmed up questions like whether you need the GET-WORD! or if it's soft quoted by default.  Or if there might be some clever shorthand:</p>
<pre><code>($ append [a b c] [d e] /only condition)
</code></pre>
<h2>I'm In A Mood To Kill Off Lesser-Loved Features <img src="https://forum.rebol.info/images/emoji/twitter/hocho.png?v=9" title=":hocho:" class="emoji" alt=":hocho:">
</h2>
<p>All things being equal, it might seem nice to support.  But every feature has a cost!</p>
<p><strong>You'd still be able to put GROUP!s in paths for your own purposes, but refinement dispatch in functions wouldn't use it.</strong></p>
<p>You could also use DO of COMPOSE'd code if you really wanted to:</p>
<pre><code>do compose/deep [
    append/(if condition ['only]) [a b c] [d e]
]
</code></pre>
<p>So if anyone has a good argument for keeping the function dispatch behavior, speak up now!</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/is-group-in-path-for-function-invocations-worth-it/1813">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/is-group-in-path-for-function-invocations-worth-it/1813</link>
          <pubDate>Fri, 13 May 2022 04:35:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1813</guid>
          <source url="https://forum.rebol.info/t/is-group-in-path-for-function-invocations-worth-it/1813.rss">Is GROUP! in PATH! for function invocations worth it?</source>
        </item>
        <item>
          <title>Conflation vs. Safety, RETURN and the Finer Points of ~null~ Isotopes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p><code>~null~</code> isotopes are a novel solution shaped to solve a specific problem.  As a reminder of what the goal is...</p>
<h1>The Goal is to Please <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> <em>AND</em> Please me</h1>
<p>NULL is the signal of "soft failure".  It's a unique result reserved for when a branch fails, or when a loop is halted by a BREAK, when PARSE fails...etc.</p>
<p>Its property of not being storable in blocks makes it critical to disambiguating this historical problem:</p>
<pre><code>redbol&gt;&gt; third [a b #[none]]
== #[none]

redbol&gt;&gt; third [a b]
== #[none]
</code></pre>
<p>In a language that prides itself on letting you work with code structure, <em>this is the tip of the iceberg of the problems that null solves</em>, and you will find the distinction's utility across the board (obviously, in tools like COMPOSE).  It facilitates rigorous analysis and rearrangements...without needing to drop to C or write convoluted code:</p>
<pre><code>&gt;&gt; third [a b _]
== _

&gt;&gt; third [a b]
; null
</code></pre>
<p>Hence NULL and VOID have taken the place of blank ("none!") in many places.  <em>(See <a href="https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942">BLANK! 2022, Revisiting the Datatype</a> for a summary.)</em></p>
<p>But unlike the elements in a block, a branch that evaluates isn't required to be non-NULL or non-VOID.  Which leads us to the long running question of what to bend these branches to so they don't conflate with the branch-not-taken result.</p>
<h2>Chris has (rightly) expressed concern</h2>
<p>At times I've said that it's not that big a deal that branches can't evaluate to NULL and get distorted.  "You didn't have a NULL before, so why get so worked up about control constructs not returning it?"</p>
<p>But the now-pervasive nature of NULL means it can't be avoided.  So:</p>
<p><em>"How do you express branching code which wants to do some work but also produce NULL as an evaluative product?"</em></p>
<p>Conflation was not a problem, e.g. in Rebol2:</p>
<pre><code>rebol2&gt;&gt; exampler: func [x] [
     print "returning sample or none if not found"
     case [
         x = &lt;string&gt; [print "sample string" {hello}]
         x = &lt;integer&gt; [print "sample integer" 3]
         x = &lt;none&gt; [print "sample none" none]
     ]
  ]

rebol2&gt;&gt; exampler &lt;string&gt;
returning sample or none if not found
sample string
== "hello"

rebol2&gt;&gt; exampler &lt;blatz&gt;
returning sample or none if not found
== #[none]

rebol2&gt;&gt; exampler &lt;none&gt;
returning sample or none if not found
sample none
== #[none]
</code></pre>
<p>However NULL is now a basic currency of "soft failure".  As such it would not be uncommon to be in the situation where a branching decision process would want to intentionally return NULL as part of the work it does.</p>
<p>Without a mechanism to address this, unpleasant convolutions would be needed, for instance surrounding anything that wanted to tunnel a NULL with a CATCH and THROW'ing it:</p>
<pre><code>x: catch [
    throw switch 1 + 2 [
        1 [print "one" 1]
        2 [print "two", &lt;two&gt;]
        3 [print "three", throw null]
     ]
]
</code></pre>
<p>Definitely not good.  But regarding the pleasing-me-part, remember I am trying to avoid this situation:</p>
<pre><code>&gt;&gt; block [a b]

&gt;&gt; case [
     true [
          print "case branch"
          item: third block
     ]
   ] else [
     print "else branch"
   ]

case branch
else branch  ; ugh
</code></pre>
<p>I don't want the CASE branch to evaluate to NULL just because some expression in the branch was incidentally NULL.  That would mean the ELSE tied to the CASE runs even though the code for the branch ran.</p>
<h2>Enter Isotopes</h2>
<p>One thing a ~NULL~ WORD! isotope has in common with NULL is that neither can be put in blocks.  But they have been automatically "decaying" into regular NULL when stored into variables.</p>
<pre><code>&gt;&gt; ~null~
== ~null~  ; isotope

&gt;&gt; x: ~null~
== ~null~  ; isotope  &lt;-- note the overall expression is still an isotope

&gt;&gt; x
; null
</code></pre>
<p>The twist is that they are <em>different enough</em> from true NULL such that a THEN or an ELSE can consider them a situation where the branch did not run:</p>
<pre><code>&gt;&gt; if false [&lt;ignored&gt;]
; null

&gt;&gt; if true [null]
== ~null~  ; isotope

&gt;&gt; if true [null] else [print "This won't run"]
== ~null~  ; isotope
</code></pre>
<p>The reason functions like ELSE can "see" the isotope is that they don't take an ordinary parameter on their left.  They take a ^META argument.  These can see the distinction between a ~null~ isotope and a "true" NULL.</p>
<p><strong>I'd largely say this has been working well...certainly better than its conceptual predecessors.</strong>  It makes piping NULL out of branches trivially easy, when the fear of conflation is not a problem.</p>
<pre><code>&gt;&gt; x: switch 1 + 2 [
     1 [print "one" 1]
     2 [print "two", &lt;two&gt;]
     3 [print "three", null]
   ]
three
== ~null~

&gt;&gt; x
; null
</code></pre>
<p>The automatic decay in variable storage prevents you from needing an explicit operation to turn ~null~ isotopes into pure nulls:</p>
<pre><code>&gt;&gt; x: decay switch 1 + 2 [
     1 [print "one" 1]
     2 [print "two", &lt;two&gt;]
     3 [print "three", null]
   ]
three
; null
</code></pre>
<h1>But <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> Would Likely Want any <em>NORMAL</em> arg decay</h1>
<p>At the very moment I am writing this, ~null~ isotopes are like all other BAD-WORD! isotopes and not accepted as normal parameters.</p>
<p><strong>They <em>could</em> decay to pure NULL for all normal args.</strong>  But let me explain a bummer of what we lose in that bargain.</p>
<p>It takes away a safety idea I had with functions like MATCH.</p>
<pre><code>&gt;&gt; match [&lt;opt&gt; integer!] 3
== 3

&gt;&gt; match [&lt;opt&gt; integer!] "notaninteger"
; null

&gt;&gt; match [&lt;opt&gt; integer!] null
== ~null~  ; isotope
</code></pre>
<p>The idea was that it could say "yes, this matched" but if ~null~ isotopes were tested, they'd give an error:</p>
<pre><code>&gt;&gt; if (match [&lt;opt&gt; integer!] null) [print "Yes it matched!"]
** Error: IF does not accept ~null~ isotopes without a ^META condition
</code></pre>
<p>Were MATCH to have passed through a plain NULL it would have succeeded in the match but not run the branch.  So it's nice to get the warning on the isotope.</p>
<p><strong>Or it could just return a ~matched~ isotope</strong>.  But this loses the following nice isotopic property:</p>
<pre><code>&gt;&gt; x: match [&lt;opt&gt; integer!] null else [fail "NO MATCH"]
== ~null~  ; isotope

&gt;&gt; x
; null
</code></pre>
<p>In fact I instituted other decaying variants for ~blank~ and ~false~</p>
<pre><code>&gt;&gt; y: match [blank!] _ else [fail "NO MATCH!"]
== ~blank~  ; isotope

&gt;&gt; y
== _

&gt;&gt; z: match [logic!] 1 = 2 else [fail "NO MATCH!"]
== ~false~  ; isotope

&gt;&gt; z
== #[false]
</code></pre>
<h1>So What To Do About MATCH and its bretheren?</h1>
<p>Seems the options are:</p>
<ol>
<li>
<p><em>Don't worry about it.</em>  If you write <strong>match [logic!] 1 = 2</strong> you get back <strong>#[false]</strong> and should you write an expression like <strong>if (match [logic!] 1 = 2) [print "Match!]</strong> you get what you deserve.</p>
</li>
<li>
<p><em>Use a different isotope.</em>  Let's say that <strong><code>match [&lt;opt&gt;] null</code></strong> is simply <strong>~matched~ (isotope)</strong>.  It wouldn't have the decaying property, but would have the invalidness property.</p>
</li>
<li>
<p><em>Have a MATCH/FALSEY variant.</em>  Let plain <strong>match</strong> on a falsey thing trigger an error and if you write <strong>if match/falsey ...</strong> then you clearly do know what you're doing so it becomes like case (1).</p>
</li>
<li>
<p><em>Make all conditional arguments take ^META arguments for their conditions.</em>  This would put the responsibility for checking for isotopes on them, and they'd uniquely disallow them before UNMETA'ing them and then testing for truth/falsehood.</p>
</li>
</ol>
<p>Option (4) is too taxing...impacting not just the interface to IF but the implementation of CASE and any conditional construct.</p>
<p><strong>I think I like (3) because it punts the ball down the road a bit.</strong></p>
<p>But this might still not suit Chris.</p>
<h1>Should Non-Meta Arguments Decay Null isotopes?</h1>
<p>The "auto-decay" of ~null~ isotopes means no variable can ever hold a NULL isotope.  And there's also a rule that no <em>normal</em> parameter can ever be passed an isotope, only ^META parameters.</p>
<p>In the beginning, it seemed useful if normal arguments would automatically decay null isotopes:</p>
<pre><code>&gt;&gt; foo: func [x] [if null? x [print "Yup, it's null"]]

&gt;&gt; foo if true [null]
Yup it's null

&gt;&gt; metafoo: func [^x] [
    case [
        null? x [print "regular null"]
        x = '~null~ [print "null isotope"]
        true [print "something else"]
     ]
   ]

&gt;&gt; metafoo if false [null]
regular null

&gt;&gt; metafoo if true [null]
null isotope
</code></pre>
<p>There is a manual DECAY operator which could be used, but would not meet that wish:</p>
<pre><code>&gt;&gt; ~null~
== ~null~  ; isotope

&gt;&gt; decay ~null~
; null

&gt;&gt; ~blank~
== ~blank~  ; isotope

&gt;&gt; decay ~blank~
== _

&gt;&gt; ~false~
== ~false~  ; isotope

&gt;&gt; decay ~false~
== #[false]
</code></pre>
<h1>Should DECAY Conflation Be A Customization?</h1>
<p>Another avenue of satisfaction could be to say that you simply customize your environment with some definitions to make auto-decaying constructs:</p>
<pre><code>switch: chain [:switch | :decay]
case: chain [:case | :decay]
...

&gt;&gt; case [true [null]]
; null

&gt;&gt; case [false [10]]
; null
</code></pre>
<p>I don't like it, but if someone isn't going to use ELSE (or is willing to accept this very easily unintentional conflation if they do) it could be an option.</p>
<p><strong>I really do believe the ability to tell from outside the construct if a branch has been taken is an interesting property, which even those who think they won't use ELSE or THEN can leverage, especially when building constructs atop each other.</strong>  But this isn't something that can be appreciated without usage, or trying to write something like UPARSE generically in usermode.</p>
<h1>Should function RETURN decay by default?</h1>
<p>Continuing along these lines, this has to do with the pattern of:</p>
<pre><code>foo: func [x] [
    return switch x [
         1 [print "one", #one]
         2 [print "two", null]
         3 [print "three", &lt;three&gt;]
    ]
]

&gt;&gt; foo 1 + 2
two
== ???   ; should this be ~null~ isotope or just NULL
</code></pre>
<p>Also, should it matter whether there's a RETURN there or not?  Is this something the type spec should distinguish?</p>
<p>Right now there's a refinement called /ISOTOPE on RETURN which asks it not to decay.</p>
<p><strong>If all non-^META parameters decay by default, then it seems isotopic decay is the right default for RETURN even though it takes a ^META parameter and returns non-decaying isotopes.</strong></p>
<h2>As Always, A Lot To Think About</h2>
<p>Want to get this posted because it's preventing me from making new drafts (Discourse won't let you have multiple top-level post drafts in-flight for some reason).</p>
<p>Will keep mulling it all over.</p>
<p><em>"A designer knows he has achieved perfection not when there is nothing left to add, but when there is nothing left to take away."</em></p>
            <p><small>7 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/conflation-vs-safety-return-and-the-finer-points-of-null-isotopes/1799">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/conflation-vs-safety-return-and-the-finer-points-of-null-isotopes/1799</link>
          <pubDate>Thu, 07 Apr 2022 04:14:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1799</guid>
          <source url="https://forum.rebol.info/t/conflation-vs-safety-return-and-the-finer-points-of-null-isotopes/1799.rss">Conflation vs. Safety, RETURN and the Finer Points of ~null~ Isotopes</source>
        </item>
        <item>
          <title>Should END-able constructs all use ^META parameters?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>R3-Alpha and Rebol2 could only have functions that were "endable" if the argument they took was quoted.  This feature was added primarily for HELP, so that you could say either:</p>
<pre><code>&gt;&gt; help
; (would display generic HELP usage information)

&gt;&gt; help topic
; (would display help for the given topic)
</code></pre>
<p>It was a <em>very limited form of variadic-ness</em>...generally used only in console-oriented commands (HELP, LS).  You couldn't write a function that was evaluative, like:</p>
<pre><code>redbol&gt;&gt; printer 1 + 2
3

redbol&gt;&gt; printer
You called the PRINTER function with no arguments
    ; ^-- not possible to accomplish with an otherwise evaluative argument!
</code></pre>
<p>Being able to handle getting to the end of input was entwined with taking quoted arguments.</p>
<h2>Ren-C added <code>&lt;end&gt;</code>-able Evaluative Parameters</h2>
<p>To facilitate certain demos in Ren Garden, Ren-C could mark an ordinary parameter as being <code>&lt;end&gt;</code>-able.  This would mean that the argument would show up as being NULL if the end was reached before an argument was seen.</p>
<p>This was--however--ambiguous with if you actually passed an evaluative NULL.</p>
<pre><code>ren-c&gt;&gt; printer 1 + 2
3

ren-c&gt;&gt; printer
You called the PRINTER function with no arguments

ren-c&gt;&gt; printer null  
You called the PRINTER function with no arguments  ; d'oh
</code></pre>
<p><strong>This kind of ambiguity wasn't new...the Redbol version had it.</strong>  The signal for quoted parameters that were endable-and-missing was to make the parameter an UNSET!.  Which meant they couldn't tell the difference between <strong>help #[unset!]</strong> and just-plain-help:</p>
<pre><code>red&gt;&gt; help #[unset!]
To use HELP, supply a word or value as its
argument:

    help insert
    help system
    help system/script

To view all words that...
</code></pre>
<p><strong>Interestingly enough, Ren-C has a solution for this with quoted parameters, because NULL cannot appear literally in source...so it can't be at the callsite.  Thus NULL can represent a missing quoted argument.</strong>  Which is neat.</p>
<h2>^META parameters can do <code>&lt;end&gt;</code> another way...</h2>
<p>A meta parameter is quoted, but will be a plain non-quoted BAD-WORD! if the callsite was passing an isotope.  With the <a href="https://forum.rebol.info/t/pure-vs-impure-invisibility-do-we-need-both/1782">recent design concept that suggests ~void~ isotopes are "pure" and equivalent to the full absence of a value</a>, you get evaluative endability without needing a separate feature.</p>
<p>So if our PRINTER took a ^META argument:</p>
<pre><code>&gt;&gt; printer 1 + 2
3
; (it actually received '3, quoted)

&gt;&gt; printer
You called the PRINTER function with no arguments
; (it actually received ~void~, not quoted)
</code></pre>
<p>The ambiguity is still there, though...</p>
<pre><code>&gt;&gt; printer ~void~
You called the PRINTER function with no arguments
; (again, it actually received ~void~, not quoted)
</code></pre>
<p>If you're following the details then I pointed out that supermeta parameters would be necessary to implement something that would know the difference in the suggested model.</p>
<p><strong>But at least you could differentiate NULL from an end.</strong>  The conflation of an invisible argument with the end doesn't seem that troubling to me, as the problem with HELP is fixed since it quotes and can tell when you say <strong>help ~void~</strong> vs. plain <strong>help</strong></p>
<h2>Killing off <code>&lt;end&gt;</code> as a core parameter flag would simplify things...</h2>
<ul>
<li>
<p>If a quoted parameter tolerates NULL as one of its legal types that's sufficient to say it is "endable"</p>
</li>
<li>
<p>If an evaluative parameter needs to detect endability, it could be your job to make it a ^META parameter and look for void, and unquote it to handle other results.</p>
</li>
</ul>
<p>The code and typeset flags for <code>&lt;end&gt;</code> could then be scrapped.</p>
<p>If someone really liked the NULL conflating version of endability they could write something to do it in usermode.</p>
<p><strong>You'd have to see the code to understand why I would think throwing away <strong><code>&lt;end&gt;</code></strong> is worth it.</strong> The way the type checking is done frames have to be filled first, which means if a function doesn't want an actual null but wants just ends to reflect as null... or wants an actual null but doesn't want ends reflected as null... hidden bits need to be grafted onto these nulls at the time of frame fulfillment to say whether it's an "endish" null or a regular null.  Various parts of the system then need to test a NULL for this invisible property.  <strong>^META parameters pull such invisible state into the light.</strong></p>
<p><strong>Basically take my word for it: meta is much cleaner, and offers a way to expose these distinctions to the user--so I think the odds are that <code>&lt;end&gt;</code> and its current mechanics need to die.</strong></p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-end-able-constructs-all-use-meta-parameters/1783">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-end-able-constructs-all-use-meta-parameters/1783</link>
          <pubDate>Fri, 21 Jan 2022 17:01:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1783</guid>
          <source url="https://forum.rebol.info/t/should-end-able-constructs-all-use-meta-parameters/1783.rss">Should END-able constructs all use ^META parameters?</source>
        </item>
        <item>
          <title>Pure vs. Impure Invisibility: Do We Need Both?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>"Invisibles" <a href="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405">were conceived 4 years ago</a>...long before BAD-WORD!s, isotopes, ^META parameters, etc.</p>
<p>The terminology needs a bit of an update, because I want to make a distinction between two different kinds:</p>
<ul>
<li>
<p><strong>IMPURE INVISIBLITY</strong> is when a special state (like a ~void~ isotope) is discarded in contexts where it's assumed to represent an invisible intent.</p>
<p>Remember that plain BAD-WORD!s (unevaluated) are normal values and can be in blocks.</p>
<pre><code>&gt;&gt; first [~void~]
== ~void~
</code></pre>
<p>But an evaluated ~void~ becomes an isotope, and operations like ALL are willing to tolerate that as a signal of invisible intent it should discard:</p>
<pre><code>&gt;&gt; ~void~
== ~void~  ; isotope

&gt;&gt; all [10 + 20, ~void~]
== 30
</code></pre>
<p>Unfortunately, this is extra work that ALL must do, since ~void~ isotopes are valid evaluative products.  Every construct that wants to integrate impure invisibility bears the burden.</p>
</li>
<li>
<p><strong>PURE INVISIBILITY</strong> is an evaluator feature when a function call can truly erase arbitrary code, such as to the right of a SET-WORD!:</p>
<pre><code>&gt;&gt; y: elide (1 + 2 print "Erased!" 3 + 4) 10 + 20
Erased!
== 30

&gt;&gt; y
== 30
</code></pre>
<p>This can only be done when a function like ELIDE specially says that it is not expected to return any result at all.  Otherwise it's not clear whether <strong>y:</strong> is supposed to get the <code>~void~</code> isotope or something after it.</p>
<p>(Over time I embraced the odd idea that just saying RETURN and not giving it an argument would be the way of being purely invisible...which has the interesting property that <strong><code>(return some-other-function ...)</code></strong> can actually chain cases where the other function is sometimes purely invisible and sometimes not!  This insight arose because of the frustrating fact that C/C++ cannot do such chains... if you say <strong><code>return some_other_function(...);</code></strong> and then change the other function from returning <code>int</code> to <code>void</code>, it will complain that you cannot use <code>return</code> with an argument inside of void functions...even if that function itself returns void.)</p>
</li>
</ul>
<h2>Why Not Make "Impure" Invisibility Act "Pure" ("Semipure?")</h2>
<p>The existence of the ^META types and operators raises an interesting theoretical option...that a ~void~ isotope could be treated as pure by the evaluator, and it's your responsibility to use meta operations if you wanted to see it:</p>
<pre><code>&gt;&gt; 1 + 2 ~void~
== 1 + 2

&gt;&gt; x: ~void~ 1 + 2
== 3

&gt;&gt; x
== 3

&gt;&gt; y: ^ ~void~ 1 + 2
== 3

&gt;&gt; y
== ~void~
    ; ^-- not an isotope
</code></pre>
<p>Pondering the potential implications of this form of thinking, it would mean there wouldn't be a form of invisibility that could beat a ^META operation:</p>
<pre><code>&gt;&gt; z: ^ comment ["hi"] ~something~
== ~something~  ; isotope

&gt;&gt; z
== ~void~
   ; ^-- the COMMENT was seen by the ^META, instead of bypassed
   ; (today COMMENT's status as a purely invisible construct means you
   ; would get Z as a non-isotope ~something~)
</code></pre>
<p><strong>Note that since parameters to functions are allowed to be meta if they need to be, changing a parameter from normal to meta would break commenting constructs.</strong>  This is not too surprising, as if you have <code>my-function comment "hi" 1 + 2</code> and change MY-FUNCTION's argument to be quoted instead of evaluated, that's another kind of parameter change that would break the commenting feature.</p>
<p>Meta parameters should be used very sparingly--far more sparingly than quoted parameters--so this may not be a problem.  I notice that a function like RETURN (which takes its argument meta so it can return isotopes) could still chain an invisible function, as it would receive ~void~ as a measure of what an isotope was.</p>
<h2>If Truly Pure Invisibility Is Not Implemented, Would People Just Reinvent it with Variadics in a Less Efficient Way Than The Current Evaluator Internals Do It?</h2>
<p>Let's say someone writes:</p>
<pre><code>foo: func [] [return comment "hi" 1 + 2]
</code></pre>
<p>Today this returns 3 due to comment's "purely invisible" status, RETURN takes its argument as a ^META parameter.  If we decide meta parameters are allowed to see the "semipure" void isotopes described above, then it would just be like you'd written:</p>
<pre><code>foo: func [] [return comment "hi"]
</code></pre>
<p><strong>That would make it seem like COMMENT is unreliable.</strong>  True, if you take a quoted argument you expect COMMENT to break in such cases as well...but meta parameters are evaluative and so it's a bit different.</p>
<p>Perhaps it should be just the <strong>^</strong> operator at the callsite that has the special vision, and meta parameters are evaluated and discard the void isotopes.  This would mean you only have to learn the rule that <strong>^ comment "hi"</strong> breaks the invisibility.</p>
<p><em>(Here we wind up with <strong>^</strong> either being a built-in thing the user has no way to write themselves, or invent a "supermeta" parameter flag to say "I can see void isotopes, too".)</em></p>
<h2>Either way, "Impure Invisibility" Is MUCH Easier To Work With</h2>
<p>The easy meta-transformations between ~void~ isotopes and plain ~void~ BAD-WORD! allow you to work with an invisible function gracefully...even when you don't know if it's invisible or not.</p>
<p>Early problems cropped up with pure invisible COMMENT like this:</p>
<pre><code>&gt;&gt; f: make frame! :comment
&gt;&gt; f.discarded: "Ignore Me"

&gt;&gt; x: do f   y: 1 + 2
== 3

&gt;&gt; x
== 3  ; this could seem surprising, but maybe not?
</code></pre>
<p>But the new world does have at least <em>an</em> answer, meta your result and you can test for void cases and handle them as you wish.</p>
<pre><code>&gt;&gt; x: ^ do f  y: 1 + 2
== 3

&gt;&gt; x
== ~void~

; alternately could have said `[^x]: do f  y: 1 + 2`
</code></pre>
<p>Yet it's still uncomfortable to imagine that an operation like DO could vanish, which is why DO tried to use void isotopes as a proxy for its return value.  A ~void~ isotope could then be semantically interpreted or converted to pure invisibility on an as-needed basis.</p>
<h2>"If You Don't Know What You're Doing, Then Do It Meta"</h2>
<p>My urge to build safety into the system is driven by wanting to enable people to write generic code.</p>
<p>...but... trying to protect people from <strong><code>do f</code></strong> from vanishing when <strong><code>f</code></strong> is a FRAME! for the COMMENT function may be misguided.  That protection could be breaking the very cool trick they are trying to perform.</p>
<p>And there's a real complexity cost to having a distinction between pure and impure invisibility.  If you allow that distinction then impure invisibility has a meta form (a plain ~void~ BAD-WORD!) while pure invisibility doesn't have one.  The powerful tool of META therefore offers no answers for a purely invisible function.</p>
<p>Maybe things like DO should have a switch to say <strong>do/vanishable</strong> and that's the right protection, otherwise they error if they could vanish.  Same with <strong>unmeta</strong>?</p>
<p>Or maybe there's a better finesse, to say that the evaluator has some generalized protection which notices when you might have meant for an invisible result to be used, and there's generic mitigation for such cases.  Like with <strong><code>x: do f  y: 1 + 2</code></strong>, if it notices the potential for misunderstanding you can say <strong><code>x: vanishable do f y: 1 + 2</code></strong>...and you'd be provoked to decide if you wanted to use VANISHABLE or ^ based on what you were actually trying to accomplish.</p>
<p><em>That actually sounds like a really clever mitigation, if a word or symbol were picked for it!</em></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/pure-vs-impure-invisibility-do-we-need-both/1782">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/pure-vs-impure-invisibility-do-we-need-both/1782</link>
          <pubDate>Fri, 21 Jan 2022 09:19:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1782</guid>
          <source url="https://forum.rebol.info/t/pure-vs-impure-invisibility-do-we-need-both/1782.rss">Pure vs. Impure Invisibility: Do We Need Both?</source>
        </item>
        <item>
          <title>DEFAULT with PATH!...What Does It *Mean*?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>The ability to have random side-effects in paths creates all kinds of nasty potentials.</p>
<p>That is why I made a way to say you only allow paths to contain evaluations if you also ask for an "invariant" representation of the path to be returned...that you could use in place of a path for further assignments.</p>
<pre><code>&gt;&gt; var: 'x

&gt;&gt; path: 'obj/(print "side effect" var)

&gt;&gt; set path 30
** Error: PATH contains GROUP!s, must request /STEPS output (can use #)

&gt;&gt; [value steps]: set path 30
side effect
== 30

&gt;&gt; steps
== @[obj x]
</code></pre>
<p>You can then use STEPS instead of the path.  e.g. <strong>set @[obj x]</strong> will act like <strong>set 'obj/x</strong>.  (The reason a BLOCK! is used is because not all datatypes would be legal in paths...a GROUP! could evaluate to anything, like an OBJECT!...which is a perfectly valid thing to set in a MAP! for instance.)</p>
<h2>This "Invariant" Form Was Intended For Things Like DEFAULT</h2>
<p>The concept was that even if you have evaluations on the left hand side, you will be able to capture where it got the value or absence-of-value from...and then in the event you need to write it back because a default is necessary, you don't have to run the evaluation again:</p>
<pre><code>&gt;&gt; n: 5

&gt;&gt; data.(n: n + 1): default [10]
</code></pre>
<p>Internally, DEFAULT can make a GET request of <strong>data.(n: n + 1)</strong> and get back STEPS with a fixed value for N, like <strong><code>@[data 6]</code></strong>.  If it discovers that the value is set to blank and needs defaulting, it can then use the steps instead of the path as the basis for the SET...so N is not changed twice.</p>
<h2>But Other Things Can Change...</h2>
<p>All kinds of changes can happen between the GET and the SET in DEFAULT.  What about this?</p>
<pre><code>&gt;&gt; data.(n: n + 1): default [data: ~gone~, 10]
</code></pre>
<p>We've prevented running imperative code and getting side effects from the path...but the side effects can come from other places.  <strong>Anything you do between the GET and the SET can make the "invariant" steps not so invariant.</strong></p>
<p>Let's say DATA was a BLOCK! at the outset.  Should the <strong><code>@[...]</code></strong> steps have actually stored a reference to the block instead of the WORD! data, so that changes to the variable couldn't redirect the invariant reference?</p>
<p>That doesn't work for immediate types.  Let's say you have:</p>
<pre><code>&gt;&gt; time: 4:00

&gt;&gt; path: 'time.(if true ['hour])

&gt;&gt; [# steps]: set path 12
== 12

&gt;&gt; steps
== @[4:00 hour]
</code></pre>
<p>Now you can't use that steps to go back and change the original time, because 4:00 is an immediate value.  You need to get at the object the time lives in.  You'd wind up with a 3-element steps in that case:</p>
<pre><code>&gt;&gt; steps
== @[make object! [...] time hour]
</code></pre>
<h2>If Nothing Is Going To Be Perfect... Should We Shortcut It?</h2>
<p>Let's say you have a path like:</p>
<pre><code>obj1.obj2.(if true [obj3]).obj4.date.time
</code></pre>
<p>We could say that the "steps" for this path are:</p>
<pre><code>@[obj1 obj2 obj3 obj4 date time]
</code></pre>
<p>But is that empirically more desirable than just noticing when we cross the line from non-immediate values into immediate values, and preserving only as much as we need?</p>
<pre><code>@[(make object! [...this is obj4...]) date time]
</code></pre>
<p>That's enough to write back to obj4...but it is fully disconnected from the path that was initially being represented.  <strong>But which is more suitable for the intent of something like DEFAULT?</strong></p>
<h2>My Head Hurts <img src="https://forum.rebol.info/images/emoji/twitter/face_with_head_bandage.png?v=9" title=":face_with_head_bandage:" class="emoji" alt=":face_with_head_bandage:">
</h2>
<p>...and it's not because of a booster shot.  It's because this is crazy, and way past the point of being fun.</p>
<p>What started out as a nice idea for taming GROUP!s in PATH!s becomes a real headache.</p>
<p><strong>So I'm going to leave well enough alone, and say that this does only that.</strong>  If you want to prune a path to get better invariants, that's on you:</p>
<p>For example:</p>
<pre><code>(obj1.obj2.obj3.obj4).date.time: default [...]
</code></pre>
<p>When you do this, then when DEFAULT asks for steps it will get 4 items in the block:</p>
<pre><code>&gt;&gt; steps
== @[(make object! [...]) date time]
</code></pre>
<p>It has latched onto the object, and so you can say inside the body of the defaulting code things like <strong><code>obj1: null</code></strong> or <strong>obj1.obj2.obj3: []</strong> and the assignment will apply to what it was looking at, because those names aren't in the steps.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/default-with-path-what-does-it-mean/1770">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/default-with-path-what-does-it-mean/1770</link>
          <pubDate>Sat, 11 Dec 2021 23:58:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1770</guid>
          <source url="https://forum.rebol.info/t/default-with-path-what-does-it-mean/1770.rss">DEFAULT with PATH!...What Does It *Mean*?</source>
        </item>
        <item>
          <title>The Pathing and Picking Predicament Pans Out</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <h2>TL;DR</h2>
<p>I'm changing path dispatch to be fundamentally recursive, and via a unified action dispatcher called <strong><code>PICK-POKE*</code></strong>.  As fate would have it, this takes a longstanding annoying edge case in how R3-Alpha methodized path dispatch for GOB!...and makes that "the answer" for how all path dispatch is done.  Additionally:</p>
<ul>
<li>
<p>It employs FRAME! reuse for native dispatch, which allows a memory use profile similar to the the "PVS" (Path Value State?) structure from R3-Alpha...even though it's making recursive evaluator calls.</p>
</li>
<li>
<p>This makes path dispatch just ordinary function dispatch, which means pathing doesn't need special accommodation in stackless.</p>
<ul>
<li>Sidenote: Path dispatch and PARSE were two extremely troublesome areas in the stackless conversion.  Both are being addressed by pushing more and more "custom" recursive C code to do their recursions by means of the interpreter's evaluator loop.</li>
</ul>
</li>
<li>
<p>It should mean that user-defined data types--or even in the near term perhaps your own OBJECT!s--could customize pathing if they wanted to <em>(though we may limit customization to <strong><code>/</code></strong> access in order to provide terra firma for accessing the object)</em></p>
</li>
</ul>
<h2>Preface: No One Has Done This Right (Until Now)</h2>
<p>Before we get carried away and give GOB! too much credit...  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>Redbols try to be bit fiddly and pack things into immediate cell values.  But if you're going to be that fiddly, you have to remember that "updating a value" really means "updating the container the value lives in".</p>
<p>Random example from Red and Rebol2:</p>
<pre><code>red&gt;&gt; b: [x 12-Dec-2021/10:00 y]
== [x 12-Dec-2021/10:00:00 y]

red&gt;&gt; b/2/time/hour
== 10

red&gt;&gt; b/2/time/hour: 20
== 20

red&gt;&gt; b
== [x 12-Dec-2021/10:00:00 y]  ; still 10:00, not 20:00
</code></pre>
<p><em>(R3-Alpha is worse, giving an error and corrupting the time.)</em></p>
<p>The reason this happens is because DATE! fits in a cell with the TIME! packed into it.  If you ask for a date's /TIME then you get a synthesized new cell to hold it.  But poking back into that synthesized cell won't change the original date.</p>
<p>Hence every SET-PATH! or POKE has to offer a kind of backflow in the chain of poking, in case any of the forward writes require bit updates backwards.  Frame reuse allows that to be made somewhat efficient with one cell's worth of stack, while PICK can use a <a href="https://stackoverflow.com/questions/22037261/what-does-sibling-calls-mean">"sibling tail call"</a>.</p>
<p>The Ren-C I'm working on takes care of the above example, and should generalize to others!</p>
<h2>Now, Explanation.  Background:</h2>
<p>Path Dispatch--or <strong>"PD"</strong> as R3-Alpha called it--was a concept fraught with issues.</p>
<p>On the surface it seems like a simple chain...it's broken into steps where each one produces a value that is picked by the next step:</p>
<pre><code>&gt;&gt; outer: make object! [inner: make object! [block: [a b c]]]

&gt;&gt; outer/inner/block/2  ; expressed as a path
== b

&gt;&gt; pick (pick (pick outer 'inner) 'block) 2  ; expanded as picks
== b

; Note: Historical Rebol required a mix of SELECT and PICK, Ren-C unifies it
</code></pre>
<p>How "hard" is that?  Well, it's not <em>that</em> hard, though it could be very wasteful.</p>
<p>Imagine the FFI with <strong>some-struct.million-int-array.1</strong>.  If that's an FFI interface to a struct with a million C int in it, do you have to generate a BLOCK! of a million INTEGER! just to pick the first one?  That's what the naive translation of pathing to step-by-step PICK calls would do.</p>
<p>Even without talking about efficiency, we can talk about semantics.  <strong>PICK at least works out semantically for pathing, but POKE does not.</strong>  Try this:</p>
<pre><code>&gt;&gt; outer/inner/block: [i am a new block]
== [i am a new block]

&gt;&gt; poke (pick (pick outer 'inner) 'block) [i am a new block]
** Error, wait a second...
</code></pre>
<p>That second formulation is <em>not</em> equivalent...because the PICK gave back a plain old block.  So it saw:</p>
<pre><code>&gt;&gt; poke [a b c] [i am a new block]
</code></pre>
<p><strong>This faces the problem that Rebol lacks "Reference" types.</strong> POKE wanted a place to put the new block...effectively the <em>address</em> of the block value in the inner object.  But it just got back the <em>value</em> of the block in the inner object.</p>
<h2>Could Rebol Have A Reference Type?</h2>
<p>Hypothetical code:</p>
<pre><code>&gt;&gt; obj: make object! [field: "I am a field"]

&gt;&gt; ref: &amp;obj.field
== &amp;"I am a field"

&gt;&gt; ref: "Field is replaced!"

&gt;&gt; obj
== make object! [field: "Field is replaced!"]
</code></pre>
<p>In such a world, changing REF didn't change the string... <em>it changed a field in the object the string lived in</em>.</p>
<p>This is the kind of mechanic that pathing would need if it were to be extensible and truly generic. What each step in the path offered up to the next would have to be a means of writing back to the field if it wanted to.</p>
<p>That sounds like a nightmare...but it wouldn't even solve the problem if it could be done, because...</p>
<h2>...Subaddressing Makes It Worse!</h2>
<p>Some of the more confusing pats of path dispatch dealt with the fact that path steps might be producing something that didn't reference a full value at all...but some optimized bit pattern.</p>
<pre><code>&gt;&gt; obj: make object! [gob: make gob! [x: 10 y: 20]]

&gt;&gt; obj.gob.size.x: 304
== 304
</code></pre>
<p>What's so weird about that?  Well, GOB! stores its bits compactly, so there is no INTEGER! cell for the X, and no PAIR! cell for the size.</p>
<p>This is all easy enough on the PICK side... you ask the GOB! what its size is, and it tells you 10x20 as a new PAIR! it makes out of thin air.  Then you ask that pair what its X is and it tells you 10.</p>
<p>But on the POKE side, <em>even if you had the address mechanic</em>, there's no address of a value that the GOB! can give for that PAIR! to let you write back to it.</p>
<h2>GOB! in R3-Alpha Actually Had The Right Idea...Sort Of</h2>
<p>With path dispatchers like R3-Alpha's <strong><a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/t-block.c#L530">PD_Block()</a></strong> that it has a "picker" (<strong>pvs-&gt;select</strong>) which it is applying to the value that's a BLOCK! or GROUP! (<strong>pvs-&gt;out</strong>).  It trusts that the "path engine" has pre-evaluated any code in parentheses if necessary to get pvs-&gt;select.</p>
<p>Then it has the detail that if <strong>pvs-&gt;setval</strong> is not null, it needs to know it's a SET-PATH!.  This is also something the path engine works out...based on whether the end of the path is reached.  Really this looks like it moves one step a time.</p>
<p>So in my early dealings with path dispatch, I'd try to formalize this a bit better...putting horse-blinders on the PD_Xxx() function by giving it narrow parameterization, and removing the PVS as a parameter.  Yet I tripped over "bad" path dispatchers like PD_Gob(), which <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/t-gob.c#L676">called Next_Path() in their implementations</a>.</p>
<p>But the "bad" handling of GOB! was closer to the right general answer:</p>
<ul>
<li>
<p>Some portion of the path is consumed by each step in the SET-PATH!</p>
</li>
<li>
<p>It then it hands the remainder off to what it can't handle via a recursive call...</p>
<ul>
<li>The return value of this recursive call is either NULL or an updated image of the cell bits that must be updated in the container to reflect an immediate type.</li>
</ul>
</li>
</ul>
<h2>Walking Through The Process With GOB!</h2>
<p>Imagine you write:</p>
<pre><code>&gt;&gt; obj/gob/size/x: 304
</code></pre>
<p>It might happen like this:</p>
<ul>
<li>
<p>POKE asks OBJECT! <em>"Hey, I want to write gob/size/x.  How much of that can you do?"</em></p>
</li>
<li>
<p>OBJECT! says <em>"I will update myself if GOB! can tell me the answer to what it wants to be if size/x is written."</em></p>
</li>
<li>
<p>GOB! says <em>"I consumed the entirety of size/x: 304 and there were no changes to my bit pattern that my caller need be aware about."</em> (because gobs are allocated in handles, REBGOB*, so the modification of the size bits is not the concern of the reference in object as it still points to that same REBGOB*)</p>
</li>
<li>
<p>OBJECT! says <em>"Okay fine then."</em></p>
</li>
</ul>
<p>Notice that <strong>We never got PAIR! involved in the dispatch, even though the answer to gob/size is a PAIR!.</strong></p>
<p>That's not the only way to do it.  There's actually three ways this could work:</p>
<ol>
<li>
<p>(the above way) Don't just consume one of the steps, but go ahead and do two--e.g. take control of what <code>size.x</code> means and don't synthesize a PAIR! at all.</p>
</li>
<li>
<p>Synthesize a PAIR! and allow it to do whatever modification it wishes, but ignore its <code>nullptr</code> return status and pack the full pair value down to the low-level bits in the GOB!</p>
</li>
<li>
<p>Drop this micro-optimization and store a PAIR! cell in the GOB! structure.</p>
</li>
</ol>
<p>I actually think <span class="hashtag">#3</span> is the best answer, but, the point here is to study being general.</p>
<h2>The New Formulation Is About As Good As This Can Get</h2>
<p>It's interesting to be able to do this kind of optimization, and things like the FFI need it.  I mentioned <strong>some-struct.million-int-array.1</strong>.  Naive approaches will be too inefficient to handle this.</p>
<p>So path processing needs this nuance.  And we'd like an answer that doesn't make the author of STRUCT! have to worry about <strong>some-struct.million-int-array.(1 + 2)</strong>, so the processing of GROUP!s has to be done by the pathing.</p>
<p>Long story long: this is a PITA and I'm making some headway on framing the problem.  Things seem in better shape, as the oddly-shaped PD_Xxx are eliminated.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-pathing-and-picking-predicament-pans-out/1704">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-pathing-and-picking-predicament-pans-out/1704</link>
          <pubDate>Sun, 05 Sep 2021 08:43:19 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1704</guid>
          <source url="https://forum.rebol.info/t/the-pathing-and-picking-predicament-pans-out/1704.rss">The Pathing and Picking Predicament Pans Out</source>
        </item>
        <item>
          <title>REDUCE meets DENULL and the BAD-WORD! ~NULL~</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>The question of what to do when REDUCE encounters NULL has been a thorn ever since its introduction.  By definition you can't put NULL in a BLOCK!.</p>
<p>So you've seemingly got three choices:</p>
<ul>
<li>
<p>Vaporize the expression slot: <strong>reduce [1 null 2]</strong> =&gt; <strong>[1 2]</strong></p>
</li>
<li>
<p>Raise an error: <strong>reduce [1 null 2]</strong> =&gt; <strong><code>** Error: NULLs illegal in REDUCE</code></strong></p>
</li>
<li>
<p>Put some value there: <strong>reduce [1 null 2]</strong> =&gt; <strong>[1 ~null~ 2]</strong> or <strong>[1 _ 2]</strong></p>
</li>
</ul>
<p>I'm exaggerating to call these the "only options".  When you throw in refinements or pass in functions, you've got more options.  I've also made the REDUCE-EACH function, which lets you get involved with the result of each expression evaluation...sky's the limit:</p>
<pre><code>collect [
    reduce-each x [1 + 2 null 10 + 20] [
        if integer? x [keep quote :[&lt;int&gt; x]]
        if null? x [keep &lt;null&gt;]
    ]
]
== [[&lt;int&gt; 3] &lt;null&gt; [&lt;int&gt; 30]]
</code></pre>
<p>But with no parameterization I think there are only three reasonable choices: You vaporize, you error, or you put <strong>~null~</strong> or <strong>_</strong> there.</p>
<h2>Several People Have Favored Vaporization</h2>
<p>I myself have <em>usually</em> usually been on the side of erroring.</p>
<p>But the place that vaporization feels most convenient is when you're doing something like an append of data to a block, and you want to cut out some items.</p>
<pre><code>&gt;&gt; use-preface: false

&gt;&gt; append data reduce [if use-preface [&lt;preface&gt;] 1 + 2 "Hello"]
== [1 + 2 "Hello"]
</code></pre>
<p>The key to why vaporization works here is that <strong>you're dealing with a situation that has no positional expectations</strong>.</p>
<p>But I don't generally use REDUCE in these cases.  It can't splice (which I usually want to be able to do).</p>
<h2>We've Now Tried Vaporization and... <em>I Don't Think I Like It</em>
</h2>
<p>Let's look at situations like the use of GET-BLOCK! (I believe must be a synonym for REDUCE) to do ranges in UPARSE.</p>
<pre><code>; Set min to null so we can easily test if it has been set or not, but is
; still "a little ornery".  Must set it before running the rule.
;
min: null

; Set max to blank so it can opt out by default if we have no max
;
max: _

&lt;&lt;BUNCH OF CODE THAT MUST SET MIN AND MAY OR MAY NOT SET MAX&gt;&gt;

uparse data [repeat (:[min max]) rule]
</code></pre>
<p>The reason I didn't say <strong><code>(min: ~)</code></strong> or <strong><code>(min: ~overwrite-me~)</code></strong> is because I wanted min to be "middlingly ornery".  So I wanted to use it in expressions like <strong>any [min, ...]</strong> but I didn't want it to be able to be used as an opt out intention.  This is the weird zone that NULL occupies and we're making the most of it.</p>
<p>Under this understanding...I'd be displeased if that turned into <strong><code>[repeat ([_]) rule]</code></strong>, because I'd have liked to have been told about the issue.</p>
<p><strong>Remember that it was not too long ago that the non-valued state would error on the variable fetch itself.</strong>  We've made a lot of concessions to get to the point where it is falsey and can be retrieved without a problem.</p>
<p>So long as the answer isn't vaporization, it would have been okay.  Making <strong><code>[repeat ([~null~ _]) rule]</code></strong> would have been poisonous enough to cause a problem.  And raising an error would have been fine too.</p>
<h2>A Compromise: DENULL... where DENULL NULL vanishes?</h2>
<p>If you really want a REDUCE to make nulls go away instead of becoming a ~null~ BAD-WORD! or raising an error, how about this?</p>
<pre><code>&gt;&gt; reduce [1 denull if true [&lt;x&gt;] 2]
== [1 &lt;x&gt; 2]

&gt;&gt; reduce [1 denull if false [&lt;x&gt;] 2]
== [1 2]

&gt;&gt; reduce [1 if false [&lt;x&gt;] 2]
== [1 ~null~ 2]
</code></pre>
<p>This gives the tool for removing things conditionally, while keeping the REDUCE number of expressions consistent.</p>
<p>Like I say... COMPOSE is my preferred tool for when you want splicing... not just letting you go from 1 expression to 0 values, but from 1 expression to N values.</p>
<h2>We Can Also Make a REDUCE* Which Drops NULLs</h2>
<p>...and I've talked about predicates and all the other possibilities.  But I think vaporization just isn't the default I want.  DENULL seems a good way to get past the problem.</p>
<p>The middle ground of <strong>~null~</strong> -- even though it's not an isotope -- gives a compromise that I think is more discoverable when it goes wrong than vaporization.</p>
<p>It seems worth trying out.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/reduce-meets-denull-and-the-bad-word-null/1665">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/reduce-meets-denull-and-the-bad-word-null/1665</link>
          <pubDate>Mon, 16 Aug 2021 02:13:44 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1665</guid>
          <source url="https://forum.rebol.info/t/reduce-meets-denull-and-the-bad-word-null/1665.rss">REDUCE meets DENULL and the BAD-WORD! ~NULL~</source>
        </item>
        <item>
          <title>Understanding FRAME!s and Phases</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>Good news: <a href="https://github.com/metaeducation/ren-c/issues/393"><strong>an old issue is (seemingly) mostly addressed!</strong></a></p>
<p>Among the various implications of this design improvement, you can AUGMENT a function with new fields that share the name of either locals or specialized values.  The only names you cannot use in extending a function are those that are public parameters on the interface!</p>
<pre><code>&gt;&gt; ap10: specialize :append [value: 10]
&gt;&gt; ap10 [a b c]
== [a b c 10]

&gt;&gt; wow!: adapt (augment :ap10 [/value [integer!]]) [insert series value]
&gt;&gt; wow!/value [a b c] 20
== [20 a b c 10]
</code></pre>
<p>So what's going on here is that underneath the hood, the <em>single</em> FRAME! for this function call has <em>two</em> slots with the label <strong><code>value</code></strong>.  But they're never in effect and visible at the same time.  This is great news for composability of functions.</p>
<p>I'm going to try to explain here a little bit of how this works.</p>
<h2>Every Function Is Defined By an "Exemplar" FRAME!</h2>
<p>Some time ago I penned the prophetic post: <a href="https://forum.rebol.info/t/seeing-all-action-s-as-variadic-frame-makers/1002">"Seeing all ACTION!s as Variadic FRAME! Makers"</a>.  This set the stage for what ultimately became an implementation mechanism where the interface to all ACTION!s are defined by a FRAME!.</p>
<p>So if you write something like:</p>
<pre><code>foo: func [return: [] x [tag! text!] y [integer!] &lt;local&gt; z] [
    print ["internal foo view:" mold binding of 'x]
]
</code></pre>
<p>Inside of FOO there is a FRAME! that lays out a map of the parameters and locals.  This is called the "exemplar".  We can get direct access to that frame:</p>
<pre><code>&gt;&gt; exemplar of :foo
== make frame! [
    return: make typeset! []
    x: make typeset! [#[datatype! text!] #[datatype! tag!]]
    y: make typeset! [#[datatype! integer!]]
    z: ~unset~
]
</code></pre>
<p>This isn't an "ordinary" frame for the function.  The fields don't hold legitimate values for a function invocation...they are holding typesets.  Except for Z which is a local, so it holds the value that it will have when a frame is made.  <em>(more on that in a second)</em></p>
<p>So now let's try making an ordinary frame for the function:</p>
<pre><code>&gt;&gt; f: make frame! :foo
== make frame! [
    x: ~unset~
    y: ~unset~
]
</code></pre>
<p>Okay, that's neat.  It doesn't <em>seem</em> to have the RETURN or Z fields because we aren't supposed to be setting those.  They are there--the memory is part of the frame, and part of what will actually be backing the variables when you DO the function.  But they are hidden in this "phaseless" view.</p>
<p>I put code inside the function to print out its internal view of that same frame.  Let's try running and see what it says:</p>
<pre><code>&gt;&gt; f.x: "Hello"

&gt;&gt; f.y: 1020

&gt;&gt; do f
internal foo view: make frame! [
    return: '#[action! [^value /isotope]]
    x: "Hello"
    y: 1020
    z: ~unset~
]
</code></pre>
<p>Hey, look at that.  <strong>When we see the frame from <em>inside</em> the function, it has access to RETURN and Z.</strong>  How does it know to hide the fields on the outside, but give access to them on the inside?</p>
<p>The answer is that each FRAME! value can optionally hold a "phase".  A phase is itself just an ACTION!--it's which step of the composition you are running.  The phase informs which of the fields are supposed to be visible.</p>
<h2>Now, Let's SPECIALIZE It...</h2>
<p>Let's make a new function BAR which fixes the value of Y.</p>
<pre><code>spfoo: specialize :foo [y: 304]
</code></pre>
<p>And now let's look at what its internal "fake" exemplar FRAME! looks like:</p>
<pre><code>&gt;&gt; exemplar of :spfoo
== make frame! [
    return: make typeset! []
    x: make typeset! [#[datatype! text!] #[datatype! tag!]]
    y: 304
    z: ~unset~
]
</code></pre>
<p>Something you'll notice is that <em>the type information for Y is now lost, and the slot where the type information would have been has been replaced by the specialized value</em>.  That's a nice little efficiency trick.</p>
<p>Now if we make a frame for SPFOO, the only thing it will let us set is X:</p>
<pre><code>&gt;&gt; f: make frame! :spfoo
== make frame! [
    x: ~unset~
]
</code></pre>
<h2>What if We Were to ADAPT the Specialization?</h2>
<p>So this raises an interesting question about the "inside" and "outside" view of things.</p>
<p>At an interface level, I would argue that it should not usually be possible to tell the difference between SPFOO and any other function that takes a single parameter X.</p>
<p>So what happens if we ADAPT the SPFOO function and get access to the frame on the inside?</p>
<pre><code>adspfoo: adapt :spfoo [
    print ["inside adaptation:" mold binding of 'x]
]

&gt;&gt; adspfoo "What happens?"
inside adaptation: make frame! [
    x: "What happens?"
]
internal foo view: make frame! [
    return: '#[action! [^value /isotope]]
    x: "What happens?"
    y: 304
    z: ~unset~
]
</code></pre>
<p>Ta-da.  ADAPT only saw a function with an X parameter, and none of the other details are exposed to it.  Its view of the frame only sees X.  <em>But it's all the same frame...</em> memory is being reused, just the access to it is controlled.</p>
<p><strong>Pretty slick, huh?</strong>  Anyway, I'm sure there are bugs but the groundwork is there.  Please experiment and let me know if anything seems to be counterintuitive.</p>
<p><em>(There's a lot of thinking that needs to be done about how RETURN plays into this...it's a weird case that needs study.  Being inside the ADAPT and not having access to the RETURN is irritating, but it may just be necessary to prevent that access and make you use an ENCLOSE if you might want to return.)</em></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/understanding-frame-s-and-phases/1645">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/understanding-frame-s-and-phases/1645</link>
          <pubDate>Wed, 04 Aug 2021 17:32:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1645</guid>
          <source url="https://forum.rebol.info/t/understanding-frame-s-and-phases/1645.rss">Understanding FRAME!s and Phases</source>
        </item>
        <item>
          <title>Thinking We Might Should Nix PROTECT/HIDE For Now</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>R3-Alpha had an interesting feature, <a href="http://www.rebol.net/r3blogs/0189.html">which let you "hide" fields in contexts</a>.</p>
<p>It was actually something that drew me in to the language in the beginning as "oh, that's cool".</p>
<p>So it has stuck around in some form, and simple examples do still seem to work:</p>
<pre><code>&gt;&gt; obj: make object! [x: 10 y: 20]
== make object! [
    x: 10
    y: 20
]

&gt;&gt; protect/hide 'obj/y
== obj/y

&gt;&gt; obj
== make object! [
    x: 10
]
</code></pre>
<p><strong>But this is a very complex feature to honor systemically.</strong>  Doing it poorly is easy.  Doing it pervasively and correctly is rather difficult.</p>
<p>In particular, what bothers me about this "user controlled hidden bit" is that I'm trying to get some system-level hidden mechanics working correctly.  And the interaction between things the system needs to hide and this "user can hide anything they want" is somewhat maddening, especially because I know how hard it is to do such a thing <em>right</em>.</p>
<p>It's an intriguing feature that seems to have been a bit of an off-the-cuff experiment.  I don't see it as mission-critical...and all it does is interfere with the hardening needed to solve the mission-critical problems related to contexts.</p>
<p>Not going to delete it immediately, but it's certainly in the crosshairs if it causes any more trouble with something I'm trying to fix.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/thinking-we-might-should-nix-protect-hide-for-now/1644">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/thinking-we-might-should-nix-protect-hide-for-now/1644</link>
          <pubDate>Tue, 03 Aug 2021 09:05:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1644</guid>
          <source url="https://forum.rebol.info/t/thinking-we-might-should-nix-protect-hide-for-now/1644.rss">Thinking We Might Should Nix PROTECT/HIDE For Now</source>
        </item>
        <item>
          <title>The Long-Awaited Death of /ONLY</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p><strong>As of July 2022, /ONLY is no longer a refinement available on APPEND, INSERT, CHANGE, FIND, SELECT, COMPOSE, or similar functions.</strong>  It only appears in the Redbol module <a href="https://forum.rebol.info/t/agree-to-disagree-points-places-i-see-both-sides/1862/3">through emulation</a>.</p>
<h2>"AS-IS" Semantics Are Default</h2>
<p>It's easy to sympathize with the historical Rebol idea of "splice blocks by default", if you only look at examples where the code is fully literal:</p>
<pre><code>append files [%foo.r %bar.r]
code: compose [... keep [sum: sum + x] ...]
</code></pre>
<p>But problems immediately strike when you start using variables that may-or-may-not-be blocks.  You can't rely on any invariants, and this leads to broken code:</p>
<pre><code>&gt;&gt; block: [#a {b} [c d e] %f]

&gt;&gt; pick block 3
== [c d e]

&gt;&gt; find block pick block 3
; null
</code></pre>
<p>Time and experience has proven that "as-is" semantics are the safest and clearest default:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c [d e]]
</code></pre>
<p>Ren-C offers a new tool for "spliced" semantics...which is to pass a BLOCK! isotope ("quoting level -1").  SPREAD is the first function offered which produces them:</p>
<pre><code>&gt;&gt; append [a b c] spread [d e]
== [a b c d e]
</code></pre>
<p>But there's nothing particularly special about SPREAD, and there will be many other options for defining functions that may-or-may-not return block isotopes...which have more parameterization and nuance.</p>
<h2>Making The Value Carry Splicing Intent Brings Systemic Good</h2>
<p>The benefits are everywhere, with safer defaults and clear choices...for instance in REPLACE:</p>
<pre><code>&gt;&gt; replace/all [[a b] a b a b] [a b] [c d e]
== [[c d e] a b a b] 

&gt;&gt; replace/all [[a b] a b a b] spread [a b] [c d e]
== [[a b] [c d e] [c d e]]

&gt;&gt; replace/all [[a b] a b a b] [a b] spread [c d e]
== [c d e a b a b]

&gt;&gt; replace/all [[a b] a b a b] spread [a b] spread [c d e]
== [[a b] c d e c d e]
</code></pre>
<p>Branching code can make decisions to splice-or-not-splice on a case by case basis:</p>
<pre><code>&gt;&gt; code: [&lt;splice&gt; [a b] &lt;no-splice&gt; [c d] &lt;no-splice&gt; 'x]

&gt;&gt; map-each [instruction item] code [
       switch instruction [
            &lt;splice&gt; [spread item]
            &lt;no-splice&gt; [item]
            fail ["Bad instruction:" instruction]
       ]
   ]
== [a b [c d] 'x]
</code></pre>
<p>And COMPOSE can have some slots that splice and others that do not, within the same operation:</p>
<pre><code>&gt;&gt; data: [a b]

&gt;&gt; compose [spliced (spread data) non-spliced (data)]
== [spliced a b non-spliced [a b]]
</code></pre>
<p>(COMPOSE is a case where not splicing by default is glaringly obvious as the right choice for a generic operation.)</p>
<h2>BLOCK! Isotopes Are Special ("unfriendly" <img src="https://forum.rebol.info/images/emoji/twitter/japanese_goblin.png?v=9" title=":japanese_goblin:" class="emoji" alt=":japanese_goblin:"> )</h2>
<p>Normal parameters cannot accept them.</p>
<pre><code>&gt;&gt; normal-function: func [value] [print ["Normal got:" mold value]]

&gt;&gt; normal-function spread [d e]
** Error: NORMAL-FUNCTION can't take a BLOCK! isotope as its VALUE argument
</code></pre>
<p>The way that you indicate you can take an isotope is using a ^META parameter.</p>
<p>But the convention with meta parameters is they will always be "one quote level higher" than the thing that they represent.</p>
<pre><code>&gt;&gt; meta-function: func [^value] [print ["Meta got:" mold value]]

&gt;&gt; meta-function [d e]
Meta got: '[d e]  ; one quote level above 0 for unquoted input

&gt;&gt; meta-function first [''[d e]]
Meta got: '''[d e]  ; three quote levels above 0 for double-quoted input

&gt;&gt; meta-function spread [d e]
Meta got: [d e]  ; no quotes for isotopic input
</code></pre>
<p>Using this detection mechanism, you can write your own routines that react specially to isotopes.</p>
<h2>Isotope Parameter Conventions Should Be Used <em>Sparingly</em>!</h2>
<p>Routines that do not intend to react to an isotope should not take them as parameters.</p>
<p>As a good example, REDUCE might seem like the kind of thing that could act on block isotopes:</p>
<pre><code>&gt;&gt; append [a b c] reduce spread [1 + 2 3 + 4]
== [a b c 3 7]
</code></pre>
<p>But we want to avoid this temptation, to stop the "spread" of isotopes to touching parts of the system that should not be concerned with them.  So exercise restraint here...and shift the burden on the calling code to reshape itself so that isotopes only exist at the points that are very close to the calls they affect:</p>
<pre><code>&gt;&gt; append [a b c] spread reduce [1 + 2 3 + 4]
== [a b c 3 7]
</code></pre>
<h2>Good Riddance /ONLY</h2>
<p>The elimination of /ONLY from the semantic model, and to have it not contaminate the user's heads, means that people can learn more generic tools that work in more contexts.</p>
<p>Its appearance in Ren-C will be limited to the Redbol compatibility module.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/the-long-awaited-death-of-only/1607">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-long-awaited-death-of-only/1607</link>
          <pubDate>Sat, 15 May 2021 09:48:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1607</guid>
          <source url="https://forum.rebol.info/t/the-long-awaited-death-of-only/1607.rss">The Long-Awaited Death of /ONLY</source>
        </item>
        <item>
          <title>Can The ^Meta Protocol Solve Unsetness?!?!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>Just had a flash <img src="https://forum.rebol.info/images/emoji/twitter/cloud_with_lightning.png?v=9" title=":cloud_with_lightning:" class="emoji" alt=":cloud_with_lightning:"> of inspiration, by thinking about a potential difference between these two things:</p>
<pre><code>x: '~unset~
y: ~unset~
</code></pre>
<p>The first is legal and puts a BAD-WORD! into the variable x.</p>
<p>Right now, the second is an error...because the evaluator doesn't like executing BAD-WORD!s.</p>
<p>But what if the second did not put a typical BAD-WORD! into y, but put it into a distinctly "unset" state?  And what if many contexts couldn't tell the difference...but ^-based detection could tell the difference?</p>
<pre><code>&gt;&gt; ^x
== '~unset~

&gt;&gt; ^y
== ~unset~
</code></pre>
<p>It's very much parallel to how ~void~ is shaping up as having a kind of dual nature.  Some functions are invisible, and some modes of calling those invisible functions give ~void~ when it needs a reified result.  Other functions are not invisible, but return ~void~ as a way of saying that they don't have a meaningful result.  When you flip into modes where you care which it is...you shift into a quoted domain, where the unquoted ~void~ is a special non-valued signal.  <em>Void isotopes, basically.</em></p>
<p>I'll have to turn this over in my head a few times, but on the surface of it... <em>this feels like the solution we've been waiting for</em>.  Unset isotopes.</p>
<p>Stay tuned.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/can-the-meta-protocol-solve-unsetness/1600">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/can-the-meta-protocol-solve-unsetness/1600</link>
          <pubDate>Fri, 07 May 2021 11:32:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1600</guid>
          <source url="https://forum.rebol.info/t/can-the-meta-protocol-solve-unsetness/1600.rss">Can The ^Meta Protocol Solve Unsetness?!?!</source>
        </item>
        <item>
          <title>The difference of the binary representation and decimal representation toward the user</title>
          <dc:creator><![CDATA[iArnold]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>When an integer! is created, its value is kept as in binary form. When in the console is entered:</p>
<pre><code>&gt;&gt; x: 256
== 256
</code></pre>
<p>The value 256 is converted to a binary representation to save the integer! value in memory.<br>
And afterwards the result of the operation is returned. The value that was assigned to x is converted from its binary form to the display format of 256.</p>
<p>Where exactly in the code is this conversion taking place?</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/the-difference-of-the-binary-representation-and-decimal-representation-toward-the-user/1597">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-difference-of-the-binary-representation-and-decimal-representation-toward-the-user/1597</link>
          <pubDate>Thu, 06 May 2021 11:21:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1597</guid>
          <source url="https://forum.rebol.info/t/the-difference-of-the-binary-representation-and-decimal-representation-toward-the-user/1597.rss">The difference of the binary representation and decimal representation toward the user</source>
        </item>
        <item>
          <title>Non-Interstitial Invisibles: More Trouble Than They&#39;re Worth?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p><strong><a href="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405">Invisibles are a novel and important concept.</a></strong>  But they introduce a lot of wrinkles.</p>
<p>While there's a lot of technical complexity--I'm not terribly worried about that (technical problems have technical solutions).  But usability and semantic problems need to be confronted.</p>
<p>Early on, I wanted to avoid situations where an invisible could be in a position where it might look like it was an assignment:</p>
<pre><code>x: elide print "It's confusing when X gets [a]"
append [] 'a
</code></pre>
<p>Since the ELIDE vanished, the result of the APPEND is what X gets.  Confusing!</p>
<p>So at first, I figured it should be illegal to do that.  But I later backed off on ruling it out when I thought about a vanishing BREAKPOINT:</p>
<pre><code>x: breakpoint append [] 'a
</code></pre>
<p>Why shouldn't you be able to put a breakpoint wherever you want, I wondered?  So it became legal.</p>
<p>In the fever dream of making invisibles able to do anything, there were tests like this:</p>
<pre><code>unset 'x
unset 'y
unset 'z
x: 10
y: 1 comment [+ 2
    z: 30] + 7
did all [
    x = 10
    y = 8
    not set? 'z
]
</code></pre>
<p>But the same problems apply when a SET-WORD! is not present in the general case; the ability to bend the "shape" of the source so arbitraily has a big complexity cost in the interpreter.  It then has to be explained in terms of <a href="https://github.com/metaeducation/ren-c/blob/0b5b42003a4c181f38f3eb28e4378dc53d3a14f1/src/mezz/base-defs.r#L150">why COMMENT is ENFIX</a> and a litany of limitations where it doesn't work.  Documenting it is maddening...and it seems to have diminishing returns.</p>
<p><strong>Now I'm having serious second thoughts about the lenience.</strong>  I don't know this tradeoff is ultimately worth it; it becomes very slippery when you are dealing with constructs that you aren't necessarily noticing are invisible.</p>
<p>So I'm thinking that the error on invisibility for non-interstitials (e.g. assignment sources or argument slots) may make sense...to say that invisibility is something that can only happen in interstitial locations.</p>
<p>You can still get your breakpoint at odd positions, just introduce a GROUP! so it's not picked up:</p>
<pre><code>x: (breakpoint append [] 'a)
</code></pre>
<p>Of course, a group might interfere with something like a COMPOSE, so you might need to use DO or be otherwise creative:</p>
<pre><code>x: do [breakpoint append [] 'a]
</code></pre>
<p>We might lament the need to worry more about restructuring the code to accommodate the breakpoint in ways that could disrupt the code.  But with dialecting, the appearance of the word BREAKPOINT even just in itself could have caused a disruption.  It's the cost of doing business in this paradigm.</p>
<h2>What might this imply for other cases, like <strong>do []</strong> ?</h2>
<p>It may suggest that <code>do []</code> can be invisible and vanish... just not have the result used in assignments.  Which might be perfect; if you get frustrated with that, you can always consciously put a value in-between.</p>
<p>So instead of:</p>
<pre><code>x: thing-that-might-be-invisible
</code></pre>
<p>You could say:</p>
<pre><code> x: (&lt;default-value&gt; thing-that-may-be-invisible)
</code></pre>
<p>There needs to be some way of specifically evaluating something and finding out if it was invisible...much like there needs to be a way of evaluating something and knowing if it threw, or raised an error, etc.  Not everything fits cleanly as a "result value".  But this shows there'd be at least one way of dealing with it besides that.</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/non-interstitial-invisibles-more-trouble-than-theyre-worth/1582">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/non-interstitial-invisibles-more-trouble-than-theyre-worth/1582</link>
          <pubDate>Mon, 12 Apr 2021 16:40:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1582</guid>
          <source url="https://forum.rebol.info/t/non-interstitial-invisibles-more-trouble-than-theyre-worth/1582.rss">Non-Interstitial Invisibles: More Trouble Than They&#39;re Worth?</source>
        </item>
        <item>
          <title>Fundamental Changes Needed for GC (Reference Counting)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>So I'd gone ahead with the implementation of virtual binding and LET, because I don't see any real future for the language without it...at least not for the kinds of distinguishing features that I think would make it notable.</p>
<p>But it means we're creating a lot of garbage.  I've brought up pathological cases, like:</p>
<pre><code>count-up x 1000000 [
   let y: x + 1
   print ["Y is" y]
]
</code></pre>
<p>Creating a million tiny tracking entities for each time through the loop is a lot of junk for the GC to have to crunch through.</p>
<p>But the problem runs much deeper than this, because even without LETs you get issues with nested loops and their virtual binding information.  It's one example of many.</p>
<p>It isn't allocating and freeing memory that kills us.  We have memory pools and the layouts of everything are tuned fairly well.  It's having to sweep through all of memory to clear out things that aren't used.</p>
<h2>Reference Counting Can't Replace GC, But Would Help</h2>
<p>If we had room in each series node for a reference counter, we could notice when that counter reached zero...and free the series without allowing it to accumulate and tax the GC.</p>
<p>That won't get everything, because blocks and objects can have cyclical references.  But a lot of the time, it would let us rapidly reclaim memory to reuse...leading to far less accumulation.</p>
<p>So in the example of the tight COUNT-UP loop above, a FRAME! would be allocated that would have a "specifier chain".  That chain would get the entry for the LET, and so that would count as a reference.  When PRINT runs, the BLOCK! <strong>["Y is" y]</strong> fills into its argument slot...and that instance of the block cell is coupled with the specifier chain...adding another reference.  But when PRINT finished, it would release its hold on the frame where that block cell lived...in this case nothing is holding that frame (it's a native, no debugger, etc.)  That means no one is seeing the cells, so they could all be blanked out...releasing their references.  This would drop the reference <strong>["Y is" y]</strong>'s derelativization has on the specifier chain, bringing it down to 1 reference.  And then, when the frame finished that iteration of the body, it would drop the reference on the specifier chain...reducing its references to 0.  That would free the LET.</p>
<p><em>Or at least the theory is something like that.</em></p>
<h2>How Hard Would It Be?</h2>
<p>Offhand, I'd say very hard.</p>
<p>With a C++ build to draw on, it becomes easier to check.  Though I'd definitely say this kind of change would be one of those moments where I'd start to seriously question the sanity of trying to keep on building a sophisticated system in C89.</p>
<p>Doing anything with low-level mechanics is harder the more low-level "core" code you have.  Anything written to higher-levels of abstraction like libRebol wouldn't have to change, but everything that assumes lower access gets a lot hairier.</p>
<p>It's better at the moment to write the code how it's supposed to look...and tackle big challenges, tolerating the slowness.  But I just wanted to bring this up because I don't think the slowness can be beaten unless we do better bookkeeping to know how to reclaim memory.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/fundamental-changes-needed-for-gc-reference-counting/1527">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/fundamental-changes-needed-for-gc-reference-counting/1527</link>
          <pubDate>Fri, 26 Feb 2021 08:53:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1527</guid>
          <source url="https://forum.rebol.info/t/fundamental-changes-needed-for-gc-reference-counting/1527.rss">Fundamental Changes Needed for GC (Reference Counting)</source>
        </item>
        <item>
          <title>Should REEVALUATE apply LET bindings?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>So the idea of REEVALUATE (short name REEVAL) is that you get the same behavior "as if" you had written the thing in place:</p>
<pre><code>&gt;&gt; x: 10
&gt;&gt; reeval (first [x:]) 20  ; acts like X: 10
&gt;&gt; x
== 20
</code></pre>
<p>But how far should this "as if you'd written it there" go?  Should the binding be applied?</p>
<pre><code>&gt;&gt; x: 1000
&gt;&gt; code: '(x + 20)
&gt;&gt; do [let x: 284, reeval code]
== ?
</code></pre>
<p>Does it see the new value for X?  Should that give you 1020, or 304?</p>
<p>I vote 1020.  Seems to me that only source-level code should see the LET's binding.</p>
<p>But there's an implementation problem because the evaluator has to know to suppress LET bindings on reevaluations.  REEVAL takes pains to make sure it's running through the same code path as the evaluator normally would.  It's not exactly clear what bits to check or flip to know how to control this behavior.</p>
<p>Tricky as that is, it would get even trickier if we said you <em>wanted</em> to apply the LET binding...because it gets hard to know whether you've applied it twice.  Imagine if you said instead:</p>
<pre><code>&gt;&gt; x: 1000
&gt;&gt; code: '(x + 20)
&gt;&gt; do compose [let x: 284, reeval '(code)]
== 304  ; we want it to see the LET X
</code></pre>
<p>How does REEVAL know if the <strong>let x: 284</strong> was taken into account already or not?  This depends on whether the argument was literal or fetched through a variable.  But REEVAL isn't supposed to know anything about its argument besides its value.  <a href="https://github.com/metaeducation/ren-c/commit/b1721727665d286be3ccafebb70461e2770b108a">I rigged up a fix</a>, and we can see how well it holds up.</p>
<p><strong>I think this points to the idea that LET and USE should probably stick to having near-parity in outcomes.</strong>  That means the binding only applies to source, not things fetched and then "treated as source" later.</p>
<p>Anyway, difficult stuff...all on the way to <a href="https://forum.rebol.info/t/what-to-do-about-funct-including-not-calling-it-that/1518">getting rid of FUNCT-behavior-of-FUNCTION</a>.  Since there's such a big monster of a codebase to try it on (including the Mezzanine, Rebmake, and ReplPad) it's getting exercised fairly heavily.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-reevaluate-apply-let-bindings/1521">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-reevaluate-apply-let-bindings/1521</link>
          <pubDate>Wed, 24 Feb 2021 20:13:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1521</guid>
          <source url="https://forum.rebol.info/t/should-reevaluate-apply-let-bindings/1521.rss">Should REEVALUATE apply LET bindings?</source>
        </item>
        <item>
          <title>Should EVALUATE bomb on an error?</title>
          <dc:creator><![CDATA[rgchris]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>Currently if you try something bad in EVALUATE, it throws an error:</p>
<pre><code class="lang-nohighlight">&gt;&gt; evaluate [unspaced null]
** Script Error: unspaced requires line argument to not be null
</code></pre>
<p>As EVALUATE is a relatively low-level function, it would seem more likely one would want to handle the error on the same basis as other possible return values:</p>
<pre><code class="lang-nohighlight">; assuming EVALUATE returns [product position]
&gt;&gt; evaluate [unspaced null foo bar]
== [**unspaced-null [foo bar]]
</code></pre>
<p>In this case, the bomb isn't particularly informative and seems reasonable to say <em>'user bewareassume errors will happen'</em>. It's kind of difficult to work around too.</p>
<p>This sort of puts it in the same class as TRAP with different semantics:</p>
<pre><code class="lang-nohighlight">trap [ok ok something bad] =&gt; [**something-bad null]
trap [ok ok] =&gt; [null ok]
evaluate [something bad ok ok] =&gt; [**something-bad [ok ok]]
evaluate [ok ok] =&gt; [ok [ok]]
</code></pre>
<p>I guess the wrinkle here is how do you determine where <code>something bad</code> ends and <code>ok ok</code> resumes? That may or may not be obvious.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/should-evaluate-bomb-on-an-error/1491">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-evaluate-bomb-on-an-error/1491</link>
          <pubDate>Sat, 06 Feb 2021 06:24:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1491</guid>
          <source url="https://forum.rebol.info/t/should-evaluate-bomb-on-an-error/1491.rss">Should EVALUATE bomb on an error?</source>
        </item>
  </channel>
</rss>

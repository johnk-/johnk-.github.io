<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Internals - AltRebol</title>
    <link>https://forum.rebol.info/c/development/internals/9</link>
    <description>Topics in the &#39;Internals&#39; category Internals of the Rebol language</description>
    
      <lastBuildDate>Thu, 22 Aug 2024 04:00:00 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/internals/9.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Re-imagining EVAL/NEXT</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <blockquote>
<p><strong>NOTE:</strong> <a href="https://forum.rebol.info/t/do-of-text-as-synonym-of-do-of-file-containing-string/2125">The nature of DO is to deal with whole scripts</a>.  We know <strong><code>do/next %foo.r</code></strong> doesn't make any sense, and in fact having DO take a BLOCK! of Rebol code should be a dialect about how to load and bind what you pass it... not expressions like <strong><code>do [1 + 2]</code></strong>.</p>
<p>So in modern Ren-C, array evaluation is handled by a primitive called <strong>EVAL</strong>.  Hence the /NEXT refinement has been removed from DO, and for a transitional period DO will not take BLOCK! at all... until all such references are gone.  At which point it will take a dialected LOAD spec, probably aligning closely with what IMPORT takes.</p>
</blockquote>
<h3><a name="p-2483-right-now-evalnext-takes-a-variable-to-store-the-new-position-1" class="anchor" href="https://forum.rebol.info#p-2483-right-now-evalnext-takes-a-variable-to-store-the-new-position-1"></a>Right Now, EVAL/NEXT Takes A Variable To Store The New Position</h3>
<pre><code>&gt;&gt; result: eval/next [1 + 2 10 + 20] $pos
== 3

&gt;&gt; pos
== [10 + 20]
</code></pre>
<p>This is exactly how Red and R3-Alpha handle DO/NEXT.</p>
<p>It was considered more convenient than how Rebol2 gave you a block of both the result and the new position...which you had to pick apart:</p>
<pre><code>rebol2&gt;&gt; do/next [1 + 2 10 + 20]
== [3 [10 + 20]]
</code></pre>
<p><em>(That couldn't work at all in Ren-C, because evaluation can produce antiforms, and antiforms can't be put in blocks.)</em></p>
<h3><a name="p-2483-one-twist-evalnext-of-returns-a-null-position-2" class="anchor" href="https://forum.rebol.info#p-2483-one-twist-evalnext-of-returns-a-null-position-2"></a>One Twist: EVAL/NEXT of <code>[]</code> Returns A NULL Position</h3>
<p>If you try to step with /NEXT over a BLOCK! like <strong>[1 + 2 10 + 20]</strong>, then there are EXACTLY TWO steps with meaningful results of 3 and 30.</p>
<p>So if you're going to be doing the evaluations in a WHILE loop, you want the EVAL/NEXT position result to return success twice, and then have a third call that returns null to signal the looping is done.</p>
<p>This gives you the possibly surprising (or not?) result that <code>EVAL/NEXT []</code> doesn't take a step and doesn't synthesize VOID, even though <code>EVAL []</code> is VOID.  It's a terminal condition.  So if you're trying to take steps and generate an overall accumulated result, you have to seed your result with VOID... and then <code>EVAL/NEXT []</code> will tell you there was nothing to do and you return your seeded result.</p>
<p>Make sense?</p>
<p>Rebol2, Red, and R3-Alpha all require you to check for the TAIL? of the block as your terminal condition.  Because DO/NEXT on a tail position just produces an UNSET! and another tail position.</p>
<pre><code>rebol2&gt;&gt; do/next [10 + 20]
== [30 []]

rebol2&gt;&gt; do/next []
== [unset []]

rebol2&gt;&gt; do/next []
 == [unset []]
</code></pre>
<p>That's quite a lot more awkward to handle for a terminal condition.  In fact it forces you to check for TAIL? on the block you're evaluating <em>before</em> the first call to DO/NEXT (because seeing the tail afterward won't tell you if the previous step synthesized a valid UNSET!).</p>
<p>R3-Alpha and Red didn't change this, and still make you check for TAIL? before you take steps:</p>
<pre><code>r3-alpha/red&gt;&gt; do/next [10 + 20] 'pos
== 30

r3-alpha/red&gt;&gt; pos
== []

r3-alpha/red&gt;&gt; do/next [] 'pos
; no console result here means unset

r3-alpha/red&gt;&gt; pos
== []

r3-alpha/red&gt;&gt; do/next [] 'pos
; no console result here means unset

r3-alpha/red&gt;&gt; pos
== []
</code></pre>
<p>Still very awkward, and unclear why they did this instead of making the POS be #[none].</p>
<h2><a name="p-2483-but-ren-c-can-do-even-better-multi-returns-3" class="anchor" href="https://forum.rebol.info#p-2483-but-ren-c-can-do-even-better-multi-returns-3"></a>But Ren-C Can Do Even Better: Multi-Returns!</h2>
<p>What if EVAL/NEXT turned the return result into a parameter pack, where you get both the evaluation product and the new position?</p>
<p><em>(I'm going to make it so it switches the main return result to be the position, and the secondary result is the evaluation product.  Then I'll explain why.)</em></p>
<pre><code>&gt;&gt; block: [1 + 2 10 + 20]
== [1 + 2 10 + 20]

&gt;&gt; pos: eval/next block  ; don't have to heed both returns
== [10 + 20]

&gt;&gt; [pos /result]: eval/next pos  ; but you can heed both returns
== []

&gt;&gt; result
== 30

&gt;&gt; [pos /result]: eval/next pos
== ~null~  ; anti

&gt;&gt; result
== ~null~  ; anti &lt;- not meaningful, because POS was null
</code></pre>
<p>The reason you (often) need the slash on /RESULT is that when EVAL/NEXT is done, it returns a pure null... not a multi-return.  This makes it correctly reactive to THEN and ELSE, which consider nulls inside of parameter packs to be "something" instead of "nothing".  But if you try to unpack a single null into two slots that is considered not enough.</p>
<p>Using a leading slash on a multi-return unpack is indication that you accept there may not be enough items in the pack to have one for that variable.  We could choose to have the multi-return unpacker make it trash or null, but in general null is more useful.</p>
<p><em>(To distinguish from a null that was actually in a pack and unpacked, you'd have to use <strong><code>^/result</code></strong>...which would meta the value so an unpacked null would be a quasiform ~null~, while the null resulting from too few values in the pack would be the antiform.  Caring about this is rare, but good to have a way to tell the difference if you do care.)</em></p>
<h2><a name="p-2483-why-did-i-make-position-the-primary-return-result-4" class="anchor" href="https://forum.rebol.info#p-2483-why-did-i-make-position-the-primary-return-result-4"></a>Why Did I Make Position The Primary Return Result?</h2>
<ol>
<li>
<p><strong>It Makes It Easier to Loop Through an Evaluation</strong> - There are some situations where EVAL/NEXT doesn't care about the value synthesized, but pretty much no cases where you don't care about the new position.  Being able to conditionally test if the returned position reached the end of a loop is super convenient.</p>
<pre><code>block: [1 + 2 10 + 20]

while [[block /result]: eval/next block] [
    print ["Step result was:" result]
]
</code></pre>
<p>It's true that with Ren-C's super multi-return powers, you could ask for the second argument to be the overall main result.  But that's uglier, why be ugly?</p>
<pre><code>block: [1 + 2 10 + 20]

while [[result @/block]: eval/next block] [
    print ["Step result was:" result]
]
</code></pre>
</li>
<li>
<p><strong>Avoids Ambiguity When EVAL Result Is Itself A Multi-Return</strong> - Imagine the following kind of confusion if we made the evaluation product the first result instead of the second:</p>
<pre><code>&gt;&gt; block: [1 + 2 comment "I don't care about this"]

&gt;&gt; result: eval/next block  ; I just want the first thing!
== 3  ; great, I didn't want that position anyway

&gt;&gt; block: [pack [&lt;left&gt; &lt;right&gt;] comment "I don't care about this"]

&gt;&gt; [left right]: eval/next block  ; just want to unpack that first thing
== &lt;left&gt;  ; great, just what I expected

&gt;&gt; right
== [comment "I don't care about this"]  ; whaaa? I wanted &lt;right&gt;!
</code></pre>
<p>Encountering problems with this in the past has made me back off from using multi-returns in places they seemed like they would be perfect.  But what I now realize is you simply don't want your primary return result of a multi-return to be something that can itself be a multi-return... unless you <em>really</em> know what you are doing.</p>
<p>If you intend to do something with the evaluation product and want to be truly general, you of course have to be using ^META conventions:</p>
<pre><code>[pos ^result]: eval/next pos
</code></pre>
<p>Whether you need to do that or not depends on what you are doing.  Why are you stepping through arrays one step at a time, anyway?  Usually intermediate results are discarded.  What is it precisely you are looking for?  (Again on my point of why making the position the primary result makes sense... usually you aren't looking at the result at all, you're a dialect and looking at what you advance to at the next position.)</p>
</li>
</ol>
<h2><a name="p-2483-lgtm-1-5" class="anchor" href="https://forum.rebol.info#p-2483-lgtm-1-5"></a>LGTM <img src="https://forum.rebol.info/images/emoji/twitter/+1.png?v=12" title=":+1:" class="emoji" alt=":+1:" loading="lazy" width="20" height="20"></h2>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/re-imagining-eval-next/767">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/re-imagining-eval-next/767</link>
          <pubDate>Thu, 22 Aug 2024 04:00:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-767</guid>
          <source url="https://forum.rebol.info/t/re-imagining-eval-next/767.rss">Re-imagining EVAL/NEXT</source>
        </item>
        <item>
          <title>Invisibility Reviewed Through Modern Eyes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>The first idea of making constructs that would "vanish completely" leveraged a special kind of enfix function, that would receive the entire evaluated value of the left hand side:</p>
<pre><code> elide: enfix func [
     left [&lt;evaluate-all&gt; any-value!]
     right
 ][
     print ["ELIDE got left as" mold left]
     return left
 ]

 &gt;&gt; 1 + 2 + 3 comment [magic!]
 hi
 ELIDE got left as 6
 == 6  ; wow!
</code></pre>
<p>This was a workaround for the (seeming?) fundamental fact that you can't have such a thing as "invisible variables" or "invisible values".  <em>Certain functions just faked invisibility by repeating the previous value in the evaluator chain.</em></p>
<p>The possibilities seemed endless.  For instance, imagine something like this:</p>
<pre><code>case [
   conditionA [...code...]
   elide print "conditionA didn't succeed but running this"
   conditionB [...code...]
   conditionC [...code...]
]
</code></pre>
<p>To do that in Rebol2 or Red would be incredibly awkward.  e.g. using a condition that runs code but evaluates to false, and then a throwaway block for the never-executed branch:</p>
<pre><code>case [
   conditionA [...code...]
   (
       print "conditionA didn't succeed but running this"
       false
   ) [&lt;unreachable&gt;]
   conditionB [...code...]
   conditionC [...code...]
]
</code></pre>
<p>Similar awkwardness would arise in things like ANY and ALL, where you'd have to switch from using true and false based on which you were using...</p>
<pre><code>any [conditionA (print "vanish" false) conditionB]
all [conditionA (print "vanish" true) conditionB]
</code></pre>
<p>Beyond being awkward, it simply can't work if what you want to vanish is the last expression.  But ELIDE handled all these cases:</p>
<pre><code>any [conditionA elide print "vanish" conditionB]
all [conditionA elide print "vanish" conditionB]
any [conditionA conditionB elide print "vanish"]
all [conditionA conditionB elide print "vanish"]
</code></pre>
<h2>
<a name="it-was-a-neat-trickbut-problems-emerged-1" class="anchor" href="https://forum.rebol.info#it-was-a-neat-trickbut-problems-emerged-1"></a>It Was A Neat Trick...But Problems Emerged</h2>
<p>The trick of invisibility requiring a function to receive its left hand side meant a GROUP! or COMMA! would break these constructs, as there was no access to a previous value:</p>
<pre><code> &gt;&gt; 1 + 2 + 3 (elide print "hi")
 hi
 ELIDE got left as null
 == ~null~  ; not 6, d'oh!

 &gt;&gt; 1 + 2 + 3, elide print "hi"
 hi
 ELIDE got left as null
 == ~null~
</code></pre>
<p>Plus being enfix forced the invisible functions to execute in the same step as whatever came before them, causing unsuspected results:</p>
<pre><code>&gt;&gt; case [
        1 = 1 [print "branch"]
        elide print "reached here first :-("
        1 = 2 [fail "Unreachable"]
    ]
ELIDE got left as [print "branch"]
reached here first :-(
branch
</code></pre>
<p>There we see that when the evaluator visited the <strong>[print "branch"]</strong> block in the CASE it had to greedily run the ELIDE, which evaluates its argument and then yielded the code block as its result.  CASE ran that code after the elide...out of order from what was desired.</p>
<p>Issues seemed to keep compounding.  These invisible functions couldn't be reliably used with MAKE FRAME!, and people trying to simulate the evaluator's logic found it hard to detect and wrap them.  That led to major issues with UPARSE trying to implement combinators that acted like ELIDE.</p>
<p>So the enfix mechanism wasn't going to cut it.  But it was too late: having been able to try out and develop all kinds of invisible constructs convinced me of their value.  I had to try another way...</p>
<h2>
<a name="formalizing-a-void-state-and-corresponding-meta-state-2" class="anchor" href="https://forum.rebol.info#formalizing-a-void-state-and-corresponding-meta-state-2"></a>Formalizing a VOID State And Corresponding Meta State</h2>
<p>The seeming impossibility of having a "void value" was addressed with the idea of folding special treatment in the evaluator of voids, but offering a meta domain in which they could be handled safely.</p>
<pre><code>&gt;&gt; var: void
; void

&gt;&gt; 1 + 2 var
== 3

&gt;&gt; var: meta void
== '

&gt;&gt; 1 + 2 var
== '

&gt;&gt; 1 + 2 unmeta var
== 3
</code></pre>
<p>The concept of being able to pipe around and process "slippery" values in this meta domain (including unset states and other isotopes) wound up being very successful.</p>
<p>Evaluators like DO and UPARSE would specially preserve the last evaluative value in order to give the illusion of invisibility when voids were seen on the next step.  Other constructs got to make a choice as to whether they wanted to embrace voids as part of the mechanic, or think of them as errors:</p>
<pre><code>&gt;&gt; comment "comments returned void"  ; Note: console doesn't show void results

&gt;&gt; if comment "hi" [print "not tolerated in conditions"]
** Error: IF doesn't accept void as its condition argument

&gt;&gt; all [comment "begin" 1 + 2 10 + 20 comment "end"]
== 30

&gt;&gt; any [comment "begin" 1 + 2 10 + 20 comment "end"]
== 3
</code></pre>
<p>e.g. for the above to work, ALL has to hang on to the last evaluated result as it goes...in case the next evaluated result is a comment.  This allows the 30 to fall out.</p>
<h2>
<a name="a-flexible-approach-but-here-be-dragons-3" class="anchor" href="https://forum.rebol.info#a-flexible-approach-but-here-be-dragons-3"></a>A Flexible Approach... But... Here Be Dragons</h2>
<p>Something that concerned me early on was that what had started as a narrow ability of just a few functions (like COMMENT and ELIDE) was becoming a case where generalized execution could possibly return voids, leading to unexpected results.</p>
<pre><code>&gt;&gt; code: [comment "some arbitary code block"]

; ... then much later ...

&gt;&gt; result: (mode: &lt;reading&gt; do code)
== &lt;reading&gt;

&gt;&gt; result
== &lt;reading&gt;  ; oops
</code></pre>
<p>Increasing dependence on void as a "vanishing" alternative to the noisier null also raised the demand for void variables, with them becoming slippery to generate:</p>
<pre><code>&gt;&gt; parse [x] [rule: ['x (void) | 'y ([some "y"])]
== x

&gt;&gt; rule
== x  ; wanted void
</code></pre>
<p>VOID was becoming a victim of its own popularity.  When it was rare coming from only a few constructs like ELIDE and COMMENT it was rare to see problems.  Yet when every IF/CASE/SWITCH statement that didn't run a branch started returning voids, things got hairier.</p>
<p>There were also snags when making void isn't a parameter...but a product of something like the body on a MAP-EACH. At first it looks fine:</p>
<pre><code>map-each item [1 &lt;one&gt; 2 &lt;two&gt; 3 &lt;three&gt;] [
    maybe match tag! item  ; leaving it as NULL would be an error
]
== [&lt;one&gt; &lt;two&gt; &lt;three&gt;]
</code></pre>
<p>But what if you had something else in the loop body?</p>
<pre><code>map-each item [1 &lt;one&gt; 2 &lt;two&gt; 3 &lt;three&gt;] [
    append log spaced ["Logging:" item]
    maybe match tag! item  ; remember, void vanishes
]
== ["Logging: 1" "Logging: &lt;one&gt;" "Logging..." ...]
</code></pre>
<h2>
<a name="once-again-isotopes-to-the-rescue-4" class="anchor" href="https://forum.rebol.info#once-again-isotopes-to-the-rescue-4"></a>Once Again: Isotopes To The Rescue</h2>
<p>As part of <a href="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134">solving the problem of multi-returns</a>, parameter pack antiforms were introduced.  These would "decay" to their first item, unless something handled the antiform specially.</p>
<pre><code>&gt;&gt; pack [1 + 2 10 + 20]
== ~['3 '30]~  ; anti

&gt;&gt; a: pack [1 + 2 10 + 20]
== 3

 &gt;&gt; [a b]: pack [1 + 2 10 + 20]  ; SET-BLOCK! handles PACK! antiform specially
 == 3

 &gt;&gt; a
 == 3

 &gt;&gt; b
 == 30
</code></pre>
<p>Unpacking the packs raised a question: <em><strong>What if the PACK! is Empty</strong></em>?  As far as variable assignment goes, it seems it can't do anything.  So erroring made the most sense:</p>
<pre><code>&gt;&gt; pack []
== ~[]~  ; anti

&gt;&gt; a: pack []
** Error: No values available in empty parameter pack
</code></pre>
<p>Then there was a breakthrough of the next thought: <em><strong>Empty antiform packs could be used as the vanishing intent!!</strong></em></p>
<pre><code>&gt;&gt; 1 + 2, pack []
== 3
</code></pre>
<p>This would mean VOID could be less "slippery" in the evaluator, being treated normally most of the time and falling out of expressions vs. vaporizing:</p>
<pre><code>&gt;&gt; 1 + 2, if false [&lt;a&gt;]  ; overall result is void
== ~void~  ; anti

&gt;&gt; 1 + 2, if true [&lt;a&gt;]
== &lt;a&gt;
</code></pre>
<h2>
<a name="empty-isotopic-packs-were-then-given-a-name-nihil-5" class="anchor" href="https://forum.rebol.info#empty-isotopic-packs-were-then-given-a-name-nihil-5"></a>Empty isotopic packs were then given a name: <strong>"NIHIL"</strong>
</h2>
<p>The terminology has varied over time.  I accomplished the distinction another way before isotopic packs, and at that time I called the distinction "impure invisibility" (non-vaporizing) vs. "pure invisibility" (vaporizing).</p>
<p>But I think the "impure" vs. "pure" terms just caused confusion.  This is where things stand today, and it seems comfortable:</p>
<pre><code>&gt;&gt; 1 + 2 void
== ~void~  ; anti

&gt;&gt; 1 + 2 nihil
== 3

&gt;&gt; 1 + 2 null
== ~null~   ; anti
</code></pre>
<h2>
<a name="i-think-this-is-a-comfortable-balance-6" class="anchor" href="https://forum.rebol.info#i-think-this-is-a-comfortable-balance-6"></a>I Think This Is A Comfortable Balance</h2>
<p>No matter what way you slice it, an expression that can truly vaporize is something that can make you uneasy.  Look at this CASE statement and imagine if FOO or BAR could vanish:</p>
<pre><code> case [
     foo [print "hi"]
     bar [print "bye"]
 ]
</code></pre>
<p>Sure... we can lament that if FOO comes back as NIHIL, it will wreck the geometry of the CASE completely.  After dropping the FOO it will treat [print "hi"] as a condition and use BAR as a code branch.</p>
<p><em>But if FOO is a function that takes a BLOCK! as a parameter, it will also wreck the geometry of the CASE completely!</em>  This is just the cost of doing business in the Rebol paradigm.</p>
<p>This modern model with NIHIL being an unstable isotope brings us back to where you can only get vanishing function calls--not vanishing variables.  FOO can be a variable holding VOID, but there's no risk of that wrecking the CASE statement...because CASE is not one of the constructs that willfully erases VOID.  Neither does the foundational evaluator (and nor does UPARSE)</p>
<p>So long as usage of NIHIL is judicious, I think this is about as terra firma as the rest of Rebol is.  And UPARSE stands as a great example of a system that has been able to build on meta-representation in order to be able to pipe around vanishing states using "special gloves" and build upon it to make new invisible behaviors...</p>
<pre><code>&gt;&gt; parse "aaabbb" [collect some keep "a", elide some "b"]
== ["a" "a" "a"]
</code></pre>
<p>It's rather satisfying.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/invisibility-reviewed-through-modern-eyes/2034">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/invisibility-reviewed-through-modern-eyes/2034</link>
          <pubDate>Fri, 23 Jun 2023 17:06:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2034</guid>
          <source url="https://forum.rebol.info/t/invisibility-reviewed-through-modern-eyes/2034.rss">Invisibility Reviewed Through Modern Eyes</source>
        </item>
        <item>
          <title>Unstable Isotope Conundrums</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>An unstable isotope is one that cannot be stored in a variable.  The clearest example of one of these is a PACK!.</p>
<p>Quick refresher: because functions receive their arguments in variables, you clearly cannot pass an unstable isotope to a function.  You instead use ^META parameters and get the quasiform.</p>
<pre><code>&gt;&gt; pack [3 4]
; first in pack of length 2
== 3

&gt;&gt; meta pack [3 4]
== ~['3 '4]~

&gt;&gt; [a b]: pack [3 4]
== 3

&gt;&gt; a
== 3

&gt;&gt; b
== 4
</code></pre>
<p><strong>But what about non-variable situations... like expressions that are being tested for being truthy or falsey?</strong></p>
<p>Right now, tests for truthiness throw the unstable state away.  For instance, ALL:</p>
<pre><code>&gt;&gt; all [1 2 pack [3 4]]
== 3
</code></pre>
<p>The PACK! formed by the PACK function is decayed to just 3 by the ALL, and then the 3 was tested as truthy.  If you wanted to get past this, you would have to meta-and-then-unmeta the pack:</p>
<pre><code>&gt;&gt; unmeta all [1 2 meta pack [3 4]]
; first in pack of length 2
== 3
</code></pre>
<p>But note that here, it's testing the meta-pack ~['3 '4]~ for truthiness, not the 3.  So if false were in the meta pack, it would still wind up truthy.</p>
<pre><code>&gt;&gt; all [1 2 meta pack [false false]]
== ~[~false~ ~false~]~
</code></pre>
<p>Whereas a regular pack would be decayed before the test:</p>
<pre><code>&gt;&gt; all [1 2 pack [false false]]
== ~null~  ; isotope
</code></pre>
<p>You might ask <em>"Why not just say all PACK!s are truthy, so you don't have to META and UNMETA them?"</em></p>
<p>Well just think about it: when you use a multi-returning function you may only be interested in the primary result...and even only be slightly aware that more results are available.  For instance: not everyone knows that today's FIND returns an additional output if you want it (it's the end of a match).</p>
<p><strong>Saying that packs must decay to test them for truthiness doesn't seem too baffling, but what about loop constructs that don't test for truthiness?</strong></p>
<p>Is this harmless?</p>
<pre><code>&gt;&gt; flag: true

&gt;&gt; meta while [flag] [flag: false, pack [3 4]]
== ~['3 '4]~
</code></pre>
<p>It seems all right, although this becomes a property that <a href="https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833">has to be preserved by compositions like FOR-BOTH</a>. (As it so happens, the composition does work.)</p>
<p>But what about UNTIL?  In until the loop condition and the body are the same, and in order to exit the loop the body must be truthy...so you can't get a pack out:</p>
<pre><code>&gt;&gt; until [pack [3 4]]
== 3
</code></pre>
<p>And also... what about situations like CONTINUE/WITH or STOP/WITH.  If the /WITH parameter is a plain refinement and not a ^META one, then the information will be lost:</p>
<pre><code>&gt;&gt; cycle [stop/with pack [3 4]]
== 3
</code></pre>
<p>If CONTINUE and STOP were to follow in the footsteps of RETURN, they would need an added refinement like RETURN/FORWARD which distinguishes the case where you do want the meta parameter from where you don't (which is the current solution, vs. something like marking ^RETURN: as always being meta on the function definition).</p>
<h2>
<a name="maybe-test-decayd-value-preserve-pack-1" class="anchor" href="https://forum.rebol.info#maybe-test-decayd-value-preserve-pack-1"></a>Maybe Test DECAY'd Value, Preserve PACK! ?</h2>
<p>Constructs like ALL or UNTIL might decay only for the purposes of the truthiness test, but preserve the original PACK! for the actual return.</p>
<p>For instance could you do this?</p>
<pre><code>&gt;&gt; [a /b]: all [
       1 = 1
       2 = 2
       pack [3 4]
   ]
== 3

&gt;&gt; a
== 3

&gt;&gt; b
== 4
</code></pre>
<p>I've pointed out that PACKs with falsey items have to break the chain:</p>
<pre><code>&gt;&gt; [a /b]: all [
       1 = 1
       2 = 2
       pack [false 4]
   ]
== ~null~  ; isotope

&gt;&gt; a
== ~null~  ; isotope

&gt;&gt; b
== ~null~  ; isotope
</code></pre>
<p>If you didn't intend that you'd have to META the pack inside the ALL...and UNMETA outside as discussed (in this case with UNMETA* which passes through null as-is vs. erroring if the leading conditions resulted in a null outcome)</p>
<pre><code>&gt;&gt; [a /b]: unmeta* all [
       1 = 1
       2 = 2
       meta pack [false 4]
   ]
== ~false~  ; isotope

&gt;&gt; a
== ~false~  ; isotope

&gt;&gt; b
== 4
</code></pre>
<p>Taking this preservation to extremes would complicate a lot of places in the code.  For instance: IF tolerates function branches, and will pass on the condition to the branch:</p>
<pre><code>&gt;&gt; var: [a b c]

&gt;&gt; if var (func [x] [print ["var was" mold x]])
var was [a b c]
</code></pre>
<p>But what if you want to do this with a pack, and have the option of receiving it in that function?</p>
<pre><code> &gt;&gt; if pack [1 2] (func [x] [print ["var was" mold x]])
 var was 1

 &gt;&gt; if pack [1 2] (func [^x] [print ["meta var was" mold x]])
 meta var was ~[1 2]~

 &gt;&gt; if pack [false 2] (func [^x] [print ["meta var was" mold x]])
 ; void
</code></pre>
<p>Interesting though that may look, it changes IF to where it has to take its condition as a ^META parameter, otherwise it decays and can't be passed on.</p>
<p>I can't tell if this is a high-enough leverage piece of functionality to be worth complicating IF or not.</p>
<h2>
<a name="for-now-tempting-to-say-loop-protocol-cant-return-pack-2" class="anchor" href="https://forum.rebol.info#for-now-tempting-to-say-loop-protocol-cant-return-pack-2"></a>For Now, Tempting To Say "Loop Protocol" Can't Return PACK!</h2>
<p>It's not necessarily <em>hard</em> to make /WITH a ^META-refinement on CONTINUE and STOP... at least in terms of allowing PACK!.  <strong>continue/with raise error</strong> would cause some uncomfortable results.</p>
<p>Again, note there are ways to work around not processing unstable pack! isotopes by the /WITH itself, by META-ing on the inside and UNMETA-ing on the outside:</p>
<pre><code> &gt;&gt; cycle [stop/with meta pack [3 4]]
 == ~[3 4]~

 &gt;&gt; [a b]: unmeta cycle [stop/with meta pack [3 4]]
 == 3

 &gt;&gt; a
 == 3

 &gt;&gt; b
 == 4
</code></pre>
<p>Every time I see this, I do kind of wish up and down arrows were on our keyboards:</p>
<pre><code>  [a b]: ↓ cycle [stop/with ↑ pack [3 4]]
</code></pre>
<p>Caret-Meta only gets you half of this:</p>
<pre><code> [a b]: unmeta cycle [stop/with ^ pack [3 4]]
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/unstable-isotope-conundrums/2033">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/unstable-isotope-conundrums/2033</link>
          <pubDate>Thu, 22 Jun 2023 17:09:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2033</guid>
          <source url="https://forum.rebol.info/t/unstable-isotope-conundrums/2033.rss">Unstable Isotope Conundrums</source>
        </item>
        <item>
          <title>ARRAY/INITIAL and ACTION! Isotopes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>So the ARRAY mezzanine from R3-Alpha allowed you to make an array with an initial value that could be a function...in which case it evaluated that function each time:</p>
<pre><code>r3-alpha&gt;&gt; array 3
== [none none none]

r3-alpha&gt;&gt; array/initial 3 10
== [10 10 10]

r3-alpha&gt;&gt; n: 0 array/initial 3 does [n: n + 1]
== [1 2 3]
</code></pre>
<p>This raises the question of how you would make an array whose initial value was itself a function.</p>
<p>If you're a loophole-minded person, you might notice you could trick <em>this particular case</em> by making a function that returns a function.</p>
<pre><code>r3-alpha&gt;&gt; array/initial 3 does [:append]
== [#[action! [...]] #[action! [...]] #[action! [...]]]
</code></pre>
<p>But that's not really a general answer for how to deal with this kind of polymorphism--it just works if you're using the result purely to do a substitution.</p>
<h2>
<a name="trying-this-with-antiform-actions-1" class="anchor" href="https://forum.rebol.info#trying-this-with-antiform-actions-1"></a>Trying This With Antiform Actions</h2>
<p>I've loosened my stance on isotopes in function frames as parameters.  It's not a good idea to take them as default, but forcing you to make every parameter ^META just to get isotopes is limiting.</p>
<p>So I gave this a shot...</p>
<pre><code>array: func [
    {Makes and initializes a block of a given size}

    return: "Generated block or null if blank input"
        [block!]
    size "Size or block of sizes for each dimension"
        [&lt;maybe&gt; integer! block!]
    /initial "Initial value (will be called each time if action isotope)"
        [any-element? action?]
]
</code></pre>
<p>So that <strong>[any-element? action?]</strong> leads to a willingness to accept frame antiforms, as well as anything you can put in a block.  Having such an annotation leads you into the "danger zone" where if you don't prefix accesses to INITIAL with a colon, you run the risk of running a function.  But if you don't have the annotation, you don't have to be paranoid and decorate your references.</p>
<p>Here's how the INITIAL references wind up in the implementation:</p>
<pre><code>case [
    block? rest [
        repeat size [append block (array/initial rest :initial)]
    ]
    action? :initial [
        repeat size [append block run :initial]  ; Called every time
    ]
    any-series? initial [
        repeat size [append block (copy/deep initial)]
    ]
] else [
    append/dup block initial size
]
</code></pre>
<p>So the BLOCK! case which recurses uses the :INITIAL for pass-thru.</p>
<p>I used <strong>RUN :INITIAL</strong> when I could have just used <strong>INITIAL</strong>, simply because it feels more clear.  If this wasn't already contained by being at the end of a block, it would be better to limit the parameterization by saying something like <strong><code>apply :initial []</code></strong> or the now-equivalent <strong><code>initial :: []</code></strong></p>
<h2>
<a name="and-it-works-2" class="anchor" href="https://forum.rebol.info#and-it-works-2"></a>And It Works</h2>
<p>What we're kind of accepting as a default is that function generation produces isotopes.  So getting a plain action requires some kind of extra step, like REIFY</p>
<pre><code>&gt;&gt; func [x] []
== ~#[frame! [x]]~  ; anti

&gt;&gt; action: reify func [x] []
== ~#[frame! {action} [x]]~

&gt;&gt; action  ; not word!-active
== ~#[frame! {action} [x]]~

&gt;&gt; ap: reify :append
== ~#[frame! {ap} [series value /part /dup /line]]~

&gt;&gt; ap
== ~#[frame! {ap} [series value /part /dup /line]]~
</code></pre>
<p>What this means is that you get a similar behavior to before, where if you pass a "live" function you've fetched from a word or just generated, then it runs.  You have to do something extra to it to get it to be inert.</p>
<pre><code>&gt;&gt; array 3
== [_ _ _]

&gt;&gt; array/initial 3 10
== [10 10 10]

&gt;&gt; n: 0 array/initial 3 does [n: n + 1]
== [1 2 3]

&gt;&gt; array/initial 3 reify does [n: n + 1]
== [~#[frame! []]~ ~#[frame! []]~ ~#[frame! []]~]

&gt;&gt; array/initial 3 reify/unquasi does [n: n + 1]
== [#[frame! []] #[frame! []] #[frame! []]]
</code></pre>
<h2>
<a name="that-looks-like-an-isotope-success-story-3" class="anchor" href="https://forum.rebol.info#that-looks-like-an-isotope-success-story-3"></a>That Looks Like An Isotope Success Story...</h2>
<p>It doesn't require any convoluted thinking to get the literal vs. non-literal distinction.  And you can apply this technique to cases that don't have a weird workaround.</p>
<p>I wish I could say that all of antiform action impacts were as well sorted out as this looks.  But it's a start, and it shows the potential.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/array-initial-and-action-isotopes/1975">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/array-initial-and-action-isotopes/1975</link>
          <pubDate>Tue, 20 Sep 2022 18:53:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1975</guid>
          <source url="https://forum.rebol.info/t/array-initial-and-action-isotopes/1975.rss">ARRAY/INITIAL and ACTION! Isotopes</source>
        </item>
        <item>
          <title>Extending Contexts (OBJECT!, MODULE!, etc)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>In R3-Alpha, it is possible to append key/value pairs to objects via a block:</p>
<pre><code>&gt;&gt; obj: make object! [a: 10]
== make object! [
   a: 10
]

&gt;&gt; append obj [b: 20 c: 30]
== make object! [
    a: 10
    b: 20
    c: 30
]
</code></pre>
<p>You can't do that in Rebol2, and Red did not carry it forward.</p>
<p><strong>But in Ren-C, isotopes are not allowed in blocks.</strong>  It's more powerful if there is an operation which extends the object via a block which gets evaluated... much as the block in MAKE OBJECT! is evaluated.</p>
<p>As a general rule, APPEND should certainly not be REDUCE-ing block arguments.  So some other operation is needed</p>
<p>Red has an EXTEND operation, but it is "reserved for future use":</p>
<pre><code>USAGE:
     EXTEND obj spec

DESCRIPTION: 
     Extend an object or map value with list of key and value pairs. 
     EXTEND is a native! value.

ARGUMENTS:
     obj          [object! map!] 
     spec         [block! hash! map!] 

REFINEMENTS:
     /case        =&gt; Use case-sensitive comparison.
</code></pre>
<p>Given that it's not implemented, we don't know if that spec block is intended to be evaluated or not.  Also, we'd assume EXTEND would create a new object (since their objects don't expand).</p>
<p>Anyway, APPEND to an OBJECT! is something that probably doesn't make sense.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/extending-contexts-object-module-etc/1913">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/extending-contexts-object-module-etc/1913</link>
          <pubDate>Tue, 09 Aug 2022 22:00:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1913</guid>
          <source url="https://forum.rebol.info/t/extending-contexts-object-module-etc/1913.rss">Extending Contexts (OBJECT!, MODULE!, etc)</source>
        </item>
        <item>
          <title>FRAME! / ACTION! Duality Examined</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>The mechanics behind FRAME! and ACTION! have been mixed up and reshaped over time, to where they are very much tied together.</p>
<p>At times I've wondered if we need both types.  If ACTION!s become inert unless they are isotopic, then that would seem to blur the distinction even more... since FRAME!s have kind of been "inert actions".</p>
<p>So I thought I'd try writing up an explanation of the current state of things.</p>
<h2>First: What's a FRAME! ?</h2>
<p>You can think of a FRAME! as an object which has keys and values for the arguments and locals of a function.  There's a flag on each cell which indicates whether the object member has been "specialized out".  If the flag is set, the slot is presumed to contain the value it will have when the function runs.  Otherwise the object member is presumed to contain the type information for acquiring that parameter.</p>
<p>So when you make an ACTION! like:</p>
<pre><code>foo: func [x [integer!] y [text!] &lt;local&gt; z] [...]
</code></pre>
<p>It's internals are actually a FRAME! (called an "exemplar") that looks <em>something</em> like:</p>
<pre><code>make frame! [
    x: [integer!]  ; unspecialized
    y: [text!]  ; unspecialized
    z: ~   ; specialized
]
</code></pre>
<h2>What's The Difference Between ACTION! and FRAME!, Then?</h2>
<p>Looking at the above: <strong>you wouldn't want to try and DO a FRAME! which has type information in the argument slots</strong>.  When the code for the function runs, it's expected that X be <em>an integer instance</em>...not type information saying an integer is expected!</p>
<p>So when you MAKE FRAME! from an ACTION!, it goes through all the slots and wipes them out to be unset:</p>
<pre><code>&gt;&gt; make frame! :foo
== make frame! [
    x: ~
    y: ~
]  ; ^-- local z is not shown, as it was already specialized to a value
</code></pre>
<p>But it still has to maintain a link to the original information about the parameter types, in order to validate them.  So there's a pointer from each of these "non-exemplar" FRAME!s to the "exemplar" FRAME! with the type information.</p>
<h2>So ACTION!s are FRAME!s w/typesets in slots where args would be?</h2>
<p>Kind of.  I glossed over some details there (there's more information in the parameter description than the type block...you need to know if it's quoted, or if it's a refinement, etc.)</p>
<p>Right now every FRAME! points at an ACTION! instance.  So you can ask <strong>action of frame</strong> and get an answer.  That answer leads you to the thing that the system will use to do type checking on that frame (and you can in theory use it yourself).</p>
<p><strong>It could truthfully be said that you never execute ACTION!s, you only execute FRAME!s.</strong>  But when we say we "execute an action" all we mean is that a new frame is created for it, and then <em>that</em> frame is executed.</p>
<p>One might wonder why something like SPECIALIZE would create an ACTION! instead of just making a FRAME!.  One good reason is that this offers an opportunity to <em>completely erase</em> the specialized variables from the interface.  With the variables erased, the words become available again for use in AUGMENT-ing the composite function.</p>
<h2>So There's Some Info...</h2>
<p>Things are sort of stable with this, but a big thing on the horizon is the possibility that there might be FRAME! instances for evaluators besides actions.  So you could have a FRAME! representing just the evaluation of a BLOCK!.  (Today that's <em>sort of</em> what a VARARGS! is.)</p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/frame-action-duality-examined/1898">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/frame-action-duality-examined/1898</link>
          <pubDate>Sat, 23 Jul 2022 17:43:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1898</guid>
          <source url="https://forum.rebol.info/t/frame-action-duality-examined/1898.rss">FRAME! / ACTION! Duality Examined</source>
        </item>
        <item>
          <title>The Long-Awaited Death of /ONLY</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p><strong>As of July 2022, /ONLY is no longer a refinement available on APPEND, INSERT, CHANGE, FIND, SELECT, COMPOSE, or similar functions.</strong>  It only appears in the Redbol module <a href="https://forum.rebol.info/t/agree-to-disagree-points-places-i-see-both-sides/1862/3">through emulation</a>.</p>
<h2>
<a name="as-is-semantics-are-default-1" class="anchor" href="https://forum.rebol.info#as-is-semantics-are-default-1"></a>"AS-IS" Semantics Are Default</h2>
<p>It's easy to empathize with the historical Rebol idea of "splice blocks by default", if you only look at examples where the code is fully literal:</p>
<pre><code>append files [%foo.r %bar.r]
code: compose [... keep [sum: sum + x] ...]
</code></pre>
<p>But problems immediately strike when you start using variables that may-or-may-not-be blocks.  You can't rely on any invariants, and this leads to broken code:</p>
<pre><code>&gt;&gt; block: [#a {b} [c d e] %f]

&gt;&gt; pick block 3
== [c d e]

&gt;&gt; find block pick block 3
== ~null~  ; anti
</code></pre>
<p>Time and experience has proven that "as-is" semantics are the safest and clearest default:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c [d e]]
</code></pre>
<p>Ren-C offers a new tool for "spliced" semantics...which is to pass a GROUP! antiform ("quoting level -1").  SPREAD is the first function offered which produces them:</p>
<pre><code>&gt;&gt; spread [d e]
== ~(d e)~  ; anti

&gt;&gt; append [a b c] spread [d e]
== [a b c d e]
</code></pre>
<p>But there's nothing particularly special about SPREAD, and there will be many other options for defining functions that may-or-may-not return group antiforms...which have more parameterization and nuance.</p>
<h2>
<a name="making-the-value-carry-splicing-intent-brings-systemic-good-2" class="anchor" href="https://forum.rebol.info#making-the-value-carry-splicing-intent-brings-systemic-good-2"></a>Making The Value Carry Splicing Intent Brings Systemic Good</h2>
<p>The benefits are everywhere, with safer defaults and clear choices...for instance in REPLACE:</p>
<pre><code>&gt;&gt; replace/all [[a b] a b a b] [a b] [c d e]
== [[c d e] a b a b] 

&gt;&gt; replace/all [[a b] a b a b] spread [a b] [c d e]
== [[a b] [c d e] [c d e]]

&gt;&gt; replace/all [[a b] a b a b] [a b] spread [c d e]
== [c d e a b a b]

&gt;&gt; replace/all [[a b] a b a b] spread [a b] spread [c d e]
== [[a b] c d e c d e]
</code></pre>
<p>Branching code can make decisions to splice-or-not-splice on a case by case basis:</p>
<pre><code>&gt;&gt; code: [&lt;splice&gt; [a b] &lt;no-splice&gt; [c d] &lt;no-splice&gt; 'x]

&gt;&gt; map-each [instruction item] code [
       switch instruction [
            &lt;splice&gt; [spread item]
            &lt;no-splice&gt; [item]
            fail ["Bad instruction:" instruction]
       ]
   ]
== [a b [c d] 'x]
</code></pre>
<p>And COMPOSE can have some slots that splice and others that do not, within the same operation:</p>
<pre><code>&gt;&gt; data: [a b]

&gt;&gt; compose [spliced (spread data) non-spliced (data)]
== [spliced a b non-spliced [a b]]
</code></pre>
<p>(COMPOSE is a case where not splicing by default is glaringly obvious as the right choice for a generic operation.)</p>
<h2>
<a name="antiform-parameter-conventions-should-be-used-sparingly-3" class="anchor" href="https://forum.rebol.info#antiform-parameter-conventions-should-be-used-sparingly-3"></a>Antiform Parameter Conventions Should Be Used <em>Sparingly</em>!</h2>
<p>Routines that do not intend to react to an antiform should generally not take them as parameters.</p>
<p>As a good example, REDUCE might seem like the kind of thing that could act on group antiforms:</p>
<pre><code>&gt;&gt; append [a b c] reduce spread [1 + 2 3 + 4]
== [a b c 3 7]
</code></pre>
<p>But we want to avoid this temptation, to stop the "spread" of antiforms to touching parts of the system that should not be concerned with them.  So exercise restraint here...and shift the burden on the calling code to reshape itself so that antiforms only exist at the points that are very close to the calls they affect:</p>
<pre><code>&gt;&gt; append [a b c] spread reduce [1 + 2 3 + 4]
== [a b c 3 7]
</code></pre>
<h2>
<a name="good-riddance-only-4" class="anchor" href="https://forum.rebol.info#good-riddance-only-4"></a>Good Riddance /ONLY</h2>
<p>The elimination of /ONLY from the semantic model, and to have it not contaminate the user's heads, means that people can learn more generic tools that work in more contexts.</p>
<p>Its appearance in Ren-C will be limited to the Redbol compatibility module.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/the-long-awaited-death-of-only/1607">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-long-awaited-death-of-only/1607</link>
          <pubDate>Thu, 21 Jul 2022 04:00:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1607</guid>
          <source url="https://forum.rebol.info/t/the-long-awaited-death-of-only/1607.rss">The Long-Awaited Death of /ONLY</source>
        </item>
        <item>
          <title>Stackless Is Here, Today, Now! :pancakes:</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>I've explained why we need stacklessness:</p>
<p><strong><a href="https://forum.rebol.info/t/switching-to-stackless-why-this-why-now/1247">Switching to Stackless: Why this, why now?</a></strong></p>
<p>It's taken a lot of thinking.  But as proof that it's real, you can try this:</p>
<pre><code>&gt;&gt; counter: func [value] [
      if 0 = modulo value 1000 [print [value]]
      counter value + 1
  ]
</code></pre>
<p>How many stack levels you get will depend on the available memory of your platform--not your CPU stack.</p>
<p>In the WebAssembly build that runs in the browser, I got this on Chromium on Linux:</p>
<pre><code>&gt;&gt; counter 0
0
1000
2000
3000
4000
5000
6000
7000
8000
9000
10000
11000
12000
13000
14000
15000
16000
17000
</code></pre>
<p>It just terminates, but the error that shows up in the browser console is:</p>
<blockquote>
<p>Uncaught RuntimeError: Aborted(Cannot enlarge memory arrays to size 16867328 bytes (OOM). Either (1) compile with -sINITIAL_MEMORY=X with X higher than the current value 16777216, (2) compile with -sALLOW_MEMORY_GROWTH which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with -sABORTING_MALLOC=0)</p>
</blockquote>
<p>The same amount was gotten on Firefox, probably because emscripten requests the same amount of Wasm memory space on each.</p>
<h2><a name="p-5933-point-is-it-ran-out-of-memory-not-stack-1" class="anchor" href="https://forum.rebol.info#p-5933-point-is-it-ran-out-of-memory-not-stack-1"></a>Point Is, It Ran Out of Memory... not Stack!</h2>
<p>We can see there's work to do on responding to out-of-memory errors (we've never really had a great story for that).  <em>But at least we can (!)</em> -- I've explained already that stack overflows can't be caught the way a failed memory allocation can.  That's a huge motivator for the change.</p>
<p>But still, over 17000 stack levels is kind of neat in and of itself!</p>
<p>So how do desktop executables "stack up", on my 16-core Lenovo ThinkPad i7 with 64GB of memory...?</p>
<p>As a quick comparison: for Red on Windows, it doesn't make it to 2000:</p>
<pre><code>red&gt;&gt; counter 0
0
1000
*** Internal Error: stack overflow
*** Where: %
*** Stack: counter counter counter counter counter counter counter counter coun
ter counter counter counter counter counter counter counter counter counter cou
nter counter counter counter counter counter counter counter counter counter co
unter counter counter coun...
</code></pre>
<p>Running an actual count got me to 1943 and then it crashed.</p>
<p><em>(I take it that encountering a stack overflow -during- a PRINT leads them to a harsher situation than just during a recursion.  But this is all the more reason you can't play fast-and-loose with the CPU stack, it cannot be trapped like an out of memory error!  Right now we may be crashing too, but it's substantially closer to being managed.)</em></p>
<p>For Rebol2 on Windows it makes it to 14262, and does not crash.  (So Red's an order of magnitude worse, and crashes.)</p>
<p>I hadn't built a 32-bit optimized Windows executable for a while (and actually had to fix a couple of compiler warnings to get one).  But I figured I'd do so for an apples-to-apples comparison with the Rebol2 and Red EXEs.</p>
<p>32-bit Ren-C makes it to...well, jeez.  Printing it out one by one could go on forever, so I tried only doing a print on modulo 10,000.  It starts to slow down a bit around 2 million, but ticks past 3 million pretty easily...and makes it to 4 million.  It eventually terminates without a message at 4780000 (it's an optimized build, and our out-of memory handling needs work...this would likely be an assert in a debug build).</p>
<p>So generously rounding Red up to 2,000... Ren-C can handle over 2000x the stack levels, at least.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-5933-now-to-reap-the-benefits-2" class="anchor" href="https://forum.rebol.info#p-5933-now-to-reap-the-benefits-2"></a>Now, To Reap The Benefits...</h2>
<ul>
<li>
<p><strike>I need to rework the JavaScript extension to use this intrinsic stackless property, instead of "Asyncify".</strike>  DONE!</p>
<ul>
<li>
<p>Asyncify gave us the pseudo-stackless ability of suspending arbitrary non-stackless code in order to run browser events.  This let us do things like ASK for input while in the middle of a loop.  With real stackless, we (shouldn't) need that.</p>
</li>
<li>
<p>Asyncify added bloat to our code generation that I recall making the .wasm about double the size.  We'll see how accurate my memory is on that, but hopefully the size of libr3.wasm will go way down.</p>
</li>
</ul>
</li>
<li>
<p><strike>One by one the natives have to be redone to stackless.  Only then can we truly ditch Asyncify, because if something like FOR-EACH isn't stackless we wouldn't be able to do something like PRINT or ASK inside of that kind of loop... it would raise an error.</strike>  MOSTLY DONE!</p>
<ul>
<li>
<p>We can probably punt on some things and drop asyncify even if not everything is stackless yet.</p>
</li>
<li>
<p>You might not be able to do something like <strong><code>foo.(ask "Field Name?"): 10</code></strong> until TUPLE! lookup has stackless processing bubble up through its GROUP! evaluations, but I think we can live with that being an error for a while--if it halves the size of the wasm.</p>
</li>
</ul>
</li>
<li>
<p>Generators and Yielders need to be resurrected.  They were pretty well designed before, but locking issues created headaches...and it's time to attack those again.</p>
</li>
<li>
<p>Out-of-memory errors have to be reined in--not just so stack overflows can be handled gracefully, but that any kind of out-of-memory is handled gracefully!</p>
<ul>
<li>We also might want users to be able to set a policy (if they wish) to limit the stack before memory runs out, just so that infinite recursions get caught earlier in casual programs that aren't intentionally using big stacks.</li>
</ul>
</li>
</ul>
<p>In any case, it feels good to get the core of the work done two years ago hammered into shape...and see it running in the browser!</p>
            <p><small>5 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/stackless-is-here-today-now/1844">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/stackless-is-here-today-now/1844</link>
          <pubDate>Fri, 17 Jun 2022 14:58:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1844</guid>
          <source url="https://forum.rebol.info/t/stackless-is-here-today-now/1844.rss">Stackless Is Here, Today, Now! :pancakes:</source>
        </item>
        <item>
          <title>Is GROUP! in PATH! for function invocations worth it?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>Back in the day, I thought it would be neat to allow you to put GROUP!s in paths.  So you could do things like this:</p>
<pre><code>append/(if condition ['only]) [a b c] [d e]
</code></pre>
<p>It turned out to be of fairly limited use.  Really you could only use it with refinements that didn't take parameters, because it changes the "shape" of the execution stream.  Consider how you would make the following sensible:</p>
<pre><code>append/(if condition ['dup]) [a b c] [d e] ???
</code></pre>
<p>When the condition is true you want something in the ??? spot.  When it's false you don't.  How can your code cover both cases?</p>
<h2><strong><a href="https://forum.rebol.info/t/apply-ii-the-revenge/1406/3">Now we have a modern APPLY</a></strong></h2>
<p>It bends some of the raw frame rules, and lets you use LOGIC! for parameterless refinements:</p>
<pre><code>apply :append [[a b c] [d e] /only condition]
</code></pre>
<p>It's a bit longer.  And we haven't really firmed up questions like whether you need the GET-WORD! or if it's soft quoted by default.  Or if there might be some clever shorthand:</p>
<pre><code>($ append [a b c] [d e] /only condition)
</code></pre>
<h2>I'm In A Mood To Kill Off Lesser-Loved Features <img src="https://forum.rebol.info/images/emoji/twitter/hocho.png?v=9" title=":hocho:" class="emoji" alt=":hocho:">
</h2>
<p>All things being equal, it might seem nice to support.  But every feature has a cost!</p>
<p><strong>You'd still be able to put GROUP!s in paths for your own purposes, but refinement dispatch in functions wouldn't use it.</strong></p>
<p>You could also use DO of COMPOSE'd code if you really wanted to:</p>
<pre><code>do compose/deep [
    append/(if condition ['only]) [a b c] [d e]
]
</code></pre>
<p>So if anyone has a good argument for keeping the function dispatch behavior, speak up now!</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/is-group-in-path-for-function-invocations-worth-it/1813">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/is-group-in-path-for-function-invocations-worth-it/1813</link>
          <pubDate>Fri, 13 May 2022 04:35:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1813</guid>
          <source url="https://forum.rebol.info/t/is-group-in-path-for-function-invocations-worth-it/1813.rss">Is GROUP! in PATH! for function invocations worth it?</source>
        </item>
        <item>
          <title>Conflation vs. Safety, RETURN and &quot;Heavy&quot; Void/Null</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>"Heavy" void and null are a novel solution shaped to solve a specific problem.  As a reminder of what the goal is...</p>
<h1>
<a name="the-goal-is-to-please-rgchris-and-please-me-1" class="anchor" href="https://forum.rebol.info#the-goal-is-to-please-rgchris-and-please-me-1"></a>The Goal is to Please <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> <em>AND</em> Please me</h1>
<p>NULL is the signal of "soft failure".  It's a unique result when a loop is halted by a BREAK, when PARSE fails...etc.  VOID is the signal of "nothingness", which is the product of conditional expressions that don't take a branch.  Neither can be stored in blocks.</p>
<p>NULL's property of not being storable in blocks makes it critical to disambiguating this historical problem:</p>
<pre><code>redbol&gt;&gt; third [a b #[none]]
== #[none]

redbol&gt;&gt; third [a b]
== #[none]
</code></pre>
<p>In a language that prides itself on letting you work with code structure, <em>this is the tip of the iceberg of the problems that null solves</em>, and you will find the distinction's utility across the board (obviously, in tools like COMPOSE).  It facilitates rigorous analysis and rearrangements...without needing to drop to C or write convoluted code:</p>
<pre><code>&gt;&gt; third [a b _]
== _

&gt;&gt; third [a b]
; null
</code></pre>
<p>Hence NULL and VOID have taken the place of blank ("none!") in many places.  <em>(See <a href="https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942">BLANK! 2022, Revisiting the Datatype</a> for a summary.)</em></p>
<p>But unlike the elements in a block, a branch that evaluates isn't required to be non-NULL or non-VOID.  Which leads us to the long running question of what to bend these branches to so they don't conflate with the branch-not-taken result.</p>
<h2>
<a name="chris-has-rightly-expressed-concern-2" class="anchor" href="https://forum.rebol.info#chris-has-rightly-expressed-concern-2"></a>Chris has (rightly) expressed concern</h2>
<p>At times I've said that it's not that big a deal that branches can't evaluate to NULL and get distorted.  "You didn't have NULL before at all, so why get so worked up about control constructs not returning it?"</p>
<p>But the now-pervasive nature of NULL means it can't be avoided.  So:</p>
<p><em>"How do you express branching code which wants to do some work but also produce NULL as an evaluative product?"</em></p>
<p>Conflation was not a problem, e.g. in Rebol2:</p>
<pre><code>rebol2&gt;&gt; exampler: func [x] [
     print "returning sample or none if not found"
     case [
         x = &lt;string&gt; [print "sample string" {hello}]
         x = &lt;integer&gt; [print "sample integer" 3]
         x = &lt;none&gt; [print "sample none" none]
     ]
  ]

rebol2&gt;&gt; exampler &lt;string&gt;
returning sample or none if not found
sample string
== "hello"

rebol2&gt;&gt; exampler &lt;blatz&gt;
returning sample or none if not found
== #[none]

rebol2&gt;&gt; exampler &lt;none&gt;
returning sample or none if not found
sample none
== #[none]
</code></pre>
<p>However NULL is now a basic currency of "soft failure".  As such it would not be uncommon to be in the situation where a branching decision process would want to intentionally return NULL as part of the work it does.</p>
<p>Without a mechanism to address this, unpleasant convolutions would be needed, for instance surrounding anything that wanted to tunnel a NULL with a CATCH and THROW'ing it:</p>
<pre><code>x: catch [
    throw switch 1 + 2 [
        1 [print "one" 1]
        2 [print "two", &lt;two&gt;]
        3 [print "three", throw null]
     ]
]
</code></pre>
<p>Definitely not good.  But regarding the pleasing-me-part, remember I am trying to avoid this situation:</p>
<pre><code>&gt;&gt; block [a b]

&gt;&gt; case [
     true [
          print "case branch"
          item: third block
     ]
   ] else [
     print "else branch"
   ]

case branch
else branch  ; ugh
</code></pre>
<p>I don't want the CASE branch to evaluate to NULL just because some expression in the branch was incidentally NULL.  That would mean the ELSE tied to the CASE runs even though the code for the branch ran.</p>
<h2>
<a name="enter-heavy-forms-packs-with-one-element-3" class="anchor" href="https://forum.rebol.info#enter-heavy-forms-packs-with-one-element-3"></a>Enter Heavy Forms: PACKs with One Element</h2>
<p>One thing a "heavy" void has in common with a "plain" void is that neither can be put in blocks.  But it automatically "decays" into regular VOID when stored into variables.</p>
<pre><code>&gt;&gt; if true [void]
; first in pack of length 1

&gt;&gt; x: if true [void]

&gt;&gt; x
</code></pre>
<p>The twist is that the heavy void is <em>different enough</em> from true VOID such that a THEN or an ELSE can consider them a situation where the branch did not run:</p>
<pre><code>&gt;&gt; if false [&lt;ignored&gt;]

&gt;&gt; if true [void]
; first in pack of length 1

&gt;&gt; if true [void] else [print "This won't run"]
</code></pre>
<p>The reason functions like ELSE can "see" the isotope is that they don't take an ordinary parameter on their left.  They take a ^META argument.  These can see the distinction between a void in an isotopic pack and a "true" VOID.</p>
<p><strong>I'd largely say this has been working well...certainly better than its conceptual predecessors.</strong>  It makes piping VOID (or NULL) out of branches trivially easy, when the fear of conflation is not a problem.</p>
<pre><code>&gt;&gt; x: switch 1 + 2 [
     1 [print "one" 1]
     2 [print "two", &lt;two&gt;]
     3 [print "three", null]
   ]
three
; first in pack of length 1
== ~null~

&gt;&gt; x
; null
</code></pre>
<p>The automatic decay in variable storage prevents you from needing an explicit operation to turn ~null~ isotopes into pure nulls:</p>
<pre><code>&gt;&gt; x: decay switch 1 + 2 [
     1 [print "one" 1]
     2 [print "two", &lt;two&gt;]
     3 [print "three", null]
   ]
three
; null
</code></pre>
<h1>
<a name="non-meta-arguments-decay-null-isotopes-4" class="anchor" href="https://forum.rebol.info#non-meta-arguments-decay-null-isotopes-4"></a>Non-Meta Arguments Decay Null isotopes</h1>
<p>The "auto-decay" of heavy ~null~ means no variable can ever hold one.  And there's also a rule that no <em>normal</em> parameter can ever be passed a "pack" like the heavy forms, only ^META parameters.</p>
<p>So it seems useful if normal arguments would automatically decay null isotopes:</p>
<pre><code>&gt;&gt; foo: func [x] [if null? x [print "Yup, it's null"]]

&gt;&gt; foo if true [null]
Yup it's null

&gt;&gt; metafoo: func [^x] [
    case [
        null? x [print "regular null"]
        x = '~[~null~]~ [print "heavy null"]
        true [print "something else"]
     ]
   ]

&gt;&gt; metafoo if false [null]
regular null

&gt;&gt; metafoo if true [null]
heavy null
</code></pre>
<p>There is a manual DECAY operator which can be used at non-parameter moments where you want to decay a heavy null:</p>
<pre><code>&gt;&gt; if true [null]
; first in pack of length 1
== ~null~  ; isotope

&gt;&gt; decay if true [null]
== ~null~  ; isotope
</code></pre>
<h1>
<a name="func-return-only-decays-if-you-have-a-return-spec-5" class="anchor" href="https://forum.rebol.info#func-return-only-decays-if-you-have-a-return-spec-5"></a>Func RETURN Only Decays If You Have A RETURN: Spec</h1>
<p>Consider this pattern:</p>
<pre><code>foo: func [x] [
    return switch x [
         1 [print "one", #one]
         2 [print "two", null]
         3 [print "three", &lt;three&gt;]
    ]
]

&gt;&gt; foo 1 + 2
two
== ???   ; should this be heavy null or just null?
</code></pre>
<p>Once upon a time, decaying was the default, and there was a refinement called /ISOTOPE on RETURN which asked it not to decay.</p>
<p>Today, there is no automatic decay <em>unless</em> you have a return spec that doesn't mention PACK?s.  So <strong>return: [any-value?]</strong> would be enough to get the auto-decay.</p>
<h2>
<a name="hopefully-it-all-makes-sense-6" class="anchor" href="https://forum.rebol.info#hopefully-it-all-makes-sense-6"></a>Hopefully It All Makes Sense</h2>
<p><em>"A designer knows he has achieved perfection not when there is nothing left to add, but when there is nothing left to take away."</em></p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/conflation-vs-safety-return-and-heavy-void-null/1799">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/conflation-vs-safety-return-and-heavy-void-null/1799</link>
          <pubDate>Thu, 07 Apr 2022 04:14:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1799</guid>
          <source url="https://forum.rebol.info/t/conflation-vs-safety-return-and-heavy-void-null/1799.rss">Conflation vs. Safety, RETURN and &quot;Heavy&quot; Void/Null</source>
        </item>
        <item>
          <title>Should END-able constructs all use ^META parameters?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>R3-Alpha and Rebol2 could only have functions that were "endable" if the argument they took was quoted.  This feature was added primarily for HELP, so that you could say either:</p>
<pre><code>&gt;&gt; help
; (would display generic HELP usage information)

&gt;&gt; help topic
; (would display help for the given topic)
</code></pre>
<p>It was a <em>very limited form of variadic-ness</em>...generally used only in console-oriented commands (HELP, LS).  You couldn't write a function that was evaluative, like:</p>
<pre><code>redbol&gt;&gt; printer 1 + 2
3

redbol&gt;&gt; printer
You called the PRINTER function with no arguments
    ; ^-- not possible to accomplish with an otherwise evaluative argument!
</code></pre>
<p>Being able to handle getting to the end of input was entwined with taking quoted arguments.</p>
<h2>
<a name="ren-c-added-end-able-evaluative-parameters-1" class="anchor" href="https://forum.rebol.info#ren-c-added-end-able-evaluative-parameters-1"></a>Ren-C added <code>&lt;end&gt;</code>-able Evaluative Parameters</h2>
<p>To facilitate certain demos in Ren Garden, Ren-C could mark an ordinary parameter as being <code>&lt;end&gt;</code>-able.  This would mean that the argument would show up as being NULL if the end was reached before an argument was seen.</p>
<p>This was--however--ambiguous with if you actually passed an evaluative NULL.</p>
<pre><code>ren-c&gt;&gt; printer 1 + 2
3

ren-c&gt;&gt; printer
You called the PRINTER function with no arguments

ren-c&gt;&gt; printer null  
You called the PRINTER function with no arguments  ; d'oh
</code></pre>
<p><strong>This kind of ambiguity wasn't new...the Redbol version had it.</strong>  The signal for quoted parameters that were endable-and-missing was to make the parameter an UNSET!.  Which meant they couldn't tell the difference between <strong>help #[unset!]</strong> and just-plain-help:</p>
<pre><code>red&gt;&gt; help #[unset!]
To use HELP, supply a word or value as its
argument:

    help insert
    help system
    help system/script

To view all words that...
</code></pre>
<p><strong>Interestingly enough, Ren-C has a solution for this with quoted parameters, because NULL cannot appear literally in source...so it can't be at the callsite.  Thus NULL can represent a missing quoted argument.</strong>  Which is neat.</p>
<h2>
<a name="meta-parameters-can-do-end-another-way-2" class="anchor" href="https://forum.rebol.info#meta-parameters-can-do-end-another-way-2"></a>^META parameters can do <code>&lt;end&gt;</code> another way...</h2>
<p>A meta parameter is quoted, but will be a quoted void if the callsite was passing a void:</p>
<p>So if our PRINTER took a ^META argument:</p>
<pre><code>&gt;&gt; printer 1 + 2
3
; (it actually received '3, quoted)

&gt;&gt; printer '
You called the PRINTER function with no arguments
; (it actually received ')
</code></pre>
<p>The ambiguity is still there, though...</p>
<pre><code>&gt;&gt; printer void
You called the PRINTER function with no arguments
; (again, it actually received ')
</code></pre>
<p><strong>But at least you could differentiate NULL from an end.</strong>  The conflation of an invisible argument with the end doesn't seem as troubling to me, as the problem with HELP is fixed since it quotes and can tell when you say <strong>help void</strong> vs. plain <strong>help</strong></p>
<h2>
<a name="killing-off-end-as-a-core-parameter-flag-would-simplify-things-3" class="anchor" href="https://forum.rebol.info#killing-off-end-as-a-core-parameter-flag-would-simplify-things-3"></a>Killing off <code>&lt;end&gt;</code> as a core parameter flag would simplify things...</h2>
<ul>
<li>
<p>If a quoted parameter tolerates NULL as one of its legal types that's sufficient to say it is "endable"</p>
</li>
<li>
<p>If an evaluative parameter needs to detect endability, it could be your job to make it a ^META parameter and look for void, and unquote it to handle other results.</p>
</li>
</ul>
<p>The code and typeset flags for <code>&lt;end&gt;</code> could then be scrapped.</p>
<p>If someone really liked the NULL conflating version of endability they could write something to do it in usermode.</p>
<p><strong>You'd have to see the code to understand why I would think throwing away <strong><code>&lt;end&gt;</code></strong> is worth it.</strong> The way the type checking is done frames have to be filled first, which means if a function doesn't want an actual null but wants just ends to reflect as null... or wants an actual null but doesn't want ends reflected as null... hidden bits need to be grafted onto these nulls at the time of frame fulfillment to say whether it's an "endish" null or a regular null.  Various parts of the system then need to test a NULL for this invisible property.  <strong>^META parameters pull such invisible state into the light.</strong></p>
<p><strong>Basically take my word for it: meta is much cleaner, and offers a way to expose these distinctions to the user--so I think the odds are that <code>&lt;end&gt;</code> and its current mechanics need to die.</strong></p>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-end-able-constructs-all-use-meta-parameters/1783">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-end-able-constructs-all-use-meta-parameters/1783</link>
          <pubDate>Fri, 21 Jan 2022 17:01:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1783</guid>
          <source url="https://forum.rebol.info/t/should-end-able-constructs-all-use-meta-parameters/1783.rss">Should END-able constructs all use ^META parameters?</source>
        </item>
        <item>
          <title>DEFAULT with TUPLE!...What Does It *Mean*?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>The ability to have random side-effects in tuples creates all kinds of nasty potentials.</p>
<p>That is why I made a way to say you only allow tuples to contain evaluations if you also ask for an "invariant" representation of the path to be returned...that you could use in place of the tuple for further assignments.</p>
<pre><code>&gt;&gt; var: 'x

&gt;&gt; tuple: 'obj.(print "side effect" var)

&gt;&gt; set tuple 30
*** Script Error: GROUP!s require /GROUPS in GET or SET:
    obj.(print "side effect" var)

&gt;&gt; [value steps]: set tuple 30
side effect
== 30

&gt;&gt; steps
== @[obj x]
</code></pre>
<p>You can then use STEPS instead of the tuple.  e.g. <strong>set @[obj x]</strong> will act like <strong>set 'obj.x</strong>.  (The reason a BLOCK! is used is because not all datatypes would be legal in tuples...a GROUP! could evaluate to anything, like an OBJECT!...which is a perfectly valid thing to set in a MAP! for instance.)</p>
<h2>
<a name="this-invariant-form-was-intended-for-things-like-default-1" class="anchor" href="https://forum.rebol.info#this-invariant-form-was-intended-for-things-like-default-1"></a>This "Invariant" Form Was Intended For Things Like DEFAULT</h2>
<p>The concept was that even if you have evaluations on the left hand side, you will be able to capture where it got the value or absence-of-value from...and then in the event you need to write it back because a default is necessary, you don't have to run the evaluation again:</p>
<pre><code>&gt;&gt; n: 5

&gt;&gt; data.(n: n + 1): default [10]
</code></pre>
<p>Internally, DEFAULT can make a GET request of <strong>data.(n: n + 1)</strong> and get back STEPS with a fixed value for N, like <strong><code>@[data 6]</code></strong>.  If it discovers that the value is set to null and needs defaulting, it can then use the steps instead of the tuple as the basis for the SET...so N is not changed twice.</p>
<h2>
<a name="but-other-things-can-change-2" class="anchor" href="https://forum.rebol.info#but-other-things-can-change-2"></a>But Other Things Can Change...</h2>
<p>All kinds of changes can happen between the GET and the SET in DEFAULT.  What about this?</p>
<pre><code>&gt;&gt; data.(n: n + 1): default [data: ~gone~, 10]
</code></pre>
<p>We've prevented running imperative code and getting side effects from the tuple...but the side effects can come from other places.  <strong>Anything you do between the GET and the SET can make the "invariant" steps not so invariant.</strong></p>
<p>Let's say DATA was a BLOCK! at the outset.  Should the <strong><code>@[...]</code></strong> steps have actually stored a reference to the block instead of the WORD! data, so that changes to the variable couldn't redirect the invariant reference?</p>
<p>That doesn't work for immediate types.  Let's say you have:</p>
<pre><code>&gt;&gt; time: 4:00

&gt;&gt; tuple: 'time.(if true ['hour])

&gt;&gt; [# steps]: set tuple 12
== 12

&gt;&gt; steps
== @[4:00 hour]
</code></pre>
<p>Now you can't use that steps to go back and change the original time, because 4:00 is an immediate value.  You need to get at the object the time lives in.  You'd wind up with a 3-element steps in that case:</p>
<pre><code>&gt;&gt; steps
== @[make object! [...] time hour]
</code></pre>
<h2>
<a name="if-nothing-is-going-to-be-perfect-should-we-shortcut-it-3" class="anchor" href="https://forum.rebol.info#if-nothing-is-going-to-be-perfect-should-we-shortcut-it-3"></a>If Nothing Is Going To Be Perfect... Should We Shortcut It?</h2>
<p>Let's say you have a tuple like:</p>
<pre><code>obj1.obj2.(if true [obj3]).obj4.date.time
</code></pre>
<p>We could say that the "steps" are:</p>
<pre><code>@[obj1 obj2 [...this is obj3...] obj4 date time]
</code></pre>
<p>But is that empirically more desirable than just noticing when we cross the line from non-immediate values into immediate values, and preserving only as much as we need?</p>
<pre><code>@[(make object! [...this is obj4...]) date time]
</code></pre>
<p>That's enough to write back to obj4...but it is fully disconnected from the tuple that was initially being represented.  <strong>But which is more suitable for the intent of something like DEFAULT?</strong></p>
<h2>
<a name="my-head-hurts-face_with_head_bandage-4" class="anchor" href="https://forum.rebol.info#my-head-hurts-face_with_head_bandage-4"></a>My Head Hurts <img src="https://forum.rebol.info/images/emoji/twitter/face_with_head_bandage.png?v=12" title=":face_with_head_bandage:" class="emoji" alt=":face_with_head_bandage:" loading="lazy" width="20" height="20">
</h2>
<p>...and it's not because of a booster shot.  It's because this is crazy, and way past the point of being fun.</p>
<p>What started out as a nice idea for taming GROUP!s in TUPLE!s becomes a real headache.</p>
<p><strong>So I'm going to leave well enough alone, and say that this does only that.</strong>  If you want to prune a tuple to get better invariants, that's on you:</p>
<p>For example:</p>
<pre><code>(obj1.obj2.obj3.obj4).date.time: default [...]
</code></pre>
<p>When you do this, then when DEFAULT asks for steps it will get 3 items in the block:</p>
<pre><code>&gt;&gt; steps
== @[(make object! [...]) date time]
</code></pre>
<p>It has latched onto the object, and so you can say inside the body of the defaulting code things like <strong><code>obj1: null</code></strong> or <strong>obj1.obj2.obj3: []</strong> and the assignment will apply to what it was looking at, because those names aren't in the steps.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/default-with-tuple-what-does-it-mean/1770">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/default-with-tuple-what-does-it-mean/1770</link>
          <pubDate>Sat, 11 Dec 2021 23:58:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1770</guid>
          <source url="https://forum.rebol.info/t/default-with-tuple-what-does-it-mean/1770.rss">DEFAULT with TUPLE!...What Does It *Mean*?</source>
        </item>
        <item>
          <title>The Pathing and Picking Predicament Pans Out</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <h2>TL;DR</h2>
<p>I'm changing path dispatch to be fundamentally recursive, and via a unified action dispatcher called <strong><code>PICK-POKE*</code></strong>.  As fate would have it, this takes a longstanding annoying edge case in how R3-Alpha methodized path dispatch for GOB!...and makes that "the answer" for how all path dispatch is done.  Additionally:</p>
<ul>
<li>
<p>It employs FRAME! reuse for native dispatch, which allows a memory use profile similar to the the "PVS" (Path Value State?) structure from R3-Alpha...even though it's making recursive evaluator calls.</p>
</li>
<li>
<p>This makes path dispatch just ordinary function dispatch, which means pathing doesn't need special accommodation in stackless.</p>
<ul>
<li>Sidenote: Path dispatch and PARSE were two extremely troublesome areas in the stackless conversion.  Both are being addressed by pushing more and more "custom" recursive C code to do their recursions by means of the interpreter's evaluator loop.</li>
</ul>
</li>
<li>
<p>It should mean that user-defined data types--or even in the near term perhaps your own OBJECT!s--could customize pathing if they wanted to <em>(though we may limit customization to <strong><code>/</code></strong> access in order to provide terra firma for accessing the object)</em></p>
</li>
</ul>
<h2>Preface: No One Has Done This Right (Until Now)</h2>
<p>Before we get carried away and give GOB! too much credit...  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>Redbols try to be bit fiddly and pack things into immediate cell values.  But if you're going to be that fiddly, you have to remember that "updating a value" really means "updating the container the value lives in".</p>
<p>Random example from Red and Rebol2:</p>
<pre><code>red&gt;&gt; b: [x 12-Dec-2021/10:00 y]
== [x 12-Dec-2021/10:00:00 y]

red&gt;&gt; b/2/time/hour
== 10

red&gt;&gt; b/2/time/hour: 20
== 20

red&gt;&gt; b
== [x 12-Dec-2021/10:00:00 y]  ; still 10:00, not 20:00
</code></pre>
<p><em>(R3-Alpha is worse, giving an error and corrupting the time.)</em></p>
<p>The reason this happens is because DATE! fits in a cell with the TIME! packed into it.  If you ask for a date's /TIME then you get a synthesized new cell to hold it.  But poking back into that synthesized cell won't change the original date.</p>
<p>Hence every SET-PATH! or POKE has to offer a kind of backflow in the chain of poking, in case any of the forward writes require bit updates backwards.  Frame reuse allows that to be made somewhat efficient with one cell's worth of stack, while PICK can use a <a href="https://stackoverflow.com/questions/22037261/what-does-sibling-calls-mean">"sibling tail call"</a>.</p>
<p>The Ren-C I'm working on takes care of the above example, and should generalize to others!</p>
<h2>Now, Explanation.  Background:</h2>
<p>Path Dispatch--or <strong>"PD"</strong> as R3-Alpha called it--was a concept fraught with issues.</p>
<p>On the surface it seems like a simple chain...it's broken into steps where each one produces a value that is picked by the next step:</p>
<pre><code>&gt;&gt; outer: make object! [inner: make object! [block: [a b c]]]

&gt;&gt; outer/inner/block/2  ; expressed as a path
== b

&gt;&gt; pick (pick (pick outer 'inner) 'block) 2  ; expanded as picks
== b

; Note: Historical Rebol required a mix of SELECT and PICK, Ren-C unifies it
</code></pre>
<p>How "hard" is that?  Well, it's not <em>that</em> hard, though it could be very wasteful.</p>
<p>Imagine the FFI with <strong>some-struct.million-int-array.1</strong>.  If that's an FFI interface to a struct with a million C int in it, do you have to generate a BLOCK! of a million INTEGER! just to pick the first one?  That's what the naive translation of pathing to step-by-step PICK calls would do.</p>
<p>Even without talking about efficiency, we can talk about semantics.  <strong>PICK at least works out semantically for pathing, but POKE does not.</strong>  Try this:</p>
<pre><code>&gt;&gt; outer/inner/block: [i am a new block]
== [i am a new block]

&gt;&gt; poke (pick (pick outer 'inner) 'block) [i am a new block]
** Error, wait a second...
</code></pre>
<p>That second formulation is <em>not</em> equivalent...because the PICK gave back a plain old block.  So it saw:</p>
<pre><code>&gt;&gt; poke [a b c] [i am a new block]
</code></pre>
<p><strong>This faces the problem that Rebol lacks "Reference" types.</strong> POKE wanted a place to put the new block...effectively the <em>address</em> of the block value in the inner object.  But it just got back the <em>value</em> of the block in the inner object.</p>
<h2>Could Rebol Have A Reference Type?</h2>
<p>Hypothetical code:</p>
<pre><code>&gt;&gt; obj: make object! [field: "I am a field"]

&gt;&gt; ref: &amp;obj.field
== &amp;"I am a field"

&gt;&gt; ref: "Field is replaced!"

&gt;&gt; obj
== make object! [field: "Field is replaced!"]
</code></pre>
<p>In such a world, changing REF didn't change the string... <em>it changed a field in the object the string lived in</em>.</p>
<p>This is the kind of mechanic that pathing would need if it were to be extensible and truly generic. What each step in the path offered up to the next would have to be a means of writing back to the field if it wanted to.</p>
<p>That sounds like a nightmare...but it wouldn't even solve the problem if it could be done, because...</p>
<h2>...Subaddressing Makes It Worse!</h2>
<p>Some of the more confusing pats of path dispatch dealt with the fact that path steps might be producing something that didn't reference a full value at all...but some optimized bit pattern.</p>
<pre><code>&gt;&gt; obj: make object! [gob: make gob! [x: 10 y: 20]]

&gt;&gt; obj.gob.size.x: 304
== 304
</code></pre>
<p>What's so weird about that?  Well, GOB! stores its bits compactly, so there is no INTEGER! cell for the X, and no PAIR! cell for the size.</p>
<p>This is all easy enough on the PICK side... you ask the GOB! what its size is, and it tells you 10x20 as a new PAIR! it makes out of thin air.  Then you ask that pair what its X is and it tells you 10.</p>
<p>But on the POKE side, <em>even if you had the address mechanic</em>, there's no address of a value that the GOB! can give for that PAIR! to let you write back to it.</p>
<h2>GOB! in R3-Alpha Actually Had The Right Idea...Sort Of</h2>
<p>With path dispatchers like R3-Alpha's <strong><a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/t-block.c#L530">PD_Block()</a></strong> that it has a "picker" (<strong>pvs-&gt;select</strong>) which it is applying to the value that's a BLOCK! or GROUP! (<strong>pvs-&gt;out</strong>).  It trusts that the "path engine" has pre-evaluated any code in parentheses if necessary to get pvs-&gt;select.</p>
<p>Then it has the detail that if <strong>pvs-&gt;setval</strong> is not null, it needs to know it's a SET-PATH!.  This is also something the path engine works out...based on whether the end of the path is reached.  Really this looks like it moves one step a time.</p>
<p>So in my early dealings with path dispatch, I'd try to formalize this a bit better...putting horse-blinders on the PD_Xxx() function by giving it narrow parameterization, and removing the PVS as a parameter.  Yet I tripped over "bad" path dispatchers like PD_Gob(), which <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/t-gob.c#L676">called Next_Path() in their implementations</a>.</p>
<p>But the "bad" handling of GOB! was closer to the right general answer:</p>
<ul>
<li>
<p>Some portion of the path is consumed by each step in the SET-PATH!</p>
</li>
<li>
<p>It then it hands the remainder off to what it can't handle via a recursive call...</p>
<ul>
<li>The return value of this recursive call is either NULL or an updated image of the cell bits that must be updated in the container to reflect an immediate type.</li>
</ul>
</li>
</ul>
<h2>Walking Through The Process With GOB!</h2>
<p>Imagine you write:</p>
<pre><code>&gt;&gt; obj/gob/size/x: 304
</code></pre>
<p>It might happen like this:</p>
<ul>
<li>
<p>POKE asks OBJECT! <em>"Hey, I want to write gob/size/x.  How much of that can you do?"</em></p>
</li>
<li>
<p>OBJECT! says <em>"I will update myself if GOB! can tell me the answer to what it wants to be if size/x is written."</em></p>
</li>
<li>
<p>GOB! says <em>"I consumed the entirety of size/x: 304 and there were no changes to my bit pattern that my caller need be aware about."</em> (because gobs are allocated in handles, REBGOB*, so the modification of the size bits is not the concern of the reference in object as it still points to that same REBGOB*)</p>
</li>
<li>
<p>OBJECT! says <em>"Okay fine then."</em></p>
</li>
</ul>
<p>Notice that <strong>We never got PAIR! involved in the dispatch, even though the answer to gob/size is a PAIR!.</strong></p>
<p>That's not the only way to do it.  There's actually three ways this could work:</p>
<ol>
<li>
<p>(the above way) Don't just consume one of the steps, but go ahead and do two--e.g. take control of what <code>size.x</code> means and don't synthesize a PAIR! at all.</p>
</li>
<li>
<p>Synthesize a PAIR! and allow it to do whatever modification it wishes, but ignore its <code>nullptr</code> return status and pack the full pair value down to the low-level bits in the GOB!</p>
</li>
<li>
<p>Drop this micro-optimization and store a PAIR! cell in the GOB! structure.</p>
</li>
</ol>
<p>I actually think <span class="hashtag">#3</span> is the best answer, but, the point here is to study being general.</p>
<h2>The New Formulation Is About As Good As This Can Get</h2>
<p>It's interesting to be able to do this kind of optimization, and things like the FFI need it.  I mentioned <strong>some-struct.million-int-array.1</strong>.  Naive approaches will be too inefficient to handle this.</p>
<p>So path processing needs this nuance.  And we'd like an answer that doesn't make the author of STRUCT! have to worry about <strong>some-struct.million-int-array.(1 + 2)</strong>, so the processing of GROUP!s has to be done by the pathing.</p>
<p>Long story long: this is a PITA and I'm making some headway on framing the problem.  Things seem in better shape, as the oddly-shaped PD_Xxx are eliminated.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-pathing-and-picking-predicament-pans-out/1704">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-pathing-and-picking-predicament-pans-out/1704</link>
          <pubDate>Sun, 05 Sep 2021 08:43:19 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1704</guid>
          <source url="https://forum.rebol.info/t/the-pathing-and-picking-predicament-pans-out/1704.rss">The Pathing and Picking Predicament Pans Out</source>
        </item>
        <item>
          <title>Vaporizing Failed Conditionals In REDUCE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>The question of what to do when REDUCE encounters NULL has been a thorn ever since its introduction.  By definition you can't put NULL in a BLOCK!.</p>
<p>So you've seemingly got three choices:</p>
<ul>
<li>
<p>Vaporize the expression slot: <strong>reduce [1 null 2]</strong> =&gt; <strong>[1 2]</strong></p>
</li>
<li>
<p>Raise an error: <strong>reduce [1 null 2]</strong> =&gt; <strong><code>** Error: NULLs illegal in REDUCE</code></strong></p>
</li>
<li>
<p>Put some value there: <strong>reduce [1 null 2]</strong> =&gt; <strong>[1 ~null~ 2]</strong> or <strong>[1 _ 2]</strong></p>
</li>
</ul>
<p>I'm exaggerating to call these the "only options".  When you throw in refinements or pass in functions, you've got more options.  I've also made the REDUCE-EACH function, which lets you get involved with the result of each expression evaluation...sky's the limit:</p>
<pre><code>collect [
    reduce-each x [1 + 2 null 10 + 20] [
        if integer? x [keep :[&lt;int&gt; x]]
        if null? x [keep &lt;null&gt;]
    ]
]
== [[&lt;int&gt; 3] &lt;null&gt; [&lt;int&gt; 30]]
</code></pre>
<p>But with no parameterization I think there are only three reasonable choices: You vaporize, you error, or you put <strong>~null~</strong> or <strong>_</strong> there.</p>
<h2>
<a name="several-people-have-favored-vaporization-1" class="anchor" href="https://forum.rebol.info#several-people-have-favored-vaporization-1"></a>Several People Have Favored Vaporization</h2>
<p>I myself have <em>usually</em> usually been on the side of erroring.</p>
<p>But the place that vaporization feels most convenient is when you're doing something like an append of data to a block, and you want to cut out some items.</p>
<pre><code>&gt;&gt; use-preface: false

&gt;&gt; append data reduce [if use-preface [&lt;preface&gt;] 1 + 2 "Hello"]
== [1 + 2 "Hello"]
</code></pre>
<p>The key to why vaporization works here is that <strong>you're dealing with a situation that has no positional expectations</strong>.</p>
<p>But I don't generally use REDUCE in these cases.  It can't splice (which I usually want to be able to do).</p>
<h2>
<a name="weve-tried-vaporizing-null-and-i-dont-think-i-like-it-2" class="anchor" href="https://forum.rebol.info#weve-tried-vaporizing-null-and-i-dont-think-i-like-it-2"></a>We've Tried Vaporizing NULL and... <em>I Don't Think I Like It</em>
</h2>
<p>Let's look at situations like the use of GET-BLOCK! (I believe must be a synonym for REDUCE) to do ranges in UPARSE.</p>
<pre><code>; Set min to null so we can easily test if it has been set or not, but is
; still "a little ornery".  Must set it before running the rule.
;
min: null

; Set max to blank so it can opt out by default if we have no max
;
max: _

&lt;&lt;BUNCH OF CODE THAT MUST SET MIN AND MAY OR MAY NOT SET MAX&gt;&gt;

uparse data [repeat (:[min max]) rule]
</code></pre>
<p>The reason I didn't say <strong><code>(min: ~)</code></strong> or <strong><code>(min: ~overwrite-me~)</code></strong> is because I wanted min to be "middlingly ornery".  So I wanted to use it in expressions like <strong>any [min, ...]</strong> but I didn't want it to be able to be used as an opt out intention.  This is the weird zone that NULL occupies and we're making the most of it.</p>
<p>Under this understanding...I'd be displeased if that turned into <strong><code>[repeat ([_]) rule]</code></strong>, because I'd have liked to have been told about the issue.</p>
<p><strong>Remember that it was not too long ago that the non-valued state would error on the variable fetch itself.</strong>  We've made a lot of concessions to get to the point where it is falsey and can be retrieved without a problem.</p>
<p>So long as the answer isn't vaporization, it would have been okay.  Making <strong><code>[repeat ([~null~ _]) rule]</code></strong> would have been poisonous enough to cause a problem.  And raising an error would have been fine too.</p>
<h2>
<a name="a-compromise-maybe-where-maybe-null-vanishes-3" class="anchor" href="https://forum.rebol.info#a-compromise-maybe-where-maybe-null-vanishes-3"></a>A Compromise: MAYBE where MAYBE NULL vanishes?</h2>
<p>If you really want a REDUCE to make nulls go away instead of becoming a ~null~ BAD-WORD! or raising an error, how about this?</p>
<pre><code>&gt;&gt; reduce [1 maybe if true [&lt;x&gt;] 2]
== [1 &lt;x&gt; 2]

&gt;&gt; reduce [1 maybe if false [&lt;x&gt;] 2]
== [1 2]

&gt;&gt; reduce [1 if false [&lt;x&gt;] 2]
== [1 ~null~ 2]
</code></pre>
<p>This gives the tool for removing things conditionally, while keeping the REDUCE number of expressions consistent.</p>
<p>Like I say... COMPOSE is my preferred tool for when you want splicing... not just letting you go from 1 expression to 0 values, but from 1 expression to N values.</p>
<h2>
<a name="we-can-also-make-a-reduce-which-drops-nulls-4" class="anchor" href="https://forum.rebol.info#we-can-also-make-a-reduce-which-drops-nulls-4"></a>We Can Also Make a REDUCE* Which Drops NULLs</h2>
<p>...and I've talked about predicates and all the other possibilities.  But I think vaporization just isn't the default I want.  MAYBE seems a good way to get past the problem.</p>
<p>The middle ground of <strong>~null~</strong> -- even though it's not an isotope -- gives a compromise that I think is more discoverable when it goes wrong than vaporization.</p>
<p>It seems worth trying out.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/vaporizing-failed-conditionals-in-reduce/1665">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/vaporizing-failed-conditionals-in-reduce/1665</link>
          <pubDate>Mon, 16 Aug 2021 02:13:44 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1665</guid>
          <source url="https://forum.rebol.info/t/vaporizing-failed-conditionals-in-reduce/1665.rss">Vaporizing Failed Conditionals In REDUCE</source>
        </item>
        <item>
          <title>Understanding FRAME! &quot;Lensing&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>Good news: <a href="https://github.com/metaeducation/ren-c/issues/393"><strong>an old issue is (seemingly) mostly addressed!</strong></a></p>
<p>Among the various implications of this design improvement, you can AUGMENT a function with new fields that share the name of either locals or specialized values.  The only names you cannot use in extending a function are those that are public parameters on the interface!</p>
<pre><code>&gt;&gt; /ap10: specialize append/ [value: 10]
&gt;&gt; ap10 [a b c]
== [a b c 10]

&gt;&gt; /wow: adapt (augment ap10/ [:value [integer!]]) [insert series value]
&gt;&gt; wow:value [a b c] 20
== [20 a b c 10]
</code></pre>
<p>So what's going on here is that underneath the hood, the <em>single</em> FRAME! for this function call has <em>two</em> slots with the label <strong><code>value</code></strong>.  But they're never in effect and visible at the same time.  This is great news for composability of functions.</p>
<p>I'm going to try to explain here a little bit of how this works.</p>
<h2><a name="p-5284-every-function-has-a-paramlist-frame-1" class="anchor" href="https://forum.rebol.info#p-5284-every-function-has-a-paramlist-frame-1"></a>Every Function Has a "ParamList" FRAME!</h2>
<p>Some time ago I penned the prophetic post: <a href="https://forum.rebol.info/t/seeing-all-action-s-as-variadic-frame-makers/1002">"Seeing all ACTION!s as Variadic FRAME! Makers"</a>.  This set the stage for what ultimately became an implementation mechanism where the interface to all actions are defined by a FRAME!.</p>
<p>So if you write something like:</p>
<pre><code>/foo: func [return: [integer!] x [tag! text!] y [integer!] &lt;local&gt; z] [
    print ["internal foo view:" mold binding of $x]
    return 5
]
</code></pre>
<p>Inside of FOO there is a FRAME! that lays out a map of the parameters and locals.  This is called the "ParamList".  Internally, it looks something like this:</p>
<pre><code>#[frame! [
    return: #[parameter! [integer!]]
    x: ~#[parameter! [tag! text!]]~
    y: ~#[parameter! [integer!]]~
    z: ~
]]
</code></pre>
<p>This isn't an "execution" frame for the function.  X and Y don't hold legitimate values for a function invocation...they are holding antiform parameters.  RETURN is a special slot known to FUNC which it will fill in with a Except for Z which is a local, so it holds the value that it will have when a frame is made.  <em>(more on that in a second)</em></p>
<p>So now let's try making an ordinary frame for the function:</p>
<pre><code>&gt;&gt; f: make frame! foo/
== #[frame! [
    x: ~
    y: ~
]]
</code></pre>
<p>Okay, that's neat.  It doesn't <em>seem</em> to have the RETURN or Z fields because we aren't supposed to be setting those.  They are there--the memory is part of the frame, and part of what will actually be backing the variables when you EVAL the frame function.  But they are hidden.</p>
<p>I put code inside the function to print out its internal view of that same frame.  Let's try running and see what it says:</p>
<pre><code>&gt;&gt; f.x: "Hello"

&gt;&gt; f.y: 1020

&gt;&gt; do f
internal foo view: #[frame! [
    return: ~#[frame! [^atom :run]]~
    x: "Hello"
    y: 1020
    z: ~
]]
</code></pre>
<p>Hey, look at that.  <strong>When we see the frame from <em>inside</em> the function, it has access to RETURN and Z.</strong>  How does it know to hide the fields on the outside, but give access to them on the inside?</p>
<p>The answer is that each FRAME! Cell instance can optionally hold a <strong>"Lens"</strong>.  A Lens is itself is a ParamList.  The Lens informs which of the fields are supposed to be visible.</p>
<h2><a name="p-5284-now-lets-specialize-it-2" class="anchor" href="https://forum.rebol.info#p-5284-now-lets-specialize-it-2"></a>Now, Let's SPECIALIZE It...</h2>
<p>Let's make a new function SPFOO which fixes the value of Y.</p>
<pre><code>/spfoo: specialize foo/ [y: 304]
</code></pre>
<p>And now let's look at what its internal "fake" exemplar FRAME! looks like:</p>
<pre><code>#[frame! [
    return: #[parameter! [integer!]]
    x: ~#[parameter! [tag! text!]]~
    y: 304
    z: ~
]]
</code></pre>
<p>Something you'll notice is that <em>the type information for Y is now lost, and the slot where the type information would have been has been replaced by the specialized value</em>.  That's a nice little efficiency trick.  (We can still check the type, because FOO's ParamList has it.)</p>
<p>Now if we make a frame for SPFOO, the only thing it will let us set is X:</p>
<pre><code>&gt;&gt; f: make frame! spfoo/
== #[frame! [
    x: ~
]]
</code></pre>
<h2><a name="p-5284-what-if-we-were-to-adapt-the-specialization-3" class="anchor" href="https://forum.rebol.info#p-5284-what-if-we-were-to-adapt-the-specialization-3"></a>What if We Were to ADAPT the Specialization?</h2>
<p>So this raises an interesting question about the "inside" and "outside" view of things.</p>
<p>At an interface level, I would argue that it should not usually be possible to tell the difference between SPFOO and any other function that takes a single parameter X.</p>
<p>So what happens if we ADAPT the SPFOO function and get access to the frame on the inside?</p>
<pre><code>/adspfoo: adapt spfoo/ [
    print ["inside adaptation:" mold binding of $x]
]

&gt;&gt; adspfoo "What happens?"
inside adaptation: make frame! [
    x: "What happens?"
]
internal foo view: make frame! [
    return: ~#[frame! [^atom :run]]~
    x: "What happens?"
    y: 304
    z: ~
]
</code></pre>
<p>Ta-da.  ADAPT only saw a function with an X parameter, and none of the other details are exposed to it.  Its view of the frame only sees X.  <em>But it's all the same frame...</em> memory is being reused, just the access to it is controlled.</p>
<p><strong>Pretty slick, huh?</strong>  Anyway, I'm sure there are bugs but the groundwork is there.  Please experiment and let me know if anything seems to be counterintuitive.</p>
<p><em>(Note that when you're inside the ADAPT, you don't have access to RETURN.  It's not part of the interface, and we want you to be able to ADAPT functions that don't have RETURN.  If you need greater control, use ENCLOSE.)</em></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/understanding-frame-lensing/1645">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/understanding-frame-lensing/1645</link>
          <pubDate>Wed, 04 Aug 2021 17:32:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1645</guid>
          <source url="https://forum.rebol.info/t/understanding-frame-lensing/1645.rss">Understanding FRAME! &quot;Lensing&quot;</source>
        </item>
        <item>
          <title>Thinking We Might Should Nix PROTECT/HIDE For Now</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>R3-Alpha had an interesting feature, <a href="http://www.rebol.net/r3blogs/0189.html">which let you "hide" fields in contexts</a>.</p>
<p>It was actually something that drew me in to the language in the beginning as "oh, that's cool".</p>
<p>So it has stuck around in some form, and simple examples do still seem to work:</p>
<pre><code>&gt;&gt; obj: make object! [x: 10 y: 20]
== make object! [
    x: 10
    y: 20
]

&gt;&gt; protect/hide 'obj/y
== obj/y

&gt;&gt; obj
== make object! [
    x: 10
]
</code></pre>
<p><strong>But this is a very complex feature to honor systemically.</strong>  Doing it poorly is easy.  Doing it pervasively and correctly is rather difficult.</p>
<p>In particular, what bothers me about this "user controlled hidden bit" is that I'm trying to get some system-level hidden mechanics working correctly.  And the interaction between things the system needs to hide and this "user can hide anything they want" is somewhat maddening, especially because I know how hard it is to do such a thing <em>right</em>.</p>
<p>It's an intriguing feature that seems to have been a bit of an off-the-cuff experiment.  I don't see it as mission-critical...and all it does is interfere with the hardening needed to solve the mission-critical problems related to contexts.</p>
<p>Not going to delete it immediately, but it's certainly in the crosshairs if it causes any more trouble with something I'm trying to fix.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/thinking-we-might-should-nix-protect-hide-for-now/1644">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/thinking-we-might-should-nix-protect-hide-for-now/1644</link>
          <pubDate>Tue, 03 Aug 2021 09:05:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1644</guid>
          <source url="https://forum.rebol.info/t/thinking-we-might-should-nix-protect-hide-for-now/1644.rss">Thinking We Might Should Nix PROTECT/HIDE For Now</source>
        </item>
        <item>
          <title>Should REEVALUATE apply LET bindings?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>So the idea of REEVALUATE (short name REEVAL) is that you get the same behavior "as if" you had written the thing in place:</p>
<pre><code>&gt;&gt; x: 10
&gt;&gt; reeval (first [x:]) 20  ; acts like X: 10
&gt;&gt; x
== 20
</code></pre>
<p>But how far should this "as if you'd written it there" go?  Should the binding be applied?</p>
<pre><code>&gt;&gt; x: 1000
&gt;&gt; code: '(x + 20)
&gt;&gt; do [let x: 284, reeval code]
== ?
</code></pre>
<p>Does it see the new value for X?  Should that give you 1020, or 304?</p>
<p>I vote 1020.  Seems to me that only source-level code should see the LET's binding.</p>
<p>But there's an implementation problem because the evaluator has to know to suppress LET bindings on reevaluations.  REEVAL takes pains to make sure it's running through the same code path as the evaluator normally would.  It's not exactly clear what bits to check or flip to know how to control this behavior.</p>
<p>Tricky as that is, it would get even trickier if we said you <em>wanted</em> to apply the LET binding...because it gets hard to know whether you've applied it twice.  Imagine if you said instead:</p>
<pre><code>&gt;&gt; x: 1000
&gt;&gt; code: '(x + 20)
&gt;&gt; do compose [let x: 284, reeval '(code)]
== 304  ; we want it to see the LET X
</code></pre>
<p>How does REEVAL know if the <strong>let x: 284</strong> was taken into account already or not?  This depends on whether the argument was literal or fetched through a variable.  But REEVAL isn't supposed to know anything about its argument besides its value.  <a href="https://github.com/metaeducation/ren-c/commit/b1721727665d286be3ccafebb70461e2770b108a">I rigged up a fix</a>, and we can see how well it holds up.</p>
<p><strong>I think this points to the idea that LET and USE should probably stick to having near-parity in outcomes.</strong>  That means the binding only applies to source, not things fetched and then "treated as source" later.</p>
<p>Anyway, difficult stuff...all on the way to <a href="https://forum.rebol.info/t/what-to-do-about-funct-including-not-calling-it-that/1518">getting rid of FUNCT-behavior-of-FUNCTION</a>.  Since there's such a big monster of a codebase to try it on (including the Mezzanine, Rebmake, and ReplPad) it's getting exercised fairly heavily.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-reevaluate-apply-let-bindings/1521">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-reevaluate-apply-let-bindings/1521</link>
          <pubDate>Wed, 24 Feb 2021 20:13:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1521</guid>
          <source url="https://forum.rebol.info/t/should-reevaluate-apply-let-bindings/1521.rss">Should REEVALUATE apply LET bindings?</source>
        </item>
        <item>
          <title>Restoring Case-Insensitive Binding</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>I've been working on the frustrating question of how to make case-insensitive binding work without sacrificing the gain of space of a platform pointer per word cell.</p>
<p>It's rough and not pushed to master yet.  But it's mixing with Virtual Binding:</p>
<pre><code>&gt;&gt; abba: 304
&gt;&gt; obj: make object! [abba: 1020]
&gt;&gt; code: [ABBA 'Abba ''abbA '''aBBa ''''AbbA '''''aBba]

&gt;&gt; do in obj compose [map-each x (code) [get dequote x]]
== [1020 1020 1020 1020 1020 1020]

&gt;&gt; map-each x code [get dequote x]
== [304 304 304 304 304 304]
</code></pre>
<h2>Strategy: Assume More Than 3 Casing Variations Uncommon</h2>
<p>The design I've gone with is to assume that there aren't that many case variations of the same word in most situations.  Maybe you have <code>accept-headers</code>, <code>Accept-Headers</code> and <code>ACCEPT-HEADERS</code>.  But you won't go too far beyond that with <code>ACcept-HEAdERS</code> etc.  If you do, then the words start to "cost more".</p>
<p><strong>Some of this stuff gets pretty vague in terms of whether I'm playing by the "rules" or just twisting code into a pretzel</strong>.</p>
<p>I've oft-mentioned the "4 platform pointers per cell" baseline.  That's pretty limited.  Also limiting is that R3-Alpha tried to do essentially everything with arrays and linked lists... and this is a far cry from being able to easily pick from any of dozens of vetted data structures to suit your problem.</p>
<p>So what's going on here is that if you use a "sufficiently weird spelling", then your cell turns into the kind that points to another cell for its content.  This is how QUOTED!s at the higher levels (4 quoting levels or more) work.</p>
<p><strong>The ramifications are subtle and pervasive.</strong>  A lot of code would assume it could just go and muck with parts of cells, but now that these expanded format cells can be shared you can impact cells you didn't mean to.  If you want to tweak a WORD! cell so that it's a SET-WORD!, you have to worry about whether it's an unusual-spelling word...and if so, you need to make a copy of the shared cell to update its bit patterns.  I've established ways to check some of this at compile-time, but it's kind of hacked together at the moment and needs tuning.</p>
<p>I'm suspecting that the average program would never need any of these cells (4 levels of quoting or 4 case-variations)...but that makes it all the more important to find ways to test it, by making the uncommon case common.  Basically forcing all words to use the expanded format and seeing what breaks.</p>
<h2>Object Keys Are Now Canon (Lowercase)</h2>
<p>This applies to MAKE OBJECT!, and things like function arguments:</p>
<pre><code>&gt;&gt; make object! [ABC: 10, Def: 20]
== make object! [
    abc: 10
    def: 20
]

&gt;&gt; func [ABC /Def] [print "Functions too."]
== #[action! [abc /def]]
</code></pre>
<p>I've written about how I believe this is the only sane answer to dealing with it <a href="https://forum.rebol.info/t/case-insensitivity-vs-case-preservation-cant-have-both/1439/14">("Case Insensitivity vs. Case Preservation (can't have both)")</a>.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/restoring-case-insensitive-binding/1472">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/restoring-case-insensitive-binding/1472</link>
          <pubDate>Sun, 24 Jan 2021 08:58:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1472</guid>
          <source url="https://forum.rebol.info/t/restoring-case-insensitive-binding/1472.rss">Restoring Case-Insensitive Binding</source>
        </item>
        <item>
          <title>Advancements In Information-Hiding: Sealed FRAME! Members</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p><strong>Having local variables be invisible to the outside of a function is something that has been important in Ren-C since the beginning.</strong></p>
<p>Superficially, we want to protect against the following kind of bug, e.g. that Red has inherited from Rebol2 and R3-Alpha:</p>
<pre><code>red&gt;&gt; maybe-format-drive: func [user password /local permissions] [
         if check-supervisor user password [
              permissions: &lt;supervisor&gt;
         ]
         if permissions = &lt;supervisor&gt; [
              print "Formatting hard drive"
         ]
    ]
</code></pre>
<p>The code above is assuming that permissions will default to NONE!.  But the problem is that you can slip the permissions in via the /LOCAL refinement:</p>
<pre><code>red&gt;&gt; maybe-format-hard-drive/local "mallory" "password" &lt;supervisor&gt;
</code></pre>
<p><strong>This is why Ren-C makes sure all true locals are set to <code>~undefined~</code> when a function runs.</strong>  While being undefined makes them more prickly than BLANK! or NULL, you can default them using DEFAULT.</p>
<h2>But Wanting To Hide Things has More Motivation Than That</h2>
<p>Clearly we're not dealing with a very "secure" language model.  So there's a bigger reason.</p>
<p>It's important for us to contractually establish that the locals are none of the caller's business.  Because once we have this information hiding, <em>it offers the potential for name reuse</em>.</p>
<p><a href="https://forum.rebol.info/t/augment-add-parameters-and-refinements-after-the-fact/1216">Remember <strong>AUGMENT</strong>?</a>  It lets you add parameters to a function frame.  This lets you do things like make a version of SWITCH that has /DEFAULT but inherits the interface of SWITCH and runs all in the same memory block.</p>
<p>But what if just incidentally, the implementation of SWITCH used a local variable called "default"?  Then you'd wind up with a frame with two keys with the same name.</p>
<p>Having a frame with two keys that have the same name sounds like a pretty big problem for binding...<em>unless there were some way to tell which names were in effect for a FRAME! based on which phase of a function composition it was in.</em></p>
<p><strong>This is where frame phasing comes in.</strong></p>
<h2>Quick Demo of FRAME! Phasing</h2>
<pre><code>foo: func [public &lt;local&gt; private] [
    private: 304
    return binding of 'public  ; return a FRAME! with the internal view
]

&gt;&gt; f-outside: make frame! :foo
== make frame! [
    public: ~undefined~   ; from the outside, you don't see `private` 
]

&gt;&gt; f-outside/public: 1020

&gt;&gt; f-inside: do f-outside   ; Note: DO kills the outside view, unless you copy
== make frame! [
    return: 'make action! [[@value /vanishable] [...]]
    public: 1020
    private: 304
]
</code></pre>
<p>We're seeing <strong>two different views of the same memory</strong>.  The outside view is unaware of the locals.  The inside view reveals them.</p>
<p>Important to observe is that what view we see doesn't depend on which stack level we're at, but the bits of the value in our hand.</p>
<p>Now, how about that augmentation?  Let's add a /PRIVATE refinement to a layer on top of FOO that uses the same frame:</p>
<pre><code>&gt;&gt; f-prelude: null

&gt;&gt; bar: adapt augment 'foo [/private [tag!]] [
       f-prelude: binding of 'private
   ]        

&gt;&gt; f-outside: make frame! :bar
&gt;&gt; f-outside/public: 1020
&gt;&gt; f-outside/private: &lt;different!&gt;

&gt;&gt; f-inside: do f-outside
== make frame! [
    return: 'make action! [[@value /vanishable] [...]]
    public: 1020
    private: 304
]

&gt;&gt; f-prelude
== make frame! [
    public: 1020
    private: &lt;different!&gt;
]
</code></pre>
<p><strong><code>f-inside</code> and <code>f-prelude</code> (and <code>f-outside</code>) are all the same frame, which reveal a different PRIVATE field based on the phase.</strong></p>
<p><strong><a href="https://github.com/metaeducation/ren-c/issues/393">This addresses Ren-C's oldest open issue, from Feb 2017.</a></strong>  Which I hope to be able to close shortly.</p>
<h2>How Does It Work?</h2>
<p>I've said time and again that a value cell is the size of 4 platform-pointers.  That's a rule of the game.</p>
<ol>
<li>
<p>Like all cells, a FRAME! cell needs to give up one of those for the header...to say (among other things) that it's a frame and not an integer, etc.</p>
</li>
<li>
<p>Next you have a binding.  This binding is important for instance when you MAKE a FRAME! for a RETURN function.  It needs to know where to return to.</p>
</li>
<li>
<p>Then you need to have a "varlist", to point at the list of values that the frame's variables currently hold.</p>
</li>
<li>
<p>The final slot is either a <strong>frame phase</strong> or a <strong>frame label</strong></p>
</li>
</ol>
<p>If the phase slot is a label, you assume that the FRAME! value you are looking at has no special privileges to see locals or anything.  It gets its keylist from the archetype of the frame...e.g. the pointer held by the varlist itself.  In this particular no-phase case, all locals and specialized-out values are hidden from the phase.</p>
<p>If the phase slot is not a label, then that's the phase...and the parameters of the action are used as the keylist.  Locals are counted since there is a phase...but "sealed" variables are not (these are what would have been considered "local" by the function that this phase derived from.)</p>
<p>The upshot of this is that many operations which used to just be able to take a varlist now need to take a whole ANY-CONTEXT! value, so the phase information is present.  Which fields are in play due to the phase is important not just for molding, but also for binding and lookup.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/advancements-in-information-hiding-sealed-frame-members/1396">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/advancements-in-information-hiding-sealed-frame-members/1396</link>
          <pubDate>Mon, 09 Nov 2020 20:56:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1396</guid>
          <source url="https://forum.rebol.info/t/advancements-in-information-hiding-sealed-frame-members/1396.rss">Advancements In Information-Hiding: Sealed FRAME! Members</source>
        </item>
        <item>
          <title>The Most Vexing Evaluation: -&gt; meets THEN/ELSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>Whenever the evaluator code gets churned around, there are a few things that break first.</p>
<p>One of the most frequent nightmares is having to fix the mixture of arrows and then/else.  Here's the working behavior:</p>
<pre><code>&gt;&gt; if 1 &lt; 2 [&lt;branch&gt;] then x -&gt; [print ["THEN" x]] else [print "ELSE"]
THEN &lt;branch&gt;

&gt;&gt; if 1 &gt; 2 [&lt;branch&gt;] then x -&gt; [print ["THEN" x]] else [print "ELSE"]
ELSE
</code></pre>
<p><strong>This is a showpiece of composition.</strong>  It's one of the things that I want people to encounter and go "wow" when they see how it's being done.  So letting it break is not an option.</p>
<h2><a name="p-4115-what-typically-breaks-1" class="anchor" href="https://forum.rebol.info#p-4115-what-typically-breaks-1"></a>What Typically Breaks</h2>
<p>When it goes south, what happens is the ELSE won't run.</p>
<p>We want the precedence to work out as if you had written this:</p>
<pre><code>((if null [&lt;branch&gt;]) then (x -&gt; [print ["THEN" x]])) else [print "ELSE"]
</code></pre>
<p>So when the THEN goes to get its branch argument, it gets the function constructed from the arrow <em>but stops there</em>...deferring the ELSE.  The THEN runs, and the ELSE acts on the completed output of the entire IF..THEN expression.</p>
<p>Instead, when this breaks, the typical broken interpretation is:</p>
<pre><code>(if null [&lt;branch&gt;]) then ((x -&gt; [print ["THEN" x]]) else [print "ELSE"])
</code></pre>
<p>Here we see that THEN went to get its branch argument of the arrow.  But the arrow--once constructed--is passed as the first argument to ELSE, and the ELSE runs.  Since the arrow isn't void or null, the ELSE evaluates to that arrow...which the THEN runs.  If the THEN gets void or null as input it doesn't run, and now considers itself the end of the chain...since the ELSE ran prematurely.</p>
<h2><a name="p-4115-why-does-it-break-2" class="anchor" href="https://forum.rebol.info#p-4115-why-does-it-break-2"></a>Why Does It Break?</h2>
<p>Remember that THEN and ELSE are "INFIX:DEFER operations".  This is to say that they don't greedily take the first opportunity to run as infix (the way something like <strong><code>+</code></strong> does).  Instead, they pass on that first opportunity...and run on the <em>second</em> opportunity.</p>
<p>Consider that if ELSE ran on its first infix opportunity, it would be pointless:</p>
<pre><code> if null [print "not run"] else [print "run"]
</code></pre>
<p>The first time ELSE gets seen by the evaluator is while it's putting the <code>[print "not run"]</code> argument into IF's branch argument slot.  If it ran at that moment, you'd have:</p>
<pre><code>if null ([print "not run"] else [print "run"])
</code></pre>
<p>The ELSE would have a block on its left that wasn't void, and evaluate to that.  So this would act the same as:</p>
<pre><code>if null [print "not run"]
</code></pre>
<p>So now back to our broken situation:</p>
<pre><code>if false [&lt;branch&gt;] then x -&gt; [print ["THEN" x]] else [print "ELSE"]
</code></pre>
<p><strong>ELSE will only defer <em>once</em></strong>.  Which means it should only be "seen" twice.  When it breaks it gets seen <em>three</em> times:</p>
<ol>
<li>It gets seen while <code>-&gt;</code> is fulfilling <code>[print ["THEN" x]]</code> into its second argument, and does a lookahead.</li>
<li>It gets seen after THEN fulfills its argument</li>
<li>It gets seen after THEN executes</li>
</ol>
<p>We definitely want the second time ELSE is seen--when it executes--to be at (3).  But which of (1) or (2) is the right "first" time to see ELSE?  Both can't happen...but one of them has to happen.</p>
<h2><a name="p-4115-a-case-of-conflicting-requirements-for-lookahead-3" class="anchor" href="https://forum.rebol.info#p-4115-a-case-of-conflicting-requirements-for-lookahead-3"></a>A Case Of Conflicting Requirements for Lookahead</h2>
<p>We know that <code>1 + 2 * 3</code> is 9 and not 7.   So the first time <code>*</code> gets a chance to be looked-ahead-at is <em>after</em> the <code>1 + 2</code> infix is finished.</p>
<p>If we looked only at this rule, it would suggest (1) is the "bad" time for ELSE to be "seen".  <code>-&gt;</code> is infix like <code>+</code> is, and ELSE is infix like <code>*</code> is.  So we might see an analogy:</p>
<ul>
<li><code>1 + 2 * 3</code> =&gt; <code>(1 + 2) * 3</code></li>
<li><code>x -&gt; [...] else [...]</code> =&gt; <code>(x -&gt; [...]) else [...]</code></li>
</ul>
<p>But if infix operators don't look ahead in their argument fulfillment, why would the <code>-&gt;</code> have been seen during the THEN?  Why wouldn't it be:</p>
<pre><code>((if null [&lt;branch&gt;] then x) -&gt; [print ["THEN" x]]) else [print "ELSE"]
</code></pre>
<p>It looks like we pretty much have to gerrymander this so that something about the properties of the parts get the desired outcome.</p>
<h2><a name="p-4115-something-has-to-bend-4" class="anchor" href="https://forum.rebol.info#p-4115-something-has-to-bend-4"></a>Something Has To Bend</h2>
<p>The easiest-seeming option is: <strong>Quoted lookbacks like the one done by -&gt; supersede the "no lookahead" rule</strong>.  That would mean you get this:</p>
<pre><code>&gt;&gt; 1 + 2 * 3
== 9  ; `*` is not left literal

&gt;&gt; left-literal-multiplier: infix func [@left right] [
       print ["left-literal-multiplier" left right]
       left * right
   ]

&gt;&gt; 1 + 2 left-literal-multiplier 3
left-literal-multiplier 2 3
== 7  ; what happens when you take the argument literally
</code></pre>
<p>I don't know if it's the <em>best</em> rule.  But it doesn't seem to come into conflict with any of the crazy examples I've come up with yet.  <em>(And I try a fair number of "crazy" things.)</em></p>
<p>I'm patching the latest breakage of this behavior, and I'm kind of sure it will probably break again.  But I wanted to have a reference to why this seems to work by taking away the "(1)" case.</p>
<p>A key point I want to make here is that since we've gotten this far with it, <em>I'm not foreseeing accepting any designs which don't allow this to work</em>.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-most-vexing-evaluation-meets-then-else/1361">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-most-vexing-evaluation-meets-then-else/1361</link>
          <pubDate>Thu, 08 Oct 2020 21:59:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1361</guid>
          <source url="https://forum.rebol.info/t/the-most-vexing-evaluation-meets-then-else/1361.rss">The Most Vexing Evaluation: -&gt; meets THEN/ELSE</source>
        </item>
        <item>
          <title>From Liability to Asset: WORD! and PATH! always running code</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>Since there are no parentheses in function application, Rebol winds up with the somewhat sketchy aspect that you can't tell when looking at a WORD! or PATH! if it's going to give you a value or run arbitrary code.</p>
<p>Tonight I've reached a point in the generic tuple + path change such that <strong>/foo</strong>, <strong>.foo</strong>, <strong>foo.</strong>, and <strong>foo/</strong> are all forms of PATH! and TUPLE! that fit efficiently into a single cell.  But once things like <strong><code>foo.</code></strong> existed I had to make them do something... so I went ahead with trying my suggestion:</p>
<pre><code>&gt;&gt; foo: 10
== 10

&gt;&gt; foo.
== 10

&gt;&gt; foo/
** Error: Terminal slash in PATH! did not follow ACTION!

&gt;&gt; append/ [1 2 3] 4
== [1 2 3 4]

&gt;&gt; append.
** Error: Picking from action on left of dot in TUPLE!
</code></pre>
<p><em>Kinda neat</em>.  (Error messages need some thought).  And I noticed something else neat about terminal slash...which is that it makes a good shortcut for REEVAL to get a function value then force its execution:</p>
<pre><code>&gt;&gt; (specialize 'add [value2: 10]) 20
== 20  ; GROUP! evaluated to an ACTION! and was discarded

&gt;&gt; reeval (specialize 'add [value2: 10]) 20
== 30  ; this is how you previously did it without a new variable for the action

&gt;&gt; (specialize 'add [value2: 10])/ 20
== 30  ; shorthand!
</code></pre>
<h2><a name="p-4080-but-is-there-more-untapped-power-lurking-here-1" class="anchor" href="https://forum.rebol.info#p-4080-but-is-there-more-untapped-power-lurking-here-1"></a>But Is There More Untapped Power Lurking Here?</h2>
<p>My first thought went to protecting from Rebol's dangerous "always execute IF a function" semantics.</p>
<p>But being able to make member access look the same when calling a function or not is a sought-after ability in other languages.  Most discussions of the feature involve <em>"Property Getters and Setters"</em>...where you can override non-parentheses access and assignment for a field.  <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/using-properties">For instance, in C#:</a></p>
<blockquote>
<p>"Properties combine aspects of both fields and methods. <strong>To the user of an object, a property appears to be a field, accessing the property requires the same syntax. To the implementer of a class, a property is one or two code blocks, representing a <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/get">get</a> accessor and/or a <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/set">set</a> accessor"</strong></p>
</blockquote>
<p>By its nature, Rebol has "getters" because you don't need parentheses to get an object member.  Just make a function with no arguments:</p>
<pre><code>&gt;&gt; my-object: make object! [
       x-private: 10
       x: func [] [
            print "Getting X!"
            return x-private + 20
       ]
 ]
            
&gt;&gt; my-object.x
Getting X!
== 30
</code></pre>
<p>But it doesn't have overrideable behavior for SET-PATH! or SET-WORD!, so you can't make something like <code>my-object.x: 10</code> call code.  The X function just gets overridden.</p>
<p>The little inkling of a thought I had was that we might be able to use the PATH!/TUPLE! distinction somehow to tell the difference between <em>calling the setter/getter function</em> and <em>dealing with the function itself</em>.</p>
<pre><code> &gt;&gt; foo.x: 1000 
 Calling the Setter Function!
 == 1000  ; imagine setter stores value - 20

 &gt;&gt; foo.x-private
 == 980  ; ...so it updated the private value

 &gt;&gt; foo.x
 Getting X
 == 1000 

 &gt;&gt; foo.x.: &lt;dead&gt;  ; notice the terminal `.`
 == &lt;dead&gt;

 &gt;&gt; foo.x
 == &lt;dead&gt;   ; no setter or getter anymore
</code></pre>
<p>It's just an inkling at this point of something that might be interesting.  I was kind of lamenting how many <code>/</code> there are in the codebase, when it seemed to me I'd be wanting to use <code>.</code> almost always.  But that got me to wondering about the kinds of motivations that people would have for using one form vs. the other.  Maybe this plays into it.</p>
<p>All that aside... really just kind of announcing that generic tuple and path unification with compression to single cells is coming up shortly.  There are a few "big" issues to think about, but the mechanics are working...for the most part.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/from-liability-to-asset-word-and-path-always-running-code/1354">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/from-liability-to-asset-word-and-path-always-running-code/1354</link>
          <pubDate>Sat, 03 Oct 2020 05:23:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1354</guid>
          <source url="https://forum.rebol.info/t/from-liability-to-asset-word-and-path-always-running-code/1354.rss">From Liability to Asset: WORD! and PATH! always running code</source>
        </item>
        <item>
          <title>O noes, Unicode Normalization</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>UTF8-Everywhere has been running along relatively well...even without any optimization on ASCII strings.</p>
<p>But there's a next level of bugaboo to worry about, and that's unicode normalization.  This is where certain codepoint sequences are considered to make the same "glyph"...e.g. there can be a single accented form of a character with an accent, or a two-codepoint sequence that is the unaccented character and the codepoint for an accent.</p>
<p>Since there's more than one form for the codepoints, one can ask what form you canonize them to.  You can either try to get them to the fewest codepoints (for the smallest file to transmit) or the most (to make it easier to process them as their decomposed parts).</p>
<p>On the plus side... unicode provides a documented standard and instructions for how to do these normalizations.  The Julia language has what seems to be a nicely factored implementation in C with few dependencies, called <strong>"<a href="https://github.com/JuliaStrings/utf8proc" rel="nofollow noopener">utf8proc</a>"</strong>  It should not be hard to incorporate that.</p>
<p>On the minus side... pretty much everything about dealing with unicode normalization.  <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=9" title=":roll_eyes:" class="emoji" alt=":roll_eyes:">  There have been cases of bugs where filenames got normalized but then were not recognized as the same filename by the filesystem with the shuffled codepoints...despite looking the same visually.  So you can wind up with data loss if you're not careful about where and when you do these normalizations.</p>
<p>This could get arbitrarily weird, especially with WORD! lookups.  Consider the kinds of things that can happen historically:</p>
<pre><code>&gt;&gt; o: make object! [LetTer: "A"]
&gt;&gt; find words-of o 'letter
== [LetTer]
</code></pre>
<p>The casing has to match, but also be preserved...and this means you could get a wacky casing you weren't expecting pretty easily.  Now add unicode normalization (I haven't even mentioned case folding).</p>
<ul>
<li>Do we preserve different un-normalized versions as distinct synonyms?</li>
<li>When you AS TEXT! convert a WORD! does the sequence of codepoints vary from one same-looking word to another?</li>
<li>Are conversions between TEXT! &lt;=&gt; WORD! guaranteed not to change the bytes?</li>
</ul>
<p>It's pretty crazy stuff.  I'm tempted to say this is another instance where making a strong bet could be a win.  For instance: say that all TEXT! must use the minimal canon forms--and if your file isn't in that format, you must convert it or process it as a BINARY!.</p>
<p>Or there could also be an alternative type, maybe something like UTF8!...which supported the full codepoint range?</p>
<p>Anyway...this stuff is the kind of thing you can't opt-out of making a decision on.  I'm gathering there should probably be a conservative mode that lets you avoid potential damage from emoji and wild characters altogether, and then these modes relax with certain settings based on what kind of data you're dealing with.</p>
            <p><small>14 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/o-noes-unicode-normalization/1322">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/o-noes-unicode-normalization/1322</link>
          <pubDate>Thu, 27 Aug 2020 16:08:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1322</guid>
          <source url="https://forum.rebol.info/t/o-noes-unicode-normalization/1322.rss">O noes, Unicode Normalization</source>
        </item>
        <item>
          <title>MAP-EACH + generic Identity Swapping vs. REMOVE-EACH</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>REMOVE-EACH is a somewhat problematic operation, in that it is doing a low-level manipulation of an array's contents...and you don't want to expose any intermediate states that aren't valid.</p>
<p>The efficiency of it is questionable...e.g. if you have an array that is 1,000 items long and you remove half of them, your array will now have 500 unused slots.  Also, each time you remove an item you have to slide the rest of the array down...otherwise you leave an array which may have outstanding references in a potentially invalid state.</p>
<p>Ren-C went to some extremes to try and make REMOVE-EACH "rigorous".  But it seems that it might be better to just write something like</p>
<pre><code>remove-each: func [
    {Removes values for each block that returns true.}

    return: "Number of removed series items, or null if BREAK"
        [&lt;opt&gt; integer!]
    'vars "Word or block of words to set each time (local)"
        [blank! word! block!]
    data "The series to traverse (modified)" ; should BLANK! opt-out?
        [&lt;blank&gt; any-series!]
    body "Block to evaluate (return TRUE to remove)"
        [&lt;const&gt; block!]  ; !! Should support ACTION!
][
    if empty? :body [body: [void]]  ; GROUP!s vaporize when empty, address it

    let mp: either block? vars [:map-each/splice] [:map-each]

    let new-data: mp (vars) data compose/deep [
        if not (as group! body) [get/any '(vars)]
    ]
    if null? new-data [return null]  ; BREAK

    let diff: (length of data) - (length of new-data)
    swap-contents data new-data
    return diff
]
</code></pre>
<p>This hinges on the SWAP-CONTENTS low-level operation (better name sought), which would simply take the guts of the new series and swap it out with the old series.  Code for this already exists.</p>
<p>What this means is that any code which accessed the original array during the removal process would see it as the pre-modified form.  Which is basically what the Ren-C bulletproofing did, just much more awkwardly.  :-/</p>
<p>REMOVE-EACH isn't all that terribly common, and the acrobatics required to make it safe aren't really a good use of time...especially to port here in stackless.  It's better to invest more into making MAP-EACH stackless and rigorous, and spending time on more important problems.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/map-each-generic-identity-swapping-vs-remove-each/1316">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/map-each-generic-identity-swapping-vs-remove-each/1316</link>
          <pubDate>Tue, 04 Aug 2020 20:07:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1316</guid>
          <source url="https://forum.rebol.info/t/map-each-generic-identity-swapping-vs-remove-each/1316.rss">MAP-EACH + generic Identity Swapping vs. REMOVE-EACH</source>
        </item>
        <item>
          <title>Should GET-WORD! of unset variables raise an error?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>The following is the behavior of Rebol2 when a GET-WORD! is used on an "UNSET!" value:</p>
<pre><code>rebol2&gt;&gt; unset 'x
rebol2&gt;&gt; type? :x
** Script Error: x has no value
</code></pre>
<p>So you would have to fall back on GET/ANY to really get an unset:</p>
<pre><code>rebol2&gt;&gt; type? get/any 'x
== unset!
</code></pre>
<p>But R3-Alpha decided to be more lenient in this respect, and Red followed the lead:</p>
<pre><code>r3-alpha&gt;&gt; unset 'x
r3-alpha&gt;&gt; type? :x
== unset!

red&gt;&gt; unset 'x
red&gt;&gt; type? :x
== unset!
</code></pre>
<p>I've always been skeptical of this, because quite often the reason you are using a GET-WORD! is because you think the thing in your hand might be a function and you don't want to call it.  But when you let it mean "get a thing that's not set" as well, you're opening the doors to letting typos through:</p>
<pre><code>return reduce ["My Action" :my-actionn]  ; whoops, I meant MY-ACTION!
</code></pre>
<p>Is it worth the tradeoff?  If anyone would say yes, it would probably be me... because I argue for the importance of being able to write truly generic code... so that usermode can be as rigorous as the internals.  But I'm not really sure.  Maybe most generic code should choke on unset unless you really wanted to process them... and maybe that added step of having to use GET/ANY is what it should take.</p>
<p><a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> <a href="https://chat.stackoverflow.com/transcript/message/49923584#49923584">suggests some agreement</a>:</p>
<blockquote>
<p>I feel  <strong>:var</strong>  should be the route to disarming functions/errors as the imperative usage—makes passing them on more intuitive.</p>
</blockquote>
<p><strong>I will point out that if we go back to the Rebol2 style, there's nothing stopping versions of the future from opening it back up to the R3-Alpha and Red style.</strong>  But if people write code expecting GET-WORD!s to return void it will be harder to backpedal later when any significant codebases exist.</p>
<p>This leads me to think we might want to try going back to erroring on unset with GET-WORD! and see where the pain points are.  There may be tools for addressing that pain that are shaped other ways.</p>
<p>Any objections?</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/should-get-word-of-unset-variables-raise-an-error/1301">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-get-word-of-unset-variables-raise-an-error/1301</link>
          <pubDate>Wed, 15 Jul 2020 03:35:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1301</guid>
          <source url="https://forum.rebol.info/t/should-get-word-of-unset-variables-raise-an-error/1301.rss">Should GET-WORD! of unset variables raise an error?</source>
        </item>
        <item>
          <title>Enfix Arity 0: A Puzzle From 2017, Now Believed to be Solved!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <blockquote>
<p>Here's the kind of question <a class="mention" href="https://forum.rebol.info/u/salotz">@salotz</a> may find informative, in light of the <a href="https://forum.rebol.info/t/make-a-rebol-minimum-viable-rebol-interpreters/1245">"how can we model the evaluator in a minimal way"</a>...where putting the evaluator on one sheet of paper like a lambda calculus or Lisp is simply not the objective.  Maybe this helps illustrate the difference?</p>
</blockquote>
<hr>
<p>In 2017 while trying to formalize some code I faced a question: <strong>How should the evaluator deal with a function that is marked as getting its first argument from the left (e.g. "enfix") if that operation takes no arguments?</strong></p>
<p>R3-Alpha only had arity-2 infix functions, and didn't allow you to make your own.  Red lets you make your own, but keeps the rule:</p>
<pre><code>red&gt;&gt; foo: func [x] [print mold x]
== func [x][print mold x]

red&gt;&gt; bar: make op! :foo
*** Script Error: making an op! requires a function with only 2 arguments
</code></pre>
<p>But Ren-C took a different tack, trying to generalize the mechanic so that "enfix" functions could take any number of arguments...and it only spoke to the question of how they got their first.  You might make a ternary operator where the condition was on the left and the branches on the right.  Or you might make a postfix operator which took a single argument--punctuating an evaluation.</p>
<p>We have some of those today.  SO is an interesting variation on ASSERT that just validates its left hand expression:</p>
<pre><code>&gt;&gt; 2 + 1 = 3 so print "No problem."
No problem

&gt;&gt; 1020 - 304 = 421 so print "Math is broken"
** Script Error: assertion failure: [#[false] so]
** Where: so console
** Near: [... = 421 so ~~ print "Math is broken"]
</code></pre>
<p>But what--if anything--should happen when you make an enfix function which takes no arguments?  How is that different from a <em>non</em>-enfix function with no arguments?</p>
<p>I remember where I was when writing down that issue.  It was at one of a number of chains of a coffee place called <a href="https://www.kofficoffee.com/pages/locations">"Koffe", but this one in South Palm Springs</a>.  And <a href="https://github.com/metaeducation/ren-c/issues/581">it has sat around as Issue #581</a> for a long while.</p>
<p>But with the passage of time, I think the answer to this has become clear.  An enfix 0-arity function is simply sequenced in the <em>same evaluator step as the left hand side</em>.</p>
<p><a href="https://github.com/metaeducation/ren-c/blob/fb5e29d593e650b2dbc02963a93348c2ac862b22/tests/functions/enfix.test.reb#L198-L332">If you want to see some cool tests that show the nuances, look here.</a>  But the issue sums up the general gist:</p>
<pre><code>&gt;&gt; bar: func [] [&lt;bar&gt;]
&gt;&gt; enbar: enfixed func [] [&lt;enbar&gt;]

&gt;&gt; evaluate @var [1020 bar 304]
== [bar 304]  ; one step, did not run bar yet, still pending

; Note: I'm not totally thrilled with the @var skippable method of telling
; EVALUATE where to put the value if you care.  I'm thinking we probably should
; be biting the bullet and figuring out a smarter multiple-return-value idea.

&gt;&gt; var
== 1020

&gt;&gt; evaluate @var [1020 enbar 304]
== [304]  ; one step, ran enbar during that step besides being arity-0

&gt;&gt; var
== &lt;enbar&gt;
</code></pre>
<p>One nuance is how enfix functions which have arguments to their left which are marked <code>&lt;skip&gt;</code> will effectively degrade to becoming non-enfix and run in the next step.  <a href="https://forum.rebol.info/t/default-now-usable-in-case-switch/739">Without that, the clever DEFAULT operation would not work.</a>  I'm open to the idea that there might be a use case for a left-hand-skipping operation that runs in the same step as the left even when it skips.  But... since I can't think of any--and I know DEFAULT needs otherwise--I'll wait until someone points out a need before getting too concerned about it.</p>
<hr>
<p><strong>These edge cases really shed light on the big picture.</strong>  I've said time and again that you don't do yourself any favors in language design by throwing yourself softballs.  You should be looking for pathological cases and if you can't solve them, building a rationale behind why--and articulating the shape of the things you <em>can</em> solve.</p>
<p>On Ren-C I've been chipping away at these issues a little at a time, and it feels good to see this old one get closed.  I'm pretty sure that people using the evaluator to invent cool things will appreciate that it bends (to the extent coherence will allow it to!)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/enfix-arity-0-a-puzzle-from-2017-now-believed-to-be-solved/1251">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/enfix-arity-0-a-puzzle-from-2017-now-believed-to-be-solved/1251</link>
          <pubDate>Thu, 12 Dec 2019 06:56:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1251</guid>
          <source url="https://forum.rebol.info/t/enfix-arity-0-a-puzzle-from-2017-now-believed-to-be-solved/1251.rss">Enfix Arity 0: A Puzzle From 2017, Now Believed to be Solved!</source>
        </item>
  </channel>
</rss>

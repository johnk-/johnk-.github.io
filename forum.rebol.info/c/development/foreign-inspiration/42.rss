<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Foreign Inspiration - AltRebol</title>
    <link>https://forum.rebol.info/c/development/foreign-inspiration/42</link>
    <description>Topics in the &#39;Foreign Inspiration&#39; category Take inspiration from other languages to create the same functionality in rebol.</description>
    
      <lastBuildDate>Sun, 27 Nov 2022 10:05:19 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/foreign-inspiration/42.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Python Speedup Proposals</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>The original "CPython" implementation is in some ways similar to Rebol/Red... though these days Ren-C is more aligned with the stackless Python implementation...which is also written in C, but distinct from CPython.</p>
<p><em>(But Ren-C's design overall is a lot less comparable to anything, due to the number of very "alien" ideas in it, but that I think are what gives it more notable properties.)</em></p>
<p>In any case, despite running an interpreter loop and doing kind-of-what-Rebol-does, they've committed themselves to doing some speedup proposals and apparently it's paying off:</p>
<p><a href="https://devblogs.microsoft.com/python/python-311-faster-cpython-team/" class="inline-onebox">A Team at Microsoft is Helping Make Python Faster - Python</a></p>
<p>Some of their proposals involve JIT-compiling things (which they know won't work on restrictive platforms like iOS).  But they apparently have done a lot of tweaks besides that which have turned out beneficial.  Because it's a C interpreter there might be something applicable to be learned by looking at their "Stage 1" and "Stage 2" changes.</p>
<blockquote>
<h3>Stage 1 -- Python 3.10</h3>
<p>The key improvement for 3.10 will be an adaptive, specializing interpreter. The interpreter will adapt to types and values during execution, exploiting type stability in the program, without needing runtime code generation.</p>
<h3>Stage 2 -- Python 3.11</h3>
<p>This stage will make many improvements to the runtime and key objects. Stage two will be characterized by lots of "tweaks", rather than any "headline" improvement. The planned improvements include:</p>
<ul>
<li>Improved performance for integers of less than one machine word.</li>
<li>Improved peformance for binary operators.</li>
<li>Faster calls and returns, through better handling of frames.</li>
<li>Better object memory layout and reduced memory management overhead.</li>
<li>Zero overhead exception handling.</li>
<li>Further enhancements to the interpreter</li>
<li>Other small enhancements.</li>
</ul>
<h3>Stage 3 -- Python 3.12 (requires runtime code generation)</h3>
<p>Simple "JIT" compiler for small regions. Compile small regions of specialized code, using a relatively simple, fast compiler.</p>
<h3>Stage 4 -- Python 3.13 (requires runtime code generation)</h3>
<p>Extend regions for compilation. Enhance compiler to generate superior machine code.</p>
</blockquote>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/python-speedup-proposals/1992">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/python-speedup-proposals/1992</link>
          <pubDate>Sun, 27 Nov 2022 10:05:19 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1992</guid>
          <source url="https://forum.rebol.info/t/python-speedup-proposals/1992.rss">Python Speedup Proposals</source>
        </item>
        <item>
          <title>Haskell and Rust Error Handling</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Ren-C is shoring up Rebol's historically problematic exception-based error handling by blending together two mechanics: definitional returns and isotopic errors.  This gives what I'm calling "definitional failures":</p>
<p><a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852" class="inline-onebox">FAIL vs. RETURN RAISE: The New Age of Definitional Failures!</a></p>
<p>Pivoting to this line of thinking has some non-accidental similarity to <a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Data-Either.html">Haskell's <code>Either</code></a> and <a href="https://doc.rust-lang.org/std/result/">Rust's <code>Result</code></a>, which I mentioned when first sketching out the motivation for change:</p>
<p><a href="https://forum.rebol.info/t/the-need-to-rethink-error/1371" class="inline-onebox">The Need To Rethink ERROR!</a></p>
<p>I thought it would be worth it to make a thread for pointing out similarities and differences, and if there are libraries they use that might have relevant inspiration.</p>
<h2>An Out-Of-Band State On The Value Is... Like An Isotope?</h2>
<p>Either is fully generic beyond just allowing errors (and <a href="https://docs.rs/either/latest/either/">Rust has its own generic Either</a> as well).  So you can really say whatever you are returning can come in two forms: the left form vs. the right form.</p>
<p>But even Rust's <code>Result</code> container will permit you to make an Error class the "valid" result, as well as the "invalid" result.</p>
<p>So here we see generic way of letting a value carry a bit--independent of what the payload is--saying whether that is a "normal" state or a "weird" state.  Then, the system has an assortment of operations that are designed for directing program flow in different ways reacting to it.</p>
<p>Ren-C embraces this deeply: effectively saying that every variable and expression product has the potential of being in this "weird" state... and <em>no array can contain a value in the weird state</em>.  But you don't have to do anything special to a value that <em>isn't</em> weird to extract it... you just get runtime errors if you use the weird values where they're not expected.</p>
<h2>Rust Tackles Low-Hanging Fruit via <code>unwrap()</code> and <code>?</code>
</h2>
<p>In Ren-C, if you don't have handling at the callsite when a definitional error happens, it's promoted to being more like a throw--and most code should not intercept it.</p>
<p>Being more formal by nature, both Haskell and Rust force <em>some</em> handling at the callsite when an error result is possible.  You have to define a code path to take if there's an error, or a code path to take if there's not.</p>
<p>But Rust has a couple of conveniences.  If you want something like the Ren-C behavior, you can just call the <code>.unwrap()</code> method on the result.  It will give you the ordinary value if the function didn't return, otherwise raise the error as a "panic".</p>
<p>There's also a cool shortcut with a postfix operator of <strong>?</strong> on the call.  This makes it so that if you call a function that returns a <code>Result</code> type from inside another function that returns a <code>Result</code> type, it will automatically propagate the result if it's an error out of the calling function.</p>
<p>Getting this behavior is more laborious in Ren-C:</p>
<pre><code>foo: func [...] [
    x: bar (...) except e -&gt; [return raise e]
    ...
]
</code></pre>
<p>Implementing the feature as postfix raises its own problems, so let's just imagine we were trying it prefix:</p>
<pre><code>foo: func [...] [
    x: ? bar (...)  ; we want this to act the same as above
    ...
]
</code></pre>
<p>For this to work under the current system, each FUNC would have to define its own <strong>?</strong> operator... because much like definitional RETURN, it would have to know what it was returning <em>from</em> in case of a raised error.</p>
<h2>Haskell Has Generic Compositional Smarts</h2>
<p>As mentioned, the strict compile-time typing in Haskell forces you to be explicit about your reaction when a function returns one of these <code>Either</code> values.</p>
<p>But because Either fits in with monadic/applicative/functor stuff, you can have higher-order operations that <a href="https://lhbg-book.link/06-errors_and_files/01-either.html">can compose together</a> failure scenarios...and gather up failures from several functions or cascade the failure through to where you want.</p>
<p>Ren-C can do this kind of thing as well, such as how you can write higher-order functions like ATTEMPT in usermode, or REDUCE a block of values in one pass with META and get the errors, then react to them later.</p>
<p>But in practice, the lack of a static type system makes this more precarious.</p>
<h2>Links To Error Handling Libraries</h2>
<ul>
<li>Rust's ANYHOW!: <a href="https://docs.rs/anyhow/">https://docs.rs/anyhow/</a>
</li>
</ul>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/haskell-and-rust-error-handling/1987">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/haskell-and-rust-error-handling/1987</link>
          <pubDate>Sun, 16 Oct 2022 02:17:44 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1987</guid>
          <source url="https://forum.rebol.info/t/haskell-and-rust-error-handling/1987.rss">Haskell and Rust Error Handling</source>
        </item>
        <item>
          <title>Waforth: WebAssembly Forth</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>There may be some relevant or interesting things to learn by looking at this:</p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://el-tramo.be/favicon-32x32.png?v=1560365977" class="site-icon" width="32" height="32">
      <a href="https://el-tramo.be/blog/waforth/" target="_blank" rel="noopener" title="12:00AM - 24 May 2018">el-tramo.be – 24 May 18</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/271;"><img src="https://el-tramo.be/blog/waforth/header@2x.png" class="thumbnail" width="690" height="271"></div>

<h3><a href="https://el-tramo.be/blog/waforth/" target="_blank" rel="noopener">A Dynamic Forth Compiler for WebAssembly</a></h3>

<p>In yet another ‘probably-useless-but-interesting’ hobby project, I wrote a Forth compiler and interpreter targeting WebAssembly. It’s written entirely in WebAssembly, and comes with a compiler that dynamically emits WebAssembly code on the fly. The...</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>I've wanted to do some kind of dynamic Wasm generation--even very simple--so we can have something like the experience of the TCC natives, but on the web.  So seeing what they have to go through is probably informative.</p>
<p>Here are the design notes:</p>
<p><a href="https://github.com/remko/waforth/blob/master/doc/Design.md">https://github.com/remko/waforth/blob/master/doc/Design.md</a></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/waforth-webassembly-forth/1927">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/waforth-webassembly-forth/1927</link>
          <pubDate>Fri, 19 Aug 2022 15:22:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1927</guid>
          <source url="https://forum.rebol.info/t/waforth-webassembly-forth/1927.rss">Waforth: WebAssembly Forth</source>
        </item>
        <item>
          <title>SQLite&#39;s &quot;sqlean&quot;: C code for SQLite Extension Stuff</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>SQLite is a pretty carefully put together piece of C code.  Seems they've factored out some bits of interesting functions in C to a common library:</p>
<aside class="onebox githubfolder">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="16" height="16">
      <a href="https://github.com/nalgeon/sqlean" target="_blank" rel="noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <img src="https://repository-images.githubusercontent.com/343191804/5e00d0fc-d757-440b-a837-b2798de8e113" class="thumbnail onebox-full-image" width="60" height="60">

<h3><a href="https://github.com/nalgeon/sqlean" target="_blank" rel="noopener">GitHub - nalgeon/sqlean: The ultimate set of SQLite extensions</a></h3>


  <p><span class="label1">The ultimate set of SQLite extensions. Contribute to nalgeon/sqlean development by creating an account on GitHub.</span></p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>So there's random stuff like <a href="https://github.com/nalgeon/sqlean/blob/main/src/fuzzy/translit.c">transliteration</a>, for example or fuzzy string matching.  It could be a place to look if that kind of need comes up...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/sqlites-sqlean-c-code-for-sqlite-extension-stuff/1904">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/sqlites-sqlean-c-code-for-sqlite-extension-stuff/1904</link>
          <pubDate>Fri, 29 Jul 2022 05:09:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1904</guid>
          <source url="https://forum.rebol.info/t/sqlites-sqlean-c-code-for-sqlite-extension-stuff/1904.rss">SQLite&#39;s &quot;sqlean&quot;: C code for SQLite Extension Stuff</source>
        </item>
        <item>
          <title>Common Lisp LOOP and ITERATE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>LOOP is about the shortest word you can get in the looping world <sub>(FOR is one letter shorter, I guess)</sub>.</p>
<p>So in a language that claims itself to be all-about-dialects, it doesn't seem to make sense to make LOOP the dumbest iteration construct in the box.</p>
<p>In Ren-C <strong>REPEAT</strong> is arity-2, where the first parameter is a number of times the block as the second parameter should be invoked.  This is what historical Redbol called LOOP.</p>
<p>So with that out of the way... we can think about LOOP as being something more on the scale of PARSE (UPARSE!) in which you can richly express your iteration intent.</p>
<p>An obvious place to look for inspiration for such a dialect is Common Lisp's LOOP.  (There's also a kind of "LOOP-lite" called ITERATE)</p>
<ul>
<li>
<p><a href="https://lispcookbook.github.io/cl-cookbook/iteration.html">https://lispcookbook.github.io/cl-cookbook/iteration.html</a></p>
</li>
<li>
<p><a href="https://gigamonkeys.com/book/loop-for-black-belts.html">https://gigamonkeys.com/book/loop-for-black-belts.html</a></p>
</li>
<li>
<p><a href="https://iterate.common-lisp.dev/">https://iterate.common-lisp.dev/</a></p>
</li>
</ul>
<p>I've skimmed these things but never actually used them.</p>
<p>Clearly we have an advantage in expressivity due to having more parts in the box.  But also, since we are oriented toward the visceral/extensible experience without much regard to performance, that could present some opportunities in clarity that they would not take.</p>
<p>Having built prototypes of <a href="https://forum.rebol.info/t/match-in-rust-vs-switch/1835/4">SWITCH2</a> and <a href="https://forum.rebol.info/t/destructure-dialect/1877">DESTRUCTURE</a> on top of UPARSE, I think it's past time to start prototyping what our take on LOOP might look like.</p>
<p>Anyone want to take a stab at designing it?  I'd write it if there were a good examples of what it should look like.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/common-lisp-loop-and-iterate/1878">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/common-lisp-loop-and-iterate/1878</link>
          <pubDate>Wed, 13 Jul 2022 22:29:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1878</guid>
          <source url="https://forum.rebol.info/t/common-lisp-loop-and-iterate/1878.rss">Common Lisp LOOP and ITERATE</source>
        </item>
        <item>
          <title>JavaScript object notation shorthand</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>I saw this syntax in JavaScript and thought it might be some feature from TypeScript or some other higher level layer:</p>
<pre><code>let text = "Hello World"
let state = { fruit: "banana" }

let obj = { text, state }
</code></pre>
<p>But it turns out in plain JavaScript that now does the same thing as:</p>
<pre><code>let obj = { text: "Hello World", state: { fruit: "banana" } }
</code></pre>
<p>In fact they also have "computed property names":</p>
<pre><code>let prop = 'foo';
let o = {
    [prop]: 'hey',
    ['b' + 'ar']: 'there'
}
</code></pre>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer" class="inline-onebox">Object initializer - JavaScript | MDN</a></p>
<p>Ren-C is inches away from doing the computed property names in MAKE OBJECT! (using SET-GROUP! rather than SET-BLOCK! would be more appropriate).</p>
<p>But because of the freeform nature of the code block in MAKE OBJECT!, the appearance of a WORD! alone can't indicate an embedded field.</p>
<p><strong>It may be that there should be a less freeform alternative to MAKE OBJECT! which doesn't let you put arbitrary code in the middle of it.</strong>  Or at the very least, you put that code in GROUP!s.</p>
<p>Perhaps MAKE OBJECT! itself should have that requirement.  It could be like PARSE and just ignore the GROUP!s as it goes.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/javascript-object-notation-shorthand/1836">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/javascript-object-notation-shorthand/1836</link>
          <pubDate>Tue, 07 Jun 2022 00:07:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1836</guid>
          <source url="https://forum.rebol.info/t/javascript-object-notation-shorthand/1836.rss">JavaScript object notation shorthand</source>
        </item>
        <item>
          <title>How ANY and ALL In Other Languages Act on Empty Inputs</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>I was looking around in the "Red Enhancement Process" repository to see if there was anything there of interest, and one thing that's at least useful was <a href="https://github.com/red/REP/issues/85">a survey of how other language constructs paralleling ANY and ALL act</a> when given empty inputs.</p>
<p>The repository is BSD-licensed and so I'll reproduce the list here.  <img src="https://forum.rebol.info/images/emoji/twitter/stuck_out_tongue.png?v=9" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"></p>
<hr>
<p><strong>Red</strong></p>
<pre><code>&gt;&gt; all [] == none
&gt;&gt; any [] == none
</code></pre>
<p><strong>Rebol2 &amp; Rebol3:</strong></p>
<pre><code>&gt;&gt; all [] == true
&gt;&gt; any [] == none
</code></pre>
<p><strong>Scheme:</strong></p>
<pre><code>(and) #t
(or) #f
</code></pre>
<p><strong>Common Lisp:</strong></p>
<pre><code>(and) T
(or) NIL
</code></pre>
<p><strong>R:</strong></p>
<pre><code>all() [1] TRUE
any() [1] FALSE
</code></pre>
<p><strong>J:</strong></p>
<pre><code>*./&gt;a: 1
+./&gt;a: 0
</code></pre>
<p><strong>Julia:</strong></p>
<pre><code>all([]) true
any([]) false
</code></pre>
<p><strong>Python:</strong></p>
<pre><code>all([]) True
any([]) False
</code></pre>
<p><strong>Javascript:</strong></p>
<pre><code>[].every(function(){}) true
[].some(function(){}) false
</code></pre>
<hr>
<h1>Lotsa Precedent For <code>ALL []</code> Truthy, <code>ANY []</code> Falsey...</h1>
<p>If you squint hard enough, there are legitimate reasons for favoring this choice--if both have to be constrained to just TRUE and FALSE.</p>
<p>The arguments sort of parallel <strong><a href="https://ae1020.github.io/is-true-greater-than-false/">why it's reasonable to say that TRUE &gt; FALSE</a></strong>.  But it's sort of abstract...and you wind up talking about <em>"mathematical consensus regarding bounded lattices…more specifically, a complemented distributive lattice."</em></p>
<h1>...BUT...We Can Do Better, With ~VOID~ ISOTOPES!</h1>
<p><img src="https://forum.rebol.info/images/emoji/twitter/man_scientist.png?v=9" title=":man_scientist:" class="emoji only-emoji" alt=":man_scientist:"> <img src="https://forum.rebol.info/images/emoji/twitter/atom_symbol.png?v=9" title=":atom_symbol:" class="emoji only-emoji" alt=":atom_symbol:"> <img src="https://forum.rebol.info/images/emoji/twitter/microscope.png?v=9" title=":microscope:" class="emoji only-emoji" alt=":microscope:"></p>
<p>VOID is the utter absence of value, and I don't think we would want this:</p>
<pre><code>&gt;&gt; expr1: [comment "I'm a comment"]
&gt;&gt; expr2: [elide print "Vanishing!"]

&gt;&gt; x: 10

&gt;&gt; 1 + 2, x: all compose [((expr1)) ((expr2))]
Vanishing
== 3

&gt;&gt; x
== 10
</code></pre>
<p>Functions that become <em>truly</em> invisible should be somewhat rare, and do so by contract.  Things kind of turn into chaos if you let the property seep too far.</p>
<h3>But ~VOID~ ISOTOPES Are Another Thing Altogether</h3>
<p>The idea behind a ~void~ isotope is that a function can say that in spirit it produced nothing, but still give back <em>some</em> result... <em>an isotope representation of void intent</em>.  You can then work with that, such as to use MAYBE to convert the intent into an actual manifestation of voidness.</p>
<p>So if you are at a callsite and you know that something like an ALL or an ANY might vaporize all of its clauses, you are in the driver's seat to make the call:</p>
<pre><code>&gt;&gt; x: 10

&gt;&gt; 1 + 2, x: all compose [((expr1)) ((expr2))]
== ~void~  ; isotope

&gt;&gt; x: 10

&gt;&gt; 1 + 2 x: maybe all compose [((expr1)) ((expr2))]
== 3  ; or 10, or ~void~ isotope...still thinking about this...

&gt;&gt; x
== 10  ; &lt;-- BUT this is the important bit
</code></pre>
<p>I think that the fact ANY [] and ALL [] have kind of eluded a standardized consensus in the Redbol world considers that historically they didn't come up in practice much.</p>
<p>BUT I've got some powerful use cases coming up to demonstrate that take advantage of the ability to erase and MAYBE'-ify the results of ANY and ALL.  These use cases blow away any microscopic benefit given by declaring the answers here to be true or false.  And for ALL to be truthy it would have to lie in some way--by fabricating an arbitrary truthy value.</p>
<p>You won't have to take my word for it that this is a big win...you'll see for yourself!</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/eye.png?v=9" title=":eye:" class="emoji" alt=":eye:"> <img src="https://forum.rebol.info/images/emoji/twitter/pig_nose.png?v=9" title=":pig_nose:" class="emoji" alt=":pig_nose:">  <img src="https://forum.rebol.info/images/emoji/twitter/eye.png?v=9" title=":eye:" class="emoji" alt=":eye:"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/how-any-and-all-in-other-languages-act-on-empty-inputs/1830">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-any-and-all-in-other-languages-act-on-empty-inputs/1830</link>
          <pubDate>Thu, 26 May 2022 06:39:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1830</guid>
          <source url="https://forum.rebol.info/t/how-any-and-all-in-other-languages-act-on-empty-inputs/1830.rss">How ANY and ALL In Other Languages Act on Empty Inputs</source>
        </item>
        <item>
          <title>undefined vs. null in JavaScript</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>JavaScript distinguishes "undefined" and "null" in something of the way that Ren-C distinguishes unset and null variables.  An undefined variable is one you haven't assigned yet, NULL is one you've set to NULL.</p>
<pre><code>// Chrome Console Session
&gt; asdf
VM66:1 Uncaught ReferenceError: asdf is not defined

&gt; typeof asdf
&lt;- "undefined"

&gt; asdf = null
&lt;- null

&gt; asdf
&lt;- null

&gt; typeof asdf
&lt;- "object"
</code></pre>
<p><em>(If you're curious why the <strong>typeof</strong> null is an object in JavaScript: <a href="https://stackoverflow.com/questions/18808226/why-is-typeof-null-object">"Because the spec says so.  This is generally regarded as a mistake."</a>.  The move of not having an answer for the value of the type, e.g. saying the answer to <strong>type of null</strong> is null - is much better)</em></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/undefined-vs-null-in-javascript/1826">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/undefined-vs-null-in-javascript/1826</link>
          <pubDate>Wed, 18 May 2022 11:22:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1826</guid>
          <source url="https://forum.rebol.info/t/undefined-vs-null-in-javascript/1826.rss">undefined vs. null in JavaScript</source>
        </item>
        <item>
          <title>REBOL 1 Manual</title>
          <dc:creator><![CDATA[DefinitionalUsername]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>I was reading about some of the design choices in REBOL, and came upon Joe Marshall's writings where he talks about the changes between REBOL 1 and 2 (missing continuations, changed scoping rules, absence of tail recursion, etc.). This made me curious about the differences between the two version; however, I can't find anything related to REBOL 1 on the internet (save for a Scheme compiler).</p>
<p>Will it be possible to share the manual/guide/documentation for REBOL 1 here? It is a piece of history, and it'll be a shame if it just disappears.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rebol-1-manual/1788">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rebol-1-manual/1788</link>
          <pubDate>Mon, 14 Feb 2022 03:29:26 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1788</guid>
          <source url="https://forum.rebol.info/t/rebol-1-manual/1788.rss">REBOL 1 Manual</source>
        </item>
        <item>
          <title>Python&#39;s Ideas for Dropping the &quot;Global Interpreter Lock&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Python's C implementation (CPython) parallels the classical Redbol world in many ways.  So some of what they talk about here may be applicable:</p>
<aside class="onebox googledocs">
  <header class="source">
      <a href="https://docs.google.com/document/d/18CXhDb1ygxg-YXNBJNzfzZsDFosB5e6BfnXLlejd9l0/edit#" target="_blank" rel="noopener">docs.google.com</a>
  </header>
  <article class="onebox-body">
    <a href="https://docs.google.com/document/d/18CXhDb1ygxg-YXNBJNzfzZsDFosB5e6BfnXLlejd9l0/edit#" target="_blank" rel="noopener"><span class="googledocs-onebox-logo g-docs-logo"></span></a>

<h3><a href="https://docs.google.com/document/d/18CXhDb1ygxg-YXNBJNzfzZsDFosB5e6BfnXLlejd9l0/edit#" target="_blank" rel="noopener">Python Multithreading without GIL</a></h3>

<p>Multithreaded Python without the GIL  Sam Gross colesbury@gmail.com / sgross@fb.com   Source code: https://github.com/colesbury/nogil   The goal of this project is to remove the global interpreter lock (GIL) from CPython to enable multiple threads to...</p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/pythons-ideas-for-dropping-the-global-interpreter-lock/1746">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/pythons-ideas-for-dropping-the-global-interpreter-lock/1746</link>
          <pubDate>Mon, 18 Oct 2021 10:06:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1746</guid>
          <source url="https://forum.rebol.info/t/pythons-ideas-for-dropping-the-global-interpreter-lock/1746.rss">Python&#39;s Ideas for Dropping the &quot;Global Interpreter Lock&quot;</source>
        </item>
        <item>
          <title>&quot;Streaming&quot; Survey from Other Languages</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>While PORT!s were ambiguous beasts, one objective we can see was that it should be possible to pipe them together.</p>
<p>This can be seen in the HTTP port.  It was written to (supposedly) not care what kind of port it was reading from, so long as it could supply a stream of bytes.</p>
<ul>
<li>
<p>If you feed HTTP from a TCP port, you get plain old http</p>
</li>
<li>
<p>If you feed HTTP from a TLS port, you get https</p>
<ul>
<li>The TLS port is, in turn, fed from TCP</li>
</ul>
</li>
</ul>
<p>I've written about how this was pretty convoluted...but is approaching a less tangled state.  So now we can look at it in a comparative light and redesign it.</p>
<p><strong>We'd really hope that something about Redbol nature can make this more interesting than what more performance-oriented languages offer.</strong></p>
<p><strong>But if nothing unique can be offered, it hopefully isn't any worse...then it's both <em>slower</em> and <em>worse</em> (which is what it has historically been).</strong></p>
<p>Comparisons follow...</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/streaming-survey-from-other-languages/1739">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/streaming-survey-from-other-languages/1739</link>
          <pubDate>Tue, 05 Oct 2021 08:25:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1739</guid>
          <source url="https://forum.rebol.info/t/streaming-survey-from-other-languages/1739.rss">&quot;Streaming&quot; Survey from Other Languages</source>
        </item>
        <item>
          <title>MATCH in Rust vs. SWITCH</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="12" data-topic="603">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/facing-the-facts-switch-must-evaluate-clauses/603/12">Facing the facts: SWITCH must evaluate clauses</a>
</div>
<blockquote>
<p>what if we presume values and branches alternate, unless COMMA! is used...in which case each element of the comma clause is assumed to be a value to match</p>
</blockquote>
</aside>
<p>We've discussed how SWITCH should deal with the "rhythm" of things matched vs. branches to take.</p>
<p>I was programming in Rust a bit, and wanted to point out their MATCH...which is like SWITCH, <a href="https://doc.rust-lang.org/rust-by-example/flow_control/match.html">where it uses <strong><code>|</code></strong> how comma has been proposed</a>:</p>
<pre><code>match number {
    1 =&gt; println!("One!"),
    2 | 3 | 5 | 7 | 11 =&gt; println!("This is a prime"),
    13..=19 =&gt; println!("A teen"),
    _ =&gt; println!("Ain't special"),
}
</code></pre>
<p>Compared to the proposal:</p>
<pre><code>switch number [
    1 [print "One!"]
    2, 3, 5, 7, 11 [print "This is a prime"]
    ; no equivalent yet proposed for ranges
] else [
    print "Ain't special"
]
</code></pre>
<p>It's worth thinking about how ranges and range testing are supposed to be expressed.</p>
<p>But the bigger point is that I think I like the comma for meaning a list of alternates in this context...enough to say that SWITCH should require it if you want multiple conditions for the same branch.  This would solve asymmetries in CASE and SWITCH and let them share more code.</p>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/match-in-rust-vs-switch/1835">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/match-in-rust-vs-switch/1835</link>
          <pubDate>Thu, 29 Apr 2021 02:00:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1835</guid>
          <source url="https://forum.rebol.info/t/match-in-rust-vs-switch/1835.rss">MATCH in Rust vs. SWITCH</source>
        </item>
        <item>
          <title>Carl&#39;s New Projects (?) AltScript, AltOS</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>This is apparently something Carl is working on...</p>
<p><strong><a href="https://altscript.com/?p=116">ASON AltScript Format</a></strong></p>
<p>Going through the bullet points:</p>
<blockquote>
<p><strong>Braces {} are used to denote objects</strong>. They are lexical and may be used directly without evaluation (the <code>make</code> constructor is not necessary).<br>
<strong>Braces {} are not used for multi-line strings</strong>. A single+double quote format is used for multi-line strings.</p>
</blockquote>
<p>At times I've certainly had my doubts about whether the language tradeoff of braces for strings is a good one.  I go back and forth on this.</p>
<p>Today the biggest justification for it is that it mixes well with putting portions of code in quotes, for strings and characters and filenames:</p>
<pre><code> REBVAL *v = rebValue("... {a string} #{c} %{spaced filename.txt}...")`.  
</code></pre>
<p>The escaping you get if you don't have that is annoying.  Single quotes aren't an option due to ambiguity with quoting.  It's a distinguishing feature, and I'd hate to drop it.</p>
<blockquote>
<p><strong>All loaded values are constant by default</strong>. This includes strings, blocks, and objects. They are all protected from modification. However, they can be copied and modified. In addition, they can be loaded as modifiable by using a load option.</p>
</blockquote>
<p>We tried this and I don't think it's as palatable or interesting as the current Ren-C behavior:</p>
<p><strong><a href="https://forum.rebol.info/t/the-beta-one-mutability-manifesto/1062">Mutability Manifesto</a></strong></p>
<p>It's been working well enough that I don't think anyone's found much fault with it.</p>
<p>Also, if Carl is working from the R3-Alpha codebase enforcement of mutability, there are countless bugs.</p>
<blockquote>
<p><strong>Zero-based indexing is used for blocks</strong> (arrays). This is consistent with many other languages.</p>
</blockquote>
<p>I've gotten used to FIRST and 1 going together.</p>
<blockquote>
<p><strong>Dots are used for field selection</strong>. For example, “person.name” refers to the name field of the person object. Slashes are not used for selection. Use of a dot for selection is common in many other languages.</p>
</blockquote>
<p>I favor dots, we have TUPLE! and the option to say that PATH! points are only for refinements.</p>
<blockquote>
<p><strong>The at sign “@” denotes literal values</strong> for none, true, false, data-types, and special values like NAN (not a number).</p>
</blockquote>
<p>This is interesting, because <a>I've suggested @ may play a role in datatypes</a>, with @ more broadly referring to a value category that is inert in the evaluator.</p>
<p>But there's still a lot to think about.</p>
<blockquote>
<p><strong>Short strings are stored directly</strong> in value cells, not in separate storage. This is an space-saving optimization.<br>
<strong>Characters are expressed as strings</strong>. The above storage optimization makes this possible.</p>
</blockquote>
<p>The TOKEN! unification (ISSUE! + CHAR!) does this.</p>
<blockquote>
<p><strong>Binary (byte arrays)</strong> use #”…” for hex and ##”…” for base-64.<br>
<strong>Base-2 binary</strong> is not directly expressible in source format.</p>
</blockquote>
<p>My current thinking is that ${...} and $"..." are used for binaries.</p>
<p>I don't know that I'm particularly concerned about special representations of base64 or base2.  It seems to me that TOKEN! can serve well enough and then you convert it if you need to.  The cases where you involve base64 binaries are few and far between...usually compressed payloads, and you know where they are so you don't need metadata saying "this information is binary, and this information is base64" because all you're going to do with it is decompress it.</p>
<blockquote>
<p><strong>Arithmetic operators</strong> can be used on series data-types (strings and blocks) for various useful results. For example “+” can be used to join strings and blocks.</p>
</blockquote>
<p><img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=9" title=":man_shrugging:" class="emoji only-emoji" alt=":man_shrugging:"></p>
<blockquote>
<p><strong>String character escapes use C notation</strong>. They use backslash notation, for example “\n” for newline and “\t” for tab.</p>
</blockquote>
<p>Giulio has asked for this.  It's a question worth revisiting.</p>
<blockquote>
<p><strong>The #{ and #[ sequences are reserved</strong> for future use. Currently they are undefined.</p>
</blockquote>
<p>I do like #{ as an alternative to #" for TOKEN!...it helps passing characters to APIs inside quoted strings.</p>
<blockquote>
<p><strong>For JSON compatiblity</strong>:</p>
<ul>
<li>Keys (word definitions) can be written with quotes (<code>“field”:</code>)</li>
<li>A lone colon (<code>:</code>) will automatically associate to the word/string immediately before it.</li>
<li>Commas as element separators are allowed as long as they are not directly followed by a non-digit character (to avoid confusion with comma-based decimal values.)</li>
</ul>
</blockquote>
<p>COMMA! has become a favorite feature of mine, so I like how it's done.</p>
<p>I don't know particularly what to say about the broader question of JSON compatibility.</p>
<p>Seems to touch upon a few points...in particular embracing dots and leaning more toward immutability/constness.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/carls-new-projects-altscript-altos/1571">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/carls-new-projects-altscript-altos/1571</link>
          <pubDate>Mon, 22 Mar 2021 17:02:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1571</guid>
          <source url="https://forum.rebol.info/t/carls-new-projects-altscript-altos/1571.rss">Carl&#39;s New Projects (?) AltScript, AltOS</source>
        </item>
        <item>
          <title>How Does Lisp Deal With Types?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>So I thought to look at how Lisp handles types.  (You'd think I'd have looked earlier.)</p>
<ul>
<li>Overview: <strong><a href="https://lispcookbook.github.io/cl-cookbook/type.html">Common Lisp Cookbook: Types</a></strong>
</li>
<li>Lengthier Survey: <strong><a href="https://alhassy.github.io/TypedLisp">"Typed Lisp, A Primer"</a></strong>
</li>
</ul>
<h2>Function Argument Type Checking (not there)</h2>
<p>First thing to note, they <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Type-Predicates.html">don't have function argument type checking</a>.</p>
<blockquote>
<p><em>"function arguments in Lisp do not have declared data types, as they do in other programming languages. It is therefore up to the individual function to test whether each actual argument belongs to a type that the function can use."</em></p>
</blockquote>
<p>While Rebol does have type checking, it's extremely limited.  It's a frustrating design point...because it's so limited, and because it is poked into a strange compacted place.  When people ask <em>"why only 64 data types?"</em> that gets at some of the strangeness of this feature.</p>
<p>When you try to build reflective abilities for the built-in type checking feature, you get into questions of how to expose these 64 bits.  That's done via TYPESET!, which isn't very easy to process, and doesn't seem like the foundation of a broader answer.  See <a href="https://forum.rebol.info/t/the-typeset-representation-problem/1300">"the TYPESET! representation problem"</a></p>
<h2>Lisp Type Representation</h2>
<p>They seem basically comfortable with the idea of using "WORD!" to name types, e.g. <strong>ensure 'integer 1</strong>.  <em>(Although their version of ENSURE is called THE, as a type annotation.  <strong>the 'integer 1</strong>  That's shorter...same length as "non", and would free ENSURE for other uses.  I can't tell if it makes total sense or not.)</em></p>
<blockquote>
<p><em>"Types are not objects in Common Lisp. There is no object that corresponds to the type <code>integer</code> , for example. What we get from a function like <code>type-of</code> , and give as an argument to a function like <code>typep</code> , is not a type, but a type specifier. A type specifier is the name of a type."</em></p>
</blockquote>
<p>They don't use the equality operator to check the result of "TYPE OF" against anything, because they get back additional "stuff, and I gather that "stuff" can vary from one implementation to another:</p>
<pre><code>* (type-of 1234)
(INTEGER 0 4611686018427387903)
</code></pre>
<p>So it seems they lean toward using functions to ask if types match.  They call these "predicates" and end them in P.  If we were to do a similar thing, it might look like:</p>
<pre><code>&gt;&gt; type? 10 'integer
== #[true]  ; knew to disregard stuff that `'integer = type of 1` wouldn't
</code></pre>
<p>Their notion of typeclasses is somewhat concretized.  Their ANY-VALUE! is just <strong><code>t</code></strong>.  So they do not try and express the notion of "anything" as an explicit union of all known types, the way that Rebol has.  It's inherently not extensible if you say <strong><code>any-value!: make typeset! [integer! text! ...]</code></strong> and then add a new datatype later.</p>
<p>If you scroll down a bit you get to some examples:</p>
<pre><code>;; The universal type “t”, has everything as its value.
(typep 'x 't) ;; ⇒ true
(typep 12 't) ;; ⇒ true

;; The empty type: nil
(typep 'x 'nil) ;; ⇒ false; nil has no values.

;; The type “null” contains the one value “nil”.
(typep nil 'null) ;; ⇒ true
(typep () 'null)  ;; ⇒ true

;; “(eql x)” is the singelton type consisting of only x.
(typep 3 '(eql 3)) ;; ⇒ true
(typep 4 '(eql 3)) ;; ⇒ false

;; “(member x₀ … xₙ)” denotes the enumerated type consisting of only the xᵢ.
(typep 3 '(member 3 x "c"))  ;; ⇒ true
(typep 'x '(member 3 x "c")) ;; ⇒ true
(typep 'y '(member 3 x "c")) ;; ⇒ false

;; “(satisfies p)” is the type of values that satisfy predicate p.
(typep 12 '(satisfies (lambda (x) (oddp x)))) ;; ⇒ false
(typep 12 '(satisfies evenp) )                ;; ⇒ true

;; Computation rule for comprehension types.
;; (typep x '(satisfies p)) ≈ (if (p x) t nil)
</code></pre>
<h2>Why Isn't Everything Just a Function?</h2>
<p>It seems like SATISFIES is the sort of generic way to hook up any function as a type check.  Like you could do arbitrary calculation to check to see if a number was prime...or something like that.</p>
<p>So why isn't this the <em>only</em> kind of type check?  Maybe something to do with the limits of what can be checked at compile time.</p>
<p>It seems that SBCL requires you to go through a symbol to use SATISFIES.  Whether that's on purpose or not, that it forces you to name your predicate is helpful as documentation.</p>
<h2>Stipulating Variables Match A Type</h2>
<p>There is a feature of saying that a word is only assigned particular types (declaim)...and though it didn't work for me in <code>"clisp"</code> it did in <code>"sbcl"</code>.</p>
<p>Were we to have such a feature, we'd presumably give it a better name, but:</p>
<pre><code>&gt;&gt; declaim 'x text!

&gt;&gt; x: 10
** Error: you said that x had to be TEXT!
</code></pre>
<p>When you think about languages arising like TypeScript, being able to annotate a variable to say that it has a certain type is a popular feature.   It's not clear how to do this inexpensively with complex type checks.</p>
<h2>Does This Point To Any Answers?</h2>
<p>The main thing to notice here is that the process isn't driven by "typesets", but rather by a kind of "type matching dialect"...that covers a few kinds of combining operations (including AND, OR), and if you can't get exactly what you want from the built-in bits, you can supply an open-ended function.</p>
<p>It goes in the direction I've been thinking about, where the core function application code doesn't really know what type checking is.  So it's layers above (like FUNC/FUNCTION) that provide the type checking, and define the type checking language.</p>
<p>Nothing particularly new, just thought I'd look.</p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/how-does-lisp-deal-with-types/1436">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-does-lisp-deal-with-types/1436</link>
          <pubDate>Thu, 17 Dec 2020 03:31:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1436</guid>
          <source url="https://forum.rebol.info/t/how-does-lisp-deal-with-types/1436.rss">How Does Lisp Deal With Types?</source>
        </item>
        <item>
          <title>Arturo: &quot;Rebol-inspired&quot; Language</title>
          <dc:creator><![CDATA[johnk]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>"Arturo is a modern programming language, vaguely inspired by various other ones - including but not limited to Rebol, Forth, Ruby, Haskell, D, SmallTalk, Tcl and Lisp."<br>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/arturo-lang/arturo" target="_blank" rel="noopener">GitHub</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/345;"><img src="https://repository-images.githubusercontent.com/210142708/e520ca00-070e-11eb-8bc9-0ebde05fef30" class="thumbnail" width="690" height="345"></div>

<h3><a href="https://github.com/arturo-lang/arturo" target="_blank" rel="noopener">arturo-lang/arturo</a></h3>

<p>Simple, modern and powerful interpreted programming language for efficient scripting. - arturo-lang/arturo</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
</p>
            <p><small>15 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/arturo-rebol-inspired-language/1370">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/arturo-rebol-inspired-language/1370</link>
          <pubDate>Thu, 22 Oct 2020 02:37:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1370</guid>
          <source url="https://forum.rebol.info/t/arturo-rebol-inspired-language/1370.rss">Arturo: &quot;Rebol-inspired&quot; Language</source>
        </item>
        <item>
          <title>Spry language: rebol + smalltalk experimental language</title>
          <dc:creator><![CDATA[salotz]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Here is an interesting Rebol inspired experimental language that combines ideas from Rebol and Smalltalk. Its Implemented in Nim. <a href="http://sprylang.se/index.html" rel="nofollow noopener">http://sprylang.se/index.html</a></p>
            <p><small>7 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/spry-language-rebol-smalltalk-experimental-language/1235">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/spry-language-rebol-smalltalk-experimental-language/1235</link>
          <pubDate>Mon, 21 Oct 2019 16:03:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1235</guid>
          <source url="https://forum.rebol.info/t/spry-language-rebol-smalltalk-experimental-language/1235.rss">Spry language: rebol + smalltalk experimental language</source>
        </item>
        <item>
          <title>Lively Web - a Javascript distributed Web Wiki</title>
          <dc:creator><![CDATA[IngoHohmann]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Lively web, said to be inspired by Smalltalk, but implemented in Javascript.</p>
<p><a href="https://lively-web.org/" class="onebox" target="_blank" rel="nofollow noopener">https://lively-web.org/</a><br>
<a href="https://lively-kernel.org/" class="onebox" target="_blank" rel="nofollow noopener">https://lively-kernel.org/</a><br>
<a href="https://lively-next.org/projects.html" class="onebox" target="_blank" rel="nofollow noopener">https://lively-next.org/projects.html</a><br>
<a href="https://lively-kernel.org/lively4/lively4-core/start.html?load=https://lively-kernel.org/lively4/lively4-core/README.md" class="onebox" target="_blank" rel="nofollow noopener">https://lively-kernel.org/lively4/lively4-core/start.html?load=https://lively-kernel.org/lively4/lively4-core/README.md</a></p>
<p>Ren-C should be able to be much better than that.<br>
(Just some ideas for the future.)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/lively-web-a-javascript-distributed-web-wiki/1218">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/lively-web-a-javascript-distributed-web-wiki/1218</link>
          <pubDate>Sun, 29 Sep 2019 22:04:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1218</guid>
          <source url="https://forum.rebol.info/t/lively-web-a-javascript-distributed-web-wiki/1218.rss">Lively Web - a Javascript distributed Web Wiki</source>
        </item>
        <item>
          <title>Should the C sources say `++foo` or `++ foo` ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Generally speaking, the Ren-C sources try to adhere to the same kind of rules that Rebol uses.  So instead of writing <code>(x+y)</code> the code uses <code>(x + y)</code>, believing this is more legible.</p>
<p>It also embraces the idea of macros that define <code>and</code> for <code>&amp;&amp;</code>, and <code>not</code> for <code>!</code>.  In addition to these being defined in C++ since the original C++98 standard as "alternative tokens", the C track has an ISO standard header for it, so you can <code>#include &lt;iso646.h&gt;</code> if you like:</p>
<p><a href="https://en.wikipedia.org/wiki/C_alternative_tokens">https://en.wikipedia.org/wiki/C_alternative_tokens</a></p>
<p>In the C++ world, there are good reasons for preferring pre-increment and pre-decrement to post (all things being equal).  While it doesn't matter in C it's good to stay in a good habit:</p>
<aside class="onebox stackexchange">
  <header class="source">
      <a href="https://stackoverflow.com/questions/30036749/is-it-still-better-to-prefer-pre-increment-over-post-increment" target="_blank" rel="noopener">stackoverflow.com</a>
  </header>
  <article class="onebox-body">
      <a href="https://stackoverflow.com/users/315052/jxh" target="_blank" rel="noopener">
    <img alt="jxh" src="https://i.stack.imgur.com/AB5ST.png?s=128&amp;g=1" class="thumbnail onebox-avatar" width="128" height="128">
  </a>
<h4>
  <a href="https://stackoverflow.com/questions/30036749/is-it-still-better-to-prefer-pre-increment-over-post-increment" target="_blank" rel="noopener">Is it still better to prefer pre-increment over post-increment?</a>
</h4>

<div class="tags">
  <strong>c++, optimization</strong>
</div>

<div class="date">
  asked by
  
  <a href="https://stackoverflow.com/users/315052/jxh" target="_blank" rel="noopener">
    jxh
  </a>
  on <a href="https://stackoverflow.com/questions/30036749/is-it-still-better-to-prefer-pre-increment-over-post-increment" target="_blank" rel="noopener">05:59PM - 04 May 15 UTC</a>
</div>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>So I've habitually changed <code>foo++</code> to <code>++foo</code> when I see it, assuming it doesn't change the semantics.</p>
<p>But another maybe-seemingly-frivolous question arises, of if it would be better to put a space there?  <code>++ foo</code>?  Is it a readability advantage that C programmers have been missing out on?  Or is it wasteful and out of touch?</p>
<p>Hard to tell, as many people do like to say <code>x=y+1020;</code>, where we say <code>x = y + 1020;</code>.  It seems natural that the sources for a language that believes in space significance would do so, I'm just curious what the operating rule for why this wouldn't apply to <code>++</code> and <code>--</code> would come from.</p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/should-the-c-sources-say-foo-or-foo/1200">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-the-c-sources-say-foo-or-foo/1200</link>
          <pubDate>Thu, 29 Aug 2019 08:53:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1200</guid>
          <source url="https://forum.rebol.info/t/should-the-c-sources-say-foo-or-foo/1200.rss">Should the C sources say `++foo` or `++ foo` ?</source>
        </item>
        <item>
          <title>Lua Multi-Return As Parameters to Function</title>
          <dc:creator><![CDATA[LkpPo]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p><em><a href="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134">[Ren-C Multi Return]</a></em> ...seems like a lua feature. <a href="https://www.lua.org/pil/5.1.html" rel="noopener nofollow ugc">Multiple return values</a> that work with <a href="https://www.lua.org/pil/4.1.html" rel="noopener nofollow ugc">multiple assignment of variables</a>, but also of the <a href="https://www.lua.org/pil/5.2.html" rel="noopener nofollow ugc">parameters</a> of a calling function.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/lua-multi-return-as-parameters-to-function/1928">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/lua-multi-return-as-parameters-to-function/1928</link>
          <pubDate>Wed, 10 Apr 2019 03:33:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1928</guid>
          <source url="https://forum.rebol.info/t/lua-multi-return-as-parameters-to-function/1928.rss">Lua Multi-Return As Parameters to Function</source>
        </item>
        <item>
          <title>PARTIAL specialization (...maybe with GET-GROUP?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Haskell has something called "currying" and it lets them write stuff like:</p>
<pre><code>map (add 2) [1, 2, 3]
</code></pre>
<p>That results in [3, 4, 5].  So it meant the same thing as what Rebol would say as <code>map-each x [1 2 3] [add 2 x]</code>.  Effectively, it's as if it noticed ADD didn't have enough parameters...but instead of erroring it assumed you wanted to create a function that would just be taking the 3 later.  <em>(Technically speaking all functions in Haskell take only take one parameter, <a href="https://softwareengineering.stackexchange.com/questions/185585/what-is-the-advantage-of-currying" rel="nofollow noopener">and that's related to the "currying"</a>, so it's not like it had to do something special to "notice".)</em></p>
<p>If we imagine MAP as a function in Ren-C that did the same thing (take a function and apply it for each member of a series, return a series of the results) you'd have to do this as:</p>
<pre><code>map (specialize 'add [value1: 2]) [1 2 3]
</code></pre>
<p>That's wordy.  It also forces you to remember the name of add's parameters, when you may not care (and parameter names may tend to change).</p>
<p>So imagine we have a variant of specialization that doesn't make you name arguments, it just kind of grabs as many as you supply...in this case one.  Let's call this PARTIAL for a moment:</p>
<pre><code>map (partial 'add [2]) [1 2 3]
</code></pre>
<p>That's brief, but still kind of wordy.  Might it be nice if there were a way to do this that was briefer, like...say...</p>
<pre><code>map :(add 2) [1 2 3]
</code></pre>
<p>In such a world, plain <strong>(add 2)</strong> would still be an error, since there was no colon.</p>
<p>One place this would be handy is because I've been trying to think about how to modify things like SHOVE and MATCH to operate on things other than the first argument.  Right now you can say:</p>
<pre><code> &gt;&gt; obj: make object! [dv: enfix :divide]
 &gt;&gt; 8 -&gt; obj/dv 2
 == 4
</code></pre>
<p>That lets you shove 8 as the left hand parameter of an enfix parameter dispatched via path.  But what if you wanted it the other way around, to make it the second parameter, so you were <em>dividing by 8</em>.  It might be nice to be able to say:</p>
<pre><code>&gt;&gt; 8 -&gt; :(obj/dv 2)
== 0.25
</code></pre>
<p>So that would "shove" the parameter to be after the 2.  As another example, today's MATCH works on the first argument:</p>
<pre><code>&gt;&gt; match parse "aab" [some "a"]
// null

&gt;&gt; match parse "aaa" [some "a"]
== "aaa"
</code></pre>
<p>But what if instead of getting the data when the expression succeeded, you wanted the rule?</p>
<pre><code>&gt;&gt; match :(parse "aab") [some "a"]
// null

&gt;&gt; match :(parse "aaa") [some "a"]
== [some "a"]
</code></pre>
<p>So MATCH is still grabbing the "first argument" of the function you give it on a match.  You just made a partial function whose first parameter was the rule, since the data was specialized into the partial.</p>
<p>I had considered making this the natural syntax of <strong>match (...) ...</strong> but that just feels like it is getting in the way of when you want to use GROUP! just for grouping.  This feels like a different operation, and one that's useful enough to build in.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/partial-specialization-maybe-with-get-group/931">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/partial-specialization-maybe-with-get-group/931</link>
          <pubDate>Wed, 28 Nov 2018 14:41:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-931</guid>
          <source url="https://forum.rebol.info/t/partial-specialization-maybe-with-get-group/931.rss">PARTIAL specialization (...maybe with GET-GROUP?)</source>
        </item>
        <item>
          <title>Syntactically Significant Newlines</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>JSON came from a Rebol heritage, yet people found it weak weak in a couple of areas.  So odd-little YAML has come in to pick up some of that slack:</p>
<p><a href="https://learnxinyminutes.com/docs/yaml/" class="onebox" target="_blank" rel="nofollow noopener">https://learnxinyminutes.com/docs/yaml/</a></p>
<p>One of the key features is syntactically significant newlines.  Rebol already ascribes syntactic significance to newlines in some constructs (comments, multi-line strings) so you can't just take an input Rebol file and smoosh all the newlines together and have it mean the same thing.</p>
<p>So why not add some way to get arbitrary string data based on a significant newline?  What if <strong>#</strong> followed by a space didn't make an empty ISSUE!, but rather cued the issue to just read to the end of the line...uninterpreted?</p>
<pre><code>&gt;&gt; issue: #   ))) Write 4nything you $want$ here  (((
&gt;&gt; as text! issue
== "   ))) Write 4nything you $want$ here  ((("
</code></pre>
<p>There'd be a light annoyance in the sense that the leading space becomes part of the content, and would need to be for accurate molding.  But with Rebol's model, you can always NEXT that out if you need to pass it to some routine.</p>
<pre><code>&gt;&gt; issue: # foo bar
&gt;&gt; as text! next issue
== "foo bar"
</code></pre>
<p>What you'd use this for are things like UNIX command lines, as in .travis.yml</p>
<pre><code># echo "Generating the cross-compiler"
# ${TOP_DIR}/external/tcc/configure --enable-cross --extra-cflags="-DEMBEDDED_IN_R3"
# make -j ${MAKE_JOBS}

// Could throw in comments, which wouldn't get tied up as part of the string content
// (they would be if you tried doing this with a multi-line string literal)
# mkdir bin
# cp *tcc bin #save cross-compilers
</code></pre>
<p>FILE! could follow the same rule:</p>
<pre><code>% echo "Generating the cross-compiler"
% ${TOP_DIR}/external/tcc/configure --enable-cross --extra-cflags="-DEMBEDDED_IN_R3"
% make -j ${MAKE_JOBS}

// This probably looks a bit better to the average UNIXer
% mkdir bin
% cp *tcc bin #save cross-compilers
</code></pre>
<p>But if you did read an issue and NEXT'd out its leading space, you'd have to mold it somehow.  Not a new problem, as you can create issues with embedded spaces today.</p>
<p>It's a bit unfortunate that #{} is used for BINARY!, as #{} would be good for empty issue (and would permit multi-line issues as well).  Due to that, I might suggest ${..} for BINARY!, with #{...} gradually phased out and ultimately repurposed.  (Curiously, any binary would be loadable as an ISSUE! since an issue can hold anything--including hex characters, so old files would still LOAD and be able to be converted under this change, perhaps at LOAD time in the legacy emulation.)</p>
<h2>Interestingly, you could kind of use # for comments</h2>
<p>Today you can write:</p>
<pre><code>sum: function [x y] [ #the-summation-function
    return x + y #return-them-added-together
]
</code></pre>
<p>It works because ISSUE!s are inert.  But with this change, you'd be able to now say:</p>
<pre><code>sum: function [x y] [ # the summation function
    return x + y # return them added together
]
</code></pre>
<p>Still only two ISSUE!s.</p>
<p>Because the values are actually <em>there</em>, it would screw up some things.  For instance, since RETURN detects no argument and then gives back void, this would return an ISSUE!:</p>
<pre><code>sum: function [x y] [ # the summation function
    return # now we're returning an ISSUE!
]
</code></pre>
<p>Of course, that consequence is small potatoes for why it wouldn't be a good general substitute for comments.  It's fairly relevant that they're not stripped out of your file but just left there.</p>
<p>But what it could mean is it could give dialects that wanted to do something creative with # that was <em>comment-like</em> could do so.</p>
<h2>It could be used with the DUMP abbreviations</h2>
<p>Instead of writing:</p>
<pre><code>-- "got to part 3a"
</code></pre>
<p>You could write:</p>
<pre><code>-- # got to part 3a
</code></pre>
<p>It's the same number of characters, but it stands out a little more while at the same time looking less cluttered.  Plus it swaps out a shift-to-type quote for a space, so you only hit one shifted character.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/syntactically-significant-newlines/918">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/syntactically-significant-newlines/918</link>
          <pubDate>Wed, 21 Nov 2018 07:29:19 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-918</guid>
          <source url="https://forum.rebol.info/t/syntactically-significant-newlines/918.rss">Syntactically Significant Newlines</source>
        </item>
        <item>
          <title>Promises, Promises: Should THEN and ELSE be used for them?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Tinkering with JavaScript again after some years of being blissfully ignorant, I notice that a style of programming which used to be popular there has caught on even more.  These are "Promises"--which I've seen under other names like "Futures".</p>
<p>They've become so ingrained that they're now in the JavaScript language itself:</p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://developer.mozilla.org/favicon-48x48.cbbd161b.png" class="site-icon" width="48" height="48">
      <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">developer.mozilla.org</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/388;"><img src="https://developer.mozilla.org/mdn-social-share.cd6c4a5a.png" class="thumbnail" width="690" height="388"></div>

<h3><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise - JavaScript | MDN</a></h3>

<p>The Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p><em>(Note: Worth pointing out is that there's a fundamental feature missing from the built-in promises, namely <a href="https://stackoverflow.com/a/30235261/211160">cancellation</a>.  Kind of makes you roll your eyes when you see someone deploy a major language feature to a worldwide audience--as if it's "the future of asynchronous programming and network requests"--when there's no way to cancel.)</em></p>
<p>When you have a promise in your hand, you can hook it up to clauses that will run if it succeeds, and clauses to run if it fails.  You hook them together with successive function calls...where the THEN clauses are the successes, and the CATCH clauses are the failures:</p>
<pre><code>some_promise.then(
    function(val) {
        log.insertAdjacentHTML('beforeend', val +
            ') Promise fulfilled (&lt;small&gt;Async code terminated&lt;/small&gt;)&lt;br/&gt;');
    }).catch(
    // Log the rejection reason
   (reason) =&gt; {
        console.log('Handle rejected promise ('+reason+') here.');
    });
</code></pre>
<p>You can make loooong chains out of these.  Steps can be triggered by callbacks, or even by just an ordinary non-promise value falling through immediately from the previous step.  It may help to look at a big example <em>(from <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261">this article</a>, if it looks weird with <code>const</code> and <code>=&gt;</code> remember that JavaScript has changed a bit, and this stuff is in it now)</em>:</p>
<pre><code>const wait = time =&gt; new Promise(
   res =&gt; setTimeout(() =&gt; res(), time)
);

wait(200)
   // onFulfilled() can return a new promise, `x`
  .then(() =&gt; new Promise(res =&gt; res('foo')))
  // the next promise will assume the state of `x`
  .then(a =&gt; a)
  // Above we returned the unwrapped value of `x`
  // so `.then()` above returns a fulfilled promise
  // with that value:
  .then(b =&gt; console.log(b)) // 'foo'
  // Note that `null` is a valid promise value:
  .then(() =&gt; null)
  .then(c =&gt; console.log(c)) // null
  // The following error is not reported yet:
  .then(() =&gt; {throw new Error('foo');})
  // Instead, the returned promise is rejected
  // with the error as the reason:
  .then(
    // Nothing is logged here due to the error above:
    d =&gt; console.log(`d: ${ d }`),
    // Now we handle the error (rejection reason)
    e =&gt; console.log(e)) // [Error: foo]
  // With the previous exception handled, we can continue:
  .then(f =&gt; console.log(`f: ${ f }`)) // f: undefined
  // The following doesn't log. e was already handled,
  // so this handler doesn't get called:
  .catch(e =&gt; console.log(e))
  .then(() =&gt; { throw new Error('bar'); })
  // When a promise is rejected, success handlers get skipped.
  // Nothing logs here because of the 'bar' exception:
  .then(g =&gt; console.log(`g: ${ g }`))
  .catch(h =&gt; console.log(h)) // [Error: bar]
;
</code></pre>
<p>This resembles the kind of chaining done with enfix, so...</p>
<h2>...might THEN and ELSE be promise-aware?</h2>
<p>JavaScript uses the name THEN here to mean "do this thing on the right <em>if the left happens</em>" or "<em>if the left is fulfilled</em>".  You can get a "false" result back from a promise:</p>
<pre><code>var falsify = new Promise(
   resolve =&gt; {
       resolve(false) // calling resolve will fulfill the promise
   }
);

falsify.then(x =&gt; console.log(x)) // this will print out false
</code></pre>
<p>Here we have to ask a question about what the rules are for the system.  If you see something like:</p>
<pre><code>all [...] then [print "done with all that stuff"]
print "moving on..."
</code></pre>
<p>Would you want the system to be based on a worldview where that could output:</p>
<pre><code>"moving on..."
"done with all that stuff"
</code></pre>
<p>If you have a PROMISE! datatype in the picture, then programs which use them will become asynchronous even if they don't appear to be written in an asynchronous style.  The more automatic it is, the greater the risks become.</p>
<p>JavaScript's promises involve very little system support.  Not only were most promise library designs done before the language supported them at all, one of the most popular implementations <a href="http://bluebirdjs.com/docs/getting-started.html">doesn't even use the new JS built-in promises</a>...but cooks up its own using functions and objects.</p>
<p>So this is different from what Gabriele was suggesting when he brought up promises <a href="https://forum.rebol.info/t/places-to-look-for-port-prior-art/621/3">as a likely path forward for PORT!s</a> in his Topaz design notes.  He's suggesting that a PROMISE! would be an active datatype, where if you merely said <strong>data: read url</strong> and got a promise back, then <strong>length of data</strong>, it would automatically wait until the length was known.  You wouldn't have to explicitly WAIT on it (or have a THEN, as suggested above).</p>
<p>It's trying to suggest a synchronous client of READ could go on their merry way using it just as if they got bytes back, or tactically drill in with promise-aware constructs on an as-needed basis.  As nice as that sounds it's <em>not realistic</em>.  What you'd need to accomplish such a goal more or less asks the runtime support for lazy evaluation, and the restrictions that brings in would push back to where the user's style of programming would have to morph into something much more like Haskell than like Rebol/JavaScript/etc.</p>
<p>JavaScript's answer is to quarantine down the promise-aware constructs of the language to more or less <em>zero</em>.  Their if() treats them as truthy, not "wait on them asynchronously and see if the result was truthy, or falsey if an error".  Things like .then() are methods on the promise itself, not generic language operators.</p>
<p>As I've pointed out that people aren't even necessarily with the built-in promises of JavaScript--enough to continue using libraries that cobble the protocols together out of objects and functions--it may suggest that zero is not a good sweet spot for language support.  To really be compelling enough for pervasive use there may need to be some special sauce you don't get elsewhere (including, I'd have to say, cancellation).</p>
<p>I do wonder if conditionals could be a place where it might be good to synchronize a promise.  Or if ANY and ALL could imply WAITs.  But certainly it seems like it would be appealing if THEN and ELSE could be used...so I guess that's what I'll put out there for a starting thought.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/promises-promises-should-then-and-else-be-used-for-them/734">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/promises-promises-should-then-and-else-be-used-for-them/734</link>
          <pubDate>Thu, 12 Jul 2018 08:34:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-734</guid>
          <source url="https://forum.rebol.info/t/promises-promises-should-then-and-else-be-used-for-them/734.rss">Promises, Promises: Should THEN and ELSE be used for them?</source>
        </item>
        <item>
          <title>Each versus for-each and for-all</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>In 8th, they have the *:each as a higher order function.</p>
<p>So, depending on whether it's being applied to a map, array, buffer, string it works like this:</p>
<pre><code>Buffer lambda b:each
</code></pre>
<p>So, here the buffer is iterated over and the index and value are placed on the stack for lambda to consume.</p>
<p>For-each neesd to create words, and for-all needs to reference the series by name which creates more visual clutter.</p>
<p>In VID lambdas had access to a similar functionality where <em>value</em> was available.</p>
<p>We could do the same:</p>
<pre><code>Each series [ code ] 
</code></pre>
<p>Where code has access to the words index and value of the series being traversed.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/each-versus-for-each-and-for-all/678">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/each-versus-for-each-and-for-all/678</link>
          <pubDate>Sat, 09 Jun 2018 23:47:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-678</guid>
          <source url="https://forum.rebol.info/t/each-versus-for-each-and-for-all/678.rss">Each versus for-each and for-all</source>
        </item>
        <item>
          <title>New version of loop</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>In 8th I see this construct:</p>
<pre><code>Function n times
</code></pre>
<p>Which is the same as Rebol's</p>
<pre><code>Loop n [ ... ]
</code></pre>
<p>But doesn't this look less busy?</p>
<pre><code>Times n :function
</code></pre>
<p>Loop could be changed to look to see if its parameter is a function to do this automatically, but currently it's a native and not in user space.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/new-version-of-loop/677">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/new-version-of-loop/677</link>
          <pubDate>Sat, 09 Jun 2018 23:29:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-677</guid>
          <source url="https://forum.rebol.info/t/new-version-of-loop/677.rss">New version of loop</source>
        </item>
        <item>
          <title>About the Foreign Inspiration category</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Take inspiration from other languages to create the same functionality in rebol.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/about-the-foreign-inspiration-category/676">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/about-the-foreign-inspiration-category/676</link>
          <pubDate>Sat, 09 Jun 2018 23:22:45 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-676</guid>
          <source url="https://forum.rebol.info/t/about-the-foreign-inspiration-category/676.rss">About the Foreign Inspiration category</source>
        </item>
  </channel>
</rss>

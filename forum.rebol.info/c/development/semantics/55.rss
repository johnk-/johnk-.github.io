<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Semantics - AltRebol</title>
    <link>https://forum.rebol.info/c/development/semantics/55</link>
    <description>Topics in the &#39;Semantics&#39; category While the &quot;Internals&quot; discusses the bits and bytes of how things are implemented, this category is for discussing things design questions of the language... like what &lt;strong&gt;do []&lt;/strong&gt; should return.</description>
    
      <lastBuildDate>Wed, 16 Feb 2022 04:10:48 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/semantics/55.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Shall we CONTINUE?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>At some point I added the ability of CONTINUE to take a parameter.  The idea was that CONTINUE with a parameter would act the same as if the loop body had completed with that value.  One place this is most useful is MAP-EACH:</p>
<pre><code>&gt;&gt; map-each x [1 2 3] [
       if x = 2 [continue &lt;twenty&gt;] else [x * 10]
   ]
== [10 &lt;twenty&gt; 30]
</code></pre>
<p>But what should CONTINUE with no argument do?  In the MAP-EACH case, I think it should pretty obviously not add anything to the output.</p>
<pre><code>&gt;&gt; map-each x [1 2 3] [
       if x = 2 [continue] else [x * 10]
   ]
== [10 30]
</code></pre>
<h2>Nice.  But what about "ordinary" loops?</h2>
<p>How about WHILE or REPEAT or FOR-EACH?  If we wanted it to be novel, it could say "don't change the pending overall result from whatever the last loop iteration would have returned":</p>
<pre><code>&gt;&gt; for-each x [1 2 3] [
     if x = 3 [continue] else [x * 10]
]
== 20
</code></pre>
<p>Although I like that in theory, it would break the loop composition rules unless loops were allowed to be invisible.  :-/</p>
<p>Think about the <a href="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/18">code I've previously written down</a> to implement FOR-BOTH:</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    unmeta all [
        meta for-each var blk1 body
        meta for-each var blk2 body
    ]
]
</code></pre>
<p>That FOR-BOTH could not have a CONTINUE that would run in the body of the second FOR-EACH and carry over a value from the first FOR-EACH.</p>
<p>Given that we'd be setting a standard that would be difficult to follow, I think the answer has to be:</p>
<pre><code>&gt;&gt; for-each x [1 2 3] [
     if x = 3 [continue] else [x * 10]
   ]
== ~none~  ; isotope
</code></pre>
<h2>What about UNTIL and CONTINUE TRUE?</h2>
<p>I've given a rule that CONTINUE passed a parameter effectively jumps to the end of the loop body as if it had finished with that value.  But in UNTIL, the loop's body also is the condition.  So what about:</p>
<pre><code>&gt;&gt; until [print "A" if true [continue true] else [&lt;unreachable&gt;]] print "B"
A
B
</code></pre>
<p>It seems to make a certain amount of sense.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/shall-we-continue/1790">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/shall-we-continue/1790</link>
          <pubDate>Wed, 16 Feb 2022 04:10:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1790</guid>
          <source url="https://forum.rebol.info/t/shall-we-continue/1790.rss">Shall we CONTINUE?</source>
        </item>
        <item>
          <title>About the Semantics category</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>While the "Internals" discusses the bits and bytes of how things are implemented, this category is for discussing things design questions of the language... like what <strong>do []</strong> should return.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/about-the-semantics-category/1789">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/about-the-semantics-category/1789</link>
          <pubDate>Wed, 16 Feb 2022 03:48:39 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1789</guid>
          <source url="https://forum.rebol.info/t/about-the-semantics-category/1789.rss">About the Semantics category</source>
        </item>
        <item>
          <title>&quot;Destructuring&quot; in FOR-EACH</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p><a class="mention" href="/u/gchiu">@gchiu</a> wrote some code that made a list of drugs and filenames related to those drugs:</p>
<pre><code> drugs: [
     ["Benzbromarone" "SA1537.pdf"]
     ["Teriparatide" "SA1139.pdf"]
     ["Adalimumab" "SA1847.pdf"]
     ["Etanercept" "SA1812.pdf"]
 ]
</code></pre>
<p>This is inconvenient to enumerate.  It won't work if you say:</p>
<pre><code>for-each [drugname filename] [...]
</code></pre>
<p>Because what you get then is two successive blocks... e.g. drugname winds up being <strong>["Benzbromarone" "SA1537.pdf"]</strong> and then filename is <strong>["Teriparatide" "SA1139.pdf"]</strong>.</p>
<p>If this were to work, it would have to offer something like:</p>
<pre><code>for-each [[drugname filename]] [...]
</code></pre>
<p>That could communicate that the information you were looking for was actually in a nested block level.</p>
<p>Though we don't want to get too literal with the dialect.  If you have:</p>
<pre><code> drugs: [
     ("Benzbromarone" "SA1537.pdf")
     ("Teriparatide" "SA1139.pdf")
     ("Adalimumab" "SA1847.pdf")
     ("Etanercept" "SA1812.pdf")
 ]
</code></pre>
<p>...we don't want to make the meaning of GROUP!s in FOR-EACH have to be related to this structure, because we use groups to say that the variable's name is calculated.  :-/</p>
<p>Similarly, we might imagine more interesting meanings for blocks in FOR-EACH than to point out a nested block level.  Maybe this would be done with quoted blocks and quoted groups?</p>
<pre><code>for-each ['(drugname filename)] [...]
</code></pre>
<p>It gets a bit hairy because you're starting to tread into parsing territory.  Hard to know where to stop.</p>
<p>Since I'm not sure I just switched Graham's case to use a flat block.</p>
<pre><code> drugs: [
     "Benzbromarone" "SA1537.pdf"
     "Teriparatide" "SA1139.pdf"
     "Adalimumab" "SA1847.pdf"
     "Etanercept" "SA1812.pdf"
 ]
</code></pre>
<p>But it should be thought about more.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/destructuring-in-for-each/1738">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/destructuring-in-for-each/1738</link>
          <pubDate>Mon, 04 Oct 2021 20:08:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1738</guid>
          <source url="https://forum.rebol.info/t/destructuring-in-for-each/1738.rss">&quot;Destructuring&quot; in FOR-EACH</source>
        </item>
        <item>
          <title>COLLECT Mutation Semantics: KEEP vs. KEEP/ONLY</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>When reimplementing COLLECT for UPARSE on top of the "pending" model, <a href="https://forum.rebol.info/t/getting-hooks-into-events-during-parse/1640/10">I mentioned a potential avenue for optimization</a> by not immediately splicing blocks, but keeping them in a list and then merging the whole list together if-and-when the COLLECT got to the success point:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="10" data-topic="1640">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/getting-hooks-into-events-during-parse/1640/10">Getting Hooks Into "Events" during PARSE</a>
</div>
<blockquote>
<p>(Efficiency sidenote: I might should have used something like @[...] blocks for GATHER, and use BLOCK!s for KEEP to complement the QUOTED!s. This would save splicing until the very end COLLECT when you have a better idea of how big the total series will be.)</p>
</blockquote>
</aside>
<p>The idea of saving splicing until the end might sound good, but... it doesn't work if we presume mutations.</p>
<p>Just imagine a delaying implementation of ordinary COLLECT:</p>
<pre><code>&gt;&gt; delayed-splice-collect [
      block: [a b c]
      keep block
      clear block
      insert block [d e f]
      keep block
  ]
== [d e f d e f]
</code></pre>
<p>That's not what we expect from today's COLLECT.</p>
<p>Though if you're <em>not</em> splicing, you expect mutations to affect what you've already collected.  It's true in all Redbols today, since you're keeping the block by identity:</p>
<pre><code>red&gt;&gt; collect [
         block: [a b c]
         keep/only block
         clear block
         insert block [d e f]
         keep/only block
      ]
== [[d e f] [d e f]]
</code></pre>
<h2>
<a href="https://hypirion.com/musings/understanding-persistent-vector-pt-1">Persistent Vector</a> Looks Awfully Tempting  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_monocle.png?v=9" title=":face_with_monocle:" class="emoji" alt=":face_with_monocle:">
</h2>
<p>Looking at things like this is always a throwback to saying <em>"mutable state by default is garbage"</em>.  But it depends on what example you're looking at.  Sometimes it's good, sometimes it's bad.</p>
<p>I guess the thing is to just explore what the good parts are.  Maybe someone will blend in some Clojure bits at some point in a derivative...but that person is not going to be me!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/collect-mutation-semantics-keep-vs-keep-only/1706">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/collect-mutation-semantics-keep-vs-keep-only/1706</link>
          <pubDate>Sun, 05 Sep 2021 11:56:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1706</guid>
          <source url="https://forum.rebol.info/t/collect-mutation-semantics-keep-vs-keep-only/1706.rss">COLLECT Mutation Semantics: KEEP vs. KEEP/ONLY</source>
        </item>
        <item>
          <title>The Thorn of WORD! Usage with APPEND, SELECT, FIND, etc.</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Though I understand anyone being skeptical given the amount of debate: <em>I do honestly think I am zeroing in on "an answer" regarding the core ergonomics for things like APPEND</em>.  But it doesn't feel quite there yet.</p>
<p>The biggest point of discomfort relates to what I mentioned about WORD!s, which is proving to be a bigger deal in practice than I first realized:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="8" data-topic="1332">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/8">Every Thought On Array Splicing Has Been Had <img width="20" height="20" src="https://forum.rebol.info/images/emoji/twitter/exploding_head.png?v=9" title="exploding_head" alt="exploding_head" class="emoji"></a>
</div>
<blockquote>
<p><strong>The most obvious side-effect is that you won't be able to append WORD!s/PATH!s/etc. without making them quoted.</strong></p>
<pre><code>&gt;&gt; append [a b c] 'd
** Error: evaluative value must be QUOTED! to append
</code></pre>
</blockquote>
</aside>
<p><em>(Remember of course that APPEND is not receiving <strong>'d</strong> in this case.  The <strong>'</strong> suppresses the evaluation and "vaporizes" so that APPEND winds up receiving the <strong>d</strong>.  To get APPEND to receive a QUOTED! value you'd have to have said <strong>''d</strong> or <strong>the 'd</strong> or <strong>just d</strong> or some other such construction.)</em></p>
<p>Of course, we can just say "screw it" and allow it...and be no worse off than history (better, really).  But that's small comfort, as I think history was bad!</p>
<p>Quick refresher:</p>
<pre><code>rebol2&gt;&gt; value: first [d/e]
== d/e
rebol2&gt;&gt; append [a b c] value
== [a b c d e]
     ; ^-- not [a b c d/e]

rebol2&gt;&gt; value: first [(d e)]
== (d e)
rebol2&gt;&gt; append [a b c] value
== [a b c d e]
     ; ^-- not [a b c (d e)]

rebol2&gt;&gt; value: first ['d]
== 'd
rebol2&gt;&gt; append [a b c] value
== [a b c d]
    ; ^-- not for the Ren-C reason... LIT-WORD! decay on WORD!-fetch
rebol2&gt;&gt; append [a b c] first ['d]
== [a b c 'd]
    ; ^-- see what I mean?  yes this is all kinds of ridiculous
</code></pre>
<p><em>(Note: Red at least doesn't do that last one, there is no LIT-WORD! decay on word fetches.)</em></p>
<p>Point being: <strong>I want people to keep in mind just how crappy history was, in understanding why the search for better is worthwhile...especially if it kills off /ONLY.</strong></p>
<h2>Back To the WORD! Pain Point</h2>
<p>Among the places I'm finding it painful to not be able to just pass a WORD!, let's look at FIND.  You'll see code like:</p>
<pre><code>if not find data 'd [append data 'd]
</code></pre>
<p>The readability suffers a bit if you change this to BLOCK!.  In this example in particular, it gets harder to see the branch:</p>
<pre><code>if not find data [d] [append data [d]]
</code></pre>
<p>If you use double quotes it seems confusing:</p>
<pre><code>if not find data ''d [append data ''d]
</code></pre>
<p>It's likely similarly strange to most readers to wonder why you have to "quote twice" when you use the word QUOTE, but it's the generic substitute for /ONLY:</p>
<pre><code>if not find data quote 'd [append data quote 'd]
</code></pre>
<p>And then there's JUST, which reads well but hides a lot of mechanics (it's QUOTE THE):</p>
<pre><code>if not find data just d [append data just d]
</code></pre>
<p>I don't think this is any less learnable than /ONLY when you add it all up, and it has a mechanical rationale behind it.  But there's something else...</p>
<h2>Bigger Problem: What About OBJECT!</h2>
<p>If you take operations like FIND and SELECT they've historically been willing to operate on BLOCK! or OBJECT!.  Should the rules about not taking evaluative types apply to them, too?  :-/</p>
<pre><code>&gt;&gt; obj: make object! [a: 10 b: 20]

&gt;&gt; select obj 'a
** Error: SELECT can't take evaluative types, use QUOTED!

&gt;&gt; select obj ''a
== 10

&gt;&gt; select obj [a]
== 10   ; ???
</code></pre>
<p>So that's not good.</p>
<p><strong>But again, on the whole: there are some things going right here with the QUOTED! behavior...and some things going wrong here with the WORD! behavior...so it's important to stop and think.</strong></p>
<h2>One Weird Thought: What About <code>@WORD</code> ?</h2>
<p>Today, the "evaluator inert doesn't need a quote" rule means that the <code>@xxx</code> types--which are inert--append as-is:</p>
<pre><code>&gt;&gt; append [a b c] @d
== [a b c @d]  ; today's behavior, whereas appending a `d` WORD! errors
</code></pre>
<p>But since there are some types like BLOCK! or BLANK! or QUOTED! that are called out as "special" in terms of behavior w.r.t. the likes of APPEND, what if the inert @ types were treated like QUOTED!?</p>
<pre><code>&gt;&gt; append [a b c] @d
== [a b c d]  ; since appending [d] and 'd are special, why not @d too?
</code></pre>
<p>This doesn't really help you if you're trying to append SET-WORD!s or other parts to the block, because there's no <strong><code>@foo:</code></strong> type (for instance).  But in the specific case of words, it helps...and that's the case where we have the issue with object keys.</p>
<p>How far would this go?  Would <code>@word</code> become the universal sign of the key?  Might it be what's offered as the key in FOR-EACH loops?</p>
<pre><code>&gt;&gt; obj: make object! [a: 10 b: 20]
&gt;&gt; for-each [key val] obj [print [mold key mold val]]
@a 10
@b 20
</code></pre>
<p>I'll point out that there are some benefits to these non-evaluative types taking on a bigger role.  When you COMPOSE or use them in the API, plain WORD! can be very inconvenient to handle...you're always having to throw in quotes to suppress their evaluation.  Remember that when you write <strong>'a</strong> you're getting a pass on that being inert for just that one evaluation...whoever receives it still has to treat it as a hot potato.</p>
<p><strong>I'm just throwing out an idea, here.</strong>  But really, I don't know.  I think making QUOTED! types append their quoted argument as-is is a winner, and I believe it's fundamental to Rebol's DNA that BLOCK! splice by default.  Yet I think the safety net of catching evaluative types is a way of saying <em>"oh, you're putting together something that could be CODE!"</em> where you can catch cases where values might be splicing blocks or throwing away their quotes on accident.</p>
<hr>
<p><strong>And of course we can wuss out and just say WORD! is special.</strong>  After all, QUOTED! is an evaluative type and it's given special meaning in APPEND.  (But that is sort of the point--since it has special meaning, we try to protect usages of the other evaluative types from being misinterpreted.)</p>
<p>I don't really think there's any particular value in saying that the <code>@xxx</code> types are uniquely able to be appended as-is since they are inert, so it kind of feels like a nice option to let them mean append themselves minus the <code>@</code>.  However that implies that ^[...] and @[...] would act the same for APPEND... via different mechanisms.</p>
<pre><code>&gt;&gt; append [a b c] @d
== [a b c d]

&gt;&gt; append [a b c] @d/e
== [a b c d/e]

&gt;&gt; append [a b c] @d.e
== [a b c d.e]

&gt;&gt; append [a b c] @(d e)
== [a b c (d e)]

&gt;&gt; append [a b c] @[d e]
== [a b c [d e]]  ; due to internal logic of APPEND with @

&gt;&gt; append [a b c] ^[d e]  ; -&gt; append [a b c] the '[d e]
== [a b c [d e]]  ; due to internal logic of APPEND with QUOTED!
</code></pre>
<h2>Or we can fully wuss out and say there's no protection</h2>
<pre><code>&gt;&gt; append [a b c] 'd
== [a b c d]

&gt;&gt; append [a b c] ''d
== [a b c d]

&gt;&gt; append [a b c] [d]
== [a b c d]

&gt;&gt; append [a b c] '[d]
== [a b c d]

&gt;&gt; append [a b c] ''[d]
== [a b c [d]]

&gt;&gt; append [a b c] quote [d]
== [a b c [d]]

&gt;&gt; append [a b c] ^[d]
== [a b c [d]]
</code></pre>
<p>But I think this should be considered carefully.</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/the-thorn-of-word-usage-with-append-select-find-etc/1653">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-thorn-of-word-usage-with-append-select-find-etc/1653</link>
          <pubDate>Tue, 10 Aug 2021 23:55:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1653</guid>
          <source url="https://forum.rebol.info/t/the-thorn-of-word-usage-with-append-select-find-etc/1653.rss">The Thorn of WORD! Usage with APPEND, SELECT, FIND, etc.</source>
        </item>
        <item>
          <title>UPARSE needs BREAK, REJECT, ACCEPT... But What Are They?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>When something doesn't sit right in my head, I notice.  Like how I could never remember in the beginning what GET-WORD! or SET-WORD! in PARSE did.  <em>(e.g. is a GET-WORD! GET-ing the parse position to SET a variable, or GET-ting a variable's value to use to SET the parse position?)</em></p>
<p>And I never really understood ACCEPT, REJECT, BREAK, and FAIL.</p>
<h2>I Currently Consider the FAIL Confusion "Solved"</h2>
<p>Things have settled nicely, in that LOGIC! is used to get a pure "keep going" or "stop".  So FAIL is replaced simply by FALSE.  It means <strong>if (expression-returning-logic)</strong> is replaced in UPARSE as <strong>:(expression-returning-logic)</strong>, and we can keep FAIL on the meaning of "raise error".</p>
<p>This generalization has the pleasing property that we don't need to go introducing "parse switch" or "parse case" or any such things.  Since NULL means the same thing as #[true] for a GET-GROUP! splice, you have every option at your disposal.</p>
<h2>BREAK and REJECT Seem Too Similar</h2>
<p>The problem I have is that BREAK sounds a lot like "this didn't work".  In fact, I've enforced that loops return NULL if-and-only-if you BREAK them:</p>
<pre><code>&gt;&gt; repeat 3 [break]
; null

&gt;&gt; repeat 3 [null]
== ~null~  ; isotope
</code></pre>
<p>A NULL is used as a signal of "soft failure", e.g. it causes ELSE to run.</p>
<pre><code> &gt;&gt; repeat 3 [break] else [print "soft failure"]
 soft failure

 &gt;&gt; repeat 3 [null] else [print "soft failure"]
 == ~null~  ; isotope
</code></pre>
<p>So the distinction between BREAK and REJECT seems a thin one.  I feel like I'd rather that BREAK meant you decided the iterated rule isn't working out...and some other signal indicated that you want to accept it and go on.</p>
<p>But ACCEPT doesn't really hint at ceasing iteration.  Perhaps STOP?  As a word, it hints more at the ceasing of an iteration...and that's used in CYCLE.</p>
<pre><code>&gt;&gt; cycle [stop]
== ~void~  ; isotope
</code></pre>
<p>Unlike BREAK (which always returns NULL) it is able to return a non-NULL...and a NULL will be isotopified so it won't be seen as a "soft failure" by ELSE:</p>
<pre><code>&gt;&gt; cycle [stop 10]
== 10

&gt;&gt; cycle [stop null]
== ~null~  ; isotope
</code></pre>
<p>Similarly, if you're going to be saying an iterative construct in PARSE is to keep going, then you should have an opportunity to say what the value synthesized from that rule will be.  This requires "endable" rules (because we want a plain stop to work).  I think that's doable.</p>
<p>So I guess I'm saying prefer BREAK to mean rule failed... return NULL.  And STOP to mean rule succeeded.  Default to returning a void isotope if no argument given, but allow an argument.  The argument would be a rule, so you could actually make the STOP a rule.</p>
<pre><code>&gt;&gt; uparse "aaab" [while ["a" (print "A") | stop ["b" (1020)]]]
A
A
A
== 1020
</code></pre>
<h2>What About CONTINUE ?</h2>
<p>If your loop is only one deep in alternates, then all an alternate needs to do continue is succeed:</p>
<pre><code>&gt;&gt; uparse "aaab" [while ["a" comment "continue" | "b" comment "continue"]]
</code></pre>
<p>But if you're deeper than that, it is trickier.  And I don't see any particular reason why you shouldn't be able to ask a rule to CONTINUE a loop.</p>
<pre><code>&gt;&gt; uparse "abbbaccc" [while [
    "a" [some "bbb" (print "BBB"), continue | some "ccc" (print "CCC")]
    (print "like this!")
]
BBB
CCC
like this!
</code></pre>
<p>And CONTINUE could also take an argument, which would matter only if it was the final iteration:</p>
<pre><code>&gt;&gt; uparse "bba" [repeat (3) ["a" continue (&lt;like this&gt;) | "b"]]
== &lt;like this&gt;
</code></pre>
<h2>Would That Be an Improvement?</h2>
<p>I think CONTINUE is pretty obviously useful.</p>
<p>One thing that's a bit weird about what I suggest is that when a BREAK happens in a <em>non-parse</em> loop, the code after it runs.</p>
<p>But the idea that "failure" stops progression is a cross-cutting design aspect in PARSE.  It seems consistent to me.</p>
<p>Yet another issue is that STOP is not currently offered by plain WHILE or REPEAT or FOR-EACH or other loops.  The reason is that if you are to try and write your own iterator in terms of other iterators, you cannot tell from the outside if a "cease iterating" intention happened.</p>
<p>Consider this:</p>
<pre><code>&gt;&gt; opaque-code: [print "looping", 1000 + 20]

&gt;&gt; repeat 2 (opaque-code) then [repeat 2 (opaque-code)]
looping
looping
looping
looping
== 1020
</code></pre>
<p>That's nice because if the opaque-code has a break, the whole thing will break:</p>
<pre><code>&gt;&gt; opaque-code: [print "entering", break]

&gt;&gt; repeat 2 (opaque-code) then [repeat 2 (opaque-code)]
entering
; null
</code></pre>
<p>But if you permit STOP to return a value, the stopping intent is lost:</p>
<pre><code>&gt;&gt; opaque-code: [print "entering", stop 1020]

&gt;&gt; repeat 2 (opaque-code) then [repeat 2 (opaque-code)]
entering
entering
== 1020
</code></pre>
<p>When you're trying to write compound looping expressions that are built up of smaller loops, this really matters.  CYCLE is an oddball because you know the only way it <em>ever</em> terminates with a value is if there was a stopping intent...which is why it allows STOP.</p>
<h2>Maybe ACCEPT and REJECT Should Be Used and No BREAK?</h2>
<p>...but this kind of runs into the same problem that non-PARSE WHILE doesn't have ACCEPT or REJECT.  So why get worked up about it having STOP when non-PARSE WHILE doesn't have STOP, if it makes everything line up?</p>
<p>Or maybe non-PARSE while <em>can</em> have STOP...you just understand that STOP has limits when it comes to loop abstraction.  Not everything works all the time.  So STOP can have a warning on it that you can't tell the stopping intent happened from outside a loop that isn't CYCLE...</p>
<h2>What Do You Think?</h2>
<p>Are the needs of PARSE different, or the same?  Should BREAK make the overall expression evaluate to NULL <em>but</em> keep going?  Are ACCEPT and REJECT the right answer?</p>
<p>It's hard to say.  I have to work out the mechanism by which such things could work in usermode combinators whatever you call them...so there's time to think about it.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/uparse-needs-break-reject-accept-but-what-are-they/1650">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/uparse-needs-break-reject-accept-but-what-are-they/1650</link>
          <pubDate>Sat, 07 Aug 2021 11:51:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1650</guid>
          <source url="https://forum.rebol.info/t/uparse-needs-break-reject-accept-but-what-are-they/1650.rss">UPARSE needs BREAK, REJECT, ACCEPT... But What Are They?</source>
        </item>
        <item>
          <title>BLOCK! Behavior In DELIMIT (hence SPACED, UNSPACED, PRINT)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Because I've thought of Redbols as targeting being a kind of "user friendly" and intuitive language, I was long bent out of shape about how junky things like PRINT and REJOIN were.</p>
<p>If your "Hello World" level programs are unpredictable nonsense, I don't see how you know where to start.  :-/</p>
<p>So an early thing I came up with was the idea to replace REJOIN with something that had some nice learnable invariants...which was called COMBINE.  It was harder than I thought.</p>
<p>Among the various philosophies that were tried out, was that blocks would be reduced recursively:</p>
<pre><code>&gt;&gt; var: "World"

old&gt;&gt; print ["Hello" var]
Hello World

&gt;&gt; block: ["Hello" var]

&gt;&gt; print ["((" block "))"]
(( Hello World ))
</code></pre>
<p>But I began having second thoughts, because it seemed like reducing blocks inside the print was a bit "dangerous".  You were in an evaluative context so if you wanted reduction you could ask for it.</p>
<p>Many ideas were tried over time, such as using BLOCK! as a means of getting "tight spacing" so you could intermix spaced and unspaced portions:</p>
<pre><code>&gt;&gt; print ["Outer" "spaced" ["inner" "not" "spaced"] "was an" "idea"]
Outer spaced innernotspaced was an idea
</code></pre>
<p>This seemed to give a best of both worlds scenario.  But it wasn't clear whether the blocks should be reduced, or exactly what this "unspaced non-reduced block" operation was.</p>
<h2>Today, I Think We Have A Direction and Rationale</h2>
<p><a href="https://forum.rebol.info/t/print-for-empty-block-empty-text-or-text-of-just-spaces/1641">I just posted my reasoning for why I think this should be true</a>:</p>
<pre><code>&gt;&gt; print ["abc" [] "def"]
abc def
</code></pre>
<p>Rebol2 and Red throw in two spaces and that's no good.</p>
<p>If BLOCK! is going to be an aggregator for material inside of PRINT then the base case needs to basically act as if no material is there.  Otherwise it's mostly useless, e.g. it couldn't be used for indentation:</p>
<pre><code>print [collect [repeat indent [keep tab]]], "what if indent is 0?"]
</code></pre>
<p>With that laid down I think it's safe to say that we want what's in a BLOCK! to be considered as being <em>pre-reduced</em>.  But also, <em>that it be unspaced</em>.</p>
<pre><code>&gt;&gt; word: "part"
== "part"

&gt;&gt; print ["Mixing" ["unspaced" word] "with" "spaced" word]
Mixing unspacedword with spaced part
</code></pre>
<p>We have a nice tool now with GET-BLOCK! that will reduce, so you have every tool on hand:</p>
<pre><code>&gt;&gt; print ["Mixing" :["unspaced" word] "with" "spaced" word]
Mixing unspacedpart with spaced part
</code></pre>
<h2>Invariant For BLOCK! Inside DELIMIT (hence PRINT, etc)</h2>
<p>So I came up with a good model for what the BLOCK! inside of the PRINT above will do.</p>
<p><strong>It does the same thing that APPEND of a BLOCK! to a string would do.</strong></p>
<pre><code>&gt;&gt; append copy {} ["unspaced" word]
== "unspacedword"
</code></pre>
<p><strong>Whatever that is, that's what happens with blocks in print.</strong>  So it's not FORM-ing, and no spaces.  It's the behavior of raw material being appended blockwise to a string.</p>
<p>This keeps us from having to define a separate new behavior.  It doesn't define that behavior, so we're not out of the woods.  But as I say, it's a slow process...one step at a time.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/block-behavior-in-delimit-hence-spaced-unspaced-print/1642">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/block-behavior-in-delimit-hence-spaced-unspaced-print/1642</link>
          <pubDate>Sat, 31 Jul 2021 17:35:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1642</guid>
          <source url="https://forum.rebol.info/t/block-behavior-in-delimit-hence-spaced-unspaced-print/1642.rss">BLOCK! Behavior In DELIMIT (hence SPACED, UNSPACED, PRINT)</source>
        </item>
        <item>
          <title>MOLD and LOAD parity</title>
          <dc:creator><![CDATA[rgchris]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>It occurred to me in <a href="https://forum.rebol.info/t/the-simple-things-matter-the-most/1428/8">this post</a> that MOLD/ONLY appears to work at odds to other /ONLY options:</p>
<pre><code>&gt;&gt; append [] []
== []

‌&gt;&gt; append/only [] []
== [[]]

‌&gt;&gt; mold []
== "[]"

‌&gt;&gt; mold/only []
== ""
</code></pre>
<p>As <a href="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/10">my solution to /ONLY</a> is to use an optimized equivalent of <a><strong>func [value][reduce [value]]</strong></a>, this highlights the discrepency:</p>
<pre><code>&gt;&gt; append only [] []  ; same as append/only
== [[]]

&gt;&gt; mold only []  ; not same as mold/only
== "[[]]"
</code></pre>
<p>How then should MOLD handle blocks, and what are the implications for LOAD? Let's assume that current MOLD/ONLY is the correct behaviour for BLOCK!:</p>
<pre><code>&gt;&gt; mold [1 2 3]
== "1 2 3"

&gt;&gt; load "1 2 3"
== [1 2 3]
</code></pre>
<p>This seems fine until you get to single-length blocks:</p>
<pre><code>&gt;&gt; mold [1]
== "1"

&gt;&gt; load "1"
== 1
</code></pre>
<p>Clearly this is now an inconsistency in LOAD. LOAD/ALL would get you there:</p>
<pre><code>&gt;&gt; load/all "1"
== [1]
</code></pre>
<p>Should LOAD/ALL then be the default? Probably. Proposition: MOLD/ONLY and LOAD/ALL become MOLD and LOAD. Yay! There is a parity where it matters most: (de)serialization of a block of values.</p>
<p>The wrinkle is: loading singular values is useful. Lost is the MOLD/LOAD parity when handling non-blocks:</p>
<pre><code>&gt;&gt; mold 1
== "1"

&gt;&gt; load "1"
== [1]
</code></pre>
<p>Where to go with that? Lost is shorthand validation of snippets of text:</p>
<pre><code>&gt;&gt; type-of load "10-Dec-2020"
== date!

&gt;&gt; type-of load "http://rebol.info"
== url!
</code></pre>
<p>I'd argue that this is beyond the scope of LOAD—LOAD is an overloaded (<img src="https://forum.rebol.info/images/emoji/twitter/sunglasses.png?v=9" title=":sunglasses:" class="emoji" alt=":sunglasses:">) function and the more critical behaviour is to return a block. It would be more fitting to dedicate a separate wrapper for TRANSCODE that is less likely to use the polymorphic demands of loading from external sources and craps out if, leading/trailing whitespace aside, the content doesn't conform to a single value (even if that value is a GROUP!). Spitballing—DETECT, DISCERN, whatever:</p>
<pre><code>&gt;&gt; map-each value ["10-Dec-2020" "http://rebol.info"] [type-of detect value]
== [date! url!]

&gt;&gt; detect "1 2 3"
== ERROR! #!*^!#%@$
</code></pre>
<p>Thus MOLD of BLOCK! holds parity with LOAD; MOLD of non-block holds parity with DETECT (or other name).</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/mold-and-load-parity/1429">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/mold-and-load-parity/1429</link>
          <pubDate>Thu, 10 Dec 2020 23:00:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1429</guid>
          <source url="https://forum.rebol.info/t/mold-and-load-parity/1429.rss">MOLD and LOAD parity</source>
        </item>
        <item>
          <title>What should do of empty block (`DO []`) do?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>I've pointed out that the answer for things like "what should a loop that never runs its body" have varied.</p>
<pre><code>rebol2/r3-alpha&gt;&gt; type? while [false] ["whatever"]
== none!

red&gt;&gt; type? while [false] ["whatever"]
== unset!
</code></pre>
<p>But it's consistent historically that if something runs <strong>do []</strong> then you get an "UNSET!"</p>
<pre><code>rebol2/r3-alpha/red&gt;&gt; type? do []
== unset!
</code></pre>
<h2>New Names Available</h2>
<p>One of the benefits of having lots of different labeled BAD-WORD!s is to stop collapsing all "potentially error-triggering situations" into the same uninformative name.</p>
<pre><code>&gt;&gt; do []
== ~empty~  ; isotope
</code></pre>
<p>Or maybe that's considered to be where ~void~ isotopes comes from:</p>
<pre><code>&gt;&gt; do []
== ~void~  ; isotope
</code></pre>
<p>In either case, you've still got a type that will be "ornery" and neither true nor false, that errors if you try to access it.  But by not reporting <code>~unset~</code> you're helping to convey that this wasn't the by-product of encountering an unset variable somewhere.  It might help people get their bearings more easily.</p>
<p>I've mentioned that this is a bit unfortunate in the sense of canonizing English into the evaluator mechanics.  But I'm taking away the option by <a href="https://forum.rebol.info/t/void-choices-the-role-of-english-in-the-evaluator/1413/6">removing <code>~</code> as a form of BAD-WORD!</a>...which is what this case had been before.</p>
<h2>Or Is This A Job For NULL ?</h2>
<p>We have some cases where emptiness produces pure NULL.  With DELIMIT and its specializations, an all empty block produces the same thing that an all-NULL-producing block produces:</p>
<pre><code>&gt;&gt; unspaced [if false ["a"] if false ["b"]]
; null

&gt;&gt; unspaced []
; null

&gt;&gt; unspaced compose [(if false ["a"]) (if false ["b"])]
; null
</code></pre>
<p>There's some neat combining of this with PRINT.  Although PRINT draws your attention to calling with NULL via error, a BLANK! will get it to overlook that and just be a no-op:</p>
<pre><code>&gt;&gt; print unspaced compose [(if false ["a"]) (if false ["b"])]
** error, print doesn't take NULL

&gt;&gt; print try unspaced compose [(if false ["a"]) (if false ["b"])]
; null
</code></pre>
<p><strong>Can anyone think of a case where there's a balance of provable value for something like a <code>do compose [...]</code> whose contents have all boiled away to be NULL instead of ~void~ ?</strong></p>
<p>You could get the same result by saying <strong>do compose [null (...whatever...)]</strong> so it's not far out of reach to have a default value of anything you like.</p>
            <p><small>16 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426</link>
          <pubDate>Wed, 09 Dec 2020 23:45:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1426</guid>
          <source url="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426.rss">What should do of empty block (`DO []`) do?</source>
        </item>
        <item>
          <title>Every Thought On Array Splicing Has Been Had :exploding_head:</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>...so it's time to take what's known and tie it all up.  <img src="https://forum.rebol.info/images/emoji/twitter/brain.png?v=9" title=":brain:" class="emoji" alt=":brain:"></p>
<p>Here goes:</p>
<h2>BLOCK!s (and only plain BLOCK!s) Splice By Default</h2>
<p>This is to say that BLOCK! is <em>The</em> universal container (<strong>"[o]"</strong>).  Splicing of the contents of a non-block is done by aliasing it as a block first...which can be done efficiently without copying memory.</p>
<p>It was always obvious to me that PATH!s should not splice.  But I didn't have any real guidance on GROUP!, or the new types like SET/GET-BLOCK!/GROUP! (and whatever <strong>@[block]</strong> or <strong>@(group)</strong> ultimately gets called).  It was a toss up between <em>"anything that uses spaces to separate elements splice, and anything tighter--like tuples/paths--not"</em> vs. <em>"the logo is [o], so anything with brackets is special"</em> (I was pretty sure <em>"do whatever Rebol2 did"</em> was not a good idea).</p>
<p>But I think there's a better narrative for justifying this solution.  Looking at other languages like Haskell/Rust/Elm, they all used parentheses for tuples...where their notion of a tuple is fixed-size with elements that aren't necessarily of the same type.  This led me to think about the question of if BLOCK!'s universal containerness might make it something you don't just pick automatically...you'd pick something else when splicing wasn't what you'd <em>typically</em> want.</p>
<p>Here's a made-up example:</p>
<pre><code>add-new-products: func [product-list: [block!]] [
    product1: '(#WID-0304 "Super Widget" $1.99)
    product2: '(#WID-1020 "Super Widget Plus" $2.00)

    append product-list product1
    append product-list product2
    append product-list [
        (#WID-0421 "Super Widget Premium" $2.01)
        (#WID-9999 "Super Widget Ultimate" $102,003.04)
    ]
]
</code></pre>
<p>See how light the generic quoting made the GROUP! literals?  Now this makes the choice of BLOCK! vs. GROUP! something that you can reason about better.  You can take advantage of the difference so you're not fighting the behavior--but "synergizing" with it.</p>
<p>But also...with <strong>@[...]</strong>/etc that doesn't splice, you have more options for shifting your data's conception of itself as it is passed around.</p>
<p>I'll point out that since there's no @ or : in the logo, this does ultimately dovetail nicely with "what's in the logo is special"...it's not just any bracketed thing, it's plain BLOCK!.   <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<h2>
<a href="https://forum.rebol.info/t/new-parameter-convention-concept-modal-arguments-or-the-arg/1187">"Modal Parameters"</a> are the Answer for Anti-Splicers</h2>
<p>I've been trying to embrace <a class="mention" href="/u/rgchris">@rgchris</a>'s concept that the language bias should stick to making it so that "common" code does not lean too strongly on symbols to convey meaning.  While you can retrain yourself to comprehend pretty much any symbol soup, letting your mindset drift to that "new normal" isn't good for communicating code to others.  <em>(And it's probably not good for your own ability to see clearly, either...even if you -think- you understand what you're doing.)</em></p>
<p>This has to be balanced against many other design factors; to which I'm sensitive because I actually understand what it takes to make things <em>work</em> at a mechanical bits-and-bytes level.  So this pushes back and forth.</p>
<p>Modal parameters give an easy mechanism to library authors, or others who want a rigorous way to append values "as is" without typing /only at every callsite.</p>
<pre><code>&gt;&gt; append [a b c] @[d e]
== [a b c [d e]]

&gt;&gt; item: @[d e]
&gt;&gt; append [a b c] item
== [a b c @[d e]]  ; modality comes from parameter, not fetched value

&gt;&gt; append [a b c] '@[d e]
== [a b c @[d e]]  ; quoting suppresses modality, then evaluates away

 &gt;&gt; do compose [append [a b c] '(third [&lt;d&gt; #e @[f g]])]
 == [a b c @[f g]]  ; quoting in COMPOSE is there to help in cases like this
</code></pre>
<p>It's not something that has to be brought up in early tutorials.  But I like it.  And it's a generic mechanism that people can use when they want a parameter to indicate the mode of a refinement...so there's generic uses for it.</p>
<h2>Further changes to APPEND and such will be abandoned</h2>
<p>I experimented with making APPEND only accept blocks, and then maybe blocks and strings, and other kinds of tweaks.  They weren't worth it.</p>
<p>What's changing the game here is making BLOCK! the only type that splices by default.</p>
<p>It used to be that when you had a moment of doing an append of some parameter--that wasn't a block before but suddenly is now--you groaned and said <em>"why'd I forget the /ONLY"</em> or <em>"why does this darn thing behave so randomly"</em>.</p>
<p>Now a new thing you can ask in many of these moments is: <em><strong>"Why was this value a plain block if I didn't want it to splice??"</strong></em>  It should feel less random, when you have more alternatives.  I'm going to look at my array choices in this new light, and maybe need /ONLY less often as a result.</p>
<p>Modal parameters are good to have to point people to who aren't on board with splice-by-default.  And I'm willing to accept the burden of using a modal parameter to enter an @ symbol when I want it.  It saves significant evaluation time over APPEND/ONLY, and doesn't require a series node allocation to hold the APPEND and ONLY words.</p>
<h2>BLOCK! Conversions Needed</h2>
<p>Because the only way to get splicing is now to have a block, it raises the question of how to get blocks.</p>
<p>AS BLOCK! is cheap; it doesn't allocate any memory, it just aliases the series as a different cell class.  So it's a good choice if you know what you have is an array.</p>
<pre><code>&gt;&gt; group: '(d e f)
&gt;&gt; append [a b c] as block! group
== [a b c d e f]
</code></pre>
<p>If you don't know if you have an array value or not, this is a little harder.  But we can actually turn items into a one-cell BLOCK! <em>without allocating any memory</em>.  This is a new trick which was called mirroring, but the mechanism is changed to where it needs a new name.  The new block is read only, but that is okay for the purposes of this append since it's gone after the splice.</p>
<p>The name for the operation I had in mind was BLOCKIFY (though it's not using the mirroring mechanism at the moment, only the PATH! trick is, which proves it does work).</p>
<pre><code>&gt;&gt; value: '(d e f)
&gt;&gt; append [a b c] blockify value  ; [d e f]
== [a b c d e f]

&gt;&gt; value: 1020
&gt;&gt; append [a b c] blockify value  ; [1]
== 1020
</code></pre>
<p>But that's a weird looking word, and I hate having to have lists of things like this (groupify?  set-groupify?)  The concept from the other day of FORCE might be interesting</p>
<pre><code>append [a b c] force block! value
</code></pre>
<p>That's at least generic, and it kind of conveys "I want a block, if it's a block then great, if not then change it".  But that makes it sound like its <em>changing</em> the input value to be a block, vs. wrapping it.</p>
<p>But maybe AS can wing it, and say that if you give it a non-block it can just do the wrapping in a block anyway and give you something read-only?  :-/  I mean, the user doesn't know that every single-valued item doesn't secretly live in a 1-element array in the implementation...it might.  Hmmm.</p>
<p>Anyway, this name looks like the only missing piece.  What do you call something that doesn't do any memory allocation but just makes a light 1-element wrapper that can live in a cell, to keep us from having to add more crazy refinements?</p>
<p>It's not a super high priority as most cases are known to be AS (in the form known today)</p>
<h2>Speak Up or Hold Your Peace</h2>
<p>Like I say, I think I've probably had all the thoughts.  There aren't any more to be had.  If you want to prove me wrong, post it here...but do it soon.</p>
            <p><small>7 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332</link>
          <pubDate>Sat, 19 Sep 2020 21:02:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1332</guid>
          <source url="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332.rss">Every Thought On Array Splicing Has Been Had :exploding_head:</source>
        </item>
        <item>
          <title>Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>The following Redbol-ism long seemed unnatural to me, of defaulting to breaking paths apart unless you say /ONLY:</p>
<pre><code>rebol2&gt;&gt; append [a b c] first [d/e/f g/h/i]
== [a b c d e f]

rebol2&gt;&gt; append/only [a b c] first [d/e/f g/h/i]
== [a b c d/e/f]
</code></pre>
<p>This raises people's questions about why blocks should default to that, which confuses many a newcomer...and which I was opposed to when I first saw it.</p>
<pre><code>rebol2&gt;&gt; append [a b c] first [[d e f] g/h/i]
== [a b c d e f]
</code></pre>
<p>Ultimately it came to be that using Rebol in practice made me feel splicing was the natural default for many block operations.  <strong>But something long remained uncomfortable with this pattern...</strong> which applies to other routines with this kind of /ONLY (for instance, FIND)...is how it's hard to tell at the callsite what's going to happen when you are talking about data indirectly:</p>
<pre><code> rebol2&gt;&gt; item: [a b c]

 ;... then much later, callsite might suddenly stop working generically
 ;... when you suddenly switch item to a block from something else:

 rebol2&gt;&gt; find reduce [1 + 2 item 3 + 4] item
 == none
</code></pre>
<h2>The known existing schools of thought</h2>
<ol>
<li>
<strong>"splicing should be the special operation"</strong> - you should have to ask for <code>append/splice</code> to get it, with all other appends defaulting to being /ONLY.  More generically the term might be something like <code>/multi</code> so it works e.g. with <code>find/multi</code>
</li>
<li>
<strong>"there's something special about BLOCK!"</strong> - this could be thought of as reinforced logographically by the distinction of using brackets in the <strong>[o]</strong>, that makes it work, so you just know they are weird.<br>
2b. <strong>"there's something special about datatypes where space is the delimiter</strong>, so BLOCK! and GROUP! <em>both</em> count</li>
<li><strong>"it's too late to change any of it it, so leave it as is"</strong></li>
</ol>
<p>I was convinced <span class="hashtag">#1</span> was probably not in Rebol's best interest.  But then I disliked auto-splicing of PATH! enough that I rejected <span class="hashtag">#3</span> as a least-favorite option.  So at one point Ren-C was switched to using <span class="hashtag">#2b</span>.  But...</p>
<h2>Informing this further with a new use case</h2>
<p>I just ran into a problem with <a href="https://forum.rebol.info/t/should-datatype-be-killed-off-in-favor-of-integer-word-etc/1177/7">my proposed usage of @[...] to be an irreducible capture of a datatype, that can also carry a quoting level</a>.  That doesn't work if @[...] blocks are considered a container that needs /ONLY for things like FIND:</p>
<pre><code> find reduce [integer! quoted-word!] quoted-word!
</code></pre>
<p>Becomes:</p>
<pre><code>find [@[integer] @['word]] @['word]
</code></pre>
<p>It today assumes the @[...] is to be handled the same a a regular block.  So this is morally equivalent to:</p>
<pre><code>find [@[integer] @['word]] ['word]
</code></pre>
<p>Which acts the same as:</p>
<pre><code>find [@[integer] @['word]] lit 'word
</code></pre>
<p>That doesn't do what's intended, and doesn't match the datatype.  But it feels ever more haphazard to just pick a random reasoning.</p>
<p><strong>What it makes me feel is that there's just something fundamentally wrong being glossed over.</strong></p>
<h2>Concept: expect [...] <em>always</em>, splice <em>always</em>, leverage :[...]?</h2>
<p>It feels like "at the source level", you want to be able to see whether what you're passing along is going to be treated atomically or not.  This is a parallel to other problems, like what caused <a href="https://forum.rebol.info/t/backpedaling-on-non-block-branches/476">"Backpedaling on non-block branches"</a>.  That was mitigated with <a href="https://forum.rebol.info/t/soft-quoted-branching-light-elegant-fast/1020">soft quoted branching</a>, which carries some other advantages.</p>
<p>One idea could be that <em>appends, insert, finds, etc. always take BLOCK! and always presume splicing semantics</em>.</p>
<pre><code>&gt;&gt; append [a b c] [1 + 2 10 + 20]
== [a b c 1 + 2 10 + 20]  ; compatible with history

&gt;&gt; append [a b c] 3
** Error: APPEND does not accept INTEGER! for its value argument
; Not compatible, but at least an error and not random new behavior

&gt;&gt; append [a b c] [3]
== [a b c 3]  ; compatible with history
</code></pre>
<p>Also allow GET-BLOCK! to ask for reduction along with your splicing:</p>
<pre><code> &gt;&gt; append [a b c] :[1 + 2 10 + 20]
 == [a b c 3 30]
</code></pre>
<p>Block parameters (the only type which would be tolerated) passed in would be spliced--because as mentioned it always takes a block parameter, and they're always spliced:</p>
<pre><code> &gt;&gt; items: [1 [2 + 3] 4]
 &gt;&gt; append [a b c] (second items)
 == [a b c 2 + 3]
</code></pre>
<p>But you could slip past this by using a GET-BLOCK! that has your expression in it...thus it would reduce and get spliced, but leaving the original alone...effectively an /ONLY:</p>
<pre><code> &gt;&gt; items: [1 [2 + 3] 4]
 &gt;&gt; append [a b c] :[second items]
 == [a b c [2 + 3]]
</code></pre>
<h2>Further radicalization - soft quote the second argument?</h2>
<p>If you'd be willing to write <strong>append [a b c] (second items)</strong> always instead of <strong>append [a b c] second items</strong>, <em>then all of the above is compatible with soft-quoting</em>.  You could then use literal material as-is, which could work for BLOCK! and other things:</p>
<pre><code> &gt;&gt; append [a b c] '[1 + 2 10 + 20]
 == [a b c [1 + 2 10 + 20]]

 &gt;&gt; append [a b c] '3
 == [a b c 3]
</code></pre>
<p>As with branching, non-quoted things would complain if you didn't give it a BLOCK!:</p>
<pre><code>&gt;&gt; item: 10
&gt;&gt; append [a b c] (item)
** Error: APPEND only takes BLOCK!, GET-BLOCK!, or QUOTED!

&gt;&gt; append [a b c] [item]
== [a b c item]

&gt;&gt; append [a b c] :[item]
== [a b c 10]

&gt;&gt; append [a b c] '10
== [a b c 10]

&gt;&gt; item: [1 + 2 10 + 20]
&gt;&gt; append [a b c] (item)
== [a b c 1 + 2 10 + 20]
</code></pre>
<p>It would work how an IF doesn't have the rule on its condition but only the branch, it's just the thing to be appended:</p>
<pre><code> &gt;&gt; target: "abcd"

 &gt;&gt; append target ["efg"]
 == "abcdefg"

 &gt;&gt; append target '{ghi}
 == "abcdefghi"
</code></pre>
<h2>Pros</h2>
<ul>
<li>
<strong>You aren't confused when you see <code>append x (y)</code> about what <code>y</code> is going to look up to.  Because if it weren't a block, that would be an error.</strong>  Being introduced from day one to APPEND+INSERT+CHANGE as operations that expect a block of things to be appended... and FIND+SELECT as taking a block of things to be found, might seem strange to us now...but I think the net complexity drops compared to /ONLY and the problems it causes.</li>
<li>
<strong>Kills off the idea of /ONLY and all the mire that accompanies it</strong>.  It is so easy to make mistakes with that, no matter how experienced in Rebol code you are.  I don't feel any satisfying solution has been articulated about it.</li>
<li>
<strong>Has a good alignment with the [o] meaning BLOCK! is a special datatype</strong>.  Sets up a psychological basis for working coherently, and hopefully not making mistakes down the road.  Suggests people use blocks to represent groups of parameters as arguments to functions instead of single items <em>systemically</em>...a better principle to embrace than expecting them how to realize to design every routine with an /ONLY option...which was <a href="https://forum.rebol.info/t/stopping-the-into-virus/705">a bit like the /INTO virus</a>
</li>
<li>
<strong>Can cover REPEND-style cases where the block being repended is source-level with expressions (likely most common)</strong>.  If it's quoting the second argument, it could blend the evaluator into the operation, even if that evaluation is just to reduce a variable name for you to be the item to append.  There's been some amount of issue about performance when the natives are <code>reduce</code> and <code>append</code> and executed in two steps, whereas a reducing append that saw the source GET-BLOCK! could build a right-sized block more efficiently.</li>
<li>
<strong>Single element blocks are pretty efficient; moreso than refinements</strong>  I've mentioned how the design has been set up such that <code>:[a]</code> fits in a single series node, so it's not horrible to need to say <code>append data :[item]</code> instead of <code>append data item</code>... it's actually <em>better</em> than <code>append/only data item</code>.  And quoted things are efficient too, so <code>append data '10</code> costs the same as <code>append data 10</code>.</li>
</ul>
<p>And across the range of allowed inputs, it would be compatible with historical code.  The Redbol emulation would be fairly trivial:</p>
<pre><code>redbol-append: function [series value /only] [
    append series case [
         only [:[value]]  ; evaluates to a spliced BLOCK! with one item in it 
         any-array? value [as block! value]  ; force path/group to block
         default [:[value]]  ; put anything else into a block
     ]
]
</code></pre>
<h2>Cons</h2>
<p>Obviously asking people to write <strong><code>find data [&lt;x&gt;]</code></strong> instead of <strong><code>find data &lt;x&gt;</code></strong> seems blocky, and <strong>find data :[var]</strong> instead of <strong>find data var</strong> is uglier.  Plus <strong>append string ["stuff"]</strong> feels a bit wordy and <strong>append string '{stuff}</strong> makes you change your string delimiter.  This might be mitigated some by being able to say <strong>append string 'stuff</strong> and allowing WORD!-based appends.</p>
<p>...Or perhaps being more lenient when the target is a string type, so the /ONLY distinction wouldn't exist in the first place...so allow any type?  e.g. enforce the "must be a block rule" for the argument <em>only when modifying or searching in arrays</em>?</p>
<p>While the soft quoting is not integral to the proposal, it has that problem of making you say <strong>append data (second items)</strong> instead of <strong>append data second items</strong>.  Regardless of whether one thinks the soft quoting is a good idea, there's much more information there... <em>you know the second thing in items is a block and it will be spliced</em>.  If you saw <strong>append data :[second items]</strong> you don't know what the thing is but you know it's not going to be spliced.</p>
<h2>For those not going with Redbol emulation, it could be a fresh start</h2>
<p>Killing off /ONLY feels like a noble cause to me.</p>
<p>This line of thinking reminds me a bit of the train of thought behind saying that <em>if</em> you have an argument that can take ANY-VALUE!, then you do not use the blank-in-null-out convention for such arguments...you have to switch to thinking of null as some kind of nothing, or accept erroring on null.</p>
<p>So maybe we could consider this a variant of 2 above:</p>
<p><strong>2c.</strong> <strong>BLOCK! has a special use by convention in the language as a "generic container of N things".</strong> You should generally not make a parameter take ANY-VALUE! if that argument intends to use this meaning of BLOCK!.  Instead you should <em>always</em> take a block, even if just to provide a single thing, for clarity at the callsites.<br>
<strong>2c.1.</strong> If your use case fits it, you can use soft-quoting to allow QUOTED! values to indicate single items as a shorthand--at the cost of having to put expressions producing BLOCK!s into GROUP!s.<br>
<strong>2c.???.</strong> (maybe?) If you have a span of target cases where multiple items cannot be handled differently from single items (e.g. <strong>find</strong> of a TEXT! in a TEXT! has no distinct meaning from <strong>find</strong> of a BLOCK! with that TEXT! in it, where an /ONLY refinement would have no meaning) then these cases may be tolerated as missing the BLOCK! container for single elements.</p>
            <p><small>13 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182</link>
          <pubDate>Mon, 22 Jul 2019 05:28:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1182</guid>
          <source url="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182.rss">Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</source>
        </item>
        <item>
          <title>Should MAP-EACH be changed to splice by default?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>I was trying to do something in JavaScript, going character by character and replacing text in a string.  JS strings are immutable so it was kind of annoying.</p>
<p>It made me wish to be able to do a MAP-EACH on a TEXT! and have the body return either a NULL, a CHAR!, or a TEXT!...</p>
<pre><code>&gt;&gt; map-each c "123" [
     case c [
         #"1" ["one"]
         #"3" [#"T"]
     ]  ; don't have any match for 2, so fall through with null
]
== "oneT"
</code></pre>
<p>The ability to go element-by-element and map to potentially 0, 1, or many elements seemed like an appealing thing.  Enough that I wondered if MAP-EACH should splice by default.</p>
<p>Splicing is strictly more powerful, because you can put things into a block:</p>
<pre><code>&gt;&gt; map-each x [a [b c] &lt;d&gt; e] [if not tag? x [x]]
== [a b c e]

&gt;&gt; map-each x [a [b c] &lt;d&gt; e] [if not tag? x [reduce [x]]]
== [a [b c] e]

&gt;&gt; map-each x [a [b c] &lt;d&gt; e] [if not tag? x [:[x]]]
== [a [b c] e]
</code></pre>
<p>It would seem to suggest you'd want an /ONLY for convenience.</p>
<p>There are benefits.  But as with APPEND doing splicing when it's not asked... it's a likely source of bugs.  This category of bugs is probably one of the biggest.</p>
<p><strong>Another side of the argument is to go with MAP-EACH as it does today, producing a BLOCK! always.</strong> If you always get a block, then you get to make up the step which coalesces things.</p>
<p>I've made arguments for this line of thinking in the past.  It seems a bit wasteful to always be producing a BLOCK! from a large text string, then merging it together.  But perhaps the <a href="https://forum.rebol.info/t/stopping-the-into-virus/705/2">argument made against /INTO</a> applies here too...that anyone who cares wouldn't use MAP-EACH?</p>
            <p><small>9 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/should-map-each-be-changed-to-splice-by-default/1155">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-map-each-be-changed-to-splice-by-default/1155</link>
          <pubDate>Thu, 02 May 2019 07:24:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1155</guid>
          <source url="https://forum.rebol.info/t/should-map-each-be-changed-to-splice-by-default/1155.rss">Should MAP-EACH be changed to splice by default?</source>
        </item>
        <item>
          <title>BLANK!-in, NULL-out convention vs. LOGIC!-returning actions</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>We're now in a situation where NULL is rejected by <em>most</em> routines as input.  Notable exceptions being the thing-to-APPEND, or the thing-to-KEEP...anything where a BLANK! acts legally as a "thing" you might want to be talking about--and NULL is the only way to opt out.</p>
<p>In this world, <strong>"BLANK!-in, NULL out"</strong> has been showing off excellently as the replacement for what was long discussed under the title <em>none propagation</em>.  <a href="https://github.com/rebol/rebol-issues/issues/1611#issuecomment-385719133">I summarize the theory of the benefits here</a>, and why routines taking "NONE!-in, NONE!-out" were a dangerous idea.</p>
<p>But it can't be followed blindly.  Just as <strong>append copy [] _</strong> returns <code>[_]</code> and not NULL, some judgment has to be applied.  As an obvious-if-you-think-about-it case, LOGIC!-returning routines have to handle blanks a different way.</p>
<h2>Getting Tricked By Inverse LOGIC!</h2>
<p>I wanted to write the following;</p>
<pre><code>if exists? try some-dir: get-env 'SOME-DIRECTORY [
     ...
]
</code></pre>
<p>If GET-ENV returns null, the TRY blanks it for EXISTS? to process.  But...<strong>what if the routine were called DOESN'T-EXIST?</strong>, and it followed BLANK!-in, NULL-out?  It would make it look like blank inputs <em>did</em> exist, if you were just checking the result for truthiness or falseyness.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>This seems like a pretty solid proof that functions returning LOGIC! should not conflate their answers with NULL.  <em>(Note: I know <code>exists?</code> is currently conflated with FILETYPE OF, so it doesn't actually return a LOGIC!, but that's just a bug that hasn't been tended to.  The point stands.)</em></p>
<h2>But what what about NaN handling?</h2>
<p>I had a theory that BLANK!s and NULLs could act as the <em>quiet NaN</em> and <em>signaling NaN</em> forms of  <a href="https://en.wikipedia.org/wiki/NaN">"not-a-number" (NaN)</a>.  The goal of this is to allow math handling to be more graceful, without needing to set up TRAPs and such--you can be selective about which operations you are willing to have fail, and supply code to fill in such cases.</p>
<p>Wikipedia has a little table about how NaNs work with comparisons:</p>
<blockquote>
<p>Comparison between NaN and any floating-point value  <em>x</em>  (including NaN and ±∞)</p>
<ul>
<li>
<strong>NaN ≥ x</strong> =&gt; <em>Always False</em>
</li>
<li>
<strong>NaN ≤  x</strong> =&gt; <em>Always False</em>
</li>
<li>
<strong>NaN &gt; x</strong> =&gt; <em>Always False</em>
</li>
<li>
<strong>NaN &lt; x</strong> =&gt; <em>Always False</em>
</li>
<li>
<strong>NaN = x</strong> =&gt; <em>Always False</em>
</li>
<li>
<strong>NaN ≠ x</strong> =&gt; <em>Always True</em>
</li>
</ul>
</blockquote>
<p>Look at that last case.  If BLANK! is the quiet NaN, you can't have that comparison returning NULL, because it would be falsey instead of truthy.</p>
<p>When these routines get BLANK! they have to decide whether to return true or false depending.  It's a close analogy to how "exists?" and "doesn't-exist?" must use their discretion on blank input.</p>
<p>However, the math operations that normally return numbers, and feed into these situations <em>DO</em> follow blank-in-null out.  This is the proposed behavior:</p>
<pre><code>&gt;&gt; square-root -1 // Note: `square-root _` is also null
// null

&gt;&gt; try square-root -1
== _

&gt;&gt; 1 + square-root -1
** Error: + doesn't accept NULL for its value2 argument

&gt;&gt; 1 + (square-root -1 else [10]) // selective handling
== 11

&gt;&gt; 1 + try square-root -1 // propagation
// null

&gt;&gt; 10 != (1 + try square-root -1)
** Error: != doesn't accept NULL for its value2 argument

&gt;&gt; 10 != (try 1 + try square-root -1)
== #[true]
</code></pre>
<p>So that demonstrates a bit of nuance involved in the "BLANK!-in, null out" rule.  <em>LOGIC!-bearing routines should still only return LOGIC!</em>, and if for some reason they can't make a reasonable call one way or another, they need to error vs. ever returning NULL.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/blank-in-null-out-convention-vs-logic-returning-actions/954">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/blank-in-null-out-convention-vs-logic-returning-actions/954</link>
          <pubDate>Mon, 10 Dec 2018 14:21:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-954</guid>
          <source url="https://forum.rebol.info/t/blank-in-null-out-convention-vs-logic-returning-actions/954.rss">BLANK!-in, NULL-out convention vs. LOGIC!-returning actions</source>
        </item>
        <item>
          <title>What to do about `do []` and `()`</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Rebol2 considers both <strong>do []</strong> and <strong>()</strong> to be #[unset], and neither true nor false.  But that doesn't necessarily suggest things always run through a common path.  The following situations are similar, but give different error messages:</p>
<pre><code>rebol2&gt;&gt; if () [print "won't work"]
** Script Error: if is missing its condition argument

rebol2&gt;&gt; while [] [print "similar situation"]
** Script Error: Block did not return a value
</code></pre>
<p>Furthering the "not going through the same path" situation, Red either intentionally-or-unintentionally permits the first:</p>
<pre><code>red&gt;&gt; if () [print "uh, it's truthy here?"]
uh, it's truthy here?

red&gt;&gt; while [] [print "but this is a problem for some reason"]
*** Script Error: block did not return a value
</code></pre>
<p>Historically in Ren-C both <code>()</code> and <code>do []</code> were null... the absence of a value.  However, absence of a value was ultimately deemed to serve best as being conditionally false, as NULL is in C.  This falsey null state has became a cornerstone of the API interaction, and the out-of-band non-valued definition of "soft failure" for functions like SELECT or FIND.  Which is turning out <em>fantastic</em>.</p>
<p>But when you run things through common code paths and try to get common behaviors, you get some differences.  This led to <code>while []</code> seeing that condition block as producing null and thus being falsey, as if you had written <code>while [null] [...]</code>.  So there was no error.  And <code>if () [print "this just wouldn't print"]</code>...falsey again.</p>
<h3>Enter the void</h3>
<p>Yet Ren-C has something that is neither true-nor-false, the #[void].  You really can think of it very much like "an unset"--except it has nothing to do with variables being unset.  It is a "void value"--a legitimate item that can appear in blocks (the way #[unset] deceptively could).</p>
<p>But when to make a void?  Here are some situations to look at:</p>
<pre><code>a: func [] []
b: func [] [return]
c: func [] [do []]
d: func [] [if true []]
e: func [] [()]
</code></pre>
<p>Should these do the same thing?  Different things?</p>
<p>Previously, we had the situation where <strong>if b [...]</strong> would fail with the argument-less RETURN yielding void, and <strong>if d [...]</strong> failing because d is void (the branch ran and had to be distinguished from NULL).  But the other cases would return plain old NULL.</p>
<p>Something about it felt wrong to me.  It seemed to me that <em>at least</em> a/b/c/d should return the same thing, yielding a function that would error if you tried to use it in a conditional clause.  And possibly/probably e too.</p>
<h3>The impact of splicing</h3>
<p>Imagine that you have something like <strong>block: [a b c]</strong>.  There is today--and probably for the future of binding--a difference between:</p>
<pre><code>code: [... do block ...]
</code></pre>
<p>...and:</p>
<pre><code>code: compose/only [... (as group! block) ...]
</code></pre>
<p>They might look similar, in that they execute the block through a "link"/"reference", without making a copy.<br>
But the latter makes the contents of the block visible as a group, which means an operation like BIND on the code will affect it.  So imagine if BLOCK contained things like RETURN in it and you tried to use this code as the body of a function.  The first case would leave whatever binding was on the return initially, while the second would pick up the binding for the new function.</p>
<p>But let's step away from the binding can-of-worms and focus on the question of what this might imply for our needs in the decayed case where the BLOCK! is empty.  What is the likely intent?</p>
<p>One possibility is that composing in the <strong>as group!</strong> is semantically the same as splicing, but the goal is to avoid duplicating the block's contents.  The wish to avoid duplication might be for memory efficiency, or it might be because it's could be modified and the modifications should be seen.  If this is the case, then the behavior of () might be best if it were the same as an expression barrier.</p>
<pre><code>&gt;&gt; 1 + () 2
** + is missing its value2 argument

&gt;&gt; 1 + 2 ()
== 3
</code></pre>
<p>That's weird, but it sort of makes sense.  It makes GROUP!s a little more ghostly, but it keeps them from coming up with values that aren't there.</p>
<p>If DO [] is #[void], and () has this behavior, it makes the a/b/c/d/e examples above all return the same thing.  It also makes <code>if () [...]</code> an error, but for a different reason...not because it's trying to determine the conditional truth or falsehood of a void, but because the IF "hit a wall"...as if you'd written <code>if | []</code> or <code>(if) []</code>.</p>
<p>Does this seem coherent?</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/what-to-do-about-do-and/772">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-to-do-about-do-and/772</link>
          <pubDate>Fri, 03 Aug 2018 16:34:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-772</guid>
          <source url="https://forum.rebol.info/t/what-to-do-about-do-and/772.rss">What to do about `do []` and `()`</source>
        </item>
        <item>
          <title>ASSERT vs. [end]able FAIL</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>To concretize this discussion point, let's use a simple example.  We have some C functions with names like "RL_rebRun" that we want to extract "rebRun" from.  We could say:</p>
<pre><code>parse cname ["RL_" copy rebName to end]
</code></pre>
<p>After this rebName will either be whatever it was beforehand (if it didn't start with "RL_"), or it could be something like "rebRun".  How might we verify it worked?</p>
<h3>What about ASSERT?</h3>
<p>PARSE now returns null (not false) on failure, so it can participate in the NULL protocols (e.g. be used with things like ELSE).  But null is still falsey, so it can be used with ASSERT:</p>
<pre><code>assert [parse cname ["RL_" copy rebName to end]]
</code></pre>
<p>That doesn't look too terrible, though it is a bit "disruptive".  The assert has taken the center stage as the first word you see, as opposed to having the failure handling be more of an exception/afterthought.</p>
<p>But here's another thing you might not know.  <a href="https://github.com/metaeducation/ren-c/blob/e8f4a8b9c689062c4b14398ec69db61d4114633e/src/mezz/base-funcs.r#L19">The implementation of ASSERT is a no-op in Ren-C</a>:</p>
<pre><code>assert: func [
    {Ensure conditions are conditionally true if hooked by debugging}
    return: &lt;void&gt;
    conditions [block!]
        {Block of conditions to evaluate and test for logical truth}
][
]
</code></pre>
<p>This is because ASSERT has no default implementation, but can be HIJACKed by a debug mode with a custom validation or output routine.</p>
<p>As it so happens we don't have "debug mode" yet.  So it just gets HIJACKed during boot.  But the point is that it's designed so that asserts could be no-ops in a "release" mode...which wouldn't run the code at all.  In our case, that means no PARSE, and rebName is never set.</p>
<h3>How about an ELSE with a FAIL?</h3>
<pre><code>parse cname ["RL_" copy rebName to end] else [
    fail "The name didn't start with RL_"
]
</code></pre>
<p>That works, but now we're on the hook for writing some kind of error message.</p>
<p><em>Or.. are we?</em>  What if we just wrote:</p>
<pre><code>parse cname ["RL_" copy rebName to end] else [fail]
</code></pre>
<p>If you think about it, a FAIL with no arguments doesn't have a lot of options for what to do besides report an error.  So why not make it <code>&lt;end&gt;</code>-able (the same way HELP can accept either no arguments or one argument), and assume that a FAIL with no arguments is just a way of saying "fail here"?</p>
<p>There are other applications for this:</p>
<pre><code>switch type of x [
    integer! [...]
    text! [...]
    fail
]
</code></pre>
<p>That's more succinct than <code>default [fail]</code>.  And maybe it's not right for everyone, but it's interesting in a sort of "you get what you pay for" failure message.  If it happens often and you think it deserves a more informative message than just showing you a place in the code where it happened, you can expand on it.</p>
<p>I think I like it.  In fact, thinking about it just got me to realize that we could <a href="https://github.com/metaeducation/ren-c/pull/835">make any RETURN willing to take no argument</a> to act as <strong>return void</strong> would, and make things simpler and more flexible.  So why not have FAIL go the same route?</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/assert-vs-end-able-fail/756">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/assert-vs-end-able-fail/756</link>
          <pubDate>Wed, 25 Jul 2018 19:31:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-756</guid>
          <source url="https://forum.rebol.info/t/assert-vs-end-able-fail/756.rss">ASSERT vs. [end]able FAIL</source>
        </item>
        <item>
          <title>Justifiable Asymmetry: TO on BLOCK!?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>I've <a href="https://forum.rebol.info/t/hacking-away-on-the-to-and-make-matrix/649">previously pitched</a> the following stakes in the ground for TO conversions:</p>
<ol>
<li>
<strong>A TO conversion won't run arbitrary code that you pass to it</strong>.  It won't even GET any variables, much less evaluate.</li>
<li><strong>Every TO conversion targeting a series type performs a new allocation</strong></li>
<li><strong>A TO conversion of a value to its own datatype will do the same thing as COPY</strong></li>
</ol>
<p>These rules are mechanical, and aren't saying much about what TO means "semantically".  It feels like we should be able to say that <strong>TO TEXT! 10</strong> is "10" and <strong>TO INTEGER! "10"</strong> is 10.  But it gets a bit more vague from there.</p>
<p>As additional guidance, I've also proposed a rule for APPEND and its bretheren:</p>
<blockquote>
<p><em>"If the type of the value being appended doesn't match the type of what you are appending to, it will act as equivalently as if it had been converted with TO into the target type first."</em></p>
</blockquote>
<p>So whatever <strong>append copy [a b c] 'x/y/z</strong> does, it would be the same as <strong>append copy [a b c] to block! 'x/y/z</strong>.</p>
<h3>Should there be symmetry?</h3>
<p>The historical ergonomics of splicing by default are not always good:</p>
<pre><code>&gt;&gt; block: copy [a b c]
&gt;&gt; path: 'd/e
&gt;&gt; append block path
== [a b c d e]
</code></pre>
<p>We know that <strong>[a b c d/e]</strong> would be more useful in almost all cases.  If you have a PATH! in your hand, the path-ness is likely relevant to what you want to do.</p>
<p>I've proposed weird rules like "only splice if the types match", but that can be a bit awkward:</p>
<pre><code>&gt;&gt; group: copy quote (a b c)
&gt;&gt; append group collect [keep 'd | keep [e f]]
== (a b c [d e f])
</code></pre>
<p>Due to their nature (and special logographic <strong>[o]</strong> status), blocks really are just a good generic carrier for material.  Hence their BLOCK!-ness quite well <em>not</em> be that important.  So here, I'd think that having to say  <strong>append group as group! collect [...]</strong> is kind of annoying.</p>
<p>So I suggested <a href="https://forum.rebol.info/t/make-splicing-by-default-only-apply-when-appending-a-block/226">"only splice blocks"</a> might be a more predictable-feeling rule.  This way, you're not worrying about the combinatorics of what you're inserting <em>and</em> what you're inserting into.</p>
<p>Merging that with the rules above would give you some asymmetry, however:</p>
<pre><code>&gt;&gt; to block! 'a/b/c
== [a/b/c]

&gt;&gt; to path! [a b c]
a/b/c

&gt;&gt; to block! quote (a b c)
[(a b c)]

&gt;&gt; to group! [a b c]
(a b c)
</code></pre>
<p>TO BLOCK! of any non-block array would just put it into a block, while TO PATH! or TO GROUP! of a block array would act more like COPY AS PATH! and COPY AS GROUP!.</p>
<p>But looking a bit closer, it seems that maybe the rule should really just apply to not breaking up paths.</p>
<h3>So what if the difference is just PATH!s?</h3>
<pre><code>&gt;&gt; to block! 'a/b/c
== [a/b/c] ;-- 1 new element when APPENDed to BLOCK!

&gt;&gt; to group! 'a/b/c
== (a/b/c) ;-- 1 new element when APPENDed to GROUP!

&gt;&gt; to block! quote (a b c)
== [a b c] ;-- 3 new elements when APPENDed to BLOCK! (splice)

&gt;&gt; to group! [a b c]
== (a b c) ;-- 3 new elements when APPENDed to GROUP! (splice)

&gt;&gt; to path! [a b c]
== a/b/c ;-- 3 new elements when APPENDed to PATH! (splice)

&gt;&gt; to path! quote (a b c)
== a/b/c ;-- 3 new elements when APPENDed to PATH! (splice)
</code></pre>
<p>This puts BLOCK! and GROUP! into the same category of "things that splice by default".  They certainly -look- more similar to each other than either looks to path due to the elements being not glued together...perhaps "spaces mean splices"?</p>
<p>It also reduces the likelihood of creating 1-element paths via TO (you'd only get that for 1-element GROUP!s and BLOCK!s).</p>
<p>It's an asymmetry, but feels sort of explainable.  Note that the AS operators are fully symmetric, and you can say <strong>copy as block! 'a/b/c</strong> and get <strong>[a b c]</strong>.  So this is really just about making the TO and APPEND/INSERT/CHANGE matrix more useful.</p>
<p><strong>So...are people on board with this?</strong></p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/justifiable-asymmetry-to-on-block/751">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/justifiable-asymmetry-to-on-block/751</link>
          <pubDate>Mon, 23 Jul 2018 00:08:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-751</guid>
          <source url="https://forum.rebol.info/t/justifiable-asymmetry-to-on-block/751.rss">Justifiable Asymmetry: TO on BLOCK!?</source>
        </item>
        <item>
          <title>The benefits of a falsey NULL (any major drawbacks?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>There's been an ongoing "shift in attitude" about NULL.</p>
<p><strong>What has not changed:</strong> null is still "not a value".  You can't put it in a block.  And a variable can't "be null", it can only be unset...which you can find out about via <code>not set? 'varname</code>.  GET gives you null as a way of <em>signaling</em> the unset-ness, but that's different from saying the variable "holds a null value".</p>
<pre><code>x: null
if x = null [ ;-- errors on access of x
    print "if a variable could actually 'be null', this would be legal"
]
</code></pre>
<p><strong>What has changed:</strong> increased acceptance of null to mean "don't append anything" or "don't compose anything" or "don't print anything".  So it's not the extreme "hot potato" that it was at one point aiming to be.</p>
<p>But it's still a slightly warm potato: it differs from BLANK! in the sense that operations won't generally accept it as a data source.  Non-mutating operations take blanks in and give nulls out.  <em>(e.g. <strong>select _ 'foo</strong> is null, while <strong>select null 'foo</strong> is an error--this helps keep error locality vs. collapsing entire chains without a deliberate TRY)</em></p>
<p>And there's a pretty big stigma NULL will never avoid, by virtue of not being able to fetch it from a variable via "normal" variable access.</p>
<h3>But what good is it to not let NULL be falsey?</h3>
<p>I just tried implementing the proposal for making APPEND or COMPOSE of BLANK! a no-op unless you used /ONLY.  This has the nice property of <strong>compose [1 (any [...]) 2]</strong> being able to vaporize the ANY expression on failure.  But it also got me to thinking, why isn't ANY returning null in the first place when it doesn't find a truthy thing?</p>
<p>The "big reason" was that people write <strong>if any [...] [...]</strong>, and null is "neither true nor false", so that would be an error should it return NULL.  <em>But in this day and age, what's the great argument for why null shouldn't be falsey?</em>  When it shifted from name/conception of "void" to the more fitting "null", that makes the suggestion more palatable.  Certainly NULL is falsey in many languages, C included.</p>
<p>When the question of truthy/falsey of UNSET! was debated in the CureCode days, people looked at the behavior of:</p>
<pre><code> all [
     1 &lt; 2
     print "got here"
     3 &lt; 4
 ]
</code></pre>
<p>There was a desire to not interrupt the ALL while injecting debug output.  Since PRINT returned an UNSET!, it wasn't counted.</p>
<p>I thought the example was a bit contrived.  A change to PRINT (or whatever) so that it returned something (perhaps the PORT! it printed to?  The data it printed)? would throw this off.  Or if you were using some other routine, you'd have to say:</p>
<pre><code> all [
     1 &lt; 2
     ((some-diagnostic-function ...) ())
     3 &lt; 4
 ]
</code></pre>
<p>With Ren-C there is ELIDE, that can be used generically in these situations:</p>
<pre><code> all [
     1 &lt; 2
     elide (some-diagnostic-function ...)
     3 &lt; 4
 ]
</code></pre>
<p>The existence of ELIDE...and wanting to be careful to not blindly proceed in the case of things like failed selects...were incorporated into an argument for why ALL began treating nulls as errors.  But what if NULL was just plain old falsey, as far as conditionals were concerned?</p>
<p>It would bring back the casual-use scenarios which people liked, with the twist that you don't always wind up with a set variable (you'd still have to use TRY to get that):</p>
<pre><code>if x: select data item [
    ;-- x is known set and not blank or false
] else [
    ;-- x may be unset, blank, or false
]
</code></pre>
<p>NULL could be the result of a failed ALL or ANY.  Again, you'd still want to throw in a TRY if you were going to put it in a variable you wanted to test later.  But by having these constructs return null on failure, you could use ALL and ANY with ELSE, ALSO, !!...</p>
<p>It would make the current hacks which allow nulls for DID, NOT, OR and AND not-hacky.</p>
<h3>The One Sacrifice</h3>
<p>The balance of null tolerance other places has shown us that the "safety" aspects aren't really viable.  Nulls happen.  Where safety comes in is when you read from variables or when you put in asserts or ENSUREs or add type annotations to parameters for your functions.</p>
<p>But there was a sort of an idea that by not blessing NULLs as falsey, there could be an established "tristate" in the system.  Unlike the case of PRINT inside the ALL above...which always wants to "opt-out"...what if you had some MAYBE-VOTE function that wanted to sometimes return truthy, sometimes return falsey, and sometimes abstain from a vote via NULL?  ELIDE doesn't cover that.</p>
<p>Well, that's kind of weird, and none of these exist.  In fact the <em>one</em> case I had that <em>did</em> exist stopped working, because I didn't want NULLs to be the "no vote", I wanted them to be effectively the "only falsey value" that could break an ALL-like construct, with all other values treated as "truthy".</p>
<p>Just to further the point on the subjectivity of this: it's come into question that if BLANK! is just "the reified form of null", why would they have a difference in their conditional behavior.  What makes BLANK! so "falsey"?  Why isn't it "neither-true-nor-false" like null?</p>
<h3>It's hard to really see the downside</h3>
<ul>
<li>
<p>I <em>know</em> that treating null as falsey will mean simpler code inside the core.</p>
</li>
<li>
<p>I <em>am nearly certain</em> that treating null as falsey will simplify user code.</p>
</li>
<li>
<p>Failures of the "opt-out" voting model for nulls led to pushing for errors in ANY and ALL, that has caused usages of DID and TRY that are cluttery.</p>
</li>
</ul>
<p>Can anyone speak up for the last time an error on a null really helped out?</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-benefits-of-a-falsey-null-any-major-drawbacks/675">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-benefits-of-a-falsey-null-any-major-drawbacks/675</link>
          <pubDate>Sat, 09 Jun 2018 12:15:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-675</guid>
          <source url="https://forum.rebol.info/t/the-benefits-of-a-falsey-null-any-major-drawbacks/675.rss">The benefits of a falsey NULL (any major drawbacks?)</source>
        </item>
        <item>
          <title>Hacking away on the TO and MAKE Matrix</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>The expanded behavior of AS is unambiguous and reassuring.  All you have to remember is that no new series is allocated.  What you'll get is what you had:</p>
<pre><code>&gt;&gt; first &lt;abc&gt;
== #"a"

&gt;&gt; t: as text! &lt;abc&gt;
== "abc"

&gt;&gt; first t
== #"a" ;-- same answer, more bindingly due to no allocation
</code></pre>
<p>AS BINARY! of an ANY-STRING! will be a little weird since you'll get a byte position in UTF-8, so the index may be different than you had...and AS to ANY-STRING! of a BINARY! will not work on non-UTF-8 binaries.  Different, but understandable.</p>
<p>Since AS never allocates new memory, you have to copy if you need to.</p>
<pre><code>as binary! copy x ;-- doesn't matter which way you write it...
copy as binary! x ;-- ...but I like this a little more
</code></pre>
<p><em>(Note: if AS were infix then <code>copy x as binary!</code> would act as ((copy x) as binary!), which seems like a non-obvious evaluation order.)</em></p>
<p><strong>It makes little sense to have MAKE or TO just act like COPY AS.</strong>  Rather, having AS pinned down opens up possibilities for reshaping those operators, that have been <a href="https://forum.rebol.info/t/behavior-of-to-string-as-string-mold/630">historically "unkempt" in Rebol2/R3-Alpha/Red</a>.</p>
<h3>TO TEXT! of ANY-VALUE! and TO ANY-VALUE! of TEXT!</h3>
<p><code>to text! 10 =&gt; "10"</code> and <code>to integer! "10" =&gt; 10</code> <em>seem</em> like two obvious points that TO conversion needs to pass through.</p>
<p>If we try to naively generalize that, it looks like using TO to convert <em>from</em> text to an arbitrary ANY-VALUE! is acting as something like LOAD.  Then trying to convert TO TEXT! is either doing a MOLD or FORM of what we give it.  But...which is it?</p>
<ol>
<li>
<p>When you APPEND something that is not a string to a string, an automatic conversion has historically been done.  There might seem to be a fairly strong argument that if such an operation is to be legal, then the refinement-less and parameter-less TO should share behavior.   e.g. <strong><code>append string non-string</code></strong> should give the same behavior as some variant of <strong><code>append string TO any-string! non-string</code></strong>  <em>That intent has usually been more FORM-like.</em></p>
</li>
<li>
<p>On the other hand, TO doesn't have refinements.  If someone has a wide range of potential formatting options, they'll need something else.  One thing about MOLD is that since it is a Rebol format with the obligation to be re-loadable back, it makes a pretty good fit.  And MOLD is a terrible name.  So if there's no options, and if the reverse is choosing to act very "LOAD-like", <em>there seems to be a good case for acting like MOLD</em>.</p>
</li>
</ol>
<p>Wanting see the MOLD name die out--along with the lack of formatting options for TO (which MOLD "doesn't need")--makes me more moved by the second argument.  Sounds good, but... let's keep delving. :-/</p>
<h3>Automatically adding quotes on TEXT! has problems</h3>
<p>Going with option 2 has some friction on option 1.  On the surface, the following might seem more or less reasonable:</p>
<pre><code> &gt;&gt; txt: copy "abc"
 &gt;&gt; append txt [def: &lt;ghi&gt;]
 == {abcdef:&lt;ghi&gt;}
</code></pre>
<p>But is the following "reasonable"?</p>
<pre><code> &gt;&gt; txt: copy "abc"
 &gt;&gt; append txt ["def" "ghi"]
 == {abc["def" "ghi"]}
</code></pre>
<p>It's probably not that useful.  If there were a special rule for BLOCK!s besides the "moldy" TO TEXT! of it, then maybe it wouldn't try to TO TEXT! the block, but each individual item...even still, that's a bit of an unlikely intent:</p>
<pre><code> &gt;&gt; txt: copy "abc"
 &gt;&gt; append txt ["def" "ghi"]
 == {abc"def""ghi"}
</code></pre>
<p>If it were deemed that no TO conversion would be done if the types matched, this example might clean up but others would vary weirdly:</p>
<pre><code> &gt;&gt; tag: copy &lt;abc&gt;
 &gt;&gt; append tag ["def" "ghi"]
 == &lt;abc"def""ghi"&gt;

 &gt;&gt; tag: copy &lt;abc&gt;
 &gt;&gt; append tag "def"
 == &lt;abc"def"&gt;
</code></pre>
<p>Basically: though WORD! is the "string type" with no delimiters in its representation, one tends to expect that TEXT! (a.k.a. STRING!) won't be systemically splicing its delimiters around.  There are fewer preconceptions about what other types do, which is why R3-Alpha changed some of it...e.g. such that TO STRING! of a SET-WORD! would have a colon in the generated data.</p>
<h3>Also, a paradox...</h3>
<p>Earlier it was suggested that TO ANY-VALUE! of a text would be LOAD-like.  That's because TO INTEGER! "10" is 10.  But what about <strong>to text! "{abc}"</strong>?  It can't be <em>both</em> LOAD <em>and</em> MOLD (nor FORM) at the same time!  When it reaches this point...should it be "removing the delimiters" in the series it makes, or adding more?</p>
<p>Or what if it would just COPY it?</p>
<h3>Should TO SOME-TYPE if already SOME-TYPE just COPY?</h3>
<p>While AS never performs series allocations, it seems reasonable if TO <em>always</em> does a new allocation when the target is a series.</p>
<p>Given that seems fair enough, pinning down the idea that <em>the system itself</em> enforces the idea that a TO conversion of a type to itself does the same thing as a copy seems reasonable.  This is done by C++ casting; you can't write an overloaded cast operator for your data type that casts to its own type.  <em>(Well, you can write one, but clang will warn you it will never get used--gcc does not currently do so.)</em></p>
<p>Making a TO of a type to itself copy itself <em>feels intuitively</em> correct, to the point one can even imagine defining COPY that way.</p>
<h3>Should appending blocks to strings fail?</h3>
<p>In the argument for explicit over implicit, one has to wonder just how realistic it is to be "automatically" making good decisions about converting things is.  Do you evaluate or not?  Do you space or not?  Do you put in delimiters or not?  <em>Are operations like APPEND and INSERT doing too much guesswork?</em></p>
<p>At minimum, I mention above is that it seems a TO without <em>any parameters</em> should probably be connected somehow to what the system does automatically.  If we think about an invariant like "what happens when you do <strong>append copy [a b] "c"</strong>, it is pleasing if we can say something like "the types do not match, a TEXT! is not a BLOCK!, so it is first converted to a BLOCK!... and acts the same as <strong>append copy [a b] ["c"]</strong>.</p>
<p><em>(Maybe that's not a useful invariant, I'm just re-iterating that they can be comforting, and we should be looking for them--at least the invariants that pass through specific examples you want to work.)</em></p>
<p>I feel like that invariant has to be articulated.  And it seems like it prevents TO TEXT! from being a general-purpose replacement for MOLD.</p>
<h3>Conclusions?</h3>
<p>This is really just a bit of a brainstorm as TO gets remapped.  It's always been a problem area, and I note people in Red are bringing it up again and looking for wikis to talk about it.</p>
<p>Pushing against the boundaries I'm starting to feel the TO of a type to itself is a synonym for COPY.  But...deep copy?  Shallow copy?  There's always been this question of if TO BLOCK! of something would wrap an existing block or just "blockify" things that weren't blocks.</p>
<p>I'm curious if anyone wants to put any pins in the map.  What TO conversion <em>has</em> to work to make "TO" a reasonable/good operation?  What's a dealbreaker if it doesn't?</p>
<p>How will this generalize to user defined types?  One thing I thought is that a TO conversion is a method of the source type parameterized with the target type (like "casting" overloads in C++), while a MAKE construction is a business of the target type (like a "constructor" in C++).  That is to say if you do TO INTEGER! on a value of type FOO!, it's FOO! making the decision of how to do it...not INTEGER!... and if you say MAKE FOO! with some spec (perhaps an integer), that's code that FOO! provides.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/hacking-away-on-the-to-and-make-matrix/649">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/hacking-away-on-the-to-and-make-matrix/649</link>
          <pubDate>Tue, 29 May 2018 02:24:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-649</guid>
          <source url="https://forum.rebol.info/t/hacking-away-on-the-to-and-make-matrix/649.rss">Hacking away on the TO and MAKE Matrix</source>
        </item>
        <item>
          <title>Negative indexing as Rebol2/Red compatible... just do it?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Rebol2/Red:</p>
<pre><code>&gt;&gt; pick next [a b] 1
== b

&gt;&gt; pick next [a b] 0
== none ;-- Red proposes error, which was also the revised R3-Alpha proposal

&gt;&gt; pick next [a b] -1
== a
</code></pre>
<p>R3-Alpha:</p>
<pre><code>&gt;&gt; pick next [a b] 1
== b

&gt;&gt; pick next [a b] 0  
== a

&gt;&gt; pick next [a b] -1
== none
</code></pre>
<p>The decision to make this change in R3-Alpha was before my time.  But what I know of it, is that it was motivated by some people feeling the "hole at 0" made it hard for mathematics-like algorithms to index into arrays.</p>
<p>It also seemed to be that changing it didn't really please anyone that much.</p>
<p>The general concept behind PICK is to try and be a kind of "natural, do what I mean" selector.  Ren-C has taken this further by making it come back with an answer that's the same as what pathing does (hence it's "path picking" and not "path selection").  So <strong>pick a/b 'c</strong> acts like <strong>a/b/c</strong>...they run the same code.</p>
<p>People who want more numerical access can use SKIP, which navigates series predictably by a number of elements...including 0.</p>
<p>There was a lot of talk about how to change the indexing back safely, but I have to wonder, <strong>can we just change it, call it done, and move on</strong>?  There's not that much negative indexing going on in general with PICK.  And we have the wherewithal to generate some kind of log to help debug anyone who merges a negative indexing change and it breaks things.</p>
<p><em>(I was provoked to look into this because there's an old list of stray tests that were only run under Rebol2, and I feel like it's time to get rid of that file by going ahead and doing triage on everything in it...so here are the tests that involve indexing, so they can be deleted from there.  No it's, not much!)</em></p>
<pre><code>[1 = pick at [1 2 3 4 5] 3 -2]
[2 = pick at [1 2 3 4 5] 3 -1]
[none? pick at [1 2 3 4 5] 3 0]
[#"1" = pick at "12345" 3 -2]
[#"2" = pick at "12345" 3 -1]
[none? pick at "12345" 3 0]</code></pre>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/negative-indexing-as-rebol2-red-compatible-just-do-it/576">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/negative-indexing-as-rebol2-red-compatible-just-do-it/576</link>
          <pubDate>Wed, 21 Mar 2018 10:56:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-576</guid>
          <source url="https://forum.rebol.info/t/negative-indexing-as-rebol2-red-compatible-just-do-it/576.rss">Negative indexing as Rebol2/Red compatible... just do it?</source>
        </item>
        <item>
          <title>OR as a Branching Construct (Deprecated) Compared to ELSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>ELSE and OR can be used for <em>similar-looking</em> purposes, but they have an important difference.</p>
<p>ELSE runs its right hand side when there's a <em>void</em> on its left:</p>
<pre><code>&gt;&gt; () else [print "left hand side is void, branch runs" 10]
left hand side is void, branch runs
== 10

&gt;&gt; false else [print "left hand side is not void, branch skipped" 10]
;-- no result
</code></pre>
<p>Whereas OR doesn't tolerate voids on its left, and reacts to <em>conditionally false</em> things on its left:</p>
<pre><code>&gt;&gt; false or [print "left hand side is 'falsey', branch runs" 10]
left hand side is 'falsey', branch runs
== 10

&gt;&gt; 20 or [print "left hand side is 'truthy', left hand returned" 10]
== 20

&gt;&gt; false or [print "both false means blank! result" false]
== _

&gt;&gt; () or [print "left hand can't be void"]
** Error: left hand side of OR can't be void
</code></pre>
<p>Here we see the behavior of OR when a BLOCK! is used as its right hand side.  It is similar to an ANY, because it will give back the first value it calculates or a BLANK!.  However, if you use a GROUP! for the right hand side, the result will be forced to a LOGIC!:</p>
<pre><code>&gt;&gt; 1 or (2)
== #[true]

&gt;&gt; false or (_)
== #[false]

&gt;&gt; 1 or [2]
== 1

&gt;&gt; false or [2]
== 2

&gt;&gt; false or [false]
== _
</code></pre>
<p><em>(An additional constraint is that if you use a GROUP! on the right hand side, then should the right hand side be evaluated--e.g. it wasn't a short circuit--it cannot be void.  A BLOCK! on the right tolerate voids, treating them like blanks.)</em></p>
<p>In any case, if you have some kind of truthy-or-falsey producing thing...like ANY or ALL or PARSE, it's a good candidate for OR.  It can improve flow and readability, consider:</p>
<pre><code>unless parse skip executable e_phoff [
    e_phnum [
        (mode: 'read) pos: program-header-rule
        (if p_offset &gt;= offset [p_offset: p_offset + delta])
        (mode: 'write) :pos program-header-rule
    ]
    to end
][
    fail "Error updating offsets in program headers"
]
</code></pre>
<p>This starts looking a little better when OR is used:</p>
<pre><code>parse skip executable e_phoff [
    e_phnum [
        (mode: 'read) pos: program-header-rule
        (if p_offset &gt;= offset [p_offset: p_offset + delta])
        (mode: 'write) :pos program-header-rule
    ]
    to end
] or [
    fail "Error updating offsets in program headers"
]
</code></pre>
<p>For starters, it's a little shorter.  But more importantly, it lets PARSE stay at the forefront so this line of code looks primarily like a <em>parse operation</em>, as opposed to an <em>unless operation</em>.  The infix OR helps contextualize things later, more than just seeing an unadorned block.  You don't have to mentally track whether it was an IF or an UNLESS when you're reading at that point.</p>
<p>ELSE is for interacting with the outcome of conditionals, where the desirability of being able to return blanks or false is just too high:</p>
<pre><code> flag: if condition [
     false
 ] else [
     true
 ]
</code></pre>
<p>This couldn't work with OR, because it would assume the successful condition check which produced FALSE would require triggering the next branch, and returning TRUE.  So IF returns void when its condition fails, as a cue to tell ELSE that it should run.  But more generally, it's useful for making a failed conditional "opt out".</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/or-as-a-branching-construct-deprecated-compared-to-else/527">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/or-as-a-branching-construct-deprecated-compared-to-else/527</link>
          <pubDate>Wed, 14 Feb 2018 01:53:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-527</guid>
          <source url="https://forum.rebol.info/t/or-as-a-branching-construct-deprecated-compared-to-else/527.rss">OR as a Branching Construct (Deprecated) Compared to ELSE</source>
        </item>
        <item>
          <title>REJOIN ugliness and the usefulness of tests</title>
          <dc:creator><![CDATA[Brett]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Short summary: We need more tests and should ask ourselves if they make sense.</p>
<p>Discovering a bug in REJOIN motivated me to create some tests for it (it had none) and the outcome of that was I was quite surprised at how weird REJOIN's current behaviour is.</p>
<p>Though I have used REJOIN extensively in my R2 code, I must be using it in a way that avoids some behavioural ugliness.</p>
<p>Have a look at the <a href="https://github.com/codebybrett/ren-c/blob/95b07ed2e6cbb1890a5336e3aa69508388eb9467/tests/series/rejoin.test.reb">tests</a> added to Ren-c for REJOIN.</p>
<p>Thought train:</p>
<ul>
<li>Why is REJOIN so weird?</li>
<li>Maybe I don't want to REJOIN in my code anymore if it is that odd.</li>
<li>I only became aware of how weird it is by writing the tests.</li>
<li>Tests serve as documentation and can therefore draw attention to weirdness perhaps motiving a better solution.</li>
<li>I wonder if it would be useful to formalise the "tests as documentation" notion?</li>
</ul>
            <p><small>6 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rejoin-ugliness-and-the-usefulness-of-tests/248">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rejoin-ugliness-and-the-usefulness-of-tests/248</link>
          <pubDate>Thu, 10 Aug 2017 06:48:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-248</guid>
          <source url="https://forum.rebol.info/t/rejoin-ugliness-and-the-usefulness-of-tests/248.rss">REJOIN ugliness and the usefulness of tests</source>
        </item>
        <item>
          <title>Make COMPRESS/DECOMPRESS default to gzip</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>The "deflate" algorithm is pretty much the gold standard for lossless compression of generic data.  However, it is very bare bones.  Among things that are left up to the container format is whether the container wants to specify the length of the uncompressed data.</p>
<p>If you don't have the length up front, then it's a bit more expensive to do the decompression.  Heuristics need to be used to guess how big a buffer to make to decompress into.  So the buffers are either allocated bigger than they have to be (then you have to worry whether to return the data in an oversized allocation or to reallocate it and shrink it) or they have to undergo the cost of resizing as they go along.</p>
<p>Hence it's not surprising that Rebol's COMPRESS sticks a length onto the end of the zlib data... to make DECOMPRESS more efficient.  But this trivial-seeming decision still constitutes a "container format".  And it's one that competes with nearly the same thing... <a href="https://en.wikipedia.org/wiki/Gzip">the gzip format</a>.</p>
<p><em>I think it's good to include the length by default.</em>  But not good to deal in yet-another-file-format.</p>
<p>So I propose that we make COMPRESS and DECOMPRESS default to gzip.  There will be zlib and raw deflate support, so it's not hard to support the old way in code that needs to.  For decompression at least, a usermode compatibility ADAPT-ation could sniff the binary to see if it was gzip-like... and if not, trim off the length and do ordinary zlib decompression.</p>
<p>The other reasonable option would be to make COMPRESS and DECOMPRESS default to zlib (a barely-there container) or pure deflate/inflate, neither of which have lengths included.  Basically, whatever the default is, not have it be an unnamed format not published elsewhere.</p>
            <p><small>8 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/make-compress-decompress-default-to-gzip/237">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/make-compress-decompress-default-to-gzip/237</link>
          <pubDate>Wed, 02 Aug 2017 16:21:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-237</guid>
          <source url="https://forum.rebol.info/t/make-compress-decompress-default-to-gzip/237.rss">Make COMPRESS/DECOMPRESS default to gzip</source>
        </item>
        <item>
          <title>Rethinking IF and IF* - IF/ONLY, IF/OPT, safety vs. complexity</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <blockquote>
<p><strong>UPDATE:</strong> This thread is retained for historical purposes, but the issues discussed are now being attacked through various mechanisms... such as quoted branches:</p>
<pre><code>&gt;&gt; if true '[print "hi"] else [print "hi"]
== [print "hi"]

&gt;&gt; if true '[print "hi"] else [print "hi"]
hi
</code></pre>
<p>The techniques have grown as the available datatypes have grown, even leading to things like branches that are reduced if they are GET-BLOCK!</p>
<pre><code>&gt;&gt; if true :[1 + 2 10 + 20]
== [3 30]
</code></pre>
<p>Hence this thread just shows the genesis of the thoughts that pushed from the R3-Alpha status quo into that direction.</p>
</blockquote>
<p>An experimental feature that some people have wound up using--while others have not--is that it was possible to use non-blocks in conditional slots.  The rationale being that Rebol's desire for expressiveness exceeded its desire for boilerplate.</p>
<p>For instance, in terms of "character economy", you might prefer to see <strong>if (x = blah) 3 foo</strong> instead of <strong>if x = blah [3] foo</strong>.  This might make it clearer that 3 is not an argument to blah with foo the body, but rather 3 is the desired result.  Or you could write <strong>x: default [if condition 4]</strong> and compact things.  It seems the decision to be permissive runs with other core beliefs--including why one does not need to put the condition of IF in a BLOCK! in the first place.</p>
<p>In the early days of open sourcing, Carl was persuaded, and it was <a href="https://github.com/rebol/rebol/pull/170">committed to GitHub rebol/rebol</a>.</p>
<p>Yet given the fact that blocks would be executed instead of handled as raw values, it seemed a parallel situation to things like APPEND was arising.  If you were just writing <strong>if condition value</strong>, and you didn't realize the variance in behavior between when value was a block vs not...you might be surprised when trying to write generic code...when it worked fine until all of a sudden you used a block.  Adding an /ONLY refinement seemed like how APPEND dealt with this, so it seemed to make sense to give generic code authors a similar tool.</p>
<p>Since that time, conditionals like IF have gathered more features:</p>
<ul>
<li>
<p>A protection on the condition against use of literal blocks; any blocks must come from an evaluation in the condition slot.  <strong>if [x = 1] [print "you can't write this"]</strong> but <strong>var: [x = 1] | if var [print "this is okay, though it isn't going to do the comparison, just say the block is truthy"]</strong> and <strong>if identity [x = 1] [print "this is okay too, if identity is a <a href="https://en.wikipedia.org/wiki/Identity_function">function that returns its input</a>, and may be useful if you're dealing with code generation"]</strong></p>
</li>
<li>
<p>Yet-another-refinement, currently called /OPT (and specialized as <code>IF*</code>).  The goal of this is to duck the "blankification" that occurs on ordinary IFs.  Without blankification, a void-returning branch can't be distinguished from a failed branch...so <strong><code>if true [print "this would print"] else [print "this also would print"]</code></strong>  But some situations actually want to void their output, e.g. those that are trying to chain other function results that purposefully returned void.</p>
</li>
</ul>
<p>So IF has gained some complexity.  And when your job is to balance complexity with benefit, it should be scrutinized.  One thing I have come to think is that /ONLY is a hard thing to remember to use if you need it; you don't get an obvious error if you've omitted it.  Also, <strong>if/only condition [x]</strong> is not that much better than <strong>if condition [[x]]</strong>, arguably worse.  So the question is whether there's a simpler, more effective, and more helpful way to get the desired help with the <strong>if/only condition var</strong> case.</p>
<p>The compromise I have in mind is similar to other recent compromises, of a kind of "expert mode" and a "casual/convenient" mode.  Casual mode would include a check on branch bodies similar to the one for the condition, except it would only permit evaluated elements if they were blocks.  Hence should you ever see <strong>if condition var</strong> it would check you to make sure var was a BLOCK!, and not some other value.  It would still tolerate literals like <strong>if condition 3</strong>.  It would also do the blankification.</p>
<p>The "expert mode" would not have the checks on either the condition or the body, no blankification, and assume you knew what you were doing.  If you don't blankify the body, and end it with a void, then an ELSE clause will run.  If <code>var</code> is 3 and you say <strong><code>if* condition var</code></strong> it will assume that's fine.</p>
<p>This seems to me like the best of both worlds.  It means we can roughly model <code>IF</code> on top of <code>IF*</code> as something like:</p>
<pre><code>if condition [body]
    =&gt;
if* (ensure-non-lit-block :condition) [
    to-value do compose [(ensure-lit-or-else-evaluated-block :body)]
]
</code></pre>
<p>...though implemented as natives for efficiency.  As for what to call <code>IF*</code>, for those who don't like that naming convention, I dunno.  It might be appropriate to have this take IF/ONLY.</p>
<p>It might seem this would only affect those who have bothered to try using the feature so far, of which there aren't too many instances.  But there's an instance it would change with CASE...you could still write <strong>case [false 1 | true 2]</strong> but not <strong>one: 1 | two: 2 | case [false one | true two]</strong>, because only blocks would be allowed in evaluative branches unless you used <code>CASE*</code>.  otoh, <strong>one: [1] | two: [1 + 1] | case [false one | true two]</strong> would be legal.</p>
            <p><small>12 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rethinking-if-and-if-if-only-if-opt-safety-vs-complexity/212">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rethinking-if-and-if-if-only-if-opt-safety-vs-complexity/212</link>
          <pubDate>Wed, 19 Jul 2017 11:42:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-212</guid>
          <source url="https://forum.rebol.info/t/rethinking-if-and-if-if-only-if-opt-safety-vs-complexity/212.rss">Rethinking IF and IF* - IF/ONLY, IF/OPT, safety vs. complexity</source>
        </item>
  </channel>
</rss>

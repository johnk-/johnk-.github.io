<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Semantics - AltRebol</title>
    <link>https://forum.rebol.info/c/development/semantics/55</link>
    <description>Topics in the &#39;Semantics&#39; category While the &quot;Internals&quot; discusses the bits and bytes of how things are implemented, this category is for discussing things design questions of the language... like what &lt;strong&gt;do []&lt;/strong&gt; should return.</description>
    
      <lastBuildDate>Fri, 29 Mar 2024 21:22:15 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/semantics/55.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Should SET-WORD!s Propagate Undecayed Packs?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Packs are antiform blocks, which decay if not specifically handled.</p>
<pre><code>&gt;&gt; pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; a: pack [1 2]
== 1

&gt;&gt; a
== 1
</code></pre>
<p>From time to time, I've wondered if there's a good reason why the plain SET-WORD! shouldn't propagate the pack:</p>
<pre><code>&gt;&gt; a: pack [1 2]
== ~['1 '2]~  ; anti  (hypothetical)

&gt;&gt; a
== 1
</code></pre>
<p>One rationale is that intuitively, <strong>a:</strong> should be a synonym for <strong>[a]:</strong>, e.g. "unpack one item" is implicit.</p>
<p>But that just bumps the question to the next one we might ask: why doesn't a multi-return without a "circled" result just evaluate to the whole pack?</p>
<p>It looks to make some sense at first, it allows you to chain indefinitely:</p>
<pre><code>&gt;&gt; [a b]: [c d]: pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; a
== 1

&gt;&gt; b
== 2

&gt;&gt; c
== 1

&gt;&gt; d
== 2
</code></pre>
<p>Though it feels a little bit unsettling when you drop it down:</p>
<pre><code>&gt;&gt; [a b]: [c]: pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; a
== 1

&gt;&gt; b
== 2

&gt;&gt; c
== 1
</code></pre>
<p>But we could argue that if you're bothered, then you use circling (currently <code>@c</code>, but with FENCE! proposed to be <code>{c}</code>).  Note in the below example you'd have to use <code>/b</code> in order to indicate you were okay with unpacking more values than available.</p>
<pre><code>&gt;&gt; [a /b]: [{c}]: pack [1 2]
== 1

&gt;&gt; a
== 1

&gt;&gt; b
== ~null~  ; anti

&gt;&gt; c
== 1
</code></pre>
<p>We could then make a choice if <strong>a:</strong> was a synonym for <strong>[a]:</strong> or for <strong>[{a}]:</strong></p>
<h2>
<a name="most-recent-motivation-for-thinking-about-this-1" class="anchor" href="https://forum.rebol.info#most-recent-motivation-for-thinking-about-this-1"></a>Most Recent Motivation For Thinking About This</h2>
<p>I rewrote <a href="https://forum.rebol.info/t/speed-of-uparse/2177/3">some code in an example</a> from this:</p>
<pre><code>[^result' remainder]: parser input except e -&gt; [
    remainder: input  ; succeed on parser fail but don't advance input
    return null
]
return unmeta result'  ; return successful parser result
</code></pre>
<p>...to this:</p>
<pre><code>return [@ remainder]: parser input except [
    remainder: input  ; succeed on parser fail but don't advance input
    return null
]
</code></pre>
<p>The idea is that the parser being called has multiple return results... the first is the synthesized value, the second is the amount it advanced.  <em>(There's a third result on some parsers of "pending items", but this OPTIONAL combinator has an "autopipe" which is just bubbling the pending items through in the order of successful parsers called...so the third result is specialized out on its interface and on the parsers it calls.)</em></p>
<p><strong>However, the synthesized value can itself be a pack.</strong>  This means that if we named a variable in the slot where the <code>@</code> is, then that pack would be decayed to store in the variable unless we used a ^META result.</p>
<p>So does the act of not-naming and just circling subvert the decay?  Or should the circled result not be decayed even if the variable is?</p>
<pre><code>&gt;&gt; [{a} b]: pack [pack [1 2] 3]
== ~['1 '2]~  ; anti  (or should it be decayed to 1?)

&gt;&gt; a
== 1

&gt;&gt; b
== 3
</code></pre>
<p>It's a different--but related--question.  It seems it should align with the behavior of plain assignments:</p>
<pre><code>&gt;&gt; a: pack [1 2]
== ~['1 '2]~  ; anti  (implied if the above behavior is chosen)

&gt;&gt; a
== 1
</code></pre>
<h2>
<a name="not-100-certain-but-i-think-undecayed-propagation-is-good-2" class="anchor" href="https://forum.rebol.info#not-100-certain-but-i-think-undecayed-propagation-is-good-2"></a>Not 100% Certain, But I Think Undecayed Propagation Is Good</h2>
<p>I'll point out that it's possible to DECAY things pretty easily, but you can't recover a pack after it has been decayed.</p>
<p>So I'm getting the feeling that it's probably best to decay the assignments, but propagate the undecayed pack.  It looks like the more general and useful behavior...even if it seems a bit confusing.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-set-word-s-propagate-undecayed-packs/2178">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-set-word-s-propagate-undecayed-packs/2178</link>
          <pubDate>Fri, 29 Mar 2024 21:22:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2178</guid>
          <source url="https://forum.rebol.info/t/should-set-word-s-propagate-undecayed-packs/2178.rss">Should SET-WORD!s Propagate Undecayed Packs?</source>
        </item>
        <item>
          <title>VOID Branches (not branches that evaluate to void)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>I've mentioned before that <a href="https://forum.rebol.info/t/augment-add-parameters-and-refinements-after-the-fact/1216">AUGMENT can be used to implement the legacy SWITCH/DEFAULT behavior</a>.</p>
<p>But looking at what seems like the "correct" formulation of that code today, we get:</p>
<pre><code>switch-d: enclose (augment :switch [
    /default "Default case if no others are found"
        [block!]
]) lambda [f [frame!]] [
    let def: f.default
    eval f else (maybe def)
]
</code></pre>
<p>It points out the existence of <em>void branches</em>... so not branches that evaluate to void (e.g. <code>[void]</code>) but code that evaluates to a branch to run, and that branch is void.</p>
<p>Considering this specific usage only, it suggests a semantic for ELSE of a VOID branch, which is that you want it to act like there was no branch at all.  e.g. as if you'd written just <strong><code>eval f</code></strong> with no ELSE.</p>
<pre><code> &gt;&gt; if false [1 + 2]
 == ~void~  ; anti

 &gt;&gt; if false [1 + 2] else [10 + 20]
 == 30

 &gt;&gt; if false [1 + 2] else (void)
 == ~void~  ; anti
</code></pre>
<p>Would the same apply to THEN?</p>
<pre><code> &gt;&gt; if true [1 + 2]
 == 3

 &gt;&gt; if true [1 + 2] then [10 + 20]
 == 30

 &gt;&gt; if true [1 + 2] then (void)
 == 3
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>I don't know if it's great, but it's certainly better than evaluating to NULL (via some void-in-null-out rationale) because that would trigger an ELSE branch.</p>
<pre><code> &gt;&gt; if true [1 + 2] then (void) else [print "we don't want this."]
 we don't want this.
</code></pre>
<p>But what should other branching constructs do, like CASE or SWITCH?  Might a void branch suggest "opting out" of that particular branch?</p>
<pre><code> case [
     1 &lt; 2 (void)
     3 &lt; 4 [print "Should this run?"]
 ]
</code></pre>
<p>A CASE (at least CASE/ALL) is supposed to be synonymous with a series of IF statements.  And IF can't exactly do that, unless it decided to be NIHIL...</p>
<pre><code>&gt;&gt; 1 + 2 if false (void)
== 3
</code></pre>
<p>That would be a bit weird, but, it does sort of parallel what happens when ELSE and THEN effectively vaporize themselves.</p>
<p>As with most things on the edge of usefulness, I don't know about this... other than the situation of wanting to revoke the ELSE branch in SWITCH-D.  I'll keep an eye on it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/void-branches-not-branches-that-evaluate-to-void/2176">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/void-branches-not-branches-that-evaluate-to-void/2176</link>
          <pubDate>Thu, 28 Mar 2024 13:07:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2176</guid>
          <source url="https://forum.rebol.info/t/void-branches-not-branches-that-evaluate-to-void/2176.rss">VOID Branches (not branches that evaluate to void)</source>
        </item>
        <item>
          <title>Definitional Break and Continue... the Time is Now</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>I was writing what I thought to be a clever bit of code, <a href="https://forum.rebol.info/t/deceptive-incomplete-parsing-a-common-problem/2065">discussed here</a></p>
<pre><code>for-each file ... [
    parse file [thru any [".reb" ".r"] &lt;end&gt; | (continue)]
    ...
]
</code></pre>
<p>I thought it was pleasing to have the CONTINUE in the rules themselves.</p>
<p>Pleasing, except... a bit displeasing considering <strong>it didn't work.</strong></p>
<p>BREAK and CONTINUE would break or continue the first loop they found above them in the stack.  Since PARSE is currently written in usermode code, it uses loops in its implementation (to loop over the rules).  <em>so you wind up continuing some arbitrary loop inside the combinators, having random effects</em>!</p>
<p>Happily Ren-C has pioneered answers to this kind of problem with definitional returns.  But loops just have to get with the program and make CONTINUE and BREAK definitional in their bodies.</p>
<p>So I did it!  And most things appeared to work (like the motivating example).</p>
<h2>
<a name="still-complexity-for-loops-implemented-without-loops-1" class="anchor" href="https://forum.rebol.info#still-complexity-for-loops-implemented-without-loops-1"></a>Still Complexity For Loops Implemented Without "Loops"</h2>
<p>In bootstrap, there was some code implementing FOR-EACH-PLATFORM.  Hand-waving a bit, it initially looked like this:</p>
<pre><code> for-each-platform: func ['var [word! tuple!] body [block!]] [
     parse platforms-table [
         while [not &lt;end&gt;] [
              ...  ; rules that build up an OBJECT! 
              (set var obj, do body)
         ]
     ]
 ]
</code></pre>
<p>But that didn't make CONTINUE work:</p>
<pre><code> for-each-platform p [
     if p.name = 'HaikuOS [continue]
     ...
 ]
</code></pre>
<p>So I'd hacked up something at one point in history which looked like this monstrosity:</p>
<pre><code>    completed*: false
    running*: false
    while [true] [  ; must be in loop for BREAK or CONTINUE
        if running* [  ; must have had a CONTINUE
            completed*: true
            break
        ]
        running*: true
        do body
        completed*: true
        break
    ]
    if not completed* [return null] 
</code></pre>
<p>That depended on non-definitional CONTINUE happening inside BODY finding the enclosing WHILE.</p>
<p>But now, that CONTINUE isn't definitionally bound anywhere.  So that CONTINUE is just a reference to a default CONTINUE function in LIB, which will error telling you there are no loops providing continue available.</p>
<p>For the modern world, this <em>works</em>:</p>
<pre><code> repeat 1 body else [return null]
</code></pre>
<p>Reserving the pure NULL return value for BREAK means you can get that communication of when BREAK was encountered out of the return result.  And in this case, CONTINUE is just supposed to bypass the remainder of code in BODY and go on parsing.  So it works.</p>
<p>But it's suboptimal as the binding of the body to BREAK and CONTINUE happens on each run instead of once.  Doing that more efficiently would need some new techniques and case studies.</p>
<p>Overall though, it's progress...in the sense that there's an answer that works slowly, vs. not working at all!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/definitional-break-and-continue-the-time-is-now/2066">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/definitional-break-and-continue-the-time-is-now/2066</link>
          <pubDate>Thu, 07 Dec 2023 16:29:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2066</guid>
          <source url="https://forum.rebol.info/t/definitional-break-and-continue-the-time-is-now/2066.rss">Definitional Break and Continue... the Time is Now</source>
        </item>
        <item>
          <title>MOLD/ONLY vs. MOLD SPREAD</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Historically, the way you would ask to mold an array without its delimiters was with MOLD/ONLY:</p>
<pre><code>rebol2&gt;&gt; mold [a b c]
== "[a b c]"

rebol2&gt;&gt; mold/only [a b c]
== "a b c" 
</code></pre>
<p>In Ren-C this raises some existential questions, like how should quoted arrays be handled?</p>
<pre><code>mold/only first [''(a b c) d e]  ; ???
</code></pre>
<p>But I think there's a better answer: <em>use SPREAD and splice isotopes</em>.  If you want to mold the contents of an array, then turning it into a splice seems the natural answer.  And since you can't have splices of quoted things...there's a nice unambiguous answer.</p>
<pre><code>&gt;&gt; mold [a b c]
== "[a b c]"

&gt;&gt; mold spread [a b c]
== "a b c"
</code></pre>
<p>It does raise the question of what to do if you have something that might be an array or might not.  How do you tell it to mold as is if it's not an array, or without the delimiters if it is?  That's what MOLD/ONLY did, after all:</p>
<pre><code>rebol2&gt;&gt; mold/only [b l o c k]
== "b l o c k"

rebol2&gt;&gt; mold/only &lt;tag&gt;
== "&lt;tag&gt;"
</code></pre>
<p><em>"SPREAD won't SPREAD tags..."</em> you say.  And no, it won't.  But I think this is a rare case... and the neat thing about putting the bit on the value (as opposed to a refinement) is you can make functions like SPREAD-OR-AS-IS.  Or SPREAD-IF-PATH-OR-GROUP.  You can really tweak this however you want.</p>
<pre><code>&gt;&gt; mold spread-or-as-is &lt;tag&gt;
== "&lt;tag&gt;"

&gt;&gt; mold spread-or-as-is "[b l o c k]"
== "b l o c k"

&gt;&gt; spread-if-path-or-group 'p/a/t/h
== ~(p a t h)~  ; isotope

&gt;&gt; mold spread-if-path-or-group 'p/a/t/h
== "p a t h"
</code></pre>
<p>How about THAT?  All of this hinges on the idea that MOLD doesn't generally know how to mold isotopes, as they have no representation.  It just chooses to interpret the request to mold a splice isotope as "contents matter, no delimiters".</p>
<p>More control, more clarity, and the death of another /ONLY.  What more could you ask for?</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/mold-only-vs-mold-spread/2059">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/mold-only-vs-mold-spread/2059</link>
          <pubDate>Sun, 22 Oct 2023 23:59:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2059</guid>
          <source url="https://forum.rebol.info/t/mold-only-vs-mold-spread/2059.rss">MOLD/ONLY vs. MOLD SPREAD</source>
        </item>
        <item>
          <title>UNION, INTERSECT, DIFFERENCE...and Splices</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>There is a pattern that comes up a lot in Query which looks like this:</p>
<pre><code>if not find qe.clause-list 'update [append qe.clause-list 'update]
</code></pre>
<p>You could use an operation like UNION here, but since UNION only works on arrays you'd have to put UPDATE in a block:</p>
<pre><code>qe.clause-list: union qe.clause-list [update]
</code></pre>
<p>If the word to update with was in a variable (e.g. <strong>word: 'update</strong>), you couldn't do that block literally...so you'd need some blockifying function to do it:</p>
<pre><code>qe.clause-list: union qe.clause-list compose [(word)]

qe.clause-list: union qe.clause-list reduce [word]

qe.clause-list: union qe.clause-list :[word]

qe.clause-list: union qe.clause-list enblock word
</code></pre>
<h2>
<a name="semantics-of-operating-on-arrays-1" class="anchor" href="https://forum.rebol.info#semantics-of-operating-on-arrays-1"></a>Semantics of Operating on Arrays</h2>
<p>Historical Rebol would only accept BLOCK!s as the second argument to these operations.  I didn't see any reason not to generalize it, so I allowed GROUP!s as well:</p>
<pre><code>&gt;&gt; intersect [a b c d] '(b c e)
== [b c]

&gt;&gt; intersect '(a b c d) [b c e]
== (b c)
</code></pre>
<p>But there's a little bit of a question there about the result type.  Both arrays are taken account in terms of the elements, but only the first determines the type.  That's a little bit odd.</p>
<p>Furthermore, what if you wanted to intersect an array as an item?  The following wouldn't give you what you intended:</p>
<pre><code>item: [b]
collection: [[a] [b] [c] [d]]

collection: intersect collection item
</code></pre>
<p>You'd have to put the block into another block.  This is another one of those /ONLY style problems...</p>
<h2>
<a name="with-spread-we-can-do-this-better-2" class="anchor" href="https://forum.rebol.info#with-spread-we-can-do-this-better-2"></a>With SPREAD, we can do this better!</h2>
<p>We can make it so that UNION and friends assume you mean just one item by default, and you need to SPREAD the second argument to get it considered itemwise:</p>
<pre><code>&gt;&gt; union [a b c d] 'e
== [a b c d e]

&gt;&gt; union [[a] [b] [c] [d]] [e]
== [[a] [b] [c] [d] [e]]

&gt;&gt; union [[a] [b] [c] [d]] spread [e]
== [[a] [b] [c] [d] e]
</code></pre>
<p>So this means the operation from Query could be a little more succinct:</p>
<pre><code>if not find qe.clause-list 'update [append qe.clause-list 'update]
=&gt;
qe.clause-list: union qe.clause-list 'update
</code></pre>
<p>But more importantly, the as-is nature would avoid needing to jump through hoops for single-item operands:</p>
<pre><code> word: update
qe.clause-list: union qe.clause-list word
</code></pre>
<p>There are some questions about whether there is a guarantee of where the update would be added if it wasn't there... does it matter if it's added at the beginning or the end?</p>
<p>This is not a new question for these operations... the blocks are being treated as sets, so theoretically multiple answers could be valid:</p>
<pre><code>&gt;&gt; intersect [a b c d] spread [c b e]
== [b c]

 &gt;&gt; intersect [a b c d] spread [c b e]
== [c b]  ; what promises this wouldn't be the answer?
</code></pre>
<p>I think it's likely beneficial to make some kind of promise here.</p>
<h2>
<a name="should-unionetc-mutate-by-default-3" class="anchor" href="https://forum.rebol.info#should-unionetc-mutate-by-default-3"></a>Should UNION/etc. mutate by default?</h2>
<p>I point out that you'd have to write:</p>
<pre><code>qe.clause-list: union qe.clause-list 'update
</code></pre>
<p>In the Rebol model, "modify by default" is how things like APPEND or REVERSE work.  That would suggest you could write:</p>
<pre><code>union qe.clause-list 'update
</code></pre>
<p>And if you didn't want to modify qe.clause-list directly, you could copy it:</p>
<pre><code>result: union copy qe.clause-list 'update
</code></pre>
<p>If the interface to these functions was changed to work with splices and treat everything else as-is by default, it seems like a good time to make this change for consistency.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/union-intersect-difference-and-splices/2058">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/union-intersect-difference-and-splices/2058</link>
          <pubDate>Sun, 22 Oct 2023 06:06:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2058</guid>
          <source url="https://forum.rebol.info/t/union-intersect-difference-and-splices/2058.rss">UNION, INTERSECT, DIFFERENCE...and Splices</source>
        </item>
        <item>
          <title>MAYBE IF conditionals went back to returning NULL on Failure?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>A while ago, I made void more friendly... to say that void variables could be fetched without using GET-WORD! access or other fanfare:</p>
<pre><code>&gt;&gt; x: void

&gt;&gt; append [a b c] x
== [a b c]
</code></pre>
<p>My rationale was something along the lines of <em>"well, if you make a void variable, then you get what you were asking for"</em>.</p>
<p>A little bit unsettling is how easy you can make voids if something like your branches in a CASE or SWITCH are not exhaustive.  For instance:</p>
<pre><code>lib: switch config.platform [
    'Windows [%windows.lib]
    'Linux [%linux.a]
]
</code></pre>
<p>You've now got LIB as VOID.  It's a little uncomfortable for me to think about how such casual creation of voids makes a thing that will go around opting out of things, but those opt-outs produce NULL via the void-in-null-out protocol, so you should find out about it eventually.  My other argument was that if you didn't want this, then you should just throw in a FAIL at the ending:</p>
<pre><code>lib: switch config.platform [
    'Windows [%windows.lib]
    'Linux [%linux.a]
    fail  ; not so hard to do this if you don't want VOIDs
]
</code></pre>
<h2>
<a name="butwhat-if-you-want-a-null-1" class="anchor" href="https://forum.rebol.info#butwhat-if-you-want-a-null-1"></a>But...What if you <em>WANT</em> a NULL?</h2>
<p>As it happens, due to the <a href="https://forum.rebol.info/t/the-fallout-from-the-switch-fallout-feature/312">SWITCH and CASE "Fallout" Feature</a>, this also works with things like NULL:</p>
<pre><code>lib: switch config.platform [
    'Windows [%windows.lib]
    'Linux [%linux.a]
    null
]
</code></pre>
<p>Basically if you give an evaluative clause with no branch, the clause drops out if it is reached.</p>
<p>It is <em>weird</em>, but it's foreignness doesn't necessarily make it <em>bad</em>.  Though were it a CASE statement, some people might gravitate toward an always-TRUE branch as not violating the structure:</p>
<pre><code>lib: case [
    config.platform = 'Windows [%windows.lib]
    config.platform = 'Linux [%linux.a]
    true [null]
]
</code></pre>
<p>But SWITCH has no equivalent, so its either the fallout feature or an ELSE (which won't please <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> and I think I prefer fallout)</p>
<pre><code>lib: switch config.platform [
    'Windows [%windows.lib]
    'Linux [%linux.a]
] else [null]
</code></pre>
<h2>
<a name="or-is-this-a-job-for-a-void-to-null-operator-2" class="anchor" href="https://forum.rebol.info#or-is-this-a-job-for-a-void-to-null-operator-2"></a>Or Is This A Job For A VOID-TO-NULL Operator?</h2>
<p>I thought maybe TRY could nullify-voids, but this creates conflation of disabling raised errors returned by branches.  e.g. what if the Windows branch tried to READ a nonexistent file?</p>
<pre><code>lib: try switch config.platform [
    'Windows [read %windowslibname.txt]  ; imagine raises error
    'Linux [%linux.a]
]
</code></pre>
<p>Not being able to open the file would conflate with not taking a branch--no good.  This shows the use of TRY to convert voids to nulls is clearly a poor idea, and that needs to be a special purpose function.</p>
<p>So TRY is off the table at this point; it's an ignore-raised-error-and-continue.</p>
<p>MAYBE makes more sense as NULL-TO-VOID and serves well in that purpose.</p>
<p>DEVOID is a cryptic name that was actually proposed to turn VOIDs to NIHILs for vaporization in situations that didn't naturally vaporize voids:</p>
<pre><code>&gt;&gt; 1 + 2 void

&gt;&gt; 1 + 2 devoid void
== 3
</code></pre>
<p>So I will call this something like NULLIFY-IF-VOID until a better idea comes along.  Clearly not great for everyday use.</p>
<h2>
<a name="or-is-this-cold-feet-on-void-from-failed-conditionals-3" class="anchor" href="https://forum.rebol.info#or-is-this-cold-feet-on-void-from-failed-conditionals-3"></a>Or... Is This Cold Feet on Void From Failed Conditionals?</h2>
<p>Production of voids from failed conditionals was motivated almost entirely by wanting IFs to vanish quietly when they don't take their branch.  At first it was just COMPOSE:</p>
<pre><code> &gt;&gt; compose [&lt;a&gt; (if false [&lt;b&gt;]) &lt;c&gt;]
 == [&lt;a&gt; &lt;b&gt;]
</code></pre>
<p>But this spread to things like REDUCE, ANY, ALL, etc.</p>
<pre><code>&gt;&gt; reduce [1 + 2 if false [30] 100 + 200]
== [3 300]

&gt;&gt; all [&lt;a&gt; if false [&lt;b&gt;] if true [&lt;c&gt;]]
== &lt;c&gt;
</code></pre>
<p>In terms of composability and convenience, it's hard for me to think this isn't the right answer.  It feels like they get mutilated if you have to throw in a NULL-TO-VOID (what I've called "MAYBE")</p>
<pre><code>&gt;&gt; compose [&lt;a&gt; (maybe if false [&lt;b&gt;]) &lt;c&gt;]
== [&lt;a&gt; &lt;b&gt;]

&gt;&gt; reduce [1 + 2 maybe if false [30] 100 + 200]
== [3 300]

&gt;&gt; all [&lt;a&gt; maybe if false [&lt;b&gt;] maybe if true [&lt;c&gt;]]
== &lt;c&gt;
</code></pre>
<p>But perhaps it's only a good answer for IF, because it has one branch and you're very aware that it takes its branch or it doesn't?  Maybe twistier constructs like SWITCH and CASE should be more conservative and evaluate to NULL when a branch isn't taken...?  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_raised_eyebrow.png?v=12" title=":face_with_raised_eyebrow:" class="emoji" alt=":face_with_raised_eyebrow:" loading="lazy" width="20" height="20"></p>
<p>I don't like it for a couple of reasons, but a big one is that it feels like it throws a wrench into equivalencies.  e.g. I'd like:</p>
<pre><code> unmeta* any [
     meta* if condition1 [branch1]
     meta* if condition2 [branch2]
 ]
</code></pre>
<p>...to be the same as:</p>
<pre><code>case [
   condition1 [branch1]
   condition2 [branch2]
]
</code></pre>
<p>Having transformations which relate constructs together means people can build on reliable parts.  The response of ANY when all expressions void out is to give a VOID, and that's by design.</p>
<p>So, hmm.</p>
<h2>
<a name="or-are-void-variables-the-problem-4" class="anchor" href="https://forum.rebol.info#or-are-void-variables-the-problem-4"></a>...Or Are Void Variables The Problem?</h2>
<p>There could be some kind of rule, that variables are not allowed to hold voids...and if you assign void to a variable it becomes null.</p>
<pre><code> &gt;&gt; void? x: if false [&lt;a&gt;]
 == ~true~  ; isotope

 &gt;&gt; x
 == ~null~  ; isotope
</code></pre>
<p>Proposals along these lines have been entertained before.  I don't think I like it, and I feel like void variables should be legal.</p>
<h2>
<a name="i-think-im-committed-to-untaken-branches-as-void-5" class="anchor" href="https://forum.rebol.info#i-think-im-committed-to-untaken-branches-as-void-5"></a>I Think I'm Committed To Untaken Branches As VOID...</h2>
<p>But as with most things here, I think the fun is letting people play language designer and making their own choices.</p>
<p>If pure VOID means no branch taken, you can pipe the constructs:</p>
<pre><code>case: chain [:case, :void-to-null]
</code></pre>
<p>And that's it.  You could choose to do this for CASE and SWITCH so they'd need a MAYBE to vanish quietly, and leave IF alone.</p>
<p>But it's important to look at all the angles...!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/maybe-if-conditionals-went-back-to-returning-null-on-failure/2047">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/maybe-if-conditionals-went-back-to-returning-null-on-failure/2047</link>
          <pubDate>Mon, 14 Aug 2023 17:08:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2047</guid>
          <source url="https://forum.rebol.info/t/maybe-if-conditionals-went-back-to-returning-null-on-failure/2047.rss">MAYBE IF conditionals went back to returning NULL on Failure?</source>
        </item>
        <item>
          <title>Should ANY and ALL Vaporize VOID (or require ELIDE-IF-VOID ?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>I've written up how <a href="https://forum.rebol.info/t/invisibility-reviewed-through-modern-eyes/2034">the evolution of invisibility gave rise to VOID vs. NIHIL</a>.</p>
<p>The default evaluator (and UPARSE) accept that void is "nothing" and can't be put in blocks.  But they don't vaporize VOID on a whim: it will still be the result of expressions whose last result is a void.</p>
<pre><code>&gt;&gt; 1 + 2 if false [&lt;a&gt;]
; void
</code></pre>
<p>On the other hand, the empty parameter pack of NIHIL truly vaporizes unless you pipe it around with ^META:</p>
<pre><code>&gt;&gt; 1 + 2 nihil
== 3
</code></pre>
<p>This means it's up to constructs to decide if they want to erase voids or not.  DELIMIT does, so you will see that reflected in things like UNSPACED:</p>
<pre><code>&gt;&gt; unspaced ["A" if false ["B"] "C"]
== "AC"
</code></pre>
<p>COMPOSE vaporizes void slots (and errors on null ones).  <a href="https://forum.rebol.info/t/vaporizing-failed-conditionals-in-reduce/1665">REDUCE is currently vaporizing VOID</a> because it seems like the default people want.</p>
<h2>
<a name="should-any-and-all-vaporize-voids-1" class="anchor" href="https://forum.rebol.info#should-any-and-all-vaporize-voids-1"></a>Should ANY and ALL Vaporize Voids?</h2>
<p>To me, this is a bit of a tough decision.</p>
<p>VOID is neither truthy nor falsey, and IF will reject it:</p>
<pre><code>&gt;&gt; if (if false [true]) [&lt;unreachable&gt;]
** Error: IF doesn't accept VOID as its condition argument
</code></pre>
<p>When there was no VOID/NIHIL distinction, then ANY and ALL were backed into a corner.  If they decided to error on void, you couldn't use an ELIDE or ASSERT in the middle of them.  If they didn't error on VOID then the risk was that you could write something like <strong><code>all [1 = 1, 2 = 2, value]</code></strong> and if VALUE was just incidentally void you'd get the 2 = 2 result as ~true~.</p>
<p>Today, things like ELIDE and ASSERT return NIHIL and can be safely vaporized by ANY and ALL, while retaining the choice to error on voids as not being true or false.  If you really want to erase voids, we can have something that converts voids to nihil called ELIDE-IF-VOID</p>
<pre><code>&gt;&gt; value: void

&gt;&gt; all [1 = 1, 2 = 2, value]
** Error: VALUE is VOID which is neither truthy nor falsey

&gt;&gt; all [1 = 1, 2 = 2, elide-if-void value]
== ~true~  ; isotope
</code></pre>
<h2>
<a name="things-like-for-bothhttpsforumrebolinfotdemonstrating-for-both-loop-composability-for-the-win1833-would-get-more-awkward-2" class="anchor" href="https://forum.rebol.info#things-like-for-bothhttpsforumrebolinfotdemonstrating-for-both-loop-composability-for-the-win1833-would-get-more-awkward-2"></a>Things Like <a href="https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833">FOR-BOTH</a> Would Get More Awkward...</h2>
<p>I was fairly proud of this formulation:</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    return unmeta* all [
        meta* for-each (var) blk1 body
        meta* for-each (var) blk2 body
    ]
]
</code></pre>
<p>(I wound up deciding that META would meta-raise everything--including pure null and void--so the asterisks were probably best included there for the alternative formulation.)</p>
<p>But if ALL and ANY errored on void, and you had to erase it, this would become:</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    return unmeta* all [
        elide-if-void meta* for-each (var) blk1 body
        elide-if-void meta* for-each (var) blk2 body
    ]
]
</code></pre>
<p>If I put on my formalism hat, I can see how this is <em>safer</em>.  But I've made similar arguments about why I don't want this:</p>
<pre><code>&gt;&gt; compose [a (if false ['b]) c]
** Error: COMPOSE cannot erase VOID (use ELIDE-IF-VOID if intentional)

&gt;&gt; compose [a (elide-if-void if false ['b]) c]
== [a c]
</code></pre>
<p>It is admittedly a bit different in ANY and ALL's case, because they're mixing in a test for truthiness.  But erasing voids by default has other advantages in writing wild control constructs.</p>
<p>I'm really torn on this, as it's right on the edge.  <strong>But when all things are mostly equal, safety isn't as compelling as enabling creativity in my current view of the language.</strong>  I think I'm going to wait until I see a really bad consequence of vaporizing the voids here... it hasn't broken any real code yet, and it has proven its convenience.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-any-and-all-vaporize-void-or-require-elide-if-void/2040">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-any-and-all-vaporize-void-or-require-elide-if-void/2040</link>
          <pubDate>Thu, 29 Jun 2023 02:09:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2040</guid>
          <source url="https://forum.rebol.info/t/should-any-and-all-vaporize-void-or-require-elide-if-void/2040.rss">Should ANY and ALL Vaporize VOID (or require ELIDE-IF-VOID ?)</source>
        </item>
        <item>
          <title>Correct Formulation of ME and MY</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>The ME function is used with enfix to allow you to avoid repeating the name of a variable:</p>
<pre><code>&gt;&gt; variable: 10

&gt;&gt; variable: me + 1
== 11

&gt;&gt; variable
== 11
</code></pre>
<p>So that's the same as if you'd written <strong>variable: variable + 1</strong>.</p>
<p>There's an analogous operation for non-enfix functions called MY.</p>
<pre><code>&gt;&gt; block: [a b c]

&gt;&gt; block: my next
== [b c]

&gt;&gt; block
== [b c]
</code></pre>
<p>So the same if you had written <strong>block: next block</strong>.</p>
<h2>Here Is The "Naive" Macro Implementation of ME</h2>
<pre><code>me: enfixed macro [
    'left [set-word! set-tuple!]
    'right [word! tuple! path!]
][
    reduce [left, plain left, right]
]
</code></pre>
<p>So the macro is looking for a SET-WORD! or SET-TUPLE! on the left, and then something indicating the action to run on the right.  It replaces the whole sequence with what was on the left, then a plain WORD! or TUPLE! version of what was on the left, and then what's on the right.</p>
<p>MY is done similarly, just with <strong>reduce [left, right, plain left]</strong> to put the repeated term after the call.</p>
<p>This is naive for two reasons:</p>
<ul>
<li>
<p>It doesn't check that what the RIGHT parameter looks up to is an action</p>
</li>
<li>
<p>If the SET-TUPLE! in LEFT has a GROUP! in it, then it will be executed twice.</p>
</li>
</ul>
<h2>Here is A "Non-Naive" Implementation of ME</h2>
<pre><code>macro [
    'left [set-word! set-tuple!]
    'right [word! tuple! path!]
    &lt;local&gt; value
][
    [left value]: resolve left  ; avoid double-evaluation
    :['set left meta value ensure action! get right]
]
</code></pre>
<p>The RESOLVE function is used to turn a TUPLE! or PATH! with groups in it into an inert representation:</p>
<pre><code> &gt;&gt; blk: [a b [c d]]

 &gt;&gt; resolve 'blk.(print "hi", 1 + 2).2
 hi
 == @[blk 3 2]
</code></pre>
<p>GET and SET accept these blocks as an alternative to words/tuples to be used to describe what to set or get.</p>
<p>It has to use a BLOCK! representation because not all things can be represented in paths that can be used with picking (note this implies you cannot pick with isotopes, otherwise not all blocks would be resolvable).</p>
<p>So long as RESOLVE is walking the path, you can ask it to give you back the value of what's there.</p>
<h2>But the non-naive version triggers a binding bug...</h2>
<p>It's also rather slow.  In trying to prioritize, it may be better to just document the right answer, as I've done here... :-/</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/correct-formulation-of-me-and-my/2020">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/correct-formulation-of-me-and-my/2020</link>
          <pubDate>Fri, 03 Mar 2023 21:23:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2020</guid>
          <source url="https://forum.rebol.info/t/correct-formulation-of-me-and-my/2020.rss">Correct Formulation of ME and MY</source>
        </item>
        <item>
          <title>Picking ACTION!s from BLOCK!s In The Age of Isotopes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>In <strong><a href="https://forum.rebol.info/t/reds-design-issues-wiki/1282">Red's Design Questions wiki</a></strong>, they bring up the issue of why picking functions out of blocks runs them:</p>
<pre><code>red&gt;&gt; block: reduce [does [print "Evaluated."]]
  == [func [][print "Evaluated."]]

red&gt;&gt; equal? block/1 first block
Evaluated.  ; d'oh
== false
</code></pre>
<p><a href="https://gitter.im/red/red?at=5c782ca0c1cab53d6f53dd6d">In the Gitter conversation</a>, Boris calls it a "shady area" that they can't get out of "under the current semantic model".  He suggests it is clear that <strong><code>block/1</code></strong> should not run an action, but possible that <strong>block/word</strong> would mean to.</p>
<p>They contemplate the idea that <strong>block/1</strong> would not run the action, but pick it:</p>
<pre><code>red&gt;&gt; block: reduce [does [print "Evaluated."]]
  == [func [][print "Evaluated."]]

red&gt;&gt; equal? block/1 first block  ; hypothetical behavior
== false
</code></pre>
<p><strong>I will argue this doesn't really help you much, the problem just becomes one step removed.</strong>  Quite often people are picking things out of blocks to put them in variables, and you'll just get bit there instead:</p>
<pre><code>red&gt;&gt; otherblock: copy []
== []

red&gt;&gt; temp: block/1
== func [][print "Evaluated."]

red&gt;&gt; append otherblock temp
Evaluated.  ; d'oh
== [unset]  ; double d'oh
</code></pre>
<h2>
<a name="isotopes-bring-the-better-semantic-model-1" class="anchor" href="https://forum.rebol.info#isotopes-bring-the-better-semantic-model-1"></a>Isotopes Bring The Better Semantic Model!</h2>
<p>In Ren-C's concept (as I'm working on it), the only actions that will run from a word reference are those that are isotopic actions.  And FUNC or DOES creates an isotopic action.</p>
<p>So you would be stopped from making an illegal block up front:</p>
<pre><code>&gt;&gt; block: reduce [does [print "Evaluated."]]
** Script Error: Invalid use of ~#[action! []]~ isotope
</code></pre>
<p>You can put quasi-ACTION!s, plain ACTION!s, and quoted actions in blocks.  Just not isotopic ones.</p>
<p>Whichever you choose, the equality test will work... and picking out a value into a variable will give you an inert variable to work with, that can be used with things like append!</p>
<pre><code>&gt;&gt; block: reduce [reify does [print "Evaluated."]] 
== [~#[action! []]~]

&gt;&gt; equal? block.1 first block
== ~true~  ; isotope  &lt;-- didn't run and print "Evaluated", yay!

&gt;&gt; otherblock: copy []
== []

red&gt;&gt; temp: block.1
== ~#[action! []]~

red&gt;&gt; append otherblock temp
== [~#[action! []]~]   ; &lt;-- didn't run and gave sensible block out
</code></pre>
<p>I used REIFY there and got a quasi-action.  BUT which would you rather put in the block: a quasi-action or a plain one?  This depends on what you plan to do with the block.  A plain action will execute when encountered by the evaluator, while a quasi-action will evaluate to an isotopic action--suitable for assigning via SET-WORD! when you meant to make that word dispatch the function when referenced.</p>
<p>My leaning is to say that either form can be used with APPLY, RUN, or the terminal path form:</p>
<pre><code>&gt;&gt; block: reduce [reify does [print "Evaluated."]] 
== [~#[action! []]~]

&gt;&gt; run block.1
Evaluated.

&gt;&gt; block: reduce [concretize does [print "Evaluated."]] 
== [#[action! []]]

&gt;&gt; apply block.1 []
Evaluated.
</code></pre>
<p><em>(See post on <a href="https://forum.rebol.info/t/reify-vs-meta-vs-something/2001">difference between REIFY and CONCRETIZE</a>, and the search for a better term...)</em></p>
<p>If you want to pick an action out of a block and put it into a variable, where it will execute from that variable, there is the RUNS transformer.  It will turn a quasi or plain ACTION! into an action isotope:</p>
<pre><code> &gt;&gt; active-var: runs block.1
 == ~#[action! {active-var} []]~  ; isotope  &lt;-- note: also cached name, neat!

 &gt;&gt; active-var
 Evaluated.
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/clap.png?v=12" title=":clap:" class="emoji only-emoji" alt=":clap:" loading="lazy" width="20" height="20"></p>
<p>You can use UNMETA more generically to get an isotope back from any quasi-form (not just actions), or ISOTOPIC to get an isotope from a plain form.</p>
<h2>
<a name="the-invariant-is-what-counts-here-2" class="anchor" href="https://forum.rebol.info#the-invariant-is-what-counts-here-2"></a>The Invariant Is What Counts, Here!</h2>
<p>The mountain that has been climbed is that we can now say that for any block, this is true:</p>
<pre><code>block2: collect [
    for-each item block1 [keep item]
]

assert [equal? block1 block2]
</code></pre>
<ul>
<li>
<p>I've just covered that there are no isotopic actions to implicitly execute; you'd get an error trying to put them in the block.</p>
</li>
<li>
<p>There are no blocks/groups/paths that will splice into the target, because splicing requires an explicit conversion to an isotope.</p>
</li>
<li>
<p>There are no "unsets" to trip on that you can find in a block, because the state conveying "unsetness" (none) is an isotope.</p>
</li>
</ul>
<p>Of course with objects, it's going to be a different story.  I think we'll still want some safeguards:</p>
<pre><code>for-each [key value] object [...]  ; will error when value is action

for-each [key :value] object [...]  ; will allow action isotopes as-is

for-each [key ^value] object [...]  ; will give a meta value
</code></pre>
<p>A key problem here is I'm wondering how much to cross purposes of GET-WORD! between action disarming and the other isotopic states.  But, it just takes time to work through.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/picking-action-s-from-block-s-in-the-age-of-isotopes/2002">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/picking-action-s-from-block-s-in-the-age-of-isotopes/2002</link>
          <pubDate>Fri, 06 Jan 2023 03:16:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2002</guid>
          <source url="https://forum.rebol.info/t/picking-action-s-from-block-s-in-the-age-of-isotopes/2002.rss">Picking ACTION!s from BLOCK!s In The Age of Isotopes</source>
        </item>
        <item>
          <title>SPLIT Semantics</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p><a href="https://gitter.im/red/red?at=63523097f00b697fec501c7a">On Red Gitter</a>, it was discussed "which of the following is 'correct'":</p>
<pre><code>Red&gt; split "" ","
== [""]

R3&gt; split "" ","
== []
</code></pre>
<p>Rebolek thinks R3 is right.  Boris says:</p>
<blockquote>
<p>I don't think there's a correct answer, just choices. I prefer the Red version because:<br>
it strictly follows the rule: `number-of-segments = 1 + number-of-delimiters", no exceptions, so it's easier to reason about</p>
<p>it should be able thus to preserve the type in case one wants to rejoin it later (that it doesn't is a bug, try split %"" ",")</p>
</blockquote>
<p>So there's a couple of ways to look at it.</p>
<p>But I have a philosophy about these things where I want edge cases to be "noisy", because usually they require special handling.  I might even say:</p>
<pre><code>&gt;&gt; split "" ","
== ~null~  ; isotope</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/split-semantics/1998">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/split-semantics/1998</link>
          <pubDate>Thu, 22 Dec 2022 04:04:52 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1998</guid>
          <source url="https://forum.rebol.info/t/split-semantics/1998.rss">SPLIT Semantics</source>
        </item>
        <item>
          <title>Should ELSE be FALSE-reactive? (in addition to void and null?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Historically one might have asked why ELSE doesn't think falseness is something worth reacting to:</p>
<pre><code>&gt;&gt; 1 = 2 else [print "Why not print?"]
Why not print?  ; seems not so bad, right?
</code></pre>
<p>The idea was panned, because <code>#[false]</code> was <em>a value</em> and ELSE's main job was to react to the situation of a branching construct that didn't produce a value:</p>
<pre><code>&gt;&gt; math-broken: if 1 = 1 [false] else [true]
== #[false]  ; if this were #[true], math seems broken
</code></pre>
<p>But now, the actual falsey <code>~false~</code> state is isotopic.  And some years of struggle with the parallel problem of what to do with branches that returned "non-values" bore curious fruit: a box that could hold a "non-value" like a null.</p>
<pre><code>&gt;&gt; if false [null]
== ~null~  ; isotope
     ^-- there is no result

&gt;&gt; if true [null]
== ~[~null~]~  ; isotope
     ^-- there is a result and it is null
</code></pre>
<p>Isotopic blocks containing one element will decay to that one element in most situations.  But ELSE is sensitive to the difference via a ^META parameter.  If someone has gone through the effort to box up a null or void vs leave it as a plain isotope, the ELSE assumes it's a meaningful result and should pass it on.  And conditional expressions know to do this; they box up nulls and voids if they are produced by executing branches.</p>
<p><strong>The same technique could work for false.</strong></p>
<pre><code>&gt;&gt; if 1 = 1 [false]
== ~[~false~]~  ; isotope

&gt;&gt; if 1 = 1 [false] else [true]
== ~[~false~]~  ; isotope

&gt;&gt; math-broken: if 1 = 1 [false] else [true]
== ~false~  ; isotope
</code></pre>
<p>It's barely any additional work for conditionals to do on top of what they're doing already.  Although it can result in branches producing false to cost a small bit more than they do today <em>(I wouldn't worry about it, these single element boxes could be optimized if it was a problem)</em></p>
<p>But I don't know how useful it would actually be.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=9" title=":man_shrugging:" class="emoji" alt=":man_shrugging:">  Just writing down the observation.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/should-else-be-false-reactive-in-addition-to-void-and-null/1991">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-else-be-false-reactive-in-addition-to-void-and-null/1991</link>
          <pubDate>Sun, 27 Nov 2022 06:00:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1991</guid>
          <source url="https://forum.rebol.info/t/should-else-be-false-reactive-in-addition-to-void-and-null/1991.rss">Should ELSE be FALSE-reactive? (in addition to void and null?)</source>
        </item>
        <item>
          <title>Line Continuation and Arity Bugs: Thoughts?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>At one point in time, there was no way to pass something to RETURN that represented a VOID.  Because voids completely vanished.  If you had a function that took an argument--and a void thing came after it--the evaluator would just keep retriggering until it found a value or hit the end.</p>
<p>This led to the only way of being able to return a void to be to have truly nothing after it.  So RETURN became effectively arity-0 or arity-1.  If you passed it no argument, it would consider itself VOID.  It even had the nice property of being able to chain functions that themselves might be void.</p>
<p>Given that RETURN was doing this, some other functions followed suit.  QUIT could take an argument or not.  CONTINUE could as well.</p>
<h2>But I Just Got Bit By a Variadic QUIT Bug</h2>
<p>Without thinking about it, I tried to end some code prematurely by injecting a quit:</p>
<pre><code> some stuff I wanted to run

 quit  ; added this

 some stuff I wanted to avoid running
</code></pre>
<p>And that QUIT ran the stuff I didn't want to run anyway, because it was variadic.</p>
<h2>My Kneejerk Reaction Was To Kill The Variadicness</h2>
<p>The original case of RETURN has changed, because so-called "non-interstitial invisibility" is dead.  You can only make expressions void in their totality--not when used as arguments.  Doing otherwise caused more harm than good.</p>
<p>Hence <strong><code>return void</code></strong> is a perfectly fine thing to write <em>(or <strong><code>return ~</code></strong> if you prefer the quasiform of void, which you probably don't, but it might come in handy somewhere if you've defined VOID to mean something else)</em></p>
<p>I'd been thinking that argument-less RETURN would thus go back to returning the default unfriendly value (currently called NONE, a <strong><code>~[]~</code></strong> isotope, e.g. a parameter pack with absolutely no values in it).  But maybe we shouldn't support argument-less RETURN at all.</p>
<h2>But Variadics Can Be Neat</h2>
<p>I guess RETURN could always take an argument, and we go back to CONTINUE/WITH and QUIT/WITH.</p>
<p>But those are uglier.</p>
<p>We might question the behavior of the system just randomly slurping up arguments from enusing lines?  Especially when APPLY has such a convenient notation now, of <strong>some-func/ [...]</strong></p>
<p>From a usability perspective, there's certainly a lot of potential for error in getting the arity wrong.  Having it be more strict could catch bugs, and make it more likely that variadic arity is being used correctly.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/line-continuation-and-arity-bugs-thoughts/1965">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/line-continuation-and-arity-bugs-thoughts/1965</link>
          <pubDate>Wed, 14 Sep 2022 17:08:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1965</guid>
          <source url="https://forum.rebol.info/t/line-continuation-and-arity-bugs-thoughts/1965.rss">Line Continuation and Arity Bugs: Thoughts?</source>
        </item>
        <item>
          <title>Revisiting TO and THRU</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>If you asked someone to count "from 1 to 10", how many people would stop at 9?</p>
<p>I'd say most wouldn't.  So if you wrote:</p>
<pre><code>for x [1 to 10] [print [x]]
</code></pre>
<p>What should that do?  I think if you showed it to people they would expect 10 to be included.</p>
<p>But PARSE has historically discerned this via TO (not including the limit) and THRU (including the limit).</p>
<p>Is that right?  Should TO be inclusive, and some other word along the lines of "UPTO" be used?</p>
<p>I almost feel like the words are slippery enough that we could bend them so that THRU was the <em>non</em>-inclusive version.  :-/</p>
<p>In PARSE, if TO included the limit, you could go up-to-but-not-include by using AHEAD with it: <strong><code>to ahead "A"</code></strong></p>
<p>We could say that UNTIL would keep advancing until it hit the rule and then stopped short of it: <strong><code>until "A"</code></strong>.</p>
<p>Would that convey the right thing in the FOR case?</p>
<pre><code>&gt;&gt; for x [1 until 10] [print [x]]
1
2
3
4
5
6
7
8
9</code></pre>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/revisiting-to-and-thru/1961">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/revisiting-to-and-thru/1961</link>
          <pubDate>Tue, 06 Sep 2022 16:56:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1961</guid>
          <source url="https://forum.rebol.info/t/revisiting-to-and-thru/1961.rss">Revisiting TO and THRU</source>
        </item>
        <item>
          <title>Should REDUCE Heed SPREAD?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>When <a href="https://forum.rebol.info/t/putting-splicing-intent-on-appended-value/1873/9">suggesting the term SPREAD</a>, <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> gave this example for REDUCE behavior, which hadn't occurred to me previously:</p>
<pre><code>&gt;&gt; reduce [spread [a b c] [a b c]]
== [a b c [a b c]]
</code></pre>
<p>Nothing about the design makes this happen automatically.  REDUCE has historically errored on isotopes.  So code has to be added to override that.</p>
<p>I'm guessing most people would be in favor of having the splicing behavior.  Arguments that say that there should be a 1:1 correspondence between expressions and values in a REDUCE are already pretty much out the window, since VOID elements vanish (including conditionals that don't take any branch).</p>
<h2>DELIMIT Would Presumably Want It Too</h2>
<p>I've complained in the past that the often random-seeming treatments of blocks in Rebol2 functions like REJOIN lead to problems--and that it would be better if people had to be explicit about their intent.  This offers the ability to "inherit" whatever the enclosing delimiting strategy is, and fold into the existing operation (technically more efficient):</p>
<pre><code>&gt;&gt; block: ["c" "d"]

&gt;&gt; spaced ["a" "b" block]
** Error: BLOCK! not handled by DELIMIT, use SPREAD or desired string conversion

&gt;&gt; spaced ["a" "b" spread block]
== "a b c d"

&gt;&gt; spaced ["a" "b" unspaced block]  ; if you wanted another interpretation
== "a b cd"
</code></pre>
<p>I believe I prefer this over having some default way that blocks behave inside string conversions.  The odds of guessing right are low enough that it's better to have people be explicit.</p>
<p>So...presuming there's no objections....there's an agenda item to fuse together the stackless logic that performs a REDUCE so that it's the same code running in DELIMIT, so I'd probably go ahead and do that and make these things work.</p>
<p><strong>UPDATE circa Oct 2022: This has been done, so you can now use this feature.</strong></p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/should-reduce-heed-spread/1917">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-reduce-heed-spread/1917</link>
          <pubDate>Tue, 16 Aug 2022 04:10:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1917</guid>
          <source url="https://forum.rebol.info/t/should-reduce-heed-spread/1917.rss">Should REDUCE Heed SPREAD?</source>
        </item>
        <item>
          <title>Ideas About a More General Meaning for TRY</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>TRY was changed from a "blank-in, null-out" meaning to use definitional errors.  This allowed NULL to be both the input and the output...without risking inadvertently trapping errors from arbitrary depths.  You'll really be intercepting the error emitted by the function just called:</p>
<pre><code>&gt;&gt; first null
** Error: FIRST on NULL requires use of TRY

&gt;&gt; try first null
; null
</code></pre>
<p>I mentioned something, which was that a "You need a TRY" ERROR! was actually able to carry a payload, saying what the TRY'd outcome value should be.  <em>(The only rule would be that a function emitting such an error should not have any side effects if it emits one of these errors.)</em></p>
<p>If we embrace this, it could really open the doors to what TRY means.  Various constructs could offer meanings for what the TRY actually does:</p>
<pre><code>&gt;&gt; unquote first ['abc]
== abc

&gt;&gt; unquote first [def]
** Error: Can't Unquote Plain WORD!, use TRY if Intentional

&gt;&gt; try unquote first [def]
== def
</code></pre>
<p>I'm sort of leaning to believing that this more general meaning of TRY may be much more interesting than the "null propagating" sense.  There's kind of an explosion of potential for the "couldn't do what you asked me to do, but if that's what you meant..." outcomes.</p>
<p>At one point I suggested it would be nice to be able to have a COLLECT that didn't actually KEEP anything return NULL, so it could be ELSE-reactive.  That meant if you really wanted an empty block, you'd have to do something like <strong><code>any [collect [...], copy []]</code></strong> which was ugly.  But the error could hold a freshly-copied block to be the result of a TRY:</p>
<pre><code>&gt;&gt; collect [keep if false [&lt;not kept&gt;]]
** Error: COLLECT didn't KEEP anything, use TRY if intended

&gt;&gt; try collect [keep if false [&lt;not kept&gt;]]
== []
</code></pre>
<p>There are various technical reasons why ELSE can't be reactive to TRY-style errors.  One fairly important one would be that if you used ELSE with a branching construct, it wouldn't be able to tell the difference between a branch that had a TRY-error and no branch taken:</p>
<pre><code>&gt;&gt; case [true [unquote first [def]]] else [print "Took branch, runs due to UNQUOTE"]
Took branch, runs due to UNQUOTE  ; this would be bad
</code></pre>
<p>But... maybe the trick could be that if you pass ELSE a function that takes an argument, it assumes that means you handle TRY-style errors?  (Because otherwise it could only be void/null... why take an arg?)</p>
<pre><code>&gt;&gt; (unquote first [def]) else arg -&gt; [print ["TRY error" arg]]
TRY error def
</code></pre>
<p>It's a weird thought.  Anyway, just wanted to write up the TRY concept...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/ideas-about-a-more-general-meaning-for-try/1912">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/ideas-about-a-more-general-meaning-for-try/1912</link>
          <pubDate>Tue, 09 Aug 2022 13:28:03 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1912</guid>
          <source url="https://forum.rebol.info/t/ideas-about-a-more-general-meaning-for-try/1912.rss">Ideas About a More General Meaning for TRY</source>
        </item>
        <item>
          <title>Weird Idea: LIB/APPEND Runs, but LIB.APPEND Doesn&#39;t?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Historical Redbol did not have generic TUPLE!.  So that meant it used paths for everything...whether you were specifying a refinement to a function, or doing a member selection out of an object, or coordinate out of a pair, or...whatever.</p>
<p>So far what Ren-C has done is to shift it such that tuples are for member selection, and pathing is for refinements only.</p>
<p>A new twist is that a terminal-slash in a path (e.g. the last element is a BLANK!) <a href="https://forum.rebol.info/t/apply-ii-the-revenge/1834/7">means "APPLY the action"</a>.  This is especially helpful when wanting to run a non-isotopic action in the new "activated actions" model:</p>
<pre><code>&gt;&gt; block: reduce [reify :print]

&gt;&gt; block.1
== #[action! {print} [line]]

&gt;&gt; block.1/ ["The terminal slash comes in handy!"]
The terminal slash comes in handy!
</code></pre>
<p>So if you have a non-isotopic action in your hand, the slash can run it.  But under the current rules, your arguments and refinements need to go in a BLOCK!.</p>
<h2>Terminal Slashes Could Provide Safety...</h2>
<p>With the above, the pattern you would use to say you were going to run something like APPEND/DUP out of LIB would be this:</p>
<pre><code>&gt;&gt; lib.append/dup [a b c] [d e] 2
== [a b c [d e] [d e]]
</code></pre>
<p>But this means that you're on the hook for simple tuple references running, which you may not have expected:</p>
<pre><code>&gt;&gt; if integer? obj.something [print "What if SOMETHING is an ACTION! isotope?"]
Boo!
** Error: Some error coming from OBJ.SOMETHING running
</code></pre>
<p>One way of stopping this would be to say that if you were going to call a function that was a member of an object, you'd have to use a terminal slash, otherwise you'd get an error.</p>
<pre><code>&gt;&gt; if integer? obj.something [print "Clearer error if it's an ACTION! isotope"]
** Error: OBJ.SOMETHING is an ACTION! isotope, use OBJ.SOMETHING/ if intended
</code></pre>
<p>That would make field selection on the whole feel "safer".  But at the cost of looking at a lot of terminal slashes, and nowadays that also forces you to use APPLY and pass your arguments in a BLOCK!.</p>
<h2>More Succinct: Allow PATH!s to Pick The Action, Too</h2>
<p>If something like <strong>lib.append/dup</strong> is clearly an action (due to the use of refinements) it wouldn't need the terminal slash, like <strong>lib.append/dup/</strong>.  You already know an action is being run.</p>
<p>So what if you said <strong>lib/append</strong> instead of <strong>lib.append/</strong> ?</p>
<p>Of course, under such a rule, <strong>lib/append</strong> becomes conflated with a situation where LIB is a function and you're applying the <strong>/append</strong> refinement.  This does break away from a rule like "slashes always mean refinements".</p>
<p>That <em>kind of</em> sucks...BUT...it's still <em>far</em> less conflated than it was before.  Remember, historical Redbol used slashes for <em>EVERYTHING</em>.</p>
<p>The new rule could be "slashes always mean <em>from here on out, what we're talking about is function invocation"</em>.  So it's either picking a function to run, or narrowing it down by means of a refinement.</p>
<p>The advantage here system-wide would be that you could use field selection without worrying about it, as <strong>foo.bar</strong>, meaning "I want that field and I don't want any functions to run".  If there's no slash, there's no invocation.</p>
<p>I almost feel like the weird exception is worth it, because it would save a lot of bulletproofing that would otherwise be required on objects.  But it's also clearly a bit <em>bent</em>.</p>
<h2>The Other Direction: Terminal Dot as Invocation Suppressor</h2>
<p>There's a possibility for saying "this reference is not an invocation", which could apply to WORD!s and to TUPLE!s alike.  That's the terminal dot.</p>
<pre><code>&gt;&gt; x: append.
** Error: APPEND. reference ends in dot but it's an ACTION! isotope
</code></pre>
<p>It has one downside of kind of being close to being a comma.</p>
<p>But the bigger reason I don't like this is just the mental tax that comes into effect.  It's the same as how I didn't like the creeping desire for correctness, meaning people putting colons in front of things in a fairly ad-hoc way.  We'd like the obvious code to just work.</p>
<p>I think the LIB/APPEND compromise may be worthwhile to get this correctness-by-default situation.</p>
<h2>Possible Objection: Value/Function Invariance?</h2>
<p>We might say that forcing you to distinguish at the callsite whether you are calling a function or not, prevents you from taking something that was a plain value previously, and substituting it with a function that calculates that value.</p>
<p>Under this principle, it's a feature that you "don't know" if <strong>obj.something</strong> is an action isotope or not...and making you commit to which it is by saying <strong>obj/something</strong> is bad.</p>
<p>It's kind of a narrow case--since you <em>have</em> to know at the callsite if it's a function that consumes arguments.  So it could only be argued for arity-0 functions.  And if the function doesn't return the same value every time, you're subject to some semantic questions.</p>
<p>I think that the answer here is that "accessor" functions (getter/setter) wouldn't count in this, if they existed.  They would use the tuple syntax but stay "behind the scenes".</p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/weird-idea-lib-append-runs-but-lib-append-doesnt/1902">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/weird-idea-lib-append-runs-but-lib-append-doesnt/1902</link>
          <pubDate>Thu, 28 Jul 2022 02:04:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1902</guid>
          <source url="https://forum.rebol.info/t/weird-idea-lib-append-runs-but-lib-append-doesnt/1902.rss">Weird Idea: LIB/APPEND Runs, but LIB.APPEND Doesn&#39;t?</source>
        </item>
        <item>
          <title>Attack of the Activated Actions</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Here's something seemingly-simple that a newcomer to Redbol might attempt:</p>
<blockquote>
<p>TASK: Write a function TWOSIE? that...</p>
<ul>
<li>returns true if a value is the INTEGER! of 2, or a BLOCK! of length 2</li>
<li>returns false otherwise</li>
</ul>
</blockquote>
<hr>
<pre><code>twosie?: func [x] [          ; Ren-C calls this LAMBDA, due to no RETURN
    to-logic any [
        x = 2                ; will also pick up DECIMAL!, since 2 = 2.0
        all [
            block? x
            2 = length? x    ; length at current position, not total 
        ]
    ]
]
</code></pre>
<hr>
<p>An "experienced" Redbol user would point out what happens when you pass a FUNCTION!.</p>
<pre><code>red&gt;&gt; twosie? :append
*** Script Error: = operator is missing an argument
*** Where: =
*** Stack: twosie? to-logic 
</code></pre>
<p>If <strong>x</strong> turns out to be a FUNCTION!, it is invoked by the references inside the body.  Which can cause unwanted side effects, as well as arbitrarily cryptic errors.</p>
<h2>How Was This Mitigated?</h2>
<p>You <em>could</em> restrict the set of accepted types, and exclude functions.  But if you make it only accept INTEGER! and BLOCK! that undermines the aspect that the function's job is to do testing.</p>
<p>Doing it "right" is annoying, putting colons on every access...possibly omitting some when the value is in a context where the program logic would say it can't be a function at that point.</p>
<pre><code>twosie?: func [x] [
    to-logic any [
        :x = 2
        all [
            block? :x
            2 = length? :x       ; :x is optional, as known to be a BLOCK! here
        ]
    ]
]
</code></pre>
<p>Sometimes, people would minimize the number of GET-WORD!s needed by short-circuiting a test for FUNCTION! first:</p>
<pre><code>twosie?: func [x] [
    if function? :x [return false]
    to-logic any [
        x = 2
        all [
            block? x
            2 = length? x
        ]
    ]
]
</code></pre>
<p>This is fairly unsatisfying as well.  It breaks easily if someone reorganizes the code and doesn't realize the test has to come first, or if there has to be additional handling and skipping all the code that uses the variable isn't the desired semantic.</p>
<p><strong>This situation is a tax on users, who are continuously torn between writing obvious code that is broken... vs. cluttered code that winds up being made more brittle due to the maintenance of the clutter.</strong></p>
<p>It would clearly be ideal if the obvious code was also correct.</p>
<h2>The Nuanced Compromise Of Isotopic ACTION!s</h2>
<p>Something that occurred to me was to ask what would happen if there were two kinds of actions:</p>
<ul>
<li>
<p>ACTION! isotopes, which would run if they were referenced via a WORD! or TUPLE!</p>
</li>
<li>
<p>Plain ACTION!s, which would be inert when accessed by WORD!</p>
</li>
</ul>
<p><strong>An obvious <em>good</em> part of this idea would be that a "normal" argument to a function would never be able to be an isotope (solving the problems outlined above).</strong></p>
<p><strong>An obvious <em>questionable</em> part of this idea is introducing another state to worry about.</strong></p>
<p>I've implemented it--though it is a radical change affecting kind of everything.  :-/  There are certainly a lot of questions raised and details to come up.</p>
<p>Something to realize is that there's a fundamental complexity coming from the fact that Rebol wants WORD! references to execute actions automatically much of the time.  But you still have a lot of places that want to talk about values "as-is".  We cannot "wish away" that complexity...only reshape it.</p>
<p><strong>But I think the ability to have obviously-written code in cases like TWOSIE? tips the balance.</strong>  I don't know that meta-code gets truly any harder to write, it just gets <em>different</em>...while the simple examples work without GET-WORD!s.</p>
<p>I'll use this thread to document differences to know about.</p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/attack-of-the-activated-actions/1900">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/attack-of-the-activated-actions/1900</link>
          <pubDate>Wed, 27 Jul 2022 05:01:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1900</guid>
          <source url="https://forum.rebol.info/t/attack-of-the-activated-actions/1900.rss">Attack of the Activated Actions</source>
        </item>
        <item>
          <title>FIND and SELECT polymorphism</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>In Rebol2, you can run FIND on OBJECT! as well as on BLOCK!:</p>
<pre><code>rebol2&gt;&gt; obj: make object! [a: 10 b: 20]

rebol2&gt;&gt; find obj 'a
== true

rebol2&gt;&gt; find obj 'asdf
== false
</code></pre>
<p>I'll point out that <a href="https://github.com/red/red/commit/7b1eeb76a6eb2c5c31e8407637fea5664ace61c2">Red does not support FIND on OBJECT!, and that was intentional</a>.   There's <a href="https://gitter.im/red/red?at=5f134373564e6b39f5655c0f">no real explanation</a> other than than something approximating <em>"objects and bitsets don't support a lot of series operations because they don't necessarily make sense"</em>.</p>
<p>But Red allows FIND on maps, for some reason?</p>
<pre><code>red&gt;&gt; m: make map! [a 10]
== #(
    a: 10
)

red&gt;&gt; find m 'a
== a
</code></pre>
<h3>Is This A Polymorphism You Can Even Use?</h3>
<p>There's no real clarity in OBJECT!/BLOCK! duality.  <a href="https://forum.rebol.info/t/block-and-object-parity-in-pathing-picking/1086">I've tried to invent some out of the murk, but come up short.</a></p>
<p>We might ask ourselves:</p>
<p><strong>Has there ever been a situation where you've had something--you didn't know what it was, either an OBJECT! or a BLOCK!--and your generic code can meaningfully use a FIND call on that thing?</strong></p>
<p>I can't imagine the answer to that is yes.  <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=9" title=":roll_eyes:" class="emoji" alt=":roll_eyes:"></p>
<p>BUT... what about something you didn't know if it was an OBJECT! or a MAP! ?</p>
<p>You can pass a WORD! to IN for an OBJECT!, and get either a bound word back in that object or NULL.  But you can't use IN on a MAP.</p>
<p>So the only polymorphic operators you can use to determine if something is in either an OBJECT! or a MAP! these days are FIND and SELECT.  Ren-C has the advantage that SELECT returns NULL if-and-only-if something isn't in a map or object, so even if you don't need the selected item you can use it.</p>
<h3>
<em>Some</em> Line Of Argumentation Might Support Rebol2's Behavior</h3>
<p>To truly generalize FIND, you could consider it to be with respect to an iterator... e.g. <a href="https://en.cppreference.com/w/cpp/algorithm/find">how C++'s find works</a>.</p>
<p>We might then look to FOR-EACH to see what it would give you if you asked it for a generic "something".  R3-Alpha supports this (not Rebol2 or Red):</p>
<pre><code>r3-alpha&gt;&gt; obj: make object! [a: 10 b: 20]

r3-alpha&gt;&gt; foreach something obj [print mold something]
a
b
</code></pre>
<p>So maybe if all of that was built on some common infrastructure, you could build a rationale for why searching keys-only made sense for FIND in an object.</p>
<p><em>But it's not built on any common infrastructure, so it's just extra random code.</em></p>
<h3>Moreover, what About BITSET! ?</h3>
<p>Above I made a potential case for seeing FIND as applying to the keys of an object.  But... BITSET!?</p>
<p>If you say <strong>bs: make bitset! 8</strong> and then <strong>bs.4: true</strong>, you're making something kind of like a block:</p>
<pre><code>[0 0 0 1 0 0 0 0]
</code></pre>
<p>So semantically, why would <strong>find bs 4</strong> be true?  Where's the 4?</p>
<p>I think what this really is more like is a positional PICK <em>(which makes sense because <strong>bs.4: true</strong> is running the code <strong>poke bs 4 true</strong>, and <strong>bs.4</strong> acts as <strong>pick bs 4</strong>)</em></p>
<p>But..it may be a potentially interesting polymorphism to think of a bitset as a mapping from integers to LOGIC!.  You might swap in something that is using a BITSET! to use a MAP!.  So SELECT with integer <em>could</em> be coherent here.</p>
<p>I think PICK is the best choice, though.</p>
<h3>Anyway...I'm removing FIND on Maps/Objects/Bitsets for Now...</h3>
<p>For the moment, I think that <strong>did select</strong> or <strong>didn't select</strong> are the best invariant ways of detecting if things are in objects or maps.   (Or use with ELSE/THEN)</p>
<p>This leaves FIND as something that might be more dialected, with options that let you search the values and not just the keys (maybe search deeply?)</p>
<p>Also it saves us from returning the kind of hokey idea of "true or null".  I'm suspicious of most functions that are in situations where they only return true or null, anyway.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/find-and-select-polymorphism/1879">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/find-and-select-polymorphism/1879</link>
          <pubDate>Thu, 14 Jul 2022 02:21:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1879</guid>
          <source url="https://forum.rebol.info/t/find-and-select-polymorphism/1879.rss">FIND and SELECT polymorphism</source>
        </item>
        <item>
          <title>Should Void be Offered to Predicates (for REDUCE, ANY/ALL, etc.)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>There's an option to pass a function to some things, to help avoid needing to write the basic logic of the function over again if you just want some difference.  So if you want a negating version of ANY you can say:</p>
<pre><code>&gt;&gt; any/predicate [1 + 2 null 3 + 4] :not
== ~null~  ; isotope (decays to null)
</code></pre>
<p>There you have a negated form of ANY.  You could specialize that:</p>
<pre><code>&gt;&gt; any-not: specialize :any [predicate: :not]
== #[action! {any-not} [block]]

&gt;&gt; any-not [1 + 2 null 3 + 4] then [print "Look, it worked!"]
Look, it worked!
</code></pre>
<p>It works with THEN and ELSE thanks to isotopes: a negating form of ANY that returns you an indicator of what the false thing was, while still being able to let you run a THEN or ELSE clause that has the expected semantics.  So even though the thing that triggered the short circuit was a NULL, the isotope form was returned and allowed to run the THEN.</p>
<p><strong>But what if there's a void entry, should your predicate function find out about it?</strong></p>
<pre><code>&gt;&gt; reduce/predicate [1 + 2 3 + 4] func [x] [return x * 10]
== [30 70]

&gt;&gt; reduce [1 + 2 if false [&lt;a&gt;] 3 + 4]
== [3 7]

&gt;&gt; reduce/predicate [1 + 2 if false [&lt;a&gt;] 3 + 4] func [x] [return x * 10]
; ...???...
</code></pre>
<p><strong>Given that the whole point of predicates is to reuse the work of the core function, it would seem like one of those pieces of work is filtering out the void expressions.</strong></p>
<p>So I think it's pretty clear the above should be <strong><code>== [30 70]</code></strong> with no error given.</p>
<p>But what if the function's argument was ^META?  Does that change things?</p>
<pre><code>&gt;&gt; reduce/predicate [1 + 2 if false [&lt;a&gt;] 3 + 4] func [^x] [...]
; ...???...
</code></pre>
<p>Or does it have to explicitly say by contract it is interested in voids?</p>
<pre><code>&gt;&gt; reduce/predicate [1 + 2 if false [&lt;a&gt;] 3 + 4] func [^x [&lt;void&gt; any-value!]] [...]
; ...???...
</code></pre>
<p>It's a pretty fringe feature either way.  I think that in REDUCE's case, we can say that if you really want to get control of every expression...then using REDUCE-EACH with ^META seems a bit more explicit that you want EACH.</p>
<p>I'm going to say for the moment that the predicate in REDUCE, ANY, and ALL will never be offered voids...and that's just part of the benefit of reusing the work.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-void-be-offered-to-predicates-for-reduce-any-all-etc/1872">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-void-be-offered-to-predicates-for-reduce-any-all-etc/1872</link>
          <pubDate>Sun, 10 Jul 2022 17:16:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1872</guid>
          <source url="https://forum.rebol.info/t/should-void-be-offered-to-predicates-for-reduce-any-all-etc/1872.rss">Should Void be Offered to Predicates (for REDUCE, ANY/ALL, etc.)</source>
        </item>
        <item>
          <title>Pushing the Potential of Polyglot Polymorphic DO</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p><strong>The brevity of DO is a strength that makes it seem natural to be polymorphic.</strong></p>
<p>I thought it was very wasteful that when Rebol2 and Red's DO saw something it didn't recognize, it would just drop out:</p>
<pre><code>rebol2&gt;&gt; do 1020
== 1020

rebol2&gt;&gt; do &lt;useless&gt;
== &lt;useless&gt;
</code></pre>
<p>Pinning people's expections to this behavior--to where they write code that relies on it--is awful.</p>
<p>There are plenty of things we can imagine for this undiscovered space.  (Soon it's planned that the ReplPad will use shorthands like <strong>do 3</strong> to mean "run the code in editor tab <span class="hashtag">#3</span>")</p>
<h2>Could We (or Should We?) Take DO's Polymorphism Further?</h2>
<p>I'd been thinking that it might be able to "run" things that are not even Rebol.   This would mean that you could <strong>do %foo.js</strong> and run JavaScript, or <strong>do %bar.css</strong> and import CSS.</p>
<p><em>(But then again, JavaScript has modules vs. ordinary code... so maybe <strong>import %foo-module.js</strong> would also be an interesting polymoprhism to have as well?)</em></p>
<p>We are getting some experience with this and the ReplPad.  And what experience is telling us is that it's really ugly to have to use names like JS-DO and CSS-DO.  Plus it puts stress on coming up with and remembering the names (was it JS-DO or DO-JS?)</p>
<p>With FRAME!s we even have the option of building things that defer execution.  Some simple pseudocode using current JS-DO to give the idea.</p>
<pre><code>load: enclose :lib.load func [frame]
    uparse try match [url! file!] frame.source then [
        let result: make frame! :js-do
        result.source: frame.source
        return result
   ]
   do frame
]

&gt;&gt; thing: load https://example.com/helloworld.js  ; doesn't run JS yet

&gt;&gt; do thing  ; would run it here
</code></pre>
<p>In today's Ren-C, the sky is the limit for many such things.</p>
<h2>I Think DO of a TEXT! String Should Be Dropped (Reclaimed)</h2>
<p>When you DO a BLOCK!, you know that block has been incarnated through some series of steps that bound it and brought it to life.</p>
<p>When you DO a TEXT! string, you have nothing to go on but the string itself.  It represents an incomplete thought, and it's hard to think of a "good" answer for what the semantics of that should be.</p>
<p>One tricky issue we've talked about is how module headers in text strings are handled:</p>
<pre><code>do "Rebol [Type: module] export thing: {This does not work}"
</code></pre>
<p>Historically what happens is that Rebol is a synonym for the SYSTEM object, so that evaluates an inert OBJECT! as a first step.  Then it evaluates the inert block [Type: module].  You don't have any of the LOADer mechanics in there.</p>
<p>So basically, the above is <em>completely</em> broken.</p>
<p>We're facing another problem of being short on strings to say where code should come from.  It's important to have a way to distinguish running paths relative to <code>system.script.path</code> as opposed to WHAT-DIR, and strings seem a reasonable way to encode that intent:</p>
<pre><code>do %../path/relative/to/what-dir
do "../path/relative/to/system.script.path"

import %../path/relative/to/what-dir
import "../path/relative/to/system.script.path"
</code></pre>
<p>When you add all this in with the spirit of language agnosticism, that makes interpreting TEXT! as being specifically Rebol language text is presumptuous.</p>
<p>This all makes going through <strong>do load</strong> to use text as source seem like a much more attractive option than trying to figure out how to push all of LOAD's options onto DO.</p>
<pre><code>&gt;&gt; do "print {Hello World}"
Hello World

&gt;&gt; do load "print {Is DO LOAD that much worse for Hello World?}"
Is DO LOAD that much worse for Hello World?
</code></pre>
<p><em>Of course, I will make the usual point that you will be able to overload this if you wish.</em>   Redbol will still DO strings, and you can decide you're never going to use the script-relative path importing (or do it another way).</p>
<p>But I think DO LOAD is a small price to pay for solving a bunch of irritating problems.</p>
<h2>I Think We Should Drop the /NEXT Option From DO</h2>
<p>Clearly a DO/NEXT of a JavaScript file doesn't make sense.  But does it make sense for a Rebol file, really?</p>
<p>Rebol2 returns a BLOCK! with a pair of the result and remaining code, which works for blocks:</p>
<pre><code>rebol2&gt;&gt; foo: [print "Some" print "Block"]

rebol2&gt;&gt; do/next foo
Some
== [unset [print "Block"]]
</code></pre>
<p>But for functions, it just ignores the /NEXT:</p>
<pre><code>rebol2&gt;&gt; foo: func [] [print "Some" print "Function"]

rebol2&gt;&gt; do/next :foo
Some
Function
</code></pre>
<p>Red gives nonsense, as usual...it returns the value of the function back and doesn't DO it at all</p>
<pre><code>red&gt;&gt; foo: func [] [print "The usual" print "nonsense"]

red&gt;&gt; foo
The usual
nonsense

red&gt;&gt; do/next :foo 'pos
== func [][print "The usual" print "nonsense"]

red&gt;&gt; pos
*** Script Error: pos has no value
</code></pre>
<p><strong>So I'm proposing the /NEXT functionality be solely in EVAL, and have EVAL run only on ANY-ARRAY!</strong></p>
<p>If you DO, that means fire-and-forget.</p>
<h2>Narrowing DO Use Is Good For Security / Avoiding Big Mistakes</h2>
<p>DO is pretty powerful.  When you say DO VALUE that could be a URL!...fetching arbitrary code off the internet and running it.</p>
<p>Of course, DO of a BLOCK! can contain code that does arbitrary things.  But if you're writing code that's supposed to all run on your machine and be self contained, it would be nice if you could be reasonably sure that you aren't running code off the internet if you didn't use DO or IMPORT.</p>
<p>So making it possible to get normal casual work done locally without ever needing to call DO seems desirable.  That is why EVAL has both "do to end" and "do step" semantics:</p>
<pre><code> &gt;&gt; eval [1 + 1 print "Modes"]
 Modes

 &gt;&gt; [value pos]: eval [1 + 1 print "Modes"]
 == 2

&gt;&gt; pos
== [print "Modes"]
</code></pre>
<p>So you can use EVAL where you would have used DO of a BLOCK!, and you can use the /NEXT mode as a multi-return (or a refinement, if you choose)</p>
<pre><code>&gt;&gt; eval/next [1 + 1 print "Modes"] 'pos
== 2

&gt;&gt; pos
== [print "Modes"]
</code></pre>
<p><strong>This raises into question if DO of a BLOCK! needs to be a way to run code at all.</strong>  It could be dialected, and let you supply arguments:</p>
<pre><code>do [%script-taking-args.reb 1 2 3]</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/pushing-the-potential-of-polyglot-polymorphic-do/1846">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/pushing-the-potential-of-polyglot-polymorphic-do/1846</link>
          <pubDate>Mon, 20 Jun 2022 10:29:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1846</guid>
          <source url="https://forum.rebol.info/t/pushing-the-potential-of-polyglot-polymorphic-do/1846.rss">Pushing the Potential of Polyglot Polymorphic DO</source>
        </item>
        <item>
          <title>Handling MATCH and &quot;Falsey&quot; Types</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>MATCH has a fundamental safety issue:</p>
<pre><code>&gt;&gt; match [&lt;opt&gt; integer!] 3
== 3

&gt;&gt; match [&lt;opt&gt; integer!] "notaninteger"
; null

&gt;&gt; match [&lt;opt&gt; integer!] null
== ???
</code></pre>
<p>This returns "heavy null".  Once upon a time, heavy null was not auto-decayed when passed to functions like IF:</p>
<pre><code>&gt;&gt; if (match [&lt;opt&gt; integer!] null) [print "Yes it matched!"]
** Error: IF does not accept heavy null without a ^META condition
</code></pre>
<p>But it came to be that for general ergonomics, heavy nulls had to decay to plain nulls when passed to normal parameters.  Otherwise, they would be too invasive.</p>
<p>So for now, a "passing null" is conflated with a "didn't pass" signal.  It will work with THEN, but be incorrect with IF.</p>
<h1>
<a name="so-what-to-do-about-match-and-its-bretheren-1" class="anchor" href="https://forum.rebol.info#so-what-to-do-about-match-and-its-bretheren-1"></a>So What To Do About MATCH and its bretheren?</h1>
<p>Seems the alternative options are:</p>
<ol>
<li>
<p><em>Don't worry about it.</em>  If you write <strong>match [logic!] 1 = 2</strong> you get back a <strong>~false~</strong> isotope and should you write an expression like <strong>if (match [logic!] 1 = 2) [print "Match!]</strong> you get what you deserve.</p>
</li>
<li>
<p><em>Use a different isotope.</em>  Let's say that <strong><code>match [&lt;opt&gt;] null</code></strong> is simply <strong>~matched~ (isotope)</strong>.  It wouldn't have the decaying property, but would have the invalidness property of not being logic testable</p>
</li>
<li>
<p><em>Have a MATCH/FALSEY variant.</em>  Let plain <strong>match</strong> on a falsey thing trigger an error and if you write <strong>if match/falsey ...</strong> then you clearly do know what you're doing so it becomes like case (1).</p>
</li>
<li>
<p><em>Make all conditional arguments take ^META arguments for their conditions.</em>  This would put the responsibility for checking for isotopes on them, and they'd uniquely disallow them before UNMETA'ing them and then testing for truth/falsehood.</p>
</li>
</ol>
<p>Option (4) is too taxing...impacting not just the interface to IF but the implementation of CASE and any conditional construct.</p>
<p>(3) punts the ball down the road a bit, but might not suit Chris.</p>
<h2>
<a name="option-5-adjust-did-as-isotope-tolerant-not-null-httpsforumrebolinfotdropping-find-while-if-unless-select-etc4982uhostilefork-2" class="anchor" href="https://forum.rebol.info#option-5-adjust-did-as-isotope-tolerant-not-null-httpsforumrebolinfotdropping-find-while-if-unless-select-etc4982uhostilefork-2"></a>Option 5. <a href="https://forum.rebol.info/t/dropping-find-while-if-unless-select-etc/498/2">Adjust <code>(DID ...)</code> as isotope-tolerant <code>(NOT NULL? ...)</code></a>
</h2>
<p>Another answer...</p>
<p>If you find yourself in a situation where isotopes are giving you a problem, switch to <strong>did match</strong> (or decay match, if you're trying to get the value and not test it as a condition)</p>
<p><em>I wouldn't reach for this by default.</em>  You're fine most of the time... if your MATCH doesn't contain <code>[&lt;opt&gt; logic! blank!]</code>.  It's only these quirky edge cases where it's better to let the isotopes give you a localized and clear error than wind up on a wild goose chase for why the program is acting strangely.</p>
<p>Beginners might be cautious and write things like <strong>did match</strong> or <strong>did parse</strong> all over the place, if they're scared of missing a case.  But there's no need to write <strong>if did match integer! value</strong>, because you're testing for a value that can't possibly be false...it's an integer! or null.  Experts would use it sparingly, in cases like <strong>if match typeset value</strong>, in case the typeset gets expanded into things including falsey values, when you're not fully cognizant of that happening.</p>
<p>This broadens the service of DID across the board, to do what it was originally intended to do: transform functions that return non-LOGIC! values and NULL as soft failure to give logic results.  It can handle historical edge cases with an elegant touch, without burdening code that knows itself well enough to not hit those cases.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/handling-match-and-falsey-types/2080">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/handling-match-and-falsey-types/2080</link>
          <pubDate>Sun, 15 May 2022 08:44:26 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2080</guid>
          <source url="https://forum.rebol.info/t/handling-match-and-falsey-types/2080.rss">Handling MATCH and &quot;Falsey&quot; Types</source>
        </item>
        <item>
          <title>About the Semantics category</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>While the "Internals" discusses the bits and bytes of how things are implemented, this category is for discussing things design questions of the language... like what <strong>do []</strong> should return.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/about-the-semantics-category/1789">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/about-the-semantics-category/1789</link>
          <pubDate>Wed, 16 Feb 2022 03:48:39 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1789</guid>
          <source url="https://forum.rebol.info/t/about-the-semantics-category/1789.rss">About the Semantics category</source>
        </item>
        <item>
          <title>&quot;Destructuring&quot; in FOR-EACH</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p><a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a> wrote some code that made a list of drugs and filenames related to those drugs:</p>
<pre><code> drugs: [
     ["Benzbromarone" "SA1537.pdf"]
     ["Teriparatide" "SA1139.pdf"]
     ["Adalimumab" "SA1847.pdf"]
     ["Etanercept" "SA1812.pdf"]
 ]
</code></pre>
<p>This is inconvenient to enumerate.  It won't work if you say:</p>
<pre><code>for-each [drugname filename] [...]
</code></pre>
<p>Because what you get then is two successive blocks... e.g. drugname winds up being <strong>["Benzbromarone" "SA1537.pdf"]</strong> and then filename is <strong>["Teriparatide" "SA1139.pdf"]</strong>.</p>
<p>If this were to work, it would have to offer something like:</p>
<pre><code>for-each [[drugname filename]] [...]
</code></pre>
<p>That could communicate that the information you were looking for was actually in a nested block level.</p>
<p>Though we don't want to get too literal with the dialect.  If you have:</p>
<pre><code> drugs: [
     ("Benzbromarone" "SA1537.pdf")
     ("Teriparatide" "SA1139.pdf")
     ("Adalimumab" "SA1847.pdf")
     ("Etanercept" "SA1812.pdf")
 ]
</code></pre>
<p>...we don't want to make the meaning of GROUP!s in FOR-EACH have to be related to this structure, because we use groups to say that the variable's name is calculated.  :-/</p>
<p>Similarly, we might imagine more interesting meanings for blocks in FOR-EACH than to point out a nested block level.  Maybe this would be done with quoted blocks and quoted groups?</p>
<pre><code>for-each ['(drugname filename)] [...]
</code></pre>
<p>It gets a bit hairy because you're starting to tread into parsing territory.  Hard to know where to stop.</p>
<p>Since I'm not sure I just switched Graham's case to use a flat block.</p>
<pre><code> drugs: [
     "Benzbromarone" "SA1537.pdf"
     "Teriparatide" "SA1139.pdf"
     "Adalimumab" "SA1847.pdf"
     "Etanercept" "SA1812.pdf"
 ]
</code></pre>
<p>But it should be thought about more.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/destructuring-in-for-each/1738">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/destructuring-in-for-each/1738</link>
          <pubDate>Mon, 04 Oct 2021 20:08:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1738</guid>
          <source url="https://forum.rebol.info/t/destructuring-in-for-each/1738.rss">&quot;Destructuring&quot; in FOR-EACH</source>
        </item>
        <item>
          <title>GET+SET vs PICK+POKE - What&#39;s The Difference?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Historically, GET could not get a path:</p>
<pre><code>rebol2&gt;&gt; obj: make object! [x: 10]

rebol2&gt;&gt; get 'obj/x
** Script Error: get expected word argument of type: any-word object none
</code></pre>
<p>That changed in R3-Alpha.  Red followed suit:</p>
<pre><code>r3-alpha/red&gt;&gt; get 'obj/x
== 10
</code></pre>
<p>Which seems like an improvement...but opened the door to something I've complained about: GET having side-effects, such as:</p>
<pre><code>red&gt;&gt; path: 'obj/(print "Boo!" 'x)
== obj/(print "Boo!" 'x)

red&gt;&gt; get path
Boo!
== 10
</code></pre>
<p>When you say that two sequential GETs can get something completely different even when nothing has changed, that really pulls the rug out from under any generic code that wants to build upon what a GET is.  Similar issues apply to SET.</p>
<h2>How Do Pick and Poke Compare?</h2>
<p>PICK and POKE add an extra parameter of a location to pick or poke from.  But then they still have a "picker" of some kind.</p>
<p>This leads one to wonder if this would work, but it doesn't:</p>
<pre><code>r3-alpha&gt;&gt; outer: make object! [inner: make object! [x: 10]]

r3-alpha&gt;&gt; pick outer 'inner/x
** Script error: pick does not allow object! for its aggregate argument
</code></pre>
<p>But there are two possible interpretations.  If OUTER is something like a MAP, it could be looking up the PATH! <strong>inner/x</strong> as the key in the map.  Or it could be looking up the key <strong>inner</strong>, fetching the thing in the map, and then picking <strong>x</strong> out of that.</p>
<p>MAP!s don't allow PATH! in R3-Alpha or Red, but if they did...we'd assume it would interpret <strong>inner/x</strong> as the key.</p>
<h2>So Historical PICK and POKE are Strictly Less Powerful?</h2>
<p>This makes it seem like GET and SET have the ability to do anything that a PATH! or SET-PATH! can do.  But PICK and POKE can only go the last mile and ask one container about its response to one key.</p>
<p>Could we make a synonym for PICK, if we just GET a PATH! that we make up?  Let's try that in Red:</p>
<pre><code>red&gt;&gt; pick2: func [series index] [
          get make path! reduce ['series to paren! reduce ['quote index]]
      ]

red&gt;&gt; m: make map! [a 10 b 20]

red&gt;&gt; pick2 m 'a
== 10

red&gt;&gt; b: [x 30 y 40]

red&gt;&gt; pick2 b 'y
== 40
</code></pre>
<p><strong>It appears to work, but the issue is that I'm sure these are completely different code paths.</strong>  So you'll see subtly different behaviors for PICK vs. pathing where they'll be the same <em>most</em> of the time, but then not.</p>
<p>It would only make sense to have two codebases if someone could articulate what's different about "picking" and "pathing".  Outside of function call dispatch with refinements I can't think of a good argument for a difference.  And Ren-C uses TUPLE! instead of PATH! for conventional picks, so the tuple-based picking could truly be the same.</p>
<h2>Not Easy To Reason About</h2>
<p>This is all made-up stuff with really imaginary semantics.  And I've come up against the hard questions like trying to make this work:</p>
<pre><code> item.(expression): default [...]
</code></pre>
<p>If you GET that SET-PATH! on the left to check to see if there's a value in it or not, and there isn't, then you decide to run the right hand side.  Then you want to SET the SET-PATH! on the left...but without some alternate mechanism, you'll be evaluating the expression twice.</p>
<p>Being able to turn that <code>item.(expression)</code> into some sort of reusable currency that you can GET and SET multiple times without side effects is ideal.  Once this was done by COMPOSE'ing that PATH!, but paths are now more restrictive in what they can have as members...so it would have to be turned into a block.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/get-set-vs-pick-poke-whats-the-difference/1719">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/get-set-vs-pick-poke-whats-the-difference/1719</link>
          <pubDate>Thu, 16 Sep 2021 18:51:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1719</guid>
          <source url="https://forum.rebol.info/t/get-set-vs-pick-poke-whats-the-difference/1719.rss">GET+SET vs PICK+POKE - What&#39;s The Difference?</source>
        </item>
        <item>
          <title>COLLECT Mutation Semantics: KEEP vs. KEEP/ONLY</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>When reimplementing COLLECT for UPARSE on top of the "pending" model, <a href="https://forum.rebol.info/t/getting-hooks-into-events-during-parse/1640/10">I mentioned a potential avenue for optimization</a> by not immediately splicing blocks, but keeping them in a list and then merging the whole list together if-and-when the COLLECT got to the success point:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="10" data-topic="1640">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/getting-hooks-into-events-during-parse/1640/10">Getting Hooks Into "Events" during PARSE</a>
</div>
<blockquote>
<p>(Efficiency sidenote: I might should have used something like @[...] blocks for GATHER, and use BLOCK!s for KEEP to complement the QUOTED!s. This would save splicing until the very end COLLECT when you have a better idea of how big the total series will be.)</p>
</blockquote>
</aside>
<p>The idea of saving splicing until the end might sound good, but... it doesn't work if we presume mutations.</p>
<p>Just imagine a delaying implementation of ordinary COLLECT:</p>
<pre><code>&gt;&gt; delayed-splice-collect [
      block: [a b c]
      keep block
      clear block
      insert block [d e f]
      keep block
  ]
== [d e f d e f]
</code></pre>
<p>That's not what we expect from today's COLLECT.</p>
<p>Though if you're <em>not</em> splicing, you expect mutations to affect what you've already collected.  It's true in all Redbols today, since you're keeping the block by identity:</p>
<pre><code>red&gt;&gt; collect [
         block: [a b c]
         keep/only block
         clear block
         insert block [d e f]
         keep/only block
      ]
== [[d e f] [d e f]]
</code></pre>
<h2>
<a href="https://hypirion.com/musings/understanding-persistent-vector-pt-1">Persistent Vector</a> Looks Awfully Tempting  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_monocle.png?v=9" title=":face_with_monocle:" class="emoji" alt=":face_with_monocle:">
</h2>
<p>Looking at things like this is always a throwback to saying <em>"mutable state by default is garbage"</em>.  But it depends on what example you're looking at.  Sometimes it's good, sometimes it's bad.</p>
<p>I guess the thing is to just explore what the good parts are.  Maybe someone will blend in some Clojure bits at some point in a derivative...but that person is not going to be me!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/collect-mutation-semantics-keep-vs-keep-only/1706">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/collect-mutation-semantics-keep-vs-keep-only/1706</link>
          <pubDate>Sun, 05 Sep 2021 11:56:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1706</guid>
          <source url="https://forum.rebol.info/t/collect-mutation-semantics-keep-vs-keep-only/1706.rss">COLLECT Mutation Semantics: KEEP vs. KEEP/ONLY</source>
        </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Semantics - AltRebol</title>
    <link>https://forum.rebol.info/c/development/semantics/55</link>
    <description>Topics in the &#39;Semantics&#39; category While the &quot;Internals&quot; discusses the bits and bytes of how things are implemented, this category is for discussing things design questions of the language... like what &lt;strong&gt;do []&lt;/strong&gt; should return.</description>
    
      <lastBuildDate>Sat, 16 Nov 2024 18:33:28 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/semantics/55.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>The Semantics of JOIN</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p><strong>As <a class="mention" href="https://forum.rebol.info/u/brett">@Brett</a>'s critique of yesteryear pointed out, <a href="https://forum.rebol.info/t/rejoin-ugliness-and-the-usefulness-of-tests/248">REJOIN sucked</a>.</strong></p>
<p>If naming were consistent, you might think from this pattern:</p>
<pre><code>append a reduce b &lt;=&gt; repend a b
</code></pre>
<p>...that the following would have been true:</p>
<pre><code>join a reduce b &lt;=&gt; rejoin a b  ; one would have perhaps thought?
</code></pre>
<p>But no...REJOIN was single arity (and was a mess).</p>
<h2><a name="p-7907-so-rejoin-is-in-the-trash-heap-but-what-about-join-1" class="anchor" href="https://forum.rebol.info#p-7907-so-rejoin-is-in-the-trash-heap-but-what-about-join-1"></a>So REJOIN is in the trash heap, but what about JOIN?</h2>
<p>JOIN implicitly reduced, and was basically this:</p>
<pre><code>join a b &lt;=&gt; append copy a reduce b
</code></pre>
<p>But <strong>b</strong> didn't have to be a BLOCK!, so if it was not, it wasn't reduced and just left as-is.</p>
<pre><code>rebol2&gt;&gt; join "abc" [1 + 2 3 + 4]
== "abc37"  ; so the block was reduced

rebol2&gt;&gt; d: 10
rebol2&gt;&gt; join "abc" 'd
== "abcd"  ; not abc10, so the word was *not* reduced
</code></pre>
<p>Red did not carry forward this definition:</p>
<pre><code>&gt;&gt; join
*** Script Error: join has no value
</code></pre>
<h2><a name="p-7907-next-level-join-allow-join-datatype-2" class="anchor" href="https://forum.rebol.info#p-7907-next-level-join-allow-join-datatype-2"></a>Next-Level JOIN: Allow JOIN  DATATYPE</h2>
<p>At some point, it occurred to me that if you could use JOIN with a datatype, it could step in to fill in the desires of REJOIN more clearly:</p>
<pre><code>&gt;&gt; join binary! [1 + 2 #{DECAFBAD} 2 + 3]
== #{03DECAFBAD05}
</code></pre>
<p>There really had been expressions of this like:</p>
<pre><code>rebol2&gt;&gt; rejoin [#{} 1 + 2 #{DECAFBAD} 2 + 3]
== #{03DECAFBAD05}
</code></pre>
<p>But see Brett's critique, if the surface-level badness isn't enough to convince you!</p>
<p>I also wanted to support things that Rebol2 probably meant to, but did not.  This should give a WORD! back:</p>
<pre><code>rebol2&gt;&gt; join 'a 'b
== "ab"  ; should be word! `ab`
</code></pre>
<p>Plus, I thought it might be nice to have a non-reducing variant, done with <code>@[...]</code></p>
<pre><code>&gt;&gt; join word! @[a 1 + 2]
== a1+2
</code></pre>
<p>I've mentioned elsewhere that I think having <em>join-like</em> actions be done with JOIN is superior to being some form of MAKE, when there's nebulousness for what MAKE means.</p>
<h2><a name="p-7907-making-peace-with-uneasiness-about-list-ambiguity-3" class="anchor" href="https://forum.rebol.info#p-7907-making-peace-with-uneasiness-about-list-ambiguity-3"></a>Making Peace (?) With Uneasiness About List Ambiguity</h2>
<p>Ergonomically, it's nice for JOIN to be able to take either a BLOCK! or some other type.</p>
<p>One of the biggest uses of JOIN is with files:</p>
<pre><code>join directory %foo.txt
</code></pre>
<p>It would be annoying if you had to write:</p>
<pre><code>join directory [%foo.txt]
</code></pre>
<p>But then, you have the problem that if you're joining onto a BLOCK!, then a BLOCK! is a legitimate thing to join:</p>
<pre><code>&gt;&gt; join [a b] [1 + 2 10 + 20]
== [a b 3 30]  ; "traditional" behavior

&gt;&gt; join [a b] [1 + 2]
== [a b [1 + 2 10 + 20]]  ; ...but this could be valid
</code></pre>
<p>We could "fix" this by defining JOIN as a non-reducing construct, then have people use SPREAD and REDUCE:</p>
<pre><code>&gt;&gt; join [a b] spread reduce [1 + 2 10 + 20]
== [a b 3 30]

&gt;&gt; join [a b] [1 + 2 10 + 20]
== [a b [1 + 2 10 + 20]]

&gt;&gt; join [a b] reduce [1 + 2 10 + 20]
== [a b [3 30]]
</code></pre>
<p>But this doesn't exactly square with the JOIN of a DATATYPE! case, and the most common desires.</p>
<p>If anything, I'd rather make JOIN always take a <strong><code>[...]</code></strong> or <strong><code>@[...]</code></strong> in the second argument, and then create some other non-reducing construct that slaps two things together.</p>
<pre><code>&gt;&gt; block: [a b]

&gt;&gt; adjoin block [c d]
== [a b [c d]]

&gt;&gt; adjoin block spread [e f]
== [a b [c d] e f]

&gt;&gt; block
== [a b]  ; unmodified (difference from append)
</code></pre>
<p>But asking people to write <strong><code>(adjoin directory %foo.txt)</code></strong> is... ugly.</p>
<p>A compromise is to narrow it, so that you could only use it with single items when joining with non-lists...</p>
<pre><code>&gt;&gt; join "abc" "def"
== "abcdef"

&gt;&gt; join [a b c] "def"
** Error: JOIN with a list must use [...] or @[...]
</code></pre>
<p>This would help steer you away from writing code like <strong><code>join list value</code></strong> and think it works, to only find it falling down when value becomes a BLOCK!.</p>
<h2><a name="p-7907-is-reduce-just-join-block-4" class="anchor" href="https://forum.rebol.info#p-7907-is-reduce-just-join-block-4"></a>Is REDUCE just JOIN BLOCK! ?</h2>
<p>The implementation of JOIN that I'm working on seems like a more powerful REDUCE.</p>
<p>But questions start to arise about the binding... what should the binding be?</p>
<pre><code>&gt;&gt; join [add 1] ['multiply 2 3]
== [add 1 multiply 2 3]
</code></pre>
<p>In that case, I'm going to assume the produced block would have the binding of the [add 1] block.  Since multiply is <strong><code>'multiply</code></strong> and not <strong><code>$multiply</code></strong> it would be unbound and hence an evaluation would be driven by that first argument's binding.</p>
<p>But what if you just said:</p>
<pre><code>&gt;&gt; join block! ['add 1 'multiply 2 3]
== [add 1 multiply 2 3]
</code></pre>
<p>Before, the second block's binding was disregarded in the product.  But when there's no first block to get the binding from, does it assume the binding of the second block?  And how would you get an unbound block if you wanted it?</p>
<p>We could say that you get an unbound block, but if you want a bound block, you'd say:</p>
<pre><code>&gt;&gt; join $[] ['add 1 'multiply 2 3]
== [add 1 multiply 2 3]
</code></pre>
<p>Then we have similar questions for things like word!:</p>
<pre><code>&gt;&gt; join word! ["a" "b"]
== ab
</code></pre>
<p>I feel that pretty obviously should be unbound.  But words follow different rules:</p>
<pre><code>&gt;&gt; join $a ["b"]
== ab  ; can't necessarily be bound, just because a was...
</code></pre>
<p>That would suggest all words come back unbound from a joining process.</p>
<p>So no shortage of questions.  But in general, I think JOIN is on the right track, and splitting MAKE behaviors that are JOIN-like to it seems good.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-semantics-of-join/2333">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-semantics-of-join/2333</link>
          <pubDate>Sat, 16 Nov 2024 18:33:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2333</guid>
          <source url="https://forum.rebol.info/t/the-semantics-of-join/2333.rss">The Semantics of JOIN</source>
        </item>
        <item>
          <title>Embracing A &quot;Useless&quot; Definition of TO</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Many years ago, I thought about <strong><a href="https://forum.rebol.info/t/hacking-away-on-the-to-and-make-matrix/649">trying to untangle of the TO and MAKE matrix</a></strong>.  These operations are notoriously unpredictable in historical Redbol.</p>
<p>I tried putting some stakes in the ground about what I believed <em>had</em> to be true.  It was difficult because I could not think of too many.</p>
<p>One thing I said was that TO should always create a "new" value (if the value was not immediate).  And I felt like this should be true:</p>
<pre><code>to (type of value) value
; ...same as...
copy value
</code></pre>
<p>Grasping for any stake in the ground I could find, I was pretty sure that TO of a string representation of an integer to an integer should give you the integer:</p>
<pre><code>&gt;&gt; to integer! "1020"
== 1020  ; we know this, at least? (one hopes...)
</code></pre>
<p>And the reverse, one would think, as well:</p>
<pre><code>&gt;&gt; to text! 1020
== "1020"  ; what else *could* it be?  codepoint 1020? -&gt; "Ï¼"
</code></pre>
<p>But beyond that it was hard to think of the pattern.</p>
<h2><a name="p-7876-coming-back-to-an-old-idea-reversibility-1" class="anchor" href="https://forum.rebol.info#p-7876-coming-back-to-an-old-idea-reversibility-1"></a>Coming Back To An Old Idea: Reversibility</h2>
<p>When I first encountered Rebol and was made aware of these problems, I suggested TO should be reversible:</p>
<pre><code>value1 = to (type of value1) to type2 value1
</code></pre>
<p>However, this gave what <em>appeared</em> to be very "unexciting" options for behavior:</p>
<pre><code>&gt;&gt; to block! 1
== [1]

&gt;&gt; to integer! [1]
== 1

&gt;&gt; to integer! [...anything else in a block that's not integer...]
** Error.  Always.
</code></pre>
<p>That particular idea was was so long ago that I don't have direct quotes on hand of people saying "nah, that sucks, TO could barely do anything."  But I'm pretty sure it was panned by basically everyone I suggested it to.  I guess I agreed, because I dropped it.</p>
<p><strong>Coming back to it now, and seeing it in a new light, I see this as much more useful than I used to.</strong>  Especially when compared to the historical mess that makes TO nigh-unusable.</p>
<p>And in fact, it fits in with several Rebol2/Red behaviors that I'd thought were kind of pointless before:</p>
<pre><code>&gt;&gt; to integer! &lt;1&gt;
== 1

&gt;&gt; to tag! 1
== &lt;1&gt;
</code></pre>
<p>The use I didn't see at the time was the frequent need when dialecting to push values out of band, into some other type, without losing their meaning.  If you have a dialect in which integers already mean something, but you want a way of pushing some integer-oriented instruction in there...you can use these kinds of operations.</p>
<p>Definitional errors in Ren-C make this convenient, since checking if something fits the pattern is quick, you just throw in a TRY and the antiform error that's the return result of the TO will be suppressed, giving you a "falsey" null:</p>
<pre><code>&gt;&gt; thing: &lt;a b&gt;

&gt;&gt; to integer! thing
** Error: Cannot TO convert &lt;a b&gt; to integer

&gt;&gt; try to integer! thing
== ~null~  ; anti
</code></pre>
<p>The more I look at it the more useful it appears.  And it helps give clarity to the MAKE vs. TO division.  If you have something that isn't shaped like this, then <em>maybe</em> MAKE is the right place to put it.  For example:</p>
<pre><code>&gt;&gt; to percent! 1
== 1%

&gt;&gt; to integer! 1%
== 1

&gt;&gt; make percent! 1
== 100%
</code></pre>
<p><em>(Note: I think ENCODE + DECODE is a better place for binary conversions, e.g. ENCODE 'IEEE-754 is better than MAKE BINARY! of a decimal because that could mean many things, and ENCODE can have more parameterization for single vs. double precision, etc.  I don't know<br>
if TO BINARY! should work at all, but if it does, I'd probably agree with the Rebol2 choice to give the binary representation of the UTF-8 string... e.g. (to binary! 1020) as #{31303230} ... and use more explicit future-proof routines to encode with specified byte size and endianness.)</em></p>
<h2><a name="p-7876-reversibility-rules-out-rounding-2" class="anchor" href="https://forum.rebol.info#p-7876-reversibility-rules-out-rounding-2"></a>Reversibility Rules Out Rounding</h2>
<p>In order to get losslessness in the representation, you can't throw out information.</p>
<p>So this works:</p>
<pre><code>&gt;&gt; to integer! 1.0
== 1

&gt;&gt; to decimal! 1
== 1.0
</code></pre>
<p>But this does not:</p>
<pre><code> &gt;&gt; to integer! 1.5
 ** Error: Can't TO INTEGER! a DECIMAL! w/digits after decimal point
</code></pre>
<p>I don't think that's a problem, because that seems like a job for ROUND.  Unfortunately, R3-Alpha and Red do something dumb:</p>
<pre><code>rebol2&gt;&gt; round 1.5
== 2

red&gt;&gt; round 1.5
== 2.0

r3-alpha&gt;&gt; round 1.5
== 2.0
</code></pre>
<p>It seems this was part of a shift to try and preserve the input type, to facilitate things like rounding MONEY!:</p>
<pre><code>r3-alpha&gt;&gt; round $1.50
== $2
</code></pre>
<p>So I guess the way the thinking went was that if you want to keep MONEY! as MONEY! when you round it, all types should act that way.</p>
<p>I think the relationship between INTEGER! and DECIMAL!, which lack decoration, suggests something more intimate where the type can be lost.  If you don't want to lose it, ROUND:TO 1.0</p>
<pre><code>&gt;&gt; round 1.5
== 2

&gt;&gt; round:to 1.5 1
== 2

&gt;&gt; round:to 1.5 1.0
== 2.0
</code></pre>
<h2><a name="p-7876-blank-pretty-much-has-to-mean-empty-3" class="anchor" href="https://forum.rebol.info#p-7876-blank-pretty-much-has-to-mean-empty-3"></a>BLANK! Pretty Much Has To Mean Empty</h2>
<p>If we're talking about equivalencies, we now know this:</p>
<pre><code>&gt;&gt; for-each 'x _ [print "Doesn't run"]
== ~void~  ; anti

&gt;&gt; empty? _
== ~okay~  ; anti
</code></pre>
<p>And so really, it seems that the TO conversion of BLANK! has only one set of answers to fit into the family of reversibility:</p>
<pre><code>&gt;&gt; to block! _
== []

&gt;&gt; to text! _
== ""

&gt;&gt; to blank! &lt;&gt;
== _

&gt;&gt; to blank! #{}
== _
</code></pre>
<p>And if you try to TO BLANK! anything that's not conceptually empty, you'd get an error.</p>
<pre><code>&gt;&gt; to blank! &lt;a&gt;
** Error: ...
</code></pre>
<p>I don't know if there's a motivating case for saying <strong>to integer! _</strong> should pick something like 0 as an answer, though Rebol2 did something of that sort:</p>
<pre><code>rebol2&gt;&gt; to integer! none
== 0
</code></pre>
<p>Neither Red nor R3-Alpha carried that forward, <a href="https://github.com/metaeducation/rebol-issues/issues/1018">though it was discussed</a></p>
<h2><a name="p-7876-can-be-checked-in-the-implementation-4" class="anchor" href="https://forum.rebol.info#p-7876-can-be-checked-in-the-implementation-4"></a>Can Be Checked In The Implementation</h2>
<p>I've started hacking this through, and it's gone relatively well.  TO dispatches <em><strong>to the type it's converting from</strong></em>, with the type being converted to as the argument.</p>
<p>And it's nice in the sense that the TO native driving the process can also check the reversibility constraint in the debug build, to give it some teeth.</p>
<p><em>(I've rigged up some interesting frame mechanics to enable doing this reversal efficiently, that have sped up other parts of the system (like CASCADE) with "downlevel shifting", that can bypass a trampoline bounce...)</em></p>
<p>Anyway, things are a mess right now with a couple hundred broken tests to painfully sift through.  But I think the reversibility rule is good... biggest questions are whether that relaxes in terms of spacing...</p>
<pre><code>&gt;&gt; to block! "  1    2  "
== [1 2]  ; legal?
</code></pre>
<p>This would suggest you would have to compare with the trimmed/canonized version of your input.</p>
<p>Also, issues of string representations.</p>
<pre><code>&gt;&gt; b: to block! "--{1}--"
== ["1"]  ; legal?
</code></pre>
<p>So there are some pain points, but chipping away at them.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/embracing-a-useless-definition-of-to/2325">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/embracing-a-useless-definition-of-to/2325</link>
          <pubDate>Fri, 08 Nov 2024 17:57:07 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2325</guid>
          <source url="https://forum.rebol.info/t/embracing-a-useless-definition-of-to/2325.rss">Embracing A &quot;Useless&quot; Definition of TO</source>
        </item>
        <item>
          <title>Bitten By Right Side Evaluation First</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>I was writing some code like this:</p>
<pre><code>while [not tail? info] [
    if find leaders info.1.name [
        leader-protos.(info.1.name): take info
    ] else [
        info: next info
    ]
]
</code></pre>
<p>Due to the post title you probably already see the bug.  TAKE INFO on the right hand side runs <em>before</em> the <strong>info.1.name</strong>.  So it's inserting under the next name.</p>
<p>I think we can (and should) precalculate the groups on the left hand side.  Basically walk the tuple and push its elements to the stack before doing the right hand side evaluation.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/bitten-by-right-side-evaluation-first/2301">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/bitten-by-right-side-evaluation-first/2301</link>
          <pubDate>Sat, 28 Sep 2024 17:53:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2301</guid>
          <source url="https://forum.rebol.info/t/bitten-by-right-side-evaluation-first/2301.rss">Bitten By Right Side Evaluation First</source>
        </item>
        <item>
          <title>META:LITE - When You Don&#39;t Want Quasiforms</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>There was a time before quasiforms existed, but where there was generic quoting.</p>
<p>It was in this time that META was invented.  It did the only thing it could do:</p>
<ul>
<li>
<p>When you META'd a plain (or quoted) thing, it got one quote level added</p>
</li>
<li>
<p>When you META'd an "antiform" you would get a plain version of the thing</p>
</li>
</ul>
<p>So it worked like this:</p>
<pre><code>&gt;&gt; meta first [(d e f)]
== '(d e f)

&gt;&gt; meta first ['(d e f)]
== ''(d e f)

&gt;&gt; spread [a b c]
== (a b c)  ; "antiform"

&gt;&gt; meta spread [a b c]
== (a b c)
</code></pre>
<p><em>(That's not how it works now--for good reasons.  Not only is it a bit too easy to get confused about whether a meta protocol is in effect, the absence of quasiforms leaves a representational hole for values that produce antiforms under evaluation.  But I won't rewrite a <a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">A Justification Of Generalized Iostopes</a> here, this post has another purpose.)</em></p>
<h2>
<a name="another-historical-twist-meta-of-null-was-null-1" class="anchor" href="https://forum.rebol.info#another-historical-twist-meta-of-null-was-null-1"></a>Another Historical Twist: META of NULL was NULL</h2>
<p>NULL was an outlier--at various times having no quoted form (and at other times being considered a quote of nothingness, e.g. the lone apostrophe (<strong><code>'</code></strong>)).</p>
<p>I don't exactly remember what state NULL was in at the time META was being invented.  But regardless, it was initially decided that META and UNMETA of NULL could just give null back.</p>
<p>This actually turned out to frequently be useful...for instance <a href="https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833">when writing a loop wrapper like FOR-BOTH</a></p>
<pre><code>for-both: func [var blk1 blk2 body] [  ; the historical formulation
    return unmeta all [
        meta for-each var blk1 body  ; META NULL =&gt; NULL allows chaining BREAK
        meta for-each var blk2 body
    ]
]
</code></pre>
<p>Though while it was useful there, plenty of places needed to speak fully abstractly about all possible states.  So as the model shaped up, META of NULL fit into the regular pattern of all things having reified metaforms, giving <strong><code>~null~</code></strong>.</p>
<h2>
<a name="i-wanted-a-metalitehttpswwwyoutubecomwatchvimv0g-4cycw-2" class="anchor" href="https://forum.rebol.info#i-wanted-a-metalitehttpswwwyoutubecomwatchvimv0g-4cycw-2"></a><a href="https://www.youtube.com/watch?v=Imv0g-4cycw">I Wanted A META:LITE</a>
</h2>
<p>The idea of a META variation that passed through keywords as-is came along as <strong><code>meta:lite</code></strong>.</p>
<pre><code>&gt;&gt; meta:lite [a b c]
== '[a b c]

&gt;&gt; spread [a b c]
== ~(a b c)~  ; null

&gt;&gt; meta:lite spread [a b c]
== ~(a b c)~

&gt;&gt; meta:lite null
== ~null~  ; anti

&gt;&gt; meta:lite first [~null~ ~void~]
== '~null~
</code></pre>
<p>So today's META:LITE still produces quasiforms for antiforms--just not for the <code>~null~</code> and <code>~void~</code> antiforms (and I now imagine it should probably pass through <code>~okay~</code> and <code>~end~</code> and <code>~NaN~</code> as well):</p>
<pre><code>/for-both: func [var blk1 blk2 body] [
    return unmeta:lite all [
        meta:lite for-each var blk1 body  ; meta:lite null =&gt; ~null~ antiform
        meta:lite for-each var blk2 body  ; meta:lite void =&gt; ~void~ antiform
    ]
]
</code></pre>
<h2>
<a name="but-what-if-metalite-didnt-make-any-quasiforms-at-all-3" class="anchor" href="https://forum.rebol.info#but-what-if-metalite-didnt-make-any-quasiforms-at-all-3"></a>But What If META:LITE Didn't Make <em>Any</em> Quasiforms At All?</h2>
<p>By design, <a href="https://forum.rebol.info/t/quasiforms-arent-super-friendly-and-they-shouldnt-be/2273">quasiforms are not very friendly</a>.  So if you have an antiform in your hand... and you know you have an antiform in your hand... it's easy to take a step to a quasiform, but you need another step to get back to a plain form you can interact with.</p>
<p>So why not have META:LITE take care of it?</p>
<pre><code>&gt;&gt; meta:lite null
== ~null~  ; anti

&gt;&gt; meta:lite spread [a b c]
== (a b c)
</code></pre>
<p>This doesn't make a difference to things like FOR-BOTH.  They'll still work--plain forms are just as truthy as quasiforms for the meta states.  They just have to remember to use UNMETA:LITE on the reverse end.  <em>(If you use plain UNMETA it will catch your error, as UNMETA does not accept plain forms.)</em></p>
<p>It might seem random to pair up the feature of not making quasiforms with passing thru null and void.  But I actually think the kinds of places where you'd want one behavior do overlap significantly with the other.</p>
<p>And we're really just running out of terms, here.  Throwing another nuance in to say <em>"I want partial META, but only partial in the sense that I'm passing through null and void, not partial in terms of the other antiforms--make those quasiforms"</em> is just starting to go beyond the ability to give names to.</p>
<p>So in my head, having META:LITE be formulated as "do what META would do in a historical world where quasiforms and meta-nulls didn't exist" feels pretty good.</p>
<h2>
<a name="its-still-fundamentally-a-valid-meta-4" class="anchor" href="https://forum.rebol.info#its-still-fundamentally-a-valid-meta-4"></a>It's Still Fundamentally a "Valid META"</h2>
<p>I couldn't really think of a good name for the operation besides just saying it was an alternate behavior of META. "Lite" is a bit strange but I felt it fit.</p>
<p>Note that it doesn't make sense as a refinement to REIFY.  Because being willing to produce something that can't be put in a block fundamentally undermines what the word REIFY means.  (<strong><code>reify:...NOT!</code></strong>)</p>
<p>The thing about META:LITE is that it really is giving you a full-spectrum meta representation of what you had in your hand.  Every input state maps to a unique output state.  The default META happens to also be a fully reifying operation as well...but here we are saying that's not intrinsic to "a meta operation".</p>
<p><em>(Would there be any use for a META that passes through <em>all</em> antiforms--not just the antiform words--and just quotes everything else?  That's more a variation of QUOTE than it is a variation of META.  I can't offhand think of a case where that would ever be useful.)</em></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/meta-lite-when-you-dont-want-quasiforms/2296">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/meta-lite-when-you-dont-want-quasiforms/2296</link>
          <pubDate>Mon, 23 Sep 2024 13:42:44 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2296</guid>
          <source url="https://forum.rebol.info/t/meta-lite-when-you-dont-want-quasiforms/2296.rss">META:LITE - When You Don&#39;t Want Quasiforms</source>
        </item>
        <item>
          <title>The Meaning of the FORM String Operation</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>So FORM's vague job is to give a "human readable representation" of the data it's given.</p>
<p>So for TEXT!, it gives you a representation of the string without delimiters--in contrast to MOLD, which gives you the delimiters:</p>
<pre><code>&gt;&gt; form "hello world"
== "hello world"

&gt;&gt; mold "hello world"
== {"hello world"}
</code></pre>
<p>And you're probably thinking <em>"Uh...FORM of a text string is a no-op.  Why would you do that?"</em></p>
<p>The idea is that there are things other than text which do what the delimiters.  Such as TAG!</p>
<pre><code>&gt;&gt; form &lt;hello world&gt;
== "&lt;hello world&gt;"

&gt;&gt; mold &lt;hello world&gt;
== "&lt;hello world&gt;"
</code></pre>
<p>What if you don't want delimiters on your TAG!s and such?  Well... for any string-ish type, thanks to UTF-8 we have a <em>super efficient</em> operation called AS TEXT! which aliases any type as a string.  It reuses the memory:</p>
<pre><code>&gt;&gt; tag: &lt;hello world&gt;

&gt;&gt; text: as text! &lt;hello world&gt;
== "hello world"

&gt;&gt; append tag "ly Ren-C user"
== &lt;hello worldly Ren-C user&gt;

&gt;&gt; text
== "hello worldly Ren-C user"
</code></pre>
<p>You can use it on ANY-WORD! as well, and it will give you a read-only string... and not have the sigils:</p>
<pre><code>&gt;&gt; as text! '$var
== "var"
</code></pre>
<p>I have an inkling that over the subset of operations to which you can use both TO and AS, that you should get the same result... just a copy:</p>
<pre><code>&gt;&gt; tag: &lt;hello world&gt;

&gt;&gt; text: to text! &lt;hello world&gt;  ; TO TEXT!, not AS TEXT!
== "hello world"

&gt;&gt; append tag "ly Ren-C user"
== &lt;hello worldly Ren-C user&gt;

&gt;&gt; text
== "hello world"
</code></pre>
<h2>
<a name="so-form-adds-delimiters-and-toas-text-does-not-1" class="anchor" href="https://forum.rebol.info#so-form-adds-delimiters-and-toas-text-does-not-1"></a>So FORM adds delimiters, and TO+AS TEXT! Does Not...</h2>
<p>...BUT...let's go back:</p>
<pre><code>&gt;&gt; form "hello world"
== "hello world"

&gt;&gt; form &lt;hello world&gt;
== "&lt;hello world&gt;"
</code></pre>
<p>Why again is FORM a no-op on text, but adds delimiters to tags?</p>
<h2>
<a name="and-how-about-blocks-2" class="anchor" href="https://forum.rebol.info#and-how-about-blocks-2"></a>And How About Blocks?</h2>
<p>The block behavior of FORM historically strikes me as not terribly useful:</p>
<pre><code>rebol2/red&gt;&gt; form [I am [:a "block" that:] &lt;is&gt; (being formed)]
== "I am a block that &lt;is&gt; being formed"

r3-alpha&gt;&gt; form [I am [:a "block" that:] &lt;is&gt; (being formed)]
== "I am :a block that: &lt;is&gt; being formed"
</code></pre>
<p>How often do you want to take a bunch of material and throw away decorations from some of it, and flatten out all the lists with no processing but spaces?</p>
<p>I don't think I've ever used that.  I see more use in MOLD SPREAD, which it seems like R3-Alpha was edging toward and didn't quite get there.</p>
<pre><code>&gt;&gt; mold spread [I am [:a "block" that:] &lt;is&gt; (being "formed")]
== {(I am :a "block" that: &lt;is&gt; (being "formed"))}
</code></pre>
<h2>
<a name="who-is-calling-form-and-why-are-they-calling-it-3" class="anchor" href="https://forum.rebol.info#who-is-calling-form-and-why-are-they-calling-it-3"></a>Who is Calling FORM (and why are they calling it?)</h2>
<p>The variance in behaviors across R3-Alpha and Red show what is usually true when you see variation--<em>people don't know why the thing exists, find out it has random behavior, then avoid using it in favor of other things</em>.</p>
<p>Most uses seem to be turning WORD! to string, and turning TAG! to string with some assurance it will have the delimiters on it.  Nobody really uses it on blocks.</p>
<p>I don't yet have a complete answer for either getting rid of it, or defining it rigorously.  But I'm going to start paying more attention to it.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/the-meaning-of-the-form-string-operation/2288">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-meaning-of-the-form-string-operation/2288</link>
          <pubDate>Fri, 20 Sep 2024 09:16:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2288</guid>
          <source url="https://forum.rebol.info/t/the-meaning-of-the-form-string-operation/2288.rss">The Meaning of the FORM String Operation</source>
        </item>
        <item>
          <title>Make REPLACE/ALL Default Semantics of REPLACE?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Pretty much every time I use REPLACE, I mean REPLACE/ALL.  But I get bitten because I forget the /ALL.</p>
<pre><code>&gt;&gt; string: "I am pretty sure I feel like I usually want to REPLACE/ALL"

&gt;&gt; replace string "I" "You"
== "You am pretty sure I feel like I usually want to REPLACE/ALL"
</code></pre>
<p>Grammar aside, I don't feel like there's a natural boundedness on REPLACE.  It seems to me the exception is replacing just one thing, e.g. REPLACE/ONE.</p>
<p>Does anyone have a good argument for why REPLACE shouldn't replace all by default?</p>
<p>It would also be nice to know if any replacements were done.  A multi-return parameter which was the count of replacements--or null if no replacements made--would be very useful.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/make-replace-all-default-semantics-of-replace/2269">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/make-replace-all-default-semantics-of-replace/2269</link>
          <pubDate>Wed, 11 Sep 2024 13:33:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2269</guid>
          <source url="https://forum.rebol.info/t/make-replace-all-default-semantics-of-replace/2269.rss">Make REPLACE/ALL Default Semantics of REPLACE?</source>
        </item>
        <item>
          <title>The Truthiness of Nothing</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p><strong>Does it really add value to consider <strong><a href="https://forum.rebol.info/t/why-nothing-is-the-name-for-unset-state/2078">the nothing state</a></strong> (an antiform blank held by unset variables) to be neither truthy nor falsey?</strong></p>
<p>Here's a quick survey of how UNSET! (the most nothing-like thing in historical Rebol) is handled:</p>
<h3>
<a name="rebol2-1" class="anchor" href="https://forum.rebol.info#rebol2-1"></a>Rebol2</h3>
<pre><code>rebol2&gt;&gt; either get/any 'asdf [print "truthy"] [print "falsey"]
** Script Error: either is missing its condition argument

rebol2&gt;&gt; unset? all [get/any 'asdf]
== true

rebol2&gt;&gt; unset? any [get/any 'asdf]
== true

rebol2&gt;&gt; case [get/any 'asdf [print "truthy"]]
** Script Error: Block did not return a value
</code></pre>
<h3>
<a name="r3-alpha-2" class="anchor" href="https://forum.rebol.info#r3-alpha-2"></a>R3-Alpha</h3>
<pre><code>r3-alpha&gt;&gt; either get/any 'asdf [print "truthy"] [print "falsey"]
** Script error: either does not allow unset! for its condition argument

r3-alpha&gt;&gt; unset? all [get/any 'asdf]
== true

r3-alpha&gt;&gt; unset? any [get/any 'asdf]
== false  ; ...huh?

r3-alpha&gt;&gt; any [get/any 'asdf 1020]   
== 1020

r3-alpha&gt;&gt; case [get/any 'asdf [print "truthy"]]
** Script error: block did not return a value
</code></pre>
<h3>
<a name="red-3" class="anchor" href="https://forum.rebol.info#red-3"></a>Red</h3>
<pre><code>red&gt;&gt; if get/any 'asdf [print "truthy"]
truthy

red&gt;&gt; either get/any 'asdf [print "truthy"] [print "falsey"]
*** Script Error: block did not return a value  ; &lt;-- huh?

red&gt;&gt; unset? all [get/any 'asdf]
== true

red&gt;&gt; unset? any [get/any 'asdf]
== true

red&gt;&gt; case [get/any 'asdf [print "truthy"]]
*** Script Error: block did not return a value  ; &lt;-- huh, again?
</code></pre>
<h2>
<a name="oldes-rebol3-4" class="anchor" href="https://forum.rebol.info#oldes-rebol3-4"></a>Oldes Rebol3</h2>
<p>Transparent in <a href="https://github.com/Oldes/Rebol3/commit/2ba01ead3b5da1ab609fa25a0c675b30e96bb163">ANY and ALL</a> (like a Ren-C void), but presumably still an error in plain IF or EITHER or CASE...</p>
<h2>
<a name="ren-cs-always-error-has-been-more-consistent-but-5" class="anchor" href="https://forum.rebol.info#ren-cs-always-error-has-been-more-consistent-but-5"></a>Ren-C's "Always Error" Has Been More <em>Consistent</em>, But...</h2>
<p>Clearly people have been pushing away from it being an error.</p>
<p>So does being "ornery" for conditional logic really help matters?  When we consider the dual role of nothing as an "uninteresting, but successful" result, might we get as much (or more?) value from considering it to be always truthy?</p>
<p>For example: Ren-C uses NOTHING as the result of PRINT when the print actually produces output.  Otherwise, you get NULL.</p>
<pre><code>&gt;&gt; message: "Hello"
== "Hello"

&gt;&gt; print message  ; won't have a console "==" due to being a nothing result
Hello

&gt;&gt; nothing? print message
Hello
== ~true~  ; anti

&gt;&gt; message: null
== ~null~  ; anti

&gt;&gt; print maybe message
== ~null~  ; anti

&gt;&gt; print []
== ~null~  ; anti
</code></pre>
<p>Nothing has the property of suppressing console output, which is desirable in most print cases--at least those that do print output.  And if you said <code>(x: print "Hello")</code> you'd get a variable that would create an error on access, which seems also desirable.</p>
<p>If nothing was truthy, that makes it easier to act on the nothing-vs-null distinction in something like an ANY or ALL construct.</p>
<h2>
<a name="should-meaningless-but-truthy-unset-variable-state-6" class="anchor" href="https://forum.rebol.info#should-meaningless-but-truthy-unset-variable-state-6"></a>Should "Meaningless but Truthy" = "Unset Variable State"?</h2>
<p>A related question may be if functions like PRINT should be returning the same value as what is held by an unset variable.</p>
<p>Now that non-antiform BLANK! itself is truthy, might it be a better choice?</p>
<pre><code>&gt;&gt; print "Hello"
Hello
== _
</code></pre>
<p>But then...</p>
<ul>
<li>
<p>For the visual we seek, the console would need to not print BLANK!.  But I find it unsatisfying to have a non-antiform be what has "no representation".</p>
</li>
<li>
<p>If you assigned the result of this "meaningless" value to a variable, you wouldn't have that added protection that the variable would appear unset.</p>
</li>
</ul>
<h2>
<a name="truthy-nothing-seems-to-have-more-pluses-than-minuses-7" class="anchor" href="https://forum.rebol.info#truthy-nothing-seems-to-have-more-pluses-than-minuses-7"></a>Truthy Nothing Seems To Have More Pluses than Minuses</h2>
<p>My "semantic safety" bias initially had made me think that when you have a function like PRINT, it's nice to catch potential mistakes when you tried to act like it was a function that could meaningfully be tested for some kind of logical result.  So I pushed R3-Alpha's error from IF and EITHER further into ANY and ALL.</p>
<p>Then I went and made it so that when the PRINT received an opted-out input, it gave back NULL instead of NOTHING.  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_diagonal_mouth.png?v=12" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20">  So it was something you could act on with ELSE, but not other conditional constructs.</p>
<p>The evolution from UNSET! to the blank-antiform that is today's NOTHING has been a long and winding one.  Working around its ornery-ness gave rise to all kinds of interesting designs like voids, and invisibles like ELIDE PRINT.</p>
<p>But though I'm sure that I haven't considered all the angles yet...having nothing be neither-true-nor-false is looking more like a dying historical artifact than something with a clear motivation applicable to the present.</p>
<p>Nothing being always truthy offers consistency...and it's possible to ELIDE it to get "no vote" so it won't affect an ANY or ALL (the way Oldes R3 treats unsets).  Yet having the vote isn't entirely useless either.  I can't think of a whole lot of downside, so I think it's worth trying.</p>
<hr>
<p>A better axis of orneryness that may actually catch more problems in practice is: <strong><a href="https://forum.rebol.info/t/making-call-raise-a-definitional-error-for-bad-exit-codes/2068/2">Should Nothing be Illegal in Comparisons</a></strong></p>
<p>(I point out in that discussion that simply disabling the ability to check nothing for truthiness/falseyness is kind of a strange counterpart to a routine that returns--say--an INTEGER! in all cases, where you get zero information from testing an integer conditionally but without anything to stop you...making the disablement of testing nothing conditionally seem like a fairly empty gesture.)</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-truthiness-of-nothing/2180">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-truthiness-of-nothing/2180</link>
          <pubDate>Fri, 03 May 2024 17:27:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2180</guid>
          <source url="https://forum.rebol.info/t/the-truthiness-of-nothing/2180.rss">The Truthiness of Nothing</source>
        </item>
        <item>
          <title>Should SET-WORD!s Propagate Undecayed Packs?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Packs are antiform blocks, which decay if not specifically handled.</p>
<pre><code>&gt;&gt; pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; a: pack [1 2]
== 1

&gt;&gt; a
== 1
</code></pre>
<p>From time to time, I've wondered if there's a good reason why the plain SET-WORD! shouldn't propagate the pack:</p>
<pre><code>&gt;&gt; a: pack [1 2]
== ~['1 '2]~  ; anti  (hypothetical)

&gt;&gt; a
== 1
</code></pre>
<p>One rationale is that intuitively, <strong>a:</strong> should be a synonym for <strong>[a]:</strong>, e.g. "unpack one item" is implicit.</p>
<p>But that just bumps the question to the next one we might ask: why doesn't a multi-return without a "circled" result just evaluate to the whole pack?</p>
<p>It looks to make some sense at first, it allows you to chain indefinitely:</p>
<pre><code>&gt;&gt; [a b]: [c d]: pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; a
== 1

&gt;&gt; b
== 2

&gt;&gt; c
== 1

&gt;&gt; d
== 2
</code></pre>
<p>Though it feels a little bit unsettling when you drop it down:</p>
<pre><code>&gt;&gt; [a b]: [c]: pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; a
== 1

&gt;&gt; b
== 2

&gt;&gt; c
== 1
</code></pre>
<p>But we could argue that if you're bothered, then you use circling (currently <code>@c</code>, but with FENCE! proposed to be <code>{c}</code>).  Note in the below example you'd have to use <code>/b</code> in order to indicate you were okay with unpacking more values than available.</p>
<pre><code>&gt;&gt; [a /b]: [{c}]: pack [1 2]
== 1

&gt;&gt; a
== 1

&gt;&gt; b
== ~null~  ; anti

&gt;&gt; c
== 1
</code></pre>
<p>We could then make a choice if <strong>a:</strong> was a synonym for <strong>[a]:</strong> or for <strong>[{a}]:</strong></p>
<h2>
<a name="most-recent-motivation-for-thinking-about-this-1" class="anchor" href="https://forum.rebol.info#most-recent-motivation-for-thinking-about-this-1"></a>Most Recent Motivation For Thinking About This</h2>
<p>I rewrote <a href="https://forum.rebol.info/t/speed-of-uparse/2177/3">some code in an example</a> from this:</p>
<pre><code>[^result' remainder]: parser input except e -&gt; [
    remainder: input  ; succeed on parser fail but don't advance input
    return null
]
return unmeta result'  ; return successful parser result
</code></pre>
<p>...to this:</p>
<pre><code>return [@ remainder]: parser input except [
    remainder: input  ; succeed on parser fail but don't advance input
    return null
]
</code></pre>
<p>The idea is that the parser being called has multiple return results... the first is the synthesized value, the second is the amount it advanced.  <em>(There's a third result on some parsers of "pending items", but this OPTIONAL combinator has an "autopipe" which is just bubbling the pending items through in the order of successful parsers called...so the third result is specialized out on its interface and on the parsers it calls.)</em></p>
<p><strong>However, the synthesized value can itself be a pack.</strong>  This means that if we named a variable in the slot where the <code>@</code> is, then that pack would be decayed to store in the variable unless we used a ^META result.</p>
<p>So does the act of not-naming and just circling subvert the decay?  Or should the circled result not be decayed even if the variable is?</p>
<pre><code>&gt;&gt; [{a} b]: pack [pack [1 2] 3]
== ~['1 '2]~  ; anti  (or should it be decayed to 1?)

&gt;&gt; a
== 1

&gt;&gt; b
== 3
</code></pre>
<p>It's a different--but related--question.  It seems it should align with the behavior of plain assignments:</p>
<pre><code>&gt;&gt; a: pack [1 2]
== ~['1 '2]~  ; anti  (implied if the above behavior is chosen)

&gt;&gt; a
== 1
</code></pre>
<h2>
<a name="not-100-certain-but-i-think-undecayed-propagation-is-good-2" class="anchor" href="https://forum.rebol.info#not-100-certain-but-i-think-undecayed-propagation-is-good-2"></a>Not 100% Certain, But I Think Undecayed Propagation Is Good</h2>
<p>I'll point out that it's possible to DECAY things pretty easily, but you can't recover a pack after it has been decayed.</p>
<p>So I'm getting the feeling that it's probably best to decay the assignments, but propagate the undecayed pack.  It looks like the more general and useful behavior...even if it seems a bit confusing.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-set-word-s-propagate-undecayed-packs/2178">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-set-word-s-propagate-undecayed-packs/2178</link>
          <pubDate>Fri, 29 Mar 2024 21:22:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2178</guid>
          <source url="https://forum.rebol.info/t/should-set-word-s-propagate-undecayed-packs/2178.rss">Should SET-WORD!s Propagate Undecayed Packs?</source>
        </item>
        <item>
          <title>VOID Branches (not branches that evaluate to void)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>I've mentioned before that <a href="https://forum.rebol.info/t/augment-add-parameters-and-refinements-after-the-fact/1216">AUGMENT can be used to implement the legacy SWITCH/DEFAULT behavior</a>.</p>
<p>But looking at what seems like the "correct" formulation of that code today, we get:</p>
<pre><code>switch-d: enclose (augment :switch [
    /default "Default case if no others are found"
        [block!]
]) lambda [f [frame!]] [
    let def: f.default
    eval f else (maybe def)
]
</code></pre>
<p>It points out the existence of <em>void branches</em>... so not branches that evaluate to void (e.g. <code>[void]</code>) but code that evaluates to a branch to run, and that branch is void.</p>
<p>Considering this specific usage only, it suggests a semantic for ELSE of a VOID branch, which is that you want it to act like there was no branch at all.  e.g. as if you'd written just <strong><code>eval f</code></strong> with no ELSE.</p>
<pre><code> &gt;&gt; if false [1 + 2]
 == ~void~  ; anti

 &gt;&gt; if false [1 + 2] else [10 + 20]
 == 30

 &gt;&gt; if false [1 + 2] else (void)
 == ~void~  ; anti
</code></pre>
<p>Would the same apply to THEN?</p>
<pre><code> &gt;&gt; if true [1 + 2]
 == 3

 &gt;&gt; if true [1 + 2] then [10 + 20]
 == 30

 &gt;&gt; if true [1 + 2] then (void)
 == 3
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>I don't know if it's great, but it's certainly better than evaluating to NULL (via some void-in-null-out rationale) because that would trigger an ELSE branch.</p>
<pre><code> &gt;&gt; if true [1 + 2] then (void) else [print "we don't want this."]
 we don't want this.
</code></pre>
<p>But what should other branching constructs do, like CASE or SWITCH?  Might a void branch suggest "opting out" of that particular branch?</p>
<pre><code> case [
     1 &lt; 2 (void)
     3 &lt; 4 [print "Should this run?"]
 ]
</code></pre>
<p>A CASE (at least CASE/ALL) is supposed to be synonymous with a series of IF statements.  And IF can't exactly do that, unless it decided to be NIHIL...</p>
<pre><code>&gt;&gt; 1 + 2 if false (void)
== 3
</code></pre>
<p>That would be a bit weird, but, it does sort of parallel what happens when ELSE and THEN effectively vaporize themselves.</p>
<p>As with most things on the edge of usefulness, I don't know about this... other than the situation of wanting to revoke the ELSE branch in SWITCH-D.  I'll keep an eye on it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/void-branches-not-branches-that-evaluate-to-void/2176">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/void-branches-not-branches-that-evaluate-to-void/2176</link>
          <pubDate>Thu, 28 Mar 2024 13:07:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2176</guid>
          <source url="https://forum.rebol.info/t/void-branches-not-branches-that-evaluate-to-void/2176.rss">VOID Branches (not branches that evaluate to void)</source>
        </item>
        <item>
          <title>Definitional Break and Continue... the Time is Now</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>I was writing what I thought to be a clever bit of code, <a href="https://forum.rebol.info/t/deceptive-incomplete-parsing-a-common-problem/2065">discussed here</a></p>
<pre><code>for-each file ... [
    parse file [thru any [".reb" ".r"] &lt;end&gt; | (continue)]
    ...
]
</code></pre>
<p>I thought it was pleasing to have the CONTINUE in the rules themselves.</p>
<p>Pleasing, except... a bit displeasing considering <strong>it didn't work.</strong></p>
<p>BREAK and CONTINUE would break or continue the first loop they found above them in the stack.  Since PARSE is currently written in usermode code, it uses loops in its implementation (to loop over the rules).  <em>so you wind up continuing some arbitrary loop inside the combinators, having random effects</em>!</p>
<p>Happily Ren-C has pioneered answers to this kind of problem with definitional returns.  But loops just have to get with the program and make CONTINUE and BREAK definitional in their bodies.</p>
<p>So I did it!  And most things appeared to work (like the motivating example).</p>
<h2>
<a name="still-complexity-for-loops-implemented-without-loops-1" class="anchor" href="https://forum.rebol.info#still-complexity-for-loops-implemented-without-loops-1"></a>Still Complexity For Loops Implemented Without "Loops"</h2>
<p>In bootstrap, there was some code implementing FOR-EACH-PLATFORM.  Hand-waving a bit, it initially looked like this:</p>
<pre><code> for-each-platform: func ['var [word! tuple!] body [block!]] [
     parse platforms-table [
         while [not &lt;end&gt;] [
              ...  ; rules that build up an OBJECT! 
              (set var obj, do body)
         ]
     ]
 ]
</code></pre>
<p>But that didn't make CONTINUE work:</p>
<pre><code> for-each-platform p [
     if p.name = 'HaikuOS [continue]
     ...
 ]
</code></pre>
<p>So I'd hacked up something at one point in history which looked like this monstrosity:</p>
<pre><code>    completed*: false
    running*: false
    while [true] [  ; must be in loop for BREAK or CONTINUE
        if running* [  ; must have had a CONTINUE
            completed*: true
            break
        ]
        running*: true
        do body
        completed*: true
        break
    ]
    if not completed* [return null] 
</code></pre>
<p>That depended on non-definitional CONTINUE happening inside BODY finding the enclosing WHILE.</p>
<p>But now, that CONTINUE isn't definitionally bound anywhere.  So that CONTINUE is just a reference to a default CONTINUE function in LIB, which will error telling you there are no loops providing continue available.</p>
<p>For the modern world, this <em>works</em>:</p>
<pre><code> repeat 1 body else [return null]
</code></pre>
<p>Reserving the pure NULL return value for BREAK means you can get that communication of when BREAK was encountered out of the return result.  And in this case, CONTINUE is just supposed to bypass the remainder of code in BODY and go on parsing.  So it works.</p>
<p>But it's suboptimal as the binding of the body to BREAK and CONTINUE happens on each run instead of once.  Doing that more efficiently would need some new techniques and case studies.</p>
<p>Overall though, it's progress...in the sense that there's an answer that works slowly, vs. not working at all!</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/definitional-break-and-continue-the-time-is-now/2066">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/definitional-break-and-continue-the-time-is-now/2066</link>
          <pubDate>Thu, 07 Dec 2023 16:29:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2066</guid>
          <source url="https://forum.rebol.info/t/definitional-break-and-continue-the-time-is-now/2066.rss">Definitional Break and Continue... the Time is Now</source>
        </item>
        <item>
          <title>MOLD/ONLY vs. MOLD SPREAD</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Historically, the way you would ask to mold an array without its delimiters was with MOLD/ONLY:</p>
<pre><code>rebol2&gt;&gt; mold [a b c]
== "[a b c]"

rebol2&gt;&gt; mold/only [a b c]
== "a b c" 
</code></pre>
<p>In Ren-C this raises some existential questions, like how should quoted arrays be handled?</p>
<pre><code>mold/only first [''(a b c) d e]  ; ???
</code></pre>
<p>But I think there's a better answer: <em>use SPREAD and splice isotopes</em>.  If you want to mold the contents of an array, then turning it into a splice seems the natural answer.  And since you can't have splices of quoted things...there's a nice unambiguous answer.</p>
<pre><code>&gt;&gt; mold [a b c]
== "[a b c]"

&gt;&gt; mold spread [a b c]
== "a b c"
</code></pre>
<p>It does raise the question of what to do if you have something that might be an array or might not.  How do you tell it to mold as is if it's not an array, or without the delimiters if it is?  That's what MOLD/ONLY did, after all:</p>
<pre><code>rebol2&gt;&gt; mold/only [b l o c k]
== "b l o c k"

rebol2&gt;&gt; mold/only &lt;tag&gt;
== "&lt;tag&gt;"
</code></pre>
<p><em>"SPREAD won't SPREAD tags..."</em> you say.  And no, it won't.  But I think this is a rare case... and the neat thing about putting the bit on the value (as opposed to a refinement) is you can make functions like SPREAD-OR-AS-IS.  Or SPREAD-IF-PATH-OR-GROUP.  You can really tweak this however you want.</p>
<pre><code>&gt;&gt; mold spread-or-as-is &lt;tag&gt;
== "&lt;tag&gt;"

&gt;&gt; mold spread-or-as-is "[b l o c k]"
== "b l o c k"

&gt;&gt; spread-if-path-or-group 'p/a/t/h
== ~(p a t h)~  ; isotope

&gt;&gt; mold spread-if-path-or-group 'p/a/t/h
== "p a t h"
</code></pre>
<p>How about THAT?  All of this hinges on the idea that MOLD doesn't generally know how to mold isotopes, as they have no representation.  It just chooses to interpret the request to mold a splice isotope as "contents matter, no delimiters".</p>
<p>More control, more clarity, and the death of another /ONLY.  What more could you ask for?</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/mold-only-vs-mold-spread/2059">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/mold-only-vs-mold-spread/2059</link>
          <pubDate>Sun, 22 Oct 2023 23:59:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2059</guid>
          <source url="https://forum.rebol.info/t/mold-only-vs-mold-spread/2059.rss">MOLD/ONLY vs. MOLD SPREAD</source>
        </item>
        <item>
          <title>UNION, INTERSECT, DIFFERENCE...and Splices</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>There is a pattern that comes up a lot in Query which looks like this:</p>
<pre><code>if not find qe.clause-list 'update [append qe.clause-list 'update]
</code></pre>
<p>You could use an operation like UNION here, but since UNION only works on arrays you'd have to put UPDATE in a block:</p>
<pre><code>qe.clause-list: union qe.clause-list [update]
</code></pre>
<p>If the word to update with was in a variable (e.g. <strong>word: 'update</strong>), you couldn't do that block literally...so you'd need some blockifying function to do it:</p>
<pre><code>qe.clause-list: union qe.clause-list compose [(word)]

qe.clause-list: union qe.clause-list reduce [word]

qe.clause-list: union qe.clause-list :[word]

qe.clause-list: union qe.clause-list enblock word
</code></pre>
<h2>
<a name="semantics-of-operating-on-arrays-1" class="anchor" href="https://forum.rebol.info#semantics-of-operating-on-arrays-1"></a>Semantics of Operating on Arrays</h2>
<p>Historical Rebol would only accept BLOCK!s as the second argument to these operations.  I didn't see any reason not to generalize it, so I allowed GROUP!s as well:</p>
<pre><code>&gt;&gt; intersect [a b c d] '(b c e)
== [b c]

&gt;&gt; intersect '(a b c d) [b c e]
== (b c)
</code></pre>
<p>But there's a little bit of a question there about the result type.  Both arrays are taken account in terms of the elements, but only the first determines the type.  That's a little bit odd.</p>
<p>Furthermore, what if you wanted to intersect an array as an item?  The following wouldn't give you what you intended:</p>
<pre><code>item: [b]
collection: [[a] [b] [c] [d]]

collection: intersect collection item
</code></pre>
<p>You'd have to put the block into another block.  This is another one of those /ONLY style problems...</p>
<h2>
<a name="with-spread-we-can-do-this-better-2" class="anchor" href="https://forum.rebol.info#with-spread-we-can-do-this-better-2"></a>With SPREAD, we can do this better!</h2>
<p>We can make it so that UNION and friends assume you mean just one item by default, and you need to SPREAD the second argument to get it considered itemwise:</p>
<pre><code>&gt;&gt; union [a b c d] 'e
== [a b c d e]

&gt;&gt; union [[a] [b] [c] [d]] [e]
== [[a] [b] [c] [d] [e]]

&gt;&gt; union [[a] [b] [c] [d]] spread [e]
== [[a] [b] [c] [d] e]
</code></pre>
<p>So this means the operation from Query could be a little more succinct:</p>
<pre><code>if not find qe.clause-list 'update [append qe.clause-list 'update]
=&gt;
qe.clause-list: union qe.clause-list 'update
</code></pre>
<p>But more importantly, the as-is nature would avoid needing to jump through hoops for single-item operands:</p>
<pre><code> word: update
qe.clause-list: union qe.clause-list word
</code></pre>
<p>There are some questions about whether there is a guarantee of where the update would be added if it wasn't there... does it matter if it's added at the beginning or the end?</p>
<p>This is not a new question for these operations... the blocks are being treated as sets, so theoretically multiple answers could be valid:</p>
<pre><code>&gt;&gt; intersect [a b c d] spread [c b e]
== [b c]

 &gt;&gt; intersect [a b c d] spread [c b e]
== [c b]  ; what promises this wouldn't be the answer?
</code></pre>
<p>I think it's likely beneficial to make some kind of promise here.</p>
<h2>
<a name="should-unionetc-mutate-by-default-3" class="anchor" href="https://forum.rebol.info#should-unionetc-mutate-by-default-3"></a>Should UNION/etc. mutate by default?</h2>
<p>I point out that you'd have to write:</p>
<pre><code>qe.clause-list: union qe.clause-list 'update
</code></pre>
<p>In the Rebol model, "modify by default" is how things like APPEND or REVERSE work.  That would suggest you could write:</p>
<pre><code>union qe.clause-list 'update
</code></pre>
<p>And if you didn't want to modify qe.clause-list directly, you could copy it:</p>
<pre><code>result: union copy qe.clause-list 'update
</code></pre>
<p>If the interface to these functions was changed to work with splices and treat everything else as-is by default, it seems like a good time to make this change for consistency.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/union-intersect-difference-and-splices/2058">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/union-intersect-difference-and-splices/2058</link>
          <pubDate>Sun, 22 Oct 2023 06:06:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2058</guid>
          <source url="https://forum.rebol.info/t/union-intersect-difference-and-splices/2058.rss">UNION, INTERSECT, DIFFERENCE...and Splices</source>
        </item>
        <item>
          <title>COMMA! and GROUP! Error Parity, e.g. (1 +) and 1,</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>I've mentioned the idea of "error parity" between comma and reaching the end of a group:</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1387">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"><a href="https://forum.rebol.info/t/the-language-worlds-weirdest-comma-mechanic/1387/1">The Language World's Weirdest COMMA! Mechanic</a></div>
<blockquote>
<pre><code>&gt;&gt; all [1 +, 2 3 + 4]
** Script Error: + is missing its value2 argument

&gt;&gt; all [(1 +) 2 3 + 4]
** Script Error: + is missing its value2 argument
</code></pre>
</blockquote>
</aside>
<p>Today we get this equivalence due to a number of complex flags and conditions, in particular BARRIER_HIT:</p>
<pre><code>//=//// FEED_FLAG_BARRIER_HIT /////////////////////////////////////////////=//
//
// Evaluation of arguments can wind up seeing a comma and "consuming" it.
// But the evaluation will advance the frame.  So if a function has more than
// one argument it has to remember that one of its arguments saw a "barrier",
// otherwise it would receive an end signal on an earlier argument yet then
// get a later argument fulfilled.
//
#define FEED_FLAG_BARRIER_HIT \
    FLAG_LEFT_BIT(3)
</code></pre>
<p>So what's going on is:</p>
<ul>
<li>
<p>Explicit commas (as well as specially marked functions) put the evaluator into a BARRIER_HIT state.</p>
</li>
<li>
<p>While in the barrier state, subsequent evaluations trying to gather arguments for the same function are rigged to act the same as end-of-block.</p>
<ul>
<li>
<p>If a function's arguments don't tolerate <strong><code>&lt;end&gt;</code></strong> then this will give an error</p>
</li>
<li>
<p>If it is tolerant of <code>&lt;end&gt;</code> then it will be able to call the function.</p>
</li>
</ul>
</li>
<li>
<p>Starting the next fresh evaluation step clears the BARRIER_HIT state.</p>
</li>
</ul>
<h2><a name="p-6650-an-early-weakness-noted-literal-arguments-1" class="anchor" href="https://forum.rebol.info#p-6650-an-early-weakness-noted-literal-arguments-1"></a>An Early Weakness Noted: Literal Arguments</h2>
<p>I quickly spotted the case of taking the next argument literally (remember that <strong>the x</strong> is just <strong>x</strong>):</p>
<pre><code>the, 1 + 2
; vs
(the) 1 + 2
</code></pre>
<p>I wasn't sure of the value of protecting people from themselves here, vs. making COMMA! the one datatype you could not pass as quoted.  If it were to be prohibited, we could ask where the right place for the prohibition is:</p>
<ol>
<li>
<p>In the evaluator guts, by simulating an <strong><code>&lt;end&gt;</code></strong> signal for this case</p>
</li>
<li>
<p>Inside of THE, testing for <strong><code>if comma? arg [...]</code></strong> in the implementation</p>
</li>
<li>
<p>In the type checking, via <strong><code>the: native [arg [(non-comma? element?)]]</code></strong></p>
</li>
</ol>
<p>Today we could choose (1), which is what happens for evaluative parameters.  However we don't do this for quoted parameters...so today it is allowed:</p>
<pre><code>; today's behavior
&gt;&gt; the,
== ,
</code></pre>
<p>Or it could be an error unless you say <strong>THE/COMMA</strong>, which would force use of (2).</p>
<h2><a name="p-6650-but-would-simpler-be-better-2" class="anchor" href="https://forum.rebol.info#p-6650-but-would-simpler-be-better-2"></a>But... Would Simpler Be Better?</h2>
<p>The existing designs predate NIHIL (an isotopic empty pack).  One major aspect of nihil is that almost no functions will accept it as a parameter.</p>
<p>So we might ask how different COMMA! needs to be from reaching a nihil state, e.g. a COMMENT?  Would this be sensible as being equivalent mechanics:</p>
<pre><code>&gt;&gt; all [1 +, "hi" 2 3 + 4]
** Script Error: + is missing its value2 argument

&gt;&gt; all [1 + comment "hi" 2 3 + 4]
** Script Error: + is missing its value2 argument
</code></pre>
<p>e.g. <strong>How bad would it be if the BARRIER_HIT mechanics went away, and we simply leveraged the idea that commas evaluated to nihil...and most functions refuse nihil arguments?</strong></p>
<h2><a name="p-6650-downside-of-simplicity-behavior-in-pack-3" class="anchor" href="https://forum.rebol.info#p-6650-downside-of-simplicity-behavior-in-pack-3"></a>Downside of Simplicity: Behavior in PACK!</h2>
<p>I decided to test this idea of making COMMA! evaluate NIHIL just like a comment would.  But found trouble because I had code that was doing something like this:</p>
<pre><code>[a b]: pack [1 + 2, 10 + 20]
</code></pre>
<p>It didn't work, because PACK was built on top of REDUCE-EACH with a ^META variable.  REDUCE-EACH performed three evaluation steps on the right hand side... the second evaluated the comma and got back a nihil (empty pack):</p>
<pre><code>&gt;&gt; meta pack [1 + 2, 10 + 20]
== ~['3 ~[]~ '30]~
</code></pre>
<p>The concept here is that if you use REDUCE-EACH with a ^META variable, you have to handle everything--that includes packs and errors.  This needs to be legal in order to do things like multi-returns with unstable isotopes (this is integral to UPARSE, for instance).</p>
<p>So this means we <em>definitely</em> want this behavior:</p>
<pre><code>&gt;&gt; meta pack [1 + 2 comment "hi" 10 + 20]
== ~['3 ~[]~ '30]~
</code></pre>
<p><strong>This suggests either that you can't use commas in PACK, -or- that PACK needs to be proactive about skipping over the commas at source level.</strong>  So long as PACK is based on REDUCE-EACH, then that suggests REDUCE-EACH needs to be able to skip commas...because you wouldn't be able to distinguish the cases based on the NIHIL evaluation product alone.</p>
<p>Something to notice about that idea is that if it's literally looking for commas, that means you can't make your own comma-like construct that acts like a barrier.</p>
<h2><a name="p-6650-another-wrinkle-set-block-with-comma-on-right-4" class="anchor" href="https://forum.rebol.info#p-6650-another-wrinkle-set-block-with-comma-on-right-4"></a>Another Wrinkle: SET-BLOCK! with Comma on Right</h2>
<p>If you were to write something like this, it wouldn't give an error:</p>
<pre><code>&gt;&gt; [/a /b]: ,
== ~null~  ; isotope

&gt;&gt; a
== ~null~  ; isotope

&gt;&gt; b
== ~null~  ; isotope
</code></pre>
<p>This is because the slashes indicate the results are optional, e.g. a shorter pack is accepted.  If COMMA!'s stopping power in the main evaluator comes only from the idea that it evaluates to an empty pack, it won't complain at the lack of a meaningful expression to its right.</p>
<p>Things like META which can accept empty packs would also not trigger an error:</p>
<pre><code>&gt;&gt; meta,
== ~[]~
</code></pre>
<p>These don't offhand seem that bad, and maybe could even be seen as good if you look at it from a certain point of view.  But it does show that the "stopping power" of commas isn't bullteproof.</p>
<h2><a name="p-6650-what-about-thenelseetc-5" class="anchor" href="https://forum.rebol.info#p-6650-what-about-thenelseetc-5"></a>What About THEN/ELSE/etc. ?</h2>
<p>THEN and ELSE are enfix and treat their left hand side evaluatively:</p>
<pre><code>(1 + 2, then [print "what happens here?"])
</code></pre>
<p>This would wind up acting the same as:</p>
<pre><code>(1 + 2 comment "hi" then [print "what happens here?"])
</code></pre>
<p>It needs to be an error...and it currently is.  The error arises because THEN and ELSE refuse to operate on nihil.  But at the moment this is a distinct case from not having a left hand argument at all.</p>
<pre><code>(then [print "what happens here?"])
</code></pre>
<p>Today, there are mechanics that make the left hand side look like an <code>&lt;end&gt;</code> condition...which falls under the complexity of BARRIER_HIT.</p>
<h2><a name="p-6650-alternative-evaluator-skips-over-comma-when-possible-6" class="anchor" href="https://forum.rebol.info#p-6650-alternative-evaluator-skips-over-comma-when-possible-6"></a>Alternative: Evaluator Skips Over COMMA! When Possible</h2>
<p>This would mean if you wrote something like:</p>
<pre><code>&gt;&gt; do/next [, , , 1 + 2, , 10 + 20] 'pos
== 3

&gt;&gt; pos
== [, , 10 + 20]  ; or possibly just [10 + 20] if it skipped trailing commas
</code></pre>
<p><em>I think this is how things worked long ago before the BARRIER_HIT flag was introduced.</em>  The concept was that a literal barrier (was <strong><code>|</code></strong>, now <strong><code>,</code></strong>) would be greedily consumed in interstitial evaluations, but raise errors otherwise.</p>
<p>This way, a COMMA! could just stay un-consumed by the evaluator.  Function calls gathering their argument would look ahead and say "hey is there <em>either</em> an end of block or a COMMA!" and if so, not run an evaluation and report an <code>&lt;end&gt;</code> condition.  This could be reported for arbitrarily many arguments...and so long as they were endable you would receive that condition.  In other words: the BARRIER_HIT flag was conveyed merely by a lagging comma that would stick around.</p>
<p><em>This feels very regressive, because every stepwise evaluating function inherits this complexity.</em>  The nice consequence of saying that COMMA! just evaluates to NIHIL is that it triggers the same handling you would use for COMMENT-like functions.</p>
<h2><a name="p-6650-on-balance-i-think-the-barrier_hit-flag-has-to-die-7" class="anchor" href="https://forum.rebol.info#p-6650-on-balance-i-think-the-barrier_hit-flag-has-to-die-7"></a>On Balance, I Think the BARRIER_HIT Flag Has To Die</h2>
<p><strong>I'm bullish on COMMA! as a great addition to the language.</strong>  But the various hoops that are jumped through to try and make it mimic the end of a block seem like a bridge too far.</p>
<p>To me, having commas vaporize is neat tech... and the idea is that if you handle things like COMMENT and ELIDE you get the comma handling for free.  This seems quite elegant to me.</p>
<p>Maybe functions like REDUCE-EACH need a refinement that lets you detect commas differently:</p>
<pre><code>&gt;&gt; reduce-each x [1 + 2, (elide print "Hi!") 10 + 20] [probe x]
3
Hi!
30
== 30

&gt;&gt; reduce-each ^x [1 + 2, (elide print "Hi!") 10 + 20] [probe x]
'3
Hi!  ; skipped over comma, by default
~[]~
'30
== '30

&gt;&gt; reduce-each/comma ^x [1 + 2, (elide print "Hi!") 10 + 20] [probe x]
'3
~,~  ; isotope
Hi!
~[]~
'30
== '30
</code></pre>
<p>Here I fancifully suggest giving back an isotopic comma to draw attention to it.  Since all other values come back meta'd, this doesn't conflate with any "real" evaluative result.  e.g. <strong><code>[~,~, ~,~]</code></strong> could distinguish "real isotopic commas" from source-level commas that REDUCE-EACH is offering to tell you about.</p>
<p>That requires commas to be stable isotopes.  But one could also not worry about the conflation, and reduce to an unstable isotope:</p>
<pre><code>&gt;&gt; ,
== ~,~  ; isotope
</code></pre>
<p>Then instead of people directly testing for NIHIL? most people could test for NOTHING? or VAPOR? which meant either nihil or isotopic comma.  :-/</p>
<p>Some crazy ideas here, but I think on balance that trying to make commas "bulletproof" leads to more confusion and problems than just making them do whatever comments do, with meta-REDUCE-EACH skipping them by default.</p>
<h2><a name="p-6650-this-means-killing-off-user-defined-expression-barriers-8" class="anchor" href="https://forum.rebol.info#p-6650-this-means-killing-off-user-defined-expression-barriers-8"></a>This Means Killing Off User-Defined Expression Barriers</h2>
<p>Paring it down such that NIHIL results are "mean" enough to stop evaluations for all practical purposes, the special flag for letting functions cause the BARRIER_HIT flag can be dropped too.  This was made available via the TWEAK function:</p>
<pre><code>//=//// DETAILS_FLAG_IS_BARRIER ///////////////////////////////////////////=//
//
// Special action property set with TWEAK.  Used by |
//
// The "expression barrier" was once a built-in type (BAR!) in order to get
// a property not possible to achieve with functions...that it would error
// if it was used during FULFILL_ARG and would be transparent in evaluation.
//
// Transparency was eventually generalized as "invisibility".  But attempts
// to intuit the barrier-ness from another property (e.g. "enfix but no args")
// were confusing.  It seems an orthogonal feature in its own right, so it
// was added to the TWEAK list pending a notation in function specs.
//
#define DETAILS_FLAG_IS_BARRIER \
    SERIES_FLAG_25
</code></pre>
<p><strong>I don't feel any particular qualm about losing this feature, because I've never really used it.</strong></p>
<p>And under the new concept, you get "barriery-enough" just by evaluating to NIHIL.  You're no better or worse than COMMA!</p>
<p><em>(Actually that's not quite true, because currently COMMA! doesn't do lookahead, so it can't serve as the left hand side of an enfix function that doesn't quote the left hand side.  But WORD! does do lookahead.  If we wanted to go for full parity, we'd allow the lookahead for evaluative commas...but making comma worse just to give it parity with a WORD! doesn't seem too smart.  If we decided that COMMA! was actually a WORD! that was a synonym for NIHIL and just rendered funny, then it might make sense... but that would wreck other things--like the PACK exception for commas.)</em></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/comma-and-group-error-parity-e-g-1-and-1/2212">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/comma-and-group-error-parity-e-g-1-and-1/2212</link>
          <pubDate>Mon, 24 Jul 2023 04:47:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2212</guid>
          <source url="https://forum.rebol.info/t/comma-and-group-error-parity-e-g-1-and-1/2212.rss">COMMA! and GROUP! Error Parity, e.g. (1 +) and 1,</source>
        </item>
        <item>
          <title>How Does BLANK! Interact With Strings?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Experiments have run the gamut to where a plain BLANK! once would opt out of appending to a series, and you had to quote it to append it:</p>
<pre><code>experiment&gt;&gt; append [a b] _
= [a b]

experiment&gt;&gt; append [a b] quote _
== [a b _]
</code></pre>
<p>But the satisfying world we have now is that anything you can pick out of a block will append as-is to another block.  So adding a blank is additive:</p>
<pre><code>&gt;&gt; append [a b] _
== [a b _]
</code></pre>
<p>It feels like a decent fit to say that appending a blank to a string is additive...since VOID and such are available if you want to opt out:</p>
<pre><code>&gt;&gt; append "ab" _
== "ab "
</code></pre>
<p>Though it raises the question of what BINARY! should do:</p>
<pre><code>&gt;&gt; append #{0102} _
== ???
</code></pre>
<p>It seems that adding a UTF-8 representation is the story for ASCII:</p>
<pre><code>&gt;&gt; as binary! "AB"
== #{4142}

&gt;&gt; append #{0102} "AB"
= #{01024142}
</code></pre>
<p>But when it comes to integers, strings append the molded form...while binaries just add one byte, not the bytes of the formed string of the integer:</p>
<pre><code>&gt;&gt; append "ab" 10
== "ab10"

&gt;&gt; append #{0102} 10
== #{01020A}
</code></pre>
<p>A bit of a mixed bag, that could support arguments that BLANK! could be "the space of binaries" (e.g. #{00})</p>
<pre><code>&gt;&gt; append #{0102} _
== #{010200}
</code></pre>
<p>But I think that's not so useful.  It's more likely that the character representation of space is useful:</p>
<pre><code>&gt;&gt; to binary! #" "
== #{20}

&gt;&gt; append #{0102} _
== #{010220}
</code></pre>
<p>Ren-C FIND and PARSE mechanics already allows you to search for strings in BINARY!, implicitly looking for the UTF-8 representation.</p>
<h2>
<a name="what-if-_-was-really-the-canon-representation-of-space-chars-1" class="anchor" href="https://forum.rebol.info#what-if-_-was-really-the-canon-representation-of-space-chars-1"></a>What If _ Was Really The Canon Representation of Space Chars?</h2>
<pre><code>&gt;&gt; pick "ab " 3
== _

&gt;&gt; #" "
== _

&gt;&gt; char? _
== ~true~  ; isotope

&gt;&gt; space? _
== ~true~  ; isotope
</code></pre>
<p>I've mentioned that single character intents are on the rise... we could call quoted void (apostrophe) "blank" and it could be used in contexts where you want to say there's no value:</p>
<pre><code>&gt;&gt; blank? first [']
== ~true~  ; isotope

&gt;&gt; blank
== '
</code></pre>
<p>You'd still have _ as an evaluator-inert dialecting part that can't be redefined.  You just would need to use something like <strong>#</strong> or <strong>'</strong> or <strong>~</strong> in cases where you had a slot that could be either any character -or- some out of band thing.</p>
<p>Off the top of my head, I can see a few problems.  If _ became a character literal, it shouldn't be used for vacant spots in paths.  So let's say paths start using this "new blank":</p>
<pre><code>&gt;&gt; as block! first [/a]
== [' a]
</code></pre>
<p>Doesn't look too bad, but if you want to parse it you need double apostrophes to match those spots:</p>
<pre><code>parse [/a] [into path! ['' 'a]]
</code></pre>
<p>This is because a single apostrophe is matched as void, e.g. matches without advancing the parse position.  <a href="https://forum.rebol.info/t/parse-behavior-for-words-that-lookup-to-quoted/2038">And it wouldn't work if you used a word to reference the blank</a>:</p>
<pre><code>&gt;&gt; parse [/a] [into path! [blank 'a]]
** Error: To match a QUOTED! you must use @blank

&gt;&gt; parse [/a] [into path! [@blank 'a]]  ; would need to do this...
== a
</code></pre>
<p>But it's not awful, and at least it doesn't silently treat the quote as a vanishing rule.</p>
<p><strong>It's still kind of an interesting thought to make _ the literal char! of space.</strong>  Still inert, still usable in dialects.  It would leave <strong><code>'</code></strong> and <strong><code>~</code></strong> as "friendly nothing" and "unfriendly nothing".</p>
<pre><code>&gt;&gt; spread first [']  ; would return void

&gt;&gt; spread first [~]
** Error: Cannot spread meta-NONE
</code></pre>
<p>Either way, I think the conclusion here is that <strong>append #{0102} _</strong> should be <strong>#{010220}</strong></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/how-does-blank-interact-with-strings/2287">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-does-blank-interact-with-strings/2287</link>
          <pubDate>Mon, 26 Jun 2023 17:39:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2287</guid>
          <source url="https://forum.rebol.info/t/how-does-blank-interact-with-strings/2287.rss">How Does BLANK! Interact With Strings?</source>
        </item>
        <item>
          <title>Correct Formulation of ME and MY</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>The ME function is used with enfix to allow you to avoid repeating the name of a variable:</p>
<pre><code>&gt;&gt; variable: 10

&gt;&gt; variable: me + 1
== 11

&gt;&gt; variable
== 11
</code></pre>
<p>So that's the same as if you'd written <strong>variable: variable + 1</strong>.</p>
<p>There's an analogous operation for non-enfix functions called MY.</p>
<pre><code>&gt;&gt; block: [a b c]

&gt;&gt; block: my next
== [b c]

&gt;&gt; block
== [b c]
</code></pre>
<p>So the same if you had written <strong>block: next block</strong>.</p>
<h2>Here Is The "Naive" Macro Implementation of ME</h2>
<pre><code>me: enfixed macro [
    'left [set-word! set-tuple!]
    'right [word! tuple! path!]
][
    reduce [left, plain left, right]
]
</code></pre>
<p>So the macro is looking for a SET-WORD! or SET-TUPLE! on the left, and then something indicating the action to run on the right.  It replaces the whole sequence with what was on the left, then a plain WORD! or TUPLE! version of what was on the left, and then what's on the right.</p>
<p>MY is done similarly, just with <strong>reduce [left, right, plain left]</strong> to put the repeated term after the call.</p>
<p>This is naive for two reasons:</p>
<ul>
<li>
<p>It doesn't check that what the RIGHT parameter looks up to is an action</p>
</li>
<li>
<p>If the SET-TUPLE! in LEFT has a GROUP! in it, then it will be executed twice.</p>
</li>
</ul>
<h2>Here is A "Non-Naive" Implementation of ME</h2>
<pre><code>macro [
    'left [set-word! set-tuple!]
    'right [word! tuple! path!]
    &lt;local&gt; value
][
    [left value]: resolve left  ; avoid double-evaluation
    :['set left meta value ensure action! get right]
]
</code></pre>
<p>The RESOLVE function is used to turn a TUPLE! or PATH! with groups in it into an inert representation:</p>
<pre><code> &gt;&gt; blk: [a b [c d]]

 &gt;&gt; resolve 'blk.(print "hi", 1 + 2).2
 hi
 == @[blk 3 2]
</code></pre>
<p>GET and SET accept these blocks as an alternative to words/tuples to be used to describe what to set or get.</p>
<p>It has to use a BLOCK! representation because not all things can be represented in paths that can be used with picking (note this implies you cannot pick with isotopes, otherwise not all blocks would be resolvable).</p>
<p>So long as RESOLVE is walking the path, you can ask it to give you back the value of what's there.</p>
<h2>But the non-naive version triggers a binding bug...</h2>
<p>It's also rather slow.  In trying to prioritize, it may be better to just document the right answer, as I've done here... :-/</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/correct-formulation-of-me-and-my/2020">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/correct-formulation-of-me-and-my/2020</link>
          <pubDate>Fri, 03 Mar 2023 21:23:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2020</guid>
          <source url="https://forum.rebol.info/t/correct-formulation-of-me-and-my/2020.rss">Correct Formulation of ME and MY</source>
        </item>
        <item>
          <title>Picking ACTION!s from BLOCK!s In The Age of Isotopes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>In <strong><a href="https://forum.rebol.info/t/reds-design-issues-wiki/1282">Red's Design Questions wiki</a></strong>, they bring up the issue of why picking functions out of blocks runs them:</p>
<pre><code>red&gt;&gt; block: reduce [does [print "Evaluated."]]
  == [func [][print "Evaluated."]]

red&gt;&gt; equal? block/1 first block
Evaluated.  ; d'oh
== false
</code></pre>
<p><a href="https://gitter.im/red/red?at=5c782ca0c1cab53d6f53dd6d">In the Gitter conversation</a>, Boris calls it a "shady area" that they can't get out of "under the current semantic model".  He suggests it is clear that <strong><code>block/1</code></strong> should not run an action, but possible that <strong>block/word</strong> would mean to.</p>
<p>They contemplate the idea that <strong>block/1</strong> would not run the action, but pick it:</p>
<pre><code>red&gt;&gt; block: reduce [does [print "Evaluated."]]
  == [func [][print "Evaluated."]]

red&gt;&gt; equal? block/1 first block  ; hypothetical behavior
== false
</code></pre>
<p><strong>I will argue this doesn't really help you much, the problem just becomes one step removed.</strong>  Quite often people are picking things out of blocks to put them in variables, and you'll just get bit there instead:</p>
<pre><code>red&gt;&gt; otherblock: copy []
== []

red&gt;&gt; temp: block/1
== func [][print "Evaluated."]

red&gt;&gt; append otherblock temp
Evaluated.  ; d'oh
== [unset]  ; double d'oh
</code></pre>
<h2>
<a name="isotopes-bring-the-better-semantic-model-1" class="anchor" href="https://forum.rebol.info#isotopes-bring-the-better-semantic-model-1"></a>Isotopes Bring The Better Semantic Model!</h2>
<p>In Ren-C's concept (as I'm working on it), the only actions that will run from a word reference are those that are isotopic actions.  And FUNC or DOES creates an isotopic action.</p>
<p>So you would be stopped from making an illegal block up front:</p>
<pre><code>&gt;&gt; block: reduce [does [print "Evaluated."]]
** Script Error: Invalid use of ~#[action! []]~ isotope
</code></pre>
<p>You can put quasi-ACTION!s, plain ACTION!s, and quoted actions in blocks.  Just not isotopic ones.</p>
<p>Whichever you choose, the equality test will work... and picking out a value into a variable will give you an inert variable to work with, that can be used with things like append!</p>
<pre><code>&gt;&gt; block: reduce [reify does [print "Evaluated."]] 
== [~#[action! []]~]

&gt;&gt; equal? block.1 first block
== ~true~  ; isotope  &lt;-- didn't run and print "Evaluated", yay!

&gt;&gt; otherblock: copy []
== []

red&gt;&gt; temp: block.1
== ~#[action! []]~

red&gt;&gt; append otherblock temp
== [~#[action! []]~]   ; &lt;-- didn't run and gave sensible block out
</code></pre>
<p>I used REIFY there and got a quasi-action.  BUT which would you rather put in the block: a quasi-action or a plain one?  This depends on what you plan to do with the block.  A plain action will execute when encountered by the evaluator, while a quasi-action will evaluate to an isotopic action--suitable for assigning via SET-WORD! when you meant to make that word dispatch the function when referenced.</p>
<p>My leaning is to say that either form can be used with APPLY, RUN, or the terminal path form:</p>
<pre><code>&gt;&gt; block: reduce [reify does [print "Evaluated."]] 
== [~#[action! []]~]

&gt;&gt; run block.1
Evaluated.

&gt;&gt; block: reduce [concretize does [print "Evaluated."]] 
== [#[action! []]]

&gt;&gt; apply block.1 []
Evaluated.
</code></pre>
<p><em>(See post on <a href="https://forum.rebol.info/t/reify-vs-meta-vs-something/2001">difference between REIFY and CONCRETIZE</a>, and the search for a better term...)</em></p>
<p>If you want to pick an action out of a block and put it into a variable, where it will execute from that variable, there is the RUNS transformer.  It will turn a quasi or plain ACTION! into an action isotope:</p>
<pre><code> &gt;&gt; active-var: runs block.1
 == ~#[action! {active-var} []]~  ; isotope  &lt;-- note: also cached name, neat!

 &gt;&gt; active-var
 Evaluated.
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/clap.png?v=12" title=":clap:" class="emoji only-emoji" alt=":clap:" loading="lazy" width="20" height="20"></p>
<p>You can use UNMETA more generically to get an isotope back from any quasi-form (not just actions), or ISOTOPIC to get an isotope from a plain form.</p>
<h2>
<a name="the-invariant-is-what-counts-here-2" class="anchor" href="https://forum.rebol.info#the-invariant-is-what-counts-here-2"></a>The Invariant Is What Counts, Here!</h2>
<p>The mountain that has been climbed is that we can now say that for any block, this is true:</p>
<pre><code>block2: collect [
    for-each item block1 [keep item]
]

assert [equal? block1 block2]
</code></pre>
<ul>
<li>
<p>I've just covered that there are no isotopic actions to implicitly execute; you'd get an error trying to put them in the block.</p>
</li>
<li>
<p>There are no blocks/groups/paths that will splice into the target, because splicing requires an explicit conversion to an isotope.</p>
</li>
<li>
<p>There are no "unsets" to trip on that you can find in a block, because the state conveying "unsetness" (none) is an isotope.</p>
</li>
</ul>
<p>Of course with objects, it's going to be a different story.  I think we'll still want some safeguards:</p>
<pre><code>for-each [key value] object [...]  ; will error when value is action

for-each [key :value] object [...]  ; will allow action isotopes as-is

for-each [key ^value] object [...]  ; will give a meta value
</code></pre>
<p>A key problem here is I'm wondering how much to cross purposes of GET-WORD! between action disarming and the other isotopic states.  But, it just takes time to work through.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/picking-action-s-from-block-s-in-the-age-of-isotopes/2002">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/picking-action-s-from-block-s-in-the-age-of-isotopes/2002</link>
          <pubDate>Fri, 06 Jan 2023 03:16:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2002</guid>
          <source url="https://forum.rebol.info/t/picking-action-s-from-block-s-in-the-age-of-isotopes/2002.rss">Picking ACTION!s from BLOCK!s In The Age of Isotopes</source>
        </item>
        <item>
          <title>SPLIT Semantics</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p><a href="https://gitter.im/red/red?at=63523097f00b697fec501c7a">On Red Gitter</a>, it was discussed "which of the following is 'correct'":</p>
<pre><code>Red&gt; split "" ","
== [""]

R3&gt; split "" ","
== []
</code></pre>
<p>Rebolek thinks R3 is right.  Boris says:</p>
<blockquote>
<p>I don't think there's a correct answer, just choices. I prefer the Red version because:<br>
it strictly follows the rule: `number-of-segments = 1 + number-of-delimiters", no exceptions, so it's easier to reason about</p>
<p>it should be able thus to preserve the type in case one wants to rejoin it later (that it doesn't is a bug, try split %"" ",")</p>
</blockquote>
<p>So there's a couple of ways to look at it.</p>
<p>But I have a philosophy about these things where I want edge cases to be "noisy", because usually they require special handling.  I might even say:</p>
<pre><code>&gt;&gt; split "" ","
== ~null~  ; isotope
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/split-semantics/1998">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/split-semantics/1998</link>
          <pubDate>Thu, 22 Dec 2022 04:04:52 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1998</guid>
          <source url="https://forum.rebol.info/t/split-semantics/1998.rss">SPLIT Semantics</source>
        </item>
        <item>
          <title>Line Continuation and Arity Bugs: Thoughts?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>At one point in time, there was no way to pass something to RETURN that represented a VOID.  Because voids completely vanished.  If you had a function that took an argument--and a void thing came after it--the evaluator would just keep retriggering until it found a value or hit the end.</p>
<p>This led to the only way of being able to return a void to be to have truly nothing after it.  So RETURN became effectively arity-0 or arity-1.  If you passed it no argument, it would consider itself VOID.  It even had the nice property of being able to chain functions that themselves might be void.</p>
<p>Given that RETURN was doing this, some other functions followed suit.  QUIT could take an argument or not.  CONTINUE could as well.</p>
<h2>
<a name="but-i-just-got-bit-by-a-variadic-quit-bug-1" class="anchor" href="https://forum.rebol.info#but-i-just-got-bit-by-a-variadic-quit-bug-1"></a>But I Just Got Bit By a Variadic QUIT Bug</h2>
<p>Without thinking about it, I tried to end some code prematurely by injecting a quit:</p>
<pre><code> some stuff I wanted to run

 quit  ; added this

 some stuff I wanted to avoid running
</code></pre>
<p>And that QUIT ran the stuff I didn't want to run anyway, because it was variadic.</p>
<h2>
<a name="my-kneejerk-reaction-was-to-kill-the-variadicness-2" class="anchor" href="https://forum.rebol.info#my-kneejerk-reaction-was-to-kill-the-variadicness-2"></a>My Kneejerk Reaction Was To Kill The Variadicness</h2>
<p>The original case of RETURN has changed, because so-called "non-interstitial invisibility" is dead.  You can only make expressions vanish in their totality--not when used as arguments.  Doing otherwise caused more harm than good.</p>
<p>Hence <strong><code>return nihil</code></strong> is a perfectly fine thing to write.</p>
<p>I'd been thinking that argument-less RETURN would thus go back to returning "NOTHING" (the default meaningless value).  But maybe we shouldn't support argument-less RETURN at all.</p>
<h2>
<a name="but-variadics-can-be-neat-3" class="anchor" href="https://forum.rebol.info#but-variadics-can-be-neat-3"></a>But Variadics Can Be Neat</h2>
<p>I guess RETURN could always take an argument, and we go back to CONTINUE/WITH and QUIT/WITH.</p>
<p>But those are uglier.</p>
<p>We might question the behavior of the system just randomly slurping up arguments from enusing lines?  Especially when APPLY has such a convenient notation now, of <strong>some-func/ [...]</strong></p>
<p>From a usability perspective, there's certainly a lot of potential for error in getting the arity wrong.  Having it be more strict could catch bugs, and make it more likely that variadic arity is being used correctly.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/line-continuation-and-arity-bugs-thoughts/1965">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/line-continuation-and-arity-bugs-thoughts/1965</link>
          <pubDate>Wed, 14 Sep 2022 17:08:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1965</guid>
          <source url="https://forum.rebol.info/t/line-continuation-and-arity-bugs-thoughts/1965.rss">Line Continuation and Arity Bugs: Thoughts?</source>
        </item>
        <item>
          <title>Revisiting TO and THRU</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>If you asked someone to count "from 1 to 10", how many people would stop at 9?</p>
<p>I'd say most wouldn't.  So if you wrote:</p>
<pre><code>for x [1 to 10] [print [x]]
</code></pre>
<p>What should that do?  I think if you showed it to people they would expect 10 to be included.</p>
<p>But PARSE has historically discerned this via TO (not including the limit) and THRU (including the limit).</p>
<p>Is that right?  Should TO be inclusive, and some other word along the lines of "UPTO" be used?</p>
<p>I almost feel like the words are slippery enough that we could bend them so that THRU was the <em>non</em>-inclusive version.  :-/</p>
<p>In PARSE, if TO included the limit, you could go up-to-but-not-include by using AHEAD with it: <strong><code>to ahead "A"</code></strong></p>
<p>We could say that UNTIL would keep advancing until it hit the rule and then stopped short of it: <strong><code>until "A"</code></strong>.</p>
<p>Would that convey the right thing in the FOR case?</p>
<pre><code>&gt;&gt; for x [1 until 10] [print [x]]
1
2
3
4
5
6
7
8
9</code></pre>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/revisiting-to-and-thru/1961">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/revisiting-to-and-thru/1961</link>
          <pubDate>Tue, 06 Sep 2022 16:56:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1961</guid>
          <source url="https://forum.rebol.info/t/revisiting-to-and-thru/1961.rss">Revisiting TO and THRU</source>
        </item>
        <item>
          <title>Should REDUCE Heed SPREAD?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>When <a href="https://forum.rebol.info/t/putting-splicing-intent-on-appended-value/1873/9">suggesting the term SPREAD</a>, <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> gave this example for REDUCE behavior, which hadn't occurred to me previously:</p>
<pre><code>&gt;&gt; reduce [spread [a b c] [a b c]]
== [a b c [a b c]]
</code></pre>
<p>Nothing about the design makes this happen automatically.  REDUCE has historically errored on isotopes.  So code has to be added to override that.</p>
<p>I'm guessing most people would be in favor of having the splicing behavior.  Arguments that say that there should be a 1:1 correspondence between expressions and values in a REDUCE are already pretty much out the window, since VOID elements vanish (including conditionals that don't take any branch).</p>
<h2>
<a name="delimit-would-presumably-want-it-too-1" class="anchor" href="https://forum.rebol.info#delimit-would-presumably-want-it-too-1"></a>DELIMIT Would Presumably Want It Too</h2>
<p>I've complained in the past that the often random-seeming treatments of blocks in Rebol2 functions like REJOIN lead to problems--and that it would be better if people had to be explicit about their intent.  This offers the ability to "inherit" whatever the enclosing delimiting strategy is, and fold into the existing operation (technically more efficient):</p>
<pre><code>&gt;&gt; block: ["c" "d"]

&gt;&gt; spaced ["a" "b" block]
** Error: BLOCK! not handled by DELIMIT, use SPREAD or desired string conversion

&gt;&gt; spaced ["a" "b" spread block]
== "a b c d"

&gt;&gt; spaced ["a" "b" unspaced block]  ; if you wanted another interpretation
== "a b cd"
</code></pre>
<p>I believe I prefer this over having some default way that blocks behave inside string conversions.  The odds of guessing right are low enough that it's better to have people be explicit.</p>
<p>So...presuming there's no objections....there's an agenda item to fuse together the stackless logic that performs a REDUCE so that it's the same code running in DELIMIT, so I'd probably go ahead and do that and make these things work.</p>
<p><strong>UPDATE circa Oct 2022: This has been done, so you can now use this feature.</strong></p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/should-reduce-heed-spread/1917">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-reduce-heed-spread/1917</link>
          <pubDate>Tue, 16 Aug 2022 04:10:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1917</guid>
          <source url="https://forum.rebol.info/t/should-reduce-heed-spread/1917.rss">Should REDUCE Heed SPREAD?</source>
        </item>
        <item>
          <title>Weird Idea: LIB/APPEND Runs, but LIB.APPEND Doesn&#39;t?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Historical Redbol did not have generic TUPLE!.  So that meant it used paths for everything...whether you were specifying a refinement to a function, or doing a member selection out of an object, or coordinate out of a pair, or...whatever.</p>
<p>So far what Ren-C has done is to shift it such that tuples are for member selection, and pathing is for refinements only.</p>
<p>A new twist is that a terminal-slash in a path (e.g. the last element is a BLANK!) <a href="https://forum.rebol.info/t/apply-ii-the-revenge/1834/7">means "APPLY the action"</a>.  This is especially helpful when wanting to run a non-isotopic action in the new "activated actions" model:</p>
<pre><code>&gt;&gt; block: reduce [reify :print]

&gt;&gt; block.1
== #[action! {print} [line]]

&gt;&gt; block.1/ ["The terminal slash comes in handy!"]
The terminal slash comes in handy!
</code></pre>
<p>So if you have a non-isotopic action in your hand, the slash can run it.  But under the current rules, your arguments and refinements need to go in a BLOCK!.</p>
<h2>Terminal Slashes Could Provide Safety...</h2>
<p>With the above, the pattern you would use to say you were going to run something like APPEND/DUP out of LIB would be this:</p>
<pre><code>&gt;&gt; lib.append/dup [a b c] [d e] 2
== [a b c [d e] [d e]]
</code></pre>
<p>But this means that you're on the hook for simple tuple references running, which you may not have expected:</p>
<pre><code>&gt;&gt; if integer? obj.something [print "What if SOMETHING is an ACTION! isotope?"]
Boo!
** Error: Some error coming from OBJ.SOMETHING running
</code></pre>
<p>One way of stopping this would be to say that if you were going to call a function that was a member of an object, you'd have to use a terminal slash, otherwise you'd get an error.</p>
<pre><code>&gt;&gt; if integer? obj.something [print "Clearer error if it's an ACTION! isotope"]
** Error: OBJ.SOMETHING is an ACTION! isotope, use OBJ.SOMETHING/ if intended
</code></pre>
<p>That would make field selection on the whole feel "safer".  But at the cost of looking at a lot of terminal slashes, and nowadays that also forces you to use APPLY and pass your arguments in a BLOCK!.</p>
<h2>More Succinct: Allow PATH!s to Pick The Action, Too</h2>
<p>If something like <strong>lib.append/dup</strong> is clearly an action (due to the use of refinements) it wouldn't need the terminal slash, like <strong>lib.append/dup/</strong>.  You already know an action is being run.</p>
<p>So what if you said <strong>lib/append</strong> instead of <strong>lib.append/</strong> ?</p>
<p>Of course, under such a rule, <strong>lib/append</strong> becomes conflated with a situation where LIB is a function and you're applying the <strong>/append</strong> refinement.  This does break away from a rule like "slashes always mean refinements".</p>
<p>That <em>kind of</em> sucks...BUT...it's still <em>far</em> less conflated than it was before.  Remember, historical Redbol used slashes for <em>EVERYTHING</em>.</p>
<p>The new rule could be "slashes always mean <em>from here on out, what we're talking about is function invocation"</em>.  So it's either picking a function to run, or narrowing it down by means of a refinement.</p>
<p>The advantage here system-wide would be that you could use field selection without worrying about it, as <strong>foo.bar</strong>, meaning "I want that field and I don't want any functions to run".  If there's no slash, there's no invocation.</p>
<p>I almost feel like the weird exception is worth it, because it would save a lot of bulletproofing that would otherwise be required on objects.  But it's also clearly a bit <em>bent</em>.</p>
<h2>The Other Direction: Terminal Dot as Invocation Suppressor</h2>
<p>There's a possibility for saying "this reference is not an invocation", which could apply to WORD!s and to TUPLE!s alike.  That's the terminal dot.</p>
<pre><code>&gt;&gt; x: append.
** Error: APPEND. reference ends in dot but it's an ACTION! isotope
</code></pre>
<p>It has one downside of kind of being close to being a comma.</p>
<p>But the bigger reason I don't like this is just the mental tax that comes into effect.  It's the same as how I didn't like the creeping desire for correctness, meaning people putting colons in front of things in a fairly ad-hoc way.  We'd like the obvious code to just work.</p>
<p>I think the LIB/APPEND compromise may be worthwhile to get this correctness-by-default situation.</p>
<h2>Possible Objection: Value/Function Invariance?</h2>
<p>We might say that forcing you to distinguish at the callsite whether you are calling a function or not, prevents you from taking something that was a plain value previously, and substituting it with a function that calculates that value.</p>
<p>Under this principle, it's a feature that you "don't know" if <strong>obj.something</strong> is an action isotope or not...and making you commit to which it is by saying <strong>obj/something</strong> is bad.</p>
<p>It's kind of a narrow case--since you <em>have</em> to know at the callsite if it's a function that consumes arguments.  So it could only be argued for arity-0 functions.  And if the function doesn't return the same value every time, you're subject to some semantic questions.</p>
<p>I think that the answer here is that "accessor" functions (getter/setter) wouldn't count in this, if they existed.  They would use the tuple syntax but stay "behind the scenes".</p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/weird-idea-lib-append-runs-but-lib-append-doesnt/1902">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/weird-idea-lib-append-runs-but-lib-append-doesnt/1902</link>
          <pubDate>Thu, 28 Jul 2022 02:04:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1902</guid>
          <source url="https://forum.rebol.info/t/weird-idea-lib-append-runs-but-lib-append-doesnt/1902.rss">Weird Idea: LIB/APPEND Runs, but LIB.APPEND Doesn&#39;t?</source>
        </item>
        <item>
          <title>Attack of the Activated Actions</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Here's something seemingly-simple that a newcomer to Redbol might attempt:</p>
<blockquote>
<p>TASK: Write a function TWOSIE? that...</p>
<ul>
<li>returns true if a value is the INTEGER! of 2, or a BLOCK! of length 2</li>
<li>returns false otherwise</li>
</ul>
</blockquote>
<hr>
<pre><code>twosie?: func [x] [          ; Ren-C calls this LAMBDA, due to no RETURN
    to-logic any [
        x = 2                ; will also pick up DECIMAL!, since 2 = 2.0
        all [
            block? x
            2 = length? x    ; length at current position, not total 
        ]
    ]
]
</code></pre>
<hr>
<p>An "experienced" Redbol user would point out what happens when you pass a FUNCTION!.</p>
<pre><code>red&gt;&gt; twosie? :append
*** Script Error: = operator is missing an argument
*** Where: =
*** Stack: twosie? to-logic 
</code></pre>
<p>If <strong>x</strong> turns out to be a FUNCTION!, it is invoked by the references inside the body.  Which can cause unwanted side effects, as well as arbitrarily cryptic errors.</p>
<h2><a name="p-6174-how-was-this-mitigated-1" class="anchor" href="https://forum.rebol.info#p-6174-how-was-this-mitigated-1"></a>How Was This Mitigated?</h2>
<p>You <em>could</em> restrict the set of accepted types, and exclude functions.  But if you make it only accept INTEGER! and BLOCK! that undermines the aspect that the function's job is to do testing.</p>
<p>Doing it "right" is annoying, putting colons on every access...possibly omitting some when the value is in a context where the program logic would say it can't be a function at that point.</p>
<pre><code>twosie?: func [x] [
    to-logic any [
        :x = 2
        all [
            block? :x
            2 = length? :x       ; :x is optional, as known to be a BLOCK! here
        ]
    ]
]
</code></pre>
<p>Sometimes, people would minimize the number of GET-WORD!s needed by short-circuiting a test for FUNCTION! first:</p>
<pre><code>twosie?: func [x] [
    if function? :x [return false]
    to-logic any [
        x = 2
        all [
            block? x
            2 = length? x
        ]
    ]
]
</code></pre>
<p>This is fairly unsatisfying as well.  It breaks easily if someone reorganizes the code and doesn't realize the test has to come first, or if there has to be additional handling and skipping all the code that uses the variable isn't the desired semantic.</p>
<p><strong>This situation is a tax on users, who are continuously torn between writing obvious code that is broken... vs. cluttered code that winds up being made more brittle due to the maintenance of the clutter.</strong></p>
<p>It would clearly be ideal if the obvious code was also correct.</p>
<h2><a name="p-6174-the-nuanced-compromise-of-isotopic-actions-2" class="anchor" href="https://forum.rebol.info#p-6174-the-nuanced-compromise-of-isotopic-actions-2"></a>The Nuanced Compromise Of Isotopic ACTION!s</h2>
<p>Something that occurred to me was to ask what would happen if there were two kinds of actions:</p>
<ul>
<li>
<p>ACTION! isotopes, which would run if they were referenced via a WORD! or TUPLE!</p>
</li>
<li>
<p>Plain ACTION!s, which would be inert when accessed by WORD!</p>
</li>
</ul>
<p><strong>An obvious <em>good</em> part of this idea would be that a "normal" argument to a function would never be able to be an isotope (solving the problems outlined above).</strong></p>
<p><strong>An obvious <em>questionable</em> part of this idea is introducing another state to worry about.</strong></p>
<p>I've implemented it--though it is a radical change affecting kind of everything.  :-/  There are certainly a lot of questions raised and details to come up.</p>
<p>Something to realize is that there's a fundamental complexity coming from the fact that Rebol wants WORD! references to execute actions automatically much of the time.  But you still have a lot of places that want to talk about values "as-is".  We cannot "wish away" that complexity...only reshape it.</p>
<p><strong>But I think the ability to have obviously-written code in cases like TWOSIE? tips the balance.</strong>  I don't know that meta-code gets truly any harder to write, it just gets <em>different</em>...while the simple examples work without GET-WORD!s.</p>
<p>I'll use this thread to document differences to know about.</p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/attack-of-the-activated-actions/1900">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/attack-of-the-activated-actions/1900</link>
          <pubDate>Wed, 27 Jul 2022 05:01:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1900</guid>
          <source url="https://forum.rebol.info/t/attack-of-the-activated-actions/1900.rss">Attack of the Activated Actions</source>
        </item>
        <item>
          <title>FIND and SELECT polymorphism</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>In Rebol2, you can run FIND on OBJECT! as well as on BLOCK!:</p>
<pre><code>rebol2&gt;&gt; obj: make object! [a: 10 b: 20]

rebol2&gt;&gt; find obj 'a
== true

rebol2&gt;&gt; find obj 'asdf
== false
</code></pre>
<p>I'll point out that <a href="https://github.com/red/red/commit/7b1eeb76a6eb2c5c31e8407637fea5664ace61c2">Red does not support FIND on OBJECT!, and that was intentional</a>.   There's <a href="https://gitter.im/red/red?at=5f134373564e6b39f5655c0f">no real explanation</a> other than than something approximating <em>"objects and bitsets don't support a lot of series operations because they don't necessarily make sense"</em>.</p>
<p>But Red allows FIND on maps, for some reason?</p>
<pre><code>red&gt;&gt; m: make map! [a 10]
== #(
    a: 10
)

red&gt;&gt; find m 'a
== a
</code></pre>
<h3>Is This A Polymorphism You Can Even Use?</h3>
<p>There's no real clarity in OBJECT!/BLOCK! duality.  <a href="https://forum.rebol.info/t/block-and-object-parity-in-pathing-picking/1086">I've tried to invent some out of the murk, but come up short.</a></p>
<p>We might ask ourselves:</p>
<p><strong>Has there ever been a situation where you've had something--you didn't know what it was, either an OBJECT! or a BLOCK!--and your generic code can meaningfully use a FIND call on that thing?</strong></p>
<p>I can't imagine the answer to that is yes.  <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=9" title=":roll_eyes:" class="emoji" alt=":roll_eyes:"></p>
<p>BUT... what about something you didn't know if it was an OBJECT! or a MAP! ?</p>
<p>You can pass a WORD! to IN for an OBJECT!, and get either a bound word back in that object or NULL.  But you can't use IN on a MAP.</p>
<p>So the only polymorphic operators you can use to determine if something is in either an OBJECT! or a MAP! these days are FIND and SELECT.  Ren-C has the advantage that SELECT returns NULL if-and-only-if something isn't in a map or object, so even if you don't need the selected item you can use it.</p>
<h3>
<em>Some</em> Line Of Argumentation Might Support Rebol2's Behavior</h3>
<p>To truly generalize FIND, you could consider it to be with respect to an iterator... e.g. <a href="https://en.cppreference.com/w/cpp/algorithm/find">how C++'s find works</a>.</p>
<p>We might then look to FOR-EACH to see what it would give you if you asked it for a generic "something".  R3-Alpha supports this (not Rebol2 or Red):</p>
<pre><code>r3-alpha&gt;&gt; obj: make object! [a: 10 b: 20]

r3-alpha&gt;&gt; foreach something obj [print mold something]
a
b
</code></pre>
<p>So maybe if all of that was built on some common infrastructure, you could build a rationale for why searching keys-only made sense for FIND in an object.</p>
<p><em>But it's not built on any common infrastructure, so it's just extra random code.</em></p>
<h3>Moreover, what About BITSET! ?</h3>
<p>Above I made a potential case for seeing FIND as applying to the keys of an object.  But... BITSET!?</p>
<p>If you say <strong>bs: make bitset! 8</strong> and then <strong>bs.4: true</strong>, you're making something kind of like a block:</p>
<pre><code>[0 0 0 1 0 0 0 0]
</code></pre>
<p>So semantically, why would <strong>find bs 4</strong> be true?  Where's the 4?</p>
<p>I think what this really is more like is a positional PICK <em>(which makes sense because <strong>bs.4: true</strong> is running the code <strong>poke bs 4 true</strong>, and <strong>bs.4</strong> acts as <strong>pick bs 4</strong>)</em></p>
<p>But..it may be a potentially interesting polymorphism to think of a bitset as a mapping from integers to LOGIC!.  You might swap in something that is using a BITSET! to use a MAP!.  So SELECT with integer <em>could</em> be coherent here.</p>
<p>I think PICK is the best choice, though.</p>
<h3>Anyway...I'm removing FIND on Maps/Objects/Bitsets for Now...</h3>
<p>For the moment, I think that <strong>did select</strong> or <strong>didn't select</strong> are the best invariant ways of detecting if things are in objects or maps.   (Or use with ELSE/THEN)</p>
<p>This leaves FIND as something that might be more dialected, with options that let you search the values and not just the keys (maybe search deeply?)</p>
<p>Also it saves us from returning the kind of hokey idea of "true or null".  I'm suspicious of most functions that are in situations where they only return true or null, anyway.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/find-and-select-polymorphism/1879">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/find-and-select-polymorphism/1879</link>
          <pubDate>Thu, 14 Jul 2022 02:21:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1879</guid>
          <source url="https://forum.rebol.info/t/find-and-select-polymorphism/1879.rss">FIND and SELECT polymorphism</source>
        </item>
        <item>
          <title>Should Void be Offered to Predicates (for REDUCE, ANY/ALL, etc.)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>There's an option to pass a function to some things, to help avoid needing to write the basic logic of the function over again if you just want some difference.  So if you want a negating version of ANY you can say:</p>
<pre><code>&gt;&gt; any/predicate [1 + 2 null 3 + 4] :not
== ~null~  ; isotope (decays to null)
</code></pre>
<p>There you have a negated form of ANY.  You could specialize that:</p>
<pre><code>&gt;&gt; any-not: specialize :any [predicate: :not]
== #[action! {any-not} [block]]

&gt;&gt; any-not [1 + 2 null 3 + 4] then [print "Look, it worked!"]
Look, it worked!
</code></pre>
<p>It works with THEN and ELSE thanks to isotopes: a negating form of ANY that returns you an indicator of what the false thing was, while still being able to let you run a THEN or ELSE clause that has the expected semantics.  So even though the thing that triggered the short circuit was a NULL, the isotope form was returned and allowed to run the THEN.</p>
<p><strong>But what if there's a void entry, should your predicate function find out about it?</strong></p>
<pre><code>&gt;&gt; reduce/predicate [1 + 2 3 + 4] func [x] [return x * 10]
== [30 70]

&gt;&gt; reduce [1 + 2 if false [&lt;a&gt;] 3 + 4]
== [3 7]

&gt;&gt; reduce/predicate [1 + 2 if false [&lt;a&gt;] 3 + 4] func [x] [return x * 10]
; ...???...
</code></pre>
<p><strong>Given that the whole point of predicates is to reuse the work of the core function, it would seem like one of those pieces of work is filtering out the void expressions.</strong></p>
<p>So I think it's pretty clear the above should be <strong><code>== [30 70]</code></strong> with no error given.</p>
<p>But what if the function's argument was ^META?  Does that change things?</p>
<pre><code>&gt;&gt; reduce/predicate [1 + 2 if false [&lt;a&gt;] 3 + 4] func [^x] [...]
; ...???...
</code></pre>
<p>Or does it have to explicitly say by contract it is interested in voids?</p>
<pre><code>&gt;&gt; reduce/predicate [1 + 2 if false [&lt;a&gt;] 3 + 4] func [^x [&lt;void&gt; any-value!]] [...]
; ...???...
</code></pre>
<p>It's a pretty fringe feature either way.  I think that in REDUCE's case, we can say that if you really want to get control of every expression...then using REDUCE-EACH with ^META seems a bit more explicit that you want EACH.</p>
<p>I'm going to say for the moment that the predicate in REDUCE, ANY, and ALL will never be offered voids...and that's just part of the benefit of reusing the work.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-void-be-offered-to-predicates-for-reduce-any-all-etc/1872">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-void-be-offered-to-predicates-for-reduce-any-all-etc/1872</link>
          <pubDate>Sun, 10 Jul 2022 17:16:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1872</guid>
          <source url="https://forum.rebol.info/t/should-void-be-offered-to-predicates-for-reduce-any-all-etc/1872.rss">Should Void be Offered to Predicates (for REDUCE, ANY/ALL, etc.)</source>
        </item>
        <item>
          <title>Pushing the Potential of Polyglot Polymorphic DO</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p><strong>The brevity of DO is a strength that makes it seem natural to be polymorphic.</strong></p>
<p>I thought it was very wasteful that when Rebol2 and Red's DO saw something it didn't recognize, it would just drop out:</p>
<pre><code>rebol2&gt;&gt; do 1020
== 1020

rebol2&gt;&gt; do &lt;useless&gt;
== &lt;useless&gt;
</code></pre>
<p>Pinning people's expections to this behavior--to where they write code that relies on it--is awful.</p>
<p>There are plenty of things we can imagine for this undiscovered space.  (Soon it's planned that the ReplPad will use shorthands like <strong>do 3</strong> to mean "run the code in editor tab <span class="hashtag">#3</span>")</p>
<h2>Could We (or Should We?) Take DO's Polymorphism Further?</h2>
<p>I'd been thinking that it might be able to "run" things that are not even Rebol.   This would mean that you could <strong>do %foo.js</strong> and run JavaScript, or <strong>do %bar.css</strong> and import CSS.</p>
<p><em>(But then again, JavaScript has modules vs. ordinary code... so maybe <strong>import %foo-module.js</strong> would also be an interesting polymoprhism to have as well?)</em></p>
<p>We are getting some experience with this and the ReplPad.  And what experience is telling us is that it's really ugly to have to use names like JS-DO and CSS-DO.  Plus it puts stress on coming up with and remembering the names (was it JS-DO or DO-JS?)</p>
<p>With FRAME!s we even have the option of building things that defer execution.  Some simple pseudocode using current JS-DO to give the idea.</p>
<pre><code>load: enclose :lib.load func [frame]
    uparse try match [url! file!] frame.source then [
        let result: make frame! :js-do
        result.source: frame.source
        return result
   ]
   do frame
]

&gt;&gt; thing: load https://example.com/helloworld.js  ; doesn't run JS yet

&gt;&gt; do thing  ; would run it here
</code></pre>
<p>In today's Ren-C, the sky is the limit for many such things.</p>
<h2>I Think DO of a TEXT! String Should Be Dropped (Reclaimed)</h2>
<p>When you DO a BLOCK!, you know that block has been incarnated through some series of steps that bound it and brought it to life.</p>
<p>When you DO a TEXT! string, you have nothing to go on but the string itself.  It represents an incomplete thought, and it's hard to think of a "good" answer for what the semantics of that should be.</p>
<p>One tricky issue we've talked about is how module headers in text strings are handled:</p>
<pre><code>do "Rebol [Type: module] export thing: {This does not work}"
</code></pre>
<p>Historically what happens is that Rebol is a synonym for the SYSTEM object, so that evaluates an inert OBJECT! as a first step.  Then it evaluates the inert block [Type: module].  You don't have any of the LOADer mechanics in there.</p>
<p>So basically, the above is <em>completely</em> broken.</p>
<p>We're facing another problem of being short on strings to say where code should come from.  It's important to have a way to distinguish running paths relative to <code>system.script.path</code> as opposed to WHAT-DIR, and strings seem a reasonable way to encode that intent:</p>
<pre><code>do %../path/relative/to/what-dir
do "../path/relative/to/system.script.path"

import %../path/relative/to/what-dir
import "../path/relative/to/system.script.path"
</code></pre>
<p>When you add all this in with the spirit of language agnosticism, that makes interpreting TEXT! as being specifically Rebol language text is presumptuous.</p>
<p>This all makes going through <strong>do load</strong> to use text as source seem like a much more attractive option than trying to figure out how to push all of LOAD's options onto DO.</p>
<pre><code>&gt;&gt; do "print {Hello World}"
Hello World

&gt;&gt; do load "print {Is DO LOAD that much worse for Hello World?}"
Is DO LOAD that much worse for Hello World?
</code></pre>
<p><em>Of course, I will make the usual point that you will be able to overload this if you wish.</em>   Redbol will still DO strings, and you can decide you're never going to use the script-relative path importing (or do it another way).</p>
<p>But I think DO LOAD is a small price to pay for solving a bunch of irritating problems.</p>
<h2>I Think We Should Drop the /NEXT Option From DO</h2>
<p>Clearly a DO/NEXT of a JavaScript file doesn't make sense.  But does it make sense for a Rebol file, really?</p>
<p>Rebol2 returns a BLOCK! with a pair of the result and remaining code, which works for blocks:</p>
<pre><code>rebol2&gt;&gt; foo: [print "Some" print "Block"]

rebol2&gt;&gt; do/next foo
Some
== [unset [print "Block"]]
</code></pre>
<p>But for functions, it just ignores the /NEXT:</p>
<pre><code>rebol2&gt;&gt; foo: func [] [print "Some" print "Function"]

rebol2&gt;&gt; do/next :foo
Some
Function
</code></pre>
<p>Red gives nonsense, as usual...it returns the value of the function back and doesn't DO it at all</p>
<pre><code>red&gt;&gt; foo: func [] [print "The usual" print "nonsense"]

red&gt;&gt; foo
The usual
nonsense

red&gt;&gt; do/next :foo 'pos
== func [][print "The usual" print "nonsense"]

red&gt;&gt; pos
*** Script Error: pos has no value
</code></pre>
<p><strong>So I'm proposing the /NEXT functionality be solely in EVAL, and have EVAL run only on ANY-ARRAY!</strong></p>
<p>If you DO, that means fire-and-forget.</p>
<h2>Narrowing DO Use Is Good For Security / Avoiding Big Mistakes</h2>
<p>DO is pretty powerful.  When you say DO VALUE that could be a URL!...fetching arbitrary code off the internet and running it.</p>
<p>Of course, DO of a BLOCK! can contain code that does arbitrary things.  But if you're writing code that's supposed to all run on your machine and be self contained, it would be nice if you could be reasonably sure that you aren't running code off the internet if you didn't use DO or IMPORT.</p>
<p>So making it possible to get normal casual work done locally without ever needing to call DO seems desirable.  That is why EVAL has both "do to end" and "do step" semantics:</p>
<pre><code> &gt;&gt; eval [1 + 1 print "Modes"]
 Modes

 &gt;&gt; [value pos]: eval [1 + 1 print "Modes"]
 == 2

&gt;&gt; pos
== [print "Modes"]
</code></pre>
<p>So you can use EVAL where you would have used DO of a BLOCK!, and you can use the /NEXT mode as a multi-return (or a refinement, if you choose)</p>
<pre><code>&gt;&gt; eval/next [1 + 1 print "Modes"] 'pos
== 2

&gt;&gt; pos
== [print "Modes"]
</code></pre>
<p><strong>This raises into question if DO of a BLOCK! needs to be a way to run code at all.</strong>  It could be dialected, and let you supply arguments:</p>
<pre><code>do [%script-taking-args.reb 1 2 3]</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/pushing-the-potential-of-polyglot-polymorphic-do/1846">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/pushing-the-potential-of-polyglot-polymorphic-do/1846</link>
          <pubDate>Mon, 20 Jun 2022 10:29:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1846</guid>
          <source url="https://forum.rebol.info/t/pushing-the-potential-of-polyglot-polymorphic-do/1846.rss">Pushing the Potential of Polyglot Polymorphic DO</source>
        </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Semantics - AltRebol</title>
    <link>https://forum.rebol.info/c/development/semantics/55</link>
    <description>Topics in the &#39;Semantics&#39; category While the &quot;Internals&quot; discusses the bits and bytes of how things are implemented, this category is for discussing things design questions of the language... like what &lt;strong&gt;do []&lt;/strong&gt; should return.</description>
    
      <lastBuildDate>Fri, 03 Mar 2023 21:23:09 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/semantics/55.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Correct Formulation of ME and MY</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>The ME function is used with enfix to allow you to avoid repeating the name of a variable:</p>
<pre><code>&gt;&gt; variable: 10

&gt;&gt; variable: me + 1
== 11

&gt;&gt; variable
== 11
</code></pre>
<p>So that's the same as if you'd written <strong>variable: variable + 1</strong>.</p>
<p>There's an analogous operation for non-enfix functions called MY.</p>
<pre><code>&gt;&gt; block: [a b c]

&gt;&gt; block: my next
== [b c]

&gt;&gt; block
== [b c]
</code></pre>
<p>So the same if you had written <strong>block: next block</strong>.</p>
<h2>Here Is The "Naive" Macro Implementation of ME</h2>
<pre><code>me: enfixed macro [
    'left [set-word! set-tuple!]
    'right [word! tuple! path!]
][
    reduce [left, plain left, right]
]
</code></pre>
<p>So the macro is looking for a SET-WORD! or SET-TUPLE! on the left, and then something indicating the action to run on the right.  It replaces the whole sequence with what was on the left, then a plain WORD! or TUPLE! version of what was on the left, and then what's on the right.</p>
<p>MY is done similarly, just with <strong>reduce [left, right, plain left]</strong> to put the repeated term after the call.</p>
<p>This is naive for two reasons:</p>
<ul>
<li>
<p>It doesn't check that what the RIGHT parameter looks up to is an action</p>
</li>
<li>
<p>If the SET-TUPLE! in LEFT has a GROUP! in it, then it will be executed twice.</p>
</li>
</ul>
<h2>Here is A "Non-Naive" Implementation of ME</h2>
<pre><code>macro [
    'left [set-word! set-tuple!]
    'right [word! tuple! path!]
    &lt;local&gt; value
][
    [left value]: resolve left  ; avoid double-evaluation
    :['set left meta value ensure action! get right]
]
</code></pre>
<p>The RESOLVE function is used to turn a TUPLE! or PATH! with groups in it into an inert representation:</p>
<pre><code> &gt;&gt; blk: [a b [c d]]

 &gt;&gt; resolve 'blk.(print "hi", 1 + 2).2
 hi
 == @[blk 3 2]
</code></pre>
<p>GET and SET accept these blocks as an alternative to words/tuples to be used to describe what to set or get.</p>
<p>It has to use a BLOCK! representation because not all things can be represented in paths that can be used with picking (note this implies you cannot pick with isotopes, otherwise not all blocks would be resolvable).</p>
<p>So long as RESOLVE is walking the path, you can ask it to give you back the value of what's there.</p>
<h2>But the non-naive version triggers a binding bug...</h2>
<p>It's also rather slow.  In trying to prioritize, it may be better to just document the right answer, as I've done here... :-/</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/correct-formulation-of-me-and-my/2020">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/correct-formulation-of-me-and-my/2020</link>
          <pubDate>Fri, 03 Mar 2023 21:23:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2020</guid>
          <source url="https://forum.rebol.info/t/correct-formulation-of-me-and-my/2020.rss">Correct Formulation of ME and MY</source>
        </item>
        <item>
          <title>Picking ACTION!s from BLOCK!s In The Age of Isotopes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>In <strong><a href="https://forum.rebol.info/t/reds-design-issues-wiki/1282">Red's Design Questions wiki</a></strong>, they bring up the issue of why picking functions out of blocks runs them:</p>
<pre><code>red&gt;&gt; block: reduce [does [print "Evaluated."]]
  == [func [][print "Evaluated."]]

red&gt;&gt; equal? block/1 first block
Evaluated.  ; d'oh
== false
</code></pre>
<p><a href="https://gitter.im/red/red?at=5c782ca0c1cab53d6f53dd6d">In the Gitter conversation</a>, Boris calls it a "shady area" that they can't get out of "under the current semantic model".  He suggests it is clear that <strong><code>block/1</code></strong> should not run an action, but possible that <strong>block/word</strong> would mean to.</p>
<p>They contemplate the idea that <strong>block/1</strong> would not run the action, but pick it:</p>
<pre><code>red&gt;&gt; block: reduce [does [print "Evaluated."]]
  == [func [][print "Evaluated."]]

red&gt;&gt; equal? block/1 first block  ; hypothetical behavior
== false
</code></pre>
<p><strong>I will argue this doesn't really help you much, the problem just becomes one step removed.</strong>  Quite often people are picking things out of blocks to put them in variables, and you'll just get bit there instead:</p>
<pre><code>red&gt;&gt; otherblock: copy []
== []

red&gt;&gt; temp: block/1
== func [][print "Evaluated."]

red&gt;&gt; append otherblock temp
Evaluated.  ; d'oh
== [unset]  ; double d'oh
</code></pre>
<h2>Isotopes Bring The Better Semantic Model!</h2>
<p>In Ren-C's concept (as I'm working on it), the only actions that will run from a word reference are those that are isotopic actions.  And FUNC or DOES creates an isotopic action.</p>
<p>So you would be stopped from making an illegal block up front:</p>
<pre><code>&gt;&gt; block: reduce [does [print "Evaluated."]]
** Script Error: Invalid use of ~#[action! []]~ isotope
</code></pre>
<p>You can put quasi-ACTION!s, plain ACTION!s, and quoted actions in blocks.  Just not isotopic ones.</p>
<p>Whichever you choose, the equality test will work... and picking out a value into a variable will give you an inert variable to work with, that can be used with things like append!</p>
<pre><code>&gt;&gt; block: reduce [reify does [print "Evaluated."]] 
== [~#[action! []]~]

&gt;&gt; equal? block.1 first block
== ~true~  ; isotope  &lt;-- didn't run and print "Evaluated", yay!

&gt;&gt; otherblock: copy []
== []

red&gt;&gt; temp: block.1
== ~#[action! []]~

red&gt;&gt; append otherblock temp
== [~#[action! []]~]   ; &lt;-- didn't run and gave sensible block out
</code></pre>
<p>I used REIFY there and got a quasi-action.  BUT which would you rather put in the block: a quasi-action or a plain one?  This depends on what you plan to do with the block.  A plain action will execute when encountered by the evaluator, while a quasi-action will evaluate to an isotopic action--suitable for assigning via SET-WORD! when you meant to make that word dispatch the function when referenced.</p>
<p>My leaning is to say that either form can be used with APPLY, RUN, or the terminal path form:</p>
<pre><code>&gt;&gt; block: reduce [reify does [print "Evaluated."]] 
== [~#[action! []]~]

&gt;&gt; run block.1
Evaluated.

&gt;&gt; block: reduce [concretize does [print "Evaluated."]] 
== [#[action! []]]

&gt;&gt; apply block.1 []
Evaluated.
</code></pre>
<p><em>(See post on <a href="https://forum.rebol.info/t/reify-vs-meta-vs-something/2001">difference between REIFY and CONCRETIZE</a>, and the search for a better term...)</em></p>
<p>If you want to pick an action out of a block and put it into a variable, where it will execute from that variable, there is the RUNS transformer.  It will turn a quasi or plain ACTION! into an action isotope:</p>
<pre><code> &gt;&gt; active-var: runs block.1
 == ~#[action! {active-var} []]~  ; isotope  &lt;-- note: also cached name, neat!

 &gt;&gt; active-var
 Evaluated.
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/clap.png?v=9" title=":clap:" class="emoji only-emoji" alt=":clap:"></p>
<p>You can use UNMETA more generically to get an isotope back from any quasi-form (not just actions), or ISOTOPIC to get an isotope from a plain form.</p>
<h2>The Invariant Is What Counts, Here!</h2>
<p>The mountain that has been climbed is that we can now say that for any block, this is true:</p>
<pre><code>block2: collect [
    for-each item block1 [keep item]
]

assert [equal? block1 block2]
</code></pre>
<ul>
<li>
<p>I've just covered that there are no isotopic actions to implicitly execute; you'd get an error trying to put them in the block.</p>
</li>
<li>
<p>There are no blocks/groups/paths that will splice into the target, because splicing requires an explicit conversion to an isotope.</p>
</li>
<li>
<p>There are no "unsets" to trip on that you can find in a block, because the state conveying "unsetness" (nihil) is an isotope.</p>
</li>
</ul>
<p>Of course with objects, it's going to be a different story.  I think we'll still want some safeguards:</p>
<pre><code>for-each [key value] object [...]  ; will error when value is action

for-each [key :value] object [...]  ; will allow action isotopes as-is

for-each [key ^value] object [...]  ; will give a meta value
</code></pre>
<p>A key problem here is I'm wondering how much to cross purposes of GET-WORD! between action disarming and the other isotopic states.  But, it just takes time to work through.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/picking-action-s-from-block-s-in-the-age-of-isotopes/2002">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/picking-action-s-from-block-s-in-the-age-of-isotopes/2002</link>
          <pubDate>Fri, 06 Jan 2023 03:16:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2002</guid>
          <source url="https://forum.rebol.info/t/picking-action-s-from-block-s-in-the-age-of-isotopes/2002.rss">Picking ACTION!s from BLOCK!s In The Age of Isotopes</source>
        </item>
        <item>
          <title>SPLIT Semantics</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p><a href="https://gitter.im/red/red?at=63523097f00b697fec501c7a">On Red Gitter</a>, it was discussed "which of the following is 'correct'":</p>
<pre><code>Red&gt; split "" ","
== [""]

R3&gt; split "" ","
== []
</code></pre>
<p>Rebolek thinks R3 is right.  Boris says:</p>
<blockquote>
<p>I don't think there's a correct answer, just choices. I prefer the Red version because:<br>
it strictly follows the rule: `number-of-segments = 1 + number-of-delimiters", no exceptions, so it's easier to reason about</p>
<p>it should be able thus to preserve the type in case one wants to rejoin it later (that it doesn't is a bug, try split %"" ",")</p>
</blockquote>
<p>So there's a couple of ways to look at it.</p>
<p>But I have a philosophy about these things where I want edge cases to be "noisy", because usually they require special handling.  I might even say:</p>
<pre><code>&gt;&gt; split "" ","
== ~null~  ; isotope</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/split-semantics/1998">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/split-semantics/1998</link>
          <pubDate>Thu, 22 Dec 2022 04:04:52 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1998</guid>
          <source url="https://forum.rebol.info/t/split-semantics/1998.rss">SPLIT Semantics</source>
        </item>
        <item>
          <title>Should ELSE be FALSE-reactive? (in addition to void and null?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Historically one might have asked why ELSE doesn't think falseness is something worth reacting to:</p>
<pre><code>&gt;&gt; 1 = 2 else [print "Why not print?"]
Why not print?  ; seems not so bad, right?
</code></pre>
<p>The idea was panned, because <code>#[false]</code> was <em>a value</em> and ELSE's main job was to react to the situation of a branching construct that didn't produce a value:</p>
<pre><code>&gt;&gt; math-broken: if 1 = 1 [false] else [true]
== #[false]  ; if this were #[true], math seems broken
</code></pre>
<p>But now, the actual falsey <code>~false~</code> state is isotopic.  And some years of struggle with the parallel problem of what to do with branches that returned "non-values" bore curious fruit: a box that could hold a "non-value" like a null.</p>
<pre><code>&gt;&gt; if false [null]
== ~null~  ; isotope
     ^-- there is no result

&gt;&gt; if true [null]
== ~[~null~]~  ; isotope
     ^-- there is a result and it is null
</code></pre>
<p>Isotopic blocks containing one element will decay to that one element in most situations.  But ELSE is sensitive to the difference via a ^META parameter.  If someone has gone through the effort to box up a null or void vs leave it as a plain isotope, the ELSE assumes it's a meaningful result and should pass it on.  And conditional expressions know to do this; they box up nulls and voids if they are produced by executing branches.</p>
<p><strong>The same technique could work for false.</strong></p>
<pre><code>&gt;&gt; if 1 = 1 [false]
== ~[~false~]~  ; isotope

&gt;&gt; if 1 = 1 [false] else [true]
== ~[~false~]~  ; isotope

&gt;&gt; math-broken: if 1 = 1 [false] else [true]
== ~false~  ; isotope
</code></pre>
<p>It's barely any additional work for conditionals to do on top of what they're doing already.  Although it can result in branches producing false to cost a small bit more than they do today <em>(I wouldn't worry about it, these single element boxes could be optimized if it was a problem)</em></p>
<p>But I don't know how useful it would actually be.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=9" title=":man_shrugging:" class="emoji" alt=":man_shrugging:">  Just writing down the observation.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/should-else-be-false-reactive-in-addition-to-void-and-null/1991">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-else-be-false-reactive-in-addition-to-void-and-null/1991</link>
          <pubDate>Sun, 27 Nov 2022 06:00:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1991</guid>
          <source url="https://forum.rebol.info/t/should-else-be-false-reactive-in-addition-to-void-and-null/1991.rss">Should ELSE be FALSE-reactive? (in addition to void and null?)</source>
        </item>
        <item>
          <title>Line Continuation and Arity Bugs: Thoughts?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>At one point in time, there was no way to pass something to RETURN that represented a VOID.  Because voids completely vanished.  If you had a function that took an argument--and a void thing came after it--the evaluator would just keep retriggering until it found a value or hit the end.</p>
<p>This led to the only way of being able to return a void to be to have truly nothing after it.  So RETURN became effectively arity-0 or arity-1.  If you passed it no argument, it would consider itself VOID.  It even had the nice property of being able to chain functions that themselves might be void.</p>
<p>Given that RETURN was doing this, some other functions followed suit.  QUIT could take an argument or not.  CONTINUE could as well.</p>
<h2>But I Just Got Bit By a Variadic QUIT Bug</h2>
<p>Without thinking about it, I tried to end some code prematurely by injecting a quit:</p>
<pre><code> some stuff I wanted to run

 quit  ; added this

 some stuff I wanted to avoid running
</code></pre>
<p>And that QUIT ran the stuff I didn't want to run anyway, because it was variadic.</p>
<h2>My Kneejerk Reaction Was To Kill The Variadicness</h2>
<p>The original case of RETURN has changed, because so-called "non-interstitial invisibility" is dead.  You can only make expressions void in their totality--not when used as arguments.  Doing otherwise caused more harm than good.</p>
<p>Hence <strong><code>return void</code></strong> is a perfectly fine thing to write <em>(or <strong><code>return ~</code></strong> if you prefer the quasiform of void, which you probably don't, but it might come in handy somewhere if you've defined VOID to mean something else)</em></p>
<p>I'd been thinking that argument-less RETURN would thus go back to returning the default unfriendly value (currently called NONE, a <strong><code>~[]~</code></strong> isotope, e.g. a parameter pack with absolutely no values in it).  But maybe we shouldn't support argument-less RETURN at all.</p>
<h2>But Variadics Can Be Neat</h2>
<p>I guess RETURN could always take an argument, and we go back to CONTINUE/WITH and QUIT/WITH.</p>
<p>But those are uglier.</p>
<p>We might question the behavior of the system just randomly slurping up arguments from enusing lines?  Especially when APPLY has such a convenient notation now, of <strong>some-func/ [...]</strong></p>
<p>From a usability perspective, there's certainly a lot of potential for error in getting the arity wrong.  Having it be more strict could catch bugs, and make it more likely that variadic arity is being used correctly.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/line-continuation-and-arity-bugs-thoughts/1965">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/line-continuation-and-arity-bugs-thoughts/1965</link>
          <pubDate>Wed, 14 Sep 2022 17:08:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1965</guid>
          <source url="https://forum.rebol.info/t/line-continuation-and-arity-bugs-thoughts/1965.rss">Line Continuation and Arity Bugs: Thoughts?</source>
        </item>
        <item>
          <title>Revisiting TO and THRU</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>If you asked someone to count "from 1 to 10", how many people would stop at 9?</p>
<p>I'd say most wouldn't.  So if you wrote:</p>
<pre><code>for x [1 to 10] [print [x]]
</code></pre>
<p>What should that do?  I think if you showed it to people they would expect 10 to be included.</p>
<p>But PARSE has historically discerned this via TO (not including the limit) and THRU (including the limit).</p>
<p>Is that right?  Should TO be inclusive, and some other word along the lines of "UPTO" be used?</p>
<p>I almost feel like the words are slippery enough that we could bend them so that THRU was the <em>non</em>-inclusive version.  :-/</p>
<p>In PARSE, if TO included the limit, you could go up-to-but-not-include by using AHEAD with it: <strong><code>to ahead "A"</code></strong></p>
<p>We could say that UNTIL would keep advancing until it hit the rule and then stopped short of it: <strong><code>until "A"</code></strong>.</p>
<p>Would that convey the right thing in the FOR case?</p>
<pre><code>&gt;&gt; for x [1 until 10] [print [x]]
1
2
3
4
5
6
7
8
9</code></pre>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/revisiting-to-and-thru/1961">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/revisiting-to-and-thru/1961</link>
          <pubDate>Tue, 06 Sep 2022 16:56:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1961</guid>
          <source url="https://forum.rebol.info/t/revisiting-to-and-thru/1961.rss">Revisiting TO and THRU</source>
        </item>
        <item>
          <title>Should REDUCE Heed SPREAD?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>When <a href="https://forum.rebol.info/t/putting-splicing-intent-on-appended-value/1873/9">suggesting the term SPREAD</a>, <a class="mention" href="/u/rgchris">@rgchris</a> gave this example for REDUCE behavior, which hadn't occurred to me previously:</p>
<pre><code>&gt;&gt; reduce [spread [a b c] [a b c]]
== [a b c [a b c]]
</code></pre>
<p>Nothing about the design makes this happen automatically.  REDUCE has historically errored on isotopes.  So code has to be added to override that.</p>
<p>I'm guessing most people would be in favor of having the splicing behavior.  Arguments that say that there should be a 1:1 correspondence between expressions and values in a REDUCE are already pretty much out the window, since VOID elements vanish (including conditionals that don't take any branch).</p>
<h2>DELIMIT Would Presumably Want It Too</h2>
<p>I've complained in the past that the often random-seeming treatments of blocks in Rebol2 functions like REJOIN lead to problems--and that it would be better if people had to be explicit about their intent.  This offers the ability to "inherit" whatever the enclosing delimiting strategy is, and fold into the existing operation (technically more efficient):</p>
<pre><code>&gt;&gt; block: ["c" "d"]

&gt;&gt; spaced ["a" "b" block]
** Error: BLOCK! not handled by DELIMIT, use SPREAD or desired string conversion

&gt;&gt; spaced ["a" "b" spread block]
== "a b c d"

&gt;&gt; spaced ["a" "b" unspaced block]  ; if you wanted another interpretation
== "a b cd"
</code></pre>
<p>I believe I prefer this over having some default way that blocks behave inside string conversions.  The odds of guessing right are low enough that it's better to have people be explicit.</p>
<p>So...presuming there's no objections....there's an agenda item to fuse together the stackless logic that performs a REDUCE so that it's the same code running in DELIMIT, so I'd probably go ahead and do that and make these things work.</p>
<p><strong>UPDATE circa Oct 2022: This has been done, so you can now use this feature.</strong></p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/should-reduce-heed-spread/1917">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-reduce-heed-spread/1917</link>
          <pubDate>Tue, 16 Aug 2022 04:10:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1917</guid>
          <source url="https://forum.rebol.info/t/should-reduce-heed-spread/1917.rss">Should REDUCE Heed SPREAD?</source>
        </item>
        <item>
          <title>Ideas About a More General Meaning for TRY</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>TRY was changed from a "blank-in, null-out" meaning to use definitional errors.  This allowed NULL to be both the input and the output...without risking inadvertently trapping errors from arbitrary depths.  You'll really be intercepting the error emitted by the function just called:</p>
<pre><code>&gt;&gt; first null
** Error: FIRST on NULL requires use of TRY

&gt;&gt; try first null
; null
</code></pre>
<p>I mentioned something, which was that a "You need a TRY" ERROR! was actually able to carry a payload, saying what the TRY'd outcome value should be.  <em>(The only rule would be that a function emitting such an error should not have any side effects if it emits one of these errors.)</em></p>
<p>If we embrace this, it could really open the doors to what TRY means.  Various constructs could offer meanings for what the TRY actually does:</p>
<pre><code>&gt;&gt; unquote first ['abc]
== abc

&gt;&gt; unquote first [def]
** Error: Can't Unquote Plain WORD!, use TRY if Intentional

&gt;&gt; try unquote first [def]
== def
</code></pre>
<p>I'm sort of leaning to believing that this more general meaning of TRY may be much more interesting than the "null propagating" sense.  There's kind of an explosion of potential for the "couldn't do what you asked me to do, but if that's what you meant..." outcomes.</p>
<p>At one point I suggested it would be nice to be able to have a COLLECT that didn't actually KEEP anything return NULL, so it could be ELSE-reactive.  That meant if you really wanted an empty block, you'd have to do something like <strong><code>any [collect [...], copy []]</code></strong> which was ugly.  But the error could hold a freshly-copied block to be the result of a TRY:</p>
<pre><code>&gt;&gt; collect [keep if false [&lt;not kept&gt;]]
** Error: COLLECT didn't KEEP anything, use TRY if intended

&gt;&gt; try collect [keep if false [&lt;not kept&gt;]]
== []
</code></pre>
<p>There are various technical reasons why ELSE can't be reactive to TRY-style errors.  One fairly important one would be that if you used ELSE with a branching construct, it wouldn't be able to tell the difference between a branch that had a TRY-error and no branch taken:</p>
<pre><code>&gt;&gt; case [true [unquote first [def]]] else [print "Took branch, runs due to UNQUOTE"]
Took branch, runs due to UNQUOTE  ; this would be bad
</code></pre>
<p>But... maybe the trick could be that if you pass ELSE a function that takes an argument, it assumes that means you handle TRY-style errors?  (Because otherwise it could only be void/null... why take an arg?)</p>
<pre><code>&gt;&gt; (unquote first [def]) else arg -&gt; [print ["TRY error" arg]]
TRY error def
</code></pre>
<p>It's a weird thought.  Anyway, just wanted to write up the TRY concept...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/ideas-about-a-more-general-meaning-for-try/1912">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/ideas-about-a-more-general-meaning-for-try/1912</link>
          <pubDate>Tue, 09 Aug 2022 13:28:03 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1912</guid>
          <source url="https://forum.rebol.info/t/ideas-about-a-more-general-meaning-for-try/1912.rss">Ideas About a More General Meaning for TRY</source>
        </item>
        <item>
          <title>Weird Idea: LIB/APPEND Runs, but LIB.APPEND Doesn&#39;t?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Historical Redbol did not have generic TUPLE!.  So that meant it used paths for everything...whether you were specifying a refinement to a function, or doing a member selection out of an object, or coordinate out of a pair, or...whatever.</p>
<p>So far what Ren-C has done is to shift it such that tuples are for member selection, and pathing is for refinements only.</p>
<p>A new twist is that a terminal-slash in a path (e.g. the last element is a BLANK!) <a href="https://forum.rebol.info/t/apply-ii-the-revenge/1834/7">means "APPLY the action"</a>.  This is especially helpful when wanting to run a non-isotopic action in the new "activated actions" model:</p>
<pre><code>&gt;&gt; block: reduce [reify :print]

&gt;&gt; block.1
== #[action! {print} [line]]

&gt;&gt; block.1/ ["The terminal slash comes in handy!"]
The terminal slash comes in handy!
</code></pre>
<p>So if you have a non-isotopic action in your hand, the slash can run it.  But under the current rules, your arguments and refinements need to go in a BLOCK!.</p>
<h2>Terminal Slashes Could Provide Safety...</h2>
<p>With the above, the pattern you would use to say you were going to run something like APPEND/DUP out of LIB would be this:</p>
<pre><code>&gt;&gt; lib.append/dup [a b c] [d e] 2
== [a b c [d e] [d e]]
</code></pre>
<p>But this means that you're on the hook for simple tuple references running, which you may not have expected:</p>
<pre><code>&gt;&gt; if integer? obj.something [print "What if SOMETHING is an ACTION! isotope?"]
Boo!
** Error: Some error coming from OBJ.SOMETHING running
</code></pre>
<p>One way of stopping this would be to say that if you were going to call a function that was a member of an object, you'd have to use a terminal slash, otherwise you'd get an error.</p>
<pre><code>&gt;&gt; if integer? obj.something [print "Clearer error if it's an ACTION! isotope"]
** Error: OBJ.SOMETHING is an ACTION! isotope, use OBJ.SOMETHING/ if intended
</code></pre>
<p>That would make field selection on the whole feel "safer".  But at the cost of looking at a lot of terminal slashes, and nowadays that also forces you to use APPLY and pass your arguments in a BLOCK!.</p>
<h2>More Succinct: Allow PATH!s to Pick The Action, Too</h2>
<p>If something like <strong>lib.append/dup</strong> is clearly an action (due to the use of refinements) it wouldn't need the terminal slash, like <strong>lib.append/dup/</strong>.  You already know an action is being run.</p>
<p>So what if you said <strong>lib/append</strong> instead of <strong>lib.append/</strong> ?</p>
<p>Of course, under such a rule, <strong>lib/append</strong> becomes conflated with a situation where LIB is a function and you're applying the <strong>/append</strong> refinement.  This does break away from a rule like "slashes always mean refinements".</p>
<p>That <em>kind of</em> sucks...BUT...it's still <em>far</em> less conflated than it was before.  Remember, historical Redbol used slashes for <em>EVERYTHING</em>.</p>
<p>The new rule could be "slashes always mean <em>from here on out, what we're talking about is function invocation"</em>.  So it's either picking a function to run, or narrowing it down by means of a refinement.</p>
<p>The advantage here system-wide would be that you could use field selection without worrying about it, as <strong>foo.bar</strong>, meaning "I want that field and I don't want any functions to run".  If there's no slash, there's no invocation.</p>
<p>I almost feel like the weird exception is worth it, because it would save a lot of bulletproofing that would otherwise be required on objects.  But it's also clearly a bit <em>bent</em>.</p>
<h2>The Other Direction: Terminal Dot as Invocation Suppressor</h2>
<p>There's a possibility for saying "this reference is not an invocation", which could apply to WORD!s and to TUPLE!s alike.  That's the terminal dot.</p>
<pre><code>&gt;&gt; x: append.
** Error: APPEND. reference ends in dot but it's an ACTION! isotope
</code></pre>
<p>It has one downside of kind of being close to being a comma.</p>
<p>But the bigger reason I don't like this is just the mental tax that comes into effect.  It's the same as how I didn't like the creeping desire for correctness, meaning people putting colons in front of things in a fairly ad-hoc way.  We'd like the obvious code to just work.</p>
<p>I think the LIB/APPEND compromise may be worthwhile to get this correctness-by-default situation.</p>
<h2>Possible Objection: Value/Function Invariance?</h2>
<p>We might say that forcing you to distinguish at the callsite whether you are calling a function or not, prevents you from taking something that was a plain value previously, and substituting it with a function that calculates that value.</p>
<p>Under this principle, it's a feature that you "don't know" if <strong>obj.something</strong> is an action isotope or not...and making you commit to which it is by saying <strong>obj/something</strong> is bad.</p>
<p>It's kind of a narrow case--since you <em>have</em> to know at the callsite if it's a function that consumes arguments.  So it could only be argued for arity-0 functions.  And if the function doesn't return the same value every time, you're subject to some semantic questions.</p>
<p>I think that the answer here is that "accessor" functions (getter/setter) wouldn't count in this, if they existed.  They would use the tuple syntax but stay "behind the scenes".</p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/weird-idea-lib-append-runs-but-lib-append-doesnt/1902">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/weird-idea-lib-append-runs-but-lib-append-doesnt/1902</link>
          <pubDate>Thu, 28 Jul 2022 02:04:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1902</guid>
          <source url="https://forum.rebol.info/t/weird-idea-lib-append-runs-but-lib-append-doesnt/1902.rss">Weird Idea: LIB/APPEND Runs, but LIB.APPEND Doesn&#39;t?</source>
        </item>
        <item>
          <title>Attack of the Activated Actions</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Here's something seemingly-simple that a newcomer to Redbol might attempt:</p>
<blockquote>
<p>TASK: Write a function TWOSIE? that...</p>
<ul>
<li>returns true if a value is the INTEGER! of 2, or a BLOCK! of length 2</li>
<li>returns false otherwise</li>
</ul>
</blockquote>
<hr>
<pre><code>twosie?: func [x] [          ; Ren-C calls this LAMBDA, due to no RETURN
    to-logic any [
        x = 2                ; will also pick up DECIMAL!, since 2 = 2.0
        all [
            block? x
            2 = length? x    ; length at current position, not total 
        ]
    ]
]
</code></pre>
<hr>
<p>An "experienced" Redbol user would point out what happens when you pass a FUNCTION!.</p>
<pre><code>red&gt;&gt; twosie? :append
*** Script Error: = operator is missing an argument
*** Where: =
*** Stack: twosie? to-logic 
</code></pre>
<p>If <strong>x</strong> turns out to be a FUNCTION!, it is invoked by the references inside the body.  Which can cause unwanted side effects, as well as arbitrarily cryptic errors.</p>
<h2>How Was This Mitigated?</h2>
<p>You <em>could</em> restrict the set of accepted types, and exclude functions.  But if you make it only accept INTEGER! and BLOCK! that undermines the aspect that the function's job is to do testing.</p>
<p>Doing it "right" is annoying, putting colons on every access...possibly omitting some when the value is in a context where the program logic would say it can't be a function at that point.</p>
<pre><code>twosie?: func [x] [
    to-logic any [
        :x = 2
        all [
            block? :x
            2 = length? :x       ; :x is optional, as known to be a BLOCK! here
        ]
    ]
]
</code></pre>
<p>Sometimes, people would minimize the number of GET-WORD!s needed by short-circuiting a test for FUNCTION! first:</p>
<pre><code>twosie?: func [x] [
    if function? :x [return false]
    to-logic any [
        x = 2
        all [
            block? x
            2 = length? x
        ]
    ]
]
</code></pre>
<p>This is fairly unsatisfying as well.  It breaks easily if someone reorganizes the code and doesn't realize the test has to come first, or if there has to be additional handling and skipping all the code that uses the variable isn't the desired semantic.</p>
<p><strong>This situation is a tax on users, who are continuously torn between writing obvious code that is broken... vs. cluttered code that winds up being made more brittle due to the maintenance of the clutter.</strong></p>
<p>It would clearly be ideal if the obvious code was also correct.</p>
<h2>The Nuanced Compromise Of Isotopic ACTION!s</h2>
<p>Something that occurred to me was to ask what would happen if there were two kinds of actions:</p>
<ul>
<li>
<p>ACTION! isotopes, which would run if they were referenced via a WORD! or TUPLE!</p>
</li>
<li>
<p>Plain ACTION!s, which would be inert when accessed by WORD!</p>
</li>
</ul>
<p><strong>An obvious <em>good</em> part of this idea would be that a "normal" argument to a function would never be able to be an isotope (solving the problems outlined above).</strong></p>
<p><strong>An obvious <em>questionable</em> part of this idea is introducing another state to worry about.</strong></p>
<p>I've implemented it--though it is a radical change affecting kind of everything.  :-/  There are certainly a lot of questions raised and details to come up.</p>
<p>Something to realize is that there's a fundamental complexity coming from the fact that Rebol wants WORD! references to execute actions automatically much of the time.  But you still have a lot of places that want to talk about values "as-is".  We cannot "wish away" that complexity...only reshape it.</p>
<p><strong>But I think the ability to have obviously-written code in cases like TWOSIE? tips the balance.</strong>  I don't know that meta-code gets truly any harder to write, it just gets <em>different</em>...while the simple examples work without GET-WORD!s.</p>
<p>I'll use this thread to document differences to know about.</p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/attack-of-the-activated-actions/1900">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/attack-of-the-activated-actions/1900</link>
          <pubDate>Wed, 27 Jul 2022 05:01:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1900</guid>
          <source url="https://forum.rebol.info/t/attack-of-the-activated-actions/1900.rss">Attack of the Activated Actions</source>
        </item>
        <item>
          <title>FIND and SELECT polymorphism</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>In Rebol2, you can run FIND on OBJECT! as well as on BLOCK!:</p>
<pre><code>rebol2&gt;&gt; obj: make object! [a: 10 b: 20]

rebol2&gt;&gt; find obj 'a
== true

rebol2&gt;&gt; find obj 'asdf
== false
</code></pre>
<p>I'll point out that <a href="https://github.com/red/red/commit/7b1eeb76a6eb2c5c31e8407637fea5664ace61c2">Red does not support FIND on OBJECT!, and that was intentional</a>.   There's <a href="https://gitter.im/red/red?at=5f134373564e6b39f5655c0f">no real explanation</a> other than than something approximating <em>"objects and bitsets don't support a lot of series operations because they don't necessarily make sense"</em>.</p>
<p>But Red allows FIND on maps, for some reason?</p>
<pre><code>red&gt;&gt; m: make map! [a 10]
== #(
    a: 10
)

red&gt;&gt; find m 'a
== a
</code></pre>
<h3>Is This A Polymorphism You Can Even Use?</h3>
<p>There's no real clarity in OBJECT!/BLOCK! duality.  <a href="https://forum.rebol.info/t/block-and-object-parity-in-pathing-picking/1086">I've tried to invent some out of the murk, but come up short.</a></p>
<p>We might ask ourselves:</p>
<p><strong>Has there ever been a situation where you've had something--you didn't know what it was, either an OBJECT! or a BLOCK!--and your generic code can meaningfully use a FIND call on that thing?</strong></p>
<p>I can't imagine the answer to that is yes.  <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=9" title=":roll_eyes:" class="emoji" alt=":roll_eyes:"></p>
<p>BUT... what about something you didn't know if it was an OBJECT! or a MAP! ?</p>
<p>You can pass a WORD! to IN for an OBJECT!, and get either a bound word back in that object or NULL.  But you can't use IN on a MAP.</p>
<p>So the only polymorphic operators you can use to determine if something is in either an OBJECT! or a MAP! these days are FIND and SELECT.  Ren-C has the advantage that SELECT returns NULL if-and-only-if something isn't in a map or object, so even if you don't need the selected item you can use it.</p>
<h3>
<em>Some</em> Line Of Argumentation Might Support Rebol2's Behavior</h3>
<p>To truly generalize FIND, you could consider it to be with respect to an iterator... e.g. <a href="https://en.cppreference.com/w/cpp/algorithm/find">how C++'s find works</a>.</p>
<p>We might then look to FOR-EACH to see what it would give you if you asked it for a generic "something".  R3-Alpha supports this (not Rebol2 or Red):</p>
<pre><code>r3-alpha&gt;&gt; obj: make object! [a: 10 b: 20]

r3-alpha&gt;&gt; foreach something obj [print mold something]
a
b
</code></pre>
<p>So maybe if all of that was built on some common infrastructure, you could build a rationale for why searching keys-only made sense for FIND in an object.</p>
<p><em>But it's not built on any common infrastructure, so it's just extra random code.</em></p>
<h3>Moreover, what About BITSET! ?</h3>
<p>Above I made a potential case for seeing FIND as applying to the keys of an object.  But... BITSET!?</p>
<p>If you say <strong>bs: make bitset! 8</strong> and then <strong>bs.4: true</strong>, you're making something kind of like a block:</p>
<pre><code>[0 0 0 1 0 0 0 0]
</code></pre>
<p>So semantically, why would <strong>find bs 4</strong> be true?  Where's the 4?</p>
<p>I think what this really is more like is a positional PICK <em>(which makes sense because <strong>bs.4: true</strong> is running the code <strong>poke bs 4 true</strong>, and <strong>bs.4</strong> acts as <strong>pick bs 4</strong>)</em></p>
<p>But..it may be a potentially interesting polymorphism to think of a bitset as a mapping from integers to LOGIC!.  You might swap in something that is using a BITSET! to use a MAP!.  So SELECT with integer <em>could</em> be coherent here.</p>
<p>I think PICK is the best choice, though.</p>
<h3>Anyway...I'm removing FIND on Maps/Objects/Bitsets for Now...</h3>
<p>For the moment, I think that <strong>did select</strong> or <strong>didn't select</strong> are the best invariant ways of detecting if things are in objects or maps.   (Or use with ELSE/THEN)</p>
<p>This leaves FIND as something that might be more dialected, with options that let you search the values and not just the keys (maybe search deeply?)</p>
<p>Also it saves us from returning the kind of hokey idea of "true or null".  I'm suspicious of most functions that are in situations where they only return true or null, anyway.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/find-and-select-polymorphism/1879">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/find-and-select-polymorphism/1879</link>
          <pubDate>Thu, 14 Jul 2022 02:21:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1879</guid>
          <source url="https://forum.rebol.info/t/find-and-select-polymorphism/1879.rss">FIND and SELECT polymorphism</source>
        </item>
        <item>
          <title>Should Void be Offered to Predicates (for REDUCE, ANY/ALL, etc.)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>There's an option to pass a function to some things, to help avoid needing to write the basic logic of the function over again if you just want some difference.  So if you want a negating version of ANY you can say:</p>
<pre><code>&gt;&gt; any/predicate [1 + 2 null 3 + 4] :not
== ~null~  ; isotope (decays to null)
</code></pre>
<p>There you have a negated form of ANY.  You could specialize that:</p>
<pre><code>&gt;&gt; any-not: specialize :any [predicate: :not]
== #[action! {any-not} [block]]

&gt;&gt; any-not [1 + 2 null 3 + 4] then [print "Look, it worked!"]
Look, it worked!
</code></pre>
<p>It works with THEN and ELSE thanks to isotopes: a negating form of ANY that returns you an indicator of what the false thing was, while still being able to let you run a THEN or ELSE clause that has the expected semantics.  So even though the thing that triggered the short circuit was a NULL, the isotope form was returned and allowed to run the THEN.</p>
<p><strong>But what if there's a void entry, should your predicate function find out about it?</strong></p>
<pre><code>&gt;&gt; reduce/predicate [1 + 2 3 + 4] func [x] [return x * 10]
== [30 70]

&gt;&gt; reduce [1 + 2 if false [&lt;a&gt;] 3 + 4]
== [3 7]

&gt;&gt; reduce/predicate [1 + 2 if false [&lt;a&gt;] 3 + 4] func [x] [return x * 10]
; ...???...
</code></pre>
<p><strong>Given that the whole point of predicates is to reuse the work of the core function, it would seem like one of those pieces of work is filtering out the void expressions.</strong></p>
<p>So I think it's pretty clear the above should be <strong><code>== [30 70]</code></strong> with no error given.</p>
<p>But what if the function's argument was ^META?  Does that change things?</p>
<pre><code>&gt;&gt; reduce/predicate [1 + 2 if false [&lt;a&gt;] 3 + 4] func [^x] [...]
; ...???...
</code></pre>
<p>Or does it have to explicitly say by contract it is interested in voids?</p>
<pre><code>&gt;&gt; reduce/predicate [1 + 2 if false [&lt;a&gt;] 3 + 4] func [^x [&lt;void&gt; any-value!]] [...]
; ...???...
</code></pre>
<p>It's a pretty fringe feature either way.  I think that in REDUCE's case, we can say that if you really want to get control of every expression...then using REDUCE-EACH with ^META seems a bit more explicit that you want EACH.</p>
<p>I'm going to say for the moment that the predicate in REDUCE, ANY, and ALL will never be offered voids...and that's just part of the benefit of reusing the work.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-void-be-offered-to-predicates-for-reduce-any-all-etc/1872">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-void-be-offered-to-predicates-for-reduce-any-all-etc/1872</link>
          <pubDate>Sun, 10 Jul 2022 17:16:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1872</guid>
          <source url="https://forum.rebol.info/t/should-void-be-offered-to-predicates-for-reduce-any-all-etc/1872.rss">Should Void be Offered to Predicates (for REDUCE, ANY/ALL, etc.)</source>
        </item>
        <item>
          <title>Pushing the Potential of Polyglot Polymorphic DO</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p><strong>The brevity of DO is a strength that makes it seem natural to be polymorphic.</strong></p>
<p>I thought it was very wasteful that when Rebol2 and Red's DO saw something it didn't recognize, it would just drop out:</p>
<pre><code>rebol2&gt;&gt; do 1020
== 1020

rebol2&gt;&gt; do &lt;useless&gt;
== &lt;useless&gt;
</code></pre>
<p>Pinning people's expections to this behavior--to where they write code that relies on it--is awful.</p>
<p>There are plenty of things we can imagine for this undiscovered space.  (Soon it's planned that the ReplPad will use shorthands like <strong>do 3</strong> to mean "run the code in editor tab <span class="hashtag">#3</span>")</p>
<h2>Could We (or Should We?) Take DO's Polymorphism Further?</h2>
<p>I'd been thinking that it might be able to "run" things that are not even Rebol.   This would mean that you could <strong>do %foo.js</strong> and run JavaScript, or <strong>do %bar.css</strong> and import CSS.</p>
<p><em>(But then again, JavaScript has modules vs. ordinary code... so maybe <strong>import %foo-module.js</strong> would also be an interesting polymoprhism to have as well?)</em></p>
<p>We are getting some experience with this and the ReplPad.  And what experience is telling us is that it's really ugly to have to use names like JS-DO and CSS-DO.  Plus it puts stress on coming up with and remembering the names (was it JS-DO or DO-JS?)</p>
<p>With FRAME!s we even have the option of building things that defer execution.  Some simple pseudocode using current JS-DO to give the idea.</p>
<pre><code>load: enclose :lib.load func [frame]
    uparse try match [url! file!] frame.source then [
        let result: make frame! :js-do
        result.source: frame.source
        return result
   ]
   do frame
]

&gt;&gt; thing: load https://example.com/helloworld.js  ; doesn't run JS yet

&gt;&gt; do thing  ; would run it here
</code></pre>
<p>In today's Ren-C, the sky is the limit for many such things.</p>
<h2>I Think DO of a TEXT! String Should Be Dropped (Reclaimed)</h2>
<p>When you DO a BLOCK!, you know that block has been incarnated through some series of steps that bound it and brought it to life.</p>
<p>When you DO a TEXT! string, you have nothing to go on but the string itself.  It represents an incomplete thought, and it's hard to think of a "good" answer for what the semantics of that should be.</p>
<p>One tricky issue we've talked about is how module headers in text strings are handled:</p>
<pre><code>do "Rebol [Type: module] export thing: {This does not work}"
</code></pre>
<p>Historically what happens is that Rebol is a synonym for the SYSTEM object, so that evaluates an inert OBJECT! as a first step.  Then it evaluates the inert block [Type: module].  You don't have any of the LOADer mechanics in there.</p>
<p>So basically, the above is <em>completely</em> broken.</p>
<p>We're facing another problem of being short on strings to say where code should come from.  It's important to have a way to distinguish running paths relative to <code>system.script.path</code> as opposed to WHAT-DIR, and strings seem a reasonable way to encode that intent:</p>
<pre><code>do %../path/relative/to/what-dir
do "../path/relative/to/system.script.path"

import %../path/relative/to/what-dir
import "../path/relative/to/system.script.path"
</code></pre>
<p>When you add all this in with the spirit of language agnosticism, that makes interpreting TEXT! as being specifically Rebol language text is presumptuous.</p>
<p>This all makes going through <strong>do load</strong> to use text as source seem like a much more attractive option than trying to figure out how to push all of LOAD's options onto DO.</p>
<pre><code>&gt;&gt; do "print {Hello World}"
Hello World

&gt;&gt; do load "print {Is DO LOAD that much worse for Hello World?}"
Is DO LOAD that much worse for Hello World?
</code></pre>
<p><em>Of course, I will make the usual point that you will be able to overload this if you wish.</em>   Redbol will still DO strings, and you can decide you're never going to use the script-relative path importing (or do it another way).</p>
<p>But I think DO LOAD is a small price to pay for solving a bunch of irritating problems.</p>
<h2>I Think We Should Drop the /NEXT Option From DO</h2>
<p>Clearly a DO/NEXT of a JavaScript file doesn't make sense.  But does it make sense for a Rebol file, really?</p>
<p>Rebol2 returns a BLOCK! with a pair of the result and remaining code, which works for blocks:</p>
<pre><code>rebol2&gt;&gt; foo: [print "Some" print "Block"]

rebol2&gt;&gt; do/next foo
Some
== [unset [print "Block"]]
</code></pre>
<p>But for functions, it just ignores the /NEXT:</p>
<pre><code>rebol2&gt;&gt; foo: func [] [print "Some" print "Function"]

rebol2&gt;&gt; do/next :foo
Some
Function
</code></pre>
<p>Red gives nonsense, as usual...it returns the value of the function back and doesn't DO it at all</p>
<pre><code>red&gt;&gt; foo: func [] [print "The usual" print "nonsense"]

red&gt;&gt; foo
The usual
nonsense

red&gt;&gt; do/next :foo 'pos
== func [][print "The usual" print "nonsense"]

red&gt;&gt; pos
*** Script Error: pos has no value
</code></pre>
<p><strong>So I'm proposing the /NEXT functionality be solely in EVAL, and have EVAL run only on ANY-ARRAY!</strong></p>
<p>If you DO, that means fire-and-forget.</p>
<h2>Narrowing DO Use Is Good For Security / Avoiding Big Mistakes</h2>
<p>DO is pretty powerful.  When you say DO VALUE that could be a URL!...fetching arbitrary code off the internet and running it.</p>
<p>Of course, DO of a BLOCK! can contain code that does arbitrary things.  But if you're writing code that's supposed to all run on your machine and be self contained, it would be nice if you could be reasonably sure that you aren't running code off the internet if you didn't use DO or IMPORT.</p>
<p>So making it possible to get normal casual work done locally without ever needing to call DO seems desirable.  That is why EVAL has both "do to end" and "do step" semantics:</p>
<pre><code> &gt;&gt; eval [1 + 1 print "Modes"]
 Modes

 &gt;&gt; [value pos]: eval [1 + 1 print "Modes"]
 == 2

&gt;&gt; pos
== [print "Modes"]
</code></pre>
<p>So you can use EVAL where you would have used DO of a BLOCK!, and you can use the /NEXT mode as a multi-return (or a refinement, if you choose)</p>
<pre><code>&gt;&gt; eval/next [1 + 1 print "Modes"] 'pos
== 2

&gt;&gt; pos
== [print "Modes"]
</code></pre>
<p><strong>This raises into question if DO of a BLOCK! needs to be a way to run code at all.</strong>  It could be dialected, and let you supply arguments:</p>
<pre><code>do [%script-taking-args.reb 1 2 3]</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/pushing-the-potential-of-polyglot-polymorphic-do/1846">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/pushing-the-potential-of-polyglot-polymorphic-do/1846</link>
          <pubDate>Mon, 20 Jun 2022 10:29:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1846</guid>
          <source url="https://forum.rebol.info/t/pushing-the-potential-of-polyglot-polymorphic-do/1846.rss">Pushing the Potential of Polyglot Polymorphic DO</source>
        </item>
        <item>
          <title>About the Semantics category</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>While the "Internals" discusses the bits and bytes of how things are implemented, this category is for discussing things design questions of the language... like what <strong>do []</strong> should return.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/about-the-semantics-category/1789">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/about-the-semantics-category/1789</link>
          <pubDate>Wed, 16 Feb 2022 03:48:39 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1789</guid>
          <source url="https://forum.rebol.info/t/about-the-semantics-category/1789.rss">About the Semantics category</source>
        </item>
        <item>
          <title>Multi-Return: Deferred Enfix + Meta Returns</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>So multi-return is based on a (conceptually) simple trick for writing ordinary function calls.  The "extra returns" are really just refinements that are labeled as outputs, but you can invoke them normally as refinements that take a WORD!... as was done historically for extra outputs of a function.</p>
<p>Traditional code:</p>
<pre><code>&gt;&gt; block: transcode "1 2 3"
== [1 2 3]  ; defaults to assuming you want the whole thing transcoded

&gt;&gt; value: transcode/next "1 2 3" 'rest
== 1  ; asking for /next gives you just one value

&gt;&gt; rest
== " 2 3"  ; the REST word passed in gets assigned the remainder
</code></pre>
<p>Now for some  <img src="https://forum.rebol.info/images/emoji/twitter/candy.png?v=9" title=":candy:" class="emoji" alt=":candy:"> <a href="https://en.wikipedia.org/wiki/Syntactic_sugar"><strong>Syntactic Sugar</strong></a> <img src="https://forum.rebol.info/images/emoji/twitter/lollipop.png?v=9" title=":lollipop:" class="emoji" alt=":lollipop:"> that is enabled when NEXT is marked as an "output refinement" (<strong>next:</strong>) instead of an "ordinary refinement" (<strong>/next</strong>) in the function spec:</p>
<pre><code>&gt;&gt; [value rest]: transcode "1 2 3" 
== 1

&gt;&gt; value
== 1  ; the overall expression was 1, but value was also assigned 1

&gt;&gt; rest
== " 2 3"  ; just as if you'd named the /NEXT refinement and passed 'REST
</code></pre>
<h2>But There Have Been Enfix Complications...</h2>
<p>Though simple in concept, the multi-returns aren't completely simple in implementation...and at present run through a bit of different code than ordinary function calls (though of course most of the function execution, type checking, etc. are shared).</p>
<p>The parts that are different--however--were creating problems with enfix...which wasn't managed as part of the frame filling process.  So it just errored.</p>
<pre><code>&gt;&gt; [value rest]: transcode "1 2 3" then [&lt;item!&gt;]
** Script Error: Ambiguous infix expression--use GROUP! to clarify
</code></pre>
<p>You could get it to execute by putting the part before the THEN in a group:</p>
<pre><code>&gt;&gt; ([value rest]: transcode "1 2 3") then [&lt;item!&gt;]
== &lt;item!&gt;
</code></pre>
<p>Which works...<em>but what if that isn't the semantics you wanted?</em>  That means your overall expression evaluates to <code>&lt;item!&gt;</code> but value is still getting 1.</p>
<p>Consider that we usually want the result of an ELSE to get into the value of a variable:</p>
<pre><code>&gt;&gt; x: if 1 &gt; 2 [10] else [20]
== 20

&gt;&gt; x
== 20
</code></pre>
<p>If you had to write this with a GROUP! you'd get x as the result of the IF (null in this case, since 1 &lt; 2)</p>
<pre><code>&gt;&gt; (x: if 1 &gt; 2 [10]) else [20]
== 20

&gt;&gt; x
; null
</code></pre>
<p>So that's the situation we were in with multi-returns--not having a choice.  You'd wind up with the variable assigned the result of the original function...never being able to use the enfix product.</p>
<p><strong>It looks like I have a fix for this, so you'll be able to choose either way.</strong></p>
<h2>Recap of The No-Group-On-Right Limitation</h2>
<p>I've mentioned how being syntactic sugar kind of limits what we can do with multi-returns.  You can't put the right hand side in a group:</p>
<pre><code>[value rest]: (transcode "1 2 3")
</code></pre>
<p>This is because it could be more than one call, and you don't know what will come after it, and it could be arbitrarily deep:</p>
<pre><code>[value rest]: ((((transcode "1 2 3", ...))))
</code></pre>
<p>You <em>might</em> argue we could still allow it if the multi-returns are tunneled down to the function and the value gets assigned from the final product of the group.</p>
<p>But I don't like it because then you are talking about something that left quoting enfix couldn't do.  I like the idea that when you get in a pinch and want to override a multi-return assignment you could do it by declaring your function enfix and pick up the SET-BLOCK! on the left as a parameter.</p>
<p>That interchangeability offers a good dynamic, and it's how <a href="https://forum.rebol.info/t/a-lot-to-unpack-replacing-the-set-of-reduce-block-idiom/1634">things like UNPACK</a> fit into this universe...where they seem like first-class language features.  Doing crazy things that don't relate to what users could build themselves isn't the ergonomic we're looking for (e.g. "bad lego alligator" territory).</p>
<h2>The Meta Dilemma</h2>
<p>The hard rule that the thing on the right of the SET-BLOCK! be the function with the multi-returns caused a problem with wanting to ask for the "meta" result.</p>
<p>UPARSE has this desire often.  It may be that a parser returns something like an unset or a null isotope.  We want to handle those distinctly from nulls, as well as to not choke on them as invalid variables.  So we ask for the meta-result of the parser.</p>
<p>I wrote a special exemption to allow it, like this:</p>
<pre><code>([result progress]: ^ parser input) then [...]
</code></pre>
<p>Recognizing the <strong>^</strong> specially in the multi-return code felt wrong.  Where do such things stop...why not <strong>([...]: ^ ^ ^ parser input)</strong> ?  It has a similar arbitrariness to it that digging through parentheses seemed to have.</p>
<p>But with the META-WORD! we had a new option...to put the meta on the argument itself:</p>
<pre><code>([^result progress]: parser input) then [...]
</code></pre>
<p>To some people's tastes maybe that looks worse.  but it is more compact.  And it can work even if you don't name a variable:</p>
<pre><code>&gt;&gt; [^ rest]: transcode "1 2 3"
== '1
</code></pre>
<p>It feels more like things are in the right place this way.  Multi-return was prototyped as just an application of enfix quoting blocks on the left of a function...and I kind of like it not straying too far from what that could do.  This is within reach of that.</p>
<p>These might seem like small things, but, they are important.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/multi-return-deferred-enfix-meta-returns/1759">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/multi-return-deferred-enfix-meta-returns/1759</link>
          <pubDate>Fri, 26 Nov 2021 14:18:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1759</guid>
          <source url="https://forum.rebol.info/t/multi-return-deferred-enfix-meta-returns/1759.rss">Multi-Return: Deferred Enfix + Meta Returns</source>
        </item>
        <item>
          <title>&quot;Destructuring&quot; in FOR-EACH</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p><a class="mention" href="/u/gchiu">@gchiu</a> wrote some code that made a list of drugs and filenames related to those drugs:</p>
<pre><code> drugs: [
     ["Benzbromarone" "SA1537.pdf"]
     ["Teriparatide" "SA1139.pdf"]
     ["Adalimumab" "SA1847.pdf"]
     ["Etanercept" "SA1812.pdf"]
 ]
</code></pre>
<p>This is inconvenient to enumerate.  It won't work if you say:</p>
<pre><code>for-each [drugname filename] [...]
</code></pre>
<p>Because what you get then is two successive blocks... e.g. drugname winds up being <strong>["Benzbromarone" "SA1537.pdf"]</strong> and then filename is <strong>["Teriparatide" "SA1139.pdf"]</strong>.</p>
<p>If this were to work, it would have to offer something like:</p>
<pre><code>for-each [[drugname filename]] [...]
</code></pre>
<p>That could communicate that the information you were looking for was actually in a nested block level.</p>
<p>Though we don't want to get too literal with the dialect.  If you have:</p>
<pre><code> drugs: [
     ("Benzbromarone" "SA1537.pdf")
     ("Teriparatide" "SA1139.pdf")
     ("Adalimumab" "SA1847.pdf")
     ("Etanercept" "SA1812.pdf")
 ]
</code></pre>
<p>...we don't want to make the meaning of GROUP!s in FOR-EACH have to be related to this structure, because we use groups to say that the variable's name is calculated.  :-/</p>
<p>Similarly, we might imagine more interesting meanings for blocks in FOR-EACH than to point out a nested block level.  Maybe this would be done with quoted blocks and quoted groups?</p>
<pre><code>for-each ['(drugname filename)] [...]
</code></pre>
<p>It gets a bit hairy because you're starting to tread into parsing territory.  Hard to know where to stop.</p>
<p>Since I'm not sure I just switched Graham's case to use a flat block.</p>
<pre><code> drugs: [
     "Benzbromarone" "SA1537.pdf"
     "Teriparatide" "SA1139.pdf"
     "Adalimumab" "SA1847.pdf"
     "Etanercept" "SA1812.pdf"
 ]
</code></pre>
<p>But it should be thought about more.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/destructuring-in-for-each/1738">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/destructuring-in-for-each/1738</link>
          <pubDate>Mon, 04 Oct 2021 20:08:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1738</guid>
          <source url="https://forum.rebol.info/t/destructuring-in-for-each/1738.rss">&quot;Destructuring&quot; in FOR-EACH</source>
        </item>
        <item>
          <title>GET+SET vs PICK+POKE - What&#39;s The Difference?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Historically, GET could not get a path:</p>
<pre><code>rebol2&gt;&gt; obj: make object! [x: 10]

rebol2&gt;&gt; get 'obj/x
** Script Error: get expected word argument of type: any-word object none
</code></pre>
<p>That changed in R3-Alpha.  Red followed suit:</p>
<pre><code>r3-alpha/red&gt;&gt; get 'obj/x
== 10
</code></pre>
<p>Which seems like an improvement...but opened the door to something I've complained about: GET having side-effects, such as:</p>
<pre><code>red&gt;&gt; path: 'obj/(print "Boo!" 'x)
== obj/(print "Boo!" 'x)

red&gt;&gt; get path
Boo!
== 10
</code></pre>
<p>When you say that two sequential GETs can get something completely different even when nothing has changed, that really pulls the rug out from under any generic code that wants to build upon what a GET is.  Similar issues apply to SET.</p>
<h2>How Do Pick and Poke Compare?</h2>
<p>PICK and POKE add an extra parameter of a location to pick or poke from.  But then they still have a "picker" of some kind.</p>
<p>This leads one to wonder if this would work, but it doesn't:</p>
<pre><code>r3-alpha&gt;&gt; outer: make object! [inner: make object! [x: 10]]

r3-alpha&gt;&gt; pick outer 'inner/x
** Script error: pick does not allow object! for its aggregate argument
</code></pre>
<p>But there are two possible interpretations.  If OUTER is something like a MAP, it could be looking up the PATH! <strong>inner/x</strong> as the key in the map.  Or it could be looking up the key <strong>inner</strong>, fetching the thing in the map, and then picking <strong>x</strong> out of that.</p>
<p>MAP!s don't allow PATH! in R3-Alpha or Red, but if they did...we'd assume it would interpret <strong>inner/x</strong> as the key.</p>
<h2>So Historical PICK and POKE are Strictly Less Powerful?</h2>
<p>This makes it seem like GET and SET have the ability to do anything that a PATH! or SET-PATH! can do.  But PICK and POKE can only go the last mile and ask one container about its response to one key.</p>
<p>Could we make a synonym for PICK, if we just GET a PATH! that we make up?  Let's try that in Red:</p>
<pre><code>red&gt;&gt; pick2: func [series index] [
          get make path! reduce ['series to paren! reduce ['quote index]]
      ]

red&gt;&gt; m: make map! [a 10 b 20]

red&gt;&gt; pick2 m 'a
== 10

red&gt;&gt; b: [x 30 y 40]

red&gt;&gt; pick2 b 'y
== 40
</code></pre>
<p><strong>It appears to work, but the issue is that I'm sure these are completely different code paths.</strong>  So you'll see subtly different behaviors for PICK vs. pathing where they'll be the same <em>most</em> of the time, but then not.</p>
<p>It would only make sense to have two codebases if someone could articulate what's different about "picking" and "pathing".  Outside of function call dispatch with refinements I can't think of a good argument for a difference.  And Ren-C uses TUPLE! instead of PATH! for conventional picks, so the tuple-based picking could truly be the same.</p>
<h2>Not Easy To Reason About</h2>
<p>This is all made-up stuff with really imaginary semantics.  And I've come up against the hard questions like trying to make this work:</p>
<pre><code> item.(expression): default [...]
</code></pre>
<p>If you GET that SET-PATH! on the left to check to see if there's a value in it or not, and there isn't, then you decide to run the right hand side.  Then you want to SET the SET-PATH! on the left...but without some alternate mechanism, you'll be evaluating the expression twice.</p>
<p>Being able to turn that <code>item.(expression)</code> into some sort of reusable currency that you can GET and SET multiple times without side effects is ideal.  Once this was done by COMPOSE'ing that PATH!, but paths are now more restrictive in what they can have as members...so it would have to be turned into a block.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/get-set-vs-pick-poke-whats-the-difference/1719">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/get-set-vs-pick-poke-whats-the-difference/1719</link>
          <pubDate>Thu, 16 Sep 2021 18:51:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1719</guid>
          <source url="https://forum.rebol.info/t/get-set-vs-pick-poke-whats-the-difference/1719.rss">GET+SET vs PICK+POKE - What&#39;s The Difference?</source>
        </item>
        <item>
          <title>COLLECT Mutation Semantics: KEEP vs. KEEP/ONLY</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>When reimplementing COLLECT for UPARSE on top of the "pending" model, <a href="https://forum.rebol.info/t/getting-hooks-into-events-during-parse/1640/10">I mentioned a potential avenue for optimization</a> by not immediately splicing blocks, but keeping them in a list and then merging the whole list together if-and-when the COLLECT got to the success point:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="10" data-topic="1640">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/getting-hooks-into-events-during-parse/1640/10">Getting Hooks Into "Events" during PARSE</a>
</div>
<blockquote>
<p>(Efficiency sidenote: I might should have used something like @[...] blocks for GATHER, and use BLOCK!s for KEEP to complement the QUOTED!s. This would save splicing until the very end COLLECT when you have a better idea of how big the total series will be.)</p>
</blockquote>
</aside>
<p>The idea of saving splicing until the end might sound good, but... it doesn't work if we presume mutations.</p>
<p>Just imagine a delaying implementation of ordinary COLLECT:</p>
<pre><code>&gt;&gt; delayed-splice-collect [
      block: [a b c]
      keep block
      clear block
      insert block [d e f]
      keep block
  ]
== [d e f d e f]
</code></pre>
<p>That's not what we expect from today's COLLECT.</p>
<p>Though if you're <em>not</em> splicing, you expect mutations to affect what you've already collected.  It's true in all Redbols today, since you're keeping the block by identity:</p>
<pre><code>red&gt;&gt; collect [
         block: [a b c]
         keep/only block
         clear block
         insert block [d e f]
         keep/only block
      ]
== [[d e f] [d e f]]
</code></pre>
<h2>
<a href="https://hypirion.com/musings/understanding-persistent-vector-pt-1">Persistent Vector</a> Looks Awfully Tempting  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_monocle.png?v=9" title=":face_with_monocle:" class="emoji" alt=":face_with_monocle:">
</h2>
<p>Looking at things like this is always a throwback to saying <em>"mutable state by default is garbage"</em>.  But it depends on what example you're looking at.  Sometimes it's good, sometimes it's bad.</p>
<p>I guess the thing is to just explore what the good parts are.  Maybe someone will blend in some Clojure bits at some point in a derivative...but that person is not going to be me!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/collect-mutation-semantics-keep-vs-keep-only/1706">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/collect-mutation-semantics-keep-vs-keep-only/1706</link>
          <pubDate>Sun, 05 Sep 2021 11:56:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1706</guid>
          <source url="https://forum.rebol.info/t/collect-mutation-semantics-keep-vs-keep-only/1706.rss">COLLECT Mutation Semantics: KEEP vs. KEEP/ONLY</source>
        </item>
        <item>
          <title>UPARSE needs BREAK, REJECT, ACCEPT... But What Are They?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>When something doesn't sit right in my head, I notice.  Like how I could never remember in the beginning what GET-WORD! or SET-WORD! in PARSE did.  <em>(e.g. is a GET-WORD! GET-ing the parse position to SET a variable, or GET-ting a variable's value to use to SET the parse position?)</em></p>
<p>And I never really understood ACCEPT, REJECT, BREAK, and FAIL.</p>
<h2>I Currently Consider the FAIL Confusion "Solved"</h2>
<p>Things have settled nicely, in that LOGIC! is used to get a pure "keep going" or "stop".  So FAIL is replaced simply by FALSE.  It means <strong>if (expression-returning-logic)</strong> is replaced in UPARSE as <strong>:(expression-returning-logic)</strong>, and we can keep FAIL on the meaning of "raise error".</p>
<p>This generalization has the pleasing property that we don't need to go introducing "parse switch" or "parse case" or any such things.  Since NULL means the same thing as #[true] for a GET-GROUP! splice, you have every option at your disposal.</p>
<h2>BREAK and REJECT Seem Too Similar</h2>
<p>The problem I have is that BREAK sounds a lot like "this didn't work".  In fact, I've enforced that loops return NULL if-and-only-if you BREAK them:</p>
<pre><code>&gt;&gt; repeat 3 [break]
; null

&gt;&gt; repeat 3 [null]
== ~null~  ; isotope
</code></pre>
<p>A NULL is used as a signal of "soft failure", e.g. it causes ELSE to run.</p>
<pre><code> &gt;&gt; repeat 3 [break] else [print "soft failure"]
 soft failure

 &gt;&gt; repeat 3 [null] else [print "soft failure"]
 == ~null~  ; isotope
</code></pre>
<p>So the distinction between BREAK and REJECT seems a thin one.  I feel like I'd rather that BREAK meant you decided the iterated rule isn't working out...and some other signal indicated that you want to accept it and go on.</p>
<p>But ACCEPT doesn't really hint at ceasing iteration.  Perhaps STOP?  As a word, it hints more at the ceasing of an iteration...and that's used in CYCLE.</p>
<pre><code>&gt;&gt; cycle [stop]
== ~void~  ; isotope
</code></pre>
<p>Unlike BREAK (which always returns NULL) it is able to return a non-NULL...and a NULL will be isotopified so it won't be seen as a "soft failure" by ELSE:</p>
<pre><code>&gt;&gt; cycle [stop 10]
== 10

&gt;&gt; cycle [stop null]
== ~null~  ; isotope
</code></pre>
<p>Similarly, if you're going to be saying an iterative construct in PARSE is to keep going, then you should have an opportunity to say what the value synthesized from that rule will be.  This requires "endable" rules (because we want a plain stop to work).  I think that's doable.</p>
<p>So I guess I'm saying prefer BREAK to mean rule failed... return NULL.  And STOP to mean rule succeeded.  Default to returning a void isotope if no argument given, but allow an argument.  The argument would be a rule, so you could actually make the STOP a rule.</p>
<pre><code>&gt;&gt; uparse "aaab" [while ["a" (print "A") | stop ["b" (1020)]]]
A
A
A
== 1020
</code></pre>
<h2>What About CONTINUE ?</h2>
<p>If your loop is only one deep in alternates, then all an alternate needs to do continue is succeed:</p>
<pre><code>&gt;&gt; uparse "aaab" [while ["a" comment "continue" | "b" comment "continue"]]
</code></pre>
<p>But if you're deeper than that, it is trickier.  And I don't see any particular reason why you shouldn't be able to ask a rule to CONTINUE a loop.</p>
<pre><code>&gt;&gt; uparse "abbbaccc" [while [
    "a" [some "bbb" (print "BBB"), continue | some "ccc" (print "CCC")]
    (print "like this!")
]
BBB
CCC
like this!
</code></pre>
<p>And CONTINUE could also take an argument, which would matter only if it was the final iteration:</p>
<pre><code>&gt;&gt; uparse "bba" [repeat (3) ["a" continue (&lt;like this&gt;) | "b"]]
== &lt;like this&gt;
</code></pre>
<h2>Would That Be an Improvement?</h2>
<p>I think CONTINUE is pretty obviously useful.</p>
<p>One thing that's a bit weird about what I suggest is that when a BREAK happens in a <em>non-parse</em> loop, the code after it runs.</p>
<p>But the idea that "failure" stops progression is a cross-cutting design aspect in PARSE.  It seems consistent to me.</p>
<p>Yet another issue is that STOP is not currently offered by plain WHILE or REPEAT or FOR-EACH or other loops.  The reason is that if you are to try and write your own iterator in terms of other iterators, you cannot tell from the outside if a "cease iterating" intention happened.</p>
<p>Consider this:</p>
<pre><code>&gt;&gt; opaque-code: [print "looping", 1000 + 20]

&gt;&gt; repeat 2 (opaque-code) then [repeat 2 (opaque-code)]
looping
looping
looping
looping
== 1020
</code></pre>
<p>That's nice because if the opaque-code has a break, the whole thing will break:</p>
<pre><code>&gt;&gt; opaque-code: [print "entering", break]

&gt;&gt; repeat 2 (opaque-code) then [repeat 2 (opaque-code)]
entering
; null
</code></pre>
<p>But if you permit STOP to return a value, the stopping intent is lost:</p>
<pre><code>&gt;&gt; opaque-code: [print "entering", stop 1020]

&gt;&gt; repeat 2 (opaque-code) then [repeat 2 (opaque-code)]
entering
entering
== 1020
</code></pre>
<p>When you're trying to write compound looping expressions that are built up of smaller loops, this really matters.  CYCLE is an oddball because you know the only way it <em>ever</em> terminates with a value is if there was a stopping intent...which is why it allows STOP.</p>
<h2>Maybe ACCEPT and REJECT Should Be Used and No BREAK?</h2>
<p>...but this kind of runs into the same problem that non-PARSE WHILE doesn't have ACCEPT or REJECT.  So why get worked up about it having STOP when non-PARSE WHILE doesn't have STOP, if it makes everything line up?</p>
<p>Or maybe non-PARSE while <em>can</em> have STOP...you just understand that STOP has limits when it comes to loop abstraction.  Not everything works all the time.  So STOP can have a warning on it that you can't tell the stopping intent happened from outside a loop that isn't CYCLE...</p>
<h2>What Do You Think?</h2>
<p>Are the needs of PARSE different, or the same?  Should BREAK make the overall expression evaluate to NULL <em>but</em> keep going?  Are ACCEPT and REJECT the right answer?</p>
<p>It's hard to say.  I have to work out the mechanism by which such things could work in usermode combinators whatever you call them...so there's time to think about it.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/uparse-needs-break-reject-accept-but-what-are-they/1650">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/uparse-needs-break-reject-accept-but-what-are-they/1650</link>
          <pubDate>Sat, 07 Aug 2021 11:51:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1650</guid>
          <source url="https://forum.rebol.info/t/uparse-needs-break-reject-accept-but-what-are-they/1650.rss">UPARSE needs BREAK, REJECT, ACCEPT... But What Are They?</source>
        </item>
        <item>
          <title>BLOCK! Behavior In DELIMIT (hence SPACED, UNSPACED, PRINT)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Because I've thought of Redbols as targeting being a kind of "user friendly" and intuitive language, I was long bent out of shape about how junky things like PRINT and REJOIN were.</p>
<p>If your "Hello World" level programs are unpredictable nonsense, I don't see how you know where to start.  :-/</p>
<p>So an early thing I came up with was the idea to replace REJOIN with something that had some nice learnable invariants...which was called COMBINE.  It was harder than I thought.</p>
<p>Among the various philosophies that were tried out, was that blocks would be reduced recursively:</p>
<pre><code>&gt;&gt; var: "World"

old&gt;&gt; print ["Hello" var]
Hello World

&gt;&gt; block: ["Hello" var]

&gt;&gt; print ["((" block "))"]
(( Hello World ))
</code></pre>
<p>But I began having second thoughts, because it seemed like reducing blocks inside the print was a bit "dangerous".  You were in an evaluative context so if you wanted reduction you could ask for it.</p>
<p>Many ideas were tried over time, such as using BLOCK! as a means of getting "tight spacing" so you could intermix spaced and unspaced portions:</p>
<pre><code>&gt;&gt; print ["Outer" "spaced" ["inner" "not" "spaced"] "was an" "idea"]
Outer spaced innernotspaced was an idea
</code></pre>
<p>This seemed to give a best of both worlds scenario.  But it wasn't clear whether the blocks should be reduced, or exactly what this "unspaced non-reduced block" operation was.</p>
<h2>Today, I Think We Have A Direction and Rationale</h2>
<p><a href="https://forum.rebol.info/t/print-for-empty-block-empty-text-or-text-of-just-spaces/1641">I just posted my reasoning for why I think this should be true</a>:</p>
<pre><code>&gt;&gt; print ["abc" [] "def"]
abc def
</code></pre>
<p>Rebol2 and Red throw in two spaces and that's no good.</p>
<p>If BLOCK! is going to be an aggregator for material inside of PRINT then the base case needs to basically act as if no material is there.  Otherwise it's mostly useless, e.g. it couldn't be used for indentation:</p>
<pre><code>print [collect [repeat indent [keep tab]]], "what if indent is 0?"]
</code></pre>
<p>With that laid down I think it's safe to say that we want what's in a BLOCK! to be considered as being <em>pre-reduced</em>.  But also, <em>that it be unspaced</em>.</p>
<pre><code>&gt;&gt; word: "part"
== "part"

&gt;&gt; print ["Mixing" ["unspaced" word] "with" "spaced" word]
Mixing unspacedword with spaced part
</code></pre>
<p>We have a nice tool now with GET-BLOCK! that will reduce, so you have every tool on hand:</p>
<pre><code>&gt;&gt; print ["Mixing" :["unspaced" word] "with" "spaced" word]
Mixing unspacedpart with spaced part
</code></pre>
<h2>Invariant For BLOCK! Inside DELIMIT (hence PRINT, etc)</h2>
<p>So I came up with a good model for what the BLOCK! inside of the PRINT above will do.</p>
<p><strong>It does the same thing that APPEND of a BLOCK! to a string would do.</strong></p>
<pre><code>&gt;&gt; append copy {} ["unspaced" word]
== "unspacedword"
</code></pre>
<p><strong>Whatever that is, that's what happens with blocks in print.</strong>  So it's not FORM-ing, and no spaces.  It's the behavior of raw material being appended blockwise to a string.</p>
<p>This keeps us from having to define a separate new behavior.  It doesn't define that behavior, so we're not out of the woods.  But as I say, it's a slow process...one step at a time.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/block-behavior-in-delimit-hence-spaced-unspaced-print/1642">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/block-behavior-in-delimit-hence-spaced-unspaced-print/1642</link>
          <pubDate>Sat, 31 Jul 2021 17:35:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1642</guid>
          <source url="https://forum.rebol.info/t/block-behavior-in-delimit-hence-spaced-unspaced-print/1642.rss">BLOCK! Behavior In DELIMIT (hence SPACED, UNSPACED, PRINT)</source>
        </item>
        <item>
          <title>Shades of Distinction In Non-Valued Intents</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p><em><strong>UPDATE 2022:</strong> Rewritten completely to explain the modern answers for the topic than inbound links to this thread wanted to talk about.</em></p>
<hr>
<h2>Rebol2/R3-Alpha/Red Have Two Kinds of Nothing (both reified)</h2>
<p>Historical Redbol gives you two main choices for "nothingness"...<strong><code>#[none]</code></strong> and <strong><code>#[unset]</code></strong>... both of which can be found either in variables, or as values in blocks:</p>
<pre><code>rebol2&gt;&gt; block: reduce [none print "print returns unset"]
print returns unset
== [none unset]  ; misleadingly renders as WORD!s

rebol2&gt;&gt; type? first block
== none!

rebol2&gt;&gt; type? second block
== unset!
</code></pre>
<p>Using <code>#[none]</code> has the advantage of being "friendly" on access via word, allowing you to write things like:</p>
<pre><code>rebol2&gt;&gt; var: none

rebol2&gt;&gt; either var [print "do something with var"] [print "do something else"]
do something else
</code></pre>
<p>But when var contained an #[unset], you'd get an error instead:</p>
<pre><code>rebol2&gt;&gt; unset 'var

rebol2&gt;&gt; either var [print "do something with var"] [print "do something else"]
do something else
</code></pre>
<p>So instead of using var directly, you had to do something more circuitous and pass the word "var" into a special test routine (morally equivalent to today's <strong>set? 'var</strong>)</p>
<p><strong>Hence #[none] was reached for frequently out of convenience.  Yet this convenience came with a cost: it was very easy to accidentally append one to a block, even if its non-valued intent should have conveyed you might not have wanted to add anything at all.</strong></p>
<p>But it's hard to say: sometimes you <em>did</em> want to add #[none] to a block, to serve as a placeholder.</p>
<p>Also, being able to enumerate a block which contained #[unset] values was problematic, because if you did something like a FOR-EACH it would appear that the variable you were enumerating with was itself not set.</p>
<h2>Early Ren-C Made Reified BLANK! and non-Valued NULL</h2>
<p>One thing that bugged me was that there was no "pretty" representation for a non-valued state in a block... and that <code>#[none]</code> often thus displayed itself as the word <code>none</code> (seen in the example at the top of the post).</p>
<p>So the BLANK! datatype took the single underscore <strong>_</strong>.</p>
<pre><code>&gt;&gt; second [a _]
== _

&gt;&gt; if blank? _ [print "yep, it's a blank"]
yep it's a blank

&gt;&gt; if not _ [print "blank is also falsey"]
blank is also falsey
</code></pre>
<p>And critically, one of the first things I tried to do was rethink the <code>#[unset]</code> state into something that you'd never find in a block, and called it NULL (as well as made it correspond to C/Javascript null in the API):</p>
<pre><code>&gt;&gt; second [a _]
== _

&gt;&gt; third [a _]
; null
</code></pre>
<p>Since NULL couldn't be found in a block, it wasn't ambiguous when you got NULL back from a block operation as to whether there was a "null in that position".</p>
<p>But it's still just two things:</p>
<ul>
<li>
<p><strong>blank!</strong> - A nothing you can put in a block</p>
<ul>
<li>it was logically false</li>
<li>it was friendly via word access (no need for GET-WORD!)</li>
</ul>
</li>
<li>
<p><strong>null</strong> - A nothing you couldn't put in a block</p>
<ul>
<li>it was also logically false</li>
<li>it was <em>unfriendly</em> via word access (need GET-WORD! for :VAR, or SET? 'VAR)</li>
</ul>
</li>
</ul>
<p>This put you in a difficult situation for your choices of emptiness when you were dealing with something like:</p>
<pre><code>append block value  ; what nothing state should you use for value?
</code></pre>
<p>If you wanted to avoid accidentally appending blanks to arrays, you kind of wanted NULL so you'd get an error.  But once you used NULL, you could not write the convenient <strong><code>if value [...]</code></strong>  control structure.</p>
<h2>Later Ren-C added a separate "ornery" non-Value State</h2>
<p>A third state was added to be neither logically true nor false, and that would trigger an error on accessing a variable with it.  (I'll whitewash history a bit and say this state was always called "NIHIL", and also always could not be put in blocks.)</p>
<p>This was the new state of unset variables:</p>
<pre><code>&gt;&gt; unset 'x

&gt;&gt; x
** Error: X is an unset variable

&gt;&gt; get/any 'x
; nihil

&gt;&gt; if get/any 'x [print "Ornery!"]
** Error: nihil is neither logically true nor false
</code></pre>
<p>So NULL now represented a middle ground.  It was something that was easy to test for being nothing (using IF) but that was impossible to accidentally put into a block.</p>
<p>This gave you three behaviors:</p>
<pre><code>[1]  &gt;&gt; nihil-value
     ** Error: NIHIL-VALUE variable is unset

[2]  &gt;&gt; null-value
     ; null

     &gt;&gt; append [a b] null-value
     ** Error: APPEND does not allow adding NULL to blocks

[3]  &gt;&gt; blank-value
     == _

     &gt;&gt; append [a b] blank-value
     == [a b _]
</code></pre>
<h2>WORD! Isotopes Brought Infinite Non-Valued Choices</h2>
<p>Eventually the NULL state became the isotopic status of the WORD! null, so a <strong>~null~</strong> isotope.</p>
<p>It joined <strong>~true~</strong> and <strong>~false~</strong> as being isotopes you could test for truthiness and falseyness.  But if you were okay with getting an error on conditional testing, any other word could be used:</p>
<pre><code>  config: ~initialize-system-not-called~

  initialize-system: func [
      {Let's say this function reads the config file}
  ][
      ...
      config: [...]
  ]
</code></pre>
<p>This usually causes a nice labeled message anytime someone tries to use CONFIG:</p>
<p>Going this route would create a pain point for anyone who thought they were going to test for whether you had a config initialized by testing <strong>if config [...]</strong>.  So that has to be considered as whether it's what you want.</p>
<p>Because on the other hand, you should use the null isotope as the initialization for something you may run some code and find it doesn't assign, and you want to be able to test that.</p>
<pre><code> directory: ~null~

 for-each [key val] config [
     if key = 'directory [
         if directory [
             fail ["Directory was already set by config:" directory]
         ]
         directory: val
     ]
 ]
</code></pre>
<h2>VOID Provided a Clean "Opt-Out" Option</h2>
<p>An unfortunate sacrifice that had been made in the design was that the "non-valued" status of NULL was chosen to raise attention to an error condition, rather than be an opportunity to opt-out of an APPEND:</p>
<pre><code>&gt;&gt; append [a b] null-value
** Error: This is the choice that we went with

&gt;&gt; append [a b] null-value
== [a b]  ; would have been another possibility, but too accident prone
</code></pre>
<p>Some "strange" things were tried...such as making it so that appending a BLANK! was a no-op, and if you wanted to append a literal blank you had to append a quoted blank:</p>
<pre><code> &gt;&gt; append [a b] _
 == [a b]  ; hmmm.

 &gt;&gt; append [a b] quote _
 == [a b _]  ; hmmm.
</code></pre>
<p><em>(It wasn't that strange considering appending a BLOCK! would append its contents, and a quoted block was being tried as the way of specifying /ONLY.  This line of thinking ultimately led to the <a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">designs for the isotopes that solve things like splicing intent</a>, so it wasn't all for naught!)</em></p>
<p>When invisibles were first introduced, you couldn't "pass a void" to a function.  Because so long as the evaluator processed an argument which vanished, it would keep re-triggering until it found one.</p>
<pre><code>&gt;&gt; append [a b] comment "hi" 1 + 2
== [a b 3]  ; old idea was that comment vanished
</code></pre>
<p>This seemed justified because there wasn't anything you <em>could</em> pass.  Void was the absence of value, not something that a variable could take on.</p>
<p>But with a change in perspective, void became a state that variables were allowed to hold.  Not only that, but it could be quoted too:</p>
<pre><code>&gt;&gt; comment "hi"
; void

&gt;&gt; quote comment "hi"
== '
</code></pre>
<p>The re-triggering was removed, and I realized that void was the perfect choice for opting out of operations:</p>
<pre><code>&gt;&gt; append [a b] comment "hi"
== [a b]

&gt;&gt; append comment "hi" [a b c]
== ~null~  ; isotope
</code></pre>
<p>As you see above, an operation can return null when it doesn't have another good answer for giving back in case of a no-op.  This gives good error locality, since the null won't trigger another opting out unless you explicitly convert the null to a void with MAYBE.</p>
<pre><code>&gt;&gt; append (append comment "hi" [a b c]) [d e f]
** Error: APPEND doesn't accept ~NULL~ isotope for the series argument

&gt;&gt; maybe null
; void

&gt;&gt; append (maybe append comment "hi" [a b c]) [d e f]
== ~null~  ; isotope
</code></pre>
<p>Void variables were deemed to be something it would be undesirable to have be "too friendly".  So they were slated to be mean on WORD!-access, and instead MAYBE would be used with null variables.</p>
<p>This gives a (seemingly) complete picture</p>
<pre><code>[1]  &gt;&gt; nihil-value
     ** Error: NIHIL-VALUE variable is unset

      &gt;&gt; append [a b] get/any 'nihil-value
      ** Error: APPEND does not allow adding ~ isotopes to blocks
      
[2]  &gt;&gt; void-value
     ** Error: VOID-VALUE is void (use GET-WORD! or GET/ANY)

     &gt;&gt; append [a b] :void-value
     == [a b]

[3]  &gt;&gt; null-value
     == ~null~  ; isotope

     &gt;&gt; append [a b] null-value
     ** Error: APPEND does not allow adding NULL to blocks

[3a] &gt;&gt; append [a b] maybe null-value
     == [a b]

[4]  &gt;&gt; blank-value
     == _

     &gt;&gt; append [a b] blank-value
     == [a b _]</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604</link>
          <pubDate>Fri, 14 May 2021 14:44:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1604</guid>
          <source url="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604.rss">Shades of Distinction In Non-Valued Intents</source>
        </item>
        <item>
          <title>Why Isn&#39;t PRINT Invisible (&quot;void&quot;)?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <blockquote>
<p><strong>2022 UPDATE:</strong> Modern thinking in Ren-C is that void states <a href="https://forum.rebol.info/t/non-interstitial-invisibles-more-trouble-than-theyre-worth/1582">only vanish in "interstitial" slots</a>.  They can be recorded in variables, just not be put in blocks:</p>
<pre><code>   &gt;&gt; x: void
   ; void
</code></pre>
<p>The question of how permissive to be is still open, and at time of writing it does this:</p>
<pre><code>  &gt;&gt; x
  ; void

  &gt;&gt; 1 + 2 x
  == 3
</code></pre>
<p>This impacted some elements of the discussion, so I edited the post accordingly to bring it up to date.</p>
</blockquote>
<hr>
<p>Since PRINT doesn't have an interesting return value, we might ask what the harm would be in making it invisible, vs give back something that trips up things like ANY and ALL.</p>
<p>But let's generalize the question to SOME-FUNCTION where the key point is that at the time you write it, you haven't thought of a meaningful result for it.</p>
<h2>Limiting Interface Flexibility</h2>
<p>If at the time of writing a function you know that it doesn't have a meaningful return value, then making it void--instead of returning a trash value--ties your hands in changing it.</p>
<p>People will start writing things like:</p>
<pre><code>all [
    ...
    some-function ...  ; user assumes no effect, because invisible
    ...
]
</code></pre>
<p>But if SOME-FUNCTION had returned a trash value, then they could have gotten the same effect more obviously with:</p>
<pre><code>all [
    ...
    elide some-function ...
    ...
]
</code></pre>
<p>This also gives more freedom to change the interface later, if you think of an interesting value to return.  You can progressively add more return types after the fact.  But once people assume you always return void, this trap will happen...you're locked in forever in a way that was pretty much completely avoidable.</p>
<h2>In PRINT's Case, a Differentiated NULL Output Has Value</h2>
<p>Having a return value from PRINT that is either an ornery value or nothing lets you offer the neat option of returning NULL if the result of the print was nothing.</p>
<pre><code> &gt;&gt; line: "some text"
 &gt;&gt; (print line) then [print "We had output!"]
 some text
 We had output!

 &gt;&gt; line: null
 &gt;&gt; (print maybe line) then [print "We had output!"]
 ; null
</code></pre>
<p>To do this kind of thing requires having an output value that wouldn't trigger THEN when there is output.  So not null, and not void.  The none isotope works for this.</p>
<p>I might be convinced that how people want to use PRINT is universally enough that they would rather it be invisible.  But that would involve a very specific understanding of a very common function...similar to how <strong>elide</strong> and <strong>comment</strong> and <strong>assert</strong> and <strong>--</strong> are known to have no result.</p>
<p>I don't think the average "no meaningful result" function fits in this category, and I'd say I'm fairly skeptical if PRINT belongs in it.</p>
<h2>I Think "Void" Functions Should Be Used Sparingly</h2>
<p>I think the feature should be <em>discoverable</em>, because how it's done is unique...and we are giving it a more normal name ("void function")</p>
<p>And it's all right that these forms of RETURN generate void functions:</p>
<pre><code>f1: func [x] [return void]
f2: func [x] [return comment x]
f3: func [x] [return ()]
f4: func [x] [return (void)]
f5: func [x] [return (comment x)]
</code></pre>
<p>But this arity-0 return should <em>not</em> be a void function:</p>
<pre><code>f6: func [x] [return]
</code></pre>
<p>Instead it should be either an error, or act like <strong>return none</strong> (e.g. <code>return ~[]~</code>, an isotopic block representing an empty parameter pack).  While the latter <em>sounds</em> neat, it creates problems if people depend on it and start thinking they can throw a plain <code>return</code> in on its own line and not bother commenting things out after it... but the return picks it up:</p>
<p><a href="https://forum.rebol.info/t/line-continuation-and-arity-bugs-thoughts/1965" class="inline-onebox">Line Continuation and Arity Bugs: Thoughts?</a></p>
<p>So it's something that should not be allowed, or that has mitigation for this "return put on its own line in the middle of code" vulnerability.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/why-isnt-print-invisible-void/1466">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/why-isnt-print-invisible-void/1466</link>
          <pubDate>Mon, 18 Jan 2021 01:40:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1466</guid>
          <source url="https://forum.rebol.info/t/why-isnt-print-invisible-void/1466.rss">Why Isn&#39;t PRINT Invisible (&quot;void&quot;)?</source>
        </item>
        <item>
          <title>Right Quoting Left vs. Left Quoting Right... Fight!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>One might think it obvious that an ordinary function that quotes its first argument needs to "win" when it quotes right... even if an enfix function after it quotes left.  Because you want <strong>help -&gt;</strong> to give you the help for <strong>-&gt;</strong>, and not try to construct a function with the named parameter <code>help</code> (and then fail, due to having no body).</p>
<p>It's not quite that simple.  To cut to the core of why not, consider the following from the evaluator's point of view:</p>
<pre><code>(print "message", 'lib)/help -&gt;
</code></pre>
<p>Let's pretend for a moment that the evaluator gives the left hand side first dibs if it quotes its first argument.  In that world, if the left is looked up and doesn't quote the right, then the right hand side gets second dibs...and is checked if it quotes its left argument.</p>
<p>But notice that to get the knowledge of if left-quotes-right or not, <em>you have to evaluate that path</em>.  That can do processing which has costs you might not want... and groups can have side-effects (like the printing of the message).  But <a href="https://forum.rebol.info/t/letting-go-of-enfix-path-dreams-but-fixing-it-with-magic/794">since enfix dispatches from words only</a>, it doesn't have that problem; it can be checked "cheaply" with no side-effects, making what the right hand side wants of the left a good fit for the first thing to check...falling through to the expensive operation with side-effects that you then <em>know</em> wins.</p>
<p>So that's why I've been letting right quoting over left win.  But you might ask: how can HELP work without making you say  <strong>help '-&gt;</strong> (which might lead down the road of consistency and making you type <strong>help 'append</strong>) ?  Because there's been a rule: <strong>"Right operators that quote left get priority, BUT become inert if they have nothing following them."</strong></p>
<pre><code>help -&gt;                                ; gives you the help for lambda
help -&gt; [print ["argument is" help]]   ; gives you an arity-1 function 
</code></pre>
<p>Weird, but it seemed to work well enough.</p>
<p>Reviewing it now, it's somewhat limiting.  It means you can't have postfix operations that quote their left hand sides and take non-inert items on their left.  But the alternative would mean never being able to left-quote paths, or having dodgy properties when you do.  Hm.</p>
<h2>Can It Be Narrower?</h2>
<p>Might only "common quoting" <strong>:left</strong> escapable parameters have this loophole, with "I <em>really</em> want to quote it" operators being presumed rare enough to break HELP...and still run at end?</p>
<p>That sounds nice, but the "I really want to quote it" forms aren't going to be so rare.  Remember that we want:</p>
<pre><code>&gt;&gt; integer! = type of 1
== #[true]
</code></pre>
<p>This means the left can't be <strong>:property</strong> and deferent to enfix, which would let <code>integer! = type</code> run first (the way branches are deferent, to support lambdas).  I was proposing it be <strong>':property</strong> as a distinction, to say it's escapable -but- on only one unit of value.</p>
<p>So now we're back to what <strong>help of</strong> would do.  We could argue that in this case, OF could sense that it's at the end...but doesn't have an endable next parameter...and it is the <em>incompleteness</em> that drives it to be deferent vs. error.  <em>However, maybe it would win if it didn't take any arguments, and that would be acceptable...?</em></p>
<p>Let's make a sample postfix non-deferent operation.  Remember that in this model, HELP takes an escapable argument (at least <strong>:topic</strong>, possibly <strong>':topic</strong>)</p>
<pre><code>&gt;&gt; ?: enfixed func [':left] [print ["is" if not :left ["not"] "truthy"]]

&gt;&gt; _ ?
is not truthy

&gt;&gt; help ?
is truthy

&gt;&gt; help :('?)   ; generic escapability (help gets the WORD! `?`)
? is an ACTION!
...help text here...

&gt;&gt; help :?   ; also generic escapability (help gets the ACTION!)
? is an ACTION!  ; and ACTION! now carries labels, so it can know the "?"
...help text here...

&gt;&gt; help '?   ; unescaped, HELP gets QUOTED! (`'?`)
? is an ACTION!  ; maybe HELP does the unquote internally, to give the answeer?
...help text here...
</code></pre>
<p>To me, this seems to give a number of options to someone who wants to get HELP on a left quoting enfix operation.  Enough options to not make left-quoting enfix of words and paths impossible.</p>
<p>And how bad would this be, really?  If we narrowed it down to where the only operators that require escaping to get HELP are those that are <em>genuinely</em> postfix hard-or-medium-quoting with no arguments... <em>that's a pretty small set</em>.  To date, we have ZERO such operators in the box, they only exist in tests.</p>
<p>(e.g. OF quotes, but still needs another argument, so that would drive its deference so that <strong>help of</strong> would dispatch to HELP with OF as the parameter...while <strong>help of 10</strong> would dispatch to OF with 'help as the property and 10 as the value)</p>
<h2>This is important!</h2>
<p><strong>Having these things work out is the point, because this is what the unique offering is.</strong>  These issues all lock together on foundational questions e.g. those pointed out by <a href="https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359"><code>"speaking with tics"</code></a>.</p>
<p>When left-quoting enfix operators can subvert a quote from the right, that means when you say <strong>for-each x</strong> you can't be sure that X won't act on the FOR-EACH.  But we can see that as different rom the situation <strong>type of</strong> is in...since OF gets the first shot.</p>
<p>Does that suggest the "out-of-the-box" constructs always have you put ticks on things you want literally on the right?  It doesn't seem we'd want to bear the consequences of that on HELP...</p>
<pre><code>&gt;&gt; help append
** Script Error: append is missing its series argument

 &gt;&gt; help 'append
 ; this would work...
</code></pre>
<p>Just have to keep everything all lined up.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/right-quoting-left-vs-left-quoting-right-fight/1434">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/right-quoting-left-vs-left-quoting-right-fight/1434</link>
          <pubDate>Mon, 14 Dec 2020 23:53:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1434</guid>
          <source url="https://forum.rebol.info/t/right-quoting-left-vs-left-quoting-right-fight/1434.rss">Right Quoting Left vs. Left Quoting Right... Fight!</source>
        </item>
        <item>
          <title>MOLD and LOAD parity</title>
          <dc:creator><![CDATA[rgchris]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>It occurred to me in <a href="https://forum.rebol.info/t/the-simple-things-matter-the-most/1428/8">this post</a> that MOLD/ONLY appears to work at odds to other /ONLY options:</p>
<pre><code>&gt;&gt; append [] []
== []

‌&gt;&gt; append/only [] []
== [[]]

‌&gt;&gt; mold []
== "[]"

‌&gt;&gt; mold/only []
== ""
</code></pre>
<p>As <a href="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/10">my solution to /ONLY</a> is to use an optimized equivalent of <a><strong>func [value][reduce [value]]</strong></a>, this highlights the discrepency:</p>
<pre><code>&gt;&gt; append only [] []  ; same as append/only
== [[]]

&gt;&gt; mold only []  ; not same as mold/only
== "[[]]"
</code></pre>
<p>How then should MOLD handle blocks, and what are the implications for LOAD? Let's assume that current MOLD/ONLY is the correct behaviour for BLOCK!:</p>
<pre><code>&gt;&gt; mold [1 2 3]
== "1 2 3"

&gt;&gt; load "1 2 3"
== [1 2 3]
</code></pre>
<p>This seems fine until you get to single-length blocks:</p>
<pre><code>&gt;&gt; mold [1]
== "1"

&gt;&gt; load "1"
== 1
</code></pre>
<p>Clearly this is now an inconsistency in LOAD. LOAD/ALL would get you there:</p>
<pre><code>&gt;&gt; load/all "1"
== [1]
</code></pre>
<p>Should LOAD/ALL then be the default? Probably. Proposition: MOLD/ONLY and LOAD/ALL become MOLD and LOAD. Yay! There is a parity where it matters most: (de)serialization of a block of values.</p>
<p>The wrinkle is: loading singular values is useful. Lost is the MOLD/LOAD parity when handling non-blocks:</p>
<pre><code>&gt;&gt; mold 1
== "1"

&gt;&gt; load "1"
== [1]
</code></pre>
<p>Where to go with that? Lost is shorthand validation of snippets of text:</p>
<pre><code>&gt;&gt; type-of load "10-Dec-2020"
== date!

&gt;&gt; type-of load "http://rebol.info"
== url!
</code></pre>
<p>I'd argue that this is beyond the scope of LOAD—LOAD is an overloaded (<img src="https://forum.rebol.info/images/emoji/twitter/sunglasses.png?v=9" title=":sunglasses:" class="emoji" alt=":sunglasses:">) function and the more critical behaviour is to return a block. It would be more fitting to dedicate a separate wrapper for TRANSCODE that is less likely to use the polymorphic demands of loading from external sources and craps out if, leading/trailing whitespace aside, the content doesn't conform to a single value (even if that value is a GROUP!). Spitballing—DETECT, DISCERN, whatever:</p>
<pre><code>&gt;&gt; map-each value ["10-Dec-2020" "http://rebol.info"] [type-of detect value]
== [date! url!]

&gt;&gt; detect "1 2 3"
== ERROR! #!*^!#%@$
</code></pre>
<p>Thus MOLD of BLOCK! holds parity with LOAD; MOLD of non-block holds parity with DETECT (or other name).</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/mold-and-load-parity/1429">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/mold-and-load-parity/1429</link>
          <pubDate>Thu, 10 Dec 2020 23:00:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1429</guid>
          <source url="https://forum.rebol.info/t/mold-and-load-parity/1429.rss">MOLD and LOAD parity</source>
        </item>
        <item>
          <title>What should do of empty block (`DO []`) do?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>I've pointed out that the answer for things like "what should a loop that never runs its body" have varied.</p>
<pre><code>rebol2/r3-alpha&gt;&gt; type? while [false] ["whatever"]
== none!

red&gt;&gt; type? while [false] ["whatever"]
== unset!
</code></pre>
<p>But it's consistent historically that if something runs <strong>do []</strong> then you get an "UNSET!"</p>
<pre><code>rebol2/r3-alpha/red&gt;&gt; type? do []
== unset!
</code></pre>
<h2>New Names Available</h2>
<p>One of the benefits of having lots of different labeled BAD-WORD!s is to stop collapsing all "potentially error-triggering situations" into the same uninformative name.</p>
<pre><code>&gt;&gt; do []
== ~empty~  ; isotope
</code></pre>
<p>Or maybe that's considered to be where ~void~ isotopes comes from:</p>
<pre><code>&gt;&gt; do []
== ~void~  ; isotope
</code></pre>
<p>In either case, you've still got a type that will be "ornery" and neither true nor false, that errors if you try to access it.  But by not reporting <code>~unset~</code> you're helping to convey that this wasn't the by-product of encountering an unset variable somewhere.  It might help people get their bearings more easily.</p>
<p>I've mentioned that this is a bit unfortunate in the sense of canonizing English into the evaluator mechanics.  But I'm taking away the option by <a href="https://forum.rebol.info/t/void-choices-the-role-of-english-in-the-evaluator/1413/6">removing <code>~</code> as a form of BAD-WORD!</a>...which is what this case had been before.</p>
<h2>Or Is This A Job For NULL ?</h2>
<p>We have some cases where emptiness produces pure NULL.  With DELIMIT and its specializations, an all empty block produces the same thing that an all-NULL-producing block produces:</p>
<pre><code>&gt;&gt; unspaced [if false ["a"] if false ["b"]]
; null

&gt;&gt; unspaced []
; null

&gt;&gt; unspaced compose [(if false ["a"]) (if false ["b"])]
; null
</code></pre>
<p>There's some neat combining of this with PRINT.  Although PRINT draws your attention to calling with NULL via error, a BLANK! will get it to overlook that and just be a no-op:</p>
<pre><code>&gt;&gt; print unspaced compose [(if false ["a"]) (if false ["b"])]
** error, print doesn't take NULL

&gt;&gt; print try unspaced compose [(if false ["a"]) (if false ["b"])]
; null
</code></pre>
<p><strong>Can anyone think of a case where there's a balance of provable value for something like a <code>do compose [...]</code> whose contents have all boiled away to be NULL instead of ~void~ ?</strong></p>
<p>You could get the same result by saying <strong>do compose [null (...whatever...)]</strong> so it's not far out of reach to have a default value of anything you like.</p>
            <p><small>16 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426</link>
          <pubDate>Wed, 09 Dec 2020 23:45:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1426</guid>
          <source url="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426.rss">What should do of empty block (`DO []`) do?</source>
        </item>
  </channel>
</rss>

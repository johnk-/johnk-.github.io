<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Feature Discover - AltRebol</title>
    <link>https://forum.rebol.info/c/usage/feature-discover/24</link>
    <description>Topics in the &#39;Feature Discover&#39; category Rebol and Red have quite a few cool features - this is PR for them.</description>
    
      <lastBuildDate>Sun, 03 Mar 2024 15:28:36 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/usage/feature-discover/24.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>REIFY and DEGRADE: a Narrower META and UNMETA</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>In the "small improvements can be big" category, I think that I've settled on the name for the function that turns quasiforms into antiforms, but leaves everything else alone: <strong>DEGRADE</strong>...and its complement <strong>REIFY</strong> which turns antiforms into quasiforms (but leaves everything else alone).</p>
<pre><code>&gt;&gt; first [1020 ~null~]
== 1020

&gt;&gt; second [1020 ~null~]
== ~null~

&gt;&gt; degrade first [1020 ~null~]
== 1020

&gt;&gt; degrade second [1020 ~null~]
== ~null~  ; anti

&gt;&gt; 304
== 304

&gt;&gt; reify 304
== 304

&gt;&gt; true
== ~true~  ; anti

&gt;&gt; reify true
== ~true~
</code></pre>
<p>If you're dealing with a full-band situation where you genuinely don't know if you're working with a "meaningful quasiform" where <em>quasi means quasi</em>, you have to use META and UNMETA.  But if you know that quasiforms aren't part of your data of interest, REIFY and DEGRADE can help you dodge adding and removing quote marks much (or most) of the time.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="12" data-topic="1560">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"><a href="https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560/12">Weird WORD!s - Allow, But Escape Them?</a></div>
<blockquote>
<p>Maybe it would be better (and give Chris less of a heart attack) if it said:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">for-each [sigil' items] [
    ~null~ [  word   tu.p.le   pa/th   [bl o ck]   (gr o up)  ]
    '::    [  word:  tu.p.le:  pa/th:  [bl o ck]:  (gr o up): ]
    ':     [ :word  :tu.p.le  :pa/th  :[bl o ck]  :(gr o up)  ]
    '^     [ ^word  ^tu.p.le  ^pa/th  ^[bl o ck]  ^(gr o up)  ]
    '&amp;     [ &amp;word  &amp;tu.p.le  &amp;pa/th  &amp;[bl o ck]  &amp;(gr o up)  ]
    '@     [ @word  @tu.p.le  @pa/th  @[bl o ck]  @(gr o up)  ]
    '$     [ $word  $tu.p.le  $pa/th  $[bl o ck]  $(gr o up)  ]
 ][
      for-each item items [
          if (unmeta sigil') &lt;&gt; sigil of item [fail [mold item]]
      ]
 ]
</code></pre>
</blockquote>
</aside>
<p>I like how DEGRADE can be used in situations like this to help you strike the quotes on the normal values...since SIGIL OF never returns quasiforms, only SIGIL! or a null antiform:</p>
<pre><code>for-each [sigil items] [
    ~null~ [  word   tu.p.le   pa/th   [bl o ck]   (gr o up)  ]
    ::     [  word:  tu.p.le:  pa/th:  [bl o ck]:  (gr o up): ]
    :      [ :word  :tu.p.le  :pa/th  :[bl o ck]  :(gr o up)  ]
    ^      [ ^word  ^tu.p.le  ^pa/th  ^[bl o ck]  ^(gr o up)  ]
    &amp;      [ &amp;word  &amp;tu.p.le  &amp;pa/th  &amp;[bl o ck]  &amp;(gr o up)  ]
    @      [ @word  @tu.p.le  @pa/th  @[bl o ck]  @(gr o up)  ]
    $      [ $word  $tu.p.le  $pa/th  $[bl o ck]  $(gr o up)  ]
][
    for-each item items [
        if (degrade sigil) &lt;&gt; sigil of item [
            fail [mold item]
        ]
    ]
]
</code></pre>
<p>I think this will be a useful and common pattern.</p>
<p>Void being a word antiform is locking this all up into place!</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/atom_symbol.png?v=12" title=":atom_symbol:" class="emoji only-emoji" alt=":atom_symbol:" loading="lazy" width="20" height="20"> <img src="https://forum.rebol.info/images/emoji/twitter/+1.png?v=12" title=":+1:" class="emoji only-emoji" alt=":+1:" loading="lazy" width="20" height="20"></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/reify-and-degrade-a-narrower-meta-and-unmeta/2163">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/reify-and-degrade-a-narrower-meta-and-unmeta/2163</link>
          <pubDate>Sun, 03 Mar 2024 15:28:36 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2163</guid>
          <source url="https://forum.rebol.info/t/reify-and-degrade-a-narrower-meta-and-unmeta/2163.rss">REIFY and DEGRADE: a Narrower META and UNMETA</source>
        </item>
        <item>
          <title>Introducing DELIMIT (plus SPACED and UNSPACED)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>Ren-C offers an alternative to historical AJOIN and REJOIN called DELIMIT:</p>
<pre><code>&gt;&gt; delimit "," ["foo" 1 + 2 "bar"]
== "foo,3,bar"

&gt;&gt; delimit/head "," ["foo" 1 + 2 "bar"]
== ",foo,3,bar"

&gt;&gt; delimit/tail "," ["foo" 1 + 2 "bar"]
== "foo,3,bar,"

&gt;&gt; delimit/head/tail "," ["foo" 1 + 2 "bar"]
== ",foo,3,bar,"
</code></pre>
<p>If you don't want it to reduce, you can use an @ block:</p>
<pre><code>&gt;&gt; delimit "," @["foo" 1 + 2 "bar"]
== "foo,1,+,2,bar"
</code></pre>
<p>SPACED and UNSPACED are specializations, running through the same code for stringifying any non-string contents.</p>
<pre><code>&gt;&gt; spaced ["foo" 1 + 2 "bar"]
== "foo 3 bar"

&gt;&gt; unspaced ["foo" 1 + 2 "bar"]
== "foo3bar"
</code></pre>
<p>PRINT uses SPACED internally when you pass it a block.  You can use <strong>print unspaced</strong> to pass it a string if you want unspaced intent.</p>
<pre><code>&gt;&gt; print ["foo" 1 + 2 "bar"]
foo 3 bar

&gt;&gt; print unspaced ["foo" 1 + 2 "bar"]
foo3bar
</code></pre>
<p>If you use a character (like <span class="hashtag">#a</span>) instead of a string (like "a"), the delimiting won't be applied.  For instance, a newline won't leave spaces on either end of the line break:</p>
<pre><code>&gt;&gt; spaced ["foo" 1 + 2 newline "bar"]
== "foo 3^/bar"
</code></pre>
<p>NULLs will trigger errors, VOIDs will vanish.</p>
<pre><code>&gt;&gt; spaced ["foo" if false [1 + 2] "bar"]
== "foo bar"

&gt;&gt; spaced ["foo" pick [a b] 3 "bar"]
** Script Error: non-NULL value required (see MAYBE, TRY, REIFY)

&gt;&gt; spaced ["foo" maybe pick [a b] 3 "bar"]
== "foo bar"
</code></pre>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/introducing-delimit-plus-spaced-and-unspaced/2102">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/introducing-delimit-plus-spaced-and-unspaced/2102</link>
          <pubDate>Thu, 11 Jan 2024 00:42:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2102</guid>
          <source url="https://forum.rebol.info/t/introducing-delimit-plus-spaced-and-unspaced/2102.rss">Introducing DELIMIT (plus SPACED and UNSPACED)</source>
        </item>
        <item>
          <title>COMPOSE of TUPLE! and PATH! (and toplevel GROUP!)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>While working on <a class="mention" href="https://forum.rebol.info/u/blackattr">@BlackATTR</a>'s query, I noticed code that was making paths (now tuples) out of components via TO TUPLE! COMPOSE of a BLOCK!.  Like this:</p>
<pre><code>to tuple! compose [obj clauses (kwd.1)]
</code></pre>
<p>But did you know that COMPOSE can act directly on TUPLE! and PATH!  You could instead just write:</p>
<pre><code>compose $obj.clauses.(kwd.1)
</code></pre>
<p>It supports splices as well:</p>
<pre><code>&gt;&gt; compose $(10 + 20)/a/b/(spread [c d e])/(reverse [g f])
== 30/a/b/c/d/e/[f g]
</code></pre>
<p>And if you remember that TUPLE! can be nested underneath PATH! (not vice versa) then you can COMPOSE/DEEP and handle mixed tuples and paths:</p>
<pre><code>&gt;&gt; compose/deep $(10 + 20)/a/b.(spread [c d e])
== 30/a/b.c.d.e
</code></pre>
<p>Voids can vanish...so there can be fewer dots in an output tuple than in the input:</p>
<pre><code>&gt;&gt; compose $a.(if false [b]).c
== a.c
</code></pre>
<p>Empty splices will vanish as well:</p>
<pre><code>&gt;&gt; compose $a.(spread []).c
== a.c
</code></pre>
<p>You can't compose in NULLs as an important safety measure...central to the design!</p>
<pre><code>&gt;&gt; compose $a.(select [x 10 y 20] 'b).c
** Script Error: non-NULL value required (see MAYBE, TRY, REIFY)
** Near: [a ** (select [x 10 y 20] 'b) c]
</code></pre>
<p>But don't forget about MAYBE as the way to convert nulls to void when that's what you meant!</p>
<pre><code>&gt;&gt; compose $a.(maybe select [x 10 y 20] 'b).c
== a.c
</code></pre>
<h2>
<a name="you-can-also-compose-a-group-1" class="anchor" href="https://forum.rebol.info#you-can-also-compose-a-group-1"></a>You can also COMPOSE a GROUP!</h2>
<p>In R3-Alpha, only BLOCK! would compose.  Everything else was passed-through as-is, including GROUP!s (PAREN!s in their terminology)</p>
<pre><code>r3-alpha&gt;&gt; compose quote (1 + (2 + 3))  ; R3-alpha QUOTE (modern THE)
== (1 + (2 + 3))
</code></pre>
<p>Red just doesn't allow it:</p>
<pre><code>red&gt;&gt; compose quote (1 + (2 + 3))   ; Red QUOTE (modern THE)
*** Script Error: compose does not allow paren! for its value argument
</code></pre>
<p>So you'd wind up having to make BLOCK!s and then convert them:</p>
<pre><code>red&gt;&gt; as paren! compose [1 + (2 + 3)]
== (1 + 5)
</code></pre>
<p>But in Ren-C, group composing works... it just leaves the top group as-is.</p>
<pre><code>&gt;&gt; compose $(1 + (2 + 3))
== (1 + 5)
</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/compose-of-tuple-and-path-and-toplevel-group/2056">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/compose-of-tuple-and-path-and-toplevel-group/2056</link>
          <pubDate>Thu, 19 Oct 2023 06:39:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2056</guid>
          <source url="https://forum.rebol.info/t/compose-of-tuple-and-path-and-toplevel-group/2056.rss">COMPOSE of TUPLE! and PATH! (and toplevel GROUP!)</source>
        </item>
        <item>
          <title>There Came an ECHO</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>I just fixed a bug in Sea of Words...which hopefully means it's a little more trustworthy.</p>
<p>It seemed like a good time to add the ECHO feature I've talked about.</p>
<pre><code>&gt;&gt; echo It's this feature, which I've described in the past.
It's this feature, which I've described in the past.
</code></pre>
<p>ECHO is a variadic function which processes what you pass it to the end of line.  If you prefer, you can also use a BLOCK!.</p>
<pre><code>&gt;&gt; echo [A block allows
    you to put an arbitrary number
    of newlines]
A block allows you to put an arbitrary number of newlines

&gt;&gt; echo [Or two echos] echo [on the same line]
Or two echos
on the same line
</code></pre>
<p>There is a variable substitution mechanism so you can use @ to point out variables or expressions.</p>
<pre><code>&gt;&gt; x: 10
&gt;&gt; echo The value is @x
The value is 10

&gt;&gt; echo The doubled value is @(x * 2)
The doubled value is 20
</code></pre>
<h2>It's Shorter!</h2>
<p>Can't argue against that.</p>
<pre><code>print ["You have written" num-lines "lines of code."]

echo [You have written @num-lines lines of code.]

echo You have written @num-lines of code.
</code></pre>
<h2>The API Benefits</h2>
<p>Not needing quotes helps API calls:</p>
<pre><code>rebElide("print [{You have written}", num_lines, "{lines of code.}]");

rebElide("echo [You have written", num_lines, "lines of code.]");

rebElide("echo You have written", num_lines, "lines of code.");
</code></pre>
<p>It's the kind of change that opens up the choose-your-own-adventure of syntax to let you build a system more like bash, or less like bash.  It's an important decoupling of the use of words from the creation of variables.  So, onward.</p>
            <p><small>8 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/there-came-an-echo/1722">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/there-came-an-echo/1722</link>
          <pubDate>Sun, 19 Sep 2021 17:05:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1722</guid>
          <source url="https://forum.rebol.info/t/there-came-an-echo/1722.rss">There Came an ECHO</source>
        </item>
        <item>
          <title>APPLY II: The Revenge!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>I'd said <em>"It's time to bring back APPLY"</em>.</p>
<p>...and by <em>"it's time"</em> I apparently meant <em>"within the next year, maybe?"</em>...</p>
<p>But better late than never, right?  It's in!</p>
<h2>
<a name="refinements-can-be-provided-in-any-order-1" class="anchor" href="https://forum.rebol.info#refinements-can-be-provided-in-any-order-1"></a>Refinements Can be Provided In Any Order</h2>
<pre><code>[a b c d e d e] = apply :append [[a b c] [d e] /dup 2]
[a b c d e d e] = apply :append [/dup 2 [a b c] [d e]]
[a b c d e d e] = apply :append [[a b c] /dup 2 [d e]]

[a b c d d] = apply :append [/dup 2 [a b c] [d e] /part 1]
[a b c d d] = apply :append [[a b c] [d e] /part 1 /dup 2]
</code></pre>
<h2>
<a name="any-parameter-not-just-refinements-can-be-used-by-name-2" class="anchor" href="https://forum.rebol.info#any-parameter-not-just-refinements-can-be-used-by-name-2"></a>Any Parameter (Not Just Refinements) Can Be Used By Name</h2>
<p>Once a parameter has been supplied by name, it is no longer considered for consuming positionally.</p>
<pre><code>[a b c d e] = apply :append [/series [a b c] /value [d e]]
[a b c d e] = apply :append [/value [d e] /series [a b c]]

[a b c d e] = apply :append [/series [a b c] [d e]]
[a b c d e] = apply :append [/value [d e] [a b c]]
</code></pre>
<h2>
<a name="commas-are-ok-so-long-as-they-are-interstitial-3" class="anchor" href="https://forum.rebol.info#commas-are-ok-so-long-as-they-are-interstitial-3"></a>Commas Are Ok So Long As They Are Interstitial</h2>
<pre><code>[a b c d e d e] = apply :append [[a b c], [d e], /dup 2]
[a b c d e d e] = apply :append [/dup 2, [a b c] [d e]]

&gt;&gt; apply :append [/dup, 2 [a b c] [d e]]
** Script Error: end was reached while trying to set /dup
</code></pre>
<h2>
<a name="giving-too-many-arguments-defaults-to-an-error-4" class="anchor" href="https://forum.rebol.info#giving-too-many-arguments-defaults-to-an-error-4"></a>Giving Too Many Arguments Defaults To An Error</h2>
<pre><code>&gt;&gt; apply :append [[a b c] [d e] [f g]]
** Script Error: Too many values in processed argument block of APPLY.
</code></pre>
<p>If you want, you can ask it to /RELAX</p>
<pre><code>&gt;&gt; apply/relax :append [[a b c] [d e] [f g]]
== [a b c [d e]] 
</code></pre>
<h2>
<a name="refinements-must-be-followed-by-a-non-refinement-5" class="anchor" href="https://forum.rebol.info#refinements-must-be-followed-by-a-non-refinement-5"></a>Refinements Must Be Followed By A Non-Refinement</h2>
<pre><code>&gt;&gt; apply :append [/dup /part 1 [a b c] [d e]]
** Script Error: end was reached while trying to set /dup
</code></pre>
<p>But you can pass refinements as arguments to refinements...just use a quote!</p>
<pre><code>&gt;&gt; tester: func [/refine [any-value!]] [refine]

&gt;&gt; apply :tester [/refine '/ta-da!]
== /ta-da!
</code></pre>
<h2>
<a name="no-arg-refinements-permit-okay-and-null-6" class="anchor" href="https://forum.rebol.info#no-arg-refinements-permit-okay-and-null-6"></a>No-Arg Refinements Permit OKAY and NULL</h2>
<p>Remember: <em>the EVAL FRAME! mechanics do not change anything.</em>  So if a refinement doesn't take an argument, <a href="https://forum.rebol.info/t/why-no-argument-refinements-are-okay-or-null/735">the only legal values for that refinement in the frame are OKAY and NULL</a>.</p>
<pre><code>&gt;&gt; testme: func [/refine] [refine]

&gt;&gt; apply :testme [/refine okay]
== ~okay~  ; anti

&gt;&gt; apply :testme [/refine null]
== ~null~  ; anti

&gt;&gt; apply :testme [/refine 1020]
** Error: No-Arg refinements can only be ~okay~ and ~null~ antiforms
</code></pre>
<h2>
<a name="meta-arguments-are-accounted-for-7" class="anchor" href="https://forum.rebol.info#meta-arguments-are-accounted-for-7"></a>^META Arguments Are Accounted For</h2>
<p>APPLY detects when a parameter is meta and will level it up...because the low-level frame mechanics aren't allowed to editorialize:</p>
<pre><code>&gt;&gt; non-detector: func [arg] [arg]  ; not a meta argument, isotopes illegal

&gt;&gt; apply :non-detector [pack [10 20]]
== 10

&gt;&gt; detector: func [^arg] [arg]

&gt;&gt; apply :detector [pack [10 20]]
== ~['10 '20]~
</code></pre>
<p><strong>I know not everyone has gotten their heads around isotopes yet, but they are critical... this stuff was the missing link to making it all gel.</strong></p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/dizzy.png?v=12" title=":dizzy:" class="emoji only-emoji" alt=":dizzy:" loading="lazy" width="20" height="20"> <img src="https://forum.rebol.info/images/emoji/twitter/dizzy.png?v=12" title=":dizzy:" class="emoji only-emoji" alt=":dizzy:" loading="lazy" width="20" height="20"> <img src="https://forum.rebol.info/images/emoji/twitter/dizzy.png?v=12" title=":dizzy:" class="emoji only-emoji" alt=":dizzy:" loading="lazy" width="20" height="20"></p>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/apply-ii-the-revenge/1834">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/apply-ii-the-revenge/1834</link>
          <pubDate>Tue, 17 Aug 2021 07:58:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1834</guid>
          <source url="https://forum.rebol.info/t/apply-ii-the-revenge/1834.rss">APPLY II: The Revenge!</source>
        </item>
        <item>
          <title>Circling Multi-Returns: Choose Which Is Expression Result</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>Multi-Returns have a feature of being able to "circle" which result will be the value of the overall expression.  You do the circling with an <strong><code>@word</code></strong> or an <strong><code>@tu.p.le</code></strong>... or an <strong><code>@(gr o up)</code></strong> that evaluates to what you want to assign.</p>
<h3>
<a name="demo-1" class="anchor" href="https://forum.rebol.info#demo-1"></a>Demo!</h3>
<p>Here's a function with a secondary return value to demonstrate with:</p>
<pre><code>multi: func [
    return: "Main return value"
        [integer!]
    @secondary: "Secondary return value"
        [integer!]
][
    secondary: 20
    return 10
]
</code></pre>
<p>Traditionally you could ask for both results, and the overall result would be the first return:</p>
<pre><code>&gt;&gt; [a b]: multi
== 10  ; defaults to same value as first result, e.g. A

&gt;&gt; a
== 10

&gt;&gt; b
== 20
</code></pre>
<p>But now you can "circle" to ask for a different result, e.g. the second:</p>
<pre><code>&gt;&gt; [a @b]: multi
== 20  ; same value as b

&gt;&gt; a
== 10

&gt;&gt; b
== 20
</code></pre>
<p>You can combine this with things like GROUP!s to calculate the variable name, or even omit the variable name and use <code>#</code>:</p>
<pre><code>&gt;&gt; [a @(#)]: multi
== 20  

&gt;&gt; a
== 10
</code></pre>
<p>There are some places where this comes in handy, although you generally want to pick the main return to be the thing people are most interested in responding to (e.g. determining success or failure of an operation).</p>
<p>There's also a characteristic that only the main return can return unstable isotopes without having to contort the value convention itself to encode the void state (e.g. by ^META quoting the results).  So that should be weighed as well when thinking about how to plan the results.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/circling-multi-returns-choose-which-is-expression-result/1587">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/circling-multi-returns-choose-which-is-expression-result/1587</link>
          <pubDate>Sat, 17 Apr 2021 06:06:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1587</guid>
          <source url="https://forum.rebol.info/t/circling-multi-returns-choose-which-is-expression-result/1587.rss">Circling Multi-Returns: Choose Which Is Expression Result</source>
        </item>
        <item>
          <title>Case Study of Case Behavior: The AN Function</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>In thinking about weird applications of case, I was reminded of the little trick of the AN function:</p>
<pre><code>&gt;&gt; an "integer"
== "an integer"

&gt;&gt; an "text"
== "a text"
</code></pre>
<p>It simply checks the letters of the start of the rendering of what comes after it, and resolves to either "a" or "an".  I came up with it during the automatic generation of help strings for typecheckers, something along the lines of:</p>
<pre><code>for-each type data-types [
    help-string: spaced ["Checks to see if value is" an mold type]
    ...
]
</code></pre>
<p>But what if the A or An is at the start of a sentence?  Wouldn't the case of the operator matter?</p>
<pre><code>&gt;&gt; An "integer"
== "An integer"
</code></pre>
<p>Or how about all-caps?</p>
<pre><code>&gt;&gt; AN "INTEGER"
== "AN INTEGER"
</code></pre>
<p>In a case-insensitive world, all of these calls are to the same function.  So what it had to do was consult the stack to see what the label was it was invoked with, and go by the case of that.</p>
<p>But in a case-sensitive world, these would be three different functions (most likely, specializations of a core <code>AN*</code> that took what casing you wanted).</p>
<p>I'm not sure where this fits in the <a class="mention" href="https://forum.rebol.info/u/mark-hi">@Mark-hi</a> taxonomy of rightness or wrongness.  But it does point to an axis of flexibility where someone can use stack reflection to force case-sensitive behavior in a case-insensitive system.</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/case-study-of-case-behavior-the-an-function/1469">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/case-study-of-case-behavior-the-an-function/1469</link>
          <pubDate>Mon, 18 Jan 2021 21:37:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1469</guid>
          <source url="https://forum.rebol.info/t/case-study-of-case-behavior-the-an-function/1469.rss">Case Study of Case Behavior: The AN Function</source>
        </item>
        <item>
          <title>Can Functions You ‚û§ Now REORDER</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>As things have slowly nudged along in the function composition space, I've kept a generic reordering facility in mind.</p>
<p>And today... less than a week into 2021... we have a first version of it, tentatively named REORDER.</p>
<pre><code>&gt;&gt; append-value-first: reorder :append [value series]

&gt;&gt; append-value-first &lt;item&gt; [a b c]
== [a b c &lt;item&gt;]
</code></pre>
<p>As with other function derivations, there's a lot of benefit over writing <strong>func [value series] [append series value]</strong> !</p>
<p>First of all, it's nearly as fast as the original function. It adds a little overhead to do the rearrangement, but it places values in the same underlying frame slots...and introduces no new frame of its own.</p>
<p>You keep the HELP, parameter names, and descriptions...as well as keep the refinements:</p>
<pre><code>&gt;&gt; append-value-first/dup &lt;item&gt; [a b c] 3
== [a b c &lt;item&gt; &lt;item&gt; &lt;item&gt;]
</code></pre>
<h2>Usage Notes</h2>
<p><em>You need to provide all the required arguments</em>.  It won't guess where you want parameters to go.</p>
<pre><code>&gt;&gt; reorder :append [value]
** Script Error: append is missing its series argument
</code></pre>
<p>However... <strong>you can position optional arguments in the ordering if you like!</strong></p>
<pre><code>&gt;&gt; append-val-dup-ser: reorder :append [value dup series]

&gt;&gt; append-val-dup-ser &lt;item&gt; 3 [a b c]
== [a b c &lt;item&gt; &lt;item&gt; &lt;item&gt;]
</code></pre>
<p>As usual, I will plead for the submission of more tests:</p>
<p><strong><a href="https://github.com/metaeducation/ren-c/blob/master/tests/functions/reorder.test.reb">%tests/functions/reorder.test.reb</a></strong></p>
<p>I point out that this is based on a more foundational ability, to specify non-refinement arguments in paths...which pushes them to the end of the pending arguments:</p>
<pre><code>&gt;&gt; append/series &lt;item&gt; [a b c]
== [a b c &lt;item&gt;]
</code></pre>
<p>REORDER gives you a more intuitive interface to it, but you can also do it that way if you feel like it!</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/can-functions-you-now-reorder/1458">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/can-functions-you-now-reorder/1458</link>
          <pubDate>Wed, 06 Jan 2021 02:46:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1458</guid>
          <source url="https://forum.rebol.info/t/can-functions-you-now-reorder/1458.rss">Can Functions You ‚û§ Now REORDER</source>
        </item>
        <item>
          <title>For Better or Worse: MACRO</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>So it's long been theorized that there could exist a form of function that would splice its result into the feed of execution.  And now we have it:</p>
<pre><code> appender: macro [x /ref] [
      if ref [
          return [append x second]  ; return block of "incomplete" code
      ] else [
          return [append x first]
      ]
 ]

 &gt;&gt; appender [a b c] [1 2 3]
 == [a b c 1]  ; acts as spliced `&lt;&lt;append x first&gt;&gt; [a b c] [1 2 3]`

 &gt;&gt; appender/ref [a b c] [1 2 3]
 == [a b c 2]  ; acts as spliced `&lt;&lt;append x second&gt;&gt; [a b c] [1 2 3]`
</code></pre>
<p>So you return a BLOCK! of what you want spliced in at the callsite.  The bindings in that block won't be changed, however...so the <strong>x</strong> will still refer to the parameter value, not some x at the callsite.</p>
<p>The reason this exists now is to expose and test a core ability that is used by predicates to make them faster and more reliable.  Predicates do a similar array splice...using the array underlying the PATH! that you pass it.  This means it doesn't have to generate a function (that would need to be GC'd) or run a function application, so <strong>any .not.even? [2, 3]</strong> is aiming to have performance parity with <strong>any [not even? 2, not even? 3]</strong></p>
<p><strong>But as with most language features called "macro", there are downsides.</strong>  The function interface for this macro looks like it only takes one argument, but it winds up implicitly picking up two.  So macros are variadic.  My plan for POINTFREE is to be smarter and actually generate an ACTION! that figures out how many parameters it needs to take, but that's more expensive to do and it was making predicates not as good as it should be.</p>
<p>Note that if you put an enfix operator at the beginning of a macro splice, it will not be able to see its left.  So if you want a macro to see the left hand side parameter, <em>the macro itself has to be enfix</em>.  It will see the enfix parameter, but won't "consume" it:</p>
<pre><code> add1020: enfix macro [discarded] [
     return [+ 1020]
 ]

 &gt;&gt; 304 add1020
 == 1324
</code></pre>
<blockquote>
<p>As a general reminder of why you can't decide enfix "after the fact"... the concept of a single instruction "step" is one that has a finishing point.  If all functions reserved the right to be enfix, then that would mean a DO of a BLOCK! couldn't be separated into individual evaluation steps...each function would run glued to the last.  It would be possible to avoid this if COMMA!s between expressions were enforced so you called out where every expression ended, but we obviously do not want that!</p>
</blockquote>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/for-better-or-worse-macro/1410">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/for-better-or-worse-macro/1410</link>
          <pubDate>Fri, 20 Nov 2020 11:46:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1410</guid>
          <source url="https://forum.rebol.info/t/for-better-or-worse-macro/1410.rss">For Better or Worse: MACRO</source>
        </item>
        <item>
          <title>Introducing REFRAMER: Close Cousin to ENCLOSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>This is a very cool tool that might help concretize some of the <a href="https://forum.rebol.info/t/seeing-all-action-s-as-variadic-frame-makers/1002/2">abstract-sounding arguments I was making about frames</a>...</p>
<p><strong>Reframers build a frame from whatever follows them at a callsite, and can operate on it before running it (<em>if</em> it runs it).</strong></p>
<p>Defining a reframer involves giving it a function that will act as the "shim".  Here is a reframer using a very simple shim, that just takes in the frame and returns it.</p>
<pre><code>get-frame-of: reframer (func [f [frame!]] [f])
</code></pre>
<p>Here is what happens if the thing that followed that reframer's execution was a call to APPEND:</p>
<pre><code>&gt;&gt; get-frame-of append [a b c] &lt;d&gt;
== make frame! [
    series: [a b c]
    value: &lt;d&gt;
    part: '
    only: '
    dup: '
    line: '
]
</code></pre>
<p>As we can see, it gathered the arguments for the APPEND and put together a FRAME! to represent the call.</p>
<p><strong>The reframing process did not automatically execute the frame.  But the "shim" function can!</strong></p>
<p>Let's try something that runs the function twice.</p>
<pre><code>&gt;&gt; two-times: reframer func [f [frame!]] [do copy f, do f]

&gt;&gt; two-times append [a b c] &lt;d&gt;
== [a b c &lt;d&gt; &lt;d&gt;]
</code></pre>
<h2>Whoa.</h2>
<p><strong>But wait, there's more.</strong>  Besides not automatically executing the FRAME!, <em>it also doesn't typecheck it (yet)</em>.</p>
<pre><code>&gt;&gt; get-frame-of append 1 &lt;d&gt;
== make frame! [
    series: 1        ; !!! this wouldn't be legal to run as-is 
    value: &lt;d&gt;
    part: '
    only: '
    dup: '
    line: '
]
</code></pre>
<p>With our "shim" function in the driver's seat, it can manipulate the inputs and the results.</p>
<p>Consider how right now, functions like APPEND won't take QUOTED!</p>
<pre><code>&gt;&gt; item: first ['''[a b c]]
== '''[a b c]

&gt;&gt; append item &lt;d&gt;
** Script Error: append does not allow QUOTED! for its series argument
</code></pre>
<p>But what if we made a REQUOTE that:</p>
<ul>
<li>would build a frame for whatever follows it</li>
<li>counted how many quoting levels were on the first argument in that frame</li>
<li>took the quoting levels off that first argument</li>
<li>ran the function</li>
<li>added the quoting levels back to the result</li>
</ul>
<p>It should be an easier function to write than it is, but even so it's not that hard:</p>
<pre><code>requote: reframer func [
     {Remove Quoting Levels From First Argument and Re-Apply to Result}
     f [frame!]
     &lt;local&gt; p num-quotes result
][
    p: first words of f
    num-quotes: quotes of f/(p)
    f/(p): dequote f/(p)

    if null? result: do f [return null]  ; exempt NULL from requoting

    return quote/depth get/any 'result num-quotes
]
</code></pre>
<p>And behold:</p>
<pre><code>&gt;&gt; item: first ['''[a b c]]
== '''[a b c]

&gt;&gt; requote append item &lt;d&gt;
== '''[a b c &lt;d&gt;]
</code></pre>
<h2>The Shim Can Take Arguments</h2>
<p>The last argument of the shim needs to be a frame, but it could also have its own arguments.</p>
<p>Just to demonstrate this point without any frame-fiddling to obscure the point, how about a message that prints before and after just executing the frame:</p>
<pre><code>&gt;&gt; bracketer: reframer func [msg [text!] f [frame!]] [
       print msg
       do f
       print msg
   ]

&gt;&gt; bracketer "Aloha!" print "I'm being framed!"
Aloha!
I'm being framed!
Aloha!
== ~void~
</code></pre>
<h2>Things To Think About</h2>
<p>This is very cool, and it pins down a number of questions about evaluation.</p>
<p>Hopefully now you can see why type errors shouldn't happen during argument fulfillment, but only once the function actually gets to the point of running.  e.g. a reframer that just does the function after it shouldn't act any different than that function would running normally.</p>
<p>One tough problem is what to do when you get multiple reframer functions in a row.  I give the example of:</p>
<pre><code>&gt;&gt; item: first ['''[a b c]]
== '''[a b c]

&gt;&gt; item: my requote append &lt;d&gt;
 ; ... how can this work?
</code></pre>
<p>MY is also a reframer.  But if it gets a FRAME! for REQUOTE, that will not be what it expects.  Because REQUOTE has a single argument in its frame...which is a frame, not a callsite argument.  :-/</p>
<p>What MY really wants is a FRAME! for the aggregate function of "REQUOTE APPEND".  Such aggregate frames aren't impossible to conceive of, but are beyond what we have today.</p>
<p>That's probably the biggest issue I can see right now with this.  But it's a step ahead of having to reinvent the technique on every function that wants to do something like it.  And it means that when an answer for one such functions is made, all of them will get it.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/introducing-reframer-close-cousin-to-enclose/1395">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/introducing-reframer-close-cousin-to-enclose/1395</link>
          <pubDate>Mon, 09 Nov 2020 03:15:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1395</guid>
          <source url="https://forum.rebol.info/t/introducing-reframer-close-cousin-to-enclose/1395.rss">Introducing REFRAMER: Close Cousin to ENCLOSE</source>
        </item>
        <item>
          <title>AUGMENT: Add Parameters and Refinements After-The-Fact</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p><img src="https://forum.rebol.info/images/emoji/twitter/boxing_glove.png?v=12" title=":boxing_glove:" class="emoji" alt=":boxing_glove:" loading="lazy" width="20" height="20"> <a href="https://www.youtube.com/watch?v=VWuVEhTJPdw">Don't call it a comeback...</a> <img src="https://forum.rebol.info/images/emoji/twitter/boxing_glove.png?v=12" title=":boxing_glove:" class="emoji" alt=":boxing_glove:" loading="lazy" width="20" height="20"></p>
<p><strong>AUGMENT</strong> is a new addition to the function composition toolbox.  It serves a single purpose: to create a variation of a function that has more parameters and refinements, but <em>acts exactly the same</em>.</p>
<pre><code>&gt;&gt; foo-x: func [x [integer!]] [
       print ["x is" x]
   ]

&gt;&gt; foo-xy: augment :foo-x [y [integer!]]

&gt;&gt; foo-x 10
x is 10

&gt;&gt; foo-xy 10
** Error: foo-xy is missing its y argument

&gt;&gt; foo-xy 10 20
x is 10
</code></pre>
<p>You might ask: "What good is that, since the original function has no idea the parameter is there?"  This is where our friends like ADAPT and ENCLOSE come in.</p>
<p>Let's try that again.  First, with an ADAPT:</p>
<pre><code>&gt;&gt; foo-xy: adapt (augment :foo-x [y [integer!]]) [
       print ["y is" y]
   ]

&gt;&gt; foo-xy 10 20
y is 20
x is 10
</code></pre>
<p>And here's an ENCLOSE example:</p>
<pre><code>&gt;&gt; foo-xy2: enclose (augment :foo-x [y [integer!]]) func [f [frame!]] [
       let y: f.y
       print ["y is" y]
       do f
       print ["y is still" y]
   ]

&gt;&gt; foo-xy2 10 20
y is 20
x is 10
y is still 20
</code></pre>
<h2>
<a name="this-didnt-drop-out-of-the-sky-1" class="anchor" href="https://forum.rebol.info#this-didnt-drop-out-of-the-sky-1"></a>This didn't drop out of the sky...</h2>
<p>It is the result of long-term-thinking, and design choices with an eye toward doing this <em>someday</em>.  One of the recent strategic moves that really made it feasible was <a href="https://forum.rebol.info/t/pure-and-refined-simplifying-refinements-to-one-or-zero-args/1120">changing refinements to be their own arguments</a>.  If it weren't for that, if your function was <strong>foo: func [x /y] [...]</strong> and you tried <strong>bar: augment 'foo [z]</strong>, the parameter list would look like you had written <strong>bar: func [x /y z] [...]</strong>.  As soon as a function got a refinement, you'd have no way to add a normal parameter...because everything would become an argument to the last refinement.</p>
<p>The very first motivating scenario which got me thinking about this was when I was lobbying for removing the /DEFAULT refinement from SWITCH.  I felt strongly about needing a generalized solution based on NULL results from branching constructs.  But I wanted it to be easy to make a compatibility version.</p>
<p>And now, it <strong>is</strong> easy:</p>
<pre><code> switch-d: enclose (augment :switch [
     /default "Default case if no others are found"
        [block!]
 ]) func [f [frame!]] [
     let def: f.default  ; see NOTE on why it's not `do f else (f/default)`
     do f else (def)
 ]
</code></pre>
<p>It works the way you'd expect:</p>
<pre><code>&gt;&gt; switch-d 1 [1 [print "one" 1020]]
one
== 1020

&gt;&gt; switch-d/default 1 [1 [print "one" 1020]] [print "defaulting!" 304]
one
== 1020

&gt;&gt; switch-d/default 2 [1 [print "one" 1020]] [print "defaulting!" 304]
defaulting!
304
</code></pre>
<p>I'm not totally thrilled with the way the meta information for HELP is being inherited.  But the somewhat hackish way it is done is working well enough to get us started.  Note how the description for /DEFAULT was incorporated:</p>
<pre><code>&gt;&gt; help switch-d
USAGE:
    SWITCH-D value :predicate cases /all /default

DESCRIPTION:
    Selects a choice and evaluates the block that follows it.
    SWITCH-D is an ACTION!

RETURNS: [&lt;opt&gt; any-value!]
    Last case evaluation, or null if no cases matched

ARGUMENTS:
    value [&lt;opt&gt; any-value!]
        Target value
    :predicate [refinement! action! &lt;skip&gt;]
        Binary switch-processing action (default is /EQUAL?)
    cases [block!]
        Block of cases (comparison lists followed by block branches)

REFINEMENTS:
    /all
        Evaluate all matches (not just first one)
    /default [block!]
        Default case if no others are found
</code></pre>
<p>This is a very new mechanism that is going to need testing.  But it's going to make many things easier--not just in implementing things like Redbol, but also in being able to create skins with warnings about deprecated refinements (and what to do instead)...while removing those refinements from the natives themselves.</p>
<p>Try it out!</p>
<hr>
<p><em>NOTE: Although I'm now of the belief that <a href="https://forum.rebol.info/t/what-happens-to-function-arguments-and-locals-when-the-call-ends/234">function arguments must outlive their calls</a>, I don't believe this implies that <strong>do f</strong> should not invalidate the caller's handle on that <strong>f</strong> frame.  It is an effective transfer of ownership of that frame to the function; and you need the feedback that you cannot expect another DO to work again.  Hence the default must be cached.</em></p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/augment-add-parameters-and-refinements-after-the-fact/1216">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/augment-add-parameters-and-refinements-after-the-fact/1216</link>
          <pubDate>Fri, 27 Sep 2019 18:46:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1216</guid>
          <source url="https://forum.rebol.info/t/augment-add-parameters-and-refinements-after-the-fact/1216.rss">AUGMENT: Add Parameters and Refinements After-The-Fact</source>
        </item>
        <item>
          <title>AS BINARY! view of strings is back...with UTF-8! (that&#39;s only /PART!)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <h2>Mutate strings aliased as BINARY!, and vice-versa, as in Rebol2!</h2>
<p>Rebol2's AS-BINARY and AS-STRING provided a convenient aliasing between binary and string as Latin1 single-byte characters:</p>
<pre><code>rebol2&gt;&gt; b: as-binary s: "hello"
== #{68656C6C6F}

rebol2&gt;&gt; append b #{68}
== #{68656C6C6F68}

rebol2&gt;&gt; s
== "helloh"  ; binary mutation reflected in original string

rebol2&gt;&gt; append s "ello"
== "hellohello"

rebol2&gt;&gt; b
== #{68656C6C6F68656C6C6F}
</code></pre>
<p>That was lost when R3-Alpha's internal string format became too unpredictable (swinging between Latin1 and UCS2) and was only canonized as UTF-8 for I/O.  Red suffered a similar fate.</p>
<p>But with <a href="https://forum.rebol.info/t/realistically-migrating-rebol-to-utf8-everywhere/374">UTF-8 Everywhere</a> as the fixed internal format of strings, Ren-C has done some voodoo to bring it back.</p>
<p>It offers a more generic AS operation, along with higher-than-UCS2 codepoint support:</p>
<pre><code>&gt;&gt; b: as binary! s: "hello"
== #{68656C6C6F}

&gt;&gt; to binary! "üê±"
== #{F09F90B1}

&gt;&gt; append b #{F09F90B1}  ; add that high-codepoint cat!
== #{68656C6C6FF09F90B1}

&gt;&gt; s
== "helloüê±"

&gt;&gt; append s "helloüê±"
== "helloüê±helloüê±"

&gt;&gt; b
== #{68656C6C6FF09F90B168656C6C6FF09F90B1}
</code></pre>
<p>But a binary alias of a string is constrained to staying as valid UTF-8:</p>
<pre><code>&gt;&gt; append b #{FEFEFEFE}
** Internal Error: invalid UTF-8 byte sequence found during decoding
</code></pre>
<p>You can actually alias WORD! as BINARY! also, without doing a separate allocation.  But it will be  read-only view, so all you're doing is saving on memory and GC load:</p>
<pre><code>&gt;&gt; b: as binary! 'immutable-word
== #{696D6D757461626C652D776F7264}

&gt;&gt; append b #{1020}
** Access Error: series is source or permanently locked, can't modify
</code></pre>
<p>Similarly, you can alias words as strings...again without making a new allocation, but with the same read-only constraint:</p>
<pre><code>&gt;&gt; t: as tag! 'append
== &lt;append&gt;

&gt;&gt; append t "nope"
** Access Error: series is source or permanently locked, can't modify
</code></pre>
<h2>The /PART refinement has just been implemented for UTF-8</h2>
<p><a href="https://github.com/rebol/rebol-issues/issues/2096" rel="nofollow noopener">The controversial behavior can be discussed on issue #2096</a> (which you can discuss on that ticket).  But what R3-Alpha and Red choose to (<a href="https://github.com/rebol/rebol-issues/issues/2383" rel="nofollow noopener">buggily</a>) implement is that it applies to the target series only...and is thus measured in the units of <em>that</em> series:</p>
<pre><code>&gt;&gt; append/part "abc" [100 "de" "fg"] 2
== "abc10"  ; 2 string units, not "abc100de" from 2 block units
</code></pre>
<p>The argument is that COPY/PART on the source series gives you that form /PART if you need it, so this is "strictly more powerful".  Rightly or wrongly... Ren-C is now doing it hopefully less buggily (though almost certainly with its own bugs), but with UTF-8 Everywhere support.</p>
<p>If you like, you can limit how much of a binary you extract from UTF-8, counted in bytes:</p>
<pre><code>&gt;&gt; to binary! "üê±"
== #{F09F90B1}

&gt;&gt; append/part #{} "üê±" 2  ; e.g. 2 bytes (half a cat)
== #{F09F}
</code></pre>
<p>Extracting bytes from UTF-8 will always work.  Going the other way, not all binary strings are valid UTF-8.  But as long as the number of characters you ask for in that section of the binary are valid, having other invalid bytes isn't a problem...only when you ask for part out of the unchecked region:</p>
<pre><code>&gt;&gt; append/part "" #{F09F90B1F09F90B1FEFEFEFE} 2  ; e.g. 2 characters
== "üê±üê±" 

&gt;&gt; append/part "" #{F09F90B1F09F90B1FEFEFEFE} 3
** Internal Error: invalid UTF-8 byte sequence found during decoding
</code></pre>
<p>If a binary is actually an alias of a UTF-8 string, this can be more efficient by not rescanning... <em>(though the code is still in its early life yet, so it has a number of areas for improvement)</em>.</p>
<p><strong>Pretty cool, eh?</strong></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/as-binary-view-of-strings-is-back-with-utf-8-thats-only-part/1186">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/as-binary-view-of-strings-is-back-with-utf-8-thats-only-part/1186</link>
          <pubDate>Tue, 23 Jul 2019 21:33:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1186</guid>
          <source url="https://forum.rebol.info/t/as-binary-view-of-strings-is-back-with-utf-8-thats-only-part/1186.rss">AS BINARY! view of strings is back...with UTF-8! (that&#39;s only /PART!)</source>
        </item>
        <item>
          <title>Postfix Assertions: SO, WAS, MATCHED</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>Assertions are important, but some people want to write short code and feel the assertions can clutter it up.</p>
<p>But what if the assertion was as brief and to the point as a comment was?  That inspired these postfix assert operators...</p>
<h2>SO</h2>
<p>Takes a condition on the left and treats that as a thing to assert on.  It's variadic on the right and won't run the right to get the expression until the left has been shown as true.</p>
<pre><code>&gt;&gt; x: 0

&gt;&gt; 1 = 2 so x: &lt;changed&gt;
** Script Error: assertion failure: [false so]
** Where: so console
** Near: [... = 2 so ~~ x: &lt;changed&gt;]

&gt;&gt; x
== 0  ; didn't change, the assignment didn't get a chance to run

&gt;&gt; 1 = 1 so x: &lt;changed&gt;
== &lt;changed&gt;

&gt;&gt; x
== &lt;changed&gt;  ; the right hand side once the left was shown true
</code></pre>
<h2>WAS</h2>
<p>The WAS word has been reclaimed from a previous purpose, now to assert "lax equality" (or IS-ness) of the left hand side to the right.  But it passes on the value.</p>
<pre><code>&gt;&gt; 10 + 10 was 5 + 15
== 20

&gt;&gt; 10 + 10 was 50 + 1000
** Script Error: assertion failure: [20 is 1050]
** Where: was console
** Near: [... 10 was 30 ~~]
</code></pre>
<h2>MATCHED</h2>
<p>Very similar to WAS, but a variant which uses the logic of <a href="https://forum.rebol.info/t/time-to-meet-your-match-dialect/1009">the MATCH dialect</a>, e.g. to test the datatype.</p>
<pre><code>&gt;&gt; 10 + 10 matched integer!
== 20

&gt;&gt; 10 + 10 matched text!    
** Script Error: assertion failure: [20 matches text!]
** Where: matched console
** Near: [... 10 matched text! ~~]
</code></pre>
<h2>Added Bonus: ASSERT is now invisible</h2>
<p>Cool as these are, you still might want to use the plain old assert for something.  If you do, know that it is now...invisible!  So you can put it anywhere.</p>
<pre><code>&gt;&gt; all [
    x: 1 + 1 
    assert [x &gt; 1]
 ]
 == 2

&gt;&gt; all [
    x: 1 + 1 
    assert [x &lt; 1]
 ]
** Script Error: assertion failure: [
    x &lt; 1 ** false
]
** Where: _ assert all console
** Near: [[x &lt; 1] ~~]</code></pre>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/postfix-assertions-so-was-matched/1046">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/postfix-assertions-so-was-matched/1046</link>
          <pubDate>Thu, 31 Jan 2019 17:55:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1046</guid>
          <source url="https://forum.rebol.info/t/postfix-assertions-so-was-matched/1046.rss">Postfix Assertions: SO, WAS, MATCHED</source>
        </item>
        <item>
          <title>Show the Love for SHOVE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <h2>
<a name="h-1" class="anchor" href="https://forum.rebol.info#h-1"></a><code>&gt;-</code>
</h2>
<p>Despite having a bit tricky to implement, it's very easy to understand.  <strong>It just pushes the argument on its left to be the first argument of the operation on its right:</strong></p>
<pre><code>&gt;&gt; 1 &gt;- add 2 * 3
== 7  ; as if you'd written `add 1 2 * 3`
</code></pre>
<p>Simple, right?  You might think it's not something you would use... <em>but you'd be thinking wrong!</em></p>
<h2>
<a name="invoke-enfix-functions-in-modules-or-libraries-2" class="anchor" href="https://forum.rebol.info#invoke-enfix-functions-in-modules-or-libraries-2"></a>Invoke enfix functions in modules or libraries</h2>
<p>Enfix execution cannot work with paths (<a href="https://forum.rebol.info/t/letting-go-of-enfix-path-dreams-but-fixing-it-with-magic/794">this isn't a bug, it <em>shouldn't</em> work</a>):</p>
<pre><code>r3-alpha&gt;&gt; 1 lib/+ 2 * 3
** Script error: op! type is not allowed here
</code></pre>
<p>But shove has your back:</p>
<pre><code>&gt;&gt; 1 &gt;- lib/+ 2 * 3
== 9  ; as if you'd written `1 + 2 * 3`
</code></pre>
<p><em>(Note the result is different from what you get with add, since + is enfix.)</em></p>
<p><strong>This is only going to get more critical as modules and namespacing move forward.</strong> And anyone who's redefined an operator--but wants to temporarily reach for another implementation--will want this.</p>
<h2>
<a name="invoke-refinements-on-enfix-executions-3" class="anchor" href="https://forum.rebol.info#invoke-refinements-on-enfix-executions-3"></a>Invoke refinements on enfix executions</h2>
<p>Historically there aren't really refinements on infix functions, because you'd never be able to use them.  Now you can:</p>
<pre><code>&gt;&gt; ++: enfixed func [a b /double] [a + either double [2 * b] [b]]

&gt;&gt; 10 ++ 20
== 30

&gt;&gt; 10 &gt;- ++/double 20
== 50
</code></pre>
<p>In the common case, you hope that your operator doesn't need refinements.  But when a special case comes up, it's nice to not have to define a prefix form just for that one instance. (which means coming up with a new name that people need to know also).  Now you can take for granted that shove is there when you need it.</p>
<h2>
<a name="symbol-y-but-not-symbol-soup-it-communicates-4" class="anchor" href="https://forum.rebol.info#symbol-y-but-not-symbol-soup-it-communicates-4"></a>Symbol-y, but not symbol soup: it communicates!</h2>
<p>Being an "arrow word" is crucial to showing its disruption of the evaluation order.  That's not going to be conveyed by a short alphabetic name:</p>
<pre><code>&gt;&gt; 1 shove lib/+ 2 * 3   ; lame and wordy
== 9
</code></pre>
<p>Invoking enfix functions from modules/namespaces and using refinements with them is <em>fundamental behavior</em>.  So it needs to be very short and light.  You want people to take this thing for granted!</p>
<h2>
<a name="extra-credit-tweak-the-argument-precedence-5" class="anchor" href="https://forum.rebol.info#extra-credit-tweak-the-argument-precedence-5"></a>Extra credit: tweak the argument precedence</h2>
<p>Rebol is well known for having a difference in interpretation when you use an infix operator vs. not:</p>
<pre><code>&gt;&gt; add 1 2 * 3
== 7

&gt;&gt; 1 + 2 * 3
== 9
</code></pre>
<p><em>(If you don't know why that is--and wonder why such a "quirk" hasn't been changed despite a lot of thought--<a href="https://forum.rebol.info/t/the-beta-one-enfix-covenant/1023">you can read more than you ever wanted to about it</a>)</em>.</p>
<p>Above I showed that shove takes its cue on how to act based on the enfixedness of what you're shoving into:</p>
<pre><code>&gt;&gt; 1 &gt;- lib/add 2 * 3
== 7  ; as if you'd said `add 1 2 * 3`

&gt;&gt; 1 &gt;- lib/+ 2 * 3
== 9  ; as if you'd said `1 + 2 * 3`
</code></pre>
<p><strong>But it might be argued that since <code>&gt;-</code> is enfix, the overall operation is always enfix, which intuitively would suggest both of the above should be 9.</strong></p>
<p>It's tough to say.  But I liked the simple definition of <em>"shove uses the value on the left as the first argument"</em>.  Imagine what the "as if you'd said" would have to be if the shove into ADD above gave 9, if you couldn't take for granted another known another name for the operation (like <code>+</code>):</p>
<pre><code>&gt;&gt; 1 &gt;- lib/add 2 * 3  ; let's say it's the hypothetical enfix-always version
== 9  ; as if you'd said `temp: enfixed :add | 1 temp 2 * 3`
</code></pre>
<p>But for sake of completeness...I introduced "force enfix behavior (<strong>-&gt;-</strong>)" and  "force prefix behavior (<strong>&gt;--</strong>)" forms:</p>
<pre><code>&gt;&gt; 1 -&gt;- lib/add 2 * 3
== 9  ; as if you'd said `1 + 2 * 3`

&gt;&gt; 1 &gt;-- lib/+ 2 * 3
== 7  ; as if you'd said `add 1 2 * 3`
</code></pre>
<p>I think it's cute that <strong><code>-&gt;-</code></strong> looks like a picture of args on the left and right of an operator, suggesting infix... while <strong><code>&gt;--</code></strong> looks like no args on the left with two args on the right!</p>
<p>But you could also just use parentheses:</p>
<pre><code>&gt;&gt; (1 &gt;- lib/add 2) * 3
== 9

&gt;&gt; 1 &gt;- lib/+ (2 * 3)
== 7
</code></pre>
<p>So whether <code>-&gt;-</code> and <code>&gt;--</code> survive or not is an open question.  If anyone actually uses them, I'd be interested to know.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/show-the-love-for-shove/1039">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/show-the-love-for-shove/1039</link>
          <pubDate>Mon, 28 Jan 2019 01:32:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1039</guid>
          <source url="https://forum.rebol.info/t/show-the-love-for-shove/1039.rss">Show the Love for SHOVE</source>
        </item>
        <item>
          <title>Easier Generalized Quoting: &lt;dequote&gt; and &lt;requote&gt;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>There are primitives for generalized quoting:</p>
<ul>
<li>
<strong>quoted?</strong> is the test, which is actually a datatype test (the type is QUOTED!)</li>
<li>
<strong>quotes of x</strong> counts the number of quote levels</li>
<li>
<strong>unquote x</strong> removes one quote level, <strong>unquote/depth x count</strong> removes more</li>
<li>
<strong>quote x</strong> will eventually add quote levels, along with <strong>quote/depth</strong>
</li>
</ul>
<p><em>(For today, QUOTE is called UNEVAL.  This makes it easier to find places where you've forgotten to switch over to LITERAL or LIT for the old meaning of QUOTE.  The weird name actually is what was around to do something similar before generalized quoting... it made a GROUP! with a quote in it, so each step of eval of that group would just remove one level of evaluation.)</em></p>
<p>So you've got everything you need to work with them.  But there are some common scenarios of dealing with them that we can help with.</p>
<p>For instance, sometimes you want to basically see past the quoting level of something and operate on its basic type, then return that thing quoted back to the level you had it.  Imagine this:</p>
<pre><code>increment: function [
    return: [&lt;opt&gt; integer!]
    x [quoted! integer!]
][
    num-quotes: quotes of x
    x: dequote x
    if not integer? x [
        fail "Invalid type"
    ]
    if x &gt; 304 [return null]
    return quote/depth (x + 1) num-quotes
]
</code></pre>
<p>So this way you get:</p>
<pre><code> &gt;&gt; increment lit '''303
 '''304

 &gt;&gt; increment lit '''1020
 ; null
</code></pre>
<p>It's cool that you <em>can</em> do that, but it's a bit irritating to write. And it's a pattern that happens often.</p>
<p>So here's a tool for helping with that:</p>
<pre><code>foo: function [
    return: [&lt;opt&gt; &lt;requote&gt; integer!]
    x [&lt;dequote&gt; integer!]
][
    if x &gt; 304 [return null]
    return x + 1
]
</code></pre>
<p>It has the same behavior, but everything is handled for you automatically, including the type checking.  As you can see it doesn't put quote levels back on a null...it assumes null doesn't have the requote rule apply.  The exception would be if your input was a quoted null, in which case it would think you meant to support that.</p>
<p>You don't have to use <code>&lt;requote&gt;</code>, you can just dequote a parameter and not add it back in to the result.  If you have <code>&lt;dequote&gt;</code> on more than one argument, then the requote will have the sum of the quotes taken off for all arguments.  That's a weird heuristic that probably won't come in useful too often, but if it's not what you want you'll have to take a QUOTED! and do your own magic.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/easier-generalized-quoting-dequote-and-requote/1035">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/easier-generalized-quoting-dequote-and-requote/1035</link>
          <pubDate>Sat, 26 Jan 2019 00:25:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1035</guid>
          <source url="https://forum.rebol.info/t/easier-generalized-quoting-dequote-and-requote/1035.rss">Easier Generalized Quoting: &lt;dequote&gt; and &lt;requote&gt;</source>
        </item>
        <item>
          <title>You can has GET-BLOCK! (SET-BLOCK!, GET-GROUP!, SET-GROUP!)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p><a href="https://github.com/metaeducation/ren-c/commit/f25087c0bbfbcef7fc6f71cb53fe69b16527b1d7" rel="nofollow noopener"><strong>Yep, they're implemented!!!</strong></a>  Go try them out!!!</p>
<hr>
<p>Years ago, discussions circled around what was so special about WORD! and PATH! that they should be the only ones with LIT-XXX! forms.  It seemed this was a bit that could equally apply to anything, e.g. <strong><code>group: '(1 + 2)</code></strong>.</p>
<p>It took a while, but eventually a <a href="https://forum.rebol.info/t/quoted-arrives-formerly-known-as-lit-bit/995/2">general and clever solution was discovered</a>.  There's no LIT-XXX!, just QUOTED! as a container for any type...with any level of quoting.  It's done with neat tricks!</p>
<h2>...but what about SET-XXX and GET-XXX?</h2>
<p>In that same vein, we might ask why PATH! and WORD! are the only types with SET-XXX! and GET-XXX! forms.  Aren't those just bits too?</p>
<p>GET-BLOCK! seems very useful if it would do a REDUCE in the evaluator.  Instead of <strong>return reduce [x y]</strong> you could just say <strong>return :[x y]</strong>.  SET-GROUP seems like it might be a little tidier too...</p>
<pre><code>word: 'x
set word 1020

word: 'x
(word): 1020
</code></pre>
<p>It's only one less <em>character</em>.  But whether you have a preference for one or the other visually, the second can be done faster; the evaluator doesn't have to look up SET to find the function, nor go through the trouble of filling function frames and dispatching.  It's much lighter-weight.</p>
<h2>Yet it seems a slippery slope...</h2>
<p>GET-BLOCK! and SET-GROUP! sure seem useful, but if we look at this as more cases of the "lit bit", where does it stop?</p>
<p>If every type has a "get bit" and a "set bit", can you have both of them?  How does this mix with the LIT-XXX forms?  Is there a difference between a LIT-SET-PATH! and a SET-LIT-PATH?</p>
<p>What would a SET-URL! look like?  How are the colons mixing up with literals that have colons in them?  <em>(:15 is a TIME! in the current world..., that would become a GET-INTEGER!, so what does a GET-TIME! look like?)</em></p>
<p>This foiled ideas of the past, like trying to get rid of SET-PATH! and GET-PATH! and just say, e.g. "a SET-PATH! is one with a SET-WORD! in its last slot".  Because then to get <strong>x/1:</strong> you would need SET-INTEGER!, to get <strong>x/(y + z):</strong> you'd need SET-GROUP!, and it just seemed to go to chaos.</p>
<p>In the absence of a clear plan, we plodded along with the status quo, awaiting some moment of clarity.</p>
<h2>Moment of clarity arrived: Just add BLOCK! and GROUP!</h2>
<p>If we only allow SET and GET forms on containers, it's a clean model (no worries about intersecting with lexical rules of the contained types).  And you get your dialected parts.  Need a SET-INTEGER! ?  Well, you <a href="https://knowyourmeme.com/memes/sites/cheezburger" rel="nofollow noopener">no can has</a>.  But with containers, you get it all:</p>
<pre><code> my-dialect [
     [1]: "It's just as good, as `1:`, really!"

     :(:15) "Even better, as if you want GET-FIFTEEN-MINUTES!, you can have it..."

     [http://example.com/colons-legal-in-url:]: "Yup, colons are legal in URL!s"

     (your multi-value expression here): "goes great with expressions!"
 ]
</code></pre>
<p><em>Then we stop.</em>  We get 4 new parts that are genuinely useful, that make the evaluator more expressive and run common functionality faster.  If you find uses in your dialects--and you almost certainly will--so much the better.</p>
<h2>The commit for them fixes flaws in the scanner</h2>
<p>There were some things you couldn't make.  In Rebol2/R3-Alpha/Red:</p>
<pre><code>rebol2&gt;&gt; first [:a/(b + c)]                       
== a/(b + c):

rebol2&gt;&gt; first [:(a + b)/c]
** Syntax error: invalid "word-get" -- ":"
</code></pre>
<p>It might seem like it wouldn't be that hard to fix, but fixing it is a lot easier if you can just pass through a moment where the head of that block is a GET-GROUP! and then twiddle it into a regular GROUP! later.  (That's how GET-PATH! works when it has a GET-WORD!-looking thing at the head).  The scanner is already rather fiddly and throwing in more fiddly-bits is not forward-looking.</p>
<p>This lets that work basically for free, just a minor tweak on the previous method:</p>
<pre><code>&gt;&gt; first [:(a + b)/c]
== :(a + b)/c

&gt;&gt; type of p: first [:(a + b)/c]
== get-path!

type of first p
== group!  ;-- regular GROUP! as first element of GET-PATH!, perfect
</code></pre>
<h2>They're awesome, you'll love 'em</h2>
<p>Try them out and let me know what you think, and if you find cool new dialect applications!  Some demos:</p>
<pre><code>; GET-BLOCK!, doing a fast REDUCE
&gt;&gt; a: 10
&gt;&gt; b: 20
&gt;&gt; :[a b]
== [10 20]

; GET-GROUP!, getting a PATH!
&gt;&gt; o: make object! [f: 304]
&gt;&gt; path: 'o/f
&gt;&gt; :(path)
== 304

; SET-GROUP!, setting a BLOCK!
&gt;&gt; m: &lt;before&gt;
&gt;&gt; o: make object! [f: &lt;before&gt;]
&gt;&gt; block: [m o/f]
&gt;&gt; (block): [1020 304]
&gt;&gt; block
== [m o/f]
&gt;&gt; m
== 1020
&gt;&gt; o/f
== 304

; SET-BLOCK!, with a block on the right
&gt;&gt; a: _ b: _
&gt;&gt; [a b]: [10 20]
&gt;&gt; a
== 10
&gt;&gt; b
== 20

; SET-BLOCK! with a non-block on the right
&gt;&gt; a: _
&gt;&gt; b: _
&gt;&gt; [a b]: &lt;thing&gt;
&gt;&gt; a
== &lt;thing&gt;
&gt;&gt; b
== &lt;thing&gt;
</code></pre>
<p>I'm sure people will think of improvements, but that's for starters.</p>
<p>And note they'll get even better with <a href="https://forum.rebol.info/t/mirrored-type-bytes-explained/1008">mirror bytes</a>, where <strong>(x):</strong> won't cost any more than <strong>x:</strong> !!!  I'm relatively confident I can make that happen, some groundwork is done already.</p>
            <p><small>7 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/you-can-has-get-block-set-block-get-group-set-group/1032">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/you-can-has-get-block-set-block-get-group-set-group/1032</link>
          <pubDate>Thu, 24 Jan 2019 03:36:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1032</guid>
          <source url="https://forum.rebol.info/t/you-can-has-get-block-set-block-get-group-set-group/1032.rss">You can has GET-BLOCK! (SET-BLOCK!, GET-GROUP!, SET-GROUP!)</source>
        </item>
        <item>
          <title>Soft Quoted Branching: Light, Elegant, Fast</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>It's uncommon to use expressions that evaluate to branches passed to conditionals.  And when you do use one, you probably don't mind putting it in a GROUP! (especially considering that 99% of the time in the <em>far</em> more common cases you were willing to put it in a BLOCK!).</p>
<p>So Ren-C now uses that fact--plus generalized quoting--to allow for a briefer and faster way to evaluate to literals in your conditionals:</p>
<pre><code>&gt;&gt; if okay '[block as data]
== [block as data]
</code></pre>
<p>Simply pass in a QUOTED! item of any kind, and that item will be what a branch evaluates to.  It will be one less level of quoting than what you pass in:</p>
<pre><code>&gt;&gt; if okay '&lt;tag&gt;
== &lt;tag&gt;
</code></pre>
<p>Previous attempts to get something like this used an /ONLY refinement.  But this lets you mix and match in the same operator, as opposed to switching the operator into a "mode":</p>
<pre><code>&gt;&gt; either okay '[1 + 2] [1 + 2]
== [1 + 2]

&gt;&gt; either null '[1 + 2] [1 + 2]
== 3
</code></pre>
<h2><a name="p-2979-it-solves-some-problems-for-case-1" class="anchor" href="https://forum.rebol.info#p-2979-it-solves-some-problems-for-case-1"></a>It Solves Some Problems for CASE</h2>
<p>Historically, CASE was more lax in accepting types than the corresponding IFs would be:</p>
<pre><code>&gt;&gt; case [1 = 1 &lt;foo&gt;]
== &lt;foo&gt;
</code></pre>
<p>It would allow the by-products of arbitrary evaluation to be used:</p>
<pre><code>&gt;&gt; word: &lt;foo&gt;
&gt;&gt; case [1 = 1 word]
== &lt;foo&gt;
</code></pre>
<p>Sometimes this resulted in double-evaluation:</p>
<pre><code>&gt;&gt; word: [print "surprise"]
&gt;&gt; case [1 = 1 word]
surprise
== true
</code></pre>
<p>The dodgy nature of this "may be a double evaluation, may be not" with no way to tell at source level raised some concerns, which are laid out in the <a href="https://forum.rebol.info/t/backpedaling-on-non-block-branches/476">"backpedaling on non-block branches"</a> post.</p>
<p>The combination of soft quoting and generalized quoting lets the same patterns that work for IF work in CASE.  It lowers the risks in a legible way:</p>
<pre><code>&gt;&gt; case [1 = 1 '&lt;foo&gt;]
== &lt;foo&gt;
</code></pre>
<h2><a name="p-2979-its-faster-and-more-efficient-2" class="anchor" href="https://forum.rebol.info#p-2979-its-faster-and-more-efficient-2"></a>It's Faster and More Efficient</h2>
<p>Quoting is done with a byte in cells.  So you can count up to 254 levels of quoting without really costing anything.  <em>(If you're wondering why not 255 levels since a byte can be from 0..255, it's because 255 is reserved for "isotopes".)</em></p>
<p>So <strong>'[x]</strong> costs less storage (and has better locality with the surrounding cells) than <strong>[[x]]</strong>.</p>
<p>Outside of the reduced storage, it's also lighter on the evaluator, because it doesn't have to push an evaluator frame to run the block!</p>
<h2><a name="p-2979-the-consequences-3" class="anchor" href="https://forum.rebol.info#p-2979-the-consequences-3"></a>The consequences</h2>
<p>There were very few pieces of code in the Ren-C repo that were affected.  One was a help test.  It wanted to generate a real-world block to run, and didn't want to call DO for some reason:</p>
<pre><code>for-each w words of lib [
    dump w
    if not set? w [continue]
    if action? get w
        compose [help (w)]   ; errors now...IF thinks the COMPOSE word! is branch
    else [
        help (get w)
    ]
]
</code></pre>
<p>It's easy enough to change that to <code>(compose [help (w)])</code>...this kind of usage is very rare.</p>
<p>The one common case of passing code to a conditional originated from Ren-C...the use of lambdas that could take the argument of what drove the conditional:</p>
<pre><code> trap [1 / 0] then error -&gt; [print [error]]
</code></pre>
<p>So you have to put it in a GROUP!:</p>
<pre><code> trap [1 / 0] then (error -&gt; [print [error]])
</code></pre>
<p>I'm pretty sure this can be rethought to work as before, given the strategy of "right quoting always wins".  But the evaluator has some kind of strict horse-blinder rules that guide its design, so not all things are possible.  We'll see.</p>
<blockquote>
<p><strong>UPDATE 2020</strong>: The required rules have been implemented, and hard quoted left parameters on the right win in this instance, so the group is not necessary.  <img src="https://forum.rebol.info/images/emoji/twitter/sushi.png?v=12" title=":sushi:" class="emoji" alt=":sushi:" loading="lazy" width="20" height="20"></p>
</blockquote>
<p>Even if it couldn't get fixed, in the scheme of things it's worth it.  And it isn't like people aren't used to putting branches in delimiters for blocks anyway!</p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/soft-quoted-branching-light-elegant-fast/1020">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/soft-quoted-branching-light-elegant-fast/1020</link>
          <pubDate>Fri, 18 Jan 2019 12:56:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1020</guid>
          <source url="https://forum.rebol.info/t/soft-quoted-branching-light-elegant-fast/1020.rss">Soft Quoted Branching: Light, Elegant, Fast</source>
        </item>
        <item>
          <title>QUOTED! arrives (formerly known as &quot;lit bit&quot;)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>I'm pleased to say that the day has come that you can use apostrophe to escape any value...not just WORD! and PATH!.  And since I said <em>any</em> value, that means you can also quote <em>quoted values</em>...as deeply as you like!</p>
<pre><code>&gt;&gt; '(1 + 2)
== (1 + 2)

&gt;&gt; ''(1 + 2)
== '(1 + 2)

&gt;&gt; quoted? first [''{double quoted text!}]
== #[true]

&gt;&gt; quotes of first ['''''''''''''''''&lt;whoa!&gt;]
== 17
</code></pre>
<p>It opens up a whole new box of parts for dialecting, and makes your every day code shorter and clearer (when used properly).  <em>But don't be fooled by the fact that you can use a stupid number of quotes if you need:</em> <strong>This isn't a frivolous thing, and being able to truly escape any value--hence including any quoted value--is integral to the feature.</strong></p>
<p>If you are a heavy user of COMPOSE-ing code and then DO-ing it, you would be more likely to appreciate the efficiency and literacy of:</p>
<pre><code> do compose [... some-var: '(foo) ...]
</code></pre>
<p>But what you realize if you program at the API level (like C or JavaScript) is that <em>every execution acts like "a do of a COMPOSE".</em>  Since API representations of values spliced in from non-Rebol code are not fetched through a WORD!, libRebol users wind up putting "QUOTE" (now THE) calls <em>everywhere</em>--slowing things down, junking it up, and fundamentally changing the types and shape of what you're working with.  If you write sophisticated enough Rebol routines you've almost certainly run up against this problem too--but it's an issue on nearly <em>every</em> call into the API.</p>
<h2>
<a name="be-warned-this-is-a-radical-change-1" class="anchor" href="https://forum.rebol.info#be-warned-this-is-a-radical-change-1"></a>Be warned, this is a radical change!</h2>
<p>I'm sure you'll love it when all is said and done.  But it changes the typeclass membership of LIT-WORD! and LIT-PATH!.  They are no longer ANY-WORD! or ANY-PATH!, but instances of a new fully generalized quoted type.  This will cause some speedbumps.</p>
<p>Since you could do things like GET on a LIT-WORD!, or APPEND to a LIT-PATH!, I've tried to set up some mechanisms for the cases I thought of.  I even threw in some new weirder ones, like letting you add directly to a quoted integer and get a quoted integer at the same level back:</p>
<pre><code> &gt;&gt; add the '''''1 2
 == '''''3
</code></pre>
<p>I didn't see a good general rule for this.  It seems FIND on a quoted BLOCK! should return a position in the quoted block that is still quoted.  But SELECTing or PICKing a value out of the block should ignore the container's quoting.  It just seems like it has to be done on a case-by-case basis, for the semantics that make sense for the operation.</p>
<h2>
<a name="basic-mechanics-2" class="anchor" href="https://forum.rebol.info#basic-mechanics-2"></a>Basic Mechanics</h2>
<p>To get the number of quote levels, use QUOTES OF.  To get rid of any quoting present on any value, use NOQUOTE.</p>
<pre><code>&gt;&gt; quotes of first ['''{triply quoted string}]
== 3

&gt;&gt; noquote first ['''&lt;some-tag&gt;]
== &lt;some-tag&gt;
</code></pre>
<p>All that happens with multiply quoted types is that each time the evaluator sees it, it will peel off one quote level:</p>
<pre><code> &gt;&gt; ''(1 + 2)
 == '(1 + 2)

 &gt;&gt; '(1 + 2)
 == (1 + 2)

 &gt;&gt; (1 + 2)
 == 3
</code></pre>
<p>This means inert types which are singly quoted get evaluated and lose the distinction from the plain inert type.  So if you have a function that takes an evaluated argument (e.g. foo: func [x] [...]) you can't provide special behavior for <strong><code>foo '[block]</code></strong> that is different from <strong><code>foo [block]</code></strong>.  The only way a called function will see the bit is if it quotes the argument, or if it's inside a dialect block (like a PARSE rule).</p>
<p>You can, however, get special behavior for <strong><code>foo ''[block]</code></strong>, as it will receive a singly quoted block as an argument.  And of course, it's now more practical to escape GROUP!s, so it might be worth it to start defining distinct behavior when groups are used since they'll be so easy to pass!  (I have some ideas about this.)</p>
<h3>
<a name="name-switcheroo-quote-the-3" class="anchor" href="https://forum.rebol.info#name-switcheroo-quote-the-3"></a>Name Switcheroo: QUOTE =&gt; THE</h3>
<p>QUOTE now adds a quoting level to whatever it gets as an argument, with that argument being evaluated normally:</p>
<pre><code> &gt;&gt; x: 1
 == 1

 &gt;&gt; quote x
 == '1

 &gt;&gt; the x
 == x
</code></pre>
            <p><small>6 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/quoted-arrives-formerly-known-as-lit-bit/995">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/quoted-arrives-formerly-known-as-lit-bit/995</link>
          <pubDate>Fri, 04 Jan 2019 08:23:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-995</guid>
          <source url="https://forum.rebol.info/t/quoted-arrives-formerly-known-as-lit-bit/995.rss">QUOTED! arrives (formerly known as &quot;lit bit&quot;)</source>
        </item>
        <item>
          <title>The Superpowers of Ren-C&#39;s Revamped COMPOSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>COMPOSE is one of Rebol's most useful and recognizable constructs.  As with most-things-Ren-C, it has evolved to become far more powerful.</p>
<h2>
<a name="no-splicing-by-default-group-isotopes-request-splicing-1" class="anchor" href="https://forum.rebol.info#no-splicing-by-default-group-isotopes-request-splicing-1"></a>No Splicing By Default, GROUP! Isotopes Request Splicing</h2>
<p>One of the immediately noticeable differences is that there is no /ONLY option any longer.  A plain BLOCK! will not splice its evaluative result.  So if <strong>block: [a b c]</strong>, it is different from historical Redbol:</p>
<pre><code>rebol2/r3-alpha/red&gt;&gt; compose [value: (block)]
== [value: a b c]

ren-c&gt;&gt; compose [value: (block)]
== [value: [a b c]]
</code></pre>
<p>If you want to have something splice, you do this with GROUP! isotopes.  For instance, SPREAD produces them:</p>
<pre><code>ren-c&gt;&gt; compose [value: (block), (spread block)]
== [value: [a b c], a b c]
</code></pre>
<ul>
<li>
<p>You can mix and match splicing parts and non-splicing parts in the same COMPOSE!</p>
</li>
<li>
<p>It gets rid of an instance of /ONLY, which has always been something that causes head-scratching to new users ("only what?")</p>
</li>
</ul>
<p><strong>I am convinced that practice has shown that not splicing is a safer and more intuitive default.</strong>  You're so often dealing with composing several values at a time that the odds of you knowing precisely what data type all of them are become lesser.  There's no question this is the better behavior for people who are writing and reading the code.</p>
<h2>
<a name="the-slots-will-vaporize-voids-2" class="anchor" href="https://forum.rebol.info#the-slots-will-vaporize-voids-2"></a>The (...) Slots will Vaporize Voids!</h2>
<p>In my list of <a href="https://forum.rebol.info/t/the-canonical-list-of-non-negotiables/1244">"non-negotiables"</a>, I've always said this <em>had</em> to be true, somehow:</p>
<pre><code>&gt;&gt; compose [&lt;a&gt; (if false [&lt;b&gt;]) &lt;c&gt;]
== [&lt;a&gt; &lt;c&gt;]
</code></pre>
<p>For quite some time, a conditional like IF that didn't run its branch would return NULL.  Because NULL couldn't be put in a block, it <em>seemed</em> like it was a good fit for signaling vaporization of a clause in a COMPOSE.  But I was nervous because as NULL came to mean "soft failure", this felt like you could be sweeping a failure under the rug.</p>
<p>But with isotopes, we got a menagerie of states that couldn't be put in blocks (and VOID, with its own antiform).  So when un-taken IF provides another choice of VOID vs. NULL, it provided the best of both worlds, where NULL can give a <em>specific</em> error tied to null splicing.</p>
<pre><code>&gt;&gt; compose [&lt;a&gt; (select [a 10 b 20] 'c) &lt;c&gt;]
** Script Error: non-NULL value required (see MAYBE, TRY, REIFY)

&gt;&gt; compose [&lt;a&gt; (maybe select [a 10 b 20] 'c) &lt;c&gt;]
== [&lt;a&gt; &lt;c&gt;]
</code></pre>
<p>That specific error can be used to interesting effects, <a href="https://forum.rebol.info/t/making-use-of-definitional-errors-curtail/2118">see CURTAIL</a></p>
<h2>
<a name="decorated-groups-including-quoted-apply-their-decorations-3" class="anchor" href="https://forum.rebol.info#decorated-groups-including-quoted-apply-their-decorations-3"></a>Decorated Groups (including quoted) Apply Their Decorations!</h2>
<p>Ren-C has a lot of variations of GROUP!:</p>
<ul>
<li><strong><code>(set-group!):</code></strong></li>
<li><strong><code>:(get-group!)</code></strong></li>
<li><strong><code>^(meta-group!)</code></strong></li>
<li><strong><code>@(the-group!)</code></strong></li>
<li>
<strong><code>''''(quoted!)</code></strong>  <sub><a href="https://forum.rebol.info/t/quoted-arrives-formerly-known-as-lit-bit/995">yes, any number of quotes!</a></sub>
</li>
</ul>
<p>COMPOSE does useful magic for you, and if the type a GROUP! evaluates to supports the decoration, it will be applied!</p>
<pre><code>&gt;&gt; fruits: [apple banana]
&gt;&gt; dispositions: [favorite least-favorite]

&gt;&gt; compose [(dispositions.1): '@(second fruits)]
== [favorite: '@banana]
</code></pre>
<p><strong>Once you have this, you won't want to go back.</strong>  The premise of the language is being able to dynamically play with code and generate structures on the fly.  This makes that feel extremely seamless.</p>
<h2>
<a name="you-can-label-the-specific-groups-you-want-composed-4" class="anchor" href="https://forum.rebol.info#you-can-label-the-specific-groups-you-want-composed-4"></a>You Can Label the Specific Groups You Want Composed!</h2>
<p>One of the good things about templating is to be able to write most of your code normally, and then point out just the parts you want to substitute.  So if you're using so many groups that just being in a GROUP! isn't distinguishing what you want to substitute, <strong>tagged COMPOSE</strong> to the rescue:</p>
<p>You can pick whatever label you want, and the first item of each group will be checked against it:</p>
<pre><code>&gt;&gt; compose/label [(1 + 2) (&lt;*&gt; 1 + 2) (1 + 2)] &lt;*&gt;
== [(1 + 2) 3 (1 + 2)]
</code></pre>
<p>As a neat shorthand for this, a skippable TAG! parameter can be used:</p>
<pre><code>&gt;&gt; compose &lt;*&gt; [(1 + 2) (&lt;*&gt; 1 + 2) (1 + 2)]
== [(1 + 2) 3 (1 + 2)]
</code></pre>
<p>The TAG! has to be given literally between the COMPOSE and the expression you want to compose.  (This is a requirement for <code>&lt;skip&gt;</code>-ability.</p>
<p>You don't have to use symbols...any tag will do.  Could be a whole word with meaningful names, which might be valuable if you were doing it in several steps...where earlier phases could leave tags for later phases to compose.  You might also tag with numbers, <code>&lt;1&gt;</code> <code>&lt;2&gt;</code>...</p>
<h2>
<a name="predicate-functions-can-process-the-compose-slots-5" class="anchor" href="https://forum.rebol.info#predicate-functions-can-process-the-compose-slots-5"></a>Predicate Functions Can Process the Compose Slots!</h2>
<p>We now have the ability to run functions on the groups before you splice them.</p>
<p>So if you want to define COMPOSE that acts historically like Rebol2 (splicing unless you say /ONLY), here's one way you can do it:</p>
<pre><code>compose2: adapt augment :compose [/only] [
    if not only [
        predicate: func [group &lt;local&gt; product] [
            either any-array? product: eval group [spread product] [:product]
        ]
    ]
]
</code></pre>
<p>We added the /ONLY refinement, and if you don't use it then it adds a processing function for arrays.  This gives you the historical result!</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/surfing_man.png?v=12" title=":surfing_man:" class="emoji only-emoji" alt=":surfing_man:" loading="lazy" width="20" height="20"></p>
<p>This only scratches the surface of what's possible, with these bendable and useful ergonomics.</p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/the-superpowers-of-ren-cs-revamped-compose/979">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-superpowers-of-ren-cs-revamped-compose/979</link>
          <pubDate>Thu, 27 Dec 2018 08:01:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-979</guid>
          <source url="https://forum.rebol.info/t/the-superpowers-of-ren-cs-revamped-compose/979.rss">The Superpowers of Ren-C&#39;s Revamped COMPOSE</source>
        </item>
        <item>
          <title>You only get...ONESHOT</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>ONESHOT is a cool new function generator, which makes a DO-like function which holds state to run only once.</p>
<pre><code>once: oneshot
for-each x [10 20 30] [
     once [print ["loop begins with" x]]
     print [x]
]
</code></pre>
<p>And that will give you:</p>
<pre><code>loop begins with 10
10
20
30
</code></pre>
<p>So although ONCE was called for each step in the loop, it only ran what it was given one time.  Unlike code that is run before the loop, it has access to the first element.  <em>(If BREAK and CONTINUE were "definitional", it would also be able to modify them just once in the loop...which will likely be a relevant thing in the near future.)</em></p>
<p>It's obviously not anything you couldn't do with declaring a LOGIC! and putting in the test-and-flip code.  But it's shorter.  And unlike wrapping that logic up in a helper function, this lets the code that you're controlling <em>change</em>, so if one of the cases runs, the other case (with differing code) won't run.</p>
<p>Plus, ONESHOT will "voidify" the evaluative result of what it's given--like a conditional would.  So NULL will always mean it didn't run the code you gave it.  So for instance, this means that for every time but the first, you could respond to it with an ELSE.</p>
<pre><code>once: oneshot
for-each x [10 20 30] [
     once [print ["first:" x]] else [print ["rest:" x]]
]
</code></pre>
<p>That gives you:</p>
<pre><code>first: 10
rest: 20
rest: 30
</code></pre>
<p>ONESHOT is actually a specialization of N-SHOT, which lets you specifiy a generic N.  If that N is negative, then it will actually <em>not</em> run the code you give it N times before it starts running it.</p>
<pre><code>&gt;&gt; anti: n-shot -2

&gt;&gt; anti [5 + 5]
// null

&gt;&gt; anti [6 + 6]
// null

&gt;&gt; anti [7 + 7]
== 14

&gt;&gt; anti [8 + 8]
== 16
</code></pre>
<p><a class="mention" href="https://forum.rebol.info/u/markeye">@MarkEye</a>/<a class="mention" href="https://forum.rebol.info/u/mark-hi">@Mark-hi</a> suggested UPSHOT as the name for the specialization when it's -1, so I went with that as the complement to ONESHOT for now.</p>
<h2>Use with <code>&lt;static&gt;</code> and get lazy initialization</h2>
<p>If you have something you want to happen only the first time you call a function, that's now pretty easy:</p>
<pre><code>operation: function [... &lt;static&gt; lazy (oneshot)] [
    lazy [
        ** "do expensive initialization here"
    ]
    ...
]
</code></pre>
<p>This is a shorter way of writing:</p>
<pre><code>operation: function [... &lt;static&gt; initialized (false)] [
    if not initialized [
        ** "do expensive initialization here"
        initialized: true
    ]
    ...
]
</code></pre>
<p>Generating oneshots makes an ACTION!, and hence incurs more overhead than making a LOGIC! variable.  But once they've been created, the execution time should be less than a conditional.  e.g. for this case, <code>lazy</code> makes its decision faster than an IF, and doesn't have to look up the words for the logic variables to be tested.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/you-only-get-oneshot/934">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/you-only-get-oneshot/934</link>
          <pubDate>Fri, 30 Nov 2018 23:46:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-934</guid>
          <source url="https://forum.rebol.info/t/you-only-get-oneshot/934.rss">You only get...ONESHOT</source>
        </item>
        <item>
          <title>Comment to end-of-line with * *</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>It's Thanksgiving, and a good time to be thankful for <a href="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405">"invisibles"</a>, one of the great success stories of 2018.  Their applications have gone far beyond commenting, though that's great too.</p>
<p>But in the spirit of taking back attention-getting symbols I've taken back <strong><code>**</code></strong> from exponentiation (now just do infix exponents with <code>pow</code>).  In an idea near-simultaneously had by <a class="mention" href="https://forum.rebol.info/u/ingohohmann">@IngoHohmann</a> and I, it now acts as "comment to end of line" (or to end of block or group, whichever comes first).</p>
<p>What's the value of such a thing over <code>;</code>-style comments?  The real power is that it clearly annotates <em>code</em>, and raises a visual flag of "I am not a normal source comment"</p>
<pre><code>all [
    blah blah blah
    line two
    ** x: [some stuff here]
    do x
]
</code></pre>
<p>Had you used <code>//</code> it might be documentation.  Maybe that line is there to illustrate a property of x, to inform the next DO line?  But with <code>**</code> you know it's not an illustrative comment, it's marked out code.  It has to be LOADable, and stay LOADable.  And your eye can scan up and down the page and see these things easily before committing them on accident.</p>
<p>If you want to use it in the middle of a line, curb its to-end-of-line-ness by putting it in a GROUP!:</p>
<pre><code>any [this runs (** my-function "code that doesn't run") this runs too]
</code></pre>
<p>If you start a BLOCK! or GROUP! which then has newlines in it, that element will be the last thing considered...commented out to its end delimiter:</p>
<pre><code>&gt;&gt; print "this runs" ** (
    print "this does not run"
) print "this runs too"
</code></pre>
<p>(We could make that not work, by detecting arrays with newlines in them, and error?)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/comment-to-end-of-line-with/920">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/comment-to-end-of-line-with/920</link>
          <pubDate>Thu, 22 Nov 2018 15:35:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-920</guid>
          <source url="https://forum.rebol.info/t/comment-to-end-of-line-with/920.rss">Comment to end-of-line with * *</source>
        </item>
        <item>
          <title>I&#39;m bringin&#39; EVERY back (yeah!)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p><em>(<img src="//forum.rebol.info/images/emoji/twitter/man_dancing.png?v=7" title=":man_dancing:" class="emoji" alt=":man_dancing:">  <img src="//forum.rebol.info/images/emoji/twitter/musical_note.png?v=7" title=":musical_note:" class="emoji" alt=":musical_note:"> <img src="//forum.rebol.info/images/emoji/twitter/desktop_computer.png?v=7" title=":desktop_computer:" class="emoji" alt=":desktop_computer:"> ...them other boys don't know how to hack (yeah!) <img src="//forum.rebol.info/images/emoji/twitter/musical_note.png?v=7" title=":musical_note:" class="emoji" alt=":musical_note:"> <img src="//forum.rebol.info/images/emoji/twitter/man_dancing.png?v=7" title=":man_dancing:" class="emoji" alt=":man_dancing:"> <img src="//forum.rebol.info/images/emoji/twitter/computer.png?v=7" title=":computer:" class="emoji" alt=":computer:">)</em></p>
<p>With <a href="https://youtu.be/UD8tGWIqA-c?t=17" rel="nofollow noopener">apologies to Justin Timberlake</a>, I re-present to you EVERY.  It was <a href="https://github.com/metaeducation/ren-c/issues/847" rel="nofollow noopener">temporarily shelved</a> due to ambiguous semantics, that recent changes to the loop result protocol have basically solved.</p>
<p>It's like a FOR-EACH but if the loop body ever returns false, it returns false:</p>
<pre><code>&gt;&gt; every x [1 3 7] [print [x] | odd? x]
1
3
7
== #[true]

&gt;&gt; every x [1 4 7] [print [x] | odd? x]
1
4
7
== #[false]
</code></pre>
<p>So EVERY runs through all the loop steps (assuming you don't break), but remembers if the body ever returns a falsey value...and if so returns #[false].  Otherwise it returns the last truthy value.</p>
<p>Note that <code>CONTINUE</code> is interpreted as <code>CONTINUE NULL</code>, which means "act as if the loop body reached the end and had evaluated to null for this iteration".  As null is falsey, that means you need to say <code>CONTINUE TRUE</code> (or other truthy value) if you want that loop iteration to not count as disrupting the everyness.</p>
<pre><code>&gt;&gt; every x [1 2 3] [print [x] | if x = 2 [continue] x]
1
2
3
== #[false]

&gt;&gt; every x [1 2 3] [print [x] | if x = 2 [continue true] x]
1
2
3
== 3
</code></pre>
<p>It still obeys the loop result protocol, so that means if the loop ever breaks you'll get a NULL... and if the loop body never runs you'll get blank.  All three states are falsey so you get:</p>
<pre><code>every x data [
    ...
] or [
    // code to run if there was a break, there was no data,
    // or any of the loop body runs returned null/break/false
]
</code></pre>
<p>If you're trying to build an opt-out situation which would default to an empty input being okay (instead of falsey like if the body failed), test against false explicitly so the blank case won't qualify:</p>
<pre><code>false &lt;&gt; every x data [
    // if this body returns false (null, blank) then that will
    // make the whole expression false.  But the no data
    // case which returns blank will still give you truthyness
]
</code></pre>
<p>Though just because of how things work out, that will treat BREAK as a "success", since <code>false &lt;&gt; null</code>.  So if you have a need to use both BREAKs <em>and</em> falsey loop bodies in the every, turn the nulls into false explicitly:</p>
<pre><code>false &lt;&gt; (every x data [
    ...
] else [false])
</code></pre>
<p>Loop iterations must return something that can be tested for conditional truth or falsehood, so voids aren't legal.  This is an important distinction with FOR-EACH, which is able to run loop bodies that return void</p>
<pre><code>&gt;&gt; every x [1 2 3] [print "this errors, void loop body result"]
this errors, void loop body result
** Script Error: VOID! values are not conditionally true or false
</code></pre>
<p><em><img src="//forum.rebol.info/images/emoji/twitter/musical_note.png?v=7" title=":musical_note:" class="emoji" alt=":musical_note:"> ...so get your EVERY on (go 'head, be gone with it) <img src="//forum.rebol.info/images/emoji/twitter/musical_note.png?v=7" title=":musical_note:" class="emoji" alt=":musical_note:"></em></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/im-bringin-every-back-yeah/915">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/im-bringin-every-back-yeah/915</link>
          <pubDate>Mon, 19 Nov 2018 15:25:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-915</guid>
          <source url="https://forum.rebol.info/t/im-bringin-every-back-yeah/915.rss">I&#39;m bringin&#39; EVERY back (yeah!)</source>
        </item>
        <item>
          <title>Taking a Thrilling Tour Through the DUMP</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>DUMP is a vastly enhanced variation of the <strong><code>??</code></strong> operator in R3-Alpha.  If you weren't familiar with that, it was a simple spin on PROBE that quoted its argument and would GET it.  Like PROBE, it would return that same result for chaining.  <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/mezz/base-debug.r#L27">There's not much to it</a>, and its only "power user" feature was the ability to take a BLOCK!, and for some reason return that block unevaluated:</p>
<pre><code>r3-alpha&gt;&gt; x: 10 y: 20

r3-alpha&gt;&gt; ?? x
x: 10
== 10

r3-alpha&gt;&gt; ?? [x y] 
x: 10  y: 20  
== [x y]
</code></pre>
<p>Now before you keep reading, you better sit down... <strong>'cause Ren-C's gonna knock you off your feet.</strong>  <img src="https://forum.rebol.info/images/emoji/twitter/mans_shoe.png?v=12" title=":mans_shoe:" class="emoji" alt=":mans_shoe:" loading="lazy" width="20" height="20"> <img src="https://forum.rebol.info/images/emoji/twitter/mans_shoe.png?v=12" title=":mans_shoe:" class="emoji" alt=":mans_shoe:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-2696-english-name-and-a-convenient-symbol-name-1" class="anchor" href="https://forum.rebol.info#p-2696-english-name-and-a-convenient-symbol-name-1"></a>English Name, and a Convenient Symbol Name</h2>
<p>The DUMP service routine is also exposed as <strong><code>--</code></strong>, as part of the <a href="https://forum.rebol.info/t/theory-of-symbols-and-repurposing-and/834/4">"repurposing of jarring symbols"</a>.  This makes it even easier to type than <code>??</code>, yet still easy to see once typed in.  But ?? isn't going to waste...it's now a shorter way to say PROBE.</p>
<p><em>(And you're going to want to use DUMP a lot, so not having to hit shift to get those ?-marks is going to be ideal.)</em></p>
<p>As the forum post linked above explains, the shorthands are for use when what you're doing is not supposed to be checked in with the code.  They're standing out for a reason, to help you notice temporary stuff you threw in to help you debug.  So hopefully you won't accidentally commit them.  If you are writing test code which intends to leave the operations in for the long term, then use the full words.</p>
<p>Note that there's no reason to shed a tear over the loss of <code>--</code> as a decrement operator!  It's been leapfrogged by the super cool <a href="https://trello.com/c/8Bmwvwya/">ME and MY operators</a>, which are more general.  <em>(They're slated to get even cooler, once the mechanisms they use are rethought as fully userspace)</em></p>
<h3><a name="p-2696-doesnt-interfere-with-surrounding-logic-2" class="anchor" href="https://forum.rebol.info#p-2696-doesnt-interfere-with-surrounding-logic-2"></a>Doesn't Interfere with Surrounding Logic</h3>
<p>DUMP in Ren-C is a <em>hard-quoting variadic invisible</em>.  It has no return result whatsoever, meaning you can use it anywhere...like in the middle of an ANY or ALL statement, and not disrupt them:</p>
<pre><code>&gt;&gt; x: 10
&gt;&gt; any [
       -- "string literals just print labels!"
       false
       -- variable
       30
   ]
</code></pre>
<p>That gives:</p>
<blockquote>
<pre><code>-- "string literals just print labels!"
-- variable: 10
== 30
</code></pre>
</blockquote>
<p>While running, the output actually includes the <code>--</code> at the beginning of the line, to help connect the dumped output to the statements in your code.  This prefix is customizable, so when you make a dump specialization you can change it to whatever you like.</p>
<p>So it works in ANY, but it also works in ALL...and supports BLOCK! (in a fancier way, explained later):</p>
<pre><code>&gt;&gt; variable: 10 x: &lt;foo&gt; y: &lt;bar&gt;
&gt;&gt; all [
       true
       -- variable
       20
       -- [x y]
   ]
</code></pre>
<blockquote>
<pre><code>-- variable: 10
-- x: &lt;foo&gt;
-- y: &lt;bar&gt;
== 20
</code></pre>
</blockquote>
<p>If it erred on the side of being either truthy or falsey, you'd have to worry about how your debugging was disrupting matters.</p>
<h2><a name="p-2696-it-quotes-but-can-run-an-assignment-3" class="anchor" href="https://forum.rebol.info#p-2696-it-quotes-but-can-run-an-assignment-3"></a>It Quotes, <em>but</em> Can Run an Assignment!</h2>
<p>Though DUMP quotes the first thing it sees on its right hand side, it has a special behavior for SET-WORD!s.  If it sees a SET-WORD! it will go ahead and let the evaluator process one unit of work before dumping the symbol.</p>
<pre><code>&gt;&gt; -- summation: 100 + 200
-- summation: 300
</code></pre>
<p>This means that you don't have to repeat yourself the way you would have to in R3-Alpha, e.g.</p>
<pre><code>r3-alpha&gt;&gt; summation: 100 + 200
r3-alpha&gt;&gt; ?? summation
summation: 300
== 300
</code></pre>
<p>While specializing variadics can be irritating, this is actually easy, because DUMP always knows it's going to want at least one quoted parameter.  So you can specialize that, and leave the variadic part unspecialized:</p>
<pre><code>&gt;&gt; --setx: specialize '-- [value: quote x:]

&gt;&gt; --setx 1 + 2
-- x: 3

&gt;&gt; --setx 3 + 4
-- x: 7
</code></pre>
<p>You'd have to understand how hard it is to make it all "just work" to appreciate it.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-2696-also-supports-group-path-refinement-4" class="anchor" href="https://forum.rebol.info#p-2696-also-supports-group-path-refinement-4"></a>Also Supports GROUP!, PATH!, REFINEMENT!...</h2>
<p>You can use expressions in a group:</p>
<pre><code>&gt;&gt; -- (1 + 2 + 3)
-- (1 + 2 + 3): 6
</code></pre>
<p>Plus, you can mix and match...things you can use individually will work in a block!  Might as well demo a PATH! and SET-PATH! in there too, huh?</p>
<pre><code>&gt;&gt; x: 10 y: 20 obj: make object! [z: _]

&gt;&gt; -- ["some things" x y obj/z (x + y) obj/z: x * y]
-- "some things"
-- x: 10
-- y: 20
-- obj/z: _
-- (x + y): 30
-- obj/z: 200
</code></pre>
<p>This shows a test of the idea that if you have a SET-WORD! or SET-PATH! it will carry over behavior as if it was variadic.  It breaks the pattern in the block and maybe makes it harder to grok, but it's at least consistent with the quirk.</p>
<p>Also, since <a href="https://github.com/metaeducation/ren-c/issues/882">@IngoHohmann wanted a quick way to type "I got here"</a> solution, REFINEMENT! is supported:</p>
<pre><code>&gt;&gt; all [(-- /a) true (-- /b) false (-- /c)] print "^ didn't make it to /c"
-- /a
-- /b
^ didn't make it to /c
</code></pre>
<p>It doesn't get too much more expedient than that... no SHIFTing and full invisibility.  (INTEGER! is for the moment reserved, for a possible verbosity application, but for better or worse, /1 and /2 are legal refinements also.)</p>
<h2><a name="p-2696-make-your-own-dumpers-with-dumps-5" class="anchor" href="https://forum.rebol.info#p-2696-make-your-own-dumpers-with-dumps-5"></a>Make Your Own Dumpers With DUMPS</h2>
<p>This is a "just invented today" idea, but it's still fairly cool.  Let's say you have a subsystem and want to make something with DUMP's functionality, but just for it:</p>
<pre><code>--net: dumps #on
</code></pre>
<p>You pass it a refinement to say whether it is on or off by default, but you can call it with <span class="hashtag-raw">#on</span> or <span class="hashtag-raw">#off</span> later:</p>
<pre><code>&gt;&gt; --net ["testing..." /1 /2]
--net "testing"
--net /1
--net /2

&gt;&gt; --net #off

&gt;&gt; --net ["testing" /1 /2]
</code></pre>
<p>Note that it picked up the name from the SET-WORD! on the left it was assigned to, and uses that to mark its output.  Also, if your block runs any code <em>it will run regardless</em> of the enablement.  (So we might want better names like <span class="hashtag-raw">#silent</span> and <span class="hashtag-raw">#loud</span>?)</p>
<p>In any case, as it happens, plain old <code>--</code> will respond to <span class="hashtag-raw">#off</span> and <span class="hashtag-raw">#on</span> too... but raw DUMP will not, it cannot be disabled (except by hijacking or similar).</p>
<h2><a name="p-2696-dumps-lets-you-make-full-specializations-as-well-6" class="anchor" href="https://forum.rebol.info#p-2696-dumps-lets-you-make-full-specializations-as-well-6"></a>DUMPS Lets You Make Full Specializations As Well</h2>
<p>Whether you have a block with a bunch of variables you want to repeatedly examine, or just one variable with a really long name, DUMPS specializes with it:</p>
<pre><code>&gt;&gt; variable-one: 10 variable-two: 20
&gt;&gt; --dv: dumps [variable-one variable-two]

&gt;&gt; --dv (variable-one: variable-two: &lt;overwrite&gt; 1000) --dv
--dv variable-one: 10
--dv variable-two: 20
--dv variable-one: &lt;overwrite&gt;
--dv variable-two: &lt;overwrite&gt;
== 1000
</code></pre>
<p>DUMPS even goes one better on this, by letting you declare a dumper and assign a variable in one step:</p>
<pre><code>&gt;&gt; --v: dumps long-variable-name: 10 * 20

&gt;&gt; --v
--v long-variable-name: 200

&gt;&gt; long-variable-name: 80
== 80

&gt;&gt; --v
--v long-variable-name: 80
</code></pre>
<p>If you contrast this with SPECIALIZE w.r.t. a SET-WORD! shown earlier, this doesn't actually specialize with a SET-WORD! or SET-PATH!.  If it did, each call would try and get more arguments.  Instead, it uses its own variadic information, and then wordifies or pathifies the argument for the specialization.  Tres cool, huh?</p>
<p><em>(Note: One problem here is that since you specialized out the parameter, you have no way to turn <strong><code>--dv</code></strong> <span class="hashtag-raw">#on</span> or <span class="hashtag-raw">#off</span> any more!  There's actually a fair number of complex issues involved with this, but they're being looked at...in the meantime, if you need to turn off a full specialization, do it in two steps...make a non-fully specialized version, then specialize it, and disable it through the non-specialized one.)</em></p>
<h2><a name="p-2696-glad-you-sat-down-arent-you-7" class="anchor" href="https://forum.rebol.info#p-2696-glad-you-sat-down-arent-you-7"></a>Glad You Sat Down, Aren't You?  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></h2>
<p>This is a great missing piece for anyone who is upset that PRINT has gotten more picky and <a href="https://forum.rebol.info/t/limiting-print-to-block-text-perhaps-blank-to-opt-out/855">only takes TEXT! and BLOCK!</a>.  If you wanted easy debugging of values, you can't get much easier than <code>-- foo</code>...giving you what you'd otherwise have to do as <code>elide print ["foo is" mold foo]</code>.  The kinds of casual scenarios that would have wanted an "easy" print almost always fit this pattern, while the more rigorous ones that produce output are going to prefer the new PRINT.</p>
<p>But the real punch line is how accessible it is getting to write and design these features in userspace.  <a href="https://github.com/metaeducation/ren-c/blob/master/src/mezz/mezz-dump.r">%mezz-dump.r</a> is relatively easy to understand, and is a work in progress.  Most of the weird code is DUMP-OBJ from R3-Alpha (it's used by HELP).  I think DUMP itself is pretty obvious.</p>
<p>There's no shortage of open questions; I've run up against a bunch tonight, but when you start tallying things like the FizzBuzz success with the cleverness of these designs, it's looking pretty upbeat.</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/taking-a-thrilling-tour-through-the-dump/909">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/taking-a-thrilling-tour-through-the-dump/909</link>
          <pubDate>Fri, 16 Nov 2018 13:57:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-909</guid>
          <source url="https://forum.rebol.info/t/taking-a-thrilling-tour-through-the-dump/909.rss">Taking a Thrilling Tour Through the DUMP</source>
        </item>
        <item>
          <title>Discovering Words as ANY-STRING!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>Rebol's extremely strange nature makes people wonder what they should or shouldn't be doing with it.  When I tried writing basically my "first mezzanine" (<a href="http://blog.hostilefork.com/combine-alternative-rebol-red-rejoin/">COMBINE</a>) long ago, I faced questions pretty much anyone writing such a primitive would...like <strong>Should a WORD! be treated casually as if it were an ANY-STRING!?</strong></p>
<pre><code> &gt;&gt; mode: 'depeche
 &gt;&gt; combine/with ["a" mode "b"] space
 == "a depeche b"
</code></pre>
<p>Back then, I didn't know if that should be an error or not.  And if WORD! would be legal, should SET-WORD! too?  Would it have a colon?  Or was there a higher purpose for these things in the dialect, and should a variable holding one act the same as if one were literally present in the block?</p>
<p>Ren-C is on the path of thinking of "ANY-WORD!" as being strings is correct.  Which led me to consider this piece of code from HELP:</p>
<pre><code>for-each [a b] [
    "!" "-ex"
    "?" "-q"
    "*" "-mul"
    "+" "-plu"
    "/" "-div"
    "=" "-eq"
    "&lt;" "-lt"
    "&gt;" "-gt"
    "|" "-bar"
][
    replace/all item a b
]
</code></pre>
<p>What it is doing is pretty simple.  It is trying to convert a Rebol name to one that is readable/safe to use in a URL, so the help website URL doesn't have "weird" characters in it.</p>
<p>But if we're all on board with WORD! as working as a string, do you really need all those quotes?  Couldn't you say:</p>
<pre><code>for-each [a b] [
    ! -ex
    ? -q
    * -mul
    + -plu
    / -div
    = -eq
    &lt; -lt
    &gt; -gt
    | -bar
][
    replace/all item a b
]
</code></pre>
<p>You can do that, though it won't work for everything.  e.g. <code>:</code> would not be a legal WORD!.  And <code>|</code> is BAR!...like how <code>_</code> is a BLANK!...one must wonder, if those will "stringify" to be how they look.  Is this a good practice?</p>
<p>What I want us to be saying clearly now is <em>YES: it's a good practice and you can count on writing code like this</em>.  I think it's foundational to what Rebol is about.</p>
<p>Though as a matter of taste, I actually think the following looks slightly better, because using different types creates a kind of delimiting:</p>
<pre><code>for-each [a b] [
    ! "-ex"
    ? "-q"
    * "-mul"
    + "-plu"
    / "-div"
    = "-eq"
    &lt; "-lt"
    &gt; "-gt"
    | "-bar"
][
    replace/all item a b
]
</code></pre>
<p>But that's just me.  YMMV.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/discovering-words-as-any-string/695">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/discovering-words-as-any-string/695</link>
          <pubDate>Sun, 17 Jun 2018 18:59:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-695</guid>
          <source url="https://forum.rebol.info/t/discovering-words-as-any-string/695.rss">Discovering Words as ANY-STRING!</source>
        </item>
        <item>
          <title>The FREE Operation - releasing a series content, even if references exist</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>I've added a new ability to series, that they can free their data allocation <em>even if references to them still exist</em>:</p>
<pre><code>&gt;&gt; foo: collect [loop 1000 [keep &lt;x&gt;]]

&gt;&gt; bar: foo

&gt;&gt; bar/100
== &lt;x&gt;

&gt;&gt; free foo

&gt;&gt; bar/100
** Error: Series data has been freed
</code></pre>
<p>A small amount of memory (a series node) still hangs around.  That's 8 pointers in size, and won't go away until all the references are gone.  But the arbitrarily-large data allocation is freed up.  If you have a BINARY! blob that was a megabyte in size, you will only have 32 bytes remaining once you FREE it (or 64 bytes on 64-bit platforms).</p>
<p>The flag controlling this... SERIES_INFO_INACCESSIBLE... already existed.  It marked when a FRAME! for a function was no longer on the stack, so the data was gone.  But it has been promoted to a general feature of any series.  This means referencing data is a little slower because it has to check for the flag...however, I think that it is worth it.</p>
<p>I needed this right now for something specific--that is not going to actually be relevant in the future.  But I think exposing it as a general purpose feature is useful.  It can help work around bugs in people's code where they meant to tidy up all lingering references to large data blobs but missed some (maybe even in some debug logging that isn't critical)...so that not finding and clearing all those references doesn't imply indefinite memory usage.  It also might be a way to reclaim memory faster than a GC can... so even if the garbage collector would wind up getting the memory anyway, you can do more allocations before waiting for it.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/the-free-operation-releasing-a-series-content-even-if-references-exist/646">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-free-operation-releasing-a-series-content-even-if-references-exist/646</link>
          <pubDate>Mon, 28 May 2018 02:48:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-646</guid>
          <source url="https://forum.rebol.info/t/the-free-operation-releasing-a-series-content-even-if-references-exist/646.rss">The FREE Operation - releasing a series content, even if references exist</source>
        </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Feature Discover - AltRebol</title>
    <link>https://forum.rebol.info/c/usage/feature-discover/24</link>
    <description>Topics in the &#39;Feature Discover&#39; category Rebol and Red have quite a few cool features - this is PR for them.</description>
    
      <lastBuildDate>Sun, 03 Mar 2024 15:28:36 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/usage/feature-discover/24.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>REIFY and DEGRADE: a Narrower META and UNMETA</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>In the "small improvements can be big" category, I think that I've settled on the name for the function that turns quasiforms into antiforms, but leaves everything else alone: <strong>DEGRADE</strong>...and its complement <strong>REIFY</strong> which turns antiforms into quasiforms (but leaves everything else alone).</p>
<pre><code>&gt;&gt; first [1020 ~null~]
== 1020

&gt;&gt; second [1020 ~null~]
== ~null~

&gt;&gt; degrade first [1020 ~null~]
== 1020

&gt;&gt; degrade second [1020 ~null~]
== ~null~  ; anti

&gt;&gt; 304
== 304

&gt;&gt; reify 304
== 304

&gt;&gt; true
== ~true~  ; anti

&gt;&gt; reify true
== ~true~
</code></pre>
<p>If you're dealing with a full-band situation where you genuinely don't know if you're working with a "meaningful quasiform" where <em>quasi means quasi</em>, you have to use META and UNMETA.  But if you know that quasiforms aren't part of your data of interest, REIFY and DEGRADE can help you dodge adding and removing quote marks much (or most) of the time.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="12" data-topic="1560">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560/12">Weird WORD!s - Allow, But Escape Them?</a>
</div>
<blockquote>
<p>Maybe it would be better (and give Chris less of a heart attack) if it said:</p>
<pre><code class="lang-plaintext">for-each [sigil' items] [
    ~null~ [  word   tu.p.le   pa/th   [bl o ck]   (gr o up)  ]
    '::    [  word:  tu.p.le:  pa/th:  [bl o ck]:  (gr o up): ]
    ':     [ :word  :tu.p.le  :pa/th  :[bl o ck]  :(gr o up)  ]
    '^     [ ^word  ^tu.p.le  ^pa/th  ^[bl o ck]  ^(gr o up)  ]
    '&amp;     [ &amp;word  &amp;tu.p.le  &amp;pa/th  &amp;[bl o ck]  &amp;(gr o up)  ]
    '@     [ @word  @tu.p.le  @pa/th  @[bl o ck]  @(gr o up)  ]
    '$     [ $word  $tu.p.le  $pa/th  $[bl o ck]  $(gr o up)  ]
 ][
      for-each item items [
          if (unmeta sigil') &lt;&gt; sigil of item [fail [mold item]]
      ]
 ]
</code></pre>
</blockquote>
</aside>
<p>I like how DEGRADE can be used in situations like this to help you strike the quotes on the normal values...since SIGIL OF never returns quasiforms, only SIGIL! or a null antiform:</p>
<pre><code>for-each [sigil items] [
    ~null~ [  word   tu.p.le   pa/th   [bl o ck]   (gr o up)  ]
    ::     [  word:  tu.p.le:  pa/th:  [bl o ck]:  (gr o up): ]
    :      [ :word  :tu.p.le  :pa/th  :[bl o ck]  :(gr o up)  ]
    ^      [ ^word  ^tu.p.le  ^pa/th  ^[bl o ck]  ^(gr o up)  ]
    &amp;      [ &amp;word  &amp;tu.p.le  &amp;pa/th  &amp;[bl o ck]  &amp;(gr o up)  ]
    @      [ @word  @tu.p.le  @pa/th  @[bl o ck]  @(gr o up)  ]
    $      [ $word  $tu.p.le  $pa/th  $[bl o ck]  $(gr o up)  ]
][
    for-each item items [
        if (degrade sigil) &lt;&gt; sigil of item [
            fail [mold item]
        ]
    ]
]
</code></pre>
<p>I think this will be a useful and common pattern.</p>
<p>Void being a word antiform is locking this all up into place!</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/atom_symbol.png?v=12" title=":atom_symbol:" class="emoji only-emoji" alt=":atom_symbol:" loading="lazy" width="20" height="20"> <img src="https://forum.rebol.info/images/emoji/twitter/+1.png?v=12" title=":+1:" class="emoji only-emoji" alt=":+1:" loading="lazy" width="20" height="20"></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/reify-and-degrade-a-narrower-meta-and-unmeta/2163">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/reify-and-degrade-a-narrower-meta-and-unmeta/2163</link>
          <pubDate>Sun, 03 Mar 2024 15:28:36 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2163</guid>
          <source url="https://forum.rebol.info/t/reify-and-degrade-a-narrower-meta-and-unmeta/2163.rss">REIFY and DEGRADE: a Narrower META and UNMETA</source>
        </item>
        <item>
          <title>Introducing DELIMIT (plus SPACED and UNSPACED)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>Ren-C offers an alternative to historical AJOIN and REJOIN called DELIMIT:</p>
<pre><code>&gt;&gt; delimit "," ["foo" 1 + 2 "bar"]
== "foo,3,bar"

&gt;&gt; delimit/head "," ["foo" 1 + 2 "bar"]
== ",foo,3,bar"

&gt;&gt; delimit/tail "," ["foo" 1 + 2 "bar"]
== "foo,3,bar,"

&gt;&gt; delimit/head/tail "," ["foo" 1 + 2 "bar"]
== ",foo,3,bar,"
</code></pre>
<p>If you don't want it to reduce, you can use an @ block:</p>
<pre><code>&gt;&gt; delimit "," @["foo" 1 + 2 "bar"]
== "foo,1,+,2,bar"
</code></pre>
<p>SPACED and UNSPACED are specializations, running through the same code for stringifying any non-string contents.</p>
<pre><code>&gt;&gt; spaced ["foo" 1 + 2 "bar"]
== "foo 3 bar"

&gt;&gt; unspaced ["foo" 1 + 2 "bar"]
== "foo3bar"
</code></pre>
<p>PRINT uses SPACED internally when you pass it a block.  You can use <strong>print unspaced</strong> to pass it a string if you want unspaced intent.</p>
<pre><code>&gt;&gt; print ["foo" 1 + 2 "bar"]
foo 3 bar

&gt;&gt; print unspaced ["foo" 1 + 2 "bar"]
foo3bar
</code></pre>
<p>If you use a character (like <span class="hashtag">#a</span>) instead of a string (like "a"), the delimiting won't be applied.  For instance, a newline won't leave spaces on either end of the line break:</p>
<pre><code>&gt;&gt; spaced ["foo" 1 + 2 newline "bar"]
== "foo 3^/bar"
</code></pre>
<p>NULLs will trigger errors, VOIDs will vanish.</p>
<pre><code>&gt;&gt; spaced ["foo" if false [1 + 2] "bar"]
== "foo bar"

&gt;&gt; spaced ["foo" pick [a b] 3 "bar"]
** Script Error: non-NULL value required (see MAYBE, TRY, REIFY)

&gt;&gt; spaced ["foo" maybe pick [a b] 3 "bar"]
== "foo bar"
</code></pre>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/introducing-delimit-plus-spaced-and-unspaced/2102">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/introducing-delimit-plus-spaced-and-unspaced/2102</link>
          <pubDate>Thu, 11 Jan 2024 00:42:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2102</guid>
          <source url="https://forum.rebol.info/t/introducing-delimit-plus-spaced-and-unspaced/2102.rss">Introducing DELIMIT (plus SPACED and UNSPACED)</source>
        </item>
        <item>
          <title>COMPOSE of TUPLE! and PATH! (and toplevel GROUP!)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>While working on <a class="mention" href="https://forum.rebol.info/u/blackattr">@BlackATTR</a>'s query, I noticed code that was making paths (now tuples) out of components via TO TUPLE! COMPOSE of a BLOCK!.  Like this:</p>
<pre><code>to tuple! compose [obj clauses (kwd.1)]
</code></pre>
<p>But did you know that COMPOSE can act directly on TUPLE! and PATH!  You could instead just write:</p>
<pre><code>compose 'obj.clauses.(kwd.1)
</code></pre>
<p>It supports splices as well:</p>
<pre><code>&gt;&gt; compose '(10 + 20)/a/b/(spread [c d e])/(reverse [g f])
== 30/a/b/c/d/e/[f g]
</code></pre>
<p>And if you remember that TUPLE! can be nested underneath PATH! (not vice versa) then you can COMPOSE/DEEP and handle mixed tuples and paths:</p>
<pre><code>&gt;&gt; compose/deep '(10 + 20)/a/b.(spread [c d e])
== 30/a/b.c.d.e
</code></pre>
<p>Voids can vanish...so there can be fewer dots in an output tuple than in the input:</p>
<pre><code>&gt;&gt; compose 'a.(if false [b]).c
== a.c
</code></pre>
<p>Empty splices will vanish as well:</p>
<pre><code>&gt;&gt; compose 'a.(spread []).c
== a.c
</code></pre>
<p>You can't compose in NULLs as an important safety measure...central to the design!</p>
<pre><code>&gt;&gt; compose 'a.(select [x 10 y 20] 'b).c
** Script Error: non-NULL value required (see MAYBE, TRY, REIFY)
** Near: [a ** (select [x 10 y 20] 'b) c]
</code></pre>
<p>But don't forget about MAYBE as the way to convert nulls to void when that's what you meant!</p>
<pre><code>&gt;&gt; compose 'a.(maybe select [x 10 y 20] 'b).c
== a.c
</code></pre>
<h2>
<a name="you-can-also-compose-a-group-1" class="anchor" href="https://forum.rebol.info#you-can-also-compose-a-group-1"></a>You can also COMPOSE a GROUP!</h2>
<p>In R3-Alpha, only BLOCK! would compose.  Everything else was passed-through as-is, including GROUP!s (PAREN!s in their terminology)</p>
<pre><code>r3-alpha&gt;&gt; compose quote (1 + (2 + 3))
== (1 + (2 + 3))
</code></pre>
<p>Red just doesn't allow it:</p>
<pre><code>red&gt;&gt; compose quote (1 + (2 + 3))
*** Script Error: compose does not allow paren! for its value argument
</code></pre>
<p>So you'd wind up having to make BLOCK!s and then convert them:</p>
<pre><code>red&gt;&gt; as paren! compose [1 + (2 + 3)]
== (1 + 5)
</code></pre>
<p>But in Ren-C, group composing works... it just leaves the top group as-is.  And you also have quoted groups to make it easier!</p>
<pre><code>&gt;&gt; compose '(1 + (2 + 3))
== (1 + 5)
</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/compose-of-tuple-and-path-and-toplevel-group/2056">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/compose-of-tuple-and-path-and-toplevel-group/2056</link>
          <pubDate>Thu, 19 Oct 2023 06:39:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2056</guid>
          <source url="https://forum.rebol.info/t/compose-of-tuple-and-path-and-toplevel-group/2056.rss">COMPOSE of TUPLE! and PATH! (and toplevel GROUP!)</source>
        </item>
        <item>
          <title>There Came an ECHO</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>I just fixed a bug in Sea of Words...which hopefully means it's a little more trustworthy.</p>
<p>It seemed like a good time to add the ECHO feature I've talked about.</p>
<pre><code>&gt;&gt; echo It's this feature, which I've described in the past.
It's this feature, which I've described in the past.
</code></pre>
<p>ECHO is a variadic function which processes what you pass it to the end of line.  If you prefer, you can also use a BLOCK!.</p>
<pre><code>&gt;&gt; echo [A block allows
    you to put an arbitrary number
    of newlines]
A block allows you to put an arbitrary number of newlines

&gt;&gt; echo [Or two echos] echo [on the same line]
Or two echos
on the same line
</code></pre>
<p>There is a variable substitution mechanism so you can use @ to point out variables or expressions.</p>
<pre><code>&gt;&gt; x: 10
&gt;&gt; echo The value is @x
The value is 10

&gt;&gt; echo The doubled value is @(x * 2)
The doubled value is 20
</code></pre>
<h2>It's Shorter!</h2>
<p>Can't argue against that.</p>
<pre><code>print ["You have written" num-lines "lines of code."]

echo [You have written @num-lines lines of code.]

echo You have written @num-lines of code.
</code></pre>
<h2>The API Benefits</h2>
<p>Not needing quotes helps API calls:</p>
<pre><code>rebElide("print [{You have written}", num_lines, "{lines of code.}]");

rebElide("echo [You have written", num_lines, "lines of code.]");

rebElide("echo You have written", num_lines, "lines of code.");
</code></pre>
<p>It's the kind of change that opens up the choose-your-own-adventure of syntax to let you build a system more like bash, or less like bash.  It's an important decoupling of the use of words from the creation of variables.  So, onward.</p>
            <p><small>8 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/there-came-an-echo/1722">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/there-came-an-echo/1722</link>
          <pubDate>Sun, 19 Sep 2021 17:05:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1722</guid>
          <source url="https://forum.rebol.info/t/there-came-an-echo/1722.rss">There Came an ECHO</source>
        </item>
        <item>
          <title>APPLY II: The Revenge!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1406">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/design-issues-for-new-apply/1406/1">Design Issues for New APPLY</a>
</div>
<blockquote>
<p>It's time to bring back APPLY</p>
</blockquote>
</aside>
<p>...and by <em>"it's time"</em> I apparently meant <em>"within the next year, maybe"</em>...</p>
<p>But better late than never, right?  It's in!</p>
<h2>
<a name="refinements-can-be-provided-in-any-order-1" class="anchor" href="https://forum.rebol.info#refinements-can-be-provided-in-any-order-1"></a>Refinements Can be Provided In Any Order</h2>
<pre><code>[a b c d e d e] = apply :append [[a b c] [d e] /dup 2]
[a b c d e d e] = apply :append [/dup 2 [a b c] [d e]]
[a b c d e d e] = apply :append [[a b c] /dup 2 [d e]]

[a b c d d] = apply :append [/dup 2 [a b c] [d e] /part 1]
[a b c d d] = apply :append [[a b c] [d e] /part 1 /dup 2]
</code></pre>
<h2>
<a name="any-parameter-not-just-refinements-can-be-used-by-name-2" class="anchor" href="https://forum.rebol.info#any-parameter-not-just-refinements-can-be-used-by-name-2"></a>Any Parameter (Not Just Refinements) Can Be Used By Name</h2>
<p>Once a parameter has been supplied by name, it is no longer considered for consuming positionally.</p>
<pre><code>[a b c d e] = apply :append [/series [a b c] /value [d e]]
[a b c d e] = apply :append [/value [d e] /series [a b c]]

[a b c d e] = apply :append [/series [a b c] [d e]]
[a b c d e] = apply :append [/value [d e] [a b c]]
</code></pre>
<h2>
<a name="commas-are-ok-so-long-as-they-are-interstitial-3" class="anchor" href="https://forum.rebol.info#commas-are-ok-so-long-as-they-are-interstitial-3"></a>Commas Are Ok So Long As They Are Interstitial</h2>
<pre><code>[a b c d e d e] = apply :append [[a b c], [d e], /dup 2]
[a b c d e d e] = apply :append [/dup 2, [a b c] [d e]]

&gt;&gt; apply :append [/dup, 2 [a b c] [d e]]
** Script Error: end was reached while trying to set /dup
</code></pre>
<h2>
<a name="giving-too-many-arguments-is-an-error-4" class="anchor" href="https://forum.rebol.info#giving-too-many-arguments-is-an-error-4"></a>Giving Too Many Arguments Is An Error</h2>
<pre><code>&gt;&gt; apply :append [[a b c] [d e] [f g]]
** Script Error: Too many values in processed argument block of APPLY.
</code></pre>
<h2>
<a name="refinements-must-be-followed-by-a-non-refinement-5" class="anchor" href="https://forum.rebol.info#refinements-must-be-followed-by-a-non-refinement-5"></a>Refinements Must Be Followed By A Non-Refinement</h2>
<pre><code>&gt;&gt; apply :append [/dup /part 1 [a b c] [d e]]
** Script Error: end was reached while trying to set /dup
</code></pre>
<p>But you can pass refinements as arguments to refinements...just use a quote!</p>
<pre><code>&gt;&gt; tester: func [/refine [any-value!]] [refine]

&gt;&gt; apply :tester [/refine '/ta-da!]
== /ta-da!
</code></pre>
<h2>
<a name="no-arg-refinements-permit-logic-but-set-null-or-6" class="anchor" href="https://forum.rebol.info#no-arg-refinements-permit-logic-but-set-null-or-6"></a>No-Arg Refinements Permit LOGIC! But Set NULL or <code>#</code>
</h2>
<p>Remember: <em>the DO FRAME! mechanics do not change anything, besides ~unset~ isotopes being turned to NULLs.</em>  So if a refinement doesn't take an argument, <a href="https://forum.rebol.info/t/why-no-argument-refinements-are-blackhole-or-null/735">the only legal values for that refinement in the frame are # and NULL</a>.</p>
<p>But APPLY isn't DO FRAME!.  It's a higher level thing that builds a frame from the values you supply, and then has an opportunity to look over them before running DO FRAME!.  So if it sees you gave a #[true] or a #[false] to a refinement with no argument, it will adjust it appropriately.</p>
<pre><code>&gt;&gt; testme: func [/refine] [refine]

# = apply :testme [/refine #]
null = apply :testme [/refine null]

# = apply :testme [/refine true]
null = apply :testme [/refine false]
</code></pre>
<h2>
<a name="meta-arguments-are-also-accounted-for-7" class="anchor" href="https://forum.rebol.info#meta-arguments-are-also-accounted-for-7"></a>^META Arguments Are Also Accounted For</h2>
<p>For those following <a href="https://forum.rebol.info/t/default-values-and-make-frame/1412">the profound design points</a>, the DO FRAME! mechanic does not allow you to have isotopes in frame slots.  The way you get isotopes through to a function is through meta parameters, and by convention those parameters are quoted or otherwise "leveled up" into non-isotope status.</p>
<p>But as another convenience, APPLY detects when a parameter is meta and will level it up...because the low-level frame mechanics aren't allowed to editorialize:</p>
<pre><code>&gt;&gt; non-detector: func [arg] [arg]  ; not a meta argument, isotopes illegal

&gt;&gt; apply :non-detector [~baddie~]
** Script Error: non-detector needs arg as ^META for ~baddie~ isotope

&gt;&gt; detector: func [^arg] [arg]

&gt;&gt; apply :detector [~baddie~]
== ~baddie~
</code></pre>
<p><strong>I know not everyone has gotten their heads around isotopes yet, but they are critical... this stuff was the missing link to making it all gel.</strong></p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/dizzy.png?v=12" title=":dizzy:" class="emoji only-emoji" alt=":dizzy:" loading="lazy" width="20" height="20"> <img src="https://forum.rebol.info/images/emoji/twitter/dizzy.png?v=12" title=":dizzy:" class="emoji only-emoji" alt=":dizzy:" loading="lazy" width="20" height="20"> <img src="https://forum.rebol.info/images/emoji/twitter/dizzy.png?v=12" title=":dizzy:" class="emoji only-emoji" alt=":dizzy:" loading="lazy" width="20" height="20"></p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/apply-ii-the-revenge/1834">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/apply-ii-the-revenge/1834</link>
          <pubDate>Tue, 17 Aug 2021 07:58:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1834</guid>
          <source url="https://forum.rebol.info/t/apply-ii-the-revenge/1834.rss">APPLY II: The Revenge!</source>
        </item>
        <item>
          <title>Circling Multi-Returns: Choose Which Is Expression Result</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>Multi-Returns have a feature of being able to "circle" which result will be the value of the overall expression.  You do the circling with an <strong><code>@word</code></strong> or an <strong><code>@tu.p.le</code></strong>... or an <strong><code>@(gr o up)</code></strong> that evaluates to what you want to assign.</p>
<h3>
<a name="demo-1" class="anchor" href="https://forum.rebol.info#demo-1"></a>Demo!</h3>
<p>Here's a function with a secondary return value to demonstrate with:</p>
<pre><code>multi: func [
    return: "Main return value"
        [integer!]
    @secondary: "Secondary return value"
        [integer!]
][
    secondary: 20
    return 10
]
</code></pre>
<p>Traditionally you could ask for both results, and the overall result would be the first return:</p>
<pre><code>&gt;&gt; [a b]: multi
== 10  ; defaults to same value as first result, e.g. A

&gt;&gt; a
== 10

&gt;&gt; b
== 20
</code></pre>
<p>But now you can "circle" to ask for a different result, e.g. the second:</p>
<pre><code>&gt;&gt; [a @b]: multi
== 20  ; same value as b

&gt;&gt; a
== 10

&gt;&gt; b
== 20
</code></pre>
<p>You can combine this with things like GROUP!s to calculate the variable name, or even omit the variable name and use <code>#</code>:</p>
<pre><code>&gt;&gt; [a @(#)]: multi
== 20  

&gt;&gt; a
== 10
</code></pre>
<p>There are some places where this comes in handy, although you generally want to pick the main return to be the thing people are most interested in responding to (e.g. determining success or failure of an operation).</p>
<p>There's also a characteristic that only the main return can return unstable isotopes without having to contort the value convention itself to encode the void state (e.g. by ^META quoting the results).  So that should be weighed as well when thinking about how to plan the results.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/circling-multi-returns-choose-which-is-expression-result/1587">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/circling-multi-returns-choose-which-is-expression-result/1587</link>
          <pubDate>Sat, 17 Apr 2021 06:06:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1587</guid>
          <source url="https://forum.rebol.info/t/circling-multi-returns-choose-which-is-expression-result/1587.rss">Circling Multi-Returns: Choose Which Is Expression Result</source>
        </item>
        <item>
          <title>Case Study of Case Behavior: The AN Function</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>In thinking about weird applications of case, I was reminded of the little trick of the AN function:</p>
<pre><code>&gt;&gt; an "integer"
== "an integer"

&gt;&gt; an "text"
== "a text"
</code></pre>
<p>It simply checks the letters of the start of the rendering of what comes after it, and resolves to either "a" or "an".  I came up with it during the automatic generation of help strings for typecheckers, something along the lines of:</p>
<pre><code>for-each type data-types [
    help-string: spaced ["Checks to see if value is" an mold type]
    ...
]
</code></pre>
<p>But what if the A or An is at the start of a sentence?  Wouldn't the case of the operator matter?</p>
<pre><code>&gt;&gt; An "integer"
== "An integer"
</code></pre>
<p>Or how about all-caps?</p>
<pre><code>&gt;&gt; AN "INTEGER"
== "AN INTEGER"
</code></pre>
<p>In a case-insensitive world, all of these calls are to the same function.  So what it had to do was consult the stack to see what the label was it was invoked with, and go by the case of that.</p>
<p>But in a case-sensitive world, these would be three different functions (most likely, specializations of a core <code>AN*</code> that took what casing you wanted).</p>
<p>I'm not sure where this fits in the <a class="mention" href="https://forum.rebol.info/u/mark-hi">@Mark-hi</a> taxonomy of rightness or wrongness.  But it does point to an axis of flexibility where someone can use stack reflection to force case-sensitive behavior in a case-insensitive system.</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/case-study-of-case-behavior-the-an-function/1469">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/case-study-of-case-behavior-the-an-function/1469</link>
          <pubDate>Mon, 18 Jan 2021 21:37:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1469</guid>
          <source url="https://forum.rebol.info/t/case-study-of-case-behavior-the-an-function/1469.rss">Case Study of Case Behavior: The AN Function</source>
        </item>
        <item>
          <title>Can Functions You ➤ Now REORDER</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>As things have slowly nudged along in the function composition space, I've kept a generic reordering facility in mind.</p>
<p>And today... less than a week into 2021... we have a first version of it, tentatively named REORDER.</p>
<pre><code>&gt;&gt; append-value-first: reorder :append [value series]

&gt;&gt; append-value-first &lt;item&gt; [a b c]
== [a b c &lt;item&gt;]
</code></pre>
<p>As with other function derivations, there's a lot of benefit over writing <strong>func [value series] [append series value]</strong> !</p>
<p>First of all, it's nearly as fast as the original function. It adds a little overhead to do the rearrangement, but it places values in the same underlying frame slots...and introduces no new frame of its own.</p>
<p>You keep the HELP, parameter names, and descriptions...as well as keep the refinements:</p>
<pre><code>&gt;&gt; append-value-first/dup &lt;item&gt; [a b c] 3
== [a b c &lt;item&gt; &lt;item&gt; &lt;item&gt;]
</code></pre>
<h2>Usage Notes</h2>
<p><em>You need to provide all the required arguments</em>.  It won't guess where you want parameters to go.</p>
<pre><code>&gt;&gt; reorder :append [value]
** Script Error: append is missing its series argument
</code></pre>
<p>However... <strong>you can position optional arguments in the ordering if you like!</strong></p>
<pre><code>&gt;&gt; append-val-dup-ser: reorder :append [value dup series]

&gt;&gt; append-val-dup-ser &lt;item&gt; 3 [a b c]
== [a b c &lt;item&gt; &lt;item&gt; &lt;item&gt;]
</code></pre>
<p>As usual, I will plead for the submission of more tests:</p>
<p><strong><a href="https://github.com/metaeducation/ren-c/blob/master/tests/functions/reorder.test.reb">%tests/functions/reorder.test.reb</a></strong></p>
<p>I point out that this is based on a more foundational ability, to specify non-refinement arguments in paths...which pushes them to the end of the pending arguments:</p>
<pre><code>&gt;&gt; append/series &lt;item&gt; [a b c]
== [a b c &lt;item&gt;]
</code></pre>
<p>REORDER gives you a more intuitive interface to it, but you can also do it that way if you feel like it!</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/can-functions-you-now-reorder/1458">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/can-functions-you-now-reorder/1458</link>
          <pubDate>Wed, 06 Jan 2021 02:46:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1458</guid>
          <source url="https://forum.rebol.info/t/can-functions-you-now-reorder/1458.rss">Can Functions You ➤ Now REORDER</source>
        </item>
        <item>
          <title>For Better or Worse: MACRO</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>So it's long been theorized that there could exist a form of function that would splice its result into the feed of execution.  And now we have it:</p>
<pre><code> appender: macro [x /ref] [
      if ref [
          return [append x second]  ; return block of "incomplete" code
      ] else [
          return [append x first]
      ]
 ]

 &gt;&gt; appender [a b c] [1 2 3]
 == [a b c 1]  ; acts as spliced `&lt;&lt;append x first&gt;&gt; [a b c] [1 2 3]`

 &gt;&gt; appender/ref [a b c] [1 2 3]
 == [a b c 2]  ; acts as spliced `&lt;&lt;append x second&gt;&gt; [a b c] [1 2 3]`
</code></pre>
<p>So you return a BLOCK! of what you want spliced in at the callsite.  The bindings in that block won't be changed, however...so the <strong>x</strong> will still refer to the parameter value, not some x at the callsite.</p>
<p>The reason this exists now is to expose and test a core ability that is used by predicates to make them faster and more reliable.  Predicates do a similar array splice...using the array underlying the PATH! that you pass it.  This means it doesn't have to generate a function (that would need to be GC'd) or run a function application, so <strong>any .not.even? [2, 3]</strong> is aiming to have performance parity with <strong>any [not even? 2, not even? 3]</strong></p>
<p><strong>But as with most language features called "macro", there are downsides.</strong>  The function interface for this macro looks like it only takes one argument, but it winds up implicitly picking up two.  So macros are variadic.  My plan for POINTFREE is to be smarter and actually generate an ACTION! that figures out how many parameters it needs to take, but that's more expensive to do and it was making predicates not as good as it should be.</p>
<p>Note that if you put an enfix operator at the beginning of a macro splice, it will not be able to see its left.  So if you want a macro to see the left hand side parameter, <em>the macro itself has to be enfix</em>.  It will see the enfix parameter, but won't "consume" it:</p>
<pre><code> add1020: enfix macro [discarded] [
     return [+ 1020]
 ]

 &gt;&gt; 304 add1020
 == 1324
</code></pre>
<blockquote>
<p>As a general reminder of why you can't decide enfix "after the fact"... the concept of a single instruction "step" is one that has a finishing point.  If all functions reserved the right to be enfix, then that would mean a DO of a BLOCK! couldn't be separated into individual evaluation steps...each function would run glued to the last.  It would be possible to avoid this if COMMA!s between expressions were enforced so you called out where every expression ended, but we obviously do not want that!</p>
</blockquote>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/for-better-or-worse-macro/1410">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/for-better-or-worse-macro/1410</link>
          <pubDate>Fri, 20 Nov 2020 11:46:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1410</guid>
          <source url="https://forum.rebol.info/t/for-better-or-worse-macro/1410.rss">For Better or Worse: MACRO</source>
        </item>
        <item>
          <title>Introducing REFRAMER: Close Cousin to ENCLOSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>This is a very cool tool that might help concretize some of the <a href="https://forum.rebol.info/t/seeing-all-action-s-as-variadic-frame-makers/1002/2">abstract-sounding arguments I was making about frames</a>...</p>
<p><strong>Reframers build a frame from whatever follows them at a callsite, and can operate on it before running it (<em>if</em> it runs it).</strong></p>
<p>Defining a reframer involves giving it a function that will act as the "shim".  Here is a reframer using a very simple shim, that just takes in the frame and returns it.</p>
<pre><code>get-frame-of: reframer (func [f [frame!]] [f])
</code></pre>
<p>Here is what happens if the thing that followed that reframer's execution was a call to APPEND:</p>
<pre><code>&gt;&gt; get-frame-of append [a b c] &lt;d&gt;
== make frame! [
    series: [a b c]
    value: &lt;d&gt;
    part: '
    only: '
    dup: '
    line: '
]
</code></pre>
<p>As we can see, it gathered the arguments for the APPEND and put together a FRAME! to represent the call.</p>
<p><strong>The reframing process did not automatically execute the frame.  But the "shim" function can!</strong></p>
<p>Let's try something that runs the function twice.</p>
<pre><code>&gt;&gt; two-times: reframer func [f [frame!]] [do copy f, do f]

&gt;&gt; two-times append [a b c] &lt;d&gt;
== [a b c &lt;d&gt; &lt;d&gt;]
</code></pre>
<h2>Whoa.</h2>
<p><strong>But wait, there's more.</strong>  Besides not automatically executing the FRAME!, <em>it also doesn't typecheck it (yet)</em>.</p>
<pre><code>&gt;&gt; get-frame-of append 1 &lt;d&gt;
== make frame! [
    series: 1        ; !!! this wouldn't be legal to run as-is 
    value: &lt;d&gt;
    part: '
    only: '
    dup: '
    line: '
]
</code></pre>
<p>With our "shim" function in the driver's seat, it can manipulate the inputs and the results.</p>
<p>Consider how right now, functions like APPEND won't take QUOTED!</p>
<pre><code>&gt;&gt; item: first ['''[a b c]]
== '''[a b c]

&gt;&gt; append item &lt;d&gt;
** Script Error: append does not allow QUOTED! for its series argument
</code></pre>
<p>But what if we made a REQUOTE that:</p>
<ul>
<li>would build a frame for whatever follows it</li>
<li>counted how many quoting levels were on the first argument in that frame</li>
<li>took the quoting levels off that first argument</li>
<li>ran the function</li>
<li>added the quoting levels back to the result</li>
</ul>
<p>It should be an easier function to write than it is, but even so it's not that hard:</p>
<pre><code>requote: reframer func [
     {Remove Quoting Levels From First Argument and Re-Apply to Result}
     f [frame!]
     &lt;local&gt; p num-quotes result
][
    p: first words of f
    num-quotes: quotes of f/(p)
    f/(p): dequote f/(p)

    if null? result: do f [return null]  ; exempt NULL from requoting

    return quote/depth get/any 'result num-quotes
]
</code></pre>
<p>And behold:</p>
<pre><code>&gt;&gt; item: first ['''[a b c]]
== '''[a b c]

&gt;&gt; requote append item &lt;d&gt;
== '''[a b c &lt;d&gt;]
</code></pre>
<h2>The Shim Can Take Arguments</h2>
<p>The last argument of the shim needs to be a frame, but it could also have its own arguments.</p>
<p>Just to demonstrate this point without any frame-fiddling to obscure the point, how about a message that prints before and after just executing the frame:</p>
<pre><code>&gt;&gt; bracketer: reframer func [msg [text!] f [frame!]] [
       print msg
       do f
       print msg
   ]

&gt;&gt; bracketer "Aloha!" print "I'm being framed!"
Aloha!
I'm being framed!
Aloha!
== ~void~
</code></pre>
<h2>Things To Think About</h2>
<p>This is very cool, and it pins down a number of questions about evaluation.</p>
<p>Hopefully now you can see why type errors shouldn't happen during argument fulfillment, but only once the function actually gets to the point of running.  e.g. a reframer that just does the function after it shouldn't act any different than that function would running normally.</p>
<p>One tough problem is what to do when you get multiple reframer functions in a row.  I give the example of:</p>
<pre><code>&gt;&gt; item: first ['''[a b c]]
== '''[a b c]

&gt;&gt; item: my requote append &lt;d&gt;
 ; ... how can this work?
</code></pre>
<p>MY is also a reframer.  But if it gets a FRAME! for REQUOTE, that will not be what it expects.  Because REQUOTE has a single argument in its frame...which is a frame, not a callsite argument.  :-/</p>
<p>What MY really wants is a FRAME! for the aggregate function of "REQUOTE APPEND".  Such aggregate frames aren't impossible to conceive of, but are beyond what we have today.</p>
<p>That's probably the biggest issue I can see right now with this.  But it's a step ahead of having to reinvent the technique on every function that wants to do something like it.  And it means that when an answer for one such functions is made, all of them will get it.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/introducing-reframer-close-cousin-to-enclose/1395">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/introducing-reframer-close-cousin-to-enclose/1395</link>
          <pubDate>Mon, 09 Nov 2020 03:15:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1395</guid>
          <source url="https://forum.rebol.info/t/introducing-reframer-close-cousin-to-enclose/1395.rss">Introducing REFRAMER: Close Cousin to ENCLOSE</source>
        </item>
        <item>
          <title>DEFAULT with Predicates: The Must-Match Constraint</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>With some sadness, <a href="https://forum.rebol.info/t/default-now-usable-in-case-switch/739/6">the experiment for DEFAULT inside of CASE/SWITCH is having to get the axe</a>.  I explain the reason there due to the coming influence of predicates.</p>
<blockquote>
<p>Note: I will emphasize that these experiments--even if they get backed out--are frequently major contributors in the sense of the facilities they test and keep working.  In this case, skippable left enfix quoting.</p>
<p>(The same is true of why COMMA! could be implemented in a day.  Its BAR!-based predecessors had stretched over years of sifting out the interactions of invisible expression barriers with all the other constructs.)</p>
</blockquote>
<h2>The Predicates Taketh Away, But They Also Giveth!</h2>
<p>So to bring in a fun new feature, I've added a predicate to DEFAULT itself.</p>
<p>What the predicate means is that you can have an additional test (beyond "being not NULL or VOID!") for <em>when a value shouldn't be overwritten</em>.</p>
<pre><code>&gt;&gt; value: "not an integer"

&gt;&gt; value: default .integer? [10 + 20]
&gt;&gt; value  ; wasn't an integer, changed
== 30

&gt;&gt; value: default .integer? [1000 + 2000]
&gt;&gt; value
== 30  ; was already an integer, no change.
</code></pre>
<p>So the behavior is <em>similar</em> to:</p>
<pre><code>if not integer? value [value: 1000 + 2000]
</code></pre>
<p>But you're getting more than avoiding the repeat of a variable name.  You're actually getting:</p>
<pre><code>all [
     not void? get/any 'value   ; or `defined? 'value`
     not null? :value           ; or `set? 'value`
     not integer? :value
 ] then [
     value: 1000 + 2000
 ]
</code></pre>
<h2>Question: Should The Predicate Be Backwards?</h2>
<p>This depends on how you read it <strong>x: default .xxx? [...]</strong></p>
<pre><code>X Should DEFAULT IF .XXX? is TRUE

X Should DEFAULT UNLESS .XXX? is TRUE
</code></pre>
<p>Neither the word "IF" nor "UNLESS" appear in DEFAULT, so it's not like there's an obvious answer.</p>
<p>I picked it the UNLESS way because it seems like you'd end up writing shorter code in general if you talk about what you <em>want</em> instead of what you <em>don't want</em>.  Almost every condition would need a NOT in it, otherwise.  So you save some typing.</p>
<p>But if people find it confusing this way, and really believe changing it would help, I'd be fine with it.</p>
<h2>Predicates Are Game-Changers</h2>
<p>There was a lot of agony before about whether BLANK! should count as a "set" variable or not.  if that's something people might want to control, you have to think of a refinement name for it (DEFAULT/ONLY ?) and it can get very hard to reason about.</p>
<p>This cuts through all the fog.  If you don't supply a predicate, the default is <code>.not.blank?</code>   e.g. any non-blank value counts as being already set, and isn't defaulted.  But blank values are defaulted.</p>
<p>Providing a custom predicate overrides it.  This is infinitely more useful.</p>
<p><strong>I think you're going to like where predicates are going, as the haphazard internal non-configurable decision making of constructs is formalized and overridable.</strong></p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/default-with-predicates-the-must-match-constraint/1393">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/default-with-predicates-the-must-match-constraint/1393</link>
          <pubDate>Sat, 07 Nov 2020 15:09:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1393</guid>
          <source url="https://forum.rebol.info/t/default-with-predicates-the-must-match-constraint/1393.rss">DEFAULT with Predicates: The Must-Match Constraint</source>
        </item>
        <item>
          <title>AUGMENT: Add Parameters and Refinements After-The-Fact</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p><img src="https://forum.rebol.info/images/emoji/twitter/boxing_glove.png?v=9" title=":boxing_glove:" class="emoji" alt=":boxing_glove:"> <a href="https://www.youtube.com/watch?v=VWuVEhTJPdw">Don't call it a comeback...</a> <img src="https://forum.rebol.info/images/emoji/twitter/boxing_glove.png?v=9" title=":boxing_glove:" class="emoji" alt=":boxing_glove:"></p>
<p><strong>AUGMENT</strong> is a new addition to the function composition toolbox.  It serves a single purpose: to create a variation of a function that has more parameters and refinements, but <em>acts exactly the same</em>.</p>
<pre><code>&gt;&gt; foo-x: func [x [integer!]] [
       print ["x is" x]
   ]

&gt;&gt; foo-xy: augment :foo-x [y [integer!]]

&gt;&gt; foo-x 10
x is 10

&gt;&gt; foo-xy 10
** Error: foo-xy is missing its y argument

&gt;&gt; foo-xy 10 20
x is 10
</code></pre>
<p>You might ask: "What good is that, since the original function has no idea the parameter is there?"  This is where our friends like ADAPT and ENCLOSE come in.</p>
<p>Let's try that again.  First, with an ADAPT:</p>
<pre><code>&gt;&gt; foo-xy: adapt (augment :foo-x [y [integer!]]) [
       print ["y is" y]
   ]

&gt;&gt; foo-xy 10 20
y is 20
x is 10
</code></pre>
<p>And here's an ENCLOSE example:</p>
<pre><code>&gt;&gt; foo-xy2: enclose (augment :foo-x [y [integer!]]) func [f [frame!]] [
       let y: f.y
       print ["y is" y]
       do f
       print ["y is still" y]
   ]

&gt;&gt; foo-xy2 10 20
y is 20
x is 10
y is still 20
</code></pre>
<h2>This didn't drop out of the sky...</h2>
<p>It is the result of long-term-thinking, and design choices with an eye toward doing this <em>someday</em>.  One of the recent strategic moves that really made it feasible was <a href="https://forum.rebol.info/t/pure-and-refined-simplifying-refinements-to-one-or-zero-args/1120">changing refinements to be their own arguments</a>.  If it weren't for that, if your function was <strong>foo: func [x /y] [...]</strong> and you tried <strong>bar: augment 'foo [z]</strong>, the parameter list would look like you had written <strong>bar: func [x /y z] [...]</strong>.  As soon as a function got a refinement, you'd have no way to add a normal parameter...because everything would become an argument to the last refinement.</p>
<p>The very first motivating scenario which got me thinking about this was when I was lobbying for removing the /DEFAULT refinement from SWITCH.  I felt strongly about needing a generalized solution based on NULL results from branching constructs.  But I wanted it to be easy to make a compatibility version.</p>
<p>And now, it <strong>is</strong> easy:</p>
<pre><code> switch-d: enclose (augment :switch [
     /default "Default case if no others are found"
        [block!]
 ]) func [f [frame!]] [
     let def: f.default  ; see NOTE on why it's not `do f else (f/default)`
     do f else (def)
 ]
</code></pre>
<p>It works the way you'd expect:</p>
<pre><code>&gt;&gt; switch-d 1 [1 [print "one" 1020]]
one
== 1020

&gt;&gt; switch-d/default 1 [1 [print "one" 1020]] [print "defaulting!" 304]
one
== 1020

&gt;&gt; switch-d/default 2 [1 [print "one" 1020]] [print "defaulting!" 304]
defaulting!
304
</code></pre>
<p>I'm not totally thrilled with the way the meta information for HELP is being inherited.  But the somewhat hackish way it is done is working well enough to get us started.  Note how the description for /DEFAULT was incorporated:</p>
<pre><code>&gt;&gt; help switch-d
USAGE:
    SWITCH-D value :predicate cases /all /default

DESCRIPTION:
    Selects a choice and evaluates the block that follows it.
    SWITCH-D is an ACTION!

RETURNS: [&lt;opt&gt; any-value!]
    Last case evaluation, or null if no cases matched

ARGUMENTS:
    value [&lt;opt&gt; any-value!]
        Target value
    :predicate [refinement! action! &lt;skip&gt;]
        Binary switch-processing action (default is /EQUAL?)
    cases [block!]
        Block of cases (comparison lists followed by block branches)

REFINEMENTS:
    /all
        Evaluate all matches (not just first one)
    /default [block!]
        Default case if no others are found
</code></pre>
<p>This is a very new mechanism that is going to need testing.  But it's going to make many things easier--not just in implementing things like Redbol, but also in being able to create skins with warnings about deprecated refinements (and what to do instead)...while removing those refinements from the natives themselves.</p>
<p>Try it out!</p>
<hr>
<p><em>NOTE: Although I'm now of the belief that <a href="https://forum.rebol.info/t/what-happens-to-function-arguments-and-locals-when-the-call-ends/234">function arguments must outlive their calls</a>, I don't believe this implies that <strong>do f</strong> should not invalidate the caller's handle on that <strong>f</strong> frame.  It is an effective transfer of ownership of that frame to the function; and you need the feedback that you cannot expect another DO to work again.  Hence the default must be cached.</em></p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/augment-add-parameters-and-refinements-after-the-fact/1216">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/augment-add-parameters-and-refinements-after-the-fact/1216</link>
          <pubDate>Fri, 27 Sep 2019 18:46:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1216</guid>
          <source url="https://forum.rebol.info/t/augment-add-parameters-and-refinements-after-the-fact/1216.rss">AUGMENT: Add Parameters and Refinements After-The-Fact</source>
        </item>
        <item>
          <title>AS BINARY! view of strings is back...with UTF-8! (that&#39;s only /PART!)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <h2>Mutate strings aliased as BINARY!, and vice-versa, as in Rebol2!</h2>
<p>Rebol2's AS-BINARY and AS-STRING provided a convenient aliasing between binary and string as Latin1 single-byte characters:</p>
<pre><code>rebol2&gt;&gt; b: as-binary s: "hello"
== #{68656C6C6F}

rebol2&gt;&gt; append b #{68}
== #{68656C6C6F68}

rebol2&gt;&gt; s
== "helloh"  ; binary mutation reflected in original string

rebol2&gt;&gt; append s "ello"
== "hellohello"

rebol2&gt;&gt; b
== #{68656C6C6F68656C6C6F}
</code></pre>
<p>That was lost when R3-Alpha's internal string format became too unpredictable (swinging between Latin1 and UCS2) and was only canonized as UTF-8 for I/O.  Red suffered a similar fate.</p>
<p>But with <a href="https://forum.rebol.info/t/realistically-migrating-rebol-to-utf8-everywhere/374">UTF-8 Everywhere</a> as the fixed internal format of strings, Ren-C has done some voodoo to bring it back.</p>
<p>It offers a more generic AS operation, along with higher-than-UCS2 codepoint support:</p>
<pre><code>&gt;&gt; b: as binary! s: "hello"
== #{68656C6C6F}

&gt;&gt; to binary! "🐱"
== #{F09F90B1}

&gt;&gt; append b #{F09F90B1}  ; add that high-codepoint cat!
== #{68656C6C6FF09F90B1}

&gt;&gt; s
== "hello🐱"

&gt;&gt; append s "hello🐱"
== "hello🐱hello🐱"

&gt;&gt; b
== #{68656C6C6FF09F90B168656C6C6FF09F90B1}
</code></pre>
<p>But a binary alias of a string is constrained to staying as valid UTF-8:</p>
<pre><code>&gt;&gt; append b #{FEFEFEFE}
** Internal Error: invalid UTF-8 byte sequence found during decoding
</code></pre>
<p>You can actually alias WORD! as BINARY! also, without doing a separate allocation.  But it will be  read-only view, so all you're doing is saving on memory and GC load:</p>
<pre><code>&gt;&gt; b: as binary! 'immutable-word
== #{696D6D757461626C652D776F7264}

&gt;&gt; append b #{1020}
** Access Error: series is source or permanently locked, can't modify
</code></pre>
<p>Similarly, you can alias words as strings...again without making a new allocation, but with the same read-only constraint:</p>
<pre><code>&gt;&gt; t: as tag! 'append
== &lt;append&gt;

&gt;&gt; append t "nope"
** Access Error: series is source or permanently locked, can't modify
</code></pre>
<h2>The /PART refinement has just been implemented for UTF-8</h2>
<p><a href="https://github.com/rebol/rebol-issues/issues/2096" rel="nofollow noopener">The controversial behavior can be discussed on issue #2096</a> (which you can discuss on that ticket).  But what R3-Alpha and Red choose to (<a href="https://github.com/rebol/rebol-issues/issues/2383" rel="nofollow noopener">buggily</a>) implement is that it applies to the target series only...and is thus measured in the units of <em>that</em> series:</p>
<pre><code>&gt;&gt; append/part "abc" [100 "de" "fg"] 2
== "abc10"  ; 2 string units, not "abc100de" from 2 block units
</code></pre>
<p>The argument is that COPY/PART on the source series gives you that form /PART if you need it, so this is "strictly more powerful".  Rightly or wrongly... Ren-C is now doing it hopefully less buggily (though almost certainly with its own bugs), but with UTF-8 Everywhere support.</p>
<p>If you like, you can limit how much of a binary you extract from UTF-8, counted in bytes:</p>
<pre><code>&gt;&gt; to binary! "🐱"
== #{F09F90B1}

&gt;&gt; append/part #{} "🐱" 2  ; e.g. 2 bytes (half a cat)
== #{F09F}
</code></pre>
<p>Extracting bytes from UTF-8 will always work.  Going the other way, not all binary strings are valid UTF-8.  But as long as the number of characters you ask for in that section of the binary are valid, having other invalid bytes isn't a problem...only when you ask for part out of the unchecked region:</p>
<pre><code>&gt;&gt; append/part "" #{F09F90B1F09F90B1FEFEFEFE} 2  ; e.g. 2 characters
== "🐱🐱" 

&gt;&gt; append/part "" #{F09F90B1F09F90B1FEFEFEFE} 3
** Internal Error: invalid UTF-8 byte sequence found during decoding
</code></pre>
<p>If a binary is actually an alias of a UTF-8 string, this can be more efficient by not rescanning... <em>(though the code is still in its early life yet, so it has a number of areas for improvement)</em>.</p>
<p><strong>Pretty cool, eh?</strong></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/as-binary-view-of-strings-is-back-with-utf-8-thats-only-part/1186">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/as-binary-view-of-strings-is-back-with-utf-8-thats-only-part/1186</link>
          <pubDate>Tue, 23 Jul 2019 21:33:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1186</guid>
          <source url="https://forum.rebol.info/t/as-binary-view-of-strings-is-back-with-utf-8-thats-only-part/1186.rss">AS BINARY! view of strings is back...with UTF-8! (that&#39;s only /PART!)</source>
        </item>
        <item>
          <title>Postfix Assertions: SO, WAS, MATCHED</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>Assertions are important, but some people want to write short code and feel the assertions can clutter it up.</p>
<p>But what if the assertion was as brief and to the point as a comment was?  That inspired these postfix assert operators...</p>
<h2>SO</h2>
<p>Takes a condition on the left and treats that as a thing to assert on.  It's variadic on the right and won't run the right to get the expression until the left has been shown as true.</p>
<pre><code>&gt;&gt; x: 0

&gt;&gt; 1 = 2 so x: &lt;changed&gt;
** Script Error: assertion failure: [false so]
** Where: so console
** Near: [... = 2 so ~~ x: &lt;changed&gt;]

&gt;&gt; x
== 0  ; didn't change, the assignment didn't get a chance to run

&gt;&gt; 1 = 1 so x: &lt;changed&gt;
== &lt;changed&gt;

&gt;&gt; x
== &lt;changed&gt;  ; the right hand side once the left was shown true
</code></pre>
<h2>WAS</h2>
<p>The WAS word has been reclaimed from a previous purpose, now to assert "lax equality" (or IS-ness) of the left hand side to the right.  But it passes on the value.</p>
<pre><code>&gt;&gt; 10 + 10 was 5 + 15
== 20

&gt;&gt; 10 + 10 was 50 + 1000
** Script Error: assertion failure: [20 is 1050]
** Where: was console
** Near: [... 10 was 30 ~~]
</code></pre>
<h2>MATCHED</h2>
<p>Very similar to WAS, but a variant which uses the logic of <a href="https://forum.rebol.info/t/time-to-meet-your-match-dialect/1009">the MATCH dialect</a>, e.g. to test the datatype.</p>
<pre><code>&gt;&gt; 10 + 10 matched integer!
== 20

&gt;&gt; 10 + 10 matched text!    
** Script Error: assertion failure: [20 matches text!]
** Where: matched console
** Near: [... 10 matched text! ~~]
</code></pre>
<h2>Added Bonus: ASSERT is now invisible</h2>
<p>Cool as these are, you still might want to use the plain old assert for something.  If you do, know that it is now...invisible!  So you can put it anywhere.</p>
<pre><code>&gt;&gt; all [
    x: 1 + 1 
    assert [x &gt; 1]
 ]
 == 2

&gt;&gt; all [
    x: 1 + 1 
    assert [x &lt; 1]
 ]
** Script Error: assertion failure: [
    x &lt; 1 ** false
]
** Where: _ assert all console
** Near: [[x &lt; 1] ~~]</code></pre>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/postfix-assertions-so-was-matched/1046">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/postfix-assertions-so-was-matched/1046</link>
          <pubDate>Thu, 31 Jan 2019 17:55:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1046</guid>
          <source url="https://forum.rebol.info/t/postfix-assertions-so-was-matched/1046.rss">Postfix Assertions: SO, WAS, MATCHED</source>
        </item>
        <item>
          <title>Show the Love for SHOVE (&gt;-)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <h2><code>&gt;-</code></h2>
<p>Despite having a bit tricky to implement, it's very easy to understand.  <strong>It just pushes the argument on its left to be the first argument of the operation on its right:</strong></p>
<pre><code>&gt;&gt; 1 &gt;- add 2 * 3
== 7  ; as if you'd written `add 1 2 * 3`
</code></pre>
<p>Simple, right?  You might think it's not something you would use... <em>but you'd be thinking wrong!</em></p>
<h2>Invoke enfix functions in modules or libraries</h2>
<p>Enfix execution cannot work with paths (<a href="https://forum.rebol.info/t/letting-go-of-enfix-path-dreams-but-fixing-it-with-magic/794">this isn't a bug, it <em>shouldn't</em> work</a>):</p>
<pre><code>r3-alpha&gt;&gt; 1 lib/+ 2 * 3
** Script error: op! type is not allowed here
</code></pre>
<p>But shove has your back:</p>
<pre><code>&gt;&gt; 1 &gt;- lib/+ 2 * 3
== 9  ; as if you'd written `1 + 2 * 3`
</code></pre>
<p><em>(Note the result is different from what you get with add, since + is enfix.)</em></p>
<p><strong>This is only going to get more critical as modules and namespacing move forward.</strong> And anyone who's redefined an operator--but wants to temporarily reach for another implementation--will want this.</p>
<h2>Invoke refinements on enfix executions</h2>
<p>Historically there aren't really refinements on infix functions, because you'd never be able to use them.  Now you can:</p>
<pre><code>&gt;&gt; ++: enfixed func [a b /double] [a + either double [2 * b] [b]]

&gt;&gt; 10 ++ 20
== 30

&gt;&gt; 10 &gt;- ++/double 20
== 50
</code></pre>
<p>In the common case, you hope that your operator doesn't need refinements.  But when a special case comes up, it's nice to not have to define a prefix form just for that one instance. (which means coming up with a new name that people need to know also).  Now you can take for granted that shove is there when you need it.</p>
<h2>Symbol-y, but not symbol soup: it communicates!</h2>
<p>Being an "arrow word" is crucial to showing its disruption of the evaluation order.  That's not going to be conveyed by a short alphabetic name:</p>
<pre><code>&gt;&gt; 1 shove lib/+ 2 * 3   ; lame and wordy
== 9
</code></pre>
<p>Invoking enfix functions from modules/namespaces and using refinements with them is <em>fundamental behavior</em>.  So it needs to be very short and light.  You want people to take this thing for granted!</p>
<h2>Extra credit: tweak the argument precedence</h2>
<p>Rebol is well known for having a difference in interpretation when you use an infix operator vs. not:</p>
<pre><code>&gt;&gt; add 1 2 * 3
== 7

&gt;&gt; 1 + 2 * 3
== 9
</code></pre>
<p><em>(If you don't know why that is--and wonder why such a "quirk" hasn't been changed despite a lot of thought--<a href="https://forum.rebol.info/t/the-beta-one-enfix-covenant/1023">you can read more than you ever wanted to about it</a>)</em>.</p>
<p>Above I showed that shove takes its cue on how to act based on the enfixedness of what you're shoving into:</p>
<pre><code>&gt;&gt; 1 &gt;- lib/add 2 * 3
== 7  ; as if you'd said `add 1 2 * 3`

&gt;&gt; 1 &gt;- lib/+ 2 * 3
== 9  ; as if you'd said `1 + 2 * 3`
</code></pre>
<p><strong>But it might be argued that since <code>&gt;-</code> is enfix, the overall operation is always enfix, which intuitively would suggest both of the above should be 9.</strong></p>
<p>It's tough to say.  But I liked the simple definition of <em>"shove uses the value on the left as the first argument"</em>.  Imagine what the "as if you'd said" would have to be if the shove into ADD above gave 9, if you couldn't take for granted another known another name for the operation (like <code>+</code>):</p>
<pre><code>&gt;&gt; 1 &gt;- lib/add 2 * 3  ; let's say it's the hypothetical enfix-always version
== 9  ; as if you'd said `temp: enfixed :add | 1 temp 2 * 3`
</code></pre>
<p>But for sake of completeness...I introduced "force enfix behavior (<strong>-&gt;-</strong>)" and  "force prefix behavior (<strong>&gt;--</strong>)" forms:</p>
<pre><code>&gt;&gt; 1 -&gt;- lib/add 2 * 3
== 9  ; as if you'd said `1 + 2 * 3`

&gt;&gt; 1 &gt;-- lib/+ 2 * 3
== 7  ; as if you'd said `add 1 2 * 3`
</code></pre>
<p>I think it's cute that <strong><code>-&gt;-</code></strong> looks like a picture of args on the left and right of an operator, suggesting infix... while <strong><code>&gt;--</code></strong> looks like no args on the left with two args on the right!</p>
<p>But you could also just use parentheses:</p>
<pre><code>&gt;&gt; (1 &gt;- lib/add 2) * 3
== 9

&gt;&gt; 1 &gt;- lib/+ (2 * 3)
== 7
</code></pre>
<p>So whether <code>-&gt;-</code> and <code>&gt;--</code> survive or not is an open question.  If anyone actually uses them, I'd be interested to know.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/show-the-love-for-shove/1039">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/show-the-love-for-shove/1039</link>
          <pubDate>Mon, 28 Jan 2019 01:32:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1039</guid>
          <source url="https://forum.rebol.info/t/show-the-love-for-shove/1039.rss">Show the Love for SHOVE (&gt;-)</source>
        </item>
        <item>
          <title>Easier Generalized Quoting: &lt;dequote&gt; and &lt;requote&gt;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>There are primitives for generalized quoting:</p>
<ul>
<li>
<strong>quoted?</strong> is the test, which is actually a datatype test (the type is QUOTED!)</li>
<li>
<strong>quotes of x</strong> counts the number of quote levels</li>
<li>
<strong>unquote x</strong> removes one quote level, <strong>unquote/depth x count</strong> removes more</li>
<li>
<strong>quote x</strong> will eventually add quote levels, along with <strong>quote/depth</strong>
</li>
</ul>
<p><em>(For today, QUOTE is called UNEVAL.  This makes it easier to find places where you've forgotten to switch over to LITERAL or LIT for the old meaning of QUOTE.  The weird name actually is what was around to do something similar before generalized quoting... it made a GROUP! with a quote in it, so each step of eval of that group would just remove one level of evaluation.)</em></p>
<p>So you've got everything you need to work with them.  But there are some common scenarios of dealing with them that we can help with.</p>
<p>For instance, sometimes you want to basically see past the quoting level of something and operate on its basic type, then return that thing quoted back to the level you had it.  Imagine this:</p>
<pre><code>increment: function [
    return: [&lt;opt&gt; integer!]
    x [quoted! integer!]
][
    num-quotes: quotes of x
    x: dequote x
    if not integer? x [
        fail "Invalid type"
    ]
    if x &gt; 304 [return null]
    return quote/depth (x + 1) num-quotes
]
</code></pre>
<p>So this way you get:</p>
<pre><code> &gt;&gt; increment lit '''303
 '''304

 &gt;&gt; increment lit '''1020
 ; null
</code></pre>
<p>It's cool that you <em>can</em> do that, but it's a bit irritating to write. And it's a pattern that happens often.</p>
<p>So here's a tool for helping with that:</p>
<pre><code>foo: function [
    return: [&lt;opt&gt; &lt;requote&gt; integer!]
    x [&lt;dequote&gt; integer!]
][
    if x &gt; 304 [return null]
    return x + 1
]
</code></pre>
<p>It has the same behavior, but everything is handled for you automatically, including the type checking.  As you can see it doesn't put quote levels back on a null...it assumes null doesn't have the requote rule apply.  The exception would be if your input was a quoted null, in which case it would think you meant to support that.</p>
<p>You don't have to use <code>&lt;requote&gt;</code>, you can just dequote a parameter and not add it back in to the result.  If you have <code>&lt;dequote&gt;</code> on more than one argument, then the requote will have the sum of the quotes taken off for all arguments.  That's a weird heuristic that probably won't come in useful too often, but if it's not what you want you'll have to take a QUOTED! and do your own magic.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/easier-generalized-quoting-dequote-and-requote/1035">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/easier-generalized-quoting-dequote-and-requote/1035</link>
          <pubDate>Sat, 26 Jan 2019 00:25:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1035</guid>
          <source url="https://forum.rebol.info/t/easier-generalized-quoting-dequote-and-requote/1035.rss">Easier Generalized Quoting: &lt;dequote&gt; and &lt;requote&gt;</source>
        </item>
        <item>
          <title>You can has GET-BLOCK! (SET-BLOCK!, GET-GROUP!, SET-GROUP!)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p><a href="https://github.com/metaeducation/ren-c/commit/f25087c0bbfbcef7fc6f71cb53fe69b16527b1d7" rel="nofollow noopener"><strong>Yep, they're implemented!!!</strong></a>  Go try them out!!!</p>
<hr>
<p>Years ago, discussions circled around what was so special about WORD! and PATH! that they should be the only ones with LIT-XXX! forms.  It seemed this was a bit that could equally apply to anything, e.g. <strong><code>group: '(1 + 2)</code></strong>.</p>
<p>It took a while, but eventually a <a href="https://forum.rebol.info/t/quoted-arrives-formerly-known-as-lit-bit/995/2">general and clever solution was discovered</a>.  There's no LIT-XXX!, just QUOTED! as a container for any type...with any level of quoting.  It's done with neat tricks!</p>
<h2>...but what about SET-XXX and GET-XXX?</h2>
<p>In that same vein, we might ask why PATH! and WORD! are the only types with SET-XXX! and GET-XXX! forms.  Aren't those just bits too?</p>
<p>GET-BLOCK! seems very useful if it would do a REDUCE in the evaluator.  Instead of <strong>return reduce [x y]</strong> you could just say <strong>return :[x y]</strong>.  SET-GROUP seems like it might be a little tidier too...</p>
<pre><code>word: 'x
set word 1020

word: 'x
(word): 1020
</code></pre>
<p>It's only one less <em>character</em>.  But whether you have a preference for one or the other visually, the second can be done faster; the evaluator doesn't have to look up SET to find the function, nor go through the trouble of filling function frames and dispatching.  It's much lighter-weight.</p>
<h2>Yet it seems a slippery slope...</h2>
<p>GET-BLOCK! and SET-GROUP! sure seem useful, but if we look at this as more cases of the "lit bit", where does it stop?</p>
<p>If every type has a "get bit" and a "set bit", can you have both of them?  How does this mix with the LIT-XXX forms?  Is there a difference between a LIT-SET-PATH! and a SET-LIT-PATH?</p>
<p>What would a SET-URL! look like?  How are the colons mixing up with literals that have colons in them?  <em>(:15 is a TIME! in the current world..., that would become a GET-INTEGER!, so what does a GET-TIME! look like?)</em></p>
<p>This foiled ideas of the past, like trying to get rid of SET-PATH! and GET-PATH! and just say, e.g. "a SET-PATH! is one with a SET-WORD! in its last slot".  Because then to get <strong>x/1:</strong> you would need SET-INTEGER!, to get <strong>x/(y + z):</strong> you'd need SET-GROUP!, and it just seemed to go to chaos.</p>
<p>In the absence of a clear plan, we plodded along with the status quo, awaiting some moment of clarity.</p>
<h2>Moment of clarity arrived: Just add BLOCK! and GROUP!</h2>
<p>If we only allow SET and GET forms on containers, it's a clean model (no worries about intersecting with lexical rules of the contained types).  And you get your dialected parts.  Need a SET-INTEGER! ?  Well, you <a href="https://knowyourmeme.com/memes/sites/cheezburger" rel="nofollow noopener">no can has</a>.  But with containers, you get it all:</p>
<pre><code> my-dialect [
     [1]: "It's just as good, as `1:`, really!"

     :(:15) "Even better, as if you want GET-FIFTEEN-MINUTES!, you can have it..."

     [http://example.com/colons-legal-in-url:]: "Yup, colons are legal in URL!s"

     (your multi-value expression here): "goes great with expressions!"
 ]
</code></pre>
<p><em>Then we stop.</em>  We get 4 new parts that are genuinely useful, that make the evaluator more expressive and run common functionality faster.  If you find uses in your dialects--and you almost certainly will--so much the better.</p>
<h2>The commit for them fixes flaws in the scanner</h2>
<p>There were some things you couldn't make.  In Rebol2/R3-Alpha/Red:</p>
<pre><code>rebol2&gt;&gt; first [:a/(b + c)]                       
== a/(b + c):

rebol2&gt;&gt; first [:(a + b)/c]
** Syntax error: invalid "word-get" -- ":"
</code></pre>
<p>It might seem like it wouldn't be that hard to fix, but fixing it is a lot easier if you can just pass through a moment where the head of that block is a GET-GROUP! and then twiddle it into a regular GROUP! later.  (That's how GET-PATH! works when it has a GET-WORD!-looking thing at the head).  The scanner is already rather fiddly and throwing in more fiddly-bits is not forward-looking.</p>
<p>This lets that work basically for free, just a minor tweak on the previous method:</p>
<pre><code>&gt;&gt; first [:(a + b)/c]
== :(a + b)/c

&gt;&gt; type of p: first [:(a + b)/c]
== get-path!

type of first p
== group!  ;-- regular GROUP! as first element of GET-PATH!, perfect
</code></pre>
<h2>They're awesome, you'll love 'em</h2>
<p>Try them out and let me know what you think, and if you find cool new dialect applications!  Some demos:</p>
<pre><code>; GET-BLOCK!, doing a fast REDUCE
&gt;&gt; a: 10
&gt;&gt; b: 20
&gt;&gt; :[a b]
== [10 20]

; GET-GROUP!, getting a PATH!
&gt;&gt; o: make object! [f: 304]
&gt;&gt; path: 'o/f
&gt;&gt; :(path)
== 304

; SET-GROUP!, setting a BLOCK!
&gt;&gt; m: &lt;before&gt;
&gt;&gt; o: make object! [f: &lt;before&gt;]
&gt;&gt; block: [m o/f]
&gt;&gt; (block): [1020 304]
&gt;&gt; block
== [m o/f]
&gt;&gt; m
== 1020
&gt;&gt; o/f
== 304

; SET-BLOCK!, with a block on the right
&gt;&gt; a: _ b: _
&gt;&gt; [a b]: [10 20]
&gt;&gt; a
== 10
&gt;&gt; b
== 20

; SET-BLOCK! with a non-block on the right
&gt;&gt; a: _
&gt;&gt; b: _
&gt;&gt; [a b]: &lt;thing&gt;
&gt;&gt; a
== &lt;thing&gt;
&gt;&gt; b
== &lt;thing&gt;
</code></pre>
<p>I'm sure people will think of improvements, but that's for starters.</p>
<p>And note they'll get even better with <a href="https://forum.rebol.info/t/mirrored-type-bytes-explained/1008">mirror bytes</a>, where <strong>(x):</strong> won't cost any more than <strong>x:</strong> !!!  I'm relatively confident I can make that happen, some groundwork is done already.</p>
            <p><small>7 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/you-can-has-get-block-set-block-get-group-set-group/1032">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/you-can-has-get-block-set-block-get-group-set-group/1032</link>
          <pubDate>Thu, 24 Jan 2019 03:36:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1032</guid>
          <source url="https://forum.rebol.info/t/you-can-has-get-block-set-block-get-group-set-group/1032.rss">You can has GET-BLOCK! (SET-BLOCK!, GET-GROUP!, SET-GROUP!)</source>
        </item>
        <item>
          <title>Soft Quoted Branching: Light, Elegant, Fast</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>It's uncommon to use expressions that evaluate to branches passed to conditionals.  And when you do use one, you probably don't mind putting it in a GROUP! (especially considering that 99% of the time in the <em>far</em> more common cases you were willing to put it in a BLOCK!).</p>
<p>So Ren-C now uses that fact--plus generalized quoting--to allow for a briefer and faster way to evaluate to literals in your conditionals:</p>
<pre><code>&gt;&gt; if true '[block as data]
== [block as data]
</code></pre>
<p>Simply pass in a QUOTED! item of any kind, and that item will be what a branch evaluates to.  It will be one less level of quoting than what you pass in:</p>
<pre><code>&gt;&gt; if true '&lt;tag&gt;
== &lt;tag&gt;
</code></pre>
<p>Previous attempts to get something like this used an /ONLY refinement.  But this lets you mix and match in the same operator, as opposed to switching the operator into a "mode":</p>
<pre><code>&gt;&gt; either true '[1 + 2] [1 + 2]
== [1 + 2]

&gt;&gt; either false '[1 + 2] [1 + 2]
== 3
</code></pre>
<h2>It Solves Some Problems for CASE</h2>
<p>Historically, CASE was more lax in accepting types than the corresponding IFs would be:</p>
<pre><code>&gt;&gt; case [1 = 1 &lt;foo&gt;]
== &lt;foo&gt;
</code></pre>
<p>It would allow the by-products of arbitrary evaluation to be used:</p>
<pre><code>&gt;&gt; word: &lt;foo&gt;
&gt;&gt; case [1 = 1 word]
== &lt;foo&gt;
</code></pre>
<p>Sometimes this resulted in double-evaluation:</p>
<pre><code>&gt;&gt; word: [print "surprise"]
&gt;&gt; case [1 = 1 word]
surprise
== true
</code></pre>
<p>The dodgy nature of this "may be a double evaluation, may be not" with no way to tell at source level raised some concerns, which are laid out in the <a href="https://forum.rebol.info/t/backpedaling-on-non-block-branches/476">"backpedaling on non-block branches"</a> post.</p>
<p>The combination of soft quoting and generalized quoting lets the same patterns that work for IF work in CASE.  It lowers the risks in a legible way:</p>
<pre><code>&gt;&gt; case [1 = 1 '&lt;foo&gt;]
== &lt;foo&gt;
</code></pre>
<h2>It's Faster and More Efficient</h2>
<p>Quoting is done with a byte in cells.  So you can count up to 254 levels of quoting without really costing anything.  <em>(If you're wondering why not 255 levels since a byte can be from 0..255, it's because 255 is reserved for "isotopes".)</em></p>
<p>So <strong>'[x]</strong> costs less storage (and has better locality with the surrounding cells) than <strong>[[x]]</strong>.</p>
<p>Outside of the reduced storage, it's also lighter on the evaluator, because it doesn't have to push an evaluator frame to run the block!</p>
<h2>The consequences</h2>
<p>There were very few pieces of code in the Ren-C repo that were affected.  One was a help test.  It wanted to generate a real-world block to run, and didn't want to call DO for some reason:</p>
<pre><code>for-each w words of lib [
    dump w
    if not set? w [continue]
    if action? get w
        compose [help (w)]   ; errors now...IF thinks the COMPOSE word! is branch
    else [
        help (get w)
    ]
]
</code></pre>
<p>It's easy enough to change that to <code>(compose [help (w)])</code>...this kind of usage is very rare.</p>
<p>The one common case of passing code to a conditional originated from Ren-C...the use of lambdas that could take the argument of what drove the conditional:</p>
<pre><code> trap [1 / 0] then error -&gt; [print [error]]
</code></pre>
<p>So you have to put it in a GROUP!:</p>
<pre><code> trap [1 / 0] then (error -&gt; [print [error]])
</code></pre>
<p>I'm pretty sure this can be rethought to work as before, given the strategy of "right quoting always wins".  But the evaluator has some kind of strict horse-blinder rules that guide its design, so not all things are possible.  We'll see.</p>
<blockquote>
<p><strong>UPDATE 2020</strong>: The required rules have been implemented, and hard quoted left parameters on the right win in this instance, so the group is not necessary.  <img src="https://forum.rebol.info/images/emoji/twitter/sushi.png?v=9" title=":sushi:" class="emoji" alt=":sushi:"></p>
</blockquote>
<p>Even if it couldn't get fixed, in the scheme of things it's worth it.  And it isn't like people aren't used to putting branches in delimiters for blocks anyway!</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/soft-quoted-branching-light-elegant-fast/1020">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/soft-quoted-branching-light-elegant-fast/1020</link>
          <pubDate>Fri, 18 Jan 2019 12:56:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1020</guid>
          <source url="https://forum.rebol.info/t/soft-quoted-branching-light-elegant-fast/1020.rss">Soft Quoted Branching: Light, Elegant, Fast</source>
        </item>
        <item>
          <title>&lt;skip&gt;-able Arguments</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>A <strong><code>&lt;skip&gt;</code></strong> parameter is one where instead of getting a type error on a mismatch, it will set the parameter to null:</p>
<pre><code> foo: function [a :b [&lt;skip&gt; tag!] c] [
     dump [a b c]
 ]

 &gt;&gt; foo 1 2
 a: 1
 b: ; null
 c: 2

 &gt;&gt; foo 1 &lt;hello&gt; 2
 a: 1
 b: &lt;hello&gt;
 c: 2
</code></pre>
<p>You can only skip a "hard quoted" parameter.  To understand why, imagine a having an evaluative skippable parameter followed by a quoted argument.  If you evaluate the first argument--see it doesn't match the type--you can't really rewind time to then switch into a quoting mode for the second argument on the thing you already evaluated.  It would be incoherent.</p>
<p>Beyond the technical reason you don't want <code>&lt;skip&gt;</code> on evaluated parameters, it also makes it clearer to the user.  For instance, consider <a href="https://forum.rebol.info/t/tag-compose-is-it-tag-specific-composition/979/7">tagged compose</a>:</p>
<pre><code>&gt;&gt; compose &lt;*&gt; [(1 + 2) (&lt;*&gt; 1 + 2) (1 + 2)]
== [(1 + 2) 3 (1 + 2)]
</code></pre>
<p>You can tell at the source level that's tagged.  But what if it said:</p>
<pre><code>&gt;&gt; compose foo [(1 + 2) (&lt;*&gt; 1 + 2) (1 + 2)]
== ???
</code></pre>
<p>Does this mean that sometimes the block is taken by the compose and sometimes it's not?  What if FOO is a block?  The "shape" of the code changes, and that seems bad.</p>
<p>So it's for quoted arguments only...and that's probably for the best.</p>
<h2>It's used by DEFAULT</h2>
<p>The use in tagged compose is pretty obvious.  But a trickier usage is DEFAULT, which quotes a SET-WORD! or SET-PATH! on its left to assign to it:</p>
<pre><code> &gt;&gt; x: null

 &gt;&gt; x: default [print "running" 1 + 2]
 running
 == 3  ; didn't have a value, so ran the body and assigned

 &gt;&gt; x: default [print "not run!" 10 + 20]
 == 3  ; already had a value, don't run the block and leave alone
</code></pre>
<p>The trick skippability brings to the table is that if there is no SET-WORD! or SET-PATH!, then it just runs the block.  This makes it a nice tool in evaluative switch/case:</p>
<pre><code> &gt;&gt; case [
     1 &gt; 2 [print "nope" 10]
     default [print "yep!" 20]
 ]
 yep
 == 20
</code></pre>
<p>CASE and SWITCH are written to just let the last value fall out of them.</p>
<pre><code> &gt;&gt; switch "not a number" [
      1 + 2 [...]
      3 + 4 [...]
      5 + 6
 ]
 == 11
</code></pre>
<p>So all DEFAULT does is fall back to acting like DO when it can't find a SET-WORD! or SET-PATH! to its left.</p>
<pre><code> &gt;&gt; switch "not a number" [
      1 + 2 [...]
      3 + 4 [...]
      default [5 + 6]
 ]
 == 11
</code></pre>
<p>It comes off as quite readable.  <em>(Though if you are lazy, or code golfing, you can just omit it...maybe some people will like that better.)</em></p>
<h2>The implementation is now solid, so this feature is sticking around</h2>
<p>The initial implementation was a bit creaky, especially when it came to skipping left hand side arguments.  I was worried it might not be able to work efficiently--or maybe it wasn't able to work in a general way at all!</p>
<p>But things have firmed up very well.  Impressively enough, this works:</p>
<pre><code>&gt;&gt; foo: function [/a :/b [&lt;skip&gt; integer!]] [
    reduce [(a else [&lt;null&gt;]) (b else [&lt;null&gt;])]
]

&gt;&gt; foob: enfix :foo/b

&gt;&gt; parameters of :foob
== [:b /a]

&gt;&gt; 10 foob
== [&lt;null&gt; 10]

&gt;&gt; "not an integer!" foob
== [&lt;null&gt; &lt;null&gt;]

&gt;&gt; 10 -&gt; foob/a 20
== [20 10]  ; (note: broken at last check, looking into it)
</code></pre>
<p>And we can discuss what <code>("not an integer!" -&gt; foob/a 20)</code> should do, <a href="https://github.com/metaeducation/ren-c/issues/909" rel="nofollow noopener">if that should be an error or not</a>.</p>
<p>Anyway, FYI, that's a pretty wild case.  If it can do that, it can probably work for whatever you want it to do.  So start thinking of creative uses of <code>&lt;skip&gt;</code> in your own code...and if you do, post it in the thread here!</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/skip-able-arguments/1013">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/skip-able-arguments/1013</link>
          <pubDate>Mon, 14 Jan 2019 05:34:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1013</guid>
          <source url="https://forum.rebol.info/t/skip-able-arguments/1013.rss">&lt;skip&gt;-able Arguments</source>
        </item>
        <item>
          <title>Time to Meet Your MATCH... (...dialect)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p><strong>MATCH</strong> is a handy tool for testing a value against some basic rules, and passing it through if they match...or evaluating to null if they don't.  The rules can be combined in some interesting ways that make them rather powerful!</p>
<p>It uses the <em>"match dialect"</em>.  This looks pretty simple on the surface, like what you put in a function spec block for the legal types:</p>
<pre><code>&gt;&gt; match [integer! tag!] 1020
== 1020

&gt;&gt; match [integer! tag!] "this text value won't match"
;-- null

&gt;&gt; match [integer! tag!] &lt;matches!&gt;
== &lt;matches!&gt;
</code></pre>
<p>But with the new features of generalized quoting, now you can test for quotedness.</p>
<pre><code>&gt;&gt; match ['word!] first [foo]
;-- null

&gt;&gt; match ['word!] first ['foo]
== 'foo
</code></pre>
<p>It actually dereferences what you give it and sums up the quote levels.  So you can do things like:</p>
<pre><code> &gt;&gt; quoted-word!: quote word! ;-- Note: during transition, QUOTE is called UNEVAL

 &gt;&gt; match 'quoted-word! first [''foo]
 == ''foo
</code></pre>
<p>So since there is a quote level in the QUOTED-WORD! value, that gets added in with the quote on the match, so it looks for a doubly quoted value.</p>
<p>The premise is that each MATCH rule component is one item, and even types like INTEGER! are used...to test a length:</p>
<pre><code> &gt;&gt; match 2 [a b]
 == [a b]

 &gt;&gt; match 2 [a b c]
 ;-- null
</code></pre>
<p>You can use single arity ACTION!s as well, if you use a GET-WORD! or GET-PATH! to indicate them:</p>
<pre><code> &gt;&gt; match :odd? 304
 ;-- null

 &gt;&gt; match :lib/even? 1020
 == 1020
</code></pre>
<h2>BLOCK! will OR rules together, PATH! will AND them</h2>
<p>So this is a cool little trick:</p>
<pre><code>&gt;&gt; match block!/2 [a b]
== [a b]

&gt;&gt; match text!/2 [a b]
;-- null

&gt;&gt; match text!/2 "ab"
== "ab"

&gt;&gt; match [block! text!]/2 "ab"
== "ab"

&gt;&gt; match '''[block! text!]/2 lit '''[a b]
== '''[a b]

&gt;&gt; match [integer!/[:even?] block!/[:empty?]] []
== []

&gt;&gt; match [integer!/[:even?] block!/[:empty?]] 1020
== 1020
</code></pre>
<p>Pretty cool huh?  And as I mentioned, you can factor these rules out like in PARSE... note also that instead of :empty? you can just use 0.</p>
<pre><code> &gt;&gt; even-int!: lit integer!/[:even?]
 &gt;&gt; empty-block!: lit block!/0

 &gt;&gt; match [even-int! empty-block!] []
 == []

 &gt;&gt; match [even-int! empty-block!] [a b]
 ;-- null 
</code></pre>
<h2>MATCH has an automatic erroring form, called ENSURE</h2>
<p>If you want a quick and dirty way to typecheck something and pass it through, but error otherwise, use ENSURE.</p>
<pre><code>&gt;&gt; ensure [even-int! empty-block!] [a b]
** Script Error: ...

&gt;&gt; ensure [even-int! empty-block!] 1020
== 1020
</code></pre>
<h2>MATCH is now built in as a PARSE keyword...</h2>
<p>The quoting features of MATCH were important for PARSE to help pick up the slack after LIT-WORD!.</p>
<pre><code>&gt;&gt; did parse ['a b 'c d] [some [match [word! 'word!]] end]
== #[true]
</code></pre>
<p>There was a little bit of a incongruity previously, which is that MATCH did not want to quote its first argument.  So you couldn't say <strong>match 'word! lit ['foo]</strong> and have it match, because the evaluator would strip off the quote.  When all things were considered, it seemed to make more sense to have MATCH soft-quote its first argument, so it doesn't throw away the quote marks...but uses them in the rule.</p>
<p>PARSE then has a compatible expression, without a block! needed:</p>
<pre><code>&gt;&gt; did parse ['a 'b 'c 'd] [some [match 'word!] end]
== #[true]
</code></pre>
<h2>
<code>&lt;opt&gt;</code>, falsey values, and /ELSE</h2>
<p>You might imagine a lot of code wants to say <strong>if match [...] whatever [...]</strong>.  This could lead to unsatisfactory results if the thing you're matching is a null, blank, or logic false -- even though you matched, the falsey nature of the thing you were testing would foil your intent.</p>
<p>To help catch those errors, any falsey input that matches will be voidified.  So at least you'll get a clear error if you used the result.  But since voids are values, you'll be okay if you use THEN or ELSE</p>
<pre><code>&gt;&gt; match [&lt;opt&gt; integer!] null then [print "matched, and void cued then!"]
matched, and void cued then!
</code></pre>
<p>There's also an /ELSE refinement, so you can provide a branch of code to run if there's no match...and it won't mutate the result at all:</p>
<pre><code>&gt;&gt; match/else [&lt;opt&gt; integer!] null [print "didn't match" 100]
;-- null

&gt;&gt; match/else [&lt;opt&gt; integer!] #foo [print "didn't match" 100]
didn't match
== 100
</code></pre>
<h2>Useful Dialect, Good Testbed for PATH!s</h2>
<p>You can see a detail above of how I want to use things like <strong>:even?</strong> as a test, and then use PATH! for AND-ing tests together generically.  But then, <strong>:even?/integer!</strong> is a GET-PATH!, while <strong>integer!/:even?</strong> would be an ordinary path.  The meaning gets confuzzled... how would you specify a function with refinements, or otherwise get something out of a path?</p>
<pre><code>obj: make object! [even-int: lit integer!/[:even?]]
match :obj/even-int 4
</code></pre>
<p>To get this distinction, we have to treat <strong>:[:obj]/even-int</strong> differently from <strong>:obj/even-int</strong>.  And this really does suggest to me that the notion of allowing GET-WORD!s, SET-WORD!s, and LIT-WORD!s in PATH! is a mistake...it doesn't generalize and will fall down at the head and tail.  Even when it works, it's ugly.</p>
<p>I think this is going in the direction of making PATH! a stronger dialecting part.  And hopefully, with more good examples we can keep pushing on some of the other things (like "does Rebol need a date format with slashes in it, and if so can it be accomplished naturally as a PATH!")...</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/time-to-meet-your-match-dialect/1009">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/time-to-meet-your-match-dialect/1009</link>
          <pubDate>Fri, 11 Jan 2019 08:59:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1009</guid>
          <source url="https://forum.rebol.info/t/time-to-meet-your-match-dialect/1009.rss">Time to Meet Your MATCH... (...dialect)</source>
        </item>
        <item>
          <title>QUOTED! arrives (formerly known as &quot;lit bit&quot;)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>I'm pleased to say that the day has come that you can use apostrophe to escape any value...not just WORD! and PATH!.  And since I said <em>any</em> value, that means you can also quote <em>quoted values</em>...as deeply as you like!</p>
<pre><code>&gt;&gt; '(1 + 2)
== (1 + 2)

&gt;&gt; ''(1 + 2)
== '(1 + 2)

&gt;&gt; quoted? first [''{double quoted text!}]
== #[true]

&gt;&gt; quotes of first ['''''''''''''''''&lt;whoa!&gt;]
== 17
</code></pre>
<p>It opens up a whole new box of parts for dialecting, and makes your every day code shorter and clearer (when used properly).  <em>But don't be fooled by the fact that you can use a stupid number of quotes if you need:</em> <strong>This isn't a frivolous thing, and being able to truly escape any value--hence including any quoted value--is integral to the feature.</strong></p>
<p>If you are a heavy user of COMPOSE-ing code and then DO-ing it, you would be more likely to appreciate the efficiency and literacy of:</p>
<pre><code> do compose [... some-var: '(foo) ...]
</code></pre>
<p>But what you realize if you program at the API level (like C or JavaScript) is that <em>every execution acts like "a do of a COMPOSE".</em>  Since API representations of values spliced in from non-Rebol code are not fetched through a WORD!, libRebol users wind up putting "QUOTE" (now THE) calls <em>everywhere</em>--slowing things down, junking it up, and fundamentally changing the types and shape of what you're working with.  If you write sophisticated enough Rebol routines you've almost certainly run up against this problem too--but it's an issue on nearly <em>every</em> call into the API.</p>
<p>The quoting implementation is optimized to the point of being nearly free for depths less than 4, using something I call <em>"in-situ escaping"</em>.  Because of how I've made the C++ build check it at compile time, it significantly reduces the risks of such a tricky performance hack.  Another very neat design point allows these new "QUOTED!s" to efficiently participate in binding...if their "contained" item is bindable.</p>
<h2>
<a name="be-warned-this-is-a-radical-change-1" class="anchor" href="https://forum.rebol.info#be-warned-this-is-a-radical-change-1"></a>Be warned, this is a radical change!</h2>
<p>I'm sure you'll love it when all is said and done.  But it changes the typeclass membership of LIT-WORD! and LIT-PATH!.  They are no longer ANY-WORD! or ANY-PATH!, but instances of a new fully generalized quoted type.  This will cause some speedbumps.</p>
<p>Since you could do things like GET on a LIT-WORD!, or APPEND to a LIT-PATH!, I've tried to set up some mechanisms for the cases I thought of.  I even threw in some new weirder ones, like letting you add directly to a quoted integer and get a quoted integer at the same level back:</p>
<pre><code> &gt;&gt; add the '''''1 2
 == '''''3
</code></pre>
<p>I didn't see a good general rule for this.  It seems FIND on a quoted BLOCK! should return a position in the quoted block that is still quoted.  But SELECTing or PICKing a value out of the block should ignore the container's quoting.  It just seems like it has to be done on a case-by-case basis, for the semantics that make sense for the operation.</p>
<h2>
<a name="basic-mechanics-2" class="anchor" href="https://forum.rebol.info#basic-mechanics-2"></a>Basic Mechanics</h2>
<p>To get the number of quote levels, use QUOTES OF.  To get rid of any quoting present on any value, use NOQUOTE.</p>
<pre><code>&gt;&gt; quotes of first ['''{triply quoted string}]
== 3

&gt;&gt; noquote first ['''&lt;some-tag&gt;]
== &lt;some-tag&gt;
</code></pre>
<p>All that happens with multiply quoted types is that each time the evaluator sees it, it will peel off one quote level:</p>
<pre><code> &gt;&gt; ''(1 + 2)
 == '(1 + 2)

 &gt;&gt; '(1 + 2)
 == (1 + 2)

 &gt;&gt; (1 + 2)
 == 3
</code></pre>
<p>This means inert types which are singly quoted get evaluated and lose the distinction from the plain inert type.  So if you have a function that takes an evaluated argument (e.g. foo: func [x] [...]) you can't provide special behavior for <strong><code>foo '[block]</code></strong> that is different from <strong><code>foo [block]</code></strong>.  The only way a called function will see the bit is if it quotes the argument, or if it's inside a dialect block (like a PARSE rule).</p>
<p>You can, however, get special behavior for <strong><code>foo ''[block]</code></strong>, as it will receive a singly quoted block as an argument.  And of course, it's now more practical to escape GROUP!s, so it might be worth it to start defining distinct behavior when groups are used since they'll be so easy to pass!  (I have some ideas about this.)</p>
<h3>
<a name="name-switcheroo-quote-the-3" class="anchor" href="https://forum.rebol.info#name-switcheroo-quote-the-3"></a>Name Switcheroo: QUOTE =&gt; THE</h3>
<p>QUOTE now adds a quoting level to whatever it gets as an argument, with that argument being evaluated normally:</p>
<pre><code> &gt;&gt; x: 1
 == 1

 &gt;&gt; quote x
 == '1

 &gt;&gt; the x
 == x
</code></pre>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/quoted-arrives-formerly-known-as-lit-bit/995">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/quoted-arrives-formerly-known-as-lit-bit/995</link>
          <pubDate>Fri, 04 Jan 2019 08:23:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-995</guid>
          <source url="https://forum.rebol.info/t/quoted-arrives-formerly-known-as-lit-bit/995.rss">QUOTED! arrives (formerly known as &quot;lit bit&quot;)</source>
        </item>
        <item>
          <title>The Superpowers of Ren-C&#39;s Revamped COMPOSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>COMPOSE is one of Rebol's most useful and recognizable constructs.  As with most-things-Ren-C, it has evolved to become far more powerful.</p>
<h2>
<a name="no-splicing-by-default-group-isotopes-request-splicing-1" class="anchor" href="https://forum.rebol.info#no-splicing-by-default-group-isotopes-request-splicing-1"></a>No Splicing By Default, GROUP! Isotopes Request Splicing</h2>
<p>One of the immediately noticeable differences is that there is no /ONLY option any longer.  A plain BLOCK! will not splice its evaluative result.  So if <strong>block: [a b c]</strong>, it is different from historical Redbol:</p>
<pre><code>rebol2/r3-alpha/red&gt;&gt; compose [value: (block)]
== [value: a b c]

ren-c&gt;&gt; compose [value: (block)]
== [value: [a b c]]
</code></pre>
<p>If you want to have something splice, you do this with GROUP! isotopes.  For instance, SPREAD produces them:</p>
<pre><code>ren-c&gt;&gt; compose [value: (block), (spread block)]
== [value: [a b c], a b c]
</code></pre>
<ul>
<li>
<p>You can mix and match splicing parts and non-splicing parts in the same COMPOSE!</p>
</li>
<li>
<p>It gets rid of an instance of /ONLY, which has always been something that causes head-scratching to new users ("only what?")</p>
</li>
</ul>
<p><strong>I am convinced that practice has shown that not splicing is a safer and more intuitive default.</strong>  You're so often dealing with composing several values at a time that the odds of you knowing precisely what data type all of them are become lesser.  There's no question this is the better behavior for people who are writing and reading the code.</p>
<h2>
<a name="the-slots-will-vaporize-voids-2" class="anchor" href="https://forum.rebol.info#the-slots-will-vaporize-voids-2"></a>The (...) Slots will Vaporize Voids!</h2>
<p>In my list of <a href="https://forum.rebol.info/t/the-canonical-list-of-non-negotiables/1244">"non-negotiables"</a>, I've always said this <em>had</em> to be true, somehow:</p>
<pre><code>&gt;&gt; compose [&lt;a&gt; (if false [&lt;b&gt;]) &lt;c&gt;]
== [&lt;a&gt; &lt;c&gt;]
</code></pre>
<p>For quite some time, a conditional like IF that didn't run its branch would return NULL.  Because NULL couldn't be put in a block, it <em>seemed</em> like it was a good fit for signaling vaporization of a clause in a COMPOSE.  But I was nervous because as NULL came to mean "soft failure", this felt like you could be sweeping a failure under the rug.</p>
<p>But with isotopes, we got a menagerie of states that couldn't be put in blocks (and VOID, with its own antiform).  So when un-taken IF provides another choice of VOID vs. NULL, it provided the best of both worlds, where NULL can give a <em>specific</em> error tied to null splicing.</p>
<pre><code>&gt;&gt; compose [&lt;a&gt; (select [a 10 b 20] 'c) &lt;c&gt;]
** Script Error: non-NULL value required (see MAYBE, TRY, REIFY)

&gt;&gt; compose [&lt;a&gt; (maybe select [a 10 b 20] 'c) &lt;c&gt;]
== [&lt;a&gt; &lt;c&gt;]
</code></pre>
<p>That specific error can be used to interesting effects, <a href="https://forum.rebol.info/t/making-use-of-definitional-errors-curtail/2118">see CURTAIL</a></p>
<h2>
<a name="decorated-groups-including-quoted-apply-their-decorations-3" class="anchor" href="https://forum.rebol.info#decorated-groups-including-quoted-apply-their-decorations-3"></a>Decorated Groups (including quoted) Apply Their Decorations!</h2>
<p>Ren-C has a lot of variations of GROUP!:</p>
<ul>
<li><strong><code>(set-group!):</code></strong></li>
<li><strong><code>:(get-group!)</code></strong></li>
<li><strong><code>^(meta-group!)</code></strong></li>
<li><strong><code>@(the-group!)</code></strong></li>
<li>
<strong><code>''''(quoted!)</code></strong>  <sub><a href="https://forum.rebol.info/t/quoted-arrives-formerly-known-as-lit-bit/995">yes, any number of quotes!</a></sub>
</li>
</ul>
<p>COMPOSE does useful magic for you, and if the type a GROUP! evaluates to supports the decoration, it will be applied!</p>
<pre><code>&gt;&gt; fruits: [apple banana]
&gt;&gt; dispositions: [favorite least-favorite]

&gt;&gt; compose [(dispositions.1): '@(second fruits)]
== [favorite: '@banana]
</code></pre>
<p><strong>Once you have this, you won't want to go back.</strong>  The premise of the language is being able to dynamically play with code and generate structures on the fly.  This makes that feel extremely seamless.</p>
<h2>
<a name="you-can-label-the-specific-groups-you-want-composed-4" class="anchor" href="https://forum.rebol.info#you-can-label-the-specific-groups-you-want-composed-4"></a>You Can Label the Specific Groups You Want Composed!</h2>
<p>One of the good things about templating is to be able to write most of your code normally, and then point out just the parts you want to substitute.  So if you're using so many groups that just being in a GROUP! isn't distinguishing what you want to substitute, <strong>tagged COMPOSE</strong> to the rescue:</p>
<p>You can pick whatever label you want, and the first item of each group will be checked against it:</p>
<pre><code>&gt;&gt; compose/label [(1 + 2) (&lt;*&gt; 1 + 2) (1 + 2)] &lt;*&gt;
== [(1 + 2) 3 (1 + 2)]
</code></pre>
<p>As a neat shorthand for this, a skippable TAG! parameter can be used:</p>
<pre><code>&gt;&gt; compose &lt;*&gt; [(1 + 2) (&lt;*&gt; 1 + 2) (1 + 2)]
== [(1 + 2) 3 (1 + 2)]
</code></pre>
<p>The TAG! has to be given literally between the COMPOSE and the expression you want to compose.  (This is a requirement for <code>&lt;skip&gt;</code>-ability.</p>
<p>You don't have to use symbols...any tag will do.  Could be a whole word with meaningful names, which might be valuable if you were doing it in several steps...where earlier phases could leave tags for later phases to compose.  You might also tag with numbers, <code>&lt;1&gt;</code> <code>&lt;2&gt;</code>...</p>
<h2>
<a name="predicate-functions-can-process-the-compose-slots-5" class="anchor" href="https://forum.rebol.info#predicate-functions-can-process-the-compose-slots-5"></a>Predicate Functions Can Process the Compose Slots!</h2>
<p>We now have the ability to run functions on the groups before you splice them.</p>
<p>So if you want to define COMPOSE that acts historically like Rebol2 (splicing unless you say /ONLY), here's one way you can do it:</p>
<pre><code>compose2: adapt augment :compose [/only] [
    if not only [
        predicate: func [group &lt;local&gt; product] [
            either any-array? product: eval group [spread product] [:product]
        ]
    ]
]
</code></pre>
<p>We added the /ONLY refinement, and if you don't use it then it adds a processing function for arrays.  This gives you the historical result!</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/surfing_man.png?v=12" title=":surfing_man:" class="emoji only-emoji" alt=":surfing_man:" loading="lazy" width="20" height="20"></p>
<p>This only scratches the surface of what's possible, with these bendable and useful ergonomics.</p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/the-superpowers-of-ren-cs-revamped-compose/979">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-superpowers-of-ren-cs-revamped-compose/979</link>
          <pubDate>Thu, 27 Dec 2018 08:01:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-979</guid>
          <source url="https://forum.rebol.info/t/the-superpowers-of-ren-cs-revamped-compose/979.rss">The Superpowers of Ren-C&#39;s Revamped COMPOSE</source>
        </item>
        <item>
          <title>You only get...ONESHOT</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>ONESHOT is a cool new function generator, which makes a DO-like function which holds state to run only once.</p>
<pre><code>once: oneshot
for-each x [10 20 30] [
     once [print ["loop begins with" x]]
     print [x]
]
</code></pre>
<p>And that will give you:</p>
<pre><code>loop begins with 10
10
20
30
</code></pre>
<p>So although ONCE was called for each step in the loop, it only ran what it was given one time.  Unlike code that is run before the loop, it has access to the first element.  <em>(If BREAK and CONTINUE were "definitional", it would also be able to modify them just once in the loop...which will likely be a relevant thing in the near future.)</em></p>
<p>It's obviously not anything you couldn't do with declaring a LOGIC! and putting in the test-and-flip code.  But it's shorter.  And unlike wrapping that logic up in a helper function, this lets the code that you're controlling <em>change</em>, so if one of the cases runs, the other case (with differing code) won't run.</p>
<p>Plus, ONESHOT will "voidify" the evaluative result of what it's given--like a conditional would.  So NULL will always mean it didn't run the code you gave it.  So for instance, this means that for every time but the first, you could respond to it with an ELSE.</p>
<pre><code>once: oneshot
for-each x [10 20 30] [
     once [print ["first:" x]] else [print ["rest:" x]]
]
</code></pre>
<p>That gives you:</p>
<pre><code>first: 10
rest: 20
rest: 30
</code></pre>
<p>ONESHOT is actually a specialization of N-SHOT, which lets you specifiy a generic N.  If that N is negative, then it will actually <em>not</em> run the code you give it N times before it starts running it.</p>
<pre><code>&gt;&gt; anti: n-shot -2

&gt;&gt; anti [5 + 5]
// null

&gt;&gt; anti [6 + 6]
// null

&gt;&gt; anti [7 + 7]
== 14

&gt;&gt; anti [8 + 8]
== 16
</code></pre>
<p><a class="mention" href="https://forum.rebol.info/u/markeye">@MarkEye</a>/<a class="mention" href="https://forum.rebol.info/u/mark-hi">@Mark-hi</a> suggested UPSHOT as the name for the specialization when it's -1, so I went with that as the complement to ONESHOT for now.</p>
<h2>Use with <code>&lt;static&gt;</code> and get lazy initialization</h2>
<p>If you have something you want to happen only the first time you call a function, that's now pretty easy:</p>
<pre><code>operation: function [... &lt;static&gt; lazy (oneshot)] [
    lazy [
        ** "do expensive initialization here"
    ]
    ...
]
</code></pre>
<p>This is a shorter way of writing:</p>
<pre><code>operation: function [... &lt;static&gt; initialized (false)] [
    if not initialized [
        ** "do expensive initialization here"
        initialized: true
    ]
    ...
]
</code></pre>
<p>Generating oneshots makes an ACTION!, and hence incurs more overhead than making a LOGIC! variable.  But once they've been created, the execution time should be less than a conditional.  e.g. for this case, <code>lazy</code> makes its decision faster than an IF, and doesn't have to look up the words for the logic variables to be tested.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/you-only-get-oneshot/934">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/you-only-get-oneshot/934</link>
          <pubDate>Fri, 30 Nov 2018 23:46:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-934</guid>
          <source url="https://forum.rebol.info/t/you-only-get-oneshot/934.rss">You only get...ONESHOT</source>
        </item>
        <item>
          <title>Comment to end-of-line with * *</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>It's Thanksgiving, and a good time to be thankful for <a href="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405">"invisibles"</a>, one of the great success stories of 2018.  Their applications have gone far beyond commenting, though that's great too:</p>
<pre><code>x: 10
y: 1 comment [+ 2
z: 30] + 7
</code></pre>
<p>That'll give you <strong>y = 8</strong>.  Nifty.</p>
<p>But in the spirit of taking back attention-getting symbols like <strong><code>--</code></strong> for <a href="https://forum.rebol.info/t/taking-a-thrilling-tour-through-the-dump/909">epically more useful things</a>, I've taken back <strong><code>**</code></strong> from exponentiation (now just do infix exponents with <code>pow</code>).  In an idea near-simultaneously had by <a class="mention" href="https://forum.rebol.info/u/ingohohmann">@IngoHohmann</a> and I, it now acts as "comment to end of line" (or to end of block or group, whichever comes first).</p>
<p>What's the value of such a thing over <code>//</code>-style comments?  The real power is that it clearly annotates <em>code</em>, and raises a visual flag of "I am not a normal source comment"</p>
<pre><code>all [
    blah blah blah
    line two
    ** x: [some stuff here]
    do x
]
</code></pre>
<p>Had you used <code>//</code> it might be documentation.  Maybe that line is there to illustrate a property of x, to inform the next DO line?  But with <code>**</code> you know it's not an illustrative comment, it's marked out code.  It has to be LOADable, and stay LOADable.  And your eye can scan up and down the page and see these things easily before committing them on accident.</p>
<p>If you want to use it in the middle of a line, curb its to-end-of-line-ness by putting it in a GROUP!:</p>
<pre><code>any [this runs (** my-function "code that doesn't run") this runs too]
</code></pre>
<p>If you start a BLOCK! or GROUP! which then has newlines in it, that element will be the last thing considered...commented out to its end delimiter:</p>
<pre><code>&gt;&gt; print "this runs" ** (
    print "this does not run"
) print "this runs too"
</code></pre>
<p>Getting this to work required a bit of tweaking of unfinished varargs features.  But since it was done for this, now the <code>--</code> form of DUMP uses it too!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/comment-to-end-of-line-with/920">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/comment-to-end-of-line-with/920</link>
          <pubDate>Thu, 22 Nov 2018 15:35:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-920</guid>
          <source url="https://forum.rebol.info/t/comment-to-end-of-line-with/920.rss">Comment to end-of-line with * *</source>
        </item>
        <item>
          <title>I&#39;m bringin&#39; EVERY back (yeah!)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p><em>(<img src="//forum.rebol.info/images/emoji/twitter/man_dancing.png?v=7" title=":man_dancing:" class="emoji" alt=":man_dancing:">  <img src="//forum.rebol.info/images/emoji/twitter/musical_note.png?v=7" title=":musical_note:" class="emoji" alt=":musical_note:"> <img src="//forum.rebol.info/images/emoji/twitter/desktop_computer.png?v=7" title=":desktop_computer:" class="emoji" alt=":desktop_computer:"> ...them other boys don't know how to hack (yeah!) <img src="//forum.rebol.info/images/emoji/twitter/musical_note.png?v=7" title=":musical_note:" class="emoji" alt=":musical_note:"> <img src="//forum.rebol.info/images/emoji/twitter/man_dancing.png?v=7" title=":man_dancing:" class="emoji" alt=":man_dancing:"> <img src="//forum.rebol.info/images/emoji/twitter/computer.png?v=7" title=":computer:" class="emoji" alt=":computer:">)</em></p>
<p>With <a href="https://youtu.be/UD8tGWIqA-c?t=17" rel="nofollow noopener">apologies to Justin Timberlake</a>, I re-present to you EVERY.  It was <a href="https://github.com/metaeducation/ren-c/issues/847" rel="nofollow noopener">temporarily shelved</a> due to ambiguous semantics, that recent changes to the loop result protocol have basically solved.</p>
<p>It's like a FOR-EACH but if the loop body ever returns false, it returns false:</p>
<pre><code>&gt;&gt; every x [1 3 7] [print [x] | odd? x]
1
3
7
== #[true]

&gt;&gt; every x [1 4 7] [print [x] | odd? x]
1
4
7
== #[false]
</code></pre>
<p>So EVERY runs through all the loop steps (assuming you don't break), but remembers if the body ever returns a falsey value...and if so returns #[false].  Otherwise it returns the last truthy value.</p>
<p>Note that <code>CONTINUE</code> is interpreted as <code>CONTINUE NULL</code>, which means "act as if the loop body reached the end and had evaluated to null for this iteration".  As null is falsey, that means you need to say <code>CONTINUE TRUE</code> (or other truthy value) if you want that loop iteration to not count as disrupting the everyness.</p>
<pre><code>&gt;&gt; every x [1 2 3] [print [x] | if x = 2 [continue] x]
1
2
3
== #[false]

&gt;&gt; every x [1 2 3] [print [x] | if x = 2 [continue true] x]
1
2
3
== 3
</code></pre>
<p>It still obeys the loop result protocol, so that means if the loop ever breaks you'll get a NULL... and if the loop body never runs you'll get blank.  All three states are falsey so you get:</p>
<pre><code>every x data [
    ...
] or [
    // code to run if there was a break, there was no data,
    // or any of the loop body runs returned null/break/false
]
</code></pre>
<p>If you're trying to build an opt-out situation which would default to an empty input being okay (instead of falsey like if the body failed), test against false explicitly so the blank case won't qualify:</p>
<pre><code>false &lt;&gt; every x data [
    // if this body returns false (null, blank) then that will
    // make the whole expression false.  But the no data
    // case which returns blank will still give you truthyness
]
</code></pre>
<p>Though just because of how things work out, that will treat BREAK as a "success", since <code>false &lt;&gt; null</code>.  So if you have a need to use both BREAKs <em>and</em> falsey loop bodies in the every, turn the nulls into false explicitly:</p>
<pre><code>false &lt;&gt; (every x data [
    ...
] else [false])
</code></pre>
<p>Loop iterations must return something that can be tested for conditional truth or falsehood, so voids aren't legal.  This is an important distinction with FOR-EACH, which is able to run loop bodies that return void</p>
<pre><code>&gt;&gt; every x [1 2 3] [print "this errors, void loop body result"]
this errors, void loop body result
** Script Error: VOID! values are not conditionally true or false
</code></pre>
<p><em><img src="//forum.rebol.info/images/emoji/twitter/musical_note.png?v=7" title=":musical_note:" class="emoji" alt=":musical_note:"> ...so get your EVERY on (go 'head, be gone with it) <img src="//forum.rebol.info/images/emoji/twitter/musical_note.png?v=7" title=":musical_note:" class="emoji" alt=":musical_note:"></em></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/im-bringin-every-back-yeah/915">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/im-bringin-every-back-yeah/915</link>
          <pubDate>Mon, 19 Nov 2018 15:25:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-915</guid>
          <source url="https://forum.rebol.info/t/im-bringin-every-back-yeah/915.rss">I&#39;m bringin&#39; EVERY back (yeah!)</source>
        </item>
  </channel>
</rss>

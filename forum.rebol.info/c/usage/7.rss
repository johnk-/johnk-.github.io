<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Usage - AltRebol</title>
    <link>https://forum.rebol.info/c/usage/7</link>
    <description>Topics in the &#39;Usage&#39; category Questions and discussion about using Rebol.</description>
    
      <lastBuildDate>Sat, 14 Jan 2023 15:21:04 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/usage/7.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Working With Truthy BLANK!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>The current re-imagining of the concept of truthy/falsey involves the idea that <em>anything you can put into a block is truthy</em>.  That includes BLANK!.</p>
<p>~null~ isotopes are falsey, and will REIFY to be <strong><code>~null~</code></strong> which can be somewhat clumsy-looking.</p>
<p>But consider some test cases for seeing how SPLIT-PATH works, looking a bit like this:</p>
<pre><code>split-path-tests:  [
    %foo                            [_ %foo]
    %/c/test/test2                  [%/c/test/ %test2]
    %/c/test                        [%/c/ %test]
    %//test                         [%// %test]
    %/test                          [%/ %test]
    %//                             [%/ %/]
    %.                              [%./ _]
    %./                             [%./ _]
    %./.                            [%./ %./]
    &lt;...etc...&gt;
]
</code></pre>
<p>SPLIT-PATH is a multi-return routine, which gives back two values: the path and the filename.  But if one or the other is missing then that component will be null, which is useful for testing with IF (or using DEFAULT with).</p>
<p>But if we just blindly changed the tests to reify, it would become less legible:</p>
<pre><code>split-path-tests:  [
    %foo                            [~null~ %foo]
    %/c/test/test2                  [%/c/test/ %test2]
    %/c/test                        [%/c/ %test]
    %//test                         [%// %test]
    %/test                          [%/ %test]
    %//                             [%/ %/]
    %.                              [%./ ~null~]
    %./                             [%./ ~null~]
    %./.                            [%./ %./]
    &lt;...etc...&gt;
]
</code></pre>
<p>However...with blanks being truthy, this means you that you can take a variable which may be null and turn it into a blank, like this:</p>
<pre><code>reduce [any [path _] any [file _]]
</code></pre>
<p>That's rather succinct!  Probably so succinct that it doesn't need its own native to express.</p>
<p>(I thought it was neat.)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/working-with-truthy-blank/2007">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/working-with-truthy-blank/2007</link>
          <pubDate>Sat, 14 Jan 2023 15:21:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2007</guid>
          <source url="https://forum.rebol.info/t/working-with-truthy-blank/2007.rss">Working With Truthy BLANK!</source>
        </item>
        <item>
          <title>ChatGPT Speaking About Rebol</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>So ChatGPT actually knows a bit about Rebol (at least Rebol2)</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/7b940f01f3801b53d0a1d4d412074bda30517443.png" data-download-href="https://forum.rebol.info/uploads/default/7b940f01f3801b53d0a1d4d412074bda30517443" title="image"><img src="https://forum.rebol.info/uploads/default/original/1X/7b940f01f3801b53d0a1d4d412074bda30517443.png" alt="image" data-base62-sha1="hDdWsU3sEBthVlysVvcHRLWmfWH" width="356" height="500" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/7b940f01f3801b53d0a1d4d412074bda30517443_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">image</span><span class="informations">634Ã—890 25 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p>This does raise some questions about the future of software, in general.  It's possible that AI models will plateau and maybe they'll never get too much better than this...</p>
<p>...but I don't think so.  I imagine year-over-year, we're going to see them learning.  I don't know exactly when they'd be able to come up with ideas like what I've been doing for Ren-C.</p>
<p>But something I did think about is that if they can write code, then giving them a super-expressive medium in which to do it could be very powerful.  If they can come up with the dialect and then use it, then they might be able to write concise programs that wind up being quite legible...whereas other languages might make them trade off length for clarity.</p>
<p>If you ask ChatGPT an interesting Rebol question, feel free to put it in this thread.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/chatgpt-speaking-about-rebol/1997">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/chatgpt-speaking-about-rebol/1997</link>
          <pubDate>Sat, 17 Dec 2022 15:53:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1997</guid>
          <source url="https://forum.rebol.info/t/chatgpt-speaking-about-rebol/1997.rss">ChatGPT Speaking About Rebol</source>
        </item>
        <item>
          <title>Jonathan Blow, and Euclid&#39;s Elements</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Jonathan Blow is a video game developer--who made a well known indie game called "Braid" that did some fun time/space manipulations people generally hadn't seen before in a Mario-type platfomer.   Later he took a number of years to make the much higher-budget art piece The Witness...a very intellectual game which has a Sixth-Sense kind of reveal that's quite good.</p>
<p>Though as time changes him from grumpy indie upstart to grumpy-old-man, he has joined the chorus of us grumpy old men when it comes to complexity:</p>
<div class="onebox lazyYT lazyYT-container" data-youtube-id="pW-SOdj4Kkk" data-youtube-title="Jonathan Blow - Preventing the Collapse of Civilization (English only)" data-parameters="feature=oembed&amp;wmode=opaque&amp;start=2189">
  <a href="https://www.youtube.com/watch?v=pW-SOdj4Kkk" target="_blank" rel="noopener">
    <img class="ytp-thumbnail-image" src="https://i.ytimg.com/vi/pW-SOdj4Kkk/maxresdefault.jpg" title="Jonathan Blow - Preventing the Collapse of Civilization (English only)" width="480" height="360">
  </a>
</div>

<p>But I'm pretty sure he would pretty much hate Redbol languages for programming his games.  He doesn't like scripting, and thinks it's dumb to use things without static typing or that catch your mistakes in advance.  (And I'm with him when he responds to people who say things like "but you can try changes without restarting" are wrongheaded.  You can compile checked bits of code and reload them dynamically if your system is designed right.)</p>
<p>What he's looking for is something that offers the benefits of C++ and Rust, but minus the things he considers to be annoying.  "Something like Rust, but cutting out anything that would be an impediment to the games that I--Jonathan Blow--would write."</p>
<p><a href="https://github.com/BSVino/JaiPrimer/blob/master/JaiPrimer.md">https://github.com/BSVino/JaiPrimer/blob/master/JaiPrimer.md</a></p>
<p>I imagine that if Jonathan <em>were</em> to appreciate something like Ren-C it would be in the way I do--as a game in itself.  (He actually playtested "Baba is You"--according to a YouTube stream of him playing the final version.  When asked what he was paid to give his feedback he just grumbled "not enough".  So I probably won't be sending Ren-C to him.  :-P)</p>
<p>In any case, he was doing a talk on games in education and cited a page from Euclid's Elements that I thought was interesting.  <a href="https://youtu.be/qWFScmtiC44?t=756">The quote he cites says</a>:</p>
<blockquote>
<p><em>"If a first magnitude has to a second the same ratio as a third has to a fourth, and also a fifth has to the second the same ratio as a sixth to a fourth, then the sum of the first and fifth has to the second the same ratio as the sum of the third and sixth has to the fourth."</em></p>
</blockquote>
<p>I'm sure it sounded like nonsense to Euclid's contemporaries, who were not able (or willing) to follow the reasoning for why such things might be important.</p>
<p>When you're reasoning through new abstract things there's lots of phases to it.  Terminology and mechanics evolve over time.  That's how it works, so people shouldn't be surprised to see things like <em><a href="https://forum.rebol.info/t/the-implications-of-meta-producing-quasi-from-isotopes/1967">"The Implications of ^META Producing QUASI! from Isotopes"</a></em>  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/jonathan-blow-and-euclids-elements/1971">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/jonathan-blow-and-euclids-elements/1971</link>
          <pubDate>Sun, 18 Sep 2022 21:14:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1971</guid>
          <source url="https://forum.rebol.info/t/jonathan-blow-and-euclids-elements/1971.rss">Jonathan Blow, and Euclid&#39;s Elements</source>
        </item>
        <item>
          <title>Rebol&#39;s Mission w.r.t. &quot;not wasting RAM or CPU cycles&quot;</title>
          <dc:creator><![CDATA[WickedSmoke]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Rebol was an attempt at grappling with the problems of overly complex and bloated software.  Part of that means not wasting RAM or CPU cycles.</p>
<p>Optimizing is just a normal part of software development. It's not done to please the programmer, but to build something of quality that respects the user who is running other pieces of software that are also using resources.  Think of it as being a good computational neighbor.</p>
<p>There needs to be some thread here about "computing horror stories". A month ago there was an article on Hacker News about NixOS and it's packaging system.  As some Nix user had just contacted me about packaging xu4, I thought I'd give it a spin.  After downloading the ISO and installing it on a virtual machine I went to get a package listing...<br>
and was greeted with some vague error message.</p>
<p>It turns out that the package manager was using well over 1GB of RAM and simply crapped out because my VM didn't have enough.  Some NixOS user told me:</p>
<blockquote>
<p>"Listing all packages is a bit of a weak spot. The entire package set is described in a lazy, functional language and listing or searching it requires evaluating the entire thing."</p>
</blockquote>
<p>This is an entire OS custom built around a package manager, and it couldn't even give me a listing of my packages.  The Nix developers want to geek out about their language, but I just want tools that work.</p>
<p>Thankfully, data-oriented design is now a thing, so I know at least someone is paying attention.</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rebols-mission-w-r-t-not-wasting-ram-or-cpu-cycles/1970">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rebols-mission-w-r-t-not-wasting-ram-or-cpu-cycles/1970</link>
          <pubDate>Sun, 18 Sep 2022 18:19:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1970</guid>
          <source url="https://forum.rebol.info/t/rebols-mission-w-r-t-not-wasting-ram-or-cpu-cycles/1970.rss">Rebol&#39;s Mission w.r.t. &quot;not wasting RAM or CPU cycles&quot;</source>
        </item>
        <item>
          <title>Minor (but nice!) %prot-http.r parsing improvements</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>Here's is R3-Alpha's <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/mezz/prot-http.r">PARSE-WRITE-DIALECT</a> from %prot-http.r</p>
<pre><code>parse-write-dialect: func [port block /local spec] [
    spec: port/spec
    parse block [
        [set block word! (spec/method: block) | (spec/method: 'post)]
        opt [set block [file! | url!] (spec/path: block)]
        [set block block! (spec/headers: block) | (spec/headers: [])]
        [set block [any-string! | binary!] (spec/content: block) | (spec/content: none)]
    ]
]
</code></pre>
<p>You couldn't set paths in R3-Alpha parse, which is weird.  So things had to be captured into a temporary variable (it reused the input block for some reason).</p>
<p>Let's imagine that setting paths were legal:</p>
<pre><code>parse-write-dialect: func [port block /local spec] [
    spec: port/spec
    parse block [
        [set spec/method word! | (spec/method: 'post)]
        opt [set spec/path [file! | url!]]
        [set spec/headers block! | (spec/headers: [])]
        [set spec/content [any-string! | binary!] | (spec/content: none)]
    ]
]
</code></pre>
<p>Let's do a quick transformation of this to PARSE3 in Ren-C:</p>
<pre><code>parse-write-dialect: func [port block &lt;local&gt; spec] [
    spec: port.spec
    parse3 block [  ; PARSE3 is R3-Alpha-compatible parse
        [set spec.method word! | (spec.method: 'post)]
        opt [set spec.path [file! | url!]]
        [set spec.headers block! | (spec.headers: [])]
        [set spec.content [any-string! | binary!] | (spec.content: _)]
    ]
]
</code></pre>
<ul>
<li>
<p>The TUPLE!s help us see we're not making function calls, which is nice</p>
</li>
<li>
<p>We have BLANK! which gives a nicer semiotic "we're nulling out this variable" look.</p>
</li>
<li>
<p>/LOCAL is a legitimate normal refinement, and <code>&lt;local&gt;</code> variables are truly local--you can't slip them in from the caller.  Because they are invisible, you can build function compositions that don't have to worry about colliding with their names.</p>
<ul>
<li>It also frees up /LOCAL to just be a typical refinement, like TIME/LOCAL</li>
</ul>
</li>
</ul>
<p>Now let's throw in some UPARSE, with the SET-WORD!s for assignment...</p>
<pre><code>parse-write-dialect: func [port block &lt;local&gt; spec] [
    spec: port.spec
    parse block [  ; PARSE is now UPARSE
        [spec.method: word! | (spec.method: 'post)]
        opt [spec.path: [file! | url!]]
        [spec.headers: block! | (spec.headers: [])]
        [spec.content: [any-string! | binary!] | (spec.content: _)]
    ]
]
</code></pre>
<p>It looks a little tighter...but then we also have the ability to factor the assignments out...</p>
<pre><code>parse-write-dialect: func [port block &lt;local&gt; spec] [
    spec: port.spec
    parse block [
        spec.method: [word! | ('post)]
        spec.path: opt [file! | url!]
        spec.headers: [block! | ([])]
        spec.content: [any-string! | binary! | (_)]
    ]
]
</code></pre>
<p>As it happens, that last line could just be <strong>opt [any-string! binary!]</strong>, because it would assign the result to NULL.</p>
<h2>But... That Raises a Question...</h2>
<p>What if the PARSE behavior for BLANK! was the same as in the evaluator, and it just produced NULL out of thin air but didn't match it?  Hence <code>_</code> would be a synonym for <code>(_)</code>.</p>
<p>Then these would be equivalent:</p>
<pre><code>spec.content: [any-string! | binary! | _]

spec.content: opt [any-string! | binary!]
</code></pre>
<p>You'd also be able to easily zero variables without entering a GROUP!.</p>
<pre><code>&gt;&gt; data: &lt;before&gt;

&gt;&gt; parse [x x x] [data: _ [some "y" (data: "Found some Y!")]]
; null

&gt;&gt; data
; null
</code></pre>
<p>I think the literal INTEGER! behavior has turned out to be a winner, where <code>3</code> is the same as <code>(3)</code>.  So maybe that would be good for blank too, given its new useful null-making behavior?  Dunno.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/minor-but-nice-prot-http-r-parsing-improvements/1945">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/minor-but-nice-prot-http-r-parsing-improvements/1945</link>
          <pubDate>Sat, 27 Aug 2022 17:38:07 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1945</guid>
          <source url="https://forum.rebol.info/t/minor-but-nice-prot-http-r-parsing-improvements/1945.rss">Minor (but nice!) %prot-http.r parsing improvements</source>
        </item>
        <item>
          <title>Weird Little Function: STEAL a Variable&#39;s Prior Value</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I don't know if it has the best name (suggestions?), but it's kind of interesting...</p>
<pre><code>&gt;&gt; x: 304
== 304

&gt;&gt; steal x: 1000 + 20
== 304

&gt;&gt; x
== 1020
</code></pre>
<p>I wrote it as a variadic function for some reason (as a test, maybe?) but you could write it in Redbol.  You could even use their lame ALSO.</p>
<pre><code>steal: func [
    {Red version}
    'var [set-word! set-path!]
    value [any-type!]
][
    also get var set var value
]
</code></pre>
<p>The Ren-C version of that reads a lot better:</p>
<pre><code>steal: lambda [
    {Ren-C version}
    'var [set-word! set-path!]
    value [any-value!]
][
    get var
    elide set var value
]
</code></pre>
<p>It naturally has the benefit of letting you break things across lines.  I feel like it's better to point out "this is the thing being erased".  And of course the mechanic is far more general.</p>
<p>I definitely like ANY-VALUE! better than ANY-TYPE!.</p>
<p>Anyway, I'm sure I've seen places I could have used it if I thought of it.  I'll keep my eyes open.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/weird-little-function-steal-a-variables-prior-value/1943">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/weird-little-function-steal-a-variables-prior-value/1943</link>
          <pubDate>Thu, 25 Aug 2022 16:27:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1943</guid>
          <source url="https://forum.rebol.info/t/weird-little-function-steal-a-variables-prior-value/1943.rss">Weird Little Function: STEAL a Variable&#39;s Prior Value</source>
        </item>
        <item>
          <title>A Justification of Generalized Isotopes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p><em>Here is a train of thought to help people realize why isotopes are needed, and why unifying their behaviors and mechanisms under a common umbrella makes sense.  It starts from the issue of solving /ONLY and then explains the generalization.</em></p>
<p><em>As time permits, I'll come back and try to improve this...</em></p>
<hr>
<p>Years of fretting over the /ONLY debacle converged on a somewhat inescapable conclusion:</p>
<p><em><strong>It's better to carry the intent of whether a value needs to be spliced on that value...as opposed to having subtle variants of core operations that modulate the splicing.</strong></em></p>
<p>I'd worked up to a point where I was implementing the "mark of intent" by adding a quoting level to <em>suppress</em> splicing.  Yet this faced likely accidents when someone had a quoted value in a variable...and really meant to use it somewhere as-is, with the quote--vs. thinking of the quote as a splice-suppression signal which the operation should remove.</p>
<p>Then <a href="https://forum.rebol.info/t/putting-splicing-intent-on-appended-value/1873/9">@rgchris made this remark</a>:</p>
<aside class="quote no-group quote-modified" data-username="rgchris" data-post="9" data-topic="1873" data-full="true">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"><a href="https://forum.rebol.info/t/putting-splicing-intent-on-appended-value/1873/9">Putting Splicing Intent On APPEND'ed Value</a>
</div>
<blockquote>
<p>The issue I have with doing the opposite of ONLYâ€”let's call it SPREADâ€”is what is the interim value?</p>
<pre><code>&gt;&gt; block: [a b c [a b c]]

&gt;&gt; find block pick block 4
[[a b c]]

&gt;&gt; find block spread pick block 4
[a b c [a b c]]

&gt;&gt; spread pick block 4
???
</code></pre>
<p>It would seem to have virtue over ONLY and is a better word.</p>
</blockquote>
</aside>
<h2>If Trying This In Historical Redbol, What Might One Do?</h2>
<p>As a rough first cut, let's represent splices with a specially recognizable 2-element wrapper block.  We'll signal it's a splice with a series in the first slot--checking for the unique identity of that series.  Then put the block itself as the second element:</p>
<pre><code>splice-cue: "!!!splice!!!"

spread: func [block [block!]] [
    return reduce [splice-cue block]
]

splice?: func [value] [
    if not block? :value [return false]
    return same? splice-cue first value
]
</code></pre>
<p>Then we can write our new versions of things like APPEND that are specifically aware of this construct.</p>
<pre><code>append*: func [series [series!] value] [
    return either splice? :value [
        append series second value
    ][
        append/only series :value
    ]
 ]
</code></pre>
<p>It works more or less in your average Redbol, e.g. in Red:</p>
<pre><code>red&gt;&gt; append* [a b c] spread [d e]
== [a b c d e]

red&gt;&gt; append* [a b c] [d e]
== [a b c [d e]]

red&gt;&gt; append* [a b c] 'd
== [a b c d]

red&gt;&gt; append* [a b c] first ['d]
== [a b c 'd]
</code></pre>
<p><em>In fact, this is essentially how the bootstrap executable for Ren-C simulates the SPREAD behavior.</em></p>
<p>But the weaknesses are <em>immediately</em> apparent!!!  <img src="https://forum.rebol.info/images/emoji/twitter/pouting_cat.png?v=9" title=":pouting_cat:" class="emoji" alt=":pouting_cat:"></p>
<h2>Not A Distinct Type: Too Easy To Overlook Handling</h2>
<p>There's no special type for the spliced block...it's just a BLOCK!.  This means any routine that hasn't been written to handle it, will just let it leak through.</p>
<pre><code>red&gt;&gt; reduce [spread [a b c] [a b c]]
== [["!!!splice!!!" [a b c]] [a b c]]  ; not [a b c [a b c]]
</code></pre>
<p>Changing to some other generic type that can contain a block...such as an OBJECT!...doesn't help matters.  You are kind of in trouble any time an operation willfully lets you put these into an array.</p>
<p><strong>The first instinct might be to introduce a new SPLICE! datatype, with a system-wide rule that splices can't be put into arrays.</strong>  <em>(Enforcing such a rule across all array-manipulating code is challenging...so let's sort of make a note of that fact, but continue.)</em></p>
<p>Because of the peculiar nature of not being able to be put in a block, there'd have to be a decision made about function arguments as to whether or not they took this type.  Many functions designed to handle generic values would not be able to handle them, so there'd presumably need to be some typeset like ANY-NOTSPLICE! or ANY-NORMAL!.</p>
<h2>How To Represent A Type That Can't Be Put In A Block?</h2>
<p>Now we've got several things to ponder about our new type.  For instance: what you should see here?</p>
<pre><code>&gt;&gt; obj: make object! [foo: spread [d e]]
== make object! [
    foo: ???
]
</code></pre>
<p>We just said that a defining feature of SPLICE! is that you can't accidentally put them in blocks.  But the argument to MAKE OBJECT!, namely <strong><code>[foo: ???]</code></strong>, is a block.  If <code>???</code> can't itself be a splice!, then what is it?</p>
<p>This brings up a possibly-related question: what if you want a way to put the intent of whether to splice or not into "suspended animation?"... in a way that you could collect it?</p>
<p>Here's a sort of contrived example of the puzzle:</p>
<pre><code>generate: func [n [integer!]] [
   if even? n [return reduce [n n + 1]]
   return spread reduce [n n + 1]
]

wrap: func [
    return: [...]
    in [splice! block!]
][
    ...
]

unwrap: func [
    return: [splice! block!]
    wrapped [...]
][
    ...
]

n: 0
pending: collect [while [n &lt; 4] [keep wrap generate n]]

data: copy []
for-each item pending [append data unwrap item]
</code></pre>
<p>How would you write WRAP and UNWRAP such that at the end of the code above, you'd get:</p>
<pre><code>&gt;&gt; data
== [[0 1] 1 2 [2 3] 3 4]
</code></pre>
<p>If the system didn't provide some answer to this, you'd end up needing to re-invent something kind of equivalent to the primitive <code>["!!!splice!!!" [...]]</code> mechanic as a means of persistence:</p>
<pre><code>&gt;&gt; pending
== [[0 1] ["!!!splice!!!" [1 2]] [2 3] ["!!!splice!!!" [3 4]]]
</code></pre>
<h1>Isotopes Were Designed For This!</h1>
<p>Isotopes are a set of curated answers for these problems.  Originally they were introduced to address issues like what an UNSET! was...which has some of the same class of problems as SPLICE! (such as not wanting to be put in BLOCK!s, and not accepted by default or by most routines).</p>
<p>Isotopes are:</p>
<ul>
<li>
<p><strong>general</strong> - all base value types (e.g. unquoted things that can be put into blocks) have isotopic forms [see note]</p>
</li>
<li>
<p><strong>efficient</strong> - isotopes do not require allocations, and merely are a different state of a byte in the value cell (the same byte that encodes quoting levels)</p>
</li>
<li>
<p><strong>"meta-representable"</strong> - all isotopes have a corresponding single-value form known as a "quasi-form", which when evaluated (or run through a more narrow UNQUASI operation) will yield the isotopic form</p>
</li>
</ul>
<p><em>(Note: An edge case is that VOID is not considered isotopic, and so it has an isotopic form--which is used to represent unsetness.  It might seem that VOID should itself be the isotopic form of something else, since void can't be put in a block.  But we could also see it as infinitely many voids can be put in a block... since <strong><code>append [a b c] void</code></strong> is just <strong><code>[a b c]</code></strong>.  It just kind of turns out that thinking of void as non-isotopic appears to work out, and thinking of null as an isotopic word! is another thing that works out.)</em></p>
<p>I mentioned at the outset that it would be somewhat costly to bulletproof all of native code against the ability to do something like append a specific data type like "SPLICE!" to a block.  But with isotopes this problem has been solved once for all the forms...so the same code that prevents a so-called "UNSET!" from winding up in arrays works for splices.  <em>That's because a splice is actually an isotopic group!, and an unset is actually an isotopic void!</em></p>
<p>Above I asked:</p>
<blockquote>
<p>What you should see here?</p>
<pre><code>&gt;&gt; obj: make object! [foo: spread [d e]]
== make object! [
    foo: ???
]
</code></pre>
</blockquote>
<p>Isotopes give us the answer, that it's <strong><code>foo: ~(d e)~</code></strong>.  This is the previously mentioned "QUASI!" form of GROUP!, which when evaluated produces an isotope.</p>
<p><em>But isotopes themselves have no canon representation.</em>  The console can print out a comment or show them in a different color, but to talk about them having a representation doesn't make much sense as you'll never see them in source.</p>
<pre><code>&gt;&gt; ~(d e)~
== ~(d e)~  ; isotope
</code></pre>
<p>I also asked:</p>
<blockquote>
<p>"How would you write WRAP and UNWRAP such that at the end of the code above, you'd get:"</p>
<pre><code>&gt;&gt; data
== [[0 1] 1 2 [2 3] 3 4]
</code></pre>
</blockquote>
<p>With isotopic blocks representing splices, you don't need to write WRAP and UNWRAP... because these operations are built in operations called META and UNMETA.  And the pending array would look like:</p>
<pre><code>&gt;&gt; pending
== ['[0 1] ~(1 2)~ '[2 3] ~(3 4)~]
</code></pre>
<p>When the QUOTED! blocks are UNMETA'd, they become regular blocks and then are appended as-is.  When the QUASI! groups are UNMETA'd they become isotopes and give the splice intent.  This produces the desired "suspended animation" to preserve the intent.</p>
<p><em>That suspended animation is also used in the ^META parameter convention, which indicates a function argument can accept isotopes... and the add-quoting-or-quasi behavior brings those isotopic variables into a reified state so they can be safely handled.</em></p>
<h2>The Proof Is In The Capabilities</h2>
<p>I've explained about splices, and mentioned how it crosses needs with unset variable states.</p>
<p>But isotopes are also a cornerstone of <a href="https://forum.rebol.info/t/default-values-and-make-frame/1412">how function and FRAME! specialization works</a>.</p>
<p>The ERROR! isotope is used to have a sneaky out-of-band way to return <a href="https://forum.rebol.info/t/fail-vs-return-fail-the-new-age-of-definitional-failures/1852">definitional errors</a></p>
<p>As their applications expand, they are slated to allow us to have non-literal modes to ask something like FIND that you want to look for <em>instances</em> of a datatype by passing that type isotopically... vs. looking for the datatype's appearance concretely in the target.  Concepts of making only isotopic ACTION!s run through WORD! references could make it completely safe to work with arguments passed as variables, saving you from needing GET-WORD!s to handle them.</p>
<p>It's natural for there to be some confusion with the new idea--especially given all its churn through the course of design.  But the design is becoming clearer, and I think people are going to find this gives solidity to writing complicated but coherent code...vastly outpacing historical Redbol.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918</link>
          <pubDate>Tue, 16 Aug 2022 10:23:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1918</guid>
          <source url="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918.rss">A Justification of Generalized Isotopes</source>
        </item>
        <item>
          <title>Enter the Dungeon ðŸ’€ ...if You Dare!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <h2>The Imaginary 3-D Dungeon Simulator of the Year, 1983...</h2>
<p>NOW ON THE WEB!!</p>
<p><strong><a href="http://hostilefork.com/media/shared/replpad-js/?do=dungeon">http://hostilefork.com/media/shared/replpad-js/?do=dungeon</a></strong></p>
<p>Source code:</p>
<p><a href="https://github.com/hostilefork/teenage-coding/blob/master/DUNGEON/dungeon.reb">https://github.com/hostilefork/teenage-coding/blob/master/DUNGEON/dungeon.reb</a></p>
<h2>Backstory</h2>
<p>When I was a kid (circa 1983, I'd be about 8 or 9), I played the Intellivision game <a href="http://en.wikipedia.org/wiki/Advanced_Dungeons_&amp;_Dragons:_Treasure_of_Tarmin">Advanced Dungeons and Dragons: Treasure of Tarmin</a>. The 3-D graphics put you in a first-person-perspective point of view with shocking realism:</p>
<p><img src="https://i.stack.imgur.com/X4aGT.png" alt="Shockingly Realistic 3-D Graphics" width="320" height="200"></p>
<p>But a year or two later, I got a C-64. And I was able to draw on the 40x25 character grid by cursoring around the screen, setting the color with the Ctrl key and a digit, and putting symbols anywhere I wanted <em>(why doesn't <code>bash</code> let me do that?)</em>. The character set had triangular components and solid block components.</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4.jpeg" data-download-href="https://forum.rebol.info/uploads/default/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4" title="image"><img src="https://forum.rebol.info/uploads/default/optimized/1X/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4_2_252x250.jpeg" alt="image" data-base62-sha1="1Rsurb7Q0aQ1IugNlN0VbFjgToE" width="252" height="250" srcset="https://forum.rebol.info/uploads/default/optimized/1X/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4_2_252x250.jpeg, https://forum.rebol.info/uploads/default/optimized/1X/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4_2_378x375.jpeg 1.5x, https://forum.rebol.info/uploads/default/optimized/1X/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4_2_504x500.jpeg 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">image</span><span class="informations">600Ã—593 128 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p>So I was able to reason through how one might generate a rendering of one's perspective in a grid through that medium.</p>
<p>In 2013, I found the nearly-three-decades-old spec, in spiral-bound notebook paper, about "Dungeon Construction Set":</p>
<p><img src="https://i.stack.imgur.com/WHYpo.jpg" alt="enter image description here" width="320" height="320"></p>
<p><em>(Careful readers will notice that while it's almost right, this doesn't quite hold together on the slanted parts...)</em></p>
<p>Though Treasure of Tarmin was played on a grid, the walls existed only on the <em>edges</em> of grid squares. Having learned what bytes were, I realized that if I made the map out of bytes...then each square on the map could have four possible states for each of its edges:</p>
<ol>
<li>Unobstructed</li>
<li>Wall</li>
<li>Door</li>
<li>Something Else?</li>
</ol>
<p>The design allows for the opportunity that adjacent cells would "disagree"...e.g. have a wall on one side and a door on the other.  I considered this a feature; these situations would give rise to one-way doors and walls that didn't appear until you passed through them and then turned around.</p>
<p>My idea was that a position on the map and a direction you were facing could "light up" regions on the screen...a bit like lighting up segments of a digit on an LCD.</p>
<p>But an implementation of the ideas eluded me.  It was a trickier program than I had written at the time, made even trickier because I was trying to implement it in a "machine language monitor".  I had no assembler, and the book I read didn't discuss them...just the instruction set and workings of the 6502 chip.</p>
<p>(The machine-language-monitor programs could encode single instructions into specific memory locations.  But unlike an assembler, it had no labels or other abstractions...all addresses had to be kept track of on paper.)</p>
<p>By the time I knew enough about programming that I could do something like this in an evening, I no longer cared much about the idea.  But better late than never, right?</p>
<p>Although Unicode/ASCII don't have good "seamless drawing" characters to do this like the C-64 could, it can still get the idea across.</p>
<h2><a href="https://github.com/red/red/pull/612">Originally Wrote this in Red (2013)</a></h2>
<p>I decided I'd use this relatively simple task as something where I would use Red the whole time--as opposed to writing it in Rebol2 or R3-Alpha and then porting the differences.  So that let me get a sense of where the pain points were regarding things like syntax error reporting, that sort of stuff.</p>
<p>Anyway, about a decade later, it's now a Ren-C sample.  Minor modifications were made, including taking advantage of the ReplPad's CLEAR-SCREEN ability (if running on the web).</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/enter-the-dungeon-if-you-dare/1865">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/enter-the-dungeon-if-you-dare/1865</link>
          <pubDate>Wed, 06 Jul 2022 04:59:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1865</guid>
          <source url="https://forum.rebol.info/t/enter-the-dungeon-if-you-dare/1865.rss">Enter the Dungeon ðŸ’€ ...if You Dare!</source>
        </item>
        <item>
          <title>Parsing a README.md File To Fill A Folder</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I've integrated <a class="mention" href="/u/gchiu">@gchiu</a>'s <a href="https://forum.rebol.info/t/js-testing-with-cypress-io/1778/3">Cypress Tests</a> to the GitHub workflow.</p>
<p>There's a certain number of things we want to have work before we "greenlight" a new libr3.wasm file.  Things like Graham's prescription writing app or chess demo are examples of this.</p>
<p>But we don't want the test scripts for those things to live in the Ren-C repository.  Because they need to change as the apps change--and they should also be running whenever those apps get a new commit pushed.</p>
<p>At first I just did a <strong>wget</strong> of the scripts:</p>
<pre><code>cd tests/cypress/e2e
wget https://gitlab.com/Zhaoshirong/rebol-chess/-/raw/master/cypress/e2e/chess.cy.js
wget https://raw.githubusercontent.com/gchiu/midcentral/main/cypress/e2e/rx-app.cy.js
</code></pre>
<p>But this encountered an error, because when git has a directory with no files in it...it doesn't exist.  So there was no e2e directory.</p>
<p>I could have just said <strong>mkdir tests/cypress/e2e</strong> as part of the workflow.  But I figured making a README.md file and putting it in the directory to explain what it was would be easier.</p>
<p>This gave me an idea: <em>What if I put the URLs in the README.md, and then parsed them out and fetched them?</em>  So that's what I did instead!</p>
<p><strong><a href="https://raw.githubusercontent.com/metaeducation/ren-c/master/tests/cypress/e2e/README.md">Here's the README.md</a></strong>, which has <strong><code>* https://whatever</code></strong> lines in it.</p>
<p>Then here's the script that uses the Ren-C GitHub Action:</p>
<pre><code>- name: Collect Cypress Tests from Repositories We Want to Keep Working
  uses: metaeducation/ren-c-action@release
  with:
    script: |
      cd %tests/cypress/e2e/
      list: uparse (as text! read %README.md) [
          collect some [
              '* space [keep url!] newline
            | thru newline
          ]
      ]
      for-each url list [
          filename: second split-path url
          write filename (read url)
      ]</code></pre>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/parsing-a-readme-md-file-to-fill-a-folder/1840">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/parsing-a-readme-md-file-to-fill-a-folder/1840</link>
          <pubDate>Tue, 14 Jun 2022 11:41:40 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1840</guid>
          <source url="https://forum.rebol.info/t/parsing-a-readme-md-file-to-fill-a-folder/1840.rss">Parsing a README.md File To Fill A Folder</source>
        </item>
        <item>
          <title>Demonstrating FOR-BOTH: Loop Composability For The Win :exclamation:</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>FOR-BOTH was an early talking point for an extremely simple usermode loop construct that would be built out of two FOR-EACH loops:</p>
<pre><code> &gt;&gt; for-both x [1 2] [3 4] [print [x], x = 5]
 1
 2
 3
 4
 == #[false]
</code></pre>
<p>A naive implementation of this in Rebol2 might look like:</p>
<pre><code> for-both-naive: func ['var blk1 blk2 body] [
     foreach :var blk1 body
     foreach :var blk2 body
 ]
</code></pre>
<p>...but...</p>
<ul>
<li>
<p><strong>It will not honor BREAK correctly</strong></p>
<pre><code>&gt;&gt; for-both-naive x [1 2] [3 4] [if x = 2 [break], print [x], x = 5]
1
3  ; the BREAK only broke the first FOREACH
4
== #[none]
</code></pre>
<p>There's no way from the outside of Rebol2 or Red's FOREACH to know for sure that a BREAK was requested.  BREAK returns NONE!, but a loop body can (and often does) evaluate to NONE! as well.  Red made it even worse by adding BREAK/RETURN--so a breaking loop can return <em>anything</em>.</p>
<p>So you'd need some kind of complex binding to search the loop bodies and bind the BREAK word to something that throws and gets caught...even for this simple goal.</p>
</li>
<li>
<p><strong>The loop won't evaluate to the last result of the body</strong>.</p>
<pre><code>&gt;&gt; for-both-naive x [1 2] [] [print [x], x * 10]
1  ; evaluated to 10
2  ; evaluated to 20
== #[none!]
</code></pre>
<p>If the second series is empty, the fallout from the first loop is forgotten.</p>
</li>
</ul>
<h2>Behold Ren-C's Elegant Solution to FOR-BOTH</h2>
<p><em>Underneath its apparent simplicity lies quite a lot of deep thought.</em>  And the mechanisms it uses apply far beyond just loops!</p>
<pre><code>    for-both: func ['var blk1 blk2 body] [
        return unmeta all [
            meta for-each (var) blk1 body
            meta for-each (var) blk2 body
        ]
    ]
</code></pre>
<p><em>(Note: see followup for why RETURN is necessary with FUNC, and how to avoid it with LAMBDA.)</em></p>
<h3>It solves the BREAK case</h3>
<p>Below we see a situation where the first FOR-EACH returns NULL (and <strong>meta null</strong> is just <strong>null</strong>).  So it short-circuits the ALL, and propagates the null as a signal that it broke:</p>
<pre><code>&gt;&gt; for-both x [1 2] [3 4] [if x = '2 [break], print [x], x = 5]
1
; null
</code></pre>
<p>Note that the first pass through the loop did not terminate the ALL, just because the body evaluated to false.  That's because meta of ordinary values produces QUOTED!, which is truthy even if the quoted thing is falsey.</p>
<pre><code> &gt;&gt; metafalse: meta #[false]
 == '#[false]

 &gt;&gt; type of metafalse
 == #[datatype! quoted!]

&gt;&gt; if metafalse [print "All QUOTED! are truthy!"]
All QUOTED! are truthy!
</code></pre>
<p>This means the loop can gracefully recover the QUOTED! as the ALL result if the loop completes, and remove the quoting level:</p>
<pre><code>&gt;&gt; for-both x [1 2] [3 4] [print [x], x = 5]
1
2
3
4
== #[false]
</code></pre>
<h3>It Solves the Fallout From The Last Loop Body</h3>
<p>This takes advantage of a new invariant: <em><strong>loops which never run their bodies return void</strong></em>.</p>
<pre><code>&gt;&gt; for-each x [] [fail "This body never runs"]
; void (decays to none)
</code></pre>
<p>Voids act invisibly in constructs like ALL.  So we get the result we want:</p>
<pre><code>&gt;&gt; for-both x [1 2] [] [print [x], x * 10]
1  ; evaluated to 10
2  ; evaluated to 20
== 20
</code></pre>
<p>There's a slight fib here, that META of the void did not produce a "meta-void" (<span class="mention">@void</span>)...but passed it through as it would a NULL.  That's a "user-friendly" property of the META-as-a-word form:</p>
<pre><code>&gt;&gt; meta comment "META-the-word passes through the vanishing void isotopes"
; void (decays to none)

&gt;&gt; ^ comment "The ^ operator is more exact, gives the meta signal"
== @void
</code></pre>
<p>But in situations like this, passing through the void state is what we wanted.</p>
<h3>You Can Even Return NULL From the Body!</h3>
<p>Thanks to isotopes, the following is possible:</p>
<pre><code>&gt;&gt; x: for-both x [1 2] [] [print [x], if x = 2 [null]]
1
2
== ~null~  ; isotope (decays to null)

&gt;&gt; x
; null
</code></pre>
<p>How cool is that?  Even though NULL is being reserved as the unique signal for loops breaking, there's a backchannel for it to escape...out of the FOR-EACH, and up out of the FOR-BOTH wrapping it!</p>
<h2>It Holds Up Under Scrutiny!</h2>
<p>I'm really pleased with it, and here are some tests:</p>
<p><a href="https://github.com/metaeducation/ren-c/blob/master/tests/loops/examples/for-both.loops.test.reb">https://github.com/metaeducation/ren-c/blob/master/tests/loops/examples/for-both.loops.test.reb</a></p>
<p>I invite you to test it some more...ask questions...and perhaps come up with your own loop compositions!</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/atom_symbol.png?v=9" title=":atom_symbol:" class="emoji only-emoji" alt=":atom_symbol:"></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833</link>
          <pubDate>Tue, 31 May 2022 16:02:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1833</guid>
          <source url="https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833.rss">Demonstrating FOR-BOTH: Loop Composability For The Win :exclamation:</source>
        </item>
        <item>
          <title>The Rebellion Against Style Guides</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>While driving from Huntsville to Florida, I listened to a talk given by a guy who oversees the general style guide for all of Google's multi-millions of lines of C++.</p>
<p>He spoke very positively about a formatting tool called <code>clang-format</code>, and how if he had his way at Google...there would be no arguing over code formatting.  He felt the robot did a better job on average than even the best developers...and being willing to delegate formatting to the tool gave them time to work on more important things.</p>
<p><strong>My well-known opinion for code like C++ or Rust or Java is that it is best represented as a graph data structure that captures the relationships and identities.</strong>  How you render that is up to the program you use to view and edit the projection of that essential code.  It doesn't matter if code is in braces or has a box drawn around it.  You could make expressions feed into an actual logical circuit AND gate instead of using <code>&amp;&amp;</code> or the word <code>and</code> or what-have-you.</p>
<p><strong>But Rebol is different (and almost absurdist) in the software world.</strong>  If anything, it has an <em>anti</em>-style guide, in <a href="http://www.rebol.com/article/0103.html">The Deep Lake / (Swamp)</a>, where Carl says:</p>
<blockquote>
<p>Suppose I write:</p>
<pre><code>if time &gt; 10:00 [
    wakeup user
]
</code></pre>
<p>which some users may choose to rewrite it this way:</p>
<pre><code>if time &gt; 10:00
[
    wakeup user
    alert "Time to work"
 ]
</code></pre>
<p>But, what if the "then block" is a variable itself, defined as:</p>
<pre><code> action: [
     wakeup user
     alert "Time to work"
  ]
</code></pre>
<p>Would you write this:</p>
<pre><code>  if time &gt; 10:00
      action
</code></pre>
<p>or this:</p>
<pre><code>   if time &gt; 10:00 action
</code></pre>
</blockquote>
<p>The conclusion is:</p>
<blockquote>
<p>...<strong>how you write code is ultimately your choice alone</strong>. REBOL, as a context dependent language, is perhaps the most freeform computing language ever invented.</p>
</blockquote>
<p>I'm bringing this up because I'm mothballing an old Trello and looking for any links or information worth preserving.  It had a card requesting a style guide, pointing out a limited bit that had been written in the Rebol2 manual:</p>
<p><a href="http://www.rebol.com/docs/core23/rebolcore-5.html#section-5">http://www.rebol.com/docs/core23/rebolcore-5.html#section-5</a></p>
<p>I'm really only interested in the bits that reduce complexity (like just-say-no-to-CRLF files, or tabs, etc.)  As for the code itself, this is kind of an ASCII-art medium.</p>
<p>So a good "style guide" for Rebol would be one that showed examples of how to take advantage of the degrees of freedom to be bent to your purposes.  I think a good one was the <strong><a href="https://forum.rebol.info/t/testing-generic-tuple-and-path-structuring/1353">tuple and path test dialect</a></strong>.  But there are certainly more!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-rebellion-against-style-guides/1819">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-rebellion-against-style-guides/1819</link>
          <pubDate>Sat, 14 May 2022 05:39:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1819</guid>
          <source url="https://forum.rebol.info/t/the-rebellion-against-style-guides/1819.rss">The Rebellion Against Style Guides</source>
        </item>
        <item>
          <title>My Summary of the Big Picture</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>First Steps</category>
          <description><![CDATA[
            <p>I wrote this to someone in a GitHub issue and thought it was pretty salient:</p>
<blockquote>
<p>What has drawn people to Rebol historically has varied. But a large number who praised it and used it were less interested in the language itself, rather the properties of the executable. It was small, and you could run on any OS without installing anything else...it came with a GUI built in.</p>
<p>But when serious language theorists look at Rebol, they notice it is riddled with design holes. The language itself wasn't <em>composable</em> the way one might like languages to be: mixing constructs in new ways that weren't specifically accounted for never worked. It was more like a "scriptable app" that had a few features that pleased its userbase...and had to be extended by the designer every time a new need came up.</p>
<p>So put briefly: If you don't understand what these holes are, then you won't appreciate the many issues that Ren-C is trying to solve.</p>
<p>Once you know that historical Rebol was fundamentally broken, there are basically 3 choices:</p>
<ol>
<li>Inventory and address the holes one at a time and try to fix or mitigate them</li>
<li>Ignore the holes and just hope that if you add enough features and integration no one will notice</li>
<li>Turn away and run from the crackpots using it, and work with a more solidly designed language</li>
</ol>
<p>(1) is Ren-C's hard-chosen path. Energy is spent on identifying certain patterns in source that users <em>must</em> be able to write and have work, if the language is to justify its existence at all. While it would be nice if stack traces were beautiful and if building the sources was 100% easy, all of that would be meaningless if the punch line was <em>"oh, and the language this is all supporting doesn't actually work"</em></p>
<p>(2) is chosen by people like Red and <a href="https://github.com/Oldes/Rebol3">Oldes's branch of R3-Alpha</a>, as well as some clones that have popped up over the years. Starting from scratch inevitably makes the same mistakes.</p>
<p>(3) is probably the most sensible choice, but if I didn't think there was some promise in the language I wouldn't be pursuing (1).</p>
</blockquote>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/my-summary-of-the-big-picture/1792">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/my-summary-of-the-big-picture/1792</link>
          <pubDate>Fri, 18 Feb 2022 19:37:40 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1792</guid>
          <source url="https://forum.rebol.info/t/my-summary-of-the-big-picture/1792.rss">My Summary of the Big Picture</source>
        </item>
        <item>
          <title>Turning a Blind Eye to Evaluator &quot;Abuse&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>I've gotten kind of attached to the current look and behavior of AND and OR, which allow short-circuiting even though one would not think the language could (should?) be able to.</p>
<p>It doesn't require simple variables be in a GROUP! on the right hand side.</p>
<pre><code>&gt;&gt; if true and true [print "True"] else [print "False"]
True
</code></pre>
<p>...but a function call has to be.</p>
<pre><code>&gt;&gt; foo: func [x] [
      print "Calling foo!"
      return x &gt; 1000
   ]

&gt;&gt; if false and foo 1020 [print "True!"] else [print "False"]
** Error: words/tuples can't be ACTION! as right hand of OR, AND, XOR

&gt;&gt; if false and (foo 1020) [print "True"] else [print "False"]
False

&gt;&gt; if true and (foo 1020) [print "True!"] else [print "False"]
Calling foo!
True
</code></pre>
<p><em>Note that if the thing to the left of the AND is false, it does not run the code in the GROUP! on the right.</em>  This requires that the right hand side be a quoted parameter convention.</p>
<p>Alternatively we could not quote it, and require the right hand side be in a block:</p>
<pre><code>&gt;&gt; if true and [true] [print "True"] else [print "False"]
True

&gt;&gt; if false and [foo 1020] [print "True"] else [print "False"]
False
</code></pre>
<p><strong>But I don't like that.</strong></p>
<p>Alternatively we could say we don't offer this and you always use ALL...maybe with COMMA! and maybe not:</p>
<pre><code>&gt;&gt; if all [true true] [print "True"] else [print "False"]
True

&gt;&gt; if all [false, foo 1020] [print "True"] else [print "False"]
False
</code></pre>
<p>I just don't think that looks as natural.</p>
<h2>It's Like I Said In <a href="https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359">"Speaking With Tics"</a>...</h2>
<p>If you think seeing a GROUP! on the right of AND and OR that doesn't unconditionally evaluate at the callsite is weird, why are you comfortable with <strong><code>for-each x [1 2 3] [...]</code></strong>?  That didn't unconditionally evaluate x.  Do you expect it to be <strong><code>for-each 'x</code></strong> instead?</p>
<aside class="quote no-group">
<blockquote>
<p>The quoted parameter convention exists to save you the trouble of quoting the callsites. <em>If this isn't what that's for, then what <strong>is</strong> it for?</em></p>
</blockquote>
</aside>
<p>It's just too nice to be able to say things like <strong><code>if var1 and var2 or (a &gt; b) [...]</code></strong>.</p>
<p>To me, part of what makes the language special is the ability to bend the evaluator to how we want to read code, vs bending code to fit the evaluator.  The existence of mechanics like quoted parameters are there to let this happen.</p>
<p><em>You don't have to use it.</em>  And the ability to switch it to where AND is a prefix operator that does bitwise math is the magic of the freedom of choice.  You can choose to change the definition even on a module-by-module basis, or on a function-by-function basis.</p>
<p>Further: if you're not bending the language, you're probably not really using it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/turning-a-blind-eye-to-evaluator-abuse/1791">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/turning-a-blind-eye-to-evaluator-abuse/1791</link>
          <pubDate>Fri, 18 Feb 2022 18:34:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1791</guid>
          <source url="https://forum.rebol.info/t/turning-a-blind-eye-to-evaluator-abuse/1791.rss">Turning a Blind Eye to Evaluator &quot;Abuse&quot;</source>
        </item>
        <item>
          <title>Understanding Definitional Scoping</title>
          <dc:creator><![CDATA[DefinitionalUsername]]></dc:creator>
          <category>First Steps</category>
          <description><![CDATA[
            <p>I just started learning Red/Rebol, and I was having trouble understanding the scoping rules. I did read the <a href="https://stackoverflow.com/a/21964858" rel="noopener nofollow ugc">Stack Overflow</a> and <a href="https://en.wikibooks.org/wiki/Rebol_Programming/Advanced/Bindology" rel="noopener nofollow ugc">Bindology</a>, and I think I somewhat understand, but I'm not sure! I'd be grateful if someone can confirm the my deductions about the following code from the SE post:</p>
<pre><code class="lang-auto">rebol []

a: 1

func-1: func [] [a]

inner: context [
    a: 2
    func-2: func [] [a]
    func-3: func [/local a] [a: 3 func-1]
]

reduce [func-1 inner/func-2 inner/func-3]
</code></pre>
<ol>
<li>
<strong>Compile-time:</strong> First, when the code is compiled, a list of top-level names is created. <em>(<code>a</code>, <code>func-1</code>, <code>inner</code>)</em>
</li>
<li>
<strong>Load-time:</strong> When the code is loaded, context <strong>A</strong> is created with those symbols as members. Also, the entire code is walked through, and every occurrence of those symbols is bound to these entries. <em>(e.g., <code>a</code> inside <code>func-2</code> would be bound to the top-level <code>a</code>)</em>
</li>
<li>
<strong>Run-time:</strong> When <code>a: 1</code> is executed, the value <code>1</code> is stored in the <code>a</code>'s slot in the context.</li>
<li>The <code>func</code> keyword after <code>func-1:</code> creates a new function, and assigns it to <code>func-1</code>. However, it leaves the binding of <code>a</code> intact.</li>
<li>The <code>context</code> keyword after <code>inner:</code> creates a new context <strong>B</strong>, walks over all the block, collecting all new symbols, and inserts those in the new object.</li>
<li>
<code>a: 2</code> assigns value <code>2</code> in <code>a</code>'s slot in the new context.</li>
<li>
<code>func</code> after <code>func-2:</code> creates a function while keeping <code>a</code>'s new binding intact, and assigns it to <code>func-2</code>'s slot.</li>
<li>
<code>func</code> after <code>func-3:</code> creates a function and creates a new context <strong>C</strong> in which <code>a</code> is inserted and bound.</li>
<li>Upon execution of <code>reduce</code>, <code>func-1</code> returns <code>1</code> from context <strong>A</strong>, <code>func-2</code> return <code>2</code> from context <strong>B</strong>, and <code>func-3</code> executes <code>func-1</code> which returns <code>1</code> from context <strong>A</strong> again.</li>
</ol>
<p>So, now,  a few questions:</p>
<ul>
<li>Is the above correct? If it is,</li>
<li>How does the <code>context</code> keyword determine which set-words it should create a slot for? i.e.,
<ul>
<li>if <code>a: 2</code> didn't exist, will it still create the slot for <code>a</code> due to <code>a: 3</code> deep inside?</li>
<li>What about if <code>a:3</code> didn't exist either? Will the new context contain a slot for <code>a</code> just due to <code>a</code> inside <code>func-2</code>'s body?</li>
</ul>
</li>
<li>Did <code>context</code> bind <code>a</code> in <code>[/local a]</code> too, before <code>func</code> was executed?</li>
<li>When a new context is created, does it copy existing symbols or bindings from the older context? If not,</li>
<li>Is there a parent-child relationship between contexts, or are they free-standing? Given a context, can I chase some pointer to its parent or child?</li>
</ul>
<p>Sorry for so many questions, I think I am getting extra confused since I already have programming experience and need to unlearn some stuff before being able to grok Rebol.</p>
<p>Thank you.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/understanding-definitional-scoping/1785">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/understanding-definitional-scoping/1785</link>
          <pubDate>Sat, 22 Jan 2022 08:13:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1785</guid>
          <source url="https://forum.rebol.info/t/understanding-definitional-scoping/1785.rss">Understanding Definitional Scoping</source>
        </item>
        <item>
          <title>Prettier TLS State Tables (and Assessing the Cost)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>So the spec-driven TLS originally had this state table.  On the left are states and on the right is a block of the legal states you can transition to from that state (if any).</p>
<p>Here are the states for a TLS read:</p>
<pre><code>read-proto-states: [
    client-hello [server-hello]
    server-hello [certificate]
    certificate [server-hello-done server-key-exchange]
    server-key-exchange [server-hello-done]
    server-hello-done [#complete]
    finished [change-cipher-spec alert]
    change-cipher-spec [encrypted-handshake]
    encrypted-handshake [application #complete]
    application [application alert #complete]
    alert [#complete]
    close-notify [alert]
]
</code></pre>
<p><em>It seemed to me this wasn't exploiting the types all that well.</em>  We see an ISSUE! being used for <span class="hashtag">#complete</span>.  I imagined it would be better to move the issue annotation onto the state itself: <strong>If a state was represented by an ISSUE!, then that meant the state could legally be transitioned to the completion state.</strong></p>
<p>So instead of:</p>
<pre><code>encrypted-handshake [application #complete]
</code></pre>
<p>That would become:</p>
<pre><code>#encrypted-handshake [#application]
</code></pre>
<p>(Since the application state could be terminal as well.)</p>
<p>Now you know just by looking at it that <span class="hashtag">#encrypted-handshake</span> is a <em>potentially-terminal state</em>...and that's everywhere that encrypted-handshake appears.  It's not that much more typing, since you have to put an apostrophe on most uses anyway...and it helps the state "stand out".</p>
<p>Plus making the non-terminal states stand out would be good, so I turned them into tags.</p>
<p><strong>I also thought that the blocks looked a bit boring, and I didn't like having to put single elements into blocks just for the convenience of the implementation.</strong>  I tried adding arrows and letting single elements stand alone on the mapped-to side:</p>
<pre><code>read-proto-states: [
    &lt;client-hello&gt;          -&gt; &lt;server-hello&gt;
    &lt;server-hello&gt;          -&gt; &lt;certificate&gt;
    &lt;certificate&gt;           -&gt; [#server-hello-done &lt;server-key-exchange&gt;]
    &lt;server-key-exchange&gt;   -&gt; #server-hello-done
    &lt;finished&gt;              -&gt; [&lt;change-cipher-spec&gt; #alert]
    &lt;change-cipher-spec&gt;    -&gt; #encrypted-handshake
    #encrypted-handshake    -&gt; #application
    #application            -&gt; [#application #alert]
    #alert                  -&gt; []
    &lt;close-notify&gt;          -&gt; #alert
]
</code></pre>
<p>Of course, this needs to be parsed into a MAP!, so we need some code like:</p>
<pre><code>transitions: make map! []  ; map from states to block of states
state-rule: [tag! | issue!]
uparse transdialect [
    while [
        left: state-rule '-&gt; right: [
            into block! [while state-rule, &lt;input&gt;]
            | collect keep state-rule
        ]
        (append transitions :[left right])
    ]
]
</code></pre>
<h2>Improvement...Or Dialecting For The Sake of Dialecting?</h2>
<p>The general question of whether or not to use things like ISSUE! and TAG! for states as opposed to the "cleaner" WORD!s is something that is a bit controversial.</p>
<p>One issue is that there's traditionally a greater cost to comparing strings than there is to comparing words.  So <strong>state = <span class="hashtag">#encrypted-handshake</span></strong> is slower than <strong>state = 'encrypted-handshake</strong>.  The worst case scenario is equality--because all the characters have to be compared to decide if they are equal.</p>
<p>I'd like to focus more on the qualities of the source representation than worry about the performance however.</p>
<p>There's certainly a point of view where the original wasn't as "noisy".  But if you take the extreme opinion of using WORD! for everything, then the code all blurs together.</p>
<h2>Parsing Has The Benefit Of Validation</h2>
<p>When you stylize your input and do some processing of it to get it into a canonized form, that process of translating your input is a chance to check that the data is what you expect.</p>
<p>Using a generic structure doesn't just keep you from throwing in "superficial" flourishes like <strong><code>-&gt;</code></strong>, but the generality usually goes with accepting anything.  Once you have a processing step that puts you in the position of being able to validate...which is a powerful thing.</p>
<h2>I Think These Kinds of Things Are "The Point"</h2>
<p>I don't know if this particular example is the best example.  But I do think that this is what PARSE is meant for, and UPARSE is pushing things to a new level.  We should be looking for opportunities to show off this kind of idea, vs just doing what other languages do in a weird way.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/prettier-tls-state-tables-and-assessing-the-cost/1736">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/prettier-tls-state-tables-and-assessing-the-cost/1736</link>
          <pubDate>Sun, 03 Oct 2021 17:29:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1736</guid>
          <source url="https://forum.rebol.info/t/prettier-tls-state-tables-and-assessing-the-cost/1736.rss">Prettier TLS State Tables (and Assessing the Cost)</source>
        </item>
        <item>
          <title>Regarding The &quot;Finality&quot; Of FAIL, RETURN, etc.</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>There are some functions that by name carry a certain <em>"finality"</em>.  You don't expect there to be a way to pass them an argument that will revoke them.</p>
<p>For instance, it would be a bit weird if FAIL followed the BLANK-IN, NULL-OUT convention:</p>
<pre><code>foo: func [error [error! blank!]] [
    fail error

    print "This looks like unreachable code."
]
</code></pre>
<p>Today we don't offer that Wayne's World version of "FAIL.... NOT!"  So you have to write:</p>
<pre><code>if error [fail error]
</code></pre>
<p>I've actually been in situations where repeating the error expression is complicated by things like API handle freeing issues, to where I've considered making something like MAYBE-FAIL which would be a No-Op on BLANK!... or perhaps a refinement as FAIL/MAYBE.</p>
<p>But I've not considered the idea of making plain FAIL a no-op on blanks.  That seems wrong.</p>
<h2>Does RETURN Have A Similar "Finality"?</h2>
<p>I've written a bunch about <a href="https://forum.rebol.info/t/uparse-return-subtleties/1589/4">how I stopped worrying and learned to love UPARSE's RETURN</a>.</p>
<p>But there's something a little weird to my tastes about it being "non-final".  For example:</p>
<pre><code>&gt;&gt; uparse "aabc" [some "a" return "x" | some "a" return "b"]
== "b"  ; today's answer (also R3-Alpha's answer with PARSE)
</code></pre>
<p>When it reached the point of RETURN "X", there were two potential interpretations:</p>
<ol>
<li>
<p><em>"Okay, it's time to return!  Let's see if this rule matches or not...and if not, we're returning NULL!"</em></p>
</li>
<li>
<p><em>"It might be time to return if this rule matches.  If it doesn't match, pretend we were never asked to return."</em></p>
</li>
</ol>
<p>Today we have (2).  It's strictly more powerful... as you can get (1) with <strong>return opt "x"</strong>.</p>
<pre><code>&gt;&gt; uparse "aabc" [some "a" return opt "x" | some "a" return opt "b"]
; null
</code></pre>
<p>Note also that if your RETURN value is in a GROUP! and evaluated as DO code instead of a rule, it will always succeed...and hence always final.  It's only when you pass a rule that it can get revoked.</p>
<p>As with needing to write <strong>if error [fail error]</strong>, if we switched to parse-RETURN-finality that would mean more code for opting out:</p>
<pre><code>; opting out in RETURN-non-final style
uparse data [... return [your rule here] ...]

; opting out in RETURN-final style
uparse data [... result: [your rule here] return (result) ...]
</code></pre>
<p><strong>But I still feel weird about RETURN in PARSE being something that can just be opted out of by the nature of its argument.</strong></p>
<p>And so far, every time I've wanted to use RETURN it has been either a RETURN of a GROUP! (thus unconditional) or a RETURN OPT.</p>
<p>So I'm thinking of making RETURN "final"...if you give it a rule that doesn't match it returns NULL.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/regarding-the-finality-of-fail-return-etc/1735">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/regarding-the-finality-of-fail-return-etc/1735</link>
          <pubDate>Sun, 03 Oct 2021 15:49:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1735</guid>
          <source url="https://forum.rebol.info/t/regarding-the-finality-of-fail-return-etc/1735.rss">Regarding The &quot;Finality&quot; Of FAIL, RETURN, etc.</source>
        </item>
        <item>
          <title>There Came an ECHO</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>I just fixed a bug in Sea of Words...which hopefully means it's a little more trustworthy.</p>
<p>It seemed like a good time to add the ECHO feature I've talked about.</p>
<pre><code>&gt;&gt; echo It's this feature, which I've described in the past.
It's this feature, which I've described in the past.
</code></pre>
<p>ECHO is a variadic function which processes what you pass it to the end of line.  If you prefer, you can also use a BLOCK!.</p>
<pre><code>&gt;&gt; echo [A block allows
    you to put an arbitrary number
    of newlines]
A block allows you to put an arbitrary number of newlines

&gt;&gt; echo [Or two echos] echo [on the same line]
Or two echos
on the same line
</code></pre>
<p>There is a variable substitution mechanism so you can use @ to point out variables or expressions.</p>
<pre><code>&gt;&gt; x: 10
&gt;&gt; echo The value is @x
The value is 10

&gt;&gt; echo The doubled value is @(x * 2)
The doubled value is 20
</code></pre>
<h2>It's Shorter!</h2>
<p>Can't argue against that.</p>
<pre><code>print ["You have written" num-lines "lines of code."]

echo [You have written @num-lines lines of code.]

echo You have written @num-lines of code.
</code></pre>
<h2>The API Benefits</h2>
<p>Not needing quotes helps API calls:</p>
<pre><code>rebElide("print [{You have written}", num_lines, "{lines of code.}]");

rebElide("echo [You have written", num_lines, "lines of code.]");

rebElide("echo You have written", num_lines, "lines of code.");
</code></pre>
<p>It's the kind of change that opens up the choose-your-own-adventure of syntax to let you build a system more like bash, or less like bash.  It's an important decoupling of the use of words from the creation of variables.  So, onward.</p>
            <p><small>8 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/there-came-an-echo/1722">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/there-came-an-echo/1722</link>
          <pubDate>Sun, 19 Sep 2021 17:05:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1722</guid>
          <source url="https://forum.rebol.info/t/there-came-an-echo/1722.rss">There Came an ECHO</source>
        </item>
        <item>
          <title>Running into issues with PARSE</title>
          <dc:creator><![CDATA[RayMPerry]]></dc:creator>
          <category>First Steps</category>
          <description><![CDATA[
            <p>Hi. I'm new to Ren-C and have been trying to get this simple parser to work.</p>
<p>(For context, <code>MOCK_DATA.csv</code> contains 1000 rows of "First Name, Last Name, Email, Date of Birth".)</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/f541999fd2a7af1257d0701a8d2ceb52c3e9bf5c.png" data-download-href="https://forum.rebol.info/uploads/default/f541999fd2a7af1257d0701a8d2ceb52c3e9bf5c" title="2021-09-12_22-23"><img src="https://forum.rebol.info/uploads/default/optimized/1X/f541999fd2a7af1257d0701a8d2ceb52c3e9bf5c_2_690x196.png" alt="2021-09-12_22-23" data-base62-sha1="yZDwIV9AxGIyq4mlMnwWFR32k1e" width="690" height="196" srcset="https://forum.rebol.info/uploads/default/optimized/1X/f541999fd2a7af1257d0701a8d2ceb52c3e9bf5c_2_690x196.png, https://forum.rebol.info/uploads/default/optimized/1X/f541999fd2a7af1257d0701a8d2ceb52c3e9bf5c_2_1035x294.png 1.5x, https://forum.rebol.info/uploads/default/optimized/1X/f541999fd2a7af1257d0701a8d2ceb52c3e9bf5c_2_1380x392.png 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/f541999fd2a7af1257d0701a8d2ceb52c3e9bf5c_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">2021-09-12_22-23</span><span class="informations">1604Ã—456 56.2 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p>The questions I have are:</p>
<ol>
<li>How do I read this error?</li>
<li>Where should I be looking for valid words/syntax?</li>
</ol>
<p>Thanks in advance.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/running-into-issues-with-parse/1716">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/running-into-issues-with-parse/1716</link>
          <pubDate>Mon, 13 Sep 2021 03:28:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1716</guid>
          <source url="https://forum.rebol.info/t/running-into-issues-with-parse/1716.rss">Running into issues with PARSE</source>
        </item>
        <item>
          <title>Taking Advantage of DELIMIT&#39;s BLOCK! Behavior and GET-BLOCK!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I finally put my foot down and said that BLOCK! in DELIMIT has the behavior of <em><strong>don't evaluate, just squoosh everything together.</strong></em></p>
<pre><code>&gt;&gt; spaced ["abc" [d e "f"] "ghi"]
== "abc def ghi"
</code></pre>
<p>You can always REDUCE if you want evaluations, but there's also GET-BLOCK!...</p>
<pre><code>&gt;&gt; spaced ["abc" :["something" 1 + 2] "ghi"]
== "abc something3 ghi"
</code></pre>
<p>And with the magic of GET-BLOCK! branches, you can even opt in or out of these things!  Don't forget to use COMMA! if you think it will look better...</p>
<pre><code>&gt;&gt; spaced ["abc" if true :["something" 1 + 2] "ghi"]
== "abc something3 ghi"

&gt;&gt; spaced ["abc", if false :["something" 1 + 2], "ghi"]
== "abc ghi"
</code></pre>
<h2>Let's Look At What Old Code Had To Do</h2>
<p>Here's some code for making a log file name from pieces in the tests:</p>
<pre><code>log-file: log-file-prefix

if code-checksum [
    append log-file "_"
    append log-file copy/part skip mold code-checksum 2 6
]

append log-file "_"
append log-file copy/part skip mold test-checksum 2 6

append log-file ".log"
log-file: clean-path log-file
</code></pre>
<p>How about we tidy that up?</p>
<h2>Here Is What We Can Confidently Write In The New Way</h2>
<pre><code>log-file: clean-path unspaced [
    log-file-prefix
        if code-checksum :["_", copy/part (skip mold code-checksum 2) 6]
        "_", copy/part (skip mold test-checksum 2) 6, ".log"
]
</code></pre>
<p><strong>Not only is it cleaner, it's more efficient!</strong>  This lets us build as we go along, without having to keep expanding string memory on each APPEND...fewer function calls.  It's better all around!</p>
<p>I think we can make a JOIN using the "REPEND" replacement optimization equally efficient:</p>
<pre><code>log-file: clean-path join log-file-prefix :[
    if code-checksum :["_", copy/part (skip mold code-checksum 2) 6]
    "_", copy/part (skip mold test-checksum 2) 6, ".log"
]
</code></pre>
<h2>It Could Be Even More Efficient, If We Wanted...</h2>
<p>Given the GET-BLOCK! optimizations, a minor tweak could boost things:</p>
<pre><code>log-file: clean-path unspaced [
    log-file-prefix
        if code-checksum ':["_", copy/part (skip mold code-checksum 2) 6]
        "_", copy/part (skip mold test-checksum 2) 6, ".log"
]
</code></pre>
<p>It's a subtle difference, but we're having the IF statement evaluate to a GET-BLOCK!...instead of having a branch that evaluates a GET-BLOCK! to make a block.</p>
<p>We can make DELIMIT evaluate get-blocks as it goes, folding them into the output without generating intermediate series...much like REPEND.</p>
<p>This could be a little wild, in terms of performing evaluations when you didn't intend them:</p>
<pre><code>data: [a b c :[format hard drive]]

...

for-each item data [
    print ["The value is" data]
]
</code></pre>
<p>But that's really just the tip of the iceberg on how many ways the system is not safe against injection attacks.  But if you're working in a secure situation, you could use a guarded layer whenever dealing with external data, to limit execution.  I think that concept (which I have called "Build Your Own Safety") is likely what people who want to use the language in more secure scenarios would have to do.</p>
<p>(After all, even the most secure programs have to at some point run on an "insecure" CPU.  A flexible and fast Ren-C could be the basis for designing a more secure language on top of it...)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/taking-advantage-of-delimits-block-behavior-and-get-block/1679">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/taking-advantage-of-delimits-block-behavior-and-get-block/1679</link>
          <pubDate>Mon, 23 Aug 2021 01:10:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1679</guid>
          <source url="https://forum.rebol.info/t/taking-advantage-of-delimits-block-behavior-and-get-block/1679.rss">Taking Advantage of DELIMIT&#39;s BLOCK! Behavior and GET-BLOCK!</source>
        </item>
        <item>
          <title>APPLY II: The Revenge!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1406">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/design-issues-for-new-apply/1406/1">Design Issues for New APPLY</a>
</div>
<blockquote>
<p>It's time to bring back APPLY</p>
</blockquote>
</aside>
<p>...and by *"it's time" I apparently meant <em>"within the next year, maybe"</em>...</p>
<p>But better late than never, right?  It's in!</p>
<h2>Refinements Can be Provided In Any Order</h2>
<pre><code>[a b c d e d e] = apply :append [[a b c] [d e] /dup 2]
[a b c d e d e] = apply :append [/dup 2 [a b c] [d e]]
[a b c d e d e] = apply :append [[a b c] /dup 2 [d e]]

[a b c d d] = apply :append [/dup 2 [a b c] [d e] /part 1]
[a b c d d] = apply :append [[a b c] [d e] /part 1 /dup 2]
</code></pre>
<h2>Any Parameter (Not Just Refinements) Can Be Used By Name</h2>
<p>Once a parameter has been supplied by name, it is no longer considered for consuming positionally.</p>
<pre><code>[a b c d e] = apply :append [/series [a b c] /value [d e]]
[a b c d e] = apply :append [/value [d e] /series [a b c]]

[a b c d e] = apply :append [/series [a b c] [d e]]
[a b c d e] = apply :append [/value [d e] [a b c]]
</code></pre>
<h2>Commas Are Ok So Long As They Are Interstitial</h2>
<pre><code>[a b c d e d e] = apply :append [[a b c], [d e], /dup 2]
[a b c d e d e] = apply :append [/dup 2, [a b c] [d e]]

&gt;&gt; apply :append [/dup, 2 [a b c] [d e]]
** Script Error: end was reached while trying to set /dup
</code></pre>
<h2>Giving Too Many Arguments Is An Error</h2>
<pre><code>&gt;&gt; apply :append [[a b c] [d e] [f g]]
** Script Error: Too many values in processed argument block of APPLY.
</code></pre>
<h2>Refinements Must Be Followed By A Non-Refinement</h2>
<pre><code>&gt;&gt; apply :append [/dup /part 1 [a b c] [d e]]
** Script Error: end was reached while trying to set /dup
</code></pre>
<p>But you can pass refinements as arguments to refinements...just use a quote!</p>
<pre><code>&gt;&gt; tester: func [/refine [any-value!]] [refine]

&gt;&gt; apply :tester [/refine '/ta-da!]
== /ta-da!
</code></pre>
<h2>No-Arg Refinements Permit LOGIC! But Set NULL or <code>#</code>
</h2>
<p>Remember: <em>the DO FRAME! mechanics do not change anything, besides ~unset~ isotopes being turned to NULLs.</em>  So if a refinement doesn't take an argument, <a href="https://forum.rebol.info/t/why-no-argument-refinements-are-blackhole-or-null/735">the only legal values for that refinement in the frame are # and NULL</a>.</p>
<p>But APPLY isn't DO FRAME!.  It's a higher level thing that builds a frame from the values you supply, and then has an opportunity to look over them before running DO FRAME!.  So if it sees you gave a #[true] or a #[false] to a refinement with no argument, it will adjust it appropriately.</p>
<pre><code>&gt;&gt; testme: func [/refine] [refine]

# = apply :testme [/refine #]
null = apply :testme [/refine null]

# = apply :testme [/refine true]
null = apply :testme [/refine false]
</code></pre>
<h2>^META Arguments Are Also Accounted For</h2>
<p>For those following <a href="https://forum.rebol.info/t/default-values-and-make-frame/1412">the profound design points</a>, the DO FRAME! mechanic does not allow you to have isotopes in frame slots.  The way you get isotopes through to a function is through meta parameters, and by convention those parameters are quoted or otherwise "leveled up" into non-isotope status.</p>
<p>But as another convenience, APPLY detects when a parameter is meta and will level it up...because the low-level frame mechanics aren't allowed to editorialize:</p>
<pre><code>&gt;&gt; non-detector: func [arg] [arg]  ; not a meta argument, isotopes illegal

&gt;&gt; apply :non-detector [~baddie~]
** Script Error: non-detector needs arg as ^META for ~baddie~ isotope

&gt;&gt; detector: func [^arg] [arg]

&gt;&gt; apply :detector [~baddie~]
== ~baddie~
</code></pre>
<p><strong>I know not everyone has gotten their heads around isotopes yet, but they are critical... this stuff was the missing link to making it all gel.</strong></p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/dizzy.png?v=9" title=":dizzy:" class="emoji only-emoji" alt=":dizzy:"> <img src="https://forum.rebol.info/images/emoji/twitter/dizzy.png?v=9" title=":dizzy:" class="emoji only-emoji" alt=":dizzy:"> <img src="https://forum.rebol.info/images/emoji/twitter/dizzy.png?v=9" title=":dizzy:" class="emoji only-emoji" alt=":dizzy:"></p>
<h1>What's Next?!  Making It Easier To Use!</h1>
<p>Imagine if we let <strong><code>&lt;-</code></strong> be an infix operator...taking the name of the function to apply on the left, and a block on the right:</p>
<pre><code>&lt;-: enfix func [
    'action [word! tuple! path! group!]
    args [block]
][
    apply (if group? action [do action] else [get action]) args
]
</code></pre>
<p>It's rather slick!</p>
<pre><code>&gt;&gt; append &lt;- [[a b c] &lt;d&gt; /dup 2]
== [a b c &lt;d&gt; &lt;d&gt;]

&gt;&gt; append/only &lt;- [[a b c] [e f] /dup 2]
== [a b c [e f] [e f]]
</code></pre>
<p>Of course, you can mix it up with your own freaky ideas, even variadic ones!</p>
<pre><code>&gt;&gt; $: enfixed func ['name [word!] 'args [&lt;variadic&gt; &lt;end&gt; any-value!]] [
    args: make block! args
    apply :(get name) args
]

&gt;&gt; data: [a b c]

&gt;&gt; (append $ /dup 2, data [d e])

&gt;&gt; print ["data is" mold data]
data is [a b c d e d e]
</code></pre>
<p>The choice is up to you.  Which is what all this is about!</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/apply-ii-the-revenge/1834">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/apply-ii-the-revenge/1834</link>
          <pubDate>Tue, 17 Aug 2021 07:58:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1834</guid>
          <source url="https://forum.rebol.info/t/apply-ii-the-revenge/1834.rss">APPLY II: The Revenge!</source>
        </item>
        <item>
          <title>Isotopic WORD!s For More Informative States in TLS</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>When introducing isotopic WORD!s, I wrote:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1383">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/lingering-idea-labeled-ornery-word-s/1383/1">Lingering Idea: Labeled "Ornery" WORD!s</a>
</div>
<blockquote>
<p>Since these can be used as a kind of deferred error--a bad result that's only there to be bad if you actually use it--the text in these words could help guide you to what happened.</p>
</blockquote>
</aside>
<p>Today I hit a good example.  I was going over some stuff in the TLS code, and found this:</p>
<pre><code>; Each encrypted message in TLS 1.1 and above carry a plaintext
; initialization vector, so the ctx does not use one for the whole
; session.  Unset it to make sure.
;
unset in ctx 'client-iv
unset in ctx 'server-iv
</code></pre>
<p>So in TLS 1.0 mode, there is a single "iv" (initialization vector) reused for the client and server over the whole session.  But you don't want to use those fields in TLS 1.1 and above, because you're supposed to be using the data from each message.</p>
<p>The historical trick to catch unwanted reads of these fields was to unset them.</p>
<ul>
<li>
<p>It was awkward to do so...since UNSET!s couldn't be assigned via SET-WORD!</p>
</li>
<li>
<p>Also, it didn't communicate any information besides "unset"</p>
</li>
</ul>
<p>Today, you can painlessly get the effect...with a more meaningful error on access!</p>
<pre><code>ctx.client-iv: ctx.server-iv: ~per-message~
</code></pre>
<p>So if you get an error on trying to access these variables, it will tell you its the isotopic WORD! of <strong>~per-message~</strong>.  You can look that up in the source or get the gist of what it means.</p>
<p><em>(I'm still thinking about how we might put the file and line number into the value itself, so you could find this assignment and get at the origin of the value!)</em></p>
<p>Using isotopes effectively is a lot of bang for the buck.  Neat stuff!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/isotopic-word-s-for-more-informative-states-in-tls/1933">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/isotopic-word-s-for-more-informative-states-in-tls/1933</link>
          <pubDate>Sun, 15 Aug 2021 12:44:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1933</guid>
          <source url="https://forum.rebol.info/t/isotopic-word-s-for-more-informative-states-in-tls/1933.rss">Isotopic WORD!s For More Informative States in TLS</source>
        </item>
        <item>
          <title>A Lot To UNPACK: (Replacing the SET of REDUCE BLOCK! Idiom)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>We've fretted a lot about the result of REDUCE when an expression produces something that can't be put in a block.  At first this was just NULL.  But now it's all BAD-WORD! isotope forms.</p>
<p>One reason to fret is the historical idiom of setting multiple values in a block.  This has been done with a SET of a REDUCE.  Something along the lines of:</p>
<pre><code>&gt;&gt; x: 3 + 4
== 7

&gt;&gt; set [a b] reduce [10 + 20 x]
== [30 7]

&gt;&gt; a
== 30

&gt;&gt; b
== 7
</code></pre>
<p>It's your choice to reduce the values or not.  If you don't involve REDUCE then the mechanics would all work out.  But once you get NULLs and isotopes, the reduced block can't store the values to convey them to the SET...</p>
<h2>But What If A Single Operation Did Both...?</h2>
<p>Let's imagine we have instead something called UNPACK that by default reduces.  Imagine it quotes a SET-BLOCK! on its left.</p>
<pre><code>&gt;&gt; x: 3 + 4
== 7

&gt;&gt; [a b]: unpack [10 + 20 x]
== 30

&gt;&gt; a
== 30

&gt;&gt; b
== 7
</code></pre>
<p>UNPACK manages the evaluation one expression at a time, instead of using REDUCE.  So as it goes it can set the variables to NULL or isotopes.  And by following the multi-return convention of returning the first value, you avoid ever needing to synthesize a block aggregating all the results together.</p>
<pre><code>&gt;&gt; [a b]: unpack case [
       1 = 1 [
           print "This is pretty slick..."
           [select [a 10] 'b, 1 + 2]
       ]
    ] else [
        print "This won't run because the ELSE gets a BLOCK!"
        print "Which is what you want, because the ELSE should be"
        print "what runs if no CASE was matched and have the option"
        print "of providing the block to UNPACK"
    ]
 This is pretty slick...
 ; null

&gt;&gt; a
; null

&gt;&gt; b
== 3
</code></pre>
<h2>@[...] can Even Avoid A REDUCE</h2>
<p>If you already have a block in reduced or literal form, how would you tell the UNPACK about that?  It could be a refinement like UNPACK/ONLY.  BUT...what if that were signaled with the @ block type?</p>
<pre><code>&gt;&gt; [a b]: unpack @[1 +]
== 1

&gt;&gt; a
== 1

&gt;&gt; b
== +
</code></pre>
<p>A real aspect of power in this approach is the ability to mix and match.  For instance you could have some branches in a CASE which have already reduced data and others that don't, and they could all participate with the same UNPACK operation.</p>
<pre><code>[op1 op2]: unpack case [
    ... [
        print "This branch uses values as-is"
        @[+ -]
    ]
    ... [
       print "This branch needs evaluation"
       [operators.1, pick [- /] op-num]
   ]
]
</code></pre>
<h2>Cool Dialecting Twists</h2>
<p>It seems to me nice to safeguard that you're not throwing away values:</p>
<pre><code>&gt;&gt; [a b]: unpack [1 2 3]
** Error: Too many values for vars in UNPACK (use ... if on purpose)
</code></pre>
<p>As the error says, though, we could indicate we're fine with this through a special syntax:</p>
<pre><code>&gt;&gt; [a b ...]: unpack [1 2 3]
== 1

&gt;&gt; a
== 1

&gt;&gt; b
== 2
</code></pre>
<p>(It's not as sketchy when you have too few values, because you can set the extra variables to unset...which will presumably trigger awareness of a problem at some point.)</p>
<p>Borrowing from multi-return: I think the idea of "circling" values to say which is the one you want the overall expression to evaluate to is a neat idea.</p>
<pre><code>&gt;&gt; [a @b]: unpack [1 2]
== 2
</code></pre>
<h2>And For Show And Tell...</h2>
<p>How hard is it to write such a thing, you ask?  In Ren-C it's super easy, barely an inconvenience:</p>
<pre><code>unpack: enfixed func [
    'vars [set-block!]
    block [block! quoted!]
][
    let result': ~unset~
    reduce-each val block [
        if vars.1 = '... [continue]  ; ignore rest, but keep reducing
        if tail? vars [fail "Too many values in UNPACK (use ...)"]
        if not blank? vars.1 [
            set vars.1 unmeta ^val
            if unset? the result' [result': ^val]
        ]
        vars: my next
    ]
    if vars.1 = '... [
        if not last? vars [fail "... only at the tail of UNPACK vars"]
    ] else [
        for-each var vars [  ; if not enough values for variables, unset
            if not blank? var [unset var]
        ]
    ]
    return unmeta result'
]
</code></pre>
<p>If the ^ and UNMETA seem confusing, the only thing you need to think about is that the META protocol helps you out when you're trying to deal with a situation of storing a value that can be anything...and you need to differentiate a state.  I'm making the result "meta" so that I can use plain unset to signal that it hasn't been assigned yet.  I could make a separate boolean variable instead, but then I'd have another variable and I'd have to GET/ANY the result...</p>
<p>I'm sure people will start getting the hang of it!  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
            <p><small>9 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/a-lot-to-unpack-replacing-the-set-of-reduce-block-idiom/1634">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/a-lot-to-unpack-replacing-the-set-of-reduce-block-idiom/1634</link>
          <pubDate>Thu, 08 Jul 2021 07:44:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1634</guid>
          <source url="https://forum.rebol.info/t/a-lot-to-unpack-replacing-the-set-of-reduce-block-idiom/1634.rss">A Lot To UNPACK: (Replacing the SET of REDUCE BLOCK! Idiom)</source>
        </item>
        <item>
          <title>Building on VS 2019</title>
          <dc:creator><![CDATA[Brett]]></dc:creator>
          <category>First Steps</category>
          <description><![CDATA[
            <p>Thought I'd have a look at the newest ren-c, but I tried and failed to build on VS 2019.  Wondering if builds with Visual Studio 2019 should be working or if that's on hold for now?</p>
<p>If it's on hold until a request, don't spend a lot of time trying to get it working for just me as my immediate interest and priority now is in end user business tools and integration for myself and my wife rather than language work per se. I.e web api's and <a href="http://vb.net">vb.net</a> because I need whip up things in languages I'm familiar with to get things done with little time.</p>
<p>What I did:</p>
<ul>
<li>
<p>Copied r3-windows-x86-8994d23.exe to ./prebuilt</p>
</li>
<li>
<p>Installed VS C++ tools (clicked the box that looked right).</p>
</li>
<li>
<p>Run a command file with the following:</p>
<p>call "C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Auxiliary\Build\vcvars64.bat"<br>
set R3_MAKE=C:\Projects\ren-c\prebuilt\r3-windows-x86-8994d23.exe<br>
"%R3_MAKE%" ../make.r config: ../configs/vs2019-x64.r debug: asserts optimize: 2</p>
</li>
</ul>
<p>What I got was:</p>
<pre><code>...
Dynamic extensions
** Script Error: generate has no value
** Where: switch for-each do catch either else _ do
** Near: [rebmake visual-studio ~~ generate (x86)]
** File: ../make.r
** Line: 871
</code></pre>
<p>Then I changed the line in make for the vs2019 target from:</p>
<pre><code>rebmake/visual-studio/generate/(x86) output-dir solution
</code></pre>
<p>to:</p>
<pre><code>rebmake/makefile/generate/(x86) output-dir solution
</code></pre>
<p>and got a different error, so then I thought I'd ask here, since I'm clueless about compiling with C, C++.</p>
<p>Thank you.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/building-on-vs-2019/1632">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/building-on-vs-2019/1632</link>
          <pubDate>Wed, 07 Jul 2021 02:58:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1632</guid>
          <source url="https://forum.rebol.info/t/building-on-vs-2019/1632.rss">Building on VS 2019</source>
        </item>
        <item>
          <title>Should Built-In Constructs Leverage More &quot;Reserved Words&quot;?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>I was looking at an old proposal for using <strong>|</strong> in PRINT to mean "newline".</p>
<pre><code>print [
    "DESCRIPTION:" |
    tab, any [description, "(undocumented)"] |
    tab (uppercase word) {is} classification #"."
]
</code></pre>
<p>That was taken off the table due to <strong>|</strong> being used as an expression barrier.  But COMMA! is doing a much better job of that, so it's back in the realm of possibility.</p>
<p>And I was also looking at some API code in ODBC like this:</p>
<pre><code>rebValue(
    "switch @", ARG(encoding), "[",
        "'utf-8 [", rebI(CHAR_COL_UTF8), "]",
        "'ucs-2 [", rebI(CHAR_COL_UTF16), "]",
        "'utf-16 [", rebI(CHAR_COL_UTF16), "]",
        "'latin-1 [", rebI(CHAR_COL_LATIN1), "]",
    "] else [",
        "fail {ENCODING must be UTF-8, UCS-2, UTF-16, or LATIN-1}"
    "]"
);
</code></pre>
<p>It made me wonder what if SWITCH let you use something like, say, fat arrow:</p>
<pre><code>rebValue(
    "switch @", ARG(encoding), "[",
        "'utf-8 =&gt;", rebI(CHAR_COL_UTF8),
        "'ucs-2 =&gt;", rebI(CHAR_COL_UTF16),
        "'utf-16 =&gt;", rebI(CHAR_COL_UTF16),
        "'latin-1 =&gt;", rebI(CHAR_COL_LATIN1),
    "] else [",
        "fail {ENCODING must be UTF-8, UCS-2, UTF-16, or LATIN-1}"
    "]"
);
</code></pre>
<h2>Are Core Constructs Underplaying Their Hand?</h2>
<p>I've felt for a long time that PRINT is not strong enough, because it hasn't taken things like TAG! away to signal format changes (colors?).</p>
<p>And when I look at the difference we get in SWITCH above, esp in the API, it makes me wonder if something like that is appropriate.  Though maybe the @ symbol is better to be pushed further to this purpose as a legal branch type...</p>
<p>...anyway the details aren't important.  I guess I'm asking more <em>"could we make a better language if we were more willing to steal words"</em>.</p>
<p>Do we need distinctions...such as "core switch" and "rich switch", and then let people pick which they use?  Where they're expected to hack up the switch to customize it to their tastes?</p>
<p>(Just wanted to put this out there, as I'm deleting a note about | as newline in PRINT on the Trello.)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-built-in-constructs-leverage-more-reserved-words/1622">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-built-in-constructs-leverage-more-reserved-words/1622</link>
          <pubDate>Sat, 05 Jun 2021 16:47:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1622</guid>
          <source url="https://forum.rebol.info/t/should-built-in-constructs-leverage-more-reserved-words/1622.rss">Should Built-In Constructs Leverage More &quot;Reserved Words&quot;?</source>
        </item>
        <item>
          <title>How Is COUNT-UP Implemented?</title>
          <dc:creator><![CDATA[iArnold]]></dc:creator>
          <category>First Steps</category>
          <description><![CDATA[
            <p>Just looked at the source of COUNT-UP and I expected to find a reference to FOR or another function to handle the details, but I only found some MAKE action!, MAKE frame! and MAKE typeset! in there.</p>
<p>So now wondering how this works..</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/how-is-count-up-implemented/1827">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-is-count-up-implemented/1827</link>
          <pubDate>Wed, 12 May 2021 08:13:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1827</guid>
          <source url="https://forum.rebol.info/t/how-is-count-up-implemented/1827.rss">How Is COUNT-UP Implemented?</source>
        </item>
  </channel>
</rss>

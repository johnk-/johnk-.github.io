<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Usage - AltRebol</title>
    <link>https://forum.rebol.info/c/usage/7</link>
    <description>Topics in the &#39;Usage&#39; category Questions and discussion about using Rebol.</description>
    
      <lastBuildDate>Thu, 13 Jun 2024 05:45:28 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/usage/7.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>The Robustness Principle Is Not Robust</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Something floating around that I've pretty much always hated--but experience has made me hate more--is the "Robustness Principle":</p>
<aside class="onebox wikipedia" data-onebox-src="https://en.wikipedia.org/wiki/Robustness_principle">
  <header class="source">

      <a href="https://en.wikipedia.org/wiki/Robustness_principle" target="_blank" rel="noopener">en.wikipedia.org</a>
  </header>

  <article class="onebox-body">
    

<h3><a href="https://en.wikipedia.org/wiki/Robustness_principle" target="_blank" rel="noopener">Robustness principle</a></h3>

<p>In computing, the robustness principle is a design guideline for software that states: "be conservative in what you do, be liberal in what you accept from others". It is often reworded as: "be conservative in what you send, be liberal in what you accept". The principle is also known as Postel's law, after Jon Postel, who used the wording in an early specification of TCP.
 In other words, programs that send messages to other machines (or to other programs on the same machine) should conform comple...</p>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>I understand the motivation.  If you have something that imports to a vector graphics program and not all the Bezier curves have endpoints... then, sure.  Someone is going to appreciate that you were forgiving and they got some kind of maybe-a-bit-broken picture instead of an "Invalid File" error.</p>
<p>Pushing this further to those of us who remember the DOS days: we had those experiences where we accidentally deleted files, but the filesystem didn't delete everything--it just wrote a zero byte on the filename (or somesuch).  Norton Utilities let us catch our mistake and get our file back.  In some ways, a lax and forgiving attitude is a beautiful thing...</p>
<p>This so-called "robustness" cannot (and should not) be subconscious.  It needs to be mitigated with an in-your-face consciousness shift!  <em>(And I think Norton Utilities is an apt example, because if you were firing up that program <a href="https://www.youtube.com/watch?v=RRU3I_o1vLc">you knew you were in the Danger Zone</a>)</em>.</p>
<p>There must be a really jarring speedbump.  When a data file is not fitting the standards, you have to go through a procedure that transforms the broken file to the standard.  You have to be aware that you are dealing with a dirty file.  And the experience of that transformation informs you that the person who gave you the dirty file isn't playing with all their marbles, and you correct them for the next transmission.</p>
<p>Authentic programs should demand a standard form.  And when they aren't getting the standard form they should speak up, march you out the door, and force you to fix your input. "Real programs" should never pretend the byte sequence of bad input is okay--there should only be "Cleanup/Recovery programs" that fix the sequence to write a correct one.  And that recovery program should be terminated before the "Real program" runs.</p>
<hr>
<p>I don't need to rewrite the critiques of the "robustness principle" cited in Wikipedia.  But it is nonsense, and the opposite of robust.  It's a garbage idea, that anyone with a whit of sense regarding security can see right through immediately.</p>
<p>There is a better way: the better way is <em>consciousness</em> about what you are working with, and rejection of any sort of malignant "middleman" acting on your data without you knowing.</p>
<ul>
<li>
<p>"Normalization" you did not ask for is an attack on your information.</p>
</li>
<li>
<p>"Glossing over or fixing invalid sequences" you did not ask for is an attack on your information</p>
</li>
<li>
<p>Anything which makes a simple load of a file and save back of the same file not idempotent is an attack on your information</p>
</li>
</ul>
<p>Perhaps I've become even more religious than Carl in some of these ways.  But I certainly see things won't get better without pushing back.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/the-robustness-principle-is-not-robust/2187">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-robustness-principle-is-not-robust/2187</link>
          <pubDate>Thu, 13 Jun 2024 05:45:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2187</guid>
          <source url="https://forum.rebol.info/t/the-robustness-principle-is-not-robust/2187.rss">The Robustness Principle Is Not Robust</source>
        </item>
        <item>
          <title>RE: The Ordering and Priorities of the Ren-C Project</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="5" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/speed-of-uparse/2177/5">Speed of UPARSE</a>
</div>
<blockquote>
<aside class="quote no-group" data-username="bradrn" data-post="4" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/speed-of-uparse/2177/4">Speed of UPARSE</a>
</div>
<blockquote>
<p>I’ll be blunt: this, to me, sounds unusably slow. Beyond the very simplest tasks, I can’t imagine a situation where I’d deliberately choose to take a 250× performance drop.</p>
</blockquote>
</aside>
<p>This is a first-of-its-kind design. And if you don't understand why I'm building things the way I'm building them, then...to be blunt...there's not much point in me listening to your feedback regarding the order in which I do things.</p>
</blockquote>
</aside>
<p>Remember, I come from well outside the Rebol world. The reason I don’t understand is, to a large extent, because this way of reasoning about code is one I’ve never seen before in my life. This is the reason I’m asking so many questions, setting out my opinions, and having these discussions with you… precisely so that I can begin to understand why it is that way.</p>
            <p><small>9 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179</link>
          <pubDate>Sat, 06 Apr 2024 19:16:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2179</guid>
          <source url="https://forum.rebol.info/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179.rss">RE: The Ordering and Priorities of the Ren-C Project</source>
        </item>
        <item>
          <title>Feb 2024 Talk, Functional Programming Sydney</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2136">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/fundamental-distinguishing-features-of-rebol/2136/1">Fundamental distinguishing features of Rebol</a>
</div>
<blockquote>
<p>I offered to give a talk at my local Functional Programming meetup next month. Given my recent interests, I’m thinking of giving an intro to Rebol and its basic concepts.</p>
</blockquote>
</aside>
<p>As a follow-up to this, the talk slides are now online: <a href="https://github.com/fp-syd/meetings/blob/master/2024/2024-02-Neimann-Computing-with-eval.pdf">https://github.com/fp-syd/meetings/blob/master/2024/2024-02-Neimann-Computing-with-eval.pdf</a></p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/feb-2024-talk-functional-programming-sydney/2175">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/feb-2024-talk-functional-programming-sydney/2175</link>
          <pubDate>Fri, 22 Mar 2024 00:19:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2175</guid>
          <source url="https://forum.rebol.info/t/feb-2024-talk-functional-programming-sydney/2175.rss">Feb 2024 Talk, Functional Programming Sydney</source>
        </item>
        <item>
          <title>&quot;More arguments for a function on request&quot; (Variadics)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>On Red's Gitter, <a href="https://matrix.to/#/!EorVRCzrVpjojJtctJ:gitter.im/$9hee8CVtrrHeVB7GTvPmKo2hV04eYAjOrhH64C3j5kY?via=gitter.im&amp;via=matrix.org&amp;via=chat.weho.st">@GiuseppeChillemi asked</a>:</p>
<blockquote>
<p>Do you think it would be possible to get more arguments for a function on request?</p>
<p>Example:</p>
<pre><code>aaa: 1
bbb: 2
ccc: 3
f: func [arg1] [other-args: get-args 3]
f arg1-val aaa bbb ccc
</code></pre>
</blockquote>
<p>And Gregg says "oh that would make Red unsafe" (as if Red were somehow "safe").</p>
<p>Anyway, Ren-C has some support for variadics.  While the implementation hasn't gotten a lot of attention in a while, it's no less safe than anything else--the mechanisms used are the same ones that gather ordinary arguments.</p>
<pre><code> aaa: 1
 bbb: 2
 ccc: 3
 f: func [arg1 others [&lt;variadic&gt; any-value?]] [
     return collect [keep arg1, repeat 3 [keep take others]]
 ]

 &gt;&gt; f 1020 aaa bbb ccc
 == [1020 1 2 3]
</code></pre>
<p>The interface is probably not what it's going to ultimately be.  But for now, you can mark a parameter <code>&lt;variadic&gt;</code> and it will be a VARARGS!, that supports TAKE to acquire parameters after the call is made.</p>
<p>Variadics should be used sparingly, because they are difficult to wrap and abstract.  There are some mechanisms for APPLY'ing variadics using a BLOCK! to supply the variadic arguments, but the interface for that is also likely to change.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/more-arguments-for-a-function-on-request-variadics/2174">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/more-arguments-for-a-function-on-request-variadics/2174</link>
          <pubDate>Tue, 19 Mar 2024 09:51:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2174</guid>
          <source url="https://forum.rebol.info/t/more-arguments-for-a-function-on-request-variadics/2174.rss">&quot;More arguments for a function on request&quot; (Variadics)</source>
        </item>
        <item>
          <title>Getting an unset variable</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>Trash (now anti BLANK!) <a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604">has been established</a> as the value of unset variables. As the example in that thread states:</p>
<pre><code class="lang-plaintext">&gt;&gt; trash-value
** Error: TRASH-VALUE variable is unset

&gt;&gt; append [a b] get/any 'trash-value
** Error: APPEND does not allow adding ~ antiforms to blocks
</code></pre>
<p>But when I try this, I get quite different results:</p>
<pre><code class="lang-plaintext">&gt;&gt; trash-value
** Script Error: trash-value word is attached to a context, but unassigned

&gt;&gt; append [a b] get/any 'trash-value
** Script Error: trash-value word is not bound to a context
</code></pre>
<p>In fact, even GET/ANY doesn’t seem to work… even when I make sure the binding is right:</p>
<pre><code class="lang-plaintext">&gt;&gt; get/any 'trash-value
** Script Error: trash-value word is not bound to a context

&gt;&gt; get/any $trash-value             
** Script Error: trash-value word is attached to a context, but unassigned
</code></pre>
<p>So, what’s happening here? And how <em>do</em> I get trash out of an unset variable?</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/getting-an-unset-variable/2169">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/getting-an-unset-variable/2169</link>
          <pubDate>Sat, 09 Mar 2024 02:39:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2169</guid>
          <source url="https://forum.rebol.info/t/getting-an-unset-variable/2169.rss">Getting an unset variable</source>
        </item>
        <item>
          <title>How To Choose Between Returning VOID and NIHIL?</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="1604">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604/6">Shades of Distinction In Non-Valued Intents</a>
</div>
<blockquote>
<p>Void is used generically in many places when you want things to vanish:</p>
<pre><code class="lang-plaintext">&gt;&gt; compose [&lt;a&gt; (if false [&lt;b&gt;]) &lt;c&gt;]
== [&lt;a&gt; &lt;c&gt;]
</code></pre>
</blockquote>
</aside>
<p>Ah-ha… I’d completely missed this use of void, as a return value.</p>
<p>Though this does now raise the question of whether a function should return nihil or void. Both seem to vaporise in lists, after all. I guess it depends on whether you want the function call to be ignored or not.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/how-to-choose-between-returning-void-and-nihil/2171">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-to-choose-between-returning-void-and-nihil/2171</link>
          <pubDate>Sat, 09 Mar 2024 02:30:26 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2171</guid>
          <source url="https://forum.rebol.info/t/how-to-choose-between-returning-void-and-nihil/2171.rss">How To Choose Between Returning VOID and NIHIL?</source>
        </item>
        <item>
          <title>What deserves to be a datatype?</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="7" data-topic="2159">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/header-dialect-and-multiline-strings/2159/7">Header dialect and multiline strings</a>
</div>
<blockquote>
<p>(If I may philosophise for a moment… I feel there’s a big, gaping hole in my understanding of how we decide ‘what Rebol syntax is’, so to speak. Perhaps my caution around sigils and TYPE-BLOCK!s are a manifestation of that hole, as is this. I’ll make a new thread about it if I can figure out any clearer way to articulate my concerns.)</p>
</blockquote>
</aside>
<p>This is that thread.</p>
<p>I’ll begin by observing that in Rebol, the complexity of the lexer vs the parser is ‘reversed’ compared to other programming languages. In Rebol, the actual syntax is highly minimalistic: there’s only a few constructs which provide explicit grouping, and none provide anything more than a simple list of items. By contrast, the lexer is exceedingly complicated: nearly every datatype has its own literal form, oftentimes more than one.</p>
<p>Language design ends up ‘reversed’ in a similar way. In most languages, discussion centres around questions like ‘which new syntactic constructs should we add’. By contrast, Rebol (and especially Ren-C) more often poses the question: ‘which new datatypes do we want to include, with which literal syntax?’.</p>
<p>At the moment, I still feel uncomfortable discussing such questions. I don’t feel that I fully understand the kind of criteria we should consider to know whether a datatype is worth including or not. Or, more concisely, I don’t understand how decide: <strong>what deserves to be a Ren-C datatype?</strong>.</p>
<hr>
<p>One obvious criterion is simply, <em>datatypes representing common types of data</em>. This is why we have things like MONEY! and FILE! and DATE! and so on. Ultimately this stems from Rebol’s heritage as a data-transfer format, but obviously these types are far more broadly useful.</p>
<p>Another obvious criterion is <em>syntax which is important for programming</em>. This gives us GROUP! and GET-WORD! and PATH! and so on. These exist as datatypes ultimately because Rebol is homoiconic, but their presence has suggested a wide range of uses beyond simple programming.</p>
<p>This accounts for most of the types in Ren-C. And, if that were all to it, I’d have no objections.</p>
<hr>
<p>But, unfortunately, there are some other types, whose presence is explained by neither of those criteria. As I’ve said previously, the ones which make me feel most uncomfortable are THE-* and TYPE-*. Neither of these represent common types of data that one would want to pass around. And, with the possible exceptions of THE-WORD! and TYPE-BLOCK!, they’re basically useless in ‘regular’ programming.</p>
<p>Despite this, <a class="mention" href="https://forum.rebol.info/u/hostilefork">@hostilefork</a> has lobbied pretty hard for both of these. Hopefully it should be clear now why I find this viewpoint confusing. I can’t say the existence of these types is <em>problematic</em>, as such, but I feel this <strong>indicates a gap in my understanding of the language</strong>.</p>
<p>The closest to an explanation I’ve found is that these types are useful in dialecting. That is, they may not be useful for programming <em>per se</em>, but having the syntax around is useful for constructing new languages. (For instance, using TYPE-WORD!s in PARSE dialect, or THE-WORD!s for module inclusion.) The problem with this is, <a href="https://forum.rebol.info/t/a-proliferation-of-word-s/2147">as we’ve established</a>, that there’s a huge number of syntaxes which would be ‘useful in dialecting’: clearly, this is too low a bar for deciding ‘what deserves to be a datatype’.</p>
<p>(And, incidentally, this also establishes that we’re quite willing to reject datatypes that don’t seem to be of sufficiently general usage.)</p>
<p>Another argument is simply consistency: other sigils have versions for words, blocks, tuples, etc., so THE-* and TYPE-* should as well. But this doesn’t strike me as particularly convincing — there’s nothing intrinsic in Ren-C which requires sigils to generalise to all possible types. Indeed, we’re quite willing to avoid doing so when it would make no sense. (For instance, we don’t have ISSUE-TEXT!, ISSUE-BINARY!, ISSUE-EMAIL!… we just have a single textual ISSUE! type, because doing otherwise would be silly.)</p>
<p>So, when all is said and done, we have a set of types which don’t seem to be of general use, and have no convincing reason to exist, but are nonetheless kept in the language. And <strong>I want to know why that is</strong>, because I can’t figure it out.</p>
            <p><small>9 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/what-deserves-to-be-a-datatype/2164">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-deserves-to-be-a-datatype/2164</link>
          <pubDate>Tue, 05 Mar 2024 08:20:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2164</guid>
          <source url="https://forum.rebol.info/t/what-deserves-to-be-a-datatype/2164.rss">What deserves to be a datatype?</source>
        </item>
        <item>
          <title>REIFY and DEGRADE: a Narrower META and UNMETA</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>In the "small improvements can be big" category, I think that I've settled on the name for the function that turns quasiforms into antiforms, but leaves everything else alone: <strong>DEGRADE</strong>...and its complement <strong>REIFY</strong> which turns antiforms into quasiforms (but leaves everything else alone).</p>
<pre><code>&gt;&gt; first [1020 ~null~]
== 1020

&gt;&gt; second [1020 ~null~]
== ~null~

&gt;&gt; degrade first [1020 ~null~]
== 1020

&gt;&gt; degrade second [1020 ~null~]
== ~null~  ; anti

&gt;&gt; 304
== 304

&gt;&gt; reify 304
== 304

&gt;&gt; true
== ~true~  ; anti

&gt;&gt; reify true
== ~true~
</code></pre>
<p>If you're dealing with a full-band situation where you genuinely don't know if you're working with a "meaningful quasiform" where <em>quasi means quasi</em>, you have to use META and UNMETA.  But if you know that quasiforms aren't part of your data of interest, REIFY and DEGRADE can help you dodge adding and removing quote marks much (or most) of the time.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="12" data-topic="1560">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560/12">Weird WORD!s - Allow, But Escape Them?</a>
</div>
<blockquote>
<p>Maybe it would be better (and give Chris less of a heart attack) if it said:</p>
<pre><code class="lang-plaintext">for-each [sigil' items] [
    ~null~ [  word   tu.p.le   pa/th   [bl o ck]   (gr o up)  ]
    '::    [  word:  tu.p.le:  pa/th:  [bl o ck]:  (gr o up): ]
    ':     [ :word  :tu.p.le  :pa/th  :[bl o ck]  :(gr o up)  ]
    '^     [ ^word  ^tu.p.le  ^pa/th  ^[bl o ck]  ^(gr o up)  ]
    '&amp;     [ &amp;word  &amp;tu.p.le  &amp;pa/th  &amp;[bl o ck]  &amp;(gr o up)  ]
    '@     [ @word  @tu.p.le  @pa/th  @[bl o ck]  @(gr o up)  ]
    '$     [ $word  $tu.p.le  $pa/th  $[bl o ck]  $(gr o up)  ]
 ][
      for-each item items [
          if (unmeta sigil') &lt;&gt; sigil of item [fail [mold item]]
      ]
 ]
</code></pre>
</blockquote>
</aside>
<p>I like how DEGRADE can be used in situations like this to help you strike the quotes on the normal values...since SIGIL OF never returns quasiforms, only SIGIL! or a null antiform:</p>
<pre><code>for-each [sigil items] [
    ~null~ [  word   tu.p.le   pa/th   [bl o ck]   (gr o up)  ]
    ::     [  word:  tu.p.le:  pa/th:  [bl o ck]:  (gr o up): ]
    :      [ :word  :tu.p.le  :pa/th  :[bl o ck]  :(gr o up)  ]
    ^      [ ^word  ^tu.p.le  ^pa/th  ^[bl o ck]  ^(gr o up)  ]
    &amp;      [ &amp;word  &amp;tu.p.le  &amp;pa/th  &amp;[bl o ck]  &amp;(gr o up)  ]
    @      [ @word  @tu.p.le  @pa/th  @[bl o ck]  @(gr o up)  ]
    $      [ $word  $tu.p.le  $pa/th  $[bl o ck]  $(gr o up)  ]
][
    for-each item items [
        if (degrade sigil) &lt;&gt; sigil of item [
            fail [mold item]
        ]
    ]
]
</code></pre>
<p>I think this will be a useful and common pattern.</p>
<p>Void being a word antiform is locking this all up into place!</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/atom_symbol.png?v=12" title=":atom_symbol:" class="emoji only-emoji" alt=":atom_symbol:" loading="lazy" width="20" height="20"> <img src="https://forum.rebol.info/images/emoji/twitter/+1.png?v=12" title=":+1:" class="emoji only-emoji" alt=":+1:" loading="lazy" width="20" height="20"></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/reify-and-degrade-a-narrower-meta-and-unmeta/2163">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/reify-and-degrade-a-narrower-meta-and-unmeta/2163</link>
          <pubDate>Sun, 03 Mar 2024 15:28:36 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2163</guid>
          <source url="https://forum.rebol.info/t/reify-and-degrade-a-narrower-meta-and-unmeta/2163.rss">REIFY and DEGRADE: a Narrower META and UNMETA</source>
        </item>
        <item>
          <title>copy all files in a directory ... a little help please?</title>
          <dc:creator><![CDATA[hcfe]]></dc:creator>
          <category>Usage</category>
          <description><![CDATA[
            <p>Hi everybody,</p>
<p>I'd like to modify this script from the script library: <a href="http://rebol.net/cookbook/recipes/0011.html" rel="noopener nofollow ugc">copy all files in a directory</a> so that it can exclude directories and or files like you can with rsync.</p>
<p>It has been a long time since I've used rebol, and I was never much good at it!</p>
<p>Any help appreciated...</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/copy-all-files-in-a-directory-a-little-help-please/2149">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/copy-all-files-in-a-directory-a-little-help-please/2149</link>
          <pubDate>Thu, 15 Feb 2024 00:10:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2149</guid>
          <source url="https://forum.rebol.info/t/copy-all-files-in-a-directory-a-little-help-please/2149.rss">copy all files in a directory ... a little help please?</source>
        </item>
        <item>
          <title>Fundamental distinguishing features of Rebol</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Perhaps foolishly, I offered to give a talk at my local Functional Programming meetup next month. Given my recent interests, I’m thinking of giving an intro to Rebol and its basic concepts.</p>
<p>So that’s gotten me thinking: what <em>are</em> the basic concepts of Rebol as a programming paradigm, which distinguish it from all others? Here’s what I’ve come up with so far:</p>
<ul>
<li>
<p><strong>Everything is a datatype</strong>: Rebol was built for networking. This means you should be able to take any value, serialise it in a human-readable way, and parse it back into a value. This means a lot of built-in datatypes for useful concepts.</p>
</li>
<li>
<p><strong>Data is code</strong>: Everything starts out its life as data. If you want, you can evaluate it in some way to get a result. Naturally, you can evaluate it using any rules you want, which gives you <strong>dialecting</strong> as a corollary.</p>
<p>(It’s worth noting that this is the converse of Lisp’s famous maxim, ‘code is data’.)</p>
</li>
<li>
<p><strong>Binding</strong>: Word values are associated with their storage. This can be arbitrarily manipulated by the programmer, leading to <strong>definitional scoping</strong>.</p>
</li>
<li>
<p>More generally, I might summarise all the above points as natural consequences of <strong>computing with evaluation</strong>: the fundamental operation of Rebol is taking values and extracting some kind of result from them. This necessitates the other points above: a rich set of datatypes to store both the original value and the result, the ability to treat those datatypes as code which can be evaluated, and a way to look up references during the evaluation process.</p>
</li>
</ul>
<p>Does this all seem reasonable? Have I missed anything?</p>
            <p><small>14 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/fundamental-distinguishing-features-of-rebol/2136">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/fundamental-distinguishing-features-of-rebol/2136</link>
          <pubDate>Mon, 29 Jan 2024 12:55:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2136</guid>
          <source url="https://forum.rebol.info/t/fundamental-distinguishing-features-of-rebol/2136.rss">Fundamental distinguishing features of Rebol</source>
        </item>
        <item>
          <title>Reacting to Definitional Errors: CURTAIL</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>Here's a simple <a href="https://forum.rebol.info/t/introducing-reframer-close-cousin-to-enclose/1395">REFRAMER</a> called CURTAIL:</p>
<pre><code>curtail: reframer function [frame [frame!]] [
    return do frame except e -&gt; [
        if e.id == 'need-non-null [return void]
        raise e
    ]
]
</code></pre>
<p>If you don't remember what reframers do, they just have access to a function call before you run it.  Here we are looking for the function we're running to give us a NEED-NON-NULL error.</p>
<p><em>But we're not looking for just any NEED-NON-NULL error that might go by.</em>  We're only interested in ones that are coming out of the call we're processing.  If that happens, we just vaporize the expression.</p>
<pre><code>&gt;&gt; compose [(null)]
** Script Error: non-NULL value required (see MAYBE, TRY, REIFY)

&gt;&gt; curtail compose [(null)]  ; will give back void
</code></pre>
<p>You can see something like this simplifying null checks:</p>
<pre><code>&gt;&gt; ver: 1.2.3
&gt;&gt; date: null

&gt;&gt; print [curtail spaced ["Version:" ver] curtail spaced ["Date:" date]]
Version: 1.2.3
</code></pre>
<p><em>But like I said, it's not just any NEED-NON-NULL...</em></p>
<pre><code>&gt;&gt; a: 1 b: null c: 3
&gt;&gt; get-ver: func [] [to tuple! reduce [a b c]]

&gt;&gt; print [curtail spaced ["Version:" get-ver] curtail spaced ["Date:" date]]
** Script Error: non-NULL value required (see MAYBE, TRY, REIFY)
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/reacting-to-definitional-errors-curtail/2118">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/reacting-to-definitional-errors-curtail/2118</link>
          <pubDate>Mon, 15 Jan 2024 01:13:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2118</guid>
          <source url="https://forum.rebol.info/t/reacting-to-definitional-errors-curtail/2118.rss">Reacting to Definitional Errors: CURTAIL</source>
        </item>
        <item>
          <title>Variant Of &quot;COLLECT&quot; Without &quot;KEEP&quot;</title>
          <dc:creator><![CDATA[no-e-in]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I recently discovered a version of COLLECT by Brett Handley (for R2) that is less general <em>[<a href="https://forum.rebol.info/t/implementing-collect-keep/2099">than what COLLECT has been come to be known as</a>]</em> but avoids nested code.</p>
<pre><code>collect: func [
    {Collects block evaluations, use as body in For, Repeat, etc.}
    block [block!] "Block to evaluate."
    /initial result [series! datatype!] "Initialise the result."
    /only "Inserts into result using Only refinement."
] [
    if not initial [result: block!]
    result: any [all [datatype? result make result 1000] result]
    reduce ['head pick [insert insert/only] not only 'tail result to paren! block]
]
</code></pre>
<p>Examples (running in Rebol2 interpreter):</p>
<pre><code>&gt;&gt; for i 1 10 2 collect [i * 10]
== [10 30 50 70 90]
    
&gt;&gt; foreach [a b] [1 2 3 4] collect [a + b]
== [3 7]

&gt;&gt; foreach w [a b c d] collect [w]
== [a b c d]

&gt;&gt; repeat e [a b c %.txt] collect/initial [e] %file
== %fileabc.txt

&gt;&gt; iota: func [n [integer!]][repeat i n collect/initial [i] make block! n]
&gt;&gt; iota 10
== [1 2 3 4 5 6 7 8 9 10]
</code></pre>
            <p><small>6 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/variant-of-collect-without-keep/2110">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/variant-of-collect-without-keep/2110</link>
          <pubDate>Thu, 11 Jan 2024 10:05:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2110</guid>
          <source url="https://forum.rebol.info/t/variant-of-collect-without-keep/2110.rss">Variant Of &quot;COLLECT&quot; Without &quot;KEEP&quot;</source>
        </item>
        <item>
          <title>Usefulness of String Interpolation</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="bradrn" data-post="7" data-topic="1751">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751/7">Rebol And Scopes: Well, Why Not?</a>
</div>
<blockquote>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1751">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751/1">Rebol And Scopes: Well, Why Not?</a>
</div>
<blockquote>
<p>Features based on string interpolation are so undeniably useful that once the possibilities are seen, they can't be unseen.</p>
</blockquote>
</aside>
<p>Honestly, I’m not sure I agree with this. In Haskell, which is my main language, there are packages which implement string interpolation… and no-one uses them, because they just aren’t necessary! It’s no big deal when it’s easier to just concatenate stuff together.</p>
</blockquote>
</aside>
<p>To pick a random example from the build helpers for "CScape" interpolation of some generated C code:</p>
<pre><code>emit {
    #define ${MAYBE PREFIX}INCLUDE_PARAMS_OF_${NATIVE-NAME} \
        $[Items]; \
        assert(Get_Series_Info(level_-&gt;varlist, HOLD))
}
</code></pre>
<ul>
<li>
<p>The use of <code>${}</code> (instead of <code>$()</code> or <code>$&lt;&gt;</code>) means that the result of the expression should be <a href="https://github.com/metaeducation/ren-c/blob/815758fb571e88591908dc94f9320581f00d9331/tools/common.r#L37">turned into a valid C identifier name</a>... so dashes are converted to underscores, etc.</p>
</li>
<li>
<p>The use of all capitals in the <code>${}</code> escaping means that the strings generated by the expressions evaluated should be made all uppercase.</p>
</li>
<li>
<p>The use of <code>$[]</code> means that items is an array, and its elements should be printed one line at a time...repeating the boilerplate leading and trailing on each line (in this case an indent on the left, and a semicolon and backslash on the right)</p>
</li>
</ul>
<p>The template looks something like the result:</p>
<pre><code>#define INCLUDE_PARAMS_OF_IF \
    DECLARE_PARAM(1, return); \
    USED(ARG(return)); \
    DECLARE_PARAM(2, condition); \
    DECLARE_PARAM(3, branch); \
    assert(Get_Series_Info(level_-&gt;varlist, HOLD))
</code></pre>
<p>Without interpolation, we fall back on LOAD-able code... where spaces and quotes are required by the language itself.  This starts to lose the ability to keep track of actual spaces in the interpolated thing, plus you keep having to start and stop string delimiters on the string portions.</p>
<p>I'm not quite sure how it would come together dialected via regular code, but it would drift away from looking like C code, at best it might look like:</p>
<pre><code>emit [
    "#define " &lt;c&gt; (MAYBE PREFIX) "INCLUDE_PARAMS_OF_" &lt;c&gt; (NATIVE-NAME) " \"
    "    " @[Items] "; \"
    "    assert(Get_Series_Info(level_-&gt;varlist, HOLD))"
]
</code></pre>
<p><em>I'd be hard-pressed to say the spacing was correct on inspection</em>.  We've lost the intuition about where the unspaced parts are.  You can imagine it getting worse when you're building unspaced material inside a string literal.  Strings can simply be the least noisy medium when you want to see something that looks close to the result.</p>
<p>Anyway, with strings carrying binding, we wouldn't have to do what we do today... which is actually pass the variables (that don't live in LIB) in a block to emit:</p>
<pre><code>emit [prefix native-name items] {  ; &lt;-- ack
    #define ${MAYBE PREFIX}INCLUDE_PARAMS_OF_${NATIVE-NAME} \
        $[Items]; \
        assert(Get_Series_Info(level_-&gt;varlist, HOLD))
}
</code></pre>
<p>So I look forward to getting rid of that.</p>
<aside class="quote no-group quote-modified" data-username="bradrn" data-post="7" data-topic="1751">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751/7">Rebol And Scopes: Well, Why Not?</a>
</div>
<blockquote>
<p>And it’s even easier in Rebol than it is in Haskell, because there’s already a single built-in function to do everything for you:</p>
<pre><code>&gt;&gt; x: 10 y: "foo"
== "foo"
&gt;&gt; print ajoin ["Scopes? " x " " x " " x " " y " " y " " y]
Scopes? 10 10 10 foo foo foo
&gt;&gt; foo: func [x] [local: 20 ajoin ["The sum is " (x + local)]]
&gt;&gt; foo 30
== "The sum is 50"
</code></pre>
<p>I strongly prefer this approach over string concatenation, since by using sensible data structures it integrates much better with the rest of the language. (It also reduces the risk of errors from malformed strings, and potentially the equivalent of SQL injection attacks.)</p>
</blockquote>
</aside>
<p>Note that <a href="https://forum.rebol.info/t/introducing-delimit/2102">Ren-C has DELIMIT (and UNSPACED, SPACED)</a> instead of AJOIN... which hopefully you'll like even better.</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/usefulness-of-string-interpolation/2114">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/usefulness-of-string-interpolation/2114</link>
          <pubDate>Thu, 11 Jan 2024 01:39:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2114</guid>
          <source url="https://forum.rebol.info/t/usefulness-of-string-interpolation/2114.rss">Usefulness of String Interpolation</source>
        </item>
        <item>
          <title>Introducing DELIMIT (plus SPACED and UNSPACED)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>Ren-C offers an alternative to historical AJOIN and REJOIN called DELIMIT:</p>
<pre><code>&gt;&gt; delimit "," ["foo" 1 + 2 "bar"]
== "foo,3,bar"

&gt;&gt; delimit/head "," ["foo" 1 + 2 "bar"]
== ",foo,3,bar"

&gt;&gt; delimit/tail "," ["foo" 1 + 2 "bar"]
== "foo,3,bar,"

&gt;&gt; delimit/head/tail "," ["foo" 1 + 2 "bar"]
== ",foo,3,bar,"
</code></pre>
<p>If you don't want it to reduce, you can use an @ block:</p>
<pre><code>&gt;&gt; delimit "," @["foo" 1 + 2 "bar"]
== "foo,1,+,2,bar"
</code></pre>
<p>SPACED and UNSPACED are specializations, running through the same code for stringifying any non-string contents.</p>
<pre><code>&gt;&gt; spaced ["foo" 1 + 2 "bar"]
== "foo 3 bar"

&gt;&gt; unspaced ["foo" 1 + 2 "bar"]
== "foo3bar"
</code></pre>
<p>PRINT uses SPACED internally when you pass it a block.  You can use <strong>print unspaced</strong> to pass it a string if you want unspaced intent.</p>
<pre><code>&gt;&gt; print ["foo" 1 + 2 "bar"]
foo 3 bar

&gt;&gt; print unspaced ["foo" 1 + 2 "bar"]
foo3bar
</code></pre>
<p>If you use a character (like <span class="hashtag">#a</span>) instead of a string (like "a"), the delimiting won't be applied.  For instance, a newline won't leave spaces on either end of the line break:</p>
<pre><code>&gt;&gt; spaced ["foo" 1 + 2 newline "bar"]
== "foo 3^/bar"
</code></pre>
<p>NULLs will trigger errors, VOIDs will vanish.</p>
<pre><code>&gt;&gt; spaced ["foo" if false [1 + 2] "bar"]
== "foo bar"

&gt;&gt; spaced ["foo" pick [a b] 3 "bar"]
** Script Error: non-NULL value required (see MAYBE, TRY, REIFY)

&gt;&gt; spaced ["foo" maybe pick [a b] 3 "bar"]
== "foo bar"
</code></pre>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/introducing-delimit-plus-spaced-and-unspaced/2102">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/introducing-delimit-plus-spaced-and-unspaced/2102</link>
          <pubDate>Thu, 11 Jan 2024 00:42:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2102</guid>
          <source url="https://forum.rebol.info/t/introducing-delimit-plus-spaced-and-unspaced/2102.rss">Introducing DELIMIT (plus SPACED and UNSPACED)</source>
        </item>
        <item>
          <title>Implementing COLLECT + KEEP</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>COLLECT allows you to build up a block, without needing to name the block or pass it as a parameter to individual APPEND instructions.  Instead you use KEEP, which appends to the implicit nameless block:</p>
<pre><code>&gt;&gt; collect [
       keep 'foo:
       print "Arbitrary code possible"
       keep/line [1 2 3]
       keep spread [Spread #works @(T O O)]
       repeat 2 [keep &lt;whatever&gt;]
    ]
Arbitrary code possible
== [
    foo: [1 2 3]
    Spread #works @(T O O) &lt;whatever&gt; &lt;whatever&gt;]
</code></pre>
<h2>
<a name="leverages-lambda-to-bind-keep-to-code-1" class="anchor" href="https://forum.rebol.info#leverages-lambda-to-bind-keep-to-code-1"></a>Leverages LAMBDA To Bind KEEP To Code</h2>
<p>The trick is that the body is turned into a function that takes KEEP as a parameter.  This defines the word KEEP for the body.</p>
<p>To see how this works, imagine this:</p>
<pre><code>collector: lambda [keep [action?]] [
    keep 'foo:
    print "Arbitrary code possible"
    keep/line [1 2 3]
    keep spread [Spread #works @(T O O)]
    repeat 2 [keep &lt;whatever&gt;]
 ]

 block: copy []
 keeper: specialize :append [series: block]

 collector :keeper
</code></pre>
<p>This code gets the desired result in BLOCK.</p>
<h2>
<a name="slight-twist-make-keep-return-its-input-2" class="anchor" href="https://forum.rebol.info#slight-twist-make-keep-return-its-input-2"></a>Slight Twist: Make KEEP Return Its Input</h2>
<p>APPEND will return the block that you append to.  This would reveal the partially-built temporary block before the collect is complete.  A better and more useful result of KEEP would be to return the value that you pass it.</p>
<p>To accomplish that, we can ENCLOSE the specialization:</p>
<pre><code>keeper: enclose (specialize :append [series: block]) func [f [frame!]] [
    let value: f.value
    do f
    return value
]
</code></pre>
<p>We have to capture the value to append before we DO the captured FRAME!, because Rebol functions are permitted to make arbitrary modifications to their arguments during execution.  <em>(To help avoid mistakes, you are not allowed to read a frame's values after a DO is complete.)</em>  It's possible to DO COPY F but that makes a copy of the entire frame, and here we just copy the value we want.</p>
<p>A more efficient way to do this is to use a LAMBDA for the wrapper function, and ELIDE the DO.  There's no need to type check F (since ENCLOSE only passes the FRAME! built for APPEND, never anything else):</p>
<pre><code>keeper: enclose (specialize :append [series: block]) lambda [f] [
    f.value
    elide do f  ; evaluates to anti-isotope of 0 length block, vanishes
]
</code></pre>
<h2>
<a name="putting-it-together-3" class="anchor" href="https://forum.rebol.info#putting-it-together-3"></a>Putting It Together</h2>
<p>Wrapping this up for a working COLLECT implementation:</p>
<pre><code>collect: func [
    return: [block!]
    body [block!]
][
    let block: copy []
    let keeper: enclose (specialize :append [series: block]) lambda [f] [
        f.value
        elide do f
    ]
    run (lambda [keep] body) :keeper
    return block
]
</code></pre>
<p>It's a good demonstration of how you can make something impressive that feels like a first-class language feature out of Rebol, with little effort.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/implementing-collect-keep/2099">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/implementing-collect-keep/2099</link>
          <pubDate>Wed, 10 Jan 2024 17:20:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2099</guid>
          <source url="https://forum.rebol.info/t/implementing-collect-keep/2099.rss">Implementing COLLECT + KEEP</source>
        </item>
        <item>
          <title>Why is TYPE OF 1 an &amp;INTEGER and not INTEGER!</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <pre><code>&gt;&gt; type of 1         
== &amp;integer
</code></pre>
<p>I would have expected this to print as <code>integer!</code>, since that’s how we refer to it in discussions. But no, it prints with an ampersand. I’m sure there’s some good reason for this, but the apparent inconsistency is jarring.</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/why-is-type-of-1-an-integer-and-not-integer/2097">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/why-is-type-of-1-an-integer-and-not-integer/2097</link>
          <pubDate>Tue, 09 Jan 2024 01:34:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2097</guid>
          <source url="https://forum.rebol.info/t/why-is-type-of-1-an-integer-and-not-integer/2097.rss">Why is TYPE OF 1 an &amp;INTEGER and not INTEGER!</source>
        </item>
        <item>
          <title>Which isotopes are currently in use?</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>Since <a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">generalised isotopes</a>, every type has an isotopic form which cannot be stored in blocks. But not every isotopic type makes sense — for instance, what could one do with an isotopic TIME!? So it seems that, out of necessity, practical uses for isotopic values are decided on an ad-hoc basis.</p>
<p>So far, the ones I know about are these:</p>
<ul>
<li>Isotopic GROUP!s are splices, which are pretty trivial to understand</li>
<li>Isotopic FRAME!s are actions, which run themselves when invoked (though in that case I don’t quite get what non-isotopic FRAME!s would be)</li>
<li>Isotopic VOID! is an unset variable, I believe, though the naming seems to have changed so often that I’ve had a lot of trouble following the relevant forum posts</li>
<li>Isotopic COMMA! is… <a href="https://forum.rebol.info/t/the-language-worlds-weirdest-comma-mechanic/1387/6">something</a>… which acts as an expression barrier somehow (though similarly to FRAME! I have trouble distinguishing this from the non-isotopic COMMA!)</li>
<li>Isotopic WORD!s seem to be error states of some description, as well as booleans — except that makes no sense to me, since surely booleans should be storable in blocks‽</li>
<li>I’ve seen a few references to an isotopic NIHIL, but I don’t know what that does nor what a non-isotopic NIHIL would be</li>
</ul>
<p>So… clearly there’s a lot missing. Do we have any comprehensive list of which of the various isotopic types are currently in use, and what they are used for? If not, it would be awfully convenient to have one…</p>
            <p><small>15 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/which-isotopes-are-currently-in-use/2094">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/which-isotopes-are-currently-in-use/2094</link>
          <pubDate>Sun, 07 Jan 2024 05:00:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2094</guid>
          <source url="https://forum.rebol.info/t/which-isotopes-are-currently-in-use/2094.rss">Which isotopes are currently in use?</source>
        </item>
        <item>
          <title>Why Have Both BLOCK! and GROUP!</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>Maybe this is a stupid question, but here’s something I’ve been wondering about Rebol: since quoting exists, block!s feel a bit redundant. Something like <code>[a b c]</code> could just as easily be represented as <code>the (a b c)</code>. So, why do both exist?</p>
<p>Or, to put it another way, it feels like Rebol has two orthogonal concepts:</p>
<ul>
<li>Grouping: you can take a bunch of symbols and parenthesize them to get a group!</li>
<li>Quoting: you can take a value and quote it to prevent evaluation</li>
</ul>
<p>So it makes sense that you can combine these: <code>the (a b c)</code>. Except that Rebol doesn’t seem to take advantage of this fact at all — rather, it goes the opposite route, by creating a new data structure which conflates aspects of both of these.</p>
            <p><small>9 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/why-have-both-block-and-group/2092">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/why-have-both-block-and-group/2092</link>
          <pubDate>Fri, 05 Jan 2024 07:25:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2092</guid>
          <source url="https://forum.rebol.info/t/why-have-both-block-and-group/2092.rss">Why Have Both BLOCK! and GROUP!</source>
        </item>
        <item>
          <title>How Much Determinism Should Be Pursued?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>While writing tests for the QUERY dialect against some sample files in a directory, it ran into an issue of the order those files were given back.  <em>Operating system APIs generally do not return the list of files in a determined order, and the ordering across filesystems also varies.</em></p>
<p>This means that even with the same files, you could have the lists come back differently.  One OS could say:</p>
<pre><code>Domain-SQL&gt;&gt; select 'name 'date from %tests/file-tests/
    where 'size &gt; 100 and 'date = 26-Jul-2021

1 [%tests/file-tests/Disk50.txt 26-Jul-2021]
2 [%tests/file-tests/11barz99.txt 26-Jul-2021]
3 [%tests/file-tests/Apple3.txt 26-Jul-2021]
4 [%tests/file-tests/Banana1.txt 26-Jul-2021]
5 [%tests/file-tests/BANANA22.txt 26-Jul-2021]
...
</code></pre>
<p>While another would say:</p>
<pre><code>Domain-SQL&gt;&gt; select 'name 'date from %tests/file-tests/
    where 'size &gt; 100 and 'date = 26-Jul-2021

1 [%tests/file-tests/Apple3.txt 26-Jul-2021]
2 [%tests/file-tests/Banana1.txt 26-Jul-2021]
3 [%tests/file-tests/BANANA22.txt 26-Jul-2021]
4 [%tests/file-tests/Disk50.txt 26-Jul-2021]
5 [%tests/file-tests/11barz99.txt 26-Jul-2021]
...
</code></pre>
<p>This made getting reproducible outputs to verify was hard.</p>
<h2>
<a name="i-made-query-use-sortcase-on-the-read-dir-result-1" class="anchor" href="https://forum.rebol.info#i-made-query-use-sortcase-on-the-read-dir-result-1"></a>I Made QUERY use SORT/CASE on the READ DIR Result</h2>
<p>Getting determinism in the output meant using a function that guarantees an ordering for filenames:</p>
<pre><code>Domain-SQL&gt;&gt; select 'name 'date from %tests/file-tests/
    where 'size &gt; 100 and 'date = 26-Jul-2021

1 [%tests/file-tests/11barz99.txt 26-Jul-2021]
2 [%tests/file-tests/Apple3.txt 26-Jul-2021]
3 [%tests/file-tests/BANANA22.txt 26-Jul-2021]
4 [%tests/file-tests/Banana1.txt 26-Jul-2021]
5 [%tests/file-tests/Disk50.txt 26-Jul-2021]
...
</code></pre>
<p>Having to pay for the sort adds a little bit of overhead, but it's not that significant.</p>
<h2>
<a name="should-read-dir-be-sorted-by-default-2" class="anchor" href="https://forum.rebol.info#should-read-dir-be-sorted-by-default-2"></a>Should READ DIR be Sorted By Default?</h2>
<p>WASI in WebAssembly is looking to chase down sources of non-determinism and see what it can do to stop it.  They mention directory listing order as one potential for problems:</p>
<p><a href="https://github.com/WebAssembly/WASI/issues/190" class="inline-onebox">Roadmap to determinism in WASI · Issue #190 · WebAssembly/WASI · GitHub</a></p>
<p>They seem to believe that on the same OS the directory ordering would be deterministic for the same files, but I don't know of any guarantee of that.</p>
<h2>
<a name="all-this-points-to-bigger-issues-about-reproducibility-3" class="anchor" href="https://forum.rebol.info#all-this-points-to-bigger-issues-about-reproducibility-3"></a>All This Points to Bigger Issues About Reproducibility</h2>
<p>We can pick many examples... like whether a MAP! will always enumerate in the same order on different platforms, or with the same contents.  Using a deterministically sorted implementation of map would seem to have a number of advantages.</p>
<p>Especially since there's a growing push in software for giving deterministic outputs by default.  If you want some reasoning, see this article:</p>
<p><a href="https://buttondown.email/nelhage/archive/determinism-in-software-engineering/" class="inline-onebox">Determinism in software engineering • Buttondown</a></p>
<p>The more testing one does, the more important it seems.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/how-much-determinism-should-be-pursued/2057">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-much-determinism-should-be-pursued/2057</link>
          <pubDate>Thu, 19 Oct 2023 19:34:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2057</guid>
          <source url="https://forum.rebol.info/t/how-much-determinism-should-be-pursued/2057.rss">How Much Determinism Should Be Pursued?</source>
        </item>
        <item>
          <title>COMPOSE of TUPLE! and PATH! (and toplevel GROUP!)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>While working on <a class="mention" href="https://forum.rebol.info/u/blackattr">@BlackATTR</a>'s query, I noticed code that was making paths (now tuples) out of components via TO TUPLE! COMPOSE of a BLOCK!.  Like this:</p>
<pre><code>to tuple! compose [obj clauses (kwd.1)]
</code></pre>
<p>But did you know that COMPOSE can act directly on TUPLE! and PATH!  You could instead just write:</p>
<pre><code>compose 'obj.clauses.(kwd.1)
</code></pre>
<p>It supports splices as well:</p>
<pre><code>&gt;&gt; compose '(10 + 20)/a/b/(spread [c d e])/(reverse [g f])
== 30/a/b/c/d/e/[f g]
</code></pre>
<p>And if you remember that TUPLE! can be nested underneath PATH! (not vice versa) then you can COMPOSE/DEEP and handle mixed tuples and paths:</p>
<pre><code>&gt;&gt; compose/deep '(10 + 20)/a/b.(spread [c d e])
== 30/a/b.c.d.e
</code></pre>
<p>Voids can vanish...so there can be fewer dots in an output tuple than in the input:</p>
<pre><code>&gt;&gt; compose 'a.(if false [b]).c
== a.c
</code></pre>
<p>Empty splices will vanish as well:</p>
<pre><code>&gt;&gt; compose 'a.(spread []).c
== a.c
</code></pre>
<p>You can't compose in NULLs as an important safety measure...central to the design!</p>
<pre><code>&gt;&gt; compose 'a.(select [x 10 y 20] 'b).c
** Script Error: non-NULL value required (see MAYBE, TRY, REIFY)
** Near: [a ** (select [x 10 y 20] 'b) c]
</code></pre>
<p>But don't forget about MAYBE as the way to convert nulls to void when that's what you meant!</p>
<pre><code>&gt;&gt; compose 'a.(maybe select [x 10 y 20] 'b).c
== a.c
</code></pre>
<h2>
<a name="you-can-also-compose-a-group-1" class="anchor" href="https://forum.rebol.info#you-can-also-compose-a-group-1"></a>You can also COMPOSE a GROUP!</h2>
<p>In R3-Alpha, only BLOCK! would compose.  Everything else was passed-through as-is, including GROUP!s (PAREN!s in their terminology)</p>
<pre><code>r3-alpha&gt;&gt; compose quote (1 + (2 + 3))
== (1 + (2 + 3))
</code></pre>
<p>Red just doesn't allow it:</p>
<pre><code>red&gt;&gt; compose quote (1 + (2 + 3))
*** Script Error: compose does not allow paren! for its value argument
</code></pre>
<p>So you'd wind up having to make BLOCK!s and then convert them:</p>
<pre><code>red&gt;&gt; as paren! compose [1 + (2 + 3)]
== (1 + 5)
</code></pre>
<p>But in Ren-C, group composing works... it just leaves the top group as-is.  And you also have quoted groups to make it easier!</p>
<pre><code>&gt;&gt; compose '(1 + (2 + 3))
== (1 + 5)
</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/compose-of-tuple-and-path-and-toplevel-group/2056">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/compose-of-tuple-and-path-and-toplevel-group/2056</link>
          <pubDate>Thu, 19 Oct 2023 06:39:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2056</guid>
          <source url="https://forum.rebol.info/t/compose-of-tuple-and-path-and-toplevel-group/2056.rss">COMPOSE of TUPLE! and PATH! (and toplevel GROUP!)</source>
        </item>
        <item>
          <title>Skinning REPLACE with Red&#39;s String PARSE Hack</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>Red made an unusual choice with their implementation of REPLACE when you use a pattern that's a block with a string.  Instead of trying to stringify the block, <a href="https://github.com/red/red/blob/40096dd12ca9c3b9b47e9eaa995d425b9faf620b/tests/source/units/replace-test.red#L72">they assume it's a PARSE rule</a>:</p>
<pre><code>red&gt;&gt; replace/case/all "aAbbabAAAa" ["Ab" | "Aa"] "-"
== "a-babAA-"
</code></pre>
<p>It seems like a bad idea to make the choice to do this based on the input type.  What if you actually want to do this when the input is a BLOCK!?  I'd prefer something like <strong>parse-replace</strong> <em>(or if we ever allow the same word to be a function and a module, maybe <strong>parse.replace</strong>)</em>.</p>
<p>But honestly, I think that the answer is just to keep pushing on UPARSE itself to be slick enough that you wouldn't feel the need to reach for a shorthand like this.  It's pretty easy to write as is:</p>
<pre><code>&gt;&gt; parse/case "aAbbabAAAa" [
       try some thru [change ["Ab" | "Aa"] ("-")]
       accept &lt;input&gt;
   ]
== "a-babAA-"
</code></pre>
<p>That's probably reaching the limits of how short UPARSE can do an equivalent.  Yet it's more powerful if you want to deviate or customize it, so I would reach for this more often than a limited REPLACE.</p>
<h2>
<a name="still-ren-c-does-backflips-and-lets-you-have-it-your-way-1" class="anchor" href="https://forum.rebol.info#still-ren-c-does-backflips-and-lets-you-have-it-your-way-1"></a>Still, Ren-C Does Backflips And Lets You Have It Your Way</h2>
<p>So you should be able to adapt REPLACE to have Red's behavior if you want it.</p>
<p>Super easy.  Barely an inconvenience!</p>
<pre><code>replace: enclose :lib.replace func [
     f [frame!]
     &lt;local&gt; head tail rule
][
    if not all [
        match [text! binary!] f.target
        block? f.pattern
    ][
        return do f  ; use normal REPLACE semantics
    ]

    rule: if activation? :f.replacement '[  ; function generates replacement
        head: &lt;here&gt;
        change [f.pattern, tail: &lt;here&gt;] (
            apply/relax :f.replacement [const head, const tail]
        )
    ] else '[  ; replacement can be used as-is
        change f.pattern (f.replacement)
    ]

    apply :parse [/case f.case, f.target [
        while [thru rule] (
            if not f.all [return f.target]
        )
        to &lt;end&gt;
    ]]
    return f.target
]
</code></pre>
<h2>
<a name="it-worked-the-first-time-i-ran-it-2" class="anchor" href="https://forum.rebol.info#it-worked-the-first-time-i-ran-it-2"></a>It worked the first time I ran it!</h2>
<p>There's so much interesting stuff going on here that it's hard to list it all. I can quickly hit some high points.</p>
<ul>
<li>
<p>You don't have to repeat the interface of REPLACE.  This is an ENCLOSE, so it just passes the frame built for LIB.REPLACE to the wrapper and lets it choose whether to run that frame as-is (or modified), or do its entirely own thing.</p>
</li>
<li>
<p>It uses the <a href="https://forum.rebol.info/t/the-cool-new-repurposing-of-while-in-parse/1875">kickass new arity-2 WHILE combinator</a> to great effect...simply iterating over the replacement rule.</p>
</li>
<li>
<p><a href="https://forum.rebol.info/t/apply-ii-the-revenge/1834">Modern kickass APPLY</a> for PARSE lets you put arguments in any order, and does refinements by name... here we put /CASE first because it's clearer... then passing the series and the rule.</p>
</li>
<li>
<p>It doesn't just run isotopic actions if they are passed, but it also optionally passes them the head and tail of where in the input is matched.  If the function is arity-1, it just receives the head.  If it's arity-0, it doesn't receive either.  (This is due to APPLY's /RELAX that tolerates too many arguments.)</p>
</li>
</ul>
<p>I wrote a little demo of the fancier function invocation:</p>
<pre><code>&gt;&gt; data: "(real)1020(powerful)0304(magic)"

&gt;&gt; collect [
       replace/all data [between "(" ")"] func [head tail] [
            let item: copy/part head tail
            keep item
            if item = "(powerful)" [item: copy "(ren-c)"]
            return uppercase item
        ]
    ]
== ["(real)" "(powerful)" "(magic)"]

&gt;&gt; data
== "(REAL)1020(REN-C)0304(MAGIC)"
</code></pre>
<p>Not only that, but the references to the head and tail of the match are CONST...which prevents the replacement function from messing up the in-progress iteration of the series where the replace is happening.  It only achieves modification by means of what result it synthesizes.</p>
<p>How about that?</p>
<p>cc: <a class="mention" href="https://forum.rebol.info/u/brett">@Brett</a>, <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a>, <a class="mention" href="https://forum.rebol.info/u/johnk">@johnk</a></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/skinning-replace-with-reds-string-parse-hack/2043">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/skinning-replace-with-reds-string-parse-hack/2043</link>
          <pubDate>Thu, 27 Jul 2023 06:23:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2043</guid>
          <source url="https://forum.rebol.info/t/skinning-replace-with-reds-string-parse-hack/2043.rss">Skinning REPLACE with Red&#39;s String PARSE Hack</source>
        </item>
        <item>
          <title>Working With Truthy BLANK! (in SPLIT-PATH Tests)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>The current re-imagining of the concept of truthy/falsey involves the idea that <em>anything you can put into a block is truthy</em>.  That includes BLANK!.</p>
<p>~null~ isotopes are falsey, and will REIFY to be <strong><code>~null~</code></strong> which can be somewhat clumsy-looking.</p>
<p>But consider some test cases for seeing how SPLIT-PATH works, looking a bit like this:</p>
<pre><code>split-path-tests:  [
    %foo                            [_ %foo]
    %/c/test/test2                  [%/c/test/ %test2]
    %/c/test                        [%/c/ %test]
    %//test                         [%// %test]
    %/test                          [%/ %test]
    %//                             [%// _]
    %./                             [%./ _]
    &lt;...etc...&gt;
]
</code></pre>
<p>SPLIT-PATH is a multi-return routine, which gives back two values: the path and the filename.  But if one or the other is missing then that component will be null, which is useful for testing with IF (or using DEFAULT with).</p>
<p>But if we just blindly changed the tests to reify, it would become less legible:</p>
<pre><code>split-path-tests:  [
    %foo                            [~null~ %foo]
    %/c/test/test2                  [%/c/test/ %test2]
    %/c/test                        [%/c/ %test]
    %//test                         [%// %test]
    %/test                          [%/ %test]
    %//                             [%// ~null~]
    %./                             [%./ ~null~]
    &lt;...etc...&gt;
]
</code></pre>
<p>However...with blanks being truthy, this means you that you can take a variable which may be null and turn it into a blank, like this:</p>
<pre><code>reduce [any [path _] any [file _]]
</code></pre>
<p>That's rather succinct!  Probably so succinct that it doesn't need its own native to express.</p>
<p>(I thought it was neat.)</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/working-with-truthy-blank-in-split-path-tests/2007">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/working-with-truthy-blank-in-split-path-tests/2007</link>
          <pubDate>Sat, 14 Jan 2023 15:21:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2007</guid>
          <source url="https://forum.rebol.info/t/working-with-truthy-blank-in-split-path-tests/2007.rss">Working With Truthy BLANK! (in SPLIT-PATH Tests)</source>
        </item>
        <item>
          <title>Jonathan Blow, and Euclid&#39;s Elements</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Jonathan Blow is a video game developer--who made a well known indie game called "Braid" that did some fun time/space manipulations people generally hadn't seen before in a Mario-type platfomer.   Later he took a number of years to make the much higher-budget art piece The Witness...a very intellectual game which has a Sixth-Sense kind of reveal that's quite good.</p>
<p>Though as time changes him from grumpy indie upstart to grumpy-old-man, he has joined the chorus of us grumpy old men when it comes to complexity:</p>
<p><a href="https://www.youtube.com/watch?v=pW-SOdj4Kkk">Jonathan Blow - Preventing the Collapse of Civilization (English only)</a></p>

<p>But I'm pretty sure he would pretty much hate Redbol languages for programming his games.  He doesn't like scripting, and thinks it's dumb to use things without static typing or that catch your mistakes in advance.  (And I'm with him when he responds to people who say things like "but you can try changes without restarting" are wrongheaded.  You can compile checked bits of code and reload them dynamically if your system is designed right.)</p>
<p>What he's looking for is something that offers the benefits of C++ and Rust, but minus the things he considers to be annoying.  "Something like Rust, but cutting out anything that would be an impediment to the games that I--Jonathan Blow--would write."</p>
<p><a href="https://github.com/BSVino/JaiPrimer/blob/master/JaiPrimer.md" class="inline-onebox">JaiPrimer/JaiPrimer.md at master · BSVino/JaiPrimer · GitHub</a></p>
<p>I imagine that if Jonathan <em>were</em> to appreciate something like Ren-C it would be in the way I do--as a game in itself.  (He actually playtested "Baba is You"--according to a YouTube stream of him playing the final version.  When asked what he was paid to give his feedback he just grumbled "not enough".  So I probably won't be sending Ren-C to him.  :-P)</p>
<p>In any case, he was doing a talk on games in education and cited a page from Euclid's Elements that I thought was interesting.  <a href="https://youtu.be/qWFScmtiC44?t=756">The quote he cites says</a>:</p>
<blockquote>
<p><em>"If a first magnitude has to a second the same ratio as a third has to a fourth, and also a fifth has to the second the same ratio as a sixth to a fourth, then the sum of the first and fifth has to the second the same ratio as the sum of the third and sixth has to the fourth."</em></p>
</blockquote>
<p>I'm sure it sounded like nonsense to Euclid's contemporaries, who were not able (or willing) to follow the reasoning for why such things might be important.</p>
<p>When you're reasoning through new abstract things there's lots of phases to it.  Terminology and mechanics evolve over time.  That's how it works, so people shouldn't be surprised to see things like <em><a href="https://forum.rebol.info/t/the-implications-of-meta-producing-quasi-from-isotopes/1967">"The Implications of ^META Producing QUASI! from Isotopes"</a></em>  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/jonathan-blow-and-euclids-elements/1971">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/jonathan-blow-and-euclids-elements/1971</link>
          <pubDate>Sun, 18 Sep 2022 21:14:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1971</guid>
          <source url="https://forum.rebol.info/t/jonathan-blow-and-euclids-elements/1971.rss">Jonathan Blow, and Euclid&#39;s Elements</source>
        </item>
        <item>
          <title>Rebol&#39;s Mission w.r.t. &quot;not wasting RAM or CPU cycles&quot;</title>
          <dc:creator><![CDATA[WickedSmoke]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Rebol was an attempt at grappling with the problems of overly complex and bloated software.  Part of that means not wasting RAM or CPU cycles.</p>
<p>Optimizing is just a normal part of software development. It's not done to please the programmer, but to build something of quality that respects the user who is running other pieces of software that are also using resources.  Think of it as being a good computational neighbor.</p>
<p>There needs to be some thread here about "computing horror stories". A month ago there was an article on Hacker News about NixOS and it's packaging system.  As some Nix user had just contacted me about packaging xu4, I thought I'd give it a spin.  After downloading the ISO and installing it on a virtual machine I went to get a package listing...<br>
and was greeted with some vague error message.</p>
<p>It turns out that the package manager was using well over 1GB of RAM and simply crapped out because my VM didn't have enough.  Some NixOS user told me:</p>
<blockquote>
<p>"Listing all packages is a bit of a weak spot. The entire package set is described in a lazy, functional language and listing or searching it requires evaluating the entire thing."</p>
</blockquote>
<p>This is an entire OS custom built around a package manager, and it couldn't even give me a listing of my packages.  The Nix developers want to geek out about their language, but I just want tools that work.</p>
<p>Thankfully, data-oriented design is now a thing, so I know at least someone is paying attention.</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rebols-mission-w-r-t-not-wasting-ram-or-cpu-cycles/1970">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rebols-mission-w-r-t-not-wasting-ram-or-cpu-cycles/1970</link>
          <pubDate>Sun, 18 Sep 2022 18:19:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1970</guid>
          <source url="https://forum.rebol.info/t/rebols-mission-w-r-t-not-wasting-ram-or-cpu-cycles/1970.rss">Rebol&#39;s Mission w.r.t. &quot;not wasting RAM or CPU cycles&quot;</source>
        </item>
        <item>
          <title>Minor (but nice!) %prot-http.r parsing improvements</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>Here's is R3-Alpha's <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/mezz/prot-http.r">PARSE-WRITE-DIALECT</a> from %prot-http.r</p>
<pre><code>parse-write-dialect: func [port block /local spec] [
    spec: port/spec
    parse block [
        [set block word! (spec/method: block) | (spec/method: 'post)]
        opt [set block [file! | url!] (spec/path: block)]
        [set block block! (spec/headers: block) | (spec/headers: [])]
        [set block [any-string! | binary!] (spec/content: block) | (spec/content: none)]
    ]
]
</code></pre>
<p>You couldn't set paths in R3-Alpha parse, which is weird.  So things had to be captured into a temporary variable (it reused the input block for some reason).</p>
<p>Let's imagine that setting paths were legal:</p>
<pre><code>parse-write-dialect: func [port block /local spec] [
    spec: port/spec
    parse block [
        [set spec/method word! | (spec/method: 'post)]
        opt [set spec/path [file! | url!]]
        [set spec/headers block! | (spec/headers: [])]
        [set spec/content [any-string! | binary!] | (spec/content: none)]
    ]
]
</code></pre>
<p>Let's do a quick transformation of this to PARSE3 in Ren-C, where the keyword TRY now replaces OPT:</p>
<pre><code>parse-write-dialect: func [port block &lt;local&gt; spec] [
    spec: port.spec
    parse3 block [  ; PARSE3 is R3-Alpha-compatible parse
        [set spec.method word! | (spec.method: 'post)]
        try [set spec.path [file! | url!]]
        [set spec.headers block! | (spec.headers: [])]
        [set spec.content [any-string! | binary!] | (spec.content: null)]
    ]
]
</code></pre>
<ul>
<li>
<p>The TUPLE!s help us see we're not making function calls, which is nice</p>
</li>
<li>
<p>/LOCAL is a legitimate normal refinement, and <code>&lt;local&gt;</code> variables are truly local--you can't slip them in from the caller.  Because they are invisible, you can build function compositions that don't have to worry about colliding with their names.</p>
<ul>
<li>It also frees up /LOCAL to just be a typical refinement, like TIME/LOCAL</li>
</ul>
</li>
</ul>
<p>Now let's throw in some UPARSE, with the SET-WORD!s for assignment...</p>
<pre><code>parse-write-dialect: func [port block &lt;local&gt; spec] [
    spec: port.spec
    parse block [  ; PARSE is now UPARSE
        [spec.method: word! | (spec.method: 'post)]
        try [spec.path: [file! | url!]]
        [spec.headers: block! | (spec.headers: [])]
        [spec.content: [any-string! | binary!] | (spec.content: null)]
    ]
]
</code></pre>
<p>It looks a little tighter...but then we also have the ability to factor the assignments out.  And as it happens, that last line could just be <strong>try [any-string! | binary!]</strong>, because TRY would assign the result to NULL if it can't match:</p>
<pre><code>parse-write-dialect: func [port block &lt;local&gt; spec] [
    spec: port.spec
    parse block [
        spec.method: [word! | ('post)]
        spec.path: try [file! | url!]
        spec.headers: [block! | ([])]
        spec.content: try [any-string! | binary!]
    ]
]
</code></pre>
<p>Improved!</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/minor-but-nice-prot-http-r-parsing-improvements/1945">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/minor-but-nice-prot-http-r-parsing-improvements/1945</link>
          <pubDate>Sat, 27 Aug 2022 17:38:07 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1945</guid>
          <source url="https://forum.rebol.info/t/minor-but-nice-prot-http-r-parsing-improvements/1945.rss">Minor (but nice!) %prot-http.r parsing improvements</source>
        </item>
  </channel>
</rss>

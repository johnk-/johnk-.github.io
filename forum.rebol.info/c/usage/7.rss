<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Usage - AltRebol</title>
    <link>https://forum.rebol.info/c/usage/7</link>
    <description>Topics in the &#39;Usage&#39; category Questions and discussion about using Rebol.</description>
    
      <lastBuildDate>Thu, 15 Feb 2024 00:10:21 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/usage/7.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>copy all files in a directory ... a little help please?</title>
          <dc:creator><![CDATA[hcfe]]></dc:creator>
          <category>Usage</category>
          <description><![CDATA[
            <p>Hi everybody,</p>
<p>I'd like to modify this script from the script library: <a href="http://rebol.net/cookbook/recipes/0011.html" rel="noopener nofollow ugc">copy all files in a directory</a> so that it can exclude directories and or files like you can with rsync.</p>
<p>It has been a long time since I've used rebol, and I was never much good at it!</p>
<p>Any help appreciated...</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/copy-all-files-in-a-directory-a-little-help-please/2149">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/copy-all-files-in-a-directory-a-little-help-please/2149</link>
          <pubDate>Thu, 15 Feb 2024 00:10:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2149</guid>
          <source url="https://forum.rebol.info/t/copy-all-files-in-a-directory-a-little-help-please/2149.rss">copy all files in a directory ... a little help please?</source>
        </item>
        <item>
          <title>Fundamental distinguishing features of Rebol</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Perhaps foolishly, I offered to give a talk at my local Functional Programming meetup next month. Given my recent interests, I’m thinking of giving an intro to Rebol and its basic concepts.</p>
<p>So that’s gotten me thinking: what <em>are</em> the basic concepts of Rebol as a programming paradigm, which distinguish it from all others? Here’s what I’ve come up with so far:</p>
<ul>
<li>
<p><strong>Everything is a datatype</strong>: Rebol was built for networking. This means you should be able to take any value, serialise it in a human-readable way, and parse it back into a value. This means a lot of built-in datatypes for useful concepts.</p>
</li>
<li>
<p><strong>Data is code</strong>: Everything starts out its life as data. If you want, you can evaluate it in some way to get a result. Naturally, you can evaluate it using any rules you want, which gives you <strong>dialecting</strong> as a corollary.</p>
<p>(It’s worth noting that this is the converse of Lisp’s famous maxim, ‘code is data’.)</p>
</li>
<li>
<p><strong>Binding</strong>: Word values are associated with their storage. This can be arbitrarily manipulated by the programmer, leading to <strong>definitional scoping</strong>.</p>
</li>
<li>
<p>More generally, I might summarise all the above points as natural consequences of <strong>computing with evaluation</strong>: the fundamental operation of Rebol is taking values and extracting some kind of result from them. This necessitates the other points above: a rich set of datatypes to store both the original value and the result, the ability to treat those datatypes as code which can be evaluated, and a way to look up references during the evaluation process.</p>
</li>
</ul>
<p>Does this all seem reasonable? Have I missed anything?</p>
            <p><small>13 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/fundamental-distinguishing-features-of-rebol/2136">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/fundamental-distinguishing-features-of-rebol/2136</link>
          <pubDate>Mon, 29 Jan 2024 12:55:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2136</guid>
          <source url="https://forum.rebol.info/t/fundamental-distinguishing-features-of-rebol/2136.rss">Fundamental distinguishing features of Rebol</source>
        </item>
        <item>
          <title>Reacting to Definitional Errors: CURTAIL</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>Here's a simple <a href="https://forum.rebol.info/t/introducing-reframer-close-cousin-to-enclose/1395">REFRAMER</a> called CURTAIL:</p>
<pre><code>curtail: reframer function [frame [frame!]] [
    return do frame except e -&gt; [
        if e.id == 'need-non-null [return void]
        raise e
    ]
]
</code></pre>
<p>If you don't remember what reframers do, they just have access to a function call before you run it.  Here we are looking for the function we're running to give us a NEED-NON-NULL error.</p>
<p><em>But we're not looking for just any NEED-NON-NULL error that might go by.</em>  We're only interested in ones that are coming out of the call we're processing.  If that happens, we just vaporize the expression.</p>
<pre><code>&gt;&gt; compose [(null)]
** Script Error: non-NULL value required (see MAYBE, TRY, REIFY)

&gt;&gt; curtail compose [(null)]  ; will give back void
</code></pre>
<p>You can see something like this simplifying null checks:</p>
<pre><code>&gt;&gt; ver: 1.2.3
&gt;&gt; date: null

&gt;&gt; print [curtail spaced ["Version:" ver] curtail spaced ["Date:" date]]
Version: 1.2.3
</code></pre>
<p><em>But like I said, it's not just any NEED-NON-NULL...</em></p>
<pre><code>&gt;&gt; a: 1 b: null c: 3
&gt;&gt; get-ver: func [] [to tuple! reduce [a b c]]

&gt;&gt; print [curtail spaced ["Version:" get-ver] curtail spaced ["Date:" date]]
** Script Error: non-NULL value required (see MAYBE, TRY, REIFY)
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/reacting-to-definitional-errors-curtail/2118">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/reacting-to-definitional-errors-curtail/2118</link>
          <pubDate>Mon, 15 Jan 2024 01:13:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2118</guid>
          <source url="https://forum.rebol.info/t/reacting-to-definitional-errors-curtail/2118.rss">Reacting to Definitional Errors: CURTAIL</source>
        </item>
        <item>
          <title>Variant Of &quot;COLLECT&quot; Without &quot;KEEP&quot;</title>
          <dc:creator><![CDATA[no-e-in]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I recently discovered a version of COLLECT by Brett Handley (for R2) that is less general <em>[<a href="https://forum.rebol.info/t/implementing-collect-keep/2099">than what COLLECT has been come to be known as</a>]</em> but avoids nested code.</p>
<pre><code>collect: func [
    {Collects block evaluations, use as body in For, Repeat, etc.}
    block [block!] "Block to evaluate."
    /initial result [series! datatype!] "Initialise the result."
    /only "Inserts into result using Only refinement."
] [
    if not initial [result: block!]
    result: any [all [datatype? result make result 1000] result]
    reduce ['head pick [insert insert/only] not only 'tail result to paren! block]
]
</code></pre>
<p>Examples (running in Rebol2 interpreter):</p>
<pre><code>&gt;&gt; for i 1 10 2 collect [i * 10]
== [10 30 50 70 90]
    
&gt;&gt; foreach [a b] [1 2 3 4] collect [a + b]
== [3 7]

&gt;&gt; foreach w [a b c d] collect [w]
== [a b c d]

&gt;&gt; repeat e [a b c %.txt] collect/initial [e] %file
== %fileabc.txt

&gt;&gt; iota: func [n [integer!]][repeat i n collect/initial [i] make block! n]
&gt;&gt; iota 10
== [1 2 3 4 5 6 7 8 9 10]
</code></pre>
            <p><small>6 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/variant-of-collect-without-keep/2110">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/variant-of-collect-without-keep/2110</link>
          <pubDate>Thu, 11 Jan 2024 10:05:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2110</guid>
          <source url="https://forum.rebol.info/t/variant-of-collect-without-keep/2110.rss">Variant Of &quot;COLLECT&quot; Without &quot;KEEP&quot;</source>
        </item>
        <item>
          <title>Usefulness of String Interpolation</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="bradrn" data-post="7" data-topic="1751">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751/7">Rebol And Scopes: Well, Why Not?</a>
</div>
<blockquote>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1751">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751/1">Rebol And Scopes: Well, Why Not?</a>
</div>
<blockquote>
<p>Features based on string interpolation are so undeniably useful that once the possibilities are seen, they can't be unseen.</p>
</blockquote>
</aside>
<p>Honestly, I’m not sure I agree with this. In Haskell, which is my main language, there are packages which implement string interpolation… and no-one uses them, because they just aren’t necessary! It’s no big deal when it’s easier to just concatenate stuff together.</p>
</blockquote>
</aside>
<p>To pick a random example from the build helpers for "CScape" interpolation of some generated C code:</p>
<pre><code>emit {
    #define ${MAYBE PREFIX}INCLUDE_PARAMS_OF_${NATIVE-NAME} \
        $[Items]; \
        assert(Get_Series_Info(level_-&gt;varlist, HOLD))
}
</code></pre>
<ul>
<li>
<p>The use of <code>${}</code> (instead of <code>$()</code> or <code>$&lt;&gt;</code>) means that the result of the expression should be <a href="https://github.com/metaeducation/ren-c/blob/815758fb571e88591908dc94f9320581f00d9331/tools/common.r#L37">turned into a valid C identifier name</a>... so dashes are converted to underscores, etc.</p>
</li>
<li>
<p>The use of all capitals in the <code>${}</code> escaping means that the strings generated by the expressions evaluated should be made all uppercase.</p>
</li>
<li>
<p>The use of <code>$[]</code> means that items is an array, and its elements should be printed one line at a time...repeating the boilerplate leading and trailing on each line (in this case an indent on the left, and a semicolon and backslash on the right)</p>
</li>
</ul>
<p>The template looks something like the result:</p>
<pre><code>#define INCLUDE_PARAMS_OF_IF \
    DECLARE_PARAM(1, return); \
    USED(ARG(return)); \
    DECLARE_PARAM(2, condition); \
    DECLARE_PARAM(3, branch); \
    assert(Get_Series_Info(level_-&gt;varlist, HOLD))
</code></pre>
<p>Without interpolation, we fall back on LOAD-able code... where spaces and quotes are required by the language itself.  This starts to lose the ability to keep track of actual spaces in the interpolated thing, plus you keep having to start and stop string delimiters on the string portions.</p>
<p>I'm not quite sure how it would come together dialected via regular code, but it would drift away from looking like C code, at best it might look like:</p>
<pre><code>emit [
    "#define " &lt;c&gt; (MAYBE PREFIX) "INCLUDE_PARAMS_OF_" &lt;c&gt; (NATIVE-NAME) " \"
    "    " @[Items] "; \"
    "    assert(Get_Series_Info(level_-&gt;varlist, HOLD))"
]
</code></pre>
<p><em>I'd be hard-pressed to say the spacing was correct on inspection</em>.  We've lost the intuition about where the unspaced parts are.  You can imagine it getting worse when you're building unspaced material inside a string literal.  Strings can simply be the least noisy medium when you want to see something that looks close to the result.</p>
<p>Anyway, with strings carrying binding, we wouldn't have to do what we do today... which is actually pass the variables (that don't live in LIB) in a block to emit:</p>
<pre><code>emit [prefix native-name items] {  ; &lt;-- ack
    #define ${MAYBE PREFIX}INCLUDE_PARAMS_OF_${NATIVE-NAME} \
        $[Items]; \
        assert(Get_Series_Info(level_-&gt;varlist, HOLD))
}
</code></pre>
<p>So I look forward to getting rid of that.</p>
<aside class="quote no-group quote-modified" data-username="bradrn" data-post="7" data-topic="1751">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751/7">Rebol And Scopes: Well, Why Not?</a>
</div>
<blockquote>
<p>And it’s even easier in Rebol than it is in Haskell, because there’s already a single built-in function to do everything for you:</p>
<pre><code>&gt;&gt; x: 10 y: "foo"
== "foo"
&gt;&gt; print ajoin ["Scopes? " x " " x " " x " " y " " y " " y]
Scopes? 10 10 10 foo foo foo
&gt;&gt; foo: func [x] [local: 20 ajoin ["The sum is " (x + local)]]
&gt;&gt; foo 30
== "The sum is 50"
</code></pre>
<p>I strongly prefer this approach over string concatenation, since by using sensible data structures it integrates much better with the rest of the language. (It also reduces the risk of errors from malformed strings, and potentially the equivalent of SQL injection attacks.)</p>
</blockquote>
</aside>
<p>Note that <a href="https://forum.rebol.info/t/introducing-delimit/2102">Ren-C has DELIMIT (and UNSPACED, SPACED)</a> instead of AJOIN... which hopefully you'll like even better.</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/usefulness-of-string-interpolation/2114">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/usefulness-of-string-interpolation/2114</link>
          <pubDate>Thu, 11 Jan 2024 01:39:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2114</guid>
          <source url="https://forum.rebol.info/t/usefulness-of-string-interpolation/2114.rss">Usefulness of String Interpolation</source>
        </item>
        <item>
          <title>Introducing DELIMIT (plus SPACED and UNSPACED)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>Ren-C offers an alternative to historical AJOIN and REJOIN called DELIMIT:</p>
<pre><code>&gt;&gt; delimit "," ["foo" 1 + 2 "bar"]
== "foo,3,bar"

&gt;&gt; delimit/head "," ["foo" 1 + 2 "bar"]
== ",foo,3,bar"

&gt;&gt; delimit/tail "," ["foo" 1 + 2 "bar"]
== "foo,3,bar,"

&gt;&gt; delimit/head/tail "," ["foo" 1 + 2 "bar"]
== ",foo,3,bar,"
</code></pre>
<p>If you don't want it to reduce, you can use an @ block:</p>
<pre><code>&gt;&gt; delimit "," @["foo" 1 + 2 "bar"]
== "foo,1,+,2,bar"
</code></pre>
<p>SPACED and UNSPACED are specializations, running through the same code for stringifying any non-string contents.</p>
<pre><code>&gt;&gt; spaced ["foo" 1 + 2 "bar"]
== "foo 3 bar"

&gt;&gt; unspaced ["foo" 1 + 2 "bar"]
== "foo3bar"
</code></pre>
<p>PRINT uses SPACED internally when you pass it a block.  You can use <strong>print unspaced</strong> to pass it a string if you want unspaced intent.</p>
<pre><code>&gt;&gt; print ["foo" 1 + 2 "bar"]
foo 3 bar

&gt;&gt; print unspaced ["foo" 1 + 2 "bar"]
foo3bar
</code></pre>
<p>If you use a character (like <span class="hashtag">#a</span>) instead of a string (like "a"), the delimiting won't be applied.  For instance, a newline won't leave spaces on either end of the line break:</p>
<pre><code>&gt;&gt; spaced ["foo" 1 + 2 newline "bar"]
== "foo 3^/bar"
</code></pre>
<p>NULLs will trigger errors, VOIDs will vanish.</p>
<pre><code>&gt;&gt; spaced ["foo" if false [1 + 2] "bar"]
== "foo bar"

&gt;&gt; spaced ["foo" pick [a b] 3 "bar"]
** Script Error: non-NULL value required (see MAYBE, TRY, REIFY)

&gt;&gt; spaced ["foo" maybe pick [a b] 3 "bar"]
== "foo bar"
</code></pre>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/introducing-delimit-plus-spaced-and-unspaced/2102">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/introducing-delimit-plus-spaced-and-unspaced/2102</link>
          <pubDate>Thu, 11 Jan 2024 00:42:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2102</guid>
          <source url="https://forum.rebol.info/t/introducing-delimit-plus-spaced-and-unspaced/2102.rss">Introducing DELIMIT (plus SPACED and UNSPACED)</source>
        </item>
        <item>
          <title>Implementing COLLECT + KEEP</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>COLLECT allows you to build up a block, without needing to name the block or pass it as a parameter to individual APPEND instructions.  Instead you use KEEP, which appends to the implicit nameless block:</p>
<pre><code>&gt;&gt; collect [
       keep 'foo:
       print "Arbitrary code possible"
       keep/line [1 2 3]
       keep spread [Spread #works @(T O O)]
       repeat 2 [keep &lt;whatever&gt;]
    ]
Arbitrary code possible
== [
    foo: [1 2 3]
    Spread #works @(T O O) &lt;whatever&gt; &lt;whatever&gt;]
</code></pre>
<h2>
<a name="leverages-lambda-to-bind-keep-to-code-1" class="anchor" href="https://forum.rebol.info#leverages-lambda-to-bind-keep-to-code-1"></a>Leverages LAMBDA To Bind KEEP To Code</h2>
<p>The trick is that the body is turned into a function that takes KEEP as a parameter.  This defines the word KEEP for the body.</p>
<p>To see how this works, imagine this:</p>
<pre><code>collector: lambda [keep [action?]] [
    keep 'foo:
    print "Arbitrary code possible"
    keep/line [1 2 3]
    keep spread [Spread #works @(T O O)]
    repeat 2 [keep &lt;whatever&gt;]
 ]

 block: copy []
 keeper: specialize :append [series: block]

 collector :keeper
</code></pre>
<p>This code gets the desired result in BLOCK.</p>
<h2>
<a name="slight-twist-make-keep-return-its-input-2" class="anchor" href="https://forum.rebol.info#slight-twist-make-keep-return-its-input-2"></a>Slight Twist: Make KEEP Return Its Input</h2>
<p>APPEND will return the block that you append to.  This would reveal the partially-built temporary block before the collect is complete.  A better and more useful result of KEEP would be to return the value that you pass it.</p>
<p>To accomplish that, we can ENCLOSE the specialization:</p>
<pre><code>keeper: enclose (specialize :append [series: block]) func [f [frame!]] [
    let value: f.value
    do f
    return value
]
</code></pre>
<p>We have to capture the value to append before we DO the captured FRAME!, because Rebol functions are permitted to make arbitrary modifications to their arguments during execution.  <em>(To help avoid mistakes, you are not allowed to read a frame's values after a DO is complete.)</em>  It's possible to DO COPY F but that makes a copy of the entire frame, and here we just copy the value we want.</p>
<p>A more efficient way to do this is to use a LAMBDA for the wrapper function, and ELIDE the DO.  There's no need to type check F (since ENCLOSE only passes the FRAME! built for APPEND, never anything else):</p>
<pre><code>keeper: enclose (specialize :append [series: block]) lambda [f] [
    f.value
    elide do f  ; evaluates to anti-isotope of 0 length block, vanishes
]
</code></pre>
<h2>
<a name="putting-it-together-3" class="anchor" href="https://forum.rebol.info#putting-it-together-3"></a>Putting It Together</h2>
<p>Wrapping this up for a working COLLECT implementation:</p>
<pre><code>collect: func [
    return: [block!]
    body [block!]
][
    let block: copy []
    let keeper: enclose (specialize :append [series: block]) lambda [f] [
        f.value
        elide do f
    ]
    run (lambda [keep] body) :keeper
    return block
]
</code></pre>
<p>It's a good demonstration of how you can make something impressive that feels like a first-class language feature out of Rebol, with little effort.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/implementing-collect-keep/2099">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/implementing-collect-keep/2099</link>
          <pubDate>Wed, 10 Jan 2024 17:20:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2099</guid>
          <source url="https://forum.rebol.info/t/implementing-collect-keep/2099.rss">Implementing COLLECT + KEEP</source>
        </item>
        <item>
          <title>Why is TYPE OF 1 an &amp;INTEGER and not INTEGER!</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>First Steps</category>
          <description><![CDATA[
            <pre><code>&gt;&gt; type of 1         
== &amp;integer
</code></pre>
<p>I would have expected this to print as <code>integer!</code>, since that’s how we refer to it in discussions. But no, it prints with an ampersand. I’m sure there’s some good reason for this, but the apparent inconsistency is jarring.</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/why-is-type-of-1-an-integer-and-not-integer/2097">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/why-is-type-of-1-an-integer-and-not-integer/2097</link>
          <pubDate>Tue, 09 Jan 2024 01:34:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2097</guid>
          <source url="https://forum.rebol.info/t/why-is-type-of-1-an-integer-and-not-integer/2097.rss">Why is TYPE OF 1 an &amp;INTEGER and not INTEGER!</source>
        </item>
        <item>
          <title>Which isotopes are currently in use?</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>First Steps</category>
          <description><![CDATA[
            <p>Since <a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">generalised isotopes</a>, every type has an isotopic form which cannot be stored in blocks. But not every isotopic type makes sense — for instance, what could one do with an isotopic TIME!? So it seems that, out of necessity, practical uses for isotopic values are decided on an ad-hoc basis.</p>
<p>So far, the ones I know about are these:</p>
<ul>
<li>Isotopic GROUP!s are splices, which are pretty trivial to understand</li>
<li>Isotopic FRAME!s are actions, which run themselves when invoked (though in that case I don’t quite get what non-isotopic FRAME!s would be)</li>
<li>Isotopic VOID! is an unset variable, I believe, though the naming seems to have changed so often that I’ve had a lot of trouble following the relevant forum posts</li>
<li>Isotopic COMMA! is… <a href="https://forum.rebol.info/t/the-language-worlds-weirdest-comma-mechanic/1387/6">something</a>… which acts as an expression barrier somehow (though similarly to FRAME! I have trouble distinguishing this from the non-isotopic COMMA!)</li>
<li>Isotopic WORD!s seem to be error states of some description, as well as booleans — except that makes no sense to me, since surely booleans should be storable in blocks‽</li>
<li>I’ve seen a few references to an isotopic NIHIL, but I don’t know what that does nor what a non-isotopic NIHIL would be</li>
</ul>
<p>So… clearly there’s a lot missing. Do we have any comprehensive list of which of the various isotopic types are currently in use, and what they are used for? If not, it would be awfully convenient to have one…</p>
            <p><small>15 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/which-isotopes-are-currently-in-use/2094">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/which-isotopes-are-currently-in-use/2094</link>
          <pubDate>Sun, 07 Jan 2024 05:00:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2094</guid>
          <source url="https://forum.rebol.info/t/which-isotopes-are-currently-in-use/2094.rss">Which isotopes are currently in use?</source>
        </item>
        <item>
          <title>Why Have Both BLOCK! and GROUP!</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>First Steps</category>
          <description><![CDATA[
            <p>Maybe this is a stupid question, but here’s something I’ve been wondering about Rebol: since quoting exists, block!s feel a bit redundant. Something like <code>[a b c]</code> could just as easily be represented as <code>the (a b c)</code>. So, why do both exist?</p>
<p>Or, to put it another way, it feels like Rebol has two orthogonal concepts:</p>
<ul>
<li>Grouping: you can take a bunch of symbols and parenthesize them to get a group!</li>
<li>Quoting: you can take a value and quote it to prevent evaluation</li>
</ul>
<p>So it makes sense that you can combine these: <code>the (a b c)</code>. Except that Rebol doesn’t seem to take advantage of this fact at all — rather, it goes the opposite route, by creating a new data structure which conflates aspects of both of these.</p>
            <p><small>9 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/why-have-both-block-and-group/2092">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/why-have-both-block-and-group/2092</link>
          <pubDate>Fri, 05 Jan 2024 07:25:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2092</guid>
          <source url="https://forum.rebol.info/t/why-have-both-block-and-group/2092.rss">Why Have Both BLOCK! and GROUP!</source>
        </item>
        <item>
          <title>How Much Determinism Should Be Pursued?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>While writing tests for the QUERY dialect against some sample files in a directory, it ran into an issue of the order those files were given back.  <em>Operating system APIs generally do not return the list of files in a determined order, and the ordering across filesystems also varies.</em></p>
<p>This means that even with the same files, you could have the lists come back differently.  One OS could say:</p>
<pre><code>Domain-SQL&gt;&gt; select 'name 'date from %tests/file-tests/
    where 'size &gt; 100 and 'date = 26-Jul-2021

1 [%tests/file-tests/Disk50.txt 26-Jul-2021]
2 [%tests/file-tests/11barz99.txt 26-Jul-2021]
3 [%tests/file-tests/Apple3.txt 26-Jul-2021]
4 [%tests/file-tests/Banana1.txt 26-Jul-2021]
5 [%tests/file-tests/BANANA22.txt 26-Jul-2021]
...
</code></pre>
<p>While another would say:</p>
<pre><code>Domain-SQL&gt;&gt; select 'name 'date from %tests/file-tests/
    where 'size &gt; 100 and 'date = 26-Jul-2021

1 [%tests/file-tests/Apple3.txt 26-Jul-2021]
2 [%tests/file-tests/Banana1.txt 26-Jul-2021]
3 [%tests/file-tests/BANANA22.txt 26-Jul-2021]
4 [%tests/file-tests/Disk50.txt 26-Jul-2021]
5 [%tests/file-tests/11barz99.txt 26-Jul-2021]
...
</code></pre>
<p>This made getting reproducible outputs to verify was hard.</p>
<h2>
<a name="i-made-query-use-sortcase-on-the-read-dir-result-1" class="anchor" href="https://forum.rebol.info#i-made-query-use-sortcase-on-the-read-dir-result-1"></a>I Made QUERY use SORT/CASE on the READ DIR Result</h2>
<p>Getting determinism in the output meant using a function that guarantees an ordering for filenames:</p>
<pre><code>Domain-SQL&gt;&gt; select 'name 'date from %tests/file-tests/
    where 'size &gt; 100 and 'date = 26-Jul-2021

1 [%tests/file-tests/11barz99.txt 26-Jul-2021]
2 [%tests/file-tests/Apple3.txt 26-Jul-2021]
3 [%tests/file-tests/BANANA22.txt 26-Jul-2021]
4 [%tests/file-tests/Banana1.txt 26-Jul-2021]
5 [%tests/file-tests/Disk50.txt 26-Jul-2021]
...
</code></pre>
<p>Having to pay for the sort adds a little bit of overhead, but it's not that significant.</p>
<h2>
<a name="should-read-dir-be-sorted-by-default-2" class="anchor" href="https://forum.rebol.info#should-read-dir-be-sorted-by-default-2"></a>Should READ DIR be Sorted By Default?</h2>
<p>WASI in WebAssembly is looking to chase down sources of non-determinism and see what it can do to stop it.  They mention directory listing order as one potential for problems:</p>
<p><a href="https://github.com/WebAssembly/WASI/issues/190" class="inline-onebox">Roadmap to determinism in WASI · Issue #190 · WebAssembly/WASI · GitHub</a></p>
<p>They seem to believe that on the same OS the directory ordering would be deterministic for the same files, but I don't know of any guarantee of that.</p>
<h2>
<a name="all-this-points-to-bigger-issues-about-reproducibility-3" class="anchor" href="https://forum.rebol.info#all-this-points-to-bigger-issues-about-reproducibility-3"></a>All This Points to Bigger Issues About Reproducibility</h2>
<p>We can pick many examples... like whether a MAP! will always enumerate in the same order on different platforms, or with the same contents.  Using a deterministically sorted implementation of map would seem to have a number of advantages.</p>
<p>Especially since there's a growing push in software for giving deterministic outputs by default.  If you want some reasoning, see this article:</p>
<p><a href="https://buttondown.email/nelhage/archive/determinism-in-software-engineering/" class="inline-onebox">Determinism in software engineering • Buttondown</a></p>
<p>The more testing one does, the more important it seems.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/how-much-determinism-should-be-pursued/2057">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-much-determinism-should-be-pursued/2057</link>
          <pubDate>Thu, 19 Oct 2023 19:34:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2057</guid>
          <source url="https://forum.rebol.info/t/how-much-determinism-should-be-pursued/2057.rss">How Much Determinism Should Be Pursued?</source>
        </item>
        <item>
          <title>COMPOSE of TUPLE! and PATH! (and toplevel GROUP!)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>While working on <a class="mention" href="https://forum.rebol.info/u/blackattr">@BlackATTR</a>'s query, I noticed code that was making paths (now tuples) out of components via TO TUPLE! COMPOSE of a BLOCK!.  Like this:</p>
<pre><code>to tuple! compose [obj clauses (kwd.1)]
</code></pre>
<p>But did you know that COMPOSE can act directly on TUPLE! and PATH!  You could instead just write:</p>
<pre><code>compose 'obj.clauses.(kwd.1)
</code></pre>
<p>It supports splices as well:</p>
<pre><code>&gt;&gt; compose '(10 + 20)/a/b/(spread [c d e])/(reverse [g f])
== 30/a/b/c/d/e/[f g]
</code></pre>
<p>And if you remember that TUPLE! can be nested underneath PATH! (not vice versa) then you can COMPOSE/DEEP and handle mixed tuples and paths:</p>
<pre><code>&gt;&gt; compose/deep '(10 + 20)/a/b.(spread [c d e])
== 30/a/b.c.d.e
</code></pre>
<p>Voids can vanish...so there can be fewer dots in an output tuple than in the input:</p>
<pre><code>&gt;&gt; compose 'a.(if false [b]).c
== a.c
</code></pre>
<p>Empty splices will vanish as well:</p>
<pre><code>&gt;&gt; compose 'a.(spread []).c
== a.c
</code></pre>
<p>You can't compose in NULLs as an important safety measure...central to the design!</p>
<pre><code>&gt;&gt; compose 'a.(select [x 10 y 20] 'b).c
** Script Error: non-NULL value required (see MAYBE, TRY, REIFY)
** Near: [a ** (select [x 10 y 20] 'b) c]
</code></pre>
<p>But don't forget about MAYBE as the way to convert nulls to void when that's what you meant!</p>
<pre><code>&gt;&gt; compose 'a.(maybe select [x 10 y 20] 'b).c
== a.c
</code></pre>
<h2>
<a name="you-can-also-compose-a-group-1" class="anchor" href="https://forum.rebol.info#you-can-also-compose-a-group-1"></a>You can also COMPOSE a GROUP!</h2>
<p>In R3-Alpha, only BLOCK! would compose.  Everything else was passed-through as-is, including GROUP!s (PAREN!s in their terminology)</p>
<pre><code>r3-alpha&gt;&gt; compose quote (1 + (2 + 3))
== (1 + (2 + 3))
</code></pre>
<p>Red just doesn't allow it:</p>
<pre><code>red&gt;&gt; compose quote (1 + (2 + 3))
*** Script Error: compose does not allow paren! for its value argument
</code></pre>
<p>So you'd wind up having to make BLOCK!s and then convert them:</p>
<pre><code>red&gt;&gt; as paren! compose [1 + (2 + 3)]
== (1 + 5)
</code></pre>
<p>But in Ren-C, group composing works... it just leaves the top group as-is.  And you also have quoted groups to make it easier!</p>
<pre><code>&gt;&gt; compose '(1 + (2 + 3))
== (1 + 5)
</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/compose-of-tuple-and-path-and-toplevel-group/2056">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/compose-of-tuple-and-path-and-toplevel-group/2056</link>
          <pubDate>Thu, 19 Oct 2023 06:39:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2056</guid>
          <source url="https://forum.rebol.info/t/compose-of-tuple-and-path-and-toplevel-group/2056.rss">COMPOSE of TUPLE! and PATH! (and toplevel GROUP!)</source>
        </item>
        <item>
          <title>Skinning REPLACE with Red&#39;s String PARSE Hack</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>Red made an unusual choice with their implementation of REPLACE when you use a pattern that's a block with a string.  Instead of trying to stringify the block, <a href="https://github.com/red/red/blob/40096dd12ca9c3b9b47e9eaa995d425b9faf620b/tests/source/units/replace-test.red#L72">they assume it's a PARSE rule</a>:</p>
<pre><code>red&gt;&gt; replace/case/all "aAbbabAAAa" ["Ab" | "Aa"] "-"
== "a-babAA-"
</code></pre>
<p>It seems like a bad idea to make the choice to do this based on the input type.  What if you actually want to do this when the input is a BLOCK!?  I'd prefer something like <strong>parse-replace</strong> <em>(or if we ever allow the same word to be a function and a module, maybe <strong>parse.replace</strong>)</em>.</p>
<p>But honestly, I think that the answer is just to keep pushing on UPARSE itself to be slick enough that you wouldn't feel the need to reach for a shorthand like this.  It's pretty easy to write as is:</p>
<pre><code>&gt;&gt; parse/case "aAbbabAAAa" [
       try some thru [change ["Ab" | "Aa"] ("-")]
       accept &lt;input&gt;
   ]
== "a-babAA-"
</code></pre>
<p>That's probably reaching the limits of how short UPARSE can do an equivalent.  Yet it's more powerful if you want to deviate or customize it, so I would reach for this more often than a limited REPLACE.</p>
<h2>
<a name="still-ren-c-does-backflips-and-lets-you-have-it-your-way-1" class="anchor" href="https://forum.rebol.info#still-ren-c-does-backflips-and-lets-you-have-it-your-way-1"></a>Still, Ren-C Does Backflips And Lets You Have It Your Way</h2>
<p>So you should be able to adapt REPLACE to have Red's behavior if you want it.</p>
<p>Super easy.  Barely an inconvenience!</p>
<pre><code>replace: enclose :lib.replace func [
     f [frame!]
     &lt;local&gt; head tail rule
][
    if not all [
        match [text! binary!] f.target
        block? f.pattern
    ][
        return do f  ; use normal REPLACE semantics
    ]

    rule: if activation? :f.replacement '[  ; function generates replacement
        head: &lt;here&gt;
        change [f.pattern, tail: &lt;here&gt;] (
            apply/relax :f.replacement [const head, const tail]
        )
    ] else '[  ; replacement can be used as-is
        change f.pattern (f.replacement)
    ]

    apply :parse [/case f.case, f.target [
        while [thru rule] (
            if not f.all [return f.target]
        )
        to &lt;end&gt;
    ]]
    return f.target
]
</code></pre>
<h2>
<a name="it-worked-the-first-time-i-ran-it-2" class="anchor" href="https://forum.rebol.info#it-worked-the-first-time-i-ran-it-2"></a>It worked the first time I ran it!</h2>
<p>There's so much interesting stuff going on here that it's hard to list it all. I can quickly hit some high points.</p>
<ul>
<li>
<p>You don't have to repeat the interface of REPLACE.  This is an ENCLOSE, so it just passes the frame built for LIB.REPLACE to the wrapper and lets it choose whether to run that frame as-is (or modified), or do its entirely own thing.</p>
</li>
<li>
<p>It uses the <a href="https://forum.rebol.info/t/the-cool-new-repurposing-of-while-in-parse/1875">kickass new arity-2 WHILE combinator</a> to great effect...simply iterating over the replacement rule.</p>
</li>
<li>
<p><a href="https://forum.rebol.info/t/apply-ii-the-revenge/1834">Modern kickass APPLY</a> for PARSE lets you put arguments in any order, and does refinements by name... here we put /CASE first because it's clearer... then passing the series and the rule.</p>
</li>
<li>
<p>It doesn't just run isotopic actions if they are passed, but it also optionally passes them the head and tail of where in the input is matched.  If the function is arity-1, it just receives the head.  If it's arity-0, it doesn't receive either.  (This is due to APPLY's /RELAX that tolerates too many arguments.)</p>
</li>
</ul>
<p>I wrote a little demo of the fancier function invocation:</p>
<pre><code>&gt;&gt; data: "(real)1020(powerful)0304(magic)"

&gt;&gt; collect [
       replace/all data [between "(" ")"] func [head tail] [
            let item: copy/part head tail
            keep item
            if item = "(powerful)" [item: copy "(ren-c)"]
            return uppercase item
        ]
    ]
== ["(real)" "(powerful)" "(magic)"]

&gt;&gt; data
== "(REAL)1020(REN-C)0304(MAGIC)"
</code></pre>
<p>Not only that, but the references to the head and tail of the match are CONST...which prevents the replacement function from messing up the in-progress iteration of the series where the replace is happening.  It only achieves modification by means of what result it synthesizes.</p>
<p>How about that?</p>
<p>cc: <a class="mention" href="https://forum.rebol.info/u/brett">@Brett</a>, <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a>, <a class="mention" href="https://forum.rebol.info/u/johnk">@johnk</a></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/skinning-replace-with-reds-string-parse-hack/2043">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/skinning-replace-with-reds-string-parse-hack/2043</link>
          <pubDate>Thu, 27 Jul 2023 06:23:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2043</guid>
          <source url="https://forum.rebol.info/t/skinning-replace-with-reds-string-parse-hack/2043.rss">Skinning REPLACE with Red&#39;s String PARSE Hack</source>
        </item>
        <item>
          <title>Working With Truthy BLANK! (in SPLIT-PATH Tests)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>The current re-imagining of the concept of truthy/falsey involves the idea that <em>anything you can put into a block is truthy</em>.  That includes BLANK!.</p>
<p>~null~ isotopes are falsey, and will REIFY to be <strong><code>~null~</code></strong> which can be somewhat clumsy-looking.</p>
<p>But consider some test cases for seeing how SPLIT-PATH works, looking a bit like this:</p>
<pre><code>split-path-tests:  [
    %foo                            [_ %foo]
    %/c/test/test2                  [%/c/test/ %test2]
    %/c/test                        [%/c/ %test]
    %//test                         [%// %test]
    %/test                          [%/ %test]
    %//                             [%// _]
    %./                             [%./ _]
    &lt;...etc...&gt;
]
</code></pre>
<p>SPLIT-PATH is a multi-return routine, which gives back two values: the path and the filename.  But if one or the other is missing then that component will be null, which is useful for testing with IF (or using DEFAULT with).</p>
<p>But if we just blindly changed the tests to reify, it would become less legible:</p>
<pre><code>split-path-tests:  [
    %foo                            [~null~ %foo]
    %/c/test/test2                  [%/c/test/ %test2]
    %/c/test                        [%/c/ %test]
    %//test                         [%// %test]
    %/test                          [%/ %test]
    %//                             [%// ~null~]
    %./                             [%./ ~null~]
    &lt;...etc...&gt;
]
</code></pre>
<p>However...with blanks being truthy, this means you that you can take a variable which may be null and turn it into a blank, like this:</p>
<pre><code>reduce [any [path _] any [file _]]
</code></pre>
<p>That's rather succinct!  Probably so succinct that it doesn't need its own native to express.</p>
<p>(I thought it was neat.)</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/working-with-truthy-blank-in-split-path-tests/2007">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/working-with-truthy-blank-in-split-path-tests/2007</link>
          <pubDate>Sat, 14 Jan 2023 15:21:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2007</guid>
          <source url="https://forum.rebol.info/t/working-with-truthy-blank-in-split-path-tests/2007.rss">Working With Truthy BLANK! (in SPLIT-PATH Tests)</source>
        </item>
        <item>
          <title>Jonathan Blow, and Euclid&#39;s Elements</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Jonathan Blow is a video game developer--who made a well known indie game called "Braid" that did some fun time/space manipulations people generally hadn't seen before in a Mario-type platfomer.   Later he took a number of years to make the much higher-budget art piece The Witness...a very intellectual game which has a Sixth-Sense kind of reveal that's quite good.</p>
<p>Though as time changes him from grumpy indie upstart to grumpy-old-man, he has joined the chorus of us grumpy old men when it comes to complexity:</p>
<p><a href="https://www.youtube.com/watch?v=pW-SOdj4Kkk">Jonathan Blow - Preventing the Collapse of Civilization (English only)</a></p>

<p>But I'm pretty sure he would pretty much hate Redbol languages for programming his games.  He doesn't like scripting, and thinks it's dumb to use things without static typing or that catch your mistakes in advance.  (And I'm with him when he responds to people who say things like "but you can try changes without restarting" are wrongheaded.  You can compile checked bits of code and reload them dynamically if your system is designed right.)</p>
<p>What he's looking for is something that offers the benefits of C++ and Rust, but minus the things he considers to be annoying.  "Something like Rust, but cutting out anything that would be an impediment to the games that I--Jonathan Blow--would write."</p>
<p><a href="https://github.com/BSVino/JaiPrimer/blob/master/JaiPrimer.md" class="inline-onebox">JaiPrimer/JaiPrimer.md at master · BSVino/JaiPrimer · GitHub</a></p>
<p>I imagine that if Jonathan <em>were</em> to appreciate something like Ren-C it would be in the way I do--as a game in itself.  (He actually playtested "Baba is You"--according to a YouTube stream of him playing the final version.  When asked what he was paid to give his feedback he just grumbled "not enough".  So I probably won't be sending Ren-C to him.  :-P)</p>
<p>In any case, he was doing a talk on games in education and cited a page from Euclid's Elements that I thought was interesting.  <a href="https://youtu.be/qWFScmtiC44?t=756">The quote he cites says</a>:</p>
<blockquote>
<p><em>"If a first magnitude has to a second the same ratio as a third has to a fourth, and also a fifth has to the second the same ratio as a sixth to a fourth, then the sum of the first and fifth has to the second the same ratio as the sum of the third and sixth has to the fourth."</em></p>
</blockquote>
<p>I'm sure it sounded like nonsense to Euclid's contemporaries, who were not able (or willing) to follow the reasoning for why such things might be important.</p>
<p>When you're reasoning through new abstract things there's lots of phases to it.  Terminology and mechanics evolve over time.  That's how it works, so people shouldn't be surprised to see things like <em><a href="https://forum.rebol.info/t/the-implications-of-meta-producing-quasi-from-isotopes/1967">"The Implications of ^META Producing QUASI! from Isotopes"</a></em>  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/jonathan-blow-and-euclids-elements/1971">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/jonathan-blow-and-euclids-elements/1971</link>
          <pubDate>Sun, 18 Sep 2022 21:14:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1971</guid>
          <source url="https://forum.rebol.info/t/jonathan-blow-and-euclids-elements/1971.rss">Jonathan Blow, and Euclid&#39;s Elements</source>
        </item>
        <item>
          <title>Rebol&#39;s Mission w.r.t. &quot;not wasting RAM or CPU cycles&quot;</title>
          <dc:creator><![CDATA[WickedSmoke]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Rebol was an attempt at grappling with the problems of overly complex and bloated software.  Part of that means not wasting RAM or CPU cycles.</p>
<p>Optimizing is just a normal part of software development. It's not done to please the programmer, but to build something of quality that respects the user who is running other pieces of software that are also using resources.  Think of it as being a good computational neighbor.</p>
<p>There needs to be some thread here about "computing horror stories". A month ago there was an article on Hacker News about NixOS and it's packaging system.  As some Nix user had just contacted me about packaging xu4, I thought I'd give it a spin.  After downloading the ISO and installing it on a virtual machine I went to get a package listing...<br>
and was greeted with some vague error message.</p>
<p>It turns out that the package manager was using well over 1GB of RAM and simply crapped out because my VM didn't have enough.  Some NixOS user told me:</p>
<blockquote>
<p>"Listing all packages is a bit of a weak spot. The entire package set is described in a lazy, functional language and listing or searching it requires evaluating the entire thing."</p>
</blockquote>
<p>This is an entire OS custom built around a package manager, and it couldn't even give me a listing of my packages.  The Nix developers want to geek out about their language, but I just want tools that work.</p>
<p>Thankfully, data-oriented design is now a thing, so I know at least someone is paying attention.</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rebols-mission-w-r-t-not-wasting-ram-or-cpu-cycles/1970">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rebols-mission-w-r-t-not-wasting-ram-or-cpu-cycles/1970</link>
          <pubDate>Sun, 18 Sep 2022 18:19:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1970</guid>
          <source url="https://forum.rebol.info/t/rebols-mission-w-r-t-not-wasting-ram-or-cpu-cycles/1970.rss">Rebol&#39;s Mission w.r.t. &quot;not wasting RAM or CPU cycles&quot;</source>
        </item>
        <item>
          <title>Minor (but nice!) %prot-http.r parsing improvements</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>Here's is R3-Alpha's <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/mezz/prot-http.r">PARSE-WRITE-DIALECT</a> from %prot-http.r</p>
<pre><code>parse-write-dialect: func [port block /local spec] [
    spec: port/spec
    parse block [
        [set block word! (spec/method: block) | (spec/method: 'post)]
        opt [set block [file! | url!] (spec/path: block)]
        [set block block! (spec/headers: block) | (spec/headers: [])]
        [set block [any-string! | binary!] (spec/content: block) | (spec/content: none)]
    ]
]
</code></pre>
<p>You couldn't set paths in R3-Alpha parse, which is weird.  So things had to be captured into a temporary variable (it reused the input block for some reason).</p>
<p>Let's imagine that setting paths were legal:</p>
<pre><code>parse-write-dialect: func [port block /local spec] [
    spec: port/spec
    parse block [
        [set spec/method word! | (spec/method: 'post)]
        opt [set spec/path [file! | url!]]
        [set spec/headers block! | (spec/headers: [])]
        [set spec/content [any-string! | binary!] | (spec/content: none)]
    ]
]
</code></pre>
<p>Let's do a quick transformation of this to PARSE3 in Ren-C, where the keyword TRY now replaces OPT:</p>
<pre><code>parse-write-dialect: func [port block &lt;local&gt; spec] [
    spec: port.spec
    parse3 block [  ; PARSE3 is R3-Alpha-compatible parse
        [set spec.method word! | (spec.method: 'post)]
        try [set spec.path [file! | url!]]
        [set spec.headers block! | (spec.headers: [])]
        [set spec.content [any-string! | binary!] | (spec.content: null)]
    ]
]
</code></pre>
<ul>
<li>
<p>The TUPLE!s help us see we're not making function calls, which is nice</p>
</li>
<li>
<p>/LOCAL is a legitimate normal refinement, and <code>&lt;local&gt;</code> variables are truly local--you can't slip them in from the caller.  Because they are invisible, you can build function compositions that don't have to worry about colliding with their names.</p>
<ul>
<li>It also frees up /LOCAL to just be a typical refinement, like TIME/LOCAL</li>
</ul>
</li>
</ul>
<p>Now let's throw in some UPARSE, with the SET-WORD!s for assignment...</p>
<pre><code>parse-write-dialect: func [port block &lt;local&gt; spec] [
    spec: port.spec
    parse block [  ; PARSE is now UPARSE
        [spec.method: word! | (spec.method: 'post)]
        try [spec.path: [file! | url!]]
        [spec.headers: block! | (spec.headers: [])]
        [spec.content: [any-string! | binary!] | (spec.content: null)]
    ]
]
</code></pre>
<p>It looks a little tighter...but then we also have the ability to factor the assignments out.  And as it happens, that last line could just be <strong>try [any-string! | binary!]</strong>, because TRY would assign the result to NULL if it can't match:</p>
<pre><code>parse-write-dialect: func [port block &lt;local&gt; spec] [
    spec: port.spec
    parse block [
        spec.method: [word! | ('post)]
        spec.path: try [file! | url!]
        spec.headers: [block! | ([])]
        spec.content: try [any-string! | binary!]
    ]
]
</code></pre>
<p>Improved!</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/minor-but-nice-prot-http-r-parsing-improvements/1945">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/minor-but-nice-prot-http-r-parsing-improvements/1945</link>
          <pubDate>Sat, 27 Aug 2022 17:38:07 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1945</guid>
          <source url="https://forum.rebol.info/t/minor-but-nice-prot-http-r-parsing-improvements/1945.rss">Minor (but nice!) %prot-http.r parsing improvements</source>
        </item>
        <item>
          <title>Weird Little Function: STEAL a Variable&#39;s Prior Value</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I don't know if it has the best name (suggestions?), but it's kind of interesting...</p>
<pre><code>&gt;&gt; x: 304
== 304

&gt;&gt; steal x: 1000 + 20
== 304

&gt;&gt; x
== 1020
</code></pre>
<p>I wrote it as a variadic function for some reason (as a test, maybe?) but you could write it in Redbol.  You could even use their lame ALSO.</p>
<pre><code>steal: func [
    {Red version}
    'var [set-word! set-path!]
    value [any-type!]
][
    also get var set var value
]
</code></pre>
<p>The Ren-C version of that reads a lot better:</p>
<pre><code>steal: lambda [
    {Ren-C version}
    'var [set-word! set-path!]
    value [any-value!]
][
    get var
    elide set var value
]
</code></pre>
<p>It naturally has the benefit of letting you break things across lines.  I feel like it's better to point out "this is the thing being erased".  And of course the mechanic is far more general.</p>
<p>I definitely like ANY-VALUE! better than ANY-TYPE!.</p>
<p>Anyway, I'm sure I've seen places I could have used it if I thought of it.  I'll keep my eyes open.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/weird-little-function-steal-a-variables-prior-value/1943">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/weird-little-function-steal-a-variables-prior-value/1943</link>
          <pubDate>Thu, 25 Aug 2022 16:27:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1943</guid>
          <source url="https://forum.rebol.info/t/weird-little-function-steal-a-variables-prior-value/1943.rss">Weird Little Function: STEAL a Variable&#39;s Prior Value</source>
        </item>
        <item>
          <title>A Justification of Generalized Isotopes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p><em>Here is a train of thought to help people realize why isotopes are needed, and why unifying their behaviors and mechanisms under a common umbrella makes sense.  It starts from the issue of solving /ONLY and then explains the generalization.</em></p>
<p><em>As time permits, I'll come back and try to improve this...</em></p>
<p><em>NOTE: Terminology has changed over time to where what was once called "the isotopic form" of a value is now called "the antiform", in order to be more consistent with the meaning of the word isotope as describing a group of forms in other fields.  You may see lingering references to the old usage.</em></p>
<hr>
<p>Years of fretting over the /ONLY debacle converged on a somewhat inescapable conclusion:</p>
<p><em><strong>It's better to carry the intent of whether a value needs to be spliced on that value...as opposed to having subtle variants of core operations that modulate the splicing.</strong></em></p>
<p>I'd worked up to a point where I was implementing the "mark of intent" by adding a quoting level to <em>suppress</em> splicing.  Yet this faced likely accidents when someone had a quoted value in a variable...and really meant to use it somewhere as-is, with the quote--vs. thinking of the quote as a splice-suppression signal which the operation should remove.</p>
<p>Then <a href="https://forum.rebol.info/t/putting-splicing-intent-on-appended-value/1873/9">@rgchris made this remark</a>:</p>
<aside class="quote no-group quote-modified" data-username="rgchris" data-post="9" data-topic="1873" data-full="true">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"><a href="https://forum.rebol.info/t/putting-splicing-intent-on-appended-value/1873/9">Putting Splicing Intent On APPEND'ed Value</a>
</div>
<blockquote>
<p>The issue I have with doing the opposite of ONLY—let's call it SPREAD—is what is the interim value?</p>
<pre><code>&gt;&gt; block: [a b c [a b c]]

&gt;&gt; find block pick block 4
[[a b c]]

&gt;&gt; find block spread pick block 4
[a b c [a b c]]

&gt;&gt; spread pick block 4
???
</code></pre>
<p>It would seem to have virtue over ONLY and is a better word.</p>
</blockquote>
</aside>
<h2>
<a name="if-trying-this-in-historical-redbol-what-might-one-do-1" class="anchor" href="https://forum.rebol.info#if-trying-this-in-historical-redbol-what-might-one-do-1"></a>If Trying This In Historical Redbol, What Might One Do?</h2>
<p>As a rough first cut, let's represent splices with a specially recognizable 2-element wrapper block.  We'll signal it's a splice with a series in the first slot--checking for the unique identity of that series.  Then put the block itself as the second element:</p>
<pre><code>splice-cue: "!!!splice!!!"

spread: func [block [block!]] [
    return reduce [splice-cue block]
]

splice?: func [value] [
    if not block? :value [return false]
    return same? splice-cue first value
]
</code></pre>
<p>Then we can write our new versions of things like APPEND that are specifically aware of this construct.</p>
<pre><code>append*: func [series [series!] value] [
    return either splice? :value [
        append series second value
    ][
        append/only series :value
    ]
 ]
</code></pre>
<p>It works more or less in your average Redbol, e.g. in Red:</p>
<pre><code>red&gt;&gt; append* [a b c] spread [d e]
== [a b c d e]

red&gt;&gt; append* [a b c] [d e]
== [a b c [d e]]

red&gt;&gt; append* [a b c] 'd
== [a b c d]

red&gt;&gt; append* [a b c] first ['d]
== [a b c 'd]
</code></pre>
<p><em>In fact, this is essentially how the bootstrap executable for Ren-C simulates the SPREAD behavior.</em></p>
<p>But the weaknesses are <em>immediately</em> apparent!!!  <img src="https://forum.rebol.info/images/emoji/twitter/pouting_cat.png?v=12" title=":pouting_cat:" class="emoji" alt=":pouting_cat:" loading="lazy" width="20" height="20"></p>
<h2>
<a name="not-a-distinct-type-too-easy-to-overlook-handling-2" class="anchor" href="https://forum.rebol.info#not-a-distinct-type-too-easy-to-overlook-handling-2"></a>Not A Distinct Type: Too Easy To Overlook Handling</h2>
<p>There's no special type for the spliced block...it's just a BLOCK!.  This means any routine that hasn't been written to handle it, will just let it leak through.</p>
<pre><code>red&gt;&gt; reduce [spread [a b c] [a b c]]
== [["!!!splice!!!" [a b c]] [a b c]]  ; not [a b c [a b c]]
</code></pre>
<p>Changing to some other generic type that can contain a block...such as an OBJECT!...doesn't help matters.  You are kind of in trouble any time an operation willfully lets you put these into an array.</p>
<p><strong>The first instinct might be to introduce a new SPLICE! datatype, with a system-wide rule that splices can't be put into arrays.</strong>  <em>(Enforcing such a rule across all array-manipulating code is challenging...so let's sort of make a note of that fact, but continue.)</em></p>
<p>Because of the peculiar nature of not being able to be put in a block, there'd have to be a decision made about function arguments as to whether or not they took this type.  Many functions designed to handle generic values would not be able to handle them, so there'd presumably need to be some typeset like ANY-NOTSPLICE! or ANY-NORMAL!.</p>
<h2>
<a name="how-to-represent-a-type-that-cant-be-put-in-a-block-3" class="anchor" href="https://forum.rebol.info#how-to-represent-a-type-that-cant-be-put-in-a-block-3"></a>How To Represent A Type That Can't Be Put In A Block?</h2>
<p>Now we've got several things to ponder about our new type.  For instance: what you should see here?</p>
<pre><code>&gt;&gt; obj: make object! [foo: spread [d e]]
== make object! [
    foo: ???
]
</code></pre>
<p>We just said that a defining feature of SPLICE! is that you can't accidentally put them in blocks.  But the argument to MAKE OBJECT!, namely <strong><code>[foo: ???]</code></strong>, is a block.  If <code>???</code> can't itself be a splice!, then what is it?</p>
<p>This brings up a possibly-related question: what if you want a way to put the intent of whether to splice or not into "suspended animation?"... in a way that you could collect it?</p>
<p>Here's a sort of contrived example of the puzzle:</p>
<pre><code>generate: func [n [integer!]] [
   if even? n [return reduce [n n + 1]]
   return spread reduce [n n + 1]
]

wrap: func [
    return: [...]
    in [splice! block!]
][
    ...
]

unwrap: func [
    return: [splice! block!]
    wrapped [...]
][
    ...
]

n: 0
pending: collect [while [n &lt; 4] [keep wrap generate n]]

data: copy []
for-each item pending [append data unwrap item]
</code></pre>
<p>How would you write WRAP and UNWRAP such that at the end of the code above, you'd get:</p>
<pre><code>&gt;&gt; data
== [[0 1] 1 2 [2 3] 3 4]
</code></pre>
<p>If the system didn't provide some answer to this, you'd end up needing to re-invent something kind of equivalent to the primitive <code>["!!!splice!!!" [...]]</code> mechanic as a means of persistence:</p>
<pre><code>&gt;&gt; pending
== [[0 1] ["!!!splice!!!" [1 2]] [2 3] ["!!!splice!!!" [3 4]]]
</code></pre>
<h1>
<a name="isotopes-were-designed-for-this-4" class="anchor" href="https://forum.rebol.info#isotopes-were-designed-for-this-4"></a>Isotopes Were Designed For This!</h1>
<p>Isotopes are a set of curated answers for these problems.  Originally they were introduced to address issues like what an UNSET! was...which has some of the same class of problems as SPLICE! (such as not wanting to be put in BLOCK!s, and not accepted by default or by most routines).</p>
<p>Isotopes introduce two new variants of datatypes called <em>antiforms</em> and <em>quasiforms</em>.  Antiforms cannot be put in blocks.</p>
<p>Isotopes are:</p>
<ul>
<li>
<p><strong>general</strong> - all base value types (e.g. unquoted things) can have antiforms and quasiforms [see note]</p>
</li>
<li>
<p><strong>efficient</strong> - antiforms and quasiforms do not require allocations, and merely are a different state of a byte in the value cell (the same byte that encodes quoting levels)</p>
</li>
<li>
<p><strong>"meta-representable"</strong> - all antiforms can be produced by evaluating their quasiforms, and quasiforms can be produced by evaluating quoted quasiforms.</p>
</li>
</ul>
<p><em>(Note: An edge case is that VOID is not considered an antiform, and so it has an antiform--which is used to represent unsetness.  It might seem that VOID should itself be the antiform of something else, since void can't be put in a block.  But we could also see it as infinitely many voids can be put in a block... since <strong><code>append [a b c] void</code></strong> is just <strong><code>[a b c]</code></strong>.  It just kind of turns out that thinking of void this way appears to work out, and thinking of null as the antiform of the word! null is another thing that works out.)</em></p>
<p>I mentioned at the outset that it would be somewhat costly to bulletproof all of native code against the ability to do something like append a specific data type like "SPLICE!" to a block.  But with isotopes this problem has been solved once for all the forms...so the same code that prevents a so-called "UNSET!" from winding up in arrays works for splices.  <em>That's because a splice is actually a group! antiform, and an unset is actually a void antiform!</em></p>
<p>Above I asked:</p>
<blockquote>
<p>What you should see here?</p>
<pre><code>&gt;&gt; obj: make object! [foo: spread [d e]]
== make object! [
    foo: ???
]
</code></pre>
</blockquote>
<p>Isotopes give us the answer, that it's <strong><code>foo: ~(d e)~</code></strong>.  This is the previously mentioned "QUASIFORM!" of GROUP!, which when evaluated produces an antiform of GROUP!...which by convention represents a splice.</p>
<p><em>But antiforms themselves have no canon representation.</em>  The console can print out a comment or show them in a different color, but to talk about them having a representation doesn't make much sense as you'll never see them in source.</p>
<pre><code>&gt;&gt; ~(d e)~
== ~(d e)~  ; anti
</code></pre>
<p>I also asked:</p>
<blockquote>
<p>"How would you write WRAP and UNWRAP such that at the end of the code above, you'd get:"</p>
<pre><code>&gt;&gt; data
== [[0 1] 1 2 [2 3] 3 4]
</code></pre>
</blockquote>
<p>With group antiforms representing splices, you don't need to write WRAP and UNWRAP... because these operations are built in operations called META and UNMETA.  And the pending array would look like:</p>
<pre><code>&gt;&gt; pending
== ['[0 1] ~(1 2)~ '[2 3] ~(3 4)~]
</code></pre>
<p>When the QUOTED! blocks are UNMETA'd, they become regular blocks and then are appended as-is.  When the QUASIFORM! groups are UNMETA'd they become antiforms and give the splice intent.  This produces the desired "suspended animation" to preserve the intent.</p>
<p><em>That suspended animation is also used in the ^META parameter convention, which indicates a function argument can accept arbitrary antiforms... and the add-quoting-or-quasi behavior brings those antiform variables into a reified state so they can be safely handled.</em></p>
<h2>
<a name="the-proof-is-in-the-capabilities-5" class="anchor" href="https://forum.rebol.info#the-proof-is-in-the-capabilities-5"></a>The Proof Is In The Capabilities</h2>
<p>I've explained about splices, and mentioned how it crosses needs with unset variable states.</p>
<p>But isotopes are also a cornerstone of <a href="https://forum.rebol.info/t/default-values-and-make-frame/1412">how function and FRAME! specialization works</a>.</p>
<p>The ERROR! antiform is used to have a sneaky out-of-band way to return <a href="https://forum.rebol.info/t/fail-vs-return-fail-the-new-age-of-definitional-failures/1852">definitional errors</a></p>
<p>As their applications expand, they are slated to allow us to have non-literal modes to ask something like FIND that you want to look for <em>instances</em> of a datatype by passing that type as an antiform... vs. looking for the datatype's appearance concretely in the target.  Concepts of making only antiform ACTION!s run through WORD! references could make it completely safe to work with arguments passed as variables, saving you from needing GET-WORD!s to handle them.</p>
<p>It's natural for there to be some confusion with the new idea--especially given all its churn through the course of design.  But the design is becoming clearer, and I think people are going to find this gives solidity to writing complicated but coherent code...vastly outpacing historical Redbol.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918</link>
          <pubDate>Tue, 16 Aug 2022 10:23:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1918</guid>
          <source url="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918.rss">A Justification of Generalized Isotopes</source>
        </item>
        <item>
          <title>Enter the Dungeon 💀 ...if You Dare!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <h2>The Imaginary 3-D Dungeon Simulator of the Year, 1983...</h2>
<p>NOW ON THE WEB!!</p>
<p><strong><a href="http://hostilefork.com/media/shared/replpad-js/?do=dungeon">http://hostilefork.com/media/shared/replpad-js/?do=dungeon</a></strong></p>
<p>Source code:</p>
<p><a href="https://github.com/hostilefork/teenage-coding/blob/master/DUNGEON/dungeon.reb">https://github.com/hostilefork/teenage-coding/blob/master/DUNGEON/dungeon.reb</a></p>
<h2>Backstory</h2>
<p>When I was a kid (circa 1983, I'd be about 8 or 9), I played the Intellivision game <a href="http://en.wikipedia.org/wiki/Advanced_Dungeons_&amp;_Dragons:_Treasure_of_Tarmin">Advanced Dungeons and Dragons: Treasure of Tarmin</a>. The 3-D graphics put you in a first-person-perspective point of view with shocking realism:</p>
<p><img src="https://i.stack.imgur.com/X4aGT.png" alt="Shockingly Realistic 3-D Graphics" width="320" height="200"></p>
<p>But a year or two later, I got a C-64. And I was able to draw on the 40x25 character grid by cursoring around the screen, setting the color with the Ctrl key and a digit, and putting symbols anywhere I wanted <em>(why doesn't <code>bash</code> let me do that?)</em>. The character set had triangular components and solid block components.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4.jpeg" data-download-href="https://forum.rebol.info/uploads/default/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4" title="image"><img src="https://forum.rebol.info/uploads/default/optimized/1X/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4_2_252x250.jpeg" alt="image" data-base62-sha1="1Rsurb7Q0aQ1IugNlN0VbFjgToE" width="252" height="250" srcset="https://forum.rebol.info/uploads/default/optimized/1X/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4_2_252x250.jpeg, https://forum.rebol.info/uploads/default/optimized/1X/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4_2_378x375.jpeg 1.5x, https://forum.rebol.info/uploads/default/optimized/1X/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4_2_504x500.jpeg 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4_2_10x10.png"></a></div><p></p>
<p>So I was able to reason through how one might generate a rendering of one's perspective in a grid through that medium.</p>
<p>In 2013, I found the nearly-three-decades-old spec, in spiral-bound notebook paper, about "Dungeon Construction Set":</p>
<p><img src="https://i.stack.imgur.com/WHYpo.jpg" alt="enter image description here" width="320" height="320"></p>
<p><em>(Careful readers will notice that while it's almost right, this doesn't quite hold together on the slanted parts...)</em></p>
<p>Though Treasure of Tarmin was played on a grid, the walls existed only on the <em>edges</em> of grid squares. Having learned what bytes were, I realized that if I made the map out of bytes...then each square on the map could have four possible states for each of its edges:</p>
<ol>
<li>Unobstructed</li>
<li>Wall</li>
<li>Door</li>
<li>Something Else?</li>
</ol>
<p>The design allows for the opportunity that adjacent cells would "disagree"...e.g. have a wall on one side and a door on the other.  I considered this a feature; these situations would give rise to one-way doors and walls that didn't appear until you passed through them and then turned around.</p>
<p>My idea was that a position on the map and a direction you were facing could "light up" regions on the screen...a bit like lighting up segments of a digit on an LCD.</p>
<p>But an implementation of the ideas eluded me.  It was a trickier program than I had written at the time, made even trickier because I was trying to implement it in a "machine language monitor".  I had no assembler, and the book I read didn't discuss them...just the instruction set and workings of the 6502 chip.</p>
<p>(The machine-language-monitor programs could encode single instructions into specific memory locations.  But unlike an assembler, it had no labels or other abstractions...all addresses had to be kept track of on paper.)</p>
<p>By the time I knew enough about programming that I could do something like this in an evening, I no longer cared much about the idea.  But better late than never, right?</p>
<p>Although Unicode/ASCII don't have good "seamless drawing" characters to do this like the C-64 could, it can still get the idea across.</p>
<h2><a href="https://github.com/red/red/pull/612">Originally Wrote this in Red (2013)</a></h2>
<p>I decided I'd use this relatively simple task as something where I would use Red the whole time--as opposed to writing it in Rebol2 or R3-Alpha and then porting the differences.  So that let me get a sense of where the pain points were regarding things like syntax error reporting, that sort of stuff.</p>
<p>Anyway, about a decade later, it's now a Ren-C sample.  Minor modifications were made, including taking advantage of the ReplPad's CLEAR-SCREEN ability (if running on the web).</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/enter-the-dungeon-if-you-dare/1865">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/enter-the-dungeon-if-you-dare/1865</link>
          <pubDate>Wed, 06 Jul 2022 04:59:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1865</guid>
          <source url="https://forum.rebol.info/t/enter-the-dungeon-if-you-dare/1865.rss">Enter the Dungeon 💀 ...if You Dare!</source>
        </item>
        <item>
          <title>The CIRCLED Dialect: Example of the Form</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I was looking at this from the emscripten config file:</p>
<pre><code> ; Right now, either #web or #node (someday #wasm-edge ?)
 ;
 javascript-environment: #web
</code></pre>
<p>And I thought to myself: well that's kind of ugly.  The comment is having to list things that would be more obviously shown by just demonstrating the options:</p>
<pre><code>javascript-environment: circled [(#web) #node]
</code></pre>
<p>It could default to NULL if you circled nothing, but you could use MUST to suggest people needed to select something:</p>
<pre><code>&gt;&gt; number: must circled [#one #two #three]
** Error: MUST requires argument not to be NULL
</code></pre>
<h2>
<a name="its-almost-too-easy-1" class="anchor" href="https://forum.rebol.info#its-almost-too-easy-1"></a>It's Almost <em>Too</em> Easy</h2>
<p>When it's this easy, who wouldn't whip such things up?</p>
<pre><code>circled: lambda [block [block!] &lt;local&gt; result] [
    parse block [
        result: try thru subparse group! [
            &lt;any&gt; &lt;end&gt; | (fail "Circled Items Must Be Singular")
        ]
        try [thru group! (fail "Only One Circle")]
        accept (result)
    ]
]

&gt;&gt; circled [a (b) c]
== b

&gt;&gt; circled [a b c]
; null

&gt;&gt; circled [a (b c)]
** Error: Circled Items Must Be Singular

&gt;&gt; circled [(a) b (c)]
** Error: Only One Circle
</code></pre>
<p>Remarkable plasticity, and I want to see these weapons come to the code golfing field <a href="https://www.youtube.com/watch?v=iDKaz1iB9wQ">once they are adequately Rebmooshed</a>.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<hr>
<p>This example tipped the balance to where I decided that matching <strong><code>&lt;end&gt;</code></strong> should be invisible.  Because I wanted a way to synthesize the result while doing the end match.  Writing <strong><code>elide &lt;end&gt;</code></strong> is possible, but there's essentially no cases in practice where you don't want to elide the end.</p>
<pre><code> &gt;&gt; parse [1 2] ['1 &lt;end&gt; | (fail "Not a 1 followed by the end")]
 ** Error: Not a 1 followed by the end

 &gt;&gt; parse [1] ['1 &lt;end&gt; | (fail "Not a 1 followed by the end")]
 == 1
</code></pre>
<p>The previous result was evaluating the <code>&lt;end&gt;</code> to the input position at that moment of being at the end--so effectively a series at its tail:</p>
<pre><code> &gt;&gt; parse [1] ['1 &lt;end&gt;]
 == []  ; old behavior...how often would you want this?
</code></pre>
<p>If that's what you actually want (which no one ever did) you can can say <strong><code>&lt;end&gt; &lt;here&gt;</code></strong>.</p>
<pre><code> &gt;&gt; parse [1] ['1 &lt;end&gt; &lt;here&gt;]
 == []
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-circled-dialect-example-of-the-form/1849">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-circled-dialect-example-of-the-form/1849</link>
          <pubDate>Sun, 26 Jun 2022 12:06:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1849</guid>
          <source url="https://forum.rebol.info/t/the-circled-dialect-example-of-the-form/1849.rss">The CIRCLED Dialect: Example of the Form</source>
        </item>
        <item>
          <title>Parsing a README.md File To Fill A Folder</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I've integrated <a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a>'s <a href="https://forum.rebol.info/t/js-testing-with-cypress-io/1778/3">Cypress Tests</a> to the GitHub workflow.</p>
<p>There's a certain number of things we want to have work before we "greenlight" a new libr3.wasm file.  Things like Graham's prescription writing app or chess demo are examples of this.</p>
<p>But we don't want the test scripts for those things to live in the Ren-C repository.  Because they need to change as the apps change--and they should also be running whenever those apps get a new commit pushed.</p>
<p>At first I just did a <strong>wget</strong> of the scripts:</p>
<pre><code>cd tests/cypress/e2e
wget https://gitlab.com/Zhaoshirong/rebol-chess/-/raw/master/cypress/e2e/chess.cy.js
wget https://raw.githubusercontent.com/gchiu/midcentral/main/cypress/e2e/rx-app.cy.js
</code></pre>
<p>But this encountered an error, because when git has a directory with no files in it...it doesn't exist.  So there was no e2e directory.</p>
<p>I could have just said <strong>mkdir tests/cypress/e2e</strong> as part of the workflow.  But I figured making a README.md file and putting it in the directory to explain what it was would be easier.</p>
<p>This gave me an idea: <em>What if I put the URLs in the README.md, and then parsed them out and fetched them?</em>  So that's what I did instead!</p>
<p><strong><a href="https://raw.githubusercontent.com/metaeducation/ren-c/master/tests/cypress/e2e/README.md">Here's the README.md</a></strong>, which has <strong><code>* https://whatever</code></strong> lines in it.</p>
<p>Then here's the script that uses the Ren-C GitHub Action:</p>
<pre><code>- name: Collect Cypress Tests from Repositories We Want to Keep Working
  uses: metaeducation/ren-c-action@release
  with:
    script: |
      cd %tests/cypress/e2e/
      list: uparse (as text! read %README.md) [
          collect some [
              '* space [keep url!] newline
            | thru newline
          ]
      ]
      for-each url list [
          filename: second split-path url
          write filename (read url)
      ]</code></pre>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/parsing-a-readme-md-file-to-fill-a-folder/1840">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/parsing-a-readme-md-file-to-fill-a-folder/1840</link>
          <pubDate>Tue, 14 Jun 2022 11:41:40 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1840</guid>
          <source url="https://forum.rebol.info/t/parsing-a-readme-md-file-to-fill-a-folder/1840.rss">Parsing a README.md File To Fill A Folder</source>
        </item>
        <item>
          <title>Demonstrating FOR-BOTH: Loop Composability For The Win :exclamation:</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>FOR-BOTH was an early talking point for an extremely simple usermode loop construct that would be built out of two FOR-EACH loops:</p>
<pre><code> &gt;&gt; for-both x [1 2] [3 4] [print [x], x = 5]
 1
 2
 3
 4
 == #[false]
</code></pre>
<p>A naive implementation of this in Rebol2 might look like:</p>
<pre><code> for-both-naive: func ['var blk1 blk2 body] [
     foreach :var blk1 body
     foreach :var blk2 body
 ]
</code></pre>
<p>...but...</p>
<ul>
<li>
<p><strong>It will not honor BREAK correctly</strong></p>
<pre><code>&gt;&gt; for-both-naive x [1 2] [3 4] [if x = 2 [break], print [x], x = 5]
1
3  ; the BREAK only broke the first FOREACH
4
== #[none]
</code></pre>
<p>There's no way from the outside of Rebol2 or Red's FOREACH to know for sure that a BREAK was requested.  BREAK returns NONE!, but a loop body can (and often does) evaluate to NONE! as well.  Red made it even worse by adding BREAK/RETURN--so a breaking loop can return <em>anything</em>.</p>
<p>So you'd need some kind of complex binding to search the loop bodies and bind the BREAK word to something that throws and gets caught...even for this simple goal.</p>
</li>
<li>
<p><strong>The loop won't evaluate to the last result of the body</strong>.</p>
<pre><code>&gt;&gt; for-both-naive x [1 2] [] [print [x], x * 10]
1  ; evaluated to 10
2  ; evaluated to 20
== #[none!]
</code></pre>
<p>If the second series is empty, the fallout from the first loop is forgotten.</p>
</li>
</ul>
<h2>
<a name="behold-ren-cs-elegant-solution-to-for-both-1" class="anchor" href="https://forum.rebol.info#behold-ren-cs-elegant-solution-to-for-both-1"></a>Behold Ren-C's Elegant Solution to FOR-BOTH</h2>
<p><em>Underneath its apparent simplicity lies quite a lot of deep thought.</em>  And the mechanisms it uses apply far beyond just loops!</p>
<pre><code>    for-both: func ['var blk1 blk2 body] [
        return unmeta all [
            meta for-each (var) blk1 body
            meta for-each (var) blk2 body
        ]
    ]
</code></pre>
<p><em>(Note: see followup for why RETURN is necessary with FUNC, and how to avoid it with LAMBDA.)</em></p>
<h3>
<a name="it-solves-the-break-case-2" class="anchor" href="https://forum.rebol.info#it-solves-the-break-case-2"></a>It solves the BREAK case</h3>
<p>Below we see a situation where the first FOR-EACH returns NULL (and <strong>meta null</strong> is just <strong>null</strong>).  So it short-circuits the ALL, and propagates the null as a signal that it broke:</p>
<pre><code>&gt;&gt; for-both x [1 2] [3 4] [if x = '2 [break], print [x], x = 5]
1
== ~null~  ; isotope
</code></pre>
<p>Note that the first pass through the loop did not terminate the ALL, just because the body evaluated to false.  That's because meta of isotopes produces QUASI!, which is truthy even if the isotopic thing is falsey:</p>
<pre><code> &gt;&gt; metafalse: meta ~false~
 == ~false~

 &gt;&gt; type of metafalse
 == #[datatype! quasi!]

&gt;&gt; if metafalse [print "All QUASI! are truthy!"]
All QUASI! are truthy!
</code></pre>
<p>This means the loop can gracefully recover the QUASI! as the ALL result if the loop completes, and remove the quasi level:</p>
<pre><code>&gt;&gt; for-both x [1 2] [3 4] [print [x], x = 5]
1
2
3
4
== ~false~  ; isotope
</code></pre>
<h3>
<a name="it-solves-the-fallout-from-the-last-loop-body-3" class="anchor" href="https://forum.rebol.info#it-solves-the-fallout-from-the-last-loop-body-3"></a>It Solves the Fallout From The Last Loop Body</h3>
<p>This takes advantage of a new invariant: <em><strong>loops which never run their bodies return void</strong></em>.</p>
<pre><code>&gt;&gt; for-each x [] [fail "This body never runs"]
; void
</code></pre>
<p>Voids act invisibly in constructs like ALL.  So we get the result we want:</p>
<pre><code>&gt;&gt; for-both x [1 2] [] [print [x], x * 10]
1  ; evaluated to 10
2  ; evaluated to 20
== 20
</code></pre>
<p>There's a slight fib here, that META of the void did not produce a "meta-void" (')...but passed it through as it would a NULL.  That's a "user-friendly" property of the META-as-a-word form:</p>
<pre><code>&gt;&gt; meta if false ["META-the-word passes through the vanishing void isotopes"]
; void

&gt;&gt; ^ if false ["The ^ operator is more exact, gives the meta signal"]
== '
</code></pre>
<p>But in situations like this, passing through the void state is what we wanted.</p>
<h3>
<a name="you-can-even-return-null-from-the-body-4" class="anchor" href="https://forum.rebol.info#you-can-even-return-null-from-the-body-4"></a>You Can Even Return NULL From the Body!</h3>
<p>Thanks to isotopes, the following is possible:</p>
<pre><code>&gt;&gt; x: for-both x [1 2] [] [print [x], if x = 2 [null]]
1
2
; first in pack of length 1
== ~null~  ; isotope

&gt;&gt; x
== ~null~ 
</code></pre>
<p>How cool is that?  Even though NULL is being reserved as the unique signal for loops breaking, there's a backchannel for it to escape...out of the FOR-EACH, and up out of the FOR-BOTH wrapping it!</p>
<h2>
<a name="it-holds-up-under-scrutiny-5" class="anchor" href="https://forum.rebol.info#it-holds-up-under-scrutiny-5"></a>It Holds Up Under Scrutiny!</h2>
<p>I'm really pleased with it, and here are some tests:</p>
<p><a href="https://github.com/metaeducation/ren-c/blob/master/tests/loops/examples/for-both.loops.test.reb" class="inline-onebox">ren-c/tests/loops/examples/for-both.loops.test.reb at master · metaeducation/ren-c · GitHub</a></p>
<p>I invite you to test it some more...ask questions...and perhaps come up with your own loop compositions!</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/atom_symbol.png?v=12" title=":atom_symbol:" class="emoji only-emoji" alt=":atom_symbol:" loading="lazy" width="20" height="20"></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833</link>
          <pubDate>Tue, 31 May 2022 16:02:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1833</guid>
          <source url="https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833.rss">Demonstrating FOR-BOTH: Loop Composability For The Win :exclamation:</source>
        </item>
        <item>
          <title>The Rebellion Against Style Guides</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>While driving from Huntsville to Florida, I listened to a talk given by a guy who oversees the general style guide for all of Google's multi-millions of lines of C++.</p>
<p>He spoke very positively about a formatting tool called <code>clang-format</code>, and how if he had his way at Google...there would be no arguing over code formatting.  He felt the robot did a better job on average than even the best developers...and being willing to delegate formatting to the tool gave them time to work on more important things.</p>
<p><strong>My well-known opinion for code like C++ or Rust or Java is that it is best represented as a graph data structure that captures the relationships and identities.</strong>  How you render that is up to the program you use to view and edit the projection of that essential code.  It doesn't matter if code is in braces or has a box drawn around it.  You could make expressions feed into an actual logical circuit AND gate instead of using <code>&amp;&amp;</code> or the word <code>and</code> or what-have-you.</p>
<p><strong>But Rebol is different (and almost absurdist) in the software world.</strong>  If anything, it has an <em>anti</em>-style guide, in <a href="http://www.rebol.com/article/0103.html">The Deep Lake / (Swamp)</a>, where Carl says:</p>
<blockquote>
<p>Suppose I write:</p>
<pre><code>if time &gt; 10:00 [
    wakeup user
]
</code></pre>
<p>which some users may choose to rewrite it this way:</p>
<pre><code>if time &gt; 10:00
[
    wakeup user
    alert "Time to work"
 ]
</code></pre>
<p>But, what if the "then block" is a variable itself, defined as:</p>
<pre><code> action: [
     wakeup user
     alert "Time to work"
  ]
</code></pre>
<p>Would you write this:</p>
<pre><code>  if time &gt; 10:00
      action
</code></pre>
<p>or this:</p>
<pre><code>   if time &gt; 10:00 action
</code></pre>
</blockquote>
<p>The conclusion is:</p>
<blockquote>
<p>...<strong>how you write code is ultimately your choice alone</strong>. REBOL, as a context dependent language, is perhaps the most freeform computing language ever invented.</p>
</blockquote>
<p>I'm bringing this up because I'm mothballing an old Trello and looking for any links or information worth preserving.  It had a card requesting a style guide, pointing out a limited bit that had been written in the Rebol2 manual:</p>
<p><a href="http://www.rebol.com/docs/core23/rebolcore-5.html#section-5">http://www.rebol.com/docs/core23/rebolcore-5.html#section-5</a></p>
<p>I'm really only interested in the bits that reduce complexity (like just-say-no-to-CRLF files, or tabs, etc.)  As for the code itself, this is kind of an ASCII-art medium.</p>
<p>So a good "style guide" for Rebol would be one that showed examples of how to take advantage of the degrees of freedom to be bent to your purposes.  I think a good one was the <strong><a href="https://forum.rebol.info/t/testing-generic-tuple-and-path-structuring/1353">tuple and path test dialect</a></strong>.  But there are certainly more!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-rebellion-against-style-guides/1819">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-rebellion-against-style-guides/1819</link>
          <pubDate>Sat, 14 May 2022 05:39:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1819</guid>
          <source url="https://forum.rebol.info/t/the-rebellion-against-style-guides/1819.rss">The Rebellion Against Style Guides</source>
        </item>
        <item>
          <title>My Summary of the Big Picture</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>First Steps</category>
          <description><![CDATA[
            <p>I wrote this to someone in a GitHub issue and thought it was pretty salient:</p>
<blockquote>
<p>What has drawn people to Rebol historically has varied. But a large number who praised it and used it were less interested in the language itself, rather the properties of the executable. It was small, and you could run on any OS without installing anything else...it came with a GUI built in.</p>
<p>But when serious language theorists look at Rebol, they notice it is riddled with design holes. The language itself wasn't <em>composable</em> the way one might like languages to be: mixing constructs in new ways that weren't specifically accounted for never worked. It was more like a "scriptable app" that had a few features that pleased its userbase...and had to be extended by the designer every time a new need came up.</p>
<p>So put briefly: If you don't understand what these holes are, then you won't appreciate the many issues that Ren-C is trying to solve.</p>
<p>Once you know that historical Rebol was fundamentally broken, there are basically 3 choices:</p>
<ol>
<li>Inventory and address the holes one at a time and try to fix or mitigate them</li>
<li>Ignore the holes and just hope that if you add enough features and integration no one will notice</li>
<li>Turn away and run from the crackpots using it, and work with a more solidly designed language</li>
</ol>
<p>(1) is Ren-C's hard-chosen path. Energy is spent on identifying certain patterns in source that users <em>must</em> be able to write and have work, if the language is to justify its existence at all. While it would be nice if stack traces were beautiful and if building the sources was 100% easy, all of that would be meaningless if the punch line was <em>"oh, and the language this is all supporting doesn't actually work"</em></p>
<p>(2) is chosen by people like Red and <a href="https://github.com/Oldes/Rebol3">Oldes's branch of R3-Alpha</a>, as well as some clones that have popped up over the years. Starting from scratch inevitably makes the same mistakes.</p>
<p>(3) is probably the most sensible choice, but if I didn't think there was some promise in the language I wouldn't be pursuing (1).</p>
</blockquote>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/my-summary-of-the-big-picture/1792">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/my-summary-of-the-big-picture/1792</link>
          <pubDate>Fri, 18 Feb 2022 19:37:40 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1792</guid>
          <source url="https://forum.rebol.info/t/my-summary-of-the-big-picture/1792.rss">My Summary of the Big Picture</source>
        </item>
  </channel>
</rss>

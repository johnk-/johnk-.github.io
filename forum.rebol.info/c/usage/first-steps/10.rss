<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Questions - AltRebol</title>
    <link>https://forum.rebol.info/c/usage/first-steps/10</link>
    <description>Topics in the &#39;Questions&#39; category Everybody is new to Rebol at some point. Whether you are struggling with the installation or you just can&#39;t figure out why you are not seeing the performance everybody else seems to be talking about.</description>
    
      <lastBuildDate>Sun, 25 Aug 2024 03:58:41 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/usage/first-steps/10.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Why is &lt;/&gt; a TAG! and not a PATH! (or WORD!)?</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="2218">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"><a href="https://forum.rebol.info/t/wolfram-language/2218/4">Wolfram Language</a></div>
<blockquote>
<p><strong><code>&lt;/&gt;</code></strong> is a TAG!</p>
</blockquote>
</aside>
<p>This strikes me as being odd. It’s not a valid closing tag in HTML or XML, for instance. I find it natural to interpret this as ‘path from <code>&lt;</code> to <code>&gt;</code>’.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/why-is-a-tag-and-not-a-path-or-word/2219">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/why-is-a-tag-and-not-a-path-or-word/2219</link>
          <pubDate>Sun, 25 Aug 2024 03:58:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2219</guid>
          <source url="https://forum.rebol.info/t/why-is-a-tag-and-not-a-path-or-word/2219.rss">Why is &lt;/&gt; a TAG! and not a PATH! (or WORD!)?</source>
        </item>
        <item>
          <title>&quot;More arguments for a function on request&quot; (Variadics)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>On Red's Gitter, <a href="https://matrix.to/#/!EorVRCzrVpjojJtctJ:gitter.im/$9hee8CVtrrHeVB7GTvPmKo2hV04eYAjOrhH64C3j5kY?via=gitter.im&amp;via=matrix.org&amp;via=chat.weho.st">@GiuseppeChillemi asked</a>:</p>
<blockquote>
<p>Do you think it would be possible to get more arguments for a function on request?</p>
<p>Example:</p>
<pre><code>aaa: 1
bbb: 2
ccc: 3
f: func [arg1] [other-args: get-args 3]
f arg1-val aaa bbb ccc
</code></pre>
</blockquote>
<p>And Gregg says "oh that would make Red unsafe" (as if Red were somehow "safe").</p>
<p>Anyway, Ren-C has some support for variadics.  While the implementation hasn't gotten a lot of attention in a while, it's no less safe than anything else--the mechanisms used are the same ones that gather ordinary arguments.</p>
<pre><code> aaa: 1
 bbb: 2
 ccc: 3
 f: func [arg1 others [&lt;variadic&gt; any-value?]] [
     return collect [keep arg1, repeat 3 [keep take others]]
 ]

 &gt;&gt; f 1020 aaa bbb ccc
 == [1020 1 2 3]
</code></pre>
<p>The interface is probably not what it's going to ultimately be.  But for now, you can mark a parameter <code>&lt;variadic&gt;</code> and it will be a VARARGS!, that supports TAKE to acquire parameters after the call is made.</p>
<p>Variadics should be used sparingly, because they are difficult to wrap and abstract.  There are some mechanisms for APPLY'ing variadics using a BLOCK! to supply the variadic arguments, but the interface for that is also likely to change.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/more-arguments-for-a-function-on-request-variadics/2174">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/more-arguments-for-a-function-on-request-variadics/2174</link>
          <pubDate>Tue, 19 Mar 2024 09:51:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2174</guid>
          <source url="https://forum.rebol.info/t/more-arguments-for-a-function-on-request-variadics/2174.rss">&quot;More arguments for a function on request&quot; (Variadics)</source>
        </item>
        <item>
          <title>Getting an unset variable</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>Nothing (now anti BLANK!) <a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604">has been established</a> as the value of unset variables. As the example in that thread states:</p>
<pre><code class="lang-plaintext">&gt;&gt; nothing-value
** Error: NOTHING-VALUE variable is unset

&gt;&gt; append [a b] get/any 'nothing-value
** Error: APPEND does not allow adding ~ antiforms to blocks
</code></pre>
<p>But when I try this, I get quite different results:</p>
<pre><code class="lang-plaintext">&gt;&gt; nothing-value
** Script Error: nothing-value word is attached to a context, but unassigned

&gt;&gt; append [a b] get/any 'nothing-value
** Script Error: nothing-value word is not bound to a context
</code></pre>
<p>In fact, even GET/ANY doesn’t seem to work… even when I make sure the binding is right:</p>
<pre><code class="lang-plaintext">&gt;&gt; get/any 'nothing-value
** Script Error: nothing-value word is not bound to a context

&gt;&gt; get/any $nothing-value             
** Script Error: nothing-value word is attached to a context, but unassigned
</code></pre>
<p>So, what’s happening here? And how <em>do</em> I get nothing out of an unset variable?</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/getting-an-unset-variable/2169">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/getting-an-unset-variable/2169</link>
          <pubDate>Sat, 09 Mar 2024 02:39:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2169</guid>
          <source url="https://forum.rebol.info/t/getting-an-unset-variable/2169.rss">Getting an unset variable</source>
        </item>
        <item>
          <title>How To Choose Between Returning VOID and NIHIL?</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="2283">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"><a href="https://forum.rebol.info/t/what-are-null-void-nothing-blank-and-nihil/2283/6">What Are NULL, VOID, NOTHING, BLANK, and NIHIL?</a></div>
<blockquote>
<p>Void is used generically in many places when you want things to vanish:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; compose [&lt;a&gt; (if false [&lt;b&gt;]) &lt;c&gt;]
== [&lt;a&gt; &lt;c&gt;]
</code></pre>
</blockquote>
</aside>
<p>Ah-ha… I’d completely missed this use of void, as a return value.</p>
<p>Though this does now raise the question of whether a function should return nihil or void. Both seem to vaporise in lists, after all. I guess it depends on whether you want the function call to be ignored or not.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/how-to-choose-between-returning-void-and-nihil/2171">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-to-choose-between-returning-void-and-nihil/2171</link>
          <pubDate>Sat, 09 Mar 2024 02:30:26 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2171</guid>
          <source url="https://forum.rebol.info/t/how-to-choose-between-returning-void-and-nihil/2171.rss">How To Choose Between Returning VOID and NIHIL?</source>
        </item>
        <item>
          <title>Why is TYPE OF 1 an &amp;INTEGER and not INTEGER!</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <pre><code>&gt;&gt; type of 1         
== &amp;integer
</code></pre>
<p>I would have expected this to print as <code>integer!</code>, since that’s how we refer to it in discussions. But no, it prints with an ampersand. I’m sure there’s some good reason for this, but the apparent inconsistency is jarring.</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/why-is-type-of-1-an-integer-and-not-integer/2097">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/why-is-type-of-1-an-integer-and-not-integer/2097</link>
          <pubDate>Tue, 09 Jan 2024 01:34:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2097</guid>
          <source url="https://forum.rebol.info/t/why-is-type-of-1-an-integer-and-not-integer/2097.rss">Why is TYPE OF 1 an &amp;INTEGER and not INTEGER!</source>
        </item>
        <item>
          <title>Which Antiforms Are In Use?</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>As an aid for myself, I made a summary table:</p>
<div class="md-table">
<table>
<thead>
<tr>
<th>Type</th>
<th>Antiform</th>
<th>Usage</th>
<th>Stable?</th>
</tr>
</thead>
<tbody>
<tr>
<td>BLANK!</td>
<td>nothing</td>
<td>Unset variables</td>
<td>✓</td>
</tr>
<tr>
<td>TAG!</td>
<td>tripwire</td>
<td>Unset variable with informative message</td>
<td>✓</td>
</tr>
<tr>
<td>WORD!</td>
<td>keyword</td>
<td>Special constant values (e.g. ~null~, ~void~)</td>
<td>✓</td>
</tr>
<tr>
<td>GROUP!</td>
<td>splice</td>
<td>Multiple values without a surrounding block</td>
<td>✓</td>
</tr>
<tr>
<td>FRAME!</td>
<td>action</td>
<td>Trigger function execution from words</td>
<td>✓</td>
</tr>
<tr>
<td>PARAMETER!</td>
<td>hole</td>
<td>Unspecialized slots in a function frame</td>
<td>✓</td>
</tr>
<tr>
<td>BLOCK!</td>
<td>pack</td>
<td>Multi-returns from a function</td>
<td>✗</td>
</tr>
<tr>
<td>COMMA!</td>
<td>barrier</td>
<td>Discarded by evaluator</td>
<td>✗</td>
</tr>
<tr>
<td>ERROR!</td>
<td>raised</td>
<td>Errors raised from a function call</td>
<td>✗</td>
</tr>
<tr>
<td>OBJECT!</td>
<td>lazy</td>
<td>(to be confirmed)</td>
<td>✗</td>
</tr>
</tbody>
</table>
</div>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/which-antiforms-are-in-use/2276">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/which-antiforms-are-in-use/2276</link>
          <pubDate>Tue, 09 Jan 2024 00:31:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2276</guid>
          <source url="https://forum.rebol.info/t/which-antiforms-are-in-use/2276.rss">Which Antiforms Are In Use?</source>
        </item>
        <item>
          <title>Why Isn&#39;t LOGIC (e.g. result of 10 &gt; 20) Storable in BLOCK! ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="bradrn" data-post="1" data-topic="2094">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/2094/1">On another topic</a></div>
<blockquote>
<p>Isotopic WORD!s seem to be error states of some description, as well as booleans — except that makes no sense to me, since surely booleans should be storable in blocks‽</p>
</blockquote>
</aside>
<p>Rebol made an unusual choice in deciding that all things that "look like" words would be words, and reassignable.  So <strong>true</strong> and <strong>false</strong> were kept following the general rules of words.  Including that all words are truthy.</p>
<pre><code>&gt;&gt; code: [flag: false]

&gt;&gt; second code
== false

&gt;&gt; if second code [print "the word false is truthy"]
the word false is truthy
</code></pre>
<p>There was a LOGIC! type, and it could be made via the <code>#[true]</code> and <code>#[false]</code> notation:</p>
<pre><code>rebol2&gt;&gt; code: [flag: #[false]]

rebol2&gt;&gt; if not second code [print "the literal #[false] is falsey"]
the literal #[false] is falsey
</code></pre>
<p>So the default definitions are <strong>true: #[true]</strong> and <strong>false: #[false]</strong>.  But the rendering would conflate with the word, despite not being a word:</p>
<pre><code>rebol2&gt;&gt; code: [flag: #[false]]

rebol2&gt;&gt; code
== [flag: false]

rebol2&gt;&gt; type? second code
== logic!

rebol2&gt;&gt; true
== true

rebol2&gt;&gt; word? true
== false
</code></pre>
<p>There was puzzling about wondering what a better notation for LOGIC! literals might be.  Considerations included things like <strong>$true</strong> and <strong>$false</strong>, among others.</p>
<p>I wanted to see there be <strong><code>$word $(gr o up) $[bl o ck] $tu.p.le $pa/th</code></strong> as additional pieces in the box of parts...so sacrificing $ for this wasn't appealing to me.</p>
<p>Hence for a long time, Ren-C just rendered them as #[true] and #[false].</p>
<h2><a name="p-6844-rebolreds-bad-rendering-reveals-a-subliminal-truth-1" class="anchor" href="https://forum.rebol.info#p-6844-rebolreds-bad-rendering-reveals-a-subliminal-truth-1"></a>Rebol/Red's Bad Rendering Reveals a Subliminal Truth</h2>
<p>As it turns out, a lot of places where you're building up structures you don't want an ugly literal (however it looks).  For a lot of scenarios you want to reconstitute the word.</p>
<p>When isotopes came on the scene it afforded the interesting choice to say that the logic-reactive ~true~ and ~false~ antiforms couldn't be put into blocks... and would have to be triaged.</p>
<pre><code>&gt;&gt; false
== ~false~  ; anti

&gt;&gt; append [flag:] false
** Error

&gt;&gt; append [flag:] meta false
== [flag: ~false~]  ; evaluates to the right thing under DO

&gt;&gt; append [flag:] logic-to-word false
== [flag: false]
</code></pre>
<h2><a name="p-6844-all-block-items-truthy-out-of-bounds-null-2" class="anchor" href="https://forum.rebol.info#p-6844-all-block-items-truthy-out-of-bounds-null-2"></a>All BLOCK! Items Truthy, Out-of-Bounds NULL</h2>
<p>This gave another benefit, which is that the null returned from out-of-bounds access of arrays gives the unique falsey result for various enumerations.  For example:</p>
<pre><code> &gt;&gt; block: [a b ~false~ c]

 &gt;&gt; while [value: try take block] [print mold value]
 a
 b
 ~false~
 c
</code></pre>
<p>Or:</p>
<pre><code>&gt;&gt; block: [a b ~false~ c]

&gt;&gt; third block
== ~false~

&gt;&gt; if third block [print "There's a third element in block"]
There's a third element in block

&gt;&gt; fifth block
== ~null~  ; isotope

&gt;&gt; if not fifth block [print "No fifth element in block"]
No fifth element in block
</code></pre>
<p>These kinds of scenarios present classic problems in Rebol and Red, because people will write code assuming that they can use conditional logic to decide if a value is there... but then one day they hit a LOGIC! or a NONE! literal and it breaks.  Having nothing that's actually in a block be falsey is a good thing.</p>
<h2><a name="p-6844-eventually-false-null-and-true-okay-3" class="anchor" href="https://forum.rebol.info#p-6844-eventually-false-null-and-true-okay-3"></a>Eventually, <code>~false~</code> =&gt; <code>~null~</code> and <code>~true~</code> =&gt; <code>~okay~</code></h2>
<p>While antiform LOGIC showed benefits, it didn't show benefit to having a separate <strong><code>~false~</code></strong> type from <strong><code>~null~</code></strong>.  The real value of TRUE and FALSE came from being the recognizable words themselves.  Which weren't necessarily better than other choices (like ON and OFF, or YES and NO).</p>
<p>So the system migrated to something called <a href="https://forum.rebol.info/t/flexible-logic-system-terminology/2252">"Flexible Logic"</a>.  This introduced a new antiform complement to NULL called OKAY, and focused on the conversion between these forms and words when block representations were necessary.</p>
<h2><a name="p-6844-no-answer-is-perfect-but-this-has-solid-benefits-4" class="anchor" href="https://forum.rebol.info#p-6844-no-answer-is-perfect-but-this-has-solid-benefits-4"></a>No Answer is Perfect, But This Has Solid Benefits</h2>
<p>The need to store things in blocks that are themselves directly testable as falsey isn't all that valuable in practice.  And it frequently led to broken code when people were assuming a conditional test could be used to know whether an element was in a block or not.</p>
<p>Encouraging discipline in triage with whether you want a word or a meta-representation of a logic (which evaluates to something that has the "branch triggering" or "branch inhibiting" property) has--in my opinion--turned out to be a net benefit.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/why-isnt-logic-e-g-result-of-10-20-storable-in-block/2095">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/why-isnt-logic-e-g-result-of-10-20-storable-in-block/2095</link>
          <pubDate>Sun, 07 Jan 2024 06:12:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2095</guid>
          <source url="https://forum.rebol.info/t/why-isnt-logic-e-g-result-of-10-20-storable-in-block/2095.rss">Why Isn&#39;t LOGIC (e.g. result of 10 &gt; 20) Storable in BLOCK! ?</source>
        </item>
        <item>
          <title>Why Have Both BLOCK! and GROUP!</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>Maybe this is a stupid question, but here’s something I’ve been wondering about Rebol: since quoting exists, block!s feel a bit redundant. Something like <code>[a b c]</code> could just as easily be represented as <code>the (a b c)</code>. So, why do both exist?</p>
<p>Or, to put it another way, it feels like Rebol has two orthogonal concepts:</p>
<ul>
<li>Grouping: you can take a bunch of symbols and parenthesize them to get a group!</li>
<li>Quoting: you can take a value and quote it to prevent evaluation</li>
</ul>
<p>So it makes sense that you can combine these: <code>the (a b c)</code>. Except that Rebol doesn’t seem to take advantage of this fact at all — rather, it goes the opposite route, by creating a new data structure which conflates aspects of both of these.</p>
            <p><small>9 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/why-have-both-block-and-group/2092">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/why-have-both-block-and-group/2092</link>
          <pubDate>Fri, 05 Jan 2024 07:25:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2092</guid>
          <source url="https://forum.rebol.info/t/why-have-both-block-and-group/2092.rss">Why Have Both BLOCK! and GROUP!</source>
        </item>
        <item>
          <title>Why IF is void on no branch, while CASE+SWITCH are null</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>For a time, all control structures returned void when they did not branch.  This was motivated in particular by wanting IFs to vanish quietly when they didn't take their branch.  At first it was just COMPOSE:</p>
<pre><code> &gt;&gt; compose [&lt;a&gt; (if false [&lt;b&gt;]) &lt;c&gt;]
 == [&lt;a&gt; &lt;b&gt;]
</code></pre>
<p>But this spread to things like REDUCE, ANY, ALL, etc.</p>
<pre><code>&gt;&gt; reduce [1 + 2 if false [30] 100 + 200]
== [3 300]

&gt;&gt; all [&lt;a&gt; if false [&lt;b&gt;] if true [&lt;c&gt;]]
== &lt;c&gt;
</code></pre>
<p>The cleanliness of this is extremely desirable.  It would lose a lot if you had to throw in a NULL-TO-VOID conversion (what we call "MAYBE")</p>
<pre><code>&gt;&gt; compose [&lt;a&gt; (maybe if false [&lt;b&gt;]) &lt;c&gt;]
== [&lt;a&gt; &lt;b&gt;]

&gt;&gt; reduce [1 + 2 maybe if false [30] 100 + 200]
== [3 300]

&gt;&gt; all [&lt;a&gt; maybe if false [&lt;b&gt;] maybe if true [&lt;c&gt;]]
== &lt;c&gt;
</code></pre>
<h2>
<a name="void-becomes-a-casualty-of-its-friendliness-1" class="anchor" href="https://forum.rebol.info#void-becomes-a-casualty-of-its-friendliness-1"></a>VOID Becomes A Casualty Of Its Friendliness</h2>
<p>At first, void variables would cause errors on access.  But this was softened, allowing them to be fetched without using GET-WORD! access or other fanfare:</p>
<pre><code>&gt;&gt; x: void

&gt;&gt; append [a b c] x
== [a b c]
</code></pre>
<p>Having things like CASE and SWITCH produce these is easily is a little bit unsettling.  All that has to happen is that you have a branch list that is not exhaustive.</p>
<p>For instance:</p>
<pre><code>lib: switch config.platform [
    'Windows [%windows.lib]
    'Linux [%linux.a]
]
</code></pre>
<p>You've now got LIB as VOID.  It's uncomfortable to think about how such casual creation of voids makes a value that will go around opting out of things.</p>
<p>This puts a burden on people writing such lists to throw in a FAIL at the ending:</p>
<pre><code>lib: switch config.platform [
    'Windows [%windows.lib]
    'Linux [%linux.a]
    fail  ; not so hard to do this if you don't want VOIDs
]
</code></pre>
<h2>
<a name="butwhat-if-you-want-a-null-2" class="anchor" href="https://forum.rebol.info#butwhat-if-you-want-a-null-2"></a>But...What if you <em>WANT</em> a NULL?</h2>
<p>As it happens, due to the <a href="https://forum.rebol.info/t/the-fallout-from-the-switch-fallout-feature/312">SWITCH and CASE "Fallout" Feature</a>, this also works with things like NULL:</p>
<pre><code>lib: switch config.platform [
    'Windows [%windows.lib]
    'Linux [%linux.a]
    null
]
</code></pre>
<p>Basically if you give an evaluative clause with no branch, the clause drops out if it is reached.</p>
<p>It is <em>weird</em>, but it's foreignness doesn't necessarily make it <em>bad</em>.  Though were it a CASE statement, some people might gravitate toward an always-TRUE branch as not violating the structure:</p>
<pre><code>lib: case [
    config.platform = 'Windows [%windows.lib]
    config.platform = 'Linux [%linux.a]
    true [null]
]
</code></pre>
<p>But SWITCH has no equivalent, so its either the fallout feature or an ELSE (which won't please <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> and I think I prefer fallout)</p>
<pre><code>lib: switch config.platform [
    'Windows [%windows.lib]
    'Linux [%linux.a]
] else [null]
</code></pre>
<h2>
<a name="youd-need-a-void-to-null-operator-thinking-3" class="anchor" href="https://forum.rebol.info#youd-need-a-void-to-null-operator-thinking-3"></a>You'd Need A VOID-TO-NULL Operator <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20">
</h2>
<p>You might think that TRY could nullify-voids, but this creates conflation of disabling raised errors returned by branches.  e.g. what if the Windows branch tried to READ a nonexistent file?</p>
<pre><code>lib: try switch config.platform [
    'Windows [read %windowslibname.txt]  ; imagine raises error
    'Linux [%linux.a]
]
</code></pre>
<p>Not being able to open the file would conflate with not taking a branch--no good.  This shows the use of TRY to convert voids to nulls is clearly a poor idea, and that needs to be a special purpose function.</p>
<p>So TRY is off the table at this point; it's an ignore-raised-error-and-continue.</p>
<p>DEVOID is a cryptic name that was actually proposed to turn VOIDs to NIHILs for vaporization in situations that didn't naturally vaporize voids:</p>
<pre><code>&gt;&gt; 1 + 2 void
== ~void~  ; anti

&gt;&gt; 1 + 2 devoid void
== 3
</code></pre>
<p>So I will call this something like NULLIFY-IF-VOID until a better idea comes along.  Clearly not great for everyday use.</p>
<h2>
<a name="ultimately-null-for-non-if-control-structures-was-chosen-4" class="anchor" href="https://forum.rebol.info#ultimately-null-for-non-if-control-structures-was-chosen-4"></a>Ultimately, NULL For Non-IF Control Structures Was Chosen</h2>
<p>IFs can be as light as <strong><code>if condition '10</code></strong>  It seems VOID is a relatively safe answer for IF, because it has one branch and you're very aware that it takes its branch or it doesn't.</p>
<p>But if you're writing a CASE or a SWITCH it's probably not tiny, and saying MAYBE CASE or MAYBE SWITCH isn't much of a burden.</p>
<p>So twistier constructs like SWITCH and CASE are more conservative and evaluate to NULL when a branch isn't taken.</p>
<p>(We might decide that the empty cases  <strong><code>case []</code></strong> and <strong><code>switch []</code></strong> are VOID, and then you have a bit more data of when no conditions were run.  Is that useful?)</p>
<h2>
<a name="some-casualties-of-equivalence-5" class="anchor" href="https://forum.rebol.info#some-casualties-of-equivalence-5"></a>Some Casualties Of Equivalence</h2>
<p>In a perfect world, I would like to be able to write something like:</p>
<pre><code> unmeta* any [
     meta* if condition1 [branch1]
     meta* if condition2 [branch2]
 ]
</code></pre>
<p>...and have it be the same as:</p>
<pre><code>case [
   condition1 [branch1]
   condition2 [branch2]
]
</code></pre>
<p>Transformations like this which relate constructs together means people can build on reliable parts.  The response of ANY when all expressions void out is to give a VOID, and that's by design.</p>
<p>But I don't know what part of the universe breaks if ANY on a bunch of IFs isn't the exact same as CASE.  It's the same if you pipe pure null to pure void.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/why-if-is-void-on-no-branch-while-case-switch-are-null/2047">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/why-if-is-void-on-no-branch-while-case-switch-are-null/2047</link>
          <pubDate>Mon, 14 Aug 2023 17:08:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2047</guid>
          <source url="https://forum.rebol.info/t/why-if-is-void-on-no-branch-while-case-switch-are-null/2047.rss">Why IF is void on no branch, while CASE+SWITCH are null</source>
        </item>
        <item>
          <title>What Are NULL, VOID, NOTHING, BLANK, and NIHIL?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>Ren-C has some very carefully designed distinctions of "nothingness"--with subtleties that go far beyond something like JavaScript's <code>null</code> and <code>undefined</code>.</p>
<p>While it might seem overwhelming at first, they are purposefully chosen, and a pleasure to work with in practice.  Here's an attempt to run through what they are and how they are used.</p>
<hr>
<h3>
<a name="void-is-the-antiform-of-the-word-void-1" class="anchor" href="https://forum.rebol.info#void-is-the-antiform-of-the-word-void-1"></a>VOID is the antiform of the WORD! "void".</h3>
<p>It vanishes in REDUCE and acts as a no-op for things like APPEND.  It is also the result of an IF that doesn't take its branch, and vaporizes in COMPOSE/etc.</p>
<pre><code>&gt;&gt; void
== ~void~  ; anti

&gt;&gt; compose [a (if 10 &gt; 20 ['b]) c]
== [a c]

&gt;&gt; reduce [1 + 2, if 10 &gt; 20 [&lt;nothing&gt;], 10 + 20]
== [3 30]

&gt;&gt; append [a b c] void
== [a b c]

&gt;&gt; if false ['b]
== ~void~  ; anti
</code></pre>
<p><a href="https://forum.rebol.info/t/why-do-any-and-all-ignore-void-when-if-errors-on-it/2040">VOID will opt out of ANY and ALL</a>.  But because of this, an isolated conditional like IF can't make a logically consistent decision about it being a "branch trigger" or "branch inhibitor", it gives back an error:</p>
<pre><code>&gt;&gt; if false [10]
== ~void~  ; anti

&gt;&gt; any [if false [10] 10 + 20]
== 30

&gt;&gt; all [10 + 20 if false [1020]]
== 30

&gt;&gt; if (if false [10]) [20]
** Error: ~void~ antiform cannot be used in isolated conditional expressions
</code></pre>
<h3>
<a name="nothing-is-the-antiform-of-blank-2" class="anchor" href="https://forum.rebol.info#nothing-is-the-antiform-of-blank-2"></a>NOTHING is the antiform of BLANK!.</h3>
<p><a href="https://forum.rebol.info/t/why-nothing-is-the-name-for-unset-state/2078">I chose the name NOTHING</a> for the contents of an unset variable:</p>
<pre><code>&gt;&gt; x: ~  ; will unset the variable

&gt;&gt; unset? $x  ; in the modern world ('x) makes a word with no binding
== ~true~  ; anti
</code></pre>
<p>Its meta-representation is a quasiform shown as a lone tilde (<code>~</code>), named TRASH.  So evaluating TRASH gives you NOTHING, <a href="https://forum.rebol.info/t/console-treatment-of-void-vs-trash/2045">which has no representation in the console</a>.</p>
<pre><code>&gt;&gt; quasi _
== ~

&gt;&gt; trash? first [~]
== ~true~  ; anti

&gt;&gt; ~

&gt;&gt; nothing? ~
== ~true~  ; anti
</code></pre>
<p>For reasons that I have outlined elsewhere, <a href="https://forum.rebol.info/t/the-truthiness-of-nothing/2180">NOTHING is a branch trigger</a>:</p>
<pre><code>&gt;&gt; print pick ["hello" "goodbye"] 1  ; result is nothing, no console display
hello

&gt;&gt; print maybe pick ["hello" "goodbye"] 3
== ~null~  ; anti

&gt;&gt; if (print pick ["hello" "goodbye"] 1) [&lt;printed&gt;]
hello
== &lt;printed&gt;

&gt;&gt; if not (print maybe pick ["hello" "goodbye"] 3) [&lt;silent&gt;]
== &lt;silent&gt;
</code></pre>
<p>Among the implications here, you can safely use PRINT statements in ANY and ALL (though they're not ignored, and if it is the last statement the overall result will of course be nothing... so use ELIDE PRINT if you want it to be no vote).</p>
<pre><code>&gt;&gt; any [print "Hello", null, 1 + 2, 10 + 20]
Hello
== 3

&gt;&gt; all [1 + 2, 10 + 20, print "Goodbye"]
Goodbye  ; nothing result means no subsequent == in console

&gt;&gt; all [1 + 2, 10 + 20, elide print "Goodbye"]
Goodbye
== 30
</code></pre>
<h3>
<a name="null-is-the-antiform-of-the-word-null-3" class="anchor" href="https://forum.rebol.info#null-is-the-antiform-of-the-word-null-3"></a>NULL is the antiform of the WORD! "null".</h3>
<p>In the API this is represented as the 0 pointer and does not require having its handle released, so it is like C's NULL.  It is used as an "ornery nothing"...but unlike NOTHING it doesn't indicate an unset variable, so it can be fetched by normal WORD! access.  The system accomplishes elegant error locality using the <a href="https://forum.rebol.info/t/the-void-in-null-out-protocol/1880">VOID-in-NULL-out protocol</a> in many places, which hinges on the MAYBE function that converts NULL to void.</p>
<pre><code>&gt;&gt; case [1 &gt; 2 [&lt;a&gt;] 10 &gt; 20 [&lt;b&gt;]]]
== ~null~  ; anti

&gt;&gt; reduce [1 + 2 case [1 &gt; 2 [&lt;a&gt;] 10 &gt; 20 [&lt;b&gt;]]] 10 + 20]
** Error: can't put ~null~ antiforms in blocks

&gt;&gt; reduce [1 + 2 maybe case [1 &gt; 2 [&lt;a&gt;] 10 &gt; 20 [&lt;b&gt;]]] 10 + 20]
== [3 30]

&gt;&gt; third [d e]
** Script Error: cannot pick 3

&gt;&gt; try third [d e]
== ~null~  ; anti

&gt;&gt; append [a b c] try third [d e]
** Error: Cannot put ~null~ antiforms in blocks

&gt;&gt; compose [all your base (try third [d e]) are belong to us]
** Error: Cannot COMPOSE ~null~ antiforms into slots

&gt;&gt; maybe try third [d e]
== ~void~  ; anti

&gt;&gt; append [a b c] maybe try third [d e]
== [a b c]
</code></pre>
<h3>
<a name="nihil-is-an-empty-antiform-block-4" class="anchor" href="https://forum.rebol.info#nihil-is-an-empty-antiform-block-4"></a>NIHIL is an empty antiform block</h3>
<p>This is a parameter pack with no values in it.  This unstable isotope can't be stored in variables or API handles, and can only be handled in its meta form.  <em>(Explanation is beyond the scope of this thread...so <a href="https://forum.rebol.info/t/invisibility-reviewed-through-modern-eyes/2034">read the post on modern invisibility</a> to understand why the shade of distinction from VOID is justified.)</em></p>
<p>If you want an EVAL to vanish (in the spirit of <strong>do []</strong>) then it does so with a switch passed to it:</p>
<pre><code>&gt;&gt; reduce [1 + 2 eval/vanish [] 10 + 20]
== [3 30]
</code></pre>
<p>But without the switch, it will be NOTHING and cause errors in these cases.  But if the contents of the block evaluate to void, that overrides the NOTHING result and it will overall evaluate to void, and vanish in these contexts.</p>
<pre><code>&gt;&gt; reduce [1 + 2 eval [if false [&lt;unused&gt;]] 10 + 20]
== [3 30]
</code></pre>
<h2>
<a name="to-sum-up-5" class="anchor" href="https://forum.rebol.info#to-sum-up-5"></a>To Sum Up...</h2>
<ul>
<li>
<p>VOID is intentional emptiness--tolerated many places as meaning "I'd like to opt out please"</p>
<ul>
<li>Since it opts out of aggregate conditional tests, it can't logically be acted on in an isolated conditional expression like IF</li>
</ul>
</li>
<li>
<p>NULL is a nothingness signal, often meaning "I couldn't find what you were looking for"</p>
<ul>
<li>
<p>Because it is a kind of "soft failure", it is treated as conditionally false</p>
</li>
<li>
<p>Also because it is a soft failure, <strong>most non-conditional slots reject it as an argument</strong></p>
</li>
<li>
<p>MAYBE can be used tactically to convert NULL results to VOID</p>
</li>
</ul>
</li>
</ul>
<p>But then antiform BLANK! comes in to be NOTHING...the "bad check".  A variable holding it is considered to not be set, and it trips up access via WORD!.</p>
<p>All three of these states can be held in variables or API handles.  And then pure invisibility is built upon a weirder mechanic of NIHIL, which can only be handled by ^META-aware code.  You don't need to know how it works to use it (the implementations of COMMENT and ELIDE are trivial in both the main language and UPARSE combinators).  But the mechanics are there required to implement them.</p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/what-are-null-void-nothing-blank-and-nihil/2283">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-are-null-void-nothing-blank-and-nihil/2283</link>
          <pubDate>Thu, 27 Jul 2023 02:36:52 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2283</guid>
          <source url="https://forum.rebol.info/t/what-are-null-void-nothing-blank-and-nihil/2283.rss">What Are NULL, VOID, NOTHING, BLANK, and NIHIL?</source>
        </item>
        <item>
          <title>Why do ANY and ALL ignore VOID, when IF errors on it?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>The evolution of "invisibility" in Ren-C gave rise to two "vaporizing intents" <a href="https://forum.rebol.info/t/invisibility-reviewed-through-modern-eyes/2034">the VOID and NIHIL antiforms</a>.</p>
<p>The default evaluator (and UPARSE) accept that void is an "opt-out state" that can't be put in blocks.  But they don't vaporize VOID on a whim: it will still be the result of expressions whose last result is a void.</p>
<pre><code>&gt;&gt; 1 + 2 if false [&lt;a&gt;]
== ~void~  ; anti
</code></pre>
<p>On the other hand, the empty parameter pack of NIHIL truly vaporizes unless you pipe it around with ^META:</p>
<pre><code>&gt;&gt; 1 + 2 nihil
== 3
</code></pre>
<p>This means it's up to constructs to decide if they want to erase voids or not.  DELIMIT does, so you will see that reflected in things like UNSPACED:</p>
<pre><code>&gt;&gt; unspaced ["A" if false ["B"] "C"]
== "AC"
</code></pre>
<p>COMPOSE vaporizes void slots (and errors on null ones).  <a href="https://forum.rebol.info/t/vaporizing-failed-conditionals-in-reduce/1665">REDUCE is currently vaporizing VOID</a> because it seems like the default people want.</p>
<h2>
<a name="but-what-should-any-and-all-do-1" class="anchor" href="https://forum.rebol.info#but-what-should-any-and-all-do-1"></a>But What Should ANY and ALL Do?</h2>
<p>We can consider that VOID is neither truthy nor falsey, and IF will reject it:</p>
<pre><code>&gt;&gt; if (if false [true]) [&lt;unreachable&gt;]
** Error: IF doesn't accept VOID as its condition argument
</code></pre>
<p>When there was no VOID/NIHIL distinction, then ANY and ALL were backed into a corner.  If they decided to error on void, you couldn't use an ELIDE or ASSERT in the middle of them.  If they didn't error on VOID then the risk was that you could write something like <strong><code>all [1 = 1, 2 = 2, value]</code></strong> and if VALUE was just incidentally void you'd get the 2 = 2 result, which may not have been your intent.</p>
<p>Today, things like ELIDE and ASSERT return NIHIL and can be safely vaporized by ANY and ALL.  This would seem to open up the choice to be consistent with IF, in erroring on voids as being neither true nor false.</p>
<p>One might suggest that if you really want to erase voids...you'd have something that converted voids to nihil called ELIDE-IF-VOID</p>
<pre><code>&gt;&gt; value: void
== ~void~  ; anti

&gt;&gt; all [1 = 1, 2 = 2, value]
** Error: VALUE is VOID which is neither truthy nor falsey

&gt;&gt; all [1 = 1, 2 = 2, elide-if-void value]
== ~true~  ; isotope
</code></pre>
<h2>
<a name="things-like-for-bothhttpsforumrebolinfotdemonstrating-for-both-loop-composability-for-the-win1833-would-get-more-awkward-2" class="anchor" href="https://forum.rebol.info#things-like-for-bothhttpsforumrebolinfotdemonstrating-for-both-loop-composability-for-the-win1833-would-get-more-awkward-2"></a>Things Like <a href="https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833">FOR-BOTH</a> Would Get More Awkward...</h2>
<p>I was fairly proud of this formulation:</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    return unmeta* all [
        meta* for-each (var) blk1 body
        meta* for-each (var) blk2 body
    ]
]
</code></pre>
<p>(I wound up deciding that META would meta-raise everything--including pure null and void--so the asterisks were probably best included there for the alternative formulation.)</p>
<p>But if ALL and ANY errored on void, and you had to erase it, this would become:</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    return unmeta* all [
        elide-if-void meta* for-each (var) blk1 body
        elide-if-void meta* for-each (var) blk2 body
    ]
]
</code></pre>
<p>If I put on my formalism hat, I can see how this is <em>safer</em>.  But I've made similar arguments about why I don't want this:</p>
<pre><code>&gt;&gt; compose [a (if false ['b]) c]
** Error: COMPOSE cannot erase VOID (use ELIDE-IF-VOID if intentional)

&gt;&gt; compose [a (elide-if-void if false ['b]) c]
== [a c]
</code></pre>
<p>It is admittedly a bit different in ANY and ALL's case, because they're mixing in a test for truthiness.  But erasing voids by default has other advantages in writing wild control constructs.</p>
<h2>
<a name="erroring-when-you-dont-have-to-inhibits-creativity-3" class="anchor" href="https://forum.rebol.info#erroring-when-you-dont-have-to-inhibits-creativity-3"></a>Erroring When You Don't Have To Inhibits Creativity</h2>
<p><strong>When all things are mostly equal, safety isn't as compelling as enabling creativity in my current view of the language.</strong></p>
<p>I haven't seen any bad consequences of vaporizing the voids.  Yet the conveniences have been proven.</p>
<p>So that's the decision that has been made.  If you want to make a version of ANY and ALL that error on voids, you can do so with a /PREDICATE.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/why-do-any-and-all-ignore-void-when-if-errors-on-it/2040">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/why-do-any-and-all-ignore-void-when-if-errors-on-it/2040</link>
          <pubDate>Thu, 29 Jun 2023 02:09:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2040</guid>
          <source url="https://forum.rebol.info/t/why-do-any-and-all-ignore-void-when-if-errors-on-it/2040.rss">Why do ANY and ALL ignore VOID, when IF errors on it?</source>
        </item>
        <item>
          <title>Why Aren&#39;t THROW and CATCH Used For Errors?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>While many languages speak of "throwing" and "catching" errors, this isn't how Rebol uses the terms.</p>
<p>Instead, it's a generic way to move values up the stack.  It gives you a handy "out" from control flow:</p>
<pre><code>result: catch [
    if condition [throw result]
    some code
    case [
        condition [more code]
        condition [more code, throw result]
    ]
    additional code
    throw result
]
</code></pre>
<p>The implementation of the feature is lightweight, and built on the same mechanic as RETURN.  You could in fact use return to do this:</p>
<pre><code>result: eval func [] [
    if condition [return result]
    some code
    case [
        condition [return code]
        condition [more code, return result]
    ]
    additional code
    return result
]
</code></pre>
<p><strong>You can, if you like, THROW an error... plain or raised...and CATCH it.</strong>  But that's just because you can throw anything.  Packs are fine, too:</p>
<pre><code>&gt;&gt; [a b]: catch [
       case [
           1 = 2 [throw pack [10 20]]
           1 = 1 [throw pack [100 200]]
       ]
   ]
== 100

&gt;&gt; a
== 100

&gt;&gt; b 
== 200
</code></pre>
<p>So it's really about throwing whatever you like--not specific to errors or error handling.</p>
<p>THROW and CATCH are a great lightweight feature for control flow, that people really should be using more often than they do.  <em>(Ren-C uses "definitional throw", which means there's no risk of you calling a routine that would accidentally catch a throw that wasn't meant for it--which is quite important!)</em></p>
<h2>
<a name="definitional-errors-use-raisetrap-1" class="anchor" href="https://forum.rebol.info#definitional-errors-use-raisetrap-1"></a>Definitional Errors Use RAISE+TRAP</h2>
<p>If you're dealing with <a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-errors/1852">definitional errors</a>, then you RAISE them and then TRAP them.</p>
<pre><code>&gt;&gt; trap [raise 'foo]
== make error! [
    type: ~null~
    id: 'foo
    message: ~null~
    near: '[raise 'foo **]
    where: '[raise entrap trap eval catch* enrescue eval rescue console]
    file: ~null~
    line: 1
]
</code></pre>
<p>You can also use EXCEPT to trap with an infix construct:</p>
<pre><code>&gt;&gt; (raise 'foo) except e -&gt; [print e.id]
== foo
</code></pre>
<p>But by design, definitional errors must be triaged and handled immediately when they are returned--or the antiform error will "decay" into an <strong>"abrupt failure"</strong>.</p>
<h2>
<a name="abrupt-failures-use-failrescue-2" class="anchor" href="https://forum.rebol.info#abrupt-failures-use-failrescue-2"></a>Abrupt Failures use FAIL+RESCUE</h2>
<p>Generally speaking, <a href="https://forum.rebol.info/t/discouraging-the-interception-of-abrupt-failures/1871">it's not a good idea to react to abrupt failures</a> <em>(unless you are something like the CONSOLE, where all you are doing is reporting that the error happened.)</em></p>
<p>As mentioned above, a raised error will decay to an abrupt failure if it isn't triaged.  But you can also cause an abrupt failure using FAIL.</p>
<p><em>(Fun tidbit: FAIL is implemented by raising a definitional error and then not triaging it before passing it on.  Right now it passes it to NULL?, which doesn't use a meta-aware parameter convention so it forces decay to abrupt failure.  <strong><code>fail: cascade [get $raise, get $null?]</code></strong>)</em></p>
<p>To help emphasize that you should generally not be reaching for the RESCUE routine to recover from abrupt failures, it lives in <strong>sys.util</strong>.</p>
<pre><code> &gt;&gt; sys.util/rescue [
       foo: func [argument] [
           return argment + 20  ; whoops, typo
       ]
       foo 1000
    ]
== make error! [
    type: 'Script
    id: 'unassigned-attach
    message: '[:arg1 "word is attached to a context, but unassigned"]
    near: '[
        return argment ** + 20]
    where: '[foo enrescue eval rescue eval catch* enrescue eval rescue console]
    file: ~null~
    line: 2
    arg1: 'argment
]
</code></pre>
<p>Hopefully it's clear to anyone--upon light reflection--why thinking you can handle abrupt failures is generally misguided!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/why-arent-throw-and-catch-used-for-errors/1954">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/why-arent-throw-and-catch-used-for-errors/1954</link>
          <pubDate>Thu, 01 Sep 2022 11:50:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1954</guid>
          <source url="https://forum.rebol.info/t/why-arent-throw-and-catch-used-for-errors/1954.rss">Why Aren&#39;t THROW and CATCH Used For Errors?</source>
        </item>
        <item>
          <title>My Summary of the Big Picture</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>I wrote this to someone in a GitHub issue and thought it was pretty salient:</p>
<blockquote>
<p>What has drawn people to Rebol historically has varied. But a large number who praised it and used it were less interested in the language itself, rather the properties of the executable. It was small, and you could run on any OS without installing anything else...it came with a GUI built in.</p>
<p>But when serious language theorists look at Rebol, they notice it is riddled with design holes. The language itself wasn't <em>composable</em> the way one might like languages to be: mixing constructs in new ways that weren't specifically accounted for never worked. It was more like a "scriptable app" that had a few features that pleased its userbase...and had to be extended by the designer every time a new need came up.</p>
<p>So put briefly: If you don't understand what these holes are, then you won't appreciate the many issues that Ren-C is trying to solve.</p>
<p>Once you know that historical Rebol was fundamentally broken, there are basically 3 choices:</p>
<ol>
<li>Inventory and address the holes one at a time and try to fix or mitigate them</li>
<li>Ignore the holes and just hope that if you add enough features and integration no one will notice</li>
<li>Turn away and run from the crackpots using it, and work with a more solidly designed language</li>
</ol>
<p>(1) is Ren-C's hard-chosen path. Energy is spent on identifying certain patterns in source that users <em>must</em> be able to write and have work, if the language is to justify its existence at all. While it would be nice if stack traces were beautiful and if building the sources was 100% easy, all of that would be meaningless if the punch line was <em>"oh, and the language this is all supporting doesn't actually work"</em></p>
<p>(2) is chosen by people like Red and <a href="https://github.com/Oldes/Rebol3">Oldes's branch of R3-Alpha</a>, as well as some clones that have popped up over the years. Starting from scratch inevitably makes the same mistakes.</p>
<p>(3) is probably the most sensible choice, but if I didn't think there was some promise in the language I wouldn't be pursuing (1).</p>
</blockquote>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/my-summary-of-the-big-picture/1792">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/my-summary-of-the-big-picture/1792</link>
          <pubDate>Fri, 18 Feb 2022 19:37:40 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1792</guid>
          <source url="https://forum.rebol.info/t/my-summary-of-the-big-picture/1792.rss">My Summary of the Big Picture</source>
        </item>
        <item>
          <title>Understanding Definitional Scoping</title>
          <dc:creator><![CDATA[DefinitionalUsername]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>I just started learning Red/Rebol, and I was having trouble understanding the scoping rules. I did read the <a href="https://stackoverflow.com/a/21964858" rel="noopener nofollow ugc">Stack Overflow</a> and <a href="https://en.wikibooks.org/wiki/Rebol_Programming/Advanced/Bindology" rel="noopener nofollow ugc">Bindology</a>, and I think I somewhat understand, but I'm not sure! I'd be grateful if someone can confirm the my deductions about the following code from the SE post:</p>
<pre><code class="lang-auto">rebol []

a: 1

func-1: func [] [a]

inner: context [
    a: 2
    func-2: func [] [a]
    func-3: func [/local a] [a: 3 func-1]
]

reduce [func-1 inner/func-2 inner/func-3]
</code></pre>
<ol>
<li>
<strong>Compile-time:</strong> First, when the code is compiled, a list of top-level names is created. <em>(<code>a</code>, <code>func-1</code>, <code>inner</code>)</em>
</li>
<li>
<strong>Load-time:</strong> When the code is loaded, context <strong>A</strong> is created with those symbols as members. Also, the entire code is walked through, and every occurrence of those symbols is bound to these entries. <em>(e.g., <code>a</code> inside <code>func-2</code> would be bound to the top-level <code>a</code>)</em>
</li>
<li>
<strong>Run-time:</strong> When <code>a: 1</code> is executed, the value <code>1</code> is stored in the <code>a</code>'s slot in the context.</li>
<li>The <code>func</code> keyword after <code>func-1:</code> creates a new function, and assigns it to <code>func-1</code>. However, it leaves the binding of <code>a</code> intact.</li>
<li>The <code>context</code> keyword after <code>inner:</code> creates a new context <strong>B</strong>, walks over all the block, collecting all new symbols, and inserts those in the new object.</li>
<li>
<code>a: 2</code> assigns value <code>2</code> in <code>a</code>'s slot in the new context.</li>
<li>
<code>func</code> after <code>func-2:</code> creates a function while keeping <code>a</code>'s new binding intact, and assigns it to <code>func-2</code>'s slot.</li>
<li>
<code>func</code> after <code>func-3:</code> creates a function and creates a new context <strong>C</strong> in which <code>a</code> is inserted and bound.</li>
<li>Upon execution of <code>reduce</code>, <code>func-1</code> returns <code>1</code> from context <strong>A</strong>, <code>func-2</code> return <code>2</code> from context <strong>B</strong>, and <code>func-3</code> executes <code>func-1</code> which returns <code>1</code> from context <strong>A</strong> again.</li>
</ol>
<p>So, now,  a few questions:</p>
<ul>
<li>Is the above correct? If it is,</li>
<li>How does the <code>context</code> keyword determine which set-words it should create a slot for? i.e.,
<ul>
<li>if <code>a: 2</code> didn't exist, will it still create the slot for <code>a</code> due to <code>a: 3</code> deep inside?</li>
<li>What about if <code>a:3</code> didn't exist either? Will the new context contain a slot for <code>a</code> just due to <code>a</code> inside <code>func-2</code>'s body?</li>
</ul>
</li>
<li>Did <code>context</code> bind <code>a</code> in <code>[/local a]</code> too, before <code>func</code> was executed?</li>
<li>When a new context is created, does it copy existing symbols or bindings from the older context? If not,</li>
<li>Is there a parent-child relationship between contexts, or are they free-standing? Given a context, can I chase some pointer to its parent or child?</li>
</ul>
<p>Sorry for so many questions, I think I am getting extra confused since I already have programming experience and need to unlearn some stuff before being able to grok Rebol.</p>
<p>Thank you.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/understanding-definitional-scoping/1785">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/understanding-definitional-scoping/1785</link>
          <pubDate>Sat, 22 Jan 2022 08:13:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1785</guid>
          <source url="https://forum.rebol.info/t/understanding-definitional-scoping/1785.rss">Understanding Definitional Scoping</source>
        </item>
        <item>
          <title>Running into issues with PARSE</title>
          <dc:creator><![CDATA[RayMPerry]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>Hi. I'm new to Ren-C and have been trying to get this simple parser to work.</p>
<p>(For context, <code>MOCK_DATA.csv</code> contains 1000 rows of "First Name, Last Name, Email, Date of Birth".)</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/f541999fd2a7af1257d0701a8d2ceb52c3e9bf5c.png" data-download-href="https://forum.rebol.info/uploads/default/f541999fd2a7af1257d0701a8d2ceb52c3e9bf5c" title="2021-09-12_22-23"><img src="https://forum.rebol.info/uploads/default/optimized/1X/f541999fd2a7af1257d0701a8d2ceb52c3e9bf5c_2_690x196.png" alt="2021-09-12_22-23" data-base62-sha1="yZDwIV9AxGIyq4mlMnwWFR32k1e" width="690" height="196" srcset="https://forum.rebol.info/uploads/default/optimized/1X/f541999fd2a7af1257d0701a8d2ceb52c3e9bf5c_2_690x196.png, https://forum.rebol.info/uploads/default/optimized/1X/f541999fd2a7af1257d0701a8d2ceb52c3e9bf5c_2_1035x294.png 1.5x, https://forum.rebol.info/uploads/default/optimized/1X/f541999fd2a7af1257d0701a8d2ceb52c3e9bf5c_2_1380x392.png 2x" data-dominant-color="2C3038"></a></div><p></p>
<p>The questions I have are:</p>
<ol>
<li>How do I read this error?</li>
<li>Where should I be looking for valid words/syntax?</li>
</ol>
<p>Thanks in advance.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/running-into-issues-with-parse/1716">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/running-into-issues-with-parse/1716</link>
          <pubDate>Mon, 13 Sep 2021 03:28:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1716</guid>
          <source url="https://forum.rebol.info/t/running-into-issues-with-parse/1716.rss">Running into issues with PARSE</source>
        </item>
        <item>
          <title>Building on VS 2019</title>
          <dc:creator><![CDATA[Brett]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>Thought I'd have a look at the newest ren-c, but I tried and failed to build on VS 2019.  Wondering if builds with Visual Studio 2019 should be working or if that's on hold for now?</p>
<p>If it's on hold until a request, don't spend a lot of time trying to get it working for just me as my immediate interest and priority now is in end user business tools and integration for myself and my wife rather than language work per se. I.e web api's and <a href="http://vb.net">vb.net</a> because I need whip up things in languages I'm familiar with to get things done with little time.</p>
<p>What I did:</p>
<ul>
<li>
<p>Copied r3-windows-x86-8994d23.exe to ./prebuilt</p>
</li>
<li>
<p>Installed VS C++ tools (clicked the box that looked right).</p>
</li>
<li>
<p>Run a command file with the following:</p>
<p>call "C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Auxiliary\Build\vcvars64.bat"<br>
set R3_MAKE=C:\Projects\ren-c\prebuilt\r3-windows-x86-8994d23.exe<br>
"%R3_MAKE%" ../make.r config: ../configs/vs2019-x64.r debug: asserts optimize: 2</p>
</li>
</ul>
<p>What I got was:</p>
<pre><code>...
Dynamic extensions
** Script Error: generate has no value
** Where: switch for-each do catch either else _ do
** Near: [rebmake visual-studio ~~ generate (x86)]
** File: ../make.r
** Line: 871
</code></pre>
<p>Then I changed the line in make for the vs2019 target from:</p>
<pre><code>rebmake/visual-studio/generate/(x86) output-dir solution
</code></pre>
<p>to:</p>
<pre><code>rebmake/makefile/generate/(x86) output-dir solution
</code></pre>
<p>and got a different error, so then I thought I'd ask here, since I'm clueless about compiling with C, C++.</p>
<p>Thank you.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/building-on-vs-2019/1632">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/building-on-vs-2019/1632</link>
          <pubDate>Wed, 07 Jul 2021 02:58:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1632</guid>
          <source url="https://forum.rebol.info/t/building-on-vs-2019/1632.rss">Building on VS 2019</source>
        </item>
        <item>
          <title>Returning a Rebol void value</title>
          <dc:creator><![CDATA[iArnold]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>When I created the MySQL extension, the way to return a void value from a function was to do a simple</p>
<pre><code>return rebVoid();
</code></pre>
<p>Now I am dealing with the GTK3 extension and I suspect something about this has changed. Multiple occasions where I return a void like this appear to be resulting in a segfault and quitting the console as a result as well.</p>
<p>Was this method indeed changed? Or  could it be that it is just unintentionally broken?</p>
<p>Should the</p>
<pre><code>return rebVoid();
</code></pre>
<p>be replaced by</p>
<pre><code>return Init_Void(D_OUT, SYM_VOID);
</code></pre>
<p>now?</p>
<pre><code>grep -r "rebVoid()" .
./extensions/stdio/readline-posix.c:            return rebVoid();  // signal a HALT
./extensions/stdio/readline-posix.c:                    return rebVoid();  // signal a HALT
./extensions/stdio/readline-windows.c:            return rebVoid();  // signal a HALT
./extensions/stdio/p-stdio.c:            line = rebVoid();
./extensions/stdio/p-stdio.c:                return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/crypt/mod-crypt.c:    return rebVoid();
./extensions/crypt/mod-crypt.c:        return rebVoid();
./extensions/crypt/mod-crypt.c:        return rebVoid();
./extensions/odbc/mod-odbc.c:    return rebVoid();
./extensions/mysql/mod-mysql.c:        return rebVoid();
./extensions/mysql/mod-mysql.c:        return rebVoid();
./extensions/mysql/mod-mysql.c:    return rebVoid();
./extensions/mysql/mod-mysql.c:        return rebVoid(); 
./extensions/mysql/mod-mysql.c:    return rebVoid();
./src/core/a-lib.c:        result = rebVoid();
./src/core/t-bitset.c:            action = rebVoid();

grep -r "Init_Void(" .
./extensions/process/mod-process.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/process/mod-process.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/event/mod-event.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/event/mod-event.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/event/p-event.c:        return Init_Void(D_OUT, SYM_VOID);
./extensions/gob/mod-gob.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/gob/mod-gob.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/network/mod-network.c:        return Init_Void(D_OUT, SYM_VOID); }
./extensions/network/mod-network.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/stdio/mod-stdio.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/stdio/mod-stdio.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/signal/mod-signal.c:        return Init_Void(D_OUT, SYM_VOID); }
./extensions/crypt/mod-crypt.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/library/mod-library.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/library/mod-library.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/vector/mod-vector.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/vector/mod-vector.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/debugger/mod-debugger.c:        Init_Void(out, SYM_VOID);
./extensions/image/mod-image.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/image/mod-image.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/javascript/mod-javascript.c:        return Init_Void(D_OUT, SYM_VOID);
./extensions/javascript/mod-javascript.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/javascript/mod-javascript.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/dns/mod-dns.c:        return Init_Void(D_OUT, SYM_VOID);
./src/boot/words.r:; more communicative.  These are standard symbols passed to Init_Void().
./src/include/datatypes/sys-void.h:#define Init_Void(out,sym) \
./src/core/t-typeset.c:                Init_Void(DS_PUSH(), SYM_CUSTOM_X);
./src/core/d-test.c:    return Init_Void(D_OUT, SYM_VOID);
./src/core/d-test.c:    return Init_Void(D_OUT, SYM_VOID);
./src/core/l-scan.c:                Init_Void(DS_PUSH(), SYM_VOID);
./src/core/t-string.c:            return Init_Void(D_OUT, SYM_VOID);
./src/core/c-bind.c:    Init_Void(ARR_SINGLE(patch), SYM_UNSET);  // start variable off as unset
./src/core/c-bind.c:    return Init_Void(D_OUT, REB_VOID);
./src/core/c-bind.c:            Init_Void(var, SYM_VOID);
./src/core/functionals/c-augment.c:    Init_Void(DS_PUSH(), SYM_VOID);  // key slot (signal for no pushes)
./src/core/functionals/c-specialize.c:            Init_Void(arg, SYM_UNSET);  // *not* VAR_MARKED_HIDDEN
./src/core/functionals/n-function.c:    return Init_Void(f-&gt;out, SYM_VOID);
./src/core/functionals/n-function.c:    return Init_Void(f-&gt;out, SYM_VOID);
./src/core/functionals/n-function.c:        Init_Void(ARG(result), SYM_VOID);
./src/core/functionals/n-function.c:            Init_Void(v, SYM_VOID); // `do [return]` acts as `return void`
./src/core/functionals/c-lambda.c:    Init_Void(DS_PUSH(), SYM_VOID);  // key slot (signal for no pushes)
./src/core/functionals/c-hijack.c:        out,  // invisibles allow for out to not be Init_Void()'d
./src/core/functionals/c-generic.c:    return Init_Void(D_OUT, SYM_VOID);
./src/core/functionals/c-chain.c:    Init_Void(FRM_SPARE(f), SYM_UNSET);
./src/core/functionals/c-native.c:    // `return: &lt;void&gt;` use `return: [void!]` and `return Init_Void(D_OUT);`
./src/core/c-context.c:    REBVAL *value = Init_Void(ARR_LAST(CTX_VARLIST(context)), SYM_UNSET);
./src/core/c-context.c:                    Init_Void(var, SYM_UNSET);  // not in source context
./src/core/n-control.c:        return Init_Void(D_OUT, SYM_MATCHED);
./src/core/c-function.c:            Init_Void(param, SYM_UNSET);
./src/core/c-function.c:    Init_Void(KEY_SLOT(DSP), SYM_VOID);  // signal for no parameters pushed
./src/core/b-init.c:    Init_Void(Prep_Cell(&amp;PG_Unset_Value), SYM_UNSET);  // symbol never GC'd
./src/core/t-binary.c:            return Init_Void(D_OUT, SYM_VOID);
./src/core/a-lib.c:    return Init_Void(Alloc_Value(), SYM_VOID);
./src/core/n-do.c:        Init_Void(D_OUT, SYM_VOID);
./src/core/t-datatype.c:            Init_Void(value, SYM_VOID);
./src/core/t-datatype.c:            Init_Void(value, SYM_VOID);
./src/core/n-loop.c:                Init_Void(les-&gt;out, SYM_NULLED);  // null signals break only
./src/core/f-series.c:                return Init_Void(D_OUT, SYM_VOID);  // !!! better than error?
./src/core/n-system.c:        Init_Void(ARG(value), SYM_QUIT);
./src/core/n-data.c:            Init_Void(dest, SYM_NULLED);  // blocks can't contain nulls
./src/core/n-data.c:        return Init_Void(D_OUT, SYM_NULLED);
./src/core/n-data.c:    return Init_Void(D_OUT, SYM_VOID); // !!! Could return freed value
./src/core/n-data.c:        return Init_Void(D_OUT, SYM_NULLED);
./src/core/n-io.c:    return Init_Void(D_OUT, SYM_VOID);
./src/core/d-stats.c:    return Init_Void(D_OUT, SYM_VOID);
./src/core/m-pools.c:    return Init_Void(D_OUT, SYM_VOID);
./src/core/t-object.c:            Init_Void(var, SYM_VOID);
./src/core/c-error.c:                    Init_Void(var, SYM_END);
./src/core/c-error.c:                    Init_Void(var, SYM_VOID);
./src/core/u-parse.c:    Init_Void(Prep_Cell(ARG(num_quotes)), SYM_UNSET);
./src/core/u-parse.c:    Init_Void(Prep_Cell(ARG(position)), SYM_UNSET);
./src/core/u-parse.c:    Init_Void(Prep_Cell(ARG(save)), SYM_UNSET);
./src/core/u-parse.c:            Init_Void(D_SPARE, SYM_VOID);
</code></pre>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/returning-a-rebol-void-value/1615">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/returning-a-rebol-void-value/1615</link>
          <pubDate>Sun, 23 May 2021 09:51:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1615</guid>
          <source url="https://forum.rebol.info/t/returning-a-rebol-void-value/1615.rss">Returning a Rebol void value</source>
        </item>
        <item>
          <title>Printing from inside a C function with rebElide</title>
          <dc:creator><![CDATA[iArnold]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>Not sure this is the right place for this question.</p>
<p>To help myself with the workings of the GTK3 binding, I want to put in some printing statements showing the values of certain items.</p>
<p>I have this working code where I want to print the return value of the C function from within another function</p>
<pre><code>unsigned int result = gtk_main_level();
REBVAL *text = rebValue("{}");
rebElide("append", text , rebI(result));
rebElide("print {after append}");
rebElide("print", text);
rebRelease(text);
</code></pre>
<p>The thing is I was expecting the fifth line replaced by:</p>
<pre><code>rebElide("print {The value of gtk_main_level equals", text, "}");
</code></pre>
<p>also to work, but this results in the exiting of the program with a segfault.<br>
Why is this?</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/printing-from-inside-a-c-function-with-rebelide/1613">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/printing-from-inside-a-c-function-with-rebelide/1613</link>
          <pubDate>Fri, 21 May 2021 08:32:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1613</guid>
          <source url="https://forum.rebol.info/t/printing-from-inside-a-c-function-with-rebelide/1613.rss">Printing from inside a C function with rebElide</source>
        </item>
        <item>
          <title>How Is COUNT-UP Implemented?</title>
          <dc:creator><![CDATA[iArnold]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>Just looked at the source of COUNT-UP and I expected to find a reference to FOR or another function to handle the details, but I only found some MAKE action!, MAKE frame! and MAKE typeset! in there.</p>
<p>So now wondering how this works..</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/how-is-count-up-implemented/1827">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-is-count-up-implemented/1827</link>
          <pubDate>Wed, 12 May 2021 08:13:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1827</guid>
          <source url="https://forum.rebol.info/t/how-is-count-up-implemented/1827.rss">How Is COUNT-UP Implemented?</source>
        </item>
        <item>
          <title>How Is An Integer Represented in the Interpreter?</title>
          <dc:creator><![CDATA[iArnold]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>When an integer! is created, its value is kept as in binary form. When in the console is entered:</p>
<pre><code>&gt;&gt; x: 256
== 256
</code></pre>
<p>The value 256 is converted to a binary representation to save the integer! value in memory.<br>
And afterwards the result of the operation is returned. The value that was assigned to x is converted from its binary form to the display format of 256.</p>
<p>Where exactly in the code is this conversion taking place?</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/how-is-an-integer-represented-in-the-interpreter/1597">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-is-an-integer-represented-in-the-interpreter/1597</link>
          <pubDate>Thu, 06 May 2021 11:21:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1597</guid>
          <source url="https://forum.rebol.info/t/how-is-an-integer-represented-in-the-interpreter/1597.rss">How Is An Integer Represented in the Interpreter?</source>
        </item>
        <item>
          <title>Why Doesn&#39;t PRINT Return VOID?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>Since PRINT doesn't have an interesting return value, we might ask what the harm would be in making it return VOID...</p>
<h2>
<a name="canonizing-void-has-misleading-opt-out-properties-1" class="anchor" href="https://forum.rebol.info#canonizing-void-has-misleading-opt-out-properties-1"></a>Canonizing VOID Has Misleading Opt-Out Properties</h2>
<p>The evolution of void results is such that it's part of the void-in-null-out strategy, as well a way of doing things like opting out of an APPEND without raising an error.</p>
<p>So consider this:</p>
<pre><code>&gt;&gt; if 10 &gt; 20 [&lt;d&gt;]
== ~void~  ; anti

&gt;&gt; if 10 &lt; 20 [&lt;d&gt;]
== &lt;d&gt;

&gt;&gt; append [a b c] if 10 &gt; 20 [&lt;d&gt;]
== [a b c]

&gt;&gt; append [a b c] if 10 &lt; 20 [&lt;d&gt;]
== [a b c &lt;d&gt;]
</code></pre>
<p><em>That feels like a purposeful application of a void state.</em>  But if we were to say that PRINT returned void, we'd be condoning things like:</p>
<pre><code>&gt;&gt; append [a b c] print "does this seem right?"
does this seem right?
== [a b c]
</code></pre>
<p>Somehow a function with an <em>uninteresting</em> result has been elevated to one that people might start assuming has an <em>interesting, void result</em>.  It seems to me that having PRINT return an "ornery" value is a safer and saner strategy:</p>
<pre><code>&gt;&gt; nothing? print "this makes more sense"
this makes more sense
== ~okay~  ; anti

&gt;&gt; append [a b c] print "I like this error"
I like this error
** Error: APPEND does not accept ~ antiform for its VALUE argument
</code></pre>
<h2>
<a name="general-argument-limiting-interface-flexibility-2" class="anchor" href="https://forum.rebol.info#general-argument-limiting-interface-flexibility-2"></a>General Argument: Limiting Interface Flexibility</h2>
<p>Let's generalize the question to SOME-FUNCTION where the key point is that at the time you write it, you haven't thought of a meaningful result for it.</p>
<p>If at the time of writing a function you know that it doesn't have a meaningful return value, then making it return void--instead of returning a nothing value--ties your hands in changing it.</p>
<p>People will start writing things like:</p>
<pre><code>all [
    ...
    some-function ...  ; user assumes no effect, because of void
    ...
]
</code></pre>
<p>But if SOME-FUNCTION had returned a nothing value, then they could have gotten the same effect more obviously with:</p>
<pre><code>all [
    ...
    elide some-function ...
    ...
]
</code></pre>
<p>This also gives more freedom to change the interface later, if you think of an interesting value to return.  You can progressively add more return types after the fact.  But once people assume you always return void, this trap will happen...you're locked in forever in a way that was pretty much completely avoidable.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/why-doesnt-print-return-void/1466">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/why-doesnt-print-return-void/1466</link>
          <pubDate>Mon, 18 Jan 2021 01:40:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1466</guid>
          <source url="https://forum.rebol.info/t/why-doesnt-print-return-void/1466.rss">Why Doesn&#39;t PRINT Return VOID?</source>
        </item>
        <item>
          <title>The simple things matter the most</title>
          <dc:creator><![CDATA[iArnold]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>Perhaps this needs to be in a (sub)category of its own.</p>
<p>You know the feeling that you want to do something that looks really simple but how to do this in Rebol/Ren-C</p>
<p>Case:<br>
A. Transforming the content of a block into a string</p>
<p>B. Transforming the content of a string to become a block</p>
<p>First try:<br>
A.</p>
<pre><code>&gt;&gt; blk: [What becomes of a block when turned into a {} value?]
== [What becomes of a block when turned into a "" value?]
&gt;&gt; mold blk
== {[What becomes of a block when turned into a "" value?]}
</code></pre>
<p>B.</p>
<pre><code>&gt;&gt; txt: "What becomes of a string when turned into a [] value?"
== {What becomes of a string when turned into a [] value?}
&gt;&gt; to block! txt
== [{What becomes of a string when turned into a [] value?}]
</code></pre>
<p>So clearly not what was intended!</p>
<p>After some tinkering:<br>
A.</p>
<pre><code>block-to-text: function [blk [block!]][
    result: copy ""
    spacer: copy ""
    for-each b blk [
        append append result spacer mold b
        spacer: copy " "
    ]
    result
]
block-to-text blk
== {What becomes of a block when turned into a "" value?}
</code></pre>
<p>B.</p>
<pre><code>&gt;&gt; blk: load append append "[" txt "]"       
== [What becomes of a string when turned into a [] value?]
</code></pre>
<p>To be improved?</p>
            <p><small>11 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/the-simple-things-matter-the-most/1428">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-simple-things-matter-the-most/1428</link>
          <pubDate>Thu, 10 Dec 2020 14:35:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1428</guid>
          <source url="https://forum.rebol.info/t/the-simple-things-matter-the-most/1428.rss">The simple things matter the most</source>
        </item>
        <item>
          <title>Help Compiling Ren-C</title>
          <dc:creator><![CDATA[TimeSlip]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>First of all, although somewhere in the back of my mind I heard about Ren-C, my programming time has been limited over the years and so I still mainly use R2 with some Red thrown in. I was working on some library stuff which led me to Nick's site which lead me to the Rebol 2019 videos. Holy Cow! Is this what you all have been up to?<br>
Anyway, I've been trying to compile the Ren-C R3 version (I'll put together a beginner's tutorial at some point) and I get these warnings several times during the compilation:<br>
In function 'rebJumps_inline':       prep\include/rebol.h:1040: warning: 'noreturn' function does return<br>
In function 'rebJumpsQ_inline':prep\include/rebol.h:1048: warning: 'noreturn' function does return</p>
<p>When the script appears to end I don't see any .exe file</p>
<p>Any ideas on how to proceed?</p>
<p>Thanks,<br>
TimeSlip, AKA James_Nak</p>
            <p><small>17 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/help-compiling-ren-c/1281">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/help-compiling-ren-c/1281</link>
          <pubDate>Mon, 25 May 2020 04:58:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1281</guid>
          <source url="https://forum.rebol.info/t/help-compiling-ren-c/1281.rss">Help Compiling Ren-C</source>
        </item>
        <item>
          <title>REBOL on embedded systems, STM32</title>
          <dc:creator><![CDATA[jhgorse]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>I am impressed with REBOL's lack of dependencies and reasonable use of resources. I am curious just how thin we can get the runtime library both with and without TinyC for use on the STM32 ARM Cortex-M MCU. A typical Cortex-M MCU may have between 64 to 2048 kB of internal flash memory and 32 to 1024 kB of RAM.</p>
<p>The Hello World of the embedded world is blinking LED and is called, affectionately, Blinky. It involves an element of timing and the writing of data to an output register (e.g. GPIOx-&gt;ODR for STM32).</p>
<p>I would like to try REBOL for this use case.</p>
<p>What would it take to give this a go on an embedded Cortex-M MCU?</p>
<p>Cheers,<br>
Joe Gorse</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rebol-on-embedded-systems-stm32/1246">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rebol-on-embedded-systems-stm32/1246</link>
          <pubDate>Tue, 03 Dec 2019 15:33:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1246</guid>
          <source url="https://forum.rebol.info/t/rebol-on-embedded-systems-stm32/1246.rss">REBOL on embedded systems, STM32</source>
        </item>
        <item>
          <title>Make a Rebol: minimum viable rebol interpreters</title>
          <dc:creator><![CDATA[salotz]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>What would it take for me to kick off this process and build a minimum viable rebol interpreter as a learning exercise?</p>
<p>I've recently been interested in the a <a href="https://github.com/kanaka/mal" rel="nofollow noopener">"make a lisp"</a> project as a powerful learning tool for both learning lisp and for learning other languages. Does anyone have any thoughts as to the feasibility of this for rebol?</p>
<p>I understand that having a good vetted implementation for doing "real work" like Ren-C or Red is important (keep the WASM build coming), but I'm coming to believe that some of the staying power of lisp is that in terms of choosing dependencies for long term projects something that you can build from scratch with dozens of examples is pretty good future proofing.</p>
            <p><small>7 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/make-a-rebol-minimum-viable-rebol-interpreters/1245">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/make-a-rebol-minimum-viable-rebol-interpreters/1245</link>
          <pubDate>Mon, 02 Dec 2019 18:23:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1245</guid>
          <source url="https://forum.rebol.info/t/make-a-rebol-minimum-viable-rebol-interpreters/1245.rss">Make a Rebol: minimum viable rebol interpreters</source>
        </item>
  </channel>
</rss>

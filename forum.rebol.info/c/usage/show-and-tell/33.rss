<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Show &amp; Tell - AltRebol</title>
    <link>https://forum.rebol.info/c/usage/show-and-tell/33</link>
    <description>Topics in the &#39;Show &amp; Tell&#39; category Created something short and syrupy sweet?  Then post your scripts here; not confined to infinite length one-liners!</description>
    
      <lastBuildDate>Fri, 22 Mar 2024 00:19:14 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/usage/show-and-tell/33.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Feb 2024 Talk, Functional Programming Sydney</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2136">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/fundamental-distinguishing-features-of-rebol/2136/1">Fundamental distinguishing features of Rebol</a>
</div>
<blockquote>
<p>I offered to give a talk at my local Functional Programming meetup next month. Given my recent interests, Iâ€™m thinking of giving an intro to Rebol and its basic concepts.</p>
</blockquote>
</aside>
<p>As a follow-up to this, the talk slides are now online: <a href="https://github.com/fp-syd/meetings/blob/master/2024/2024-02-Neimann-Computing-with-eval.pdf">https://github.com/fp-syd/meetings/blob/master/2024/2024-02-Neimann-Computing-with-eval.pdf</a></p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/feb-2024-talk-functional-programming-sydney/2175">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/feb-2024-talk-functional-programming-sydney/2175</link>
          <pubDate>Fri, 22 Mar 2024 00:19:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2175</guid>
          <source url="https://forum.rebol.info/t/feb-2024-talk-functional-programming-sydney/2175.rss">Feb 2024 Talk, Functional Programming Sydney</source>
        </item>
        <item>
          <title>Reacting to Definitional Errors: CURTAIL</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>Here's a simple <a href="https://forum.rebol.info/t/introducing-reframer-close-cousin-to-enclose/1395">REFRAMER</a> called CURTAIL:</p>
<pre><code>curtail: reframer function [frame [frame!]] [
    return do frame except e -&gt; [
        if e.id == 'need-non-null [return void]
        raise e
    ]
]
</code></pre>
<p>If you don't remember what reframers do, they just have access to a function call before you run it.  Here we are looking for the function we're running to give us a NEED-NON-NULL error.</p>
<p><em>But we're not looking for just any NEED-NON-NULL error that might go by.</em>  We're only interested in ones that are coming out of the call we're processing.  If that happens, we just vaporize the expression.</p>
<pre><code>&gt;&gt; compose [(null)]
** Script Error: non-NULL value required (see MAYBE, TRY, REIFY)

&gt;&gt; curtail compose [(null)]  ; will give back void
</code></pre>
<p>You can see something like this simplifying null checks:</p>
<pre><code>&gt;&gt; ver: 1.2.3
&gt;&gt; date: null

&gt;&gt; print [curtail spaced ["Version:" ver] curtail spaced ["Date:" date]]
Version: 1.2.3
</code></pre>
<p><em>But like I said, it's not just any NEED-NON-NULL...</em></p>
<pre><code>&gt;&gt; a: 1 b: null c: 3
&gt;&gt; get-ver: func [] [to tuple! reduce [a b c]]

&gt;&gt; print [curtail spaced ["Version:" get-ver] curtail spaced ["Date:" date]]
** Script Error: non-NULL value required (see MAYBE, TRY, REIFY)
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/reacting-to-definitional-errors-curtail/2118">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/reacting-to-definitional-errors-curtail/2118</link>
          <pubDate>Mon, 15 Jan 2024 01:13:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2118</guid>
          <source url="https://forum.rebol.info/t/reacting-to-definitional-errors-curtail/2118.rss">Reacting to Definitional Errors: CURTAIL</source>
        </item>
        <item>
          <title>Variant Of &quot;COLLECT&quot; Without &quot;KEEP&quot;</title>
          <dc:creator><![CDATA[no-e-in]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I recently discovered a version of COLLECT by Brett Handley (for R2) that is less general <em>[<a href="https://forum.rebol.info/t/implementing-collect-keep/2099">than what COLLECT has been come to be known as</a>]</em> but avoids nested code.</p>
<pre><code>collect: func [
    {Collects block evaluations, use as body in For, Repeat, etc.}
    block [block!] "Block to evaluate."
    /initial result [series! datatype!] "Initialise the result."
    /only "Inserts into result using Only refinement."
] [
    if not initial [result: block!]
    result: any [all [datatype? result make result 1000] result]
    reduce ['head pick [insert insert/only] not only 'tail result to paren! block]
]
</code></pre>
<p>Examples (running in Rebol2 interpreter):</p>
<pre><code>&gt;&gt; for i 1 10 2 collect [i * 10]
== [10 30 50 70 90]
    
&gt;&gt; foreach [a b] [1 2 3 4] collect [a + b]
== [3 7]

&gt;&gt; foreach w [a b c d] collect [w]
== [a b c d]

&gt;&gt; repeat e [a b c %.txt] collect/initial [e] %file
== %fileabc.txt

&gt;&gt; iota: func [n [integer!]][repeat i n collect/initial [i] make block! n]
&gt;&gt; iota 10
== [1 2 3 4 5 6 7 8 9 10]
</code></pre>
            <p><small>6 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/variant-of-collect-without-keep/2110">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/variant-of-collect-without-keep/2110</link>
          <pubDate>Thu, 11 Jan 2024 10:05:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2110</guid>
          <source url="https://forum.rebol.info/t/variant-of-collect-without-keep/2110.rss">Variant Of &quot;COLLECT&quot; Without &quot;KEEP&quot;</source>
        </item>
        <item>
          <title>Implementing COLLECT + KEEP</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>COLLECT allows you to build up a block, without needing to name the block or pass it as a parameter to individual APPEND instructions.  Instead you use KEEP, which appends to the implicit nameless block:</p>
<pre><code>&gt;&gt; collect [
       keep 'foo:
       print "Arbitrary code possible"
       keep/line [1 2 3]
       keep spread [Spread #works @(T O O)]
       repeat 2 [keep &lt;whatever&gt;]
    ]
Arbitrary code possible
== [
    foo: [1 2 3]
    Spread #works @(T O O) &lt;whatever&gt; &lt;whatever&gt;]
</code></pre>
<h2>
<a name="leverages-lambda-to-bind-keep-to-code-1" class="anchor" href="https://forum.rebol.info#leverages-lambda-to-bind-keep-to-code-1"></a>Leverages LAMBDA To Bind KEEP To Code</h2>
<p>The trick is that the body is turned into a function that takes KEEP as a parameter.  This defines the word KEEP for the body.</p>
<p>To see how this works, imagine this:</p>
<pre><code>collector: lambda [keep [action?]] [
    keep 'foo:
    print "Arbitrary code possible"
    keep/line [1 2 3]
    keep spread [Spread #works @(T O O)]
    repeat 2 [keep &lt;whatever&gt;]
 ]

 block: copy []
 keeper: specialize :append [series: block]

 collector :keeper
</code></pre>
<p>This code gets the desired result in BLOCK.</p>
<h2>
<a name="slight-twist-make-keep-return-its-input-2" class="anchor" href="https://forum.rebol.info#slight-twist-make-keep-return-its-input-2"></a>Slight Twist: Make KEEP Return Its Input</h2>
<p>APPEND will return the block that you append to.  This would reveal the partially-built temporary block before the collect is complete.  A better and more useful result of KEEP would be to return the value that you pass it.</p>
<p>To accomplish that, we can ENCLOSE the specialization:</p>
<pre><code>keeper: enclose (specialize :append [series: block]) func [f [frame!]] [
    let value: f.value
    do f
    return value
]
</code></pre>
<p>We have to capture the value to append before we DO the captured FRAME!, because Rebol functions are permitted to make arbitrary modifications to their arguments during execution.  <em>(To help avoid mistakes, you are not allowed to read a frame's values after a DO is complete.)</em>  It's possible to DO COPY F but that makes a copy of the entire frame, and here we just copy the value we want.</p>
<p>A more efficient way to do this is to use a LAMBDA for the wrapper function, and ELIDE the DO.  There's no need to type check F (since ENCLOSE only passes the FRAME! built for APPEND, never anything else):</p>
<pre><code>keeper: enclose (specialize :append [series: block]) lambda [f] [
    f.value
    elide do f  ; evaluates to anti-isotope of 0 length block, vanishes
]
</code></pre>
<h2>
<a name="putting-it-together-3" class="anchor" href="https://forum.rebol.info#putting-it-together-3"></a>Putting It Together</h2>
<p>Wrapping this up for a working COLLECT implementation:</p>
<pre><code>collect: func [
    return: [block!]
    body [block!]
][
    let block: copy []
    let keeper: enclose (specialize :append [series: block]) lambda [f] [
        f.value
        elide do f
    ]
    run (lambda [keep] body) :keeper
    return block
]
</code></pre>
<p>It's a good demonstration of how you can make something impressive that feels like a first-class language feature out of Rebol, with little effort.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/implementing-collect-keep/2099">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/implementing-collect-keep/2099</link>
          <pubDate>Wed, 10 Jan 2024 17:20:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2099</guid>
          <source url="https://forum.rebol.info/t/implementing-collect-keep/2099.rss">Implementing COLLECT + KEEP</source>
        </item>
        <item>
          <title>Skinning REPLACE with Red&#39;s String PARSE Hack</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>Red made an unusual choice with their implementation of REPLACE when you use a pattern that's a block with a string.  Instead of trying to stringify the block, <a href="https://github.com/red/red/blob/40096dd12ca9c3b9b47e9eaa995d425b9faf620b/tests/source/units/replace-test.red#L72">they assume it's a PARSE rule</a>:</p>
<pre><code>red&gt;&gt; replace/case/all "aAbbabAAAa" ["Ab" | "Aa"] "-"
== "a-babAA-"
</code></pre>
<p>It seems like a bad idea to make the choice to do this based on the input type.  What if you actually want to do this when the input is a BLOCK!?  I'd prefer something like <strong>parse-replace</strong> <em>(or if we ever allow the same word to be a function and a module, maybe <strong>parse.replace</strong>)</em>.</p>
<p>But honestly, I think that the answer is just to keep pushing on UPARSE itself to be slick enough that you wouldn't feel the need to reach for a shorthand like this.  It's pretty easy to write as is:</p>
<pre><code>&gt;&gt; parse/case "aAbbabAAAa" [
       try some thru [change ["Ab" | "Aa"] ("-")]
       accept &lt;input&gt;
   ]
== "a-babAA-"
</code></pre>
<p>That's probably reaching the limits of how short UPARSE can do an equivalent.  Yet it's more powerful if you want to deviate or customize it, so I would reach for this more often than a limited REPLACE.</p>
<h2>
<a name="still-ren-c-does-backflips-and-lets-you-have-it-your-way-1" class="anchor" href="https://forum.rebol.info#still-ren-c-does-backflips-and-lets-you-have-it-your-way-1"></a>Still, Ren-C Does Backflips And Lets You Have It Your Way</h2>
<p>So you should be able to adapt REPLACE to have Red's behavior if you want it.</p>
<p>Super easy.  Barely an inconvenience!</p>
<pre><code>replace: enclose :lib.replace func [
     f [frame!]
     &lt;local&gt; head tail rule
][
    if not all [
        match [text! binary!] f.target
        block? f.pattern
    ][
        return do f  ; use normal REPLACE semantics
    ]

    rule: if activation? :f.replacement '[  ; function generates replacement
        head: &lt;here&gt;
        change [f.pattern, tail: &lt;here&gt;] (
            apply/relax :f.replacement [const head, const tail]
        )
    ] else '[  ; replacement can be used as-is
        change f.pattern (f.replacement)
    ]

    apply :parse [/case f.case, f.target [
        while [thru rule] (
            if not f.all [return f.target]
        )
        to &lt;end&gt;
    ]]
    return f.target
]
</code></pre>
<h2>
<a name="it-worked-the-first-time-i-ran-it-2" class="anchor" href="https://forum.rebol.info#it-worked-the-first-time-i-ran-it-2"></a>It worked the first time I ran it!</h2>
<p>There's so much interesting stuff going on here that it's hard to list it all. I can quickly hit some high points.</p>
<ul>
<li>
<p>You don't have to repeat the interface of REPLACE.  This is an ENCLOSE, so it just passes the frame built for LIB.REPLACE to the wrapper and lets it choose whether to run that frame as-is (or modified), or do its entirely own thing.</p>
</li>
<li>
<p>It uses the <a href="https://forum.rebol.info/t/the-cool-new-repurposing-of-while-in-parse/1875">kickass new arity-2 WHILE combinator</a> to great effect...simply iterating over the replacement rule.</p>
</li>
<li>
<p><a href="https://forum.rebol.info/t/apply-ii-the-revenge/1834">Modern kickass APPLY</a> for PARSE lets you put arguments in any order, and does refinements by name... here we put /CASE first because it's clearer... then passing the series and the rule.</p>
</li>
<li>
<p>It doesn't just run isotopic actions if they are passed, but it also optionally passes them the head and tail of where in the input is matched.  If the function is arity-1, it just receives the head.  If it's arity-0, it doesn't receive either.  (This is due to APPLY's /RELAX that tolerates too many arguments.)</p>
</li>
</ul>
<p>I wrote a little demo of the fancier function invocation:</p>
<pre><code>&gt;&gt; data: "(real)1020(powerful)0304(magic)"

&gt;&gt; collect [
       replace/all data [between "(" ")"] func [head tail] [
            let item: copy/part head tail
            keep item
            if item = "(powerful)" [item: copy "(ren-c)"]
            return uppercase item
        ]
    ]
== ["(real)" "(powerful)" "(magic)"]

&gt;&gt; data
== "(REAL)1020(REN-C)0304(MAGIC)"
</code></pre>
<p>Not only that, but the references to the head and tail of the match are CONST...which prevents the replacement function from messing up the in-progress iteration of the series where the replace is happening.  It only achieves modification by means of what result it synthesizes.</p>
<p>How about that?</p>
<p>cc: <a class="mention" href="https://forum.rebol.info/u/brett">@Brett</a>, <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a>, <a class="mention" href="https://forum.rebol.info/u/johnk">@johnk</a></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/skinning-replace-with-reds-string-parse-hack/2043">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/skinning-replace-with-reds-string-parse-hack/2043</link>
          <pubDate>Thu, 27 Jul 2023 06:23:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2043</guid>
          <source url="https://forum.rebol.info/t/skinning-replace-with-reds-string-parse-hack/2043.rss">Skinning REPLACE with Red&#39;s String PARSE Hack</source>
        </item>
        <item>
          <title>Working With Truthy BLANK! (in SPLIT-PATH Tests)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>The current re-imagining of the concept of truthy/falsey involves the idea that <em>anything you can put into a block is truthy</em>.  That includes BLANK!.</p>
<p>~null~ isotopes are falsey, and will REIFY to be <strong><code>~null~</code></strong> which can be somewhat clumsy-looking.</p>
<p>But consider some test cases for seeing how SPLIT-PATH works, looking a bit like this:</p>
<pre><code>split-path-tests:  [
    %foo                            [_ %foo]
    %/c/test/test2                  [%/c/test/ %test2]
    %/c/test                        [%/c/ %test]
    %//test                         [%// %test]
    %/test                          [%/ %test]
    %//                             [%// _]
    %./                             [%./ _]
    &lt;...etc...&gt;
]
</code></pre>
<p>SPLIT-PATH is a multi-return routine, which gives back two values: the path and the filename.  But if one or the other is missing then that component will be null, which is useful for testing with IF (or using DEFAULT with).</p>
<p>But if we just blindly changed the tests to reify, it would become less legible:</p>
<pre><code>split-path-tests:  [
    %foo                            [~null~ %foo]
    %/c/test/test2                  [%/c/test/ %test2]
    %/c/test                        [%/c/ %test]
    %//test                         [%// %test]
    %/test                          [%/ %test]
    %//                             [%// ~null~]
    %./                             [%./ ~null~]
    &lt;...etc...&gt;
]
</code></pre>
<p>However...with blanks being truthy, this means you that you can take a variable which may be null and turn it into a blank, like this:</p>
<pre><code>reduce [any [path _] any [file _]]
</code></pre>
<p>That's rather succinct!  Probably so succinct that it doesn't need its own native to express.</p>
<p>(I thought it was neat.)</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/working-with-truthy-blank-in-split-path-tests/2007">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/working-with-truthy-blank-in-split-path-tests/2007</link>
          <pubDate>Sat, 14 Jan 2023 15:21:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2007</guid>
          <source url="https://forum.rebol.info/t/working-with-truthy-blank-in-split-path-tests/2007.rss">Working With Truthy BLANK! (in SPLIT-PATH Tests)</source>
        </item>
        <item>
          <title>Minor (but nice!) %prot-http.r parsing improvements</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>Here's is R3-Alpha's <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/mezz/prot-http.r">PARSE-WRITE-DIALECT</a> from %prot-http.r</p>
<pre><code>parse-write-dialect: func [port block /local spec] [
    spec: port/spec
    parse block [
        [set block word! (spec/method: block) | (spec/method: 'post)]
        opt [set block [file! | url!] (spec/path: block)]
        [set block block! (spec/headers: block) | (spec/headers: [])]
        [set block [any-string! | binary!] (spec/content: block) | (spec/content: none)]
    ]
]
</code></pre>
<p>You couldn't set paths in R3-Alpha parse, which is weird.  So things had to be captured into a temporary variable (it reused the input block for some reason).</p>
<p>Let's imagine that setting paths were legal:</p>
<pre><code>parse-write-dialect: func [port block /local spec] [
    spec: port/spec
    parse block [
        [set spec/method word! | (spec/method: 'post)]
        opt [set spec/path [file! | url!]]
        [set spec/headers block! | (spec/headers: [])]
        [set spec/content [any-string! | binary!] | (spec/content: none)]
    ]
]
</code></pre>
<p>Let's do a quick transformation of this to PARSE3 in Ren-C, where the keyword TRY now replaces OPT:</p>
<pre><code>parse-write-dialect: func [port block &lt;local&gt; spec] [
    spec: port.spec
    parse3 block [  ; PARSE3 is R3-Alpha-compatible parse
        [set spec.method word! | (spec.method: 'post)]
        try [set spec.path [file! | url!]]
        [set spec.headers block! | (spec.headers: [])]
        [set spec.content [any-string! | binary!] | (spec.content: null)]
    ]
]
</code></pre>
<ul>
<li>
<p>The TUPLE!s help us see we're not making function calls, which is nice</p>
</li>
<li>
<p>/LOCAL is a legitimate normal refinement, and <code>&lt;local&gt;</code> variables are truly local--you can't slip them in from the caller.  Because they are invisible, you can build function compositions that don't have to worry about colliding with their names.</p>
<ul>
<li>It also frees up /LOCAL to just be a typical refinement, like TIME/LOCAL</li>
</ul>
</li>
</ul>
<p>Now let's throw in some UPARSE, with the SET-WORD!s for assignment...</p>
<pre><code>parse-write-dialect: func [port block &lt;local&gt; spec] [
    spec: port.spec
    parse block [  ; PARSE is now UPARSE
        [spec.method: word! | (spec.method: 'post)]
        try [spec.path: [file! | url!]]
        [spec.headers: block! | (spec.headers: [])]
        [spec.content: [any-string! | binary!] | (spec.content: null)]
    ]
]
</code></pre>
<p>It looks a little tighter...but then we also have the ability to factor the assignments out.  And as it happens, that last line could just be <strong>try [any-string! | binary!]</strong>, because TRY would assign the result to NULL if it can't match:</p>
<pre><code>parse-write-dialect: func [port block &lt;local&gt; spec] [
    spec: port.spec
    parse block [
        spec.method: [word! | ('post)]
        spec.path: try [file! | url!]
        spec.headers: [block! | ([])]
        spec.content: try [any-string! | binary!]
    ]
]
</code></pre>
<p>Improved!</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/minor-but-nice-prot-http-r-parsing-improvements/1945">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/minor-but-nice-prot-http-r-parsing-improvements/1945</link>
          <pubDate>Sat, 27 Aug 2022 17:38:07 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1945</guid>
          <source url="https://forum.rebol.info/t/minor-but-nice-prot-http-r-parsing-improvements/1945.rss">Minor (but nice!) %prot-http.r parsing improvements</source>
        </item>
        <item>
          <title>Weird Little Function: STEAL a Variable&#39;s Prior Value</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I don't know if it has the best name (suggestions?), but it's kind of interesting...</p>
<pre><code>&gt;&gt; x: 304
== 304

&gt;&gt; steal x: 1000 + 20
== 304

&gt;&gt; x
== 1020
</code></pre>
<p>I wrote it as a variadic function for some reason (as a test, maybe?) but you could write it in Redbol.  You could even use their lame ALSO.</p>
<pre><code>steal: func [
    {Red version}
    'var [set-word! set-path!]
    value [any-type!]
][
    also get var set var value
]
</code></pre>
<p>The Ren-C version of that reads a lot better:</p>
<pre><code>steal: lambda [
    {Ren-C version}
    'var [set-word! set-path!]
    value [any-value!]
][
    get var
    elide set var value
]
</code></pre>
<p>It naturally has the benefit of letting you break things across lines.  I feel like it's better to point out "this is the thing being erased".  And of course the mechanic is far more general.</p>
<p>I definitely like ANY-VALUE! better than ANY-TYPE!.</p>
<p>Anyway, I'm sure I've seen places I could have used it if I thought of it.  I'll keep my eyes open.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/weird-little-function-steal-a-variables-prior-value/1943">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/weird-little-function-steal-a-variables-prior-value/1943</link>
          <pubDate>Thu, 25 Aug 2022 16:27:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1943</guid>
          <source url="https://forum.rebol.info/t/weird-little-function-steal-a-variables-prior-value/1943.rss">Weird Little Function: STEAL a Variable&#39;s Prior Value</source>
        </item>
        <item>
          <title>Enter the Dungeon ðŸ’€ ...if You Dare!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <h2>The Imaginary 3-D Dungeon Simulator of the Year, 1983...</h2>
<p>NOW ON THE WEB!!</p>
<p><strong><a href="http://hostilefork.com/media/shared/replpad-js/?do=dungeon">http://hostilefork.com/media/shared/replpad-js/?do=dungeon</a></strong></p>
<p>Source code:</p>
<p><a href="https://github.com/hostilefork/teenage-coding/blob/master/DUNGEON/dungeon.reb">https://github.com/hostilefork/teenage-coding/blob/master/DUNGEON/dungeon.reb</a></p>
<h2>Backstory</h2>
<p>When I was a kid (circa 1983, I'd be about 8 or 9), I played the Intellivision game <a href="http://en.wikipedia.org/wiki/Advanced_Dungeons_&amp;_Dragons:_Treasure_of_Tarmin">Advanced Dungeons and Dragons: Treasure of Tarmin</a>. The 3-D graphics put you in a first-person-perspective point of view with shocking realism:</p>
<p><img src="https://i.stack.imgur.com/X4aGT.png" alt="Shockingly Realistic 3-D Graphics" width="320" height="200"></p>
<p>But a year or two later, I got a C-64. And I was able to draw on the 40x25 character grid by cursoring around the screen, setting the color with the Ctrl key and a digit, and putting symbols anywhere I wanted <em>(why doesn't <code>bash</code> let me do that?)</em>. The character set had triangular components and solid block components.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4.jpeg" data-download-href="https://forum.rebol.info/uploads/default/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4" title="image"><img src="https://forum.rebol.info/uploads/default/optimized/1X/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4_2_252x250.jpeg" alt="image" data-base62-sha1="1Rsurb7Q0aQ1IugNlN0VbFjgToE" width="252" height="250" srcset="https://forum.rebol.info/uploads/default/optimized/1X/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4_2_252x250.jpeg, https://forum.rebol.info/uploads/default/optimized/1X/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4_2_378x375.jpeg 1.5x, https://forum.rebol.info/uploads/default/optimized/1X/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4_2_504x500.jpeg 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4_2_10x10.png"></a></div><p></p>
<p>So I was able to reason through how one might generate a rendering of one's perspective in a grid through that medium.</p>
<p>In 2013, I found the nearly-three-decades-old spec, in spiral-bound notebook paper, about "Dungeon Construction Set":</p>
<p><img src="https://i.stack.imgur.com/WHYpo.jpg" alt="enter image description here" width="320" height="320"></p>
<p><em>(Careful readers will notice that while it's almost right, this doesn't quite hold together on the slanted parts...)</em></p>
<p>Though Treasure of Tarmin was played on a grid, the walls existed only on the <em>edges</em> of grid squares. Having learned what bytes were, I realized that if I made the map out of bytes...then each square on the map could have four possible states for each of its edges:</p>
<ol>
<li>Unobstructed</li>
<li>Wall</li>
<li>Door</li>
<li>Something Else?</li>
</ol>
<p>The design allows for the opportunity that adjacent cells would "disagree"...e.g. have a wall on one side and a door on the other.  I considered this a feature; these situations would give rise to one-way doors and walls that didn't appear until you passed through them and then turned around.</p>
<p>My idea was that a position on the map and a direction you were facing could "light up" regions on the screen...a bit like lighting up segments of a digit on an LCD.</p>
<p>But an implementation of the ideas eluded me.  It was a trickier program than I had written at the time, made even trickier because I was trying to implement it in a "machine language monitor".  I had no assembler, and the book I read didn't discuss them...just the instruction set and workings of the 6502 chip.</p>
<p>(The machine-language-monitor programs could encode single instructions into specific memory locations.  But unlike an assembler, it had no labels or other abstractions...all addresses had to be kept track of on paper.)</p>
<p>By the time I knew enough about programming that I could do something like this in an evening, I no longer cared much about the idea.  But better late than never, right?</p>
<p>Although Unicode/ASCII don't have good "seamless drawing" characters to do this like the C-64 could, it can still get the idea across.</p>
<h2><a href="https://github.com/red/red/pull/612">Originally Wrote this in Red (2013)</a></h2>
<p>I decided I'd use this relatively simple task as something where I would use Red the whole time--as opposed to writing it in Rebol2 or R3-Alpha and then porting the differences.  So that let me get a sense of where the pain points were regarding things like syntax error reporting, that sort of stuff.</p>
<p>Anyway, about a decade later, it's now a Ren-C sample.  Minor modifications were made, including taking advantage of the ReplPad's CLEAR-SCREEN ability (if running on the web).</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/enter-the-dungeon-if-you-dare/1865">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/enter-the-dungeon-if-you-dare/1865</link>
          <pubDate>Wed, 06 Jul 2022 04:59:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1865</guid>
          <source url="https://forum.rebol.info/t/enter-the-dungeon-if-you-dare/1865.rss">Enter the Dungeon ðŸ’€ ...if You Dare!</source>
        </item>
        <item>
          <title>The CIRCLED Dialect: Example of the Form</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I was looking at this from the emscripten config file:</p>
<pre><code> ; Right now, either #web or #node (someday #wasm-edge ?)
 ;
 javascript-environment: #web
</code></pre>
<p>And I thought to myself: well that's kind of ugly.  The comment is having to list things that would be more obviously shown by just demonstrating the options:</p>
<pre><code>javascript-environment: circled [(#web) #node]
</code></pre>
<p>It could default to NULL if you circled nothing, but you could use MUST to suggest people needed to select something:</p>
<pre><code>&gt;&gt; number: must circled [#one #two #three]
** Error: MUST requires argument not to be NULL
</code></pre>
<h2>
<a name="its-almost-too-easy-1" class="anchor" href="https://forum.rebol.info#its-almost-too-easy-1"></a>It's Almost <em>Too</em> Easy</h2>
<p>When it's this easy, who wouldn't whip such things up?</p>
<pre><code>circled: lambda [block [block!] &lt;local&gt; result] [
    parse block [
        result: try thru subparse group! [
            &lt;any&gt; &lt;end&gt; | (fail "Circled Items Must Be Singular")
        ]
        try [thru group! (fail "Only One Circle")]
        accept (result)
    ]
]

&gt;&gt; circled [a (b) c]
== b

&gt;&gt; circled [a b c]
; null

&gt;&gt; circled [a (b c)]
** Error: Circled Items Must Be Singular

&gt;&gt; circled [(a) b (c)]
** Error: Only One Circle
</code></pre>
<p>Remarkable plasticity, and I want to see these weapons come to the code golfing field <a href="https://www.youtube.com/watch?v=iDKaz1iB9wQ">once they are adequately Rebmooshed</a>.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<hr>
<p>This example tipped the balance to where I decided that matching <strong><code>&lt;end&gt;</code></strong> should be invisible.  Because I wanted a way to synthesize the result while doing the end match.  Writing <strong><code>elide &lt;end&gt;</code></strong> is possible, but there's essentially no cases in practice where you don't want to elide the end.</p>
<pre><code> &gt;&gt; parse [1 2] ['1 &lt;end&gt; | (fail "Not a 1 followed by the end")]
 ** Error: Not a 1 followed by the end

 &gt;&gt; parse [1] ['1 &lt;end&gt; | (fail "Not a 1 followed by the end")]
 == 1
</code></pre>
<p>The previous result was evaluating the <code>&lt;end&gt;</code> to the input position at that moment of being at the end--so effectively a series at its tail:</p>
<pre><code> &gt;&gt; parse [1] ['1 &lt;end&gt;]
 == []  ; old behavior...how often would you want this?
</code></pre>
<p>If that's what you actually want (which no one ever did) you can can say <strong><code>&lt;end&gt; &lt;here&gt;</code></strong>.</p>
<pre><code> &gt;&gt; parse [1] ['1 &lt;end&gt; &lt;here&gt;]
 == []
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-circled-dialect-example-of-the-form/1849">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-circled-dialect-example-of-the-form/1849</link>
          <pubDate>Sun, 26 Jun 2022 12:06:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1849</guid>
          <source url="https://forum.rebol.info/t/the-circled-dialect-example-of-the-form/1849.rss">The CIRCLED Dialect: Example of the Form</source>
        </item>
        <item>
          <title>Parsing a README.md File To Fill A Folder</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I've integrated <a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a>'s <a href="https://forum.rebol.info/t/js-testing-with-cypress-io/1778/3">Cypress Tests</a> to the GitHub workflow.</p>
<p>There's a certain number of things we want to have work before we "greenlight" a new libr3.wasm file.  Things like Graham's prescription writing app or chess demo are examples of this.</p>
<p>But we don't want the test scripts for those things to live in the Ren-C repository.  Because they need to change as the apps change--and they should also be running whenever those apps get a new commit pushed.</p>
<p>At first I just did a <strong>wget</strong> of the scripts:</p>
<pre><code>cd tests/cypress/e2e
wget https://gitlab.com/Zhaoshirong/rebol-chess/-/raw/master/cypress/e2e/chess.cy.js
wget https://raw.githubusercontent.com/gchiu/midcentral/main/cypress/e2e/rx-app.cy.js
</code></pre>
<p>But this encountered an error, because when git has a directory with no files in it...it doesn't exist.  So there was no e2e directory.</p>
<p>I could have just said <strong>mkdir tests/cypress/e2e</strong> as part of the workflow.  But I figured making a README.md file and putting it in the directory to explain what it was would be easier.</p>
<p>This gave me an idea: <em>What if I put the URLs in the README.md, and then parsed them out and fetched them?</em>  So that's what I did instead!</p>
<p><strong><a href="https://raw.githubusercontent.com/metaeducation/ren-c/master/tests/cypress/e2e/README.md">Here's the README.md</a></strong>, which has <strong><code>* https://whatever</code></strong> lines in it.</p>
<p>Then here's the script that uses the Ren-C GitHub Action:</p>
<pre><code>- name: Collect Cypress Tests from Repositories We Want to Keep Working
  uses: metaeducation/ren-c-action@release
  with:
    script: |
      cd %tests/cypress/e2e/
      list: uparse (as text! read %README.md) [
          collect some [
              '* space [keep url!] newline
            | thru newline
          ]
      ]
      for-each url list [
          filename: second split-path url
          write filename (read url)
      ]</code></pre>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/parsing-a-readme-md-file-to-fill-a-folder/1840">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/parsing-a-readme-md-file-to-fill-a-folder/1840</link>
          <pubDate>Tue, 14 Jun 2022 11:41:40 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1840</guid>
          <source url="https://forum.rebol.info/t/parsing-a-readme-md-file-to-fill-a-folder/1840.rss">Parsing a README.md File To Fill A Folder</source>
        </item>
        <item>
          <title>Demonstrating FOR-BOTH: Loop Composability For The Win :exclamation:</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>FOR-BOTH was an early talking point for an extremely simple usermode loop construct that would be built out of two FOR-EACH loops:</p>
<pre><code> &gt;&gt; for-both x [1 2] [3 4] [print [x], x = 5]
 1
 2
 3
 4
 == #[false]
</code></pre>
<p>A naive implementation of this in Rebol2 might look like:</p>
<pre><code> for-both-naive: func ['var blk1 blk2 body] [
     foreach :var blk1 body
     foreach :var blk2 body
 ]
</code></pre>
<p>...but...</p>
<ul>
<li>
<p><strong>It will not honor BREAK correctly</strong></p>
<pre><code>&gt;&gt; for-both-naive x [1 2] [3 4] [if x = 2 [break], print [x], x = 5]
1
3  ; the BREAK only broke the first FOREACH
4
== #[none]
</code></pre>
<p>There's no way from the outside of Rebol2 or Red's FOREACH to know for sure that a BREAK was requested.  BREAK returns NONE!, but a loop body can (and often does) evaluate to NONE! as well.  Red made it even worse by adding BREAK/RETURN--so a breaking loop can return <em>anything</em>.</p>
<p>So you'd need some kind of complex binding to search the loop bodies and bind the BREAK word to something that throws and gets caught...even for this simple goal.</p>
</li>
<li>
<p><strong>The loop won't evaluate to the last result of the body</strong>.</p>
<pre><code>&gt;&gt; for-both-naive x [1 2] [] [print [x], x * 10]
1  ; evaluated to 10
2  ; evaluated to 20
== #[none!]
</code></pre>
<p>If the second series is empty, the fallout from the first loop is forgotten.</p>
</li>
</ul>
<h2>
<a name="behold-ren-cs-elegant-solution-to-for-both-1" class="anchor" href="https://forum.rebol.info#behold-ren-cs-elegant-solution-to-for-both-1"></a>Behold Ren-C's Elegant Solution to FOR-BOTH</h2>
<p><em>Underneath its apparent simplicity lies quite a lot of deep thought.</em>  And the mechanisms it uses apply far beyond just loops!</p>
<pre><code>    for-both: func ['var blk1 blk2 body] [
        return unmeta all [
            meta for-each (var) blk1 body
            meta for-each (var) blk2 body
        ]
    ]
</code></pre>
<p><em>(Note: see followup for why RETURN is necessary with FUNC, and how to avoid it with LAMBDA.)</em></p>
<h3>
<a name="it-solves-the-break-case-2" class="anchor" href="https://forum.rebol.info#it-solves-the-break-case-2"></a>It solves the BREAK case</h3>
<p>Below we see a situation where the first FOR-EACH returns NULL (and <strong>meta null</strong> is just <strong>null</strong>).  So it short-circuits the ALL, and propagates the null as a signal that it broke:</p>
<pre><code>&gt;&gt; for-both x [1 2] [3 4] [if x = '2 [break], print [x], x = 5]
1
== ~null~  ; isotope
</code></pre>
<p>Note that the first pass through the loop did not terminate the ALL, just because the body evaluated to false.  That's because meta of isotopes produces QUASI!, which is truthy even if the isotopic thing is falsey:</p>
<pre><code> &gt;&gt; metafalse: meta ~false~
 == ~false~

 &gt;&gt; type of metafalse
 == #[datatype! quasi!]

&gt;&gt; if metafalse [print "All QUASI! are truthy!"]
All QUASI! are truthy!
</code></pre>
<p>This means the loop can gracefully recover the QUASI! as the ALL result if the loop completes, and remove the quasi level:</p>
<pre><code>&gt;&gt; for-both x [1 2] [3 4] [print [x], x = 5]
1
2
3
4
== ~false~  ; isotope
</code></pre>
<h3>
<a name="it-solves-the-fallout-from-the-last-loop-body-3" class="anchor" href="https://forum.rebol.info#it-solves-the-fallout-from-the-last-loop-body-3"></a>It Solves the Fallout From The Last Loop Body</h3>
<p>This takes advantage of a new invariant: <em><strong>loops which never run their bodies return void</strong></em>.</p>
<pre><code>&gt;&gt; for-each x [] [fail "This body never runs"]
; void
</code></pre>
<p>Voids act invisibly in constructs like ALL.  So we get the result we want:</p>
<pre><code>&gt;&gt; for-both x [1 2] [] [print [x], x * 10]
1  ; evaluated to 10
2  ; evaluated to 20
== 20
</code></pre>
<p>There's a slight fib here, that META of the void did not produce a "meta-void" (')...but passed it through as it would a NULL.  That's a "user-friendly" property of the META-as-a-word form:</p>
<pre><code>&gt;&gt; meta if false ["META-the-word passes through the vanishing void isotopes"]
; void

&gt;&gt; ^ if false ["The ^ operator is more exact, gives the meta signal"]
== '
</code></pre>
<p>But in situations like this, passing through the void state is what we wanted.</p>
<h3>
<a name="you-can-even-return-null-from-the-body-4" class="anchor" href="https://forum.rebol.info#you-can-even-return-null-from-the-body-4"></a>You Can Even Return NULL From the Body!</h3>
<p>Thanks to isotopes, the following is possible:</p>
<pre><code>&gt;&gt; x: for-both x [1 2] [] [print [x], if x = 2 [null]]
1
2
; first in pack of length 1
== ~null~  ; isotope

&gt;&gt; x
== ~null~ 
</code></pre>
<p>How cool is that?  Even though NULL is being reserved as the unique signal for loops breaking, there's a backchannel for it to escape...out of the FOR-EACH, and up out of the FOR-BOTH wrapping it!</p>
<h2>
<a name="it-holds-up-under-scrutiny-5" class="anchor" href="https://forum.rebol.info#it-holds-up-under-scrutiny-5"></a>It Holds Up Under Scrutiny!</h2>
<p>I'm really pleased with it, and here are some tests:</p>
<p><a href="https://github.com/metaeducation/ren-c/blob/master/tests/loops/examples/for-both.loops.test.reb" class="inline-onebox">ren-c/tests/loops/examples/for-both.loops.test.reb at master Â· metaeducation/ren-c Â· GitHub</a></p>
<p>I invite you to test it some more...ask questions...and perhaps come up with your own loop compositions!</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/atom_symbol.png?v=12" title=":atom_symbol:" class="emoji only-emoji" alt=":atom_symbol:" loading="lazy" width="20" height="20"></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833</link>
          <pubDate>Tue, 31 May 2022 16:02:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1833</guid>
          <source url="https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833.rss">Demonstrating FOR-BOTH: Loop Composability For The Win :exclamation:</source>
        </item>
        <item>
          <title>Prettier TLS State Tables (and Assessing the Cost)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>So the spec-driven TLS originally had this state table.  On the left are states and on the right is a block of the legal states you can transition to from that state (if any).</p>
<p>Here are the states for a TLS read:</p>
<pre><code>read-proto-states: [
    client-hello [server-hello]
    server-hello [certificate]
    certificate [server-hello-done server-key-exchange]
    server-key-exchange [server-hello-done]
    server-hello-done [#complete]
    finished [change-cipher-spec alert]
    change-cipher-spec [encrypted-handshake]
    encrypted-handshake [application #complete]
    application [application alert #complete]
    alert [#complete]
    close-notify [alert]
]
</code></pre>
<p><em>It seemed to me this wasn't exploiting the types all that well.</em>  We see an ISSUE! being used for <span class="hashtag">#complete</span>.  I imagined it would be better to move the issue annotation onto the state itself: <strong>If a state was represented by an ISSUE!, then that meant the state could legally be transitioned to the completion state.</strong></p>
<p>So instead of:</p>
<pre><code>encrypted-handshake [application #complete]
</code></pre>
<p>That would become:</p>
<pre><code>#encrypted-handshake [#application]
</code></pre>
<p>(Since the application state could be terminal as well.)</p>
<p>Now you know just by looking at it that <span class="hashtag">#encrypted-handshake</span> is a <em>potentially-terminal state</em>...and that's everywhere that encrypted-handshake appears.  It's not that much more typing, since you have to put an apostrophe on most uses anyway...and it helps the state "stand out".</p>
<p>Plus making the non-terminal states stand out would be good, so I turned them into tags.</p>
<p><strong>I also thought that the blocks looked a bit boring, and I didn't like having to put single elements into blocks just for the convenience of the implementation.</strong>  I tried adding arrows and letting single elements stand alone on the mapped-to side:</p>
<pre><code>read-proto-states: [
    &lt;client-hello&gt;          -&gt; &lt;server-hello&gt;
    &lt;server-hello&gt;          -&gt; &lt;certificate&gt;
    &lt;certificate&gt;           -&gt; [#server-hello-done &lt;server-key-exchange&gt;]
    &lt;server-key-exchange&gt;   -&gt; #server-hello-done
    &lt;finished&gt;              -&gt; [&lt;change-cipher-spec&gt; #alert]
    &lt;change-cipher-spec&gt;    -&gt; #encrypted-handshake
    #encrypted-handshake    -&gt; #application
    #application            -&gt; [#application #alert]
    #alert                  -&gt; []
    &lt;close-notify&gt;          -&gt; #alert
]
</code></pre>
<p>Of course, this needs to be parsed into a MAP!, so we need some code like:</p>
<pre><code>transitions: make map! []  ; map from states to block of states
state-rule: [tag! | issue!]
uparse transdialect [
    while [
        left: state-rule '-&gt; right: [
            into block! [while state-rule, &lt;input&gt;]
            | collect keep state-rule
        ]
        (append transitions :[left right])
    ]
]
</code></pre>
<h2>Improvement...Or Dialecting For The Sake of Dialecting?</h2>
<p>The general question of whether or not to use things like ISSUE! and TAG! for states as opposed to the "cleaner" WORD!s is something that is a bit controversial.</p>
<p>One issue is that there's traditionally a greater cost to comparing strings than there is to comparing words.  So <strong>state = <span class="hashtag">#encrypted-handshake</span></strong> is slower than <strong>state = 'encrypted-handshake</strong>.  The worst case scenario is equality--because all the characters have to be compared to decide if they are equal.</p>
<p>I'd like to focus more on the qualities of the source representation than worry about the performance however.</p>
<p>There's certainly a point of view where the original wasn't as "noisy".  But if you take the extreme opinion of using WORD! for everything, then the code all blurs together.</p>
<h2>Parsing Has The Benefit Of Validation</h2>
<p>When you stylize your input and do some processing of it to get it into a canonized form, that process of translating your input is a chance to check that the data is what you expect.</p>
<p>Using a generic structure doesn't just keep you from throwing in "superficial" flourishes like <strong><code>-&gt;</code></strong>, but the generality usually goes with accepting anything.  Once you have a processing step that puts you in the position of being able to validate...which is a powerful thing.</p>
<h2>I Think These Kinds of Things Are "The Point"</h2>
<p>I don't know if this particular example is the best example.  But I do think that this is what PARSE is meant for, and UPARSE is pushing things to a new level.  We should be looking for opportunities to show off this kind of idea, vs just doing what other languages do in a weird way.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/prettier-tls-state-tables-and-assessing-the-cost/1736">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/prettier-tls-state-tables-and-assessing-the-cost/1736</link>
          <pubDate>Sun, 03 Oct 2021 17:29:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1736</guid>
          <source url="https://forum.rebol.info/t/prettier-tls-state-tables-and-assessing-the-cost/1736.rss">Prettier TLS State Tables (and Assessing the Cost)</source>
        </item>
        <item>
          <title>Isotopic WORD!s For More Informative States in TLS</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>When introducing isotopic WORD!s, I wrote:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1383">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/lingering-idea-labeled-ornery-word-s/1383/1">Lingering Idea: Labeled "Ornery" WORD!s</a>
</div>
<blockquote>
<p>Since these can be used as a kind of deferred error--a bad result that's only there to be bad if you actually use it--the text in these words could help guide you to what happened.</p>
</blockquote>
</aside>
<p>Today I hit a good example.  I was going over some stuff in the TLS code, and found this:</p>
<pre><code>; Each encrypted message in TLS 1.1 and above carry a plaintext
; initialization vector, so the ctx does not use one for the whole
; session.  Unset it to make sure.
;
unset in ctx 'client-iv
unset in ctx 'server-iv
</code></pre>
<p>So in TLS 1.0 mode, there is a single "iv" (initialization vector) reused for the client and server over the whole session.  But you don't want to use those fields in TLS 1.1 and above, because you're supposed to be using the data from each message.</p>
<p>The historical trick to catch unwanted reads of these fields was to unset them.</p>
<ul>
<li>
<p>It was awkward to do so...since UNSET!s couldn't be assigned via SET-WORD!</p>
</li>
<li>
<p>Also, it didn't communicate any information besides "unset"</p>
</li>
</ul>
<p>Today, you can painlessly get the effect...with a more meaningful error on access!</p>
<pre><code>ctx.client-iv: ctx.server-iv: ~per-message~
</code></pre>
<p>So if you get an error on trying to access these variables, it will tell you its the isotopic WORD! of <strong>~per-message~</strong>.  You can look that up in the source or get the gist of what it means.</p>
<p><em>(I'm still thinking about how we might put the file and line number into the value itself, so you could find this assignment and get at the origin of the value!)</em></p>
<p>Using isotopes effectively is a lot of bang for the buck.  Neat stuff!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/isotopic-word-s-for-more-informative-states-in-tls/1933">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/isotopic-word-s-for-more-informative-states-in-tls/1933</link>
          <pubDate>Sun, 15 Aug 2021 12:44:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1933</guid>
          <source url="https://forum.rebol.info/t/isotopic-word-s-for-more-informative-states-in-tls/1933.rss">Isotopic WORD!s For More Informative States in TLS</source>
        </item>
        <item>
          <title>A Lot To UNPACK: (Replacing the SET of REDUCE BLOCK! Idiom)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>We've fretted a lot about the result of REDUCE when an expression produces something that can't be put in a block.  At first this was just NULL.  <em><a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">But now it's all isotopic forms.</a></em></p>
<p>One reason to fret is the historical idiom of setting multiple values in a block.  This was done with a SET of a REDUCE.  Something along the lines of:</p>
<pre><code>&gt;&gt; x: 3 + 4
== 7

&gt;&gt; set [a b] reduce [10 + 20 x]
== [30 7]

&gt;&gt; a
== 30

&gt;&gt; b
== 7
</code></pre>
<p>It's your choice to reduce the values or not.  If you don't involve REDUCE then the mechanics would all work out.  But once you get NULLs and isotopes, the reduced block can't store the values to convey them to the SET...</p>
<h2>
<a name="but-what-if-a-single-operation-did-both-1" class="anchor" href="https://forum.rebol.info#but-what-if-a-single-operation-did-both-1"></a>But What If A Single Operation Did Both...?</h2>
<p>Let's imagine we have instead something called PACK that by default reduces to meta values... and that SET-BLOCK! is willing to "unpack" one at a time in UNMETA'd variables.</p>
<pre><code>&gt;&gt; x: 3 + 4
== 7

&gt;&gt; [a b]: pack [10 + 20 x]
== 30

&gt;&gt; a
== 30

&gt;&gt; b
== 7
</code></pre>
<p>We can prototype the behavior by making PACK quote a SET-WORD! or SET-BLOCK! on its left, and combine that with the unpacking.  PACK manages the evaluation one expression at a time, instead of using REDUCE.  So as it goes it can set the variables to NULL or isotopes.  And by following the multi-return convention of returning the first value, you avoid ever needing to synthesize a block aggregating all the results together.</p>
<pre><code>&gt;&gt; [a b]: pack case [
       1 = 1 [
           print "This is pretty slick..."
           [select [a 10] 'b, 1 + 2]
       ]
    ] else [
        print "This won't run because the ELSE gets a BLOCK!"
        print "Which is what you want, because the ELSE should be"
        print "what runs if no CASE was matched and have the option"
        print "of providing the block to UNPACK"
    ]
 This is pretty slick...
 == ~null~  ; isotope

&gt;&gt; a
== ~null~  ; isotope

&gt;&gt; b
== 3
</code></pre>
<h2>
<a name="can-even-avoid-a-reduce-2" class="anchor" href="https://forum.rebol.info#can-even-avoid-a-reduce-2"></a>@[...] can Even Avoid A REDUCE</h2>
<p>If you already have a block in reduced or literal form, how would you tell the PACK about that?  It could be a refinement like PACK/ONLY.  BUT...what if that were signaled with the @ block type?</p>
<pre><code>&gt;&gt; [a b]: pack @[1 +]
== 1

&gt;&gt; a
== 1

&gt;&gt; b
== +
</code></pre>
<p>A real aspect of power in this approach is the ability to mix and match.  For instance you could have some branches in a CASE which have already reduced data and others that don't, and they could all participate with the same PACK operation.</p>
<pre><code>[op1 op2]: pack case [
    ... [
        print "This branch uses values as-is"
        @[+ -]
    ]
    ... [
       print "This branch needs evaluation"
       [operators.1, pick [- /] op-num]
   ]
]
</code></pre>
<h2>
<a name="cool-dialecting-twists-3" class="anchor" href="https://forum.rebol.info#cool-dialecting-twists-3"></a>Cool Dialecting Twists</h2>
<p>The basic premise of multiple returns is that if you don't know about extra values, you don't worry about them... so by default packs with extra values need to just ignore them.</p>
<pre><code>&gt;&gt; [a b]: pack [1 2 3]
== 1

&gt;&gt; a
== 1

&gt;&gt; b
== 2
</code></pre>
<p>But for some applications, it might be nice to be able to check that an unpacking is exact:</p>
<pre><code>&gt;&gt; [a b &lt;end&gt;]: pack [1 2 3]
** Error: Too many values for vars in PACK (expected &lt;end&gt;)
</code></pre>
<p>Borrowing from multi-return: I think the idea of "circling" values to say which is the one you want the overall expression to evaluate to is a neat idea.</p>
<pre><code>&gt;&gt; [a @b]: pack [1 2]
== 2
</code></pre>
<h2>
<a name="and-for-show-and-tell-a-prototype-4" class="anchor" href="https://forum.rebol.info#and-for-show-and-tell-a-prototype-4"></a>And For Show And Tell... A Prototype!</h2>
<p>How hard is it to write such a thing, you ask?  In Ren-C it's super easy, barely an inconvenience:</p>
<p><em>(Note: Prototype updated circa 2023...kept around as a test of usermode behavior.  But now this is handled by SET-BLOCK! and PACK! isotopes.)</em></p>
<pre><code>pack: enfixed func [
    {Prepare a BLOCK! of values for storing each in a SET-BLOCK!}
    return: [&lt;opt&gt; &lt;void&gt; any-value!]
    'vars [set-block! set-group!]
    block "Reduced if normal [block], but values used as-is if @[block]"
        [block! the-block!]
][
    if set-group? vars [vars: eval vars]

    ; Want to reduce the block ahead of time, because we don't want partial
    ; writes to the results (if one is written, all should be)
    ;
    ; (Hence need to do validation on the ... for unpacking and COMPOSE the
    ; vars list too, but this is a first step.)
    ;
    block: if the-block? block [
        map-each item block [quote item]  ; should REDUCE do this for @[...] ?
    ]
    else [
        reduce/predicate block :meta
    ]

    let result': void'
    for-each val' block [
        if result' = void' [
            result': either blank? vars.1 [void'] [val']
        ]
        if vars.1 = &lt;end&gt; [
            fail "Too many values for vars in PACK (expected &lt;end&gt;)"
        ]
        if tail? vars [
            continue  ; ignore all other values (but must reduce all)
        ]
        switch/type vars.1 [
            blank! []  ; no assignment
            word! tuple! [set vars.1 unmeta val']
            meta-word! meta-tuple! [set vars.1 val']
        ]
        vars: my next
    ]
    if vars.1 = &lt;end&gt; [
        if not last? vars [
            fail "&lt;end&gt; must appear only at the tail of PACK variable list"
        ]
    ] else [
        ; We do not error on too few values (such as `[a b c]: [1 2]`) but
        ; instead unset the remaining variables (e.g. `c` above).  There could
        ; be a refinement to choose whether to error on this case.
        ;
        for-each var vars [  ; if not enough values for variables, unset
            if not blank? var [unset var]
        ]
    ]
    return unmeta any [result' void']
]
</code></pre>
<p>If the ^ and UNMETA seem confusing, the only thing you need to think about is that the META protocol helps you out when you're trying to deal with a situation of storing a value that can be anything...and you need to differentiate a state.  I'm making the result "meta" so that I can use plain unset to signal that it hasn't been assigned yet.  I could make a separate boolean variable instead, but then I'd have another variable and I'd have to GET/ANY the result...</p>
<p>I'm sure people will start getting the hang of it!  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/a-lot-to-unpack-replacing-the-set-of-reduce-block-idiom/1634">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/a-lot-to-unpack-replacing-the-set-of-reduce-block-idiom/1634</link>
          <pubDate>Thu, 08 Jul 2021 07:44:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1634</guid>
          <source url="https://forum.rebol.info/t/a-lot-to-unpack-replacing-the-set-of-reduce-block-idiom/1634.rss">A Lot To UNPACK: (Replacing the SET of REDUCE BLOCK! Idiom)</source>
        </item>
        <item>
          <title>UPARSE Case Study: Escaping In Strings</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I wanted to make a REWORD variation that would look for escaped parts of strings and extract them as words.  So:</p>
<pre><code>Input: "abc$(def)ghi"
Output: ["abc" def "ghi"]
</code></pre>
<p>It's a common-seeming and not entirely trivial task.  The first thing I came up with is a bit convoluted...perhaps because I tried to not repeat the "$(" and ")" strings in the rule:</p>
<pre><code>parse text [
    collect [
        try some [
            not &lt;end&gt;
            (capturing: false)
            try keep between &lt;here&gt; ["$(" (capturing: true) | &lt;end&gt;]
            :(if capturing '[
                let inner: between &lt;here&gt; ")"
                keep (as word! inner)
            ])
        ]
    ]
]
</code></pre>
<p>It basically alternates between a capturing mode and a non-capturing mode.  It decides if it needs to run a capture mode with a variable.</p>
<p>It has to throw in a <a href="https://forum.rebol.info/t/any-vs-while-and-not-end/1572"><code>NOT &lt;END&gt;</code> for reasons I explain in another post</a>.  Because it's running alternating rules that may both opt out.</p>
<p>I use a GET-GROUP! spliced conditional rule, as UPARSE doesn't have any loop-interrupting constructs yet.  So you can't say "Stop running this rule, but consider it to have matched."  There's only LOGIC! of #[false] which means what FAIL used to mean...e.g. the overall rule did not match (so any collected material would be forgotten).</p>
<p>Since it can't break out of the rule and report success, it has to have a way to skip over a rule.  So the rule for capturing inside the parentheses conditions itself out with an IF statement and a generated rule.  I could have instead written that as an alternate rule, where if <code>not capturing</code> was true it would bypass normal code:</p>
<pre><code>parse text [
    collect [
        try some [
            not &lt;end&gt;
            (capturing: false)
            try keep between &lt;here&gt; ["$(" (capturing: true) | &lt;end&gt;]
            [:(not capturing) |
                let inner: between &lt;here&gt; ")"
                keep (as word! inner)
            ]
        ]
    ]
]
</code></pre>
<p>That feels more convoluted to me because of the inverse logic of the NOT, though.</p>
<p>It produces more empty strings than I would like:</p>
<pre><code>Input: "$(abc)$(def)$(ghi)"
Output: ["" abc "" def "" ghi]
</code></pre>
<p>It would technically be possible for a rule like BETWEEN to succeed and give a NULL result if there were no content, instead of an empty string:</p>
<pre><code>&gt;&gt; parse "()" [between "(" ")"]
== ~null~  ; anti
</code></pre>
<p>But this then means you can't get a good distinction of what happened in the case of an optional rule.</p>
<pre><code>&gt;&gt; parse "" [try between "(" ")"]
== ~null~   ; anti...so were there parentheses or not?
</code></pre>
<p>So I guess it's another situation where if you want to filter out the empty strings, you have to capture into a variable and filter it.</p>
<p><strong>I think UPARSE helps out here...but it's not quite the slam dunk I'd hope for.</strong></p>
<p>Because it has two rules that may both opt themselves out, it's a thought piece for asking if the NOT END makes sense with TRY SOME.  Or is it better off baking that into the TRY SOME rule and having another construct?  Intuitively I feel like the tax of having two slightly different versions and explaining the use of one vs. the other is worse than just having the more general construct.</p>
<p>If there were a loop-ending construct that indicated the overall rule was a success (e.g. didn't discard the KEEPs), then we might avoid the capturing flag:</p>
<pre><code>uparse text [
    collect [
        try some [
            try keep between &lt;here&gt; ["$(" | &lt;end&gt;]
            [&lt;end&gt; break |
                let inner: between &lt;here&gt; ")"
                keep (as word! inner)
            ]
        ]
    ]
]
</code></pre>
<p>But I don't know if BREAK is the right name for a loop-accepting operation (as in DO's while this typically causes most loop operations to return NULL).  So I'd think it would perhaps discard anything kept.  Perhaps STOP would be more consistent, and it could be value-bearing as well (<strong>stop (...)</strong>)</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/uparse-case-study-escaping-in-strings/1573">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/uparse-case-study-escaping-in-strings/1573</link>
          <pubDate>Sat, 27 Mar 2021 13:44:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1573</guid>
          <source url="https://forum.rebol.info/t/uparse-case-study-escaping-in-strings/1573.rss">UPARSE Case Study: Escaping In Strings</source>
        </item>
        <item>
          <title>Weird Idiom: Labeling Values?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I'm going through and changing a lot of FUNCTION uses to FUNC + LET.  The long term goal will be to eliminate the locals-gathering functionality...and you either use LET/USE or you go explicit with <code>&lt;local&gt;</code> in the function spec.</p>
<p>I came across this:</p>
<pre><code>    size-as-binary: enbin [be + 8] length of embedding
    append executable size-as-binary
</code></pre>
<p>This was the only use of the variable.  Changing it to a LET works, but it's kind of a waste:</p>
<pre><code>    let size-as-binary: enbin [be + 8] length of embedding
    append executable size-as-binary
</code></pre>
<p>LET's assignment form does run the right hand side...because the LET word itself vaporizes, so it's like the bound new SET-WORD! just runs as normal:</p>
<pre><code>    append executable let size-as-binary: enbin [be + 8] length of embedding
</code></pre>
<p>But a LET isn't really necessary here.  I had a weird thought, what if a TAG! or ISSUE! or something was used in a way that was "obviously" throwing it away?</p>
<pre><code>    append executable (&lt;size-as-binary&gt; enbin [be + 8] length of embedding)
</code></pre>
<p>Maybe a little confusing.  But it saves on a variable declaration.</p>
<p>A comment is zero overhead, so I'm doing that...</p>
<pre><code>    append executable enbin [be + 8] length of embedding  ; size of binary
</code></pre>
<p>But I just thought the idea of a deliberately discarded leading value was kind of interesting.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/weird-idiom-labeling-values/1500">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/weird-idiom-labeling-values/1500</link>
          <pubDate>Wed, 10 Feb 2021 19:21:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1500</guid>
          <source url="https://forum.rebol.info/t/weird-idiom-labeling-values/1500.rss">Weird Idiom: Labeling Values?</source>
        </item>
        <item>
          <title>Rebmake Shows Why NULLs Shouldn&#39;t Vaporize in REDUCE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p><em>Before there were <a href="https://forum.rebol.info/t/what-to-call-the-unstable-antiform-of-empty-block/2204">distinct NULL and VOID states</a>, there was only NULL... and it was the product of failed conditionals.  There was a debate about whether NULL should be an error if encountered by REDUCE, or if it should vaporize.  This is a little piece of circa 2021 history I extracted about the first case I saw that represented a problem, that I edited out of a thread I was paring down.</em></p>
<hr>
<blockquote>
<p>Both changes are now in master:</p>
<ul>
<li><a href="https://github.com/metaeducation/ren-c/commit/988fc71103f5c75c0656a688ac3c3a36fdba1c9b"><strong>null = do []</strong></a></li>
<li><a href="https://github.com/metaeducation/ren-c/commit/056d9f336050a1813426916e41b604e9bcbc70b9"><strong>[] = reduce [null]</strong></a></li>
</ul>
<p>The new REDUCE behavior has been advocated now by <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a>, <a class="mention" href="https://forum.rebol.info/u/blackattr">@BlackATTR</a>, <a class="mention" href="https://forum.rebol.info/u/giuliolunati">@giuliolunati</a>, <a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a>, and was my original choice also:</p>
<pre><code>&gt;&gt; append [&lt;a&gt; &lt;b&gt;] reduce [&lt;c&gt; if false [&lt;d&gt;]]
== [&lt;a&gt; &lt;b&gt; &lt;c&gt;]
</code></pre>
<p>Up until now it has errored to leave the option open, without yet breaking the "N expressions in, N values out" dogma espoused by DocKimbel.</p>
</blockquote>
<hr>
<p>Hmmm...well when I tried bootstrapping the updated executable, here is an example of where NULL vaporizing in REDUCE bit me:</p>
<p>It was some of Shixin's code from rebmake.</p>
<pre><code>    if not let suffix: find reduce [
        #application target-platform/exe-suffix
        #dynamic-library target-platform/dll-suffix
        #static-library target-platform/archive-suffix
        #object-library target-platform/archive-suffix
        #object-file target-platform/obj-suffix
    ] project/class [return]

    suffix: second suffix
</code></pre>
<p>I had changed the suffixes in the base class of some objects from BLANK! to NULL.  This was in order to be more likely to catch usage problems of those suffixes, when BLANK! is more quiet about many operations (e.g. they will silently append, like classical #[none] would).</p>
<p>NULL provides a gentle sort of alarm...in the sense that it is falsey and can't be e.g. silently appended without an operation converting it to a value.  This is good for callsite comprehension.</p>
<p>But with NULL vanishing here, code in this style has problems.  I'm not sure there's anything particularly wrong about code in this style.  So we still might want to think about this.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/rebmake-shows-why-nulls-shouldnt-vaporize-in-reduce/2205">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rebmake-shows-why-nulls-shouldnt-vaporize-in-reduce/2205</link>
          <pubDate>Thu, 10 Dec 2020 19:59:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2205</guid>
          <source url="https://forum.rebol.info/t/rebmake-shows-why-nulls-shouldnt-vaporize-in-reduce/2205.rss">Rebmake Shows Why NULLs Shouldn&#39;t Vaporize in REDUCE</source>
        </item>
        <item>
          <title>YIELDER and GENERATOR (and thinking about Coroutines)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>The stackless model so far has been built on a generic and comprehensible building block called a <strong>YIELDER</strong>.  I thought I'd walk through it a little.</p>
<h1>To understand YIELDER, first look at GENERATOR</h1>
<p>I think a generator is pretty easy to understand.  It is like a function, but instead of RETURN it has something called YIELD.  Each time YIELD is called the generator gives back the result but is left in a suspended state, and the next call to the generator will pick up right after the YIELD:</p>
<pre><code>counter: generator [
     let n: 0
     cycle [
          n: n + 1
          yield n
     ]
]

&gt;&gt; counter
== 1

&gt;&gt; counter
== 2
</code></pre>
<h2>Generators are building blocks, meant to be used with functions</h2>
<p>Generators don't take parameters.  So if you want to parameterize them, you should combine them with a function.  Imagine you wanted to be able to specify a bump amount for your counter:</p>
<pre><code>make-counter: func [bump] [
     return generator [
         let n: 0
         cycle [yield n: n + 1]
     ]
]

&gt;&gt; counter: make-counter 5

&gt;&gt; counter
== 1

&gt;&gt; counter
== 6

&gt;&gt; counter
== 11
</code></pre>
<h2>But functions aren't limited to being just "generator makers"...</h2>
<p>For instance: functions can be generator wrappers, that actually delegate to the generator...or perhaps even destroy it and make new ones.  Consider making a resettable counter, as <a class="mention" href="https://forum.rebol.info/u/giuliolunati">@giuliolunati</a> has in his GENERATE usermode generator:</p>
<pre><code> counter: func [/reset &lt;static&gt; n (0) gen (null)] [
     if reset [n: 0, return]
     return reeval gen: default [
         generator [
             cycle [yield n: n + 1]
         ]
     ]
 ]

 &gt;&gt; counter
 == 1

 &gt;&gt; counter
 == 2

 &gt;&gt; counter/reset

 &gt;&gt; counter
 == 1

 &gt;&gt; counter
 == 2
</code></pre>
<p>This gives a lot of flexibility in the design of generator interfaces.  Considering the above example alone: what if you are in a situation where you think the <strong>counter/reset</strong> should have returned 1 instead of being a separate step that had no return result?  Or maybe you think it should have returned what the last generator value was.</p>
<p>By making generators a "simplistic" building block, you're in control of these interface choices.</p>
<h2>The YIELDER hybridizes with functions for efficiency</h2>
<p>I said that generators don't have parameters or a function spec, but that is because they are a specialization of a version that does have a spec... called a YIELDER.</p>
<pre><code>weird-print: yielder [x] [
    cycle [
        print ["Odd print:" x]
        yield none
        print ["Even print:" x]
        yield none
    ]
]

&gt;&gt; weird-print "Hello"
Odd print: Hello

&gt;&gt; weird-print "Weird"
Even print: Weird

&gt;&gt; weird-print "World"
Odd print: World
</code></pre>
<p>This isn't anything you couldn't have achieved with a function that wrapped a generator, that held that generator statically and then sub-dispatched to it.  It's just cleaner and more efficient.  <em>(Since GENERATOR is implemented as <code>yielder [] [...generator body...]</code> it's kind of like the DOES analogue to FUNC.)</em></p>
<p>But this kind of gives you a sense of the parts box you have for building relatively efficient generator-type things.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/yielder-and-generator-and-thinking-about-coroutines/1311">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/yielder-and-generator-and-thinking-about-coroutines/1311</link>
          <pubDate>Tue, 28 Jul 2020 03:52:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1311</guid>
          <source url="https://forum.rebol.info/t/yielder-and-generator-and-thinking-about-coroutines/1311.rss">YIELDER and GENERATOR (and thinking about Coroutines)</source>
        </item>
        <item>
          <title>Portable Bridge Notation (PBN) Parser</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I decided I would do a small task in the web Ren-C build, which is to take the <a href="https://www.tistis.nl/pbn/" rel="nofollow noopener">"Portable Bridge Notation"</a> for representing a deal of a hand of cards, and turn it into blocks of symbolic data representing each player's hand.</p>
<p>The notation is pretty straightforward, e.g.</p>
<pre><code>N:QJ6.K652.J85.T98 873.J97.AT764.Q4 K5.T83.KQ9.A7652 AT942.AQ4.32.KJ3
</code></pre>
<p>Separated by spaces are the cards for each of 4 hands.  The suits are separated by dots, and the order is <strong><code>clubs.diamonds.hearts.spades</code></strong>.  T is used for 10, while J/Q/K/A are the typical Jack/Queen/King/Ace.  The first letter is a direction (N=North, E=East, S=South, W=West) of which player the first hand represented is for.</p>
<p>This case decodes like so:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/af1db86d4b17341751b69cbc3cba816ca16b2af6.jpeg" data-download-href="https://forum.rebol.info/uploads/default/af1db86d4b17341751b69cbc3cba816ca16b2af6" title="pbn-converter.jpg"><img src="https://forum.rebol.info/uploads/default/optimized/1X/af1db86d4b17341751b69cbc3cba816ca16b2af6_2_690x458.jpeg" alt="pbn-converter" data-base62-sha1="oZ9erLwEVhI0IGIYxhS9X9InLRY" width="690" height="458" srcset="https://forum.rebol.info/uploads/default/optimized/1X/af1db86d4b17341751b69cbc3cba816ca16b2af6_2_690x458.jpeg, https://forum.rebol.info/uploads/default/optimized/1X/af1db86d4b17341751b69cbc3cba816ca16b2af6_2_1035x687.jpeg 1.5x, https://forum.rebol.info/uploads/default/optimized/1X/af1db86d4b17341751b69cbc3cba816ca16b2af6_2_1380x916.jpeg 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/af1db86d4b17341751b69cbc3cba816ca16b2af6_2_10x10.png"></a></div><p></p>
<p><em>(<a href="https://github.com/hostilefork/replpad-js/blob/d7af14eea92d23d50c2bd25d5dfca20a11929a8a/replpad.reb#L173" rel="nofollow noopener">console escaping is now done by Rebol code</a>, so this shows some colorization and live hyperlink as an example of what we might do with that)</em>.</p>
<p>I wanted the PBN conversion to be accessible and demonstrate "best practices".  Here's what I came up with:</p>
<pre><code>pbn-to-hands: func [
    {Convert portable bridge notation to BLOCK!-structured hands}

    return: [object!]
    pbn [text!]
][
    let rank-rule: [
        'A | 'K | 'Q | 'J | 'T | '9 | '8 | '7 | '6 | '5 | '4 | '3 | '2
    ]

    let suit-order: [â™£ â™¦ â™¥ â™ ]
    let suit: void

    let one-hand: void
    let one-hand-rule: [
        (suit: 'â™£)
        [
            collect one-hand [4 [
                any [
                    set rank rank-rule
                    keep :[
                        as word! unspaced [suit either rank = #"T" [10] [rank]]
                    ]
                ]
                :(
                    suit: select suit-order suit
                    if suit ["."] else '[ahead [space | end]]
                )
            ]]
        ]
        |
        (fail "Invalid Hand information in PBN")
    ]

    let hands: make object! [N: E: S: W: void]
    let direction-order: [N E S W]

    let start: void
    let direction: void

    parse pbn [
        any space  ; We allow leading whitespace, good idea?

        [
            set start ['N | 'E | 'S | 'W] (
                start: to word! start
                direction: start
            )
            |
            (fail "PBN must start with N, E, S, or W")
        ]

        [":" | (fail "PBN second character must be `:`")]

        [
            [4 [
                one-hand-rule (  ; Should set `one-hand` if rule succeeds.
                    hands/(direction): one-hand
                    one-hand: void
                    direction: (select direction-order direction) else [
                        first direction-order
                    ]
                )
                any space  ; Should more than one space between hands be ok?
            ]]
            |
            (fail "PBN must have 4 hand definitions")
        ]
        end
    ]

    assert [direction = start]  ; skipping around should have cycled
    return hands
]</code></pre>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/portable-bridge-notation-pbn-parser/1306">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/portable-bridge-notation-pbn-parser/1306</link>
          <pubDate>Sun, 19 Jul 2020 01:58:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1306</guid>
          <source url="https://forum.rebol.info/t/portable-bridge-notation-pbn-parser/1306.rss">Portable Bridge Notation (PBN) Parser</source>
        </item>
        <item>
          <title>Collector In Disguise</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>So, this is somewhat trivial.  But what if you wanted a function that instead of RETURN ending the function, it just added to the results and moved on?  <a href="https://www.youtube.com/watch?v=35qsykW3f58">We might call this a COLLECTOR</a>.</p>
<p>Let's imagine that we like KEEP better than renaming to RETURN</p>
<pre><code>collector: func [spec block] [return func spec compose [collect (block)]]
; ^-- Ren-C semantics for COMPOSE, BLOCK! only splices if ((...))

c: collector [x] [
    keep x + 1
    keep x + 2
    keep x + 3
]

&gt;&gt; c 10
== [11 12 13]

&gt;&gt; c 20
== [21 22 23]

&gt;&gt; c 30
== [31 32 33]
</code></pre>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/collector-in-disguise/1277">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/collector-in-disguise/1277</link>
          <pubDate>Tue, 28 Apr 2020 11:47:36 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1277</guid>
          <source url="https://forum.rebol.info/t/collector-in-disguise/1277.rss">Collector In Disguise</source>
        </item>
        <item>
          <title>API Use Example: Elliptic Curve</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>It turns out we probably don't need to be adding <a href="https://en.wikipedia.org/wiki/Curve25519" rel="nofollow noopener">Curve25519</a> right at the moment for TLS.  But how quick I could bridge to a short C implementation's function was really neat, so I thought I'd both save the code and show it off.</p>
<p>What happens is it takes a 32-byte input and an optional 32-byte basepoint, both as BINARY!.  Then it returns another 32-byte result from calling the C implementation on the <code>unsigned char*</code> buffers (REBYTE):</p>
<pre><code>//
//  export curve25519: native [
//      return: "32-byte binary of public key data"
//          [binary!]
//      secret "32-byte binary of secret data"
//          [binary!]
//      /basepoint "optional 32-bytes, defaults to #{09000000...}"
//          [binary!] 
//  ]
//
REBNATIVE(curve25519)
{
    CRYPT_INCLUDE_PARAMS_OF_CURVE25519;

    size_t secret_size;
    REBYTE *secret = rebBytes(&amp;secret_size,
        "if 32 != length of", ARG(secret), "[",
            "fail {SECRET must be a 32-byte BINARY! for curve25519}",
        "]",
        ARG(secret),
    );
    assert(secret_size == 32);

    size_t basepoint_size;
    REBYTE *opt_basepoint = rebBytes(&amp;basepoint_size,
        "if all [", REF(basepoint), "32 != length of", REF(basepoint), "] [",
            "fail {/BASEPOINT must be a 32-byte BINARY! for curve25519}",
        "]",
        REF(basepoint),
    );
    assert(opt_basepoint ? basepoint_size == 32 : basepoint_size == 0);

    REBYTE mypublic[32];  // "public" is a C++ keyword :-/

    curve25519(mypublic, secret, opt_basepoint);
    rebFree(secret);
    rebFree(opt_basepoint);  // null-tolerant, like C's free()

    return rebSizedBinary(mypublic, 32);
}
</code></pre>
<p>Here you see the power of libRebol's hybridized calls.  rebBytes isn't just a routine for extracting the binary bytes out of a Rebol value...it's able to do a size check first (which FAILs if it needs to).  Then the last item in the evaluation is the argument itself.  C's 0-for-null is leveraged simply, so that if an argument is null the extractors just give back null.</p>
<p>Being able to do this in plain ANSI C is really rather awesome!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/api-use-example-elliptic-curve/1263">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/api-use-example-elliptic-curve/1263</link>
          <pubDate>Wed, 19 Feb 2020 03:14:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1263</guid>
          <source url="https://forum.rebol.info/t/api-use-example-elliptic-curve/1263.rss">API Use Example: Elliptic Curve</source>
        </item>
        <item>
          <title>Simple Sudoku Solver</title>
          <dc:creator><![CDATA[iArnold]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <pre><code>; simple sudoku solver based on the Python example from computerphile:
; https://www.youtube.com/watch?v=G_UYXzGuqvM&amp;list=WL&amp;index=228

grid: [
5 3 0 0 7 0 0 0 0
6 0 0 1 9 5 0 0 0
0 9 8 0 0 0 0 6 0
8 0 0 0 6 0 0 0 3
4 0 0 8 0 3 0 0 1
7 0 0 0 2 0 0 0 6
0 6 0 0 0 0 2 8 0
0 0 0 4 1 9 0 0 5
0 0 0 0 8 0 0 7 9
]

print-grid: func [&lt;with&gt; grid &lt;local&gt; output][
    output: copy ""
    count-up i 81 [
        append output grid/:i
        either i mod 9 = 0 [
            append output newline
            if all [ i mod 27 = 0
                     i &lt; 81        ][
                append output "------+-------+------^/"
            ]
        ][
             append output either any [ i mod 9 = 3
                                        i mod 9 = 6 ][ " | " ][ " " ]
        ]
    ]
    print output
]

possible: func [
    y
    x
    n
    &lt;with&gt; grid
    &lt;local&gt; x0 y0
][
    count-up i 9 [
        if n = grid/(9 * (y - 1) + i) [
            return false
        ]
    ]
    count-up i 9 [
        if n = grid/(9 * (i - 1) + x) [
            return false
        ]    
    ]
    x0: ((to integer! (x - 1) / 3)) * 3 + 1
    y0: ((to integer! (y - 1) / 3)) * 3 + 1
    count-up i 3 [
        count-up j 3 [
            if n = grid/(9 * (y0 + (i - 1) - 1) + (x0 + (j - 1))) [
                return false
            ]
        ]
    ]
    return true
]

solve: func [&lt;with&gt; grid][
    count-up y 9 [
        count-up x 9 [
            if 0 = grid/(9 * (y - 1) + x) [
                count-up n 9 [
                    if possible y x n [
                        grid/(9 * (y - 1) + x): n
                        solve
                        grid/(9 * (y - 1) + x): 0 ; backtracking
                    ]
                ] return _
            ]
        ]
    ]
    print-grid
]
</code></pre>
<p>The result of running it:</p>
<pre><code>&gt;&gt; solve
5 3 4 | 6 7 8 | 9 1 2
6 7 2 | 1 9 5 | 3 4 8
1 9 8 | 3 4 2 | 5 6 7
------+-------+------
8 5 9 | 7 6 1 | 4 2 3
4 2 6 | 8 5 3 | 7 9 1
7 1 3 | 9 2 4 | 8 5 6
------+-------+------
9 6 1 | 5 3 7 | 2 8 4
2 8 7 | 4 1 9 | 6 3 5
3 4 5 | 2 8 6 | 1 7 9

== _
</code></pre>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/simple-sudoku-solver/2070">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/simple-sudoku-solver/2070</link>
          <pubDate>Thu, 13 Feb 2020 12:01:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2070</guid>
          <source url="https://forum.rebol.info/t/simple-sudoku-solver/2070.rss">Simple Sudoku Solver</source>
        </item>
        <item>
          <title>8 Queens Problem</title>
          <dc:creator><![CDATA[iArnold]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>Code for the "8 Queens problem"</p>
<pre><code>; REN-C solution to the N Queens problem
;
; Place all N queens on the NxN chessboard where every queen is to be placed 
; on a field that is not taken nor covered by any of the other queens.
;
; We know the solutions are not symmetrical themselves but the solutions can be
; mirror images of other solutions or turned solutions.

; This solution works as follows
; By symmetry we only need to test the first half of the row or column with
; the first queen. On an odd sized board we only cannot double the number of
; results for the middle position.

; We do not know or even care if we work horizontally or vertically and even if we are
; starting at the first or last row or column is irrelevant.

; We start with adding our first queen to the board. This is a number in a
; solution block. The we go to the next level and determine the free choices
; for our next queen. This is a collection of all fields minus the ones other
; queens cover. This propagates through all rows / columns. At the end we
; reach an empty set so no solution or a set of solutions.

; This global variable is a quick and dirty fix.
number-of-solutions: 0

reset-number-of-solutions: does [
    number-of-solutions: 0
]

add-one-to-number-of-solutions: does [
    number-of-solutions: number-of-solutions + 1
]

get-number-of-solutions: does [
    number-of-solutions
]

; This variable is to signal that results should not be duplicated for
; this value.
odd-symmetry-limit: 0

reset-symmetry-limit: does [
    odd-symmetry-limit: 0
]

add-to-symmetry-limit: does [
    odd-symmetry-limit: odd-symmetry-limit + 1
]

;
logic-countonly: 0

set-countonly-true: does [
    logic-countonly: 1
]

set-countonly-false: does [
    logic-countonly: 0
]

; Function to print the board for a solution

print-board: function [n [integer!]
                       board-values [block!]
][
    a: copy ""
    for-each b board-values [
        repeat t b - 1 [ append a ". "]
        append a "Q "
        repeat t n - b [ append a ". "]
        append a newline
    ]
    print a
]

; Function for recursion
add-queen: function [n [integer!]
     solution [block!]
     free-places [block!]
][
     ; Determine the free choices for this queen
     forbidden-places: copy []
     can-see: 1
     rsolution: reverse copy solution
     for-each sol rsolution [
         append forbidden-places sol
         append forbidden-places sol + can-see
         append forbidden-places sol - can-see ; too lazy to check for out of bounds
         can-see: can-see + 1
     ]
     free-choices: exclude free-places forbidden-places
     if not empty? free-choices [
         either n = 1 [
             ; now check for a solution, no more recursion possible
             for-each place free-choices [
                 append solution place
                 if logic-countonly = 0 [print-board length-of solution solution]
                 add-one-to-number-of-solutions
                 if any [odd-symmetry-limit &gt; first solution
                         odd-symmetry-limit = 0]
                  [
                     if logic-countonly = 0 [print-board length-of solution reverse copy solution]
                     add-one-to-number-of-solutions
                 ]
                 clear skip solution ((length-of solution) - 1)
             ]
         ][
             for-each place free-choices [
                 append solution place
                 add-queen n - 1 solution free-places
                 clear skip solution ((length-of solution) - 1)
             ]
         ]
     ]
]

; Function for main solution

solve-n-queens: function [
    n [integer!] "The number queens on to place the board of size nxn"
    /countonly "Only print the number of solutions found"
][
    ; We need to know this within our recursive function
    either "/countonly" = mold countonly [
        set-countonly-true
    ][
        set-countonly-false
    ]

    ; make a basic block of the row / column numbers
    places-block: copy []
    count-up i n [append places-block i]

    reset-number-of-solutions

    ; We need only do half of the first row / column for reasons of symmetry
    half: either odd? n [(n + 1) / 2][n / 2]
    reset-symmetry-limit
    if odd? n [
        loop half [add-to-symmetry-limit]
    ]

    either n &gt; 1 [
        count-up first-queen half [
            solution: copy []
            append solution first-queen

            add-queen n - 1 solution places-block

            clear solution ; this is okay because we are in the outermost loop here
        ]
    ][
        add-one-to-number-of-solutions
        print-board n [1]
    ]

    ; print the number of solutions now
    print spaced ["Total number of solutions for n =" n "is" get-number-of-solutions]
]


; Examples

solve-n-queens 1
solve-n-queens 2
solve-n-queens 3
solve-n-queens 4
solve-n-queens 5
solve-n-queens/countonly 5

solve-n-queens/countonly 8
; 92
</code></pre>
<p>If we want to know how slow REN-C is on my machine</p>
<pre><code>&gt;&gt; delta-time [solve-n-queens/countonly 5]
Total number of solutions for n = 5 is 10
== 0:00:00.00145

&gt;&gt; delta-time [solve-n-queens/countonly 8]
Total number of solutions for n = 8 is 92
== 0:00:00.041275

&gt;&gt; delta-time [solve-n-queens/countonly 12] 
Total number of solutions for n = 12 is 14200
== 0:00:08.126828

&gt;&gt; delta-time [solve-n-queens/countonly 14] 
Total number of solutions for n = 14 is 365596
== 0:06:21.679977
</code></pre>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/8-queens-problem/2071">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/8-queens-problem/2071</link>
          <pubDate>Sat, 01 Feb 2020 21:25:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2071</guid>
          <source url="https://forum.rebol.info/t/8-queens-problem/2071.rss">8 Queens Problem</source>
        </item>
        <item>
          <title>Displaying Prime Factors</title>
          <dc:creator><![CDATA[iArnold]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>Displaying the Prime factors of an integer.<br>
On <a href="http://rebol.org">rebol.org</a> <a href="http://www.rebol.org/view-script.r?script=oneliner-prime-factors.r">this oneliner script</a> by Sunanda can be found.<br>
I needs slight <strong>mod</strong> ification to work on REN-C. And with a bit of realigning and getting rid of the abbreviation for 'append we arrive at this function.</p>
<pre><code>prime-factors: function [n [integer!]][
    m: 2 
    s: 1 
    a: copy[]
    until[
        either n mod m = 0 [
            n: n / m 
            append a m
        ][
            m: m + s 
            s: 2
        ]
        if 1. * m * m &gt; n [
            append a n 
            n: 1
        ]
         n = 1
    ]
    a
] 
</code></pre>
<p>Where it is to be noted that n should be &gt;= 2 and the maximum size will also be limited</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/displaying-prime-factors/2072">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/displaying-prime-factors/2072</link>
          <pubDate>Thu, 30 Jan 2020 14:06:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2072</guid>
          <source url="https://forum.rebol.info/t/displaying-prime-factors/2072.rss">Displaying Prime Factors</source>
        </item>
  </channel>
</rss>

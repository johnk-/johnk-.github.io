<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Show &amp; Tell - AltRebol</title>
    <link>https://forum.rebol.info/c/usage/show-and-tell/33</link>
    <description>Topics in the &#39;Show &amp; Tell&#39; category Created something short and syrupy sweet?  Then post your scripts here; not confined to infinite length one-liners!</description>
    
      <lastBuildDate>Fri, 08 Nov 2024 19:05:55 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/usage/show-and-tell/33.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Trailing Slash Is A Winner For Defused Actions</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I <em>really</em> like this trailing slash thing, meaning "get me the action as is and don't run it AND guarantee it's an action".</p>
<pre><code>&gt;&gt; replace [a 1 a &lt;baby&gt;] word?/ &lt;ice&gt;
== [&lt;ice&gt; 1 &lt;ice&gt; &lt;baby&gt;]
</code></pre>
<p>That's to me just about perfect:</p>
<ul>
<li>
<p>You're passing the parameter of what to replace as being an antiform action, so it will be called on the elements.</p>
</li>
<li>
<p>It does NOT take a parameter (notice the slash dividing it from what comes after it?  that's a strong semiotic hint that <code>&lt;ice&gt;</code> is not a parameter to <code>word?</code>)</p>
</li>
<li>
<p>...and it's an antiform, so you know it doesn't occur literally in the block.</p>
</li>
</ul>
<p>Before this form existed, I was using MATCHES which made an antiform action for a datatype:</p>
<pre><code>&gt;&gt; replace [a 1 a &lt;baby&gt;] matches word! &lt;ice&gt;
== [&lt;ice&gt; 1 &lt;ice&gt; &lt;baby&gt;]
</code></pre>
<p>That's slower, wordier, and more opaque about the mechanics.</p>
<p>It's useful if you have a datatype in your hand and need to convert it to a function, or if you have a more complex type construction:</p>
<pre><code>&gt;&gt; replace [a 1 a &lt;baby&gt;] matches [word! integer!] &lt;ice&gt;
== [&lt;ice&gt; &lt;ice&gt; &lt;ice&gt; &lt;baby&gt;]
</code></pre>
<p>Maybe it should be called MATCHER, since it's actually a function generator.  MATCHES looks a little too much like MATCH, so it seems like it might take <code>&lt;ice&gt;</code> as an argument.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=12" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>If you make such a call often, you wouldn't want to regenerate the function each time:</p>
<pre><code>&gt;&gt; word-or-int?: matcher [word! integer!]

&gt;&gt; replace [a 1 a &lt;baby&gt;] word-or-int?/ &lt;ice&gt;
== [&lt;ice&gt; &lt;ice&gt; &lt;ice&gt; &lt;baby&gt;]
</code></pre>
<p>MATCHES would seems like it's providing an answer in the moment, whereas MATCHER works better for when you're not using immediately.  So it's probably the better choice.</p>
<p>Anyway, I'll also say that the <a href="https://forum.rebol.info/t/make-replace-all-default-semantics-of-replace/2269">REPLACE "ALL" semantic being the default</a> is a big improvement.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/trailing-slash-is-a-winner-for-defused-actions/2327">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/trailing-slash-is-a-winner-for-defused-actions/2327</link>
          <pubDate>Fri, 08 Nov 2024 19:05:55 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2327</guid>
          <source url="https://forum.rebol.info/t/trailing-slash-is-a-winner-for-defused-actions/2327.rss">Trailing Slash Is A Winner For Defused Actions</source>
        </item>
        <item>
          <title>TRIPWIRE in The Wild</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>If you access an unset variable, you don't get a lot of information back:</p>
<pre><code>&gt;&gt; state: ~

&gt;&gt; state
** Script Error: state is ~ antiform
** See ^(...) and GET/ANY
</code></pre>
<p>But with <strong><a href="https://forum.rebol.info/t/antiform-tag-as-triggers-an-error-on-access-type/2170">antiform tags</a></strong>, you can embed a message into the unset variable:</p>
<pre><code>&gt;&gt; state: ~&lt;INITIALIZE-STATE hasn't been called yet&gt;~

&gt;&gt; state
** Script Error: state is ~&lt;INITIALIZE-STATE hasn't been called yet&gt;~ antiform
** See ^(...) and GET/ANY
</code></pre>
<p>This new concept is called a <strong>TRIPWIRE</strong>.</p>
<p>DEFAULT reacts to it, considering the variable to be "vacant"</p>
<pre><code>&gt;&gt; vacancy? get/any $state
== ~okay~  ; anti

&gt;&gt; state: default [10 + 20]
== 30

&gt;&gt; state
== 30
</code></pre>
<h2>
<a name="can-be-better-than-a-meandering-comment-1" class="anchor" href="https://forum.rebol.info#can-be-better-than-a-meandering-comment-1"></a>Can Be Better Than A Meandering Comment!</h2>
<p>A comment won't direct people to the relevant issue at runtime.  But a well-chosen tripwire can.</p>
<p>Compare:</p>
<pre><code>; !!! UPARSE is not available in SYS because it is higher level.  We hack it
; up so that when %uparse.r runs it pokes itself into sys.util/parse
;
parse: ~
</code></pre>
<p>With:</p>
<pre><code>parse: ~&lt;higher-level %uparse.r hasn't set SYS.UTIL/PARSE yet&gt;~
</code></pre>
<p>Much better!  Gives you the information you need, when you need it!</p>
<p><em>(Note: I was inspired to this concept by a style of usage <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> had in his scripts, using TAG!s to provide guidance for what was supposed to be filled into certain slots.  I just wanted to give that some teeth, to know that the variable was conceptually unset.)</em></p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/tripwire-in-the-wild/2278">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/tripwire-in-the-wild/2278</link>
          <pubDate>Sun, 15 Sep 2024 07:46:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2278</guid>
          <source url="https://forum.rebol.info/t/tripwire-in-the-wild/2278.rss">TRIPWIRE in The Wild</source>
        </item>
        <item>
          <title>Quick and Dirty FLOW Example</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>At one point I proposed something along the lines of:</p>
<pre><code>&gt;&gt; flow [
       [1 2 3]
       reverse _
       map-each x _ [x * 10]
   ]
== [30 20 10]
</code></pre>
<h2>
<a name="seems-neat-how-hard-is-it-to-do-1" class="anchor" href="https://forum.rebol.info#seems-neat-how-hard-is-it-to-do-1"></a>Seems Neat.  How Hard Is It To Do?</h2>
<p>Well, let's just be simple-minded to start.</p>
<p><em>(and let's use the up-and-coming notation, just to start getting used to it...as well as my proposed change to <a href="https://forum.rebol.info/t/make-replace-all-default-semantics-of-replace/2269/">REPLACE to mean REPLACE/ALL by default</a>...)</em></p>
<pre><code>flow: func [
    block [block!]
    :placeholder [element?]
    &lt;local&gt; flow-result
][
    placeholder: default [_]
    block: copy block
    replace block placeholder $flow-result
    while [not tail? block] [
         insert block $flow-result:
         [block flow-result]: evaluate:next block
    ]
    return flow-result
]
</code></pre>
<h2>
<a name="and-on-this-example-it-works-2" class="anchor" href="https://forum.rebol.info#and-on-this-example-it-works-2"></a>And On This Example, It Works!</h2>
<p>Not with the new notation quite yet, but with the slash-as-refinement notation.  Some notes:</p>
<ul>
<li>
<p><strong>element?</strong> means any non-antiform</p>
</li>
<li>
<p><strong>$flow-result</strong> evaluates to the plain word of <strong>flow-result</strong>, but carrying a binding from the current context (in this case, so that the code in the user supplied block can see the local variable in FLOW's frame)</p>
</li>
</ul>
<h2>
<a name="but-how-does-it-work-3" class="anchor" href="https://forum.rebol.info#but-how-does-it-work-3"></a>But <em>How</em> Does It Work?</h2>
<p>It simply creates a variable FLOW-RESULT, and then splices it into a copy of the block:</p>
<pre><code>flow [
    [1 2 3]
    reverse _
    map-each x _ [x * 10]
]
=&gt;
[
   flow-result: [1 2 3]
   flow-result: reverse flow-result
   flow-result: map-each x flow-result [x * 10]
]
</code></pre>
<p>But it can't do it ahead of time, because it doesn't know the span of the expressions until it executes them.  So it goes one step at a time, inserting the SET-WORD! after each step</p>
<pre><code>[
   flow-result: [1 2 3]  ; &lt;-- gets to here
   reverse flow-result
   map-each x flow-result [x * 10]
]
...
[
   flow-result: [1 2 3]
   flow-result: reverse flow-result  ; &lt;-- gets to here
   map-each x flow-result [x * 10]
]
...
[
   flow-result: [1 2 3]
   flow-result: reverse flow-result
   flow-result: map-each x flow-result [x * 10]  ; finished
]
</code></pre>
<h2>
<a name="very-simple-but-useful-right-off-the-bat-4" class="anchor" href="https://forum.rebol.info#very-simple-but-useful-right-off-the-bat-4"></a>Very Simple, But Useful Right Off The Bat</h2>
<p>I don't know what all design the correct FLOW would need.  It would need to do its replacements deeply (we don't have REPLACE/DEEP, so you'd have to use PARSE or something).</p>
<p>And I don't know what features it should have.  But... pretty cool to see this kind of thing be so natural to do.</p>
<p><a href="https://www.youtube.com/watch?v=nlQBYZClWXs">Dimension 5 - Flow</a></p>

            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/quick-and-dirty-flow-example/2270">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/quick-and-dirty-flow-example/2270</link>
          <pubDate>Wed, 11 Sep 2024 13:47:55 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2270</guid>
          <source url="https://forum.rebol.info/t/quick-and-dirty-flow-example/2270.rss">Quick and Dirty FLOW Example</source>
        </item>
        <item>
          <title>Parallel FOR Example</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>One goal of Ren-C since the start has been to make sure people can write their own looping constructs that behave like the built-in loops.  (That's why <a href="https://forum.rebol.info/t/what-are-definitional-returns/2191">definitional return</a> was so important, which paved the way for many other improvements to come.)</p>
<p>One loop construct requested by <a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a> was the ability to walk through blocks in parallel.  It's in the tests, but I thought I'd share it here:</p>
<pre><code>for-parallel: function [
    return: [any-atom?]
    vars [block!]
    blk1 [~void~ any-list?]
    blk2 [~void~ any-list?]
    body [block!]
][
    return while [(not empty? maybe blk1) or (not empty? maybe blk2)] [
        (vars): pack [(first maybe blk1) (first maybe blk2)]

        repeat 1 body else [  ; if pure NULL it was a BREAK
            return null
        ]

        ; They either did a CONTINUE the REPEAT caught, or the body reached
        ; the end.  ELIDE the increment, so body evaluation is WHILE's result.
        ;
        elide blk1: next maybe blk1
        elide blk2: next maybe blk2
    ]
]
</code></pre>
<p>You get this behavior:</p>
<pre><code>&gt;&gt; collect [
       assert [
           20 = for-parallel [x y] [a b] [1 2] [
               keep :[x y]
               y * 10
           ]
       ]
   ]
== [[a 1] [b 2]]
</code></pre>
<p>There's a lot of nice little flourishes here.  BREAK and CONTINUE work, thanks to the <a href="https://forum.rebol.info/t/the-simple-yet-powerful-magic-of-the-loop-result-protocol/609">loop result protocol</a>.  Assigning the variables is handled elegantly by multi-return, where a SET-GROUP! retriggers as a SET-BLOCK!.  ELIDE is put to good use to avoid a temporary variable for the loop product.</p>
<p><em><strong>"Isn't it nice... when things just... work?"</strong></em></p>
<p><a href="https://www.youtube.com/watch?v=Z57kGB-mI54">Honda - The Cog</a></p>

            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/parallel-for-example/2261">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/parallel-for-example/2261</link>
          <pubDate>Mon, 09 Sep 2024 01:03:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2261</guid>
          <source url="https://forum.rebol.info/t/parallel-for-example/2261.rss">Parallel FOR Example</source>
        </item>
        <item>
          <title>VOID &amp; Definitional Error with SET and SET-GROUP!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I'm doing some refactoring to bring more consistency between the behavior of SET of a group and a SET-XXX!:</p>
<pre><code>set var expression

; vs.

(var): expression

; vs.

eval compose [(var): expression]
</code></pre>
<p>Ideally these should be interchangeable and have the same properties.</p>
<h2>
<a name="raised-error-propagation-1" class="anchor" href="https://forum.rebol.info#raised-error-propagation-1"></a>Raised Error Propagation</h2>
<p>One of those interesting properties is that definitional errors will skip the assignment and propagate one step, vs be promoted to abrupt failure at the moment you try to SET.  This allows you to write things like:</p>
<pre><code>&gt;&gt; item: &lt;whatever&gt;
&gt;&gt; block: []

&gt;&gt; error: trap [item: take block]
== make error! [
    type: 'Script
    id: 'nothing-to-take
    message: "Can't TAKE, no value available (consider TRY TAKE)"
    near: '[item: take block **]
    where: '[take entrap trap enrescue console]
    file: ~null~
    line: 1
]

&gt;&gt; item
== &lt;whatever&gt;
</code></pre>
<p>This has turned out to be quite useful, because without it you'd basically not be able to use TRAP with assignments.  The only way to deal with them would be EXCEPT:</p>
<pre><code>var: (...) except e -&gt; [...]
</code></pre>
<p>And that's not always what you want--it could be putting the exception logic in an awkward position, and it also often makes you parenthesize complex expressions on the left of the except.</p>
<h2>
<a name="another-cool-feature-opting-out-2" class="anchor" href="https://forum.rebol.info#another-cool-feature-opting-out-2"></a>Another Cool Feature... Opting Out</h2>
<p>I've actually had cases where this is useful!  Let's say you have a variable that's sometimes null, but something you want to set:</p>
<pre><code>var: case [
    condition1 [$word1]
    condition1 [$word2]
]  ; if none of the cases match, CASE returns null
</code></pre>
<p>Okay, now let's say you want to call SOME-FUNCTION with an expression, and if VAR is not null you want to assign the expression to var too.</p>
<p>Like this:</p>
<pre><code> if var [
     some-function (var): expression
 ] else [
     some-function expression
 ]
</code></pre>
<p>You could factor that out a bit:</p>
<pre><code> some-function if var [
     (var): expression
 ] else [
     expression
 ]
</code></pre>
<p>If your expression is complex you'd probably wind up needing to factor it out vs. repeating it:</p>
<pre><code> let e: expression
 some-function either var [(var): e] else [e]
</code></pre>
<p><strong>BUT SET-GROUP! of a VOID variable will just propagate the value out!</strong></p>
<pre><code>some-function (maybe var): expression
</code></pre>
<p>Cool, huh?  Anyway, I'm making sure these things work the same with SET the native.</p>
<pre><code>some-function set maybe var expression
</code></pre>
<h2>
<a name="you-cant-do-that-with-compose-though-3" class="anchor" href="https://forum.rebol.info#you-cant-do-that-with-compose-though-3"></a>You Can't Do That With COMPOSE, Though</h2>
<pre><code>eval compose [some-function (maybe var): expression]
</code></pre>
<p>It could perhaps be argued that would produce either of:</p>
<pre><code>some-function []: expression
some-function (): expression
</code></pre>
<p>Which we might envision working the same way.  But I think if you want that, you need to ask for it.</p>
<pre><code>eval compose [some-function (any [var []]): expression]
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/void-definitional-error-with-set-and-set-group/2258">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/void-definitional-error-with-set-and-set-group/2258</link>
          <pubDate>Sat, 07 Sep 2024 09:15:55 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2258</guid>
          <source url="https://forum.rebol.info/t/void-definitional-error-with-set-and-set-group/2258.rss">VOID &amp; Definitional Error with SET and SET-GROUP!</source>
        </item>
        <item>
          <title>Nice Blank Moment While Killing GET-PATH!/SET-PATH!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I'm busily killing off all the stray SET-PATH! and GET-PATH! that exist... <em>(because <a href="https://forum.rebol.info/t/introducingnew-chain-datatype/2226">CHAIN! is going to be underneath PATH!</a>, you won't be able to put a path in a chain such that you would describe the path as being set or gotten... the colon can't be "applied to" the path)</em>.</p>
<p>I came across the pleasing SIGIL! test:</p>
<pre><code>for-each [sigil items] [
    ~null~  [  word    tu.p.le    pa/th    [bl o ck]    (gr o up)  ]
    ::      [  word:   tu.p.le:   pa/th:   [bl o ck]:   (gr o up): ]
    :       [ :word   :tu.p.le   :pa/th   :[bl o ck]   :(gr o up)  ]
    ^       [ ^word   ^tu.p.le   ^pa/th   ^[bl o ck]   ^(gr o up)  ]
    &amp;       [ &amp;word   &amp;tu.p.le   &amp;pa/th   &amp;[bl o ck]   &amp;(gr o up)  ]
    @       [ @word   @tu.p.le   @pa/th   @[bl o ck]   @(gr o up)  ]
    $       [ $word   $tu.p.le   $pa/th   $[bl o ck]   $(gr o up)  ]
    '       [ 'word   'tu.p.le   'pa/th   '[bl o ck]   '(gr o up)  ]
    ~~      [ ~word~  ~tu.p.le~  ~pa/th~  ~[bl o ck]~  ~(gr o up)~ ]
][
    for-each item items [
        assert [any [quoted? item, quasi? item, bindable? item]]
        if (degrade sigil) &lt;&gt; sigil of item [
            fail [mold item]
        ]
    ]
]
</code></pre>
<p><strong><code>:</code></strong> and <strong><code>::</code></strong> are not going to be SIGIL! at all soon.  But as a first step, I need to get rid of SET-PATH! and GET-PATH!</p>
<h2>
<a name="behold-just-a-little-nice-rebolish-moment-1" class="anchor" href="https://forum.rebol.info#behold-just-a-little-nice-rebolish-moment-1"></a>Behold Just A Little Nice Rebolish Moment</h2>
<p>I realized I needed to kill QUASI-TUPLE! and QUASI-PATH! also...</p>
<pre><code>for-each [sigil items] [
    ~null~  [  word    tu.p.le    pa/th    [bl o ck]    (gr o up)  ]
    ::      [  word:   tu.p.le:     _      [bl o ck]:   (gr o up): ]
    :       [ :word   :tu.p.le      _     :[bl o ck]   :(gr o up)  ]
    ^       [ ^word   ^tu.p.le   ^pa/th   ^[bl o ck]   ^(gr o up)  ]
    &amp;       [ &amp;word   &amp;tu.p.le   &amp;pa/th   &amp;[bl o ck]   &amp;(gr o up)  ]
    @       [ @word   @tu.p.le   @pa/th   @[bl o ck]   @(gr o up)  ]
    $       [ $word   $tu.p.le   $pa/th   $[bl o ck]   $(gr o up)  ]
    '       [ 'word   'tu.p.le   'pa/th   '[bl o ck]   '(gr o up)  ]
    ~~      [ ~word~      _         _     ~[bl o ck]~  ~(gr o up)~ ]
][
    for-each item items [
        if blank? item [continue]
        assert [any [quoted? item, quasi? item, bindable? item]]
        if (degrade sigil) &lt;&gt; sigil of item [
            fail [mold item]
        ]
    ]
]
</code></pre>
<p>When you have the parts, you just use them...</p>
<p>Of course I could have used other things.</p>
<hr>
<pre><code>    ::      [  word:   tu.p.le:     ~    [bl o ck]:   (gr o up): ]
</code></pre>
<hr>
<pre><code>    ::      [  word:   tu.p.le:     #    [bl o ck]:   (gr o up): ]
</code></pre>
<hr>
<pre><code>    ::      [  word:   tu.p.le:    !!!   [bl o ck]:   (gr o up): ]
</code></pre>
<hr>
<pre><code>    ::      [  word:   tu.p.le:  &lt;dead&gt;  [bl o ck]:   (gr o up): ]
</code></pre>
<hr>
<pre><code>    ::      [  word:   tu.p.le:  ~null~  [bl o ck]:   (gr o up): ]
</code></pre>
<hr>
<pre><code>    ::      [  word:   tu.p.le:   #dead  [bl o ck]:   (gr o up): ]
</code></pre>
<hr>
<p>It would be nice to have <strong><code>~dead~</code></strong>, but I have spoken about reserving WORD! quasi/antiforms.</p>
<p>(Maybe that could be relaxed, to where quasiforms are allowed for all WORD! but antiforms only for those endorsed by the system?  It might make sense.  You can dialect with <code>~null~</code> the quasiform all you like without having that mean anything to do with the behavior of null, so you could do that with any other quasiform word of the future... might as well let you make them, right?  But QUASI-TUPLE! and QUASI-PATH! don't get that allowance, so <strong><code>~/foo</code></strong> can be a PATH!)</p>
<p>In a lot of cases, trash (<strong><code>~</code></strong>) would be the right choice for a "this is invalid slot".</p>
<p>But here, we've got quasiforms in the mix as part of the discussion.  It favors picking blank as out of band.  And it gets out of the way a little more.</p>
<h2>
<a name="note-that-path-and-path-will-become-loadable-again-2" class="anchor" href="https://forum.rebol.info#note-that-path-and-path-will-become-loadable-again-2"></a>Note That <code>:pa/th</code> and <code>pa/th:</code> Will Become LOADable Again...</h2>
<p>You just won't ask about colons applied on the head or tail of the paths, because you'll have to "dig" to find the chains underneath.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/nice-blank-moment-while-killing-get-path-set-path/2241">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/nice-blank-moment-while-killing-get-path-set-path/2241</link>
          <pubDate>Sat, 31 Aug 2024 20:27:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2241</guid>
          <source url="https://forum.rebol.info/t/nice-blank-moment-while-killing-get-path-set-path/2241.rss">Nice Blank Moment While Killing GET-PATH!/SET-PATH!</source>
        </item>
        <item>
          <title>Feb 2024 Talk, Functional Programming Sydney</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2136">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/fundamental-distinguishing-features-of-rebol/2136/1">Fundamental distinguishing features of Rebol</a></div>
<blockquote>
<p>I offered to give a talk at my local Functional Programming meetup next month. Given my recent interests, I’m thinking of giving an intro to Rebol and its basic concepts.</p>
</blockquote>
</aside>
<p>As a follow-up to this, the talk slides are now online: <a href="https://github.com/fp-syd/meetings/blob/master/2024/2024-02-Neimann-Computing-with-eval.pdf" class="inline-onebox">meetings/2024/2024-02-Neimann-Computing-with-eval.pdf at master · fp-syd/meetings · GitHub</a></p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/feb-2024-talk-functional-programming-sydney/2175">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/feb-2024-talk-functional-programming-sydney/2175</link>
          <pubDate>Fri, 22 Mar 2024 00:19:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2175</guid>
          <source url="https://forum.rebol.info/t/feb-2024-talk-functional-programming-sydney/2175.rss">Feb 2024 Talk, Functional Programming Sydney</source>
        </item>
        <item>
          <title>Reacting to Definitional Errors: CURTAIL</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>Here's a simple <a href="https://forum.rebol.info/t/introducing-reframer-close-cousin-to-enclose/1395">REFRAMER</a> called CURTAIL:</p>
<pre><code>curtail: reframer function [frame [frame!]] [
    return do frame except e -&gt; [
        if e.id == 'need-non-null [return void]
        raise e
    ]
]
</code></pre>
<p>If you don't remember what reframers do, they just have access to a function call before you run it.  Here we are looking for the function we're running to give us a NEED-NON-NULL error.</p>
<p><em>But we're not looking for just any NEED-NON-NULL error that might go by.</em>  We're only interested in ones that are coming out of the call we're processing.  If that happens, we just vaporize the expression.</p>
<pre><code>&gt;&gt; compose [(null)]
** Script Error: non-NULL value required (see MAYBE, TRY, REIFY)

&gt;&gt; curtail compose [(null)]  ; will give back void
</code></pre>
<p>You can see something like this simplifying null checks:</p>
<pre><code>&gt;&gt; ver: 1.2.3
&gt;&gt; date: null

&gt;&gt; print [curtail spaced ["Version:" ver] curtail spaced ["Date:" date]]
Version: 1.2.3
</code></pre>
<p><em>But like I said, it's not just any NEED-NON-NULL...</em></p>
<pre><code>&gt;&gt; a: 1 b: null c: 3
&gt;&gt; get-ver: func [] [to tuple! reduce [a b c]]

&gt;&gt; print [curtail spaced ["Version:" get-ver] curtail spaced ["Date:" date]]
** Script Error: non-NULL value required (see MAYBE, TRY, REIFY)
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/reacting-to-definitional-errors-curtail/2118">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/reacting-to-definitional-errors-curtail/2118</link>
          <pubDate>Mon, 15 Jan 2024 01:13:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2118</guid>
          <source url="https://forum.rebol.info/t/reacting-to-definitional-errors-curtail/2118.rss">Reacting to Definitional Errors: CURTAIL</source>
        </item>
        <item>
          <title>Variant Of &quot;COLLECT&quot; Without &quot;KEEP&quot;</title>
          <dc:creator><![CDATA[no-e-in]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I recently discovered a version of COLLECT by Brett Handley (for R2) that is less general <em>[<a href="https://forum.rebol.info/t/implementing-collect-keep/2099">than what COLLECT has been come to be known as</a>]</em> but avoids nested code.</p>
<pre><code>collect: func [
    {Collects block evaluations, use as body in For, Repeat, etc.}
    block [block!] "Block to evaluate."
    /initial result [series! datatype!] "Initialise the result."
    /only "Inserts into result using Only refinement."
] [
    if not initial [result: block!]
    result: any [all [datatype? result make result 1000] result]
    reduce ['head pick [insert insert/only] not only 'tail result to paren! block]
]
</code></pre>
<p>Examples (running in Rebol2 interpreter):</p>
<pre><code>&gt;&gt; for i 1 10 2 collect [i * 10]
== [10 30 50 70 90]
    
&gt;&gt; foreach [a b] [1 2 3 4] collect [a + b]
== [3 7]

&gt;&gt; foreach w [a b c d] collect [w]
== [a b c d]

&gt;&gt; repeat e [a b c %.txt] collect/initial [e] %file
== %fileabc.txt

&gt;&gt; iota: func [n [integer!]][repeat i n collect/initial [i] make block! n]
&gt;&gt; iota 10
== [1 2 3 4 5 6 7 8 9 10]
</code></pre>
            <p><small>6 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/variant-of-collect-without-keep/2110">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/variant-of-collect-without-keep/2110</link>
          <pubDate>Thu, 11 Jan 2024 10:05:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2110</guid>
          <source url="https://forum.rebol.info/t/variant-of-collect-without-keep/2110.rss">Variant Of &quot;COLLECT&quot; Without &quot;KEEP&quot;</source>
        </item>
        <item>
          <title>Implementing COLLECT + KEEP</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>COLLECT allows you to build up a block, without needing to name the block or pass it as a parameter to individual APPEND instructions.  Instead you use KEEP, which appends to the implicit nameless block:</p>
<pre><code>&gt;&gt; collect [
       keep 'foo:
       print "Arbitrary code possible"
       keep/line [1 2 3]
       keep spread [Spread #works @(T O O)]
       repeat 2 [keep &lt;whatever&gt;]
    ]
Arbitrary code possible
== [
    foo: [1 2 3]
    Spread #works @(T O O) &lt;whatever&gt; &lt;whatever&gt;]
</code></pre>
<h2>
<a name="leverages-lambda-to-bind-keep-to-code-1" class="anchor" href="https://forum.rebol.info#leverages-lambda-to-bind-keep-to-code-1"></a>Leverages LAMBDA To Bind KEEP To Code</h2>
<p>The trick is that the body is turned into a function that takes KEEP as a parameter.  This defines the word KEEP for the body.</p>
<p>To see how this works, imagine this:</p>
<pre><code>collector: lambda [keep [action?]] [
    keep 'foo:
    print "Arbitrary code possible"
    keep/line [1 2 3]
    keep spread [Spread #works @(T O O)]
    repeat 2 [keep &lt;whatever&gt;]
 ]

 block: copy []
 keeper: specialize :append [series: block]

 collector :keeper
</code></pre>
<p>This code gets the desired result in BLOCK.</p>
<h2>
<a name="slight-twist-make-keep-return-its-input-2" class="anchor" href="https://forum.rebol.info#slight-twist-make-keep-return-its-input-2"></a>Slight Twist: Make KEEP Return Its Input</h2>
<p>APPEND will return the block that you append to.  This would reveal the partially-built temporary block before the collect is complete.  A better and more useful result of KEEP would be to return the value that you pass it.</p>
<p>To accomplish that, we can ENCLOSE the specialization:</p>
<pre><code>keeper: enclose (specialize :append [series: block]) func [f [frame!]] [
    let value: f.value
    do f
    return value
]
</code></pre>
<p>We have to capture the value to append before we DO the captured FRAME!, because Rebol functions are permitted to make arbitrary modifications to their arguments during execution.  <em>(To help avoid mistakes, you are not allowed to read a frame's values after a DO is complete.)</em>  It's possible to DO COPY F but that makes a copy of the entire frame, and here we just copy the value we want.</p>
<p>A more efficient way to do this is to use a LAMBDA for the wrapper function, and ELIDE the DO.  There's no need to type check F (since ENCLOSE only passes the FRAME! built for APPEND, never anything else):</p>
<pre><code>keeper: enclose (specialize :append [series: block]) lambda [f] [
    f.value
    elide do f  ; evaluates to anti-isotope of 0 length block, vanishes
]
</code></pre>
<h2>
<a name="putting-it-together-3" class="anchor" href="https://forum.rebol.info#putting-it-together-3"></a>Putting It Together</h2>
<p>Wrapping this up for a working COLLECT implementation:</p>
<pre><code>collect: func [
    return: [block!]
    body [block!]
][
    let block: copy []
    let keeper: enclose (specialize :append [series: block]) lambda [f] [
        f.value
        elide do f
    ]
    run (lambda [keep] body) :keeper
    return block
]
</code></pre>
<p>It's a good demonstration of how you can make something impressive that feels like a first-class language feature out of Rebol, with little effort.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/implementing-collect-keep/2099">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/implementing-collect-keep/2099</link>
          <pubDate>Wed, 10 Jan 2024 17:20:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2099</guid>
          <source url="https://forum.rebol.info/t/implementing-collect-keep/2099.rss">Implementing COLLECT + KEEP</source>
        </item>
        <item>
          <title>Skinning REPLACE with Red&#39;s String PARSE Hack</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>Red made an unusual choice with their implementation of REPLACE when you use a pattern that's a block with a string.  Instead of trying to stringify the block, <a href="https://github.com/red/red/blob/40096dd12ca9c3b9b47e9eaa995d425b9faf620b/tests/source/units/replace-test.red#L72">they assume it's a PARSE rule</a>:</p>
<pre><code>red&gt;&gt; replace/case/all "aAbbabAAAa" ["Ab" | "Aa"] "-"
== "a-babAA-"
</code></pre>
<p>It seems like a bad idea to make the choice to do this based on the input type.  What if you actually want to do this when the input is a BLOCK!?  I'd prefer something like <strong>parse-replace</strong> <em>(or if we ever allow the same word to be a function and a module, maybe <strong>parse.replace</strong>)</em>.</p>
<p>But honestly, I think that the answer is just to keep pushing on UPARSE itself to be slick enough that you wouldn't feel the need to reach for a shorthand like this.  It's pretty easy to write as is:</p>
<pre><code>&gt;&gt; parse/case "aAbbabAAAa" [
       opt some thru [change ["Ab" | "Aa"] ("-")]
       accept &lt;input&gt;
   ]
== "a-babAA-"
</code></pre>
<p>That's probably reaching the limits of how short UPARSE can do an equivalent.  Yet it's more powerful if you want to deviate or customize it, so I would reach for this more often than a limited REPLACE.</p>
<h2>
<a name="still-ren-c-does-backflips-and-lets-you-have-it-your-way-1" class="anchor" href="https://forum.rebol.info#still-ren-c-does-backflips-and-lets-you-have-it-your-way-1"></a>Still, Ren-C Does Backflips And Lets You Have It Your Way</h2>
<p>So you should be able to adapt REPLACE to have Red's behavior if you want it.</p>
<p>Super easy.  Barely an inconvenience!</p>
<pre><code>replace: enclose :lib.replace func [
     f [frame!]
     &lt;local&gt; head tail rule
][
    if not all [
        match [text! binary!] f.target
        block? f.pattern
    ][
        return eval f  ; use normal REPLACE semantics
    ]

    rule: if action? :f.replacement '[  ; function generates replacement
        head: &lt;here&gt;
        change [f.pattern, tail: &lt;here&gt;] (
            apply/relax :f.replacement [const head, const tail]
        )
    ] else '[  ; replacement can be used as-is
        change f.pattern (f.replacement)
    ]

    apply :parse [/case f.case, f.target [
        while [thru rule] (
            if not f.all [return f.target]
        )
        to &lt;end&gt;
    ]]
    return f.target
]
</code></pre>
<h2>
<a name="it-worked-the-first-time-i-ran-it-2" class="anchor" href="https://forum.rebol.info#it-worked-the-first-time-i-ran-it-2"></a>It worked the first time I ran it!</h2>
<p>There's so much interesting stuff going on here that it's hard to list it all. I can quickly hit some high points.</p>
<ul>
<li>
<p>You don't have to repeat the interface of REPLACE.  This is an ENCLOSE, so it just passes the frame built for LIB.REPLACE to the wrapper and lets it choose whether to run that frame as-is (or modified), or do its entirely own thing.</p>
</li>
<li>
<p>It uses the <a href="https://forum.rebol.info/t/the-cool-new-repurposing-of-while-in-parse/1875">kickass new arity-2 WHILE combinator</a> to great effect...simply iterating over the replacement rule.</p>
</li>
<li>
<p><a href="https://forum.rebol.info/t/apply-ii-the-revenge/1834">Modern kickass APPLY</a> for PARSE lets you put arguments in any order, and does refinements by name... here we put /CASE first because it's clearer... then passing the series and the rule.</p>
</li>
<li>
<p>It doesn't just run antiform actions if they are passed, but it also optionally passes them the head and tail of where in the input is matched.  If the function is arity-1, it just receives the head.  If it's arity-0, it doesn't receive either.  (This is due to APPLY's /RELAX that tolerates too many arguments.)</p>
</li>
</ul>
<p>I wrote a little demo of the fancier function invocation:</p>
<pre><code>&gt;&gt; data: "(real)1020(powerful)0304(magic)"

&gt;&gt; collect [
       replace/all data [between "(" ")"] func [head tail] [
            let item: copy/part head tail
            keep item
            if item = "(powerful)" [item: copy "(ren-c)"]
            return uppercase item
        ]
    ]
== ["(real)" "(powerful)" "(magic)"]

&gt;&gt; data
== "(REAL)1020(REN-C)0304(MAGIC)"
</code></pre>
<p>Not only that, but the references to the head and tail of the match are CONST...which prevents the replacement function from messing up the in-progress iteration of the series where the replace is happening.  It only achieves modification by means of what result it synthesizes.</p>
<p>How about that?</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/skinning-replace-with-reds-string-parse-hack/2043">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/skinning-replace-with-reds-string-parse-hack/2043</link>
          <pubDate>Thu, 27 Jul 2023 06:23:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2043</guid>
          <source url="https://forum.rebol.info/t/skinning-replace-with-reds-string-parse-hack/2043.rss">Skinning REPLACE with Red&#39;s String PARSE Hack</source>
        </item>
        <item>
          <title>Working With Truthy BLANK! (in SPLIT-PATH Tests)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>The current re-imagining of the concept of truthy/falsey involves the idea that <em>anything you can put into a block is truthy</em>.  That includes BLANK!.</p>
<p>~null~ isotopes are falsey, and will REIFY to be <strong><code>~null~</code></strong> which can be somewhat clumsy-looking.</p>
<p>But consider some test cases for seeing how SPLIT-PATH works, looking a bit like this:</p>
<pre><code>split-path-tests:  [
    %foo                            [_ %foo]
    %/c/test/test2                  [%/c/test/ %test2]
    %/c/test                        [%/c/ %test]
    %//test                         [%// %test]
    %/test                          [%/ %test]
    %//                             [%// _]
    %./                             [%./ _]
    &lt;...etc...&gt;
]
</code></pre>
<p>SPLIT-PATH is a multi-return routine, which gives back two values: the path and the filename.  But if one or the other is missing then that component will be null, which is useful for testing with IF (or using DEFAULT with).</p>
<p>But if we just blindly changed the tests to reify, it would become less legible:</p>
<pre><code>split-path-tests:  [
    %foo                            [~null~ %foo]
    %/c/test/test2                  [%/c/test/ %test2]
    %/c/test                        [%/c/ %test]
    %//test                         [%// %test]
    %/test                          [%/ %test]
    %//                             [%// ~null~]
    %./                             [%./ ~null~]
    &lt;...etc...&gt;
]
</code></pre>
<p>However...with blanks being truthy, this means you that you can take a variable which may be null and turn it into a blank, like this:</p>
<pre><code>reduce [any [path _] any [file _]]
</code></pre>
<p>That's rather succinct!  Probably so succinct that it doesn't need its own native to express.</p>
<p>(I thought it was neat.)</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/working-with-truthy-blank-in-split-path-tests/2007">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/working-with-truthy-blank-in-split-path-tests/2007</link>
          <pubDate>Sat, 14 Jan 2023 15:21:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2007</guid>
          <source url="https://forum.rebol.info/t/working-with-truthy-blank-in-split-path-tests/2007.rss">Working With Truthy BLANK! (in SPLIT-PATH Tests)</source>
        </item>
        <item>
          <title>Minor (but nice!) %prot-http.r parsing improvements</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>Here's is R3-Alpha's <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/mezz/prot-http.r">PARSE-WRITE-DIALECT</a> from %prot-http.r</p>
<pre><code>parse-write-dialect: func [port block /local spec] [
    spec: port/spec
    parse block [
        [set block word! (spec/method: block) | (spec/method: 'post)]
        opt [set block [file! | url!] (spec/path: block)]
        [set block block! (spec/headers: block) | (spec/headers: [])]
        [set block [any-string! | binary!] (spec/content: block) | (spec/content: none)]
    ]
]
</code></pre>
<p>You couldn't set paths in R3-Alpha parse, which is weird.  So things had to be captured into a temporary variable (it reused the input block for some reason).</p>
<p>Let's imagine that setting paths were legal:</p>
<pre><code>parse-write-dialect: func [port block /local spec] [
    spec: port/spec
    parse block [
        [set spec/method word! | (spec/method: 'post)]
        opt [set spec/path [file! | url!]]
        [set spec/headers block! | (spec/headers: [])]
        [set spec/content [any-string! | binary!] | (spec/content: none)]
    ]
]
</code></pre>
<p>Let's do a quick transformation of this to PARSE3 in Ren-C, where the keyword TRY now replaces OPT:</p>
<pre><code>parse-write-dialect: func [port block &lt;local&gt; spec] [
    spec: port.spec
    parse3 block [  ; PARSE3 is R3-Alpha-compatible parse
        [set spec.method word! | (spec.method: 'post)]
        try [set spec.path [file! | url!]]
        [set spec.headers block! | (spec.headers: [])]
        [set spec.content [any-string! | binary!] | (spec.content: null)]
    ]
]
</code></pre>
<ul>
<li>
<p>The TUPLE!s help us see we're not making function calls, which is nice</p>
</li>
<li>
<p>/LOCAL is a legitimate normal refinement, and <code>&lt;local&gt;</code> variables are truly local--you can't slip them in from the caller.  Because they are invisible, you can build function compositions that don't have to worry about colliding with their names.</p>
<ul>
<li>It also frees up /LOCAL to just be a typical refinement, like TIME/LOCAL</li>
</ul>
</li>
</ul>
<p>Now let's throw in some UPARSE, with the SET-WORD!s for assignment...</p>
<pre><code>parse-write-dialect: func [port block &lt;local&gt; spec] [
    spec: port.spec
    parse block [  ; PARSE is now UPARSE
        [spec.method: word! | (spec.method: 'post)]
        try [spec.path: [file! | url!]]
        [spec.headers: block! | (spec.headers: [])]
        [spec.content: [any-string! | binary!] | (spec.content: null)]
    ]
]
</code></pre>
<p>It looks a little tighter...but then we also have the ability to factor the assignments out.  And as it happens, that last line could just be <strong>try [any-string! | binary!]</strong>, because TRY would assign the result to NULL if it can't match:</p>
<pre><code>parse-write-dialect: func [port block &lt;local&gt; spec] [
    spec: port.spec
    parse block [
        spec.method: [word! | ('post)]
        spec.path: try [file! | url!]
        spec.headers: [block! | ([])]
        spec.content: try [any-string! | binary!]
    ]
]
</code></pre>
<p>Improved!</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/minor-but-nice-prot-http-r-parsing-improvements/1945">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/minor-but-nice-prot-http-r-parsing-improvements/1945</link>
          <pubDate>Sat, 27 Aug 2022 17:38:07 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1945</guid>
          <source url="https://forum.rebol.info/t/minor-but-nice-prot-http-r-parsing-improvements/1945.rss">Minor (but nice!) %prot-http.r parsing improvements</source>
        </item>
        <item>
          <title>Weird Little Function: STEAL a Variable&#39;s Prior Value</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I don't know if it has the best name (suggestions?), but it's kind of interesting...</p>
<pre><code>&gt;&gt; x: 304
== 304

&gt;&gt; steal x: 1000 + 20
== 304

&gt;&gt; x
== 1020
</code></pre>
<p>I wrote it as a variadic function for some reason (as a test, maybe?) but you could write it in Redbol.  You could even use their lame ALSO.</p>
<pre><code>steal: func [
    {Red version}
    'var [set-word! set-path!]
    value [any-type!]
][
    also get var set var value
]
</code></pre>
<p>The Ren-C version of that reads a lot better:</p>
<pre><code>steal: lambda [
    {Ren-C version}
    'var [set-word! set-path!]
    value [any-value!]
][
    get var
    elide set var value
]
</code></pre>
<p>It naturally has the benefit of letting you break things across lines.  I feel like it's better to point out "this is the thing being erased".  And of course the mechanic is far more general.</p>
<p>I definitely like ANY-VALUE! better than ANY-TYPE!.</p>
<p>Anyway, I'm sure I've seen places I could have used it if I thought of it.  I'll keep my eyes open.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/weird-little-function-steal-a-variables-prior-value/1943">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/weird-little-function-steal-a-variables-prior-value/1943</link>
          <pubDate>Thu, 25 Aug 2022 16:27:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1943</guid>
          <source url="https://forum.rebol.info/t/weird-little-function-steal-a-variables-prior-value/1943.rss">Weird Little Function: STEAL a Variable&#39;s Prior Value</source>
        </item>
        <item>
          <title>Enter the Dungeon 💀 ...if You Dare!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <h2><a name="p-6011-the-imaginary-3-d-dungeon-simulator-of-the-year-1983-1" class="anchor" href="https://forum.rebol.info#p-6011-the-imaginary-3-d-dungeon-simulator-of-the-year-1983-1"></a>The Imaginary 3-D Dungeon Simulator of the Year, 1983...</h2>
<p>NOW ON THE WEB!!</p>
<p><strong><a href="http://hostilefork.com/media/shared/replpad-js/?do=dungeon">http://hostilefork.com/media/shared/replpad-js/?do=dungeon</a></strong></p>
<p>Source code:</p>
<p><a href="https://github.com/hostilefork/teenage-coding/blob/master/DUNGEON/dungeon.reb">https://github.com/hostilefork/teenage-coding/blob/master/DUNGEON/dungeon.reb</a></p>
<h2><a name="p-6011-backstory-2" class="anchor" href="https://forum.rebol.info#p-6011-backstory-2"></a>Backstory</h2>
<p>When I was a kid (circa 1983, I'd be about 8 or 9), I played the Intellivision game <a href="http://en.wikipedia.org/wiki/Advanced_Dungeons_&amp;_Dragons:_Treasure_of_Tarmin">Advanced Dungeons and Dragons: Treasure of Tarmin</a>. The 3-D graphics put you in a first-person-perspective point of view with shocking realism:</p>
<p><img src="https://i.stack.imgur.com/X4aGT.png" alt="Shockingly Realistic 3-D Graphics" width="320" height="200"></p>
<p>But a year or two later, I got a C-64. And I was able to draw on the 40x25 character grid by cursoring around the screen, setting the color with the Ctrl key and a digit, and putting symbols anywhere I wanted <em>(why doesn't <code>bash</code> let me do that?)</em>. The character set had triangular components and solid block components.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4.jpeg" data-download-href="https://forum.rebol.info/uploads/default/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4" title="image"><img src="https://forum.rebol.info/uploads/default/optimized/1X/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4_2_252x250.jpeg" alt="image" data-base62-sha1="1Rsurb7Q0aQ1IugNlN0VbFjgToE" width="252" height="250" srcset="https://forum.rebol.info/uploads/default/optimized/1X/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4_2_252x250.jpeg, https://forum.rebol.info/uploads/default/optimized/1X/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4_2_378x375.jpeg 1.5x, https://forum.rebol.info/uploads/default/optimized/1X/0d0d338da02ccf2e47f3427a3ffc08fddfbfb7a4_2_504x500.jpeg 2x" data-dominant-color="6364AA"></a></div><p></p>
<p>So I was able to reason through how one might generate a rendering of one's perspective in a grid through that medium.</p>
<p>In 2013, I found the nearly-three-decades-old spec, in spiral-bound notebook paper, about "Dungeon Construction Set":</p>
<p><img src="https://i.stack.imgur.com/WHYpo.jpg" alt="enter image description here" width="320" height="320"></p>
<p><em>(Careful readers will notice that while it's almost right, this doesn't quite hold together on the slanted parts...)</em></p>
<p>Though Treasure of Tarmin was played on a grid, the walls existed only on the <em>edges</em> of grid squares. Having learned what bytes were, I realized that if I made the map out of bytes...then each square on the map could have four possible states for each of its edges:</p>
<ol>
<li>Unobstructed</li>
<li>Wall</li>
<li>Door</li>
<li>Something Else?</li>
</ol>
<p>The design allows for the opportunity that adjacent cells would "disagree"...e.g. have a wall on one side and a door on the other.  I considered this a feature; these situations would give rise to one-way doors and walls that didn't appear until you passed through them and then turned around.</p>
<p>My idea was that a position on the map and a direction you were facing could "light up" regions on the screen...a bit like lighting up segments of a digit on an LCD.</p>
<p>But an implementation of the ideas eluded me.  It was a trickier program than I had written at the time, made even trickier because I was trying to implement it in a "machine language monitor".  I had no assembler, and the book I read didn't discuss them...just the instruction set and workings of the 6502 chip.</p>
<p>(The machine-language-monitor programs could encode single instructions into specific memory locations.  But unlike an assembler, it had no labels or other abstractions...all addresses had to be kept track of on paper.)</p>
<p>By the time I knew enough about programming that I could do something like this in an evening, I no longer cared much about the idea.  But better late than never, right?</p>
<p>Although Unicode/ASCII don't have good "seamless drawing" characters to do this like the C-64 could, it can still get the idea across.</p>
<h2><a name="p-6011-originally-wrote-this-in-red-2013httpsgithubcomredredpull612-3" class="anchor" href="https://forum.rebol.info#p-6011-originally-wrote-this-in-red-2013httpsgithubcomredredpull612-3"></a><a href="https://github.com/red/red/pull/612">Originally Wrote this in Red (2013)</a></h2>
<p>I decided I'd use this relatively simple task as something where I would use Red the whole time--as opposed to writing it in Rebol2 or R3-Alpha and then porting the differences.  So that let me get a sense of where the pain points were regarding things like syntax error reporting, that sort of stuff.</p>
<p>Anyway, about a decade later, it's now a Ren-C sample.  Minor modifications were made, including taking advantage of the ReplPad's CLEAR-SCREEN ability (if running on the web).</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/enter-the-dungeon-if-you-dare/1865">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/enter-the-dungeon-if-you-dare/1865</link>
          <pubDate>Wed, 06 Jul 2022 04:59:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1865</guid>
          <source url="https://forum.rebol.info/t/enter-the-dungeon-if-you-dare/1865.rss">Enter the Dungeon 💀 ...if You Dare!</source>
        </item>
        <item>
          <title>The CIRCLED Dialect: Example of the Form</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I was looking at this from the emscripten config file:</p>
<pre><code> ; Right now, either #web or #node (someday #wasm-edge ?)
 ;
 javascript-environment: #web
</code></pre>
<p>And I thought to myself: well that's kind of ugly.  The comment is having to list things that would be more obviously shown by just demonstrating the options:</p>
<pre><code>javascript-environment: circled [(#web) #node]
</code></pre>
<p>It could default to NULL if you circled nothing, but you could use MUST to suggest people needed to select something:</p>
<pre><code>&gt;&gt; number: must circled [#one #two #three]
** Error: MUST requires argument not to be NULL
</code></pre>
<h2>
<a name="its-almost-too-easy-1" class="anchor" href="https://forum.rebol.info#its-almost-too-easy-1"></a>It's Almost <em>Too</em> Easy</h2>
<p>When it's this easy, who wouldn't whip such things up?</p>
<pre><code>circled: lambda [block [block!] &lt;local&gt; result] [
    parse block [
        result: try thru subparse group! [
            &lt;any&gt; &lt;end&gt; | (fail "Circled Items Must Be Singular")
        ]
        try [thru group! (fail "Only One Circle")]
        accept (result)
    ]
]

&gt;&gt; circled [a (b) c]
== b

&gt;&gt; circled [a b c]
; null

&gt;&gt; circled [a (b c)]
** Error: Circled Items Must Be Singular

&gt;&gt; circled [(a) b (c)]
** Error: Only One Circle
</code></pre>
<p>Remarkable plasticity, and I want to see these weapons come to the code golfing field <a href="https://www.youtube.com/watch?v=iDKaz1iB9wQ">once they are adequately Rebmooshed</a>.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<hr>
<p>This example tipped the balance to where I decided that matching <strong><code>&lt;end&gt;</code></strong> should be invisible.  Because I wanted a way to synthesize the result while doing the end match.  Writing <strong><code>elide &lt;end&gt;</code></strong> is possible, but there's essentially no cases in practice where you don't want to elide the end.</p>
<pre><code> &gt;&gt; parse [1 2] ['1 &lt;end&gt; | (fail "Not a 1 followed by the end")]
 ** Error: Not a 1 followed by the end

 &gt;&gt; parse [1] ['1 &lt;end&gt; | (fail "Not a 1 followed by the end")]
 == 1
</code></pre>
<p>The previous result was evaluating the <code>&lt;end&gt;</code> to the input position at that moment of being at the end--so effectively a series at its tail:</p>
<pre><code> &gt;&gt; parse [1] ['1 &lt;end&gt;]
 == []  ; old behavior...how often would you want this?
</code></pre>
<p>If that's what you actually want (which no one ever did) you can can say <strong><code>&lt;end&gt; &lt;here&gt;</code></strong>.</p>
<pre><code> &gt;&gt; parse [1] ['1 &lt;end&gt; &lt;here&gt;]
 == []
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-circled-dialect-example-of-the-form/1849">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-circled-dialect-example-of-the-form/1849</link>
          <pubDate>Sun, 26 Jun 2022 12:06:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1849</guid>
          <source url="https://forum.rebol.info/t/the-circled-dialect-example-of-the-form/1849.rss">The CIRCLED Dialect: Example of the Form</source>
        </item>
        <item>
          <title>Parsing a README.md File To Fill A Folder</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I've integrated <a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a>'s <a href="https://forum.rebol.info/t/js-testing-with-cypress-io/1778/3">Cypress Tests</a> to the GitHub workflow.</p>
<p>There's a certain number of things we want to have work before we "greenlight" a new libr3.wasm file.  Things like Graham's prescription writing app or chess demo are examples of this.</p>
<p>But we don't want the test scripts for those things to live in the Ren-C repository.  Because they need to change as the apps change--and they should also be running whenever those apps get a new commit pushed.</p>
<p>At first I just did a <strong>wget</strong> of the scripts:</p>
<pre><code>cd tests/cypress/e2e
wget https://gitlab.com/Zhaoshirong/rebol-chess/-/raw/master/cypress/e2e/chess.cy.js
wget https://raw.githubusercontent.com/gchiu/midcentral/main/cypress/e2e/rx-app.cy.js
</code></pre>
<p>But this encountered an error, because when git has a directory with no files in it...it doesn't exist.  So there was no e2e directory.</p>
<p>I could have just said <strong>mkdir tests/cypress/e2e</strong> as part of the workflow.  But I figured making a README.md file and putting it in the directory to explain what it was would be easier.</p>
<p>This gave me an idea: <em>What if I put the URLs in the README.md, and then parsed them out and fetched them?</em>  So that's what I did instead!</p>
<p><strong><a href="https://raw.githubusercontent.com/metaeducation/ren-c/master/tests/cypress/e2e/README.md">Here's the README.md</a></strong>, which has <strong><code>* https://whatever</code></strong> lines in it.</p>
<p>Then here's the script that uses the Ren-C GitHub Action:</p>
<pre><code>- name: Collect Cypress Tests from Repositories We Want to Keep Working
  uses: metaeducation/ren-c-action@release
  with:
    script: |
      cd %tests/cypress/e2e/
      list: uparse (as text! read %README.md) [
          collect some [
              '* space [keep url!] newline
            | thru newline
          ]
      ]
      for-each url list [
          filename: second split-path url
          write filename (read url)
      ]</code></pre>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/parsing-a-readme-md-file-to-fill-a-folder/1840">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/parsing-a-readme-md-file-to-fill-a-folder/1840</link>
          <pubDate>Tue, 14 Jun 2022 11:41:40 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1840</guid>
          <source url="https://forum.rebol.info/t/parsing-a-readme-md-file-to-fill-a-folder/1840.rss">Parsing a README.md File To Fill A Folder</source>
        </item>
        <item>
          <title>Demonstrating FOR-BOTH: Loop Composability For The Win :exclamation:</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>FOR-BOTH was an early talking point for an extremely simple usermode loop construct that would be built out of two FOR-EACH loops:</p>
<pre><code> &gt;&gt; for-both 'x [1 2] [3 4] [print [x], x = 5]
 1
 2
 3
 4
 ; first in pack of 1 item
 == ~null~  ; anti
</code></pre>
<p>A naive implementation of this in Rebol2 might look like:</p>
<pre><code> for-both-naive: func [var blk1 blk2 body] [
     foreach (var) blk1 body
     foreach (var) blk2 body
 ]
</code></pre>
<p>...but...</p>
<ul>
<li>
<p><strong>It will not honor BREAK correctly</strong></p>
<pre><code>&gt;&gt; for-both-naive 'x [1 2] [3 4] [if x = 2 [break], print [x], x = 5]
1
3  ; the BREAK only broke the first FOREACH
4
== #[none]
</code></pre>
<p>There's no way from the outside of Rebol2 or Red's FOREACH to know for sure that a BREAK was requested.  BREAK returns NONE!, but a loop body can (and often does) evaluate to NONE! as well.  Red made it even worse by adding BREAK/RETURN--so a breaking loop can return <em>anything</em>.</p>
<p>So you'd need some kind of complex binding to search the loop bodies and bind the BREAK word to something that throws and gets caught...even for this simple goal.</p>
</li>
<li>
<p><strong>The loop won't evaluate to the last result of the body</strong>.</p>
<pre><code>&gt;&gt; for-both-naive 'x [1 2] [] [print [x], x * 10]
1  ; evaluated to 10
2  ; evaluated to 20
== #[none!]
</code></pre>
<p>If the second series is empty, the fallout from the first loop is forgotten.</p>
</li>
</ul>
<h2>
<a name="behold-ren-cs-elegant-solution-to-for-both-1" class="anchor" href="https://forum.rebol.info#behold-ren-cs-elegant-solution-to-for-both-1"></a>Behold Ren-C's Elegant Solution to FOR-BOTH</h2>
<p><em>Underneath its apparent simplicity lies quite a lot of deep thought.</em>  And the mechanisms it uses apply far beyond just loops!</p>
<pre><code>    for-both: func [var blk1 blk2 body] [
        return unmeta/lite all [
            meta/lite for-each var blk1 body
            meta/lite for-each var blk2 body
        ]
    ]
</code></pre>
<h3>
<a name="it-solves-the-break-case-2" class="anchor" href="https://forum.rebol.info#it-solves-the-break-case-2"></a>It solves the BREAK case</h3>
<p>Below we see a situation where the first FOR-EACH returns NULL (and <strong>meta null</strong> is just <strong>null</strong>).  So it short-circuits the ALL, and propagates the null as a signal that it broke:</p>
<pre><code>&gt;&gt; for-both 'x [1 2] [3 4] [if x = '2 [break], print [x], x = 5]
1
== ~null~  ; anti
</code></pre>
<p>Note that the first pass through the loop did not terminate the ALL, just because the body evaluated to null.  That's because it produced a "heavy null", and META/LITE of non-pure-void, non-pure-null antiforms produces QUASIFORM!, which is a branch trigger even if the antiform thing would not be:</p>
<pre><code> &gt;&gt; metanull: meta ~[~null~]~
 == ~[~null~]~

 &gt;&gt; type of metanull
 == &amp;[quasiform]

&gt;&gt; if metafalse [print "All QUASIFORM! are branch triggers!"]
All QUASIFORM! are branch triggers!
</code></pre>
<p>This means the loop can gracefully recover the QUASIFORM! as the ALL result if the loop completes, and remove the quasi level:</p>
<pre><code>&gt;&gt; for-both 'x [1 2] [3 4] [print [x], x = 5]
1
2
3
4
; first in pack of 1 item
== ~null~  ; anti
</code></pre>
<h3>
<a name="it-solves-the-fallout-from-the-last-loop-body-3" class="anchor" href="https://forum.rebol.info#it-solves-the-fallout-from-the-last-loop-body-3"></a>It Solves the Fallout From The Last Loop Body</h3>
<p>This takes advantage of a new invariant: <em><strong>loops which never run their bodies return void</strong></em>.</p>
<pre><code>&gt;&gt; for-each x [] [fail "This body never runs"]
== ~void~  ; anti
</code></pre>
<p>Voids act invisibly in constructs like ALL.  So we get the result we want:</p>
<pre><code>&gt;&gt; for-both 'x [1 2] [] [print [x], x * 10]
1  ; evaluated to 10
2  ; evaluated to 20
== 20
</code></pre>
<p>There's a slight fib here, that META/LITE of the void did not produce a "meta-void" (')...but passed it through (it would pass through NULL, as well).  That's a property of the /LITE refinement:</p>
<pre><code>&gt;&gt; meta/lite if 10 &gt; 20 ["META/LITE passes through the void antiforms"]
== ~void~  ; anti

&gt;&gt; meta if 10 &gt; 20 ["Without /LITE is more exact, gives the quasiform"]
== ~void~
</code></pre>
<p>But in situations like this, passing through the void state is what we wanted.</p>
<h3>
<a name="you-can-even-return-null-from-the-body-4" class="anchor" href="https://forum.rebol.info#you-can-even-return-null-from-the-body-4"></a>You Can Even Return NULL From the Body!</h3>
<p>Thanks to isotopes, the following is possible:</p>
<pre><code>&gt;&gt; x: for-both 'x [1 2] [] [print [x], if x = 2 [null]]
1
2
; first in pack of length 1
== ~null~  ; anti

&gt;&gt; x
== ~null~ 
</code></pre>
<p>How cool is that?  Even though NULL is being reserved as the unique signal for loops breaking, there's a backchannel for it to escape...out of the FOR-EACH, and up out of the FOR-BOTH wrapping it!</p>
<h2>
<a name="it-holds-up-under-scrutiny-5" class="anchor" href="https://forum.rebol.info#it-holds-up-under-scrutiny-5"></a>It Holds Up Under Scrutiny!</h2>
<p>I'm really pleased with it, and here are some tests:</p>
<p><a href="https://github.com/metaeducation/ren-c/blob/master/tests/loops/examples/for-both.loops.test.reb" class="inline-onebox">ren-c/tests/loops/examples/for-both.loops.test.reb at master · metaeducation/ren-c · GitHub</a></p>
<p>I invite you to test it some more...ask questions...and perhaps come up with your own loop compositions!</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/atom_symbol.png?v=12" title=":atom_symbol:" class="emoji only-emoji" alt=":atom_symbol:" loading="lazy" width="20" height="20"></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833</link>
          <pubDate>Tue, 31 May 2022 16:02:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1833</guid>
          <source url="https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833.rss">Demonstrating FOR-BOTH: Loop Composability For The Win :exclamation:</source>
        </item>
        <item>
          <title>Prettier TLS State Tables (and Assessing the Cost)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>So the spec-driven TLS originally had this state table.  On the left are states and on the right is a block of the legal states you can transition to from that state (if any).</p>
<p>Here are the states for a TLS read:</p>
<pre><code>read-proto-states: [
    client-hello [server-hello]
    server-hello [certificate]
    certificate [server-hello-done server-key-exchange]
    server-key-exchange [server-hello-done]
    server-hello-done [#complete]
    finished [change-cipher-spec alert]
    change-cipher-spec [encrypted-handshake]
    encrypted-handshake [application #complete]
    application [application alert #complete]
    alert [#complete]
    close-notify [alert]
]
</code></pre>
<p><em>It seemed to me this wasn't exploiting the types all that well.</em>  We see an ISSUE! being used for <span class="hashtag">#complete</span>.  I imagined it would be better to move the issue annotation onto the state itself: <strong>If a state was represented by an ISSUE!, then that meant the state could legally be transitioned to the completion state.</strong></p>
<p>So instead of:</p>
<pre><code>encrypted-handshake [application #complete]
</code></pre>
<p>That would become:</p>
<pre><code>#encrypted-handshake [#application]
</code></pre>
<p>(Since the application state could be terminal as well.)</p>
<p>Now you know just by looking at it that <span class="hashtag">#encrypted-handshake</span> is a <em>potentially-terminal state</em>...and that's everywhere that encrypted-handshake appears.  It's not that much more typing, since you have to put an apostrophe on most uses anyway...and it helps the state "stand out".</p>
<p>Plus making the non-terminal states stand out would be good, so I turned them into tags.</p>
<p><strong>I also thought that the blocks looked a bit boring, and I didn't like having to put single elements into blocks just for the convenience of the implementation.</strong>  I tried adding arrows and letting single elements stand alone on the mapped-to side:</p>
<pre><code>read-proto-states: [
    &lt;client-hello&gt;          -&gt; &lt;server-hello&gt;
    &lt;server-hello&gt;          -&gt; &lt;certificate&gt;
    &lt;certificate&gt;           -&gt; [#server-hello-done &lt;server-key-exchange&gt;]
    &lt;server-key-exchange&gt;   -&gt; #server-hello-done
    &lt;finished&gt;              -&gt; [&lt;change-cipher-spec&gt; #alert]
    &lt;change-cipher-spec&gt;    -&gt; #encrypted-handshake
    #encrypted-handshake    -&gt; #application
    #application            -&gt; [#application #alert]
    #alert                  -&gt; []
    &lt;close-notify&gt;          -&gt; #alert
]
</code></pre>
<p>Of course, this needs to be parsed into a MAP!, so we need some code like:</p>
<pre><code>transitions: make map! []  ; map from states to block of states
state-rule: [tag! | issue!]
uparse transdialect [
    while [
        left: state-rule '-&gt; right: [
            into block! [while state-rule, &lt;input&gt;]
            | collect keep state-rule
        ]
        (append transitions :[left right])
    ]
]
</code></pre>
<h2>Improvement...Or Dialecting For The Sake of Dialecting?</h2>
<p>The general question of whether or not to use things like ISSUE! and TAG! for states as opposed to the "cleaner" WORD!s is something that is a bit controversial.</p>
<p>One issue is that there's traditionally a greater cost to comparing strings than there is to comparing words.  So <strong>state = <span class="hashtag">#encrypted-handshake</span></strong> is slower than <strong>state = 'encrypted-handshake</strong>.  The worst case scenario is equality--because all the characters have to be compared to decide if they are equal.</p>
<p>I'd like to focus more on the qualities of the source representation than worry about the performance however.</p>
<p>There's certainly a point of view where the original wasn't as "noisy".  But if you take the extreme opinion of using WORD! for everything, then the code all blurs together.</p>
<h2>Parsing Has The Benefit Of Validation</h2>
<p>When you stylize your input and do some processing of it to get it into a canonized form, that process of translating your input is a chance to check that the data is what you expect.</p>
<p>Using a generic structure doesn't just keep you from throwing in "superficial" flourishes like <strong><code>-&gt;</code></strong>, but the generality usually goes with accepting anything.  Once you have a processing step that puts you in the position of being able to validate...which is a powerful thing.</p>
<h2>I Think These Kinds of Things Are "The Point"</h2>
<p>I don't know if this particular example is the best example.  But I do think that this is what PARSE is meant for, and UPARSE is pushing things to a new level.  We should be looking for opportunities to show off this kind of idea, vs just doing what other languages do in a weird way.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/prettier-tls-state-tables-and-assessing-the-cost/1736">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/prettier-tls-state-tables-and-assessing-the-cost/1736</link>
          <pubDate>Sun, 03 Oct 2021 17:29:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1736</guid>
          <source url="https://forum.rebol.info/t/prettier-tls-state-tables-and-assessing-the-cost/1736.rss">Prettier TLS State Tables (and Assessing the Cost)</source>
        </item>
        <item>
          <title>Isotopic WORD!s For More Informative States in TLS</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>When introducing isotopic WORD!s, I wrote:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1383">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"><a href="https://forum.rebol.info/t/1383/1">On another topic</a></div>
<blockquote>
<p>Since these can be used as a kind of deferred error--a bad result that's only there to be bad if you actually use it--the text in these words could help guide you to what happened.</p>
</blockquote>
</aside>
<p>Today I hit a good example.  I was going over some stuff in the TLS code, and found this:</p>
<pre><code>; Each encrypted message in TLS 1.1 and above carry a plaintext
; initialization vector, so the ctx does not use one for the whole
; session.  Unset it to make sure.
;
unset in ctx 'client-iv
unset in ctx 'server-iv
</code></pre>
<p>So in TLS 1.0 mode, there is a single "iv" (initialization vector) reused for the client and server over the whole session.  But you don't want to use those fields in TLS 1.1 and above, because you're supposed to be using the data from each message.</p>
<p>The historical trick to catch unwanted reads of these fields was to unset them.</p>
<ul>
<li>
<p>It was awkward to do so...since UNSET!s couldn't be assigned via SET-WORD!</p>
</li>
<li>
<p>Also, it didn't communicate any information besides "unset"</p>
</li>
</ul>
<p>Today, you can painlessly get the effect...with a more meaningful error on access!</p>
<pre><code>ctx.client-iv: ctx.server-iv: ~per-message~
</code></pre>
<p>So if you get an error on trying to access these variables, it will tell you its the isotopic WORD! of <strong>~per-message~</strong>.  You can look that up in the source or get the gist of what it means.</p>
<p><em>(I'm still thinking about how we might put the file and line number into the value itself, so you could find this assignment and get at the origin of the value!)</em></p>
<p>Using isotopes effectively is a lot of bang for the buck.  Neat stuff!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/isotopic-word-s-for-more-informative-states-in-tls/1933">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/isotopic-word-s-for-more-informative-states-in-tls/1933</link>
          <pubDate>Sun, 15 Aug 2021 12:44:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1933</guid>
          <source url="https://forum.rebol.info/t/isotopic-word-s-for-more-informative-states-in-tls/1933.rss">Isotopic WORD!s For More Informative States in TLS</source>
        </item>
        <item>
          <title>A Lot To UNPACK: (Replacing the SET of REDUCE BLOCK! Idiom)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>We've fretted a lot about the result of REDUCE when an expression produces something that can't be put in a block.  At first this was just NULL.  <em><a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">But now it's all isotopic forms.</a></em></p>
<p>One reason to fret is the historical idiom of setting multiple values in a block.  This was done with a SET of a REDUCE.  Something along the lines of:</p>
<pre><code>&gt;&gt; x: 3 + 4
== 7

&gt;&gt; set [a b] reduce [10 + 20 x]
== [30 7]

&gt;&gt; a
== 30

&gt;&gt; b
== 7
</code></pre>
<p>It's your choice to reduce the values or not.  If you don't involve REDUCE then the mechanics would all work out.  But once you get NULLs and isotopes, the reduced block can't store the values to convey them to the SET...</p>
<h2>
<a name="but-what-if-a-single-operation-did-both-1" class="anchor" href="https://forum.rebol.info#but-what-if-a-single-operation-did-both-1"></a>But What If A Single Operation Did Both...?</h2>
<p>Let's imagine we have instead something called PACK that by default reduces to meta values... and that SET-BLOCK! is willing to "unpack" one at a time in UNMETA'd variables.</p>
<pre><code>&gt;&gt; x: 3 + 4
== 7

&gt;&gt; [a b]: pack [10 + 20 x]
== 30

&gt;&gt; a
== 30

&gt;&gt; b
== 7
</code></pre>
<p>We can prototype the behavior by making PACK quote a SET-WORD! or SET-BLOCK! on its left, and combine that with the unpacking.  PACK manages the evaluation one expression at a time, instead of using REDUCE.  So as it goes it can set the variables to NULL or isotopes.  And by following the multi-return convention of returning the first value, you avoid ever needing to synthesize a block aggregating all the results together.</p>
<pre><code>&gt;&gt; [a b]: pack case [
       1 = 1 [
           print "This is pretty slick..."
           [select [a 10] 'b, 1 + 2]
       ]
    ] else [
        print "This won't run because the ELSE gets a BLOCK!"
        print "Which is what you want, because the ELSE should be"
        print "what runs if no CASE was matched and have the option"
        print "of providing the block to UNPACK"
    ]
 This is pretty slick...
 == ~null~  ; isotope

&gt;&gt; a
== ~null~  ; isotope

&gt;&gt; b
== 3
</code></pre>
<h2>
<a name="can-even-avoid-a-reduce-2" class="anchor" href="https://forum.rebol.info#can-even-avoid-a-reduce-2"></a>@[...] can Even Avoid A REDUCE</h2>
<p>If you already have a block in reduced or literal form, how would you tell the PACK about that?  It could be a refinement like PACK/ONLY.  BUT...what if that were signaled with the @ block type?</p>
<pre><code>&gt;&gt; [a b]: pack @[1 +]
== 1

&gt;&gt; a
== 1

&gt;&gt; b
== +
</code></pre>
<p>A real aspect of power in this approach is the ability to mix and match.  For instance you could have some branches in a CASE which have already reduced data and others that don't, and they could all participate with the same PACK operation.</p>
<pre><code>[op1 op2]: pack case [
    ... [
        print "This branch uses values as-is"
        @[+ -]
    ]
    ... [
       print "This branch needs evaluation"
       [operators.1, pick [- /] op-num]
   ]
]
</code></pre>
<h2>
<a name="cool-dialecting-twists-3" class="anchor" href="https://forum.rebol.info#cool-dialecting-twists-3"></a>Cool Dialecting Twists</h2>
<p>The basic premise of multiple returns is that if you don't know about extra values, you don't worry about them... so by default packs with extra values need to just ignore them.</p>
<pre><code>&gt;&gt; [a b]: pack [1 2 3]
== 1

&gt;&gt; a
== 1

&gt;&gt; b
== 2
</code></pre>
<p>But for some applications, it might be nice to be able to check that an unpacking is exact:</p>
<pre><code>&gt;&gt; [a b &lt;end&gt;]: pack [1 2 3]
** Error: Too many values for vars in PACK (expected &lt;end&gt;)
</code></pre>
<p>Borrowing from multi-return: I think the idea of "circling" values to say which is the one you want the overall expression to evaluate to is a neat idea.</p>
<pre><code>&gt;&gt; [a @b]: pack [1 2]
== 2
</code></pre>
<h2>
<a name="and-for-show-and-tell-a-prototype-4" class="anchor" href="https://forum.rebol.info#and-for-show-and-tell-a-prototype-4"></a>And For Show And Tell... A Prototype!</h2>
<p>How hard is it to write such a thing, you ask?  In Ren-C it's super easy, barely an inconvenience:</p>
<p><em>(Note: Prototype updated circa 2023...kept around as a test of usermode behavior.  But now this is handled by SET-BLOCK! and PACK! isotopes.)</em></p>
<pre><code>pack: enfixed func [
    {Prepare a BLOCK! of values for storing each in a SET-BLOCK!}
    return: [&lt;opt&gt; &lt;void&gt; any-value!]
    'vars [set-block! set-group!]
    block "Reduced if normal [block], but values used as-is if @[block]"
        [block! the-block!]
][
    if set-group? vars [vars: eval vars]

    ; Want to reduce the block ahead of time, because we don't want partial
    ; writes to the results (if one is written, all should be)
    ;
    ; (Hence need to do validation on the ... for unpacking and COMPOSE the
    ; vars list too, but this is a first step.)
    ;
    block: if the-block? block [
        map-each item block [quote item]  ; should REDUCE do this for @[...] ?
    ]
    else [
        reduce/predicate block :meta
    ]

    let result': void'
    for-each val' block [
        if result' = void' [
            result': either blank? vars.1 [void'] [val']
        ]
        if vars.1 = &lt;end&gt; [
            fail "Too many values for vars in PACK (expected &lt;end&gt;)"
        ]
        if tail? vars [
            continue  ; ignore all other values (but must reduce all)
        ]
        switch/type vars.1 [
            blank! []  ; no assignment
            word! tuple! [set vars.1 unmeta val']
            meta-word! meta-tuple! [set vars.1 val']
        ]
        vars: my next
    ]
    if vars.1 = &lt;end&gt; [
        if not last? vars [
            fail "&lt;end&gt; must appear only at the tail of PACK variable list"
        ]
    ] else [
        ; We do not error on too few values (such as `[a b c]: [1 2]`) but
        ; instead unset the remaining variables (e.g. `c` above).  There could
        ; be a refinement to choose whether to error on this case.
        ;
        for-each var vars [  ; if not enough values for variables, unset
            if not blank? var [unset var]
        ]
    ]
    return unmeta any [result' void']
]
</code></pre>
<p>If the ^ and UNMETA seem confusing, the only thing you need to think about is that the META protocol helps you out when you're trying to deal with a situation of storing a value that can be anything...and you need to differentiate a state.  I'm making the result "meta" so that I can use plain unset to signal that it hasn't been assigned yet.  I could make a separate boolean variable instead, but then I'd have another variable and I'd have to GET/ANY the result...</p>
<p>I'm sure people will start getting the hang of it!  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/a-lot-to-unpack-replacing-the-set-of-reduce-block-idiom/1634">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/a-lot-to-unpack-replacing-the-set-of-reduce-block-idiom/1634</link>
          <pubDate>Thu, 08 Jul 2021 07:44:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1634</guid>
          <source url="https://forum.rebol.info/t/a-lot-to-unpack-replacing-the-set-of-reduce-block-idiom/1634.rss">A Lot To UNPACK: (Replacing the SET of REDUCE BLOCK! Idiom)</source>
        </item>
        <item>
          <title>UPARSE Case Study: Escaping In Strings</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I wanted to make a REWORD variation that would look for escaped parts of strings and extract them as words.  So:</p>
<pre><code>Input: "abc$(def)ghi"
Output: ["abc" def "ghi"]
</code></pre>
<p>It's a common-seeming and not entirely trivial task.  The first thing I came up with is a bit convoluted...perhaps because I tried to not repeat the "$(" and ")" strings in the rule:</p>
<pre><code>parse text [
    collect [
        try some [
            not &lt;end&gt;
            (capturing: false)
            try keep between &lt;here&gt; ["$(" (capturing: true) | &lt;end&gt;]
            :(if capturing '[
                let inner: between &lt;here&gt; ")"
                keep (as word! inner)
            ])
        ]
    ]
]
</code></pre>
<p>It basically alternates between a capturing mode and a non-capturing mode.  It decides if it needs to run a capture mode with a variable.</p>
<p>It has to throw in a <a href="https://forum.rebol.info/t/any-vs-while-and-not-end/1572"><code>NOT &lt;END&gt;</code> for reasons I explain in another post</a>.  Because it's running alternating rules that may both opt out.</p>
<p>I use a GET-GROUP! spliced conditional rule, as UPARSE doesn't have any loop-interrupting constructs yet.  So you can't say "Stop running this rule, but consider it to have matched."  There's only LOGIC! of #[false] which means what FAIL used to mean...e.g. the overall rule did not match (so any collected material would be forgotten).</p>
<p>Since it can't break out of the rule and report success, it has to have a way to skip over a rule.  So the rule for capturing inside the parentheses conditions itself out with an IF statement and a generated rule.  I could have instead written that as an alternate rule, where if <code>not capturing</code> was true it would bypass normal code:</p>
<pre><code>parse text [
    collect [
        try some [
            not &lt;end&gt;
            (capturing: false)
            try keep between &lt;here&gt; ["$(" (capturing: true) | &lt;end&gt;]
            [:(not capturing) |
                let inner: between &lt;here&gt; ")"
                keep (as word! inner)
            ]
        ]
    ]
]
</code></pre>
<p>That feels more convoluted to me because of the inverse logic of the NOT, though.</p>
<p>It produces more empty strings than I would like:</p>
<pre><code>Input: "$(abc)$(def)$(ghi)"
Output: ["" abc "" def "" ghi]
</code></pre>
<p>It would technically be possible for a rule like BETWEEN to succeed and give a NULL result if there were no content, instead of an empty string:</p>
<pre><code>&gt;&gt; parse "()" [between "(" ")"]
== ~null~  ; anti
</code></pre>
<p>But this then means you can't get a good distinction of what happened in the case of an optional rule.</p>
<pre><code>&gt;&gt; parse "" [try between "(" ")"]
== ~null~   ; anti...so were there parentheses or not?
</code></pre>
<p>So I guess it's another situation where if you want to filter out the empty strings, you have to capture into a variable and filter it.</p>
<p><strong>I think UPARSE helps out here...but it's not quite the slam dunk I'd hope for.</strong></p>
<p>Because it has two rules that may both opt themselves out, it's a thought piece for asking if the NOT END makes sense with TRY SOME.  Or is it better off baking that into the TRY SOME rule and having another construct?  Intuitively I feel like the tax of having two slightly different versions and explaining the use of one vs. the other is worse than just having the more general construct.</p>
<p>If there were a loop-ending construct that indicated the overall rule was a success (e.g. didn't discard the KEEPs), then we might avoid the capturing flag:</p>
<pre><code>uparse text [
    collect [
        try some [
            try keep between &lt;here&gt; ["$(" | &lt;end&gt;]
            [&lt;end&gt; break |
                let inner: between &lt;here&gt; ")"
                keep (as word! inner)
            ]
        ]
    ]
]
</code></pre>
<p>But I don't know if BREAK is the right name for a loop-accepting operation (as in DO's while this typically causes most loop operations to return NULL).  So I'd think it would perhaps discard anything kept.  Perhaps STOP would be more consistent, and it could be value-bearing as well (<strong>stop (...)</strong>)</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/uparse-case-study-escaping-in-strings/1573">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/uparse-case-study-escaping-in-strings/1573</link>
          <pubDate>Sat, 27 Mar 2021 13:44:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1573</guid>
          <source url="https://forum.rebol.info/t/uparse-case-study-escaping-in-strings/1573.rss">UPARSE Case Study: Escaping In Strings</source>
        </item>
        <item>
          <title>Weird Idiom: Labeling Values?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I'm going through and changing a lot of FUNCTION uses to FUNC + LET.  The long term goal will be to eliminate the locals-gathering functionality...and you either use LET/USE or you go explicit with <code>&lt;local&gt;</code> in the function spec.</p>
<p>I came across this:</p>
<pre><code>    size-as-binary: enbin [be + 8] length of embedding
    append executable size-as-binary
</code></pre>
<p>This was the only use of the variable.  Changing it to a LET works, but it's kind of a waste:</p>
<pre><code>    let size-as-binary: enbin [be + 8] length of embedding
    append executable size-as-binary
</code></pre>
<p>LET's assignment form does run the right hand side...because the LET word itself vaporizes, so it's like the bound new SET-WORD! just runs as normal:</p>
<pre><code>    append executable let size-as-binary: enbin [be + 8] length of embedding
</code></pre>
<p>But a LET isn't really necessary here.  I had a weird thought, what if a TAG! or ISSUE! or something was used in a way that was "obviously" throwing it away?</p>
<pre><code>    append executable (&lt;size-as-binary&gt; enbin [be + 8] length of embedding)
</code></pre>
<p>Maybe a little confusing.  But it saves on a variable declaration.</p>
<p>A comment is zero overhead, so I'm doing that...</p>
<pre><code>    append executable enbin [be + 8] length of embedding  ; size of binary
</code></pre>
<p>But I just thought the idea of a deliberately discarded leading value was kind of interesting.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/weird-idiom-labeling-values/1500">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/weird-idiom-labeling-values/1500</link>
          <pubDate>Wed, 10 Feb 2021 19:21:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1500</guid>
          <source url="https://forum.rebol.info/t/weird-idiom-labeling-values/1500.rss">Weird Idiom: Labeling Values?</source>
        </item>
        <item>
          <title>Rebmake Shows Why NULLs Shouldn&#39;t Vaporize in REDUCE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p><em>Before there were <a href="https://forum.rebol.info/t/what-to-call-the-unstable-antiform-of-empty-block/2204">distinct NULL and VOID states</a>, there was only NULL... and it was the product of failed conditionals.  There was a debate about whether NULL should be an error if encountered by REDUCE, or if it should vaporize.  This is a little piece of circa 2021 history I extracted about the first case I saw that represented a problem, that I edited out of a thread I was paring down.</em></p>
<hr>
<blockquote>
<p>Both changes are now in master:</p>
<ul>
<li><a href="https://github.com/metaeducation/ren-c/commit/988fc71103f5c75c0656a688ac3c3a36fdba1c9b"><strong>null = do []</strong></a></li>
<li><a href="https://github.com/metaeducation/ren-c/commit/056d9f336050a1813426916e41b604e9bcbc70b9"><strong>[] = reduce [null]</strong></a></li>
</ul>
<p>The new REDUCE behavior has been advocated now by <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a>, <a class="mention" href="https://forum.rebol.info/u/blackattr">@BlackATTR</a>, <a class="mention" href="https://forum.rebol.info/u/giuliolunati">@giuliolunati</a>, <a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a>, and was my original choice also:</p>
<pre><code>&gt;&gt; append [&lt;a&gt; &lt;b&gt;] reduce [&lt;c&gt; if false [&lt;d&gt;]]
== [&lt;a&gt; &lt;b&gt; &lt;c&gt;]
</code></pre>
<p>Up until now it has errored to leave the option open, without yet breaking the "N expressions in, N values out" dogma espoused by DocKimbel.</p>
</blockquote>
<hr>
<p>Hmmm...well when I tried bootstrapping the updated executable, here is an example of where NULL vaporizing in REDUCE bit me:</p>
<p>It was some of Shixin's code from rebmake.</p>
<pre><code>    if not let suffix: find reduce [
        #application target-platform/exe-suffix
        #dynamic-library target-platform/dll-suffix
        #static-library target-platform/archive-suffix
        #object-library target-platform/archive-suffix
        #object-file target-platform/obj-suffix
    ] project/class [return]

    suffix: second suffix
</code></pre>
<p>I had changed the suffixes in the base class of some objects from BLANK! to NULL.  This was in order to be more likely to catch usage problems of those suffixes, when BLANK! is more quiet about many operations (e.g. they will silently append, like classical #[none] would).</p>
<p>NULL provides a gentle sort of alarm...in the sense that it is falsey and can't be e.g. silently appended without an operation converting it to a value.  This is good for callsite comprehension.</p>
<p>But with NULL vanishing here, code in this style has problems.  I'm not sure there's anything particularly wrong about code in this style.  So we still might want to think about this.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/rebmake-shows-why-nulls-shouldnt-vaporize-in-reduce/2205">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rebmake-shows-why-nulls-shouldnt-vaporize-in-reduce/2205</link>
          <pubDate>Thu, 10 Dec 2020 19:59:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2205</guid>
          <source url="https://forum.rebol.info/t/rebmake-shows-why-nulls-shouldnt-vaporize-in-reduce/2205.rss">Rebmake Shows Why NULLs Shouldn&#39;t Vaporize in REDUCE</source>
        </item>
        <item>
          <title>YIELDER and GENERATOR (and thinking about Coroutines)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>The stackless model so far has been built on a generic and comprehensible building block called a <strong>YIELDER</strong>.  I thought I'd walk through it a little.</p>
<h1>
<a name="to-understand-yielder-first-look-at-generator-1" class="anchor" href="https://forum.rebol.info#to-understand-yielder-first-look-at-generator-1"></a>To understand YIELDER, first look at GENERATOR</h1>
<p>I think a generator is pretty easy to understand.  It is like a function, but instead of RETURN it has something called YIELD.  Each time YIELD is called the generator gives back the result but is left in a suspended state, and the next call to the generator will pick up right after the YIELD:</p>
<pre><code>counter: generator [
     let n: 0
     cycle [
          n: n + 1
          yield n
     ]
]

&gt;&gt; counter
== 1

&gt;&gt; counter
== 2
</code></pre>
<h2>
<a name="generators-are-building-blocks-meant-to-be-used-with-functions-2" class="anchor" href="https://forum.rebol.info#generators-are-building-blocks-meant-to-be-used-with-functions-2"></a>Generators are building blocks, meant to be used with functions</h2>
<p>Generators don't take parameters.  So if you want to parameterize them, you should combine them with a function.  Imagine you wanted to be able to specify a bump amount for your counter:</p>
<pre><code>make-counter: func [bump] [
     return generator [
         let n: 0
         cycle [yield n: n + 1]
     ]
]

&gt;&gt; counter: make-counter 5

&gt;&gt; counter
== 1

&gt;&gt; counter
== 6

&gt;&gt; counter
== 11
</code></pre>
<h2>
<a name="but-functions-arent-limited-to-being-just-generator-makers-3" class="anchor" href="https://forum.rebol.info#but-functions-arent-limited-to-being-just-generator-makers-3"></a>But functions aren't limited to being just "generator makers"...</h2>
<p>For instance: functions can be generator wrappers, that actually delegate to the generator...or perhaps even destroy it and make new ones.  Consider making a resettable counter, as <a class="mention" href="https://forum.rebol.info/u/giuliolunati">@giuliolunati</a> has in his GENERATE usermode generator:</p>
<pre><code> counter: func [/reset &lt;static&gt; n (0) gen (null)] [
     if reset [n: 0, return]
     return reeval gen: default [
         generator [
             cycle [yield n: n + 1]
         ]
     ]
 ]

 &gt;&gt; counter
 == 1

 &gt;&gt; counter
 == 2

 &gt;&gt; counter/reset

 &gt;&gt; counter
 == 1

 &gt;&gt; counter
 == 2
</code></pre>
<p>This gives a lot of flexibility in the design of generator interfaces.  Considering the above example alone: what if you are in a situation where you think the <strong>counter/reset</strong> should have returned 1 instead of being a separate step that had no return result?  Or maybe you think it should have returned what the last generator value was.</p>
<p>By making generators a "simplistic" building block, you're in control of these interface choices.</p>
<h2>
<a name="the-yielder-hybridizes-with-functions-for-efficiency-4" class="anchor" href="https://forum.rebol.info#the-yielder-hybridizes-with-functions-for-efficiency-4"></a>The YIELDER hybridizes with functions for efficiency</h2>
<p>I said that generators don't have parameters or a function spec, but that is because they are a specialization of a version that does have a spec... called a YIELDER.</p>
<pre><code>weird-print: yielder [x] [
    cycle [
        print ["Odd print:" x]
        yield ~
        print ["Even print:" x]
        yield ~
    ]
]

&gt;&gt; weird-print "Hello"
Odd print: Hello

&gt;&gt; weird-print "Weird"
Even print: Weird

&gt;&gt; weird-print "World"
Odd print: World
</code></pre>
<p>This isn't anything you couldn't have achieved with a function that wrapped a generator, that held that generator statically and then sub-dispatched to it.  It's just cleaner and more efficient.  <em>(Since GENERATOR is implemented as <code>yielder [] [...generator body...]</code> it's kind of like the DOES analogue to FUNC.)</em></p>
<p>But this kind of gives you a sense of the parts box you have for building relatively efficient generator-type things.</p>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/yielder-and-generator-and-thinking-about-coroutines/1311">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/yielder-and-generator-and-thinking-about-coroutines/1311</link>
          <pubDate>Tue, 28 Jul 2020 03:52:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1311</guid>
          <source url="https://forum.rebol.info/t/yielder-and-generator-and-thinking-about-coroutines/1311.rss">YIELDER and GENERATOR (and thinking about Coroutines)</source>
        </item>
  </channel>
</rss>

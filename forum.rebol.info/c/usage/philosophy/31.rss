<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Philosophy - AltRebol</title>
    <link>https://forum.rebol.info/c/usage/philosophy/31</link>
    <description>Topics in the &#39;Philosophy&#39; category How does Rebol differ from other computer languages and what makes code Rebolish and functional vs procedural coding.</description>
    
      <lastBuildDate>Sat, 17 Dec 2022 15:53:35 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/usage/philosophy/31.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>ChatGPT Speaking About Rebol</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>So ChatGPT actually knows a bit about Rebol (at least Rebol2)</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/7b940f01f3801b53d0a1d4d412074bda30517443.png" data-download-href="https://forum.rebol.info/uploads/default/7b940f01f3801b53d0a1d4d412074bda30517443" title="image"><img src="https://forum.rebol.info/uploads/default/original/1X/7b940f01f3801b53d0a1d4d412074bda30517443.png" alt="image" data-base62-sha1="hDdWsU3sEBthVlysVvcHRLWmfWH" width="356" height="500" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/7b940f01f3801b53d0a1d4d412074bda30517443_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">image</span><span class="informations">634Ã—890 25 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p>This does raise some questions about the future of software, in general.  It's possible that AI models will plateau and maybe they'll never get too much better than this...</p>
<p>...but I don't think so.  I imagine year-over-year, we're going to see them learning.  I don't know exactly when they'd be able to come up with ideas like what I've been doing for Ren-C.</p>
<p>But something I did think about is that if they can write code, then giving them a super-expressive medium in which to do it could be very powerful.  If they can come up with the dialect and then use it, then they might be able to write concise programs that wind up being quite legible...whereas other languages might make them trade off length for clarity.</p>
<p>If you ask ChatGPT an interesting Rebol question, feel free to put it in this thread.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/chatgpt-speaking-about-rebol/1997">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/chatgpt-speaking-about-rebol/1997</link>
          <pubDate>Sat, 17 Dec 2022 15:53:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1997</guid>
          <source url="https://forum.rebol.info/t/chatgpt-speaking-about-rebol/1997.rss">ChatGPT Speaking About Rebol</source>
        </item>
        <item>
          <title>Jonathan Blow, and Euclid&#39;s Elements</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Jonathan Blow is a video game developer--who made a well known indie game called "Braid" that did some fun time/space manipulations people generally hadn't seen before in a Mario-type platfomer.   Later he took a number of years to make the much higher-budget art piece The Witness...a very intellectual game which has a Sixth-Sense kind of reveal that's quite good.</p>
<p>Though as time changes him from grumpy indie upstart to grumpy-old-man, he has joined the chorus of us grumpy old men when it comes to complexity:</p>
<div class="onebox lazyYT lazyYT-container" data-youtube-id="pW-SOdj4Kkk" data-youtube-title="Jonathan Blow - Preventing the Collapse of Civilization (English only)" data-parameters="feature=oembed&amp;wmode=opaque&amp;start=2189">
  <a href="https://www.youtube.com/watch?v=pW-SOdj4Kkk" target="_blank" rel="noopener">
    <img class="ytp-thumbnail-image" src="https://i.ytimg.com/vi/pW-SOdj4Kkk/maxresdefault.jpg" title="Jonathan Blow - Preventing the Collapse of Civilization (English only)" width="480" height="360">
  </a>
</div>

<p>But I'm pretty sure he would pretty much hate Redbol languages for programming his games.  He doesn't like scripting, and thinks it's dumb to use things without static typing or that catch your mistakes in advance.  (And I'm with him when he responds to people who say things like "but you can try changes without restarting" are wrongheaded.  You can compile checked bits of code and reload them dynamically if your system is designed right.)</p>
<p>What he's looking for is something that offers the benefits of C++ and Rust, but minus the things he considers to be annoying.  "Something like Rust, but cutting out anything that would be an impediment to the games that I--Jonathan Blow--would write."</p>
<p><a href="https://github.com/BSVino/JaiPrimer/blob/master/JaiPrimer.md">https://github.com/BSVino/JaiPrimer/blob/master/JaiPrimer.md</a></p>
<p>I imagine that if Jonathan <em>were</em> to appreciate something like Ren-C it would be in the way I do--as a game in itself.  (He actually playtested "Baba is You"--according to a YouTube stream of him playing the final version.  When asked what he was paid to give his feedback he just grumbled "not enough".  So I probably won't be sending Ren-C to him.  :-P)</p>
<p>In any case, he was doing a talk on games in education and cited a page from Euclid's Elements that I thought was interesting.  <a href="https://youtu.be/qWFScmtiC44?t=756">The quote he cites says</a>:</p>
<blockquote>
<p><em>"If a first magnitude has to a second the same ratio as a third has to a fourth, and also a fifth has to the second the same ratio as a sixth to a fourth, then the sum of the first and fifth has to the second the same ratio as the sum of the third and sixth has to the fourth."</em></p>
</blockquote>
<p>I'm sure it sounded like nonsense to Euclid's contemporaries, who were not able (or willing) to follow the reasoning for why such things might be important.</p>
<p>When you're reasoning through new abstract things there's lots of phases to it.  Terminology and mechanics evolve over time.  That's how it works, so people shouldn't be surprised to see things like <em><a href="https://forum.rebol.info/t/the-implications-of-meta-producing-quasi-from-isotopes/1967">"The Implications of ^META Producing QUASI! from Isotopes"</a></em>  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/jonathan-blow-and-euclids-elements/1971">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/jonathan-blow-and-euclids-elements/1971</link>
          <pubDate>Sun, 18 Sep 2022 21:14:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1971</guid>
          <source url="https://forum.rebol.info/t/jonathan-blow-and-euclids-elements/1971.rss">Jonathan Blow, and Euclid&#39;s Elements</source>
        </item>
        <item>
          <title>Rebol&#39;s Mission w.r.t. &quot;not wasting RAM or CPU cycles&quot;</title>
          <dc:creator><![CDATA[WickedSmoke]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Rebol was an attempt at grappling with the problems of overly complex and bloated software.  Part of that means not wasting RAM or CPU cycles.</p>
<p>Optimizing is just a normal part of software development. It's not done to please the programmer, but to build something of quality that respects the user who is running other pieces of software that are also using resources.  Think of it as being a good computational neighbor.</p>
<p>There needs to be some thread here about "computing horror stories". A month ago there was an article on Hacker News about NixOS and it's packaging system.  As some Nix user had just contacted me about packaging xu4, I thought I'd give it a spin.  After downloading the ISO and installing it on a virtual machine I went to get a package listing...<br>
and was greeted with some vague error message.</p>
<p>It turns out that the package manager was using well over 1GB of RAM and simply crapped out because my VM didn't have enough.  Some NixOS user told me:</p>
<blockquote>
<p>"Listing all packages is a bit of a weak spot. The entire package set is described in a lazy, functional language and listing or searching it requires evaluating the entire thing."</p>
</blockquote>
<p>This is an entire OS custom built around a package manager, and it couldn't even give me a listing of my packages.  The Nix developers want to geek out about their language, but I just want tools that work.</p>
<p>Thankfully, data-oriented design is now a thing, so I know at least someone is paying attention.</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rebols-mission-w-r-t-not-wasting-ram-or-cpu-cycles/1970">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rebols-mission-w-r-t-not-wasting-ram-or-cpu-cycles/1970</link>
          <pubDate>Sun, 18 Sep 2022 18:19:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1970</guid>
          <source url="https://forum.rebol.info/t/rebols-mission-w-r-t-not-wasting-ram-or-cpu-cycles/1970.rss">Rebol&#39;s Mission w.r.t. &quot;not wasting RAM or CPU cycles&quot;</source>
        </item>
        <item>
          <title>A Justification of Generalized Isotopes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p><em>Here is a train of thought to help people realize why isotopes are needed, and why unifying their behaviors and mechanisms under a common umbrella makes sense.  It starts from the issue of solving /ONLY and then explains the generalization.</em></p>
<p><em>As time permits, I'll come back and try to improve this...</em></p>
<hr>
<p>Years of fretting over the /ONLY debacle converged on a somewhat inescapable conclusion:</p>
<p><em><strong>It's better to carry the intent of whether a value needs to be spliced on that value...as opposed to having subtle variants of core operations that modulate the splicing.</strong></em></p>
<p>I'd worked up to a point where I was implementing the "mark of intent" by adding a quoting level to <em>suppress</em> splicing.  Yet this faced likely accidents when someone had a quoted value in a variable...and really meant to use it somewhere as-is, with the quote--vs. thinking of the quote as a splice-suppression signal which the operation should remove.</p>
<p>Then <a href="https://forum.rebol.info/t/putting-splicing-intent-on-appended-value/1873/9">@rgchris made this remark</a>:</p>
<aside class="quote no-group quote-modified" data-username="rgchris" data-post="9" data-topic="1873" data-full="true">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"><a href="https://forum.rebol.info/t/putting-splicing-intent-on-appended-value/1873/9">Putting Splicing Intent On APPEND'ed Value</a>
</div>
<blockquote>
<p>The issue I have with doing the opposite of ONLYâ€”let's call it SPREADâ€”is what is the interim value?</p>
<pre><code>&gt;&gt; block: [a b c [a b c]]

&gt;&gt; find block pick block 4
[[a b c]]

&gt;&gt; find block spread pick block 4
[a b c [a b c]]

&gt;&gt; spread pick block 4
???
</code></pre>
<p>It would seem to have virtue over ONLY and is a better word.</p>
</blockquote>
</aside>
<h2>If Trying This In Historical Redbol, What Might One Do?</h2>
<p>As a rough first cut, let's represent splices with a specially recognizable 2-element wrapper block.  We'll signal it's a splice with a series in the first slot--checking for the unique identity of that series.  Then put the block itself as the second element:</p>
<pre><code>splice-cue: "!!!splice!!!"

spread: func [block [block!]] [
    return reduce [splice-cue block]
]

splice?: func [value] [
    if not block? :value [return false]
    return same? splice-cue first value
]
</code></pre>
<p>Then we can write our new versions of things like APPEND that are specifically aware of this construct.</p>
<pre><code>append*: func [series [series!] value] [
    return either splice? :value [
        append series second value
    ][
        append/only series :value
    ]
 ]
</code></pre>
<p>It works more or less in your average Redbol, e.g. in Red:</p>
<pre><code>red&gt;&gt; append* [a b c] spread [d e]
== [a b c d e]

red&gt;&gt; append* [a b c] [d e]
== [a b c [d e]]

red&gt;&gt; append* [a b c] 'd
== [a b c d]

red&gt;&gt; append* [a b c] first ['d]
== [a b c 'd]
</code></pre>
<p><em>In fact, this is essentially how the bootstrap executable for Ren-C simulates the SPREAD behavior.</em></p>
<p>But the weaknesses are <em>immediately</em> apparent!!!  <img src="https://forum.rebol.info/images/emoji/twitter/pouting_cat.png?v=9" title=":pouting_cat:" class="emoji" alt=":pouting_cat:"></p>
<h2>Not A Distinct Type: Too Easy To Overlook Handling</h2>
<p>There's no special type for the spliced block...it's just a BLOCK!.  This means any routine that hasn't been written to handle it, will just let it leak through.</p>
<pre><code>red&gt;&gt; reduce [spread [a b c] [a b c]]
== [["!!!splice!!!" [a b c]] [a b c]]  ; not [a b c [a b c]]
</code></pre>
<p>Changing to some other generic type that can contain a block...such as an OBJECT!...doesn't help matters.  You are kind of in trouble any time an operation willfully lets you put these into an array.</p>
<p><strong>The first instinct might be to introduce a new SPLICE! datatype, with a system-wide rule that splices can't be put into arrays.</strong>  <em>(Enforcing such a rule across all array-manipulating code is challenging...so let's sort of make a note of that fact, but continue.)</em></p>
<p>Because of the peculiar nature of not being able to be put in a block, there'd have to be a decision made about function arguments as to whether or not they took this type.  Many functions designed to handle generic values would not be able to handle them, so there'd presumably need to be some typeset like ANY-NOTSPLICE! or ANY-NORMAL!.</p>
<h2>How To Represent A Type That Can't Be Put In A Block?</h2>
<p>Now we've got several things to ponder about our new type.  For instance: what you should see here?</p>
<pre><code>&gt;&gt; obj: make object! [foo: spread [d e]]
== make object! [
    foo: ???
]
</code></pre>
<p>We just said that a defining feature of SPLICE! is that you can't accidentally put them in blocks.  But the argument to MAKE OBJECT!, namely <strong><code>[foo: ???]</code></strong>, is a block.  If <code>???</code> can't itself be a splice!, then what is it?</p>
<p>This brings up a possibly-related question: what if you want a way to put the intent of whether to splice or not into "suspended animation?"... in a way that you could collect it?</p>
<p>Here's a sort of contrived example of the puzzle:</p>
<pre><code>generate: func [n [integer!]] [
   if even? n [return reduce [n n + 1]]
   return spread reduce [n n + 1]
]

wrap: func [
    return: [...]
    in [splice! block!]
][
    ...
]

unwrap: func [
    return: [splice! block!]
    wrapped [...]
][
    ...
]

n: 0
pending: collect [while [n &lt; 4] [keep wrap generate n]]

data: copy []
for-each item pending [append data unwrap item]
</code></pre>
<p>How would you write WRAP and UNWRAP such that at the end of the code above, you'd get:</p>
<pre><code>&gt;&gt; data
== [[0 1] 1 2 [2 3] 3 4]
</code></pre>
<p>If the system didn't provide some answer to this, you'd end up needing to re-invent something kind of equivalent to the primitive <code>["!!!splice!!!" [...]]</code> mechanic as a means of persistence:</p>
<pre><code>&gt;&gt; pending
== [[0 1] ["!!!splice!!!" [1 2]] [2 3] ["!!!splice!!!" [3 4]]]
</code></pre>
<h1>Isotopes Were Designed For This!</h1>
<p>Isotopes are a set of curated answers for these problems.  Originally they were introduced to address issues like what an UNSET! was...which has some of the same class of problems as SPLICE! (such as not wanting to be put in BLOCK!s, and not accepted by default or by most routines).</p>
<p>Isotopes are:</p>
<ul>
<li>
<p><strong>general</strong> - all base value types (e.g. unquoted things that can be put into blocks) have isotopic forms [see note]</p>
</li>
<li>
<p><strong>efficient</strong> - isotopes do not require allocations, and merely are a different state of a byte in the value cell (the same byte that encodes quoting levels)</p>
</li>
<li>
<p><strong>"meta-representable"</strong> - all isotopes have a corresponding single-value form known as a "quasi-form", which when evaluated (or run through a more narrow UNQUASI operation) will yield the isotopic form</p>
</li>
</ul>
<p><em>(Note: An edge case is that VOID is not considered isotopic, and so it has an isotopic form--which is used to represent unsetness.  It might seem that VOID should itself be the isotopic form of something else, since void can't be put in a block.  But we could also see it as infinitely many voids can be put in a block... since <strong><code>append [a b c] void</code></strong> is just <strong><code>[a b c]</code></strong>.  It just kind of turns out that thinking of void as non-isotopic appears to work out, and thinking of null as an isotopic word! is another thing that works out.)</em></p>
<p>I mentioned at the outset that it would be somewhat costly to bulletproof all of native code against the ability to do something like append a specific data type like "SPLICE!" to a block.  But with isotopes this problem has been solved once for all the forms...so the same code that prevents a so-called "UNSET!" from winding up in arrays works for splices.  <em>That's because a splice is actually an isotopic group!, and an unset is actually an isotopic void!</em></p>
<p>Above I asked:</p>
<blockquote>
<p>What you should see here?</p>
<pre><code>&gt;&gt; obj: make object! [foo: spread [d e]]
== make object! [
    foo: ???
]
</code></pre>
</blockquote>
<p>Isotopes give us the answer, that it's <strong><code>foo: ~(d e)~</code></strong>.  This is the previously mentioned "QUASI!" form of GROUP!, which when evaluated produces an isotope.</p>
<p><em>But isotopes themselves have no canon representation.</em>  The console can print out a comment or show them in a different color, but to talk about them having a representation doesn't make much sense as you'll never see them in source.</p>
<pre><code>&gt;&gt; ~(d e)~
== ~(d e)~  ; isotope
</code></pre>
<p>I also asked:</p>
<blockquote>
<p>"How would you write WRAP and UNWRAP such that at the end of the code above, you'd get:"</p>
<pre><code>&gt;&gt; data
== [[0 1] 1 2 [2 3] 3 4]
</code></pre>
</blockquote>
<p>With isotopic blocks representing splices, you don't need to write WRAP and UNWRAP... because these operations are built in operations called META and UNMETA.  And the pending array would look like:</p>
<pre><code>&gt;&gt; pending
== ['[0 1] ~(1 2)~ '[2 3] ~(3 4)~]
</code></pre>
<p>When the QUOTED! blocks are UNMETA'd, they become regular blocks and then are appended as-is.  When the QUASI! groups are UNMETA'd they become isotopes and give the splice intent.  This produces the desired "suspended animation" to preserve the intent.</p>
<p><em>That suspended animation is also used in the ^META parameter convention, which indicates a function argument can accept isotopes... and the add-quoting-or-quasi behavior brings those isotopic variables into a reified state so they can be safely handled.</em></p>
<h2>The Proof Is In The Capabilities</h2>
<p>I've explained about splices, and mentioned how it crosses needs with unset variable states.</p>
<p>But isotopes are also a cornerstone of <a href="https://forum.rebol.info/t/default-values-and-make-frame/1412">how function and FRAME! specialization works</a>.</p>
<p>The ERROR! isotope is used to have a sneaky out-of-band way to return <a href="https://forum.rebol.info/t/fail-vs-return-fail-the-new-age-of-definitional-failures/1852">definitional errors</a></p>
<p>As their applications expand, they are slated to allow us to have non-literal modes to ask something like FIND that you want to look for <em>instances</em> of a datatype by passing that type isotopically... vs. looking for the datatype's appearance concretely in the target.  Concepts of making only isotopic ACTION!s run through WORD! references could make it completely safe to work with arguments passed as variables, saving you from needing GET-WORD!s to handle them.</p>
<p>It's natural for there to be some confusion with the new idea--especially given all its churn through the course of design.  But the design is becoming clearer, and I think people are going to find this gives solidity to writing complicated but coherent code...vastly outpacing historical Redbol.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918</link>
          <pubDate>Tue, 16 Aug 2022 10:23:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1918</guid>
          <source url="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918.rss">A Justification of Generalized Isotopes</source>
        </item>
        <item>
          <title>The Rebellion Against Style Guides</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>While driving from Huntsville to Florida, I listened to a talk given by a guy who oversees the general style guide for all of Google's multi-millions of lines of C++.</p>
<p>He spoke very positively about a formatting tool called <code>clang-format</code>, and how if he had his way at Google...there would be no arguing over code formatting.  He felt the robot did a better job on average than even the best developers...and being willing to delegate formatting to the tool gave them time to work on more important things.</p>
<p><strong>My well-known opinion for code like C++ or Rust or Java is that it is best represented as a graph data structure that captures the relationships and identities.</strong>  How you render that is up to the program you use to view and edit the projection of that essential code.  It doesn't matter if code is in braces or has a box drawn around it.  You could make expressions feed into an actual logical circuit AND gate instead of using <code>&amp;&amp;</code> or the word <code>and</code> or what-have-you.</p>
<p><strong>But Rebol is different (and almost absurdist) in the software world.</strong>  If anything, it has an <em>anti</em>-style guide, in <a href="http://www.rebol.com/article/0103.html">The Deep Lake / (Swamp)</a>, where Carl says:</p>
<blockquote>
<p>Suppose I write:</p>
<pre><code>if time &gt; 10:00 [
    wakeup user
]
</code></pre>
<p>which some users may choose to rewrite it this way:</p>
<pre><code>if time &gt; 10:00
[
    wakeup user
    alert "Time to work"
 ]
</code></pre>
<p>But, what if the "then block" is a variable itself, defined as:</p>
<pre><code> action: [
     wakeup user
     alert "Time to work"
  ]
</code></pre>
<p>Would you write this:</p>
<pre><code>  if time &gt; 10:00
      action
</code></pre>
<p>or this:</p>
<pre><code>   if time &gt; 10:00 action
</code></pre>
</blockquote>
<p>The conclusion is:</p>
<blockquote>
<p>...<strong>how you write code is ultimately your choice alone</strong>. REBOL, as a context dependent language, is perhaps the most freeform computing language ever invented.</p>
</blockquote>
<p>I'm bringing this up because I'm mothballing an old Trello and looking for any links or information worth preserving.  It had a card requesting a style guide, pointing out a limited bit that had been written in the Rebol2 manual:</p>
<p><a href="http://www.rebol.com/docs/core23/rebolcore-5.html#section-5">http://www.rebol.com/docs/core23/rebolcore-5.html#section-5</a></p>
<p>I'm really only interested in the bits that reduce complexity (like just-say-no-to-CRLF files, or tabs, etc.)  As for the code itself, this is kind of an ASCII-art medium.</p>
<p>So a good "style guide" for Rebol would be one that showed examples of how to take advantage of the degrees of freedom to be bent to your purposes.  I think a good one was the <strong><a href="https://forum.rebol.info/t/testing-generic-tuple-and-path-structuring/1353">tuple and path test dialect</a></strong>.  But there are certainly more!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-rebellion-against-style-guides/1819">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-rebellion-against-style-guides/1819</link>
          <pubDate>Sat, 14 May 2022 05:39:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1819</guid>
          <source url="https://forum.rebol.info/t/the-rebellion-against-style-guides/1819.rss">The Rebellion Against Style Guides</source>
        </item>
        <item>
          <title>Turning a Blind Eye to Evaluator &quot;Abuse&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>I've gotten kind of attached to the current look and behavior of AND and OR, which allow short-circuiting even though one would not think the language could (should?) be able to.</p>
<p>It doesn't require simple variables be in a GROUP! on the right hand side.</p>
<pre><code>&gt;&gt; if true and true [print "True"] else [print "False"]
True
</code></pre>
<p>...but a function call has to be.</p>
<pre><code>&gt;&gt; foo: func [x] [
      print "Calling foo!"
      return x &gt; 1000
   ]

&gt;&gt; if false and foo 1020 [print "True!"] else [print "False"]
** Error: words/tuples can't be ACTION! as right hand of OR, AND, XOR

&gt;&gt; if false and (foo 1020) [print "True"] else [print "False"]
False

&gt;&gt; if true and (foo 1020) [print "True!"] else [print "False"]
Calling foo!
True
</code></pre>
<p><em>Note that if the thing to the left of the AND is false, it does not run the code in the GROUP! on the right.</em>  This requires that the right hand side be a quoted parameter convention.</p>
<p>Alternatively we could not quote it, and require the right hand side be in a block:</p>
<pre><code>&gt;&gt; if true and [true] [print "True"] else [print "False"]
True

&gt;&gt; if false and [foo 1020] [print "True"] else [print "False"]
False
</code></pre>
<p><strong>But I don't like that.</strong></p>
<p>Alternatively we could say we don't offer this and you always use ALL...maybe with COMMA! and maybe not:</p>
<pre><code>&gt;&gt; if all [true true] [print "True"] else [print "False"]
True

&gt;&gt; if all [false, foo 1020] [print "True"] else [print "False"]
False
</code></pre>
<p>I just don't think that looks as natural.</p>
<h2>It's Like I Said In <a href="https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359">"Speaking With Tics"</a>...</h2>
<p>If you think seeing a GROUP! on the right of AND and OR that doesn't unconditionally evaluate at the callsite is weird, why are you comfortable with <strong><code>for-each x [1 2 3] [...]</code></strong>?  That didn't unconditionally evaluate x.  Do you expect it to be <strong><code>for-each 'x</code></strong> instead?</p>
<aside class="quote no-group">
<blockquote>
<p>The quoted parameter convention exists to save you the trouble of quoting the callsites. <em>If this isn't what that's for, then what <strong>is</strong> it for?</em></p>
</blockquote>
</aside>
<p>It's just too nice to be able to say things like <strong><code>if var1 and var2 or (a &gt; b) [...]</code></strong>.</p>
<p>To me, part of what makes the language special is the ability to bend the evaluator to how we want to read code, vs bending code to fit the evaluator.  The existence of mechanics like quoted parameters are there to let this happen.</p>
<p><em>You don't have to use it.</em>  And the ability to switch it to where AND is a prefix operator that does bitwise math is the magic of the freedom of choice.  You can choose to change the definition even on a module-by-module basis, or on a function-by-function basis.</p>
<p>Further: if you're not bending the language, you're probably not really using it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/turning-a-blind-eye-to-evaluator-abuse/1791">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/turning-a-blind-eye-to-evaluator-abuse/1791</link>
          <pubDate>Fri, 18 Feb 2022 18:34:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1791</guid>
          <source url="https://forum.rebol.info/t/turning-a-blind-eye-to-evaluator-abuse/1791.rss">Turning a Blind Eye to Evaluator &quot;Abuse&quot;</source>
        </item>
        <item>
          <title>Regarding The &quot;Finality&quot; Of FAIL, RETURN, etc.</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>There are some functions that by name carry a certain <em>"finality"</em>.  You don't expect there to be a way to pass them an argument that will revoke them.</p>
<p>For instance, it would be a bit weird if FAIL followed the BLANK-IN, NULL-OUT convention:</p>
<pre><code>foo: func [error [error! blank!]] [
    fail error

    print "This looks like unreachable code."
]
</code></pre>
<p>Today we don't offer that Wayne's World version of "FAIL.... NOT!"  So you have to write:</p>
<pre><code>if error [fail error]
</code></pre>
<p>I've actually been in situations where repeating the error expression is complicated by things like API handle freeing issues, to where I've considered making something like MAYBE-FAIL which would be a No-Op on BLANK!... or perhaps a refinement as FAIL/MAYBE.</p>
<p>But I've not considered the idea of making plain FAIL a no-op on blanks.  That seems wrong.</p>
<h2>Does RETURN Have A Similar "Finality"?</h2>
<p>I've written a bunch about <a href="https://forum.rebol.info/t/uparse-return-subtleties/1589/4">how I stopped worrying and learned to love UPARSE's RETURN</a>.</p>
<p>But there's something a little weird to my tastes about it being "non-final".  For example:</p>
<pre><code>&gt;&gt; uparse "aabc" [some "a" return "x" | some "a" return "b"]
== "b"  ; today's answer (also R3-Alpha's answer with PARSE)
</code></pre>
<p>When it reached the point of RETURN "X", there were two potential interpretations:</p>
<ol>
<li>
<p><em>"Okay, it's time to return!  Let's see if this rule matches or not...and if not, we're returning NULL!"</em></p>
</li>
<li>
<p><em>"It might be time to return if this rule matches.  If it doesn't match, pretend we were never asked to return."</em></p>
</li>
</ol>
<p>Today we have (2).  It's strictly more powerful... as you can get (1) with <strong>return opt "x"</strong>.</p>
<pre><code>&gt;&gt; uparse "aabc" [some "a" return opt "x" | some "a" return opt "b"]
; null
</code></pre>
<p>Note also that if your RETURN value is in a GROUP! and evaluated as DO code instead of a rule, it will always succeed...and hence always final.  It's only when you pass a rule that it can get revoked.</p>
<p>As with needing to write <strong>if error [fail error]</strong>, if we switched to parse-RETURN-finality that would mean more code for opting out:</p>
<pre><code>; opting out in RETURN-non-final style
uparse data [... return [your rule here] ...]

; opting out in RETURN-final style
uparse data [... result: [your rule here] return (result) ...]
</code></pre>
<p><strong>But I still feel weird about RETURN in PARSE being something that can just be opted out of by the nature of its argument.</strong></p>
<p>And so far, every time I've wanted to use RETURN it has been either a RETURN of a GROUP! (thus unconditional) or a RETURN OPT.</p>
<p>So I'm thinking of making RETURN "final"...if you give it a rule that doesn't match it returns NULL.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/regarding-the-finality-of-fail-return-etc/1735">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/regarding-the-finality-of-fail-return-etc/1735</link>
          <pubDate>Sun, 03 Oct 2021 15:49:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1735</guid>
          <source url="https://forum.rebol.info/t/regarding-the-finality-of-fail-return-etc/1735.rss">Regarding The &quot;Finality&quot; Of FAIL, RETURN, etc.</source>
        </item>
        <item>
          <title>Should Built-In Constructs Leverage More &quot;Reserved Words&quot;?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>I was looking at an old proposal for using <strong>|</strong> in PRINT to mean "newline".</p>
<pre><code>print [
    "DESCRIPTION:" |
    tab, any [description, "(undocumented)"] |
    tab (uppercase word) {is} classification #"."
]
</code></pre>
<p>That was taken off the table due to <strong>|</strong> being used as an expression barrier.  But COMMA! is doing a much better job of that, so it's back in the realm of possibility.</p>
<p>And I was also looking at some API code in ODBC like this:</p>
<pre><code>rebValue(
    "switch @", ARG(encoding), "[",
        "'utf-8 [", rebI(CHAR_COL_UTF8), "]",
        "'ucs-2 [", rebI(CHAR_COL_UTF16), "]",
        "'utf-16 [", rebI(CHAR_COL_UTF16), "]",
        "'latin-1 [", rebI(CHAR_COL_LATIN1), "]",
    "] else [",
        "fail {ENCODING must be UTF-8, UCS-2, UTF-16, or LATIN-1}"
    "]"
);
</code></pre>
<p>It made me wonder what if SWITCH let you use something like, say, fat arrow:</p>
<pre><code>rebValue(
    "switch @", ARG(encoding), "[",
        "'utf-8 =&gt;", rebI(CHAR_COL_UTF8),
        "'ucs-2 =&gt;", rebI(CHAR_COL_UTF16),
        "'utf-16 =&gt;", rebI(CHAR_COL_UTF16),
        "'latin-1 =&gt;", rebI(CHAR_COL_LATIN1),
    "] else [",
        "fail {ENCODING must be UTF-8, UCS-2, UTF-16, or LATIN-1}"
    "]"
);
</code></pre>
<h2>Are Core Constructs Underplaying Their Hand?</h2>
<p>I've felt for a long time that PRINT is not strong enough, because it hasn't taken things like TAG! away to signal format changes (colors?).</p>
<p>And when I look at the difference we get in SWITCH above, esp in the API, it makes me wonder if something like that is appropriate.  Though maybe the @ symbol is better to be pushed further to this purpose as a legal branch type...</p>
<p>...anyway the details aren't important.  I guess I'm asking more <em>"could we make a better language if we were more willing to steal words"</em>.</p>
<p>Do we need distinctions...such as "core switch" and "rich switch", and then let people pick which they use?  Where they're expected to hack up the switch to customize it to their tastes?</p>
<p>(Just wanted to put this out there, as I'm deleting a note about | as newline in PRINT on the Trello.)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-built-in-constructs-leverage-more-reserved-words/1622">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-built-in-constructs-leverage-more-reserved-words/1622</link>
          <pubDate>Sat, 05 Jun 2021 16:47:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1622</guid>
          <source url="https://forum.rebol.info/t/should-built-in-constructs-leverage-more-reserved-words/1622.rss">Should Built-In Constructs Leverage More &quot;Reserved Words&quot;?</source>
        </item>
        <item>
          <title>Debunking the Arity-1 MAKE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Rebol2, R3-Alpha, and Red embrace the idea of an arity-1 MAKE, that you use for any type.</p>
<p>When a single parameter seems insufficient to create a datatype, it just stuffed the two things into a BLOCK!.  That led to things like this FUNC definition in the bootstrap for R3-Alpha...which is a weird two-step process.  It wants to copy the spec/body in most cases, but the mezzanine optimizes and does not write code in a style that would need to copy the spec/body...so there's a "funco" helper:</p>
<pre><code>funco: make function! [[
    {Non-copying function constructor (optimized for boot).}
    spec [block!] {Help string (opt) followed by arg words}
    body [block!] {The body block of the function}
][
    make function! reduce [spec body]
]]

func: funco [
    {Defines a user function with given spec and body.}
    spec [block!] {Help string (opt) followed by arg words}
    body [block!] {The body block of the function}
][
    make function! copy/deep reduce [spec body]  ; (now it deep copies)
]
</code></pre>
<h2>Is This Just "Make-Work"? (pun intended)</h2>
<p>Imagine a different approach in which FUNC itself is just a native that takes two parameters and makes a function out of it.  There would be several benefits:</p>
<ul>
<li>
<p>You don't need to run a REDUCE to make a block that you're ultimately just going to separate into two blocks.  That's wasted space and computation.  The FUNC passes through the two blocks separately.</p>
</li>
<li>
<p>You avoid looking into a table of MAKE dispatchers, breaking down a block and re-type checking it to make sure it's a block of exactly two other blocks.  The FUNC type checking takes care of that on the independent proeprties.</p>
</li>
<li>
<p>If there's a low-level property such as not copying the blocks passed in, that could be handled by a refinement (/NOCOPY) which makes the distinction clearer in the cases that use it.</p>
</li>
</ul>
<p>Faster, clearer.  No one really uses the "polymorphism" of <strong>make some-type some-definition</strong> without really knowing what type or definition is, right?  That seems essentially meaningless.</p>
<h2>So What Is The Theoretical Value of Arity-1 MAKE?</h2>
<p>I'd assumed that the actual theoretical value was something along the lines of <em>having a serialization form of every type as a BLOCK!</em> (or other simple type)</p>
<p>Perhaps the reasoning went:</p>
<ul>
<li>
<em>if</em> you can <em>create</em> any type from a single argument like a BLOCK!</li>
<li>...then that means you can MOLD any instance of a value into that same representation.</li>
</ul>
<p>So what I did in the early days of Ren-C is I tried to enforce a correspondence between <strong>make function! [...]</strong> and <strong>#[function! [...]]</strong>.  The code that was dispatched by MAKE was the same code that constructing a molded function would call.</p>
<p><em>That was a nice thought, but due to binding, it doesn't actually work.</em>  Basic disproof:</p>
<pre><code>&gt;&gt; obj: make object! [y: 10]

&gt;&gt; f: func [x] bind [x + y] obj

&gt;&gt; y: 100

&gt;&gt; molded: mold f
== "#[action! [[x] [x + y]]]"

&gt;&gt; g: load molded

&gt;&gt; f 1
== 11

&gt;&gt; g 1
== 101
</code></pre>
<p>The only real way to preserve the loaded connections of things is in some kind of binary serialization format (like "redbin" is pursuing)...or to always be storing the session's memory as a persistent VM state (like Smalltalk's Squeak and such).</p>
<h3>...any counter-arguments in defense of the usefulness of Arity-1 Make?</h3>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/debunking-the-arity-1-make/1591">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/debunking-the-arity-1-make/1591</link>
          <pubDate>Fri, 30 Apr 2021 16:54:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1591</guid>
          <source url="https://forum.rebol.info/t/debunking-the-arity-1-make/1591.rss">Debunking the Arity-1 MAKE</source>
        </item>
        <item>
          <title>Weird WORD!s - Allow, But Escape Them?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>My feeling is you should be able to build paths and tuples out of anything that's a valid WORD!.  But is it time we had an escaping mode for "weird words"?</p>
<p>Let's say you didn't want <strong><code>&lt;.&gt;</code></strong> to be a  TAG!, but rather a TUPLE! where the first element was <strong><code>&lt;</code></strong> and the second was <strong><code>&gt;</code></strong>.</p>
<p>We could do something like backquotes:</p>
<pre><code>`&lt;`.`&gt;`
</code></pre>
<p>Having an escaping mode for words would open up more lexical space.  For instance,  I like the idea of allowing $FOO, $(FOO), $FOO/BAR, $[FOO BAR] etc. as another type...</p>
<p>But this would seem to kill off the idea of being able to have <code>$</code> and <code>$$</code> etc. as WORD!s, because you get into ambiguous situations... is $/foo a PATH! with the $ word in the first slot, or an ENV-PATH! with an empty first slot?</p>
<p>These ambiguities create problems for other things that might stand alone all right, because we don't want to have "second-class-citizen" WORD!s that can't appear in paths.</p>
<p>But what if we used backticks if they wind up in paths?</p>
<pre><code>`$`/foo   ; PATH! with $ in the first slot
$/foo  ; ENV-PATH! with blank in the first slot
</code></pre>
<p>This could give us the likes of <code>:</code> and <code>::</code> as operators...</p>
<pre><code>&gt;&gt; `:`: does [print "I am colon!"]

&gt;&gt; :
I am colon!

&gt;&gt; type of :`:`
== #[datatype! action!]
</code></pre>
<p>It could work for other standalone characters, like <strong><code>@</code></strong> and perhaps <strong><code>&amp;</code></strong>.  <strong>%</strong> could be the same (with %"" or %{} used for empty file)</p>
<p>I feel like # and / may not be good candidates for this treatment, it would need more thought.</p>
<p><strong>The point wouldn't be that you'd likely be going crazy with paths involving these characters, but rather that you might want to do interesting things with them standalone.</strong>  It's just to put them on the map as legitimate words.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560</link>
          <pubDate>Mon, 15 Mar 2021 03:30:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1560</guid>
          <source url="https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560.rss">Weird WORD!s - Allow, But Escape Them?</source>
        </item>
        <item>
          <title>Don&#39;t Fear The WORD!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Something Rebol touts as a big advantage is that it hasn't pinned a meaning to any words, so you can use them to mean what you want.</p>
<p>But I frequently have stressed over this, because words have associated costs that are non-trivial.</p>
<h2>Example: The Section Divider: <strong><code>===</code></strong>
</h2>
<p>I thought it would be neat if we could use this to have a Markdown-Like split of headers which just used plain words:</p>
<pre><code>all [
    === STEP WITH JUST WORDS ===

    step1 arg1

    === {STEP WITH STRING, NOT AS PLEASING} ===

    step2 arg2
]
then [
    print "=== is invisible, so it doesn't interfere with things like ALL!"
]
</code></pre>
<p>The idea is that it could be hooked in ways a comment couldn't...to print out messages to know you've reached the step (for instance).</p>
<p>Because I thought it was more pleasing, I designed it to permit words.  === was as a variadic function which would keep looking across its input until it found a === to terminate.</p>
<p><em>(Note: Wanting to reclaim <strong>==</strong> for using as an even briefer way of saying "section" is one of several motivators for cleaning up the use of it for equality)</em></p>
<p>But there are issues that come up from trying to write strings without string delimiters in Redbol.</p>
<p><strong>You have to write LOAD-able syntax.</strong>  Having COMMA! makes it a bit more tolerable, but you can still get in trouble with unusual uses of other characters.</p>
<pre><code>=== Here's a 3rd example; broken! ===
</code></pre>
<p>That's going to not be able to handle <code>3rd</code> in the current system (though <a href="https://forum.rebol.info/t/pack-sequence-type/1503">the PACK! proposal</a> could help here).  Then the semicolon will wind out commenting stuff out.</p>
<p><strong>Meaning of GROUP! is contentious.</strong>  I use a lot of parentheses when I write text, and not mean running code.  But we presumably want a way to get expressions in there:</p>
<p>That might not be a problem if we limit that to GET-GROUP!.</p>
<pre><code>=== DEMO OF VARIATIONS (GROUP EXAMPLE) ===

count-up n 100 [
    === Running Step :(n) ===
    print "This might be a way of doing it?"
]
</code></pre>
<p>Another alternative could be to use blocks for any evaluated portions, since square brackets don't often come up in English writing.</p>
<p><strong>Plenty of Other Questions</strong>... I don't want to tackle them all here, because I'd like to move to the big issue.</p>
<h2>Biggest Issue: Creating Tons Of Stray Bindings</h2>
<p>On the happy side, with LET we are moving into an idea of dynamism in binding so that using a SET-WORD! doesn't get you a local.  That keeps this from throwing in a local definition of PARSE:</p>
<pre><code>foo: function [data] [
    === BEGIN PARSE: It would suck if this overwrote PARSE! ===
    parse data [...]  ; if PARSE: was gathered as local, parse would be unset
]
</code></pre>
<p>Things like this are why I was so adamant against locals gathering.  It's good that it's gone from standard use, and relegated to being a weird feature for code golfing.  LET may be slow right now, but better to be slow than absolutely wrong.  Slow features can be sped up.  Wrong features can only be deleted.</p>
<p>The storage and loading of words themselves is actually pretty efficient.  The system is geared around it.  I'm not terribly concerned about the storage overhead difference between strings and a bunch of words.</p>
<p><strong>What's more troubling is all the bindings made in the user context.</strong>  These words don't know their binding isn't going to be used.  So the user context gets expanded and expanded.</p>
<p>I won't rewrite the explanation of this here.  But see <strong><a href="https://forum.rebol.info/t/the-real-story-about-user-and-lib-contexts/764">The Real Story About User and Lib Contexts</a></strong></p>
<h2>I Think Supporting Words This Way Is Mission Critical</h2>
<p>There are a lot of kneejerk responses which would dislike <strong>===</strong> in the form that I suggest.</p>
<p>Some people wouldn't like that it's variadic.  They might believe the principle of Rebol is based on blocks...so variadic functions shouldn't even be in the language to begin with.  I think they're wrong, and we now depend on variadicness quite a lot.</p>
<p>Others might worry about the overhead caused by bloating up the symbol space...or the length of the code block.  Or the CPU cycles consumed by having to run a variadic loop across the content of the line...one value at a time.</p>
<p><strong>But I think my leaning is that being able to choose to work this way is the distinguishing factor of the language.</strong></p>
<p>You can still use <strong><code>=== {Text} ===</code></strong> if you really want to.  Or you can avoid using === altogether and just use a comment like <strong><code>;===</code></strong> or <strong><code>;;</code></strong> and it won't have any runtime aspects at all...though then you won't get a log when it reaches that line if you want it.</p>
<p>Using bash is making me realize that even as light as Rebol can be a lot of the time, it's still too heavy sometimes.  Having to put things in quotes adds up 2 characters at a time, over time.  We should keep an eye on bending the mechanics to make it possible to use LOAD-ed "Rebol sentences" literally, and find places where that makes sense.</p>
<h2>This Means Binding Has To Be Rethought... More...</h2>
<p>We're just pinning down more of the requirements.  So as those requirements get locked, then hopefully that will make a design "emerge".</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/dont-fear-the-word/1549">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dont-fear-the-word/1549</link>
          <pubDate>Wed, 10 Mar 2021 03:17:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1549</guid>
          <source url="https://forum.rebol.info/t/dont-fear-the-word/1549.rss">Don&#39;t Fear The WORD!</source>
        </item>
        <item>
          <title>Pivotal Design Question: Is Evaluator State Just A Block?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>I ran into a hitch with LET and EVALUATE in single-stepping.</p>
<p>It raises a pretty big question about how much we want to tie the hands of the evaluator in favor of "simplicity".</p>
<h2>The Problem</h2>
<p>On the surface a LET statement might seem impossible for step by step evaluation:</p>
<pre><code>&gt;&gt; block: evaluate [let x: 10 print ["X is" x]]
== [print ["X is" x]]
</code></pre>
<p>That LET statement declared a variable, but where did it go?  It only lives until the block is over.  It would seem that the PRINT is out of luck.</p>
<p><em>But...</em> I could make it work since a BLOCK! can carry along virtual binding state.  So, at each step you just get a little more state added on.  The <strong>[print ["X is x]]</strong> is <em>different</em> from the block you'd have gotten from saying SKIP 3 on the full block, due to this binding.</p>
<p><strong>But what if you reposition the block?</strong></p>
<pre><code>&gt;&gt; block: head block
== [let x: 10 print ["X is" x]]
</code></pre>
<p>Now you have a block that has X defined in its bindings, and if you step through it you'll define it again.</p>
<h2>Can This Be Solved?</h2>
<p>I think the cleanest and clearest way to solve it is to rethink EVALUATE so that it operates on a FRAME!...not a BLOCK!.  This would match the internal model better.</p>
<p>Today, we have to tear down a frame and build up a new one each time you do a step.  This would say that you'd be keeping it alive.</p>
<p>You'd be limited in terms of being able to look back over past values you had already evaluated.  That limitation would keep you from rewinding... if you wanted to go back and do things over, you'd have to do that by working with your original block that started the whole process.</p>
<p>What you'd be able to do in terms of looking ahead would be more like what a variadic is able to do today.</p>
<h2>The Big Philosophical Question</h2>
<p>I guess the big philosophical question is not necessarily so much about LET itself, but <strong>should we rule out the existence of things like LET in general</strong>.</p>
<p>In other words: is it imperative to step the evaluator across a block and <em>not</em> accrue any state particular to that evaluation?</p>
<p>I've been kind of looking for a convergence between things like the evaluator and PARSE, and so asking what the restrictions on the evaluator are may be asking what the restrictions are on anything that tries to leverage the FRAME!-based processing of blocks...for tracking positions, giving errors, etc.  If we require them all to be amnesiacs after every step, this would make it hard to write things like the COLLECT/KEEP feature in parse with the rollback feature...because it would have to record its state in some external thing.</p>
<p><a class="mention" href="/u/rgchris">@rgchris</a> --^ please see that and think about it.  If EVALUATE returned a FRAME! representing the block and not a new position of a block, what kind of disruption would it be?  Do you see the accrual of state in the evaluator to be something that should be ruled out--thus killing off LET or anything like LET--to be worth it to have the feature of a memoryless evaluator?</p>
<hr>
<p><strong>My leaning on this is to say that we would be crippling the language by ruling out LET-like things in the design.</strong></p>
<p>Right now, I have this test code working.  Note it's three evaluation steps, because the LET is actually invisible (1 unit lookahead to see x and add the binding, then leaves <code>x: 10</code> to run normally)</p>
<pre><code>x: &lt;in-user-context&gt;
output: '~unset~
block: evaluate evaluate evaluate [let x: 10 output: x]
did all [
    block = []
    output = 10
    x = &lt;in-user-context&gt;
]
</code></pre>
<p>And when you look at some of the other designs of how this is plugging together, I don't think we should turn back.  It's simply too hard to build abstractions on top of FUNC if the bodies cannot dynamically declare new variables, and I think forcing everyone in those situations to deal with USE is ergonomically just too awkward to feel like the language is living up to its promises.</p>
<p>I don't want to give up on virtual binding and LET when it has come this far.  It may be broken, but its brokenness is already a better kind of broken than what was there before...and there's no proof yet that it can't be made better.</p>
<p>Rebol's M.O. has been throwing imaginative <em>but I want the code to look like THIS</em> at a data structure and see how far that can go...without proof that it can or should work well.  Every now and again I think I should have the right to throw my own bad idea that looks good in there.  And maybe some poor sucker in the future can figure out the limits of how it can be made to seem like it works more.   <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/pivotal-design-question-is-evaluator-state-just-a-block/1496">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/pivotal-design-question-is-evaluator-state-just-a-block/1496</link>
          <pubDate>Tue, 09 Feb 2021 21:25:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1496</guid>
          <source url="https://forum.rebol.info/t/pivotal-design-question-is-evaluator-state-just-a-block/1496.rss">Pivotal Design Question: Is Evaluator State Just A Block?</source>
        </item>
        <item>
          <title>On Wasted Bits</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>In one of my Philadelphia talks, I cited a quote from Paul Graham in <a>The 1,000 Year Language</a></p>
<blockquote>
<p><em>"I learned to program when computer power was scarce. I can remember taking all the spaces out of my Basic programs so they would fit into the memory of a 4K TRS-80. The thought of all this stupendously inefficient software burning up cycles doing the same thing over and over seems kind of gross to me. But I think my intuitions here are wrong. I'm like someone who grew up poor, and can't bear to spend money even for something important, like going to the doctor."</em></p>
<p>...</p>
<p><em>"The desire for speed is so deeply engrained in us, with our puny computers, that it will take a conscious effort to overcome it. In language design, we should be consciously seeking out situations where we can trade efficiency for even the smallest increase in convenience."</em></p>
</blockquote>
<p>I've been struggling some with this fight.  For instance, the scenario of:</p>
<pre><code>count-up x 1000000 [
    let y: x + 1
    print [y]
]
</code></pre>
<p>What I have explored is the question of making LET a dynamic construct.  This dynamism would mean it wouldn't be scanned for in advance (like "FUNCT" looked for SET-WORD!).  It would actually bring a new variable and binding into existence... basically just syntax sugar for if you had written:</p>
<pre><code>count-up x 1000000 [
    use [y] [
        y: x + 1
        print [y]
    ]
]
</code></pre>
<p>It's uncomfortable to induce the thought that you'd be making a new object each time through the loop...an object with one field (y).  That's a million objects being made, that the GC will have to grapple with.</p>
<p>I'm working on making these as small as possible...and the GC will sweep them up.  But people who have seen LET or LET-like constructs from other languages would not generally assume that it would cause so much pain to the GC.  It feels so much more catastrophically worse than creating a single object:</p>
<pre><code>let y
count-up x 1000000 [
    y: x + 1
    print [y]
]
</code></pre>
<p>And if you were using <strong><code>func [... &lt;local&gt; y]</code></strong> that's even more efficient.  It doesn't create a separate object identity at all, but piggy-backs on the frame (where the arguments are already stored).</p>
<p>Of course, we're dealing with an incredibly dumb "mark and sweep the world" GC right now, that only starts cleaning up when it hits a wall.  If we were more clever, I'm sure there could be ways that the GC could localize most LETs and do zoning cleverness...doing light pick-ups of GC objects.</p>
<h2>I May Be Worrying Too Much</h2>
<p>The size of the variable is smaller than the size of the frame created by an addition, e.g. by the <strong>+</strong>.  If someone is at the level of optimizing for the LETs, they'd make a much bigger difference by eliminating the block:</p>
<pre><code>count-up x 1000000 [
    let y: x + 1
    print x
]
</code></pre>
<p><em>(Note: PRINT requires blocks on non-strings, non-newline characters <a href="https://forum.rebol.info/t/limiting-print-to-block-text-perhaps-blank-to-opt-out/855">for a pretty good reason</a>, but I'm just trying to make the point about the relative costs of things.)</em></p>
<p>The creation of FRAME! (e.g. for a BLOCK!) has been optimized to reduce the GC load to just about the minimum that it can, but that minimum is the same minimum as what we're looking at for a LET.  So when the cost of a LET is more or less on the same level as the cost for a GROUP!, how much should we really be asking people to worry about it?</p>
<p>When you think about the forces in play here--the ability to do rearrangements to optimize it if you need to, and Paul Graham's remarks about expressivity being the long tail--I think making LET dynamic is probably the winning bet.</p>
<p>Luddites who don't like it can use <strong><code>&lt;local&gt;</code></strong> and be no worse off.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/on-wasted-bits/1492">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/on-wasted-bits/1492</link>
          <pubDate>Sat, 06 Feb 2021 06:54:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1492</guid>
          <source url="https://forum.rebol.info/t/on-wasted-bits/1492.rss">On Wasted Bits</source>
        </item>
        <item>
          <title>THEN and ELSE are Essential</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>When I was describing the details of <a href="https://forum.rebol.info/t/multiple-returns-and-branching-could-it-unseat-voidification/1408">rigging it so enfix functions could interoperate with multiple retrun values</a>, <a class="mention" href="/u/iarnold">@iArnold</a> responded:</p>
<aside class="quote no-group quote-modified" data-username="iArnold" data-post="3" data-topic="1408" data-full="true">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/iarnold/40/226_2.png" class="avatar"><a href="https://forum.rebol.info/t/multiple-returns-and-branching-could-it-unseat-voidification/1408/3">Multiple Returns and Branching: Could It Unseat Voidification?</a>
</div>
<blockquote>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1408">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/multiple-returns-and-branching-could-it-unseat-voidification/1408/2">Multiple Returns and Branching: Could It Unseat Voidification?</a>
</div>
<blockquote>
<p><strong>But How Does IF Know ELSE Wanted The /BRANCHED Output?</strong><br>
ELSE runs <em>after</em> IF. So it would need to be able to connect its need for a branched output up to IF's parameterization <em>before IF runs</em>. <img src="https://forum.rebol.info/images/emoji/twitter/pleading_face.png?v=9" title=":pleading_face:" class="emoji" alt=":pleading_face:"></p>
</blockquote>
</aside>
<p>This problem was solved in R2. IF knew there was no else and EITHER did.</p>
</blockquote>
</aside>
<p>Rather than just delete and ignore this tangent... I'm moving it here with <a href="https://forum.rebol.info/t/null-blank-void-history-under-scrutiny/1249/4">another remark from Chris</a>:</p>
<aside class="quote no-group" data-username="rgchris" data-post="4" data-topic="1249">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"><a href="https://forum.rebol.info/t/null-blank-void-history-under-scrutiny/1249/4">NULL, BLANK!, VOID!: History Under Scrutiny</a>
</div>
<blockquote>
<p>I should say that as of now, I don't have a favourable opinion of the ELSE/THEN idiom (on a stylistic/comprehension basis) and don't think they're worth the extra complexity alone</p>
</blockquote>
</aside>
<p>Let me respond quickly.</p>
<h2>I Haven't Given Up Making It Not Affect Those Who Don't Use It</h2>
<p>Firstly: You should always have the last resort of using Redbol if you want, and I'm trying my best to make sure every convention is reversible.  Though it's a bit of a hard pill to swallow to dial back large parts of the language a decade, I think it can be done in something of a piecemeal way so that you can revert just the parts you don't like.</p>
<p>Secondly: As the post I made shows, <em>I'm still racking my brain to see what I can do</em>, even if it means pretty crazy evaluator acrobatics.  If my current trick manages to pan out, there will be a generic mechanism for getting more than one value across an enfix call barrier.  It would mean all branches would go back to being "as-is".  But who knows what other doors might open.</p>
<h2>ELSE and THEN are Bigger Than An Alternative To EITHER</h2>
<p>I've demonstrated the synergy between CASE and SWITCH and ELSE and ALSO and THEN.  When you throw invisibles like ELIDE in, you get evaluator combinatorics I have never seen before.  Expressing imperative logic with so many seamless "asides" is going to be a real mind-blower.</p>
<p>This is what makes the language worth paying attention to.  If <em>I'm</em> impressed, then that's a pretty high bar, and so I shouldn't be the last person to feel that way.</p>
<p>(Quite a stronger and more timeless message than "fastest mostly-open-source 32-bit Rebol2 on Earth".)</p>
<h2>Remember The Self-Selection Bias</h2>
<p>If you have been using Rebol for decades, and see no problem with forcing every IF...ELSE to be EITHER, remember this:</p>
<p><strong>you are one of a <em>very, very small minority of people who managed to not be put off by the language</em></strong></p>
<p>Maybe my tastes are "mainstream".  But I don't usually like EITHER.  It might fit in sometimes when I can get everything all on one line.</p>
<p>But since I still use other languages besides Rebol, I haven't forgotten that the straightforward ordinary way can be coherent and nice:</p>
<pre><code> if ((a and b) or (c and d)) { ... } else { ... }
</code></pre>
<p>Which makes you see just how uncomfortable this is:</p>
<pre><code>either any [all [a b] all [c d]] [ ... ] [ ... ]
</code></pre>
<p>I'm more than intelligent enough to understand both.  And with years to consider it, I still prefer the first if those were my only two options.  Though I might like to write that particular one as:</p>
<pre><code>any [a and b, c and d] then [ ... ] else [ ... ]
      ; ^-- I'm considering AND's quoting convention to allow WORD!s on right
</code></pre>
<p>Of course, how you look at it depends on the length of the clauses and what you're going to emphasize.  If you've got enough code to warrant newlines, the ANYs and ALLs start being better propositions.</p>
<p>But on a higher level: if you're advertising <em>"most freeform programming language ever invented"</em>, saying that you <em>"have to write your code in a style you don't like much, because it's Rebolish"</em> is missing the message.</p>
<h2>THEN, ELSE, and ALSO are <a href="https://forum.rebol.info/t/the-canonical-list-of-non-negotiables/1244/4">Non-Negotiables</a> for Me</h2>
<p>I've pointed out before that <a href="https://forum.rebol.info/t/rationalizing-the-illusion-readability-over-writability/397">the illusion of this</a> is what keeps me going:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="397">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/rationalizing-the-illusion-readability-over-writability/397/1">Rationalizing the Illusion: Readability over Writability</a>
</div>
<blockquote>
<p>I think every time we get another one of these illusions under our belt, like <a href="https://trello.com/c/NPivtSdd">ELSE and THEN</a>, the game goes a little further. I'd have quit Rebol a long time ago if these breakthroughs weren't still coming along... each one probably buys one more month of my interest in the area of study</p>
</blockquote>
</aside>
<p>I'd quit if this stuff weren't in the mechanics, because the language wouldn't interest me much.</p>
            <p><small>6 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/then-and-else-are-essential/1411">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/then-and-else-are-essential/1411</link>
          <pubDate>Sat, 21 Nov 2020 13:40:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1411</guid>
          <source url="https://forum.rebol.info/t/then-and-else-are-essential/1411.rss">THEN and ELSE are Essential</source>
        </item>
        <item>
          <title>Brevity in the Box: When Is It Worth It?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>(cc: <a class="mention" href="/u/razetime">@razetime</a>, please let me know if any of this makes sense, or if not what parts don't)</p>
<p>Now that I'm again <a href="https://forum.rebol.info/t/reviving-the-rebmu-dialect/1377">revisiting Rebmu</a>, the familiar pattern of <em>"hey wait, should this be a default language feature?"</em> comes up again.</p>
<h2>A Simple Example Of The Pattern</h2>
<p>Just imagine a shortcut for something like WHILE, where if you give it a WORD! as the condition, it acts as if you put the condition in a block:</p>
<pre><code> x: true
 while 'x [...]
</code></pre>
<p>That's shorter than <strong>while [x] [...]</strong>.  But to get it even shorter, while could <em>quote</em> its first argument.</p>
<pre><code> x: true
 while x [...]  ; doesn't eval X at callsite, so WHILE gets the WORD! itself
</code></pre>
<p>The downside to this is that if the condition is generated by code, you'd have to escape the quoting somehow.  Otherwise <strong>while reduce [some condition] [some body]</strong> would be interpreted expecting REDUCE to be an arity-0 function called each time as the condition check.  Then, the <strong>[some condition]</strong> block would wind up in the body slot.  So <code>[some body]</code> would get inertly discarded as the next expression.</p>
<h2>This Is Harder To Teach</h2>
<p>A new user has a tough time getting their head around the simple question of why IF can't have a BLOCK! around its condition, but WHILE requires one.  It takes a while to instill this "obvious" idea and convince people that it is a design feature vs. a bug.  <em>(<a class="mention" href="/u/razetime">@razetime</a> - it would be a good idea to be able to write out--in your own words--why Rebol's IF doesn't take a BLOCK! as its condition, but WHILE needs it.)</em></p>
<p>Though changing the convention would have its share of surprises, this isn't to say that the current behavior doesn't have its own confusing possibilities.  With evaluative conditions, you could leave the block off on accident and if it <em>incidentally</em> was a block, you could run something as code:</p>
<pre><code> data: [[print "formatting hard drive"] [print "sorting MP3 collection"]]

 x: first data
 while x [...]   ; imagine they meant to say `while [x] [...]`
</code></pre>
<p>You can still make mistakes under today's semantics, as the code above shows.  It can be argued that the mistake is more consistent, as the argument is simply being evaluated like that of APPEND or other primitives.  Though that consistency doesn't magically mean it's any less confusing.</p>
<h2>Might Quoting-but-Erroring Provide a Smooth Continuum?</h2>
<p>Continuing to consider this example, we might imagine that it quotes the condition argument in the default implementation <em>but refuses to run anything but BLOCK! and GROUP!</em>  This would pave the way for compatibility with code that gave meaning to the quoted case.</p>
<pre><code> import &lt;core&gt;  ; imagine this is how you get the default definitions

 x: true
 while x [...]  ; !!! Error, WORD! not accepted as argument
 while 'x [...]  ; maybe this would be okay vs. `while [x]`, though?
</code></pre>
<p>Then if you did some kind of expert mode import, it would become more lax</p>
<pre><code> import &lt;core&gt;/lax   ; let's say you can provide switches to IMPORT

 x: true
 while x [...]  ; let's say lax meant this acts as `while [x]`
</code></pre>
<p>This might be reasonable.  And it may provide an answer to the issues I bring up in <a href="https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359">"Speaking with Tics"</a>.  Maybe a strict mode makes you say <strong>for-each 'x [...]</strong> and <strong>'type of x</strong> and then there's a wholesale switch on arguments that lets you dodge quoting.</p>
<h2>Another Example: DOES</h2>
<p>Today's DOES is actually taken from Rebmu, because it lets you avoid putting the body of the DOES in an outermost block:</p>
<pre><code> &gt;&gt; old-way: does [print "Hello"]
 &gt;&gt; old-way
 Hello

 &gt;&gt; new-way: does print "Hello"
 &gt;&gt; new-way
 Hello
</code></pre>
<p>I thought this was cool enough to adopt.  But this has that characteristic pattern of needing escaping when the body is generated from code:</p>
<pre><code> rebol2&gt;&gt; old-way: does reverse ["Different" print]  ; reversal is body
 rebol2&gt;&gt; old-way
 Different  ; printed

 &gt;&gt; new-way: does reverse ["Different" print]  ; specializes REVERSE
 &gt;&gt; new-way
 == [print "Different"]  ; block value, reversed each time
 &gt;&gt; new-way
 == ["Different" print]  ; it's the same block, so doubly-reversed now

 &gt;&gt; new-compatible: does :(reverse ["Different" print])  ; reversal as body
 &gt;&gt; new-compatible
 Different  ; printed
</code></pre>
<blockquote>
<p>Note that the DOES handling for GROUP! isn't escaped so you have to use <strong>:(reverse ["Different" print])</strong>.  Whether we think this needs fixing or not depends on if we decide that <strong>does (...)</strong> has an interesting unique meaning, e.g. <strong>does (elide print "vanishes")</strong> would be invisible while <strong>does [elide print "vanishes"]</strong> would be void.  In other words, <strong>does (x)</strong> is currently acting as <strong>do '(x)</strong> would, while <strong>does :(x)</strong> is acting like <strong>do x</strong>.  I'm not 100% sure either way right now.</p>
</blockquote>
<p><em>This feels like something positive to have in the box as a default, as opposed to just being a fringe Rebmu-ism.</em>  Especially because DOES lacks a RETURN statement, isn't it nice to be able to say:</p>
<pre><code> helper: does catch [
      if condition [throw 10]
      throw 20
 ]

 ; Compare with...

 helper: does [catch [
      if condition [throw 10]
      throw 20
 ]]
</code></pre>
<p>But notice the implication here gets to where DOES needs to be variadic.  The mechanic of doing something along the lines of <a href="https://forum.rebol.info/t/looking-into-a-usermode-pointfree/1236">POINTFREE</a> for a parameter is something that's a pain to have to rewrite every time, and it means the argument is harder to fill with in FRAME!s with specializations.  That suggests it should probably be a parameter convention in its own right.  :-/</p>
<h2>How Far Should This Go?</h2>
<p>Much like the points I raise in "Speaking With Tics" regarding shorthand, it's hard to say.</p>
<p>DOES is a pretty good poster child for the question.  A reasonable hedging strategy might be to reserve the right to make DOES be "clever" in the future by quoting its argument, but disallowing WORD!s for now.  So if you produce the thing-to-do with code, you have to put that code in a GET-GROUP! as <strong>does :(...)</strong>.</p>
<p>But I have mixed feelings about extending this approach places.  If you want to do some pre-binding on a function body, do you want to have to write:</p>
<pre><code> func [...] :(in some-context [
     ...
 ])
</code></pre>
<p>Or is it too "Rebol-like" to have these meta-coding experiments not need parentheses:</p>
<pre><code> func [...] in some-context [
     ...
 ]
</code></pre>
<p>Key to the question under debate is if it would be more common for people to want to write:</p>
<pre><code> func [...] case [
     ...
 ]
</code></pre>
<p>...insead of:</p>
<pre><code> func [...] [
     case [
         ...
     ]
 ]
</code></pre>
<p><strong>When Rebmu is considered, meta-coding is the rarer need, so that seems to favor optimizing out the brackets in the non-meta cases and paying for the group in the meta case.</strong>  But clearly the mechanics get weird.  As an example, think about:</p>
<pre><code> func [x] if x [
     ...
 ]
</code></pre>
<p>For that to be equivalent to <strong>func [x] [if x [...]]</strong>, <em>the variadic expression needs to bind into the spec</em>.  So that X can't be specialized as whatever it was in the enclosing context.  So a magic parameter convention which was willing to specialize the body as an ACTION! couldn't be used, as it would need to be informed by the binding logic of FUNC itself.  This points to an advantage of getting things in blocks.</p>
<h2>Lowest Common Denominator In Box, Then Let Users Decide?</h2>
<p>Imagine we say that a function body can be only two things, a BLOCK! or a GET-GROUP!.</p>
<p>That could be the standard that you encourage to work for any variant of FUNC/FUNCTION.  But beyond that, each module could pick its conventions...or even change conventions on an impromptu basis (per class, per function, or per scope-in-function even).</p>
<p>One convention might say:</p>
<pre><code>func [x] reverse [...]  =&gt;  func [x] :(reverse [...])   ; reversed block is body
</code></pre>
<p>Another convention might say:</p>
<pre><code>func [x] reverse [y]  =&gt;  func [x] [reverse [...]]   ; reverse upon invocation
</code></pre>
<p>Restricting to [...] and :(...) by default doesn't seem too terribly antagonistic.  The policy needs a name, something like <em><strong>"the baseline block rule"</strong></em>.  Then focus on facilities for easily customizing local definitions of things like FUNC or WHILE to be more creative, instead of trying to prescribe the shape of that creativity in the natives themselves.</p>
<p>One advantage of a baseline block proposal is better learnability for new users.  Recall the example I gave up top about WHILE working "incidentally" because the value you forgot to put in a block turned out to just happen to evaluate to a block:</p>
<pre><code> data: [[print "formatting hard drive"] [print "sorting MP3 collection"]]

 x: first data
 while x [...]   ; imagine they meant to say `while [x] [...]`
</code></pre>
<p>But with baseline block, that'd be an error.  They'd have to clarify it as either <strong>while [x]</strong> or <strong>while :(x)</strong>.</p>
<p>Then we focus on figuring out how to make it easier and easier for people to bend this when they get new ideas.  Maybe <strong>while 7 =&gt; (x q) [body]</strong> signals something of interest to a budding language designer, and they want to build a detection pattern for INTEGER! =&gt; GROUP! that applies in while conditions only... but they'd like all their normal whiles to keep working.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=9" title=":man_shrugging:" class="emoji" alt=":man_shrugging:"></p>
<p>This way, the golfing adaptations become just a sample of the kinds of adaptations you might choose.  And if you liked the Rebmu choices at a conceptual level, you could import those without having to also adopt all the short names as well.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/brevity-in-the-box-when-is-it-worth-it/1380">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/brevity-in-the-box-when-is-it-worth-it/1380</link>
          <pubDate>Mon, 02 Nov 2020 03:09:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1380</guid>
          <source url="https://forum.rebol.info/t/brevity-in-the-box-when-is-it-worth-it/1380.rss">Brevity in the Box: When Is It Worth It?</source>
        </item>
        <item>
          <title>Speaking With Tics: Should Quoted Arguments Always Be Apostrophe&#39;d?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>In the past it has been discussed whether it is better or worse to have quoted things be apostrophe'd.</p>
<p>Historical Rebol actively prohibits the use of a lit-word! with FOREACH for the loop variable:</p>
<pre><code>&gt;&gt; foreach 'x [1 2 3] [print [x]]
** Script Error: foreach expected word argument of type: get-word word block
</code></pre>
<p>R3-Alpha and Red don't allow it either.</p>
<p>But it might seem you'd want to be able to do this in Ren-C...because there are quoting constructs that can quote backwards:</p>
<pre><code>&gt;&gt; backquote: enfixed func [:x] [print ["I backquoted" x]]
== make action! [[:x] [...]]

&gt;&gt; foo: backquote
I backquoted foo:
</code></pre>
<p>So if you try <code>for-each foo</code>, the backwards-quoting FOO would get the FOR-EACH before the forwards-quoting FOR-EACH could get the FOO.  That's just the order that the evaluator works in <em>(unless there's nothing to the right of FOO, which is the exception that would allow HELP FOO to work)</em>.</p>
<p>You can work around that with:</p>
<pre><code>for-each ('foo) [1 2 3] [print [x]]
</code></pre>
<p>But it seems like it would be nicer if you could write it without the parentheses.</p>
<h2>Should All Quoting Sites <em>REQUIRE</em> Quoted Input?</h2>
<p>The quoted parameter convention exists to save you the trouble of quoting the callsites. <em>If this isn't what that's for, then what <strong>is</strong> it for?</em></p>
<p>I'd be happy to buck the status quo if I thought it were clearly wrong.  But when we look across the board we see how nice and fluent <strong>type of foo</strong> looks vs. <strong>'type of foo</strong>.  Over time it gets internalized to the point that <strong>type: type of foo</strong> doesn't feel weird at all (thought it might look so when you see it the first time).</p>
<p>While there's something to be said for the educational value of seeing when a word is being used by name vs. by value, it's just... "uglier"</p>
<pre><code>type: 'type of foo
</code></pre>
<p>We seem lose something about knowing the "rules of OF" and the parts of speech involved by context, in order to add a bit of visual noise.  To my tastes, it seems this is not in the same "clear win" zone over <code>type-of</code> and <code>type?</code> that we were in before.</p>
<p>It seems to me a core experimental theory in the language is that there is value in allowing acclimations in our mind to writing things that "start looking natural" even if they don't follow systemic rules.  That speedbump of typing <strong>type of x</strong> of hitting the apostrophe key, as well as the visual jarringness, suggests it's a place to take advantage of not quoting <em>when it's possible</em>.</p>
<h2>Should All Quoting Sites Merely <em>PERMIT</em> Quoted Input?</h2>
<p>I mentioned that the current workaround for slipping past cases of things like backquoting operators is to use a GROUP!.</p>
<pre><code>for-each ('foo) [1 2 3] [print [x]]
</code></pre>
<p>We might ask if the operation with the quoting slot should be lenient and let you just alternately write:</p>
<pre><code>for-each 'foo [1 2 3] [print [x]]
</code></pre>
<p>Quoted words won't dispatch functions, so you don't have to worry about FOO's associated behavior if you do this.</p>
<p>A problem with being lenient in that way is that now the function spec is expanded to where it has to accept either WORD! -or- QUOTED! in its quoted slot.  That complicates things, and now the author of the quoting function needs to be bothered with the quote-or-not of their argument.</p>
<p>If you take the easy-way-out and just DEQUOTE your argument (which leaves it as is if it's not quoted), then you may be permitting things with arbitrary numbers of quotes.</p>
<pre><code>for-each '''''''''foo [1 2 3] [print [x]]
</code></pre>
<p>I'm pretty sure UNQUOTE should require its argument to be quoted, for the sake of sanity.  So the implementation of functions like FOR-EACH would get hairier if they were to have to check and preprocess their arguments, e.g. to permit one-and-only one level of quote that they strip off.  This could be made easier with some helper for the purpose, though.</p>
<h2>A Benefit To Requiring Quotes</h2>
<p>I've mentioned in the past that for things like FOR-EACH, if we <em>required</em> the first argument to be quoted then there could be a special interpretation for when there wasn't a quote.  e.g. just run a function without naming a variable:</p>
<pre><code>&gt;&gt; for-each ["No" "Variable"] :print
No
Variable
</code></pre>
<p>This keeps you from having to write something like:</p>
<pre><code>for-each _ ["No" "Variable"] :print
</code></pre>
<p>A plain function declaration isn't particularly interesting in this form, even with a lambda it's wordier (and symboly-er) than the old-style without:</p>
<pre><code>for-each [1 2 3] x -&gt; [print [x]]
</code></pre>
<p>But when you bring in something like <a href="https://forum.rebol.info/t/looking-into-a-usermode-pointfree/1236">"POINTFREE"</a> it gets more interesting:</p>
<pre><code>&gt;&gt; block: [a b c]

&gt;&gt; for-each [1 2 3] (&lt;- append block)

&gt;&gt; block
== [a b c 1 2 3]
</code></pre>
<p>With the idea that <strong>#</strong> is legal, it might look better if you "opt-in" to the variables:</p>
<pre><code>for-each # [1 2 3] (&lt;- append block)
</code></pre>
<p>This would let you do a template for what you want and don't want passed to your function.</p>
<pre><code>&gt;&gt; block: [a b c]

&gt;&gt; for-each [# _] [1 2 3 4] (&lt;- append block)

&gt;&gt; block
== [a b c 1 3]
</code></pre>
<p>This allows us to justify why the variable slot has usefulness even if we're not using a variable.  Maybe that's the answer.  And if we shorten FOR-EACH to simply EACH it would come out cleaner, even in complex invocations:</p>
<pre><code>each [# _] [1 2 3 4] (&lt;- append block)
</code></pre>
<h2>Switch to <code>#</code> for opt-in on variables, allow (but don't require) QUOTED! ?</h2>
<p>...is this a plan?  Does it cover all the angles?</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359</link>
          <pubDate>Wed, 07 Oct 2020 19:32:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1359</guid>
          <source url="https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359.rss">Speaking With Tics: Should Quoted Arguments Always Be Apostrophe&#39;d?</source>
        </item>
        <item>
          <title>Embracing Dialected TUPLE! and PATH!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>I've talked about the idea of <strong><a href="https://forum.rebol.info/t/brave-switch-new-world-skippable-predicates/1045">using TUPLE! for "predicates"</a></strong>.  The specific concept that I had would be that the elements of the tuple would represent the function calls in the order you'd write them:</p>
<pre><code>&gt;&gt; any .even? [1 3 7 10 13]  ; parallel to `even? 1`, `even? 3`...
== 10

&gt;&gt; all .not.odd? [2 4 6 8]  ; parallel to `not odd? 2`, `not odd? 4`...
== 8
</code></pre>
<p>But I've also been arguing for dots having meaning in ordinary PATH! dispatch, e.g. when not having a leading blank.  In that case, I'd said things like <em>"functions wouldn't be on the left side of a dot"</em>.  But that's a whole different purpose.</p>
<p>Put these two together in the same line, and you might wind up looking at code like:</p>
<pre><code> &gt;&gt; obj: make object! [data: [2 4 6 8]]

 &gt;&gt; all .not.odd? obj.data.
 == 8
</code></pre>
<ul>
<li>
<p>The BLANK!-headed TUPLE! <strong><code>.not.odd?</code></strong> matched the skippable parameter type constraint for "PREDICATE!", and is interpreted as <strong>chain [:odd? | :not]</strong> ...or <strong>(-&gt; not odd?)</strong> if you are using <a href="https://forum.rebol.info/t/looking-into-a-usermode-pointfree/1236">POINTFREE</a></p>
</li>
<li>
<p><code>obj.data.</code> was interpreted as a non-blank-headed tuple, so it's the argument...and the terminal dot indicates the caller wanted to ensures that obj.data isn't a function .</p>
</li>
</ul>
<h2>Is this <em>bad</em>?</h2>
<p>If TUPLE! were always inert (as in the original proposal) you'd never see things like that, you'd only see:</p>
<pre><code>&gt;&gt; all .not.odd? obj/data
== 8
</code></pre>
<p>But I'm now fairly sold on TUPLE! for member selection (looks good) and the terminal dot to say "don't execute" is really promising.</p>
<p>I'll point out that there are ways to avoid the particular juxtaposition of tuples if it bothered you:</p>
<pre><code>&gt;&gt; all .not.odd? pick obj 'data
== 8

&gt;&gt; all/predicate obj.data. (-&gt; not odd?)
== 8

&gt;&gt; apply 'all [obj.data. /predicate func [x] [not odd? x]]  ; syntax pending
== 8
</code></pre>
<p>So a lot of ways to attack it.  And these are advanced features, so you can imagine people writing quite a lot of code without ever doing this kind of thing.</p>
<p>But the bigger philosophical question is about entering the era where TUPLE! and PATH! become candidates for multiple dialected meanings.  Is <em>that</em> good or bad?</p>
<h2>Dialecting ANY-SEQUENCE! Is Good (in the spirit of the "game")</h2>
<p>We don't really have problems when a BLOCK! of code contains PARSE instructions vs. being executed by DO.  So why should different purposes for TUPLE! be considered strange?</p>
<p>Having the parts be robust enough to want to use creatively is a good thing.  I think it's just new, and figuring out what to do with that newness will likely take some time.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/embracing-dialected-tuple-and-path/1355">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/embracing-dialected-tuple-and-path/1355</link>
          <pubDate>Sun, 04 Oct 2020 06:26:55 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1355</guid>
          <source url="https://forum.rebol.info/t/embracing-dialected-tuple-and-path/1355.rss">Embracing Dialected TUPLE! and PATH!</source>
        </item>
        <item>
          <title>Const Parameters By Default?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>I've been tinkering around with Rust this past week.  It's an interesting language that tries to blend together best practices of C++ as things that are compiler-enforced...and inherits some Haskell for good measure.</p>
<p>It's gotten me back to thinking about how basic choices make a big difference.  And I feel like <code>const</code> parameters may make a good logical default.  As it stands, people have to annotate functions to say <code>(modifies)</code> in a  comment.  Wouldn't it be better if you didn't get mutability unless you asked for it?</p>
<p>There could be a compromise for quick-and-dirty functions that if you don't annotate a parameter, then you get things mutable:</p>
<pre><code> data: [a b c]

 quick: func [blk] [append blk #quick]
 
 &gt;&gt; quick data
 == [a b c #quick]

 not-quick: func [blk [block!]] [
     append blk {You had time to write BLOCK!, why not &lt;mutable&gt; BLOCK!}
 ]

&gt;&gt; not-quick data
** Error: blk is `const`, mark parameters `&lt;mutable&gt;` or see MUTABLE

modifier: func [blk [&lt;mutable&gt; block!]] [
    append blk {Would &lt;mut&gt; be better?}
]

&gt;&gt; modifier data
== [a b c #quick {Would &lt;mut&gt; be better?}]

&gt;&gt; modifier const data
** Error: modifier wants its blk parameter to be mutable
</code></pre>
<p><em>(I have a little bit of a feeling of deja-vu writing this, so I've probably suggested it before.)</em></p>
<p>Anyway, it seems to me that looking around the language landscape, these kinds of small gestures of control are the least we can do.  It would be better in the HELP to see when something modifies, and having it enforced from the beginning would be nice.  Note that with BigNum, INTEGER! will be a type that can end up mutable...and it seems like stopping people from writing to integers you pass to routines by default is desirable.</p>
<p><strong>of course, questions come up</strong>, e.g. for mixed needs of parameters.  If you take a TEXT! or a BLOCK!, but only the BLOCK! is handled as mutable, what option should you use?  Someone might have a read-only text and want to call your routine.</p>
<p>A cop-out would be to have some kind of <code>&lt;mixed&gt;</code> or <code>&lt;as-is&gt;</code> annotation that basically doesn't do checks for mutability or constness, and leaves it up to the routine.  Not a great answer, but I don't know how often such a circumstance would come up.  This could be a near-term option that would evolve into a better solution at some point.</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/const-parameters-by-default/1328">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/const-parameters-by-default/1328</link>
          <pubDate>Tue, 15 Sep 2020 04:09:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1328</guid>
          <source url="https://forum.rebol.info/t/const-parameters-by-default/1328.rss">Const Parameters By Default?</source>
        </item>
        <item>
          <title>Modifying While Iterating: Crash, Nonsense, Predictable, or Illegal?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Every imperative language has the problem of when you modify a data structure, you run the risk of confusing other code that is looking at that data structure at the same time.  Whether it's threads competing for access, or just a loop whose body modifies the data being looped over...the problem comes up.</p>
<p>The options for dealing with it are:</p>
<ul>
<li>
<p><strong>Crash</strong> - You can just crash.  R3-Alpha had this in several places--for instance PARSE, where a <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/u-parse.c#L658" rel="nofollow noopener">data pointer (REBVAL*) into the rules series</a> was incremented along the rules...even though code was permitted to change the rules as you went (via GROUP!s).  The rule series might grow and be retargeted at a larger memory block, leaving the old pointer recycled and invalid.</p>
</li>
<li>
<p><strong>Nonsense</strong> - You can make the iteration never crash, but be protected in such a way that it does <em>something</em> to avoid crashing.  Basically this means you modify only in ways that can be checked by iterations.  However, this means additional checking must run in the iterations to make sure it picks up on the signal that something has changed.  For instance: in the PARSE example above there could be a check of the length and a re-fetch of the pointer by index; if the length is out of bounds, it could error.  If still in bounds--even if between rules--it could take a shot at keeping running, and just fail as if the nonsense had been how it were written all along.</p>
</li>
<li>
<p><strong>Predictable</strong> - Some languages offer guarantees about what kind of modifications are safe, and which ones are not.  For instance it may say if you are iterating a map, then anything you remove that you haven't visited yet won't be seen...or if you insert then anything you add won't cause something already visited to be seen again.  They might tell you explicitly when all bets are off--and say the effects may vary, or even if they may crash.  (C++ has container guarantees, and things outside the guarantees may crash.)</p>
</li>
<li>
<p><strong>Illegal</strong> - This has been Ren-C's strategy so far...to simply say you cannot modify things that are being iterated.  Some routines (like FOR-NEXT) aren't considered to be iterating, because they are just running NEXT on a variable each time, and so have the same between loop invariants as if you did it yourself.</p>
</li>
</ul>
<hr>
<p>It's likely that most people agree that crashing is not a good choice.  <a href="https://wiki.python.org/moin/CrashingPython" rel="nofollow noopener">Python says</a>:</p>
<p><em>"I'm not saying it's uncrashable. I'm saying that if you crash it, it's a bug unless proven harebrained."</em></p>
<p>So what they get are exceptions, e.g.:</p>
<pre><code>my_list = [1,2,3,4,5,6,7,8,9] 
for i in range(len(my_list)): 
    if my_list[i] == 8: 
        del my_list[i] 

 IndexError: list index out of range
</code></pre>
<p>Rebol (and Red's) history seems to aspire to <em>non-crashing Nonsense</em>.  There's not a lot of emphasis on what the promised invariants are, but they give lip service to the idea of "crashing is bad".  So if you point out a crash, a patch is made at that point based on some testable property (index out of bounds, etc.) and a non-crashing behavior is picked.  Repeat as crashes are discovered.</p>
<p><em>I've felt like illegal has worked out pretty well for Ren-C</em>.  It's conservative...but the general rule of thumb is that modification during iteration is a so-called "code smell".  You can always do it another way.  And if this ever became a real performance problem, a dedicated native that caters to a certain explicit stylized modification could optimize for that particular case (e.g. REMOVE-EACH).</p>
<p><strong>But stackless introduces a problem for locking series: it means locks are no longer necessarily taken in a stack-like manner, so locking cannot be done via a single bit.</strong></p>
<p>Previously series had a single bit on them... SERIES_INFO_HOLD.  This bit is in the same bitflag set as other sources of read-only-ness, such as SERIES_INFO_PROTECTED (can be turned on and off) and SERIES_INFO_FROZEN (permanently immutable).  So all three could be conveniently checked in one masking operation on modification.</p>
<p>What would happen in an operation that wanted to take a hold is that it would look to see if the series already had SERIES_INFO_HOLD.  If so, it would do nothing.  If not, it would set a flag on itself to say that it took a hold it needed to release...and release when it was done.</p>
<p><em>This does not work in a stackless model.</em>  A sort of minimum would be that the series would need to have a lock count that was incremented and decremented.  The miserly design for series does not currently have space to put that in the series node.  Something will have to grow, somewhere.</p>
<hr>
<p>Python's approach seems to please people enough...with questions on Stack Overflow about modifying while iterating having people say "avoid it".  They don't have locks, and the code just does what it does.</p>
<p><strong>This is a deeper question for Rebol than for Python, because the locking questions apply to source code itself (source blocks, parse rules, etc.)...not just user data structures.</strong></p>
<p>I hate to give up putting iterative holds on series, and letting chaos win.  We wouldn't want that in our filesystems, why allow it in programming languages?  The problem of releasing locks is something I think that the <a href="https://forum.rebol.info/t/module-startup-and-shutdown-constructors-destructors/960/4">DEFER</a> mechanism can probably handle pretty well.</p>
<p>I've been thinking about some hybrid approaches which use a bit if it's sufficient, but only break out into a locking table if there's more than one iterator.  Build options could decide: no locks (allow crashes), cheap locks (reference counts), heavy locks (be able to tell you which frame took the lock).</p>
<p>I'll probably give an enhanced locking method a shot, and stay the course on prohibiting modification during iteration (unless using an iterator that specifically accounts for that).</p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/modifying-while-iterating-crash-nonsense-predictable-or-illegal/1317">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/modifying-while-iterating-crash-nonsense-predictable-or-illegal/1317</link>
          <pubDate>Thu, 06 Aug 2020 22:30:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1317</guid>
          <source url="https://forum.rebol.info/t/modifying-while-iterating-crash-nonsense-predictable-or-illegal/1317.rss">Modifying While Iterating: Crash, Nonsense, Predictable, or Illegal?</source>
        </item>
        <item>
          <title>&quot;Finding the Invariant&quot; - Case Study: TO</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>I was trying to make some fairly generic routines that would accept either a WORD!, a TEXT!, a CHAR!, or an INTEGER!.  Then it would give you either a WORD! or an INTEGER! out.</p>
<p>At some point I ran up against this:</p>
<pre><code>&gt;&gt; to integer! "1"
== 1

&gt;&gt; to integer! #"1"  ; I wanted 1...
== 49  ; ..but I got a codepoint (the ASCII value for 1)
</code></pre>
<p>That is the status quo.  But I thought to compare this with another possibility:</p>
<pre><code>&gt;&gt; to integer! "1"
== 1

&gt;&gt; to integer! #"1"
== 1

&gt;&gt; codepoint of #"1"
== 49
</code></pre>
<p>With this, you could imagine putting a TEXT! or a CHAR! in as input to <code>to integer!</code>...not knowing which type of input you had...yet either way get a result that had some kind of consistent representational meaning.</p>
<p>But the status quo is unlikely to ever have a useful invariant like that.  Even just considering these two cases, TO INTEGER! becomes a bizarre operation.  If it had a name it would be something like <strong>convert-decimal-string-to-integer-value-unless-char-in-which-case-codepoint</strong>.</p>
<p>No one wants that operation.  So of course you see it used in cases where people already know which they have... something like <strong>to integer! my-string</strong> or  <strong>to integer! my char!</strong>.  All that's happening is that the short word TO is being leveraged to get a frequently used integer property.</p>
<p>Yet it's not even that "short" when you have to add a type onto it.  As I point out with CODEPOINT OF, might there be clearer ways to say that at little or no extra cost?</p>
<pre><code> TO INTEGER!
 CODEPOINT OF  ; just one character longer... and more explanatory
</code></pre>
<p>If you take a look at <a href="https://forum.rebol.info/t/binary-dialected-encoding-decoding-instead-of-to-conversions/1270">what a difference ENBIN and DEBIN are making</a> vs. trying to pick arbitrary TO conversions, I think it tells a similar story.</p>
<p>So might the TO conversions be studied in such a way that there's some actual chance that accepting multiple types as input could be an asset instead of a liability?</p>
<p>I think this case of TO INTEGER! of #"1" is a good talking point for that.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/finding-the-invariant-case-study-to/1308">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/finding-the-invariant-case-study-to/1308</link>
          <pubDate>Fri, 24 Jul 2020 00:49:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1308</guid>
          <source url="https://forum.rebol.info/t/finding-the-invariant-case-study-to/1308.rss">&quot;Finding the Invariant&quot; - Case Study: TO</source>
        </item>
        <item>
          <title>Semantic Limits of Eliminating Redundancy via Specialization</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>R3-Alpha had a lot of redundant code.  If you said <strong>clear series</strong> you were effectively doing the same thing as <strong>change/part series tail series</strong>.   And if you said <strong>remove/part series 4</strong> you were doing the same thing as <strong>change/part series [] 4</strong>.</p>
<p><em>(Note: today the latter could also be said more "obviously" as <strong>change/part series null 4</strong>)</em></p>
<p>When you have redundant code, slightly different things happen on each path.  It makes it harder to test, and it means any optimizations you apply don't get applied evenly.  For instance: CLEAR would reset a series's "bias", but a REMOVE or CHANGE that effectively emptied a series also, would not.</p>
<h2>I tried redefining REMOVE + CLEAR in terms of CHANGE, but...</h2>
<p>...when I did try it, this pointed out some problems with the idea of taking narrower operations and trying to define them in more general ones.</p>
<p>As an example: <a href="https://forum.rebol.info/t/partial-specialization-syntax-in-a-null-refinement-world/1266">using the null-specialization hack I described</a>, <strong>I tried defining CLEAR to be CHANGE to NULL with a /PART that is the TAIL of the input</strong>.  Yet that doesn't work for MAP!, because it doesn't have a notion of position to get the tail from.  Similar problems exist for types like BITSET!, and operations like REMOVE when defined in terms of CHANGE.</p>
<p>It's possible to shuffle things around so that these types only support CHANGE with no /PART and assume you mean "change everything".  But that's fairly inconsistent.</p>
<p>We wind up saying: <em>Some things can be "cleared", but cannot be "changed".</em>  It gets shaky, because these words are being reused and applied to things that do not obey a common "series interface".</p>
<p>If sharing can be achieved in such an environment, it seems like there needs to be some kind of decision tree of fallbacks.  e.g. CLEAR could try to be understood by a datatype directly, and if it doesn't know how to do that (or lacks a specific optimization for it) then it would see if CHANGE to NULL was available.  Or you could tie the CLEAR to CHANGE translations to being an operation common on ANY-SERIES!, with other types hooking in differently.</p>
<p>I really don't know.  What I do know is that it looks pretty complicated and we don't have great answers at the moment.  On the other hand: it's nice that specialization is working and I can try things like this, but it doesn't feel like enough questions are answered yet about the bigger semantic model of how these generics work.</p>
<p><em>(If you missed my post on user-defined types and related issues, e.g. how ADD currently tries to "generalize" but fails, see <a href="https://forum.rebol.info/t/user-defined-type-scenarios-solicited/1253">User-Defined-Type Scenarios Solicited</a>)</em></p>
<p><strong>So I'm backing off on the shared specialization attempt for the moment.</strong>  It's good experience, and every time we try it we get to see how well SPECIALIZE is holding up, etc.  But not the most important thing to be doing right now, and I've already failed at one other thing I tried today... so... time to do something more feel-good.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/semantic-limits-of-eliminating-redundancy-via-specialization/1267">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/semantic-limits-of-eliminating-redundancy-via-specialization/1267</link>
          <pubDate>Wed, 04 Mar 2020 19:32:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1267</guid>
          <source url="https://forum.rebol.info/t/semantic-limits-of-eliminating-redundancy-via-specialization/1267.rss">Semantic Limits of Eliminating Redundancy via Specialization</source>
        </item>
        <item>
          <title>Fight for the Future: How DELINE will save us from CR LF</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>An early idea that seems to have been in Rebol's "easy cross-platform vision" was the desire to simplify strings in the language to have a single codepoint to represent line breaks.  This had been the standard for Unix machines for some time, and when Apple went to a unix basis for OS X they adopted it too.</p>
<p>... <em>but</em> to try and be a good citizen, Rebol didn't want to do this at the cost of bucking the trend on Windows...where files on disk had two-byte "CR LF" sequences.  Despite most every programmer's editor being able to handle plain LF on Windows for decades, the rigid holdout of NOTEPAD.EXE would continue to make such files render with everything on one line.</p>
<p>(How did NOTEPAD.EXE become so powerful?  <a href="http://blog.hostilefork.com/death-to-carriage-return/" rel="nofollow noopener">It's a good question--read some modern opinions.</a>)</p>
<p><strong>The good instinct here was that a single codepoint is a reduced complexity situation.</strong>  Whether it's a PARSE rule or any other code that does string manipulation, that single codepoint for the idea of a line break is way easier to look for and manage.</p>
<p><strong>But it's not 1997 anymore (and it never should have been, at least in this respect).</strong>  Having carriage returns in your files is an artifact of history.  The untold man-hours lost by developers trying to appease NOTEPAD.EXE were wasted--and it's one of those cases where people should have been firm and standardized on LF.  So while you're getting those old files upgraded to UTF-8 and out of whatever <a href="https://en.wikipedia.org/wiki/Code_page_866" rel="nofollow noopener">codepage 866</a> or formats with <a href="https://en.wikipedia.org/wiki/Byte_order_mark" rel="nofollow noopener">byte-order-marks</a> you have... <em>lose the CRs too</em>.</p>
<p><strong>The fact is that when the interpreter core attempts to be magical about this it becomes a mess.</strong>  Low-level C stops being able to assume it can work with strings directly--with the actual bytes that are in them--to having to make copies or move memory around to remove the things you don't want to be there.  You wind up entangled in questions of what to do if you see [CR CR LF] or [LF CR].  And when you start mutating the user's input behind the scenes without explicit say-so, the "magic" often leads to mysterious side effects and information loss.</p>
<h1>New Answer: Strict Core, but Enhance DELINE</h1>
<p>Historically DELINE took strings.  But now I'm going to make it take BINARY!, FILE!, and URL!.</p>
<p>If you suspect that a file has CR LF sequences in it and you wish to be tolerant of this, then:</p>
<pre><code>do deline %some-wonky-local-file.reb
</code></pre>
<p>Otherwise, <strong>the default behavior is that DO will error on CR</strong>.  TO TEXT! of a BINARY! will consider CR to be codepoint-non-grata...you will need to use DELINE and it will now accept BINARY!.</p>
<p>TO TEXT! is going to be prescriptive in other ways.  It's not going to allow embedded <code>0</code> bytes, because that creates risky interactions with old-style zero-terminated C strings.  It means you cannot trust a simple extractor of a <code>char*</code> as giving you all the relevant data--you always need to worry about a length output parameter.  I think that's an undesirable property for the string extractor for libRebol, and you should use a BINARY! in such cases where you are forced to always get back a size in the API.</p>
<h1>Q: How "Platform-Sensitive" Should It Be?  (A: None?)</h1>
<p>It seems like DELINE pretty much by default needs to accept files that either have CR LF in them or that do not.  Because if you say:</p>
<pre><code>do deline https://example.com/some-wonky-internet-file.reb
</code></pre>
<p>You are dealing with a file that's not on your computer, <em>and we don't want to create a disincentive to the person hosting it cleaning it up</em>.  They may not be able to edit your script.</p>
<p>But then we have to ask about things like whether ENLINE should default to being a no-op on Linux platforms, and only adding the CRs on Windows.  Historical Rebol added it either way.</p>
<p><strong>My hope is that people will really avoid using ENLINE and DELINE at all possible, and get their files in order.</strong>  But as tools they will be there for people who find themselves stuck and can't do that.  I feel this is definitely a step in the right direction, and overall code cleanliness and performance will benefit from it.</p>
            <p><small>10 posts - 5 participants</small></p>
            <p><a href="https://forum.rebol.info/t/fight-for-the-future-how-deline-will-save-us-from-cr-lf/1264">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/fight-for-the-future-how-deline-will-save-us-from-cr-lf/1264</link>
          <pubDate>Sun, 23 Feb 2020 19:22:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1264</guid>
          <source url="https://forum.rebol.info/t/fight-for-the-future-how-deline-will-save-us-from-cr-lf/1264.rss">Fight for the Future: How DELINE will save us from CR LF</source>
        </item>
        <item>
          <title>The Canonical List of Non-Negotiables</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>I realized this is something that maybe hasn't been attempted, but would be very useful.  That is <strong>a list of concrete code samples where if Rebol won't run that code looking that way, <em>then it is dead to you</em>.</strong></p>
<p>I'd imagine it's easier to say things like <em>"it's dead to me if it requires me to install Java"</em>.  But there must be something other than the meta-properties of the language which people consider foundational?  Actual code--looking and acting an actual way?</p>
<p>I'm not looking for <em>controversial</em> things here--rather things generally agreed on as good.    But naming some of them out loud might have benefit.  I'll start.</p>
<h2>COMPOSE, UNSPACED, ETC. VAPORIZING CONDITIONALS</h2>
<p>The lack of conditional vaporization bugged me to no end about Rebol2:</p>
<pre><code>rebol2&gt;&gt; compose [&lt;a&gt; (if false [&lt;b&gt;]) &lt;c&gt;]
== [&lt;a&gt; none &lt;c&gt;]

rebol2&gt;&gt; rejoin ["a" if false ["b"] "c"]
== "anonec"
</code></pre>
<p>You had to throw in an EITHER with an empty branch, to get an UNSET!.</p>
<pre><code>rebol2&gt;&gt; compose [&lt;a&gt; (either false [&lt;b&gt;] []) &lt;c&gt;]
== [&lt;a&gt; &lt;c&gt;]

rebol2&gt;&gt; rejoin ["a" either false ["b"] [] "c"]
== "ac"
</code></pre>
<p>So I advocated vaporizing NONE! by default for a while...facing resistance from those wanting to use them as placeholders in blocks, adamant that NONE! <em>was a value</em>.</p>
<p>Hence the idea was moved around to being more like a failed conditional would return an UNSET!.  But because UNSET! was "a value", it could legitimately be put into blocks.</p>
<p>Hence Ren-C rethought the playing field to have "non-valued" states...like NULL (which you couldn't put in blocks, but could assign to a variable) and the transient VOID state (which you could neither put in blocks nor assign variables to...attempting to do so would "unset" the variable).</p>
<p>So failed conditionals were re-tuned to return VOID:</p>
<pre><code>&gt;&gt; compose [&lt;a&gt; (if false [&lt;b&gt;]) &lt;c&gt;]
== [&lt;a&gt; &lt;c&gt;]

&gt;&gt; unspaced ["a" if false ["b"] "c"]
== "ac"
</code></pre>
<p>The NULL state was decided to be an error in these situations.  So you can't go directly from a NULL variable to a vanishing slot without something that turns it into VOID.   The construct that does so is called MAYBE.</p>
<pre><code>&gt;&gt; var: null

&gt;&gt; compose [&lt;a&gt; (var) &lt;c&gt;]
** Error: need non-NULL value in COMPOSE slot

&gt;&gt; compose [&lt;a&gt; (maybe var) &lt;c&gt;]
== [&lt;a&gt; &lt;c&gt;]
</code></pre>
<h2>DEFINITIONAL RETURN</h2>
<p>Novices using Rebol2 or Red aren't really clear on how their RETURN works.  (Or <em>doesn't</em> work, as the case my be.)  RETURN climbs the stack until it finds a function that is willing to accept returns.</p>
<ul>
<li>Functions in Rebol2/Red that <em>won't</em> accept returns: <strong>IF, WHILE, or pretty much any native</strong>
</li>
<li>Functions in Rebol2/Red that <em>will</em> accept returns: <strong>any user FUNC you write</strong>
</li>
</ul>
<p>To give a brutally simple example, you cannot implement UNLESS in terms of IF:</p>
<pre><code> rebol2&gt;&gt; foo: func [x] [if not x = 10 [return "not 10"] return "it's 10!"]
 rebol2&gt;&gt; foo 20
 == "not 10"

 rebol2&gt;&gt; unless: func [cond block] [if not cond block]
 rebol2&gt;&gt; bar: func [x] [unless x = 10 [return "not 10"] return "it's 10!"]
 rebol2&gt;&gt; bar 20
 == "it's 10"  ; D'oh
</code></pre>
<p>That UNLESS, because it's a FUNC and not a native, is a candidate for receiving RETURN.  So the UNLESS itself returned "not 10" instead of returning from bar.  Execution continued and the `return "it's 10!" ran.  <strong>I maintain that correct behavior constitutes another must-have, <a href="https://github.com/rebol/rebol-issues/issues/539#issuecomment-170878011">and I was by no means alone in this, nor the first to say so</a></strong>.</p>
<pre><code>&gt;&gt; unless: function [cond block] [if not cond (block)]  ; see note re: group!
&gt;&gt; bar: function [x] [unless x = 10 [return "not 10"] return "it's 10!"]
&gt;&gt; bar 20
== "not 10"
</code></pre>
<p><strong>I do not consider annotating UNLESS to say "I'm the kind of thing that doesn't catch returns" to be remotely acceptable.</strong>  I'd sooner throw out the project than go that route.  Addressing definitional returns wasn't at all trivial...even though conceptually it was understood what needed to be done.  It was one of the first things I tried to do in open-sourced R3-Alpha.  The rearranging I had to do in order to understand the code well enough to accomplish it laid the groundwork for many features to come.</p>
<p>So this belongs in the non-negotiable list.</p>
<p><em>(Note: The reason you have to put a group! around <code>block</code> (or say <code>:block</code>) is due to soft-quoted branching, and I <a href="https://forum.rebol.info/t/stylistic-questions-and-soft-quoted-branching/1220">argue for the tradeoff here</a>.  I would not consider that one of my non-negotiable points for this list, though I've offered what I believe to be some compelling arguments.  I do--however--consider FUNCTION instead of FUNC to be a non-negotiable way of writing this, with current leaning that <a href="https://forum.rebol.info/t/abbreviations-as-synonyms/1211">FUNC is a full synonym for FUNCTION</a>)</em></p>
<h2>...and...</h2>
<p>That's only two off the top of my head.  But my idea was that we can keep adding posts to this thread whenever someone thinks of something.  What <em>has</em> to work else it's "dead to you"?  <a class="mention" href="/u/ingohohmann">@IngoHohmann</a>, <a class="mention" href="/u/rgchris">@rgchris</a>, <a class="mention" href="/u/gchiu">@gchiu</a>, <a class="mention" href="/u/mark-hi">@Mark-hi</a>, <a class="mention" href="/u/blackattr">@BlackAttr</a>... ?</p>
<p>Like I say: please avoid functionality concepts like "has to talk to ODBC"...unless you have a very specific code sample that looks <em>exactly</em> right for how it needs to look for some case.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/the-canonical-list-of-non-negotiables/1244">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-canonical-list-of-non-negotiables/1244</link>
          <pubDate>Fri, 29 Nov 2019 05:04:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1244</guid>
          <source url="https://forum.rebol.info/t/the-canonical-list-of-non-negotiables/1244.rss">The Canonical List of Non-Negotiables</source>
        </item>
        <item>
          <title>The Cliffs of Complexity: How Much Is Too Much?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Ren-C has tried out a lot of new ideas.</p>
<p>Among the ideas that have been kept, most have added <em>some</em> level of complexity.  A notable exception would be the <a href="https://forum.rebol.info/t/pure-and-refined-simplifying-refinements-to-one-or-zero-args/1120">0-or-1 refinement parameter change</a>.  That was a welcome simplification--and I am rather confident that nothing of value was lost in the process.</p>
<p>Yet trying to write a <a href="https://forum.rebol.info/t/looking-into-a-usermode-pointfree/1236">usermode pointfree specialization</a> draws out the inconvenient truth: <strong>Ren-C's tech <em>could have easily nailed</em> a complete version of what it would take to do historical Rebol's parameter conventions--IF IT HAD NOT RAISED THE BAR.</strong></p>
<p>Rephrasing that: if we were willing to turn back the clock to where there were only four parameter types ("normal", "soft quoted", "hard quoted", "refinement"), then the code I posted for POINTFREE would pretty much work as written...<sub><a href="https://www.elsevier.com/__data/assets/image/0012/834888/Sidney-Harris-cartoon-main-image.jpg">with a little more work for enfix</a></sub>.</p>
<p>All the things that throw wrenches into it are Ren-C-isms:</p>
<ul>
<li><a href="https://trello.com/c/Y17CEywN/131-extremely-flexible-varargs-variadic-functions-with">Variadics</a></li>
<li><a href="https://forum.rebol.info/t/skip-able-arguments/1013">Skippable Parameters</a></li>
<li>
<strike> <a href="https://forum.rebol.info/t/new-parameter-convention-concept-modal-arguments-or-the-arg/1187">Modal Parameters</a></strike> (replaced by the more general and high-leverage ^META parameters)</li>
<li>
<a href="https://trello.com/c/gL9rHcEC/136-endable-args-replace-the-unset-quoting-hack-used-to-make-help-work-with-1-or-0-args-allows-infix-functions-to-implement-handling">Endable Parameters</a> (this one's not totally new, as HELP vs. HELP TOPIC relied on a similar quirk, but Ren-C generalized it)</li>
</ul>
<h2>Is the Answer to Cut Features?</h2>
<p><em>I don't think so.</em>  These features are important.</p>
<p>I think that the evaluator just has to become more modular or hookable.  This question of having a parameter to fill, and asking it to be filled from the callsite, just has to be formed as a native in its own right.</p>
<p>So basically: we need a form of EVALUATE that lets you pass in a function which can peek at the input feed and make a decision to pre-process that input.  This is somewhat the same needs as the debugger.</p>
<p>MAKE ACTION! from a FRAME! is still quite a good feature.  But when your goal is to simulate the evaluator on a stream of input, you need more tools...unless you either burden the person doing the simulation (who will make mistakes) or lose expressivity in the evaluator (which undermines all the interesting work).</p>
<p>The fact that such a simulation is non-trivial isn't a fatal flaw...it's part of what brings the necessary expressivity to make things fun and notable.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-cliffs-of-complexity-how-much-is-too-much/1241">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-cliffs-of-complexity-how-much-is-too-much/1241</link>
          <pubDate>Sun, 03 Nov 2019 13:59:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1241</guid>
          <source url="https://forum.rebol.info/t/the-cliffs-of-complexity-how-much-is-too-much/1241.rss">The Cliffs of Complexity: How Much Is Too Much?</source>
        </item>
        <item>
          <title>Parameter Order in Rebol</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>With the advent of <a href="https://forum.rebol.info/t/looking-into-a-usermode-pointfree/1236">Point-Free expression</a>, things that were wordy using SPECIALIZE are now succinct.  You don't have to name the parameters...which saves typing and also keeps you from having to look it up:</p>
<pre><code>next: specialize 'skip [offset: 1]
;
; ...becomes
;
next: (&lt;- skip _ 1)
</code></pre>
<p>Though that placeholder is a little bit unsatisfying.  Which means one starts looking at questions like "in Rebol, why isn't the offset to skip by <em>first</em>".  In the narrow case of this specialization, it would make it a bit briefer and seem more natural...</p>
<pre><code>next: (&lt;- skip 1)
</code></pre>
<p>And to play devil's advocate, if Rebol is to be English-inspired instead of traditional OOP inspired...wouldn't you say:</p>
<pre><code>"Skip 10 pages ahead"
</code></pre>
<p>Instead of the more awkward:</p>
<pre><code>"Skip pages ahead by 10"
</code></pre>
<p>It's almost like the underscore in the partial specialization is playing the role of <code>"by"</code>.  But, anyway--is there some kind of universal rule to guide such decisions?</p>
<h2>Most-or-Least Important Thing First</h2>
<p>Since this looks very Haskell-y, here's a good summary paragraph <a href="https://stackoverflow.com/a/31738041/211160">from a StackOverflow answer</a> on why Haskell users would favor <code>(&lt;- skip 1)</code> to <code>(&lt;- skip _ 1)</code>:</p>
<blockquote>
<p><em>"It's common practice in Haskell to order function parameters so that parameters which "configure" an operation come first, and the "main thing being operated on" comes last. This is often counter intuitive coming from other languages, since it tends to mean you end up passing the "least important" information first. It's especially jarring coming from OO where the "main" argument is usually the object on which the method is being invoked, occurring so early in in the call that it's out of the parameter list entirely!"</em></p>
</blockquote>
<p>One thing about the least important parameter is it is often briefer to express.  Consider the example we hit with DELIMIT when the data to act on was first:</p>
<pre><code>delimit [
    "here" "is" "my"
    long block of code stuff
    "and we go on for a while"
] ","
</code></pre>
<p>By the time you get to the comma, you might have forgotten what you are doing.  It seems it's pretty rare for the thing you're delimiting with to be coming from a long and complex expression, while the thing you're operating on may well be a giant expression (like a COLLECT).</p>
<p>So <a class="mention" href="/u/johnk">@johnk</a> and I thought it seemed better to say:</p>
<pre><code>delimit "," [
    "here" "is" "my"
    long block of code stuff
    "and we go on for a while"
]
</code></pre>
<p>So that was changed...and as a consequence we get natural-looking specializations now like:</p>
<pre><code>spaced: (&lt;- delimit space)
</code></pre>
<p>What does this mean for old-school institutions like SKIP?  I don't know.  <strong>But I do know it's getting faster and clearer to bend the system to anything you want it to be...</strong></p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/parameter-order-in-rebol/1238">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/parameter-order-in-rebol/1238</link>
          <pubDate>Thu, 31 Oct 2019 10:32:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1238</guid>
          <source url="https://forum.rebol.info/t/parameter-order-in-rebol/1238.rss">Parameter Order in Rebol</source>
        </item>
  </channel>
</rss>

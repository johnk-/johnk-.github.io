<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Philosophy - AltRebol</title>
    <link>https://forum.rebol.info/c/usage/philosophy/31</link>
    <description>Topics in the &#39;Philosophy&#39; category How does Rebol differ from other computer languages and what makes code Rebolish and functional vs procedural coding.</description>
    
      <lastBuildDate>Sat, 24 Aug 2024 18:38:40 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/usage/philosophy/31.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>The Theory of Meta-Representability</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p><em>I wrote this to try and give some context to an AI before asking it a naming question.  For a less high-level treatment, see <strong><a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">A Justification of Generalized Isotopes</a></strong>.</em></p>
<hr>
<p>Most imperative programming languages do not delve into the relationships between things like null and undefined... as if they were mathematical, and you were going to discover that if you take the square root of undefined you get null, etc.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20">  But I am doing something analogous to that.</p>
<p>In particular, I'm making it possible to push variables which may contain states like undefined and null "upwards" representationally, to where whatever they are holding becomes "Meta".</p>
<pre><code>&gt;&gt; var
** Error: var is nothing

&gt;&gt; var: meta var
== ~

&gt;&gt; var  ; no error on access
== ~

&gt;&gt; var: meta var  ; again, no error
== '~

&gt;&gt; var
== '~

&gt;&gt; var: meta var  ; no error again
== ''~
</code></pre>
<p>If something is a special form (like nothing or null) the first META step will use tildes to indicate it has been raised to a "quasiform".  Quasiforms do not cause errors when accessed from variables, and can be put into "reified" contexts like arrays.  Then every META step after that adds a level of quoting, indicated by an apostrophe.</p>
<p>UNMETA reverses this process, ultimately getting back to the special form which cannot be put in arrays and--in the case of "nothing"--causes errors on access.</p>
<pre><code>&gt;&gt; var: unmeta first ['~]
== ~

&gt;&gt; var
== ~

&gt;&gt; var: unmeta var  ; result is nothing, shows nothing in the console

&gt;&gt; var
** Error: var is nothing
</code></pre>
<p>If something didn't start out as a special form, then it will just get quoting levels added by apostrophes:</p>
<pre><code>&gt;&gt; var
== 10

&gt;&gt; var: meta var
== '10

&gt;&gt; var: meta var
== ''10
</code></pre>
<p>So what this lets people do is kind of work generically and persist special states of interest to them in meta form, multiplexed alongside things that had been conventional values.</p>
<p>The special states are called "antiforms".  And they aren't just things like NULL and NOTHING, but also <a href="https://forum.rebol.info/t/the-void-in-null-out-protocol/1880">VOID</a>... <a href="https://forum.rebol.info/t/why-theres-no-boolean-type-storable-in-a-block/2095">logical TRUE and FALSE</a> (which means all reified states can be truthy)... <a href="https://forum.rebol.info/t/thought-reimplementing-multi-return-via-isotopic-block/1955">multi-return packs</a>, <a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-errors/1852">raised errors</a>, <a href="https://forum.rebol.info/t/the-long-awaited-death-of-only/1607">splice representations</a>...</p>
<p>To a newcomer, the merits or applications may not be obvious.  But this model gives phenomenal expressive power.  And I definitely do think of it as being like the "higher mathematics" of Rebol.</p>
<hr>
<p><a href="https://www.youtube.com/watch?v=B1J6Ou4q8vE">Animation vs. Math</a></p>

            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-theory-of-meta-representability/2217">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-theory-of-meta-representability/2217</link>
          <pubDate>Sat, 24 Aug 2024 18:38:40 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2217</guid>
          <source url="https://forum.rebol.info/t/the-theory-of-meta-representability/2217.rss">The Theory of Meta-Representability</source>
        </item>
        <item>
          <title>Trust the User&#39;s Judgment... *When You Can*</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>When writing about <a href="https://forum.rebol.info/t/set-word-to-initialize-locals-in-function-specs/2210">whether we should have SET-WORD! for initializing locals in function specs</a>, I talked about whether to enforce the right hand side of the SET-WORD! being a GROUP! for safety:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2210">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/set-word-to-initialize-locals-in-function-specs/2210/1">SET-WORD! To Initialize Locals In Function Specs?</a>
</div>
<blockquote>
<p>If plain words are being picked up as locals there's potential for error if you accidentally wrote an expression that didn't work, like:</p>
<pre><code class="lang-plaintext">func [
   arg [integer!]
   &lt;local&gt;
   local1 local2
   local3: arity-2-but-I-think-it's-3 a b c
   local4: 10
][
    ...
]
</code></pre>
<p>That could wind up making a local <strong><code>c</code></strong> that you didn't intend. But then again, sometimes it would be just a very obvious simple initialization, like <strong><code>local4: 10</code></strong>. Forcing people to use parentheses could do more harm than good, vs. trusting them to use the parentheses if they feel it's warranted.</p>
</blockquote>
</aside>
<p>I realized this kind of dove to the heart of Rebol philosophy:</p>
<p><strong>If you need to evaluate an expression multiple times, it has to be in an array.  But if you're doing an evaluation just once, trust the user to formulate the expression and use an array if they deem it necessary.</strong></p>
<p>Most people encounter this first with the difference between IF and WHILE.</p>
<p>Certainly IF <em>could</em> take its condition in a BLOCK!.  But it doesn't.  You can mess up:</p>
<p>In Rebol2:</p>
<pre><code>block: [a b]
data: [c]

if 3 = length? append block [
   print "Appending data to block gave us 3 elements"
]

stuff: [a b c]
</code></pre>
<p>You run the code and you get no output, because you forgot to say <strong>append block data</strong>.  So what did you get instead?</p>
<pre><code>&gt;&gt; block
== [a b
    print "Appending data to block gave us 3 elements"
]
</code></pre>
<p>What you thought was a branch got appended.  And the branch actually wound up being the block from the next expression (SET-WORD!s evaluate to what they are assigned).</p>
<p><em>(As it so happens in Ren-C, it catches this...due to <a href="https://forum.rebol.info/t/soft-quoted-branching-light-elegant-fast/1020">soft-quoted branching</a>.  Since it quotes its branch slot, it saw a SET-WORD! in the position, and it doesn't allow things like WORD! or SET-WORD! there.  If we didn't already have enough reasons to appreciate soft quoted branching, there's one more!)</em></p>
<h2>
<a name="should-it-have-required-a-block-for-the-condition-1" class="anchor" href="https://forum.rebol.info#should-it-have-required-a-block-for-the-condition-1"></a>Should It Have Required a Block For The Condition?</h2>
<p><strong>The answer for the Rebol Core is: No.</strong>  The goal is to trust the user to make that call.</p>
<p>If you think the expression you're writing is too risky to get right, you should use a GROUP! or break it into subexpressions or otherwise rethink your code so it's not risky.  Being able to cook up a DSL in ten minutes that solves patterns you find useful is the tool you use when you find yourself making code that's at risk of mistakes.</p>
<p><strong>The answer for You is: Your Choice.</strong>  If you find you're making lots of mistakes and want to set a policy that IF always takes a BLOCK! condition, suit yourself.  IF is yours, just like everything.  Redefine it.  It's about <a href="https://forum.rebol.info/t/back-to-personal-computing/186">putting the personal back into personal computing.</a></p>
<h2>
<a name="well-then-why-use-a-block-for-whiles-condition-2" class="anchor" href="https://forum.rebol.info#well-then-why-use-a-block-for-whiles-condition-2"></a>Well Then Why Use A BLOCK! For WHILE's Condition?</h2>
<p>Because there wasn't another choice.</p>
<p>You can't tell how long an expression is going to be just by looking at it.  You have to evaluate it.</p>
<p>The condition in a WHILE needs to be evaluated more than once.  So it's taken as a BLOCK!.</p>
<h2>
<a name="this-is-one-of-the-big-ideas-3" class="anchor" href="https://forum.rebol.info#this-is-one-of-the-big-ideas-3"></a>This Is One of The "Big Ideas"</h2>
<p>Whether you see it as a big idea or just kind of gonzo programming, is up to you.</p>
<p>With the state of software being how it is, I think we need the occasional Flower Sermon.</p>
<p><strong><a href="https://en.wikipedia.org/wiki/Flower_Sermon">https://en.wikipedia.org/wiki/Flower_Sermon</a></strong></p>
<p>Ren-C has <a href="https://forum.rebol.info/t/the-language-worlds-weirdest-comma-mechanic/1387">thrown in another big tool here, with COMMA!</a>.  Giving you yet more choice.</p>
<p>Yet EVAL and PARSE still let you write your streams of consciousness, giving the code a written-English like fluidity, of mostly words and spaces...which we are naturally good at working with.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/trust-the-users-judgment-when-you-can/2211">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/trust-the-users-judgment-when-you-can/2211</link>
          <pubDate>Sat, 24 Aug 2024 03:44:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2211</guid>
          <source url="https://forum.rebol.info/t/trust-the-users-judgment-when-you-can/2211.rss">Trust the User&#39;s Judgment... *When You Can*</source>
        </item>
        <item>
          <title>MAKE Should Be Using *Dialected Constructors*</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1591">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/debunking-the-arity-1-make/1591/1">Debunking the Arity-1 MAKE</a>
</div>
<blockquote>
<p>No one really uses the "polymorphism" of <strong>make some-type some-definition</strong> without really knowing what type or definition is, right? That seems essentially meaningless.</p>
</blockquote>
</aside>
<p>In thinking more about "what is MAKE", I feel like it is fundamentally a constructor.</p>
<hr>
<p>When you think about Rebol's value proposition vs. other languages, what's the key idea?</p>
<p><strong>DIALECTS.</strong>  The freeform Jazz of programming.  <img src="https://forum.rebol.info/images/emoji/twitter/saxophone.png?v=12" title=":saxophone:" class="emoji" alt=":saxophone:" loading="lazy" width="20" height="20"></p>
<hr>
<p>So what should be the differentiating factor about constructors in Rebol vs. other languages?</p>
<p><strong>CONSTRUCTOR DIALECTS.</strong> <img src="https://forum.rebol.info/images/emoji/twitter/saxophone.png?v=12" title=":saxophone:" class="emoji" alt=":saxophone:" loading="lazy" width="20" height="20"> <img src="https://forum.rebol.info/images/emoji/twitter/guitar.png?v=12" title=":guitar:" class="emoji" alt=":guitar:" loading="lazy" width="20" height="20"> <img src="https://forum.rebol.info/images/emoji/twitter/drum.png?v=12" title=":drum:" class="emoji" alt=":drum:" loading="lazy" width="20" height="20"> <img src="https://forum.rebol.info/images/emoji/twitter/musical_keyboard.png?v=12" title=":musical_keyboard:" class="emoji" alt=":musical_keyboard:" loading="lazy" width="20" height="20"></p>
<hr>
<p>When I say <strong><code>make my-type! [...]</code></strong> then what goes in that BLOCK! needs to be delegated to MY-TYPE! in some way to allow it the freedom to interpret the hell out of that block.</p>
<p>And it shouldn't only be allowed to be a BLOCK! full of madness.  Consistent with history where you can write things like <strong><code>(make block! 10)</code></strong> to preallocate a size, you should be able to pass anything you want.</p>
<pre><code>make my-type! 'some-word

make my-type! /some-refinement

make my-type! ${...}  ; gimme a bound FENCE!

make my-type! @[...]  ; special meaning if "inert" block received?
</code></pre>
<hr>
<h3>
<a name="history-has-ridiculously-underformed-the-potential-1" class="anchor" href="https://forum.rebol.info#history-has-ridiculously-underformed-the-potential-1"></a>History Has Ridiculously Underformed The Potential</h3>
<p>When you look at the TO/MAKE Matrix, it's full of meaningless choices:</p>
<pre><code>rebol2&gt;&gt; make block! [a b c]
== [a b c]
</code></pre>
<p>Huh?  What the hell use is that.  Is it a copy?  Is it a deep copy?  <em><a href="https://www.youtube.com/watch?v=U80ebi4AKgs">Where's the beef?</a></em></p>
<p>Why isn't the constructor for block a literate landscape, subsuming the functionality of <a href="http://www.rebol.com/docs/words/warray.html">ARRAY</a> (a terrible name for a verb) and much more?</p>
<pre><code>&gt;&gt; make block! [4/8 initial: '*]
== [* * * *]  ; length 4, capacity 8, initialize elements with *

&gt;&gt; make block! /8
== []  ; just capacity 8

&gt;&gt; make block! 4
== [~ ~ ~ ~]  ; default to meta-TRASH
</code></pre>
<p>There's an answer here that "dialect design is hard", and it's scary to put a dialect in the core.  But there's decades of experience at this point.  And maybe even ways for people to do their own rewrites and transformations so they don't have to use a <strong><code>make-block</code></strong> function but can customize <strong><code>make block!</code></strong> itself.</p>
<hr>
<h3>
<a name="ren-c-has-opened-up-the-skies-and-will-do-more-2" class="anchor" href="https://forum.rebol.info#ren-c-has-opened-up-the-skies-and-will-do-more-2"></a>Ren-C Has Opened Up The Skies, and Will Do More</h3>
<p>I was musing on the behavior of FENCE! in the interpreter and thought, what if it wasn't narrowly defined as being OBJECT! related.  <em>What if it was MAKE-related, with an object-generating default?</em></p>
<pre><code>&gt;&gt; {x: 10, y: 20}
== #[object! x: 10 y: 20]

&gt;&gt; {[block!] 4/8 initial: '*}  ; maybe leading block means MAKE that?
== [* * * *]

&gt;&gt; {block! {4/8 initial: '*}}  ; maybe nesting FENCE! does it?
== [* * * *]

&gt;&gt; {block! 4/8 initial: '*}  ; maybe starting with WORD! is enough?
== [* * * *]

&gt;&gt; {block!}
== []
</code></pre>
<p>It's a half-baked thought, and I don't know what the ideal syntax is.  But I feel like this could make FENCE! so much more.</p>
<hr>
<h2>
<a name="so-coming-soon-the-great-make-purge-3" class="anchor" href="https://forum.rebol.info#so-coming-soon-the-great-make-purge-3"></a>So Coming Soon: The Great MAKE Purge.</h2>
<p>In the combinatoric TO/MAKE matrix, there is a ton of garbage.</p>
<p>I've previously suggested that TO should not do any evaluation (e.g. be binding agnostic on what it gets in).  I think that remains a good idea, that it be purely mechanical.  <a href="https://forum.rebol.info/t/hacking-away-on-the-to-and-make-matrix/649">I had some other ideas that are lingering.</a></p>
<p>I think it's time to further cull the "MAKE for the sake of thinking everything you pass needs to do something, even if it's trivial."  I've been wiping out some of the garbage, but more is needed.</p>
<p>And we have to find a way to give users the ability to hook MAKE on their objects... such that something like <strong><code>make point-3D! [...]</code></strong> isn't locked into a trivial extension syntax of SET-WORD! and value, but truly able to do interesting things.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/make-should-be-using-dialected-constructors/2196">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/make-should-be-using-dialected-constructors/2196</link>
          <pubDate>Tue, 20 Aug 2024 05:41:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2196</guid>
          <source url="https://forum.rebol.info/t/make-should-be-using-dialected-constructors/2196.rss">MAKE Should Be Using *Dialected Constructors*</source>
        </item>
        <item>
          <title>The Robustness Principle Is Not Robust</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Something floating around that I've pretty much always hated--but experience has made me hate more--is the "Robustness Principle":</p>
<aside class="onebox wikipedia" data-onebox-src="https://en.wikipedia.org/wiki/Robustness_principle">
  <header class="source">

      <a href="https://en.wikipedia.org/wiki/Robustness_principle" target="_blank" rel="noopener">en.wikipedia.org</a>
  </header>

  <article class="onebox-body">
    

<h3><a href="https://en.wikipedia.org/wiki/Robustness_principle" target="_blank" rel="noopener">Robustness principle</a></h3>

<p>In computing, the robustness principle is a design guideline for software that states: "be conservative in what you do, be liberal in what you accept from others". It is often reworded as: "be conservative in what you send, be liberal in what you accept". The principle is also known as Postel's law, after Jon Postel, who used the wording in an early specification of TCP.
 In other words, programs that send messages to other machines (or to other programs on the same machine) should conform comple...</p>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>I understand the motivation.  If you have something that imports to a vector graphics program and not all the Bezier curves have endpoints... then, sure.  Someone is going to appreciate that you were forgiving and they got some kind of maybe-a-bit-broken picture instead of an "Invalid File" error.</p>
<p>Pushing this further to those of us who remember the DOS days: we had those experiences where we accidentally deleted files, but the filesystem didn't delete everything--it just wrote a zero byte on the filename (or somesuch).  Norton Utilities let us catch our mistake and get our file back.  In some ways, a lax and forgiving attitude is a beautiful thing...</p>
<p>This so-called "robustness" cannot (and should not) be subconscious.  It needs to be mitigated with an in-your-face consciousness shift!  <em>(And I think Norton Utilities is an apt example, because if you were firing up that program <a href="https://www.youtube.com/watch?v=RRU3I_o1vLc">you knew you were in the Danger Zone</a>)</em>.</p>
<p>There must be a really jarring speedbump.  When a data file is not fitting the standards, you have to go through a procedure that transforms the broken file to the standard.  You have to be aware that you are dealing with a dirty file.  And the experience of that transformation informs you that the person who gave you the dirty file isn't playing with all their marbles, and you correct them for the next transmission.</p>
<p>Authentic programs should demand a standard form.  And when they aren't getting the standard form they should speak up, march you out the door, and force you to fix your input. "Real programs" should never pretend the byte sequence of bad input is okay--there should only be "Cleanup/Recovery programs" that fix the sequence to write a correct one.  And that recovery program should be terminated before the "Real program" runs.</p>
<hr>
<p>I don't need to rewrite the critiques of the "robustness principle" cited in Wikipedia.  But it is nonsense, and the opposite of robust.  It's a garbage idea, that anyone with a whit of sense regarding security can see right through immediately.</p>
<p>There is a better way: the better way is <em>consciousness</em> about what you are working with, and rejection of any sort of malignant "middleman" acting on your data without you knowing.</p>
<ul>
<li>
<p>"Normalization" you did not ask for is an attack on your information.</p>
</li>
<li>
<p>"Glossing over or fixing invalid sequences" you did not ask for is an attack on your information</p>
</li>
<li>
<p>Anything which makes a simple load of a file and save back of the same file not idempotent is an attack on your information</p>
</li>
</ul>
<p>Perhaps I've become even more religious than Carl in some of these ways.  But I certainly see things won't get better without pushing back.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/the-robustness-principle-is-not-robust/2187">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-robustness-principle-is-not-robust/2187</link>
          <pubDate>Thu, 13 Jun 2024 05:45:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2187</guid>
          <source url="https://forum.rebol.info/t/the-robustness-principle-is-not-robust/2187.rss">The Robustness Principle Is Not Robust</source>
        </item>
        <item>
          <title>RE: The Ordering and Priorities of the Ren-C Project</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="5" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/speed-of-uparse/2177/5">Speed of UPARSE</a>
</div>
<blockquote>
<aside class="quote no-group" data-username="bradrn" data-post="4" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/speed-of-uparse/2177/4">Speed of UPARSE</a>
</div>
<blockquote>
<p>I’ll be blunt: this, to me, sounds unusably slow. Beyond the very simplest tasks, I can’t imagine a situation where I’d deliberately choose to take a 250× performance drop.</p>
</blockquote>
</aside>
<p>This is a first-of-its-kind design. And if you don't understand why I'm building things the way I'm building them, then...to be blunt...there's not much point in me listening to your feedback regarding the order in which I do things.</p>
</blockquote>
</aside>
<p>Remember, I come from well outside the Rebol world. The reason I don’t understand is, to a large extent, because this way of reasoning about code is one I’ve never seen before in my life. This is the reason I’m asking so many questions, setting out my opinions, and having these discussions with you… precisely so that I can begin to understand why it is that way.</p>
            <p><small>9 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179</link>
          <pubDate>Sat, 06 Apr 2024 19:16:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2179</guid>
          <source url="https://forum.rebol.info/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179.rss">RE: The Ordering and Priorities of the Ren-C Project</source>
        </item>
        <item>
          <title>What deserves to be a datatype?</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="7" data-topic="2159">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/header-dialect-and-multiline-strings/2159/7">Header dialect and multiline strings</a>
</div>
<blockquote>
<p>(If I may philosophise for a moment… I feel there’s a big, gaping hole in my understanding of how we decide ‘what Rebol syntax is’, so to speak. Perhaps my caution around sigils and TYPE-BLOCK!s are a manifestation of that hole, as is this. I’ll make a new thread about it if I can figure out any clearer way to articulate my concerns.)</p>
</blockquote>
</aside>
<p>This is that thread.</p>
<p>I’ll begin by observing that in Rebol, the complexity of the lexer vs the parser is ‘reversed’ compared to other programming languages. In Rebol, the actual syntax is highly minimalistic: there’s only a few constructs which provide explicit grouping, and none provide anything more than a simple list of items. By contrast, the lexer is exceedingly complicated: nearly every datatype has its own literal form, oftentimes more than one.</p>
<p>Language design ends up ‘reversed’ in a similar way. In most languages, discussion centres around questions like ‘which new syntactic constructs should we add’. By contrast, Rebol (and especially Ren-C) more often poses the question: ‘which new datatypes do we want to include, with which literal syntax?’.</p>
<p>At the moment, I still feel uncomfortable discussing such questions. I don’t feel that I fully understand the kind of criteria we should consider to know whether a datatype is worth including or not. Or, more concisely, I don’t understand how decide: <strong>what deserves to be a Ren-C datatype?</strong>.</p>
<hr>
<p>One obvious criterion is simply, <em>datatypes representing common types of data</em>. This is why we have things like MONEY! and FILE! and DATE! and so on. Ultimately this stems from Rebol’s heritage as a data-transfer format, but obviously these types are far more broadly useful.</p>
<p>Another obvious criterion is <em>syntax which is important for programming</em>. This gives us GROUP! and GET-WORD! and PATH! and so on. These exist as datatypes ultimately because Rebol is homoiconic, but their presence has suggested a wide range of uses beyond simple programming.</p>
<p>This accounts for most of the types in Ren-C. And, if that were all to it, I’d have no objections.</p>
<hr>
<p>But, unfortunately, there are some other types, whose presence is explained by neither of those criteria. As I’ve said previously, the ones which make me feel most uncomfortable are THE-* and TYPE-*. Neither of these represent common types of data that one would want to pass around. And, with the possible exceptions of THE-WORD! and TYPE-BLOCK!, they’re basically useless in ‘regular’ programming.</p>
<p>Despite this, <a class="mention" href="https://forum.rebol.info/u/hostilefork">@hostilefork</a> has lobbied pretty hard for both of these. Hopefully it should be clear now why I find this viewpoint confusing. I can’t say the existence of these types is <em>problematic</em>, as such, but I feel this <strong>indicates a gap in my understanding of the language</strong>.</p>
<p>The closest to an explanation I’ve found is that these types are useful in dialecting. That is, they may not be useful for programming <em>per se</em>, but having the syntax around is useful for constructing new languages. (For instance, using TYPE-WORD!s in PARSE dialect, or THE-WORD!s for module inclusion.) The problem with this is, <a href="https://forum.rebol.info/t/a-proliferation-of-word-s/2147">as we’ve established</a>, that there’s a huge number of syntaxes which would be ‘useful in dialecting’: clearly, this is too low a bar for deciding ‘what deserves to be a datatype’.</p>
<p>(And, incidentally, this also establishes that we’re quite willing to reject datatypes that don’t seem to be of sufficiently general usage.)</p>
<p>Another argument is simply consistency: other sigils have versions for words, blocks, tuples, etc., so THE-* and TYPE-* should as well. But this doesn’t strike me as particularly convincing — there’s nothing intrinsic in Ren-C which requires sigils to generalise to all possible types. Indeed, we’re quite willing to avoid doing so when it would make no sense. (For instance, we don’t have ISSUE-TEXT!, ISSUE-BINARY!, ISSUE-EMAIL!… we just have a single textual ISSUE! type, because doing otherwise would be silly.)</p>
<p>So, when all is said and done, we have a set of types which don’t seem to be of general use, and have no convincing reason to exist, but are nonetheless kept in the language. And <strong>I want to know why that is</strong>, because I can’t figure it out.</p>
            <p><small>9 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/what-deserves-to-be-a-datatype/2164">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-deserves-to-be-a-datatype/2164</link>
          <pubDate>Tue, 05 Mar 2024 08:20:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2164</guid>
          <source url="https://forum.rebol.info/t/what-deserves-to-be-a-datatype/2164.rss">What deserves to be a datatype?</source>
        </item>
        <item>
          <title>Fundamental distinguishing features of Rebol</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Perhaps foolishly, I offered to give a talk at my local Functional Programming meetup next month. Given my recent interests, I’m thinking of giving an intro to Rebol and its basic concepts.</p>
<p>So that’s gotten me thinking: what <em>are</em> the basic concepts of Rebol as a programming paradigm, which distinguish it from all others? Here’s what I’ve come up with so far:</p>
<ul>
<li>
<p><strong>Everything is a datatype</strong>: Rebol was built for networking. This means you should be able to take any value, serialise it in a human-readable way, and parse it back into a value. This means a lot of built-in datatypes for useful concepts.</p>
</li>
<li>
<p><strong>Data is code</strong>: Everything starts out its life as data. If you want, you can evaluate it in some way to get a result. Naturally, you can evaluate it using any rules you want, which gives you <strong>dialecting</strong> as a corollary.</p>
<p>(It’s worth noting that this is the converse of Lisp’s famous maxim, ‘code is data’.)</p>
</li>
<li>
<p><strong>Binding</strong>: Word values are associated with their storage. This can be arbitrarily manipulated by the programmer, leading to <strong>definitional scoping</strong>.</p>
</li>
<li>
<p>More generally, I might summarise all the above points as natural consequences of <strong>computing with evaluation</strong>: the fundamental operation of Rebol is taking values and extracting some kind of result from them. This necessitates the other points above: a rich set of datatypes to store both the original value and the result, the ability to treat those datatypes as code which can be evaluated, and a way to look up references during the evaluation process.</p>
</li>
</ul>
<p>Does this all seem reasonable? Have I missed anything?</p>
            <p><small>16 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/fundamental-distinguishing-features-of-rebol/2136">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/fundamental-distinguishing-features-of-rebol/2136</link>
          <pubDate>Mon, 29 Jan 2024 12:55:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2136</guid>
          <source url="https://forum.rebol.info/t/fundamental-distinguishing-features-of-rebol/2136.rss">Fundamental distinguishing features of Rebol</source>
        </item>
        <item>
          <title>Usefulness of String Interpolation</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="bradrn" data-post="7" data-topic="1751">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751/7">Rebol And Scopes: Well, Why Not?</a>
</div>
<blockquote>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1751">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751/1">Rebol And Scopes: Well, Why Not?</a>
</div>
<blockquote>
<p>Features based on string interpolation are so undeniably useful that once the possibilities are seen, they can't be unseen.</p>
</blockquote>
</aside>
<p>Honestly, I’m not sure I agree with this. In Haskell, which is my main language, there are packages which implement string interpolation… and no-one uses them, because they just aren’t necessary! It’s no big deal when it’s easier to just concatenate stuff together.</p>
</blockquote>
</aside>
<p>To pick a random example from the build helpers for "CScape" interpolation of some generated C code:</p>
<pre><code>emit {
    #define ${MAYBE PREFIX}INCLUDE_PARAMS_OF_${NATIVE-NAME} \
        $[Items]; \
        assert(Get_Series_Info(level_-&gt;varlist, HOLD))
}
</code></pre>
<ul>
<li>
<p>The use of <code>${}</code> (instead of <code>$()</code> or <code>$&lt;&gt;</code>) means that the result of the expression should be <a href="https://github.com/metaeducation/ren-c/blob/815758fb571e88591908dc94f9320581f00d9331/tools/common.r#L37">turned into a valid C identifier name</a>... so dashes are converted to underscores, etc.</p>
</li>
<li>
<p>The use of all capitals in the <code>${}</code> escaping means that the strings generated by the expressions evaluated should be made all uppercase.</p>
</li>
<li>
<p>The use of <code>$[]</code> means that items is an array, and its elements should be printed one line at a time...repeating the boilerplate leading and trailing on each line (in this case an indent on the left, and a semicolon and backslash on the right)</p>
</li>
</ul>
<p>The template looks something like the result:</p>
<pre><code>#define INCLUDE_PARAMS_OF_IF \
    DECLARE_PARAM(1, return); \
    USED(ARG(return)); \
    DECLARE_PARAM(2, condition); \
    DECLARE_PARAM(3, branch); \
    assert(Get_Series_Info(level_-&gt;varlist, HOLD))
</code></pre>
<p>Without interpolation, we fall back on LOAD-able code... where spaces and quotes are required by the language itself.  This starts to lose the ability to keep track of actual spaces in the interpolated thing, plus you keep having to start and stop string delimiters on the string portions.</p>
<p>I'm not quite sure how it would come together dialected via regular code, but it would drift away from looking like C code, at best it might look like:</p>
<pre><code>emit [
    "#define " &lt;c&gt; (MAYBE PREFIX) "INCLUDE_PARAMS_OF_" &lt;c&gt; (NATIVE-NAME) " \"
    "    " @[Items] "; \"
    "    assert(Get_Series_Info(level_-&gt;varlist, HOLD))"
]
</code></pre>
<p><em>I'd be hard-pressed to say the spacing was correct on inspection</em>.  We've lost the intuition about where the unspaced parts are.  You can imagine it getting worse when you're building unspaced material inside a string literal.  Strings can simply be the least noisy medium when you want to see something that looks close to the result.</p>
<p>Anyway, with strings carrying binding, we wouldn't have to do what we do today... which is actually pass the variables (that don't live in LIB) in a block to emit:</p>
<pre><code>emit [prefix native-name items] {  ; &lt;-- ack
    #define ${MAYBE PREFIX}INCLUDE_PARAMS_OF_${NATIVE-NAME} \
        $[Items]; \
        assert(Get_Series_Info(level_-&gt;varlist, HOLD))
}
</code></pre>
<p>So I look forward to getting rid of that.</p>
<aside class="quote no-group quote-modified" data-username="bradrn" data-post="7" data-topic="1751">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751/7">Rebol And Scopes: Well, Why Not?</a>
</div>
<blockquote>
<p>And it’s even easier in Rebol than it is in Haskell, because there’s already a single built-in function to do everything for you:</p>
<pre><code>&gt;&gt; x: 10 y: "foo"
== "foo"
&gt;&gt; print ajoin ["Scopes? " x " " x " " x " " y " " y " " y]
Scopes? 10 10 10 foo foo foo
&gt;&gt; foo: func [x] [local: 20 ajoin ["The sum is " (x + local)]]
&gt;&gt; foo 30
== "The sum is 50"
</code></pre>
<p>I strongly prefer this approach over string concatenation, since by using sensible data structures it integrates much better with the rest of the language. (It also reduces the risk of errors from malformed strings, and potentially the equivalent of SQL injection attacks.)</p>
</blockquote>
</aside>
<p>Note that <a href="https://forum.rebol.info/t/introducing-delimit/2102">Ren-C has DELIMIT (and UNSPACED, SPACED)</a> instead of AJOIN... which hopefully you'll like even better.</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/usefulness-of-string-interpolation/2114">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/usefulness-of-string-interpolation/2114</link>
          <pubDate>Thu, 11 Jan 2024 01:39:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2114</guid>
          <source url="https://forum.rebol.info/t/usefulness-of-string-interpolation/2114.rss">Usefulness of String Interpolation</source>
        </item>
        <item>
          <title>How Much Determinism Should Be Pursued?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>While writing tests for the QUERY dialect against some sample files in a directory, it ran into an issue of the order those files were given back.  <em>Operating system APIs generally do not return the list of files in a determined order, and the ordering across filesystems also varies.</em></p>
<p>This means that even with the same files, you could have the lists come back differently.  One OS could say:</p>
<pre><code>Domain-SQL&gt;&gt; select 'name 'date from %tests/file-tests/
    where 'size &gt; 100 and 'date = 26-Jul-2021

1 [%tests/file-tests/Disk50.txt 26-Jul-2021]
2 [%tests/file-tests/11barz99.txt 26-Jul-2021]
3 [%tests/file-tests/Apple3.txt 26-Jul-2021]
4 [%tests/file-tests/Banana1.txt 26-Jul-2021]
5 [%tests/file-tests/BANANA22.txt 26-Jul-2021]
...
</code></pre>
<p>While another would say:</p>
<pre><code>Domain-SQL&gt;&gt; select 'name 'date from %tests/file-tests/
    where 'size &gt; 100 and 'date = 26-Jul-2021

1 [%tests/file-tests/Apple3.txt 26-Jul-2021]
2 [%tests/file-tests/Banana1.txt 26-Jul-2021]
3 [%tests/file-tests/BANANA22.txt 26-Jul-2021]
4 [%tests/file-tests/Disk50.txt 26-Jul-2021]
5 [%tests/file-tests/11barz99.txt 26-Jul-2021]
...
</code></pre>
<p>This made getting reproducible outputs to verify was hard.</p>
<h2>
<a name="i-made-query-use-sortcase-on-the-read-dir-result-1" class="anchor" href="https://forum.rebol.info#i-made-query-use-sortcase-on-the-read-dir-result-1"></a>I Made QUERY use SORT/CASE on the READ DIR Result</h2>
<p>Getting determinism in the output meant using a function that guarantees an ordering for filenames:</p>
<pre><code>Domain-SQL&gt;&gt; select 'name 'date from %tests/file-tests/
    where 'size &gt; 100 and 'date = 26-Jul-2021

1 [%tests/file-tests/11barz99.txt 26-Jul-2021]
2 [%tests/file-tests/Apple3.txt 26-Jul-2021]
3 [%tests/file-tests/BANANA22.txt 26-Jul-2021]
4 [%tests/file-tests/Banana1.txt 26-Jul-2021]
5 [%tests/file-tests/Disk50.txt 26-Jul-2021]
...
</code></pre>
<p>Having to pay for the sort adds a little bit of overhead, but it's not that significant.</p>
<h2>
<a name="should-read-dir-be-sorted-by-default-2" class="anchor" href="https://forum.rebol.info#should-read-dir-be-sorted-by-default-2"></a>Should READ DIR be Sorted By Default?</h2>
<p>WASI in WebAssembly is looking to chase down sources of non-determinism and see what it can do to stop it.  They mention directory listing order as one potential for problems:</p>
<p><a href="https://github.com/WebAssembly/WASI/issues/190" class="inline-onebox">Roadmap to determinism in WASI · Issue #190 · WebAssembly/WASI · GitHub</a></p>
<p>They seem to believe that on the same OS the directory ordering would be deterministic for the same files, but I don't know of any guarantee of that.</p>
<h2>
<a name="all-this-points-to-bigger-issues-about-reproducibility-3" class="anchor" href="https://forum.rebol.info#all-this-points-to-bigger-issues-about-reproducibility-3"></a>All This Points to Bigger Issues About Reproducibility</h2>
<p>We can pick many examples... like whether a MAP! will always enumerate in the same order on different platforms, or with the same contents.  Using a deterministically sorted implementation of map would seem to have a number of advantages.</p>
<p>Especially since there's a growing push in software for giving deterministic outputs by default.  If you want some reasoning, see this article:</p>
<p><a href="https://buttondown.email/nelhage/archive/determinism-in-software-engineering/" class="inline-onebox">Determinism in software engineering • Buttondown</a></p>
<p>The more testing one does, the more important it seems.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/how-much-determinism-should-be-pursued/2057">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-much-determinism-should-be-pursued/2057</link>
          <pubDate>Thu, 19 Oct 2023 19:34:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2057</guid>
          <source url="https://forum.rebol.info/t/how-much-determinism-should-be-pursued/2057.rss">How Much Determinism Should Be Pursued?</source>
        </item>
        <item>
          <title>Jonathan Blow, and Euclid&#39;s Elements</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Jonathan Blow is a video game developer--who made a well known indie game called "Braid" that did some fun time/space manipulations people generally hadn't seen before in a Mario-type platfomer.   Later he took a number of years to make the much higher-budget art piece The Witness...a very intellectual game which has a Sixth-Sense kind of reveal that's quite good.</p>
<p>Though as time changes him from grumpy indie upstart to grumpy-old-man, he has joined the chorus of us grumpy old men when it comes to complexity:</p>
<p><a href="https://www.youtube.com/watch?v=pW-SOdj4Kkk">Jonathan Blow - Preventing the Collapse of Civilization (English only)</a></p>

<p>But I'm pretty sure he would pretty much hate Redbol languages for programming his games.  He doesn't like scripting, and thinks it's dumb to use things without static typing or that catch your mistakes in advance.  (And I'm with him when he responds to people who say things like "but you can try changes without restarting" are wrongheaded.  You can compile checked bits of code and reload them dynamically if your system is designed right.)</p>
<p>What he's looking for is something that offers the benefits of C++ and Rust, but minus the things he considers to be annoying.  "Something like Rust, but cutting out anything that would be an impediment to the games that I--Jonathan Blow--would write."</p>
<p><a href="https://github.com/BSVino/JaiPrimer/blob/master/JaiPrimer.md" class="inline-onebox">JaiPrimer/JaiPrimer.md at master · BSVino/JaiPrimer · GitHub</a></p>
<p>I imagine that if Jonathan <em>were</em> to appreciate something like Ren-C it would be in the way I do--as a game in itself.  (He actually playtested "Baba is You"--according to a YouTube stream of him playing the final version.  When asked what he was paid to give his feedback he just grumbled "not enough".  So I probably won't be sending Ren-C to him.  :-P)</p>
<p>In any case, he was doing a talk on games in education and cited a page from Euclid's Elements that I thought was interesting.  <a href="https://youtu.be/qWFScmtiC44?t=756">The quote he cites says</a>:</p>
<blockquote>
<p><em>"If a first magnitude has to a second the same ratio as a third has to a fourth, and also a fifth has to the second the same ratio as a sixth to a fourth, then the sum of the first and fifth has to the second the same ratio as the sum of the third and sixth has to the fourth."</em></p>
</blockquote>
<p>I'm sure it sounded like nonsense to Euclid's contemporaries, who were not able (or willing) to follow the reasoning for why such things might be important.</p>
<p>When you're reasoning through new abstract things there's lots of phases to it.  Terminology and mechanics evolve over time.  That's how it works, so people shouldn't be surprised to see things like <em><a href="https://forum.rebol.info/t/the-implications-of-meta-producing-quasi-from-isotopes/1967">"The Implications of ^META Producing QUASI! from Isotopes"</a></em>  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/jonathan-blow-and-euclids-elements/1971">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/jonathan-blow-and-euclids-elements/1971</link>
          <pubDate>Sun, 18 Sep 2022 21:14:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1971</guid>
          <source url="https://forum.rebol.info/t/jonathan-blow-and-euclids-elements/1971.rss">Jonathan Blow, and Euclid&#39;s Elements</source>
        </item>
        <item>
          <title>Rebol&#39;s Mission w.r.t. &quot;not wasting RAM or CPU cycles&quot;</title>
          <dc:creator><![CDATA[WickedSmoke]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Rebol was an attempt at grappling with the problems of overly complex and bloated software.  Part of that means not wasting RAM or CPU cycles.</p>
<p>Optimizing is just a normal part of software development. It's not done to please the programmer, but to build something of quality that respects the user who is running other pieces of software that are also using resources.  Think of it as being a good computational neighbor.</p>
<p>There needs to be some thread here about "computing horror stories". A month ago there was an article on Hacker News about NixOS and it's packaging system.  As some Nix user had just contacted me about packaging xu4, I thought I'd give it a spin.  After downloading the ISO and installing it on a virtual machine I went to get a package listing...<br>
and was greeted with some vague error message.</p>
<p>It turns out that the package manager was using well over 1GB of RAM and simply crapped out because my VM didn't have enough.  Some NixOS user told me:</p>
<blockquote>
<p>"Listing all packages is a bit of a weak spot. The entire package set is described in a lazy, functional language and listing or searching it requires evaluating the entire thing."</p>
</blockquote>
<p>This is an entire OS custom built around a package manager, and it couldn't even give me a listing of my packages.  The Nix developers want to geek out about their language, but I just want tools that work.</p>
<p>Thankfully, data-oriented design is now a thing, so I know at least someone is paying attention.</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rebols-mission-w-r-t-not-wasting-ram-or-cpu-cycles/1970">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rebols-mission-w-r-t-not-wasting-ram-or-cpu-cycles/1970</link>
          <pubDate>Sun, 18 Sep 2022 18:19:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1970</guid>
          <source url="https://forum.rebol.info/t/rebols-mission-w-r-t-not-wasting-ram-or-cpu-cycles/1970.rss">Rebol&#39;s Mission w.r.t. &quot;not wasting RAM or CPU cycles&quot;</source>
        </item>
        <item>
          <title>A Justification of Generalized Isotopes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p><em>Here is a train of thought to help people realize why isotopes are needed, and why unifying their behaviors and mechanisms under a common umbrella makes sense.  It starts from the issue of solving /ONLY and then explains the generalization.</em></p>
<p><em>As time permits, I'll come back and try to improve this...</em></p>
<p><em>NOTE: Terminology has changed over time to where what was once called "the isotopic form" of a value is now called "the antiform", in order to be more consistent with the meaning of the word isotope as describing a group of forms in other fields.  You may see lingering references to the old usage.</em></p>
<hr>
<p>Years of fretting over the /ONLY debacle converged on a somewhat inescapable conclusion:</p>
<p><em><strong>It's better to carry the intent of whether a value needs to be spliced on that value...as opposed to having subtle variants of core operations that modulate the splicing.</strong></em></p>
<p>I'd worked up to a point where I was implementing the "mark of intent" by adding a quoting level to <em>suppress</em> splicing.  Yet this faced likely accidents when someone had a quoted value in a variable...and really meant to use it somewhere as-is, with the quote--vs. thinking of the quote as a splice-suppression signal which the operation should remove.</p>
<p>Then <a href="https://forum.rebol.info/t/putting-splicing-intent-on-appended-value/1873/9">@rgchris made this remark</a>:</p>
<aside class="quote no-group quote-modified" data-username="rgchris" data-post="9" data-topic="1873" data-full="true">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"><a href="https://forum.rebol.info/t/putting-splicing-intent-on-appended-value/1873/9">Putting Splicing Intent On APPEND'ed Value</a>
</div>
<blockquote>
<p>The issue I have with doing the opposite of ONLY—let's call it SPREAD—is what is the interim value?</p>
<pre><code>&gt;&gt; block: [a b c [a b c]]

&gt;&gt; find block pick block 4
[[a b c]]

&gt;&gt; find block spread pick block 4
[a b c [a b c]]

&gt;&gt; spread pick block 4
???
</code></pre>
<p>It would seem to have virtue over ONLY and is a better word.</p>
</blockquote>
</aside>
<h2>
<a name="if-trying-this-in-historical-redbol-what-might-one-do-1" class="anchor" href="https://forum.rebol.info#if-trying-this-in-historical-redbol-what-might-one-do-1"></a>If Trying This In Historical Redbol, What Might One Do?</h2>
<p>As a rough first cut, let's represent splices with a specially recognizable 2-element wrapper block.  We'll signal it's a splice with a series in the first slot--checking for the unique identity of that series.  Then put the block itself as the second element:</p>
<pre><code>splice-cue: "!!!splice!!!"

spread: func [block [block!]] [
    return reduce [splice-cue block]
]

splice?: func [value] [
    if not block? :value [return false]
    return same? splice-cue first value
]
</code></pre>
<p>Then we can write our new versions of things like APPEND that are specifically aware of this construct.</p>
<pre><code>append*: func [series [series!] value] [
    return either splice? :value [
        append series second value
    ][
        append/only series :value
    ]
 ]
</code></pre>
<p>It works more or less in your average Redbol, e.g. in Red:</p>
<pre><code>red&gt;&gt; append* [a b c] spread [d e]
== [a b c d e]

red&gt;&gt; append* [a b c] [d e]
== [a b c [d e]]

red&gt;&gt; append* [a b c] 'd
== [a b c d]

red&gt;&gt; append* [a b c] first ['d]
== [a b c 'd]
</code></pre>
<p><em>In fact, this is essentially how the bootstrap executable for Ren-C simulates the SPREAD behavior.</em></p>
<p>But the weaknesses are <em>immediately</em> apparent!!!  <img src="https://forum.rebol.info/images/emoji/twitter/pouting_cat.png?v=12" title=":pouting_cat:" class="emoji" alt=":pouting_cat:" loading="lazy" width="20" height="20"></p>
<h2>
<a name="not-a-distinct-type-too-easy-to-overlook-handling-2" class="anchor" href="https://forum.rebol.info#not-a-distinct-type-too-easy-to-overlook-handling-2"></a>Not A Distinct Type: Too Easy To Overlook Handling</h2>
<p>There's no special type for the spliced block...it's just a BLOCK!.  This means any routine that hasn't been written to handle it, will just let it leak through.</p>
<pre><code>red&gt;&gt; reduce [spread [a b c] [a b c]]
== [["!!!splice!!!" [a b c]] [a b c]]  ; not [a b c [a b c]]
</code></pre>
<p>Changing to some other generic type that can contain a block...such as an OBJECT!...doesn't help matters.  You are kind of in trouble any time an operation willfully lets you put these into an array.</p>
<p><strong>The first instinct might be to introduce a new SPLICE! datatype, with a system-wide rule that splices can't be put into arrays.</strong>  <em>(Enforcing such a rule across all array-manipulating code is challenging...so let's sort of make a note of that fact, but continue.)</em></p>
<p>Because of the peculiar nature of not being able to be put in a block, there'd have to be a decision made about function arguments as to whether or not they took this type.  Many functions designed to handle generic values would not be able to handle them, so there'd presumably need to be some typeset like ANY-NOTSPLICE! or ANY-NORMAL!.</p>
<h2>
<a name="how-to-represent-a-type-that-cant-be-put-in-a-block-3" class="anchor" href="https://forum.rebol.info#how-to-represent-a-type-that-cant-be-put-in-a-block-3"></a>How To Represent A Type That Can't Be Put In A Block?</h2>
<p>Now we've got several things to ponder about our new type.  For instance: what you should see here?</p>
<pre><code>&gt;&gt; obj: make object! [foo: spread [d e]]
== make object! [
    foo: ???
]
</code></pre>
<p>We just said that a defining feature of SPLICE! is that you can't accidentally put them in blocks.  But the argument to MAKE OBJECT!, namely <strong><code>[foo: ???]</code></strong>, is a block.  If <code>???</code> can't itself be a splice!, then what is it?</p>
<p>This brings up a possibly-related question: what if you want a way to put the intent of whether to splice or not into "suspended animation?"... in a way that you could collect it?</p>
<p>Here's a sort of contrived example of the puzzle:</p>
<pre><code>generate: func [n [integer!]] [
   if even? n [return reduce [n n + 1]]
   return spread reduce [n n + 1]
]

wrap: func [
    return: [...]
    in [splice! block!]
][
    ...
]

unwrap: func [
    return: [splice! block!]
    wrapped [...]
][
    ...
]

n: 0
pending: collect [while [n &lt; 4] [keep wrap generate n]]

data: copy []
for-each item pending [append data unwrap item]
</code></pre>
<p>How would you write WRAP and UNWRAP such that at the end of the code above, you'd get:</p>
<pre><code>&gt;&gt; data
== [[0 1] 1 2 [2 3] 3 4]
</code></pre>
<p>If the system didn't provide some answer to this, you'd end up needing to re-invent something kind of equivalent to the primitive <code>["!!!splice!!!" [...]]</code> mechanic as a means of persistence:</p>
<pre><code>&gt;&gt; pending
== [[0 1] ["!!!splice!!!" [1 2]] [2 3] ["!!!splice!!!" [3 4]]]
</code></pre>
<h1>
<a name="isotopes-were-designed-for-this-4" class="anchor" href="https://forum.rebol.info#isotopes-were-designed-for-this-4"></a>Isotopes Were Designed For This!</h1>
<p>Isotopes are a set of curated answers for these problems.  Originally they were introduced to address issues like what an UNSET! was...which has some of the same class of problems as SPLICE! (such as not wanting to be put in BLOCK!s, and not accepted by default or by most routines).</p>
<p>Isotopes introduce two new variants of datatypes called <em>antiforms</em> and <em>quasiforms</em>.  Antiforms cannot be put in blocks.</p>
<p>Isotopes are:</p>
<ul>
<li>
<p><strong>general</strong> - all base value types (e.g. unquoted things) can have antiforms and quasiforms</p>
</li>
<li>
<p><strong>efficient</strong> - antiforms and quasiforms do not require allocations, and merely are a different state of a byte in the value cell (the same byte that encodes quoting levels)</p>
</li>
<li>
<p><strong>"meta-representable"</strong> - all antiforms can be produced by evaluating their quasiforms, and quasiforms can be produced by evaluating quoted quasiforms.</p>
</li>
</ul>
<p>I mentioned at the outset that it would be somewhat costly to bulletproof all of native code against the ability to do something like append a specific data type like "SPLICE!" to a block.  But with isotopes this problem has been solved once for all the forms...so the same code that prevents a so-called "UNSET!" from winding up in arrays works for splices.  <em>That's because a splice is actually a group! antiform, and an unset variables actually hold BLANK! antiforms!</em></p>
<p>Above I asked:</p>
<blockquote>
<p>What you should see here?</p>
<pre><code>&gt;&gt; obj: make object! [foo: spread [d e]]
== make object! [
    foo: ???
]
</code></pre>
</blockquote>
<p>Isotopes give us the answer, that it's <strong><code>foo: ~(d e)~</code></strong>.  This is the previously mentioned "QUASIFORM!" of GROUP!, which when evaluated produces an antiform of GROUP!...which by convention represents a splice.</p>
<p><em>But antiforms themselves have no canon representation.</em>  The console can print out a comment or show them in a different color, but to talk about them having a representation doesn't make much sense as you'll never see them in source.</p>
<pre><code>&gt;&gt; ~(d e)~
== ~(d e)~  ; anti
</code></pre>
<p>I also asked:</p>
<blockquote>
<p>"How would you write WRAP and UNWRAP such that at the end of the code above, you'd get:"</p>
<pre><code>&gt;&gt; data
== [[0 1] 1 2 [2 3] 3 4]
</code></pre>
</blockquote>
<p>With group antiforms representing splices, you don't need to write WRAP and UNWRAP... because these operations are built in operations called META and UNMETA.  And the pending array would look like:</p>
<pre><code>&gt;&gt; pending
== ['[0 1] ~(1 2)~ '[2 3] ~(3 4)~]
</code></pre>
<p>When the QUOTED! blocks are UNMETA'd, they become regular blocks and then are appended as-is.  When the QUASIFORM! groups are UNMETA'd they become antiforms and give the splice intent.  This produces the desired "suspended animation" to preserve the intent.</p>
<p><em>That suspended animation is also used in the ^META parameter convention, which indicates a function argument can accept arbitrary antiforms... and the add-quoting-or-quasi behavior brings those antiform variables into a reified state so they can be safely handled.</em></p>
<h2>
<a name="the-proof-is-in-the-capabilities-5" class="anchor" href="https://forum.rebol.info#the-proof-is-in-the-capabilities-5"></a>The Proof Is In The Capabilities</h2>
<p>I've explained about splices, and mentioned how it crosses needs with unset variable states.</p>
<p>But it's also <a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604">how NULL and VOID are implemented</a>, as antiforms of WORD! states that can't be put in blocks.</p>
<p>The ERROR! antiform is used to have a sneaky out-of-band way to return <a href="https://forum.rebol.info/t/fail-vs-return-fail-the-new-age-of-definitional-failures/1852">definitional errors</a></p>
<p>The FRAME! antiform is what we'd traditionally think of as an "ACTION!" or "FUNCTION!".  It triggers execution if accessed via WORD! references.  This makes it safe to handle items picked out of blocks without worrying about defusing actions...because only quasiform or plain frames can be put in blocks in the first place!</p>
<p>It's natural for there to be some confusion with the new idea--especially given all its churn through the course of design.  But the design is becoming clearer, and I think people are going to find this gives solidity to writing complicated but coherent code...vastly outpacing historical Redbol.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918</link>
          <pubDate>Tue, 16 Aug 2022 10:23:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1918</guid>
          <source url="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918.rss">A Justification of Generalized Isotopes</source>
        </item>
        <item>
          <title>The Rebellion Against Style Guides</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>While driving from Huntsville to Florida, I listened to a talk given by a guy who oversees the general style guide for all of Google's multi-millions of lines of C++.</p>
<p>He spoke very positively about a formatting tool called <code>clang-format</code>, and how if he had his way at Google...there would be no arguing over code formatting.  He felt the robot did a better job on average than even the best developers...and being willing to delegate formatting to the tool gave them time to work on more important things.</p>
<p><strong>My well-known opinion for code like C++ or Rust or Java is that it is best represented as a graph data structure that captures the relationships and identities.</strong>  How you render that is up to the program you use to view and edit the projection of that essential code.  It doesn't matter if code is in braces or has a box drawn around it.  You could make expressions feed into an actual logical circuit AND gate instead of using <code>&amp;&amp;</code> or the word <code>and</code> or what-have-you.</p>
<p><strong>But Rebol is different (and almost absurdist) in the software world.</strong>  If anything, it has an <em>anti</em>-style guide, in <a href="http://www.rebol.com/article/0103.html">The Deep Lake / (Swamp)</a>, where Carl says:</p>
<blockquote>
<p>Suppose I write:</p>
<pre><code>if time &gt; 10:00 [
    wakeup user
]
</code></pre>
<p>which some users may choose to rewrite it this way:</p>
<pre><code>if time &gt; 10:00
[
    wakeup user
    alert "Time to work"
 ]
</code></pre>
<p>But, what if the "then block" is a variable itself, defined as:</p>
<pre><code> action: [
     wakeup user
     alert "Time to work"
  ]
</code></pre>
<p>Would you write this:</p>
<pre><code>  if time &gt; 10:00
      action
</code></pre>
<p>or this:</p>
<pre><code>   if time &gt; 10:00 action
</code></pre>
</blockquote>
<p>The conclusion is:</p>
<blockquote>
<p>...<strong>how you write code is ultimately your choice alone</strong>. REBOL, as a context dependent language, is perhaps the most freeform computing language ever invented.</p>
</blockquote>
<p>I'm bringing this up because I'm mothballing an old Trello and looking for any links or information worth preserving.  It had a card requesting a style guide, pointing out a limited bit that had been written in the Rebol2 manual:</p>
<p><a href="http://www.rebol.com/docs/core23/rebolcore-5.html#section-5">http://www.rebol.com/docs/core23/rebolcore-5.html#section-5</a></p>
<p>I'm really only interested in the bits that reduce complexity (like just-say-no-to-CRLF files, or tabs, etc.)  As for the code itself, this is kind of an ASCII-art medium.</p>
<p>So a good "style guide" for Rebol would be one that showed examples of how to take advantage of the degrees of freedom to be bent to your purposes.  I think a good one was the <strong><a href="https://forum.rebol.info/t/testing-generic-tuple-and-path-structuring/1353">tuple and path test dialect</a></strong>.  But there are certainly more!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-rebellion-against-style-guides/1819">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-rebellion-against-style-guides/1819</link>
          <pubDate>Sat, 14 May 2022 05:39:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1819</guid>
          <source url="https://forum.rebol.info/t/the-rebellion-against-style-guides/1819.rss">The Rebellion Against Style Guides</source>
        </item>
        <item>
          <title>Turning a Blind Eye to Evaluator &quot;Abuse&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>I've gotten kind of attached to the current look and behavior of AND and OR, which allow short-circuiting even though one would not think the language could (should?) be able to.</p>
<p>It doesn't require simple variables be in a GROUP! on the right hand side.</p>
<pre><code>&gt;&gt; if true and true [print "True"] else [print "False"]
True
</code></pre>
<p>...but a function call has to be.</p>
<pre><code>&gt;&gt; foo: func [x] [
      print "Calling foo!"
      return x &gt; 1000
   ]

&gt;&gt; if false and foo 1020 [print "True!"] else [print "False"]
** Error: words/tuples can't be ACTION! as right hand of OR, AND, XOR

&gt;&gt; if false and (foo 1020) [print "True"] else [print "False"]
False

&gt;&gt; if true and (foo 1020) [print "True!"] else [print "False"]
Calling foo!
True
</code></pre>
<p><em>Note that if the thing to the left of the AND is false, it does not run the code in the GROUP! on the right.</em>  This requires that the right hand side be a quoted parameter convention.</p>
<p>Alternatively we could not quote it, and require the right hand side be in a block:</p>
<pre><code>&gt;&gt; if true and [true] [print "True"] else [print "False"]
True

&gt;&gt; if false and [foo 1020] [print "True"] else [print "False"]
False
</code></pre>
<p><strong>But I don't like that.</strong></p>
<p>Alternatively we could say we don't offer this and you always use ALL...maybe with COMMA! and maybe not:</p>
<pre><code>&gt;&gt; if all [true true] [print "True"] else [print "False"]
True

&gt;&gt; if all [false, foo 1020] [print "True"] else [print "False"]
False
</code></pre>
<p>I just don't think that looks as natural.</p>
<h2>It's Like I Said In <a href="https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359">"Speaking With Tics"</a>...</h2>
<p>If you think seeing a GROUP! on the right of AND and OR that doesn't unconditionally evaluate at the callsite is weird, why are you comfortable with <strong><code>for-each x [1 2 3] [...]</code></strong>?  That didn't unconditionally evaluate x.  Do you expect it to be <strong><code>for-each 'x</code></strong> instead?</p>
<aside class="quote no-group">
<blockquote>
<p>The quoted parameter convention exists to save you the trouble of quoting the callsites. <em>If this isn't what that's for, then what <strong>is</strong> it for?</em></p>
</blockquote>
</aside>
<p>It's just too nice to be able to say things like <strong><code>if var1 and var2 or (a &gt; b) [...]</code></strong>.</p>
<p>To me, part of what makes the language special is the ability to bend the evaluator to how we want to read code, vs bending code to fit the evaluator.  The existence of mechanics like quoted parameters are there to let this happen.</p>
<p><em>You don't have to use it.</em>  And the ability to switch it to where AND is a prefix operator that does bitwise math is the magic of the freedom of choice.  You can choose to change the definition even on a module-by-module basis, or on a function-by-function basis.</p>
<p>Further: if you're not bending the language, you're probably not really using it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/turning-a-blind-eye-to-evaluator-abuse/1791">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/turning-a-blind-eye-to-evaluator-abuse/1791</link>
          <pubDate>Fri, 18 Feb 2022 18:34:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1791</guid>
          <source url="https://forum.rebol.info/t/turning-a-blind-eye-to-evaluator-abuse/1791.rss">Turning a Blind Eye to Evaluator &quot;Abuse&quot;</source>
        </item>
        <item>
          <title>Regarding The &quot;Finality&quot; Of FAIL, RETURN, etc.</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>There are some functions that by name carry a certain <em>"finality"</em>.  You don't expect there to be a way to pass them an argument that will revoke them.</p>
<p>For instance, it would be a bit weird if FAIL followed the BLANK-IN, NULL-OUT convention:</p>
<pre><code>foo: func [error [error! blank!]] [
    fail error

    print "This looks like unreachable code."
]
</code></pre>
<p>Today we don't offer that Wayne's World version of "FAIL.... NOT!"  So you have to write:</p>
<pre><code>if error [fail error]
</code></pre>
<p>I've actually been in situations where repeating the error expression is complicated by things like API handle freeing issues, to where I've considered making something like MAYBE-FAIL which would be a No-Op on BLANK!... or perhaps a refinement as FAIL/MAYBE.</p>
<p>But I've not considered the idea of making plain FAIL a no-op on blanks.  That seems wrong.</p>
<h2>Does RETURN Have A Similar "Finality"?</h2>
<p>I've written a bunch about <a href="https://forum.rebol.info/t/uparse-return-subtleties/1589/4">how I stopped worrying and learned to love UPARSE's RETURN</a>.</p>
<p>But there's something a little weird to my tastes about it being "non-final".  For example:</p>
<pre><code>&gt;&gt; uparse "aabc" [some "a" return "x" | some "a" return "b"]
== "b"  ; today's answer (also R3-Alpha's answer with PARSE)
</code></pre>
<p>When it reached the point of RETURN "X", there were two potential interpretations:</p>
<ol>
<li>
<p><em>"Okay, it's time to return!  Let's see if this rule matches or not...and if not, we're returning NULL!"</em></p>
</li>
<li>
<p><em>"It might be time to return if this rule matches.  If it doesn't match, pretend we were never asked to return."</em></p>
</li>
</ol>
<p>Today we have (2).  It's strictly more powerful... as you can get (1) with <strong>return opt "x"</strong>.</p>
<pre><code>&gt;&gt; uparse "aabc" [some "a" return opt "x" | some "a" return opt "b"]
; null
</code></pre>
<p>Note also that if your RETURN value is in a GROUP! and evaluated as DO code instead of a rule, it will always succeed...and hence always final.  It's only when you pass a rule that it can get revoked.</p>
<p>As with needing to write <strong>if error [fail error]</strong>, if we switched to parse-RETURN-finality that would mean more code for opting out:</p>
<pre><code>; opting out in RETURN-non-final style
uparse data [... return [your rule here] ...]

; opting out in RETURN-final style
uparse data [... result: [your rule here] return (result) ...]
</code></pre>
<p><strong>But I still feel weird about RETURN in PARSE being something that can just be opted out of by the nature of its argument.</strong></p>
<p>And so far, every time I've wanted to use RETURN it has been either a RETURN of a GROUP! (thus unconditional) or a RETURN OPT.</p>
<p>So I'm thinking of making RETURN "final"...if you give it a rule that doesn't match it returns NULL.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/regarding-the-finality-of-fail-return-etc/1735">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/regarding-the-finality-of-fail-return-etc/1735</link>
          <pubDate>Sun, 03 Oct 2021 15:49:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1735</guid>
          <source url="https://forum.rebol.info/t/regarding-the-finality-of-fail-return-etc/1735.rss">Regarding The &quot;Finality&quot; Of FAIL, RETURN, etc.</source>
        </item>
        <item>
          <title>Should Built-In Constructs Leverage More &quot;Reserved Words&quot;?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>I was looking at an old proposal for using <strong>|</strong> in PRINT to mean "newline".</p>
<pre><code>print [
    "DESCRIPTION:" |
    tab, any [description, "(undocumented)"] |
    tab (uppercase word) {is} classification #"."
]
</code></pre>
<p>That was taken off the table due to <strong>|</strong> being used as an expression barrier.  But COMMA! is doing a much better job of that, so it's back in the realm of possibility.</p>
<p>And I was also looking at some API code in ODBC like this:</p>
<pre><code>rebValue(
    "switch @", ARG(encoding), "[",
        "'utf-8 [", rebI(CHAR_COL_UTF8), "]",
        "'ucs-2 [", rebI(CHAR_COL_UTF16), "]",
        "'utf-16 [", rebI(CHAR_COL_UTF16), "]",
        "'latin-1 [", rebI(CHAR_COL_LATIN1), "]",
    "] else [",
        "fail {ENCODING must be UTF-8, UCS-2, UTF-16, or LATIN-1}"
    "]"
);
</code></pre>
<p>It made me wonder what if SWITCH let you use something like, say, fat arrow:</p>
<pre><code>rebValue(
    "switch @", ARG(encoding), "[",
        "'utf-8 =&gt;", rebI(CHAR_COL_UTF8),
        "'ucs-2 =&gt;", rebI(CHAR_COL_UTF16),
        "'utf-16 =&gt;", rebI(CHAR_COL_UTF16),
        "'latin-1 =&gt;", rebI(CHAR_COL_LATIN1),
    "] else [",
        "fail {ENCODING must be UTF-8, UCS-2, UTF-16, or LATIN-1}"
    "]"
);
</code></pre>
<h2>Are Core Constructs Underplaying Their Hand?</h2>
<p>I've felt for a long time that PRINT is not strong enough, because it hasn't taken things like TAG! away to signal format changes (colors?).</p>
<p>And when I look at the difference we get in SWITCH above, esp in the API, it makes me wonder if something like that is appropriate.  Though maybe the @ symbol is better to be pushed further to this purpose as a legal branch type...</p>
<p>...anyway the details aren't important.  I guess I'm asking more <em>"could we make a better language if we were more willing to steal words"</em>.</p>
<p>Do we need distinctions...such as "core switch" and "rich switch", and then let people pick which they use?  Where they're expected to hack up the switch to customize it to their tastes?</p>
<p>(Just wanted to put this out there, as I'm deleting a note about | as newline in PRINT on the Trello.)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-built-in-constructs-leverage-more-reserved-words/1622">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-built-in-constructs-leverage-more-reserved-words/1622</link>
          <pubDate>Sat, 05 Jun 2021 16:47:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1622</guid>
          <source url="https://forum.rebol.info/t/should-built-in-constructs-leverage-more-reserved-words/1622.rss">Should Built-In Constructs Leverage More &quot;Reserved Words&quot;?</source>
        </item>
        <item>
          <title>Debunking the Arity-1 MAKE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Rebol2, R3-Alpha, and Red embrace the idea of an arity-1 MAKE, that you use for any type.</p>
<p>When a single parameter seems insufficient to create a datatype, it just stuffed the two things into a BLOCK!.  That led to things like this FUNC definition in the bootstrap for R3-Alpha...which is a weird two-step process.  It wants to copy the spec/body in most cases, but the mezzanine optimizes and does not write code in a style that would need to copy the spec/body...so there's a "funco" helper:</p>
<pre><code>funco: make function! [[
    {Non-copying function constructor (optimized for boot).}
    spec [block!] {Help string (opt) followed by arg words}
    body [block!] {The body block of the function}
][
    make function! reduce [spec body]
]]

func: funco [
    {Defines a user function with given spec and body.}
    spec [block!] {Help string (opt) followed by arg words}
    body [block!] {The body block of the function}
][
    make function! copy/deep reduce [spec body]  ; (now it deep copies)
]
</code></pre>
<h2>Is This Just "Make-Work"? (pun intended)</h2>
<p>Imagine a different approach in which FUNC itself is just a native that takes two parameters and makes a function out of it.  There would be several benefits:</p>
<ul>
<li>
<p>You don't need to run a REDUCE to make a block that you're ultimately just going to separate into two blocks.  That's wasted space and computation.  The FUNC passes through the two blocks separately.</p>
</li>
<li>
<p>You avoid looking into a table of MAKE dispatchers, breaking down a block and re-type checking it to make sure it's a block of exactly two other blocks.  The FUNC type checking takes care of that on the independent proeprties.</p>
</li>
<li>
<p>If there's a low-level property such as not copying the blocks passed in, that could be handled by a refinement (/NOCOPY) which makes the distinction clearer in the cases that use it.</p>
</li>
</ul>
<p>Faster, clearer.  No one really uses the "polymorphism" of <strong>make some-type some-definition</strong> without really knowing what type or definition is, right?  That seems essentially meaningless.</p>
<h2>So What Is The Theoretical Value of Arity-1 MAKE?</h2>
<p>I'd assumed that the actual theoretical value was something along the lines of <em>having a serialization form of every type as a BLOCK!</em> (or other simple type)</p>
<p>Perhaps the reasoning went:</p>
<ul>
<li>
<em>if</em> you can <em>create</em> any type from a single argument like a BLOCK!</li>
<li>...then that means you can MOLD any instance of a value into that same representation.</li>
</ul>
<p>So what I did in the early days of Ren-C is I tried to enforce a correspondence between <strong>make function! [...]</strong> and <strong>#[function! [...]]</strong>.  The code that was dispatched by MAKE was the same code that constructing a molded function would call.</p>
<p><em>That was a nice thought, but due to binding, it doesn't actually work.</em>  Basic disproof:</p>
<pre><code>&gt;&gt; obj: make object! [y: 10]

&gt;&gt; f: func [x] bind [x + y] obj

&gt;&gt; y: 100

&gt;&gt; molded: mold f
== "#[action! [[x] [x + y]]]"

&gt;&gt; g: load molded

&gt;&gt; f 1
== 11

&gt;&gt; g 1
== 101
</code></pre>
<p>The only real way to preserve the loaded connections of things is in some kind of binary serialization format (like "redbin" is pursuing)...or to always be storing the session's memory as a persistent VM state (like Smalltalk's Squeak and such).</p>
<h3>...any counter-arguments in defense of the usefulness of Arity-1 Make?</h3>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/debunking-the-arity-1-make/1591">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/debunking-the-arity-1-make/1591</link>
          <pubDate>Fri, 30 Apr 2021 16:54:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1591</guid>
          <source url="https://forum.rebol.info/t/debunking-the-arity-1-make/1591.rss">Debunking the Arity-1 MAKE</source>
        </item>
        <item>
          <title>Weird WORD!s - Allow, But Escape Them?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>My feeling is you should be able to build paths and tuples out of anything that's a valid WORD!.  But is it time we had an escaping mode for "weird words"?</p>
<p>Let's say you didn't want <strong><code>&lt;.&gt;</code></strong> to be a  TAG!, but rather a TUPLE! where the first element was <strong><code>&lt;</code></strong> and the second was <strong><code>&gt;</code></strong>.</p>
<p>We could do something like backquotes:</p>
<pre><code>`&lt;`.`&gt;`
</code></pre>
<p>Having an escaping mode for words would open up more lexical space.  For instance,  I like the idea of allowing $FOO, $(FOO), $FOO/BAR, $[FOO BAR] etc. as another type...</p>
<p>But this would seem to kill off the idea of being able to have <code>$</code> and <code>$$</code> etc. as WORD!s, because you get into ambiguous situations... is $/foo a PATH! with the $ word in the first slot, or an ENV-PATH! with an empty first slot?</p>
<p>These ambiguities create problems for other things that might stand alone all right, because we don't want to have "second-class-citizen" WORD!s that can't appear in paths.</p>
<p>But what if we used backticks if they wind up in paths?</p>
<pre><code>`$`/foo   ; PATH! with $ in the first slot
$/foo  ; ENV-PATH! with blank in the first slot
</code></pre>
<p>This could give us the likes of <code>:</code> and <code>::</code> as operators...</p>
<pre><code>&gt;&gt; `:`: does [print "I am colon!"]

&gt;&gt; :
I am colon!

&gt;&gt; type of :`:`
== #[datatype! action!]
</code></pre>
<p>It could work for other standalone characters, like <strong><code>@</code></strong> and perhaps <strong><code>&amp;</code></strong>.  <strong>%</strong> could be the same (with %"" or %{} used for empty file)</p>
<p>I feel like # and / may not be good candidates for this treatment, it would need more thought.</p>
<p><strong>The point wouldn't be that you'd likely be going crazy with paths involving these characters, but rather that you might want to do interesting things with them standalone.</strong>  It's just to put them on the map as legitimate words.</p>
            <p><small>13 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560</link>
          <pubDate>Mon, 15 Mar 2021 03:30:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1560</guid>
          <source url="https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560.rss">Weird WORD!s - Allow, But Escape Them?</source>
        </item>
        <item>
          <title>Don&#39;t Fear The WORD!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Something Rebol touts as a big advantage is that it hasn't pinned a meaning to any words, so you can use them to mean what you want.</p>
<p>But I frequently have stressed over this, because words have associated costs that are non-trivial.</p>
<h2>Example: The Section Divider: <strong><code>===</code></strong>
</h2>
<p>I thought it would be neat if we could use this to have a Markdown-Like split of headers which just used plain words:</p>
<pre><code>all [
    === STEP WITH JUST WORDS ===

    step1 arg1

    === {STEP WITH STRING, NOT AS PLEASING} ===

    step2 arg2
]
then [
    print "=== is invisible, so it doesn't interfere with things like ALL!"
]
</code></pre>
<p>The idea is that it could be hooked in ways a comment couldn't...to print out messages to know you've reached the step (for instance).</p>
<p>Because I thought it was more pleasing, I designed it to permit words.  === was as a variadic function which would keep looking across its input until it found a === to terminate.</p>
<p><em>(Note: Wanting to reclaim <strong>==</strong> for using as an even briefer way of saying "section" is one of several motivators for cleaning up the use of it for equality)</em></p>
<p>But there are issues that come up from trying to write strings without string delimiters in Redbol.</p>
<p><strong>You have to write LOAD-able syntax.</strong>  Having COMMA! makes it a bit more tolerable, but you can still get in trouble with unusual uses of other characters.</p>
<pre><code>=== Here's a 3rd example; broken! ===
</code></pre>
<p>That's going to not be able to handle <code>3rd</code> in the current system (though <a href="https://forum.rebol.info/t/pack-sequence-type/1503">the PACK! proposal</a> could help here).  Then the semicolon will wind out commenting stuff out.</p>
<p><strong>Meaning of GROUP! is contentious.</strong>  I use a lot of parentheses when I write text, and not mean running code.  But we presumably want a way to get expressions in there:</p>
<p>That might not be a problem if we limit that to GET-GROUP!.</p>
<pre><code>=== DEMO OF VARIATIONS (GROUP EXAMPLE) ===

count-up n 100 [
    === Running Step :(n) ===
    print "This might be a way of doing it?"
]
</code></pre>
<p>Another alternative could be to use blocks for any evaluated portions, since square brackets don't often come up in English writing.</p>
<p><strong>Plenty of Other Questions</strong>... I don't want to tackle them all here, because I'd like to move to the big issue.</p>
<h2>Biggest Issue: Creating Tons Of Stray Bindings</h2>
<p>On the happy side, with LET we are moving into an idea of dynamism in binding so that using a SET-WORD! doesn't get you a local.  That keeps this from throwing in a local definition of PARSE:</p>
<pre><code>foo: function [data] [
    === BEGIN PARSE: It would suck if this overwrote PARSE! ===
    parse data [...]  ; if PARSE: was gathered as local, parse would be unset
]
</code></pre>
<p>Things like this are why I was so adamant against locals gathering.  It's good that it's gone from standard use, and relegated to being a weird feature for code golfing.  LET may be slow right now, but better to be slow than absolutely wrong.  Slow features can be sped up.  Wrong features can only be deleted.</p>
<p>The storage and loading of words themselves is actually pretty efficient.  The system is geared around it.  I'm not terribly concerned about the storage overhead difference between strings and a bunch of words.</p>
<p><strong>What's more troubling is all the bindings made in the user context.</strong>  These words don't know their binding isn't going to be used.  So the user context gets expanded and expanded.</p>
<p>I won't rewrite the explanation of this here.  But see <strong><a href="https://forum.rebol.info/t/the-real-story-about-user-and-lib-contexts/764">The Real Story About User and Lib Contexts</a></strong></p>
<h2>I Think Supporting Words This Way Is Mission Critical</h2>
<p>There are a lot of kneejerk responses which would dislike <strong>===</strong> in the form that I suggest.</p>
<p>Some people wouldn't like that it's variadic.  They might believe the principle of Rebol is based on blocks...so variadic functions shouldn't even be in the language to begin with.  I think they're wrong, and we now depend on variadicness quite a lot.</p>
<p>Others might worry about the overhead caused by bloating up the symbol space...or the length of the code block.  Or the CPU cycles consumed by having to run a variadic loop across the content of the line...one value at a time.</p>
<p><strong>But I think my leaning is that being able to choose to work this way is the distinguishing factor of the language.</strong></p>
<p>You can still use <strong><code>=== {Text} ===</code></strong> if you really want to.  Or you can avoid using === altogether and just use a comment like <strong><code>;===</code></strong> or <strong><code>;;</code></strong> and it won't have any runtime aspects at all...though then you won't get a log when it reaches that line if you want it.</p>
<p>Using bash is making me realize that even as light as Rebol can be a lot of the time, it's still too heavy sometimes.  Having to put things in quotes adds up 2 characters at a time, over time.  We should keep an eye on bending the mechanics to make it possible to use LOAD-ed "Rebol sentences" literally, and find places where that makes sense.</p>
<h2>This Means Binding Has To Be Rethought... More...</h2>
<p>We're just pinning down more of the requirements.  So as those requirements get locked, then hopefully that will make a design "emerge".</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/dont-fear-the-word/1549">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dont-fear-the-word/1549</link>
          <pubDate>Wed, 10 Mar 2021 03:17:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1549</guid>
          <source url="https://forum.rebol.info/t/dont-fear-the-word/1549.rss">Don&#39;t Fear The WORD!</source>
        </item>
        <item>
          <title>Pivotal Design Question: Is Evaluator State Just A Block?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>I ran into a hitch with LET and EVALUATE in single-stepping.</p>
<p>It raises a pretty big question about how much we want to tie the hands of the evaluator in favor of "simplicity".</p>
<h2>The Problem</h2>
<p>On the surface a LET statement might seem impossible for step by step evaluation:</p>
<pre><code>&gt;&gt; block: evaluate [let x: 10 print ["X is" x]]
== [print ["X is" x]]
</code></pre>
<p>That LET statement declared a variable, but where did it go?  It only lives until the block is over.  It would seem that the PRINT is out of luck.</p>
<p><em>But...</em> I could make it work since a BLOCK! can carry along virtual binding state.  So, at each step you just get a little more state added on.  The <strong>[print ["X is x]]</strong> is <em>different</em> from the block you'd have gotten from saying SKIP 3 on the full block, due to this binding.</p>
<p><strong>But what if you reposition the block?</strong></p>
<pre><code>&gt;&gt; block: head block
== [let x: 10 print ["X is" x]]
</code></pre>
<p>Now you have a block that has X defined in its bindings, and if you step through it you'll define it again.</p>
<h2>Can This Be Solved?</h2>
<p>I think the cleanest and clearest way to solve it is to rethink EVALUATE so that it operates on a FRAME!...not a BLOCK!.  This would match the internal model better.</p>
<p>Today, we have to tear down a frame and build up a new one each time you do a step.  This would say that you'd be keeping it alive.</p>
<p>You'd be limited in terms of being able to look back over past values you had already evaluated.  That limitation would keep you from rewinding... if you wanted to go back and do things over, you'd have to do that by working with your original block that started the whole process.</p>
<p>What you'd be able to do in terms of looking ahead would be more like what a variadic is able to do today.</p>
<h2>The Big Philosophical Question</h2>
<p>I guess the big philosophical question is not necessarily so much about LET itself, but <strong>should we rule out the existence of things like LET in general</strong>.</p>
<p>In other words: is it imperative to step the evaluator across a block and <em>not</em> accrue any state particular to that evaluation?</p>
<p>I've been kind of looking for a convergence between things like the evaluator and PARSE, and so asking what the restrictions on the evaluator are may be asking what the restrictions are on anything that tries to leverage the FRAME!-based processing of blocks...for tracking positions, giving errors, etc.  If we require them all to be amnesiacs after every step, this would make it hard to write things like the COLLECT/KEEP feature in parse with the rollback feature...because it would have to record its state in some external thing.</p>
<p><a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> --^ please see that and think about it.  If EVALUATE returned a FRAME! representing the block and not a new position of a block, what kind of disruption would it be?  Do you see the accrual of state in the evaluator to be something that should be ruled out--thus killing off LET or anything like LET--to be worth it to have the feature of a memoryless evaluator?</p>
<hr>
<p><strong>My leaning on this is to say that we would be crippling the language by ruling out LET-like things in the design.</strong></p>
<p>Right now, I have this test code working.  Note it's three evaluation steps, because the LET is actually invisible (1 unit lookahead to see x and add the binding, then leaves <code>x: 10</code> to run normally)</p>
<pre><code>x: &lt;in-user-context&gt;
output: '~unset~
block: evaluate evaluate evaluate [let x: 10 output: x]
did all [
    block = []
    output = 10
    x = &lt;in-user-context&gt;
]
</code></pre>
<p>And when you look at some of the other designs of how this is plugging together, I don't think we should turn back.  It's simply too hard to build abstractions on top of FUNC if the bodies cannot dynamically declare new variables, and I think forcing everyone in those situations to deal with USE is ergonomically just too awkward to feel like the language is living up to its promises.</p>
<p>I don't want to give up on virtual binding and LET when it has come this far.  It may be broken, but its brokenness is already a better kind of broken than what was there before...and there's no proof yet that it can't be made better.</p>
<p>Rebol's M.O. has been throwing imaginative <em>but I want the code to look like THIS</em> at a data structure and see how far that can go...without proof that it can or should work well.  Every now and again I think I should have the right to throw my own bad idea that looks good in there.  And maybe some poor sucker in the future can figure out the limits of how it can be made to seem like it works more.   <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/pivotal-design-question-is-evaluator-state-just-a-block/1496">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/pivotal-design-question-is-evaluator-state-just-a-block/1496</link>
          <pubDate>Tue, 09 Feb 2021 21:25:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1496</guid>
          <source url="https://forum.rebol.info/t/pivotal-design-question-is-evaluator-state-just-a-block/1496.rss">Pivotal Design Question: Is Evaluator State Just A Block?</source>
        </item>
        <item>
          <title>On Wasted Bits</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>In one of my Philadelphia talks, I cited a quote from Paul Graham in <a href="https://forum.rebol.info">The 1,000 Year Language</a></p>
<blockquote>
<p><em>"I learned to program when computer power was scarce. I can remember taking all the spaces out of my Basic programs so they would fit into the memory of a 4K TRS-80. The thought of all this stupendously inefficient software burning up cycles doing the same thing over and over seems kind of gross to me. But I think my intuitions here are wrong. I'm like someone who grew up poor, and can't bear to spend money even for something important, like going to the doctor."</em></p>
<p>...</p>
<p><em>"The desire for speed is so deeply engrained in us, with our puny computers, that it will take a conscious effort to overcome it. In language design, we should be consciously seeking out situations where we can trade efficiency for even the smallest increase in convenience."</em></p>
</blockquote>
<p>I've been struggling some with this fight.  For instance, the scenario of:</p>
<pre><code>count-up x 1000000 [
    let y: x + 1
    print [y]
]
</code></pre>
<p>What I have explored is the question of making LET a dynamic construct.  This dynamism would mean it wouldn't be scanned for in advance (like "FUNCT" looked for SET-WORD!).  It would actually bring a new variable and binding into existence... basically just syntax sugar for if you had written:</p>
<pre><code>count-up x 1000000 [
    use [y] [
        y: x + 1
        print [y]
    ]
]
</code></pre>
<p>It's uncomfortable to induce the thought that you'd be making a new object each time through the loop...an object with one field (y).  That's a million objects being made, that the GC will have to grapple with.</p>
<p>I'm working on making these as small as possible...and the GC will sweep them up.  But people who have seen LET or LET-like constructs from other languages would not generally assume that it would cause so much pain to the GC.  It feels so much more catastrophically worse than creating a single object:</p>
<pre><code>let y
count-up x 1000000 [
    y: x + 1
    print [y]
]
</code></pre>
<p>And if you were using <strong><code>func [... &lt;local&gt; y]</code></strong> that's even more efficient.  It doesn't create a separate object identity at all, but piggy-backs on the frame (where the arguments are already stored).</p>
<p>Of course, we're dealing with an incredibly dumb "mark and sweep the world" GC right now, that only starts cleaning up when it hits a wall.  If we were more clever, I'm sure there could be ways that the GC could localize most LETs and do zoning cleverness...doing light pick-ups of GC objects.</p>
<h2>I May Be Worrying Too Much</h2>
<p>The size of the variable is smaller than the size of the frame created by an addition, e.g. by the <strong>+</strong>.  If someone is at the level of optimizing for the LETs, they'd make a much bigger difference by eliminating the block:</p>
<pre><code>count-up x 1000000 [
    let y: x + 1
    print x
]
</code></pre>
<p><em>(Note: PRINT requires blocks on non-strings, non-newline characters <a href="https://forum.rebol.info/t/limiting-print-to-block-text-perhaps-blank-to-opt-out/855">for a pretty good reason</a>, but I'm just trying to make the point about the relative costs of things.)</em></p>
<p>The creation of FRAME! (e.g. for a BLOCK!) has been optimized to reduce the GC load to just about the minimum that it can, but that minimum is the same minimum as what we're looking at for a LET.  So when the cost of a LET is more or less on the same level as the cost for a GROUP!, how much should we really be asking people to worry about it?</p>
<p>When you think about the forces in play here--the ability to do rearrangements to optimize it if you need to, and Paul Graham's remarks about expressivity being the long tail--I think making LET dynamic is probably the winning bet.</p>
<p>Luddites who don't like it can use <strong><code>&lt;local&gt;</code></strong> and be no worse off.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/on-wasted-bits/1492">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/on-wasted-bits/1492</link>
          <pubDate>Sat, 06 Feb 2021 06:54:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1492</guid>
          <source url="https://forum.rebol.info/t/on-wasted-bits/1492.rss">On Wasted Bits</source>
        </item>
        <item>
          <title>THEN and ELSE are Essential</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>When I was describing the details of <a href="https://forum.rebol.info/t/multiple-returns-and-branching-could-it-unseat-voidification/1408">rigging it so enfix functions could interoperate with multiple retrun values</a>, <a class="mention" href="https://forum.rebol.info/u/iarnold">@iArnold</a> responded:</p>
<aside class="quote no-group quote-modified" data-username="iArnold" data-post="3" data-topic="1408" data-full="true">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/iarnold/40/226_2.png" class="avatar"><a href="https://forum.rebol.info/t/multiple-returns-and-branching-could-it-unseat-voidification/1408/3">Multiple Returns and Branching: Could It Unseat Voidification?</a>
</div>
<blockquote>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1408">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/multiple-returns-and-branching-could-it-unseat-voidification/1408/2">Multiple Returns and Branching: Could It Unseat Voidification?</a>
</div>
<blockquote>
<p><strong>But How Does IF Know ELSE Wanted The /BRANCHED Output?</strong><br>
ELSE runs <em>after</em> IF. So it would need to be able to connect its need for a branched output up to IF's parameterization <em>before IF runs</em>. <img src="https://forum.rebol.info/images/emoji/twitter/pleading_face.png?v=9" title=":pleading_face:" class="emoji" alt=":pleading_face:"></p>
</blockquote>
</aside>
<p>This problem was solved in R2. IF knew there was no else and EITHER did.</p>
</blockquote>
</aside>
<p>Rather than just delete and ignore this tangent... I'm moving it here with <a href="https://forum.rebol.info/t/null-blank-void-history-under-scrutiny/1249/4">another remark from Chris</a>:</p>
<aside class="quote no-group" data-username="rgchris" data-post="4" data-topic="1249">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"><a href="https://forum.rebol.info/t/null-blank-void-history-under-scrutiny/1249/4">NULL, BLANK!, VOID!: History Under Scrutiny</a>
</div>
<blockquote>
<p>I should say that as of now, I don't have a favourable opinion of the ELSE/THEN idiom (on a stylistic/comprehension basis) and don't think they're worth the extra complexity alone</p>
</blockquote>
</aside>
<p>Let me respond quickly.</p>
<h2>I Haven't Given Up Making It Not Affect Those Who Don't Use It</h2>
<p>Firstly: You should always have the last resort of using Redbol if you want, and I'm trying my best to make sure every convention is reversible.  Though it's a bit of a hard pill to swallow to dial back large parts of the language a decade, I think it can be done in something of a piecemeal way so that you can revert just the parts you don't like.</p>
<p>Secondly: As the post I made shows, <em>I'm still racking my brain to see what I can do</em>, even if it means pretty crazy evaluator acrobatics.  If my current trick manages to pan out, there will be a generic mechanism for getting more than one value across an enfix call barrier.  It would mean all branches would go back to being "as-is".  But who knows what other doors might open.</p>
<h2>ELSE and THEN are Bigger Than An Alternative To EITHER</h2>
<p>I've demonstrated the synergy between CASE and SWITCH and ELSE and ALSO and THEN.  When you throw invisibles like ELIDE in, you get evaluator combinatorics I have never seen before.  Expressing imperative logic with so many seamless "asides" is going to be a real mind-blower.</p>
<p>This is what makes the language worth paying attention to.  If <em>I'm</em> impressed, then that's a pretty high bar, and so I shouldn't be the last person to feel that way.</p>
<p>(Quite a stronger and more timeless message than "fastest mostly-open-source 32-bit Rebol2 on Earth".)</p>
<h2>Remember The Self-Selection Bias</h2>
<p>If you have been using Rebol for decades, and see no problem with forcing every IF...ELSE to be EITHER, remember this:</p>
<p><strong>you are one of a <em>very, very small minority of people who managed to not be put off by the language</em></strong></p>
<p>Maybe my tastes are "mainstream".  But I don't usually like EITHER.  It might fit in sometimes when I can get everything all on one line.</p>
<p>But since I still use other languages besides Rebol, I haven't forgotten that the straightforward ordinary way can be coherent and nice:</p>
<pre><code> if ((a and b) or (c and d)) { ... } else { ... }
</code></pre>
<p>Which makes you see just how uncomfortable this is:</p>
<pre><code>either any [all [a b] all [c d]] [ ... ] [ ... ]
</code></pre>
<p>I'm more than intelligent enough to understand both.  And with years to consider it, I still prefer the first if those were my only two options.  Though I might like to write that particular one as:</p>
<pre><code>any [a and b, c and d] then [ ... ] else [ ... ]
      ; ^-- I'm considering AND's quoting convention to allow WORD!s on right
</code></pre>
<p>Of course, how you look at it depends on the length of the clauses and what you're going to emphasize.  If you've got enough code to warrant newlines, the ANYs and ALLs start being better propositions.</p>
<p>But on a higher level: if you're advertising <em>"most freeform programming language ever invented"</em>, saying that you <em>"have to write your code in a style you don't like much, because it's Rebolish"</em> is missing the message.</p>
<h2>THEN, ELSE, and ALSO are <a href="https://forum.rebol.info/t/the-canonical-list-of-non-negotiables/1244/4">Non-Negotiables</a> for Me</h2>
<p>I've pointed out before that <a href="https://forum.rebol.info/t/rationalizing-the-illusion-readability-over-writability/397">the illusion of this</a> is what keeps me going:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="397">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/rationalizing-the-illusion-readability-over-writability/397/1">Rationalizing the Illusion: Readability over Writability</a>
</div>
<blockquote>
<p>I think every time we get another one of these illusions under our belt, like <a href="https://trello.com/c/NPivtSdd">ELSE and THEN</a>, the game goes a little further. I'd have quit Rebol a long time ago if these breakthroughs weren't still coming along... each one probably buys one more month of my interest in the area of study</p>
</blockquote>
</aside>
<p>I'd quit if this stuff weren't in the mechanics, because the language wouldn't interest me much.</p>
            <p><small>6 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/then-and-else-are-essential/1411">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/then-and-else-are-essential/1411</link>
          <pubDate>Sat, 21 Nov 2020 13:40:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1411</guid>
          <source url="https://forum.rebol.info/t/then-and-else-are-essential/1411.rss">THEN and ELSE are Essential</source>
        </item>
        <item>
          <title>Brevity in the Box: When Is It Worth It?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>(cc: <a class="mention" href="https://forum.rebol.info/u/razetime">@razetime</a>, please let me know if any of this makes sense, or if not what parts don't)</p>
<p>Now that I'm again <a href="https://forum.rebol.info/t/reviving-the-rebmu-dialect/1377">revisiting Rebmu</a>, the familiar pattern of <em>"hey wait, should this be a default language feature?"</em> comes up again.</p>
<h2>A Simple Example Of The Pattern</h2>
<p>Just imagine a shortcut for something like WHILE, where if you give it a WORD! as the condition, it acts as if you put the condition in a block:</p>
<pre><code> x: true
 while 'x [...]
</code></pre>
<p>That's shorter than <strong>while [x] [...]</strong>.  But to get it even shorter, while could <em>quote</em> its first argument.</p>
<pre><code> x: true
 while x [...]  ; doesn't eval X at callsite, so WHILE gets the WORD! itself
</code></pre>
<p>The downside to this is that if the condition is generated by code, you'd have to escape the quoting somehow.  Otherwise <strong>while reduce [some condition] [some body]</strong> would be interpreted expecting REDUCE to be an arity-0 function called each time as the condition check.  Then, the <strong>[some condition]</strong> block would wind up in the body slot.  So <code>[some body]</code> would get inertly discarded as the next expression.</p>
<h2>This Is Harder To Teach</h2>
<p>A new user has a tough time getting their head around the simple question of why IF can't have a BLOCK! around its condition, but WHILE requires one.  It takes a while to instill this "obvious" idea and convince people that it is a design feature vs. a bug.  <em>(<a class="mention" href="https://forum.rebol.info/u/razetime">@razetime</a> - it would be a good idea to be able to write out--in your own words--why Rebol's IF doesn't take a BLOCK! as its condition, but WHILE needs it.)</em></p>
<p>Though changing the convention would have its share of surprises, this isn't to say that the current behavior doesn't have its own confusing possibilities.  With evaluative conditions, you could leave the block off on accident and if it <em>incidentally</em> was a block, you could run something as code:</p>
<pre><code> data: [[print "formatting hard drive"] [print "sorting MP3 collection"]]

 x: first data
 while x [...]   ; imagine they meant to say `while [x] [...]`
</code></pre>
<p>You can still make mistakes under today's semantics, as the code above shows.  It can be argued that the mistake is more consistent, as the argument is simply being evaluated like that of APPEND or other primitives.  Though that consistency doesn't magically mean it's any less confusing.</p>
<h2>Might Quoting-but-Erroring Provide a Smooth Continuum?</h2>
<p>Continuing to consider this example, we might imagine that it quotes the condition argument in the default implementation <em>but refuses to run anything but BLOCK! and GROUP!</em>  This would pave the way for compatibility with code that gave meaning to the quoted case.</p>
<pre><code> import &lt;core&gt;  ; imagine this is how you get the default definitions

 x: true
 while x [...]  ; !!! Error, WORD! not accepted as argument
 while 'x [...]  ; maybe this would be okay vs. `while [x]`, though?
</code></pre>
<p>Then if you did some kind of expert mode import, it would become more lax</p>
<pre><code> import &lt;core&gt;/lax   ; let's say you can provide switches to IMPORT

 x: true
 while x [...]  ; let's say lax meant this acts as `while [x]`
</code></pre>
<p>This might be reasonable.  And it may provide an answer to the issues I bring up in <a href="https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359">"Speaking with Tics"</a>.  Maybe a strict mode makes you say <strong>for-each 'x [...]</strong> and <strong>'type of x</strong> and then there's a wholesale switch on arguments that lets you dodge quoting.</p>
<h2>Another Example: DOES</h2>
<p>Today's DOES is actually taken from Rebmu, because it lets you avoid putting the body of the DOES in an outermost block:</p>
<pre><code> &gt;&gt; old-way: does [print "Hello"]
 &gt;&gt; old-way
 Hello

 &gt;&gt; new-way: does print "Hello"
 &gt;&gt; new-way
 Hello
</code></pre>
<p>I thought this was cool enough to adopt.  But this has that characteristic pattern of needing escaping when the body is generated from code:</p>
<pre><code> rebol2&gt;&gt; old-way: does reverse ["Different" print]  ; reversal is body
 rebol2&gt;&gt; old-way
 Different  ; printed

 &gt;&gt; new-way: does reverse ["Different" print]  ; specializes REVERSE
 &gt;&gt; new-way
 == [print "Different"]  ; block value, reversed each time
 &gt;&gt; new-way
 == ["Different" print]  ; it's the same block, so doubly-reversed now

 &gt;&gt; new-compatible: does :(reverse ["Different" print])  ; reversal as body
 &gt;&gt; new-compatible
 Different  ; printed
</code></pre>
<blockquote>
<p>Note that the DOES handling for GROUP! isn't escaped so you have to use <strong>:(reverse ["Different" print])</strong>.  Whether we think this needs fixing or not depends on if we decide that <strong>does (...)</strong> has an interesting unique meaning, e.g. <strong>does (elide print "vanishes")</strong> would be invisible while <strong>does [elide print "vanishes"]</strong> would be void.  In other words, <strong>does (x)</strong> is currently acting as <strong>do '(x)</strong> would, while <strong>does :(x)</strong> is acting like <strong>do x</strong>.  I'm not 100% sure either way right now.</p>
</blockquote>
<p><em>This feels like something positive to have in the box as a default, as opposed to just being a fringe Rebmu-ism.</em>  Especially because DOES lacks a RETURN statement, isn't it nice to be able to say:</p>
<pre><code> helper: does catch [
      if condition [throw 10]
      throw 20
 ]

 ; Compare with...

 helper: does [catch [
      if condition [throw 10]
      throw 20
 ]]
</code></pre>
<p>But notice the implication here gets to where DOES needs to be variadic.  The mechanic of doing something along the lines of <a href="https://forum.rebol.info/t/looking-into-a-usermode-pointfree/1236">POINTFREE</a> for a parameter is something that's a pain to have to rewrite every time, and it means the argument is harder to fill with in FRAME!s with specializations.  That suggests it should probably be a parameter convention in its own right.  :-/</p>
<h2>How Far Should This Go?</h2>
<p>Much like the points I raise in "Speaking With Tics" regarding shorthand, it's hard to say.</p>
<p>DOES is a pretty good poster child for the question.  A reasonable hedging strategy might be to reserve the right to make DOES be "clever" in the future by quoting its argument, but disallowing WORD!s for now.  So if you produce the thing-to-do with code, you have to put that code in a GET-GROUP! as <strong>does :(...)</strong>.</p>
<p>But I have mixed feelings about extending this approach places.  If you want to do some pre-binding on a function body, do you want to have to write:</p>
<pre><code> func [...] :(in some-context [
     ...
 ])
</code></pre>
<p>Or is it too "Rebol-like" to have these meta-coding experiments not need parentheses:</p>
<pre><code> func [...] in some-context [
     ...
 ]
</code></pre>
<p>Key to the question under debate is if it would be more common for people to want to write:</p>
<pre><code> func [...] case [
     ...
 ]
</code></pre>
<p>...insead of:</p>
<pre><code> func [...] [
     case [
         ...
     ]
 ]
</code></pre>
<p><strong>When Rebmu is considered, meta-coding is the rarer need, so that seems to favor optimizing out the brackets in the non-meta cases and paying for the group in the meta case.</strong>  But clearly the mechanics get weird.  As an example, think about:</p>
<pre><code> func [x] if x [
     ...
 ]
</code></pre>
<p>For that to be equivalent to <strong>func [x] [if x [...]]</strong>, <em>the variadic expression needs to bind into the spec</em>.  So that X can't be specialized as whatever it was in the enclosing context.  So a magic parameter convention which was willing to specialize the body as an ACTION! couldn't be used, as it would need to be informed by the binding logic of FUNC itself.  This points to an advantage of getting things in blocks.</p>
<h2>Lowest Common Denominator In Box, Then Let Users Decide?</h2>
<p>Imagine we say that a function body can be only two things, a BLOCK! or a GET-GROUP!.</p>
<p>That could be the standard that you encourage to work for any variant of FUNC/FUNCTION.  But beyond that, each module could pick its conventions...or even change conventions on an impromptu basis (per class, per function, or per scope-in-function even).</p>
<p>One convention might say:</p>
<pre><code>func [x] reverse [...]  =&gt;  func [x] :(reverse [...])   ; reversed block is body
</code></pre>
<p>Another convention might say:</p>
<pre><code>func [x] reverse [y]  =&gt;  func [x] [reverse [...]]   ; reverse upon invocation
</code></pre>
<p>Restricting to [...] and :(...) by default doesn't seem too terribly antagonistic.  The policy needs a name, something like <em><strong>"the baseline block rule"</strong></em>.  Then focus on facilities for easily customizing local definitions of things like FUNC or WHILE to be more creative, instead of trying to prescribe the shape of that creativity in the natives themselves.</p>
<p>One advantage of a baseline block proposal is better learnability for new users.  Recall the example I gave up top about WHILE working "incidentally" because the value you forgot to put in a block turned out to just happen to evaluate to a block:</p>
<pre><code> data: [[print "formatting hard drive"] [print "sorting MP3 collection"]]

 x: first data
 while x [...]   ; imagine they meant to say `while [x] [...]`
</code></pre>
<p>But with baseline block, that'd be an error.  They'd have to clarify it as either <strong>while [x]</strong> or <strong>while :(x)</strong>.</p>
<p>Then we focus on figuring out how to make it easier and easier for people to bend this when they get new ideas.  Maybe <strong>while 7 =&gt; (x q) [body]</strong> signals something of interest to a budding language designer, and they want to build a detection pattern for INTEGER! =&gt; GROUP! that applies in while conditions only... but they'd like all their normal whiles to keep working.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=9" title=":man_shrugging:" class="emoji" alt=":man_shrugging:"></p>
<p>This way, the golfing adaptations become just a sample of the kinds of adaptations you might choose.  And if you liked the Rebmu choices at a conceptual level, you could import those without having to also adopt all the short names as well.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/brevity-in-the-box-when-is-it-worth-it/1380">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/brevity-in-the-box-when-is-it-worth-it/1380</link>
          <pubDate>Mon, 02 Nov 2020 03:09:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1380</guid>
          <source url="https://forum.rebol.info/t/brevity-in-the-box-when-is-it-worth-it/1380.rss">Brevity in the Box: When Is It Worth It?</source>
        </item>
        <item>
          <title>Speaking With Tics: Should Quoted Arguments Always Be Apostrophe&#39;d?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>In the past it has been discussed whether it is better or worse to have quoted things be apostrophe'd.</p>
<p>Historical Rebol actively prohibits the use of a lit-word! with FOREACH for the loop variable:</p>
<pre><code>&gt;&gt; foreach 'x [1 2 3] [print [x]]
** Script Error: foreach expected word argument of type: get-word word block
</code></pre>
<p>R3-Alpha and Red don't allow it either.</p>
<p>But it might seem you'd want to be able to do this in Ren-C...because there are quoting constructs that can quote backwards:</p>
<pre><code>&gt;&gt; backquote: enfixed func [:x] [print ["I backquoted" x]]
== make action! [[:x] [...]]

&gt;&gt; foo: backquote
I backquoted foo:
</code></pre>
<p>So if you try <code>for-each backquote</code>, the backwards-quoting BACKQUOTE would get the FOR-EACH before the forwards-quoting FOR-EACH could get the BACKQUOTE.  That's just the order that the evaluator works in <em>(unless there's nothing to the right of BACKQUOTE, which is the exception that would allow HELP BACKQUOTE to work)</em>.</p>
<p>You can work around that with:</p>
<pre><code>for-each ('backquote) [1 2 3] [print [backquote]]
</code></pre>
<p>But it seems like it would be nicer if you could write it without the parentheses.</p>
<h2>
<a name="should-all-quoting-sites-require-quoted-input-1" class="anchor" href="https://forum.rebol.info#should-all-quoting-sites-require-quoted-input-1"></a>Should All Quoting Sites <em>REQUIRE</em> Quoted Input?</h2>
<p>The quoted parameter convention exists to save you the trouble of quoting the callsites. <em>If this isn't what that's for, then what <strong>is</strong> it for?</em></p>
<p>I'd be happy to buck the status quo if I thought it were clearly wrong.  But when we look across the board we see how nice and fluent <strong>type of foo</strong> looks vs. <strong>'type of foo</strong>.  Over time it gets internalized to the point that <strong>type: type of foo</strong> doesn't feel weird at all (thought it might look so when you see it the first time).</p>
<p>While there's something to be said for the educational value of seeing when a word is being used by name vs. by value, it's just... "uglier"</p>
<pre><code>type: 'type of foo
</code></pre>
<p>We seem lose something about knowing the "rules of OF" and the parts of speech involved by context, in order to add a bit of visual noise.  To my tastes, it seems this is not in the same "clear win" zone over <code>type-of</code> and <code>type?</code> that we were in before.</p>
<p>It seems to me a core experimental theory in the language is that there is value in allowing acclimations in our mind to writing things that "start looking natural" even if they don't follow systemic rules.  That speedbump of typing <strong>type of x</strong> of hitting the apostrophe key, as well as the visual jarringness, suggests it's a place to take advantage of not quoting <em>when it's possible</em>.</p>
<h2>
<a name="should-all-quoting-sites-merely-permit-quoted-input-2" class="anchor" href="https://forum.rebol.info#should-all-quoting-sites-merely-permit-quoted-input-2"></a>Should All Quoting Sites Merely <em>PERMIT</em> Quoted Input?</h2>
<p>I mentioned that the current workaround for slipping past cases of things like backquoting operators is to use a GROUP!.</p>
<pre><code>for-each ('foo) [1 2 3] [print [x]]
</code></pre>
<p>We might ask if the operation with the quoting slot should be lenient and let you just alternately write:</p>
<pre><code>for-each 'foo [1 2 3] [print [x]]
</code></pre>
<p>Quoted words won't dispatch functions, so you don't have to worry about FOO's associated behavior if you do this.</p>
<p>A problem with being lenient in that way is that now the function spec is expanded to where it has to accept either WORD! -or- QUOTED! in its quoted slot.  That complicates things, and now the author of the quoting function needs to be bothered with the quote-or-not of their argument.</p>
<p>If you take the easy-way-out and just DEQUOTE your argument (which leaves it as is if it's not quoted), then you may be permitting things with arbitrary numbers of quotes.</p>
<pre><code>for-each '''''''''foo [1 2 3] [print [x]]
</code></pre>
<p>I'm pretty sure UNQUOTE should require its argument to be quoted, for the sake of sanity.  So the implementation of functions like FOR-EACH would get hairier if they were to have to check and preprocess their arguments, e.g. to permit one-and-only one level of quote that they strip off.  This could be made easier with some helper for the purpose, though.</p>
<h2>
<a name="a-benefit-to-requiring-quotes-3" class="anchor" href="https://forum.rebol.info#a-benefit-to-requiring-quotes-3"></a>A Benefit To Requiring Quotes</h2>
<p>I've mentioned in the past that for things like FOR-EACH, if we <em>required</em> the first argument to be quoted then there could be a special interpretation for when there wasn't a quote.  e.g. just run a function without naming a variable:</p>
<pre><code>&gt;&gt; for-each ["No" "Variable"] :print
No
Variable
</code></pre>
<p>This keeps you from having to write something like:</p>
<pre><code>for-each _ ["No" "Variable"] :print
</code></pre>
<p>A plain function declaration isn't particularly interesting in this form, even with a lambda it's wordier (and symboly-er) than the old-style without:</p>
<pre><code>for-each [1 2 3] x -&gt; [print [x]]
</code></pre>
<p>But when you bring in something like <a href="https://forum.rebol.info/t/looking-into-a-usermode-pointfree/1236">"POINTFREE"</a> it gets more interesting:</p>
<pre><code>&gt;&gt; block: [a b c]

&gt;&gt; for-each [1 2 3] (&lt;- append block)

&gt;&gt; block
== [a b c 1 2 3]
</code></pre>
<p>With the idea that <strong>#</strong> is legal, it might look better if you "opt-in" to the variables:</p>
<pre><code>for-each # [1 2 3] (&lt;- append block)
</code></pre>
<p>This would let you do a template for what you want and don't want passed to your function.</p>
<pre><code>&gt;&gt; block: [a b c]

&gt;&gt; for-each [# _] [1 2 3 4] (&lt;- append block)

&gt;&gt; block
== [a b c 1 3]
</code></pre>
<p>This allows us to justify why the variable slot has usefulness even if we're not using a variable.  Maybe that's the answer.  And if we shorten FOR-EACH to simply EACH it would come out cleaner, even in complex invocations:</p>
<pre><code>each [# _] [1 2 3 4] (&lt;- append block)
</code></pre>
<h2>
<a name="switch-to-for-opt-in-on-variables-allow-but-dont-require-quoted-4" class="anchor" href="https://forum.rebol.info#switch-to-for-opt-in-on-variables-allow-but-dont-require-quoted-4"></a>Switch to <code>#</code> for opt-in on variables, allow (but don't require) QUOTED! ?</h2>
<p>...is this a plan?  Does it cover all the angles?</p>
            <p><small>8 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359</link>
          <pubDate>Wed, 07 Oct 2020 19:32:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1359</guid>
          <source url="https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359.rss">Speaking With Tics: Should Quoted Arguments Always Be Apostrophe&#39;d?</source>
        </item>
        <item>
          <title>Embracing Dialected TUPLE! and PATH!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>I've talked about the idea of <strong><a href="https://forum.rebol.info/t/brave-switch-new-world-skippable-predicates/1045">using TUPLE! for "predicates"</a></strong>.  The specific concept that I had would be that the elements of the tuple would represent the function calls in the order you'd write them:</p>
<pre><code>&gt;&gt; any .even? [1 3 7 10 13]  ; parallel to `even? 1`, `even? 3`...
== 10

&gt;&gt; all .not.odd? [2 4 6 8]  ; parallel to `not odd? 2`, `not odd? 4`...
== 8
</code></pre>
<p>But I've also been arguing for dots having meaning in ordinary PATH! dispatch, e.g. when not having a leading blank.  In that case, I'd said things like <em>"functions wouldn't be on the left side of a dot"</em>.  But that's a whole different purpose.</p>
<p>Put these two together in the same line, and you might wind up looking at code like:</p>
<pre><code> &gt;&gt; obj: make object! [data: [2 4 6 8]]

 &gt;&gt; all .not.odd? obj.data.
 == 8
</code></pre>
<ul>
<li>
<p>The BLANK!-headed TUPLE! <strong><code>.not.odd?</code></strong> matched the skippable parameter type constraint for "PREDICATE!", and is interpreted as <strong>chain [:odd? | :not]</strong> ...or <strong>(-&gt; not odd?)</strong> if you are using <a href="https://forum.rebol.info/t/looking-into-a-usermode-pointfree/1236">POINTFREE</a></p>
</li>
<li>
<p><code>obj.data.</code> was interpreted as a non-blank-headed tuple, so it's the argument...and the terminal dot indicates the caller wanted to ensures that obj.data isn't a function .</p>
</li>
</ul>
<h2>Is this <em>bad</em>?</h2>
<p>If TUPLE! were always inert (as in the original proposal) you'd never see things like that, you'd only see:</p>
<pre><code>&gt;&gt; all .not.odd? obj/data
== 8
</code></pre>
<p>But I'm now fairly sold on TUPLE! for member selection (looks good) and the terminal dot to say "don't execute" is really promising.</p>
<p>I'll point out that there are ways to avoid the particular juxtaposition of tuples if it bothered you:</p>
<pre><code>&gt;&gt; all .not.odd? pick obj 'data
== 8

&gt;&gt; all/predicate obj.data. (-&gt; not odd?)
== 8

&gt;&gt; apply 'all [obj.data. /predicate func [x] [not odd? x]]  ; syntax pending
== 8
</code></pre>
<p>So a lot of ways to attack it.  And these are advanced features, so you can imagine people writing quite a lot of code without ever doing this kind of thing.</p>
<p>But the bigger philosophical question is about entering the era where TUPLE! and PATH! become candidates for multiple dialected meanings.  Is <em>that</em> good or bad?</p>
<h2>Dialecting ANY-SEQUENCE! Is Good (in the spirit of the "game")</h2>
<p>We don't really have problems when a BLOCK! of code contains PARSE instructions vs. being executed by DO.  So why should different purposes for TUPLE! be considered strange?</p>
<p>Having the parts be robust enough to want to use creatively is a good thing.  I think it's just new, and figuring out what to do with that newness will likely take some time.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/embracing-dialected-tuple-and-path/1355">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/embracing-dialected-tuple-and-path/1355</link>
          <pubDate>Sun, 04 Oct 2020 06:26:55 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1355</guid>
          <source url="https://forum.rebol.info/t/embracing-dialected-tuple-and-path/1355.rss">Embracing Dialected TUPLE! and PATH!</source>
        </item>
  </channel>
</rss>

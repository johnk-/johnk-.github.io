<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Parsing - AltRebol</title>
    <link>https://forum.rebol.info/c/domains/parsing/16</link>
    <description>Topics in the &#39;Parsing&#39; category One of the most popular and developed dialects in Rebol is the PARSE dialect.</description>
    
      <lastBuildDate>Thu, 28 Nov 2024 00:35:37 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/domains/parsing/16.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>UPARSE Combinator Return Conventions: Reviewed</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>UPARSE was an early client of multiple return values, at a time when they worked by assigning variables local to your frame, which were then proxied to items in a SET-BLOCK!:</p>
<pre><code> /multi-returner: func [
     return: [integer!]
     secondary: [integer!]  ; SET-WORD! indicated another return
 ][
     secondary: 20
     return 10
 ]

 &gt;&gt; [ten twenty]: multi-returner
 == 10

 &gt;&gt; ten
 == 10

 &gt;&gt; twenty
 == 20
</code></pre>
<p>This basically made every multi-return function a kind of infix operation, that was able to take a SET-BLOCK! on its left hand side.  <a href="https://forum.rebol.info/t/multiple-return-values-via-infix/1257">(In fact, it was prototyped using infix.)</a></p>
<p>But this method had composability problems, and was defeated by abstraction of any sort, even the most minor forms:</p>
<pre><code> &gt;&gt; [ten twenty]: (multi-returner)
 ** Error: even this wouldn't work
</code></pre>
<p>So the method gave way to returning antiform BLOCK!s.  These represented parameter packs that would "decay" to their first item in most circumstances...but SET-BLOCK!s were one of the cases that could pick them apart (though you could design other operations as well).</p>
<pre><code> /multi-returner: func [
     return: [~[integer! integer!]~]
 ][
     return pack [10 20]
 ]
</code></pre>
<p>You can read all about it in <strong><a href="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134">The History of Multi-Return in Ren-C</a></strong></p>
<h2><a name="p-7932-so-local-proxies-diedbut-uparse-mimicked-them-1" class="anchor" href="https://forum.rebol.info#p-7932-so-local-proxies-diedbut-uparse-mimicked-them-1"></a>So Local Proxies Died...But UPARSE Mimicked Them</h2>
<p>Just because the mechanics got rid of local proxies doesn't mean you can't fake them.  All you have to do is hack up its RETURN function to make a PACK using a local variable.</p>
<p>Simplified example:</p>
<pre><code> /proxy-multi-func: adapt func/ [
      body: compose $() inside body '[
          /return: adapt return/ [
             atom: pack [(unmeta atom) secondary]
          ]
          (as group! unbind body)  ; I wish this pattern were simpler
      ]
 ]

 /multi-returner: proxy-multi-func [
     return: [integer!]
     &lt;local&gt; secondary  ; could be specially marked, if spec rewritten
 ][
     secondary: 20
     return 10
 ]
</code></pre>
<p>So when the multi-return-by-antiform-block change happened, this is what COMBINATOR did instead of transition to having every combinator do <strong><code>return pack [synthesized remainder]</code></strong></p>
<p>Instead it worked the same as before: you'd set <strong>remainder</strong> however you wished, do <strong>return synthesized</strong>.  Except now the specialization of RETURN would PACK things up.</p>
<h2><a name="p-7932-why-did-combinator-preserve-proxying-2" class="anchor" href="https://forum.rebol.info#p-7932-why-did-combinator-preserve-proxying-2"></a>Why Did COMBINATOR Preserve Proxying?</h2>
<p>Well... for starters, to show that it could be done.  You <em>should</em> be able to do it.  So having a living test case to hammer through any issues was good.</p>
<p>Also, because some combinators have two return values (synthesized and remainder), while others add a third (pending).  In truth the combinator always needs to return a pack of 3, it's just that some combinators automatically pipe the pending results from successful combinators to the output.  This means even if your combinator returned a pack of 2 in the piped case, that would have to be broken apart and turned into a pack of 3.  Having it in components helps.</p>
<p>But generally, I think it makes the code clearer as well.  Saying <strong><code>(return pack [x y])</code></strong> doesn't have any labeling, while <strong><code>(remainder: y, return x)</code></strong> is somewhat clearer, and you don't need to label the "primary" result because that's understood as what the combinator is synthesizing.</p>
<h2><a name="p-7932-synthesized-cant-be-proxied-unless-meta-3" class="anchor" href="https://forum.rebol.info#p-7932-synthesized-cant-be-proxied-unless-meta-3"></a>Synthesized Can't Be Proxied (unless ^META)</h2>
<p>It's worth pointing out that there's a sort of design constraint here, when you're going to break out multi-return results and have them represented by local variables which are proxied by an adjusted RETURN...</p>
<p>...and that constraint is that you can't put unstable antiforms in variables.  So if you have something you want to return like an antiform pack (as combinators can legitimately synthesize), it has to be the main return result.</p>
<p>So since they use this proxying, combinators kind of break the rule of thumb of "don't make unstable antiforms your primary return in a multi-return situation".  This is because if you do:</p>
<pre><code>return pack [pack [1 2] "a"]
</code></pre>
<p>Then you face some ambiguity in terms of what people might think <strong><code>([x y]: multi-return-func)</code></strong> should mean... or what <strong><code>(x: multi-return-func)</code></strong> should mean.</p>
<p>But really, this is still being worked out.</p>
<h2><a name="p-7932-anyway-just-wanted-to-sum-up-uparse-return-4" class="anchor" href="https://forum.rebol.info#p-7932-anyway-just-wanted-to-sum-up-uparse-return-4"></a>Anyway, Just Wanted To Sum Up UPARSE RETURN</h2>
<p>I was questioning it, and wanted to kind of work through why it is the way it is.  But I think it's right.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/uparse-combinator-return-conventions-reviewed/2337">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/uparse-combinator-return-conventions-reviewed/2337</link>
          <pubDate>Thu, 28 Nov 2024 00:35:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2337</guid>
          <source url="https://forum.rebol.info/t/uparse-combinator-return-conventions-reviewed/2337.rss">UPARSE Combinator Return Conventions: Reviewed</source>
        </item>
        <item>
          <title>FENCE! In PARSE: What Should It Do?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>FENCE! is coming soon.  How soon?  ...soon.</p>
<p>When it gets here I'm going to want to kick the tires a bit with purposes in dialects.  And so of course a big question is: <strong>What will FENCE! do in PARSE?</strong>  <em>(By default, I mean...you can override it with whatever FENCE! combinator you want.)</em></p>
<p>It <em>might</em> seem an obvious use for it would be to make objects, e.g. act as GATHER:</p>
<p>So instead of:</p>
<pre><code>&gt;&gt; parse "aaabbb" [
      gather [
          emit x: collect some ["a", keep (&lt;a&gt;)]
          emit y: collect some ["b", keep (&lt;b&gt;)]
      ]
  ]
== make object! [
    x: [&lt;a&gt; &lt;a&gt; &lt;a&gt;]
    y: [&lt;b&gt; &lt;b&gt; &lt;b&gt;]
]
</code></pre>
<p>You might imagine writing:</p>
<pre><code>&gt;&gt; parse "aaabbb" [
      {
          x: collect some ["a", keep (&lt;a&gt;)]
          y: collect some ["b", keep (&lt;b&gt;)]
      }
  ]
== make object! [
    x: [&lt;a&gt; &lt;a&gt; &lt;a&gt;]
    y: [&lt;b&gt; &lt;b&gt; &lt;b&gt;]
]
</code></pre>
<p><strong>But I don't know if that's obviously a great application.</strong></p>
<p>We shouldn't be thinking inside-the-box that just because FENCE! is used for making objects sometimes, that's the most pressing need for them in dialects.  I actually think GATHER does a good enough job at what it does...and I think the above example reads more clearly with it.</p>
<p>But I've pointed to other rather weak areas, <strong><a href="https://forum.rebol.info/t/implicit-capture-in-parse-how-to-get-it/1718">like how we don't have implicit capture</a></strong>.</p>
<pre><code>parse isodate [
    year: between &lt;here&gt; "-"
    month: between &lt;here&gt; "-"
    day: between &lt;here&gt; "T"
    ...
]
</code></pre>
<p>I'm not saying this is what we should use fences for, but just to kick-off that "outside-the-box" brainstorm:</p>
<pre><code>parse isodate [{year} "-" {month} "-" {day} "T" ...]
</code></pre>
<p>If my only choices were between that and an alternate for GATHER+EMIT, I'd pick that, because I think we'd get a lot more mileage out of it.</p>
<p>Remember also that there are lots of variations, like <strong><code>${...}</code></strong> and <strong><code>:{...}</code></strong> and whatever combinations in paths in chains and tuples you can think of.  Ideally how it's used makes some sense across these variants.  But we should remember that dialecting is about serving the domain, not making sacrifices to some god-of-consistency.</p>
<p><strong>Anyway...it's going to take time to build up a sense of what being "fency" means.</strong></p>
<p>But if any pet applications start coming to mind, pitch them.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/fence-in-parse-what-should-it-do/2312">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/fence-in-parse-what-should-it-do/2312</link>
          <pubDate>Thu, 10 Oct 2024 18:52:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2312</guid>
          <source url="https://forum.rebol.info/t/fence-in-parse-what-should-it-do/2312.rss">FENCE! In PARSE: What Should It Do?</source>
        </item>
        <item>
          <title>Parsing/Destructuring a QUOTED! or QUASIFORM!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Quoteds (and quasiforms) can be seen kind of as containers...</p>
<p>But there isn't a good way to destructure them at the moment.</p>
<p>One off-the-cuff idea would be that you could SUBPARSE into them:</p>
<pre><code>&gt;&gt; parse ['a:] [subparse quoted! set-word!]
== a:

&gt;&gt; parse [''a:] [subparse quoted! subparse quoted! set-word!]
== a:

&gt;&gt; parse [~(a b c)~] [subparse quasiform! subparse group! [some word!]]
== c
</code></pre>
<p>A bit of a belabored method.  And because combinators require a series, I can't think of any efficient way to do that (vs. fabricating an array to hold a single item, and parsing that as a series.)  But it's better than no method at all.</p>
<p><strong>UPDATE:</strong> Having come up with a strategy for <a href="https://forum.rebol.info/t/typechecking-quoted-forms-quasiforms-antiforms/2298">doing constraints like <strong><code>quote:quote:block?</code></strong></a>, it seems that covers a lot of use cases:</p>
<pre><code>&gt;&gt; parse ['a:] [&amp;quote:set-word!]
== a:

&gt;&gt; parse [''a:] [&amp;quote:quote:set-word!]
== a:

&gt;&gt; parse [~(a b c)~] [subparse &amp;quasi:group! [some word!]]
== c
</code></pre>
<p>It would require SUBPARSE to be willing to go inside quoted lists, which is easy enough to permit (and no reason not to, since it has to pass the type check you know what you're doing).</p>
<p>Seems to be reasonably powerful...just have to make peace with this strange new world of <em>dialecting the act of calling functions itself.</em> (!)</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/parsing-destructuring-a-quoted-or-quasiform/2300">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/parsing-destructuring-a-quoted-or-quasiform/2300</link>
          <pubDate>Fri, 27 Sep 2024 21:59:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2300</guid>
          <source url="https://forum.rebol.info/t/parsing-destructuring-a-quoted-or-quasiform/2300.rss">Parsing/Destructuring a QUOTED! or QUASIFORM!</source>
        </item>
        <item>
          <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>R3-Alpha had an idea--carried forward by Red--of an <strong>arity-1</strong> IF combinator.</p>
<pre><code>red&gt;&gt; num: 1020

red&gt;&gt; parse [a a a] [if (even? num) some 'a]
== true

red&gt;&gt; parse [a a a] [if (odd? num) some 'a]
== false
</code></pre>
<p>As you see, if the expression you give it turns out to be "falsey" then it doesn't continue matching.  It skips to the next alternate--if there is one.</p>
<pre><code>red&gt;&gt; parse [a a a] [if (odd? num) some 'b | some 'a]
== true
</code></pre>
<p>But I always thought the arity-1 IF was a pretty alien thing that would confuse people.  You might think there's a branch, but there's no "branch"... just continuing along with the variadic list of everything that follows until the next <strong>|</strong> or end of BLOCK!.</p>
<p>I also wondered "where does it end?"  With an IF combinator, why not a CASE combinator, or SWITCH combinator?</p>
<p>So when I came up with GET-GROUP! doing arbitrary substitutions of the rule it evaluates to, I thought "hey, that's a lot more general!"  We could just say that ~true~ and ~void~ antiforms would continue the parse, ~false~ would stop it, and ~null~ antiforms would trigger an error in case you didn't mean to do that.</p>
<h3><a name="p-7569-what-that-get-group-concept-looked-like-1" class="anchor" href="https://forum.rebol.info#p-7569-what-that-get-group-concept-looked-like-1"></a>What That <code>:(GET-GROUP!)</code> Concept Looked Like</h3>
<p><em>(Note that <strong>if condition '[...]</strong> is equivalent to <strong>if condition [[...]]</strong>.  This is called <a href="https://forum.rebol.info/t/soft-quoted-branching-light-elegant-fast/1020">"soft-quoted branching"</a>)</em></p>
<pre><code>&gt;&gt; num: 1020, rule: null

; generated [some 'b] rule is treated as if it had been written there
&gt;&gt; parse [a a a b b b] [some 'a :(if even? num '[some 'b])]
== b 

; generated ~void~ from non-taken IF gets ignored, and it kept parsing
&gt;&gt; parse [a a a b b b] [some 'a :(if odd? num '[some 'c]) some 'b]
== b

; generated ~true~ signal continues parse, just as ~void~ did
&gt;&gt; parse [a a a b b b] [some 'a :(even? num) some 'b]
== b

; generated ~false~ skips to next alternate (isn't one, so parse fails)
&gt;&gt; parse [a a a b b b] [some 'a :(odd? num) some 'b]
** Error: PARSE BLOCK! combinator did not match input

; treat ~null~ conservatively, use :(maybe rule) for ~void~ to keep going 
&gt;&gt; parse [a a a b b b] [some 'a :(rule) some 'b]
** Error: ~null~ antiform generated by GET-GROUP! in PARSE
</code></pre>
<h2><a name="p-7569-flexible-logichttpsforumrebolinfotflexible-logic-system-terminology2252-kills-true-false-breaks-that-idea-2" class="anchor" href="https://forum.rebol.info#p-7569-flexible-logichttpsforumrebolinfotflexible-logic-system-terminology2252-kills-true-false-breaks-that-idea-2"></a><a href="https://forum.rebol.info/t/flexible-logic-system-terminology/2252">Flexible Logic</a> Kills <code>[~true~ ~false~]</code>... Breaks That Idea</h2>
<p>In the flexible logic model, <code>[TRUE FALSE ON OFF YES NO]</code> are WORD!s, and hence indiscriminately trigger taking the branch in something like an IF when used directly.  The ~null~ antiform is the "branch inhibitor", and it's what conditional expressions return when they don't match the condition.</p>
<pre><code>&gt;&gt; 10 &gt; 20
== ~null~  ; anti
</code></pre>
<p>I don't think it's a good idea to make substitions via GET-GROUP! (or whatever comes to replace it) silently continue on NULL.  If you forgot to set a variable that was supposed to hold something (as in <strong>rule</strong> above), that should give you an error.  But I don't think you should have to write <strong>:(maybe even? num)</strong> <img src="https://forum.rebol.info/images/emoji/twitter/nauseated_face.png?v=12" title=":nauseated_face:" class="emoji" alt=":nauseated_face:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-7569-so-having-a-conditional-logic-combinator-makes-sense-3" class="anchor" href="https://forum.rebol.info#p-7569-so-having-a-conditional-logic-combinator-makes-sense-3"></a>So Having A Conditional Logic Combinator Makes Sense</h2>
<p>I just think that IF is a rather lousy name for it.</p>
<p>So I'll suggest <strong>WHEN</strong>.</p>
<pre><code>&gt;&gt; parse [a a a b b b] [some 'a, when (even? num), some 'b]
== b 
</code></pre>
<p>It would be against the premise of flexible logic to have WHEN be biased and assume things like TRUE, YES, or NO should mean it continues or not.  I like the idea that you could hold a completely arbitrary word in a variable and say <strong><code>when (word)</code></strong>, that means <em>"continue matching when word is set to a non-null value"</em>.</p>
<p>Hence you'd have to say <strong><code>when (true? flag)</code></strong> or <strong><code>when (off? toggle)</code></strong> etc.  I'm not merely <em>comfortable</em> with this... I am gung-ho about it! <img src="https://forum.rebol.info/images/emoji/twitter/comet.png?v=12" title=":comet:" class="emoji" alt=":comet:" loading="lazy" width="20" height="20"></p>
<p>(Of course people can make their own combinators and build in biases of their choosing, the core just doesn't pick sides.)</p>
<h2><a name="p-7569-bypass-can-be-a-synonym-for-when-null-4" class="anchor" href="https://forum.rebol.info#p-7569-bypass-can-be-a-synonym-for-when-null-4"></a>BYPASS Can Be A Synonym For <code>[when (null)]</code></h2>
<p>I didn't like using FAIL for saying when to stop a rule chain and go to the next alternate, because that is used for causing "abrupt failures" in the system.</p>
<p>So I'd been using quasiform <code>~false~</code> the state in source (and the antiform if in a variable).</p>
<pre><code>&gt;&gt; parse [a a a b b b] [some 'a, :(if even? num [false]), some 'b]
** Error: PARSE BLOCK! combinator did not match input

&gt;&gt; parse [a a a b b b] [some 'a, ~false~, some 'b]
** Error: PARSE BLOCK! combinator did not match input
</code></pre>
<p>But that isn't the model anymore.  There is no ~false~ or ~true~ antiform.  And honestly it wasn't that literate anyway. <strong>when (...)</strong> makes it clearer when you're using a variable.  And the quasiform just looks confusing.</p>
<p>Searching for a good word that doesn't run into something serving other purposes (e.g. BREAK), I asked Claude.ai for suggestions, and one of those was BYPASS.</p>
<p>I like it.  So for example you could write:</p>
<pre><code>&gt;&gt; parse [a a a b b b] [some 'a [:(if even? num ['bypass]) some 'c] | some 'b]]
== b
</code></pre>
<p>Although that particular case is clearer as <strong><code>[when (odd? num) ...]</code></strong>, but sometimes you have to throw in a bypass rule.</p>
<p><em>(Amusingly, in Rebol2 the idiom for BYPASS was <strong><code>[end skip]</code></strong>, which was a rule guaranteed to mismatch at any position: either you weren't at the tail and the END wouldn't match, or you were at the tail and the END would match but then you couldn't SKIP.)</em></p>
<h2><a name="p-7569-where-does-it-stop-5" class="anchor" href="https://forum.rebol.info#p-7569-where-does-it-stop-5"></a>Where Does It Stop?</h2>
<blockquote>
<p>I also wondered "where does it end?"  With an IF combinator, why not a CASE combinator, or SWITCH combinator?</p>
</blockquote>
<p>So I think it's good to just say WHEN.</p>
<p>You don't <em>technically</em> need WHEN if you have BYPASS to skip to next alternate, and ~void~ to keep going (or empty block, if you like... <code>[]</code> will keep going too).</p>
<pre><code> when (cond) =&gt; :(if not cond ['bypass])  ; or :(if not cond 'bypass)
</code></pre>
<p>But that forces you to reverse the sense of your logic and write out something longer (and slower).  I think if you've got logic that's complex like a case or switch, then writing it out as a splicing rule would have negligible benefit to try and shoehorn as a combinator.</p>
<h2><a name="p-7569-a-potential-weak-spot-in-for-canon-branch-trigger-6" class="anchor" href="https://forum.rebol.info#p-7569-a-potential-weak-spot-in-for-canon-branch-trigger-6"></a>A Potential Weak Spot In <strong><code>#</code></strong> for Canon Branch Trigger</h2>
<p>It's a given that the ~null~ antiform is the canon "Branch Inhibitor".  It may well be the <em>only</em> branch inhibitor (though I'm considering <a href="https://forum.rebol.info/t/isotopes-and-nan-not-a-number/2245">~NaN~ antiforms</a> might also not trigger branches).</p>
<p>What's more up in the air is what the <em>canon branch trigger</em> is.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2250">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"><a href="https://forum.rebol.info/t/true-false-on-off-yes-no/2250/5">True, False, On, Off, Yes, No...?</a></div>
<blockquote>
<p>I think this all just points to <strong><code>#</code></strong> being the most sensible choice, even though it's not an antiform. You can't have everything.</p>
</blockquote>
</aside>
<p>Before considering WHEN--I was looking at the impacts of using <strong>#</strong> on the GET-GROUP! substitution rules that had been in place.</p>
<p>Previously you could do this:</p>
<pre><code>&gt;&gt; parse #{000000FFFFFF} [zeros: tally #{00} :(odd? zeros) some #{FF}]
== #{FF}

&gt;&gt; parse #{000000FFFFFF} [zeros: tally #{00} :(even? zeros) some #{FF}]
** Error: PARSE BLOCK! combinator did not match input
</code></pre>
<p>But this becomes <em>fully broken</em> with things like EVEN? and ODD? returning either <strong><code>~null~</code></strong> or <strong><code>#</code></strong>.</p>
<pre><code>&gt;&gt; parse #{000000FFFFFF} [zeros: tally #{00} :(odd? zeros) some #{FF}]
** Error: ~null~ antiform generated by GET-GROUP! in PARSE

&gt;&gt; parse #{000000FFFFFF} [zeros: tally #{00} :(even? zeros) some #{FF}]
** Error: PARSE BLOCK! combinator did not match input
</code></pre>
<p>The second case didn't match because since things like <strong><code>#a</code></strong> are character literals, <strong><code>#</code></strong> has been used to represent the 0 codepoint.  So in BINARY! it matches that.</p>
<pre><code>&gt;&gt; append #{DECAFBAD} #
== #{DECAFBAD00}

&gt;&gt; parse #{000000} [some #]
== #
</code></pre>
<p><em>(Having the # combinator synthesize # vs 0 is debatable.  But it wouldn't be #{00}.  We don't want matching combinators to make new series--they only return their own series argument which is already allocated.)</em></p>
<p>And if you had a BLOCK! it would match <strong>#</strong></p>
<pre><code>&gt;&gt; data: [a a a # b b b]

&gt;&gt; parse data [some 'a :(true? trailing-b) some 'b]
== b  ; great!  we know the block is all As and Bs!  (oh, WHOOPS!)
</code></pre>
<p>This is part of why I was saying the canon branch trigger should be an antiform--because it gets pushed out of band for things like this.</p>
<p>But the inconvenient truth is that tradeoffs are inevitable.  Here (and elsewhere) the problem can be addressed by not trying to mix conditional logic with substitution.  Substitution needs to be either a legal array element, or a ~void~ antiform to consciously opt out.  Conditional logic is now fully driven by non-nullity, meaning you need different instructions to contrast it with full-band substitution.</p>
<p>It still makes me a uneasy that the canon branch trigger isn't an antiform.  That will inevitably cause confusion... be accepted where it shouldn't, or have unintended meanings.</p>
<pre><code>&gt;&gt; num: 304

&gt;&gt; compose [flag: (odd? num)]
** Error: Cannot compose ~null~ antiform into array slot

&gt;&gt; compose [flag: (even? num)]
== [flag: #]  ; we allowed something that is likely not what you meant
</code></pre>
<p><strong>So perhaps people can be empathetic to why I thought NOTHING would be a better choice for the canon branch trigger!</strong></p>
<p>But this might be an unwinnable fight, and the consequences of reusing the NOTHING antiform are greater than that of getting the occasional # substituted where it should not be...with the burden of inventing a whole new antiform not giving the payoff that putting another part in the mix needs to have.</p>
            <p><small>12 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253</link>
          <pubDate>Thu, 05 Sep 2024 20:19:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2253</guid>
          <source url="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
        </item>
        <item>
          <title>Deceptive Incomplete Parsing: A Common Problem</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Some code I'd written checked for file extensions, wanting only %.r and %.reb files to be processed.  It looked like this:</p>
<pre><code> for-each file ... [
     parse file [thru ".reb" | thru ".r"] else [continue]
     ...
 ]
</code></pre>
<p>That doesn't work anymore, because PARSE raises an error instead of returning null.  The ELSE needs to be an EXCEPT, or you have to use IF NOT OK?, or some other solution.</p>
<p>My first thought on fixing it was why not just put the CONTINUE inside the parse...</p>
<pre><code> for-each file ... [
     parse file [thru ".reb" | thru ".r" | (continue)]
     ...
 ]
</code></pre>
<p>That's a neat Rebolism that shows the kind of malleability other languages just don't have.</p>
<p>But it has a problem.  Can you spot it?</p>
<h2>
<a name="old-redbol-conventions-wouldnt-catch-the-mistake-1" class="anchor" href="https://forum.rebol.info#old-redbol-conventions-wouldnt-catch-the-mistake-1"></a>Old Redbol Conventions Wouldn't Catch The Mistake</h2>
<p>Imagine if the file is named <strong>%foo.reb.zip</strong> or <strong>%foo.rar</strong>.  One of the THRUs succeeds, so it won't run the continue alternate.  But it won't reach the end of the filename.</p>
<p>Historical Redbol would have had the PARSE return false, but would have just blindly continued running, passing those unintended filenames!!!</p>
<p>Now we're a step ahead, because PARSE will error if it doesn't reach the end!  <img src="https://forum.rebol.info/images/emoji/twitter/clap.png?v=12" title=":clap:" class="emoji" alt=":clap:" loading="lazy" width="20" height="20"></p>
<h2>
<a name="but-how-to-stop-the-error-2" class="anchor" href="https://forum.rebol.info#but-how-to-stop-the-error-2"></a>But How To Stop the Error?</h2>
<p>We don't want an error if it doesn't terminate in %.r or %.reb, we want to continue the loop.</p>
<p>This will work:</p>
<pre><code> parse file [thru ".reb" &lt;end&gt; | thru ".r" &lt;end&gt; | (continue)]
</code></pre>
<p>And it's not catastrophically bad.  But it feels weird.</p>
<p>You can remove the <code>&lt;end&gt;</code> duplication:</p>
<pre><code> parse file [thru [".reb" | ".r"] &lt;end&gt; | (continue)]
</code></pre>
<p>You can also do that with ANY:</p>
<pre><code> parse file [thru any [".reb" ".r"] &lt;end&gt; | (continue)]
</code></pre>
<p>You can of course go for the conventional forms:</p>
<pre><code>parse file [thru ".reb" | thru ".r"] except [continue]

if not ok? parse file [thru ".reb" | thru ".r"] [continue]
</code></pre>
<p>But I feel like there's something missing when you write something like this without making the <code>&lt;end&gt;</code> explicit...because it leads to someone getting the bright idea (as I did) to reformulate it without taking the <code>&lt;end&gt;</code> into account.</p>
<h2>
<a name="in-any-case-this-being-overlooked-is-now-caught-3" class="anchor" href="https://forum.rebol.info#in-any-case-this-being-overlooked-is-now-caught-3"></a>In Any Case, This Being Overlooked Is Now Caught!</h2>
<p>It's food for thought on what style you want. But no matter what style you like, I think it shows a clear win for raising the error when the parse doesn't reach the end.</p>
<p>That %foo.rar or %foo.reb.zip -- when they occur -- will not be accepted quietly in the reformulation!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/deceptive-incomplete-parsing-a-common-problem/2065">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/deceptive-incomplete-parsing-a-common-problem/2065</link>
          <pubDate>Tue, 28 Nov 2023 03:33:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2065</guid>
          <source url="https://forum.rebol.info/t/deceptive-incomplete-parsing-a-common-problem/2065.rss">Deceptive Incomplete Parsing: A Common Problem</source>
        </item>
        <item>
          <title>Could PARSE Have a &quot;MAYBE&quot; Combinator?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>By design, nulls are handled noisily--right at the moment of fetching the word!--in UPARSE (and PARSE3):</p>
<pre><code>&gt;&gt; prefix: null, suffix: ")"

&gt;&gt; parse "aaa)" [prefix, some "a", suffix]
** Error: (prefix is null, and we raise errors for that in parse)
</code></pre>
<p>If we didn't raise an error it seems there are only two other options:</p>
<ol>
<li>
<p>Make <strong><code>null</code></strong> always succeed, keeping the parse position where it is (synonym for <strong><code>[]</code></strong>)</p>
</li>
<li>
<p>Make <strong><code>null</code></strong> always be an unsuccessful combinator match, but not cause a failure (synonym for <strong><code>BYPASS</code></strong>)</p>
</li>
</ol>
<p>I think (1) feels like a pretty obvious bad idea, because null is supposed to represent a soft failure. This is the behavior for void, e.g. <strong><code>parse "ab" ["a" void "b"]</code></strong> would work.</p>
<p>I'm not too pleased with the idea of (2), and prefer the error as the default.</p>
<p><em>...that said...</em> it seems there should be some operators or combinators that let you get the other behaviors.</p>
<h2><a name="p-6590-what-about-a-maybe-combinator-to-use-with-null-1" class="anchor" href="https://forum.rebol.info#p-6590-what-about-a-maybe-combinator-to-use-with-null-1"></a>What About a "MAYBE" Combinator To Use With Null?</h2>
<p>In standard code, the policy of "void-in-null-out" has worked well, with MAYBE transforming soft-failure nulls to voids:</p>
<pre><code> ; non-PARSE handling of NULL via MAYBE

 &gt;&gt; append [a b c] null
 ** Error: cannot append ~null~ isotope to a block

 &gt;&gt; append [a b c] maybe null
 == [a b c]

 &gt;&gt; block: null

 &gt;&gt; append maybe block [d e]
 == ~null~  ; anti
</code></pre>
<p>So if we imagine applying this to the parse example, it would presumably do this:</p>
<pre><code>&gt;&gt; prefix: null, suffix: ")"

&gt;&gt; parse "aaa)" [maybe prefix, some "a", maybe suffix]
== ")"
</code></pre>
<p>For the above parse to succeed, the combinator made by <strong>maybe prefix</strong> would have to succeed and not advance the input.</p>
<h2><a name="p-6590-but-it-doesnt-combine-well-in-larger-rules-2" class="anchor" href="https://forum.rebol.info#p-6590-but-it-doesnt-combine-well-in-larger-rules-2"></a>But It Doesn't Combine Well In Larger Rules</h2>
<p>What if what you intended was <em>"if there's a prefix, match some non-zero number of instances, but if prefix is null then don't worry about matching"</em>:</p>
<p>You might try doing that by COMPOSE'ing your rules.  But UPARSE actually lets us write that out literally using GET-GROUP! rule synthesis:</p>
<pre><code>&gt;&gt; parse "aaa)))" [:(if prefix '[some prefix]), some "a", :(if suffix '[some suffix])]
== ")"
</code></pre>
<p>But what if we tried to do that with MAYBE...could it work?</p>
<pre><code>&gt;&gt; parse "aaa)))" [some maybe prefix, some "a", some maybe suffix]
; infinite loop!
</code></pre>
<p>No dice.  We've said <strong>maybe prefix</strong> just succeeds and doesn't advance the input when prefix was null.  But if you combine that with <code>some</code> the null case will just match nothing in perpetuity, causing an infinite loop.</p>
<p>This may look familiar, because if you write <strong>some opt [...anything...]</strong> you'll always get an infinite loop.  But in that case it's just wrong thinking: you know that the repetitive nature of <code>some</code> looking for an eventual non-match meant you must have intended <strong>some [...anything...]</strong> (at least one) or <strong>opt some [...anything...]</strong> (zero or more).</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<blockquote>
<h3>NOTE THAT HISTORICAL PARSE HAS NO GOOD ANSWER FOR THIS</h3>
<p>Rebol2 treats NONE! as a no-op which just succeeds but doesn't advance the input.  So the following gives you an infinite loop:</p>
<pre><code>rebol2&gt;&gt; prefix: none suffix: ")"

rebol2&gt;&gt; parse "aaa)))" [some prefix some "a" some suffix]   
; infinite loop
</code></pre>
<p>The hackish "must make progress" rules in R3-Alpha actually make the above "work as intended", because the SOME will bail out after one non-advancing match.  I don't consider that a "good" answer--more a random effect.</p>
</blockquote>
<h2><a name="p-6590-another-problem-maybe-is-a-very-similar-word-to-optional-3" class="anchor" href="https://forum.rebol.info#p-6590-another-problem-maybe-is-a-very-similar-word-to-optional-3"></a>Another Problem: MAYBE is a very similar word to OPTIONAL</h2>
<p>Imagine looking at this code:</p>
<pre><code>&gt;&gt; prefix: "(", suffix: ")"

&gt;&gt; parse "aaa)" [maybe prefix, some "a", maybe suffix]
== ~null~  ; anti
</code></pre>
<p><em>"But wait"</em>... I can imagine someone saying... <em>"shouldn't MAYBE mean that if it's not there, you skip the rule"</em>?</p>
<p>No... MAYBE is speaking about the <em>optionality (nullability) of the rule itself</em>, not the optionality of the (non-null) rule succeeding.  That's a fairly fine point of distinction that might not be obvious to people.</p>
<p>So perhaps it should go by another name in parsing.  <a href="https://forum.rebol.info/t/shorthand-for-maybe-what-about/2247">There's the shorthand of <strong>?</strong></a>, and that could be learnable as <em>"this rule may be NULL, and if so then just ignore it and keep going"</em>.</p>
<h2><a name="p-6590-an-extra-barrier-to-creating-maybe-is-mechanical-4" class="anchor" href="https://forum.rebol.info#p-6590-an-extra-barrier-to-creating-maybe-is-mechanical-4"></a>An extra barrier to creating MAYBE is mechanical</h2>
<p>It's a bit of a trick, because what happens when you "combinate" a ~null~ is that it has to abruptly fail.  Because if it returned a definitional error, that would just seem like a combinator that didn't match to all the other constructs, and they wouldn't promote it to hard failure.  They'd just treat it like anything else that didn't match.</p>
<p>So the only way I can see a null-disabling MAYBE parse combinator working would be by quoting its argument, doing the rule fetch itself, and turning into a failing combinator if it fetched null.  This breaks the model somewhat.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=12" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>Anyway, we've lived without the MAYBE combinator, and there are workarounds <em>(as I mention, conditional code inside a splicing GROUP! construct)</em>.  Perhaps it isn't necessary.  But wanted to write it up.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/could-parse-have-a-maybe-combinator/2023">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/could-parse-have-a-maybe-combinator/2023</link>
          <pubDate>Fri, 07 Apr 2023 00:14:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2023</guid>
          <source url="https://forum.rebol.info/t/could-parse-have-a-maybe-combinator/2023.rss">Could PARSE Have a &quot;MAYBE&quot; Combinator?</source>
        </item>
        <item>
          <title>Series Switching in PARSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p><strong>Rebol2 Prohibited Series Switching During a PARSE</strong></p>
<pre><code>&gt;&gt; series1: [a a a]
== [a a a]

&gt;&gt; series2: [b b b]
== [b b b]

&gt;&gt; parse series1 ['a :series2 some 'b]
** Script Error: Invalid argument: b b b
</code></pre>
<p>The error wasn't particularly informative.  But it was trying to tell you that you couldn't do that.</p>
<p><strong>Red Chose to Follow Suit, and Prohibits Series Switching During a PARSE</strong></p>
<p>red&gt;&gt; series1: [a a a]<br>
== [a a a]</p>
<p>red&gt;&gt; series2: [b b b]<br>
== [b b b]</p>
<p>red&gt;&gt; parse series1 ['a :series2 some 'b]<br>
*** Script Error: PARSE - get-word refers to a different series! :series2</p>
<p><strong>R3-Alpha Decided To Make It Legal</strong></p>
<pre><code>r3-alpha&gt;&gt; series1: [a a a]
== [a a a]

r3-alpha&gt;&gt; series2: [b b b]
== [b b b]

r3-alpha&gt;&gt; parse series1 ['a :series2 some 'b]
== true
</code></pre>
<p>I wasn't aware the feature was used, but <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> used it in the Rebol3 version of altjson:</p>
<p><a href="https://github.com/rgchris/Scripts/blob/6fa69eabe11fe78b9fd0a7bd6bb17a923cee0b2b/r3-alpha/altjson.r3#L48" class="inline-onebox">Scripts/r3-alpha/altjson.r3 at 6fa69eabe11fe78b9fd0a7bd6bb17a923cee0b2b · rgchris/Scripts · GitHub</a></p>
<h2><a name="p-6421-the-feature-was-added-to-r3-alpha-circa-2009-1" class="anchor" href="https://forum.rebol.info#p-6421-the-feature-was-added-to-r3-alpha-circa-2009-1"></a>The Feature Was Added to R3-Alpha Circa 2009</h2>
<p>Carl's blog entry:</p>
<p><a href="http://www.rebol.net/r3blogs/0265.html">http://www.rebol.net/r3blogs/0265.html</a></p>
<p>He points out one fairly clear reason why this is sketchy:</p>
<blockquote>
<p>The problem is this: if you change the series but the rule fails, forcing a recovery to a prior index, <em>it's still the new series</em>. That is, we do not recover to the old series.</p>
<p>If advanced users are willing to live with that restriction, then this change can be made.</p>
</blockquote>
<p>Another comment says the opposite of what I would think:</p>
<blockquote>
<p>Input switching would make parsing of big (or streaming) files more easy, as we wouldn't have to keep the whole data in memory, and could read it as needed, without losing the current parse state.</p>
</blockquote>
<p>Doing streaming parsing <em>correctly</em> requires <em>tighter</em> control over the process... not less.</p>
<h2><a name="p-6421-can-the-desire-be-met-other-ways-2" class="anchor" href="https://forum.rebol.info#p-6421-can-the-desire-be-met-other-ways-2"></a>Can The Desire Be Met Other Ways?</h2>
<p>Since you're basically destroying the ability to meaningfully backtrack, I don't know how this is that different from starting a new parse.</p>
<p>I'd like it to be easy to return results out of a parse (see the <a href="https://forum.rebol.info/t/uparses-spin-on-return/1589">RETURN/ACCEPT post</a>)</p>
<p>So why wouldn't you have some kind of driving loop on the outside of your parse that looks for a continuation signal, and then starts a new parse with what it's given?</p>
<p>I want to take a look at the cases and see if they could be done some other way.  So maybe <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> can explain the rational behind the choice in altjson, and if there's some feature that would be a better fit.</p>
            <p><small>7 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/series-switching-in-parse/1974">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/series-switching-in-parse/1974</link>
          <pubDate>Tue, 20 Sep 2022 02:03:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1974</guid>
          <source url="https://forum.rebol.info/t/series-switching-in-parse/1974.rss">Series Switching in PARSE</source>
        </item>
        <item>
          <title>SPREAD in PARSE: Isotopic Matching</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Remember that the <code>@var</code> rule will match the contents of variables literally, vs. running them as a rule:</p>
<pre><code>&gt;&gt; var: [some rule]
== [some rule]

&gt;&gt; parse [[some rule] [some rule]] [some @var]
== [some rule]
</code></pre>
<p>You can evaluate an expression to literally match, too:</p>
<pre><code>&gt;&gt; parse [[some rule] [some rule]] [some @(reverse copy [rule some])]
== [some rule]
</code></pre>
<p>Now there's a powerful new twist: <strong>You can match in a spliced fashion, using an isotopic block!</strong></p>
<pre><code>&gt;&gt; var: [some rule]

&gt;&gt; parse [some rule some rule] [some @(spread var)]
== ~[some rule]~  ; isotope
</code></pre>
<p><em>And you can synthesize a product that may be a splice or not!!!</em></p>
<pre><code>&gt;&gt; append [a b c] parse [1 2 3] [block! | spread across some integer!]
== [a b c 1 2 3]

&gt;&gt; append [a b c] parse [[x y z]] [block! | spread across some integer!]
== [a b c [x y z]]
</code></pre>
<p><strong><a href="https://forum.rebol.info/t/putting-splicing-intent-on-appended-value/1873">Encoding the splicing intent on the value is clearly the way to go.</a></strong>  Seems obvious now, but hindsight is 20/20.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/spread-in-parse-isotopic-matching/1949">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/spread-in-parse-isotopic-matching/1949</link>
          <pubDate>Wed, 31 Aug 2022 10:36:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1949</guid>
          <source url="https://forum.rebol.info/t/spread-in-parse-isotopic-matching/1949.rss">SPREAD in PARSE: Isotopic Matching</source>
        </item>
        <item>
          <title>Matching Characters in BINARY! PARSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>In Rebol2, you can't match a character (or string) against a binary!:</p>
<pre><code>rebol2&gt;&gt; to binary! " "
== #{20}

rebol2&gt;&gt; parse #{20} [" "]
== false

rebol2&gt;&gt; parse #{20} [#" "]
== false
</code></pre>
<p>In Red and R3-Alpha, you can do both...</p>
<pre><code>red&gt;&gt; parse #{20} [" "]
== true

red&gt;&gt; parse #{20} [#" "]
== true
</code></pre>
<p>But their unicode model means they really don't know what they're doing in any general sense, and I'm sure whatever's under the hood is incoherent:</p>
<pre><code>red&gt;&gt; to binary! "Æ"
== #{C386}

red&gt;&gt; parse #{C386} ["Æ"]
== false
</code></pre>
<p>Ren-C is much more coherent!</p>
<pre><code>&gt;&gt; did parse #{C386} ["Æ"]
== #[true]
</code></pre>
<h2>So the PARSE Succeeds, but... what should it return?</h2>
<p>Right now a parse on a string returns the <em>rule</em> when it matches.</p>
<pre><code>&gt;&gt; rule: "cd"

&gt;&gt; result: parse "abcd" ["ab" rule]
== "cd"

&gt;&gt; append result "ef"
== "cdef"

&gt;&gt; rule
"cdef"
</code></pre>
<p><strong>This is clearly correct, because you don't want it to make a copy if it doesn't know if you're going to use the copy.</strong>  Basic rule matching should not produce a new series.</p>
<p>The same logic applies to BINARY!...but should it give you the string as a string, or aliased to its binary form?</p>
<pre><code>&gt;&gt; parse #{C386} ["Æ"]
== "Æ"  ; option 1

&gt;&gt; parse #{C386} ["Æ"]
== #{C386}  ; option 2
</code></pre>
<p>I think the answer is that you should match it as whatever form it was in the rule.</p>
<p>But then...how about something like BLANK!, which acts equivalently to space if the input is a string... or BLANK! if it's an array?</p>
<pre><code>&gt;&gt; parse [_] [_]
== _

&gt;&gt; parse " " [_]
== ???

&gt;&gt; parse #{20} [_]
== ???
</code></pre>
<p>If we're going with the idea of rule as being primacy, then the language of the match should be the same as the language of the rule... e.g. the above all return blank.</p>
<p>But this is something of a gray area, IMO.  I feel like blank is acting as a stand-in for space and should probably be looked at as if you said space.</p>
<pre><code>&gt;&gt; parse " " [_]
== #" "

&gt;&gt; parse #{20} [_]
== #" "  ; instead of 32
</code></pre>
<p>So this is what I'm going with, unless someone has a really good argument for something else.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/matching-characters-in-binary-parse/1935">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/matching-characters-in-binary-parse/1935</link>
          <pubDate>Sun, 21 Aug 2022 05:43:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1935</guid>
          <source url="https://forum.rebol.info/t/matching-characters-in-binary-parse/1935.rss">Matching Characters in BINARY! PARSE</source>
        </item>
        <item>
          <title>TRY PARSE + PARSE EXCEPT : *RAISE* On Mismatch</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>There's a snazzy new potential for giving more informative messages / logs from failed parses... which means we now have a more interesting option than we might have had before.</p>
<p>Imagine something like:</p>
<pre><code>&gt;&gt; parse "aaa" [some "a" some "b"]
** Error: SOME requires at least one match
** Where: [some "a" \\ some "b" \\]
; Note: this failure can be intercepted by TRY, EXCEPT, ATTEMPT
</code></pre>
<p>It can't be perfect unless it maintains some kind of large error tree that accumulates the list of all the reasons it decided to fail, so you might have to be in a debugging mode to ask it to give you a bigger diagnostic.  But we can build it now with the participation of the combinators themselves.</p>
<p><strong>But not only this, we could open up the full spectrum of return values.</strong>  Right now if your parse returns NULL, it has to be contorted into a "heavy null" PACK to avoid accidentally cuing an ELSE.  (Similar contortions for void.)</p>
<pre><code>result: parse block rules except e -&gt; [print "Got an error", return ~]

; If you got here, you know result is good
; Even if it was a purposefully returned NULL, etc.
</code></pre>
<p>There'd be some way to rig this up without using enfix.  I might make things more lax about letting you assign error antiforms, because the isotope will bubble through and cause a problem anyway.  So you could write something like:</p>
<pre><code> if raised? result: parse block rules [
     print "You have a failure, use ^result to get it"
 ]
</code></pre>
<p>If you were willing to collapse failure down to a NULL or somesuch, or didn't even care about the result, you could just TRY it.</p>
<pre><code> try parse block rules
</code></pre>
<h2>
<a name="too-good-not-to-be-the-default-1" class="anchor" href="https://forum.rebol.info#too-good-not-to-be-the-default-1"></a>Too Good Not To Be The Default</h2>
<p>Of course you'll be able to reskin it however you like for the R3C's or R3Chius out there.  But I think this looks like a perfect convergence to put in the box.</p>
<p>Errors aren't going to be that interesting on day one, but it's good to point the ship in the right direction.</p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/try-parse-parse-except-raise-on-mismatch/1924">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/try-parse-parse-except-raise-on-mismatch/1924</link>
          <pubDate>Fri, 19 Aug 2022 06:23:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1924</guid>
          <source url="https://forum.rebol.info/t/try-parse-parse-except-raise-on-mismatch/1924.rss">TRY PARSE + PARSE EXCEPT : *RAISE* On Mismatch</source>
        </item>
        <item>
          <title>Wish: Multi-Returns For UPARSE Combinators</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Every combinator has a synthesized value.  But some combinators throw away values synthesized by their parser parameters.</p>
<p>For instance, TALLY.</p>
<pre><code>&gt;&gt; parse [1020 304] [int: some integer!]
== 304

&gt;&gt; parse [1020 304] [count: tally some integer!]
== 2
</code></pre>
<p>TALLY knows what the result of the last call it made was, but doesn't preserve it.  What if you could?</p>
<pre><code>&gt;&gt; parse [1020 304] [[count int]: tally some integer!]
== 2

&gt;&gt; count
== 2

&gt;&gt; int
== 304
</code></pre>
<p>That particular one is not necessarily a very interesting example, since you could get it yourself...</p>
<pre><code>parse [1020 304] [count: tally int: some integer!]
</code></pre>
<p>I only mention it because it was in a comment in UPARSE I wanted to delete, because it's a long enough file without becoming a wishlist compilation.  :-/</p>
<p>But there are certainly going to be other examples of combinators that might want to synthesize more than one value.  So hopefully the feature can be implemented at some point...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/wish-multi-returns-for-uparse-combinators/1920">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/wish-multi-returns-for-uparse-combinators/1920</link>
          <pubDate>Wed, 17 Aug 2022 14:43:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1920</guid>
          <source url="https://forum.rebol.info/t/wish-multi-returns-for-uparse-combinators/1920.rss">Wish: Multi-Returns For UPARSE Combinators</source>
        </item>
        <item>
          <title>Calling Combinators (Decoders?) as Normal Functions</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>A few times I've talked about the potential of making it possible to call a COMBINATOR function from outside of PARSE.</p>
<p>This is to say that if some PARSE-specific parameter was missing (e.g. the "parse state") there'd be a mode in the guts of the COMBINATOR mechanic which cooked up something like a temporary parse session just for the input you passed in.</p>
<h2><a name="p-6238-would-it-combinate-parsers-for-you-1" class="anchor" href="https://forum.rebol.info#p-6238-would-it-combinate-parsers-for-you-1"></a>Would It "Combinate" Parsers For You?</h2>
<p>The situations I had in mind weren't really combinators that take parsers as parameters.  And now that I look at it, I think that suggests that... no, you probably shouldn't call these kinds of combinators outside of parse.</p>
<p>Here's one imagination of calling a combinator like SOME:</p>
<pre><code>&gt;&gt; [value rest]: some "aaaabbb" [repeat 2 "a"]
== "a"

&gt;&gt; value
== "a"

&gt;&gt; rest
== "bbb"
</code></pre>
<p>This exposes how SOME is actually not arity-1.  Though it takes a "combinated parser" as a parameter, it also takes an INPUT...but that's usually implicit...specialized in by PARSE.  But calling directly from normal code it could offer that parameter being gathered normally.</p>
<p>it doesn't feel that compelling, since you're getting a synonym for:</p>
<pre><code>parse "aaaabbb" [some repeat 2 "a"]
</code></pre>
<p>But also, why would it take that interpretation instead of:</p>
<pre><code>parse "aaaabbb" [some ([repeat 2 "a"])]
</code></pre>
<p>One point of view would say it makes more sense to think of the expression as the product of evaluation, because the argument would presumably be otherwise evaluative:</p>
<pre><code>&gt;&gt; [value rest]: some "aaaabbb" append [repeat 2] "a"
== ??? ; infinite loop?
</code></pre>
<p>But this would make rule-taking combinators nearly useless.</p>
<h2><a name="p-6238-it-was-suggested-for-sharing-decoding-not-combinating-2" class="anchor" href="https://forum.rebol.info#p-6238-it-was-suggested-for-sharing-decoding-not-combinating-2"></a>It Was Suggested For Sharing "Decoding", not "Combinating"</h2>
<p>Seeing how SOME isn't a good example for this, maybe the right way of saying what I'm trying to say here this is that there's some category of functions we might call "decoders"...and PARSE would be willing to call these.</p>
<p>They'd fit a standard format regarding things like taking an input series and giving back an amount of progress or an error.  But they would not be passed something like the parser stack or have any automatic composition of parsers as arguments.</p>
<p>Plain decoding operations--like <a href="https://forum.rebol.info/t/binary-dialected-encoding-decoding-instead-of-to-conversions/1270">ENBIN and DEBIN</a>--were the motivating cases:</p>
<pre><code>&gt;&gt; debin #{FEFFFF} [le + 3]
== 16777214

&gt;&gt; parse #{FEFFFFFEFFFF} [collect [keep debin [le + 3]]]
== [16777214 16777214]
</code></pre>
<p>The idea here was that you could write one version of DEBIN, and it would be able to implicitly pick up the INPUT when used in PARSE.</p>
<p>But because the input is an implicit parameter that you get automatically for all "decoders", then without extra information it would have to be at either the beginning or end of the parameter list.  Above it's at the beginning, which is different from how DEBIN was defined originally:</p>
<pre><code>&gt;&gt; debin [le + 3] #{FEFFFF}  ; original DEBIN design took dialect block first
== 16777214
</code></pre>
<p><em>(Note: I have a post about <a href="https://forum.rebol.info/t/parameter-order-in-rebol/1238">parameter ordering</a> which questions the series-first model.)</em></p>
<p>We could say that "decoders" have to manually mention their input parameter somewhere, and position it in the order that it would be consumed if it's used outside of PARSE...which would allow customization of this process.  It could default to being the first parameter if not positioned explicitly.  Not an idea-killer, in any case.</p>
<h2><a name="p-6238-if-all-the-input-wasnt-consumed-it-would-error-3" class="anchor" href="https://forum.rebol.info#p-6238-if-all-the-input-wasnt-consumed-it-would-error-3"></a>If All The Input Wasn't Consumed, It Would Error</h2>
<p>One idea of calling these decoders on arbitrary input could be that if the end of input was not reached, it would give an error:</p>
<pre><code>&gt;&gt; debin [le + 3] #{FEFFFF00}  ; asking for 3 bytes of decode, passed 4
** Error: DEBIN did not consume all input, request remainder if intentional
</code></pre>
<p>Asking for a remainder could prevent the error:</p>
<pre><code>&gt;&gt; [value rest]: debin [le + 3] #{FEFFFF00}
== 16777214

&gt;&gt; rest
== #{00}
</code></pre>
<p>So this is kind of where the motivation is.  Once you've written the decoder version of DEBIN, you have everything you need to run a DEBIN operation inside or outside of PARSE.  So why should you need to write a separate combinator and non-combinator form?</p>
<p>As usual, more thought needed.  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_head_bandage.png?v=12" title=":face_with_head_bandage:" class="emoji" alt=":face_with_head_bandage:" loading="lazy" width="20" height="20"></p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/calling-combinators-decoders-as-normal-functions/1914">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/calling-combinators-decoders-as-normal-functions/1914</link>
          <pubDate>Mon, 15 Aug 2022 07:39:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1914</guid>
          <source url="https://forum.rebol.info/t/calling-combinators-decoders-as-normal-functions/1914.rss">Calling Combinators (Decoders?) as Normal Functions</source>
        </item>
        <item>
          <title>The &quot;Yada Yada Yada&quot; Operator (...)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>It seemed we could have a shorter way to say <strong><code>to &lt;end&gt;</code></strong> (or <strong><code>thru &lt;end&gt;</code></strong>, they act the same).</p>
<pre><code> &gt;&gt; parse "aabbcc" [some "a" to &lt;end&gt;]
 == ""
</code></pre>
<p>In fact, what you want more often is probably <strong><code>elide to &lt;end&gt;</code></strong>.  Because the <strong><code>&lt;end&gt;</code></strong> combinator currently evaluates to the end position of the series (hence the "" you see above, as the TO returns what its argument evaluates to.)</p>
<pre><code> &gt;&gt; parse "aabbbcc" [some "a" elide to &lt;end&gt;]
 == "a"
</code></pre>
<p>A kind of obvious choice for meaning this would be <strong><code>...</code></strong></p>
<pre><code> &gt;&gt; parse "aabbbcc" [some "a" ...]
 == "a"
</code></pre>
<p><sub><em>(Initially I was skeptical of using <code>...</code> without some decoration, and did this with the TAG! of <code>&lt;...&gt;</code>, but I think the reasons I was skeptical are probably not good reasons, and we should go ahead and make it  easier on the eyes and easier to type.)</em></sub></p>
<h2>But Why Should It Only Work At The End?</h2>
<p>This seems useful:</p>
<pre><code> &gt;&gt; parse "aabbbcc" [... some "b" ...]
 == "b"
</code></pre>
<p>But isn't that just a synonym for THRU, with the exception that if there's nothing to go THRU it assumes you mean <code>&lt;end&gt;</code> ?</p>
<p><em>Well, a synonym for THRU isn't really what you want.</em>  You'd probably like this to work:</p>
<pre><code> &gt;&gt; parse "aabbbcc" [... some "x" | some "b" ...]
 == "b"
</code></pre>
<p>In essence, you want it to implicitly wrap anything to the right--up to the next <code>&lt;...&gt;</code>--in a BLOCK!, so act equivalently to:</p>
<pre><code> &gt;&gt; parse "aabbbcc" [thru [some "x" | some "b"] elide to &lt;end&gt;]
 == "b"
</code></pre>
<p>That's not possible for a normal combinator, you'd need a variadic one.</p>
<p>Today's approximation of variadic combinators is to just special-case the implementation directly in the BLOCK! combinator.</p>
<p><strong>So...that's what I've done!</strong></p>
<p>A more elegant way of writing the feature may come down the pipe someday.  But this gives us a version we can use in the here and now.</p>
<p>It's experimental, so use with caution.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/man_scientist.png?v=9" title=":man_scientist:" class="emoji only-emoji" alt=":man_scientist:"></p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-yada-yada-yada-operator/1876">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-yada-yada-yada-operator/1876</link>
          <pubDate>Tue, 12 Jul 2022 14:55:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1876</guid>
          <source url="https://forum.rebol.info/t/the-yada-yada-yada-operator/1876.rss">The &quot;Yada Yada Yada&quot; Operator (...)</source>
        </item>
        <item>
          <title>Semantics of UPARSE&#39;s FURTHEST</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Upon the announcement of UPARSE, <a class="mention" href="https://forum.rebol.info/u/brett">@Brett</a> listed as his <a href="https://forum.rebol.info/t/introducing-uparse-the-hackable-usermode-parse/1529/4">secondmost missing feature</a> the idea of knowing "how far a parse got":</p>
<blockquote>
<ol start="2">
<li>An ability to return the furthest input point matched and the rule that caused rollback from there on parse failure. During development of rules this generally indicates the rule that is not properly specified.</li>
</ol>
</blockquote>
<p>What I've done is make it so combinators use a common generator COMBINATOR.  This generator takes the function body you give it, and stuffs in some boilerplate parameters (like the INPUT and STATE).  But it also wraps your code with some more boilerplate that can run before and after the parser.</p>
<p>The current idea of the "parser state" is just to pass around the FRAME! of the UPARSE operation itself.  So if you have any global state you want visible to the parse you can put it there.  Hence the state gives every combinator access to the arguments, return values, and locals of the invocation.</p>
<p>I made <strong>FURTHEST</strong> a multi-return value.  The hooked combinators are run, and then if they succeed they're checked to see if they got further than any previous combinator.  If so they update furthest.</p>
<pre><code>&gt;&gt; [_ furthest]: uparse "aaabbb" [some "a" some "c"]
; null

&gt;&gt; furthest
== "bbb"
</code></pre>
<h2><a name="p-6031-i-notice-to-and-ahead-skew-furthest-a-bit-far-1" class="anchor" href="https://forum.rebol.info#p-6031-i-notice-to-and-ahead-skew-furthest-a-bit-far-1"></a>I Notice TO and AHEAD Skew FURTHEST a Bit Far...</h2>
<p>Consider the case of the <strong>TO</strong> combinator.  It's supposed to move the parse position to <em>right before</em> an instance of the matching rule.</p>
<p>But the subtlety of backing up that position is lost on FURTHEST...which just noticed that a successful parser run occurred, and updates the high water mark:</p>
<pre><code>&gt;&gt; [result furthest]: uparse "aabbcc" [to "bb"]
; null

&gt;&gt; furthest
== "cc"  ; not "bbcc"
</code></pre>
<p>It's a problem that's kind of a parallel with rollback.  <em>Which leads to the discovery of a quirk!</em> TO does not manage its "pending" list explicitly...it uses the default "auto-routing".  Hence the success of the last parser it calls--whose advancement it doesn't want--counts in a collect:</p>
<pre><code>&gt;&gt; uparse "aabbcc" [collect to [some keep "b"], elide [2 "b" 2 "c"]]
== ["b" "b"]
</code></pre>
<p>Is that right?  (cc: <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a>)  If it's <em>not</em> right, then it would seem that any KEEPs inside a TO rule should never have an effect.  That seems strictly less powerful than being <em>able</em> to grab things when you find an ahead-match, so I think it's okay.  <img src="https://forum.rebol.info/images/emoji/twitter/question.png?v=12" title=":question:" class="emoji" alt=":question:" loading="lazy" width="20" height="20"></p>
<p>But with FURTHEST it's less clear.</p>
<h2><a name="p-6031-pathology-studies-how-about-minmatch-2" class="anchor" href="https://forum.rebol.info#p-6031-pathology-studies-how-about-minmatch-2"></a>Pathology Studies: How About MINMATCH?</h2>
<p>I made MAXMATCH as a case study of different approaches to influence on COLLECT:</p>
<p><strong><a href="https://github.com/metaeducation/ren-c/blob/8ed60125a473fe285e56213f82a6e7e4fa1d9e5a/tests/parse/examples/maxmatch.parse.test.reb">maxmatch.parse.test.reb</a></strong></p>
<p>Similarly we could ask about MINMATCH, and what its participation with FURTHEST should be.</p>
<p>It could call two parsers...have both succeed...and then only advance the smaller amount of the two.  We might say this "foils" a wrapper-based approach to updating furthest, as it would be advanced by the larger amount.</p>
<p>I'm hesitant to burden combinator authors with another parameterization just to express distinctions for the purposes of FURTHEST.  But it's a good thought experiment for what the limits are.</p>
<aside class="quote no-group quote-modified" data-username="Brett" data-post="4" data-topic="1529">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/brett/48/177_2.png" class="avatar"><a href="https://forum.rebol.info/t/introducing-the-hackable-usermode-parse-uparse/1529/4">Introducing The Hackable Usermode PARSE ("UPARSE")</a></div>
<blockquote>
<p>... and the rule that caused rollback from there on parse failure. During development of rules this generally indicates the rule that is not properly specified.</p>
</blockquote>
</aside>
<p>I'm not really sure what the behavior here would be.</p>
<p>Maybe you can look at <a href="https://github.com/metaeducation/ren-c/blob/fb0d6758fa53d6b004cf96940aaaefc95853d615/scripts/uparse.reb#L82">how the furthest detection works</a> and explain in the context of the code what you would want.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/semantics-of-uparses-furthest/1868">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/semantics-of-uparses-furthest/1868</link>
          <pubDate>Sat, 09 Jul 2022 12:21:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1868</guid>
          <source url="https://forum.rebol.info/t/semantics-of-uparses-furthest/1868.rss">Semantics of UPARSE&#39;s FURTHEST</source>
        </item>
        <item>
          <title>Should &quot;Arity-2 INTO&quot; in UPARSE actually just be... PARSE?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>There's a cool feature that UPARSE's INTO is willing to take a rule that gives the data you want to parse into, even if it has to be synthesized:</p>
<pre><code>&gt;&gt; uparse "(1 1 1)" [
    into [between "(" ")"] [data: &lt;here&gt; (print mold data) some integer!]
]
</code></pre>
<p>That will give you:</p>
<pre><code>"1 1 1"  ; notice no ")" because the INTO copied the data spanning the rule
== 1
</code></pre>
<p><em>(I threw in the INTEGER! transcode for fun there.  Note that Red allows the transcoding rules for datatypes as well, but only on BINARY! input series. It's because they don't have UTF-8 everywhere, they'd have to rewrite their scanner to process variable-width strings. One of the uncountable Ren-C design advantages...)</em></p>
<p>More generally, you can pass any variable you want to INTO.</p>
<pre><code>&gt;&gt; uparse [1 2 3] [some integer! into ("aaa") some "a"]
== "a"
</code></pre>
<h2>
<a name="but-couldnt-we-just-call-that-parse-1" class="anchor" href="https://forum.rebol.info#but-couldnt-we-just-call-that-parse-1"></a>But... Couldn't We Just Call That PARSE?</h2>
<p>This arity-2 INTO takes an input, and rules.  Why isn't that just PARSE?</p>
<p>Difference is that since it's inside a parse already, its first parameter will be treated as a rule and use the synthesized result...unless you put it in a GROUP!.  But that's implicit.  Maybe call it SUBPARSE to be clear?</p>
<p>It would free up the keyword INTO, maybe to be compatible with historical single-arity version, for cases that have already figured out they're at a series value and don't want to repeat themselves by giving a rule that matches where they know they are.</p>
            <p><small>6 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/should-arity-2-into-in-uparse-actually-just-be-parse/1864">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-arity-2-into-in-uparse-actually-just-be-parse/1864</link>
          <pubDate>Wed, 06 Jul 2022 03:53:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1864</guid>
          <source url="https://forum.rebol.info/t/should-arity-2-into-in-uparse-actually-just-be-parse/1864.rss">Should &quot;Arity-2 INTO&quot; in UPARSE actually just be... PARSE?</source>
        </item>
        <item>
          <title>Parsing Alternates: Should &quot;Must Match To End&quot; Be Considered?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>I didn't quite absorb that the following was the case in all PARSEs we know of:</p>
<pre><code> &gt;&gt; parse [a b] [word! word!]
 == truthy

 &gt;&gt; parse [a b] [word!]
 == falsey

 &gt;&gt; parse [a b] [word! | word! word!]
 == falsey
</code></pre>
<h2>Distinctly Self-Aware "Terminal Blocks", Could They Be Good?</h2>
<pre><code>&gt;&gt; uparse [a b] [word! | word! word!]
== b
</code></pre>
<p>I'd argue that there already are "two types of blocks":</p>
<ol>
<li>
<p>There are blocks that give a truthy result when they don't reach the end, but don't have any match failures</p>
</li>
<li>
<p>There are blocks that can succeed on every match but not reach the end, but be an overall failure</p>
</li>
</ol>
<p>Right now we know these blocks by context.  The main rule block you give to PARSE is of type 2, and so is the block given to an INTO.</p>
<p>It's a very small semantic difference to say that "they're the same kind of block, with the decisions about them being made by their caller".  Why not allow them to be different kinds of blocks?</p>
<h2>It Would Be Weird If It Propagated</h2>
<p>Here's an example of the kind of weirdness you'd get into if we said it wasn't a property <em>strictly</em> of the root blocks, but rather "any block that found itself at the end of a chain":</p>
<pre><code>&gt;&gt; parse [] [[(print "A") | (print "B")] [(print "C") | (print "D")]]
A
C
D
</code></pre>
<p>Being a "category 2 block", we see how the outer rule block would be creating some irritating asymmetry by saying that any block that knew it wasn't going to reach the end got the privilege.</p>
<p>So I definitely don't like that.</p>
<p><strong>But I'm suggesting a sticky property of blocks, that they effectively already had, being allowed to influence one thing besides whether they are forced to reach the end to succeed... that those blocks also get to try all their alternates before saying they failed.</strong></p>
<p>It's like because they're under more pressure they are given a resource to fall back on to succeed <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<h2>Looking for Reasons Why It Would Break</h2>
<p>It definitely benefits <a href="https://forum.rebol.info/t/the-circled-dialect-example-of-the-form/1849">cases like how I was writing CIRCLED</a>, and now that I think about it I've certainly encountered others.</p>
<p>It does break a kind of universality of understanding, like:</p>
<pre><code>rule: [word! | word! word! (print "breaks faith this can never print")]
</code></pre>
<p>Yet the understandings in the PARSE world are a little fuzzy.  You might say the existing paradigms break the understanding that if that rule came across [a b] as input that it would succeed.  It won't if it's an outermost block...</p>
<p>The new understanding would be <em>"Common subsequences in your rule may wind up being matched alternately in top-level parse contexts."</em>  If you don't want it, you have an out...double up your block!</p>
<pre><code>rule: [[word! | word! word! (print "breaks faith this can never print")]]
</code></pre>
<p>Now your rule won't be subject to the toplevel alternates exception...if you can think of a really good reason why you wouldn't want it.</p>
<h2>But, UPARSE is Configurable, So Why Worry Too Much?</h2>
<p>I might like it, and other people might not.  So we'll see.</p>
<p>I think I'm at least going to try it out, because it looks like it serves common tasks.  I'll get some more data and report back.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/parsing-alternates-should-must-match-to-end-be-considered/1850">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/parsing-alternates-should-must-match-to-end-be-considered/1850</link>
          <pubDate>Sun, 26 Jun 2022 12:46:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1850</guid>
          <source url="https://forum.rebol.info/t/parsing-alternates-should-must-match-to-end-be-considered/1850.rss">Parsing Alternates: Should &quot;Must Match To End&quot; Be Considered?</source>
        </item>
        <item>
          <title>Contemplating PARSE-VALUE: Super-Powered Branching</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Since PARSE is at heart a matching task, it seems there might be more accommodation when the input value is not a block... and you want to do some top level pattern matching.  Consider something like this:</p>
<pre><code>case [
     integer? item [
         print "Not a series, so, have to write handling code here"
     ]
     text? item [
         print "A series, but maybe we want to do something else"
     ]
     block? item [
         print "Okay finally we can use the parse we mean..."
         uparse item [...rules...]
     ]
] else [
   fail "Whatever"
]
</code></pre>
<p>When I see this I start thinking along these lines:</p>
<pre><code>parse reduce [item] [
     integer! (print "More convenient, perhaps...")
         |
     text! (print "Depends on the use case...")
         |
     subparse block! [
        (print "Your rules here I guess...")
     ]
]  ; raises definitional error on no match, handle w/EXCEPT etc. if needed
</code></pre>
<p>Now imagine that being something like <strong>PARSE-VALUE</strong> instead of <strong>PARSE REDUCE [ITEM]</strong>...but with additional cleverness.</p>
<p>One aspect of being better would be that if your input was calculated, you could still call it up with <code>&lt;input&gt;</code> ... although that wouldn't be available to the code in groups automatically:</p>
<pre><code>&gt;&gt; parse-value 1 + 2 [integer! (print "int") | text! (print "text") || &lt;input&gt;]
int
== 3

&gt;&gt; parse-value "foo" [integer! (print "int") | text! (print "text") || &lt;input&gt;]
text
== "foo"
</code></pre>
<p>But you're no worse off than in a switch statement that doesn't have calculated input captured under a name.  (Slightly better, in fact, since you have a means of calling up the calculated input.)</p>
<p>It's just a thought, because I've seen this pattern several times: "I have a decision tree but I can't start doing parsing until I have a series".  This is just an idea about stretching all the matching and extraction logic that is going to be needed in PARSE anyway to apply to single values.</p>
<h2>
<a name="parse-value-or-parsevalue-1" class="anchor" href="https://forum.rebol.info#parse-value-or-parsevalue-1"></a>PARSE-VALUE or PARSE/VALUE</h2>
<p>This strongly parallels the LOAD-VALUE vs. LOAD issue.  It seemed to make more sense in that case to separate it out so LOAD was fully generic and unconcerned with the /VALUE aspect.  This might or might not have the same rationale as to why PARSE shouldn't internally be concerned with the behavior.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/contemplating-parse-value-super-powered-branching/1822">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/contemplating-parse-value-super-powered-branching/1822</link>
          <pubDate>Tue, 17 May 2022 08:43:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1822</guid>
          <source url="https://forum.rebol.info/t/contemplating-parse-value-super-powered-branching/1822.rss">Contemplating PARSE-VALUE: Super-Powered Branching</source>
        </item>
        <item>
          <title>What Should BLANK! in UPARSE Do?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>It's always good to look at history first.  So let's compare and contrast #[none] vs. empty block in old Redbols.</p>
<p><strong>In Rebol2 and R3-Alpha, both are no-ops.</strong>  The input type doesn't matter.</p>
<pre><code>r2/r3&gt;&gt; parse {ab} [[] "a" [] "b" []]
== true

r2/r3&gt;&gt; parse {ab} [#[none] "a" #[none] "b" #[none]]
== true

r2/r3&gt;&gt; parse [a b] [[] 'a [] 'b []]
== true

r2/r3&gt;&gt; parse [a b] [#[none] 'a #[none] 'b #[none]]
== true
</code></pre>
<p><strong>In Red, #[none]s are expected to be literal.</strong>  However, you don't get an error on string inputs...just a failure.</p>
<pre><code>red&gt;&gt; parse {ab} [[] "a" [] "b" []]
== true

red&gt;&gt; parse {ab} [#[none] "a" #[none] "b" #[none]]
== false

red&gt;&gt; parse [a b] [[] 'a [] 'b []]
== true

red&gt;&gt; parse [a b] [#[none] 'a #[none] 'b #[none]]
== false

red&gt;&gt; parse [#[none] a #[none] b #[none]] [#[none] 'a #[none] 'b #[none]]
== true</code></pre>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/what-should-blank-in-uparse-do/1821">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-should-blank-in-uparse-do/1821</link>
          <pubDate>Sun, 15 May 2022 22:35:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1821</guid>
          <source url="https://forum.rebol.info/t/what-should-blank-in-uparse-do/1821.rss">What Should BLANK! in UPARSE Do?</source>
        </item>
        <item>
          <title>The Cool New Repurposing of WHILE in PARSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Historical Redbol PARSE had some cognitive dissonance over its "looping constructs".</p>
<p>One weird point was that WHILE was an arity-1 construct...a peculiar variant of a "looping ANY" which dropped the requirement of a need to make progress.  <img src="https://forum.rebol.info/images/emoji/twitter/confused.png?v=9" title=":confused:" class="emoji" alt=":confused:"></p>
<p>Just as <a href="https://forum.rebol.info/t/the-cool-new-repurposing-of-any-in-parse/1662">ANY could be improved</a> by making it do something more "obvious", I think the obvious solution for WHILE is also the better one:</p>
<h2>So now, default PARSE has WHILE <em>and it's arity-2</em> !</h2>
<p>These two things are synonyms:</p>
<pre><code> while rule1 rule2   &lt;=&gt;  opt some [rule1 rule2]
</code></pre>
<p><strong>One very common application is <code>WHILE [NOT &lt;END&gt;] [...]</code></strong></p>
<p>This is such a clear case it's bizarre that no one seemed to go to bat for it before.</p>
<p><strong>It would make it cleaner to pair up code in a GROUP! with a rule:</strong></p>
<p>GROUP! rules always run their side effect and succeed.  So:</p>
<pre><code>opt some [rule (code to run on each match)]
</code></pre>
<p>Could instead be written as:</p>
<pre><code>while rule (code to run on each match)
</code></pre>
<p>I would use this frequently!</p>
<p><strong>It helps pscyhologically divide a process into two parts: trigger and response</strong></p>
<p>You can of course write things as:</p>
<pre><code>opt some [
     thing1 thing2 [
        thing3 thing4
     |  thing5 thing6
     ]
]
</code></pre>
<p>Or:</p>
<pre><code>opt some [thing1 thing2 [
    thing3 thing4
        |
   thing5 thing6
]]
</code></pre>
<p>But I think the WHILE structuring into a control half and response half helps you see this better:</p>
<pre><code>while [thing1 thing2] [
    thing3 thing4
        |
    thing5 thing6
]</code></pre>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/the-cool-new-repurposing-of-while-in-parse/1875">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-cool-new-repurposing-of-while-in-parse/1875</link>
          <pubDate>Sat, 14 May 2022 23:34:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1875</guid>
          <source url="https://forum.rebol.info/t/the-cool-new-repurposing-of-while-in-parse/1875.rss">The Cool New Repurposing of WHILE in PARSE</source>
        </item>
        <item>
          <title>Old Parse Tutorial</title>
          <dc:creator><![CDATA[Brett]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <blockquote>
<p>This is an old tutorial which originally appeared on <a href="http://codeconscious.com">codeconscious.com</a>. It has been posted here in the expectation that <a href="http://codeconscious.com">codeconscious.com</a> will be decommissioned early 2022. Other old articles on REBOL can be found at <a href="https://web.archive.org/web/*/https://codeconscious.com/rebol/">REBOL by codeconscious.com on archive.org</a></p>
</blockquote>
<h1><a name="p-5682-introduction-1" class="anchor" href="https://forum.rebol.info#p-5682-introduction-1"></a>Introduction</h1>
<blockquote>
<p>Note: This article is a revised version written for open sourced Rebol (Rebol 3), the original Rebol 2 version is here: <a href="https://codeconscious.com/rebol/parse-tutorial.html">Parse Tutorial for Rebol 2</a>.</p>
</blockquote>
<p>If you want to extract data from strings (like HTML, TXT, CSV, etc.) consider Parse.</p>
<p>If you want to just check some user data against a specific format consider using Parse.</p>
<p>If you want to validate some message written in your new dialect use Parse.</p>
<p>Parse is useful.</p>
<p>Parse is quick.</p>
<p>Parse operates on string, binary and block input.  Using Parse you can process these types of input in some way, overlaying the input with new meaning. That is you have a string or block and you are perhaps identifying fields of records, tokens of a language or even identifying sections of a message protocol.</p>
<p>This document is a very rough show by example description of Parse with a few warnings thrown in.</p>
<h1><a name="p-5682-parse-dialect-2" class="anchor" href="https://forum.rebol.info#p-5682-parse-dialect-2"></a>Parse Dialect</h1>
<p>You give Parse a rule block containing instructions to follow written in the Parse dialect. These instructions allow you to utilise Parse to interpret custom external formats or protocols. These instructions can be as simple or as complex as you need. A simple example would be to check that some input against postal code format. A sophisticated example is Rebol's URL parser (help sys/*parse-url/rules).</p>
<p>The instructions are written using the Parse dialect and tell Parse how to read through your input. In actual fact, the instructions describe the patterns that the input should take. Parse attempts to match the input against your patterns. Parse will return a TRUE result if your instructions accurately describe the input. If your instructions fail to describe the input (or looking at it the other way, the input fails to follow your rules) Parse will return FALSE. You also have the ability to carry out normal Rebol operations as Parse traverses the input and your rules.</p>
<p>It is very important to realise that the keywords of the Parse dialect are interpreted by Parse in a specific way and should be considered as being different in meaning to Rebol words when used at the console.</p>
<h2><a name="p-5682-lets-start-at-the-end-3" class="anchor" href="https://forum.rebol.info#p-5682-lets-start-at-the-end-3"></a>Let's start at the end</h2>
<pre><code>&gt;&gt; input-string: {}
&gt;&gt; parse input-string [end]
== true
</code></pre>
<p>Ah success! Here I am parsing an empty string. My rule says to Parse "check that we are at the end". The result is of course TRUE because the string was empty to begin with.</p>
<p>This is similar in normal Rebol script to:</p>
<pre><code>&gt;&gt; tail? input-string
== true
</code></pre>
<h2><a name="p-5682-baby-steps-4" class="anchor" href="https://forum.rebol.info#p-5682-baby-steps-4"></a>Baby steps</h2>
<p>Next up, let's test that a string matches our expectations:</p>
<pre><code>&gt;&gt; input-string: "fox"
== "fox"
&gt;&gt; parse input-string ["fox" end]
== true
</code></pre>
<p>We successfully tested that the input started with "fox" and then finished. Ok, no big deal.</p>
<p>But reflect a moment. This is a sequence - first "fox" then END. As Parse traverses the input</p>
<p>and your rule block, it keeps track of a current position for both. So at the start, the current position in the input is at the head of the string. After the rule "fox" was matched the current position in the input string will be directly after the "x" of "fox".</p>
<p>In this example, this happens to be the tail of the string, so the very next match rule END will succeed.</p>
<p>We do not always have to supply an END in the rule block. You can omit it in the last example because Parse effectively slaps one on at the end anyway.</p>
<pre><code>&gt;&gt; parse input-string ["fox"]
== true
</code></pre>
<p>While you can do this for simple examples, remember you'll likely need to add it in</p>
<p>explicitly for more complex rules.</p>
<p>Ok, back to the example again. In an ordinary Rebol session the above example is similar to the following:</p>
<pre><code>&gt;&gt; input-string: find/match input-string "fox"
== ""
&gt;&gt; tail? input-string
== true
</code></pre>
<p>Note that the ordinary Rebol code examples through this article are provided to help learn Parse. There are enough important differences between the Parse examples and the ordinary code examples that you cannot alway treat them as exactly equivalent.</p>
<h2><a name="p-5682-failures-challenges-5" class="anchor" href="https://forum.rebol.info#p-5682-failures-challenges-5"></a>Failures / challenges</h2>
<p>For contrast let's look at an unsuccessful match:</p>
<pre><code>&gt;&gt; input-string: "dog"
== "dog"
&gt;&gt; parse input-string ["fox"]
== false
</code></pre>
<p>The meaning of this is pretty obvious. Hang on though, what actually happens when Parse encounters a failure with one of the rules? Well it backtracks the input to the point it was at when the rule started. So in Rebol code what happens is actually more like this:</p>
<pre><code>input-string: "dog"
If position: Find/match input-string "fox" [input-string: position]
Tail? input-string
</code></pre>
<p>Keep this little idea in the back of your mind, it becomes more meaningful with more complex rules.</p>
<h2><a name="p-5682-optional-matching-and-compound-rules-6" class="anchor" href="https://forum.rebol.info#p-5682-optional-matching-and-compound-rules-6"></a>Optional matching and Compound Rules</h2>
<p>What if we want to check for a number of common pet alternatives?</p>
<p>Let's accept a "dog" or a "cat" or indeed a "bird":</p>
<pre><code>&gt;&gt; input-string: "dog"
== "dog"
&gt;&gt; parse input-string ["dog" | "cat" | "bird"]
== true
</code></pre>
<p>In ordinary Rebol this is like coding:</p>
<pre><code>input-string: any [
    find/match input-string "dog"
    find/match input-string "cat"
    find/match input-string "bird"
]
tail? input-string
</code></pre>
<p>Now, Rebol can be pretty concise and the ANY function definitely helps in writing concise code, but you can see already that the Parse dialect is looking to be better suited to matching than ordinary scripting.</p>
<p>Reflecting on this a bit. We have here a more interesting rule, a compound rule. Our compound rule is composed of three subrules. Each of the three subrules here are very basic but subrules are allowed to be compound rules themselves. The basic rules perform the lowest level matching of the input, the compound rules check the overall structure/grammar of your data.</p>
<p>Back to options. What about something that may or may not exist at all? Using OPT we can indicate that a bird could be big or just leave it out:</p>
<pre><code>&gt;&gt;  input-string: "bigbird"
== "bigbird"
&gt;&gt;  parse input-string [opt "big" "bird"]
== true
&gt;&gt; input-string: "bird"
== "bird"
&gt;&gt; parse input-string [opt "big" "bird"]
== true
</code></pre>
<p>There are more Parse options such as NOT which give you greater flexibility in specifying your rules. We'll cover this later.</p>
<h2><a name="p-5682-spaces-and-split-7" class="anchor" href="https://forum.rebol.info#p-5682-spaces-and-split-7"></a>Spaces and Split</h2>
<p>Parse treats spaces like any other character. Note that Rebol 3 acts differently here to Rebol 2 as whitespace is now parsed by default without needing the /ALL refinement</p>
<pre><code>&gt;&gt;  input-string: "black dog"
== "black dog"
&gt;&gt;  parse input-string ["black" " " "dog"]
== true
</code></pre>
<p>There are constants defined for common characters such as SPACE, NEWLINE and TAB which can be used instead.</p>
<pre><code>&gt;&gt;  parse input-string ["black" space "dog"]
== true
</code></pre>
<p>To make things easier we can use the SPLIT function to pre-process the input string. SPLIT breaks up the string based on a given delimeter or other rules.</p>
<pre><code>&gt;&gt; parse split "brown dog" " " ["brown" "dog"]
== true
</code></pre>
<p>If we look at the output of split we see the following.</p>
<pre><code>&gt;&gt; split "brown dog" " "
== [ "brown" "dog" ]
</code></pre>
<p>In this case split is returning a block of strings simplifying our work with Parse.</p>
<h1><a name="p-5682-blocks-repetition-and-more-8" class="anchor" href="https://forum.rebol.info#p-5682-blocks-repetition-and-more-8"></a>Blocks, repetition and more</h1>
<p>Using Parse for strings is good, but using parse on native Rebol datatypes really shows its power.</p>
<p>Rebol has a rich set of datatypes which simplify parsing data, and code.</p>
<p>This mode is used when the value to be parsed is actually a block not a string. You use this mode when you have already loaded data into Rebol values. You write Parse instructions in a rule block using the parse dialect in a similar way to that described for parsing strings except when parsing blocks the semantics are different and you have a couple more keywords to use.</p>
<p>This is the mode of Parse that deserves the attention of anyone using Rebol. The reason is that you are free to store your data in a form understandable by yourself and others and yet is still computer readable.</p>
<h2><a name="p-5682-first-steps-parsing-blocks-9" class="anchor" href="https://forum.rebol.info#p-5682-first-steps-parsing-blocks-9"></a>First steps parsing blocks</h2>
<p>As we move from strings to blocks we can start to use some of the Rebol datatypes to make our lives much easier.</p>
<pre><code>&gt;&gt; parse [1234.16] [number!]
== true
</code></pre>
<p>Processing dates and times are a good example. You can see how the datatypes support a wide range of input formats. It is worth noting for Americans that Rebol always assumes day/month/year order.</p>
<pre><code>&gt;&gt; parse [12/Dec/2012 2:30pm ] [date! time!]
== true
</code></pre>
<p>There are many more datatypes although that does not stop you from using strings for datatypes which do not map to Rebol types.</p>
<pre><code>&gt;&gt; parse [&lt;div&gt; "Hello" http://rebol.com $1.00 &lt;/div&gt; bob@test.com ] [ tag! "Hello" url! money! tag! email!]
== true
</code></pre>
<h2><a name="p-5682-repetition-known-range-of-occurrences-10" class="anchor" href="https://forum.rebol.info#p-5682-repetition-known-range-of-occurrences-10"></a>Repetition - known range of occurrences</h2>
<p>Time for some more compound rules.</p>
<p>Here's how to check for exactly two dogs.</p>
<pre><code>&gt;&gt; parse "dogdog" [2 "dog"]
== true
</code></pre>
<p>I can specify between 1 and 4 Zs (inclusive) too:</p>
<pre><code>&gt;&gt;  parse "Zzzz" [1 4 "z"]
== true
</code></pre>
<p>Note that by default Parse is not case sensitive unless you want it to be by using the /CASE refinement:</p>
<pre><code>&gt;&gt; parse/case "ZZ" [2 "Z"]
== true
</code></pre>
<p>This is also very powerful for parsing blocks:</p>
<pre><code>&gt;&gt; parse [ http://rebolsource.net http://rebol.org http://rebol.com ] [ 3 url! ]
== true
</code></pre>
<h2><a name="p-5682-repetition-again-unknown-number-of-occurrences-11" class="anchor" href="https://forum.rebol.info#p-5682-repetition-again-unknown-number-of-occurrences-11"></a>Repetition again <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"> - unknown number of occurrences</h2>
<p>What if we grab a net and go prawning? We may not know how many prawns are caught by the net when we catch them:</p>
<pre><code>&gt;&gt; loop random 100 [append input-string: "" "prawn"]
== "prawnprawnprawnprawn"
&gt;&gt; parse input-string [some "prawn"]
== true
</code></pre>
<p>Excellent, we have some prawns but we don't know how many.</p>
<p>The SOME keyword means "match one or more of the following". Again it is a compound rule because I could have as easily done this if it was "raining cats and dogs":</p>
<pre><code>&gt;&gt; input-string: "dogdogcatdogcat"
== "dogdogcatdogcat"
&gt;&gt; parse input-string [some [ "dog" | "cat"] ]
== true
</code></pre>
<p>If it fines up:</p>
<pre><code>&gt;&gt; input-string: {}
== ""
&gt;&gt; parse input-string [some [ "dog" | "cat"]  ]
== false
</code></pre>
<p>It returns false because SOME requires at least one instance to be matched. If however, we don't actually care whether we get some or not we can use ANY:</p>
<pre><code>&gt;&gt; input-string: {}
== ""
&gt;&gt; parse input-string [any [ "dog" | "cat" ] ]
== true
&gt;&gt; input-string: "dog"
== "dog"
&gt;&gt; parse input-string [any [ "dog" | "cat"] ]
== true
</code></pre>
<p>Here is another example of one of those Rebol words with a new meaning in the context of Parse. In ordinary Rebol ANY is a function that return the first non-false or non-none value in the block it is given. In Parse, by contrast, ANY is a keyword that introduces a compound rule that means, "match zero or more of the following".</p>
<p>Repetition works equally well for blocks:</p>
<pre><code>&gt;&gt; parse [Fibonacci 1 1 2 3 5 8 13] [some [number! | word!] ]
== true
</code></pre>
<h2><a name="p-5682-moving-right-along-12" class="anchor" href="https://forum.rebol.info#p-5682-moving-right-along-12"></a>Moving right along...</h2>
<p>Sometimes we really couldn't care less what lies between things of interest.</p>
<p>This example does not "skip c" it reads "match a, skip a character, match c, tail?".</p>
<pre><code>&gt;&gt; parse {abc} ["a" skip "c" end]
== true
</code></pre>
<p>You want to skip 5 characters? Use repetition:</p>
<pre><code>&gt;&gt; parse {1234567890} ["123" 5 skip "90" end]
== true
</code></pre>
<p>Sometimes we don't know how much is in between but we do know what is the next interesting bit:</p>
<pre><code>&gt;&gt; input-string: {1234 fox}
== "1234 fox"
&gt;&gt; parse input-string [thru "fox" end]
== true
</code></pre>
<p>This is like the Rebol code of:</p>
<pre><code>&gt;&gt; input-string: find/tail input-string "fox"
== ""
&gt;&gt; tail? input-string
== true
</code></pre>
<p>We can stop where fox starts using TO:</p>
<pre><code>&gt;&gt;  input-string: "1234 fox"
== "1234 fox"
&gt;&gt;  parse input-string [to "fox" "fox" end]
== true
</code></pre>
<p>And the Rebol code that performs similarly:</p>
<pre><code>input-string: {1234 fox}
input-string: find input-string "fox"
input-string: find/match input-string "fox"
tail? input-string
</code></pre>
<p>We can skip to the end as well:</p>
<pre><code>&gt;&gt;  parse {123456} ["123" to end end]
== true
</code></pre>
<p>This says "match 123, move to the tail, test tail". Pretty obvious we would get a true result if you think of it in these terms.</p>
<p>While we're here how about a warning. The rule [to end] moves to the tail and reports</p>
<p>success every time.</p>
<h2><a name="p-5682-all-these-characters-13" class="anchor" href="https://forum.rebol.info#p-5682-all-these-characters-13"></a>All these characters</h2>
<p>Charset. Stands for character set. It is a bitset which makes it fast for pattern matching operations.</p>
<p>Let's say you only want to check that your input contains the digits 0 to 9.</p>
<pre><code>&gt;&gt; digit: charset [#"0" - #"9"]
</code></pre>
<p>Now parse can use this directly as a pattern matching instruction. It will match one character (byte) only of those in the set 0 - 9.</p>
<pre><code>&gt;&gt; parse {1} [digit]
== true
</code></pre>
<p>Naturally enough you can use these in compound rules too:</p>
<p>An Australian postcode consists of 4 numeric digits so:</p>
<pre><code>&gt;&gt; parse {2069} [4 digit]
== true
</code></pre>
<p>Charsets (bitsets) are sets and you can apply the set operations union, intersection, exclude, etc</p>
<p>on them:</p>
<pre><code>letter: charset [#"a" - #"z" #"A" - #"Z"]
digit: charset [#"0" - #"9"]
letter-or-digit: union letter digit
valid-name: [letter any letter-or-digit]
&gt;&gt;  parse {1abc} valid-name
== false
&gt;&gt;  parse {rebol} valid-name
== true
&gt;&gt;  parse {xyz1234} valid-name
== true
</code></pre>
<p>Maybe you want everything but digits:</p>
<pre><code>&gt;&gt; parse {A} [not digit skip]
== true
</code></pre>
<p>Notice how we needed to SKIP forward as NOT simply inverses the following rule and does not advance the input.</p>
<p>This is different from the Rebol 2 approach of creating a COMPLEMENT of a charset. This may work in some situations, but will not always give you the desired result due to the use of UNICODE in Rebol 3.</p>
<h2><a name="p-5682-but-i-want-some-information-from-it-14" class="anchor" href="https://forum.rebol.info#p-5682-but-i-want-some-information-from-it-14"></a>But I want some information from it!</h2>
<p>Up to this point I've concentrated on the various matching functionality of Parse. Of course though you want to extract information from your data. The keyword of note for this purpose is COPY. Also of use is the ability to execute Rebol code within the Parse rules (actions) and thereby set and maintain Rebol variables (eg. Counters) using that code.</p>
<p>Ok COPY.</p>
<p>Copy is really really simple really. It is a compound rule that takes two arguments a variable and a subrule. Whatever input the subrule matches gets copied into the variable. If the subrule doesn't match anything (fails) COPY returns the failure but leaves the variable unchanged.</p>
<p>Here the subrule is to match an "A" which obviously fails.</p>
<pre><code>&gt;&gt; parse {123} [copy some-text "A"]
== false
&gt;&gt; some-text
** Script error: some-text has no value
</code></pre>
<p>Here the subrule is a simple skip:</p>
<pre><code>&gt;&gt; parse {123} [copy some-text skip to end]
== true
&gt;&gt; some-text
== "1"
</code></pre>
<p>And here the subrule is to match nothing NONE which is always successful so copy copies that which was matched...an empty string:</p>
<pre><code>&gt;&gt; parse "123" [copy some-text none]
== false
&gt;&gt; some-text
== ""
</code></pre>
<p>Another way of getting data is by using SET:</p>
<pre><code>&gt;&gt; parse [ $100 ] [ set wallet money! ]
== true
&gt;&gt; wallet
== $100
</code></pre>
<h2><a name="p-5682-bring-on-the-code-actions-15" class="anchor" href="https://forum.rebol.info#p-5682-bring-on-the-code-actions-15"></a>Bring on the code (actions)</h2>
<p>Ordinary Rebol code can be used inside the parse dialect via the use of "(" and ")" i.e. a Paren! series:</p>
<pre><code>&gt;&gt; parse {} [(print "some code just executed") end]
some code just executed
== true
</code></pre>
<p>Obviously this is very handy. Even nicer is that it runs according to its placement in the rule. Note though that even if the rule ultimately fails your code may have already run:</p>
<pre><code>&gt;&gt; parse {123} [
     "1" (print "found 1!")
     "2" (print "found 2!")
     "A" (print "found an A!")
    end
]
found 1!
found 2!
== false
</code></pre>
<p>So the upshot is you can maintain counters and take actions based on your Parse rules.</p>
<p>During development it can be useful to put print statements in these allowing you to see what is happening.</p>

<h1><a name="p-5682-advanced-section-16" class="anchor" href="https://forum.rebol.info#p-5682-advanced-section-16"></a>Advanced section</h1>
<h2><a name="p-5682-repeated-repetition-17" class="anchor" href="https://forum.rebol.info#p-5682-repeated-repetition-17"></a>Repeated Repetition</h2>
<p>Now that I've introduced repetition and compound rules, what happens if I create a compound rule made up of nested repetition rules? Hmm, tricky.</p>
<p>This next example put Parse into a spin - an infinite loop. The escape key will not work, but you can break out with Ctrl+c:</p>
<pre><code>&gt;&gt; input-string: {}
== {}
&gt;&gt; parse input-string [while [any "dog"] ]
</code></pre>

<p>To understand why this infinite loop happens you need to know when the ANY rule returns success and when it completes.</p>
<p>Here's the major answer: WHILE ALWAYS returns success.</p>
<p>WHILE will keep calling its subrule while that subrule returns success regardless of if the input position advances. WHILE gives up on receipt of bad news (failure) but it itself always returns success. Now if WHILE always receives a success because it's subrule in fact is another WHILE or ANY... Well I think that explains it.</p>
<p>Remember OPT. It always returns success just like WHILE. So putting an OPT inside an WHILE is bound to lead to trouble as well.</p>
<p>The point then is that your repetition compound rules must be carefully written because of the possibility of creating these infinite loops. It is not a bug in Rebol, it is consequence of having a flexible Parse dialect.</p>
<p>Sometimes these infinite loops start only after traversing lots of other complex rules and therefore can become hard to catch. I create these loops less often now since I started considering how I want Parse's input position to move. When writing your rules consider how the input is consumed by the rules.</p>
<p>That's part of the reason why I've been demonstrating the Rebol code similar to the various Parse examples.</p>
<p>Not all combinations of repetition rules create infinite loops:</p>
<pre><code>&gt;&gt;  input-string: {}
== ""
&gt;&gt;  parse input-string [while [some "dog"] ]
== true
</code></pre>
<p>This last example is ok because the SOME does not always return success - it must consume some input. If SOME does not have at least one success it</p>
<p>returns a failure result. So you can see that at some point, given that we can assume that the input is</p>
<p>finite, the overall rule must terminate.</p>
<p>Quoting Ladislav, "The dangerous rules are rules, that don't consume any input, yet they return success."</p>
<p>There is another way to escape when you don't want your rule to progress further - the BREAK keyword. BREAK terminates the rule when it is encountered.</p>
<p>This could be used to improve performance by stopping evaluation of unnecessary rules.</p>
<pre><code>&gt;&gt; parse [1 2 end 3 4 5 7 8 9] [some [integer! | 'end break]]
== false
</code></pre>
<p>This rule will exist as soon as it reaches the end keyword improving the performance.</p>
<h2><a name="p-5682-debugging-parse-rules-18" class="anchor" href="https://forum.rebol.info#p-5682-debugging-parse-rules-18"></a>Debugging parse rules</h2>
<p>The ?? command is invaluable in debugging Parse rules.</p>
<pre><code>&gt;&gt; parse "dog" [ ?? "d" ?? [ "i" | "o" ] ?? "g" ?? ]
"d": "dog"
["i" | "o"]: "og"
"g": "g"
end!: ""
== true
</code></pre>
<p>It displays the next rule and the current position in the series being parsed.</p>
<h2><a name="p-5682-the-current-index-and-manipulating-it-19" class="anchor" href="https://forum.rebol.info#p-5682-the-current-index-and-manipulating-it-19"></a>The current index and manipulating it</h2>
<p>Parse maintains a reference to the input. The reference is a series and so has a current index.</p>
<p>Some special Parse dialect syntax allows you to get and set this reference. You use a set-word and get-word syntax respectively.</p>
<p>In this example I set the word "mark" to the input series at the current index that Parse has, don't worry about the false - it is just saying we didn't get all the way through the input:</p>
<pre><code>&gt;&gt;  parse {123456} ["123" mark:]
== false
&gt;&gt; mark
== "456"
</code></pre>
<p>I can manipulate the current index that Parse uses too:</p>
<pre><code>&gt;&gt;  parse {1234567} ["123" mark: (mark: next next mark) :mark "67"]
== true
</code></pre>
<p>To explain. First "123" is matched, then the word mark is set to the reference.</p>
<p>Then the Rebol code between the parentheses is evaluated. This code manipulates the reference we hold by two characters. I return this modified reference to Parse using the get-word syntax. Parse seeing the get-word syntax knows that it must update it's reference to that given. Finally I match the "67".</p>
<h2><a name="p-5682-more-block-examples-20" class="anchor" href="https://forum.rebol.info#p-5682-more-block-examples-20"></a>More Block examples ...</h2>

<p>An example that shows what can be achieved is Carl Sassenrath's stock transaction example which you can see below. Now what if "sell 300 shares at $89.08" came in via email?</p>
<p>If you study this example you will see that Carl, in a very small space, has created a small interpreter that parses, validates and performs computations. This is very powerful technology that is easily underestimated because it is so small and simple.</p>
<pre><code>rule: [
    set action ['buy | 'sell]
    set number integer!
    'shares 'at
    set price money!
    (either action = 'sell [
            print ["income" price * number]
            total: total + (price * number)
        ] [
            print ["cost" price * number]
            total: total - (price * number)
        ]
    )
]
total: 0
parse [sell 100 shares at $123.45] rule
print ["total:" total]
total: 0
parse [
    sell 300 shares at $89.08
    buy 100 shares at $120.45
    sell 400 shares at $270.89
] [some rule]
print ["total:" total]
</code></pre>
<p>Another powerful example of this is the VID dialect of Rebol/View 2. VID describes in a<br>
effective but simple way what should appear on screen. VID is actually a block using normal<br>
Rebol values such as words and strings. The LAYOUT function of Rebol/View 2 takes a VID<br>
block as an argument to construct the visual objects. Layout uses Parse to process the<br>
VID specification.</p>
<h1><a name="p-5682-special-situations-21" class="anchor" href="https://forum.rebol.info#p-5682-special-situations-21"></a>Special situations</h1>
<h2><a name="p-5682-when-you-do-not-want-to-match-a-pattern-22" class="anchor" href="https://forum.rebol.info#p-5682-when-you-do-not-want-to-match-a-pattern-22"></a>When you do NOT want to match a pattern</h2>

<p>NOT does not consume input, so you can use it one ore more times before matching something else:</p>
<pre><code>&gt;&gt; parse "bird" [not "big" "bird"]
== true
</code></pre>
<p>One situation where you might do this is when you have a sub rule that might "consume" something needed by an enclosing rule.</p>
<p>For my example, I'll Parse a block rather than text but the concept still applies.</p>
<p>I want to Parse the following block, and print out every word, but if I encounter a bar ("|") I'll print out the text "**********":</p>
<pre><code>my-block: [ the quick brown fox | jumped | over the lazy]
</code></pre>
<p>This next bit of code will not work. If you try it you will see that no "*" is printed, instead you will see the "|":</p>
<pre><code>single-word: [set item word! (print mold item)]
phrase: [some single-word]
parse my-block [ phrase some ['| (print "**********") phrase] ]
</code></pre>
<p>The thing to note is that the bar "|" is a word too. Therefore the bar is "consumed" by the rule called SINGLE-WORD.</p>
<p>So one way to solve this is to give SINGLE-WORD some indigestion (make it fail) when it encounters a bar.</p>
<p>You can force a rule to fail using the FAIL keyword but here we use AND and NOT to make the rule fail under a specific condition.</p>
<p>To make it clear what is happening here, I wrap SINGLE-WORD with a rule I call WORD-EXCEPT-BAR. The</p>
<p>purpose of this new rule is to fail if it finds the "|" word otherwise it goes ahead and runs SINGLE-WORD.</p>
<p>I've added comments to clarify how WORD-EXCEPT-BAR works:</p>
<pre><code>word-except-bar: [
    and not '| ; Without advancing the input position, is this not a bar?
    single-word ; Match single-word
]
</code></pre>
<p>The point to note here is that the rule AND NOT '| is a "guard" - it guards the next rule from consuming input under a specific condition.</p>
<p>I also need to modify PHRASE to call WORD-EXCEPT-BAR.</p>
<pre><code>phrase: [some word-except-bar]
</code></pre>
<p>Another way to describe the PHRASE rule, as it is now, is "a rule that matches a series of words which does not contain the word |."</p>
<p>To finish off I'll create a function to call parse with the correct rule and</p>
<p>wrap the whole lot in an object just to be tidy:</p>
<pre><code>word-parsing-object: context [
    single-word: [set item word! (print mold item)]
    word-except-bar: [and not '| single-word]
    phrase: [some word-except-bar]
    set 'parse-words func[ a-block [block!] ] [
        parse a-block [phrase some ['| (print "**********") phrase] ]
    ]
]
</code></pre>
<p>Here is a test run:</p>
<pre><code>&gt;&gt; parse-words [the quick brown fox | jumped | over the lazy]
the
quick
brown
fox
**********
jumped
**********
over
the
lazy
== true
</code></pre>
<p>In summary in this section I have demonstrated how one can match a specific pattern even when a more general pattern (that includes the specific pattern) gets to see the input first.</p>
<h2><a name="p-5682-why-didnt-you-just-write-23" class="anchor" href="https://forum.rebol.info#p-5682-why-didnt-you-just-write-23"></a>Why didn't you just write...</h2>
<pre><code>parse-words: func [a-block [block!]] [
    parse a-block [
        some [
            '| (print "**********") |
            set item word! (print mold item)
        ]
    ]
]
</code></pre>
<p>That is the better way to solve the problem, but the point is to demonstrate the concept of preventing a subrule from consuming certain input and how to use AND as a guard. There are situations when you need these ideas.</p>
<h2><a name="p-5682-the-break-keyword-24" class="anchor" href="https://forum.rebol.info#p-5682-the-break-keyword-24"></a>The BREAK keyword</h2>

<p>From RT's changes document:</p>
<pre><code>When the BREAK word is encountered within a rule block, the block is
immediately terminated regardless of the current input pointer.
Expressions that follow the BREAK within the same rule block will not
be evaluated.
</code></pre>
<p>BREAK is usually used with repetition. In this example the SOME rule is exited early:</p>
<pre><code>&gt;&gt; parse "X" [some [ (print "*Break*") break] "X"]
*Break*
== true
</code></pre>
<p>Here again the SOME rule is exited early just like the previous example. In this case the rule that SOME is processing is referred to by a word:</p>
<pre><code>&gt;&gt; rule-to-break: [(print "*Break*") break]
== [(print "*Break*") break]
&gt;&gt; parse "X" [some rule-to-break "X"]
*Break*
== true
</code></pre>
<h1><a name="p-5682-related-toolset-25" class="anchor" href="https://forum.rebol.info#p-5682-related-toolset-25"></a>Related toolset</h1>
<p>I have written "Parse Analysis Toolset" to help learn and analyse the way Parse works. The Explain-parse function of the toolset should help with learning Parse. The script has related documentation. You can find the script and a linkg to the documentation at:</p>
<p><a href="http://www.rebol.org/cgi-bin/cgiwrap/rebol/view-script.r?script=parse-analysis.r">parse-analysis.r (at REBOL.org Script Library)</a></p>
<p>One more program I've made can return a parse tree of your input:</p>
<p><a href="http://www.rebol.org/cgi-bin/cgiwrap/rebol/documentation.r?script=load-parse-tree.r">load-parse-tree.r (at REBOL.org Script Library)</a></p>
<h1><a name="p-5682-comments-26" class="anchor" href="https://forum.rebol.info#p-5682-comments-26"></a>Comments</h1>
<p>Parse is a key component Rebol. Rebol is promoted as a messaging<br>
language. Messages can come in many formats (syntaxes). Parse allows<br>
you to define the syntax of a message so that you can interpret the message and transform<br>
it to something else or act on it directly. That may sound complex, but it isn't really.</p>
<p>What are messages? Lots of things can be considered as messages. Basically if you can<br>
put it into a file and the format of the file has some rule to it, then I think you have<br>
a message. You don't have to put it in a file though to use Parse. Rebol's networking<br>
functions use Parse to interpret many of the internet protocols that Rebol provides<br>
access to.</p>
<p>With Rebol you can define a mini-language for a specific purpose - a dialect. Outside Rebol this would be called a domain-specific language or DSL.</p>
<p>Parse helps you to validate and process such dialects. You might want to design a dialect for creating web pages on your internet site. Or perhaps for controlling a special device you have attached to your computer.</p>
<h1><a name="p-5682-acknowledgement-27" class="anchor" href="https://forum.rebol.info#p-5682-acknowledgement-27"></a>Acknowledgement</h1>
<p>Thank you to John Kenyon for his initiative, edits and effort as we updated this article from the original.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/old-parse-tutorial/1771">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/old-parse-tutorial/1771</link>
          <pubDate>Sun, 12 Dec 2021 00:08:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1771</guid>
          <source url="https://forum.rebol.info/t/old-parse-tutorial/1771.rss">Old Parse Tutorial</source>
        </item>
        <item>
          <title>How Would Stream PARSE Handle Positions?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Generically speaking: when dealing with a streaming data source, you often don't know how many bytes or characters you want to read in advance.  You're looking for some pattern in the input to delimit it.</p>
<p>(The simplest-yet-very-common example would be reading until a newline.)</p>
<p>Go has dedicated operations for reading up-until one certain byte (<a href="https://pkg.go.dev/bufio#Reader.ReadBytes">ReadBytes(byte)</a>) or one certain UTF-8 character byte sequence (<a href="https://pkg.go.dev/bufio#Reader.ReadString">ReadString(codepoint)</a>).  These are methods of the buffered IO abstraction, because if you didn't go through a buffering middleman you'd have to call a lower-level <code>Read()</code> just one byte at a time.  Otherwise the lack of a buffer would mean you wouldn't have anywhere to hold the queued-up extra data after a newline...if a Read() came back with a bigger chunk.</p>
<p>Rigging up anything more detailed in Go is harder.  <strong>So this is where I thought a streaming PARSE would offer an interesting answer for a lot of scenarios.</strong>  Getting PARSE worked out correctly would save people the trouble of having to drive the progressive Read process themselves, just to get a more nuanced condition than "until a certain byte is seen".</p>
<h2>But Streams Aren't Series...So How Would You Call PARSE?</h2>
<p>When you parse a <em>series</em>, you don't "consume" it:</p>
<pre><code>&gt;&gt; data: "aaa"

&gt;&gt; uparse data [some "a" (&lt;Yay, some A!&gt;)]
== &lt;Yay, some A!&gt;

&gt;&gt; data
== "aaa"  ; hasn't changed
</code></pre>
<p>And you can do partial processing and get a position via <code>&lt;here&gt;</code>:</p>
<pre><code>&gt;&gt; data: "aaabbb"

&gt;&gt; uparse data [some "a" &lt;here&gt;]
== "bbb"  ; this is a "position" that points into `data`

&gt;&gt; data
== "aaabbb"  ; again, the unchanged input
</code></pre>
<p><strong>However, streams don't have any position <em>but</em> "here".</strong>  So how would <code>&lt;here&gt;</code> be any different from <code>&lt;input&gt;</code>?</p>
<h2>Some Streams May Internally Know A Position, But Not All</h2>
<p>In Go we saw an example of how streaming is an interface that something can offer, while having other methods depending on the data source.  Those other methods can offer features like timeouts.  Or something like a file could offer the ability to re-seek so the next call reading from the stream would get from a random access position.</p>
<p><em>But that's all outside of the streaming interface.</em>  The stream itself is a black box.  And the position is "inside"...all references to the same stream interface will be updated if you read from any reference.</p>
<p>With Rebol series, the position is "outside"...each instance has its own index.  So when you NEXT a series, you have to save the result, or you will get the same thing again:</p>
<pre><code>&gt;&gt; series: [a b c]

&gt;&gt; next series
== [b c]

&gt;&gt; next series
== [b c]
</code></pre>
<p>If streams worked this way, you'd have to constantly be saving the new stream value every time you read from it, as another return value of the READ process.</p>
<pre><code>[data stream]: read/part stream 10
</code></pre>
<p>But if you did have to code like that, how would it react to a situation like this?</p>
<pre><code>&gt;&gt; [data newstream]: read/part oldstream 10

&gt;&gt; read/part oldstream 10
</code></pre>
<p>The (presumably) buffered stream no longer has the data on hand.  So it either preserves the data indefinitely or some of these calls would fail.</p>
<h2>So Parsing Consumes Streams, But Not Series?</h2>
<p>Right now, there's no way to leave a stream alone, because reading it consumes it.</p>
<p>The only way you'd be able to "consume" a series value--e.g. advance the index of the input--would be to pass into parse a variable holding the input.  Because the index of the series is an immediate in the value itself.</p>
<p>It seems unfortunate that something like a FILE! can know how to do random seeks, and not be able to save and restore positions in PARSE.  But if it did, what would the type of <code>&lt;here&gt;</code> be?  It would have to create a new stream instance into the same file...this would be like being able to say:</p>
<pre><code>&gt;&gt; s2: clone stream  ; maybe file reads support, but tcp reads don't?

&gt;&gt; read stream
== #{ABCD0102}

&gt;&gt; read s2
== #{ABCD0102}
</code></pre>
<p>It's probably bad for PARSE to be going this direction.</p>
<h2>A Better Idea (?) <em>some</em> Streams Offer <code>&lt;index&gt;</code>, Some Don't</h2>
<p>It's already the case that SEEK will accept either an index number or a series position.  So when you ask for <code>&lt;index&gt;</code> it could tell you the position in the file.</p>
<p><em>(Although I should mention that file seeking has historically always been offset-based, starting with zero.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:">  This was true in R3-Alpha and is also true in 1-based languages like Julia.)</em></p>
<p>This just rules out the idea of having <code>&lt;here&gt;</code> on a stream series altogether; to basically stamp out the concept that there is such a thing as a "stream-at-position".  You only deal with positions separate from streams...and only on the streams that happen to offer them.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/how-would-stream-parse-handle-positions/1740">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-would-stream-parse-handle-positions/1740</link>
          <pubDate>Wed, 06 Oct 2021 16:40:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1740</guid>
          <source url="https://forum.rebol.info/t/how-would-stream-parse-handle-positions/1740.rss">How Would Stream PARSE Handle Positions?</source>
        </item>
        <item>
          <title>Validating Subseries Data In PARSE... INPUT or INTO TAG!s?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>If you want to validate a block of input and return that block, how do you do it?</p>
<p>By default, UPARSE gives you the last rule match:</p>
<pre><code>&gt;&gt; uparse [1 2 &lt;three&gt; "four"] [some integer! tag! text!] 
== "four"
</code></pre>
<p>You can bend that last-result behavior to your advantage by invoking a rule that returns the input.  The tag! combinator <strong><code>&lt;input&gt;</code></strong> does exactly that!</p>
<pre><code>&gt;&gt; uparse [1 2 &lt;three&gt; "four"] [some integer! tag! text! &lt;input&gt;] 
== [1 2 &lt;three&gt; "four"]
</code></pre>
<p>Pretty slick.  But what if it's a <em>nested</em> block?  Does <code>&lt;input&gt;</code> give you the INTO series, or the original series?</p>
<p>Right now it gives you the INTO series.  e.g. what <code>&lt;input&gt;</code> returns is whatever the <em>currently parsed input</em> is:</p>
<pre><code>&gt;&gt; uparse [zero [1 2 &lt;three&gt; "four"]] [
      word: word!
      validated: into block! [some integer! tag! text! &lt;input&gt;]
      ("some overall result")
 ]
== "some overall result"

&gt;&gt; validated
== [1 2 &lt;three&gt; "four"]

&gt;&gt; word
== zero
</code></pre>
<p>That's nice, but... you can also imagine being inside some nested rule like this where you want to make a decision like <strong><code>return &lt;input&gt;</code></strong> which wants to imply accepting the original input to the parse.</p>
<p>Should <strong><code>&lt;input&gt;</code></strong> always return the overall parser input, and a separate rule like <strong><code>&lt;into&gt;</code></strong> give back the current sub-input?</p>
<ul>
<li>
<p>At a combinator level, the currently processed argument is always called INPUT.  So calling it <code>&lt;input&gt;</code> and returning the currently applicable input is consistent with the implementation.</p>
<ul>
<li>
<p>Well...it's actually only partially consistent.  Because the INPUT to each combinator actually is at the current position.  So it's more like HERE.</p>
<ul>
<li>I'm actually not that bothered by this</li>
</ul>
</li>
</ul>
</li>
<li>
<p>INTO is not the only combinator that we can conceive of can that can go to a nested level.  So calling the tag <code>&lt;into&gt;</code> might not be a good idea.  Also, that doesn't have the ring of generality to return the input at wherever you currently are...e.g. return the main input if you haven't done an INTO</p>
<ul>
<li>Shades of meaning are difficult here with other words, as <code>&lt;current&gt;</code> (for instance) is hard to distinguish from <code>&lt;here&gt;</code>... e.g. you'd think it would include the position.</li>
</ul>
</li>
</ul>
<p><strong>In any case...I lean toward thinking <code>&lt;input&gt;</code> reflecting the <em>current</em> input is the best answer.</strong>  I think this suggests a special term for the main input, like <code>&lt;main-input&gt;</code>.  A better choice for this would maybe be <code>&lt;original&gt;</code>.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/validating-subseries-data-in-parse-input-or-into-tag-s/1737">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/validating-subseries-data-in-parse-input-or-into-tag-s/1737</link>
          <pubDate>Mon, 04 Oct 2021 15:11:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1737</guid>
          <source url="https://forum.rebol.info/t/validating-subseries-data-in-parse-input-or-into-tag-s/1737.rss">Validating Subseries Data In PARSE... INPUT or INTO TAG!s?</source>
        </item>
        <item>
          <title>Implicit Capture In PARSE - How To Get It?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>ISO-8601 dates are very close to Rebol dates, but just different enough to make it a pain.</p>
<pre><code>; ISO-8601
2021-09-15T12:20:53-04:00

; Rebol
15-Sep-2021/12:20:53-04:00
</code></pre>
<p>Are Rebol dates more readable?  Yes.  Are they so much better as to make it worthwhile to buck the standard?  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20">  Are they in conflict with generalized PATH! representation?  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p>
<h2>
<a name="nevermind-this-post-is-about-something-else-1" class="anchor" href="https://forum.rebol.info#nevermind-this-post-is-about-something-else-1"></a>Nevermind, This Post Is About Something Else</h2>
<p>Let's say I just want to capture the YEAR, the MONTH, and the DAY out of an ISO-8601 date.</p>
<pre><code>parse isodate [
    year: between &lt;here&gt; "-"
    month: between &lt;here&gt; "-"
    day: between &lt;here&gt; "T"
    ...
 ]
</code></pre>
<p>Despite having BETWEEN, it's laborious.  <em>(Historical Rebol needs <code>copy to "-"</code> followed by a SKIP, even more convoluted, and worse if you need to skip more than one series item).</em></p>
<p>It needs a shorthand.  We have TAG! at our disposal, still:</p>
<pre><code>parse isodate [year: &lt;*&gt; "-" month: &lt;*&gt; "-" day: &lt;*&gt; "T" ...]
</code></pre>
<p>And it could be plain <strong><code>*</code></strong>:</p>
<pre><code>parse isodate [year: * "-" month: * "-" day: * "T" ...]
</code></pre>
<p>But I kind of find myself wishing for another lexical type that means "capture" that has the word "in it".  I'd thought about this as being the meaning of <code>@xxx</code> before the current interpretation, and also <code>$xxx</code>:</p>
<pre><code>parse isodate [$year "-" $month "-" $day "T" ...]
</code></pre>
<p>But almost certainly, $ is going to be binding-related in the default combinator set.</p>
<h2>
<a name="it-feels-weak-to-not-have-an-answer-for-this-2" class="anchor" href="https://forum.rebol.info#it-feels-weak-to-not-have-an-answer-for-this-2"></a>It Feels Weak To Not Have An Answer For This</h2>
<p>Other parsing systems will always seem like they have an edge if there isn't a shorthand for this "capture until the next rule".</p>
<p>But it may be that the default combinators are just too saturated and general-purpose to sacrifice any WORD!-based syntax for such a capture.  It might have to be another parameterized parse variation.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/implicit-capture-in-parse-how-to-get-it/1718">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/implicit-capture-in-parse-how-to-get-it/1718</link>
          <pubDate>Wed, 15 Sep 2021 16:40:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1718</guid>
          <source url="https://forum.rebol.info/t/implicit-capture-in-parse-how-to-get-it/1718.rss">Implicit Capture In PARSE - How To Get It?</source>
        </item>
        <item>
          <title>PARSE Errors And You: FURTHEST, FAIL, ENSURE?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>So far there's only a little bit of UPARSE featuring related to errors.  One is the FURTHEST return result:</p>
<pre><code>&gt;&gt; [v furthest]: uparse "abbbabbabcabab" [some ["a" | "b"]]
; null

&gt;&gt; furthest
== "cabab"
</code></pre>
<p>What it's doing is it's recording the high water mark of whatever a combinator called success.</p>
<p>It's better than nothing, I guess.  But for parsers that scan ahead it might be worthless.  (I'll point this out to <a class="mention" href="https://forum.rebol.info/u/brett">@Brett</a>, since he suggested the feature...)</p>
<pre><code>&gt;&gt; [v furthest]: uparse "[ababbbcabbab]" [
       "[" ahead to "]"  ; this pushes the high water mark to the ]
       some ["a" | "b"]
       "]"
   ]
; null

&gt;&gt; furthest
== "]"
</code></pre>
<p>So here we are not implicating the "c", which people would think of as the actual culprit.  But it's harder than one might think to figure out who that is.</p>
<h2>Recap of the New FAIL Feature</h2>
<p>With the new FAIL in UPARSE, you have a little bit of support on implicating the point of the input to complain about.</p>
<p>The idea is that you make sure the parse position is where you want to implicate, by making the FAIL an alternate to that position:</p>
<pre><code>&gt;&gt; uparse "{ababcababa}" [
       into between "{" "}" [
           some ["a" | "b"] &lt;end&gt;
           | fail @["Between braces should be just a and b"]
       ]
   ]
** User Error: Between braces should be just a and b
** Near: "ababcababa"
</code></pre>
<p><em>(If you've forgotten why FAIL's argument needs the @, it's because the PARSE dialect has a meaning for BLOCK! already...and for the purposes of "regularity" in the dialect this tries not to override that.  But this is an open issue if FAIL wants to break the rules.)</em></p>
<p>For demonstration purposes here, I didn't implicate the "c", but actually wrote it so the alternate is set to backtrack to when it started matching b.  You get a different result to make the fail an alternate to the end:</p>
<pre><code>&gt;&gt; uparse "{ababcababa}" [
       into between "{" "}" [
           some ["a" | "b"]
           [&lt;end&gt; | fail @["Between braces should be just a and b"]]
       ]
   ]
** User Error: Between braces should be just a and b
** Near: "cababa"
</code></pre>
<h2>A New Fuzzy Concept: ENSURE</h2>
<p>We have ENSURE for values outside of PARSE.  It runs a test and passes through the result if it matches, or stops and errors:</p>
<pre><code>&gt;&gt; x: 10

&gt;&gt; ensure integer! x
== 10

&gt;&gt; ensure tag! x
** Error: ENSURE failed with argument of type integer!
</code></pre>
<p>It seems appealing to make PARSE able to do that too:</p>
<pre><code>&gt;&gt; uparse [&lt;x&gt; 10 #y 20] [collect [while [
       keep ensure tag!
       keep ensure integer!
   ]]
** Error: ENSURE failed with argument of type ISSUE!
** Near: [... 10 \\ #y \\ 20]
</code></pre>
<p>So a similar idea to FAIL, where you get some feedback on the input location causing the problem.</p>
<p>But also similar to FAIL, this doesn't work within the model of having alternates.  It sees something it doesn't like and errors in the moment, without giving any <strong>|</strong> options in the rest of the rules a chance.  That's a bit harsh, but maybe still would fit a lot of scenarios.</p>
<p>The historical ENSURE only works on datatypes.  Could this work on values, or alternate values?</p>
<p>Far-out idea:</p>
<pre><code> &gt;&gt; uparse "abbbcababa" [some ensure ["a" | b"]]
 ** Error: ENSURE would have expected:
       "a"
       "b"
   But it received "c"
</code></pre>
<p>The idea would be that once ENSURE started, it might have some way of collecting the "leaf nodes" of failed rules.  But I have no idea how such a thing could actually work.</p>
<p>More generally I wonder how alternates figure into <em>any</em> system of error delivery.</p>
<h2>Random Weird Dialect Idea: BAD-WORD!</h2>
<p>Just wanted to write down a strange idea I had, to use BAD-WORD! to indicate a shorthand for FAIL with a message.  The idea was to make it come after a complete rule and imply a message to give if the rule to its left didn't match:</p>
<pre><code>&gt;&gt; uparse "[ababbbcabbab]" [
       "[" ahead to "]"
       some ["a" | "b"] ~a-or-b-expected~
       "]"
   ]
** Error: a-or-b-expected
** At parse input location: "cabbbab]"
</code></pre>
<p>It sucks, but it was just a brainstorming idea as a shorthand for:</p>
<pre><code>&gt;&gt; uparse "[ababbbcabbab]" [
       "[" ahead to "]"
       [some ["a" | "b"] | fail ~a-or-b-expected~]
       "]"
   ]
</code></pre>
<p>Maybe this points to the need for an ELSE construct, as it might be a bit smoother than having to enclose everything in blocks:</p>
<pre><code>&gt;&gt; uparse "[ababbbcabbab]" [
       "[" ahead to "]"
       some ["a" | "b"] else fail ~a-or-b-expected~
       "]"
   ]</code></pre>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/parse-errors-and-you-furthest-fail-ensure/1714">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/parse-errors-and-you-furthest-fail-ensure/1714</link>
          <pubDate>Mon, 13 Sep 2021 02:05:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1714</guid>
          <source url="https://forum.rebol.info/t/parse-errors-and-you-furthest-fail-ensure/1714.rss">PARSE Errors And You: FURTHEST, FAIL, ENSURE?</source>
        </item>
        <item>
          <title>Parsing Giant Streams Without Consuming Tons of Memory: How?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>I've mentioned that before I go through optimizing UPARSE I wanted to make it good at one thing that's been a bit of a pet wish of mine...</p>
<p>...and that's to be able to PARSE a giant file or network stream without needing to read it all into memory at once.</p>
<p>There are two levels of goal here:</p>
<ol>
<li>
<p><strong>Big Crazy Goal:</strong> To have something like a long network stream of data <em>(that you can't seek backwards in)</em> and be able to have records in it parsed discretely one at a time.  Even if the stream is 100GB in size, you'd only use a fixed amount of memory to do your processing.</p>
</li>
<li>
<p><strong>More Modest Goal:</strong> To let the PARSE be woven in with the read process, so it can start processing and reacting without waiting for all the data to be read...even if it ultimately isn't able to avoid reading the whole stream of data into a buffer.</p>
</li>
</ol>
<p>Getting 2 to work is the easier of these.  -But- let me be clear that given the lack of existence of "streams" in historical Rebol, it by no means <em>easy</em>!</p>
<p>1 is the more tricky and interesting one to my tastes, so I'll start by talking about that.</p>
<h2>
<a name="if-combinators-inform-us-then-1-seems-tractable-tractor-1" class="anchor" href="https://forum.rebol.info#if-combinators-inform-us-then-1-seems-tractable-tractor-1"></a>If Combinators Inform Us, Then (1) <em>Seems</em> Tractable <img src="https://forum.rebol.info/images/emoji/twitter/tractor.png?v=12" title=":tractor:" class="emoji" alt=":tractor:" loading="lazy" width="20" height="20">
</h2>
<p>Let's say we're trying to parse lines with just the letters A and B, and count them as we go:</p>
<pre><code>p: open %giant-file.txt

count: 0

parse p [
   some [some ["A" | "B"] newline (count: count + 1)]
]
then [
    print ["Your giant file had" count "lines of ABs"]
else [
    print ["Giant file wasn't just lines of ABs"]
]
</code></pre>
<p>Our intuition tells us that we can can do this one line at a time, throwing it out as you go.  But how might PARSE know that?</p>
<p>It builds a SOME combinator and can see that's the last thing in the rule block.  Assuming the user doesn't capture any positions with <strong><code>&lt;here&gt;</code></strong> or do any <strong><code>SEEK</code></strong>, there is no way that the SOME will ever backtrack from the point where it started.  Each iteration can throw out the ability to backtrack.</p>
<p><em>But right now SOME is a black box;</em> doing whatever it wants until it finally returns a result.  From PARSE's perspective there's nothing from the outside that differentiates it from something called SOME-HALF that will repeat a rule some number of times, and then jump back in time to the halfway point of the match:</p>
<pre><code>&gt;&gt; parse "abababab" [some-half "ab", return &lt;here&gt;]
== "abab"

&gt;&gt; parse "abababababab" [some-half "ab", return &lt;here&gt;]
== "ababab"
</code></pre>
<p>Without some additional information, the system doesn't know that SOME won't make a decision like SOME-HALF would.  It has to let it run until it is finished.</p>
<h2>
<a name="how-can-combinators-tell-parse-about-backtrack-needs-2" class="anchor" href="https://forum.rebol.info#how-can-combinators-tell-parse-about-backtrack-needs-2"></a>How Can Combinators Tell PARSE About Backtrack Needs?</h2>
<p>One way of looking at this is that the combinator itself becomes responsible for storing any memory that it requires for backtracking.</p>
<p>That is to say that it pulls information out of the stream...and if it wants to backtrack it pushes it back in.</p>
<pre><code>&gt;&gt; parse "aaab" [some ["a"] "b"]    
</code></pre>
<ul>
<li>SOME combinator grabs an "a" from stream, matches the "a"</li>
<li>SOME combinator grabs an "a" from stream, matches the "a"</li>
<li>SOME combinator grabs an "a" from stream, matches the "a"</li>
<li>SOME combinator grabs a "b" from stream, doesn't like it, pushes it back and ends</li>
<li>TEXT! combinator grabs a "b" from the stream, matches the "b"</li>
</ul>
<p>If the SOME becomes responsible for pushing back any input it doesn't like, then the stream can just discard everything as it goes (in cases where it doesn't see any potential for some rule down the line to request backtrack).  This means offering some kind of "push back into stream" operator that combinators can use if they need to back out.</p>
<p><strong>This concept of putting back the character is actually how many things like this work.</strong></p>
<ul>
<li>
<p>In C++ iostreams there is <a href="https://stackoverflow.com/questions/6769416/difference-between-putback-and-unget">istream::putback() and istream::unget()</a></p>
</li>
<li>
<p>In Haskell's Data.Stream, there is <a href="https://hackage.haskell.org/package/io-streams-1.5.2.1/docs/System-IO-Streams.html#v:unRead">unRead</a></p>
</li>
</ul>
<p>In C++, unget() requires you give what you read in.  By doing so, then if the data is no longer in a buffer and you're reading from a file...it doesn't need to do anything but push its file offset backwards.  Haskell's unRead and C++ putback() let you push back something different than what you read...and considers that a feature <em>(we'll assume it does a similar optimization to unget() if you were reading from a file and it noticed what you pushed back was the same as the data in the buffer?)</em></p>
<h2>
<a name="going-unit-by-unit-sounds-laborious-and-slow-3" class="anchor" href="https://forum.rebol.info#going-unit-by-unit-sounds-laborious-and-slow-3"></a>"Going Unit-By-Unit Sounds Laborious, and <em>Slow</em>...?"</h2>
<p>It may seem laborious on the surface, but as far as I can tell this is the way streams work.</p>
<p>I was just working on an implementation of READ-LINE for standard input.  And all the prescribed methods of reading one line at a time from a file in C would go one character at a time.  That sounds like a lot of I/O requests, but the thing is that basically all I/O systems have buffering in them...if you ask to read a character from a file, it isn't going to your hard drive or making a network request for that one character.  It buffers it--and if you try to buffer it yourself you're likely just going to be adding complexity/code/memory and making things worse.</p>
<p><strong>Unfortunately <a href="http://docs.libuv.org/en/v1.x/stream.html">libuv() streams</a> don't have any putback() or ungetc() ability.</strong>  There's no going back in time with them.  :-/</p>
<p>And as it turns out Boost.ASIO doesn't have it either.  (Which surprises me.)</p>
<p>This means if we were building combinators on top of an ungetc()-type logic...and want to go back in time to read a file and not have it fully in memory...we'd have to be using the raw file API if we wanted to keep sync'd to the data that's already on disk and be able to use it instead of keeping the full buffer contents.</p>
<p>That's a bit depressing.  But if there's any good news, it's that Rebol datatypes are optimized specifically for "unget".  If the buffers are BLOCK!s or BINARY!s or TEXT!s then when you "NEXT" them the data is still there, and you just BACK it to do an ungetc.</p>
<p>Plus, we'd have to have our own layer for managing this if we were going to seek back in time using <strong><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests">HTTP Range Requests</a></strong> on networks.</p>
<p>I guess I'll just experiment and see what I can work out.  :-/</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/parsing-giant-streams-without-consuming-tons-of-memory-how/1698">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/parsing-giant-streams-without-consuming-tons-of-memory-how/1698</link>
          <pubDate>Thu, 02 Sep 2021 05:17:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1698</guid>
          <source url="https://forum.rebol.info/t/parsing-giant-streams-without-consuming-tons-of-memory-how/1698.rss">Parsing Giant Streams Without Consuming Tons of Memory: How?</source>
        </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Dialects/DSLs - AltRebol</title>
    <link>https://forum.rebol.info/c/domains/dialects-dsls/18</link>
    <description>Topics in the &#39;Dialects/DSLs&#39; category Discussion focused on the creation of dialects and DSLs using Rebol. Rebmu talk is appropriate here.</description>
    
      <lastBuildDate>Tue, 28 Feb 2023 22:17:50 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/domains/dialects-dsls/18.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Pikchr Drawing Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>This is an interesting dialect-looking thing that's a Unix utility someone showed me for diagrams.  It might interest <a class="mention" href="/u/rgchris">@rgchris</a>, or others.  It's called PIKCHR.</p>
<p>You can try it online at <a href="https://pikchr.org/home/pikchrshow">https://pikchr.org/home/pikchrshow</a> ... there are a few examples.</p>
<p>It's a textual set of instructions that lets you lay things out... but differently from something like PDF, it captures intents in a pretty interesting way for aligments and duplication.</p>
<p>Look how it lays out this "swim lanes" example graphic:</p>
<p><img src="https://forum.rebol.info/uploads/default/original/1X/babd46454d69ba774a09050d20d26dc3e2e9e326.png" alt="image" data-base62-sha1="qDYklKuijn94kAkO07RmNG9E6YS" width="520" height="449"></p>
<pre><code>$laneh = 0.75
# Draw the lanes
down
box width 3.5in height $laneh fill 0xacc9e3
box same fill 0xc5d8ef
box same as first box
box same as 2nd box
line from 1st box.sw+(0.2,0) up until even with 1st box.n "Alan" above aligned
line from 2nd box.sw+(0.2,0) up until even with 2nd box.n "Betty" above aligned
line from 3rd box.sw+(0.2,0) up until even with 3rd box.n "Charlie" above aligned
line from 4th box.sw+(0.2,0) up until even with 4th box.n "Darlene" above aligned
# fill in content for the Alice lane
right
A1: circle rad 0.1in at end of first line + (0.2,-0.2) fill white thickness 1.5px "1"
arrow right 50%
circle same "2"
arrow right until even with first box.e - (0.65,0.0)
ellipse "future" fit fill white height 0.2 width 0.5 thickness 1.5px
A3: circle same at A1+(0.8,-0.3) "3" fill 0xc0c0c0
arrow from A1 to last circle chop "fork!" below aligned
# content for the Betty lane
B1: circle same as A1 at A1-(0,$laneh) "1"
arrow right 50%
circle same "2"
arrow right until even with first ellipse.w
ellipse same "future"
B3: circle same at A3-(0,$laneh) "3"
arrow right 50%
circle same as A3 "4"
arrow from B1 to 2nd last circle chop
# content for the Charlie lane
C1: circle same as A1 at B1-(0,$laneh) "1"
arrow 50%
circle same "2"
arrow right 0.8in "goes" "offline"
C5: circle same as A3 "5"
arrow right until even with first ellipse.w "back online" above "pushes 5" below "pulls 3 &amp; 4" below
ellipse same "future"
# content for the Darlene lane
D1: circle same as A1 at C1-(0,$laneh) "1"
arrow 50%
circle same "2"
arrow right until even with C5.w
circle same "5"
arrow 50%
circle same as A3 "6"
arrow right until even with first ellipse.w
ellipse same "future"
D3: circle same as B3 at B3-(0,2*$laneh) "3"
arrow 50%
circle same "4"
arrow from D1 to D3 chop</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/pikchr-drawing-dialect/2018">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/pikchr-drawing-dialect/2018</link>
          <pubDate>Tue, 28 Feb 2023 22:17:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2018</guid>
          <source url="https://forum.rebol.info/t/pikchr-drawing-dialect/2018.rss">Pikchr Drawing Dialect</source>
        </item>
        <item>
          <title>Future of the MATH Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>It is basically inevitable that people coming to Rebol will ask about its mathematical evaluation being left-to-right, instead of obeying the precedence order that they are used to.  Red just had a new user try to file it as a bug... 3 days ago:</p>
<p><a href="https://github.com/red/red/issues/5276">https://github.com/red/red/issues/5276</a></p>
<p><strong>What seemed to make sense to people like me and BrianH was that the core ship with a dialect called MATH.</strong>  The concept was that <strong>math [1 + 2 * 3]</strong> would give <strong>7</strong> and not <strong>9</strong>.  Having something in the box seemed better than having the first line of argument being <em>"you don't want the precedence you think you do"</em>.</p>
<p>But it turned out to be kind of hard to make pleasing.  One key difficulty which <a class="mention" href="/u/brett">@Brett</a> and I fretted over at some point was that since Rebol isn't "psychic" regarding arity, does not know a-priori how much code an expression will consume:</p>
<pre><code>math [1 + 2 * foo baz bar + 3]

; should it be...
[1 + (2 * (foo baz bar)) + 3]

; or perhaps...
[(1 + (2 * foo)) ((baz bar) + 3)]

; maybe...
[(1 + (2 * foo)) baz (bar + 3)]
</code></pre>
<p><strong>It started to appear that the user would have to put anything that wasn't a number or a math operator in groups.</strong>  There may be some heuristics which tolerate words that look up to numbers vs. functions, but it feels very slippery.</p>
<p>As I've said I hate to be dropping things, but MATH is something that Rebol programmers don't really want in the first place--and I don't think non-Rebol programmers would be satisfied by it.  If it's included in the core that suggests support for it, and there are just too many things in play.</p>
<p>Here is an implementation that was previously included, by Gabriele:</p>
<pre><code>; This MATH implementation is from Gabrielle Santilli circa 2001, found
; via http://www.rebol.org/ml-display-thread.r?m=rmlXJHS. It implements the
; much-requested (by new users) idea of * and / running before + and - in
; math expressions. Expanded to include functions.
;
math: func [
    {Process expression taking "usual" operator precedence into account.}

    expr [block!]
        {Block to evaluate}
    /only
        {Translate operators to their prefix calls, but don't execute}

    ; !!! This creation of static rules helps avoid creating those rules
    ; every time, but has the problem that the references to what should
    ; be locals are bound to statics as well (e.g. everything below which
    ; is assigned with BLANK! really should be relatively bound to the
    ; function, so that it will refer to the specific call.)  It's not
    ; technically obvious how to do that, not the least of the problem is
    ; that statics are currently a usermode feature...and injecting relative
    ; binding information into something that's not the function body itself
    ; isn't implemented.

    &lt;static&gt;

    slash (the /)

    expr-val (_)

    expr-op (_)

    expression  ([
        term (expr-val: term-val)
        opt some [
            ['+ (expr-op: 'add) | '- (expr-op: 'subtract)]
            term (expr-val: compose [(expr-op) (expr-val) (term-val)])
        ]
        &lt;end&gt;
    ])

    term-val (_)

    term-op (_)

    term ([
        pow (term-val: power-val)
        opt some [
            ['* (term-op: 'multiply) | slash (term-op: 'divide)]
            pow (term-val: compose [(term-op) (term-val) (power-val)])
        ]
    ])

    power-val (_)

    pow ([
        unary (power-val: unary-val)
        opt ['** unary (power-val: compose [power (power-val) (unary-val)])]
    ])

    unary-val (_)

    pre-uop (_)

    post-uop (_)

    unary ([
        (post-uop: pre-uop: [])
        opt ['- (pre-uop: 'negate)]
        primary
        opt ['! (post-uop: 'factorial)]
        (unary-val: compose [(post-uop) (pre-uop) (prim-val)])
    ])

    prim-val (_)

    primary ([
        set prim-val any-number!
        | set prim-val [word! | path!] (prim-val: reduce [prim-val])
            ; might be a funtion call, looking for arguments
            opt some [
                nested-expression (append prim-val take nested-expr-val)
            ]
        | ahead group! into nested-expression (prim-val: take nested-expr-val)
    ])

    p-recursion (_)

    nested-expr-val ([])

    save-vars (func [][
            p-recursion: reduce [
                :p-recursion :expr-val :expr-op :term-val :term-op :power-val :unary-val
                :pre-uop :post-uop :prim-val
            ]
        ])

    restore-vars (func [][
            set [
                p-recursion expr-val expr-op term-val term-op power-val unary-val
                pre-uop post-uop prim-val
            ] p-recursion
        ])

    nested-expression ([
            ;all of the static variables have to be saved
            (save-vars)
            expression
            (
                ; This rule can be recursively called as well,
                ; so result has to be passed via a stack
                insert nested-expr-val expr-val
                restore-vars
            )
            ; vars could be changed even it failed, so restore them and fail
            | (restore-vars) fail

    ])
][
    clear nested-expr-val
    let res: either parse3 expr expression [expr-val] [blank]

    either only [
        return res
    ][
        ret: reduce res
        all [
            1 = length of ret
            any-number? ret.1
        ] else [
            fail [
                unspaced ["Cannot be REDUCED to a number (" mold ret ")"]
                ":" mold res
            ]
        ]
        return ret.1
    ]
]</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/future-of-the-math-dialect/2013">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/future-of-the-math-dialect/2013</link>
          <pubDate>Tue, 31 Jan 2023 19:08:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2013</guid>
          <source url="https://forum.rebol.info/t/future-of-the-math-dialect/2013.rss">Future of the MATH Dialect</source>
        </item>
        <item>
          <title>Dialecting With Quasiforms</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>In the list of potential ideas of the long forgotten past, there was a thought that strings would come in two forms... one that was compared case-sensitively, and another that was not.</p>
<p>The visual look of the case-insensitive form was suggested as having a leading tilde, as one representation.</p>
<pre><code>&gt;&gt; "a" = ~"A"
== #[true]
</code></pre>
<p>No one really went to bat for the idea or thought through its ramifications.  It wasn't particularly easy to test what that would be like.</p>
<h2>Quasiforms Make The Proposal Easier To Test</h2>
<p>We now basically have the implementation guts needed to where we could consider the bits passed on the value.  It even has a decent name:</p>
<pre><code>&gt;&gt; quasi "A"
== ~"A"~

 &gt;&gt; "a" = "A"
 == #[false]

 &gt;&gt; "a" = quasi "A"
 == #[true]
</code></pre>
<p>The principle meaning of a quasiform is as the ^META of an isotope form.  And what this would mean is, there's no such thing as a differentiation between an isotopic case-sensitive word/string and an isotopic case-insensitive word/string.</p>
<h2>I Don't Think I Like It, BUT...</h2>
<p>Regardless of me not liking it, it's a possibility for dialects.  If you wanted to mark some strings for case-insensitivity you have another option in the box.</p>
<p>The reason I don't like it is because the isotope and quasi forms are supposed to stand out and draw attention to weirdness.  This is too common an application.  And it would mean your case-insensitive forms would be evaluating to isotopes everywhere, unless the quasiform evaluation changed in some way to make quasi-strings inert.  This isn't in line with what I want to do.</p>
<p>But...your dialect can do it.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/dialecting-with-quasiforms/1960">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dialecting-with-quasiforms/1960</link>
          <pubDate>Mon, 05 Sep 2022 08:16:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1960</guid>
          <source url="https://forum.rebol.info/t/dialecting-with-quasiforms/1960.rss">Dialecting With Quasiforms</source>
        </item>
        <item>
          <title>Scheduler Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>I thought of the scheduler dialect today that DocKimbel had made, and went and looked it up.</p>
<p>This is something that should be able to run as-is in Ren-C under Redbol emulation--so I'll see what I can do about that.  But it would also be interesting to see what kinds of improvements could be made to it with a Ren-C specific version.</p>
<aside class="onebox githubgist">
  <header class="source">
      <a href="https://gist.github.com/greggirwin/63471784ace61153763f465c3ea37c98" target="_blank" rel="noopener">gist.github.com</a>
  </header>
  <article class="onebox-body">
    <h4><a href="https://gist.github.com/greggirwin/63471784ace61153763f465c3ea37c98" target="_blank" rel="noopener">https://gist.github.com/greggirwin/63471784ace61153763f465c3ea37c98</a></h4>
<h5>scheduler.r</h5>
<pre><code class="Rebol">REBOL [
	Title: "Scheduler"
	File: %scheduler.r
	Purpose: "Dialected task scheduling library"
	Author: ["SOFTINNOV / Nenad Rakocevic" "Pointillistic / Gregg Irwin"]
	Copyright: ["2009 SOFTINNOV" "2013 SOFTINNOV/POINTILLISTIC"]
	Email: [nr@softinnov.com gregg@pointillistic.com]
	Date: 28-Oct-2013
	Version: 0.9.5
	License: "BSD - see %LICENCE.txt file"</code></pre>
This file has been truncated. <a href="https://gist.github.com/greggirwin/63471784ace61153763f465c3ea37c98" target="_blank" rel="noopener">show original</a>

<p>
</p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/scheduler-dialect/1957">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/scheduler-dialect/1957</link>
          <pubDate>Sat, 03 Sep 2022 07:40:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1957</guid>
          <source url="https://forum.rebol.info/t/scheduler-dialect/1957.rss">Scheduler Dialect</source>
        </item>
        <item>
          <title>What&#39;s Cool (According to Danny)</title>
          <dc:creator><![CDATA[Danny]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Photos are nice. complex. but some how easy to understand most of the time without having to know the "who, what, when, where, and why." Just by looking at them, you can kinda tell what it's trying to show you. I want Rebol coding to look like that while working with any data context in its original form as possible.</p>
<blockquote>
<p>**<br>
var {whats-cool 0: Brett}<br>
Var Rebdol: {Rebdol cool: "what's-cool"}**</p>
</blockquote>
<p>The <a href="http://www.rebol.org/view-script.r?script=rebol-dom.r" rel="noopener nofollow ugc">%Rebol-dom.r</a> Var is named from the associated value strings/words, unless you *!, select-all-fetch-as strings/words. Then you can, Rebdol."cool" -&gt;select &amp; load "what's-cool". Wich is, whats-cool: { 0: Brett}. Then .[0], and  you get Brett.</p>
<p>Or change the *value to Ren-C. **</p>
<blockquote>
<p>whats-cool [ /rebdol.cool.&amp;.0 = Ren-C] <em>messy, noisy example</em><br>
**</p>
</blockquote>
<p>Is this musing when the origonal data context does'nt need to be changed. And if parsed into a Dialect Object Model, without changing syntax, this data can be searched, updated with DOM functions.</p>
<p>Creating Vars out of molded data/code with foreign syntax, is its own Sequence built notation.</p>
<blockquote>
<pre><code>struct: :Var

 struct qwerty {
                   Int #1
                   Char "hello"
                   Float 9.0
                   Char "there"
                } *! 'qwerty

*variable: "request" new[qwerty]
</code></pre>
</blockquote>
<p>This data looks like and can be used to construct *New nodes that can run as code without creating defined functions but remain as sequence(molded) data that needs no bindings or loading to take place.</p>
<p>I hope this is musing, for others as it is for me. Rebol-dom.r Sequence/molded data, strings as *keys have context all without loading anything but the *value. It's what i found and fished out of that Deep Lake.</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/whats-cool-according-to-danny/1906">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/whats-cool-according-to-danny/1906</link>
          <pubDate>Fri, 29 Jul 2022 23:42:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1906</guid>
          <source url="https://forum.rebol.info/t/whats-cool-according-to-danny/1906.rss">What&#39;s Cool (According to Danny)</source>
        </item>
        <item>
          <title>FIND treats TYPESET!s specially...why not functions?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>In Rebol2, R3-Alpha, and Red...doing a FIND searching for a TYPESET! will give you the first instance of that type in a block:</p>
<pre><code>&gt;&gt; find [1 2 "abc" 3 4] any-string!
== ["abc" 3 4]

&gt;&gt; find [1 2 &lt;abc&gt; 3 4] any-string!
== [&lt;abc&gt; 3 4]
</code></pre>
<p>One would think that you'd be able to search for the typeset literally by using /ONLY.  But that doesn't work <em>(though Red says <a href="https://github.com/red/red/issues/4911">they addressed this recently</a>)</em></p>
<h3>Why Wasn't This Taken Further?</h3>
<p>Trying to FIND a function is pretty rare.  So why didn't they make it so that passing a function to FIND makes it search?</p>
<pre><code>&gt;&gt; find [1 2 3 4] func [x] [x &gt; 2]
== [3 4]
</code></pre>
<p>If a function took multiple arguments, that could be asking it to effectively /SKIP and group items at a time:</p>
<pre><code>&gt;&gt; find [1 2 4 3 5 6] func [a b] [a &gt; b]
== [4 3 5 6]
</code></pre>
<p>/ONLY could have worked for finding a function literally:</p>
<pre><code>&gt;&gt; find/only reduce [:positive? :zero? :negative?] :zero?
== [#[native! zero?...] #[native! negative?...]]
</code></pre>
<h3>Ren-C goes with QUOTED! vs. /ONLY, but same basic premise</h3>
<pre><code>&gt;&gt; find [1 0 2 0] :zero?
== [0 2 0]

&gt;&gt; find reduce [:positive? :zero? :negative?] quote :zero?
== [#[native! zero?...] #[native! negative?...]]
</code></pre>
<h3>Though It Seems Easy To Make Mistakes...</h3>
<p>People are invariably going to write <strong>find data value</strong>...think it works for a few values they try...and assume it works for others.  Redbols are notorious for pulling the rug out from under you with such things.</p>
<p>But if you're willing to do this for typesets, I don't see why doing it for functions is that much worse.</p>
<p>Just something to think about.</p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/find-treats-typeset-s-specially-why-not-functions/1881">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/find-treats-typeset-s-specially-why-not-functions/1881</link>
          <pubDate>Thu, 14 Jul 2022 10:36:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1881</guid>
          <source url="https://forum.rebol.info/t/find-treats-typeset-s-specially-why-not-functions/1881.rss">FIND treats TYPESET!s specially...why not functions?</source>
        </item>
        <item>
          <title>DESTRUCTURE Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>I've talked about this.  But there's no excuse not to write it, when there's so much power in modern PARSE <em>(the engine we up until recently called UPARSE)</em>.</p>
<p>A simple motivating case was a desire for different behavior from PARSE alternates with <strong><code>|</code></strong>.  So while <strong>[word! | word! word!]</strong> is always considered to be a badly-written parse rule, you could get a different treatment in destructure...because it always assumes you mean to go to <code>&lt;end&gt;</code></p>
<pre><code>&gt;&gt; destructure [banana] [
      [word!] =&gt; [print "Just one word"]
      [word! word!] =&gt; [print "Two words"]
   ]
Just one word

&gt;&gt; destructure [apple banana] [
      [word!] =&gt; [print "Just one word"]  ; not complete, so no match
      [word! word!] =&gt; [print "Two words"]
   ]
Two words
</code></pre>
<p>But the dialect concept is more ambitious than that, allowing you to give names to capture rules.  Then when you use those names, that's the variable that is set:</p>
<pre><code>&gt;&gt; destructure [apple banana] [
      w1: [word!] w2: [word!]

      [w1] =&gt; [print ["One:" w1]]
      [w1 w2] =&gt; [print ["Two:" w1 w2]]
   ]
Two: apple banana
</code></pre>
<p>And because what's actually powering this behind the scenes is PARSE, you have all those tools at your disposal...including the just-added <a href="https://forum.rebol.info/t/the-yada-yada-yada-combinator/1876">ellipsis operator</a>!</p>
<pre><code>&gt;&gt; destructure [1 2 apple banana 3 4 5] [
      w1: [word!] w2: [word!]

      [w1] =&gt; [print ["One:" w1]]
      [w1 w2] =&gt; [print ["Two:" w1 w2]]
      [... w1 w2 ...] =&gt; [print ["Words and more stuff:" w1 w2]]
   ]
Words and more stuff: apple banana
</code></pre>
<h2>A Crazy Short Implementation!</h2>
<p>I'm sure it will receive some enhancements, but... this is pretty badass for something I wrote that worked more or less the first time!</p>
<pre><code>destructure: func [
    input [any-series!]
    dialect [block!]
    /multi "Run multiple branches"
    &lt;local&gt; result' name rule pattern branch combinators
][
    result': '~
    combinators: copy default-combinators
    parse dialect [while [not &lt;end&gt;] [
        name: to-word/ set-word!, rule: block! (
            combinators.(name): compose [(name): (rule)]
        )
        |
        pattern: block!, '=&gt;, branch: block!
        (
            parse/combinators input pattern combinators then (
                branch
            ) also ^r' -&gt; [
                if not multi [
                    return unmeta r'
                ]
                result': r'
            ]
        )
        |
        fail "Invalid DESTRUCTURE dialect entry"
    ]]
    return unmeta result'
]
</code></pre>
<h2>And It's Composable, Too!</h2>
<p>That's right... you can use DESTRUCTURE with ELSE and THEN.</p>
<p>It follows the rules; a destructure that does not match anything is void!</p>
<pre><code>&gt;&gt; 1 + 2 destructure [a] [[integer!] =&gt; [print "Not happening"]]
== 3
</code></pre>
<p>Notice I even threw a /MULTI feature in there, so you can match multiple ways!</p>
<pre><code>&gt;&gt; destructure/multi [apple banana] [
      w1: [word!] w2: [word!]

      [w1] =&gt; [print ["One:" w1]]
      [w1 w2] =&gt; [print ["Two:" w1 w2]]
      [repeat 2 &lt;any&gt;] =&gt; [print "Matching any two values also counts"]
   ]
Two: apple banana
Matching any two values also counts
</code></pre>
<hr>
<h1>
<img src="https://forum.rebol.info/images/emoji/twitter/boom.png?v=9" title=":boom:" class="emoji" alt=":boom:"> <img src="https://forum.rebol.info/images/emoji/twitter/raised_hand_with_fingers_splayed.png?v=9" title=":raised_hand_with_fingers_splayed:" class="emoji" alt=":raised_hand_with_fingers_splayed:"> <img src="https://forum.rebol.info/images/emoji/twitter/electric_plug.png?v=9" title=":electric_plug:" class="emoji" alt=":electric_plug:">  POWER, IN YOUR HANDS! <img src="https://forum.rebol.info/images/emoji/twitter/electric_plug.png?v=9" title=":electric_plug:" class="emoji" alt=":electric_plug:"> <img src="https://forum.rebol.info/images/emoji/twitter/raised_hand_with_fingers_splayed.png?v=9" title=":raised_hand_with_fingers_splayed:" class="emoji" alt=":raised_hand_with_fingers_splayed:">  <img src="https://forum.rebol.info/images/emoji/twitter/boom.png?v=9" title=":boom:" class="emoji" alt=":boom:">
</h1>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/destructure-dialect/1877">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/destructure-dialect/1877</link>
          <pubDate>Tue, 12 Jul 2022 15:52:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1877</guid>
          <source url="https://forum.rebol.info/t/destructure-dialect/1877.rss">DESTRUCTURE Dialect</source>
        </item>
        <item>
          <title>The CIRCLED Dialect: Example of the Form</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>I was looking at this from the emscripten config file:</p>
<pre><code> ; Right now, either #web or #node (someday #wasm-edge ?)
 ;
 javascript-environment: #web
</code></pre>
<p>And I thought to myself: well that's kind of ugly.  The comment is having to list things that would be more obviously shown by just demonstrating the options:</p>
<pre><code>javascript-environment: circled [(#web) #node]
</code></pre>
<p>Being dialected, it could even have visual hints as to whether many options are allowed, or just one.</p>
<pre><code>extensions: circled [[
   (javascript)
   (debugger)
    view
    jpeg
   (crypto)
]]
</code></pre>
<p>Or maybe it uses optional parameters to tell you how many you can have.</p>
<pre><code>toppings: circled 0..3 [(cheese) tomatoes (pickles) (lettuce) onions]
</code></pre>
<p>It could default to NULL if you circled nothing, but you could use MUST to suggest people needed to select something:</p>
<pre><code>&gt;&gt; number: must circled [#one #two #three]
** Error: MUST requires argument not to be NULL
</code></pre>
<h2>It's Almost <em>Too</em> Easy</h2>
<p>When it's this easy, who wouldn't whip such things up?</p>
<p>Ultimately I believe this should work (once PARSE is renamed and there's <a href="https://forum.rebol.info/t/parsing-alternates-should-must-match-to-end-be-considered/1850">Terminal Parse Alternates</a>):</p>
<pre><code>circled: lambda [block [block!]] [
    parse block [return [
         thru into group! [&lt;any&gt; | (fail "Circle One")]
         maybe [thru group! (fail "Circle One")]
    ]]
]

&gt;&gt; circled [a (b) c]
== b

&gt;&gt; circled [a b c]
; null

&gt;&gt; circled [(a) b (c)]
** Error: Circle One

&gt;&gt; circled [a (b c)]
** Error: Circle One
</code></pre>
<p>But of course PARSE is called UPARSE right now, and there's a detail of alternates not being offered in blocks seeking completion before failing...that makes you need <code>elide &lt;end&gt;</code>, so for now:</p>
<pre><code>circled: lambda [block [block!]] [
    uparse block [return [
         thru into group! [&lt;any&gt; elide &lt;end&gt; | (fail "Circle One")]
         maybe [thru group! (fail "Circle One")]
    ]]
]
</code></pre>
<p>It finds one group to extract an element from, and extracts it via INTO.  Then it has a second clause that's optional--and if it doesn't match is invisible...but if it <em>does</em> match it fails.</p>
<p>Remarkable plasticity, and I want to see these weapons come to the code golfing field.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-circled-dialect-example-of-the-form/1849">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-circled-dialect-example-of-the-form/1849</link>
          <pubDate>Sun, 26 Jun 2022 12:06:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1849</guid>
          <source url="https://forum.rebol.info/t/the-circled-dialect-example-of-the-form/1849.rss">The CIRCLED Dialect: Example of the Form</source>
        </item>
        <item>
          <title>Dialecting URL!s...Should They Ever Be Strings?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>So I just tried to use a URL! in PARSE and found it was an error.  It's an error in R3-Alpha, too:</p>
<pre><code>r3-alpha&gt;&gt; parse http://example.com/foo [http://example.com "/foo"]
** Script error: PARSE - invalid rule or usage of rule: http://example.com
</code></pre>
<p>Red treats it as a string:</p>
<pre><code>red&gt;&gt; parse http://example.com/foo [http://example.com "/foo"]
== true
</code></pre>
<p><strong>But if you think about it, this is a pretty limited application of the datatype.</strong></p>
<ul>
<li>
<p>If your input is a string, you're saving two characters over putting it in braces or quotes, like <strong><code>["http://example.com" "/foo"]</code></strong></p>
<ul>
<li>Ren-C has generic quoting, so there's quoted URL!s with a single character as another option... <strong><code>['http://example.com "/foo"]</code></strong>
</li>
</ul>
</li>
<li>
<p>If what you're matching against is a URL it's only going to match the very beginning part.</p>
</li>
</ul>
<h2>Could It Fetch Rules From A Network?</h2>
<p>In some cases--like the COMPILE dialect--you can build a list of code and libraries to put together, along with user natives.  It's neat there to have URLs be interpreted as fetching from the network.</p>
<p>But that seems a bit strange for UPARSE.  You'd depend on caching <em>(you wouldn't want to do a network fetch each time you hit the URL! in the rule...?)</em>  In Ren-C you can kind of do this minus the caching, e.g.</p>
<pre><code>uparse data [... :(load http://example.com/rules/) ...]
</code></pre>
<h2>Could It Be Commentary?</h2>
<p>In the test dialect, I thought it might be nice to just be able to drop URLs in the middle of things without having to make them comments.  It doesn't save that much, but can look more clean:</p>
<pre><code>[
    #386
    http://en.wikipedia.org/wiki/Some_Related_Topic
    (1 + 1 = 2)
]
</code></pre>
<p>I've also sometimes wondered about this for function specifications.</p>
<pre><code>foo: func [
    http://example.com/this-explains-this-function
    return: [integer!]
    arg [integer!]
][
    ...
]
</code></pre>
<p>This doesn't seem a good fit for PARSE behavior, but I kind of want to mention the idea of different ways that URL! might be used.</p>
<h2>In UPARSE It's Customizable...Leave it Open?</h2>
<p>One possibility would be to say that URL! doesn't do anything by default, and you can make a URL! combinator that decides what it does do.</p>
<p>How useful would it be?  I don't know.</p>
<p><strong>I'm just questioning whether the knee-jerk response of treating URL! as a string (or matching a URL! value if block parsing) is obviously the way to go.</strong></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/dialecting-url-s-should-they-ever-be-strings/1763">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dialecting-url-s-should-they-ever-be-strings/1763</link>
          <pubDate>Mon, 29 Nov 2021 15:36:40 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1763</guid>
          <source url="https://forum.rebol.info/t/dialecting-url-s-should-they-ever-be-strings/1763.rss">Dialecting URL!s...Should They Ever Be Strings?</source>
        </item>
        <item>
          <title>USCII Seen With New Eyes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>In 2008 I used R3-Alpha to make some 5x7 bitmaps out of a stock font I found, plus some data to make symbols for the missing control characters.  The way I defined the missing characters was with blocks of data, like:</p>
<pre><code>[
    code: 10
    name: "Line Feed"
    abbr: "LF"
    description: {
        On typewriters, printers, and some terminal emulators, moves the
        cursor down one row without affecting its column position. On Unix,
        used to mark end-of-line.
    }
    image: [
        "XXX  "
        "  X  "
        "  X  "
        "  X  "
        "XXXXX"
        " XXX "
        "  X  "
    ]
    notes: {
        A spin on the carraige return which emphasizes the "downness" of
        a feed, but also with a horizontal suggestion of the current line
    }
    rating: 'good
] 
</code></pre>
<p>Besides not needing commas on the strings, this doesn't really buy a whole lot over JSON.  The script had a couple of talking points--that PNG encoding and IMAGE! was built in, and that you could put BINARY! data directly in your script as hex.  But largely unremarkable.</p>
<p>Not that the point was to demo "great Rebol practices", really.  I was just using it as a tool.  <em>(And it was 2008, so I had just found the language...one shouldn't expect much regardless.)</em></p>
<p><strong>I've gotten it working under Redbol emulation--which is kind of a cool trick in and of itself.</strong>  This involved patching up the bad IMAGE! code well enough to work with the script, but it felt worth it to run the rest of it.</p>
<p><strong>But the real fun begins moving to modern ideas.</strong>  So I put aside a copy as a historical version to keep as a Redbol test, but then started updating it to the new world...</p>
<h2>Rethought With UTF-8 and a Dialect</h2>
<p>When you take away the BLOCK! and start using the parts in the box, what you get is a lot more remarkable.</p>
<pre><code>=== LF: Line Feed (10) ===

◼◼◼▢▢
▢▢◼▢▢
▢▢◼▢▢
▢▢◼▢▢
◼◼◼◼◼
▢◼◼◼▢
▢▢◼▢▢

description: {
    On typewriters, printers, and some terminal emulators, moves the
    cursor down one row without affecting its column position. On Unix,
    used to mark end-of-line.
}
notes: {
    A spin on the carraige return which emphasizes the "downness" of
    a feed, but also with a horizontal suggestion of the current line
}
rating: good
</code></pre>
<p>It's much more interesting:</p>
<ul>
<li>
<p>UTF-8 means that we can use solid and hollow boxes to represent the bitmap.  They're legal characters in WORD!s, so instead of 7 TEXT!s the bitmap can be represented as 7 WORD!s and still be LOAD-able.</p>
</li>
<li>
<p>A section-divider can do double duty for the attributes.  A SET-WORD! becomes the shorthand, the name can be turned into regular WORD!s spanning up to a GROUP! that contains the codepoint.</p>
</li>
<li>
<p>There were multiple shorthands in some cases (e.g. 17, Device Control 1, can be known as DC1 or XON).  instead of a SET-WORD! like <strong>LF:</strong> that can be a SET-PATH!, like <strong>DC1/XON:</strong>.</p>
</li>
<li>
<p>Since it's a dialect, there's no need to put a tick mark on the rating of "good/fair/poor".</p>
</li>
</ul>
<h2>A Fluid Format that You Transform With UPARSE</h2>
<p>The first thing I did was to transform the new representation back to the old representation with UPARSE.  <a href="https://forum.rebol.info/t/collect-of-set-word-text-uparse-reduce/1712">I wrote about how it could be better if UPARSE had REDUCE</a>...</p>
<p>So it's not optimal, and we wouldn't need such a transformation step anyway if processing directly.  You'd use GATHER/EMIT.</p>
<p>But I'm pasting it here just to make the point that in just a couple of minutes I was able to have the old code up and running on the new format:</p>
<pre><code>override-list: parse load %uscii-5x7-english-c0.reb [
    collect some keep gather [
        '===
        emit abbreviation: [
            temp: set-word! (as text! temp)  ; e.g. `LF`
            |
            temp: set-path! (as block! temp)  ; e.g. `DC1/XON`
        ]
        emit name: form/ between &lt;here&gt; [emit code: subparse group! integer!]
        '===

        emit image: collect repeat 7 [w: word!, keep (as text! w)]

        maybe ['description:, emit description: text!]
        maybe ['notes:, emit notes: text!]
        maybe ['rating:, emit rating: word!]
    ]
] else [
    fail ["Could not parse %uscii-5x7-english-c0.reb"]
]
</code></pre>
<h2>IMO, This is Rebol's "Deep Lake"</h2>
<p>Breaking free of the JSON mindset and using the parts really makes this work:</p>
<p><a href="https://github.com/hostilefork/uscii/blob/master/uscii-5x7-english-c0.reb">https://github.com/hostilefork/uscii/blob/master/uscii-5x7-english-c0.reb</a></p>
<p>Revisiting this and the Whitespace interpreter are just really good examples of the form.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/uscii-seen-with-new-eyes/1713">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/uscii-seen-with-new-eyes/1713</link>
          <pubDate>Sun, 12 Sep 2021 13:15:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1713</guid>
          <source url="https://forum.rebol.info/t/uscii-seen-with-new-eyes/1713.rss">USCII Seen With New Eyes</source>
        </item>
        <item>
          <title>Boris&#39;s &quot;NEW-EACH&quot; Loop Dialecting Proposals</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Here are some ideas for what kinds of things you might put in a FOR-EACH variable block besides just words, and some other ideas:</p>
<p><a href="https://gitlab.com/hiiamboris/red-mezz-warehouse/-/blob/master/foreach-design.md" class="inline-onebox">foreach-design.md · master · hi i am boris / Red mezz warehouse · GitLab</a></p>
<p>It's definitely worth thinking about how to ask for the iteration counter automatically while iterating.  Or getting the position <em>and</em> the value somehow at once, instead of being forced to iterate by position and remember to say <code>pos.1</code> to get the value.  We've had some hare-brained schemes for that come down the pipe.</p>
<p>The simple idea of just asking for it in the vars spec feels pretty solid.  I'm not thrilled about the <strong>/var</strong> notation, but it's a desirable feature and certainly in reach:</p>
<pre><code>&gt;&gt; for-each [/i x y] [#a &lt;b&gt; #c &lt;d&gt; #e] [
       print [i x y]
   ]
1 #a &lt;b&gt;
2 #c &lt;d&gt;
3 #e
</code></pre>
<p>But some of the other proposals are a bit heavy, like a type constraint and then skipping out of iterations where the type doesn't match:</p>
<pre><code>&gt;&gt; for-each [/i x [text! group!] y] ["a" &lt;b&gt; #c &lt;d&gt; (e)] [
       print [i x y]
   ]
1 "a" &lt;b&gt;
3 (e)
</code></pre>
<p>The semantic combinatorics start to add up.  He says that the index keeps counting regardless of whether the iteration was skipped or not... but, is that obvious?</p>
<p>And isn't the following kind of clearer:</p>
<pre><code>&gt;&gt; for-each [/i x y] ["a" &lt;b&gt; #c &lt;d&gt; "e"] [
       match [text! group!] x else [continue]   
       print [index x y]
   ]
1 "a" &lt;b&gt;
3 (e)
</code></pre>
<h2>Things to Avoid: Overdesign, "Parts of Speech" Abuse</h2>
<p>I think we should be cautious about overdesigning such  core constructs.  (But certainly these things--whether you think they are monstrosities or not--are exactly the kind of thing that people are supposed to be empowered to make if it pleases them.  It's supposed to be a <em>personal</em> language, and you personalize it to the extent of your tastes.)</p>
<p>As we want to know the loop iteration you're on, maybe the better angle isn't to be abusing word decorations in such weird ways...but to use refinements as labels and then name the variable after it.  I wouldn't call the loop counter the "index" because the index is in the series position... so, /COUNTER or   /COUNT maybe?</p>
<pre><code>&gt;&gt; for-each [/count i x y] [#a &lt;b&gt; #c &lt;d&gt; #e] [
       print [i x y]
   ]
</code></pre>
<p>Commas would probably make it clearer, so good we have them:</p>
<pre><code>&gt;&gt; for-each [/count i, x y] [#a &lt;b&gt; #c &lt;d&gt; #e] [
       print [i x y]
   ]
</code></pre>
<p>You could get the series position with <strong>/here</strong>.  And <a class="mention" href="/u/blackattr">@BlackATTR</a> and <a class="mention" href="/u/gchiu">@gchiu</a> and I have talked about things like wanting to know if you were on the first or last iteration.  Well, why not <strong>/first?</strong> and <strong>/last?</strong></p>
<pre><code>&gt;&gt; for-each [/first? f, /last? l, x y] [#a &lt;b&gt; #c &lt;d&gt; #e] [
       print [f l x y]
   ]
true false #a &lt;b&gt;
false false #c &lt;d&gt;
false true #e
</code></pre>
<p>Some of these could apply to other loop forms like COUNT-UP I guess...</p>
<pre><code>&gt;&gt; count-up [/first? f, /last? l, x] 3 [print [f l x]]
true false 1
false false 2
false true 3
</code></pre>
<p>People who really want shorthands to say that "just a refinement means /count" could put a little preprocessor adapting the spec to the more verbose form.  But I'd rather use the verbose version.</p>
<h2>Generalized Generators Throw A Thorn in This</h2>
<p>In moving to a generalized FOR that runs over a generator, the values are being provided by something that gets called N times and returns answers.  The underlying pattern can be shown by the rewrite:</p>
<pre><code>&gt;&gt; for [/first? f, /last? l, x y] (each [#a &lt;b&gt; #c &lt;d&gt; #e]) [
       print [f l x y]
   ]
</code></pre>
<p>EACH is a generator.  And FOR is something that calls that generator N times.</p>
<p>But not all generators operate on series, some fabricate data out of thin air.  So they'd have no series position to answer /HERE with.  And while we can universally answer the "is this the first iteration" in the iteration construct itself, not all generators know if they're on the last time you're calling them...they provide data for each call until they return NULL.</p>
<p>So I guess the mechanics would have to be to try and request these as output parameters from the generator, and it either has them or it doesn't.  Yay for multi-returns, amiright?  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>But since the answers are coming from the generator you'd probably have to put your questions for it in front of the variable for the iteration # you are asking:</p>
<pre><code>&gt;&gt; for [/first? f, x, /last? l, y] (each [#a &lt;b&gt; #c &lt;d&gt; #e]) [
       print [f l x y]
   ]
</code></pre>
<p>This moves the LAST? question so it would ostensibly be grouped with the request for Y.</p>
<h2>Weird Thought... "FOR specs", like "FUNC specs"?</h2>
<p>It occurred to me like we might actually want to think about documenting these like specs.</p>
<pre><code>&gt;&gt; data: [#a &lt;b&gt; #c &lt;d&gt; #e]

&gt;&gt; for-each [
       /first? f [logic!]
       x [tag!] "Maybe document what this is for with a TEXT!?"
       /last? l [logic!]
       y [issue!] "Same here..."
   ] data [
       print [f l x y]
   ]
</code></pre>
<p>It could introduce concepts like <code>&lt;skip&gt;</code> able parameters.</p>
<p>Of course you wouldn't have to use such wacky things if you didn't want to, I'm just saying you could.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/boriss-new-each-loop-dialecting-proposals/1682">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/boriss-new-each-loop-dialecting-proposals/1682</link>
          <pubDate>Tue, 24 Aug 2021 04:53:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1682</guid>
          <source url="https://forum.rebol.info/t/boriss-new-each-loop-dialecting-proposals/1682.rss">Boris&#39;s &quot;NEW-EACH&quot; Loop Dialecting Proposals</source>
        </item>
        <item>
          <title>Isotopes and Divergence in Function Spec Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Right now we have a couple of dark alleys in the function spec dialect.</p>
<h2>"Divergence" (always throws, fails, etc....never returns)</h2>
<p>Today's vocabulary word is <a href="https://en.wikipedia.org/wiki/Divergence_(computer_science)">divergent functions</a>...when a function never returns a result in a "normal" way.</p>
<p>All functions that can FAIL or be THROWN or RETURN'd across have divergence as an <em>option</em> (which is, right now, all functions).  But it becomes an issue of what to say when there really is no type a function <em>ever</em> returns...what do you put in the spec?</p>
<p>Lately I've been using just <strong><code>[return: []]</code></strong>.  That might look perfect...by saying there's no types you can return, then any return would generate an error.</p>
<p>But Ren-C is complicated... you've got things like invisible functions, as well as BAD-WORD! isotopes.  And NULL which is a bit of a pickle too--<strong><a href="https://forum.rebol.info/t/revisiting-opt-in-the-func-spec-dialect/1658">I've written about revisiting <code>&lt;opt&gt;</code> in its own post.</a></strong></p>
<h2>What About Isotopes?</h2>
<p>If you say your function returns <strong>[bad-word!]</strong>, that doesn't cover isotope forms.</p>
<p>Right now, there's no type checking on isotopes.  Any function can return any isotope right now--they're outside of type checking.</p>
<p>We could narrow it down to just certain isotopes by putting them in the spec as BAD-WORD!s, like <strong>[integer! ~none~]</strong>...though there's no place to store a list of such isotopes at present :-/</p>
<p>Returning <strong>[ any-value!]</strong> is already pretty wordy.  Having to say <strong>[  any-value!]</strong> is a hassle.  The reasoning I had for letting any function return any isotope was that they're close enough to being errors anyway to a caller...so erroring in the type checking didn't serve that much of a point, for the wordiness.</p>
<h2>What About Invisibility?</h2>
<p>You can't say plain RETURN these days with no argument unless your function has <strong><code>&lt;invisible&gt;</code></strong> in the return spec (or if it has <strong><code>return: &lt;none&gt;</code></strong> which just ignores whatever you return anyway and gives back NONE).  That's another weird notational tic.</p>
<p>I just wanted to mention these issues.  No great answers right now, so we've just got the mediocre answers.  It's working, so...not the biggest priority.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/isotopes-and-divergence-in-function-spec-dialect/1667">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/isotopes-and-divergence-in-function-spec-dialect/1667</link>
          <pubDate>Mon, 16 Aug 2021 02:35:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1667</guid>
          <source url="https://forum.rebol.info/t/isotopes-and-divergence-in-function-spec-dialect/1667.rss">Isotopes and Divergence in Function Spec Dialect</source>
        </item>
        <item>
          <title>CLI Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>A long time ago, earl and I discussed the concept of making it so that a script's header would use something like the function spec dialect to define the command line arguments for a script.  So if you declared a refinement like <strong>/foo [integer!]</strong> that would be translated into something appropriate for your platform, like an argument to your script taken as <strong>--foo=3</strong> on Linux or <strong>/foo 3</strong> on Windows.  Or whatever.</p>
<p>Regular args would be required arguments, you'd get automatic help from the string descriptions in the spec, etc.</p>
<p>Red's Boris has done nearly exactly this...but he isn't putting a spec into the script header.  He has you make a function and then pass that function to a CLI dialect processor:</p>
<p><a href="https://gitlab.com/hiiamboris/red-cli/" class="inline-onebox">hi i am boris / CLI dialect for Red · GitLab</a></p>
<p>I do still like the aesthetics of putting it in the script header; it feels like a good place.  Though that would bake it in somewhat more...and introduces the question of what scope the arguments are in.  Would you have to say <strong>system.processed-args.foo</strong>, or would it be a globally scoped <strong>foo</strong> to the whole script?</p>
<p>And he mentions a good point of making this something you can apply to any function:</p>
<blockquote>
<p><em>"You can turn any Red function into a command line utility with one or two words. Suppose you have a <code>grep</code> function that is to be used from Red. Prefix it with <code>process-into</code>, add <code>print</code> for the output, compile it, and you have a <code>grep</code> utility!"</em></p>
</blockquote>
<p>That is worth thinking about.  You can say <strong>--do "..."</strong> on the command line to run arbitrary code, but what if you could specify a script name and say <strong>--function "func-name"</strong>, and have that function suddenly get its arguments from the command line?</p>
<p>If that sounds dumb compared to <strong>--do "func-name/refine arg1 arg2"</strong> just consider that sometimes you do want to integrate with the shell, and getting arguments spliced via the shell into such a --do string can be a mess.  It also can't be aliased into a single shell command.</p>
<p>Anyway, their experience with this is worth looking at, as it's something I've wanted for a while.  Whether there's a way of offering this in a script's header or not, I think I'm sold on the "you should be able to do it to any function if you want" angle.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/cli-dialect/1651">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/cli-dialect/1651</link>
          <pubDate>Sat, 07 Aug 2021 15:21:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1651</guid>
          <source url="https://forum.rebol.info/t/cli-dialect/1651.rss">CLI Dialect</source>
        </item>
        <item>
          <title>((Doubled Groups)) as a Dialecting Tool</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>In trying to get COMPOSE to lose /ONLY, there was a time when it looked for doubled groups.</p>
<pre><code>&gt;&gt; block: [a b c]

&gt;&gt; compose [(block) ((block))]
== [a b c [a b c]]
</code></pre>
<p>I liked it, and I said:</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="10" data-topic="979">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/the-superpowers-of-ren-cs-revamped-compose/979/10">The Superpowers of Ren-C's Revamped COMPOSE</a>
</div>
<blockquote>
<p>As a higher-level tool, it should cater to the higher-level needs...and that's not splicing unless you ask. I really believe this is the better behavior for people who are writing and reading the code.</p>
</blockquote>
</aside>
<p>But I found concerns:</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="10" data-topic="979">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/the-superpowers-of-ren-cs-revamped-compose/979/10">The Superpowers of Ren-C's Revamped COMPOSE</a>
</div>
<blockquote>
<p>One qualm I have about this is the visual difficulty of telling if something is a double-group if you are composing more than one item.</p>
<pre><code>&gt;&gt; compose [a b ((some code
         that goes on and on and) oh it ended there (maybe you start
         another group and
     eventually end)) d e]
</code></pre>
<p>That's <em>not</em> a splicing case because it's not a double group, but it kind of looks like one.</p>
</blockquote>
</aside>
<p>To be fair: it's hardly the only case where if you jump to conclusions on reading a few characters that you'll have problems because the code keeps going and may invalidate the assumptions you made by looking at those few characters.  But it still wasn't perfect.</p>
<p>...and as it turned out, it was another one of those "close but no cigar" cases of wanting to mark the intent of splice specially, but using a mechanism that's not as good as BLOCK! isotopes.</p>
<p><strong>I think that doubled-up-groups are a neat example of a dialecting concept, where you might want to give that significance.  It would certainly belong in the dialecting handbook (if we had one).</strong></p>
<p>But in the COMPOSE case, we have a better option... <strong>compose [... (spread block) ...]</strong> (or another operator of your choice that produces block isotopes).  And it's more fitting for the core, because it doesn't have the weakness mentioned above.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/doubled-groups-as-a-dialecting-tool/1893">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/doubled-groups-as-a-dialecting-tool/1893</link>
          <pubDate>Sun, 06 Jun 2021 02:54:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1893</guid>
          <source url="https://forum.rebol.info/t/doubled-groups-as-a-dialecting-tool/1893.rss">((Doubled Groups)) as a Dialecting Tool</source>
        </item>
        <item>
          <title>Idea: QUOTED! Data Means FOR =&gt; FOR-EACH</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>So I had another flash-o-inspiration.</p>
<pre><code>for x [1 thru 3] [
   print [x]
]
</code></pre>
<p>Gives you:</p>
<pre><code>1
2
3
</code></pre>
<p>But...</p>
<pre><code>for x @[1 thru 3] [
   print [x]
]
</code></pre>
<p>Leads to the second parameter to FOR being <strong>'[1 thru 3]</strong>  And that would give you:</p>
<pre><code>1
thru
3
</code></pre>
<p>And if you don't like how that looks, you could also use:</p>
<pre><code>for x each [1 thru 3] [
   print [x]
]

1
thru
3
</code></pre>
<p>In that case, EACH is making a generator function, so the second argument to FOR is an ACTION! that produces values until it produces a NULL which causes it to stop the FOR.</p>
<p>So I think that resolves that the base level of FOR and MAP is a dialect for generating values.  Anyone have ideas for this dialect and how it works besides me?  :-/  <sub>No, don't worry about it, I'll solve it.</sub></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/idea-quoted-data-means-for-for-each/1601">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/idea-quoted-data-means-for-for-each/1601</link>
          <pubDate>Wed, 12 May 2021 08:24:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1601</guid>
          <source url="https://forum.rebol.info/t/idea-quoted-data-means-for-for-each/1601.rss">Idea: QUOTED! Data Means FOR =&gt; FOR-EACH</source>
        </item>
        <item>
          <title>Revisiting The ZIP Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Vincent Ecuyer's <a href="http://www.rebol.org/view-script.r?script=rebzip.r">ZIP Dialect</a> is an example of tool in a domain that pretty much everyone knows and uses: zipping and unzipping files.</p>
<p>I'd thought its source code might be a good place to study the power of BINARY! parsing...until I realized how lacking binary parsing actually was in practice.  With UPARSE, I hope to attack those problems.  If so, then ZIP may yet become a showcase of how something like the zip file specification can become easily absorbed as usermode code.</p>
<p><strong>But another opportunity may come from making the ZIP dialect a tool people would actually want to use for its powers.</strong></p>
<p>It's already a little bit dialected.  When you pass it a block, you don't just specify filenames.  You can also give it literal blobs of BINARY! data, or URL!s to fetch.  This means you don't have to do calls to <code>curl</code> to get a temporary file, rename that file, and then pass the filename to a zip tool... the tool itself has smarts.</p>
<p>Here's what the options were in the original script:</p>
<pre><code>you can zip a single file:
    zip %new-zip.zip %my-file

a block of files:
    zip %new-zip.zip [%file-1.txt %file-2.exe]

a block of data (binary!/string!) and files:
    zip %new-zip.zip [%my-file "my data"]

a entire directory:
    zip/deep %new-zip.zip %my-directory/

from an url:
    zip %new-zip.zip ftp://192.168.1.10/my-file.txt

any combination of these:
    zip/deep %new-zip.zip  [
        %readme.txt "An example" 
        ftp://192.168.1.10/my-file.txt
        %my-directory
     ]
</code></pre>
<p>When you think of this being used alongside my demo of <a href="https://forum.rebol.info/t/using-ren-c-as-the-shell-in-github-actions/1547">steps in GitHub Actions</a> we could pack it up.  Here's a sketch of what that might look like:</p>
<pre><code> - uses: hostilefork/zip-github-action@v1
   output: new-zip.zip
   deep: true
   run: |
       %readme.txt "An example" 
       ftp://192.168.1.10/my-file.txt
       %my-directory
</code></pre>
<p>The ideal would be that there be a very easy way to make such a packaging for any given ACTION!.  You want to be able to get the non-dialect arguments and refinements split out from the body (the way the output filename and /DEEP is split out here).</p>
<h2>This Seems Like A Good Example to Try And Hone</h2>
<p>It doesn't really get any simpler than this.  So why don't we ask:</p>
<p><strong>Can we make the ZIP dialect something so compelling that anyone who wanted to make a ZIP file on GitHub Actions would be a fool not to use it, if it had a zero-effort usage pattern like the above?</strong></p>
<p>The dialect could take advantage of new parts in the box.  e.g. SET-BLOCK! if you want to use a different filename than what something has already:</p>
<pre><code>; Make a file in the zip called bar.txt, with contents of foo.txt
zip %output.zip [[%bar.txt]: %foo.txt]

; Make a file in the zip called foo.txt, with contents of foo.txt
zip %output.zip [%foo.txt]
</code></pre>
<p>Talking to <a class="mention" href="/u/blackattr">@BlackATTR</a> about it, I wondered if it's the kind of dialect where plain WORD!, PATH!, and TUPLE! should be interpreted as filenames, just to reduce the level of noise.  So <strong>readme.txt</strong> would be a legal alternative to <strong>%readme.txt</strong> and you would use GROUP!s to run code.  This introduces a lot of questions, <a href="https://forum.rebol.info/t/form-of-group-s-get-word-s/1543">but I've brought up the question elsewhere, e.g. with FORM</a>.</p>
<p>Playing along better with bash would be nice.  Maybe allow <strong>$ (some bash expression)</strong>?  I've got a post about a SHELL dialect I've been thinking about.</p>
<p>Anyway, if we can't do this, we probably can't do anything more complicated.  So it's time to start putting our code where our mouth is and seeing if this can actually make something anyone wanted to use.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/revisiting-the-zip-dialect/1548">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/revisiting-the-zip-dialect/1548</link>
          <pubDate>Wed, 10 Mar 2021 00:55:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1548</guid>
          <source url="https://forum.rebol.info/t/revisiting-the-zip-dialect/1548.rss">Revisiting The ZIP Dialect</source>
        </item>
        <item>
          <title>FORM of GROUP!s, GET-WORD!s...</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Trying to write shell code in Rebol, you notice that bash has a pretty strong advantage of putting together fragments of text with environment variables.</p>
<p>I think we'd have a leg up if there were a behavior in something that didn't reduce strings--like FORM--if it would make an exception for GROUP!s.</p>
<p>Historically you get something pretty useless:</p>
<pre><code>rebol2&gt;&gt; form [--sysroot (first [/foo /bar])]
== "--sysroot first /foo /bar"

red&gt;&gt; form [--sysroot (first [/foo /bar])]
 == "--sysroot first /foo /bar"
</code></pre>
<p>I don't see that helping a whole lot.  Evaluating the group would make more sense.</p>
<pre><code>&gt;&gt; form [--sysroot (first [/foo /bar])]
== "--sysroot /foo"
</code></pre>
<p>As an aside, I've always thought FORM is a weird name for this.  Maybe it needs a better name.</p>
<p>But whatever it is, I think we need something like it for putting together bash-like "sentences", without having to use so many quotes...because every character adds up:</p>
<pre><code>&gt;&gt; spaced [{--sysroot} (first ["/foo" "/bar"])]
== "--sysroot /foo"
</code></pre>
<p>I'll point out that having greater flexibility on what is a legal PATH!, permitting <strong>foo/bar/</strong> and <strong>/foo/</strong> etc. really is already helping a lot for common cases of writing shell-like scripts.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/form-of-group-s-get-word-s/1543">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/form-of-group-s-get-word-s/1543</link>
          <pubDate>Sun, 07 Mar 2021 03:50:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1543</guid>
          <source url="https://forum.rebol.info/t/form-of-group-s-get-word-s/1543.rss">FORM of GROUP!s, GET-WORD!s...</source>
        </item>
        <item>
          <title>Dissecting the ASSERT Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Another dialect to talk about while discussing the question of <a href="https://forum.rebol.info/t/pivotal-design-question-is-evaluator-state-just-a-block/1496">whether the evaluator can accrue state across evaluation steps</a> is ASSERT.</p>
<p>The idea of ASSERT is to let you put one expression after the other, and have it tested for "truthiness".</p>
<p><strong>ASSERT needs to do stepwise evaluation, test the result, and ideally report the expression that failed.</strong></p>
<h2>Historical Brittleness</h2>
<p>Since assert accepts multiple expressions, clipping it in the error makes sense so that you only see the expression that failed.</p>
<pre><code>&gt;&gt; assert [1 = 1 2 = 3 4 = 4]
** Script error: assertion failed for: [2 = 3]
</code></pre>
<p>So it has to copy the expression out to put in the error.  But for some reason, it only copies an arbitrary three items from the expression:</p>
<pre><code>r3-alpha&gt;&gt; assert [empty? first first [[[a]]]]  
** Script error: assertion failed for: [empty? first first]
</code></pre>
<p>This raises a number of questions about error reporting...as to whether this kind of copying makes sense in the first place, or if there should be some common services to help be more informative when providing the "near" information...to implicate the start of an expression instead of the end.</p>
<p>But as it's referring to the block, what if the block is modified?</p>
<pre><code>r3-alpha&gt;&gt; block: [not empty? clear block]

r3-alpha&gt;&gt; assert block
** Script error: assertion failed for: []
</code></pre>
<p>This is something Ren-C helps with, by locking the array during evaluation:</p>
<pre><code>ren-c &gt;&gt; block: [not empty? clear block]
== [not empty? clear block]

ren-c&gt;&gt; assert block
** Access Error: series has temporary read-only hold for iteration
** Where: clear evaluate while _ assert console
** Near: [*** empty? clear block **]
** Line: 1
</code></pre>
<h2>Invisibility in Ren-C</h2>
<p>A difference with Ren-C is that you can put an assert anywhere and it won't count against the evaluation:</p>
<pre><code> ren-c&gt;&gt; all [1 = 1, assert [2 = 2], 10 + 20]
 == 30

 ren-c&gt;&gt; any [1 = 2, assert [2 = 2], 10 + 20]
 == 30
</code></pre>
<p>R3-Alpha can't have it both ways...the behavior has to fall on the side of making assert return something either truthy or falsey:</p>
<pre><code>r3-alpha&gt;&gt; all [1 = 1 assert [2 = 2] 10 + 20] 
== 30  ; because the assert returned true

r3-alpha&gt;&gt; any [1 = 2 assert [2 = 2] 10 + 20]
== true  ; because the assert returned true
</code></pre>
<h2>Implementation Needs</h2>
<p>This gives an example of an abstraction that wants to be able to:</p>
<ul>
<li>record a position</li>
<li>perform an evaluation step</li>
<li>decide it doesn't like the evaluation result, and implicate the position it previously recorded</li>
</ul>
<p>I started the discussion about "state accumulation" with LET.  But let's talk about something like MACRO, which throws a more obvious wrench into this situation.</p>
<p>For instance, let's imagine:</p>
<pre><code>macroA: enfix macro [] [return [+ 2 =]]
macroB: macro [] [return [3 10 =]]

assert [1 macroA macroB 20]
</code></pre>
<p>The full expression being processed in practice would be <strong>assert [1 + 2 = 3 10 = 20]</strong> which should fail on the 10 = 20.</p>
<p>Here we have not just a desire to take single steps across a virtualized block, but also a desire to produce meaningful error messages.</p>
<p><strong>How to deal with this kind of situation?</strong>  We're in a position where we can probably get the evaluator to make the code work for a plain DO.  But when it comes to giving errors and single stepping, what parts are involved is not clear.  Is this something that should be forbidden, because the evaluator state is not entirely capturable in terms of the input block's positions?  If not forbidden, what sort of interface and mitigation would it need?</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/dissecting-the-assert-dialect/1508">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dissecting-the-assert-dialect/1508</link>
          <pubDate>Sun, 14 Feb 2021 21:28:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1508</guid>
          <source url="https://forum.rebol.info/t/dissecting-the-assert-dialect/1508.rss">Dissecting the ASSERT Dialect</source>
        </item>
        <item>
          <title>JS-EVAL and JS-DO</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p><em>(I knew I'd written this up but couldn't find it...the reason was because it was a git commit message, not a forum post.  Reprinting here.)</em></p>
<p>This is a fun usage of the new @-types, which lets you refer to Rebol values more easily in JS-DO and JS-EVAL expressions. By doing so you not only save on typing, but it finesses what would be hairy escaping situations if your only currency was text:</p>
<pre><code>&gt;&gt; text: { ykcirT" a s'tI}

&gt;&gt; js-eval [{reb.Spell("reverse",} @text {) + "String" + '"'}]
== {It's a "Tricky String"}
</code></pre>
<p>So what's going on there is it's generating a temporary API handle to refer to the value fetched from TEXT. This API handle is then used literally as one of the arguments to the variadic/evaluating<br>
extraction routines in the API (mixed here with some JavaScript <code>+</code> string concatenation). The variadic knows to free this handle after it is done processing it, (so it is like a reb.RELEASING() or reb.R()<br>
handle).</p>
<p>This is more powerful than just treating a block as running JS-EVAL UNSPACED [...]. But if you want that, you can still use a plain GROUP!:</p>
<pre><code>&gt;&gt; text: "gnirob"

&gt;&gt; js-eval [{"} (reverse text) { group"}]
== "boring group"
</code></pre>
<p>You can use <span class="mention">@path</span>/values, @(computed values). Although INTEGER! Rebol values aren't the best example (since you could pass them fine via their string representations), they'll work too <em>(just easier to demo in a PR than Blobs for BINARY! and such...)</em></p>
<pre><code>&gt;&gt; x: 1000
&gt;&gt; y: 20
&gt;&gt; js-eval [{reb.Unbox(} @(x + y) {)}]
== 1020
</code></pre>
<p>And to make things even more succinct, WORD!s in this dialect can be<br>
used to generate the reb.XXX() calls for you:</p>
<pre><code>&gt;&gt; x: 1000
&gt;&gt; js-eval [{20 +} unbox @x]
== 1020
</code></pre>
<p>Currently there's support for UNBOX and SPELL, but this could expand.</p>
<p>(Note: JS-DO and JS-EVAL are similar, except JS-EVAL tries to return a result to Rebol translated from the JavaScript it is given...and cannot declare variables in global scope. See technical notes in the implementation if interested.)</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/js-eval-and-js-do/1504">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/js-eval-and-js-do/1504</link>
          <pubDate>Fri, 12 Feb 2021 14:07:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1504</guid>
          <source url="https://forum.rebol.info/t/js-eval-and-js-do/1504.rss">JS-EVAL and JS-DO</source>
        </item>
        <item>
          <title>Dissecting the TLS EMIT Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>As we question <a href="https://forum.rebol.info/t/pivotal-design-question-is-evaluator-state-just-a-block/1496">what the rules are for evaluator state between steps</a>, it's instructive to look at dialects that make use of stepwise evaluation.</p>
<p>One such dialect that comes to mind is the EMIT dialect I designed to try and make the TLS protocol code leverage the language better.  It's used for constructing BINARY! packets by appending material together, where SET-WORD!s are made into variables holding positions in that binary packet based on where they occur:</p>
<pre><code>emit ctx [
  TLSPlaintext: ; https://tools.ietf.org/html/rfc5246#section-6.2.1
    #{16}                       ; protocol type (22=Handshake)
    min-ver-bytes               ; TLS version for ClientHello (min? max?)
  fragment-length:
    #{00 00}                    ; length of handshake data (updated after)
]
</code></pre>
<p>One thing the labels provide is documentation of what's at each position.  So even if they're not used, they are helpful.</p>
<p>But the positions also can be used for reading and writing the data.  Here we see some information being assembled at the start of the packet, which has a two-byte "fragment length".  We don't yet know what this length is, so it's filled in with zeros and patched later:</p>
<pre><code>change fragment-length enbin [be + 2] (length of Handshake)
</code></pre>
<h2>Note That This Is A Poster Child For Making EMIT "LET-like"</h2>
<p>The position variables are not aggregated in some kind of context or a map.  If they were, you would have to write it as:</p>
<pre><code>labels: emit ctx [
  TLSPlaintext: ; https://tools.ietf.org/html/rfc5246#section-6.2.1
    #{16}                       ; protocol type (22=Handshake)
    min-ver-bytes               ; TLS version for ClientHello (min? max?)
  fragment-length:
    #{00 00}                    ; length of handshake data (updated after)
]
...
change labels/fragment-length enbin [be + 2] (length of Handshake)
</code></pre>
<p><strong>I think that not having to be explicit is somewhat critical to the point.</strong>  So the EMIT abstraction could benefit from being "like LET" in that it wants to generate variable bindings you can use in the stream afterwards.</p>
<p>But at time of writing, it depends on being inside a "FUNCT"-style function which will "gather" the SET-WORD!s.  That means you'd be out of luck if you COMPOSE-d in the values, since FUNCT wouldn't see them.</p>
<p>I've made the case many times that having a 1:1 correspondence between SET-WORD!s and locals often gets you <em>too many</em> spurious locals.  But what about too few, if you miss other notations?  Let's say the designer wanted to call out the sections with BLOCK! instead?</p>
<pre><code>emit ctx [
  [TLSPlaintext] ; https://tools.ietf.org/html/rfc5246#section-6.2.1
    #{16}                       ; protocol type (22=Handshake)
    min-ver-bytes               ; TLS version for ClientHello (min? max?)
  [fragment-length]
    #{00 00}                    ; length of handshake data (updated after)
]
</code></pre>
<p>Or maybe SET-BLOCK! means "label and create variable" while plain SET-WORD! means "just label"?  Anyway, just raising the point that having functions like LET be able to create one or more new variables is powerful.</p>
<p><a href="https://forum.rebol.info/t/giving-functions-the-power-to-create-local-variables/1499">UPDATE: I have made EMIT create its own variables</a>, using a fledgling generic mechanism.</p>
<h2>Dissecting the Implementation</h2>
<p>The current EMIT is very comprehensible.  It does stepwise evaluation of the block:</p>
<ul>
<li>
<p>At the beginning of each step it looks to see if the value right in front of it is a SET-WORD!.  If it is, then it sets the value of that word to the marked position in the binary so far...and skips the SET-WORD! so it's not part of the evaluation.</p>
</li>
<li>
<p>For non-SET-WORD!s a single evaluation step is done, and the BINARY! result of it is added to the buffer.</p>
</li>
</ul>
<p>This is rigged in such a way that even supports comments and invisibles, such as ELIDE, ASSERT, and debug dump routines.</p>
<pre><code>emit: function [
    {Emits binary data, optionally marking positions with SET-WORD!}

    return: &lt;void&gt;
    ctx [object!]
    code [block!]
    &lt;local&gt; result
][
    while [code] [
        if set-word? code/1 [
            set code/1 tail ctx/msg  ; save position
            code: my next
        ]
        else [
            ; Keep evaluating so long as returned code pos is quoted, as
            ; it indicates invisible eval (`emit ctx [comment "X" ...]`)
            ;
            if until .not.quoted? [[code result]: evaluate code] [
                append ctx/msg ensure binary! result
            ]
        ]
    ]
]
</code></pre>
<h2>Observation: Only Sees SET-WORD!s At Start Of Step</h2>
<p>It only recognizes SET-WORD!s at the <em>start</em> of evaluation steps.  Any SET-WORD!s that are part of a function parameter won't count.</p>
<p>So imagine if min-ver-bytes took a parameter, e.g. <strong>min-ver-bytes: func [version]</strong></p>
<pre><code>emit ctx [
  TLSPlaintext:
    #{16}
    min-ver-bytes version: 1.2
  fragment-length:
    #{00 00}
]
</code></pre>
<p>So you wouldn't wind up with VERSION being set to a BINARY! position.  It would just be a normal assignment in the evaluator, and get 1.2</p>
<p>Curiously, LET wouldn't have this problem...because LET is invisible when followed by a SET-WORD!.  The set-word just gets a new binding.  But using LET for this wouldn't give you a definition outside of the block, only inside it:</p>
<pre><code>emit ctx [
  let TLSPlaintext:  ; only defined to end of block
    #{16}
    min-ver-bytes
  let fragment-length:  ; only defined to end of block
    #{00 00}
]
...
change fragment-length enbin [be + 2] (length of Handshake)  ; error
</code></pre>
<p>This is why EMIT has to take over the duty of LET, adding the new bindings to the frame itself.  <em>(It could choose to do so only if you say LET...thus allowing plain SET-WORD! to be just a comment...but it would not be running LET, just recognizing the word to help document that a new declaration was being created.)</em></p>
<h2>Every Step Must Produce A BINARY!...or be invisible</h2>
<p>The concept behind this is that all the steps either produce a BINARY!.  But you have the nice exception of invisible evaluations.</p>
<pre><code>emit ctx [
  let TLSPlaintext:
    #{16}
    elide prep-for-min-ver-bytes arg
    min-ver-bytes
  let fragment-length:
    #{00 00}
]
</code></pre>
<p>Historical Rebol could have let you do what you would do with invisibles with a GROUP!, you'd just have to put the things you wanted to throw away at the beginning of it:</p>
<pre><code>emit ctx [
  TLSPlaintext:
    #{16}
    (prep-for-min-ver-bytes arg, min-ver-bytes)  ; pretend they had comma
  fragment-length:
    #{00 00}
]
</code></pre>
<p>But this forces your dialect to sacrifice potential other uses for GROUP!s.</p>
<p>I think the general case of stepwise evaluation that tries to mix in its own behavior should want to gracefully handle invisibles.</p>
<h2>I Think TLS EMIT is a Very Good Example</h2>
<p>This is a useful thing.  While it would be ridiculous to bet your internet security on this particular TLS codebase, the methodology of this dialect shows promise for how to deal with other real problems.</p>
<p><strong>We do see that this case would work under the feed-based interface protocol of a variadic.</strong> That is to say, that if what EVALUATE did was spin up a FRAME!, and restrict you from going back in time...forcing you to look ahead one unit at a time and either consume or evaluate it, then it would still be fine.</p>
<p>I think that will be a pattern you will notice to be true in most "evaluator-compatible" dialects, that do not isolate their evaluation portions into GROUP!s or BLOCK!s.  If this pattern holds up, it suggests that allowing the evaluator to accrue state that is not purely representable in terms of a block position is reasonable.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/dissecting-the-tls-emit-dialect/1498">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dissecting-the-tls-emit-dialect/1498</link>
          <pubDate>Wed, 10 Feb 2021 10:56:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1498</guid>
          <source url="https://forum.rebol.info/t/dissecting-the-tls-emit-dialect/1498.rss">Dissecting the TLS EMIT Dialect</source>
        </item>
        <item>
          <title>Whitespace Interpreter Revisited</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>I came across what was near-to-one of my first Rebol programs (the first one using PARSE).</p>
<p>It was an interpreter for a language called "Whitespace", where all the instructions are made out of tab, space, and newline characters.  My idea was to use PARSE to actually evaluate the code:</p>
<p><a href="https://github.com/hostilefork/whitespacers/blob/master/rebol/whitespace.reb">https://github.com/hostilefork/whitespacers/blob/master/rebol/whitespace.reb</a></p>
<p>The idea of using parse as the interpreter is an interesting take...<strong>but the code is far too repetitive.</strong>  It was clearly written before I knew much about COMPOSE or really using the generative side of things.</p>
<h2>Ideas on Doing it "Right"?</h2>
<p>Currently there's a split between the specification and the implementation.  That might be desirable in some cases, but I don't think it's desirable here.</p>
<p>The instructions are grouped together, which lets them "inherit" their leading sequence.  For example, putting <strong>push [space Number]</strong> and <strong>duplicate-top [lf space]</strong> in "Stack-Manipulation" container lets them inherit the leading space common to each instruction.  Otherwise they'd have to be spelled out as <strong>[space space Number]</strong> and <strong>[space lf space]</strong>.</p>
<p>But beyond that, being inside a grouping pulls them out of "global scope", which means the instructions aren't overwriting the definitions of things like <strong>add</strong> and <strong>subtract</strong> with the whitespace versions.</p>
<h2>Reducing The Repetition</h2>
<p>The first thing I think of is merging the functions with the whitespace spec, and doing it more dialect-style:</p>
<pre><code>    ; The 2010 JavaScript-Like Way
    ...
push: [
	command: [space Number]
	description: {Push the number onto the stack}
]
duplicate-top: [
	command: [lf space]
	description: {Duplicate the top item on the stack}
]
    ...
push: func [value [integer!]] [
    insert stack value
    return none
]
duplicate-top: func [] [
    insert stack first stack
    return none
]
</code></pre>
<p>Being relatively liberal in syntax here, we can imagine doing this more like:</p>
<pre><code>; A Modern Dialected Way

push: ??? [
    {Push the number onto the stack}
    space (value &lt;number!&gt;)
][
    insert stack value
    return none
]

duplicate-top: ??? [
    {Duplicate the top item on the stack}
    lf space
][
    insert stack first stack
    return none
]
</code></pre>
<p>This is a little push in the right direction.  But we have some issues to think through.</p>
<ul>
<li>
<p>Whatever we're building here as units of the language need to be "registered" in the complete list of operations.  If they were global declarations run by the evaluator, then one of the things the <code>???</code> operator would have to do would be this registration.  If they are not global, then registration could be done by their container that is invoking them.</p>
</li>
<li>
<p>We still have to inherit the leading space that both of these instructions have.  An interesting point in the PARSE branching is that we benefit from having the knowledge that these all start with space, so that the space can lead into these tests as alternates...e.g. <strong><code>[space [lf space | space &lt;Number&gt;]]</code></strong> will be more efficient than <strong><code>[space lf space | space space &lt;Number&gt;]</code></strong>.</p>
</li>
<li>
<p>If we decide that the container is the boss, then giving a name to <code>???</code> is not really necessary.  But what happens if you leave it off?</p>
<pre><code>... Stack-Manipulation ... [
    push: [
        {Push the number onto the stack}
        space (value &lt;number!&gt;)
    ][
        insert stack value
        return none
     ]
     ...
 ]
</code></pre>
<p>This is a counterintuitive mixture of a SET-WORD! with two blocks after it. How do we reconcile the idea of "declaration-like-things" inside of a container like this?  The code needs to be in a block, the other things don't...so other notations are possible...</p>
<pre><code>... Stack-Manipulation ... [
    PUSH
    {Push the number onto the stack}
    space (value &lt;number!&gt;) [
        insert stack value
        return none
     ]
     ...
 ]
</code></pre>
</li>
</ul>
<p>I guess the easiest thing to do is to cave, and just come up with something for ???.  It has the benefit that you can actually run your implementation of Stack-Manipulation through the evaluator and do normal assignments.  So something like <strong>push: instruction [...] [...]</strong></p>
<p>Yet there's something a bit dissatisfying about having to type INSTRUCTION redundantly each time...where you're also kind of claiming that word so it can't be used other ways.</p>
<h2>Lots Of Other Questions...</h2>
<p>I think it would be worthwhile to rework this, but it's worth taking note of how adrift you can get right out of the gate looking at it.  There are lots of big questions that don't really have obvious answers.</p>
            <p><small>18 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/whitespace-interpreter-revisited/1482">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/whitespace-interpreter-revisited/1482</link>
          <pubDate>Sat, 30 Jan 2021 17:09:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1482</guid>
          <source url="https://forum.rebol.info/t/whitespace-interpreter-revisited/1482.rss">Whitespace Interpreter Revisited</source>
        </item>
        <item>
          <title>Function Escapable Literal Parameters... :X or &#39;:X ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <h2>Background with GROUP!s (prior to GET-GROUP! existing)</h2>
<p>Sometimes you don't pass a literal block of code to a conditional, but the callsite runs code that generates the branch--or fetches it out of a variable.</p>
<p>Historical Rebol has this behavior for GROUP!s in conditionals:</p>
<pre><code> rebol2&gt;&gt; branches: [[print "Apple"] [print "Banana"]]

 rebol2&gt;&gt; either false (print "one" take branches) (print "two" take branches)
 one
 two
 Banana
</code></pre>
<p>Doesn't seem ideal.  But having both groups run is the only choice you have if the branches are evaluative parameters.  The GROUP!s are evaluated before EITHER has a chance to say anything about it.</p>
<p>I pointed out that this was inconsistent with things like historical CASE:</p>
<pre><code> rebol2&gt;&gt; branches: [[print "Apple"] [print "Banana"]]

 rebol2&gt;&gt; case [
      false (print "one" take branches)
      true (print "two" take branches)
 ]
 two
 Apple
 == true  ; ignore silly `true` (Ren-C &amp; Red give PRINT's result)
</code></pre>
<h2>Ren-C Takes Branches Literally and Was Able To Sync This Up</h2>
<p>Ren-C had begun requiring branches be single literal values for other reasons, namely to give it access to the quote status of the argument:</p>
<pre><code>ren-c&gt;&gt; if true 'a
== a

ren-c&gt;&gt; if true '[a b c]
== [a b c]
</code></pre>
<p>So to provide code you'd have to put it in a group (unless it's a single variable, where you could use a GET-WORD! or GET-PATH!)  For technically fiddly reasons, it also means that <strong>if (...) else (...)</strong> is fully swappable with <strong>either (...) (...)</strong>  when they would not be quite exact replacements otherwise.</p>
<p><strong>So long as we're going this way, conditionals have the choice to see the GROUP! which would evaluate to produce a branch, yet decide not to run it.</strong>  There were enough <img src="https://forum.rebol.info/images/emoji/twitter/heart.png?v=9" title=":heart:" class="emoji" alt=":heart:"> clicked on the idea to support this, so that's what we have now:</p>
<pre><code> ren-c&gt;&gt; branches: [[print "Apple"] [print "Banana"]]

 ren-c&gt;&gt; either false (print "one" take branches) (print "two" take branches)
 two
 Apple
</code></pre>
<p>This goes further into the rabbit-hole of bending parameter conventions to suit the likely intent of usage.  But I think it's a good example of where it's worth it.  It's better than twisting around to get the reverse consistency...forcing CASE to run its GROUP!s regardless of the condition matching.</p>
<h2>Soft Literal Parameters vs. Hard Literal Parameters</h2>
<p>Rebol2 introduced the variations of "hard literal" as :X and "soft literal" as 'X.  Hard literals would always give you the callsite value literally...</p>
<pre><code>rebol2&gt;&gt; hard: func [:x] [print mold x]

rebol2&gt;&gt; var: 'foo

rebol2&gt;&gt; hard var
== var

rebol2&gt;&gt; hard :var
== :var

rebol2&gt;&gt; hard (first [foo bar])
== (first [foo bar])
</code></pre>
<p>Soft literals would make GET-WORD!, GET-PATH! evaluative...with everything else literally what was at the callsite:</p>
<pre><code>rebol2&gt;&gt; soft: func ['x] [print mold x]

rebol2&gt;&gt; var: 'foo

rebol2&gt;&gt; soft var
== var

rebol2&gt;&gt; soft :var
== foo

rebol2&gt;&gt; soft (first [foo bar])
== (first [foo bar])
</code></pre>
<p>R3-Alpha added a twist: that soft quotes would evaluate GROUP!s vs. taking them literally:</p>
<pre><code>r3-alpha&gt;&gt; soft (first [foo bar])
== foo
</code></pre>
<p>Two big points:</p>
<ul>
<li>
<p><strong>This looks backwards for :x and 'x</strong>.  Shouldn't it be that the thing with GET-WORD! in the parameter name is the one that's "colon-reactive"?</p>
</li>
<li>
<p><strong>The picture gets even more consistent if we use GET-GROUP! for the code escape</strong>.  Then all the quoting subversion is colon'd, and regular GROUP!s can go back to not being "soft" as in Rebol2.</p>
</li>
</ul>
<p>This makes the branch quoting example work with soft branches.  SO you get control if you want to get back to the "run the code whether you take the branch or not" situation:</p>
<pre><code> ren-c&gt;&gt; branches: [[print "Apple"] [print "Banana"]]

 ren-c&gt;&gt; either false :(print "one" take branches) :(print "two" take branches)
 one
 two
 Banana
</code></pre>
<p>I hope all the above makes sense.  <em>Please speak up if it does not make sense.</em></p>
<h2>So... Should Escapable Literals Be <code>:param</code> or <code>':param</code> ?</h2>
<p>One truism is that unless you have a very good reason to need to quote GET-WORD!s, GET-PATH!s, and GET-GROUP!s...your construct should permit escaping to make it easy for callsites to tunnel in what they want without resorting to APPLY.  This likely guided R3-Alpha to make escapability the default behavior for the common <code>'param</code> form.</p>
<p>So if we're asking people to default all literal parameter callsites to the escapable convention, then <strong>:param</strong> is nicer to look at than <strong>':param</strong>, even if the latter is "more communicative".</p>
<p>One factor to weigh would be if there were an interesting meaning for <strong>:param</strong> that didn't involve literalness.  Let's review the new escapable literal concept, and pretend for a moment we say it's a quoted get-word!:</p>
<pre><code> &gt;&gt; soft: func [':param] [print mold param]

 &gt;&gt; var: 'foo

 &gt;&gt; soft var
 == var

 &gt;&gt; soft :var
 == foo

 &gt;&gt; soft (first [foo bar])
 == (first [foo bar])

 &gt;&gt; soft :(first [foo bar])
 == foo
</code></pre>
<p>So is there any meaning for "plain escapable"?</p>
<pre><code> &gt;&gt; huh: func [:param] [print mold param]

 &gt;&gt; huh ... ?
</code></pre>
<p>Presumably this would similarly be an instruction to how :x, :x/y, and :(x y) are handled at the callsite.  But if you're not escaping the quoting, what <em>are</em> you escaping?</p>
<p>It would be silly to say you are "escaping evaluation":</p>
<pre><code> &gt;&gt; huh :(a)
 == a
</code></pre>
<p>That is done more cleanly with quoting, as a generic "escaping evaluation" tool for evaluative parameters...and doesn't raise questions about how to treat <strong>huh :(a b)</strong></p>
<pre><code>&gt;&gt; huh 'a
== a
</code></pre>
<p>There are some other choices for what it might mean, like "optional".  That's something that doesn't apply to literal parameters (because you can't get NULL literally).</p>
<pre><code>func [:arg [any-value!]] [...]  &lt;=&gt; func [arg [&lt;opt&gt; any-value!]]
</code></pre>
<p>I don't know that it makes a whole lot of sense.  And having a way to recognize NULL in-band in the type block is important:</p>
<pre><code> &gt;&gt; match [&lt;opt&gt; integer!] null then [print "This should run"]
 This should run
</code></pre>
<hr>
<h2>Brainstorm On One Aspect of Distinction</h2>
<p>So trying to make the change I tripped up on some edge cases, which suggests that for some functions they are more willing to let soft quoted sites come from the evaluation of more than one cell.</p>
<p>We might imagine for instance that <strong>':x</strong> or <strong>:x</strong> controls how enfix is handled.  Consider the following:</p>
<pre><code>&gt;&gt; integer! = type of 1
== #[true]

&gt;&gt; integer! = :(second [length type]) of 1
== #[true]
</code></pre>
<p>For OF, this is how you want the interaction to shake out when you are midstream in an enfix evaluation... <code>integer! = (type of 1)</code>.  But other constructs might want to consider an in-progress enfix something not to interrupt...and treat it like the left was more-or-less in a GET-GROUP!.</p>
<p>As an example, consider the <a href="https://forum.rebol.info/t/the-most-vexing-evaluation-lambda-meets-then-else/1361">most vexing evaluation</a>:</p>
<pre><code>&gt;&gt; if true [&lt;branch&gt;] then x -&gt; [print ["THEN" x]] else [print "ELSE"]
THEN &lt;branch&gt;

&gt;&gt; if false [&lt;branch&gt;] then x -&gt; [print ["THEN" x]] else [print "ELSE"]
ELSE
</code></pre>
<p>The THEN and ELSE branches want to see their argument literally, e.g. if it's quoted.  But it wants branches to be escapable (so you can use the GET-GROUP! to run the branch regardless), <em>and</em> it wants enfix to be able to overrule it.  That's different from the left argument for OF, which wants escapable literalness but does <em>not</em> want the enfix equality operator to win.</p>
<p>We might then say that <strong>':x</strong> is the strict form of "only one value on the left is inspected".  e.g. it is quoted, and <em>then</em> it is escaped.  Then <strong>:x</strong> could mean "it's accepted if it's already in mid-evaluation, otherwise it is quoted, then escaped".</p>
<p>So <strong>:x</strong> would be saying <em>"I don't out-prioritize enfix"</em> while <strong>':x</strong> says <em>"I beat enfix just as 'x would, but then the escaping is automatic so you don't have to do it inside your function body"</em>.</p>
<p>Continuing the thought experiement...you'd have SOFT</p>
<pre><code>&gt;&gt; soft: func [:x] [print [mold x], 10]

&gt;&gt; soft add 1 2
add
== 2  ; (soft add) 1 2

&gt;&gt; soft 1 + 2
3
== 10  ; soft (1 + 2)

&gt;&gt; soft :(1 + 2)
3
== 10 
</code></pre>
<p>Then MEDIUM</p>
<pre><code>&gt;&gt; medium: func [':x] [print [mold x], 10]

&gt;&gt; medium add 1 2
add
== 2  ; (medium add) 1 2

&gt;&gt; medium 1 + 2
1
== 12  ; (medium 1) + 2

&gt;&gt; medium :(1 + 2)
3
== 10

&gt;&gt; medium (1 + 2)
(1 + 2)
== 10
</code></pre>
<p>And HARD would be as you expect, always exactly the callsite parameter.</p>
<p><em>While I'm admittedly a bit wary of super complex parameter conventions, I also like having full coverage of the potential desires.</em>  What worries me a little is that this feels like the "tight" parameter convention coming up again...though it's backwards and maybe a little more logical, saying the only places you can ask for looseness is in parameters that are "weird" by virtue of quoting.  While it's late and I don't really have a full articulation of why this is more coherent... I think it likely is.</p>
<p>But...mucking with the code and seeing impact across the system in the tests is the way to test that theory.</p>
<hr>
<h2>Bonus Question... what might <strong>:[get blocks]</strong> do with escaping?</h2>
<p>It seems that if GET-WORD!, GET-PATH!, and GET-GROUP! evaluate for <strong>:SOFT</strong> parameters, then there might be some kind of magic for GET-BLOCK!s.</p>
<pre><code>&gt;&gt; soft :[what's this for?]
== ???
</code></pre>
<p>Even if we can't think of anything right now, I'd think they should error to reserve for future use (vs. pass the GET-BLOCK! through as if it were any other type).  Or just to keep from seeming inconsistent.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/function-escapable-literal-parameters-x-or-x/1433">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/function-escapable-literal-parameters-x-or-x/1433</link>
          <pubDate>Sun, 13 Dec 2020 02:08:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1433</guid>
          <source url="https://forum.rebol.info/t/function-escapable-literal-parameters-x-or-x/1433.rss">Function Escapable Literal Parameters... :X or &#39;:X ?</source>
        </item>
        <item>
          <title>Design Issues for New APPLY</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <blockquote>
<p><strong>UPDATE 2021/2022:</strong> <a href="https://forum.rebol.info/t/apply-ii-the-revenge/1834">These issues are now all solved: <strong>APPLY II, The Revenge!</strong></a></p>
<p>And we don't have to worry about APPLY taking its function argument quoted.  Because if you want it to look clean, you don't want the word APPLY in there at all.  This is now the behavior of terminal slash paths!</p>
<pre><code>  append/ [series value /dup 2]
</code></pre>
<p>In any case--APPLY does not quote, and "Worldview <span class="hashtag">#1</span>" below is the winner.</p>
</blockquote>
<h2>First Big Question: Quote The Function or Not?</h2>
<p>This has been on my mind since the beginning: <em>should you have to use a GET-WORD! to name the function to apply, or does it quote by default...and make you put code fragments that returns a function in a group</em>.</p>
<pre><code> ; Worldview #1
 apply :append [series value /dup 2]
 apply second reduce [:insert :append] [series value /dup 2]  ; will APPLY :APPEND

 ; Worldview #2
 apply append [series value /dup 2]
 apply :append [series value /dup 2]  ; still legal if you want
 apply (second reduce [:insert :append]) [series value /dup 2]  ; GROUP! required
</code></pre>
<p>We have at least some relief at not having to consider Worldview <span class="hashtag">#3</span>, of <code>apply 'append [series value]</code> so APPLY can capture the name "append" for debug stack purposes.  That's not needed because <code>:append</code> gets an ACTION! that carries the label in its cell.  <a href="https://forum.rebol.info/t/more-comprehensible-errors-with-per-cell-labeling/1357">This has been a change that punches above its weight.</a></p>
<p>In the beginning I would have said it <em>definitely</em> has to go with Worldview <span class="hashtag">#1</span>, because in the second case you don't get a clear signal that APPEND is not being called on [SERIES VALUE /DUP 2] and the result being passed to APPLY.  If you didn't see the apply or were otherwise distracted, your reading comprehension would be thrown off by breaking from convention.</p>
<p>Over time I've become more of a believer that the whole premise of the language is to let you bend constructs to predominate use, so the 99% case is pleasing to use.  The now famous case of OF's left-quote, for instance:</p>
<pre><code>type: 'type of x  ; without OF quoting

type: type of x  ; with OF quoting
</code></pre>
<p>The quote mark makes it clearer, but when OF becomes so common that you "just know" then it's a much more pleasing function to use.  How many times do you use OF with a reflector you pick via code?  When is that code a single-arity function you wouldn't have to put in a GROUP! to use with enfix anyway??!</p>
<p>But does that same philosophy to APPLY, that we come to read <strong>apply append</strong> as one indivisible unit, and feel thankful for not having to reach for the colon key?  It's a little bit different than OF because you read left to right, and you can start reading at the APPEND with no speedbump after it.</p>
<p>I'll stress that you would still have the choice.  If you were the type of person who thought it clearer to use the colon, you could do so.  You just wouldn't be able to invoke a function-to-generate-the-function unless you put that in a GROUP!.</p>
<p><em>I can't make up my mind.</em>  So I think I'm going to make the answer Worldview 1.5:</p>
<pre><code> ; Worldview 1.5
 &gt;&gt; apply second reduce [:insert :append] [series value]
 ** Error: APPLY arguments must be GET-WORD! or GROUP! at the moment
</code></pre>
<p>This leaves the door open to interpreting plain WORD! as naming a function in the future.  And it gives time for people to find a really compelling case for where not being able to generate a function without using a GROUP! would be a deal-breaker.</p>
<h2>Naming Refinements</h2>
<p>Historical APPLY had a nasty positional nature for refinements, which led to things like this, from the R3-Alpha module code:</p>
<pre><code>return map-each [mod ver sum name] source [
    apply :load-module [
        mod true? ver ver true? sum sum no-share no-lib import true? name name delay
    ]
]
</code></pre>
<p>You see the combination of <code>true? ver</code> followed by <code>ver</code> as filling in first the refinement slot for /VERSION, and then the value of the refinement argument.</p>
<p>Then you see "used or not" refinements being supplied to their argument cells by the value alone (<code>no-share</code> signaling not to provide /SHARE, <code>no-lib</code> signaling not to use /LIB)</p>
<p><strong>But we can now put refinement names in the APPLY dialect!</strong></p>
<pre><code>apply :load-module [
    mod /version ver /sum sum
        /share null /lib null  ; avoids need for "clarifying" `no-share: false`
        /import import /name name
        /delay delay
]
</code></pre>
<p>You might ask what was stopping that before.  The issue was that historical Rebol had the problem that if you had an argument that could take on any value...including NONE!...then NONE! could not be used to represent the state of the refinement itself.</p>
<p>(Imagine if you are specifying an initial value to fill a block with (as in ARRAY/INITIAL).  It may be important to distinguish putting a NONE! in vs. not having a default at all.)</p>
<p>This is solved in Ren-C by reserving the non-valued NULL state for "refinement not taken".</p>
<blockquote>
<p>Note: I'd gone back and forth a while over whether a REFINEMENT-like PATH! would be appropriate to use in this dialect, based on the question of whether they would be evaluator-active or not.  Ideas were floated around like <code>foo</code> would fetch a variable but be an error if it was NULL, while <code>/foo</code> would fetch a variable and allow NULL.</p>
<p>In the end, inertness for refinements won out.  BLANK!-headed PATH!s and TUPLE!s simply have more dialecting power if they don't overlap what could be a legitimate user intention to fetch variables.  This APPLY situation shows a good example of why inertness is good.)*</p>
<p>Also, if you want to literally pass a refinement value you can do so.  Just quote it:</p>
<pre><code>   apply :whatever [/refinement '/refinement]
</code></pre>
<p>That will pass /REFINEMENT as the refinement parameter.</p>
</blockquote>
<h2>Providing Normal Arguments By Name</h2>
<p>A neat feature of new APPLY will be not only that you can reorder refinements to put them in any position, but also that you can name normal arguments.</p>
<p>So things like this would be legal:</p>
<pre><code>&gt;&gt; apply :append [/dup 2, /value &lt;d&gt;, [a b c]]
== [a b c &lt;d&gt; &lt;d&gt;]
</code></pre>
<p>Everything is streamlined by the idea that refinements represent one (and only one) argument in the frame.  <em>Which has been a critical and elegance-making change.</em></p>
<p>The concept is that ordered parameters which have not yet been named would be filled in, in the order that they are supplied.  You wouldn't be able to specify something twice, so this would be an error:</p>
<pre><code>&gt;&gt; apply :append [/series [a b c], [d e f], &lt;g&gt;]
** Error: Duplicate argument supplied for SERIES
</code></pre>
<h2>Can LOGIC! Be Used With Parameterless-Refinements?</h2>
<p>I have belabored the point of why we don't want low-level FRAME! mechanics getting involved in <a href="https://forum.rebol.info/t/should-refinement-arguments-be-refinement-if-used/735/4">transforming <code>[#[true] #[false]]</code> into <code>[# null]</code></a> for refinements that are "either used or not".</p>
<p>Those rules don't really "apply" here.  APPLY is its own dialect with its own mechanics, and it can do what's convenient.  It can canonize true and false into # and NULL in the frame.</p>
<pre><code>foo: func [/usable /logicable [logic!]] [...]

apply :foo [/usable 1 &lt; 2, /logicable 1 &lt; 2]
; this would give usable of `#`, and logicable of `#[true]`

apply :foo [/usable 1 &gt; 2, /logicable 1 &gt; 2]
; this would give usable of NULL, and logicable of `#[false]`
</code></pre>
<p>Hopefully it makes sense why I think APPLY should be able to do this, while MAKE FRAME! and friends don't.  MAKE FRAME! is the tool for writing <em>APPLY-like-things</em>, and there's no layer between the frame and the evaluator where it's appropriate to put these transformations.  It should be kept pure.</p>
<h2>Should You Be <em>Able</em> to Provide Refinements By Position?</h2>
<p>I'm not sure if giving refinements by position is a great idea.  But this hits on a philosophical question of whether refinements have an order that is exposed to the user.</p>
<p><em>But specialization can shuffle the order.</em>  For instance, what was once a refinement can become a normal argument.</p>
<pre><code>&gt;&gt; foo: func [x [integer!] /refine1 [integer!] /refine2 [integer!]] [...]

&gt;&gt; parameters of :foo
== [x /refine1 /refine2]  ; one normal argument

&gt;&gt; foo-2: :foo/refine2
== [x refine2 /refine1]  ; two normal arguments (e.g. acts like FOO/REFINE2)
</code></pre>
<p>This makes things a bit wacky.</p>
<p>I feel like the safest decision for right now is to say that once you've filled all the ordered arguments, any more arguments in the APPLY with no label causes an error.  The place where this would cause issues would be if BLOCK!s are used to serialize and deserialize frame state generically.  That's a thorny problem in general, which brings us to...</p>
<h2>Should There Be An APPLY/ONLY</h2>
<p>The idea behind APPLY/ONLY was that you have the values for a function's arguments already processed, and you don't want to evaluate them again.</p>
<p>One thing that breaks APPLY/ONLY in Ren-C's world is that this doesn't give a way to supply NULL arguments.  One option would be to let the BAD-WORD! with label <code>~null~</code> be an escape mechanism for this, which might cover a lot of cases (though obviously not accurately capturing a frame that purposefully wanted to pass the ~null~ BAD-WORD!).</p>
<p><em>Because FRAME!s have come along as a general and pure tool for representing function applications, the pressure is taken off of APPLY to be all things to all people.</em>  I think it should start out as the handy evaluative form, and then wait for motivating scenarios before trying to bend to anything else.  Maybe another operator entirely would be more suitable, or just using FRAME! as it is.</p>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/design-issues-for-new-apply/1406">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/design-issues-for-new-apply/1406</link>
          <pubDate>Thu, 19 Nov 2020 11:11:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1406</guid>
          <source url="https://forum.rebol.info/t/design-issues-for-new-apply/1406.rss">Design Issues for New APPLY</source>
        </item>
        <item>
          <title>The Dialecting Power of NewPath /REF/(INE)/[MENT]</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p><em>(Note: I have been calling <strong>/FOO/BAR</strong> a "refinement", so <strong>refinement? '/foo/bar</strong> is true)</em></p>
<hr>
<p>For a long while, I was hesitant to commit <strong><code>/foo</code></strong> to being inert, because I wondered if there was some greater meaning for it in binding.</p>
<p>But now I'm resigned to it.  Which gives a somewhat interesting result: a whole category of bound dialecting parts that you know <em>aren't</em> meant as variable references.</p>
<p>We already see how well this works with TUPLE! and predicates.  If they weren't inert, you'd have to worry that <strong>until .not.even? [...]</strong> should be interpreted as <strong>(until .not.even?), ([...])</strong></p>
<h2>What Cool Role Could Refinements Have?</h2>
<p>The original suggestion for predicates actually used refinements.  But <strong>until /not/even? [...]</strong> didn't seem to be as good, so tuple was used.</p>
<p>But is there a good use at callsites?</p>
<p>Something I observed today was that <strong><code>/(...)</code></strong> and <strong><code>/[...]</code></strong> open up a new GROUP! and BLOCK! type, at the very least.  What might this mean in PARSE, and could it be connected to a meaning for words like <strong>/rule</strong> or <strong>/obj/member</strong> ?</p>
<p>The only connotation refinements have right now is "optionality" and...<em>parameter-ness</em>?  The optionality could be one focus:</p>
<pre><code>&gt;&gt; did parse [a c] ['a /['b] 'c]  ; synonym for `opt ['b]`
== #[true]

rule: ['b]
&gt;&gt; did parse [a c] ['a /rule 'c]  ; synonym for `opt rule`
== #[true]
</code></pre>
<p>That's not compelling, clearly.  But I'm just trying to stimulate thoughts on what it might be used for.</p>
<p>Perhaps it could be the "matches literally, not as a rule" concept?</p>
<pre><code>&gt;&gt; data: [some integer!]

&gt;&gt; parse [[some integer!] [some integer!]] [2 /data]
== [[some integer!] [some integer!]]
</code></pre>
<p>This could build conceptually on the "more inert" form (as opposed to an active rule).  Though I kind of liked the "as-is" connotation of <span class="mention">@data</span>.  But perhaps this would be easier on the eyes.</p>
<p><em>This points out something I hadn't thought about...</em> that refinements could have been used for other signals:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c d e]

&gt;&gt; append [a b c] /[d e]
== [a b c [d e]]

&gt;&gt; append [a b c] '/[d e]
== [a b c /[d e]]

&gt;&gt; data: [d e]
&gt;&gt; append [a b c] /data
== [a b c [d e]]
</code></pre>
<p>I had a vague inkling that it might be used in blaming function parameters:</p>
<pre><code>&gt;&gt; foo: func [x] [fail /x "Pointing at problem"]

 &gt;&gt; foo 10
** Error: Pointing at problem
** Where: foo console
** Near: [foo 10 **]  ; note it indicates callsite, not the FAIL site
</code></pre>
<p>That sort of makes sense, because /FOO is likely to be used in the apply dialect to name parameters.  So this could be seen as better than <strong><code>fail @foo</code></strong>.  What makes me a little uncomfortable with it is that paths and URLs will be legal as the error ID, so having a "slashed thing" might seem repetitive in a way that the @ would not.</p>
<p><em>This is just a brainstorm pointing out the existence of an available new-old-type.</em>  I'd be interested to hear any ideas or feelings on what PARSE might do with it...</p>
<h2>Then...What About GET and SET Forms?</h2>
<p>There's four assignment forms to deal with:</p>
<ul>
<li><strong><code>.foo.bar:</code></strong></li>
<li><strong><code>:.foo.bar</code></strong></li>
<li><strong><code>/foo/bar:</code></strong></li>
<li><strong><code>:/foo/bar</code></strong></li>
</ul>
<p>What would these be for?</p>
<p>I've proposed terminal slash and dot be a commentary on whether the thing being gotten or assigned is allowed to be an action or not.  Though that seems to make <strong>:foo.bar.</strong> and <strong>foo.bar.</strong> synonymous, as the GET only has impact on actions...and you're assuring it's not one.</p>
<p>Just more stuff to think about.  My suggestion for anything that doesn't have an interesting novel answer yet is to just make it error...to save it for meaning something in the future.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-dialecting-power-of-newpath-ref-ine-ment/1401">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-dialecting-power-of-newpath-ref-ine-ment/1401</link>
          <pubDate>Fri, 13 Nov 2020 11:35:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1401</guid>
          <source url="https://forum.rebol.info/t/the-dialecting-power-of-newpath-ref-ine-ment/1401.rss">The Dialecting Power of NewPath /REF/(INE)/[MENT]</source>
        </item>
        <item>
          <title>MAKE-FILE and %% Unleashed: Time To Use It</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>There's a lot that isn't known about how NewPath files are going to work.  But I'm at the point where I think enough is known that it's time to start using it and get to pushing on its development.</p>
<p>This is the basic gist of the idea, showing the prototype MAKE-FILE and the <a href="https://forum.rebol.info/t/the-newpath-finesse-make-file-lit/1386">quoting shorthand <strong>%%</strong></a></p>
<pre><code>&gt;&gt; extension: "txt"
&gt;&gt; dir: %/home/test/

&gt;&gt; make-file '(dir)/subdir/foo.(extension)
== %/home/test/subdir/foo.txt

&gt;&gt; %% (dir)/subdir/foo.(extension)
== %/home/test/subdir/foo.txt
</code></pre>
<p>It completely replaces the <em>extremely sketchy</em> historical "pathing" of a FILE! to produce a new FILE!:</p>
<pre><code>&gt;&gt; dir: %/home/test

&gt;&gt; dir/subdir/foo  ; cases like this give no hint that it's a file
== %/home/test/subdir/foo
</code></pre>
<p>It's bad for all sorts of reasons--like that you don't really know what <strong>dir/2</strong> should do (does it give the <code>#h</code> character, or <code>%/home/test/2</code> ?).  The slash handling mechanics were ad hoc, adding more variability to the process instead of more certainty.</p>
<p>Now it will be an error, and good riddance.</p>
<h2>Structure Means More Checks Possible</h2>
<p>The hope of MAKE-FILE is not just to provide a representation that's nice to look at, but also one that can help you avoid mistakes that aren't caught by normal string operations.</p>
<p>For example:</p>
<pre><code>&gt;&gt; extension: "txt/bad"

&gt;&gt; %% a/b.(extension)
** Error: Embedded / encountered inside filename component: "txt/bad"
</code></pre>
<p>There is no mechanism for silent tolerance of doubled slashes.  Instead, situations that generate doubled slashes are called out:</p>
<pre><code>&gt;&gt; base: %/home/test/

&gt;&gt; %% [(base) /subdir]
** Error: Doubled / encountered while generating filename: /subdir
</code></pre>
<p>The code is a very rough prototype, <strong>and the reason I want to push forward on it is that I want other people involved in designing it</strong>.  Or at least throwing more situations at it so that we can figure out what protections offer good value propositions vs. just getting in the way.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/make-file-and-unleashed-time-to-use-it/1398">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/make-file-and-unleashed-time-to-use-it/1398</link>
          <pubDate>Thu, 12 Nov 2020 09:23:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1398</guid>
          <source url="https://forum.rebol.info/t/make-file-and-unleashed-time-to-use-it/1398.rss">MAKE-FILE and %% Unleashed: Time To Use It</source>
        </item>
  </channel>
</rss>

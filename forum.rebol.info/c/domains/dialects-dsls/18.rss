<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Dialects/DSLs - AltRebol</title>
    <link>https://forum.rebol.info/c/domains/dialects-dsls/18</link>
    <description>Topics in the &#39;Dialects/DSLs&#39; category Discussion focused on the creation of dialects and DSLs using Rebol. Rebmu talk is appropriate here.</description>
    
      <lastBuildDate>Tue, 08 Oct 2024 17:59:30 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/domains/dialects-dsls/18.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Dialecting Function Calls: New, Weird, Powerful</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>The advent of the <a href="https://forum.rebol.info/t/introducingnew-chain-datatype/2226">CHAIN! datatype</a> has provoked the idea of <em>dialecting function calls themselves</em>.</p>
<p>I've given examples like pointing the variable to blame for a failure...because you often don't really want an error message to implicate the location where the error itself is raised, but rather some callsite arbitrarily far up the stack.</p>
<p>The proposal I had for this was to change:</p>
<pre><code>fail:blame ["This failure will implicate VAR at callsite"] $var
</code></pre>
<p>Into:</p>
<pre><code>fail:$var ["This failure will implicate VAR at callsite"]
</code></pre>
<p>Another idea I mentioned was the concept of folding the function you want to use as a predicate into the chain.  At first I suggested allowing these names to conflate with what looked like a refinement:</p>
<pre><code>&gt;&gt; any:even? [1 3 8 7 10]
== 8
</code></pre>
<p>The rationalizing I used was to say "Well, in dialects we have cases where if a keyword isn't recognized then it falls back to looking up the word."   That's how PARSE works... like in this historical case:</p>
<pre><code>red&gt;&gt; begin: "[" end: "]"
== "]"

red&gt;&gt; parse "[aaa]" [begin copy stuff to end skip]
== false
</code></pre>
<p>Er, so maybe I should say "that's how PARSE doesn't work".  In any case, the END keyword overrode the END variable definition.  But BEGIN matched, because there's no parse keyword for BEGIN.</p>
<p><em>(Note: This is a reason why Ren-C uses <strong><code>&lt;end&gt;</code></strong> the tag combinator instead of END the word combinator...and other tag combinators for noun-like things.)</em></p>
<p>So maybe it's not the best plan to follow the lead there.  Another idea would be to use a TYPE-WORD!</p>
<pre><code>&gt;&gt; any:&amp;even? [1 3 8 7 10]
== 8
</code></pre>
<p>It's a little clunkier, but it's clearer what's going on.  In this case, the predicate is a single arity function which returns NULL or OKAY...and that's what ANY wants, so it's a particularly good match.</p>
<p>That also works for my suggestion of <strong><code>quote:&amp;word?</code></strong> and <strong><code>meta:&amp;raised?</code></strong>.  Though it implies that if you composed them together you'd have to say <strong><code>quote:&amp;quote:&amp;word?</code></strong>, and it doesn't look as good as <strong><code>quote:quote:word?</code></strong></p>
<p>Also...in this case the predicate is a single arity function that returns a logic.  But other cases aren't, and wouldn't make sense to use <code>&amp;</code>.  What about them?</p>
<h2><a name="p-7835-is-conflation-stupid-or-outside-the-box-genius-1" class="anchor" href="https://forum.rebol.info#p-7835-is-conflation-stupid-or-outside-the-box-genius-1"></a>Is Conflation Stupid, Or Outside-The-Box Genius?</h2>
<p>I can't really tell if allowing you to write the likes of <strong><code>any:even?</code></strong> and proceeding blissfully along outweighs the missing "conscious marker" of why EVEN? wouldn't be any refinement you can find on the HELP for ANY.</p>
<p>Part of me thinks "that's the way this game is played".  Another part of me is thinking about how the system wouldn't know what to do with this.  How would the system know how to specialize that, and put EVEN? into the :PREDICATE slot?  Would <strong><code>any:even?/</code></strong> just throw up its hands and error?  For that matter, does <strong><code>any:&amp;even?/</code></strong> really get any easier?</p>
<p><strong>I guess that aspect of "it doesn't get any easier either way" suggests we have room to experiment and see how it feels.</strong></p>
<p>Actions would have to have some kind of "Interpret Chain" hook that would go from CHAIN! =&gt; FRAME!.  Because this is likely to be performance sensitive, the system should offer some kind of parameterization of the default hook (e.g. "if you don't recognize anything from the spec, fetch it and throw it into parameter named XXX" or "if you see something with a certain sigil, fetch it and throw it into a parameter named YYY")</p>
<p>I guess I'd like to try living in the <strong><code>any:even?</code></strong> and <strong><code>meta:raised?</code></strong> universe a bit and get a bit more informed before making the stupid vs. genius verdict.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/dialecting-function-calls-new-weird-powerful/2310">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dialecting-function-calls-new-weird-powerful/2310</link>
          <pubDate>Tue, 08 Oct 2024 17:59:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2310</guid>
          <source url="https://forum.rebol.info/t/dialecting-function-calls-new-weird-powerful/2310.rss">Dialecting Function Calls: New, Weird, Powerful</source>
        </item>
        <item>
          <title>ENVELOP (and COMPOSE!) By Example</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Prior to splices, we were considering rethinking <strong>append/only [a b c] [d e]</strong> as <strong>append [a b c] only [d e]</strong>, where ONLY would just envelop its argument in a block.</p>
<p><a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> didn't care for the name:</p>
<aside class="quote no-group" data-username="rgchris" data-post="1" data-topic="1873">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/48/14_2.png" class="avatar"><a href="https://forum.rebol.info/t/1873/1">On another topic</a></div>
<blockquote>
<p>Correct me if I'm wrong, but this proposed ONLY function would simply create a single value cell with the block reference, which would seem pretty efficient.</p>
<p>It'd be very easy to shim:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">only: func [value][
    reduce [value]
]
</code></pre>
<p>I'm still fond of ENVELOP over BLOCKIFY as a name. I don't think ONLY would make the cut. Naming is tricky as it is sort of a hackâ€”it's purpose is to make a block a singular value but in actuality it is creating a new value of which the old one just happens to be the only content.</p>
</blockquote>
</aside>
<p>As it happens, ONLY defined in this way stuck around for a while.  (I actually thought it had been deleted, but it turns out it was hiding as **<code>only*</code>, so just finally deleted it now!)</p>
<p>I agree that ENVELOP is a better and more useful name for the category of operations.  Today we have ENBLOCK and ENGROUP:</p>
<pre><code>&gt;&gt; enblock [a b c]
== [[a b c]]

&gt;&gt; enblock &lt;tag&gt;
== [&lt;tag&gt;]

&gt;&gt; engroup [a b c]
== ([a b c])

&gt;&gt; engroup &lt;tag&gt;
== (&lt;tag&gt;)
</code></pre>
<p>But there's no generalized ENVELOP.</p>
<h2><a name="p-7757-envelop-by-example-seems-like-an-important-construct-1" class="anchor" href="https://forum.rebol.info#p-7757-envelop-by-example-seems-like-an-important-construct-1"></a>"Envelop by Example" Seems Like an Important Construct</h2>
<pre><code>&gt;&gt; something: 1020

&gt;&gt; word: 'something  ; demo behavior when unbound (binding from context)

&gt;&gt; envelop '[] word
== [something]

&gt;&gt; envelop '() word
== (something)

&gt;&gt; envelop '@[] word  ; would work with sigil-decorated types
== @[something]

&gt;&gt; envelop '(()) word  ; could work with nested envelopes
== ((something))
</code></pre>
<p>There's a big advantage in passing in a block or group "by example".  It means you can implicitly pass along a binding, which can be integrated in the same step...if that's what you want.  (The modern art of writing Ren-C code requires a lot of consciousness about the decision to use bound or unbound material.)</p>
<pre><code>&gt;&gt; eval envelop '(()) word  ; quoting means no binding
** Error: something not defined

&gt;&gt; eval envelop $(()) word  ; if binding passed in, it's used
== 1020
</code></pre>
<p>ENVELOP might even support <a href="https://forum.rebol.info/t/synthetic-asymmetric-delimiters/1893">Synthetic Asymmetric Delimiters</a></p>
<pre><code>&gt;&gt; envelop '(| |) word
== (| something |)

&gt;&gt; envelop '(|) word  ; shorthand--assume paired?
== (| something |)

&gt;&gt; envelop '(&lt;*&gt;) word  ; maybe not assume, for COMPOSE marker compatibility
== (&lt;*&gt; something)
</code></pre>
<h2><a name="p-7757-engroup-and-enblock-still-useful-2" class="anchor" href="https://forum.rebol.info#p-7757-engroup-and-enblock-still-useful-2"></a>ENGROUP and ENBLOCK Still Useful</h2>
<p>I do think that ENGROUP and ENBLOCK as specializations of ENVELOP turn out to be what you'll use at least 90% of the time...so they're worth having around.</p>
<p>But as arity-1 functions, the returned block or group would be unbound at its tip.  So you'd have to use the ENVELOP-by-example to pass in a binding.</p>
<h2><a name="p-7757-this-overlaps-the-morph-proposalhttpsforumrebolinfotsetify-plainify-getify-symify-or-morph1334-somewhat-3" class="anchor" href="https://forum.rebol.info#p-7757-this-overlaps-the-morph-proposalhttpsforumrebolinfotsetify-plainify-getify-symify-or-morph1334-somewhat-3"></a>This Overlaps <a href="https://forum.rebol.info/t/setify-plainify-getify-symify-or-morph/1334">the MORPH Proposal</a> Somewhat</h2>
<p>MORPH has the ability to change the decorations on the value you're passing in, whereas ENVELOP would assume you wanted the item as-is, just enclosed in some other stuff.</p>
<p>My instinct is to say that this takes the pressure off MORPH to be all things to all people... vs. the idea that we don't need ENVELOP and it should just become a subfeature of morph.  But I dunno.</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/envelop-and-compose-by-example/2294">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/envelop-and-compose-by-example/2294</link>
          <pubDate>Mon, 23 Sep 2024 12:43:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2294</guid>
          <source url="https://forum.rebol.info/t/envelop-and-compose-by-example/2294.rss">ENVELOP (and COMPOSE!) By Example</source>
        </item>
        <item>
          <title>DEFAULT as Dialect?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Flipping through the entirety of Carl's old Rebol blog, I came across a surprising post in which he considers <a href="https://www.rebol.com/article/0388.html">a trick for implementing DEFAULT using left-quoting in Rebol2</a>.</p>
<p>While it's very odd that there were ways to hack that in, I found myself more curious about the alternative proposal... to have DEFAULT work as a dialect.</p>
<pre><code> x: y: default [10 + 20]  ; can't set X
 default [x: y: 10 + 20]  ; dialect can offer handling of leading SET-WORD!s
</code></pre>
<p>This isn't a situation like comparing <strong>let x: 10</strong> and <strong>let [x: 10]</strong>.  LET doesn't need the block, so you get something inherently messier.  But because the nature of DEFAULT requires the block to suppress evaluation in the case that it doesn't need to do the defaulting, you have it either way. <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<pre><code>  &gt;&gt; x: null
  &gt;&gt; y: &lt;something&gt;

  &gt;&gt; default [x: y: 10 + 20]
  == ???  ; by convention, what's the answer?

  &gt;&gt; x
  == 30

  &gt;&gt; y
  == &lt;something&gt;
</code></pre>
<p>It's a bit of a problem on what the return result would be, and it's a bit misleading because you see on the screen [x: y: 10 + 20] but you get back something where after that <code>x &lt;&gt; y</code>.</p>
<p>I think I'm going to have to go with thinking that the current way is better.  But again, I was a bit surprised to see the Rebol2 backwards-quoting-hack.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/default-as-dialect/2198">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/default-as-dialect/2198</link>
          <pubDate>Tue, 20 Aug 2024 12:47:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2198</guid>
          <source url="https://forum.rebol.info/t/default-as-dialect/2198.rss">DEFAULT as Dialect?</source>
        </item>
        <item>
          <title>hiiamboris&#39;s WITH</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>I've mentioned that binding might be helped by a dialect, and it turns out there is some precedent in <strong><a href="https://codeberg.org/hiiamboris/red-common/src/branch/master/with.red">hiiamboris's WITH</a></strong>:</p>
<blockquote>
<h3>USAGE SUMMARY</h3>
<pre><code>with x  [..]          == bind [..] x
with 'x [..]          == bind [..] 'x
with :fun [..]        == bind [..] :fun
with [:fun] [..]      == bind [..] :fun
with [x y 'z] [..]    == bind bind bind [..] 'z y x
with [x: 1 y: 2] [..] == bind [..] context [x: 1 y: 2]
</code></pre>
<h3>EXAMPLES</h3>
<h4>omit the path to an object, but work inside it's context:</h4>
<pre><code>do with face/parent/pane/1 [
    color: red
    text: mold color
    visible?: yes
]

if true with system/view/fonts [print [serif size]]

f: func [/- /+ /*] [        ;-- redefines important globals locally
    (do something with local flags)
    foreach x [set..] with system/words [
        (do something with global * + -)
    ]
]
</code></pre>
<h4>create static storage for functions where existing literal forms don't allow you to:</h4>
<pre><code>factorial: func [x] with [cache: make hash! [0 1]] [
    any [
        select/skip cache x 2
        put cache x x * factorial x - 1
    ]
]
</code></pre>
<h4>anonymize words used during initialization of the program:</h4>
<pre><code>first item in the block should be of set-word! type

do with [x: 1 y: 2] [
    z: x * y
    ... other code that uses x or y ...
]
</code></pre>
<h4>bind a block to multiple contexts at once (in the list order):</h4>
<p>First item in the block should be of word!/get-word!, path!/get-path! or lit-word! type</p>
<ol>
<li>
<p>words and paths values are fetched, while lit-words are converted into words<br>
get-words and get-paths should be used for function context, otherwise they get evaluated</p>
</li>
<li>
<p>if resulting value is a context, block is bound to it<br>
if resulting value is a word, block is bound to the context of this word</p>
<p>the following example illustrates usage of words and lit-words:</p>
<pre><code>a: b: x: y: none
c: context [
    a: 1
    b: 2
    f: func [x y] [
       ; calls `with` internally
       print composite [self 'x] "a=(a) b=(b) x*y=(x * y)"
       ; equivalent
       print composite [self :f] "a=(a) b=(b) x*y=(x * y)"
    ]
]
</code></pre>
</li>
</ol>
<p>Thus, <code>with [c]</code> is equivalent to <code>with c</code>, while <code>with ['c]</code> - to <code>with 'c</code>.</p>
<h3>WHY IS IT DESIGNED LIKE THIS?</h3>
<ol>
<li>
<p>It does not evaluate</p>
<p><code>with</code> does not evaluate the block, so:</p>
<ul>
<li>it can be used after <code>context</code>s, <code>if</code>s, <code>loop</code>s, <code>func</code>s, etc.</li>
<li>it can be chained <code>with x with y ...</code></li>
</ul>
<p>I've found that this makes code much more readable than it would be with <code>bind</code>.<br>
Prefix it with <code>do</code> if you want immediate evaluation.</p>
</li>
<li>
<p>It accepts blocks</p>
<p>Design question here was - if we allow block! for <code>ctx</code>, how should we treat it?</p>
<ul>
<li>
<p>convert it to a context? <code>ctx: context ctx</code></p>
<p>that shortens the <code>with context [locals...] [code]</code> idiom</p>
</li>
<li>
<p>list multiple contexts in a block as a sequence and bind to each one?</p>
<p>that shortens <code>with this with that [code]</code> idiom</p>
</li>
</ul>
<p>Personally, I've used the 1st at least a few times, but 2nd - never, though I admit there are use cases.<br>
This can be solved by checking type of the 1st item in the block is a set-word or not <img src="https://forum.rebol.info/images/emoji/twitter/wink.png?v=12" title=":wink:" class="emoji" alt=":wink:" loading="lazy" width="20" height="20"><br>
But still ambiguous! When <code>with</code> gets a <code>word!</code> argument it can:</p>
<ul>
<li>get the value of this word, which should be an <code>object!</code>, and bind to this object</li>
<li>get the context of this word, and bind to this context</li>
</ul>
<p>When inside a context, 2nd option is nice:</p>
<pre><code>context [
    a: 1
    f: func [x y] [
        with [self x] [x * y * a]
    ]
 ]
</code></pre>
<p>..where the alternative would be:</p>
<pre><code>context [
    a: 1
    f: func [x y] [
        with context? 'x with self [x * y * a]
    ]
]
</code></pre>
<p>When outside of it, 1st option is better:</p>
<pre><code>x: context [x: 10]
y: context [y: 20]
do with [x y] [x * y]
</code></pre>
<p>..where the alternative would be:</p>
<pre><code>x: context [x: 10]
y: context [y: 20]
do with in x 'x with in y 'y [x * y]
</code></pre>
<p>But this still can be solved: let <code>word!</code>s evaluate to contexts and <code>lit-word!</code>s, same as we have <code>bind code ctx</code> vs <code>bind code 'ctx</code>:</p>
<pre><code>context [
    a: 1
    f: func [x y] [
        with [self 'x] [x * y * a]
    ]
]

x: context [x: 10]
y: context [y: 20]
do with [x y] [x * y]
</code></pre>
</li>
</ol>
</blockquote>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/hiiamboriss-with/2138">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/hiiamboriss-with/2138</link>
          <pubDate>Tue, 30 Jan 2024 21:14:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2138</guid>
          <source url="https://forum.rebol.info/t/hiiamboriss-with/2138.rss">hiiamboris&#39;s WITH</source>
        </item>
        <item>
          <title>Case-Insensitivity And Dialecting</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Today's Ren-C uses case-sensitive binding.  The topic has been discussed a lot:</p>
<p><a href="https://forum.rebol.info/t/case-insensitivity-vs-case-preservation-cant-have-both/1439" class="inline-onebox">Case Insensitivity vs. Case-Preservation (can't have both?)</a></p>
<p>As a discipline, we still are trying to keep the language lowercase, in the standard library at least.</p>
<p>But one thing that hasn't been discussed much is how case could be used creatively in dialects, when you know the case doesn't matter.  I think that in certain domains, use of case in dialects could be an interesting tool.</p>
<h2>
<a name="using-casing-to-imply-uppercase-lowercase-as-is-case-1" class="anchor" href="https://forum.rebol.info#using-casing-to-imply-uppercase-lowercase-as-is-case-1"></a>Using Casing To Imply Uppercase, Lowercase, As-Is Case</h2>
<p>I've written a little about how the <a href="https://forum.rebol.info/t/usefulness-of-string-interpolation/2114">CScape interpolation tool</a> does casing.  That's strings and not ordinary code.</p>
<p>The case logic would work in ordinary code something like this:</p>
<pre><code>&gt;&gt; strings: ["aBc" "dEf" "gHi]

&gt;&gt; cased-print ["For instance:" STRINGS.1 strings.2 Strings.3]
For instance: ABC def gHi
</code></pre>
<p>It might seem silly, but in CScape it turns out to be pretty useful to do that.</p>
<h2>
<a name="non-case-related-example-hardening-bindings-2" class="anchor" href="https://forum.rebol.info#non-case-related-example-hardening-bindings-2"></a>Non-Case-Related Example: "Hardening" Bindings</h2>
<p>We have an issue now that sometimes when you are composing material you want bindings to "stick".  Here we want LET and PASSTHRU to be bound to the same environment as the block given to the COMPOSE (which propagates to the GROUP!s, and then to the blocks evaluated in the groups).  But we want RETURN to be unbound, and pick up its binding from the site where it is composed:</p>
<pre><code> compose [
     (in [] 'let) (name): (in [] 'passthru) :return
 ]
</code></pre>
<p>There could be some dialect options for this... a special signal, maybe something you pass:</p>
<pre><code>compose/harden [
    &lt;hard&gt; let (name): &lt;hard&gt; passthru :return
] &lt;hard&gt;

compose/harden [
    %h let (name): %h passthru :return
] %h

compose/harden [
    $ let (name): $ passthru :return
] $
</code></pre>
<p>Since you have groups available, you could get the literal of the thing you're hardening with, e.g. with <code>(&lt;hard&gt;)</code> or <code>(%h)</code> or <code>($)</code></p>
<p>And of course, you could have an operation that reverses this...so that things were hardened by default but you escaped to leave them unbound.</p>
<p>But... a weirder idea... what if you used something like the case?</p>
<pre><code> weird-compose [
     LET (unbind name): PASSTHRU :return
 ]
</code></pre>
<p>Important to remember is that symbols don't have case.  So you can't use the trick for everything.</p>
<p>But I present this in juxtaposition to using even the most minimal signal (like $) just to show how much the comprehensibility can benefit.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/case-insensitivity-and-dialecting/2123">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/case-insensitivity-and-dialecting/2123</link>
          <pubDate>Wed, 17 Jan 2024 22:33:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2123</guid>
          <source url="https://forum.rebol.info/t/case-insensitivity-and-dialecting/2123.rss">Case-Insensitivity And Dialecting</source>
        </item>
        <item>
          <title>A (Lame) Hole-Punch Motivating Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <blockquote>
<p><em>Referenced in the explanation of <a href="https://forum.rebol.info/t/what-dialects-need-from-binding/2111/11">"What Dialects Need From Binding"</a></em></p>
<p><em><strong>This code uses hypothetical mechanisms for a new approach to pure virtual binding that are not yet implemented at time of writing.</strong></em></p>
</blockquote>
<hr>
<p>Let's imagine you have the idea of a dialect which validates the number of some characters in a string.  You give it a list of strings and you match using "keywords" ONE or TWO for the character at hand.  You can also run code in groups if you want:</p>
<pre><code>&gt;&gt; dialect ["aaaa" "bbbb"] [
       [#a [one two one (print "rule one match")]]
       [#b [two one one (print "passed 2 1 1") one (print "rule two match")]]
   ]
  rule one match
  passed 2 1 1
</code></pre>
<p>Now imagine a callsite that wants to use this dialect.  Let's say it has its own definition for what TWO means just incidentally defined.  But it knows the dialect's meaning should override that.  However let's say it also has some MESSAGE, that it doesn't want the dialect to override.</p>
<p>Let's also throw in COLLECT for good measure:</p>
<pre><code> let two: lambda [body] [repeat 2 body]  ; some incidental definition

 let message: "passed 2 1 1"  ; intended to be seen by the dialect

 let results: collect [
      dialect ["aaaa" "bbbb"] [
           [#a [one two one (keep &lt;finished a&gt;)]]
           [#b [two one one (print message) one (keep &lt;finished b&gt;)]]
       ]
 ]
</code></pre>
<p>The caller and DIALECT have a common understanding: that ONE and TWO are things that the dialect provides.  But it's the dialect's responsibility to sort that out.  Even though the tip of the block it receives has a definition for TWO, it shouldn't be influenced by that...because all the ONE and TWO are unbound inside that block.</p>
<p>Now say the plan of attack that the author has is to build upon the PARSE dialect to implement what they're doing.  It seems plausible they should be able to do the following:</p>
<pre><code> dialect: func [strings [block!] lines [block!]] [
     for-each line lines [
        line: in lines line
        let char: line.1
        let rule: in line line.2
        let string: strings.1
        do compose/deep [
            let one: (char)
            let two: [repeat 2 (char)]
            parse (string) [comment "your code here" (unuse [one two] rule)]
        ]
        strings: next strings
     ]
 ]
</code></pre>
<p>In more detail:</p>
<ul>
<li>
<p>Propagating with IN LINES and IN LINE means that RULE gets the binding of the original LINES block, which is the aggregated chain of bindings (from LIB for things like PRINT, for the LETs, for KEEP).  But it also has that definition of TWO.</p>
</li>
<li>
<p>We want RULE to come out of this as a BLOCK!, not boxed into a function, as PARSE intends to enumerate it.. as well as to be able to DO GROUP!s inside it.</p>
</li>
<li>
<p>We don't want to have to make a copy of that aggregated binding (e.g. an entire copy of LIB to remove any ONE and TWO, and a copy of all the other contexts to remove ONE and TWO).  Beyond inefficiency, we don't want to explode the number of binding environment identities.  Instead, we need an additive means to say <em>"I want everything <em>but</em> ONE and TWO from this binding environment"</em>.  Sort of a <a href="https://hypirion.com/musings/understanding-persistent-vector-pt-1">"persistent-vector"</a> approach.</p>
</li>
<li>
<p>This is what I call a hole-punching instruction... that becomes the new specifier for the embedded rule, pointing at the specifier of rule as a parent.  Later on during the DO of the composed code... when PARSE descends into the block and uses IN, that's where the hole-punched binding is "coalesced" with available definitions of ONE and TWO from PARSE's "current environment" (which it propagated off second parameter it received).</p>
</li>
</ul>
<p>There are many other ways to accomplish this intent--and this particular example does suck (it inadvertently exposes all the features of PARSE even if it didn't want to...among other criticisms).  But I maintain this implementation strategy is analogous to real situations that come up, vs. some imagined thing.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/a-lame-hole-punch-motivating-dialect/2116">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/a-lame-hole-punch-motivating-dialect/2116</link>
          <pubDate>Sat, 13 Jan 2024 07:39:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2116</guid>
          <source url="https://forum.rebol.info/t/a-lame-hole-punch-motivating-dialect/2116.rss">A (Lame) Hole-Punch Motivating Dialect</source>
        </item>
        <item>
          <title>Discouraging Semantics for COMMA! in Dialects</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Today I consider <a href="https://forum.rebol.info/t/the-language-worlds-weirdest-comma-mechanic/1387">COMMA! to be an indispensible addition to the language</a>.</p>
<p>But something that feels like a Rebol philosophy point is that we should strongly discourage the idea of commas having semantic meaning in dialects.  The status quo should be that they just provide visual separation.</p>
<p>In this mindset, the only impact adding a comma should have on code would be an error if they're not put in an "interstitial" position.  If you want a grouping to have semantic meaning, then a BLOCK! or GROUP! should be used... or perhaps a vertical bar |.</p>
<p>I think giving this guidance helps preserve Rebol's natural language stream aesthetic, where the kinds of problems mandatory commas introduce can be avoided.  Whether you are doing things at source level or in code generation, having N entries needing (N - 1) commas can be an annoyance.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/discouraging-semantics-for-comma-in-dialects/2042">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/discouraging-semantics-for-comma-in-dialects/2042</link>
          <pubDate>Wed, 26 Jul 2023 16:30:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2042</guid>
          <source url="https://forum.rebol.info/t/discouraging-semantics-for-comma-in-dialects/2042.rss">Discouraging Semantics for COMMA! in Dialects</source>
        </item>
        <item>
          <title>Dialecting With Quasiforms</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>In the list of potential ideas of the long forgotten past, there was a thought that strings would come in two forms... one that was compared case-sensitively, and another that was not.</p>
<p>The visual look of the case-insensitive form was suggested as having a leading tilde, as one representation.</p>
<pre><code>&gt;&gt; "a" = ~"A"
== #[true]
</code></pre>
<p>No one really went to bat for the idea or thought through its ramifications.  It wasn't particularly easy to test what that would be like.</p>
<h2>Quasiforms Make The Proposal Easier To Test</h2>
<p>We now basically have the implementation guts needed to where we could consider the bits passed on the value.  It even has a decent name:</p>
<pre><code>&gt;&gt; quasi "A"
== ~"A"~

 &gt;&gt; "a" = "A"
 == #[false]

 &gt;&gt; "a" = quasi "A"
 == #[true]
</code></pre>
<p>The principle meaning of a quasiform is as the ^META of an isotope form.  And what this would mean is, there's no such thing as a differentiation between an isotopic case-sensitive word/string and an isotopic case-insensitive word/string.</p>
<h2>I Don't Think I Like It, BUT...</h2>
<p>Regardless of me not liking it, it's a possibility for dialects.  If you wanted to mark some strings for case-insensitivity you have another option in the box.</p>
<p>The reason I don't like it is because the isotope and quasi forms are supposed to stand out and draw attention to weirdness.  This is too common an application.  And it would mean your case-insensitive forms would be evaluating to isotopes everywhere, unless the quasiform evaluation changed in some way to make quasi-strings inert.  This isn't in line with what I want to do.</p>
<p>But...your dialect can do it.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/dialecting-with-quasiforms/1960">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dialecting-with-quasiforms/1960</link>
          <pubDate>Mon, 05 Sep 2022 08:16:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1960</guid>
          <source url="https://forum.rebol.info/t/dialecting-with-quasiforms/1960.rss">Dialecting With Quasiforms</source>
        </item>
        <item>
          <title>Scheduler Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>I thought of the scheduler dialect today that DocKimbel had made, and went and looked it up.</p>
<p>This is something that should be able to run as-is in Ren-C under Redbol emulation--so I'll see what I can do about that.  But it would also be interesting to see what kinds of improvements could be made to it with a Ren-C specific version.</p>
<aside class="onebox githubgist">
  <header class="source">
      <a href="https://gist.github.com/greggirwin/63471784ace61153763f465c3ea37c98" target="_blank" rel="noopener">gist.github.com</a>
  </header>
  <article class="onebox-body">
    <h4><a href="https://gist.github.com/greggirwin/63471784ace61153763f465c3ea37c98" target="_blank" rel="noopener">https://gist.github.com/greggirwin/63471784ace61153763f465c3ea37c98</a></h4>
<h5>scheduler.r</h5>
<pre><code class="Rebol">REBOL [
	Title: "Scheduler"
	File: %scheduler.r
	Purpose: "Dialected task scheduling library"
	Author: ["SOFTINNOV / Nenad Rakocevic" "Pointillistic / Gregg Irwin"]
	Copyright: ["2009 SOFTINNOV" "2013 SOFTINNOV/POINTILLISTIC"]
	Email: [nr@softinnov.com gregg@pointillistic.com]
	Date: 28-Oct-2013
	Version: 0.9.5
	License: "BSD - see %LICENCE.txt file"</code></pre>
This file has been truncated. <a href="https://gist.github.com/greggirwin/63471784ace61153763f465c3ea37c98" target="_blank" rel="noopener">show original</a>

<p>
</p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/scheduler-dialect/1957">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/scheduler-dialect/1957</link>
          <pubDate>Sat, 03 Sep 2022 07:40:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1957</guid>
          <source url="https://forum.rebol.info/t/scheduler-dialect/1957.rss">Scheduler Dialect</source>
        </item>
        <item>
          <title>What&#39;s Cool (According to Danny)</title>
          <dc:creator><![CDATA[Danny]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Photos are nice. complex. but some how easy to understand most of the time without having to know the "who, what, when, where, and why." Just by looking at them, you can kinda tell what it's trying to show you. I want Rebol coding to look like that while working with any data context in its original form as possible.</p>
<blockquote>
<p>**<br>
var {whats-cool 0: Brett}<br>
Var Rebdol: {Rebdol cool: "what's-cool"}**</p>
</blockquote>
<p>The <a href="http://www.rebol.org/view-script.r?script=rebol-dom.r" rel="noopener nofollow ugc">%Rebol-dom.r</a> Var is named from the associated value strings/words, unless you *!, select-all-fetch-as strings/words. Then you can, Rebdol."cool" -&gt;select &amp; load "what's-cool". Wich is, whats-cool: { 0: Brett}. Then .[0], and  you get Brett.</p>
<p>Or change the *value to Ren-C. **</p>
<blockquote>
<p>whats-cool [ /rebdol.cool.&amp;.0 = Ren-C] <em>messy, noisy example</em><br>
**</p>
</blockquote>
<p>Is this musing when the origonal data context does'nt need to be changed. And if parsed into a Dialect Object Model, without changing syntax, this data can be searched, updated with DOM functions.</p>
<p>Creating Vars out of molded data/code with foreign syntax, is its own Sequence built notation.</p>
<blockquote>
<pre><code>struct: :Var

 struct qwerty {
                   Int #1
                   Char "hello"
                   Float 9.0
                   Char "there"
                } *! 'qwerty

*variable: "request" new[qwerty]
</code></pre>
</blockquote>
<p>This data looks like and can be used to construct *New nodes that can run as code without creating defined functions but remain as sequence(molded) data that needs no bindings or loading to take place.</p>
<p>I hope this is musing, for others as it is for me. Rebol-dom.r Sequence/molded data, strings as *keys have context all without loading anything but the *value. It's what i found and fished out of that Deep Lake.</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/whats-cool-according-to-danny/1906">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/whats-cool-according-to-danny/1906</link>
          <pubDate>Fri, 29 Jul 2022 23:42:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1906</guid>
          <source url="https://forum.rebol.info/t/whats-cool-according-to-danny/1906.rss">What&#39;s Cool (According to Danny)</source>
        </item>
        <item>
          <title>FIND treats TYPESET!s specially...why not functions?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>In Rebol2, R3-Alpha, and Red...doing a FIND searching for a TYPESET! will give you the first instance of that type in a block:</p>
<pre><code>&gt;&gt; find [1 2 "abc" 3 4] any-string!
== ["abc" 3 4]

&gt;&gt; find [1 2 &lt;abc&gt; 3 4] any-string!
== [&lt;abc&gt; 3 4]
</code></pre>
<p>One would think that you'd be able to search for the typeset literally by using /ONLY.  But that doesn't work <em>(though Red says <a href="https://github.com/red/red/issues/4911">they addressed this recently</a>)</em></p>
<h3>Why Wasn't This Taken Further?</h3>
<p>Trying to FIND a function is pretty rare.  So why didn't they make it so that passing a function to FIND makes it search?</p>
<pre><code>&gt;&gt; find [1 2 3 4] func [x] [x &gt; 2]
== [3 4]
</code></pre>
<p>If a function took multiple arguments, that could be asking it to effectively /SKIP and group items at a time:</p>
<pre><code>&gt;&gt; find [1 2 4 3 5 6] func [a b] [a &gt; b]
== [4 3 5 6]
</code></pre>
<p>/ONLY could have worked for finding a function literally:</p>
<pre><code>&gt;&gt; find/only reduce [:positive? :zero? :negative?] :zero?
== [#[native! zero?...] #[native! negative?...]]
</code></pre>
<h3>Ren-C goes with QUOTED! vs. /ONLY, but same basic premise</h3>
<pre><code>&gt;&gt; find [1 0 2 0] :zero?
== [0 2 0]

&gt;&gt; find reduce [:positive? :zero? :negative?] quote :zero?
== [#[native! zero?...] #[native! negative?...]]
</code></pre>
<h3>Though It Seems Easy To Make Mistakes...</h3>
<p>People are invariably going to write <strong>find data value</strong>...think it works for a few values they try...and assume it works for others.  Redbols are notorious for pulling the rug out from under you with such things.</p>
<p>But if you're willing to do this for typesets, I don't see why doing it for functions is that much worse.</p>
<p>Just something to think about.</p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/find-treats-typeset-s-specially-why-not-functions/1881">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/find-treats-typeset-s-specially-why-not-functions/1881</link>
          <pubDate>Thu, 14 Jul 2022 10:36:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1881</guid>
          <source url="https://forum.rebol.info/t/find-treats-typeset-s-specially-why-not-functions/1881.rss">FIND treats TYPESET!s specially...why not functions?</source>
        </item>
        <item>
          <title>DESTRUCTURE Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>I've talked about this.  But there's no excuse not to write it, when there's so much power in modern PARSE <em>(the engine we up until recently called UPARSE)</em>.</p>
<p>A simple motivating case was a desire for different behavior from PARSE alternates with <strong><code>|</code></strong>.  So while <strong>[word! | word! word!]</strong> is always considered to be a badly-written parse rule, you could get a different treatment in destructure...because it always assumes you mean to go to <code>&lt;end&gt;</code></p>
<pre><code>&gt;&gt; destructure [banana] [
      [word!] =&gt; [print "Just one word"]
      [word! word!] =&gt; [print "Two words"]
   ]
Just one word

&gt;&gt; destructure [apple banana] [
      [word!] =&gt; [print "Just one word"]  ; not complete, so no match
      [word! word!] =&gt; [print "Two words"]
   ]
Two words
</code></pre>
<p>But the dialect concept is more ambitious than that, allowing you to give names to capture rules.  Then when you use those names, that's the variable that is set:</p>
<pre><code>&gt;&gt; destructure [apple banana] [
      w1: [word!] w2: [word!]

      [w1] =&gt; [print ["One:" w1]]
      [w1 w2] =&gt; [print ["Two:" w1 w2]]
   ]
Two: apple banana
</code></pre>
<p>And because what's actually powering this behind the scenes is PARSE, you have all those tools at your disposal...including the just-added <a href="https://forum.rebol.info/t/the-yada-yada-yada-combinator/1876">ellipsis operator</a>!</p>
<pre><code>&gt;&gt; destructure [1 2 apple banana 3 4 5] [
      w1: [word!] w2: [word!]

      [w1] =&gt; [print ["One:" w1]]
      [w1 w2] =&gt; [print ["Two:" w1 w2]]
      [... w1 w2 ...] =&gt; [print ["Words and more stuff:" w1 w2]]
   ]
Words and more stuff: apple banana
</code></pre>
<h2>
<a name="a-crazy-short-implementation-1" class="anchor" href="https://forum.rebol.info#a-crazy-short-implementation-1"></a>A Crazy Short Implementation!</h2>
<p>I'm sure it will receive some enhancements, but... this is pretty badass for something I wrote that worked more or less the first time!</p>
<pre><code>destructure: func [
    input [any-series!]
    dialect [block!]
    /multi "Run multiple branches"
][
    let result': void'
    let combinators: copy default-combinators
    parse dialect [while [not &lt;end&gt;] [
        let set-word: set-word!, let rule: block! (
            combinators.(to word! set-word): compose [(set-word) (rule)]
        )
        |
        let pattern: block!, '=&gt;, let branch: block!
        (
            parse/combinators input pattern combinators then (
                branch
            ) also ^r' -&gt; [
                if not multi [
                    return unmeta r'
                ]
                result': r'
            ]
        )
        |
        fail "Invalid DESTRUCTURE dialect entry"
    ]]
    return unmeta result'
]
</code></pre>
<h2>
<a name="and-its-composable-too-2" class="anchor" href="https://forum.rebol.info#and-its-composable-too-2"></a>And It's Composable, Too!</h2>
<p>That's right... you can use DESTRUCTURE with ELSE and THEN.</p>
<p>It follows the rules; a destructure that does not match anything is void</p>
<pre><code>&gt;&gt; void? destructure [a] [[integer!] =&gt; [print "Not happening"]]
== ~true~  ; anti
</code></pre>
<p>Notice I even threw a /MULTI feature in there, so you can match multiple ways!</p>
<pre><code>&gt;&gt; destructure/multi [apple banana] [
      w1: [word!] w2: [word!]

      [w1] =&gt; [print ["One:" w1]]
      [w1 w2] =&gt; [print ["Two:" w1 w2]]
      [repeat 2 &lt;any&gt;] =&gt; [print "Matching any two values also counts"]
   ]
Two: apple banana
Matching any two values also counts
</code></pre>
<hr>
<h1>
<a name="boom-raised_hand_with_fingers_splayed-electric_plug-power-in-your-hands-electric_plug-raised_hand_with_fingers_splayed-boom-3" class="anchor" href="https://forum.rebol.info#boom-raised_hand_with_fingers_splayed-electric_plug-power-in-your-hands-electric_plug-raised_hand_with_fingers_splayed-boom-3"></a><img src="https://forum.rebol.info/images/emoji/twitter/boom.png?v=12" title=":boom:" class="emoji" alt=":boom:" loading="lazy" width="20" height="20"> <img src="https://forum.rebol.info/images/emoji/twitter/raised_hand_with_fingers_splayed.png?v=12" title=":raised_hand_with_fingers_splayed:" class="emoji" alt=":raised_hand_with_fingers_splayed:" loading="lazy" width="20" height="20"> <img src="https://forum.rebol.info/images/emoji/twitter/electric_plug.png?v=12" title=":electric_plug:" class="emoji" alt=":electric_plug:" loading="lazy" width="20" height="20">  POWER, IN YOUR HANDS! <img src="https://forum.rebol.info/images/emoji/twitter/electric_plug.png?v=12" title=":electric_plug:" class="emoji" alt=":electric_plug:" loading="lazy" width="20" height="20"> <img src="https://forum.rebol.info/images/emoji/twitter/raised_hand_with_fingers_splayed.png?v=12" title=":raised_hand_with_fingers_splayed:" class="emoji" alt=":raised_hand_with_fingers_splayed:" loading="lazy" width="20" height="20">  <img src="https://forum.rebol.info/images/emoji/twitter/boom.png?v=12" title=":boom:" class="emoji" alt=":boom:" loading="lazy" width="20" height="20">
</h1>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/destructure-dialect/1877">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/destructure-dialect/1877</link>
          <pubDate>Tue, 12 Jul 2022 15:52:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1877</guid>
          <source url="https://forum.rebol.info/t/destructure-dialect/1877.rss">DESTRUCTURE Dialect</source>
        </item>
        <item>
          <title>%rebol-dom.r</title>
          <dc:creator><![CDATA[Danny]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>I been giving more thought to the DOM  format in Rebol  and I think it needs to present a clear, concise demonstration of how it would be used as an object model for DSL's.</p>
<p>While improving on or extending choices of formatting DSL data can be easy, feeding it a subset of a complete DSL may not. It takes a lot of thought in creating the DSL's and a subset of say HTML some would rightfully say isn't Good enough.</p>
<p>The html standard is huge.  Even so i believe it really can be done all in Rebol. instead of html only you would have a dsl choice, say make doc, markdown, or defualt DOM code. So Rebol-DOM.r is very simple.</p>
<p><a href="http://www.rebol.org/view-script.r?script=rebol-dom.r" rel="noopener nofollow ugc">http://www.rebol.org/view-script.r?script=rebol-dom.r</a></p>
<p>But to make it better i would need others coding experience. You mentioned tests. Wich types of testing would be  best for now.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rebol-dom-r/2237">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rebol-dom-r/2237</link>
          <pubDate>Thu, 14 Apr 2022 02:33:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2237</guid>
          <source url="https://forum.rebol.info/t/rebol-dom-r/2237.rss">%rebol-dom.r</source>
        </item>
        <item>
          <title>Dialecting URL!s...Should They Ever Be Strings?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>So I just tried to use a URL! in PARSE and found it was an error.  It's an error in R3-Alpha, too:</p>
<pre><code>r3-alpha&gt;&gt; parse http://example.com/foo [http://example.com "/foo"]
** Script error: PARSE - invalid rule or usage of rule: http://example.com
</code></pre>
<p>Red treats it as a string:</p>
<pre><code>red&gt;&gt; parse http://example.com/foo [http://example.com "/foo"]
== true
</code></pre>
<p><strong>But if you think about it, this is a pretty limited application of the datatype.</strong></p>
<ul>
<li>
<p>If your input is a string, you're saving two characters over putting it in braces or quotes, like <strong><code>["http://example.com" "/foo"]</code></strong></p>
<ul>
<li>Ren-C has generic quoting, so there's quoted URL!s with a single character as another option... <strong><code>['http://example.com "/foo"]</code></strong>
</li>
</ul>
</li>
<li>
<p>If what you're matching against is a URL it's only going to match the very beginning part.</p>
</li>
</ul>
<h2>Could It Fetch Rules From A Network?</h2>
<p>In some cases--like the COMPILE dialect--you can build a list of code and libraries to put together, along with user natives.  It's neat there to have URLs be interpreted as fetching from the network.</p>
<p>But that seems a bit strange for UPARSE.  You'd depend on caching <em>(you wouldn't want to do a network fetch each time you hit the URL! in the rule...?)</em>  In Ren-C you can kind of do this minus the caching, e.g.</p>
<pre><code>uparse data [... :(load http://example.com/rules/) ...]
</code></pre>
<h2>Could It Be Commentary?</h2>
<p>In the test dialect, I thought it might be nice to just be able to drop URLs in the middle of things without having to make them comments.  It doesn't save that much, but can look more clean:</p>
<pre><code>[
    #386
    http://en.wikipedia.org/wiki/Some_Related_Topic
    (1 + 1 = 2)
]
</code></pre>
<p>I've also sometimes wondered about this for function specifications.</p>
<pre><code>foo: func [
    http://example.com/this-explains-this-function
    return: [integer!]
    arg [integer!]
][
    ...
]
</code></pre>
<p>This doesn't seem a good fit for PARSE behavior, but I kind of want to mention the idea of different ways that URL! might be used.</p>
<h2>In UPARSE It's Customizable...Leave it Open?</h2>
<p>One possibility would be to say that URL! doesn't do anything by default, and you can make a URL! combinator that decides what it does do.</p>
<p>How useful would it be?  I don't know.</p>
<p><strong>I'm just questioning whether the knee-jerk response of treating URL! as a string (or matching a URL! value if block parsing) is obviously the way to go.</strong></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/dialecting-url-s-should-they-ever-be-strings/1763">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dialecting-url-s-should-they-ever-be-strings/1763</link>
          <pubDate>Mon, 29 Nov 2021 15:36:40 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1763</guid>
          <source url="https://forum.rebol.info/t/dialecting-url-s-should-they-ever-be-strings/1763.rss">Dialecting URL!s...Should They Ever Be Strings?</source>
        </item>
        <item>
          <title>JSON Envy: Serialization Dialect in Rebol?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <blockquote>
<p>Carl's thinking about <a href="https://forum.rebol.info/t/carls-new-projects-altscript-altos/1571">a successor to Rebol's notation called ASON</a> included the idea that braces would be used for object construction--not strings.</p>
<p>I've panned the notion of "lexical objects", and explained why in a thread outlining an alternative of treating braces as <strong><a href="https://forum.rebol.info/t/rethinking-braces-as-an-array-type/1727">a new array type called FENCE!</a></strong>, which I have come to think is likely well worth it.</p>
<p><em>But assuming we <strong>don't</strong> have FENCE!</em>, what might Rebol's version of JSON look like?  This was a tangent explored in October 2021 on the fence thread that I've broken into its own topic.</p>
</blockquote>
<hr>
<p>Consider <a href="https://json.org/example.html">this example from json.org</a></p>
<pre><code>{"glossary": {
    "title": "example glossary",
    "GlossDiv": {
        "title": "S",
        "GlossList": {
            "GlossEntry": {
                "ID": "SGML",
                "SortAs": "SGML",
                "GlossTerm": "Standard Generalized Markup Language",
                "Acronym": "SGML",
                "Abbrev": "ISO 8879:1986",
                "GlossDef": {
                    "para": "A meta-markup language...",
                    "GlossSeeAlso": ["GML", "XML"]
                },
               "GlossSee": "markup"
            }
        }
    }
}}
</code></pre>
<p>I think allowing spaces in the keys is a weakness and not a strength.  And Rebol doesn't have the historical problem of disallowing language "keywords" in the keys, so the quotes wouldn't be necessary (they're not in modern JavaScript either for that reason, but they are if your word has dashes or spaces in it).</p>
<p>Let's drop the quotes and turn <em>all</em> the braces into brackets.  Commas can be optional now, but let's say we don't care to use them when things are on different lines.</p>
<pre><code>[glossary: [
    title: "example glossary"
    GlossDiv: [
        title: "S"
        GlossList: [
            GlossEntry: [
                ID: "SGML"
                SortAs: "SGML"
                GlossTerm: "Standard Generalized Markup Language",
                Acronym: "SGML"
                Abbrev: "ISO 8879:1986"
                GlossDef: [
                    para: "A meta-markup language..."
                    GlossSeeAlso: ["GML", "XML"]  ; can use commas if we want?
                ]
                GlossSee: "markup"
            ]
        ]
    ]
]]
</code></pre>
<p>In practice, the serializer/deserializer could say that any block starting with a SET-WORD! is presumed to be an object...and if you have an array that you don't want to get this treatment you use <strong>'[...]</strong></p>
<pre><code>&gt;&gt; deserialize "[[a: 10 b: 20] '[c: 10 &lt;random stuff&gt; d: 20]]"
== [
    #object![a: 10 b: 20]  ; whatever notation
    [c: 10 &lt;random stuff&gt; d: 20]
]
</code></pre>
<p>A simple rule about SET-WORD!s could give us the same object vs. array distinction in what's being transferred.  It would keep us centered on one nice bracket form to be hitting... allow an escape route for arbitrary BLOCK!s that want SET-WORD!s via quote...and we keep our nice braced strings without the need for nasty escapes.</p>
<h2><a name="p-5601-what-about-evaluative-things-in-lists-1" class="anchor" href="https://forum.rebol.info#p-5601-what-about-evaluative-things-in-lists-1"></a>What About Evaluative Things In Lists?</h2>
<p>The lightness of unadorned WORD! has a big draw in Rebol, and has caused a lot of headaches...for instance in deciding if we should say <strong>Type: 'module</strong> or <strong>Type: module</strong>.</p>
<p>While there's no rule that says module headers have to obey the same rules as whatever this operation is, it feels unwise to have them deviate.  So this implies <strong>Type: 'module</strong> or moving to something inert like <strong>Type: <span class="hashtag-raw">#module</span></strong> or <strong>Type: "module"</strong></p>
<p>The problem expands to lists, where you have <strong>category: [fun script]</strong> needing to mitigate or avoid evaluation one way or another:</p>
<pre><code>category: '[fun script]

category: ['fun 'script]

category: ["fun" "script"]

category: [#fun #script]
</code></pre>
<p>While the first option of putting a quote on the list seems like the cleanest, things trying to generate serializations wouldn't have that choice if it was mixing words and objects:</p>
<pre><code>mix: ['word-one [a: 10 b: 20] 'word-two]
</code></pre>
<p>If the outer block were quoted, then it wouldn't dig in to make the inner block into an object.</p>
<p>These kinds of odd mixtures of evaluation with objects points out a not-uncommon Rebol problem... if you're doing a deserialization and descending into a block that isn't quoted, you might be seeing BLOCK!s that are arguments to functions along with blocks that are meant to act as objects.  Which wins?</p>
<p>Code like PRINT goes step by step, as opposed to gathering all the strings ahead of time and assuming it is for itself:</p>
<pre><code>&gt;&gt; print ["hello" reverse "dlrow"]
hello world
</code></pre>
<p>The deserialization operator could work the same way, though it could effectively COMPOSE the BLOCK!s representing objects in so that any functions would be passed the object.  :-/</p>
<p>Certainly raises some questions, but, they are fairly common Rebol questions.</p>
<p><strong>...or...REDUCE requests could be explicit?</strong></p>
<p>We don't have to make "recurses to look for blocks to instantiate objects" also imply that the arrays themselves are evaluative, but I think it would be confusing.  JavaScript programmers expect the arrays inside objects to be evaluated:</p>
<pre><code> let x = {label: "object", data: {label: "array", data: [1 + 2, 10 + 20]}}
</code></pre>
<p>This gives you a nested structure with <strong><code>data: [3, 30]</code></strong>.  So I feel like this operation should follow suit, reducing blocks unless you suppress that.</p>
<p>So if your input is:</p>
<pre><code>[label: "object", data: [label: "array", data: [1 + 2, 10 + 20]]]
</code></pre>
<p>I think data should be <strong>[3 30]</strong>, and if your input is:</p>
<pre><code>[label: "object", data: [label: "array", data: '[1 + 2, 10 + 20]]]
</code></pre>
<p>Then data should be <strong>[1 + 2, 10 + 20]</strong>.  The mixing and matching really is where you run into trouble, of an array that contains some blocks and some objects...though everything can be represented thanks to generic quoting, it could get messy.</p>
<h2><a name="p-5601-what-if-we-used-groups-in-serialization-2" class="anchor" href="https://forum.rebol.info#p-5601-what-if-we-used-groups-in-serialization-2"></a>What If We Used GROUP!s in Serialization?</h2>
<pre><code>&gt;&gt; stuff: reduce [make object! [a: 10 b: 10 + 10]]
== [object!#[a: 10 b: 20]]  ; or whatever internal representation

&gt;&gt; serialize stuff 
== [(a: 10 b: 20)]

&gt;&gt; deserialize stuff
== [object![a: 10 b: 20]]
</code></pre>
<p>JSON doesn't use parentheses in this way because it can't.  Parentheses are not reified.</p>
<p>But if a Rebol system wants to exchange information with another Rebol system "in the style of JSON", GROUP! could be used to represent the key/value objects and BLOCK! could represent plain array/lists...with braces being a handy mode of string representation that can get away with less escaping.</p>
<p>And with modern COMPOSE you could deserialize and compose, by labeling the compose sites:</p>
<pre><code>&gt;&gt; deserialize compose &lt;*&gt; [
    (a: 10 b: 20)  ; deserialize treats as object
    (&lt;*&gt; reduce [1 + 2 3 + 4])  ; array before deserialize
 ]
</code></pre>
<p>Whatever you call it, having something like COMPOSE which treats nested levels of GROUP!s as object creation requests isn't that crazy an idea.  (Perhaps OBJECTIFY ?)</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/json-envy-serialization-dialect-in-rebol/2140">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/json-envy-serialization-dialect-in-rebol/2140</link>
          <pubDate>Sat, 23 Oct 2021 06:06:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2140</guid>
          <source url="https://forum.rebol.info/t/json-envy-serialization-dialect-in-rebol/2140.rss">JSON Envy: Serialization Dialect in Rebol?</source>
        </item>
        <item>
          <title>Uses of FENCE! In Dialecting</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>I'm now committed to <a href="https://forum.rebol.info/t/rethinking-braces-as-an-array-type/1727">make braces a new array type</a>. Rebol has put itself in a bad position by using that particularly valuable piece of keyboard real-estate for something "superficial" like making strings a little cleaner, sometimes.  :-/</p>
<h1>
<a name="block-group-fence-1" class="anchor" href="https://forum.rebol.info#block-group-fence-1"></a><code>[block]</code> <code>â€¢</code>  <code>(group)</code> <code>â€¢</code> <code>{fence}</code>
</h1>
<p>It's <em>likely</em> (though not 100% set in stone) that FENCE! will evaluate by running MAKE OBJECT!.  But what might it do in other dialects?</p>
<ul>
<li>
<p><em>"If there's an integer inside of a pair of fences, such as <code>{{10}}</code>, then that represents a citation.  Citations can appear at either the beginning or end of a reference block."</em></p>
</li>
<li>
<p><em>"In the PARSE dialect, blocks are used to represent subrules.  Groups switch over to running ordinary code as with DO.  While fences are used to... (insert your active imagination here)"</em></p>
</li>
</ul>
<h2>
<a name="if-fence-were-inert-that-would-change-dialecting-possibilities-2" class="anchor" href="https://forum.rebol.info#if-fence-were-inert-that-would-change-dialecting-possibilities-2"></a>If FENCE! Were Inert, That Would Change Dialecting Possibilities</h2>
<p>Fences don't necessarily have to produce an object under evaluation.  If it wasn't, you could do things like pass it to an arity-1 MAKE:</p>
<pre><code>&gt;&gt; obj: make {x: 10 y: 20}
== ...object x: 10 y: 20...  ; whatever literals look like
</code></pre>
<p>Switching to an arity-1 MAKE could be dialected, if you needed to slip things like a parent object in:</p>
<pre><code>&gt;&gt; obj2: make {&lt;parent&gt; obj, x: 30}  ; potential dialect for mentioning parent
== ...object x: 30 y: 20....

&gt;&gt; obj3: make {{obj} x: 30}  ; weirder but more succinct dialect parent concept
== ...object x: 30 y: 20...
</code></pre>
<p>Less disruptive, we could just say it reduces:</p>
<pre><code>&gt;&gt; reduce {x: 10 y: 20}
== make object! [x: 10 y: 20]  ; or whatever
</code></pre>
<p>Then GET-FENCE! could do the same:</p>
<pre><code>&gt;&gt; :{x: 10 y: 20}
== make object! [x: 10 y: 20]  ; or whatever
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/uses-of-fence-in-dialecting/1728">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/uses-of-fence-in-dialecting/1728</link>
          <pubDate>Thu, 30 Sep 2021 11:36:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1728</guid>
          <source url="https://forum.rebol.info/t/uses-of-fence-in-dialecting/1728.rss">Uses of FENCE! In Dialecting</source>
        </item>
        <item>
          <title>USCII Seen With New Eyes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>In 2008 I used R3-Alpha for <a href="http://uscii.hostilefork.com/">USCII</a>, to make some 5x7 bitmaps out of a stock font I found, plus some data to make symbols for the missing control characters.  The way I defined the missing characters was with blocks of data, like:</p>
<pre><code>[
    code: 10
    name: "Line Feed"
    abbr: "LF"
    description: {
        On typewriters, printers, and some terminal emulators, moves the
        cursor down one row without affecting its column position. On Unix,
        used to mark end-of-line.
    }
    image: [
        "XXX  "
        "  X  "
        "  X  "
        "  X  "
        "XXXXX"
        " XXX "
        "  X  "
    ]
    notes: {
        A spin on the carraige return which emphasizes the "downness" of
        a feed, but also with a horizontal suggestion of the current line
    }
    rating: 'good
] 
</code></pre>
<p>Besides not needing commas on the strings, this doesn't really buy a whole lot over JSON.  The script had a couple of talking points--that PNG encoding and IMAGE! was built in, and that you could put BINARY! data directly in your script as hex.  But largely unremarkable.</p>
<p>Not that the point was to demo "great Rebol practices", really.  I was just using it as a tool.  <em>(And it was 2008, so I had just found the language...one shouldn't expect much regardless.)</em></p>
<p><strong>I've gotten it working under Redbol emulation--which is kind of a cool trick in and of itself.</strong>  This involved patching up the bad IMAGE! code well enough to work with the script, but it felt worth it to run the rest of it.</p>
<p><strong>But the real fun begins moving to modern ideas.</strong>  So I put aside a copy as a historical version to keep as a Redbol test, but then started updating it to the new world...</p>
<h2>
<a name="rethought-with-utf-8-and-a-dialect-1" class="anchor" href="https://forum.rebol.info#rethought-with-utf-8-and-a-dialect-1"></a>Rethought With UTF-8 and a Dialect</h2>
<p>When you take away the BLOCK! and start using the parts in the box, what you get is a lot more remarkable.</p>
<pre><code>=== LF: Line Feed (10) ===

â—¼â—¼â—¼â–¢â–¢
â–¢â–¢â—¼â–¢â–¢
â–¢â–¢â—¼â–¢â–¢
â–¢â–¢â—¼â–¢â–¢
â—¼â—¼â—¼â—¼â—¼
â–¢â—¼â—¼â—¼â–¢
â–¢â–¢â—¼â–¢â–¢

description: {
    On typewriters, printers, and some terminal emulators, moves the
    cursor down one row without affecting its column position. On Unix,
    used to mark end-of-line.
}
notes: {
    A spin on the carraige return which emphasizes the "downness" of
    a feed, but also with a horizontal suggestion of the current line
}
rating: good
</code></pre>
<p>It's much more interesting:</p>
<ul>
<li>
<p>UTF-8 means that we can use solid and hollow boxes to represent the bitmap.  They're legal characters in WORD!s, so instead of 7 TEXT!s the bitmap can be represented as 7 WORD!s and still be LOAD-able.</p>
</li>
<li>
<p>A section-divider can do double duty for the attributes.  A SET-WORD! becomes the shorthand, the name can be turned into regular WORD!s spanning up to a GROUP! that contains the codepoint.</p>
</li>
<li>
<p>There were multiple shorthands in some cases (e.g. 17, Device Control 1, can be known as DC1 or XON).  instead of a SET-WORD! like <strong>LF:</strong> that can be a SET-PATH!, like <strong>DC1/XON:</strong>.</p>
</li>
<li>
<p>Since it's a dialect, there's no need to put a tick mark on the rating of "good/fair/poor".</p>
</li>
</ul>
<h2>
<a name="a-fluid-format-that-you-transform-with-uparse-2" class="anchor" href="https://forum.rebol.info#a-fluid-format-that-you-transform-with-uparse-2"></a>A Fluid Format that You Transform With UPARSE</h2>
<p>The first thing I did was to transform the new representation back to the old representation with UPARSE.</p>
<p>So it's not optimal, and we wouldn't need such a transformation step anyway if processing directly.</p>
<p>But I'm pasting it here just to make the point that in just a couple of minutes I was able to have the old code up and running on the new format:</p>
<pre><code>override-list: parse load %uscii-5x7-english-c0.reb [
    collect some keep gather [
        '===
        emit abbreviation: [
            temp: set-word! (as text! temp)  ; e.g. `LF`
            |
            temp: set-path! (as block! temp)  ; e.g. `DC1/XON`
        ]
        emit name: form/ between &lt;here&gt; [emit code: subparse group! integer!]
        '===

        emit image: collect repeat 7 [w: word!, keep (as text! w)]

        try ['description:, emit description: text!]
        try ['notes:, emit notes: text!]
        try ['rating:, emit rating: word!]
    ]
] except [
    fail ["Could not parse %uscii-5x7-english-c0.reb"]
]
</code></pre>
<h2>
<a name="imo-this-is-rebols-deep-lake-3" class="anchor" href="https://forum.rebol.info#imo-this-is-rebols-deep-lake-3"></a>IMO, This is Rebol's "Deep Lake"</h2>
<p>Breaking free of the JSON mindset and using the parts really makes this work:</p>
<p><a href="https://github.com/hostilefork/uscii/blob/master/uscii-5x7-english-c0.reb">https://github.com/hostilefork/uscii/blob/master/uscii-5x7-english-c0.reb</a></p>
<p>Revisiting this and the Whitespace interpreter are just really good examples of the form.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/uscii-seen-with-new-eyes/1713">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/uscii-seen-with-new-eyes/1713</link>
          <pubDate>Sun, 12 Sep 2021 13:15:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1713</guid>
          <source url="https://forum.rebol.info/t/uscii-seen-with-new-eyes/1713.rss">USCII Seen With New Eyes</source>
        </item>
        <item>
          <title>Boris&#39;s &quot;NEW-EACH&quot; Loop Dialecting Proposals</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Here are some ideas for what kinds of things you might put in a FOR-EACH variable block besides just words, and some other ideas:</p>
<p><a href="https://gitlab.com/hiiamboris/red-mezz-warehouse/-/blob/master/foreach-design.md" class="inline-onebox">foreach-design.md Â· master Â· hi i am boris / Red mezz warehouse Â· GitLab</a></p>
<p>It's definitely worth thinking about how to ask for the iteration counter automatically while iterating.  Or getting the position <em>and</em> the value somehow at once, instead of being forced to iterate by position and remember to say <code>pos.1</code> to get the value.  We've had some hare-brained schemes for that come down the pipe.</p>
<p>The simple idea of just asking for it in the vars spec feels pretty solid.  I'm not thrilled about the <strong>/var</strong> notation, but it's a desirable feature and certainly in reach:</p>
<pre><code>&gt;&gt; for-each [/i x y] [#a &lt;b&gt; #c &lt;d&gt; #e] [
       print [i x y]
   ]
1 #a &lt;b&gt;
2 #c &lt;d&gt;
3 #e
</code></pre>
<p>But some of the other proposals are a bit heavy, like a type constraint and then skipping out of iterations where the type doesn't match:</p>
<pre><code>&gt;&gt; for-each [/i x [text! group!] y] ["a" &lt;b&gt; #c &lt;d&gt; (e)] [
       print [i x y]
   ]
1 "a" &lt;b&gt;
3 (e)
</code></pre>
<p>The semantic combinatorics start to add up.  He says that the index keeps counting regardless of whether the iteration was skipped or not... but, is that obvious?</p>
<p>And isn't the following kind of clearer:</p>
<pre><code>&gt;&gt; for-each [/i x y] ["a" &lt;b&gt; #c &lt;d&gt; "e"] [
       match [text! group!] x else [continue]   
       print [index x y]
   ]
1 "a" &lt;b&gt;
3 (e)
</code></pre>
<h2>Things to Avoid: Overdesign, "Parts of Speech" Abuse</h2>
<p>I think we should be cautious about overdesigning such  core constructs.  (But certainly these things--whether you think they are monstrosities or not--are exactly the kind of thing that people are supposed to be empowered to make if it pleases them.  It's supposed to be a <em>personal</em> language, and you personalize it to the extent of your tastes.)</p>
<p>As we want to know the loop iteration you're on, maybe the better angle isn't to be abusing word decorations in such weird ways...but to use refinements as labels and then name the variable after it.  I wouldn't call the loop counter the "index" because the index is in the series position... so, /COUNTER or   /COUNT maybe?</p>
<pre><code>&gt;&gt; for-each [/count i x y] [#a &lt;b&gt; #c &lt;d&gt; #e] [
       print [i x y]
   ]
</code></pre>
<p>Commas would probably make it clearer, so good we have them:</p>
<pre><code>&gt;&gt; for-each [/count i, x y] [#a &lt;b&gt; #c &lt;d&gt; #e] [
       print [i x y]
   ]
</code></pre>
<p>You could get the series position with <strong>/here</strong>.  And <a class="mention" href="https://forum.rebol.info/u/blackattr">@BlackATTR</a> and <a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a> and I have talked about things like wanting to know if you were on the first or last iteration.  Well, why not <strong>/first?</strong> and <strong>/last?</strong></p>
<pre><code>&gt;&gt; for-each [/first? f, /last? l, x y] [#a &lt;b&gt; #c &lt;d&gt; #e] [
       print [f l x y]
   ]
true false #a &lt;b&gt;
false false #c &lt;d&gt;
false true #e
</code></pre>
<p>Some of these could apply to other loop forms like COUNT-UP I guess...</p>
<pre><code>&gt;&gt; count-up [/first? f, /last? l, x] 3 [print [f l x]]
true false 1
false false 2
false true 3
</code></pre>
<p>People who really want shorthands to say that "just a refinement means /count" could put a little preprocessor adapting the spec to the more verbose form.  But I'd rather use the verbose version.</p>
<h2>Generalized Generators Throw A Thorn in This</h2>
<p>In moving to a generalized FOR that runs over a generator, the values are being provided by something that gets called N times and returns answers.  The underlying pattern can be shown by the rewrite:</p>
<pre><code>&gt;&gt; for [/first? f, /last? l, x y] (each [#a &lt;b&gt; #c &lt;d&gt; #e]) [
       print [f l x y]
   ]
</code></pre>
<p>EACH is a generator.  And FOR is something that calls that generator N times.</p>
<p>But not all generators operate on series, some fabricate data out of thin air.  So they'd have no series position to answer /HERE with.  And while we can universally answer the "is this the first iteration" in the iteration construct itself, not all generators know if they're on the last time you're calling them...they provide data for each call until they return NULL.</p>
<p>So I guess the mechanics would have to be to try and request these as output parameters from the generator, and it either has them or it doesn't.  Yay for multi-returns, amiright?  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>But since the answers are coming from the generator you'd probably have to put your questions for it in front of the variable for the iteration # you are asking:</p>
<pre><code>&gt;&gt; for [/first? f, x, /last? l, y] (each [#a &lt;b&gt; #c &lt;d&gt; #e]) [
       print [f l x y]
   ]
</code></pre>
<p>This moves the LAST? question so it would ostensibly be grouped with the request for Y.</p>
<h2>Weird Thought... "FOR specs", like "FUNC specs"?</h2>
<p>It occurred to me like we might actually want to think about documenting these like specs.</p>
<pre><code>&gt;&gt; data: [#a &lt;b&gt; #c &lt;d&gt; #e]

&gt;&gt; for-each [
       /first? f [logic!]
       x [tag!] "Maybe document what this is for with a TEXT!?"
       /last? l [logic!]
       y [issue!] "Same here..."
   ] data [
       print [f l x y]
   ]
</code></pre>
<p>It could introduce concepts like <code>&lt;skip&gt;</code> able parameters.</p>
<p>Of course you wouldn't have to use such wacky things if you didn't want to, I'm just saying you could.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/boriss-new-each-loop-dialecting-proposals/1682">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/boriss-new-each-loop-dialecting-proposals/1682</link>
          <pubDate>Tue, 24 Aug 2021 04:53:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1682</guid>
          <source url="https://forum.rebol.info/t/boriss-new-each-loop-dialecting-proposals/1682.rss">Boris&#39;s &quot;NEW-EACH&quot; Loop Dialecting Proposals</source>
        </item>
        <item>
          <title>CLI Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>A long time ago, earl and I discussed the concept of making it so that a script's header would use something like the function spec dialect to define the command line arguments for a script.  So if you declared a refinement like <strong>/foo [integer!]</strong> that would be translated into something appropriate for your platform, like an argument to your script taken as <strong>--foo=3</strong> on Linux or <strong>/foo 3</strong> on Windows.  Or whatever.</p>
<p>Regular args would be required arguments, you'd get automatic help from the string descriptions in the spec, etc.</p>
<p>Red's Boris has done nearly exactly this...but he isn't putting a spec into the script header.  He has you make a function and then pass that function to a CLI dialect processor:</p>
<p><a href="https://gitlab.com/hiiamboris/red-cli/" class="inline-onebox">hi i am boris / CLI dialect for Red Â· GitLab</a></p>
<p>I do still like the aesthetics of putting it in the script header; it feels like a good place.  Though that would bake it in somewhat more...and introduces the question of what scope the arguments are in.  Would you have to say <strong>system.processed-args.foo</strong>, or would it be a globally scoped <strong>foo</strong> to the whole script?</p>
<p>And he mentions a good point of making this something you can apply to any function:</p>
<blockquote>
<p><em>"You can turn any Red function into a command line utility with one or two words. Suppose you have a <code>grep</code> function that is to be used from Red. Prefix it with <code>process-into</code>, add <code>print</code> for the output, compile it, and you have a <code>grep</code> utility!"</em></p>
</blockquote>
<p>That is worth thinking about.  You can say <strong>--do "..."</strong> on the command line to run arbitrary code, but what if you could specify a script name and say <strong>--function "func-name"</strong>, and have that function suddenly get its arguments from the command line?</p>
<p>If that sounds dumb compared to <strong>--do "func-name/refine arg1 arg2"</strong> just consider that sometimes you do want to integrate with the shell, and getting arguments spliced via the shell into such a --do string can be a mess.  It also can't be aliased into a single shell command.</p>
<p>Anyway, their experience with this is worth looking at, as it's something I've wanted for a while.  Whether there's a way of offering this in a script's header or not, I think I'm sold on the "you should be able to do it to any function if you want" angle.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/cli-dialect/1651">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/cli-dialect/1651</link>
          <pubDate>Sat, 07 Aug 2021 15:21:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1651</guid>
          <source url="https://forum.rebol.info/t/cli-dialect/1651.rss">CLI Dialect</source>
        </item>
        <item>
          <title>(| Synthetic |) [[Asymmetric]] {&gt; Delimiters &lt;}</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>In trying to get COMPOSE to lose /ONLY, there was a time when it looked for doubled groups.</p>
<pre><code>&gt;&gt; block: [a b c]

&gt;&gt; compose [(block) ((block))]
== [a b c [a b c]]
</code></pre>
<p>I liked it, and I said:</p>
<aside class="quote no-group quote-post-not-found" data-username="hostilefork" data-post="10" data-topic="979">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"><a href="https://forum.rebol.info/t/the-superpowers-of-ren-cs-revamped-compose/979/10">The Superpowers of Ren-C's Revamped COMPOSE</a></div>
<blockquote>
<p>As a higher-level tool, it should cater to the higher-level needs...and that's not splicing unless you ask. I really believe this is the better behavior for people who are writing and reading the code.</p>
</blockquote>
</aside>
<p>But I found concerns:</p>
<aside class="quote no-group quote-post-not-found" data-username="hostilefork" data-post="10" data-topic="979">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"><a href="https://forum.rebol.info/t/the-superpowers-of-ren-cs-revamped-compose/979/10">The Superpowers of Ren-C's Revamped COMPOSE</a></div>
<blockquote>
<p>One qualm I have about this is the visual difficulty of telling if something is a double-group if you are composing more than one item.</p>
<pre><code>&gt;&gt; compose [a b ((some code
         that goes on and on and) oh it ended there (maybe you start
         another group and
     eventually end)) d e]
</code></pre>
<p>That's <em>not</em> a splicing case because it's not a double group, but it kind of looks like one.</p>
</blockquote>
</aside>
<p>To be fair: it's hardly the only case where if you jump to conclusions on reading a few characters that you'll have problems because the code keeps going and may invalidate the assumptions you made by looking at those few characters.  But it still wasn't perfect.</p>
<p>...and as it turned out, it was another one of those "close but no cigar" cases of wanting to mark the intent of splice specially, but using a mechanism <strong><a href="https://forum.rebol.info/t/putting-splicing-intent-on-appended-value/1873">that's not as good as splice isotopes</a>!</strong>.</p>
<p><strong>I think that doubled-up-groups are a neat example of a dialecting concept, where you might want to give that significance.  It would certainly belong in the dialecting handbook (if we had one).</strong></p>
<p>But in the COMPOSE case, we have a better option... <strong>compose [... (spread block) ...]</strong> (or another operator of your choice that produces block isotopes).  And it's more fitting for the core, because it doesn't have the weakness mentioned above.</p>
<hr>
<p>Not that it would be hard to write again, but here's the C code for detecting doubled groups!</p>
<pre><code>INLINE bool Is_Any_Doubled_Group(const Element* group) {
    assert(Any_Group_Heart(Cell_Heart(group)));
    const Cell* tail;
    const Cell* inner = Cell_Array_At(&amp;tail, group);
    if (inner + 1 != tail)  // should be exactly one item
        return false;
    return Is_Group(inner);  // if true, it's a ((...)) GROUP!
}
</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/synthetic-asymmetric-delimiters/1893">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/synthetic-asymmetric-delimiters/1893</link>
          <pubDate>Sun, 06 Jun 2021 02:54:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1893</guid>
          <source url="https://forum.rebol.info/t/synthetic-asymmetric-delimiters/1893.rss">(| Synthetic |) [[Asymmetric]] {&gt; Delimiters &lt;}</source>
        </item>
        <item>
          <title>Idea: QUOTED! Data Means FOR =&gt; FOR-EACH</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>So I had another flash-o-inspiration.</p>
<pre><code>for x [1 thru 3] [
   print [x]
]
</code></pre>
<p>Gives you:</p>
<pre><code>1
2
3
</code></pre>
<p>But...</p>
<pre><code>for x @[1 thru 3] [
   print [x]
]
</code></pre>
<p>Leads to the second parameter to FOR being <strong>'[1 thru 3]</strong>  And that would give you:</p>
<pre><code>1
thru
3
</code></pre>
<p>And if you don't like how that looks, you could also use:</p>
<pre><code>for x each [1 thru 3] [
   print [x]
]

1
thru
3
</code></pre>
<p>In that case, EACH is making a generator function, so the second argument to FOR is an ACTION! that produces values until it produces a NULL which causes it to stop the FOR.</p>
<p>So I think that resolves that the base level of FOR and MAP is a dialect for generating values.  Anyone have ideas for this dialect and how it works besides me?  :-/  <sub>No, don't worry about it, I'll solve it.</sub></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/idea-quoted-data-means-for-for-each/1601">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/idea-quoted-data-means-for-for-each/1601</link>
          <pubDate>Wed, 12 May 2021 08:24:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1601</guid>
          <source url="https://forum.rebol.info/t/idea-quoted-data-means-for-for-each/1601.rss">Idea: QUOTED! Data Means FOR =&gt; FOR-EACH</source>
        </item>
        <item>
          <title>Are GET-WORD!s Too Ugly? :FOO vs. $FOO</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>When looking at bash, you can see it doing things that look nice and light:</p>
<pre><code># bash code
echo "Installed Version: $ANDROID_NDK_VERSION for the NDK"
</code></pre>
<p>Rebol isn't <em>terrible</em>:</p>
<pre><code>; Rebol version
print ["Installed Version:" ANDROID_NDK_VERSION "for the NDK"]
</code></pre>
<p>But I'm becoming a believer that we should be thinking about offering versions that start by <a href="https://forum.rebol.info/t/dont-fear-the-word/1549">taking the words you write at face value</a>, and marking the substitutions.  That would suggest perhaps offering an echo like:</p>
<pre><code>; A Rebol Echo with literal tendencies
echo [Installed Version: (ANDROID_NDK_VERSION) for the NDK]
</code></pre>
<p>But I've mentioned that even GROUP!s might want to be literal in such contexts for the default case (I often use parentheses in writing English, as I'm doing here).  So perhaps a GET-WORD! would be more appropriate:</p>
<pre><code>echo [Installed Version: :ANDROID_NDK_VERSION for the NDK]
</code></pre>
<p>That looks a bit unsatisfying.</p>
<h2>
<a name="leading-colon-ive-never-liked-you-1" class="anchor" href="https://forum.rebol.info#leading-colon-ive-never-liked-you-1"></a>Leading colon, I've never liked you...</h2>
<p>Beyond looking bad, it doesn't really call your attention to the escaping.</p>
<p>But it raises to my attention something that's just sort of generally true as a whole... <em>GET-WORD! is unsatisfiying.</em></p>
<p>I've never liked the way <strong>x: :y</strong> looks.  It doesn't have a good vibe...especially when you put a get right after a set like that.</p>
<p>We don't put colons in front of things in English, like, ever.  While there's some amount of abstract symmetry to <em>"colon in back means set, colon in front means get"</em>, we don't have to be a slave to that.  If pure symbolic reversal were the way to invert meanings we'd use SET to set and TES to get.  :-/</p>
<p>So for dialecting, I wonder if using VAR-WORD! ($) would be better:</p>
<pre><code>echo [Installed Version: $ANDROID_NDK_VERSION for the NDK]
</code></pre>
<p>And I think it actually looks <em>better</em> than the bash, with the brackets instead of quotes:</p>
<pre><code>echo "Installed Version: $ANDROID_NDK_VERSION for the NDK"
</code></pre>
<p>Thoughts?</p>
            <p><small>6 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/are-get-word-s-too-ugly-foo-vs-foo/1550">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/are-get-word-s-too-ugly-foo-vs-foo/1550</link>
          <pubDate>Wed, 10 Mar 2021 04:58:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1550</guid>
          <source url="https://forum.rebol.info/t/are-get-word-s-too-ugly-foo-vs-foo/1550.rss">Are GET-WORD!s Too Ugly? :FOO vs. $FOO</source>
        </item>
        <item>
          <title>Revisiting The ZIP Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Vincent Ecuyer's <a href="http://www.rebol.org/view-script.r?script=rebzip.r">ZIP Dialect</a> is an example of tool in a domain that pretty much everyone knows and uses: zipping and unzipping files.</p>
<p>I'd thought its source code might be a good place to study the power of BINARY! parsing...until I realized how lacking binary parsing actually was in practice.  With UPARSE, I hope to attack those problems.  If so, then ZIP may yet become a showcase of how something like the zip file specification can become easily absorbed as usermode code.</p>
<p><strong>But another opportunity may come from making the ZIP dialect a tool people would actually want to use for its powers.</strong></p>
<p>It's already a little bit dialected.  When you pass it a block, you don't just specify filenames.  You can also give it literal blobs of BINARY! data, or URL!s to fetch.  This means you don't have to do calls to <code>curl</code> to get a temporary file, rename that file, and then pass the filename to a zip tool... the tool itself has smarts.</p>
<p>Here's what the options were in the original script:</p>
<pre><code>you can zip a single file:
    zip %new-zip.zip %my-file

a block of files:
    zip %new-zip.zip [%file-1.txt %file-2.exe]

a block of data (binary!/string!) and files:
    zip %new-zip.zip [%my-file "my data"]

a entire directory:
    zip/deep %new-zip.zip %my-directory/

from an url:
    zip %new-zip.zip ftp://192.168.1.10/my-file.txt

any combination of these:
    zip/deep %new-zip.zip  [
        %readme.txt "An example" 
        ftp://192.168.1.10/my-file.txt
        %my-directory
     ]
</code></pre>
<p>When you think of this being used alongside my demo of <a href="https://forum.rebol.info/t/using-ren-c-as-the-shell-in-github-actions/1547">steps in GitHub Actions</a> we could pack it up.  Here's a sketch of what that might look like:</p>
<pre><code> - uses: hostilefork/zip-github-action@v1
   output: new-zip.zip
   deep: true
   run: |
       %readme.txt "An example" 
       ftp://192.168.1.10/my-file.txt
       %my-directory
</code></pre>
<p>The ideal would be that there be a very easy way to make such a packaging for any given ACTION!.  You want to be able to get the non-dialect arguments and refinements split out from the body (the way the output filename and /DEEP is split out here).</p>
<h2>This Seems Like A Good Example to Try And Hone</h2>
<p>It doesn't really get any simpler than this.  So why don't we ask:</p>
<p><strong>Can we make the ZIP dialect something so compelling that anyone who wanted to make a ZIP file on GitHub Actions would be a fool not to use it, if it had a zero-effort usage pattern like the above?</strong></p>
<p>The dialect could take advantage of new parts in the box.  e.g. SET-BLOCK! if you want to use a different filename than what something has already:</p>
<pre><code>; Make a file in the zip called bar.txt, with contents of foo.txt
zip %output.zip [[%bar.txt]: %foo.txt]

; Make a file in the zip called foo.txt, with contents of foo.txt
zip %output.zip [%foo.txt]
</code></pre>
<p>Talking to <a class="mention" href="https://forum.rebol.info/u/blackattr">@BlackATTR</a> about it, I wondered if it's the kind of dialect where plain WORD!, PATH!, and TUPLE! should be interpreted as filenames, just to reduce the level of noise.  So <strong>readme.txt</strong> would be a legal alternative to <strong>%readme.txt</strong> and you would use GROUP!s to run code.  This introduces a lot of questions, <a href="https://forum.rebol.info/t/form-of-group-s-get-word-s/1543">but I've brought up the question elsewhere, e.g. with FORM</a>.</p>
<p>Playing along better with bash would be nice.  Maybe allow <strong>$ (some bash expression)</strong>?  I've got a post about a SHELL dialect I've been thinking about.</p>
<p>Anyway, if we can't do this, we probably can't do anything more complicated.  So it's time to start putting our code where our mouth is and seeing if this can actually make something anyone wanted to use.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/revisiting-the-zip-dialect/1548">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/revisiting-the-zip-dialect/1548</link>
          <pubDate>Wed, 10 Mar 2021 00:55:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1548</guid>
          <source url="https://forum.rebol.info/t/revisiting-the-zip-dialect/1548.rss">Revisiting The ZIP Dialect</source>
        </item>
        <item>
          <title>FORM of GROUP!s, GET-WORD!s...</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Trying to write shell code in Rebol, you notice that bash has a pretty strong advantage of putting together fragments of text with environment variables.</p>
<p>I think we'd have a leg up if there were a behavior in something that didn't reduce strings--like FORM--if it would make an exception for GROUP!s.</p>
<p>Historically you get something pretty useless:</p>
<pre><code>rebol2&gt;&gt; form [--sysroot (first [/foo /bar])]
== "--sysroot first /foo /bar"

red&gt;&gt; form [--sysroot (first [/foo /bar])]
 == "--sysroot first /foo /bar"
</code></pre>
<p>I don't see that helping a whole lot.  Evaluating the group would make more sense.</p>
<pre><code>&gt;&gt; form [--sysroot (first [/foo /bar])]
== "--sysroot /foo"
</code></pre>
<p>As an aside, I've always thought FORM is a weird name for this.  Maybe it needs a better name.</p>
<p>But whatever it is, I think we need something like it for putting together bash-like "sentences", without having to use so many quotes...because every character adds up:</p>
<pre><code>&gt;&gt; spaced [{--sysroot} (first ["/foo" "/bar"])]
== "--sysroot /foo"
</code></pre>
<p>I'll point out that having greater flexibility on what is a legal PATH!, permitting <strong>foo/bar/</strong> and <strong>/foo/</strong> etc. really is already helping a lot for common cases of writing shell-like scripts.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/form-of-group-s-get-word-s/1543">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/form-of-group-s-get-word-s/1543</link>
          <pubDate>Sun, 07 Mar 2021 03:50:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1543</guid>
          <source url="https://forum.rebol.info/t/form-of-group-s-get-word-s/1543.rss">FORM of GROUP!s, GET-WORD!s...</source>
        </item>
        <item>
          <title>Dissecting the ASSERT Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Another dialect to talk about while discussing the question of <a href="https://forum.rebol.info/t/pivotal-design-question-is-evaluator-state-just-a-block/1496">whether the evaluator can accrue state across evaluation steps</a> is ASSERT.</p>
<p>The idea of ASSERT is to let you put one expression after the other, and have it tested for "truthiness".</p>
<p><strong>ASSERT needs to do stepwise evaluation, test the result, and ideally report the expression that failed.</strong></p>
<h2>Historical Brittleness</h2>
<p>Since assert accepts multiple expressions, clipping it in the error makes sense so that you only see the expression that failed.</p>
<pre><code>&gt;&gt; assert [1 = 1 2 = 3 4 = 4]
** Script error: assertion failed for: [2 = 3]
</code></pre>
<p>So it has to copy the expression out to put in the error.  But for some reason, it only copies an arbitrary three items from the expression:</p>
<pre><code>r3-alpha&gt;&gt; assert [empty? first first [[[a]]]]  
** Script error: assertion failed for: [empty? first first]
</code></pre>
<p>This raises a number of questions about error reporting...as to whether this kind of copying makes sense in the first place, or if there should be some common services to help be more informative when providing the "near" information...to implicate the start of an expression instead of the end.</p>
<p>But as it's referring to the block, what if the block is modified?</p>
<pre><code>r3-alpha&gt;&gt; block: [not empty? clear block]

r3-alpha&gt;&gt; assert block
** Script error: assertion failed for: []
</code></pre>
<p>This is something Ren-C helps with, by locking the array during evaluation:</p>
<pre><code>ren-c &gt;&gt; block: [not empty? clear block]
== [not empty? clear block]

ren-c&gt;&gt; assert block
** Access Error: series has temporary read-only hold for iteration
** Where: clear evaluate while _ assert console
** Near: [*** empty? clear block **]
** Line: 1
</code></pre>
<h2>Invisibility in Ren-C</h2>
<p>A difference with Ren-C is that you can put an assert anywhere and it won't count against the evaluation:</p>
<pre><code> ren-c&gt;&gt; all [1 = 1, assert [2 = 2], 10 + 20]
 == 30

 ren-c&gt;&gt; any [1 = 2, assert [2 = 2], 10 + 20]
 == 30
</code></pre>
<p>R3-Alpha can't have it both ways...the behavior has to fall on the side of making assert return something either truthy or falsey:</p>
<pre><code>r3-alpha&gt;&gt; all [1 = 1 assert [2 = 2] 10 + 20] 
== 30  ; because the assert returned true

r3-alpha&gt;&gt; any [1 = 2 assert [2 = 2] 10 + 20]
== true  ; because the assert returned true
</code></pre>
<h2>Implementation Needs</h2>
<p>This gives an example of an abstraction that wants to be able to:</p>
<ul>
<li>record a position</li>
<li>perform an evaluation step</li>
<li>decide it doesn't like the evaluation result, and implicate the position it previously recorded</li>
</ul>
<p>I started the discussion about "state accumulation" with LET.  But let's talk about something like MACRO, which throws a more obvious wrench into this situation.</p>
<p>For instance, let's imagine:</p>
<pre><code>macroA: enfix macro [] [return [+ 2 =]]
macroB: macro [] [return [3 10 =]]

assert [1 macroA macroB 20]
</code></pre>
<p>The full expression being processed in practice would be <strong>assert [1 + 2 = 3 10 = 20]</strong> which should fail on the 10 = 20.</p>
<p>Here we have not just a desire to take single steps across a virtualized block, but also a desire to produce meaningful error messages.</p>
<p><strong>How to deal with this kind of situation?</strong>  We're in a position where we can probably get the evaluator to make the code work for a plain DO.  But when it comes to giving errors and single stepping, what parts are involved is not clear.  Is this something that should be forbidden, because the evaluator state is not entirely capturable in terms of the input block's positions?  If not forbidden, what sort of interface and mitigation would it need?</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/dissecting-the-assert-dialect/1508">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dissecting-the-assert-dialect/1508</link>
          <pubDate>Sun, 14 Feb 2021 21:28:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1508</guid>
          <source url="https://forum.rebol.info/t/dissecting-the-assert-dialect/1508.rss">Dissecting the ASSERT Dialect</source>
        </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Domains - AltRebol</title>
    <link>https://forum.rebol.info/c/domains/15</link>
    <description>Topics in the &#39;Domains&#39; category Applications of Rebol in various specialized subject domains.</description>
    
      <lastBuildDate>Sun, 21 Aug 2022 05:43:45 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/domains/15.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Matching Characters in BINARY! PARSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>In Rebol2, you can't match a character (or string) against a binary!:</p>
<pre><code>rebol2&gt;&gt; to binary! " "
== #{20}

rebol2&gt;&gt; parse #{20} [" "]
== false

rebol2&gt;&gt; parse #{20} [#" "]
== false
</code></pre>
<p>In Red and R3-Alpha, you can do both...</p>
<pre><code>red&gt;&gt; parse #{20} [" "]
== true

red&gt;&gt; parse #{20} [#" "]
== true
</code></pre>
<p>But their unicode model means they really don't know what they're doing in any general sense, and I'm sure whatever's under the hood is incoherent:</p>
<pre><code>red&gt;&gt; to binary! "Æ"
== #{C386}

red&gt;&gt; parse #{C386} ["Æ"]
== false
</code></pre>
<p>Ren-C is much more coherent!</p>
<pre><code>&gt;&gt; did parse #{C386} ["Æ"]
== #[true]
</code></pre>
<h2>So the PARSE Succeeds, but... what should it return?</h2>
<p>Right now a parse on a string returns the <em>rule</em> when it matches.</p>
<pre><code>&gt;&gt; rule: "cd"

&gt;&gt; result: parse "abcd" ["ab" rule]
== "cd"

&gt;&gt; append result "ef"
== "cdef"

&gt;&gt; rule
"cdef"
</code></pre>
<p><strong>This is clearly correct, because you don't want it to make a copy if it doesn't know if you're going to use the copy.</strong>  Basic rule matching should not produce a new series.</p>
<p>The same logic applies to BINARY!...but should it give you the string as a string, or aliased to its binary form?</p>
<pre><code>&gt;&gt; parse #{C386} ["Æ"]
== "Æ"  ; option 1

&gt;&gt; parse #{C386} ["Æ"]
== #{C386}  ; option 2
</code></pre>
<p>I think the answer is that you should match it as whatever form it was in the rule.</p>
<p>But then...how about something like BLANK!, which acts equivalently to space if the input is a string... or BLANK! if it's an array?</p>
<pre><code>&gt;&gt; parse [_] [_]
== _

&gt;&gt; parse " " [_]
== ???

&gt;&gt; parse #{20} [_]
== ???
</code></pre>
<p>If we're going with the idea of rule as being primacy, then the language of the match should be the same as the language of the rule... e.g. the above all return blank.</p>
<p>But this is something of a gray area, IMO.  I feel like blank is acting as a stand-in for space and should probably be looked at as if you said space.</p>
<pre><code>&gt;&gt; parse " " [_]
== #" "

&gt;&gt; parse #{20} [_]
== #" "  ; instead of 32
</code></pre>
<p>So this is what I'm going with, unless someone has a really good argument for something else.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/matching-characters-in-binary-parse/1935">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/matching-characters-in-binary-parse/1935</link>
          <pubDate>Sun, 21 Aug 2022 05:43:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1935</guid>
          <source url="https://forum.rebol.info/t/matching-characters-in-binary-parse/1935.rss">Matching Characters in BINARY! PARSE</source>
        </item>
        <item>
          <title>Calling Ren Functions From Redbol</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>When you <strong><code>import @redbol</code></strong> the environment for your module is skinned with the Redbol definitions.  But it can run concurrently with non-Redbol modules in the same session.  This is very cool.</p>
<p>I've nudged it a little further into cool by having the definition of LIB in Redbol be the initial state of the Redbol definitions, and then REN is the Ren-C's version of LIB.</p>
<pre><code>&gt;&gt; import @redbol

&gt;&gt; append [a b c] [d e]
== [a b c d e]

&gt;&gt; append/only [a b c] [d e]
== [a b c [d e]]

&gt;&gt; ren/append [a b c] [d e]
== [a b c [d e]]

&gt;&gt; ren/append [a b c] ren/spread [d e]
== [a b c d e]

&gt;&gt; append: does [print "Overwritten"]
== #[action! {append} []]

&gt;&gt; append
Overwritten

&gt;&gt; lib/append [a b c] [d e]
== [a b c d e]
</code></pre>
<p><em>Pretty slick.</em></p>
<h2>But IMPORT is Ultimately Not The Right Mechanism</h2>
<p>Because it's done using import, Redbol does not "clear out" the space of all the Ren-Cisms.</p>
<p>In fact, I didn't actually have to say <strong>ren/spread</strong> because the spread definition is still available:</p>
<pre><code>&gt;&gt; ren/append [a b c] spread [d e]
== [a b c d e]
</code></pre>
<p>It's non-viable to ask Redbol to remove every Ren-C definition.  Instead, there needs to be a way to get a Redbol-using module to start from a fully clean slate where it explicitly exports everything it wants to make available.  This doesn't have to be that much work, it can just be a list of words in a block, with possible renamings:</p>
<pre><code>redbol-inherit [even?, odd?, value?: unset? ...]
</code></pre>
<h2>These Challenges Are Great For Vetting</h2>
<p>I don't throw softballs.  This is all truly attempting to live up to the hype of a language that you can bend and redefine at will, without constantly tripping over your own changes--and being able to build on top of existing functionality without being forced to rewrite it too.</p>
<p>Although things move slowly... the arrow of progress is in the right direction.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/calling-ren-functions-from-redbol/1934">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/calling-ren-functions-from-redbol/1934</link>
          <pubDate>Sat, 20 Aug 2022 21:05:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1934</guid>
          <source url="https://forum.rebol.info/t/calling-ren-functions-from-redbol/1934.rss">Calling Ren Functions From Redbol</source>
        </item>
        <item>
          <title>TRY PARSE + PARSE EXCEPT : *FAIL* On Mismatch</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>There's a snazzy new potential for giving more informative messages / logs from failed parses... which means we now have a more interesting option than we might have had before.</p>
<p>Imagine something like:</p>
<pre><code>&gt;&gt; parse "aaa" [some "a" some "b"]
** Error: SOME requires at least one match
** Where: [some "a" \\ some "b" \\]
; Note: this failure can be intercepted by TRY, EXCEPT, ATTEMPT
</code></pre>
<p>It can't be perfect unless it maintains some kind of large error tree that accumulates the list of all the reasons it decided to fail, so you might have to be in a debugging mode to ask it to give you a bigger diagnostic.  But we can build it now with the participation of the combinators themselves.</p>
<p><strong>But not only this, we could open up the full spectrum of return values.</strong>  Right now if your parse returns NULL, it has to be contorted into a null isotope to avoid accidentally cuing an ELSE.  Similar contortions for void, blank, and logic false.</p>
<pre><code>result: parse block rules except e -&gt; [print "Got an error", return]

; If you got here, you know result is good
; Even if it was a purposefully returned NULL, etc.
</code></pre>
<p>There'd be some way to rig this up without using enfix.  I might make things more lax about letting you assign error isotopes, because the isotope will bubble through and cause a problem anyway.  So you could write something like:</p>
<pre><code> if fail? result: parse block rules [
     print "You have a failure, use ^result to get it"
 ]
</code></pre>
<p>If you were willing to collapse failure down to a NULL or somesuch, or didn't even care about the result, you could just TRY it.</p>
<pre><code> try parse block rules
</code></pre>
<h2>Too Good Not To Be The Default</h2>
<p>Of course you'll be able to reskin it however you like for the R3C's or R3Chius out there.  But I think this looks like a perfect convergence to put in the box.</p>
<p>Errors aren't going to be that interesting on day one, but it's good to point the ship in the right direction.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/try-parse-parse-except-fail-on-mismatch/1924">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/try-parse-parse-except-fail-on-mismatch/1924</link>
          <pubDate>Fri, 19 Aug 2022 06:23:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1924</guid>
          <source url="https://forum.rebol.info/t/try-parse-parse-except-fail-on-mismatch/1924.rss">TRY PARSE + PARSE EXCEPT : *FAIL* On Mismatch</source>
        </item>
        <item>
          <title>Wish: Multi-Returns For UPARSE Combinators</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Every combinator has a synthesized value.  But some combinators throw away values synthesized by their parser parameters.</p>
<p>For instance, TALLY.</p>
<pre><code>&gt;&gt; parse [1020 304] [int: some integer!]
== 304

&gt;&gt; parse [1020 304] [count: tally some integer!]
== 2
</code></pre>
<p>TALLY knows what the result of the last call it made was, but doesn't preserve it.  What if you could?</p>
<pre><code>&gt;&gt; parse [1020 304] [[count int]: tally some integer!]
== 2

&gt;&gt; count
== 2

&gt;&gt; int
== 304
</code></pre>
<p>That particular one is not necessarily a very interesting example, since you could get it yourself...</p>
<pre><code>parse [1020 304] [count: tally int: some integer!]
</code></pre>
<p>I only mention it because it was in a comment in UPARSE I wanted to delete, because it's a long enough file without becoming a wishlist compilation.  :-/</p>
<p>But there are certainly going to be other examples of combinators that might want to synthesize more than one value.  So hopefully the feature can be implemented at some point...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/wish-multi-returns-for-uparse-combinators/1920">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/wish-multi-returns-for-uparse-combinators/1920</link>
          <pubDate>Wed, 17 Aug 2022 14:43:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1920</guid>
          <source url="https://forum.rebol.info/t/wish-multi-returns-for-uparse-combinators/1920.rss">Wish: Multi-Returns For UPARSE Combinators</source>
        </item>
        <item>
          <title>Calling Combinators (Decoders?) as Normal Functions</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>A few times I've talked about the potential of making it possible to call a COMBINATOR function from outside of PARSE.</p>
<p>This is to say that if some PARSE-specific parameter was missing (e.g. the "parse state") there'd be a mode in the guts of the COMBINATOR mechanic which cooked up something like a temporary parse session just for the input you passed in.</p>
<h2>Would It "Combinate" Parsers For You?</h2>
<p>The situations I had in mind weren't really combinators that take parsers as parameters.  And now that I look at it, I think that suggests that... no, you probably shouldn't call these kinds of combinators outside of parse.</p>
<p>Here's one imagination of calling a combinator like SOME:</p>
<pre><code>&gt;&gt; [value rest]: some "aaaabbb" [repeat 2 "a"]
== "a"

&gt;&gt; value
== "a"

&gt;&gt; rest
== "bbb"
</code></pre>
<p>This exposes how SOME is actually not arity-1.  Though it takes a "combinated parser" as a parameter, it also takes an INPUT...but that's usually implicit...specialized in by PARSE.  But calling directly from normal code it could offer that parameter being gathered normally.</p>
<p>it doesn't feel that compelling, since you're getting a synonym for:</p>
<pre><code>parse "aaaabbb" [some repeat 2 "a"]
</code></pre>
<p>But also, why would it take that interpretation instead of:</p>
<pre><code>parse "aaaabbb" [some ([repeat 2 "a"])]
</code></pre>
<p>One point of view would say it makes more sense to think of the expression as the product of evaluation, because the argument would presumably be otherwise evaluative:</p>
<pre><code>&gt;&gt; [value rest]: some "aaaabbb" append [repeat 2] "a"
== ??? ; infinite loop?
</code></pre>
<p>But this would make rule-taking combinators nearly useless.</p>
<h2>It Was Suggested For Sharing "Decoding", not "Combinating"</h2>
<p>Seeing how SOME isn't a good example for this, maybe the right way of saying what I'm trying to say here this is that there's some category of functions we might call "decoders"...and PARSE would be willing to call these.</p>
<p>They'd fit a standard format regarding things like taking an input series and giving back an amount of progress or an error.  But they would not be passed something like the parser stack or have any automatic composition of parsers as arguments.</p>
<p>Plain decoding operations--like <a href="https://forum.rebol.info/t/binary-dialected-encoding-decoding-instead-of-to-conversions/1270">ENBIN and DEBIN</a>--were the motivating cases:</p>
<pre><code>&gt;&gt; debin #{FEFFFF} [le + 3]
== 16777214

&gt;&gt; parse #{FEFFFFFEFFFF} [collect [keep debin [le + 3]]]
== [16777214 16777214]
</code></pre>
<p>The idea here was that you could write one version of DEBIN, and it would be able to implicitly pick up the INPUT when used in PARSE.</p>
<p>But because the input is an implicit parameter that you get automatically for all "decoders", then without extra information it would have to be at either the beginning or end of the parameter list.  Above it's at the beginning, which is different from how DEBIN was defined originally:</p>
<pre><code>&gt;&gt; debin [le + 3] #{FEFFFF}  ; original DEBIN design took dialect block first
== 16777214
</code></pre>
<p><em>(Note: I have a post about <a href="https://forum.rebol.info/t/parameter-order-in-rebol/1238">parameter ordering</a> which questions the series-first model.)</em></p>
<p>We could say that "decoders" have to manually mention their input parameter somewhere, and position it in the order that it would be consumed if it's used outside of PARSE...which would allow customization of this process.  It could default to being the first parameter if not positioned explicitly.  Not an idea-killer, in any case.</p>
<h2>If All The Input Wasn't Consumed, It Would Error</h2>
<p>One idea of calling these decoders on arbitrary input could be that if the end of input was not reached, it would give an error:</p>
<pre><code>&gt;&gt; debin [le + 3] #{FEFFFF00}  ; asking for 3 bytes of decode, passed 4
** Error: DEBIN did not consume all input, request remainder if intentional
</code></pre>
<p>Asking for a remainder could prevent the error:</p>
<pre><code>&gt;&gt; [value rest]: debin [le + 3] #{FEFFFF00}
== 16777214

&gt;&gt; rest
== #{00}
</code></pre>
<p>So this is kind of where the motivation is.  Once you've written the decoder version of DEBIN, you have everything you need to run a DEBIN operation inside or outside of PARSE.  So why should you need to write a separate combinator and non-combinator form?</p>
<h2>I Was Thinking About This Now Because of TRY</h2>
<p>I'm putting together some thoughts where if TRY is the way you say it's okay if a combinator doesn't succeed in PARSE, what would the behavior be outside of PARSE?</p>
<p>Up until now we've said that NULL is the reserved result for combinator failure.  But I've put forth the idea that NULL might be a legitimate combinator result, and so definitional errors could be used to say that an operation did not meet its requirements.</p>
<p>So now...how about these "decoders"?  Should a decoder run in isolation raise an error if it doesn't work, or should it just return NULL?</p>
<p><strong>It seems clear that at least <em>some</em> operations should raise errors instead of passively returning NULL.</strong>  If you ask to decode an invalid stream, it should be noisy about that failure.</p>
<p>I believe that some of these errors shouldn't be defused by TRY.  For instance, <strong>debin #{FEFFFF} [banana + 3]</strong>... that's an inability to understand what you're even asking.  To me this is on par with typos or passing invalid types; they are a sign of downright incorrect code, not the kind of thing that something like ATTEMPT should be able to ignore...much less should TRY quiet them.</p>
<h2>So...What Should Count As Things TRY Defuses?</h2>
<p>At first, the TRY error was specifically tied to the idea of a special error that happened when inputs were NULL.  This required special code in the FUNC typechecking, because by default a typechecking error does not produce a definitional error that can be trapped with something like EXCEPT.</p>
<p>Now I've expanded the idea that the word was short and useful enough that it might be used for any case where there were no adverse side effects, and a function wanted to say it simply couldn't do the thing it was asked to do.</p>
<p>Might we say that <em>all definitional errors</em> fit under this category?  That you shouldn't do <strong>return raise [...]</strong> unless the error can be swept under the rug by a TRY?  Does this suggest a "value surrogate" for TRY is a generic thing that any error can carry (if you TRY me, convert to this value).  Or is that just a characteristic of errors that TRY is willing to defuse?</p>
<p>As usual, more thought needed.  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_head_bandage.png?v=9" title=":face_with_head_bandage:" class="emoji" alt=":face_with_head_bandage:"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/calling-combinators-decoders-as-normal-functions/1914">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/calling-combinators-decoders-as-normal-functions/1914</link>
          <pubDate>Mon, 15 Aug 2022 07:39:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1914</guid>
          <source url="https://forum.rebol.info/t/calling-combinators-decoders-as-normal-functions/1914.rss">Calling Combinators (Decoders?) as Normal Functions</source>
        </item>
        <item>
          <title>What&#39;s Cool (According to Danny)</title>
          <dc:creator><![CDATA[Danny]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Photos are nice. complex. but some how easy to understand most of the time without having to know the "who, what, when, where, and why." Just by looking at them, you can kinda tell what it's trying to show you. I want Rebol coding to look like that while working with any data context in its original form as possible.</p>
<blockquote>
<p>**<br>
var {whats-cool 0: Brett}<br>
Var Rebdol: {Rebdol cool: "what's-cool"}**</p>
</blockquote>
<p>The <a href="http://www.rebol.org/view-script.r?script=rebol-dom.r" rel="noopener nofollow ugc">%Rebol-dom.r</a> Var is named from the associated value strings/words, unless you *!, select-all-fetch-as strings/words. Then you can, Rebdol."cool" -&gt;select &amp; load "what's-cool". Wich is, whats-cool: { 0: Brett}. Then .[0], and  you get Brett.</p>
<p>Or change the *value to Ren-C. **</p>
<blockquote>
<p>whats-cool [ /rebdol.cool.&amp;.0 = Ren-C] <em>messy, noisy example</em><br>
**</p>
</blockquote>
<p>Is this musing when the origonal data context does'nt need to be changed. And if parsed into a Dialect Object Model, without changing syntax, this data can be searched, updated with DOM functions.</p>
<p>Creating Vars out of molded data/code with foreign syntax, is its own Sequence built notation.</p>
<blockquote>
<pre><code>struct: :Var

 struct qwerty {
                   Int #1
                   Char "hello"
                   Float 9.0
                   Char "there"
                } *! 'qwerty

*variable: "request" new[qwerty]
</code></pre>
</blockquote>
<p>This data looks like and can be used to construct *New nodes that can run as code without creating defined functions but remain as sequence(molded) data that needs no bindings or loading to take place.</p>
<p>I hope this is musing, for others as it is for me. Rebol-dom.r Sequence/molded data, strings as *keys have context all without loading anything but the *value. It's what i found and fished out of that Deep Lake.</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/whats-cool-according-to-danny/1906">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/whats-cool-according-to-danny/1906</link>
          <pubDate>Fri, 29 Jul 2022 23:42:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1906</guid>
          <source url="https://forum.rebol.info/t/whats-cool-according-to-danny/1906.rss">What&#39;s Cool (According to Danny)</source>
        </item>
        <item>
          <title>Could we replace PARSE&#39;s OPT with TRY ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Just a week ago, things stood at the idea that TRY was for "defusing NULL" by turning it into a BLANK!:</p>
<pre><code>&gt;&gt; try null
== _  ; tolerated by some functions that would not tolerate NULL
</code></pre>
<p>But that's all out the window, now.  TRY is for saying <em>"hey, wait, don't fail... you can be a no-op, that's fine."</em>  Nothing to do with blanks anymore.</p>
<p><strong>This makes it a candidate for being a very literate alternative to OPT in parse!</strong></p>
<pre><code>&gt;&gt; parse "aaaccc" [some "a", try some "b", some "c"]
== "c"
</code></pre>
<p>It helps make the loss of "ANY" as a looping construct more palatable, as <strong><code>try some</code></strong>  is easier on the eyes than <strong><code>opt some</code></strong>.</p>
<p><strong>But...what about conflation with the purpose of defusing NULL arguments?</strong></p>
<pre><code>&gt;&gt; rule: null

&gt;&gt; parse "aaaccc" [some "a", try some rule, some "c"]
== "c"  ; ???
</code></pre>
<p>Hmmm.  And what if you wanted to require it <em>unless</em> it was null?</p>
<pre><code>&gt;&gt; rule: "b"

&gt;&gt; parse "aaaccc" [some "a", try some rule, some "c"]
; null  (e.g. conceptually I was TRY-ing RULE, not the SOME)
</code></pre>
<p>That doesn't feel right.  And I don't like the idea that we'd be seeing things like <strong>opt try some rule</strong> on any kind of regular basis.</p>
<h2>Let's Remember: This is a Dialect</h2>
<p>Things are already stretched around a bit, and we make things line up when they make sense...and unalign them when they do not.</p>
<p><strong>We're free to say that TRY has nothing (or little?) to do with tolerating NULL inputs to parse rules, but where it shares heritage in meaning is "a no-op here is okay".</strong></p>
<p>I think there are two reasonable options:</p>
<ol>
<li>
<p>Keep the current policy that most times, passing a NULL to rules is an error.  If you want a no-op rule, use <strong><code>[]</code></strong> or for more efficiency, <strong>(the ')</strong> (a quoted null)</p>
<ul>
<li>
<p>So this would mean that the decision is on a per-combinator basis, vs. saying all parser arguments to combinators are implicitly <code>[&lt;try&gt;]</code> ... and so things like SOME would not choose to label its argument that way.</p>
</li>
<li>
<p>Exceptions could be made for things like SEEK, where <strong>try seek (null)</strong> would be a way to say it's okay if you don't provide a seek position.</p>
</li>
</ul>
</li>
<li>
<p>Systemically allow conflation on all combinators, where <strong>some null</strong> errors but <strong>try some null</strong> is legal.</p>
</li>
</ol>
<p>Off the top of my head here, I think (1) is probably the better choice.  If someone disagrees, we might want to make it easier to change via a switch vs. having to copy all the combinators and add <code>&lt;try&gt;</code> to their arguments.</p>
<p>But I <em>definitely</em> don't like the idea that a rule prefaced with TRY would be expected to succeed if its argument were non-null.  TRY should mean the rule cannot fail its match (other than by raising an error).</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/could-we-replace-parses-opt-with-try/1888">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/could-we-replace-parses-opt-with-try/1888</link>
          <pubDate>Sat, 16 Jul 2022 15:36:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1888</guid>
          <source url="https://forum.rebol.info/t/could-we-replace-parses-opt-with-try/1888.rss">Could we replace PARSE&#39;s OPT with TRY ?</source>
        </item>
        <item>
          <title>VID/S or Spaces, from Red&#39;s hiiamboris</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>GUI</category>
          <description><![CDATA[
            <p>I haven't looked at it closely, but what I find interesting is that the demos are trying to show some non-trivial looking things:</p>
<p><a href="https://codeberg.org/hiiamboris/red-spaces" class="inline-onebox">hiiamboris/red-spaces: Draw based widgets for Red - red-spaces - Codeberg.org</a></p>
<p>Here's the code for editing text on a spiral:</p>
<p><a href="https://codeberg.org/hiiamboris/red-spaces/src/branch/master/tests/spiral-test.red" class="inline-onebox">red-spaces/spiral-test.red at master - red-spaces - Codeberg.org</a></p>
<p>I guess there's nothing particularly remarkable about it, in the sense that it's just a clickable canvas...drawing the whole thing every time.  Modern computers just happen to be pretty fast, so duplicating a couple of lorem ipsum texts 10 times isn't going to create all that much of a barrier to doing such a thing...even if Red is nothing special.</p>
<p>What I'd consider "remarkable" would be if there was some design whereby you were inheriting selection behavior...so it was doing some kind of behavior-preserving coordinate transformation on a fully functional text editor widget.  It's not.</p>
<p>So that sort of dampens my interest in looking too much deeper.</p>
<p>The "rotate a form" demo is a more behavior-preserving example, but not a particularly profound one.  I'm not completely sure what the pitch is.  CSS can do transforms, too.  3-D even.</p>
<p><a href="https://impress.js.org/#/bored" class="inline-onebox">impress.js | presentation tool based on the power of CSS3 transforms and transitions in modern browsers | by Bartek Szopka @bartaz</a></p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/vid-s-or-spaces-from-reds-hiiamboris/1886">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/vid-s-or-spaces-from-reds-hiiamboris/1886</link>
          <pubDate>Sat, 16 Jul 2022 13:21:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1886</guid>
          <source url="https://forum.rebol.info/t/vid-s-or-spaces-from-reds-hiiamboris/1886.rss">VID/S or Spaces, from Red&#39;s hiiamboris</source>
        </item>
        <item>
          <title>`tac` : Implementation of UNIX&#39;s line reverser</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>System Tools</category>
          <description><![CDATA[
            <p>I mentioned I wanted to study some basic utilities...even more basic than <a href="https://forum.rebol.info/t/greb-grep-using-parse/1818">greb</a>.  Small codebases can put a focus on big design points.</p>
<p>Here was my off-the-cuff line-reverser (TAC ... reverse CAT, where CAT is like Windows Command Shell's TYPE).  I wrote it a year ago, while I was solely focused on getting READ-LINE to work from piped input cross platform at the time...so almost no thought went into it:</p>
<pre><code>; %tac.r, version 0.0.1
;
; * COLLECT the lines
; * REVERSE the collection
; * output the result DELIMIT-ed with newline
;
write-stdout try delimit/tail newline reverse collect [
    until [not keep line: try read-line]
]
</code></pre>
<p><em>Right off the bat, you can see it's using twice the memory it needs to.</em>   It's collecting a block of strings, and then while that whole block is in memory it merges it into one giant string before output.  At minimum, this should loop and write the strings out of the block out one at a time.  (Though doing it this way does draw attention to an interesting point about DELIMIT, which I'll get to later.)</p>
<blockquote>
<p>Note: This line-reversing task is one of those pathological cases that can't be done in a "streaming" way.  You can't start writing anything to the output until you've read the input to the end.  (Doing better needs a random-access I/O PORT! that can SEEK the end of the file and go backwards...but the standard input device can't do this.)</p>
</blockquote>
<h2>But First Things First: The Impact of <a href="https://forum.rebol.info/t/definitional-errors-as-blank-in-null-out-alternative/1880">the New TRY Rules</a>
</h2>
<p>Recall that the old behavior was that TRY would turn NULL into BLANK! in order to stop functions from raising an error on those NULLs.  So here:</p>
<ul>
<li>
<p>we'd stop KEEP from failing when there are no more lines to READ-LINE from, so it acts as a no-op instead</p>
</li>
<li>
<p>we'd stop WRITE-STDOUT from failing when an empty block is collected and DELIMIT returns NULL:</p>
<pre><code>write-stdout try delimit/tail newline reverse collect [  ; TRY DELIMIT =&gt; BLANK!
  until [not keep line: try read-line]  ; TRY READ-LINE =&gt; BLANK!
]
</code></pre>
</li>
</ul>
<p>The new way <img src="https://forum.rebol.info/images/emoji/twitter/sparkles.png?v=9" title=":sparkles:" class="emoji" alt=":sparkles:"> is you go ahead and pass the NULL, and the function raises a very narrow error.  This error is caught by a TRY on the function call itself.</p>
<p>So applying that transformation:</p>
<pre><code>try write-stdout delimit/tail newline reverse collect [  ; TRY WRITE-STDOUT =&gt; NULL
    until [not try keep line: read-line]  ; TRY KEEP =&gt; NULL
]
</code></pre>
<h2>Why Does DELIMIT Ever Return NULL ?</h2>
<p>One might ask if it should never be able to return NULL when you use /TAIL.  At the moment, it does:</p>
<pre><code>&gt;&gt; delimit/tail "," ["a" "b"]
== "a,b,"

&gt;&gt; delimit []
; null

&gt;&gt; delimit/tail "," []
; null
</code></pre>
<p>Maybe that last one should be "," ?  Perhaps when you have /HEAD or /TAIL, you never get null back.</p>
<p>But... let's stick to looking at the use cases.</p>
<h2>What Does %tac.r Want From DELIMIT/TAIL Here?</h2>
<p>If we look at the edge case here, there is a difference between these two situations:</p>
<ul>
<li>
<p>The first call to READ-LINE returns an empty string, and the second call returns NULL</p>
<ul>
<li>
<p>This happens when you pipe in a 1-byte file containing a single line feed, e.g. a file containing one line that's empty.</p>
</li>
<li>
<p>With the code above, COLLECT produces the block <strong><code>[""]</code></strong> for this case</p>
</li>
</ul>
</li>
<li>
<p>The first call to READ-LINE returns NULL</p>
<ul>
<li>
<p>This happens when you pipe in a 0-byte file, e.g. a file containing no lines at all</p>
</li>
<li>
<p>With the code above, COLLECT produces the block <strong><code>[]</code></strong> for this case.</p>
</li>
</ul>
</li>
</ul>
<p><strong>So perhaps you see why DELIMIT chooses to react with some kind of signal when the block contents vaporize.</strong>  It's precisely because cases like this tend to need some kind of special handling, and it's not good to gloss over that.</p>
<p>In this case, the empty block (which corresponds to the 0-byte file input, e.g. 0 lines) should result in there being no write to the output.  So the default behavior of TRY WRITE-STDOUT NULL is the right answer.</p>
<h2>More to Study, I Just Thought That Bit Was Interesting...</h2>
<hr>
<blockquote>
<p><em>"There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no obvious deficiencies. The first method is far more difficult."</em></p>
</blockquote>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/tac-implementation-of-unixs-line-reverser/1883">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/tac-implementation-of-unixs-line-reverser/1883</link>
          <pubDate>Sat, 16 Jul 2022 04:16:07 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1883</guid>
          <source url="https://forum.rebol.info/t/tac-implementation-of-unixs-line-reverser/1883.rss">`tac` : Implementation of UNIX&#39;s line reverser</source>
        </item>
        <item>
          <title>FIND treats TYPESET!s specially...why not functions?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>In Rebol2, R3-Alpha, and Red...doing a FIND searching for a TYPESET! will give you the first instance of that type in a block:</p>
<pre><code>&gt;&gt; find [1 2 "abc" 3 4] any-string!
== ["abc" 3 4]

&gt;&gt; find [1 2 &lt;abc&gt; 3 4] any-string!
== [&lt;abc&gt; 3 4]
</code></pre>
<p>One would think that you'd be able to search for the typeset literally by using /ONLY.  But that doesn't work <em>(though Red says <a href="https://github.com/red/red/issues/4911">they addressed this recently</a>)</em></p>
<h3>Why Wasn't This Taken Further?</h3>
<p>Trying to FIND a function is pretty rare.  So why didn't they make it so that passing a function to FIND makes it search?</p>
<pre><code>&gt;&gt; find [1 2 3 4] func [x] [x &gt; 2]
== [3 4]
</code></pre>
<p>If a function took multiple arguments, that could be asking it to effectively /SKIP and group items at a time:</p>
<pre><code>&gt;&gt; find [1 2 4 3 5 6] func [a b] [a &gt; b]
== [4 3 5 6]
</code></pre>
<p>/ONLY could have worked for finding a function literally:</p>
<pre><code>&gt;&gt; find/only reduce [:positive? :zero? :negative?] :zero?
== [#[native! zero?...] #[native! negative?...]]
</code></pre>
<h3>Ren-C goes with QUOTED! vs. /ONLY, but same basic premise</h3>
<pre><code>&gt;&gt; find [1 0 2 0] :zero?
== [0 2 0]

&gt;&gt; find reduce [:positive? :zero? :negative?] quote :zero?
== [#[native! zero?...] #[native! negative?...]]
</code></pre>
<h3>Though It Seems Easy To Make Mistakes...</h3>
<p>People are invariably going to write <strong>find data value</strong>...think it works for a few values they try...and assume it works for others.  Redbols are notorious for pulling the rug out from under you with such things.</p>
<p>But if you're willing to do this for typesets, I don't see why doing it for functions is that much worse.</p>
<p>Just something to think about.</p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/find-treats-typeset-s-specially-why-not-functions/1881">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/find-treats-typeset-s-specially-why-not-functions/1881</link>
          <pubDate>Thu, 14 Jul 2022 10:36:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1881</guid>
          <source url="https://forum.rebol.info/t/find-treats-typeset-s-specially-why-not-functions/1881.rss">FIND treats TYPESET!s specially...why not functions?</source>
        </item>
        <item>
          <title>DESTRUCTURE Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>I've talked about this.  But there's no excuse not to write it, when there's so much power in modern PARSE <em>(the engine we up until recently called UPARSE)</em>.</p>
<p>A simple motivating case was a desire for different behavior from PARSE alternates with <strong><code>|</code></strong>.  So while <strong>[word! | word! word!]</strong> is always considered to be a badly-written parse rule, you could get a different treatment in destructure...because it always assumes you mean to go to <code>&lt;end&gt;</code></p>
<pre><code>&gt;&gt; destructure [banana] [
      [word!] =&gt; [print "Just one word"]
      [word! word!] =&gt; [print "Two words"]
   ]
Just one word

&gt;&gt; destructure [apple banana] [
      [word!] =&gt; [print "Just one word"]  ; not complete, so no match
      [word! word!] =&gt; [print "Two words"]
   ]
Two words
</code></pre>
<p>But the dialect concept is more ambitious than that, allowing you to give names to capture rules.  Then when you use those names, that's the variable that is set:</p>
<pre><code>&gt;&gt; destructure [apple banana] [
      w1: [word!] w2: [word!]

      [w1] =&gt; [print ["One:" w1]]
      [w1 w2] =&gt; [print ["Two:" w1 w2]]
   ]
Two: apple banana
</code></pre>
<p>And because what's actually powering this behind the scenes is PARSE, you have all those tools at your disposal...including the just-added <a href="https://forum.rebol.info/t/the-yada-yada-yada-combinator/1876">ellipsis operator</a>!</p>
<pre><code>&gt;&gt; destructure [1 2 apple banana 3 4 5] [
      w1: [word!] w2: [word!]

      [w1] =&gt; [print ["One:" w1]]
      [w1 w2] =&gt; [print ["Two:" w1 w2]]
      [... w1 w2 ...] =&gt; [print ["Words and more stuff:" w1 w2]]
   ]
Words and more stuff: apple banana
</code></pre>
<h2>A Crazy Short Implementation!</h2>
<p>I'm sure it will receive some enhancements, but... this is pretty badass for something I wrote that worked more or less the first time!</p>
<pre><code>destructure: func [
    input [any-series!]
    dialect [block!]
    /multi "Run multiple branches"
    &lt;local&gt; result' name rule pattern branch combinators
][
    result': @void
    combinators: copy default-combinators
    parse dialect [while [not &lt;end&gt;] [
        name: to-word/ set-word!, rule: block! (
            combinators.(name): compose [(name): (rule)]
        )
        |
        pattern: block!, '=&gt;, branch: block!
        (
            parse/combinators input pattern combinators then (
                branch
            ) also ^r' -&gt; [
                if not multi [
                    return unmeta r'
                ]
                result': r'
            ]
        )
        |
        fail "Invalid DESTRUCTURE dialect entry"
    ]]
    return unmeta result'
]
</code></pre>
<h2>And It's Composable, Too!</h2>
<p>That's right... you can use DESTRUCTURE with ELSE and THEN.</p>
<p>It follows the rules; a destructure that does not match anything is void!</p>
<pre><code>&gt;&gt; 1 + 2 destructure [a] [[integer!] =&gt; [print "Not happening"]]
== 3
</code></pre>
<p>Notice I even threw a /MULTI feature in there, so you can match multiple ways!</p>
<pre><code>&gt;&gt; destructure/multi [apple banana] [
      w1: [word!] w2: [word!]

      [w1] =&gt; [print ["One:" w1]]
      [w1 w2] =&gt; [print ["Two:" w1 w2]]
      [repeat 2 &lt;any&gt;] =&gt; [print "Matching any two values also counts"]
   ]
Two: apple banana
Matching any two values also counts
</code></pre>
<hr>
<h1>
<img src="https://forum.rebol.info/images/emoji/twitter/boom.png?v=9" title=":boom:" class="emoji" alt=":boom:"> <img src="https://forum.rebol.info/images/emoji/twitter/raised_hand_with_fingers_splayed.png?v=9" title=":raised_hand_with_fingers_splayed:" class="emoji" alt=":raised_hand_with_fingers_splayed:"> <img src="https://forum.rebol.info/images/emoji/twitter/electric_plug.png?v=9" title=":electric_plug:" class="emoji" alt=":electric_plug:">  POWER, IN YOUR HANDS! <img src="https://forum.rebol.info/images/emoji/twitter/electric_plug.png?v=9" title=":electric_plug:" class="emoji" alt=":electric_plug:"> <img src="https://forum.rebol.info/images/emoji/twitter/raised_hand_with_fingers_splayed.png?v=9" title=":raised_hand_with_fingers_splayed:" class="emoji" alt=":raised_hand_with_fingers_splayed:">  <img src="https://forum.rebol.info/images/emoji/twitter/boom.png?v=9" title=":boom:" class="emoji" alt=":boom:">
</h1>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/destructure-dialect/1877">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/destructure-dialect/1877</link>
          <pubDate>Tue, 12 Jul 2022 15:52:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1877</guid>
          <source url="https://forum.rebol.info/t/destructure-dialect/1877.rss">DESTRUCTURE Dialect</source>
        </item>
        <item>
          <title>The &quot;Yada Yada Yada&quot; Operator (...)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>It seemed we could have a shorter way to say <strong><code>to &lt;end&gt;</code></strong> (or <strong><code>thru &lt;end&gt;</code></strong>, they act the same).</p>
<pre><code> &gt;&gt; parse "aabbcc" [some "a" to &lt;end&gt;]
 == ""
</code></pre>
<p>In fact, what you want more often is probably <strong><code>elide to &lt;end&gt;</code></strong>.  Because the <strong><code>&lt;end&gt;</code></strong> combinator currently evaluates to the end position of the series (hence the "" you see above, as the TO returns what its argument evaluates to.)</p>
<pre><code> &gt;&gt; parse "aabbbcc" [some "a" elide to &lt;end&gt;]
 == "a"
</code></pre>
<p>A kind of obvious choice for meaning this would be <strong><code>...</code></strong></p>
<pre><code> &gt;&gt; parse "aabbbcc" [some "a" ...]
 == "a"
</code></pre>
<p><sub><em>(Initially I was skeptical of using <code>...</code> without some decoration, and did this with the TAG! of <code>&lt;...&gt;</code>, but I think the reasons I was skeptical are probably not good reasons, and we should go ahead and make it  easier on the eyes and easier to type.)</em></sub></p>
<h2>But Why Should It Only Work At The End?</h2>
<p>This seems useful:</p>
<pre><code> &gt;&gt; parse "aabbbcc" [... some "b" ...]
 == "b"
</code></pre>
<p>But isn't that just a synonym for THRU, with the exception that if there's nothing to go THRU it assumes you mean <code>&lt;end&gt;</code> ?</p>
<p><em>Well, a synonym for THRU isn't really what you want.</em>  You'd probably like this to work:</p>
<pre><code> &gt;&gt; parse "aabbbcc" [... some "x" | some "b" ...]
 == "b"
</code></pre>
<p>In essence, you want it to implicitly wrap anything to the right--up to the next <code>&lt;...&gt;</code>--in a BLOCK!, so act equivalently to:</p>
<pre><code> &gt;&gt; parse "aabbbcc" [thru [some "x" | some "b"] elide to &lt;end&gt;]
 == "b"
</code></pre>
<p>That's not possible for a normal combinator, you'd need a variadic one.</p>
<p>Today's approximation of variadic combinators is to just special-case the implementation directly in the BLOCK! combinator.</p>
<p><strong>So...that's what I've done!</strong></p>
<p>A more elegant way of writing the feature may come down the pipe someday.  But this gives us a version we can use in the here and now.</p>
<p>It's experimental, so use with caution.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/man_scientist.png?v=9" title=":man_scientist:" class="emoji only-emoji" alt=":man_scientist:"></p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-yada-yada-yada-operator/1876">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-yada-yada-yada-operator/1876</link>
          <pubDate>Tue, 12 Jul 2022 14:55:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1876</guid>
          <source url="https://forum.rebol.info/t/the-yada-yada-yada-operator/1876.rss">The &quot;Yada Yada Yada&quot; Operator (...)</source>
        </item>
        <item>
          <title>Semantics of UPARSE&#39;s FURTHEST</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Upon the announcement of UPARSE, <a class="mention" href="/u/brett">@Brett</a> listed as his <a href="https://forum.rebol.info/t/introducing-uparse-the-hackable-usermode-parse/1529/4">secondmost missing feature</a> the idea of knowing "how far a parse got":</p>
<blockquote>
<ol start="2">
<li>An ability to return the furthest input point matched and the rule that caused rollback from there on parse failure. During development of rules this generally indicates the rule that is not properly specified.</li>
</ol>
</blockquote>
<p>I implemented a wrapper around combinators which basically got control before each combinator, and after.  Every parser that succeeded I'd look at how far it said it got in the input...and if that was further than the previous "furthest" it would bump it.</p>
<p><strong>But what happens when a combinator calls a parser that succeeds, but that success isn't used?</strong></p>
<p>Examples would be things like AHEAD, or TO:</p>
<pre><code> &gt;&gt; [result furthest]: uparse "aabbcc" [to "bb"]
 ; how can FURTHEST be "bbcc" and not "cc"
</code></pre>
<p>TO iterates, checking to see if "aabbcc" matches, then if "abbcc" matches, then finds a match at "bbcc".</p>
<p>But the reason it found a match at "bbcc" is that it ran "bb" on that and got "cc".  The "bb" combinator has the wrapper, and so FURTHEST got pushed.</p>
<p><strong>TO and AHEAD actually used to work on accident, before <a href="https://forum.rebol.info/t/output-variables-in-multi-return/1859">changing multi-returns</a>, because they didn't ask for the remainder from the parser parameter that they called.</strong></p>
<p>Previously the nature of multi-return was that you'd actually get the variable to write to as the multi-return parameter.  This made them compatible with historical refinements like /NEXT of DO that passed variables, and was just an alternative syntax for that.  It's far superior to do proxying to those variables at the end of the function...and allow the multi-return to be read and written as a normal variable.</p>
<p>But when you could see the variable, there was the ability to choose a different behavior when it was a "BLACKHOLE" indicator (#) that you weren't planning to use the result.</p>
<p>So the TO combinator would pass in a blackhole saying it wasn't planning on using the remainder of the parser it was calling on each iteration.  This meant the wrapper actually didn't find out how far the combinator TO called got, because there was no variable to write to.  If it tried to read the <strong>index of</strong> it would fail, so the protection of not updating furthest "just did the right thing".</p>
<p><strong>But that's not a general solution...</strong></p>
<p>There was a parallel problem with rollback, where not all succeeding parsers were supposed to contribute to an in-progress COLLECT.  This led to the PENDING mechanism, where some parsers had to explicitly route the output and say "yes, I want this to be collected".</p>
<p><em>(Hence combinators don't "roll back" collections, they just don't commit to routing what they aggregate from component parsers until they are finished.)</em></p>
<p>Which leads to the discovery of a quirk... TO does not manage its pending explicitly...it uses the default "auto-routing".  Hence the success of the last parser it calls--whose advancement it doesn't want--counts in a collect:</p>
<pre><code>&gt;&gt; uparse "aabbcc" [collect to [some keep "b"], elide [2 "b" 2 "c"]]
== ["b" "b"]
</code></pre>
<p>Is that right?  (cc: <a class="mention" href="/u/rgchris">@rgchris</a>)</p>
<p>If so, it means <em>"I want to consider the called parser's pending results, yet I don't want to incorporate its advancement in FURTHEST."</em></p>
<p>That would rule out something I was pondering, which was if there was some way of tying those two things together (only advance furthest if the pendings are used).</p>
<h2>Pathology Studies: How About MINMATCH?</h2>
<p>I made MAXMATCH as a case study of different approaches to influence on COLLECT:</p>
<p><strong><a href="https://github.com/metaeducation/ren-c/blob/8ed60125a473fe285e56213f82a6e7e4fa1d9e5a/tests/parse/examples/maxmatch.parse.test.reb">maxmatch.parse.test.reb</a></strong></p>
<p>Similarly we could ask about MINMATCH, and what its participation with FURTHEST should be.</p>
<p>MINMATCH wouldn't have the crutch of not having asked for the remainder from its component parsers.  So it wouldn't have worked accidentally.</p>
<p>It could call two parsers...have both succeed...and then only advance the smaller amount of the two.  We might say this "foils" a wrapper-based approach to updating furthest, as it would be advanced by the larger amount.</p>
<h2>At The Moment, TO and AHEAD Skew FURTHEST a Bit Far</h2>
<p>I can't stop the presses and not incorporate the multi-return change.  So right now, you get this:</p>
<pre><code>&gt;&gt; [result furthest]: uparse "aabbcc" [to "bb"]
; null

&gt;&gt; furthest
== "cc"
</code></pre>
<p>I'm hesitant to burden combinator authors with another parameterization just for this feature.</p>
<p>I am a little bit wondering if it's worth it to convey to a function that a multi-return result is "requested, but will not be written back to a variable".  There are some optimizations functions might make that are pertinent to that.  So we might be able to go back to how it used to be where if the remainder is requested as a "blackhole" then the furthest is not updated.  It could fix TO and AHEAD.</p>
<p>But MINMATCH would still be the kind of thing that would raise questions.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/semantics-of-uparses-furthest/1868">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/semantics-of-uparses-furthest/1868</link>
          <pubDate>Sat, 09 Jul 2022 12:21:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1868</guid>
          <source url="https://forum.rebol.info/t/semantics-of-uparses-furthest/1868.rss">Semantics of UPARSE&#39;s FURTHEST</source>
        </item>
        <item>
          <title>A Cry for HELP</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Help System</category>
          <description><![CDATA[
            <p><a class="mention" href="/u/jhgorse">@jhgorse</a>  was trying out <a href="https://forum.rebol.info/t/enter-the-dungeon-if-you-dare/1865">the Amazing 3-D Dungeon Simulator</a>, and wandered into the console to poke at the HELP.  Several things there don't work.</p>
<ul>
<li>
<p>Some of it is just weirdness people added and then never backed it up with their support, like <strong>help <a class="hashtag" href="https://forum.rebol.info/tag/compiling">#<span>compiling</span></a></strong> <em>(was that something I was supposed to write, about compiling the source?  well forget that, either way.)</em></p>
</li>
<li>
<p>Some commands aren't relevant (?), like UPGRADE</p>
<ul>
<li>
<p>Rather than have a different HELP summary for the console that removes these commands, they could just be stubs... like UPGRADE could say "you are already running the latest version".</p>
</li>
<li>
<p>...or perhaps it would do a force refresh of the page if it checks and notices a mismatch between the last greenlit version and your current one?  But that seems like make-work to me, at least at the moment.</p>
</li>
</ul>
</li>
<li>
<p>Some things suck, like SOURCE.  I wish we could do more here...especially in terms of pointing you at the GitHub or file location where something was defined.  <a href="https://forum.rebol.info/t/use-the-source/1212/5">But I've explained some of the difficulties.</a></p>
<ul>
<li>We need to put our heads together on that and get something that's useful.</li>
</ul>
</li>
</ul>
<p><em>I can't really chase down everything to make a polished experience AND do the core work.</em>  So I thought I'd pull out a call to <a class="mention" href="/u/iarnold">@iArnold</a>, <a class="mention" href="/u/ingohohmann">@IngoHohmann</a>, <a class="mention" href="/u/blackattr">@BlackATTR</a> and anyone else who can just <strong><a href="https://github.com/hostilefork/replpad-js/issues">start opening issues on the ReplPad GitHub</a></strong> and helping cross them off.</p>
<p>It would be great if there were PRs fixing the issues.  But a lot of it isn't even about writing the code, just inventorying and deciding what things should <em>do</em>.</p>
<p>Obviously there's a whole level beyond this of having a "interactive tutorial" or cool instructional YouTube videos that might be able play in a tab while you code on the right.  (Wonder if there's some easy way to get code snippets to sync with a video so people can copy from that part and try it themselves?)  Some experiments in those directions would be great.</p>
<p>But simple steps help too.  If people could get in the spirit of bug bashing and polishing...and then hopefully adding tests to make sure the efforts don't regress... I think things could get noticeably better step by step.</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/a-cry-for-help/1867">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/a-cry-for-help/1867</link>
          <pubDate>Wed, 06 Jul 2022 15:57:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1867</guid>
          <source url="https://forum.rebol.info/t/a-cry-for-help/1867.rss">A Cry for HELP</source>
        </item>
        <item>
          <title>Rebol2 Desktop... in a ReplPad tab?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Web</category>
          <description><![CDATA[
            <p>In a 2019 demo, <a class="mention" href="/u/rgchris">@rgchris</a> showed off his HTML Rebol2/View-like file browser:</p>
<div class="onebox lazyYT lazyYT-container" data-youtube-id="sM7uGKCZMl0" data-youtube-title="Chris Ross-Gill's Dialects and Personal Projects in Rebol" data-parameters="feature=oembed&amp;wmode=opaque&amp;start=153">
  <a href="https://www.youtube.com/watch?v=sM7uGKCZMl0" target="_blank" rel="noopener">
    <img class="ytp-thumbnail-image" src="https://i.ytimg.com/vi/sM7uGKCZMl0/maxresdefault.jpg" title="Chris Ross-Gill's Dialects and Personal Projects in Rebol" width="690" height="388">
  </a>
</div>

<p>With programs like <a href="https://forum.rebol.info/t/enter-the-dungeon-if-you-dare/1865">dungeon.reb</a> running in the browser, it seems we should have a list and let you browse them similarly...!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/rebol2-desktop-in-a-replpad-tab/1866">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rebol2-desktop-in-a-replpad-tab/1866</link>
          <pubDate>Wed, 06 Jul 2022 13:30:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1866</guid>
          <source url="https://forum.rebol.info/t/rebol2-desktop-in-a-replpad-tab/1866.rss">Rebol2 Desktop... in a ReplPad tab?</source>
        </item>
        <item>
          <title>Should &quot;Arity-2 INTO&quot; in UPARSE actually just be... PARSE?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>There's a cool feature that UPARSE's INTO is willing to take a rule that gives the boundaries of the data you want to copy, and will make the copy for you:</p>
<pre><code>&gt;&gt; uparse "(1 1 1)" [
    into [between "(" ")"] [data: &lt;here&gt; (print mold data) some integer!]
]
</code></pre>
<p>That will give you:</p>
<pre><code>"1 1 1"  ; notice no ")" because the INTO copied the data spanning the rule
== 1
</code></pre>
<p><em>(I threw in the INTEGER! transcode for fun there.  Note that Red allows the transcoding rules for datatypes as well, but only on BINARY! input series. It's because they don't have UTF-8 everywhere, they'd have to rewrite their scanner to process variable-width strings. One of the uncountable Ren-C design advantages...)</em></p>
<p>More generally, you can pass any variable you want to INTO.</p>
<pre><code>&gt;&gt; uparse [1 2 3] [some integer! into ("aaa") some "a"]
== "a"
</code></pre>
<h2>But... Couldn't We Just Call That PARSE?</h2>
<p>This arity-2 INTO takes an input, and rules.  Why isn't that just PARSE?</p>
<p>Difference is that since it's inside a parse already, its first parameter will be treated as a rule and use the synthesized result...unless you put it in a GROUP!.  But that's implicit.  Maybe call it SUBPARSE to be clear?</p>
<p>It would free up the keyword INTO, maybe to be compatible with historical single-arity version, for cases that have already figured out they're at a series value and don't want to repeat themselves by giving a rule that matches where they know they are.</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/should-arity-2-into-in-uparse-actually-just-be-parse/1864">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-arity-2-into-in-uparse-actually-just-be-parse/1864</link>
          <pubDate>Wed, 06 Jul 2022 03:53:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1864</guid>
          <source url="https://forum.rebol.info/t/should-arity-2-into-in-uparse-actually-just-be-parse/1864.rss">Should &quot;Arity-2 INTO&quot; in UPARSE actually just be... PARSE?</source>
        </item>
        <item>
          <title>&quot;Bincode&quot;</title>
          <dc:creator><![CDATA[rgchris]]></dc:creator>
          <category>R3C</category>
          <description><![CDATA[
            <p><a href="https://github.com/rgchris/Scripts/blob/master/rebol-2/bincode.r">'Bincode'</a> is the working name I've given to a pair (well, trio) of functions designed to work with binary formats. I know my general approach here isn't altogether unique, but I think in implementation it has some qualities of its own that I at least have found to be endearing.</p>
<h1>Consume (+ Advance)</h1>
<p>CONSUME takes a reference to a BINARY! and a named binary datatype (such as 'SIGNED-32, 'FLOAT-64, etc) or an INTEGER!, returns that value (or errors out if there's not enough input) and updates the reference to the point after said value.</p>
<pre><code class="lang-nohighlight">source: #{010003}
consume source 'signed-16
; returns 64, source =&gt; #{03}
</code></pre>
<p>Additionally CONSUME can take a BLOCK! in which shorthand functions for the various datatypes are available:</p>
<pre><code class="lang-nohighlight">source: #{03010203}
values: collect [
    consume source [
        loop unsigned-8 [
            keep unsigned-8
        ]
    ]
]
; values =&gt; [1 2 3], source =&gt; #{}
</code></pre>
<p>ADVANCE simply skips a given INTEGER! amount.</p>
<h1>Accumulate</h1>
<p>ACCUMULATE goes in the reverse direction using the same shorthand functions:</p>
<pre><code class="lang-nohighlight">accumulate #{} [
    utf-8 65
    utf-8 8212
    float-64 pi
    repeat x 3 [
        unsigned-8 x
    ]
]
; =&gt; #{41E28094400921FB54442D18010203}
</code></pre>
<p>This snippet is another pass at creating a single-pixel PNG image (with an assist from a R2 DEFLATE wrapper):</p>
<pre><code class="lang-nohighlight">chunkify: func [
    target [binary!]
    header [word!]
    data [binary!]
    /compress
][
    header: as-binary form header

    if compress [
        data: deflate/envelope data 'zlib
    ]

    accumulate target [
        unsigned-32 length? data
        accumulate header
        accumulate data
        accumulate crc32-checksum-of join header data
    ]
]

probe accumulate png: #{} [
    accumulate #{
        89504E47
        0D0A1A0A
    }

    chunkify png 'IHDR #{
        00000001
        00000001
        08 02 00 00 00
    }

    chunkify/compress png 'IDAT #{
        00 CC0000
    }
    
    chunkify png 'tEXt join #{} [
        "Title" null "Single Pixel!"
    ]

    chunkify png 'IEND #{}
]
</code></pre>
<h1>Notes</h1>
<p>Fairly sure this is bait for a lot of where Ren-C has gone with uparse/streaming/ports etc. That's fine, what I'm looking for is the vocabulary that stretches over a handful of common file formats (including <a href="https://forum.rebol.info/t/backtrack-zip/1860">Zip</a>). I don't necessarily think that this is a silver bullet, though it has worked well enough to be used in that domain with enough clarity to make adjustments and retain readability. Doesn't seem too much of a stretch to consider this sitting over a stream or even compressed stream too.</p>
            <p><small>7 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/bincode/1863">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/bincode/1863</link>
          <pubDate>Wed, 06 Jul 2022 01:00:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1863</guid>
          <source url="https://forum.rebol.info/t/bincode/1863.rss">&quot;Bincode&quot;</source>
        </item>
        <item>
          <title>Agree-To-Disagree Points: Places I See Both Sides</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>R3C</category>
          <description><![CDATA[
            <p>I thought I would make a thread for deviations from Rebol2 that I consider to be matters-of-taste, as opposed to where I think there's a hard "right vs. wrong", and provide the code to reverse the decision.</p>
<p><em>(Please discuss the issues on the linked posts--not here.)</em></p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/agree-to-disagree-points-places-i-see-both-sides/1862">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/agree-to-disagree-points-places-i-see-both-sides/1862</link>
          <pubDate>Tue, 05 Jul 2022 00:53:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1862</guid>
          <source url="https://forum.rebol.info/t/agree-to-disagree-points-places-i-see-both-sides/1862.rss">Agree-To-Disagree Points: Places I See Both Sides</source>
        </item>
        <item>
          <title>Backtrack: PDF</title>
          <dc:creator><![CDATA[rgchris]]></dc:creator>
          <category>R3C</category>
          <description><![CDATA[
            <p>This backtrack is semi-related to the <a href="https://forum.rebol.info/t/backtrack-zip/1860">Zip Backtrack</a> and expands on the dialect principle used for the Zip/Build function.</p>
<p>It's a departure from the Parse-approach to dialecting and one that I took to try to sail a little closer to the way PDFs are structured.</p>
<p><a href="https://gist.github.com/rgchris/884be89a396a7e4259d1197ad172fcf6">PDF Experiment</a></p>
<h1>Create</h1>
<p>The <code>pdf/create</code> function takes a <code>block!</code> and evaluates its contents in a context containing helper functions. The result should be a completely modeled PDF document ready for serialization:</p>
<pre><code class="lang-auto">doc: pdf/create [
    info [
        title "A Document"
        author "@rgchris"
    ]

    add-page 640x480 [
        ; supported colors:
        ; RGB 0.0.0 - 255.255.255
        ; Gray 0 - 100
        ; CMYK 0.0.0.0 - 100.100.100.100
        ;
        set-fill 0.100.100.0
        set-pen 0.0.0.0

        ; several helper functions are available in page context for
        ; altering the graphics state
        ;
        set-line-width 2

        ; other helper functions apply graphics to the page
        ;
        draw none non-zero [
            rectangle 20x20 600x440
        ]

        draw line none [
            rectangle 530x370 50x50
        ]

        set-dash-array [4 5] 2
        set-line-cap 'round

        draw line none [
            move-to 0x0
            curve-to
                as-pair 0 page/height
                as-pair page/width 0
                as-pair page/width page/height
        ]
    ]

    add-page 200x200 [
        set-pen 204.0.0
        set-fill 10
        set-line-width 2

        ; PUSH creates an isolated graphics state in which changes
        ; do not affect subsequent graphics operations
        ;
        push [
            set-pen 80

            draw line none [
                repeat offset 21 [
                    move-to as-pair 0 offset - 1 * 10 0
                    line-to as-pair 200 offset - 1 * -10 + page/height
                ]
            ]
        ]

        ; this retains the red pen from before the PUSH
        ;
        draw line even-odd [
            rectangle 20x85 30x30
        ]
    ]

    ; fonts/text not yet implemented, this is a no-op
    ;
    add-font /Helvetica [
        spec
    ]
]
</code></pre>
<p>Some functions can be used outside the <code>pdf/create</code> context:</p>
<pre><code class="lang-auto">pdf/add-page doc 400x200 [
    set-pen 10

    draw line non-zero [
        move-to reduce [
            50 page/height - 50
        ]

        line-to 50x100
        line-to 100x100
        line-to 100x50
        close-path
    ]
]
</code></pre>
<p>The model can be serialized using the <code>pdf/render</code> function:</p>
<pre><code class="lang-auto">probe pdf/render doc
</code></pre>
<h1>Relevance</h1>
<p>The context-sensitive functions give both an appearance of dialecting and the transparency and rigor of being regular functions. I think the function specialization in Ren-C would really make this an efficient and scalable approach.</p>
            <p><small>6 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/backtrack-pdf/1861">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/backtrack-pdf/1861</link>
          <pubDate>Mon, 04 Jul 2022 20:51:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1861</guid>
          <source url="https://forum.rebol.info/t/backtrack-pdf/1861.rss">Backtrack: PDF</source>
        </item>
        <item>
          <title>Backtrack: Zip</title>
          <dc:creator><![CDATA[rgchris]]></dc:creator>
          <category>R3C</category>
          <description><![CDATA[
            <p>In contemplating what I'm looking to achieve with R3C, I've been backtracking on ways in which I've/we've approached working with common formats.</p>
<p>I've <a href="https://forum.rebol.info/t/anatomy-of-a-zip-scheme/160">mused over Zip</a> before and given thought I'd revisit this first. <a href="https://github.com/rgchris/Scripts/blob/master/rebol-2/zip.r">This time in Rebol 2</a> (along with a <a href="https://github.com/rgchris/Scripts/blob/master/rebol-2/deflate.r">core-friendly Deflate</a> implementation).</p>
<h1>Unpacking</h1>
<p>First goal here is versatility: no <em>unzip and be done</em>—rather try to isolate the atomic steps of retrieval so as to offer more control over the process. Thus:</p>
<pre><code class="lang-auto">archive: zip/load %archive.zip
</code></pre>
<p>Returns an object representing the archive and</p>
<pre><code class="lang-auto">entry: zip/step archive
</code></pre>
<p>Will return the next entry (or none if at the end). So far nothing has been decompressed thus is a relatively cheap operation. Metadata for that entry such as filename/date is readily available.</p>
<pre><code class="lang-auto">entry/filename
entry/date
</code></pre>
<p>As is the compressed content itself:</p>
<pre><code class="lang-auto">content: zip/unpack entry
</code></pre>
<p>With these building blocks, it's easy enough to extract a whole archive or target specific files:</p>
<pre><code class="lang-auto">doc: zip/load %document.odt

while [
    file: zip/step doc
][
    if file/filename == %mimetype [
        probe zip/unpack file
        ; =&gt; "application/vnd.oasis.opendocument.text"
    ]
]
</code></pre>
<h1>Packing</h1>
<p>This presented a few conceptional challenges as to how one represents archives/entries in construction. Essentially an archive is a block of entry objects sharing the same structure as above (conceptually you could just throw those extracted entry objects into a block and pack them, but in writing this I don't recall if I implemented that—need to go back and look, would be cool if so).</p>
<pre><code class="lang-auto">new-archive: reduce [
    zip/prepare %thing #{01234567}
]

write %thing.zip zip/pack new-archive
</code></pre>
<p>Again, a key here is to keep the steps atomized so they can be handled in different ways. One such way is a wrapper that provides shorthand contextual functions (in one sense a 'dialect' but is just regular code).</p>
<pre><code class="lang-auto">write %thing.zip zip/build [
    add-file %mimetype "application/x-rebol+zip"

    repeat count 3 [
        add-file join %thing- count #{01234567}
    ]

    add-comment "A possibly useful note"
]
</code></pre>
<h1>Relevance</h1>
<p>I don't think anything here resembles anything particularly revolutionary, only that it's a departure from the typical Rebol way of doing things that I think opens up some possibilities. This isn't an end point, there's a bit more digging to do</p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/backtrack-zip/1860">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/backtrack-zip/1860</link>
          <pubDate>Mon, 04 Jul 2022 20:23:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1860</guid>
          <source url="https://forum.rebol.info/t/backtrack-zip/1860.rss">Backtrack: Zip</source>
        </item>
        <item>
          <title>Parsing Alternates: Should &quot;Must Match To End&quot; Be Considered?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>I didn't quite absorb that the following was the case in all PARSEs we know of:</p>
<pre><code> &gt;&gt; parse [a b] [word! word!]
 == truthy

 &gt;&gt; parse [a b] [word!]
 == falsey

 &gt;&gt; parse [a b] [word! | word! word!]
 == falsey
</code></pre>
<h2>Distinctly Self-Aware "Terminal Blocks", Could They Be Good?</h2>
<pre><code>&gt;&gt; uparse [a b] [word! | word! word!]
== b
</code></pre>
<p>I'd argue that there already are "two types of blocks":</p>
<ol>
<li>
<p>There are blocks that give a truthy result when they don't reach the end, but don't have any match failures</p>
</li>
<li>
<p>There are blocks that can succeed on every match but not reach the end, but be an overall failure</p>
</li>
</ol>
<p>Right now we know these blocks by context.  The main rule block you give to PARSE is of type 2, and so is the block given to an INTO.</p>
<p>It's a very small semantic difference to say that "they're the same kind of block, with the decisions about them being made by their caller".  Why not allow them to be different kinds of blocks?</p>
<h2>It Would Be Weird If It Propagated</h2>
<p>Here's an example of the kind of weirdness you'd get into if we said it wasn't a property <em>strictly</em> of the root blocks, but rather "any block that found itself at the end of a chain":</p>
<pre><code>&gt;&gt; parse [] [[(print "A") | (print "B")] [(print "C") | (print "D")]]
A
C
D
</code></pre>
<p>Being a "category 2 block", we see how the outer rule block would be creating some irritating asymmetry by saying that any block that knew it wasn't going to reach the end got the privilege.</p>
<p>So I definitely don't like that.</p>
<p><strong>But I'm suggesting a sticky property of blocks, that they effectively already had, being allowed to influence one thing besides whether they are forced to reach the end to succeed... that those blocks also get to try all their alternates before saying they failed.</strong></p>
<p>It's like because they're under more pressure they are given a resource to fall back on to succeed <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<h2>Looking for Reasons Why It Would Break</h2>
<p>It definitely benefits <a href="https://forum.rebol.info/t/the-circled-dialect-example-of-the-form/1849">cases like how I was writing CIRCLED</a>, and now that I think about it I've certainly encountered others.</p>
<p>It does break a kind of universality of understanding, like:</p>
<pre><code>rule: [word! | word! word! (print "breaks faith this can never print")]
</code></pre>
<p>Yet the understandings in the PARSE world are a little fuzzy.  You might say the existing paradigms break the understanding that if that rule came across [a b] as input that it would succeed.  It won't if it's an outermost block...</p>
<p>The new understanding would be <em>"Common subsequences in your rule may wind up being matched alternately in top-level parse contexts."</em>  If you don't want it, you have an out...double up your block!</p>
<pre><code>rule: [[word! | word! word! (print "breaks faith this can never print")]]
</code></pre>
<p>Now your rule won't be subject to the toplevel alternates exception...if you can think of a really good reason why you wouldn't want it.</p>
<h2>But, UPARSE is Configurable, So Why Worry Too Much?</h2>
<p>I might like it, and other people might not.  So we'll see.</p>
<p>I think I'm at least going to try it out, because it looks like it serves common tasks.  I'll get some more data and report back.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/parsing-alternates-should-must-match-to-end-be-considered/1850">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/parsing-alternates-should-must-match-to-end-be-considered/1850</link>
          <pubDate>Sun, 26 Jun 2022 12:46:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1850</guid>
          <source url="https://forum.rebol.info/t/parsing-alternates-should-must-match-to-end-be-considered/1850.rss">Parsing Alternates: Should &quot;Must Match To End&quot; Be Considered?</source>
        </item>
        <item>
          <title>The CIRCLED Dialect: Example of the Form</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>I was looking at this from the emscripten config file:</p>
<pre><code> ; Right now, either #web or #node (someday #wasm-edge ?)
 ;
 javascript-environment: #web
</code></pre>
<p>And I thought to myself: well that's kind of ugly.  The comment is having to list things that would be more obviously shown by just demonstrating the options:</p>
<pre><code>javascript-environment: circled [(#web) #node]
</code></pre>
<p>Being dialected, it could even have visual hints as to whether many options are allowed, or just one.</p>
<pre><code>extensions: circled [[
   (javascript)
   (debugger)
    view
    jpeg
   (crypto)
]]
</code></pre>
<p>Or maybe it uses optional parameters to tell you how many you can have.</p>
<pre><code>toppings: circled 0..3 [(cheese) tomatoes (pickles) (lettuce) onions]
</code></pre>
<p>It could default to NULL if you circled nothing, but you could use MUST to suggest people needed to select something:</p>
<pre><code>&gt;&gt; number: must circled [#one #two #three]
** Error: MUST requires argument not to be NULL
</code></pre>
<h2>It's Almost <em>Too</em> Easy</h2>
<p>When it's this easy, who wouldn't whip such things up?</p>
<p>Ultimately I believe this should work (once PARSE is renamed and there's <a href="https://forum.rebol.info/t/parsing-alternates-should-must-match-to-end-be-considered/1850">Terminal Parse Alternates</a>):</p>
<pre><code>circled: lambda [block [block!]] [
    parse block [return [
         thru into group! [&lt;any&gt; | (fail "Circle One")]
         maybe [thru group! (fail "Circle One")]
    ]]
]

&gt;&gt; circled [a (b) c]
== b

&gt;&gt; circled [a b c]
; null

&gt;&gt; circled [(a) b (c)]
** Error: Circle One

&gt;&gt; circled [a (b c)]
** Error: Circle One
</code></pre>
<p>But of course PARSE is called UPARSE right now, and there's a detail of alternates not being offered in blocks seeking completion before failing...that makes you need <code>elide &lt;end&gt;</code>, so for now:</p>
<pre><code>circled: lambda [block [block!]] [
    uparse block [return [
         thru into group! [&lt;any&gt; elide &lt;end&gt; | (fail "Circle One")]
         maybe [thru group! (fail "Circle One")]
    ]]
]
</code></pre>
<p>It finds one group to extract an element from, and extracts it via INTO.  Then it has a second clause that's optional--and if it doesn't match is invisible...but if it <em>does</em> match it fails.</p>
<p>Remarkable plasticity, and I want to see these weapons come to the code golfing field.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-circled-dialect-example-of-the-form/1849">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-circled-dialect-example-of-the-form/1849</link>
          <pubDate>Sun, 26 Jun 2022 12:06:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1849</guid>
          <source url="https://forum.rebol.info/t/the-circled-dialect-example-of-the-form/1849.rss">The CIRCLED Dialect: Example of the Form</source>
        </item>
        <item>
          <title>@earl&#39;s tiny httpd server, circa 2009</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Web</category>
          <description><![CDATA[
            <p>This little httpd server was the basis for our current httpd.  It's worth looking at to think about what the minimum requirements for a server are...and how our current implementation might be too heavy in places.</p>
<p>But it was in the tests directory, and it hasn't been used in any test for a long time.  Rather than upgrade it, I decided it better to archive it here.</p>
<pre><code>REBOL [title: "A tiny static HTTP server" author: 'abolka date: 2009-11-04]

code-map: make map! [200 "OK" 400 "Forbidden" 404 "Not Found"]
mime-map: make map! [
    "html" "text/html" "css" "text/css" "js" "application/javascript"
    "gif" "image/gif" "jpg" "image/jpeg" "png" "image/png"
    "r" "text/plain" "r3" "text/plain" "reb" "text/plain"
]
error-template: trim/auto {
    &lt;html&gt;&lt;head&gt;&lt;title&gt;$code $text&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;$text&lt;/h1&gt;
    &lt;p&gt;Requested URI: &lt;code&gt;$uri&lt;/code&gt;&lt;/p&gt;&lt;hr&gt;&lt;i&gt;shttpd.r&lt;/i&gt; on
    &lt;a href="http://www.rebol.com/rebol3/"&gt;REBOL 3&lt;/a&gt; $r3&lt;/body&gt;&lt;/html&gt;
}

error-response: func [code uri &lt;local&gt; values] [
    values: [code (code) text (code-map/:code) uri (uri) r3 (system.version)]
    reduce [code "text/html" reword error-template compose values]
]

start-response: func [port res &lt;local&gt; code text type body] [
    set [code type body] res
    write port unspaced [
        "HTTP/1.0" _ code _ code-map/:code CR LF
        "Content-type:" _ type CR LF
        "Content-length:" _ (length of body) CR LF
        CR LF
    ]
    ; Manual chunking is only necessary because of several bugs in R3's
    ; networking stack (mainly cc#2098 &amp; cc#2160; in some constellations also
    ; cc#2103). Once those are fixed, we should directly use R3's internal
    ; chunking instead: `write port body`.
    port.locals: copy body
]

send-chunk: func [port] [
    ; Trying to send data &gt;32'000 bytes at once will trigger R3's internal
    ; chunking (which is buggy, see above). So we cannot use chunks &gt;32'000
    ; for our manual chunking.
    either empty? port.locals [
        _
    ][
        write port take/part port.locals 32'000
    ]
]

handle-request: function [config req] [
    parse3 to-text req ["get " ["/ " | copy uri: to " "]]
    uri: default ["index.html"]
    print ["URI:" uri]
    parse3 uri [some [thru "."] copy ext to end (type: mime-map/:ext)]
    type: default ["application/octet-stream"]
    if not exists? file: config/root/:uri [return error-response 404 uri]
    if error? trap [data: read file] [return error-response 400 uri]
    reduce [200 type data]
]

awake-client: function [event] [
    port: event/port
    switch event/type [
        'read [
            either find port.data to-binary unspaced [CR LF CR LF] [
                res: handle-request port.locals.config port.data
                start-response port res
            ] [
                read port
            ]
        ]
        'wrote [if not send-chunk port [close port]]
        'close [close port]
    ]
]

awake-server: func [event &lt;local&gt; client] [
    if event/type = 'accept [
        client: first event/port
        client/awake: :awake-client
        read client
    ]
]

serve: func [web-port web-root &lt;local&gt; listen-port] [
    listen-port: open join tcp://: web-port
    listen-port.locals: make object! compose/deep [
        config: [root: (web-root)]
    ]
    listen-port.awake: :awake-server
    wait listen-port
]

serve 8080 system.options.path
; vim: set syn=rebol sw=4 ts=4:</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/earls-tiny-httpd-server-circa-2009/1842">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/earls-tiny-httpd-server-circa-2009/1842</link>
          <pubDate>Wed, 15 Jun 2022 10:22:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1842</guid>
          <source url="https://forum.rebol.info/t/earls-tiny-httpd-server-circa-2009/1842.rss">@earl&#39;s tiny httpd server, circa 2009</source>
        </item>
        <item>
          <title>Visual PARSE on the Web... has arrived!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Web</category>
          <description><![CDATA[
            <p><strong>It's only the beginning... but the potential is pretty tremendous.</strong></p>
<p>cc: parsing innovators <a class="mention" href="/u/rgchris">@rgchris</a>, <a class="mention" href="/u/brett">@Brett</a></p>
<p><img src="https://forum.rebol.info/uploads/default/original/1X/f411109ea0a124c88b333f52f00f97a80cb5adc3.png" alt="image" data-base62-sha1="yP73YPLtl4CRY4iWWfhET6JSs95" width="640" height="338"></p>
<hr>
<p><em>(EDIT opens a new editor.  EPARSE applies the parse rule to the last selected editor, with the usermode addition of a combinator MARK)</em></p>
<hr>
<ul>
<li>
<p><strong>A Fantastic Case Study of Usermode UPARSE customization</strong> - It's just the MARK combinator added in, and it even utilizes the same rollback mechanics that COLLECT uses.  So if you mark something during a rule and that rule ultimately fails, the mark rolls back too!</p>
<ul>
<li>
<p>...of course it wouldn't be difficult to make a combinator that did it the easier way and not roll it back...</p>
</li>
<li>
<p>but there are all sorts of web-interactive combinators you might imagine...go ahead and imagine some!  <img src="https://forum.rebol.info/images/emoji/twitter/rainbow.png?v=9" title=":rainbow:" class="emoji" alt=":rainbow:"> <img src="https://forum.rebol.info/images/emoji/twitter/unicorn.png?v=9" title=":unicorn:" class="emoji" alt=":unicorn:"></p>
</li>
</ul>
</li>
<li>
<p><strong>REORGANIZABLE TABS</strong> - I've built and integrated Golden Layout, but the ReplPad still is a standalone component that can live completely on its own...with a lighter footprint.</p>
</li>
<li>
<p><strong>Integration with Codemirror 6</strong> - We're ahead of the curve on this; it's a very new modularized thing, which has an amount of configurability that should be very enabling.</p>
<ul>
<li>...and again, there's nothing particularly tying the ReplPad to this editor.  None of the JS or CSS for it are loaded until you type EDIT, and we could integrate with other options.</li>
</ul>
</li>
</ul>
            <p><small>7 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/visual-parse-on-the-web-has-arrived/1837">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/visual-parse-on-the-web-has-arrived/1837</link>
          <pubDate>Tue, 07 Jun 2022 14:01:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1837</guid>
          <source url="https://forum.rebol.info/t/visual-parse-on-the-web-has-arrived/1837.rss">Visual PARSE on the Web... has arrived!</source>
        </item>
        <item>
          <title>Merge Equal Fields when Molding/Printing Objects</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Console</category>
          <description><![CDATA[
            <p>One of the justifications for why <a href="https://forum.rebol.info/t/bad-word-choices-the-role-of-english-in-the-evaluator/1413/9">~unset~ was changed to ~</a> was to reduce the amount of "noise" when printing things like FRAME!s, and so the specialized fields could be seen easier.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="9" data-topic="1413">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/bad-word-choices-the-role-of-english-in-the-evaluator/1413/9">BAD-WORD! Choices: The Role of English in the Evaluator</a>
</div>
<blockquote>
<pre><code>&gt;&gt; make frame! :append
== make frame! [
    series: ~
    value: ~
    part: ~
    only: ~
    dup: ~
    line: ~
]
</code></pre>
</blockquote>
</aside>
<p>...but why not:</p>
<pre><code>&gt;&gt; make frame! :append
== make frame! [
    series: 
    value:
    part:
    only:
    dup:
    line: ~
]</code></pre>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/merge-equal-fields-when-molding-printing-objects/1829">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/merge-equal-fields-when-molding-printing-objects/1829</link>
          <pubDate>Mon, 23 May 2022 22:11:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1829</guid>
          <source url="https://forum.rebol.info/t/merge-equal-fields-when-molding-printing-objects/1829.rss">Merge Equal Fields when Molding/Printing Objects</source>
        </item>
  </channel>
</rss>

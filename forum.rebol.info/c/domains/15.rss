<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Domains - AltRebol</title>
    <link>https://forum.rebol.info/c/domains/15</link>
    <description>Topics in the &#39;Domains&#39; category Applications of Rebol in various specialized subject domains.</description>
    
      <lastBuildDate>Thu, 01 Feb 2024 00:13:45 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/domains/15.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Rendering Difference For Bound/Unbound Code</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Console</category>
          <description><![CDATA[
            <p>With the new binding model tending to have things sparsely bound, it helps to know what is and isn't bound.</p>
<p>It seems to me it would be very useful (and educational) in rich consoles to make the rendering of code reflect the binding status.</p>
<p><img src="https://forum.rebol.info/uploads/default/original/1X/c7cac409fc3ebb1db0467fb9c8c94b531ff1ec11.png" alt="image" data-base62-sha1="svrriultuZqA01aLNlih32dDyRr" width="258" height="201"></p>
<p>So there you can see that a plain block will evaluate so the block itself is bound, while the contents are left unbound.  A quoted block will be all unbound.</p>
<p>Even better would be if you could hover over the bound bits and see what they were bound to.  It may be best if the coloring was very subtle by default (e.g. just bold black vs a dark gray) and then if you hovered, maybe it would colorize it... perhaps even making things bound the same match colors.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rendering-difference-for-bound-unbound-code/2142">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rendering-difference-for-bound-unbound-code/2142</link>
          <pubDate>Thu, 01 Feb 2024 00:13:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2142</guid>
          <source url="https://forum.rebol.info/t/rendering-difference-for-bound-unbound-code/2142.rss">Rendering Difference For Bound/Unbound Code</source>
        </item>
        <item>
          <title>hiiamboris&#39;s WITH</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>I've mentioned that binding might be helped by a dialect, and it turns out there is some precedent in <strong><a href="https://codeberg.org/hiiamboris/red-common/src/branch/master/with.red">hiiamboris's WITH</a></strong>:</p>
<blockquote>
<h3>USAGE SUMMARY</h3>
<pre><code>with x  [..]          == bind [..] x
with 'x [..]          == bind [..] 'x
with :fun [..]        == bind [..] :fun
with [:fun] [..]      == bind [..] :fun
with [x y 'z] [..]    == bind bind bind [..] 'z y x
with [x: 1 y: 2] [..] == bind [..] context [x: 1 y: 2]
</code></pre>
<h3>EXAMPLES</h3>
<h4>omit the path to an object, but work inside it's context:</h4>
<pre><code>do with face/parent/pane/1 [
    color: red
    text: mold color
    visible?: yes
]

if true with system/view/fonts [print [serif size]]

f: func [/- /+ /*] [        ;-- redefines important globals locally
    (do something with local flags)
    foreach x [set..] with system/words [
        (do something with global * + -)
    ]
]
</code></pre>
<h4>create static storage for functions where existing literal forms don't allow you to:</h4>
<pre><code>factorial: func [x] with [cache: make hash! [0 1]] [
    any [
        select/skip cache x 2
        put cache x x * factorial x - 1
    ]
]
</code></pre>
<h4>anonymize words used during initialization of the program:</h4>
<pre><code>first item in the block should be of set-word! type

do with [x: 1 y: 2] [
    z: x * y
    ... other code that uses x or y ...
]
</code></pre>
<h4>bind a block to multiple contexts at once (in the list order):</h4>
<p>First item in the block should be of word!/get-word!, path!/get-path! or lit-word! type</p>
<ol>
<li>
<p>words and paths values are fetched, while lit-words are converted into words<br>
get-words and get-paths should be used for function context, otherwise they get evaluated</p>
</li>
<li>
<p>if resulting value is a context, block is bound to it<br>
if resulting value is a word, block is bound to the context of this word</p>
<p>the following example illustrates usage of words and lit-words:</p>
<pre><code>a: b: x: y: none
c: context [
    a: 1
    b: 2
    f: func [x y] [
       ; calls `with` internally
       print composite [self 'x] "a=(a) b=(b) x*y=(x * y)"
       ; equivalent
       print composite [self :f] "a=(a) b=(b) x*y=(x * y)"
    ]
]
</code></pre>
</li>
</ol>
<p>Thus, <code>with [c]</code> is equivalent to <code>with c</code>, while <code>with ['c]</code> - to <code>with 'c</code>.</p>
<h3>WHY IS IT DESIGNED LIKE THIS?</h3>
<ol>
<li>
<p>It does not evaluate</p>
<p><code>with</code> does not evaluate the block, so:</p>
<ul>
<li>it can be used after <code>context</code>s, <code>if</code>s, <code>loop</code>s, <code>func</code>s, etc.</li>
<li>it can be chained <code>with x with y ...</code>
</li>
</ul>
<p>I've found that this makes code much more readable than it would be with <code>bind</code>.<br>
Prefix it with <code>do</code> if you want immediate evaluation.</p>
</li>
<li>
<p>It accepts blocks</p>
<p>Design question here was - if we allow block! for <code>ctx</code>, how should we treat it?</p>
<ul>
<li>
<p>convert it to a context? <code>ctx: context ctx</code></p>
<p>that shortens the <code>with context [locals...] [code]</code> idiom</p>
</li>
<li>
<p>list multiple contexts in a block as a sequence and bind to each one?</p>
<p>that shortens <code>with this with that [code]</code> idiom</p>
</li>
</ul>
<p>Personally, I've used the 1st at least a few times, but 2nd - never, though I admit there are use cases.<br>
This can be solved by checking type of the 1st item in the block is a set-word or not <img src="https://forum.rebol.info/images/emoji/twitter/wink.png?v=12" title=":wink:" class="emoji" alt=":wink:" loading="lazy" width="20" height="20"><br>
But still ambiguous! When <code>with</code> gets a <code>word!</code> argument it can:</p>
<ul>
<li>get the value of this word, which should be an <code>object!</code>, and bind to this object</li>
<li>get the context of this word, and bind to this context</li>
</ul>
<p>When inside a context, 2nd option is nice:</p>
<pre><code>context [
    a: 1
    f: func [x y] [
        with [self x] [x * y * a]
    ]
 ]
</code></pre>
<p>..where the alternative would be:</p>
<pre><code>context [
    a: 1
    f: func [x y] [
        with context? 'x with self [x * y * a]
    ]
]
</code></pre>
<p>When outside of it, 1st option is better:</p>
<pre><code>x: context [x: 10]
y: context [y: 20]
do with [x y] [x * y]
</code></pre>
<p>..where the alternative would be:</p>
<pre><code>x: context [x: 10]
y: context [y: 20]
do with in x 'x with in y 'y [x * y]
</code></pre>
<p>But this still can be solved: let <code>word!</code>s evaluate to contexts and <code>lit-word!</code>s, same as we have <code>bind code ctx</code> vs <code>bind code 'ctx</code>:</p>
<pre><code>context [
    a: 1
    f: func [x y] [
        with [self 'x] [x * y * a]
    ]
]

x: context [x: 10]
y: context [y: 20]
do with [x y] [x * y]
</code></pre>
</li>
</ol>
</blockquote>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/hiiamboriss-with/2138">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/hiiamboriss-with/2138</link>
          <pubDate>Tue, 30 Jan 2024 21:14:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2138</guid>
          <source url="https://forum.rebol.info/t/hiiamboriss-with/2138.rss">hiiamboris&#39;s WITH</source>
        </item>
        <item>
          <title>The Fate of Redbol Emulation In A Mostly Unbound World</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>100% Emulation of historical Rebol was always going to be impossible.  But if we go forward with the model that most code is unbound, that's going to break even code that didn't do anything sophisticated with binding.  Not only will any values you PICK out of a block or iterate over be unbound, but even basic quoting won't be bound:</p>
<p>e.g. this won't work:</p>
<pre><code>rebol2&gt;&gt; thing: 10

rebol2&gt;&gt; foo: func [w [word!]] [return get w]

rebol2&gt;&gt; foo 'thing
== 10
</code></pre>
<p>I had a problem with this in emulating my very, very old whitespace interpreter.  It <a href="https://github.com/hostilefork/rebol-whitespacers/blob/1d69ea0e79e60ba79fe680d3af657d0823dcbe9e/historical/whitespace-old.reb#L595">quoted ADD</a> and then <a href="https://github.com/hostilefork/rebol-whitespacers/blob/1d69ea0e79e60ba79fe680d3af657d0823dcbe9e/historical/whitespace-old.reb#L424">put it in a block</a>, expecting a DO of that block to run the ADD it meant.</p>
<h2>
<a name="simulating-waves-of-binding-probably-impractical-1" class="anchor" href="https://forum.rebol.info#simulating-waves-of-binding-probably-impractical-1"></a>Simulating Waves of Binding (Probably?) Impractical</h2>
<p>You might think that so long as every word can still hold a binding, then historical behavior could be simulated by manually binding everything.</p>
<p>When a module loads, you could walk through it binding every word.  Then when a function runs, you could copy its body and walk through it...overwriting those module bindings for functions and arguments.</p>
<p>But it would really mean rewriting everything.  You'd have to redo MAKE OBJECT!, otherwise the <a href="https://forum.rebol.info/t/sticky-set-word-binding-problem-in-make-object/2127">indiscriminate binding would break its expectations</a>--as it doesn't override explicit binding anymore.</p>
<h2>
<a name="hooked-evaluator-may-fix-some-cases-2" class="anchor" href="https://forum.rebol.info#hooked-evaluator-may-fix-some-cases-2"></a>Hooked Evaluator May Fix (Some) Cases</h2>
<p>We already are going to need a hooked evaluator to handle things like PATH! looking up in objects (done presently with a hack to the main evaluator).</p>
<p>Another hook could just say that quoted things wound up bound under the same rules that non-quoted things use.</p>
<p>That would make this one whitespace example work, and maybe it would be able to run some more simple historical example scripts.  But anything that mixes COMPOSE and DO is likely doomed.</p>
<p>This may just be the price of progress.  Rebol2 emulation remains a good experiment of changing your baseline library, and it still would be a good example of that... for all the changes to primitives like FUNC and APPEND etc.  It just may not be able to accommodate the different expectations of binding.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-fate-of-redbol-emulation-in-a-mostly-unbound-world/2131">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-fate-of-redbol-emulation-in-a-mostly-unbound-world/2131</link>
          <pubDate>Tue, 23 Jan 2024 15:11:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2131</guid>
          <source url="https://forum.rebol.info/t/the-fate-of-redbol-emulation-in-a-mostly-unbound-world/2131.rss">The Fate of Redbol Emulation In A Mostly Unbound World</source>
        </item>
        <item>
          <title>Case-Insensitivity And Dialecting</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Today's Ren-C uses case-sensitive binding.  The topic has been discussed a lot:</p>
<p><a href="https://forum.rebol.info/t/case-insensitivity-vs-case-preservation-cant-have-both/1439" class="inline-onebox">Case Insensitivity vs. Case-Preservation (can't have both?)</a></p>
<p>As a discipline, we still are trying to keep the language lowercase, in the standard library at least.</p>
<p>But one thing that hasn't been discussed much is how case could be used creatively in dialects, when you know the case doesn't matter.  I think that in certain domains, use of case in dialects could be an interesting tool.</p>
<h2>
<a name="using-casing-to-imply-uppercase-lowercase-as-is-case-1" class="anchor" href="https://forum.rebol.info#using-casing-to-imply-uppercase-lowercase-as-is-case-1"></a>Using Casing To Imply Uppercase, Lowercase, As-Is Case</h2>
<p>I've written a little about how the <a href="https://forum.rebol.info/t/usefulness-of-string-interpolation/2114">CScape interpolation tool</a> does casing.  That's strings and not ordinary code.</p>
<p>The case logic would work in ordinary code something like this:</p>
<pre><code>&gt;&gt; strings: ["aBc" "dEf" "gHi]

&gt;&gt; cased-print ["For instance:" STRINGS.1 strings.2 Strings.3]
For instance: ABC def gHi
</code></pre>
<p>It might seem silly, but in CScape it turns out to be pretty useful to do that.</p>
<h2>
<a name="non-case-related-example-hardening-bindings-2" class="anchor" href="https://forum.rebol.info#non-case-related-example-hardening-bindings-2"></a>Non-Case-Related Example: "Hardening" Bindings</h2>
<p>We have an issue now that sometimes when you are composing material you want bindings to "stick".  Here we want LET and PASSTHRU to be bound to the same environment as the block given to the COMPOSE (which propagates to the GROUP!s, and then to the blocks evaluated in the groups).  But we want RETURN to be unbound, and pick up its binding from the site where it is composed:</p>
<pre><code> compose [
     (in [] 'let) (name): (in [] 'passthru) :return
 ]
</code></pre>
<p>There could be some dialect options for this... a special signal, maybe something you pass:</p>
<pre><code>compose/harden [
    &lt;hard&gt; let (name): &lt;hard&gt; passthru :return
] &lt;hard&gt;

compose/harden [
    %h let (name): %h passthru :return
] %h

compose/harden [
    $ let (name): $ passthru :return
] $
</code></pre>
<p>Since you have groups available, you could get the literal of the thing you're hardening with, e.g. with <code>(&lt;hard&gt;)</code> or <code>(%h)</code> or <code>($)</code></p>
<p>And of course, you could have an operation that reverses this...so that things were hardened by default but you escaped to leave them unbound.</p>
<p>But... a weirder idea... what if you used something like the case?</p>
<pre><code> weird-compose [
     LET (unbind name): PASSTHRU :return
 ]
</code></pre>
<p>Important to remember is that symbols don't have case.  So you can't use the trick for everything.</p>
<p>But I present this in juxtaposition to using even the most minimal signal (like $) just to show how much the comprehensibility can benefit.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/case-insensitivity-and-dialecting/2123">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/case-insensitivity-and-dialecting/2123</link>
          <pubDate>Wed, 17 Jan 2024 22:33:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2123</guid>
          <source url="https://forum.rebol.info/t/case-insensitivity-and-dialecting/2123.rss">Case-Insensitivity And Dialecting</source>
        </item>
        <item>
          <title>A (Lame) Hole-Punch Motivating Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <blockquote>
<p><em>Referenced in the explanation of <a href="https://forum.rebol.info/t/what-dialects-need-from-binding/2111/11">"What Dialects Need From Binding"</a></em></p>
<p><em><strong>This code uses hypothetical mechanisms for a new approach to pure virtual binding that are not yet implemented at time of writing.</strong></em></p>
</blockquote>
<hr>
<p>Let's imagine you have the idea of a dialect which validates the number of some characters in a string.  You give it a list of strings and you match using "keywords" ONE or TWO for the character at hand.  You can also run code in groups if you want:</p>
<pre><code>&gt;&gt; dialect ["aaaa" "bbbb"] [
       [#a [one two one (print "rule one match")]]
       [#b [two one one (print "passed 2 1 1") one (print "rule two match")]]
   ]
  rule one match
  passed 2 1 1
</code></pre>
<p>Now imagine a callsite that wants to use this dialect.  Let's say it has its own definition for what TWO means just incidentally defined.  But it knows the dialect's meaning should override that.  However let's say it also has some MESSAGE, that it doesn't want the dialect to override.</p>
<p>Let's also throw in COLLECT for good measure:</p>
<pre><code> let two: lambda [body] [repeat 2 body]  ; some incidental definition

 let message: "passed 2 1 1"  ; intended to be seen by the dialect

 let results: collect [
      dialect ["aaaa" "bbbb"] [
           [#a [one two one (keep &lt;finished a&gt;)]]
           [#b [two one one (print message) one (keep &lt;finished b&gt;)]]
       ]
 ]
</code></pre>
<p>The caller and DIALECT have a common understanding: that ONE and TWO are things that the dialect provides.  But it's the dialect's responsibility to sort that out.  Even though the tip of the block it receives has a definition for TWO, it shouldn't be influenced by that...because all the ONE and TWO are unbound inside that block.</p>
<p>Now say the plan of attack that the author has is to build upon the PARSE dialect to implement what they're doing.  It seems plausible they should be able to do the following:</p>
<pre><code> dialect: func [strings [block!] lines [block!]] [
     for-each line lines [
        line: in lines line
        let char: line.1
        let rule: in line line.2
        let string: strings.1
        do compose/deep [
            let one: (char)
            let two: [repeat 2 (char)]
            parse (string) [comment "your code here" (unuse [one two] rule)]
        ]
        strings: next strings
     ]
 ]
</code></pre>
<p>In more detail:</p>
<ul>
<li>
<p>Propagating with IN LINES and IN LINE means that RULE gets the binding of the original LINES block, which is the aggregated chain of bindings (from LIB for things like PRINT, for the LETs, for KEEP).  But it also has that definition of TWO.</p>
</li>
<li>
<p>We want RULE to come out of this as a BLOCK!, not boxed into a function, as PARSE intends to enumerate it.. as well as to be able to DO GROUP!s inside it.</p>
</li>
<li>
<p>We don't want to have to make a copy of that aggregated binding (e.g. an entire copy of LIB to remove any ONE and TWO, and a copy of all the other contexts to remove ONE and TWO).  Beyond inefficiency, we don't want to explode the number of binding environment identities.  Instead, we need an additive means to say <em>"I want everything <em>but</em> ONE and TWO from this binding environment"</em>.  Sort of a <a href="https://hypirion.com/musings/understanding-persistent-vector-pt-1">"persistent-vector"</a> approach.</p>
</li>
<li>
<p>This is what I call a hole-punching instruction... that becomes the new specifier for the embedded rule, pointing at the specifier of rule as a parent.  Later on during the DO of the composed code... when PARSE descends into the block and uses IN, that's where the hole-punched binding is "coalesced" with available definitions of ONE and TWO from PARSE's "current environment" (which it propagated off second parameter it received).</p>
</li>
</ul>
<p>There are many other ways to accomplish this intent--and this particular example does suck (it inadvertently exposes all the features of PARSE even if it didn't want to...among other criticisms).  But I maintain this implementation strategy is analogous to real situations that come up, vs. some imagined thing.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/a-lame-hole-punch-motivating-dialect/2116">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/a-lame-hole-punch-motivating-dialect/2116</link>
          <pubDate>Sat, 13 Jan 2024 07:39:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2116</guid>
          <source url="https://forum.rebol.info/t/a-lame-hole-punch-motivating-dialect/2116.rss">A (Lame) Hole-Punch Motivating Dialect</source>
        </item>
        <item>
          <title>Replaying Console Commands (Red&#39;s &quot;Spaces Console&quot;)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Console</category>
          <description><![CDATA[
            <p>Red's hiiamboris has made an alternative console (built on his <a href="https://forum.rebol.info/t/vid-s-or-spaces-from-reds-hiiamboris/1886">"Spaces" VID alternative</a>).  It appears you can go back to an earlier expression and edit it, and if you do, it will ripple the changes through running all your future expressions again.</p>
<p><img src="https://link.storjshare.io/raw/jwtiabvp6myahg3zzf3q5zoii7la/gif/spaces/demo-spaces-console.gif" alt="spaces console" width="409" height="500"></p>
<p>It's called <strong><a href="https://codeberg.org/hiiamboris/red-spaces/src/branch/master/programs/console">"Spaces Console"</a></strong>, and it's an interesting idea.  Sort of fuses together a watchlist with a console.</p>
<p>Note that Ren-C's Web Console can keep Ctrl-Z'ing to undo console output and go back to edit previous expressions... but you lose the subsequent commands.  Though the web console also has a <a href="https://youtu.be/0exDvv5WEv4?t=326">watchlist like the one in the Qt Ren Garden</a>.</p>
<p>Anyway, something to think about.</p>
<p>Note that the current implementation appears to be slow (<a href="https://matrix.to/#/!EorVRCzrVpjojJtctJ:gitter.im/$nf_3fEnM_24P0qAMnxdnwdcOKF3NVsAtzR6YnZq0PKM?via=gitter.im&amp;via=matrix.org&amp;via=chat.weho.st">Gitter link</a>):</p>
<blockquote>
<p><strong>Gregg:</strong> <em>"I thought it didn't like <code>repeat i 100 [print i]</code>, but just took a long time to process it. ~10s."</em></p>
<p><strong>Boris:</strong> <em>"printing is O(n^2) atm, need to overcome laziness and make it lower level :D"</em></p>
</blockquote>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/replaying-console-commands-reds-spaces-console/2107">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/replaying-console-commands-reds-spaces-console/2107</link>
          <pubDate>Thu, 11 Jan 2024 10:00:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2107</guid>
          <source url="https://forum.rebol.info/t/replaying-console-commands-reds-spaces-console/2107.rss">Replaying Console Commands (Red&#39;s &quot;Spaces Console&quot;)</source>
        </item>
        <item>
          <title>How Console Displays Things With No Literal Representation</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Console</category>
          <description><![CDATA[
            <p>It's tricky to think of what to do to print out things that don't have representation.</p>
<p>For example, isotopes ("antiforms") don't have representations and cannot be molded. (For a proposal of the exception of MOLD of splices, see <strong><a href="https://forum.rebol.info/t/mold-only-vs-mold-spread/2059">MOLD/ONLY vs spread</a></strong>)</p>
<p>So what's traditionally been done is just render it as a quasiform (so the tilde at the beginning hints something its up), and then add a comment at the end of the rendering.</p>
<p>If the <a href="https://forum.rebol.info/t/quasiforms-stable-unstable-isotopes-simpler-terminology/2005/7">renaming of "isotope" to "anti" were taken</a>, this would look like:</p>
<pre><code>&gt;&gt; anti 'null
== ~null~  ; anti
</code></pre>
<p>The representational issue is a bit of a thorn in the console, but you have to print something. (Well, unless it's a void, where printing nothing is the design.)</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/how-console-displays-things-with-no-literal-representation/2096">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-console-displays-things-with-no-literal-representation/2096</link>
          <pubDate>Mon, 08 Jan 2024 23:58:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2096</guid>
          <source url="https://forum.rebol.info/t/how-console-displays-things-with-no-literal-representation/2096.rss">How Console Displays Things With No Literal Representation</source>
        </item>
        <item>
          <title>Deceptive Incomplete Parsing: A Common Problem</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Some code I'd written checked for file extensions, wanting only %.r and %.reb files to be processed.  It looked like this:</p>
<pre><code> for-each file ... [
     parse file [thru ".reb" | thru ".r"] else [continue]
     ...
 ]
</code></pre>
<p>That doesn't work anymore, because PARSE raises an error instead of returning null.  The ELSE needs to be an EXCEPT, or you have to use IF NOT OK?, or some other solution.</p>
<p>My first thought on fixing it was why not just put the CONTINUE inside the parse...</p>
<pre><code> for-each file ... [
     parse file [thru ".reb" | thru ".r" | (continue)]
     ...
 ]
</code></pre>
<p>That's a neat Rebolism that shows the kind of malleability other languages just don't have.</p>
<p>But it has a problem.  Can you spot it?</p>
<h2>
<a name="old-redbol-conventions-wouldnt-catch-the-mistake-1" class="anchor" href="https://forum.rebol.info#old-redbol-conventions-wouldnt-catch-the-mistake-1"></a>Old Redbol Conventions Wouldn't Catch The Mistake</h2>
<p>Imagine if the file is named <strong>%foo.reb.zip</strong> or <strong>%foo.rar</strong>.  One of the THRUs succeeds, so it won't run the continue alternate.  But it won't reach the end of the filename.</p>
<p>Historical Redbol would have had the PARSE return false, but would have just blindly continued running, passing those unintended filenames!!!</p>
<p>Now we're a step ahead, because PARSE will error if it doesn't reach the end!  <img src="https://forum.rebol.info/images/emoji/twitter/clap.png?v=12" title=":clap:" class="emoji" alt=":clap:" loading="lazy" width="20" height="20"></p>
<h2>
<a name="but-how-to-stop-the-error-2" class="anchor" href="https://forum.rebol.info#but-how-to-stop-the-error-2"></a>But How To Stop the Error?</h2>
<p>We don't want an error if it doesn't terminate in %.r or %.reb, we want to continue the loop.</p>
<p>This will work:</p>
<pre><code> parse file [thru ".reb" &lt;end&gt; | thru ".r" &lt;end&gt; | (continue)]
</code></pre>
<p>And it's not catastrophically bad.  But it feels weird.</p>
<p>You can remove the <code>&lt;end&gt;</code> duplication:</p>
<pre><code> parse file [thru [".reb" | ".r"] &lt;end&gt; | (continue)]
</code></pre>
<p>You can also do that with ANY:</p>
<pre><code> parse file [thru any [".reb" ".r"] &lt;end&gt; | (continue)]
</code></pre>
<p>You can of course go for the conventional forms:</p>
<pre><code>parse file [thru ".reb" | thru ".r"] except [continue]

if not ok? parse file [thru ".reb" | thru ".r"] [continue]
</code></pre>
<p>But I feel like there's something missing when you write something like this without making the <code>&lt;end&gt;</code> explicit...because it leads to someone getting the bright idea (as I did) to reformulate it without taking the <code>&lt;end&gt;</code> into account.</p>
<h2>
<a name="in-any-case-this-being-overlooked-is-now-caught-3" class="anchor" href="https://forum.rebol.info#in-any-case-this-being-overlooked-is-now-caught-3"></a>In Any Case, This Being Overlooked Is Now Caught!</h2>
<p>It's food for thought on what style you want. But no matter what style you like, I think it shows a clear win for raising the error when the parse doesn't reach the end.</p>
<p>That %foo.rar or %foo.reb.zip -- when they occur -- will not be accepted quietly in the reformulation!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/deceptive-incomplete-parsing-a-common-problem/2065">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/deceptive-incomplete-parsing-a-common-problem/2065</link>
          <pubDate>Tue, 28 Nov 2023 03:33:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2065</guid>
          <source url="https://forum.rebol.info/t/deceptive-incomplete-parsing-a-common-problem/2065.rss">Deceptive Incomplete Parsing: A Common Problem</source>
        </item>
        <item>
          <title>Console Treatment of VOID vs. TRASH</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Console</category>
          <description><![CDATA[
            <p>Rebol2 and Red both have a console property that when the console sees an UNSET!, it prints nothing:</p>
<pre><code>&gt;&gt; block: reduce [&lt;a&gt; #[unset!] &lt;b&gt;]
== [&lt;a&gt; unset &lt;b&gt;]  ; bad rendering, conflates #[unset!] with the word `unset`

&gt;&gt; first block
== &lt;a&gt;

&gt;&gt; second block

&gt;&gt; third block
== &lt;b&gt;
</code></pre>
<p>This doesn't provide the best grounding in the console, especially considering that in their world an UNSET! is a reified value that can be found in a block.</p>
<p>However, returning an UNSET! is how functions like PRINT avoid outputting anything with <strong><code>==</code></strong> in the console:</p>
<pre><code>rebol2&gt;&gt; print "Notice no == result"
Notice no == result

rebol2&gt;&gt; type? print "Test"
Test
== unset!
</code></pre>
<h2>
<a name="but-what-result-should-ren-c-suppress-1" class="anchor" href="https://forum.rebol.info#but-what-result-should-ren-c-suppress-1"></a>But What Result Should Ren-C Suppress?</h2>
<p>Ren-C has two antiforms which might be considered candidates for not displaying... VOID and TRASH.</p>
<p>Because voids vanish, it might seem to make the most sense to have voids not print anything, and trashes print out the standard isotopic form:</p>
<pre><code>&gt;&gt; void

&gt;&gt; quote void
== ~void~

&gt;&gt; ~
== ~  ; anti
</code></pre>
<p>Looking at this, it might seem to make a lot of sense to have functions like PRINT and HELP return VOID.</p>
<p><strong>BUT</strong> as I explain in <a href="https://forum.rebol.info/t/why-doesnt-print-return-void-or-vaporize-via-nihil/1466">"Why doesn't PRINT return VOID or NIHIL"</a>, there is a bit of a pitfall.  Voids are friendly in terms of opting out of things:</p>
<pre><code>&gt;&gt; append [a b c] print "If PRINT returned void..."
If PRINT returned void...
== [a b c]
</code></pre>
<p><em>This seems too friendly to me.</em>  There's another possibility of returning NIHIL, which would prohibit use as an argument.  It would wind up making an evaluation appear to be void <em>if no other expressions were in play</em>...but if other expressions were involved it would let them fall out</p>
<pre><code>&gt;&gt; print "If PRINT returned nihil"
If PRINT returned nihil

&gt;&gt; append [a b c] "If PRINT returned nihil"
If PRINT returned nihil
** Error: APPEND is missing its VALUE argument

&gt;&gt; 1 + 2 print "If PRINT returned nihil"
If PRINT returned nihil
== 3
</code></pre>
<p>So returning TRASH feels like it makes the most <em>mechanical</em> sense...it has the right amount of ornery-ness:</p>
<pre><code>&gt;&gt; print "Mechanically this works best"
Mechanically this works best
== ~  ; isotope
</code></pre>
<p>But it's ugly to have that <strong>== ~  ; isotope</strong> after every HELP or PRINT or other function.</p>
<p>Historically I've gone with trash printing nothing, and void printing a result.</p>
<pre><code>&gt;&gt; ~

&gt;&gt; void
== ~void~  ; anti
</code></pre>
<p>But I've given a try at printing the results always to see what the results are.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/console-treatment-of-void-vs-trash/2045">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/console-treatment-of-void-vs-trash/2045</link>
          <pubDate>Thu, 03 Aug 2023 22:48:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2045</guid>
          <source url="https://forum.rebol.info/t/console-treatment-of-void-vs-trash/2045.rss">Console Treatment of VOID vs. TRASH</source>
        </item>
        <item>
          <title>Discouraging Semantics for COMMA! in Dialects</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Today I consider <a href="https://forum.rebol.info/t/the-language-worlds-weirdest-comma-mechanic/1387">COMMA! to be an indispensible addition to the language</a>.</p>
<p>But something that feels like a Rebol philosophy point is that we should strongly discourage the idea of commas having semantic meaning in dialects.  The status quo should be that they just provide visual separation.</p>
<p>In this mindset, the only impact adding a comma should have on code would be an error if they're not put in an "interstitial" position.  If you want a grouping to have semantic meaning, then a BLOCK! or GROUP! should be used... or perhaps a vertical bar |.</p>
<p>I think giving this guidance helps preserve Rebol's natural language stream aesthetic, where the kinds of problems mandatory commas introduce can be avoided.  Whether you are doing things at source level or in code generation, having N entries needing (N - 1) commas can be an annoyance.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/discouraging-semantics-for-comma-in-dialects/2042">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/discouraging-semantics-for-comma-in-dialects/2042</link>
          <pubDate>Wed, 26 Jul 2023 16:30:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2042</guid>
          <source url="https://forum.rebol.info/t/discouraging-semantics-for-comma-in-dialects/2042.rss">Discouraging Semantics for COMMA! in Dialects</source>
        </item>
        <item>
          <title>The Handling of NULL and VOID in UPARSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>By design, nulls are handled noisily--right at the moment of fetching the word!--in UPARSE (and PARSE3):</p>
<pre><code>&gt;&gt; prefix: null, suffix: ")"

&gt;&gt; parse "aaa)" [prefix, some "a", suffix]
** Error: (prefix is null, and we raise errors for that in parse)
</code></pre>
<p>If we didn't raise an error it seems there are only two other options:</p>
<ol>
<li>
<p>Make <strong><code>null</code></strong> always succeed, keeping the parse position where it is (synonym for <strong><code>[]</code></strong>)</p>
</li>
<li>
<p>Make <strong><code>null</code></strong> always be an unsuccessful combinator match, but not cause a failure (synonym for <strong><code>false</code></strong>)</p>
</li>
</ol>
<p>I think (1) feels like a pretty obvious bad idea, because null is supposed to represent a soft failure.  I've suggested that this is a better behavior for void, e.g. <strong><code>parse "ab" ["a" void "b"]</code></strong> would work.</p>
<p>I'm not too pleased with the idea of (2), and prefer the error as the default.</p>
<p><em>...that said...</em> it seems there should be some operators or combinators that let you get the other behaviors.</p>
<h2>
<a name="what-about-a-maybe-combinator-to-use-with-null-1" class="anchor" href="https://forum.rebol.info#what-about-a-maybe-combinator-to-use-with-null-1"></a>What About a "MAYBE" Combinator To Use With Null?</h2>
<p>In standard code, the policy of "void-in-null-out" has worked well, with MAYBE transforming soft-failure nulls to voids:</p>
<pre><code> ; non-PARSE handling of NULL via MAYBE

 &gt;&gt; append [a b c] null
 ** Error: cannot append ~null~ isotope to a block

 &gt;&gt; append [a b c] maybe null
 == [a b c]

 &gt;&gt; block: null

 &gt;&gt; append maybe block [d e]
 == ~null~  ; isotope
</code></pre>
<p>So if we imagine applying this to the parse example, it would presumably do this:</p>
<pre><code>&gt;&gt; prefix: null, suffix: ")"

&gt;&gt; parse "aaa)" [maybe prefix, some "a", maybe suffix]
== ")"
</code></pre>
<p>For the above parse to succeed, the combinator made by <strong>maybe prefix</strong> would have to succeed and not advance the input.</p>
<h2>
<a name="but-it-doesnt-combine-well-in-larger-rules-2" class="anchor" href="https://forum.rebol.info#but-it-doesnt-combine-well-in-larger-rules-2"></a>But It Doesn't Combine Well In Larger Rules</h2>
<p>What if what you intended was <em>"if there's a prefix, match some non-zero number of instances, but if prefix is null then don't worry about matching"</em>:</p>
<p>You might try doing that by COMPOSE'ing your rules.  But UPARSE actually lets us write that out literally using GET-GROUP! rule synthesis:</p>
<pre><code>&gt;&gt; parse "aaa)))" [:(if prefix '[some prefix]), some "a", :(if suffix '[some suffix])]
== ")"
</code></pre>
<p>But what if we tried to do that with MAYBE...could it work?</p>
<pre><code>&gt;&gt; parse "aaa)))" [some maybe prefix, some "a", some maybe suffix]
; infinite loop!
</code></pre>
<p>No dice.  We've said <strong>maybe prefix</strong> just succeeds and doesn't advance the input when prefix was null.  But if you combine that with <code>some</code> the null case will just match nothing in perpetuity, causing an infinite loop.</p>
<p>This may look familiar, because if you write <strong>some opt [...anything...]</strong> you'll always get an infinite loop.  But in that case it's just wrong thinking: you know that the repetitive nature of <code>some</code> looking for an eventual non-match meant you must have intended <strong>some [...anything...]</strong> (at least one) or <strong>opt some [...anything...]</strong> (zero or more).</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<blockquote>
<h3>NOTE THAT HISTORICAL PARSE HAS NO GOOD ANSWER FOR THIS</h3>
<p>Rebol2 treats NONE! as a no-op which just succeeds but doesn't advance the input.  So the following gives you an infinite loop:</p>
<pre><code>rebol2&gt;&gt; prefix: none suffix: ")"

rebol2&gt;&gt; parse "aaa)))" [some prefix some "a" some suffix]   
; infinite loop
</code></pre>
<p>The hackish "must make progress" rules in R3-Alpha actually make the above "work as intended", because the SOME will bail out after one non-advancing match.  I don't consider that a "good" answer--more a random effect.</p>
</blockquote>
<h2>
<a name="another-problem-maybe-is-a-very-similar-word-to-opt-3" class="anchor" href="https://forum.rebol.info#another-problem-maybe-is-a-very-similar-word-to-opt-3"></a>Another Problem: MAYBE is a very similar word to OPT</h2>
<p>Imagine looking at this code:</p>
<pre><code>&gt;&gt; prefix: "(", suffix: ")"

&gt;&gt; parse "aaa)" [maybe prefix, some "a", maybe suffix]
== ~null~  ; isotope
</code></pre>
<p><em>"But wait"</em>... I can imagine someone saying... <em>"doesn't that mean that if it's not there, you skip the rule"</em>?</p>
<blockquote>
<p>I've had some mental back-and-forth about the words <strong><code>try</code></strong>, <strong><code>opt</code></strong>, and <strong><code>maybe</code></strong>...with a general dislike of the word OPT.  The current idea is that TRY was intended to defuse harder definitional errors:</p>
<pre><code>&gt;&gt; take []
** Error: you can't take from an empty block (stopping further code)

&gt;&gt; try take []
== ~null~  ; isotope
</code></pre>
</blockquote>
<h2>
<a name="an-extra-barrier-to-creating-maybe-is-mechanical-4" class="anchor" href="https://forum.rebol.info#an-extra-barrier-to-creating-maybe-is-mechanical-4"></a>An extra barrier to creating MAYBE is mechanical</h2>
<p>... <em>because the error that NULL generates is the "null combinator" itself</em>.  It is <em>not</em> a definitional error, because those just represent things like "type didn't match".</p>
<p>The only way I can see a null-disabling MAYBE parse combinator working would be by quoting its argument, doing the rule fetch itself, and turning into a failing combinator if it fetched null.  This breaks the model somewhat.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=12" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<h2>
<a name="maybe-prefix-could-mean-optionally-null-variable-5" class="anchor" href="https://forum.rebol.info#maybe-prefix-could-mean-optionally-null-variable-5"></a>Maybe <strong>/prefix</strong> could Mean Optionally-Null variable?</h2>
<pre><code>&gt;&gt; prefix: null, suffix: ")"

&gt;&gt; parse "aaa)" [/prefix, some "a", /suffix]
== ")"
</code></pre>
<p>It's already the case that paths have to be quoted to match in blocks, but a leading slash could be used to deal with the rules.</p>
<p>It's a lot to think about on my first day of thinking about Rebol stuff for a while!  But there you go.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-handling-of-null-and-void-in-uparse/2023">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-handling-of-null-and-void-in-uparse/2023</link>
          <pubDate>Fri, 07 Apr 2023 00:14:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2023</guid>
          <source url="https://forum.rebol.info/t/the-handling-of-null-and-void-in-uparse/2023.rss">The Handling of NULL and VOID in UPARSE</source>
        </item>
        <item>
          <title>Future of the MATH Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>It is basically inevitable that people coming to Rebol will ask about its mathematical evaluation being left-to-right, instead of obeying the precedence order that they are used to.  Red just had a new user try to file it as a bug... 3 days ago:</p>
<p><a href="https://github.com/red/red/issues/5276" class="inline-onebox">Incorrect Order of Arithmetic Operations · Issue #5276 · red/red · GitHub</a></p>
<p><strong>What seemed to make sense to people like me and BrianH was that the core ship with a dialect called MATH.</strong>  The concept was that <strong>math [1 + 2 * 3]</strong> would give <strong>7</strong> and not <strong>9</strong>.  Having something in the box seemed better than having the first line of argument being <em>"you don't want the precedence you think you do"</em>.</p>
<p>But it turned out to be kind of hard to make pleasing.  One key difficulty which <a class="mention" href="https://forum.rebol.info/u/brett">@Brett</a> and I fretted over at some point was that since Rebol isn't "psychic" regarding arity, does not know a-priori how much code an expression will consume:</p>
<pre><code>math [1 + 2 * foo baz bar + 3]

; should it be...
[1 + (2 * (foo baz bar)) + 3]

; or perhaps...
[(1 + (2 * foo)) ((baz bar) + 3)]

; maybe...
[(1 + (2 * foo)) baz (bar + 3)]
</code></pre>
<p><strong>It started to appear that the user would have to put anything that wasn't a number or a math operator in groups.</strong>  There may be some heuristics which tolerate words that look up to numbers vs. functions, but it feels very slippery.</p>
<p>As I've said I hate to be dropping things, but MATH is something that Rebol programmers don't really want in the first place--and I don't think non-Rebol programmers would be satisfied by it.  If it's included in the core that suggests support for it, and there are just too many things in play.</p>
<p>Here is an implementation that was previously included, by Gabriele:</p>
<pre><code>; This MATH implementation is from Gabrielle Santilli circa 2001, found
; via http://www.rebol.org/ml-display-thread.r?m=rmlXJHS. It implements the
; much-requested (by new users) idea of * and / running before + and - in
; math expressions. Expanded to include functions.
;
math: func [
    {Process expression taking "usual" operator precedence into account.}

    expr [block!]
        {Block to evaluate}
    /only
        {Translate operators to their prefix calls, but don't execute}

    ; !!! This creation of static rules helps avoid creating those rules
    ; every time, but has the problem that the references to what should
    ; be locals are bound to statics as well (e.g. everything below which
    ; is assigned with BLANK! really should be relatively bound to the
    ; function, so that it will refer to the specific call.)  It's not
    ; technically obvious how to do that, not the least of the problem is
    ; that statics are currently a usermode feature...and injecting relative
    ; binding information into something that's not the function body itself
    ; isn't implemented.

    &lt;static&gt;

    slash (the /)

    expr-val (_)

    expr-op (_)

    expression  ([
        term (expr-val: term-val)
        opt some [
            ['+ (expr-op: 'add) | '- (expr-op: 'subtract)]
            term (expr-val: compose [(expr-op) (expr-val) (term-val)])
        ]
        &lt;end&gt;
    ])

    term-val (_)

    term-op (_)

    term ([
        pow (term-val: power-val)
        opt some [
            ['* (term-op: 'multiply) | slash (term-op: 'divide)]
            pow (term-val: compose [(term-op) (term-val) (power-val)])
        ]
    ])

    power-val (_)

    pow ([
        unary (power-val: unary-val)
        opt ['** unary (power-val: compose [power (power-val) (unary-val)])]
    ])

    unary-val (_)

    pre-uop (_)

    post-uop (_)

    unary ([
        (post-uop: pre-uop: [])
        opt ['- (pre-uop: 'negate)]
        primary
        opt ['! (post-uop: 'factorial)]
        (unary-val: compose [(post-uop) (pre-uop) (prim-val)])
    ])

    prim-val (_)

    primary ([
        set prim-val any-number!
        | set prim-val [word! | path!] (prim-val: reduce [prim-val])
            ; might be a funtion call, looking for arguments
            opt some [
                nested-expression (append prim-val take nested-expr-val)
            ]
        | ahead group! into nested-expression (prim-val: take nested-expr-val)
    ])

    p-recursion (_)

    nested-expr-val ([])

    save-vars (func [][
            p-recursion: reduce [
                :p-recursion :expr-val :expr-op :term-val :term-op :power-val :unary-val
                :pre-uop :post-uop :prim-val
            ]
        ])

    restore-vars (func [][
            set [
                p-recursion expr-val expr-op term-val term-op power-val unary-val
                pre-uop post-uop prim-val
            ] p-recursion
        ])

    nested-expression ([
            ;all of the static variables have to be saved
            (save-vars)
            expression
            (
                ; This rule can be recursively called as well,
                ; so result has to be passed via a stack
                insert nested-expr-val expr-val
                restore-vars
            )
            ; vars could be changed even it failed, so restore them and fail
            | (restore-vars) fail

    ])
][
    clear nested-expr-val
    let res: either parse3 expr expression [expr-val] [blank]

    either only [
        return res
    ][
        ret: reduce res
        all [
            1 = length of ret
            any-number? ret.1
        ] else [
            fail [
                unspaced ["Cannot be REDUCED to a number (" mold ret ")"]
                ":" mold res
            ]
        ]
        return ret.1
    ]
]
</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/future-of-the-math-dialect/2013">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/future-of-the-math-dialect/2013</link>
          <pubDate>Tue, 31 Jan 2023 19:08:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2013</guid>
          <source url="https://forum.rebol.info/t/future-of-the-math-dialect/2013.rss">Future of the MATH Dialect</source>
        </item>
        <item>
          <title>Websocket Support in Oldes Rebol3</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>Looking to see what Oldes has been up to, he added some kind of minimal websocket support to the HTTP scheme:</p>
<p><a href="https://github.com/Oldes/Rebol3/commit/bae6cffe97e662ec9a727a01cdcc1fdd61455ea6#diff-490ba807ac4a5ee57e7a587ca0936d36e4c0ff2798b0652fdf791e758ce079c2R718" class="inline-onebox">FEAT: Minimalistic WebSocket support in the `httpd` scheme · Oldes/Rebol3@bae6cff · GitHub</a></p>
<p>Websockets isn't something I'm looking into at this time, but I wanted to bookmark it here in case it comes up later.</p>
<p>He also updated zlib to a new version released in 2022... and <a href="https://github.com/Oldes/Rebol3/commit/15fcc00b84f6d0e386f2ba2f4fc7bdc32ebff75d">used Ren-C's %make-zlib.r to do it!</a>.  But he edited it so he'd be able to run it under his Rebol3.  It's not a huge priority to do that update, but seems like since his ported script still worked, it might not be too hard.  (And a good reminder that script exists, and should be part of a CI test...)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/websocket-support-in-oldes-rebol3/2003">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/websocket-support-in-oldes-rebol3/2003</link>
          <pubDate>Fri, 06 Jan 2023 03:56:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2003</guid>
          <source url="https://forum.rebol.info/t/websocket-support-in-oldes-rebol3/2003.rss">Websocket Support in Oldes Rebol3</source>
        </item>
        <item>
          <title>Head-to-Head Battle of the Coding Fonts</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Console</category>
          <description><![CDATA[
            <p>So I don't think this did the best job of representing Inconsolata (the choice for the ReplPad), but it lets you pit monospace fonts against each other to find the one you like:</p>
<p><a href="https://www.codingfont.com/">https://www.codingfont.com/</a></p>
<p>I still think if the right weight of Inconsolata is chosen it's the best.</p>
<p><a href="https://fonts.google.com/specimen/Inconsolata?preview.text=0O1Iil&amp;preview.text_type=custom#styles" class="inline-onebox">Google Fonts: Inconsolata</a></p>
<p>For me, the competition would be Source Code Pro or Fira Code.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/head-to-head-battle-of-the-coding-fonts/1994">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/head-to-head-battle-of-the-coding-fonts/1994</link>
          <pubDate>Thu, 01 Dec 2022 14:43:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1994</guid>
          <source url="https://forum.rebol.info/t/head-to-head-battle-of-the-coding-fonts/1994.rss">Head-to-Head Battle of the Coding Fonts</source>
        </item>
        <item>
          <title>R3-Alpha&#39;s DATATYPE! Definition</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>You likely know that DATATYPE! in R3-Alpha (Rebol 2, Red...) has a distinct "type byte" in the cell.  So the implementation can tell it's a different thing, even if not all representations show that:</p>
<pre><code>r3-alpha&gt;&gt; block: reduce ['integer! integer!]
== [integer! integer!]

r3-alpha&gt;&gt; type? first block
== word!

r3-alpha&gt;&gt; type? second block
== datatype!
</code></pre>
<p>One way R3-Alpha has to see the difference is with MOLD/ALL</p>
<pre><code>r3-alpha&gt;&gt; mold/all block
== "[integer! #[datatype! integer!]]"
</code></pre>
<h2>
<a name="but-whats-actually-in-a-datatype-cell-1" class="anchor" href="https://forum.rebol.info#but-whats-actually-in-a-datatype-cell-1"></a>But What's Actually <em>in</em> a DATATYPE! Cell?</h2>
<p>This was <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/include/sys-value.h#L106">the definition struct from R3-Alpha</a>:</p>
<pre><code>typedef struct Reb_Type {
    REBINT type;  // base type
    REBSER *spec;
    // REBINT min_type;
    // REBINT max_type;
} REBTYP;
</code></pre>
<p>So an integer to say what <strong><code>type</code></strong> it is (e.g. REB_INTEGER = 1, REB_LOGIC = 2, REB_BLOCK = 3 or whatever).  Note that this in the <em>payload</em> of the cell, not the header...because the type in the header is REB_DATATYPE to say it carries a "datatype payload".</p>
<p>Who knows what the commented-out <strong><code>min_type</code></strong> and <strong><code>max_type</code></strong> were.  But a remark says this payload is for a "Datatype or pseudo-datatype".  We can guess these were for pseudo-datatypes as a way of specifying a range of REB_XXX numbers to implement categories like ANY-SERIES!, as an alternative to typesets (?)</p>
<p>The <strong><code>spec</code></strong> is actually an object, that comes back as the answer to SPEC-OF:</p>
<pre><code>r3-alpha&gt;&gt; spec-of integer!
== make object! [
    title: "64 bit integer"
    type: 'scalar
]
</code></pre>
<p>This limited amount of information was built into the executable from the <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/boot/typespec.r#L24">Rebol-format table table in %typespec.r</a>.</p>
<p>You needed to use SPEC-OF to access these properties, but it could have been accessible with paths, e.g. <strong>integer!/title</strong>.  And it might have had more interesting properties:</p>
<pre><code>&gt;&gt; integer!/max-value
== 9223372036854775807
</code></pre>
<h2>
<a name="all-redbols-conflated-the-looks-of-datatype-and-word-2" class="anchor" href="https://forum.rebol.info#all-redbols-conflated-the-looks-of-datatype-and-word-2"></a>All Redbols Conflated The Looks of DATATYPE! and WORD!</h2>
<p>In lockstep, they all did it:</p>
<pre><code>rebol2&gt;&gt; integer!
== integer!

r3-alpha&gt;&gt; integer!
== integer!

red&gt;&gt; integer!
== integer!
</code></pre>
<p>Since I have <a href="https://forum.rebol.info/t/boron-language/1976">Boron</a> built, I find it renames integer! to int!, but otherwise the same:</p>
<pre><code>)&gt; int!
== int!

)&gt; type? int!
== datatype!

)&gt; type? first [int!]
== word!
</code></pre>
<p><strong>It seemed to me that this conflation couldn't possibly be the best answer.</strong>  So I made Ren-C buck this trend to use the R3-Alpha construction syntax, because it was something that could LOAD back:</p>
<pre><code>&gt;&gt; integer!
== #[datatype! integer!]

&gt;&gt; load "#[datatype! integer!]"
== [#[datatype! integer!]]
</code></pre>
<p><strong>Rendering differently was good, but the specific different rendering wasn't all that palatable.</strong>  And it wasn't showing it as any complex object.</p>
<h2>
<a name="where-to-go-from-there-3" class="anchor" href="https://forum.rebol.info#where-to-go-from-there-3"></a>Where To Go From There?</h2>
<p>There seemed to be two directions to go with this:</p>
<ul>
<li>
<p>Accept DATATYPE! as some kind of alien complex type which has ugly rendering</p>
</li>
<li>
<p>Fit it into the lexical space somewhere.</p>
</li>
</ul>
<p>Ren-C has moved toward the idea of making datatypes a BLOCK! variant, decorated with &amp;:</p>
<pre><code>&gt;&gt; type of integer!
== &amp;[integer]
</code></pre>
<p>The details of what structure is used on these type blocks is still under consideration at time of writing.  See the threads in the forum's <a href="https://forum.rebol.info/c/development/datatypes/45">Datatypes Category</a></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/r3-alphas-datatype-definition/1978">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/r3-alphas-datatype-definition/1978</link>
          <pubDate>Sat, 24 Sep 2022 08:02:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1978</guid>
          <source url="https://forum.rebol.info/t/r3-alphas-datatype-definition/1978.rss">R3-Alpha&#39;s DATATYPE! Definition</source>
        </item>
        <item>
          <title>Series Switching in PARSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p><strong>Rebol2 Prohibited Series Switching During a PARSE</strong></p>
<pre><code>&gt;&gt; series1: [a a a]
== [a a a]

&gt;&gt; series2: [b b b]
== [b b b]

&gt;&gt; parse series1 ['a :series2 some 'b]
** Script Error: Invalid argument: b b b
</code></pre>
<p>The error wasn't particularly informative.  But it was trying to tell you that you couldn't do that.</p>
<p><strong>Red Chose to Follow Suit, and Prohibits Series Switching During a PARSE</strong></p>
<p>red&gt;&gt; series1: [a a a]<br>
== [a a a]</p>
<p>red&gt;&gt; series2: [b b b]<br>
== [b b b]</p>
<p>red&gt;&gt; parse series1 ['a :series2 some 'b]<br>
*** Script Error: PARSE - get-word refers to a different series! :series2</p>
<p><strong>R3-Alpha Decided To Make It Legal</strong></p>
<pre><code>r3-alpha&gt;&gt; series1: [a a a]
== [a a a]

r3-alpha&gt;&gt; series2: [b b b]
== [b b b]

r3-alpha&gt;&gt; parse series1 ['a :series2 some 'b]
== true
</code></pre>
<p>I wasn't aware the feature was used, but <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> used it in the Rebol3 version of altjson:</p>
<p><a href="https://github.com/rgchris/Scripts/blob/6fa69eabe11fe78b9fd0a7bd6bb17a923cee0b2b/r3-alpha/altjson.r3#L48">https://github.com/rgchris/Scripts/blob/6fa69eabe11fe78b9fd0a7bd6bb17a923cee0b2b/r3-alpha/altjson.r3#L48</a></p>
<h2>The Feature Was Added to R3-Alpha Circa 2009</h2>
<p>Carl's blog entry:</p>
<p><a href="http://www.rebol.net/r3blogs/0265.html">http://www.rebol.net/r3blogs/0265.html</a></p>
<p>He points out one fairly clear reason why this is sketchy:</p>
<blockquote>
<p>The problem is this: if you change the series but the rule fails, forcing a recovery to a prior index, <em>it's still the new series</em>. That is, we do not recover to the old series.</p>
<p>If advanced users are willing to live with that restriction, then this change can be made.</p>
</blockquote>
<p>Another comment says the opposite of what I would think:</p>
<blockquote>
<p>Input switching would make parsing of big (or streaming) files more easy, as we wouldn't have to keep the whole data in memory, and could read it as needed, without losing the current parse state.</p>
</blockquote>
<p>Doing streaming parsing <em>correctly</em> requires <em>tighter</em> control over the process... not less.</p>
<h2>Can The Desire Be Met Other Ways?</h2>
<p>Since you're basically destroying the ability to meaningfully backtrack, I don't know how this is that different from starting a new parse.</p>
<p>I'd like it to be easy to return results out of a parse (see the <a href="https://forum.rebol.info/t/uparses-spin-on-return/1589">RETURN/ACCEPT post</a>)</p>
<p>So why wouldn't you have some kind of driving loop on the outside of your parse that looks for a continuation signal, and then starts a new parse with what it's given?</p>
<p>I want to take a look at the cases and see if they could be done some other way.  So maybe <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> can explain the rational behind the choice in altjson, and if there's some feature that would be a better fit.</p>
            <p><small>7 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/series-switching-in-parse/1974">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/series-switching-in-parse/1974</link>
          <pubDate>Tue, 20 Sep 2022 02:03:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1974</guid>
          <source url="https://forum.rebol.info/t/series-switching-in-parse/1974.rss">Series Switching in PARSE</source>
        </item>
        <item>
          <title>Boron Language</title>
          <dc:creator><![CDATA[WickedSmoke]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>Hello, Boron author here.  I look in on the Ren-C project once a year or so to see what's going on.  A few times I have considered joining this forum but for various reasons have not done so.  Since you have made space for similar projects, now seems like a good time to touch base.</p>
<p>Boron is my daily driver for scripting and has been in a stable period for years.  Bugfix releases occur roughly once per year.  I should have been making release announcements on the mailing list, but as there is no community of active users I didn't bother.  To exercise the language I have used it in the <a href="http://xu4.sourceforge.net/" rel="noopener nofollow ugc">xu4 project</a> to replace the XML configuration and scripting.</p>
<p>The next period of change may include support for static strings (ala AltScript), optimized path! storage, and reworking the evaluator to support yielding.</p>
<p>Games and graphics are an interest of mine so the Boron-GL project is where I experiment with GUIs, shaders, and such.  Some of the work on xu4 such as font rendering and the <a href="https://wickedsmoke.github.io/faun/" rel="noopener nofollow ugc">Faun</a> library will make it's way into Boron-GL.  The GL code was part of the main Boron repository until the end of 2019.</p>
            <p><small>12 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/boron-language/1976">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/boron-language/1976</link>
          <pubDate>Sat, 17 Sep 2022 14:39:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1976</guid>
          <source url="https://forum.rebol.info/t/boron-language/1976.rss">Boron Language</source>
        </item>
        <item>
          <title>Dialecting With Quasiforms</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>In the list of potential ideas of the long forgotten past, there was a thought that strings would come in two forms... one that was compared case-sensitively, and another that was not.</p>
<p>The visual look of the case-insensitive form was suggested as having a leading tilde, as one representation.</p>
<pre><code>&gt;&gt; "a" = ~"A"
== #[true]
</code></pre>
<p>No one really went to bat for the idea or thought through its ramifications.  It wasn't particularly easy to test what that would be like.</p>
<h2>Quasiforms Make The Proposal Easier To Test</h2>
<p>We now basically have the implementation guts needed to where we could consider the bits passed on the value.  It even has a decent name:</p>
<pre><code>&gt;&gt; quasi "A"
== ~"A"~

 &gt;&gt; "a" = "A"
 == #[false]

 &gt;&gt; "a" = quasi "A"
 == #[true]
</code></pre>
<p>The principle meaning of a quasiform is as the ^META of an isotope form.  And what this would mean is, there's no such thing as a differentiation between an isotopic case-sensitive word/string and an isotopic case-insensitive word/string.</p>
<h2>I Don't Think I Like It, BUT...</h2>
<p>Regardless of me not liking it, it's a possibility for dialects.  If you wanted to mark some strings for case-insensitivity you have another option in the box.</p>
<p>The reason I don't like it is because the isotope and quasi forms are supposed to stand out and draw attention to weirdness.  This is too common an application.  And it would mean your case-insensitive forms would be evaluating to isotopes everywhere, unless the quasiform evaluation changed in some way to make quasi-strings inert.  This isn't in line with what I want to do.</p>
<p>But...your dialect can do it.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/dialecting-with-quasiforms/1960">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dialecting-with-quasiforms/1960</link>
          <pubDate>Mon, 05 Sep 2022 08:16:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1960</guid>
          <source url="https://forum.rebol.info/t/dialecting-with-quasiforms/1960.rss">Dialecting With Quasiforms</source>
        </item>
        <item>
          <title>Scheduler Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>I thought of the scheduler dialect today that DocKimbel had made, and went and looked it up.</p>
<p>This is something that should be able to run as-is in Ren-C under Redbol emulation--so I'll see what I can do about that.  But it would also be interesting to see what kinds of improvements could be made to it with a Ren-C specific version.</p>
<aside class="onebox githubgist">
  <header class="source">
      <a href="https://gist.github.com/greggirwin/63471784ace61153763f465c3ea37c98" target="_blank" rel="noopener">gist.github.com</a>
  </header>
  <article class="onebox-body">
    <h4><a href="https://gist.github.com/greggirwin/63471784ace61153763f465c3ea37c98" target="_blank" rel="noopener">https://gist.github.com/greggirwin/63471784ace61153763f465c3ea37c98</a></h4>
<h5>scheduler.r</h5>
<pre><code class="Rebol">REBOL [
	Title: "Scheduler"
	File: %scheduler.r
	Purpose: "Dialected task scheduling library"
	Author: ["SOFTINNOV / Nenad Rakocevic" "Pointillistic / Gregg Irwin"]
	Copyright: ["2009 SOFTINNOV" "2013 SOFTINNOV/POINTILLISTIC"]
	Email: [nr@softinnov.com gregg@pointillistic.com]
	Date: 28-Oct-2013
	Version: 0.9.5
	License: "BSD - see %LICENCE.txt file"</code></pre>
This file has been truncated. <a href="https://gist.github.com/greggirwin/63471784ace61153763f465c3ea37c98" target="_blank" rel="noopener">show original</a>

<p>
</p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/scheduler-dialect/1957">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/scheduler-dialect/1957</link>
          <pubDate>Sat, 03 Sep 2022 07:40:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1957</guid>
          <source url="https://forum.rebol.info/t/scheduler-dialect/1957.rss">Scheduler Dialect</source>
        </item>
        <item>
          <title>Code Golf Website</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Rebmu</category>
          <description><![CDATA[
            <p>Here's a competitive code golf site with a leaderboard:</p>
<p><a href="https://code.golf/">https://code.golf/</a></p>
<p>The site seems to be reasonably well done, puzzles look good:</p>
<p><a href="https://code.golf/qr-decoder#c" class="inline-onebox">QR Decoder</a></p>
<p>It has a different model than other sites, where the answers are secret:</p>
<blockquote>
<p><em>"Can I See Other People's Solutions?</em></p>
<p><em>No, that way all holes stay competitive. If you're stuck on how to shave a couple of strokes off your solution then why not visit our Discord server for some advice."</em></p>
</blockquote>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/code-golf-website/1952">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/code-golf-website/1952</link>
          <pubDate>Wed, 31 Aug 2022 15:21:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1952</guid>
          <source url="https://forum.rebol.info/t/code-golf-website/1952.rss">Code Golf Website</source>
        </item>
        <item>
          <title>SPREAD in PARSE: Isotopic Matching</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Remember that the <code>@var</code> rule will match the contents of variables literally, vs. running them as a rule:</p>
<pre><code>&gt;&gt; var: [some rule]
== [some rule]

&gt;&gt; parse [[some rule] [some rule]] [some @var]
== [some rule]
</code></pre>
<p>You can evaluate an expression to literally match, too:</p>
<pre><code>&gt;&gt; parse [[some rule] [some rule]] [some @(reverse copy [rule some])]
== [some rule]
</code></pre>
<p>Now there's a powerful new twist: <strong>You can match in a spliced fashion, using an isotopic block!</strong></p>
<pre><code>&gt;&gt; var: [some rule]

&gt;&gt; parse [some rule some rule] [some @(spread var)]
== ~[some rule]~  ; isotope
</code></pre>
<p><em>And you can synthesize a product that may be a splice or not!!!</em></p>
<pre><code>&gt;&gt; append [a b c] parse [1 2 3] [block! | spread across some integer!]
== [a b c 1 2 3]

&gt;&gt; append [a b c] parse [[x y z]] [block! | spread across some integer!]
== [a b c [x y z]]
</code></pre>
<p><strong><a href="https://forum.rebol.info/t/putting-splicing-intent-on-appended-value/1873">Encoding the splicing intent on the value is clearly the way to go.</a></strong>  Seems obvious now, but hindsight is 20/20.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/spread-in-parse-isotopic-matching/1949">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/spread-in-parse-isotopic-matching/1949</link>
          <pubDate>Wed, 31 Aug 2022 10:36:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1949</guid>
          <source url="https://forum.rebol.info/t/spread-in-parse-isotopic-matching/1949.rss">SPREAD in PARSE: Isotopic Matching</source>
        </item>
        <item>
          <title>Matching Characters in BINARY! PARSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>In Rebol2, you can't match a character (or string) against a binary!:</p>
<pre><code>rebol2&gt;&gt; to binary! " "
== #{20}

rebol2&gt;&gt; parse #{20} [" "]
== false

rebol2&gt;&gt; parse #{20} [#" "]
== false
</code></pre>
<p>In Red and R3-Alpha, you can do both...</p>
<pre><code>red&gt;&gt; parse #{20} [" "]
== true

red&gt;&gt; parse #{20} [#" "]
== true
</code></pre>
<p>But their unicode model means they really don't know what they're doing in any general sense, and I'm sure whatever's under the hood is incoherent:</p>
<pre><code>red&gt;&gt; to binary! "Æ"
== #{C386}

red&gt;&gt; parse #{C386} ["Æ"]
== false
</code></pre>
<p>Ren-C is much more coherent!</p>
<pre><code>&gt;&gt; did parse #{C386} ["Æ"]
== #[true]
</code></pre>
<h2>So the PARSE Succeeds, but... what should it return?</h2>
<p>Right now a parse on a string returns the <em>rule</em> when it matches.</p>
<pre><code>&gt;&gt; rule: "cd"

&gt;&gt; result: parse "abcd" ["ab" rule]
== "cd"

&gt;&gt; append result "ef"
== "cdef"

&gt;&gt; rule
"cdef"
</code></pre>
<p><strong>This is clearly correct, because you don't want it to make a copy if it doesn't know if you're going to use the copy.</strong>  Basic rule matching should not produce a new series.</p>
<p>The same logic applies to BINARY!...but should it give you the string as a string, or aliased to its binary form?</p>
<pre><code>&gt;&gt; parse #{C386} ["Æ"]
== "Æ"  ; option 1

&gt;&gt; parse #{C386} ["Æ"]
== #{C386}  ; option 2
</code></pre>
<p>I think the answer is that you should match it as whatever form it was in the rule.</p>
<p>But then...how about something like BLANK!, which acts equivalently to space if the input is a string... or BLANK! if it's an array?</p>
<pre><code>&gt;&gt; parse [_] [_]
== _

&gt;&gt; parse " " [_]
== ???

&gt;&gt; parse #{20} [_]
== ???
</code></pre>
<p>If we're going with the idea of rule as being primacy, then the language of the match should be the same as the language of the rule... e.g. the above all return blank.</p>
<p>But this is something of a gray area, IMO.  I feel like blank is acting as a stand-in for space and should probably be looked at as if you said space.</p>
<pre><code>&gt;&gt; parse " " [_]
== #" "

&gt;&gt; parse #{20} [_]
== #" "  ; instead of 32
</code></pre>
<p>So this is what I'm going with, unless someone has a really good argument for something else.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/matching-characters-in-binary-parse/1935">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/matching-characters-in-binary-parse/1935</link>
          <pubDate>Sun, 21 Aug 2022 05:43:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1935</guid>
          <source url="https://forum.rebol.info/t/matching-characters-in-binary-parse/1935.rss">Matching Characters in BINARY! PARSE</source>
        </item>
        <item>
          <title>Calling Ren Functions From Redbol</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>When you <strong><code>import @redbol</code></strong> the environment for your module is skinned with the Redbol definitions.  But it can run concurrently with non-Redbol modules in the same session.  This is very cool.</p>
<p>I've nudged it a little further into cool by having the definition of LIB in Redbol be the initial state of the Redbol definitions, and then REN is the Ren-C's version of LIB.</p>
<pre><code>&gt;&gt; import @redbol

&gt;&gt; append [a b c] [d e]
== [a b c d e]

&gt;&gt; append/only [a b c] [d e]
== [a b c [d e]]

&gt;&gt; ren/append [a b c] [d e]
== [a b c [d e]]

&gt;&gt; ren/append [a b c] ren/spread [d e]
== [a b c d e]

&gt;&gt; append: does [print "Overwritten"]
== #[action! {append} []]

&gt;&gt; append
Overwritten

&gt;&gt; lib/append [a b c] [d e]
== [a b c d e]
</code></pre>
<p><em>Pretty slick.</em></p>
<h2>But IMPORT is Ultimately Not The Right Mechanism</h2>
<p>Because it's done using import, Redbol does not "clear out" the space of all the Ren-Cisms.</p>
<p>In fact, I didn't actually have to say <strong>ren/spread</strong> because the spread definition is still available:</p>
<pre><code>&gt;&gt; ren/append [a b c] spread [d e]
== [a b c d e]
</code></pre>
<p>It's non-viable to ask Redbol to remove every Ren-C definition.  Instead, there needs to be a way to get a Redbol-using module to start from a fully clean slate where it explicitly exports everything it wants to make available.  This doesn't have to be that much work, it can just be a list of words in a block, with possible renamings:</p>
<pre><code>redbol-inherit [even?, odd?, value?: unset? ...]
</code></pre>
<h2>These Challenges Are Great For Vetting</h2>
<p>I don't throw softballs.  This is all truly attempting to live up to the hype of a language that you can bend and redefine at will, without constantly tripping over your own changes--and being able to build on top of existing functionality without being forced to rewrite it too.</p>
<p>Although things move slowly... the arrow of progress is in the right direction.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/calling-ren-functions-from-redbol/1934">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/calling-ren-functions-from-redbol/1934</link>
          <pubDate>Sat, 20 Aug 2022 21:05:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1934</guid>
          <source url="https://forum.rebol.info/t/calling-ren-functions-from-redbol/1934.rss">Calling Ren Functions From Redbol</source>
        </item>
        <item>
          <title>TRY PARSE + PARSE EXCEPT : *FAIL* On Mismatch</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>There's a snazzy new potential for giving more informative messages / logs from failed parses... which means we now have a more interesting option than we might have had before.</p>
<p>Imagine something like:</p>
<pre><code>&gt;&gt; parse "aaa" [some "a" some "b"]
** Error: SOME requires at least one match
** Where: [some "a" \\ some "b" \\]
; Note: this failure can be intercepted by TRY, EXCEPT, ATTEMPT
</code></pre>
<p>It can't be perfect unless it maintains some kind of large error tree that accumulates the list of all the reasons it decided to fail, so you might have to be in a debugging mode to ask it to give you a bigger diagnostic.  But we can build it now with the participation of the combinators themselves.</p>
<p><strong>But not only this, we could open up the full spectrum of return values.</strong>  Right now if your parse returns NULL, it has to be contorted into a null isotope to avoid accidentally cuing an ELSE.  Similar contortions for void, blank, and logic false.</p>
<pre><code>result: parse block rules except e -&gt; [print "Got an error", return none]

; If you got here, you know result is good
; Even if it was a purposefully returned NULL, etc.
</code></pre>
<p>There'd be some way to rig this up without using enfix.  I might make things more lax about letting you assign error isotopes, because the isotope will bubble through and cause a problem anyway.  So you could write something like:</p>
<pre><code> if raised? result: parse block rules [
     print "You have a failure, use ^result to get it"
 ]
</code></pre>
<p>If you were willing to collapse failure down to a NULL or somesuch, or didn't even care about the result, you could just TRY it.</p>
<pre><code> try parse block rules
</code></pre>
<h2>
<a name="too-good-not-to-be-the-default-1" class="anchor" href="https://forum.rebol.info#too-good-not-to-be-the-default-1"></a>Too Good Not To Be The Default</h2>
<p>Of course you'll be able to reskin it however you like for the R3C's or R3Chius out there.  But I think this looks like a perfect convergence to put in the box.</p>
<p>Errors aren't going to be that interesting on day one, but it's good to point the ship in the right direction.</p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/try-parse-parse-except-fail-on-mismatch/1924">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/try-parse-parse-except-fail-on-mismatch/1924</link>
          <pubDate>Fri, 19 Aug 2022 06:23:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1924</guid>
          <source url="https://forum.rebol.info/t/try-parse-parse-except-fail-on-mismatch/1924.rss">TRY PARSE + PARSE EXCEPT : *FAIL* On Mismatch</source>
        </item>
        <item>
          <title>Wish: Multi-Returns For UPARSE Combinators</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Every combinator has a synthesized value.  But some combinators throw away values synthesized by their parser parameters.</p>
<p>For instance, TALLY.</p>
<pre><code>&gt;&gt; parse [1020 304] [int: some integer!]
== 304

&gt;&gt; parse [1020 304] [count: tally some integer!]
== 2
</code></pre>
<p>TALLY knows what the result of the last call it made was, but doesn't preserve it.  What if you could?</p>
<pre><code>&gt;&gt; parse [1020 304] [[count int]: tally some integer!]
== 2

&gt;&gt; count
== 2

&gt;&gt; int
== 304
</code></pre>
<p>That particular one is not necessarily a very interesting example, since you could get it yourself...</p>
<pre><code>parse [1020 304] [count: tally int: some integer!]
</code></pre>
<p>I only mention it because it was in a comment in UPARSE I wanted to delete, because it's a long enough file without becoming a wishlist compilation.  :-/</p>
<p>But there are certainly going to be other examples of combinators that might want to synthesize more than one value.  So hopefully the feature can be implemented at some point...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/wish-multi-returns-for-uparse-combinators/1920">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/wish-multi-returns-for-uparse-combinators/1920</link>
          <pubDate>Wed, 17 Aug 2022 14:43:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1920</guid>
          <source url="https://forum.rebol.info/t/wish-multi-returns-for-uparse-combinators/1920.rss">Wish: Multi-Returns For UPARSE Combinators</source>
        </item>
  </channel>
</rss>

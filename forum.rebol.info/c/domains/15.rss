<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Domains - AltRebol</title>
    <link>https://forum.rebol.info/c/domains/15</link>
    <description>Topics in the &#39;Domains&#39; category Applications of Rebol in various specialized subject domains.</description>
    
      <lastBuildDate>Tue, 17 May 2022 08:43:30 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/domains/15.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Contemplating UPARSE-VALUE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Once upon a time, PARSE was willing to take rules that were not BLOCK! and do "simple parsing".  Ultimately this was thought better of and became SPLIT...because that wasn't a very interesting polymorphism.</p>
<p>But... since PARSE is at heart a matching task, it seems there might be more accommodation when the input value is not a block... and you want to do some top level pattern matching.  Consider something like this:</p>
<pre><code>case [
     integer? item [
         print "Not a series, so, have to write handling code here"
     ]
     text? item [
         print "A series, but maybe we want to do something else"
     ]
     block? item [
         print "Okay finally we can use the parse we mean..."
         uparse item [...rules...]
     ]
] else [
   fail "Whatever"
]
</code></pre>
<p>It's something of a missed opportunity, and when I see this I start thinking along these lines:</p>
<pre><code>uparse reduce [item] [
     integer! &lt;end&gt; (print "More convenient, perhaps...")
         |
     text! &lt;end&gt; (print "Depends on the use case...")
         |
     into block! &lt;end&gt; [
        (print "Your rules here I guess...")
     ]
] else [
    fail "Whatever"
]
</code></pre>
<p>On first glance it's not necessarily an improvement, but... let's say for a minute that we have a UPARSE-VALUE which implicitly throws in the <code>&lt;end&gt;</code>:</p>
<pre><code>uparse-value item [
     integer! (print "Okay, this...")
         |
     text! (print "Seems a bit cleaner...")
         |
     into block! [
        (print "Your rules here I guess...")
     ]
] else [
    fail "Whatever"
]
</code></pre>
<p>This is just a high-level thought of pushing down the higher level matching tasks into UPARSE instead of keeping it fully separate.  If your input was calculated, you could still call it up with <code>&lt;input&gt;</code> ... although that wouldn't be available to the GROUP! code.</p>
<pre><code>&gt;&gt; uparse-value 1 + 2 [integer! (print "int") &lt;input&gt; | text! (print "text", #text)]
int
== 3

&gt;&gt; uparse-value "foo" [integer! (print "int") &lt;input&gt; | text! (print "text", #text)]
text
== #text
</code></pre>
<p>But you're no worse off than in a switch statement that doesn't have calculated input captured under a name.  (Slightly better, in fact, since you have a means of calling up the calculated input.)</p>
<p>It's just a thought, because I've seen this pattern several times: "I have a decision tree but I can't start doing parsing until I have a series".  This is just an idea about stretching all the matching and extraction logic that is going to be needed in UPARSE anyway to apply to single values.</p>
<h2>UPARSE-VALUE or UPARSE/VALUE</h2>
<p>This strongly parallels the LOAD-VALUE vs. LOAD issue.  It seemed to make more sense in that case to separate it out so LOAD was fully generic and unconcerned with the /VALUE aspect.  This might or might not have the same rationale as to why UPARSE shouldn't internally be concerned with the behavior.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/contemplating-uparse-value/1822">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/contemplating-uparse-value/1822</link>
          <pubDate>Tue, 17 May 2022 08:43:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1822</guid>
          <source url="https://forum.rebol.info/t/contemplating-uparse-value/1822.rss">Contemplating UPARSE-VALUE</source>
        </item>
        <item>
          <title>What Should BLANK! in UPARSE Do?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>It's always good to look at history first.  So let's compare and contrast #[none] vs. empty block in old Redbols.</p>
<p><strong>In Rebol2 and R3-Alpha, both are no-ops.</strong>  The input type doesn't matter.</p>
<pre><code>r2/r3&gt;&gt; parse {ab} [[] "a" [] "b" []]
== true

r2/r3&gt;&gt; parse {ab} [#[none] "a" #[none] "b" #[none]]
== true

r2/r3&gt;&gt; parse [a b] [[] 'a [] 'b []]
== true

r2/r3&gt;&gt; parse [a b] [#[none] 'a #[none] 'b #[none]]
== true
</code></pre>
<p><strong>In Red, #[none]s are expected to be literal.</strong>  However, you don't get an error on string inputs...just a failure.</p>
<pre><code>red&gt;&gt; parse {ab} [[] "a" [] "b" []]
== true

red&gt;&gt; parse {ab} [#[none] "a" #[none] "b" #[none]]
== false

red&gt;&gt; parse [a b] [[] 'a [] 'b []]
== true

red&gt;&gt; parse [a b] [#[none] 'a #[none] 'b #[none]]
== false

red&gt;&gt; parse [#[none] a #[none] b #[none]] [#[none] 'a #[none] 'b #[none]]
== true
</code></pre>
<h2>I Think No-Op Is the Superior Choice for BLANK! (NONE!)</h2>
<p>Ren-C's philosophy surrounding blank as "reified nothing" is that it is there to signal opting-out.</p>
<p>It's raison d'etre is being falsey, and easy to test for its nothing-ish state...easily convertible to and from NULL.  (NULL rules are errors, as they should be).</p>
<p>The idea of being able to look for literal values is being explored other ways, the @ was one proposal (though this is going back and forth).</p>
<pre><code>  &gt;&gt; var: _

  &gt;&gt; uparse [_ _ _] [some @var]
  == #[true]
</code></pre>
<p>But a blank rule is more effectively a no-op, IMO.</p>
<p>(For a time it had been considered that it could be a way of matching ANY-VALUE!, but that is now done more clearly with the <strong><code>&lt;any&gt;</code></strong> tag combinator, which is working out splendidly.)</p>
<h2>What Should a BLANK! Rule's Synthesized Product Be?</h2>
<p>When it comes to empty blocks, I'm pretty solidly sold that the answer is a ~none~ isotope:</p>
<pre><code>&gt;&gt; rule: []

&gt;&gt; did uparse {ab} ["a" x: rule "b"]
== #[true]

&gt;&gt; x
** Script Error: x is ~none~ isotope
</code></pre>
<p>There's a deeply interlocked set of justifications for that, which (I hope) aren't going to need rethinking.</p>
<p>But with BLANK! rules it's not so obvious:</p>
<pre><code>&gt;&gt; rule: _

&gt;&gt; did uparse {ab} ["a" x: rule "b"]
== #[true]

&gt;&gt; x
== ???
</code></pre>
<p>I'm skeptical of vaporization, e.g. <strong><code>(x = "b")</code></strong>  It seems that would be useful only in the most rare of situations, and 99% of the time it would surprise the caller.</p>
<p>The philosophy of "blank in, null out" suggests NULL.  That seems useful.  (Implementation of this would actually return a <em>null isotope</em>, such that the rule could still look successful while handing back that result!)</p>
<p>I think that gives a pretty interesting shape to things.  Because this is new, I'll have to look for applications of it...but I'm pretty sure they will show up.  If I see any, I'll make a note of them here.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/what-should-blank-in-uparse-do/1821">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-should-blank-in-uparse-do/1821</link>
          <pubDate>Sun, 15 May 2022 22:35:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1821</guid>
          <source url="https://forum.rebol.info/t/what-should-blank-in-uparse-do/1821.rss">What Should BLANK! in UPARSE Do?</source>
        </item>
        <item>
          <title>`greb` : Grep Using PARSE?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>System Tools</category>
          <description><![CDATA[
            <p>There was a Trello card with a remark from <a class="mention" href="/u/johnk">@johnk</a> about an idea from Pekr:</p>
<blockquote>
<p>Not sure how this would work, but it is an interesting excercise to think about.  Something that bridges between unix and rebol syntax like:</p>
<pre><code>ls | greb 'some alpha ".reb"'
</code></pre>
<p>(assuming a few more built in rules/charsets)</p>
<p>May need a collect/keep kind of wrapper to retrieve data cleanly.</p>
</blockquote>
<p>This would be a very small subset of what <a class="mention" href="/u/blackattr">@BlackATTR</a>'s QUERY could do...but it seems like it wouldn't hurt if we went ahead and made this program as a test and put it in the <a href="https://github.com/metaeducation/ren-c-stdio">ren-c-stdio</a> repository.</p>
<p>I've already made things like TAC (backwards unix CAT), where the goal is to see how essential and correct we can make things:</p>
<aside class="onebox githubblob">
  <header class="source">
      <a href="https://github.com/metaeducation/ren-c-stdio/blob/7fc17e5bb36ceeb7f688516ba57db5ad84a923c9/tests/tac.r#L19-L21" target="_blank" rel="noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <h4><a href="https://github.com/metaeducation/ren-c-stdio/blob/7fc17e5bb36ceeb7f688516ba57db5ad84a923c9/tests/tac.r#L19-L21" target="_blank" rel="noopener">metaeducation/ren-c-stdio/blob/7fc17e5bb36ceeb7f688516ba57db5ad84a923c9/tests/tac.r#L19-L21</a></h4>
<pre class="onebox"><code class="lang-r"><ol class="start lines" start="19" style="counter-reset: li-counter 18 ;">
<li>write-stdout try delimit/tail newline reverse collect [</li>
<li>    until [not keep line: try read-line]</li>
<li>]</li>
</ol></code></pre>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p><strong>I like the idea of making GREB similarly essential, and part of the samples.</strong>  Worth doing.</p>
<p>(Note that <code>grep</code> was itself originally framed as a one-line <code>awk</code> program.)</p>
<p>I'll also throw in a little ping that it would be nice to have a simple web app that exposed PARSE functionality with some highlighting, like <a href="http://regexpal.com/">http://regexpal.com/</a>.  Seems sometimes we get such big ideas in our head we forget to do the small ones (!)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/greb-grep-using-parse/1818">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/greb-grep-using-parse/1818</link>
          <pubDate>Sat, 14 May 2022 05:09:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1818</guid>
          <source url="https://forum.rebol.info/t/greb-grep-using-parse/1818.rss">`greb` : Grep Using PARSE?</source>
        </item>
        <item>
          <title>Mustache Templates vs RSP</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Web</category>
          <description><![CDATA[
            <p>On an old Trello I found a link to this renderer for "Mustache":</p>
<aside class="onebox githubfolder">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="16" height="16">
      <a href="https://github.com/kronwiz/r3-mustache" target="_blank" rel="noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <img src="https://opengraph.githubassets.com/1e73d9d2c54389cdd35bded29734b54c3d25b8293c427a9df0cc11db00084d73/kronwiz/r3-mustache" class="thumbnail onebox-full-image" width="60" height="60">

<h3><a href="https://github.com/kronwiz/r3-mustache" target="_blank" rel="noopener">GitHub - kronwiz/r3-mustache: Mustache templates renderer for Rebol 3</a></h3>


  <p><span class="label1">Mustache templates renderer for Rebol 3. Contribute to kronwiz/r3-mustache development by creating an account on GitHub.</span></p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>It may or may not be interesting.  <a class="mention" href="/u/rgchris">@rgchris</a> said:</p>
<blockquote>
<p>"I'd suggest looking at my <a href="http://reb4.me/r3/rsp">RSP engine</a> for handling string templates, local values, sanitization. LOAD-RSP loads a template and returns a function. That function can be applied to a block of local words and returns a completed string. The template need only be loaded once."*</p>
</blockquote>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/mustache-templates-vs-rsp/1817">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/mustache-templates-vs-rsp/1817</link>
          <pubDate>Sat, 14 May 2022 04:56:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1817</guid>
          <source url="https://forum.rebol.info/t/mustache-templates-vs-rsp/1817.rss">Mustache Templates vs RSP</source>
        </item>
        <item>
          <title>(U)PARSE + CALL: Controlling Of Interactive CLI Apps</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>General Tools</category>
          <description><![CDATA[
            <p>A long time ago (e.g. college), I used something in Tcl called EXPECT...which was a great way of driving interactive console applications.</p>
<p>You'd specify the patterns you wanted to wait on (that came from the app's stdout), and script the responses to be fed to stdin, in an interactive fashion.</p>
<p>Today people think a lot more about exposing functionality through APIs (with whatever Java or XML and such).  So it's more rare that you have to resort to writing "stdio robots".</p>
<p>But it's a pretty easy-to-absorb test case, and could be a real showcase for UPARSE...as well as a good challenge for a renewed PORT! model.</p>
<p>I found this code from <a class="mention" href="/u/brett">@Brett</a> on Trello, where the need for an R3 version of CALL was being articulated.  It gives some EXPECT-like functionality:</p>
<aside class="onebox githubblob">
  <header class="source">
      <a href="https://github.com/codebybrett/r3-scripts/blob/master/call-server.r" target="_blank" rel="noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <h4><a href="https://github.com/codebybrett/r3-scripts/blob/master/call-server.r" target="_blank" rel="noopener">codebybrett/r3-scripts/blob/master/call-server.r</a></h4>
<pre><code class="lang-r">REBOL [
	Title: "call-server"
	File: %call-server.r
	Author: "Brett Handley"
	Date: 22-Jun-2013
	Purpose: "Provides a way to capture output from console program and send input to interactive console programs."
	License: {

		Copyright 2013 Brett Handley

		Licensed under the Apache License, Version 2.0 (the "License");
		you may not use this file except in compliance with the License.
		You may obtain a copy of the License at

			http://www.apache.org/licenses/LICENSE-2.0

		Unless required by applicable law or agreed to in writing, software
		distributed under the License is distributed on an "AS IS" BASIS,
		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		See the License for the specific language governing permissions and
</code></pre>

  This file has been truncated. <a href="https://github.com/codebybrett/r3-scripts/blob/master/call-server.r" target="_blank" rel="noopener">show original</a>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>This seems like a good domain to build some simple-but-impressive demos for... in the "layperson could have built this robot" sense (if we can push it to that point).</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/u-parse-call-controlling-of-interactive-cli-apps/1816">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/u-parse-call-controlling-of-interactive-cli-apps/1816</link>
          <pubDate>Sat, 14 May 2022 04:52:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1816</guid>
          <source url="https://forum.rebol.info/t/u-parse-call-controlling-of-interactive-cli-apps/1816.rss">(U)PARSE + CALL: Controlling Of Interactive CLI Apps</source>
        </item>
        <item>
          <title>Old Idea from DocKimbel For Rebol2 =&gt; Rebol3/Red</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>This is something I just ran across from a long time ago, which I thought would be interesting to look at with modern eyes.</p>
<p>It's a Gist: <a href="https://gist.github.com/dockimbel/5083375">https://gist.github.com/dockimbel/5083375</a> of a proposal of actually making a DO variant that would rewrite the source of a script.</p>
<p>He is quoted as having said: <em>"A JIT-migration tool would be more accurate. It would run just after LOAD and before DO to rewrite part of the R2 sources in a R3 compatible format."</em></p>
<p>Static analysis of Turing-Complete programs is notoriously on the difficult-if-not-impossible scale, even for simple languages.  So JIT-rewriting even something like PARSE rules is only going to be feasible if those rules were not built by code.</p>
<p>His example just looks for one source pattern (negative literal indexing, so like translating between <strong><code>data/0</code></strong> and <strong><code>data/-1</code></strong>).  But determining what is "code" and what is "data" is deliberately more complex in Rebol than other language.</p>
<p>In Ren-C we have code like <code>enbin [BE +/- 32]</code> and that path is never meant to execute, it's just there to convey the notion of wanting to encode a signed number.  Going around and randomly turning all paths with 0 in them to be -1 misses the whole point of "relative expressions"; you don't know what they're relative to.</p>
<p>So the ironic point of preserving this is just to say "nothing to see, here".  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:">  <code>%redbol.reb</code> is a saner track.  But I do think it's going to wind up requiring DO itself being different... a DO2 (like UPARSE2).  It won't rewriting the code block given, but hook the evaluator with different rules.</p>
<pre><code>REBOL [
    Author:  "Nenad Rakocevic"
    Date:      04/03/2013
    Purpose: {
        Show how to achieve R2 source rewriting suitable for evaluation
        using R3 interpreter.
    }
        Note: "Use it from %Red/ folder"
]

context [
    do*: s: none
    
    path-rewrite: [
        some [
            s: integer! (if negative? s/1 [s/1: s/1 + 1])
            ;| handle other indexed-access cases here
            | skip
        ]
    ]

    patched-do: func [value /arg /local saved rule mark path file][
        unless file? :value [return do* value]

        saved: system/script/path
        set [path file] split-path :value
        change-dir path
        value: load file

        parse value rule: [
            any [
                mark: [path! | set-path! | lit-path!] :mark into path-rewrite
                ;; | mark: string! :mark into string-rewrite 
                ;; add more rewritting rules here
                | mark: any-block! :mark into rule
                | skip
            ]
        ]
        also 
            do* value
            system/script/path: saved
    ]
    
    set 'do-r2 func [blk [block!]][
        do*: :do
        set 'do :patched-do
        do blk
        set 'do :do*
    ]
]

do-r2 [
    do %red/compiler.r
]
save %red.new red  ;-- inspect the file to see the changes
halt</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/old-idea-from-dockimbel-for-rebol2-rebol3-red/1814">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/old-idea-from-dockimbel-for-rebol2-rebol3-red/1814</link>
          <pubDate>Sat, 14 May 2022 04:12:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1814</guid>
          <source url="https://forum.rebol.info/t/old-idea-from-dockimbel-for-rebol2-rebol3-red/1814.rss">Old Idea from DocKimbel For Rebol2 =&gt; Rebol3/Red</source>
        </item>
        <item>
          <title>Asymmetric Encryption/Decryption in Ren-C</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Cryptography</category>
          <description><![CDATA[
            <p>The most easily recognized form of encryption is symmetric, where the same password is used to encrypt something as to decrypt it.</p>
<p>But a weirder form is <strong>asymmetric encryption</strong>, <em>where the key used to encrypt is different from the one used to decrypt</em>.</p>
<h2>Ren-C Supports RSA Public/Private Encryption</h2>
<p>You generate your keys in a pair, which come back via multiple return results.  You must specify a size for the public key (in <em>bits</em>, not <em>bytes</em>...<a href="https://crypto.stackexchange.com/questions/58124/">because that's the convention</a>)</p>
<p>We'll start using [raw] RSA encryption:</p>
<pre><code>; use /INSECURE to override errors that tell you the key is too small
; (makes examples more readable)

&gt;&gt; [public-key private-key]: rsa-generate-keypair/padding/insecure 128 [raw]
== make object! [
    padding: [raw]
    n: #{C097238C34E7191561DD7D30BBB77C65}
    e: #{010001}
]

&gt;&gt; length of public-key.n
== 16  ; 16 bytes is 128 bits
</code></pre>
<p>When you use raw mode encryption, the data you encrypt must be <em>exactly the same size</em> as the key you made.  We'll show how to work around this later, but for now let's just deal with it.</p>
<pre><code>&gt;&gt; data: #{0123456789ABCDEFFEDCBA9876543210}

&gt;&gt; length of data
== 16  ; same size as our key

&gt;&gt; encrypted: rsa-encrypt data public-key
== #{3F7E8ACD2DEE61D09B7A6FC914E22295}

&gt;&gt; length of encrypted
== 16  ; also same length as key
</code></pre>
<p>Now, decryption is done with the private key:</p>
<pre><code>&gt;&gt; rsa-decrypt encrypted private-key
== #{0123456789ABCDEFFEDCBA9876543210}
</code></pre>
<h2>But <code>[raw]</code> Makes The Same Message Every Time...</h2>
<p>Raw RSA doesn't waste any space (e.g. 4096 bytes in means 4096 bytes out).  <strong>But a given output always produces the same output with raw RSA</strong>:</p>
<pre><code>&gt;&gt; rsa-encrypt data public-key
== #{3F7E8ACD2DEE61D09B7A6FC914E22295}

&gt;&gt; rsa-encrypt data public-key
== #{3F7E8ACD2DEE61D09B7A6FC914E22295}
</code></pre>
<p>This can make it easy (or at least, easier) for someone who doesn't have the private key to do some factoring with the public key, and see if they can generate input that produces that output...effectively defeating the encryption.</p>
<p>Also since it requires exactly the keysize of data coming in, you're likely going to have a lot of cases where you have to throw in some padding.  But naive answers to padding also create security problems:</p>
<ul>
<li>
<p><strong>It would be bad to pad the data block with zeros (or whatever)</strong>, because such predictable behavior generally makes it easier to guess what the encrypted information might be.</p>
</li>
<li>
<p><strong>It would be bad to just put random data in the padding</strong>, because the person doing the decryption wouldn't know if the gibberish they got when decrypting was the same gibberish you put in.</p>
<ul>
<li>Attackers could leverage this random tolerance to forge data in the non-padded portions, then forging the padding in a way that compensated.</li>
</ul>
</li>
</ul>
<p><strong><a href="https://security.stackexchange.com/a/183330">Real-World problems motivated the tricks that are used to resist attacks.</a></strong>  You can read about them if you want...or just don't use <code>[raw]</code> and you'll get a sensible default.</p>
<pre><code>&gt;&gt; [public-a private-a]: rsa-generate-keypair/insecure 128
== make object! [
    padding: [pkcs1-v15]
    n: #{A9EE9282744CC0FC6765824EB2B87539}
    e: #{010001}
]

&gt;&gt; one: rsa-encrypt #{DECAFBAD} public-a  ; Note: shorter input than key
== #{13C14811A3B1CD95100BA4F3273F0962}

&gt;&gt; two: rsa-encrypt #{DECAFBAD} public-a
== #{3245179A18C6B488FD39CDE7B4F5E3EC}  ; different!

&gt;&gt; rsa-decrypt one private-a
== #{DECAFBAD}

&gt;&gt; rsa-decrypt two private-a
== #{DECAFBAD}
</code></pre>
<h2>That Encrypts Smaller Than The Key...But What About Bigger?</h2>
<p>A fundamental issue with RSA encryption/decryption is it is relatively S-L-O-W.  And if you want to futureproof a key to use with big file sizes, those keys would also be B-I-G!</p>
<p><strong>But you can use a smaller asymmetric key as a stepping stone to providing a symmetric key.</strong></p>
<p>It's easy!  Let's say someone has published their 4096-bit public key and you want to send them a 100 megabyte file that only they will know how to open.  Follow these steps:</p>
<ol>
<li>
<p>Generate a random string that's less than 4096 bits, and encrypt <em>that</em> with their public key</p>
</li>
<li>
<p>Encrypt the file using a faster symmetric algorithm, with that random string as the password</p>
</li>
<li>
<p>Send the recipient both the asymmetrically-encrypted random string and the symmetrically-encrypted 100mb file</p>
</li>
<li>
<p>Your recipient uses their private key to decrypt the one-off password you randomly generated, and decrypts the symmetrically encrypted file with it.</p>
</li>
</ol>
<h2>It's All New, So Help Design the Interface...</h2>
<p>The original motivation to research mbedTLS was so that <a class="mention" href="/u/gchiu">@gchiu</a> didn't have to call out to external utilities to generate RSA keys.</p>
<p>But the generation abilities weren't actually written until now.  And honestly, I'm not sure the RSA stuff was even working at all.  :-/  <strong><a href="https://github.com/metaeducation/ren-c/blob/master/extensions/crypt/tests/rsa.test.reb">Now there's at least a minimal amount of testing.</a></strong></p>
<p>I think the multiple return values are a good start on making it clear, but it's certainly a good time for feedback if anyone has any.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/asymmetric-encryption-decryption-in-ren-c/1812">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/asymmetric-encryption-decryption-in-ren-c/1812</link>
          <pubDate>Fri, 13 May 2022 01:17:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1812</guid>
          <source url="https://forum.rebol.info/t/asymmetric-encryption-decryption-in-ren-c/1812.rss">Asymmetric Encryption/Decryption in Ren-C</source>
        </item>
        <item>
          <title>Transitioning from mbedTLS 2 to mbedTLS 3: Promise and Peril</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Cryptography</category>
          <description><![CDATA[
            <p>Historically R3-Alpha had its few pieces of crypto math cobbled together from generally unknown sources on the Internet...</p>
<ul>
<li>
<p>My understanding is that Rebol2's support for talking to a limited set of HTTPS sites was written entirely in C.  It's never been open-sourced, so we don't know much about it--such as whether it was original code or done with some early TLS library of the time.</p>
</li>
<li>
<p>Saphirion chose to split out the code for the Transport-Layer-Security protocol and make it usermode Rebol.  Only the foundational cryptographic primitives like <a href="https://forum.rebol.info/t/checksums-and-secure-hashes-in-ren-c/1808">Secure Hashes</a> or <a href="https://forum.rebol.info/t/key-exchange-methods-in-ren-c/1809">Key Exchange</a> were written in C.</p>
<ul>
<li>
<p><strong>Many of R3-Alpha's C cryptography bits seemed to come from the (one-man?) effort known as <a href="http://axtls.sourceforge.net/">Axolotl TLS (AxTLS)</a></strong></p>
</li>
<li>
<p>The Rebol parts were written by Cyphre (Richard Smolak)</p>
</li>
</ul>
</li>
</ul>
<h2>I Was Initially Very Skeptical of Continuing Saphirion's Strategy...</h2>
<p>If a change ever rippled into affecting the TLS file, it was a voodoo nightmare to figure out how to fix it.  I didn't understand why limited efforts should be stretched into involvement with "something the language wasn't really good for".</p>
<p><em>My impression was also that the %prot-tls.r implementation was bad.</em>  But when I got to looking at the details, the most insidious problems weren't so much the fault of the protocol code.  It more-or-less followed the spec, in a pretty literate way (that I <a href="https://forum.rebol.info/t/dissecting-the-tls-emit-dialect/1498">improved with some dialecting</a>).</p>
<p>The main frustrations regarding prot-tls came from the fact that <a href="https://forum.rebol.info/t/the-weirdness-of-wait/1703">R3-Alpha's asynchronous port model made no sense</a>.  When I rewrote it to use the "seemingly-synchronous" model (which aims to parallel the Go language), it became more clear.</p>
<p><strong>Through the process of implementing TLS 1.2, I began to get the impression that such protocols may actually be a fitting domain for a language like Rebol.</strong></p>
<p>Today's %prot-tls.r is an aggressive and practical test of dialecting.  If it continues to be enhanced may be a case of exposing the workings of an important protocol to the layperson.</p>
<h2>We Needed More Cryptography, and mbedTLS Fit the Bill</h2>
<p>Adding TLS 1.2 wasn't going to do any good without also providing some of the newer exotic cipher suites that are demanded these days.  That meant getting things like elliptic curve key exchange, or SHA512, or anything else the future may demand.</p>
<p>When I found mbedTLS it was much "cleaner" than OpenSSL, and seemed perfect:</p>
<ul>
<li>
<p>It was targeting embedded processors, with <a href="https://github.com/Mbed-TLS/mbedtls/blob/42650260a9109f53d2058f82e1133205545fd65b/include/mbedtls/mbedtls_config.h">incredibly granular controls</a> for doing things like using smaller/slower algorithms vs. bigger/faster ones.</p>
<ul>
<li>
<p>Pure C code, that could be compiled even by TCC.</p>
</li>
<li>
<p>This meant the conference demo of bootstrap could still work, with a TCC-built R3-WITH-TCC having enough cryptography in it to download its own source from an HTTPS GitHub link.</p>
</li>
</ul>
</li>
<li>
<p>The cryptography primitives could be lifted out "a la carte" from the C-based TLS protocol code; the files seemed completely separate:</p>
<ul>
<li>
<p>If we wanted to, we could have a C-based mbedTLS extension option instead of using %prot-tls.r, and it could reuse the same cryptography.</p>
</li>
<li>
<p>(We may at some point have to resort to this, if keeping %prot-tls.r up to date with the times proves impractical.)</p>
</li>
</ul>
</li>
<li>
<p>The interfaces for every cipher and hash supported streaming, so we'd have the ability to incrementally do cryptography on large files or network connections (assuming we figured out how to expose that).</p>
</li>
</ul>
<p><strong>And critically, all of it was under the umbrella of a working group at ARM which would hopefully ensure that it was kept up to date, and being vetted for problems.</strong></p>
<p>All of it made this seem like a no-brainer to build on, which <a href="https://github.com/metaeducation/ren-c/commit/06e110235efb68500700fead3478a3216899d780">I did in April of 2020</a>:</p>
<blockquote>
<p>The mbedTLS library is an embedded-focused set of cryptography hashes,<br>
key exchanges, block ciphers, and other tools.  Its components range<br>
from lower-level facilities like BigNum arithmetic, to higher-level<br>
services like TLS negotiation and certificate validation.  Its<br>
facilities are well-factored such that each piece can be used with only<br>
its dependencies:</p>
<p><a href="https://tls.mbed.org/">https://tls.mbed.org/</a></p>
<p>Because of its fine-grained control, it's possible to use its basic<br>
tools while still keeping higher-level negotiations as spec-driven<br>
usermode Rebol (e.g. the TLS protocol itself) to facilitate more<br>
hooking and understanding.  And because it offers a consistent set of<br>
vetted and active code, it can replace the "hodgepodge" of cut-and-paste<br>
snippets for cryptography (originating from axTLS, internet sources,<br>
custom code, edited OpenSSL, etc.) where there are problems like not<br>
being written to a common BigNum implementation.</p>
<p>Additionally--due to the factoring, it is hoped that this code could be<br>
used as the basis for implementing BigNum arithmetic in the interpreter<br>
core itself...which would be naturally reused in the implementation<br>
of these C algorithms when cryptographic extensions are loaded.</p>
</blockquote>
<p>Possibly inspired by this--or just his own coming to the same conclusions--<a href="https://github.com/Oldes/Rebol3/commit/77515519655a579fbef99f7e185a27a4451718d7">Oldes changed his hashes to use mbedTLS in January 2021</a></p>
<h2>...and Then, Version 3.0 Came... <img src="https://forum.rebol.info/images/emoji/twitter/dragon.png?v=9" title=":dragon:" class="emoji" alt=":dragon:">
</h2>
<p><em>I probably should have been paying more attention to what mbedTLS was planning in their future branches.</em></p>
<p>What I've gathered is that ARM (or someone) was pointing out that mbedTLS not only needed to implement TLS 1.3, but that it wasn't sufficiently fast vs. the competition.</p>
<p>A somewhat-sensible approach to optimization is to first tighten the control over your data structures, making them more opaque to clients.  By limiting the APIs you can use to access those structures, you can know more about the states they are in...and take more for granted.  Your functions can then make optimizations which leverage these rules--adding or rearranging fields in more clever ways.</p>
<p><strong>But I didn't want cleverness, I just wanted the math.</strong>  I liked that our objects for things like Diffie-Hellman showed you the true cryptographic parameters, and wasn't some kind of "black box".  If we were closed off from that, everything would be a HANDLE! and you would have limited ways of extracting parameters from it.</p>
<p>Not only did they close off access to the structure members, many APIs they offered were TLS-specific!</p>
<ul>
<li>
<p>If a cryptographic primitive depended on parameters X and Y and produced Z, they'd offer a function that takes in a blob of data representing X and Y <em>in the specific format that TLS messages encode them</em>.</p>
</li>
<li>
<p>If you were building some protocol that <em>wasn't</em> TLS using that basic crypto primitive, the only way offered to load the parameters was to make a TLS-format message buffer and pass it.</p>
</li>
<li>
<p>The TLS-specific functions were creeping into what were supposed to be the "a la carte" cryptography files, adding bloat at compile time (if not also runtime) if you weren't using them.</p>
</li>
</ul>
<p>One can imagine that this seems good from the point of view of speeding up their C TLS protocol, but bad for anyone trying to use the underlying cryptography.</p>
<p>There was an announcement I missed that it would be split into two libraries: "mbed crypto" and "mbedTLS", to serve the two different audiences for the code.  But that seemed to be short-lived, and "mbed crypto" was reabsorbed into the mbedTLS codebase.  Not before the damage had been done to the layering and generality.</p>
<p>So now mbedTLS seems to be playing catch-up on serving the audience that wanted the crypto primitives.  But functionality that had an endorsed method to do in mbedTLS 2 now requires hacking beneath the approved API to accomplish.</p>
<h2>On the bright side...</h2>
<p>Since the re-absorption of "mbed crypto", mbedTLS seems amenable to having answers for the a-la-carte crypto crowd.  <a href="https://github.com/Mbed-TLS/mbedtls/issues/5818">A request I made is at least marked medium importance</a>.</p>
<p>Also, the API becoming more formalized is pointing out some weird mistakes that were made before in the code...filling structure parameters that were unused, for instance.  Having to call each of these things into question is a good vetting of the code.</p>
<p>And although I had to use hacks to do it, we now can run https on top of mbedTLS 3.  I've been a little on the fence of whether to stick with mbedTLS 2 (support ending in 2024) or find some other library.  But writing about cryptography has made me realize it's a bit of a red herring on the importance scale, and I think we're better off rolling with the punches of mbedTLS 3 than going it some other route.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/transitioning-from-mbedtls-2-to-mbedtls-3-promise-and-peril/1810">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/transitioning-from-mbedtls-2-to-mbedtls-3-promise-and-peril/1810</link>
          <pubDate>Tue, 10 May 2022 14:47:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1810</guid>
          <source url="https://forum.rebol.info/t/transitioning-from-mbedtls-2-to-mbedtls-3-promise-and-peril/1810.rss">Transitioning from mbedTLS 2 to mbedTLS 3: Promise and Peril</source>
        </item>
        <item>
          <title>Key Exchange Methods in Ren-C</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Cryptography</category>
          <description><![CDATA[
            <p>Having given a summary of <a href="https://forum.rebol.info/t/checksums-and-secure-hashes-in-ren-c/1808/">Checksums and Secure Hashes</a>, I thought I'd follow up with a quick description of something you're likely not as familiar with: <strong>Key Exchanges</strong>.</p>
<p>There's old quote I like (but can't find a source for):</p>
<blockquote>
<p>"The shared secret is capital.  We may spend it or squander it."</p>
</blockquote>
<p>An example of taking advantage of a shared secret is when people want to share an encrypted .ZIP file.  If you and your friend both know the encryption password that no one else knows...then you could put the file on a public server for your friend to download.  If you trust the encryption, the fact it was public would not matter.</p>
<p><strong>But what if the situation is that your friend has a password that only they know... and you have a password that only you know?</strong>  That wouldn't seem to help with the .ZIP file scenario, because it expects the same password to decrypt as was used to encrypt it.</p>
<p>Key Exchange is a way of taking your individual "passwords" and coming to an agreement on a third "password" that only the two of you know.  Amazingly enough, you can carry out the conversation where you establish the shared password in public.</p>
<h2>Creating one Shared Secret from two Non-Shared Secrets</h2>
<p>For educational purposes, people use paint-mixing as an analogy for key exchange.  It's really "multiplying big prime numbers" instead of mixing paint, but it's visual and easy to see.</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/184fa9035c24ffa1250e324b61acaa3915f7757e.png" data-download-href="https://forum.rebol.info/uploads/default/184fa9035c24ffa1250e324b61acaa3915f7757e" title="image"><img src="https://forum.rebol.info/uploads/default/optimized/1X/184fa9035c24ffa1250e324b61acaa3915f7757e_2_345x500.png" alt="image" data-base62-sha1="3t485Do7kYfAw6HMsMv5klePtsq" width="345" height="500" srcset="https://forum.rebol.info/uploads/default/optimized/1X/184fa9035c24ffa1250e324b61acaa3915f7757e_2_345x500.png, https://forum.rebol.info/uploads/default/original/1X/184fa9035c24ffa1250e324b61acaa3915f7757e.png 1.5x, https://forum.rebol.info/uploads/default/original/1X/184fa9035c24ffa1250e324b61acaa3915f7757e.png 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/184fa9035c24ffa1250e324b61acaa3915f7757e_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">image</span><span class="informations">480×695 28 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p>This assumes everyone in the world has some kind of weird "common paint".  This paint isn't white (because if you mixed it with something that would be too easy to guess at the precise shade you had mixed it with).  And it isn't black (because mixing might just get you something too dark to measure well).</p>
<p>But the key point to absorb is what the diagram says: <strong>we assume that mixture separation is expensive</strong>.  Once you've mixed the common paint with your secret color, it produces a new shade that no one else knows how to make exactly.</p>
<p>When you and your friend exchange your mixtures you cleverly go to your private lairs and each add your secret color to the other's mixture.  <strong>Now both of you have the same weird color, and this is a secret you share.</strong></p>
<h2>Ren-C Supports Diffie-Hellman Key Exchange</h2>
<p>I oversimplified this by saying you each start with a "password"...because that made it sound like you could just pick a phrase out of your head.  In reality, choosing your secret involves some tricky math...to make sure your secret paint color is a <em>good</em> secret paint color.  You don't pick these--you ask the computer to generate it.</p>
<p>To get the ball rolling, you need to specify what kind of "common paint" to use.  You make that by picking two suitable prime numbers, a modulus and a base.  Then you can ask for a unique random secret to be generated.</p>
<p>For the sake of education, I've made it possible to use <em>relatively bad</em> paint mixes with the /INSECURE refinement.  It won't allow numbers that are so broken the process won't work (for instance: non-primes, or primes that don't meet the basic requirements of the algorithm).  This lets you work with small enough numbers that you can see for yourself what's going on more easily.</p>
<p>So let's use a modulus of 9 and a base of 3:</p>
<pre><code>&gt;&gt; mine: dh-generate-keypair/insecure #{09} #{05}
== make object! [
    modulus: #{09}
    generator: #{05}
    private-key: #{07}
    public-key: #{05}
]

&gt;&gt; theirs: dh-generate-keypair/insecure #{09} #{05}
== make object! [
    modulus: #{09}
    generator: #{05}
    private-key: #{05}
    public-key: #{02}
]
</code></pre>
<p>So privately, my secret is 7... and their secret is 5.  But we want to come to an agreement on a new number while only sharing with the public my "mixture" of 5 and their mixture of 2.</p>
<pre><code>&gt;&gt; my-shared: dh-compute-secret mine theirs.public-key
== #{02}

&gt;&gt; their-shared: dh-compute-secret theirs mine.public-key
== #{02}
</code></pre>
<p>So here you see each of us could come to a common agreement of 2.  You can follow through the math on the <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">Wikipedia page</a> if you want...but it's enough to know that it works.</p>
<p>What makes for a good (big!) modulus and base to use?  You don't really need to come up with them yourself, although <a href="https://security.stackexchange.com/a/103924">there are algorithms for it</a>.  There are papers that publish some good choices--and we should probably provide a way to default to well-known ones, like maybe accept either an object or an ISSUE!</p>
<pre><code>&gt;&gt; dh-generate-keypair #RFC-3526
; ...or...
&gt;&gt; dh-generate-keypair make object [base: ..., modulus: ...]
</code></pre>
<p>But the main thing to know is that <strong>both sides have to agree on the "common paint" to use</strong>, in order to come to the same conclusion.  So <code>dh-compute-secret</code> won't work unless the same numbers were used here.</p>
<h2>We Also Support Elliptic Curve Key Exchange (ECHDE)</h2>
<p>Modern Internet Transport Security has moved on from traditional Diffie Hellman to trickier math.  But the premise is the same.</p>
<p>In the interface, we only support two "common paints" for this method: "secp256r1" and "curve25519".  There's no option for small answers here:</p>
<pre><code>&gt;&gt; mine: ecc-generate-keypair 'curve25519
== make object! [
    public-key: make object! [
        x: #{121413C34DC265025F24CBEBBA6065B9
             75F1BFA6E493D07A0F4776FAE03DC245}
        y: #{00000000000000000000000000000000
             00000000000000000000000000000000}
    ]
    private-key: #{610A8D99A72500B3A2E8A1FD714FA412
                   17F0A0EA5EDFC9CFBDAE0425E199DC70}
]

&gt;&gt; theirs: ecc-generate-keypair 'curve25519
== make object! [
    public-key: make object! [
        x: #{10D65366D8C9229591C99903D3B5EB0F
             57709AD27E37989E4782050D2B9B2B93}
        y: #{00000000000000000000000000000000
             00000000000000000000000000000000}
    ]
    private-key: #{7C3262BF6028B049EEDC6C37E37A8261
                   EA4DF31F16E4D534D92A7EF11D974618}
]
</code></pre>
<p>But it works the same way; you come to the same conclusion when combining your partner's public portion with your private portion:</p>
<pre><code>&gt;&gt; my-secret: (
    ecdh-shared-secret 'curve25519 mine.private-key theirs.public-key
)
== #{E27891074A60250580B8F2C7CB2448A9AA491C97161D7C8D381348D90E438025}

&gt;&gt; their-secret: (
    ecdh-shared-secret 'curve25519 mine.private-key theirs.public-key
)
== #{E27891074A60250580B8F2C7CB2448A9AA491C97161D7C8D381348D90E438025}

&gt;&gt; my-secret = their-secret
== #[true]
</code></pre>
<h2>Would Average Users Ever Need Key Exchange Functions?</h2>
<p>Right now, the main reason most people would care whether the language has these key exchanges is because without them you can't do TLS.  So no reading or writing over HTTPS.</p>
<p>You really only need key exchanges when protocols are trying to establish private channels of communication.  So notably, some cryptographic protocols (like Bitcoin) don't need key exchanges...because they're carrying out their work in public.</p>
<ul>
<li>
<p><strong>It would be neat if we could democratize the creation of cryptographic protocols</strong>.  I think giving people easier and more transparent access to these kinds of things could foster some grassroots innovation, where people would build <em>exactly the security they needed</em> into a program's design...no more and no less.</p>
<ul>
<li>This would stand in contrast to today's methods, where "security" is accomplished by standing on top of a mountain of protocols (using a literal zoo of cryptographic algorithms) to tunnel and log in somewhere that they are "safe"...and putting more data than they need to in that place.</li>
</ul>
</li>
<li>
<p><strong>But even "simple" cryptography is tricky to reason about, and people are lazy.</strong>  I myself am pretty guilty of doing things like falling back on my GitHub password and resetting my keys instead of doing a good job of filing them in safe places.</p>
<ul>
<li>Convincing people their programs should be "organic and locally sourced"... by tailor-making the protocols and asking their users to keep track of files, is going to be a hard sell to those who are happy to use OAuth and leave this all up to Google.</li>
</ul>
</li>
</ul>
<p>So pessimistically speaking, I don't know that we're going to be able to market easy-to-use key exchange to anyone as a killer feature.  It's a nice thought, and I certainly like having it available to tinker with.  But I'd be surprised if anyone reading this has an idea how to use it in something they're working on.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/key-exchange-methods-in-ren-c/1809">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/key-exchange-methods-in-ren-c/1809</link>
          <pubDate>Mon, 09 May 2022 18:20:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1809</guid>
          <source url="https://forum.rebol.info/t/key-exchange-methods-in-ren-c/1809.rss">Key Exchange Methods in Ren-C</source>
        </item>
        <item>
          <title>Checksums and Secure Hashes in Ren-C</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Cryptography</category>
          <description><![CDATA[
            <p>I thought I'd write up a quick post about algorithms that take in a bunch of bytes--like a BINARY!--and produce a (usually) shorter "fingerprint" of that data.</p>
<ul>
<li>
<p>It's not hard to make an <em>insecure</em> hash...like taking the first couple of letters of a string: <code>"DICKENS" =&gt; DI</code>.  That might be useful if you're trying to divide book authors into drawers of an old-fashioned library card catalog.</p>
</li>
<li>
<p>But it's easy to find another string that would make the same "DI" fingerprint, like "DIABOLICAL" or "DIR^/FORMAT C:"</p>
</li>
<li>
<p>If you were using a fingerprint to trust something was what it was supposed to be, the easiness of generating these "collisions" is a liability!! <img src="https://forum.rebol.info/images/emoji/twitter/skull_and_crossbones.png?v=9" title=":skull_and_crossbones:" class="emoji" alt=":skull_and_crossbones:"></p>
</li>
<li>
<p>Secure hashes do complicated "one-way functions" in math to make it <em>really hard</em> on today's computers to fabricate any binary sequence--even garbage--that will give you the same fingerprint as any other input.</p>
</li>
</ul>
<p>You've certainly seen web pages that redirect you off to download a file, but beforehand give you some bytes of what the file should securely hash to.  <sub>(And you've probably never checked to make sure they match.)</sub></p>
<h2>If the Fingerprint is Shorter than the data, <a href="https://en.wikipedia.org/wiki/Pigeonhole_principle">COLLISIONS EXIST!</a>
</h2>
<p>You obviously can't give every 500mb file in the universe a unique fingerprint that's 32-bits, 128-bits, 512-bits, 2048-bits etc.</p>
<p>So the concept behind a secure hash is just supposed to be you can't find a collision until we're all dead and no one cares.  Less grimly: we might pair a hash with an expiration date to say not to trust a hash after a very conservative guess at how long it would take for computers to advance enough to break it.</p>
<p>When this hope falls apart (e.g. if any researcher can show two inputs that generate the same fingerprint) it's generally considered that the "secure" part of that hash is broken...for the purposes of whatever time-bubble you're living in.</p>
<h2>We Have Four Secure Hashes in the Box Right Now...</h2>
<p>It shouldn't be surprising that longer fingerprints correlate with being harder to find collisions:</p>
<pre><code>&gt;&gt; checksum/method {DICKENS} 'md5
== #{3717A787E2F16310EA51DC0308E88803}  ; considered vulnerable

&gt;&gt; checksum/method {DICKENS} 'sha1
== #{DFE5DD61B2B19C319DBC4F44328CDF8D24366F88}  ; considered vulnerable

&gt;&gt; checksum/method {DICKENS} 'sha256
== #{52A095CF1F0319EF44FF9134AAD2EF5E2BFE1A48307DCB0AD0408F1CE393C950}

&gt;&gt; checksum/method {DICKENS} 'sha512
== #{
E8DBC26DE28FAA1BC2A6A3E1BC6DD22C1ECB3FD0D5FCBBFB69BC63C6AAC6A9CE
FB76294EFFB0522D4C90A5E5829233FC5BC5B811AE6684A6EA632ECB3FF88DA1
}

&gt;&gt; checksum/method {DICKENS} 'ripemd160         ; bitcoin uses this one
== #{ADC86945BE4CEF31F0CFCAF66775E1DA5160F877}  ; ...no one knows why
</code></pre>
<p>But longer isn't <em>intrinsically</em> better...there might be a weakness to exploit in the method used by a longer hash which isn't present in shorter ones.  However, a bunch of mathematicians look at this stuff and we would generally hope that we'd be getting what we pay for--more bytes meaning more security (unless they're from the NSA and trying to punk us).</p>
<h2>We Also Have Three <em>Insecure</em> Hashes...</h2>
<p>These are fine when you're doing something that is not supposed to be protecting against adversarial attacks.  They're smaller to store and much cheaper to calculate...but it's trivial to find other input data that would produces the same 32-bit result:</p>
<pre><code>&gt;&gt; checksum/method {DICKENS} 'crc32
== #{FB05F0BC}  ; used to very gzip files (among other places)

&gt;&gt; checksum/method {DICKENS} 'adler32
== #{0202D207}  ; used by zlib deflate and inflate
</code></pre>
<p>If you want a <em>really</em> cheapskate insecure checksum, we include the one that is in TCP packets on the internet:</p>
<pre><code>&gt;&gt; checksum/method {DICKENS} 'tcp
== #{CA32}
</code></pre>
<hr>
<blockquote>
<p><strong>Fun Corner</strong>: Let's find a collision!</p>
<pre><code>&gt;&gt; until [
    string: copy {}
    repeat (random 10) [append string make char! 64 + random 26]
    #{CA32} = checksum/method string 'tcp
]
== #[true]

&gt;&gt; print string
AOGTDDN

&gt;&gt; checksum/method {AOGTDDN} 'tcp
== #{CA32}
</code></pre>
<p>That wasn't so hard, but... if you can find collisions for any of the <em>secure</em> hashes above (even the relatively-weak MD5 or SHA1) <em>you will be famous!</em></p>
</blockquote>
<h2>We're Primed To Make <strong>STREAMING</strong> Secure (or Insecure) Hashes !</h2>
<p>R3-Alpha did not have fancy modern hashes like SHA256 or SHA512.  But also the code it used was copy-pasted out of a library that required you to have all the data at once.</p>
<p>Hence if you have a multi-gigabyte DVD .iso file that you want to checksum, you have to read that into a multi-gigabyte BINARY! to process it.</p>
<p>But since Ren-C is leveraging the cryptography of the <a href="https://github.com/Mbed-TLS/mbedtls">pure C library known as mbedTLS</a>, the foundations are there to stream in little blobs at a time...and it is generalized so we can just flip on or off any hashes we care about.  <a href="https://forum.rebol.info/t/what-is-a-port/617/5">If we only knew how to express streaming with PORT!s (or whatever)</a>.</p>
<p>And also, the CRC32 and ADLER32 algorithms we have "for free" by including Zlib are now set up in a way that the insecure hashes can be streamed too.</p>
<h2>
<img src="https://forum.rebol.info/images/emoji/twitter/globe_with_meridians.png?v=9" title=":globe_with_meridians:" class="emoji" alt=":globe_with_meridians:"> <em>"How Does This Tie Into The Web Repl Story"?</em> <img src="https://forum.rebol.info/images/emoji/twitter/globe_with_meridians.png?v=9" title=":globe_with_meridians:" class="emoji" alt=":globe_with_meridians:">
</h2>
<p>I really want to have a laser focus on whether investing effort into something is going to be something that pays off or not, and to me a part of that payoff question is "will people using the web build care".</p>
<p><strong>Right now the web build does not include the CHECKSUM function at all.</strong>  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>That is too bad, because I do believe that putting secure hashes into the hands of users at the Web Repl prompt (as well as other basic crypto parts) would be a great playground.</p>
<p>But it would be rather heavyweight to push secure hashing into the default .wasm being pulled down on every site if it didn't use it.  This is why I really want to get "Wasm extensions" working, that can be dynamically loaded.  There's something called "side modules" that I have meant to explore but haven't.</p>
<p>Anyway, I hope this summary gives a little insight into where this is at, and perhaps educational for those who don't have experience with the difference between secure/insecure hashing.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/checksums-and-secure-hashes-in-ren-c/1808">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/checksums-and-secure-hashes-in-ren-c/1808</link>
          <pubDate>Mon, 09 May 2022 04:04:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1808</guid>
          <source url="https://forum.rebol.info/t/checksums-and-secure-hashes-in-ren-c/1808.rss">Checksums and Secure Hashes in Ren-C</source>
        </item>
        <item>
          <title>Dropping RC4 Support from the Crypto Extension</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Cryptography</category>
          <description><![CDATA[
            <p>I pretty sure no one out there is using it, but the RC4 cipher has been deprecated for a pretty long time now.  Per Wikipedia:</p>
<blockquote>
<p>In <a href="https://en.wikipedia.org/wiki/Cryptography">cryptography</a>, <strong>RC4</strong> (Rivest Cipher 4 also known as <strong>ARC4</strong> or <strong>ARCFOUR</strong> meaning Alleged RC4, see below) is a <a href="https://en.wikipedia.org/wiki/Stream_cipher">stream cipher</a>. While it is remarkable for its simplicity and speed in software, multiple vulnerabilities have been discovered in RC4, rendering it insecure.</p>
</blockquote>
<p>The insecurity of RC4 led the IETF to <a href="https://tools.ietf.org/html/rfc7465">prohibit RC4 for TLS use in 2015</a></p>
<p>However, the original cryptography code (mostly from AxTLS) had an RC4 function, and it was in mbedTLS 2.  So I went ahead and kept it working.</p>
<p>It is now dropped from mbedTLS 3.  So in the scheme of things, time to let it go.</p>
<h2>Code Being Dropped</h2>
<p>The files arc4.h and arc4.c from mbedTLS are now gone, and this was the crypt module code for supporting it:</p>
<pre><code>static void cleanup_rc4_ctx(const REBVAL *v)
{
    struct mbedtls_arc4_context *ctx
        = VAL_HANDLE_POINTER(struct mbedtls_arc4_context, v);
    mbedtls_arc4_free(ctx);
    FREE(struct mbedtls_arc4_context, ctx);
}


//
//  export rc4-key: native [
//
//  "Encrypt/decrypt data (modifies) using RC4 algorithm."
//
//      return: [handle!]
//      key [binary!]
//  ]
//
REBNATIVE(rc4_key)
//
// !!! RC4 was originally included for use with TLS.  However, the insecurity
// of RC4 led the IETF to prohibit RC4 for TLS use in 2015:
//
// https://tools.ietf.org/html/rfc7465
//
// So it is not in use at the moment.  It isn't much code, but could probably
// be moved to its own extension so it could be selected to build in or not,
// which is how cryptography methods should probably be done.
{
    CRYPT_INCLUDE_PARAMS_OF_RC4_KEY;

    struct mbedtls_arc4_context *ctx = TRY_ALLOC(struct mbedtls_arc4_context);
    mbedtls_arc4_init(ctx);

    REBSIZ key_len;
    const REBYTE *key = VAL_BINARY_SIZE_AT(&amp;key_len, ARG(key));
    mbedtls_arc4_setup(ctx, key, key_len);

    return Init_Handle_Cdata_Managed(
        D_OUT,
        ctx,
        sizeof(struct mbedtls_arc4_context),
        &amp;cleanup_rc4_ctx
    );
}


//
//  export rc4-stream: native [
//
//  "Encrypt/decrypt data (modifies) using RC4 algorithm."
//
//      return: &lt;none&gt;
//      ctx "Stream cipher context"
//          [handle!]
//      data "Data to encrypt/decrypt (modified)"
//          [binary!]
//  ]
//
REBNATIVE(rc4_stream)
{
    CRYPT_INCLUDE_PARAMS_OF_RC4_STREAM;

    REBVAL *data = ARG(data);

    if (VAL_HANDLE_CLEANER(ARG(ctx)) != cleanup_rc4_ctx)
        rebJumps ("fail [{Not a RC4 Context:}", ARG(ctx), "]");

    struct mbedtls_arc4_context *ctx
        = VAL_HANDLE_POINTER(struct mbedtls_arc4_context, ARG(ctx));

    REBVAL *error = nullptr;

    REBSIZ length;
    REBYTE *output = VAL_BINARY_SIZE_AT_ENSURE_MUTABLE(&amp;length, data);
    const REBYTE *input = output;
    IF_NOT_0(cleanup, error, mbedtls_arc4_crypt(
        ctx,
        length,
        input,  // input "message"
        output  // output (same, since it modifies)
    ));

  cleanup:
     if (error)
        rebJumps ("fail", error);

    return rebNone();
}
</code></pre>
<p>...and here is the very basic test, also being removed...</p>
<pre><code>ctx: rc4-key as binary! "Deprecated Algorithm"
data: as binary! "But Implemented Anyway"
rc4-stream ctx data
data = #{0C4E2F3BD157EA7214C33F280BE4D9DF1DFB580563A6}</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/dropping-rc4-support-from-the-crypto-extension/1807">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dropping-rc4-support-from-the-crypto-extension/1807</link>
          <pubDate>Mon, 09 May 2022 01:32:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1807</guid>
          <source url="https://forum.rebol.info/t/dropping-rc4-support-from-the-crypto-extension/1807.rss">Dropping RC4 Support from the Crypto Extension</source>
        </item>
        <item>
          <title>REPL Querying</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Console</category>
          <description><![CDATA[
            <p>It might be worthwhile to take some inspiration from this:</p>
<aside class="onebox githubfolder">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/ellie/atuin" target="_blank" rel="noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/345;"><img src="https://opengraph.githubassets.com/dca1958aebeb424b5526f3fa3c903c51716ab4f22eb7cd64a50259c3d4288398/ellie/atuin" class="thumbnail" width="690" height="345"></div>

<h3><a href="https://github.com/ellie/atuin" target="_blank" rel="noopener">GitHub - ellie/atuin: 🐢 Magical shell history</a></h3>


  <p><span class="label1">🐢 Magical shell history. Contribute to ellie/atuin development by creating an account on GitHub.</span></p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>I'd like us to start using the <a href="https://github.com/hostilefork/replpad-js/blob/master/storage.md">persistence features</a> to remember previous sessions, and perhaps make it easier to <strong>curate past Repl interactions into scripts</strong>.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/repl-querying/1804">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/repl-querying/1804</link>
          <pubDate>Sat, 07 May 2022 19:11:19 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1804</guid>
          <source url="https://forum.rebol.info/t/repl-querying/1804.rss">REPL Querying</source>
        </item>
        <item>
          <title>Rebmu History Removed from File (is History: a good idea?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Rebmu</category>
          <description><![CDATA[
            <p>When I started Rebmu I followed along the pattern of having seen people put <strong><code>History:</code></strong> in the headers of files.  And as it got longer, I kind of questioned the value of it.</p>
<p>I'm not sure what the "best practices" for history is, but it's a lot of stuff to skip over when you're trying to get to the meat of a file.  It warrants its own discussion topic (which I guess can be discussed here, with the extracted history).</p>
<pre><code>History: [
    0.1.0 [10-Jan-2010 {Sketchy prototype written to cover only the
    Roman Numeral example I worked through when coming up with the
    idea.  So very incomplete, more a proof of concept.}]

    0.2.0 [22-Jun-2010 {Language more complete, includes examples.
    Ditched concept of mushing symbols like + and - into single
    character operators is removed due to realization that A+
    B+ C+ etc. are more valuable in the symbol space than one
    character for AD.}]

    0.3.0 [24-Jun-2010 {Made backwards compatible with Rebol 2.
    Note that things like CN for continue or PERCENTAGE! datatype
    were added in Rebol 3.  You can use these in your Rebmu programs
    but they will only work if using Rebmu with an r3 interpreter.
    Also did several name tweaks like instead of AA for AND~ it's
    now A~ along with other consistencies.}]

    0.5.0 [16-Feb-2014 {Version bump to indicate growing maturity
    of the language.  Abandon Rebol 2 support.  Rebmu files now
    have proper Rebol ecology headers.}]

    0.6.0 [6-Apr-2014 {Large cleanup creating incompatibility with
    most all previous Rebmu code solutions.  Examples have been updated
    in GitHub.  Major theme was removing the custom IF/UNLESS/EITHER
    implementation and some clearer names.}]

    0.7.0 [15-Sep-2015 {Project revisited to incorporate new ideas and
    decisions from the Ren/C effort.  Incorporates the rebol-proposals
    module to work with experimental language features instead of
    having its own "incubator" project.  "Mu library" features removed
    in favor of embracing the language default more closely.}]
]</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/rebmu-history-removed-from-file-is-history-a-good-idea/1798">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rebmu-history-removed-from-file-is-history-a-good-idea/1798</link>
          <pubDate>Mon, 07 Mar 2022 08:22:26 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1798</guid>
          <source url="https://forum.rebol.info/t/rebmu-history-removed-from-file-is-history-a-good-idea/1798.rss">Rebmu History Removed from File (is History: a good idea?)</source>
        </item>
        <item>
          <title>Symbols and Mushing in Rebmu</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Rebmu</category>
          <description><![CDATA[
            <p>There are symbols like &amp; and | which were applied somewhat haphazardly in the original Rebmu, as experiments.</p>
<p>For instance, <strong>&amp;</strong> was a shortcut for DOES.</p>
<pre><code>phi: does [print "hi"]
=&gt;
PHI &amp;[print "hi"]
</code></pre>
<p>(There've been murmurs of other uses for &amp;, but no hard decisions on it yet...and even if it were used for HTML characters like <strong>&amp;nbsp</strong>, it might remain free standalone as a symbol.)</p>
<p>For a time, <strong>|</strong> in Ren-C was not something you could redefine as a WORD!, it was its own datatype "BAR!".  But that has been replaced by the successful COMMA!, retaking it as a word.  It was used in function definition, and some of the contractions I've suggested as things like <strong><code>fqC[...]</code></strong> =&gt; <strong>function [a b c] [...]</strong> were contracted as simply <strong><code>c|[...]</code></strong></p>
<p>There was a handling of dots which allowed a quick way of doing redefinitions:</p>
<pre><code>     .[aBCdEF] =&gt; .[a bc d ef] =&gt; a: :bc d: :ef
</code></pre>
<p>There's still some back-and-forth on the handling of lone dot.  I like it being a reduced case of a TUPLE! in some sense...because it makes it easier to write generic fusing code for things like JOIN.  But putting into the new SYMBOL! class (which cannot appear in TUPLE! or PATH!) might have advantages, and helpers to count the dots might serve just as well.</p>
<p>I'm not sure what the in-language default function for plain dot will be, but it's likely that it will not be more powerful than either <strong>.a</strong> or <strong>a.</strong> enough to justify that <strong>a.a</strong> should be interpreted as <strong>a . a</strong>.</p>
<p>It's important to look at the specifics of mushing with symbols as they have no case, so the breakapart rules are different.  I've diagrammed some of these before.</p>
<pre><code>a+b =&gt; a+b  ; compatibility with all lowercase code
a+B =&gt; a+ b  ; favors breaking to the left, vs. a +b
</code></pre>
<p>I'll delve into these justifications, but since I'm deleting the old definitions of things like <strong>a&amp;</strong> and <strong>a|</strong> I wanted to put a placeholder topic for discussing it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/symbols-and-mushing-in-rebmu/1797">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/symbols-and-mushing-in-rebmu/1797</link>
          <pubDate>Mon, 07 Mar 2022 08:08:03 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1797</guid>
          <source url="https://forum.rebol.info/t/symbols-and-mushing-in-rebmu/1797.rss">Symbols and Mushing in Rebmu</source>
        </item>
        <item>
          <title>Rebmu&#39;s FUNQTION (FQ): Dialecting Function Definition Itself</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Rebmu</category>
          <description><![CDATA[
            <blockquote>
<p>After writing this I realized I had <a href="https://forum.rebol.info/t/function-mu-rebmus-function-generator-dialect/1379">already written a post about this in 2020</a>, but... here it is again, I guess!  Maybe I said it better or worse this time?</p>
</blockquote>
<p><em>(Note: FQ is pronounced EFF-QUEUE, say it carefully. <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:">)</em></p>
<p>So in Rebmu, <strong>FN</strong> is a superset of <strong>FUNC</strong> (itself a synonym for <strong>FUNCTION</strong>).</p>
<p>It doesn't do anything <em>terribly</em> tricky because its arguments are both evaluative.  So you can pass it specs and bodies that are variables.  Here's a useless example of taking advantage of that with a spec in a variable:</p>
<pre><code>; define a spec which takes two arguments
S[xY]   ; =&gt; s: [x y]

; define function A that adds X and Y.
AfnS[adXy]  ; =&gt; a: fn s [ad x y]
            ; =&gt; a: function s [add x y]

; define function M that multiplies X and Y
MfnS[mpXy]  ; =&gt; m: fn s [mp x y]
            ; =&gt; m: function s [multiply x y]
</code></pre>
<p><em>...but what might a Code-Golf-Dialected FUNQTION (FQ) Do, unbound by rote evaluation of its parameters?</em>  Let's use our imagination...</p>
<h2>A Quoted Spec could permit Spec Compression</h2>
<p>How about if you gave a WORD! that was a letter and a number, you'd get 3 args starting with that letter?</p>
<pre><code>fqR3[adMPrSt]
; =&gt; fq r3 [ad mp r s t]
; =&gt; fn [r s t] [ad mp r s t]
; =&gt; function [r s t] [add multiply r s t]
; =&gt; function [r s t] [add (multiply r s) t]
</code></pre>
<p>That's a three character savings vs. having to express the block for <strong>[r s t]</strong> explicitly with a plain function:</p>
<pre><code>fn[rSt][adMPrSt]
</code></pre>
<p>If you didn't include a number that might be a different memoization of what the arguments were, such as:</p>
<pre><code>fqA[...] =&gt; fn [a] [...]
fqB[...] =&gt; fn [a b] [...]
fqC[...] =&gt; fn [a b c] [...]

fqX[...] =&gt; fn [z y x] [...]
fqY[...] =&gt; fn [z y] [...]
fqZ[...] =&gt; fn [z] [...]
</code></pre>
<p>The idea being that you need to sort of spread out your variable names in code golf, for instance when working with nested functions.  From a tactical standpoint one might be served to throw in curveballs:</p>
<pre><code>fqM[...] =&gt; fn [m j z] [...]
</code></pre>
<p>Though that lessens the readability/learnability.  Anyway, what else...?</p>
<h2>Variadically Quoted Bodies Could Circumvent Brackets</h2>
<p>Let's say if it found a word in the slot where the body block would ordinarily be, it would treat that as a function that should be called.</p>
<p>To make it easier, let's just think about this un-Rebmu'd:</p>
<pre><code>foo: func [x y z] [any [x y z]]

bar: funq [x y z] any [x y z]
</code></pre>
<p>If FUNQ is variadic and quoting its body slot, it could notice the body does not contain a block but a WORD!.  Seeing that function is ANY, it could count the number of parameters ANY needs and pick them up from the callsite.</p>
<p><em>Such mechanics are within reach using today's FRAME!s</em>, in fact <a href="https://forum.rebol.info/t/looking-into-a-usermode-pointfree/1236">they are used by things like POINTFREE</a>...itself clearly useful in Rebmu.</p>
<h2>What Else Might FQ do?</h2>
<p>There's also things like GROUP!s, and <strong>fq(x)...</strong> could imply a completely different thing from <strong>fq[x]...</strong>, suggesting a mode switch in how the ensuing information is interpreted.</p>
<p>Or <strong>fqX(...)</strong> and <strong>fqX[...]</strong> could be completely different.  What about strings?  How might string interpolation fit into all of this?</p>
<pre><code>ZfqC{Implicit printing of $a and $b and $c?}
; =&gt; z: fn [a b c] [print interpolate {Implicit print of $a and $b and $c}]
</code></pre>
<p>Maybe the implicit printing is different, like FP, and FQ with a string simply interpolates it.</p>
<p><strong>Hopefully you get the drift.</strong>  I'm talking about making Rebmu a powerhouse showcase of what Ren-C is driving at.</p>
<p>How can quoting, variadics, frames, interpolation, and all of that be applied to dialecting the act of function definition itself?</p>
<h1><code>[insert your ideas here]</code></h1>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/rebmus-funqtion-fq-dialecting-function-definition-itself/1796">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rebmus-funqtion-fq-dialecting-function-definition-itself/1796</link>
          <pubDate>Mon, 07 Mar 2022 07:07:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1796</guid>
          <source url="https://forum.rebol.info/t/rebmus-funqtion-fq-dialecting-function-definition-itself/1796.rss">Rebmu&#39;s FUNQTION (FQ): Dialecting Function Definition Itself</source>
        </item>
        <item>
          <title>What was REBMU-WRAP (and why we no longer need it)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Rebmu</category>
          <description><![CDATA[
            <p>As I bring the Rebmu dialect up to date I'll try and talk about any teachable moments that it provides.</p>
<p>Let's look at one of the earliest weird functions, REBMU-WRAP:</p>
<pre><code>rebmu-wrap: function [refined [path!] args [block!]] [
    func args compose [
        (refined) (args)
    ]
]
</code></pre>
<p>It was designed to make it (slightly) easier to define something like <code>APO</code> as a synonym for <code>APPEND/ONLY</code>.</p>
<pre><code>APO: rebmu-wrap 'append/only [series value]
</code></pre>
<p>So that turns into effectively:</p>
<pre><code>APO: func [series value] [
    append/only series value
]
</code></pre>
<p><strong>Basically this was an incredibly weak way to save a few characters while making a partial specialization.</strong>  Some of its weaknesses:</p>
<ol>
<li>
<p>You still have to specify the number and names of arguments the specialization takes.</p>
</li>
<li>
<p>If you make a mistake at the time of definition (like mentioning an unavailable refinement) you don't get the error until the call.</p>
</li>
<li>
<p>The other refinements are missing from the wrapped function, e.g. you can't invoke <code>apo/part</code> or <code>apo/dup</code>.</p>
</li>
<li>
<p>You don't inherit anything about the original function's parameter conventions; e.g. if an argument were quoted you'd get the parameter name word you passed for it.</p>
</li>
<li>
<p>Performance-wise you generate a whole new function call...path evaluation...argument evaluation...</p>
</li>
<li>
<p>Your new function doesn't have any HELP... etc. etc.</p>
</li>
</ol>
<h2>How To Make This Better in Classical "Redbol"?</h2>
<p>Let's put yourself in the mind of someone thinking about how I was at that time, <em>who wanted to use the same strategy but merely address (1) and (2)</em>.  So to be able to write the slightly shorter hand:</p>
<pre><code>APO: rebmu-wrap 'append/only
APD: rebmu-wrap 'append/dup
APDP: rebmu-wrap 'append/dup/part
APPD: rebmu-wrap 'append/part/dup  ; ...etc.
</code></pre>
<p>This version of REBMU-WRAP would need to analyze the spec, presumably with WORDS-OF:</p>
<pre><code>r3-alpha&gt;&gt; words-of :append
== [series value /part length /only /dup count]
</code></pre>
<p>So you might try something like the following nightmare...<strong>which took me at least an hour to write and debug!</strong> (probably more like two, because of the glitch of trying to mutate the spec in place and needing to notice when the insertion position matches the position a refinement argument is being moved from):</p>
<pre><code>rebmu-wrap: func [refined [path!] /local spec body pos insert-pos item] [
    if not any-function? (action: get first refined) [
        do make error! "first element of path must refer to a function"
    ]
    spec: words-of :action
    body: reduce [refined]
    insert-pos: spec  ; find where refinement args should be inserted
    while [all [not tail? insert-pos not refinement? insert-pos/1]][
        append body insert-pos/1
        insert-pos: next insert-pos
    ]
    foreach refinement-name (next refined) [
        if not pos: find spec to-refinement refinement-name [
            do make error! "missing or duplicate refinement specified"
        ]
        take pos  ; drop refinement from spec
        while [all [not tail? pos not refinement? pos/1 pos != insert-pos]] [
             insert-pos: insert insert-pos item: take pos
             append body item
        ]
    ]
    func ?? spec ?? body
]
</code></pre>
<p>If you try this in R3-Alpha, yes it does indeed work for (1) and (2). I put in the probes so you can see the spec and body of the new function:</p>
<pre><code>r3-alpha&gt;&gt; apo: rebmu-wrap 'append/only
spec: [series value /part length /dup count]
body: [append/only series value]

r3-alpha&gt; apd: rebmu-wrap 'append/dup
spec: [series value count /part length /only]
body: [append/dup series value count]

r3-alpha&gt;&gt; apdp: rebmu-wrap 'append/dup/part
spec: [series value count length /only]
body: [append/dup/part series value count]

r3-alpha&gt;&gt; appd: rebmu-wrap 'append/part/dup
spec: [series value count length /only]
body: [append/part/dup series value count]
</code></pre>
<p>It gets a head-start on (3) by leaving the refinements that haven't been partially specialized on the spec, but they're ignored in the call.</p>
<h2>That's A Lot Of Work for Something That Still Sucks! <img src="https://forum.rebol.info/images/emoji/twitter/nauseated_face.png?v=9" title=":nauseated_face:" class="emoji" alt=":nauseated_face:">
</h2>
<p>When you think of everything it entails to get (3) and (4), you are going to either need to COMPOSE your invocation on each call -or- change methodology to use APPLY.  But even if you are aware of APPLY it doesn't make this a trivial exercise, and doesn't help with (5) or (6).</p>
<p><strong>...and this is why I never even tried to write such things (before)... instead trying to add core interpreter features for partial specialization.</strong></p>
<h2>The Happy New World of Partial Specialization <img src="https://forum.rebol.info/images/emoji/twitter/sun_with_face.png?v=9" title=":sun_with_face:" class="emoji" alt=":sun_with_face:">
</h2>
<p>In today's Ren-C, all you have to do is get a function as a path, and you have (1) (2) (3) (4) (5).</p>
<pre><code>ren-c&gt;&gt; ap: :append
 == #[action! {ap} [series value /part /dup /line /only]]

ren-c&gt;&gt; ap [a b c] [d e]
== [a b c d e]

ren-c&gt;&gt; apo: :append/only
== #[action! {apo} [series value /part /dup /line]]

ren-c&gt;&gt; apo [a b c] [d e]
== [a b c [d e]]

ren-c&gt;&gt; apo/dup [a b c] [d e] 2  ; e.g. demonstrating (3)
== [a b c [d e] [d e]]
</code></pre>
<p>The new function call is just as efficient as the original (you might think of it moreso since there's no path processing, e.g. <strong>apo</strong> is faster than invoking <strong>ap/only</strong>!)</p>
<p>You don't get the HELP inherited automatically (it has an associated cost), but there is a function that will do it if you want to... you say <strong>inherit-meta :apo :append</strong> and then <strong>help apo</strong> will have the help strings copied into its meta information.</p>
<p>So that's some assistance with (6), but do remember that it's not a perfect world when talking about how to automatically write meaningful adjusted help.  If any parameter descriptions refer to the argument you specialized out, it's no longer on the interface, so they may not make sense!</p>
<p><em>(Note: Now that refinements are their own arguments, you can't tell by parameter list alone if a refinement is a 0 or 1 arg case.  It's determined by the typeset: if the typeset is empty--no types accepted--it is a 0 arg refinement.  Something to ponder if this can be done better, but see all the other nice things...like caching the label of the function name for stack traces, etc.)</em></p>
<h2>So long, REBMU-WRAP...</h2>
<p>...but I wanted to write this up just to show a good example of how early experiences playing with Rebmu led me to question Rebol, and want to shore up its abilities.</p>
<blockquote>
<p>"Beware of the Turing tar-pit in which <strong>everything is possible but nothing of interest is easy</strong>."</p>
</blockquote>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/what-was-rebmu-wrap-and-why-we-no-longer-need-it/1795">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-was-rebmu-wrap-and-why-we-no-longer-need-it/1795</link>
          <pubDate>Mon, 07 Mar 2022 06:06:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1795</guid>
          <source url="https://forum.rebol.info/t/what-was-rebmu-wrap-and-why-we-no-longer-need-it/1795.rss">What was REBMU-WRAP (and why we no longer need it)</source>
        </item>
        <item>
          <title>(No) Alternative Local Notation in the Func Spec Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <h1>TL;DR:</h1>
<p>When using a spec in FUNCTION (remember <a href="https://forum.rebol.info/t/abbreviations-as-synonyms/1211">FUNC is a synonym now</a>):</p>
<ul>
<li>
<p><strong>if you want to specify locals you say <code>[... &lt;local&gt; x y z ...]</code></strong> (/LOCAL is a normal refinement like any other in Ren-C.</p>
</li>
<li>
<p><strong>there is no longer a datatype-based shortcut for locals as a way to save the trouble of finding <code>&lt;local&gt;</code> in specs and inserting at the right point</strong>.</p>
<ul>
<li>
<p>Once you could toss random SET-WORD!s anywhere in a spec, like <strong><code>[a b c: d]</code></strong> and it would act like <strong><code>[a b d &lt;local&gt; c]</code></strong>.  This feature was to make higher-level function generators easier to write, to save them from having to find <code>&lt;local&gt;</code> in the spec...add it if not there...and do everything at the right point.</p>
</li>
<li>
<p>When multi-returns began using SET-WORD! this was changed to be <strong><code>[a b .c d]</code></strong> just to move it out of the way.</p>
</li>
<li>
<p>What this was trying to achieve has been obsoleted by newer and better methods, which actually entwine with the idea that <em>you should never know what local variables a function you are composing on top of has</em>.</p>
</li>
</ul>
</li>
</ul>
<h1>More Explanation</h1>
<p>Long ago, when I was looking at some of the higher-level function generators (like FUNCT on top of FUNCTION) I was struck by how tricky it was to get the adaptations written correctly.</p>
<p>We can look at <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/mezz/base-funcs.r#L28">FUNCT from R3-Alpha</a> and see some of that complexity, even just to try and add some local variables.</p>
<p>It had to check to see if there was already a /LOCAL, and add it if not:</p>
<pre><code>; Copy the spec and add /local to the end if not found
unless find spec: copy/deep spec /local [append spec [
	/local ; In a block so the generated source gets the newlines
]]
</code></pre>
<p><em>Bear in mind that specifying /LOCAL twice would be a duplicate refinement error, and /LOCAL did not have to be at the end of a spec.</em>  Things were tricky, because there were "private refinements".  These refinements were an artifact of how help worked--they were not shown--but weren't actually private.</p>
<p>So you had to be careful, to insert things after local but not after the private refinements, or they'd be arguments to those refinements:</p>
<pre><code>; Collect all set-words in the body as words to be used as locals, and add
; them to the spec. Don't include the words already in the spec or object.
insert find/tail spec /local collect-words/deep/set/ignore body either with [
   ...
]
</code></pre>
<p><strong>I wanted to take better advantage of datatypes, so I adopted the TAG! <code>&lt;local&gt;</code> in the spec so that /LOCAL could be used like any other refinement... e.g. GET-TIME/LOCAL or GET-LANGUAGE/LOCAL.</strong>  This is an idea preserved to this day, and I think it's a better move (though LET has been developing as the more viable general option for making locals).</p>
<p>But another concept I had was to make SET-WORD! in the dialect be another way to put a local anywhere in the spec.  So if you were writing code munging function specs you could just throw local variables on:</p>
<pre><code>foo: func [a b c: d] [...]

&lt;= equivalent to =&gt;

foo: func [a b d &lt;local&gt; c] [...]
</code></pre>
<p>But the idea was that <code>&lt;local&gt;</code> itself was transformed into the SET-WORD!, so the only language you needed to understand was that of the SET-WORD!s:</p>
<pre><code>&gt;&gt; foo: func [a b d &lt;local&gt; c] [...]

&gt;&gt; spec-of :foo
== [a b d c:]
</code></pre>
<p>When multi-returns came about and took SET-WORD!s, this idea was bumped around to be done with TUPLE!s with leading blanks like <strong>.c</strong></p>
<h1><a href="https://www.youtube.com/watch?v=2q9MaEKHakY">... but Everything Changed <img src="https://forum.rebol.info/images/emoji/twitter/robot.png?v=9" title=":robot:" class="emoji" alt=":robot:"> ...</a></h1>
<p>I've been marching toward something more like <a href="https://forum.rebol.info/t/seeing-all-action-s-as-variadic-frame-makers/1002">"Seeing all ACTION!s as Variadic Frame Makers?"</a></p>
<p>Function composition tools operate on FRAME!s using tools like ADAPT, SPECIALIZE, AUGMENT, ENCLOSE, etc.  There is no API for getting at the locals <em>because when you build on top of a function you can't see them, they're not part of the interface...they are sealed inside.</em>   This is good because you can build on top of a function without worrying about the details of the parts from which it was composed.</p>
<p>The migration to where <a href="https://forum.rebol.info/t/pure-and-refined-simplifying-refinements-to-one-or-zero-args/1120">refinements are their own arguments</a> has been key in making function calls easier to model as an object.</p>
<p><strong>In this world we do not need a representation for locals in the spec to add them...because the entire concept of how FUNCT was written is gone.</strong>  If you want to add locals you use tools like AUGMENT and don't worry about it.</p>
<h1>There Are Still (many) Problems To Solve</h1>
<p>Consider that you can do something like ask for a FRAME! of something like APPEND, then enumerate the keys:</p>
<pre><code>&gt;&gt; f: make frame! :append

&gt;&gt; for-each key f [print mold key]
return
series
value
part
dup
line
only
</code></pre>
<p>There are a lot of questions to answer about the unique nature of the main function's RETURN.  Although other multi-returns have to be on the interface, should you be able to put a variable in that return?  Consider that you could use multi-return with append today:</p>
<pre><code>&gt;&gt; [var]: append "abc" "d"
== "abcd"

&gt;&gt; var
== "abcd"
</code></pre>
<p>So should you be able to preload the frame with <strong>f.return: 'var</strong> and get the same effect?  This is competitive with the notion that RETURN is a concept of a local variable to the action, that holds an action that returns specifically from that action... so the responsibilities are somewhat murky for this distinguished result.</p>
<p>But we can also see that if we only look at object keys, we don't know which things are refinements or which are not...if they are refinements we don't know if they are 0-arg or 1-arg form, we don't know what types they take... or are they <code>&lt;end&gt;</code>-able.  <strong>I believe getting at this information should be done by means other than analysis of some spec block you filter out for description strings/etc. so that is on the right track.</strong>  But it's still a long road.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/no-alternative-local-notation-in-the-func-spec-dialect/1793">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/no-alternative-local-notation-in-the-func-spec-dialect/1793</link>
          <pubDate>Sat, 05 Mar 2022 20:33:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1793</guid>
          <source url="https://forum.rebol.info/t/no-alternative-local-notation-in-the-func-spec-dialect/1793.rss">(No) Alternative Local Notation in the Func Spec Dialect</source>
        </item>
        <item>
          <title>Could Ren-C and Red Interoperate (and if so, *should* they?)</title>
          <dc:creator><![CDATA[Cplus]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>When this year can we expect to see full "message passing" inter-operability between Ren-C and Red?</p>
<p>The very basics - MOLD and SAVE are almost in place.</p>
<p>The "binary" equivalent with some form of compatible REBBIN is surely not that hard to agree between the two sets of developers.</p>
<p>Fuller, fluid, message passing - for example the seamless invoking of functions and continuations within a running instance of the other language would be an important demonstration of the REBOL cousins' languages abilities to do what they have stated is a desired characteristic of their respective dialects of REBOL.</p>
<p>This would also harness the strengths of both dialects - for each has been focused these last few years on different arenas. Together, they have the makings of a formidable whole.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/could-ren-c-and-red-interoperate-and-if-so-should-they/1787">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/could-ren-c-and-red-interoperate-and-if-so-should-they/1787</link>
          <pubDate>Fri, 04 Feb 2022 19:20:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1787</guid>
          <source url="https://forum.rebol.info/t/could-ren-c-and-red-interoperate-and-if-so-should-they/1787.rss">Could Ren-C and Red Interoperate (and if so, *should* they?)</source>
        </item>
        <item>
          <title>Old Parse Tutorial</title>
          <dc:creator><![CDATA[Brett]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <blockquote>
<p>This is an old tutorial which originally appeared on <a href="http://codeconscious.com">codeconscious.com</a>. It has been posted here in the expectation that <a href="http://codeconscious.com">codeconscious.com</a> will be decommissioned early 2022. Other old articles on REBOL can be found at <a href="https://web.archive.org/web/*/https://codeconscious.com/rebol/">REBOL by codeconscious.com on archive.org</a></p>
</blockquote>
<h1>Introduction</h1>
<blockquote>
<p>Note: This article is a revised version written for open sourced Rebol (Rebol 3), the original Rebol 2 version is here: <a href="https://codeconscious.com/rebol/parse-tutorial.html">Parse Tutorial for Rebol 2</a>.</p>
</blockquote>
<p>If you want to extract data from strings (like HTML, TXT, CSV, etc.) consider Parse.</p>
<p>If you want to just check some user data against a specific format consider using Parse.</p>
<p>If you want to validate some message written in your new dialect use Parse.</p>
<p>Parse is useful.</p>
<p>Parse is quick.</p>
<p>Parse operates on string, binary and block input.  Using Parse you can process these types of input in some way, overlaying the input with new meaning. That is you have a string or block and you are perhaps identifying fields of records, tokens of a language or even identifying sections of a message protocol.</p>
<p>This document is a very rough show by example description of Parse with a few warnings thrown in.</p>
<h1>Parse Dialect</h1>
<p>You give Parse a rule block containing instructions to follow written in the Parse dialect. These instructions allow you to utilise Parse to interpret custom external formats or protocols. These instructions can be as simple or as complex as you need. A simple example would be to check that some input against postal code format. A sophisticated example is Rebol's URL parser (help sys/*parse-url/rules).</p>
<p>The instructions are written using the Parse dialect and tell Parse how to read through your input. In actual fact, the instructions describe the patterns that the input should take. Parse attempts to match the input against your patterns. Parse will return a TRUE result if your instructions accurately describe the input. If your instructions fail to describe the input (or looking at it the other way, the input fails to follow your rules) Parse will return FALSE. You also have the ability to carry out normal Rebol operations as Parse traverses the input and your rules.</p>
<p>It is very important to realise that the keywords of the Parse dialect are interpreted by Parse in a specific way and should be considered as being different in meaning to Rebol words when used at the console.</p>
<h2>Let's start at the end</h2>
<pre><code>&gt;&gt; input-string: {}
&gt;&gt; parse input-string [end]
== true
</code></pre>
<p>Ah success! Here I am parsing an empty string. My rule says to Parse "check that we are at the end". The result is of course TRUE because the string was empty to begin with.</p>
<p>This is similar in normal Rebol script to:</p>
<pre><code>&gt;&gt; tail? input-string
== true
</code></pre>
<h2>Baby steps</h2>
<p>Next up, let's test that a string matches our expectations:</p>
<pre><code>&gt;&gt; input-string: "fox"
== "fox"
&gt;&gt; parse input-string ["fox" end]
== true
</code></pre>
<p>We successfully tested that the input started with "fox" and then finished. Ok, no big deal.</p>
<p>But reflect a moment. This is a sequence - first "fox" then END. As Parse traverses the input</p>
<p>and your rule block, it keeps track of a current position for both. So at the start, the current position in the input is at the head of the string. After the rule "fox" was matched the current position in the input string will be directly after the "x" of "fox".</p>
<p>In this example, this happens to be the tail of the string, so the very next match rule END will succeed.</p>
<p>We do not always have to supply an END in the rule block. You can omit it in the last example because Parse effectively slaps one on at the end anyway.</p>
<pre><code>&gt;&gt; parse input-string ["fox"]
== true
</code></pre>
<p>While you can do this for simple examples, remember you'll likely need to add it in</p>
<p>explicitly for more complex rules.</p>
<p>Ok, back to the example again. In an ordinary Rebol session the above example is similar to the following:</p>
<pre><code>&gt;&gt; input-string: find/match input-string "fox"
== ""
&gt;&gt; tail? input-string
== true
</code></pre>
<p>Note that the ordinary Rebol code examples through this article are provided to help learn Parse. There are enough important differences between the Parse examples and the ordinary code examples that you cannot alway treat them as exactly equivalent.</p>
<h2>Failures / challenges</h2>
<p>For contrast let's look at an unsuccessful match:</p>
<pre><code>&gt;&gt; input-string: "dog"
== "dog"
&gt;&gt; parse input-string ["fox"]
== false
</code></pre>
<p>The meaning of this is pretty obvious. Hang on though, what actually happens when Parse encounters a failure with one of the rules? Well it backtracks the input to the point it was at when the rule started. So in Rebol code what happens is actually more like this:</p>
<pre><code>input-string: "dog"
If position: Find/match input-string "fox" [input-string: position]
Tail? input-string
</code></pre>
<p>Keep this little idea in the back of your mind, it becomes more meaningful with more complex rules.</p>
<h2>Optional matching and Compound Rules</h2>
<p>What if we want to check for a number of common pet alternatives?</p>
<p>Let's accept a "dog" or a "cat" or indeed a "bird":</p>
<pre><code>&gt;&gt; input-string: "dog"
== "dog"
&gt;&gt; parse input-string ["dog" | "cat" | "bird"]
== true
</code></pre>
<p>In ordinary Rebol this is like coding:</p>
<pre><code>input-string: any [
    find/match input-string "dog"
    find/match input-string "cat"
    find/match input-string "bird"
]
tail? input-string
</code></pre>
<p>Now, Rebol can be pretty concise and the ANY function definitely helps in writing concise code, but you can see already that the Parse dialect is looking to be better suited to matching than ordinary scripting.</p>
<p>Reflecting on this a bit. We have here a more interesting rule, a compound rule. Our compound rule is composed of three subrules. Each of the three subrules here are very basic but subrules are allowed to be compound rules themselves. The basic rules perform the lowest level matching of the input, the compound rules check the overall structure/grammar of your data.</p>
<p>Back to options. What about something that may or may not exist at all? Using OPT we can indicate that a bird could be big or just leave it out:</p>
<pre><code>&gt;&gt;  input-string: "bigbird"
== "bigbird"
&gt;&gt;  parse input-string [opt "big" "bird"]
== true
&gt;&gt; input-string: "bird"
== "bird"
&gt;&gt; parse input-string [opt "big" "bird"]
== true
</code></pre>
<p>There are more Parse options such as NOT which give you greater flexibility in specifying your rules. We'll cover this later.</p>
<h2>Spaces and Split</h2>
<p>Parse treats spaces like any other character. Note that Rebol 3 acts differently here to Rebol 2 as whitespace is now parsed by default without needing the /ALL refinement</p>
<pre><code>&gt;&gt;  input-string: "black dog"
== "black dog"
&gt;&gt;  parse input-string ["black" " " "dog"]
== true
</code></pre>
<p>There are constants defined for common characters such as SPACE, NEWLINE and TAB which can be used instead.</p>
<pre><code>&gt;&gt;  parse input-string ["black" space "dog"]
== true
</code></pre>
<p>To make things easier we can use the SPLIT function to pre-process the input string. SPLIT breaks up the string based on a given delimeter or other rules.</p>
<pre><code>&gt;&gt; parse split "brown dog" " " ["brown" "dog"]
== true
</code></pre>
<p>If we look at the output of split we see the following.</p>
<pre><code>&gt;&gt; split "brown dog" " "
== [ "brown" "dog" ]
</code></pre>
<p>In this case split is returning a block of strings simplifying our work with Parse.</p>
<h1>Blocks, repetition and more</h1>
<p>Using Parse for strings is good, but using parse on native Rebol datatypes really shows its power.</p>
<p>Rebol has a rich set of datatypes which simplify parsing data, and code.</p>
<p>This mode is used when the value to be parsed is actually a block not a string. You use this mode when you have already loaded data into Rebol values. You write Parse instructions in a rule block using the parse dialect in a similar way to that described for parsing strings except when parsing blocks the semantics are different and you have a couple more keywords to use.</p>
<p>This is the mode of Parse that deserves the attention of anyone using Rebol. The reason is that you are free to store your data in a form understandable by yourself and others and yet is still computer readable.</p>
<h2>First steps parsing blocks</h2>
<p>As we move from strings to blocks we can start to use some of the Rebol datatypes to make our lives much easier.</p>
<pre><code>&gt;&gt; parse [1234.16] [number!]
== true
</code></pre>
<p>Processing dates and times are a good example. You can see how the datatypes support a wide range of input formats. It is worth noting for Americans that Rebol always assumes day/month/year order.</p>
<pre><code>&gt;&gt; parse [12/Dec/2012 2:30pm ] [date! time!]
== true
</code></pre>
<p>There are many more datatypes although that does not stop you from using strings for datatypes which do not map to Rebol types.</p>
<pre><code>&gt;&gt; parse [&lt;div&gt; "Hello" http://rebol.com $1.00 &lt;/div&gt; bob@test.com ] [ tag! "Hello" url! money! tag! email!]
== true
</code></pre>
<h2>Repetition - known range of occurrences</h2>
<p>Time for some more compound rules.</p>
<p>Here's how to check for exactly two dogs.</p>
<pre><code>&gt;&gt; parse "dogdog" [2 "dog"]
== true
</code></pre>
<p>I can specify between 1 and 4 Zs (inclusive) too:</p>
<pre><code>&gt;&gt;  parse "Zzzz" [1 4 "z"]
== true
</code></pre>
<p>Note that by default Parse is not case sensitive unless you want it to be by using the /CASE refinement:</p>
<pre><code>&gt;&gt; parse/case "ZZ" [2 "Z"]
== true
</code></pre>
<p>This is also very powerful for parsing blocks:</p>
<pre><code>&gt;&gt; parse [ http://rebolsource.net http://rebol.org http://rebol.com ] [ 3 url! ]
== true
</code></pre>
<h2>Repetition again <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"> - unknown number of occurrences</h2>
<p>What if we grab a net and go prawning? We may not know how many prawns are caught by the net when we catch them:</p>
<pre><code>&gt;&gt; loop random 100 [append input-string: "" "prawn"]
== "prawnprawnprawnprawn"
&gt;&gt; parse input-string [some "prawn"]
== true
</code></pre>
<p>Excellent, we have some prawns but we don't know how many.</p>
<p>The SOME keyword means "match one or more of the following". Again it is a compound rule because I could have as easily done this if it was "raining cats and dogs":</p>
<pre><code>&gt;&gt; input-string: "dogdogcatdogcat"
== "dogdogcatdogcat"
&gt;&gt; parse input-string [some [ "dog" | "cat"] ]
== true
</code></pre>
<p>If it fines up:</p>
<pre><code>&gt;&gt; input-string: {}
== ""
&gt;&gt; parse input-string [some [ "dog" | "cat"]  ]
== false
</code></pre>
<p>It returns false because SOME requires at least one instance to be matched. If however, we don't actually care whether we get some or not we can use ANY:</p>
<pre><code>&gt;&gt; input-string: {}
== ""
&gt;&gt; parse input-string [any [ "dog" | "cat" ] ]
== true
&gt;&gt; input-string: "dog"
== "dog"
&gt;&gt; parse input-string [any [ "dog" | "cat"] ]
== true
</code></pre>
<p>Here is another example of one of those Rebol words with a new meaning in the context of Parse. In ordinary Rebol ANY is a function that return the first non-false or non-none value in the block it is given. In Parse, by contrast, ANY is a keyword that introduces a compound rule that means, "match zero or more of the following".</p>
<p>Repetition works equally well for blocks:</p>
<pre><code>&gt;&gt; parse [Fibonacci 1 1 2 3 5 8 13] [some [number! | word!] ]
== true
</code></pre>
<h2>Moving right along...</h2>
<p>Sometimes we really couldn't care less what lies between things of interest.</p>
<p>This example does not "skip c" it reads "match a, skip a character, match c, tail?".</p>
<pre><code>&gt;&gt; parse {abc} ["a" skip "c" end]
== true
</code></pre>
<p>You want to skip 5 characters? Use repetition:</p>
<pre><code>&gt;&gt; parse {1234567890} ["123" 5 skip "90" end]
== true
</code></pre>
<p>Sometimes we don't know how much is in between but we do know what is the next interesting bit:</p>
<pre><code>&gt;&gt; input-string: {1234 fox}
== "1234 fox"
&gt;&gt; parse input-string [thru "fox" end]
== true
</code></pre>
<p>This is like the Rebol code of:</p>
<pre><code>&gt;&gt; input-string: find/tail input-string "fox"
== ""
&gt;&gt; tail? input-string
== true
</code></pre>
<p>We can stop where fox starts using TO:</p>
<pre><code>&gt;&gt;  input-string: "1234 fox"
== "1234 fox"
&gt;&gt;  parse input-string [to "fox" "fox" end]
== true
</code></pre>
<p>And the Rebol code that performs similarly:</p>
<pre><code>input-string: {1234 fox}
input-string: find input-string "fox"
input-string: find/match input-string "fox"
tail? input-string
</code></pre>
<p>We can skip to the end as well:</p>
<pre><code>&gt;&gt;  parse {123456} ["123" to end end]
== true
</code></pre>
<p>This says "match 123, move to the tail, test tail". Pretty obvious we would get a true result if you think of it in these terms.</p>
<p>While we're here how about a warning. The rule [to end] moves to the tail and reports</p>
<p>success every time.</p>
<h2>All these characters</h2>
<p>Charset. Stands for character set. It is a bitset which makes it fast for pattern matching operations.</p>
<p>Let's say you only want to check that your input contains the digits 0 to 9.</p>
<pre><code>&gt;&gt; digit: charset [#"0" - #"9"]
</code></pre>
<p>Now parse can use this directly as a pattern matching instruction. It will match one character (byte) only of those in the set 0 - 9.</p>
<pre><code>&gt;&gt; parse {1} [digit]
== true
</code></pre>
<p>Naturally enough you can use these in compound rules too:</p>
<p>An Australian postcode consists of 4 numeric digits so:</p>
<pre><code>&gt;&gt; parse {2069} [4 digit]
== true
</code></pre>
<p>Charsets (bitsets) are sets and you can apply the set operations union, intersection, exclude, etc</p>
<p>on them:</p>
<pre><code>letter: charset [#"a" - #"z" #"A" - #"Z"]
digit: charset [#"0" - #"9"]
letter-or-digit: union letter digit
valid-name: [letter any letter-or-digit]
&gt;&gt;  parse {1abc} valid-name
== false
&gt;&gt;  parse {rebol} valid-name
== true
&gt;&gt;  parse {xyz1234} valid-name
== true
</code></pre>
<p>Maybe you want everything but digits:</p>
<pre><code>&gt;&gt; parse {A} [not digit skip]
== true
</code></pre>
<p>Notice how we needed to SKIP forward as NOT simply inverses the following rule and does not advance the input.</p>
<p>This is different from the Rebol 2 approach of creating a COMPLEMENT of a charset. This may work in some situations, but will not always give you the desired result due to the use of UNICODE in Rebol 3.</p>
<h2>But I want some information from it!</h2>
<p>Up to this point I've concentrated on the various matching functionality of Parse. Of course though you want to extract information from your data. The keyword of note for this purpose is COPY. Also of use is the ability to execute Rebol code within the Parse rules (actions) and thereby set and maintain Rebol variables (eg. Counters) using that code.</p>
<p>Ok COPY.</p>
<p>Copy is really really simple really. It is a compound rule that takes two arguments a variable and a subrule. Whatever input the subrule matches gets copied into the variable. If the subrule doesn't match anything (fails) COPY returns the failure but leaves the variable unchanged.</p>
<p>Here the subrule is to match an "A" which obviously fails.</p>
<pre><code>&gt;&gt; parse {123} [copy some-text "A"]
== false
&gt;&gt; some-text
** Script error: some-text has no value
</code></pre>
<p>Here the subrule is a simple skip:</p>
<pre><code>&gt;&gt; parse {123} [copy some-text skip to end]
== true
&gt;&gt; some-text
== "1"
</code></pre>
<p>And here the subrule is to match nothing NONE which is always successful so copy copies that which was matched...an empty string:</p>
<pre><code>&gt;&gt; parse "123" [copy some-text none]
== false
&gt;&gt; some-text
== ""
</code></pre>
<p>Another way of getting data is by using SET:</p>
<pre><code>&gt;&gt; parse [ $100 ] [ set wallet money! ]
== true
&gt;&gt; wallet
== $100
</code></pre>
<h2>Bring on the code (actions)</h2>
<p>Ordinary Rebol code can be used inside the parse dialect via the use of "(" and ")" i.e. a Paren! series:</p>
<pre><code>&gt;&gt; parse {} [(print "some code just executed") end]
some code just executed
== true
</code></pre>
<p>Obviously this is very handy. Even nicer is that it runs according to its placement in the rule. Note though that even if the rule ultimately fails your code may have already run:</p>
<pre><code>&gt;&gt; parse {123} [
     "1" (print "found 1!")
     "2" (print "found 2!")
     "A" (print "found an A!")
    end
]
found 1!
found 2!
== false
</code></pre>
<p>So the upshot is you can maintain counters and take actions based on your Parse rules.</p>
<p>During development it can be useful to put print statements in these allowing you to see what is happening.</p>

<h1>Advanced section</h1>
<h2>Repeated Repetition</h2>
<p>Now that I've introduced repetition and compound rules, what happens if I create a compound rule made up of nested repetition rules? Hmm, tricky.</p>
<p>This next example put Parse into a spin - an infinite loop. The escape key will not work, but you can break out with Ctrl+c:</p>
<pre><code>&gt;&gt; input-string: {}
== {}
&gt;&gt; parse input-string [while [any "dog"] ]
</code></pre>

<p>To understand why this infinite loop happens you need to know when the ANY rule returns success and when it completes.</p>
<p>Here's the major answer: WHILE ALWAYS returns success.</p>
<p>WHILE will keep calling its subrule while that subrule returns success regardless of if the input position advances. WHILE gives up on receipt of bad news (failure) but it itself always returns success. Now if WHILE always receives a success because it's subrule in fact is another WHILE or ANY... Well I think that explains it.</p>
<p>Remember OPT. It always returns success just like WHILE. So putting an OPT inside an WHILE is bound to lead to trouble as well.</p>
<p>The point then is that your repetition compound rules must be carefully written because of the possibility of creating these infinite loops. It is not a bug in Rebol, it is consequence of having a flexible Parse dialect.</p>
<p>Sometimes these infinite loops start only after traversing lots of other complex rules and therefore can become hard to catch. I create these loops less often now since I started considering how I want Parse's input position to move. When writing your rules consider how the input is consumed by the rules.</p>
<p>That's part of the reason why I've been demonstrating the Rebol code similar to the various Parse examples.</p>
<p>Not all combinations of repetition rules create infinite loops:</p>
<pre><code>&gt;&gt;  input-string: {}
== ""
&gt;&gt;  parse input-string [while [some "dog"] ]
== true
</code></pre>
<p>This last example is ok because the SOME does not always return success - it must consume some input. If SOME does not have at least one success it</p>
<p>returns a failure result. So you can see that at some point, given that we can assume that the input is</p>
<p>finite, the overall rule must terminate.</p>
<p>Quoting Ladislav, "The dangerous rules are rules, that don't consume any input, yet they return success."</p>
<p>There is another way to escape when you don't want your rule to progress further - the BREAK keyword. BREAK terminates the rule when it is encountered.</p>
<p>This could be used to improve performance by stopping evaluation of unnecessary rules.</p>
<pre><code>&gt;&gt; parse [1 2 end 3 4 5 7 8 9] [some [integer! | 'end break]]
== false
</code></pre>
<p>This rule will exist as soon as it reaches the end keyword improving the performance.</p>
<h2>Debugging parse rules</h2>
<p>The ?? command is invaluable in debugging Parse rules.</p>
<pre><code>&gt;&gt; parse "dog" [ ?? "d" ?? [ "i" | "o" ] ?? "g" ?? ]
"d": "dog"
["i" | "o"]: "og"
"g": "g"
end!: ""
== true
</code></pre>
<p>It displays the next rule and the current position in the series being parsed.</p>
<h2>The current index and manipulating it</h2>
<p>Parse maintains a reference to the input. The reference is a series and so has a current index.</p>
<p>Some special Parse dialect syntax allows you to get and set this reference. You use a set-word and get-word syntax respectively.</p>
<p>In this example I set the word "mark" to the input series at the current index that Parse has, don't worry about the false - it is just saying we didn't get all the way through the input:</p>
<pre><code>&gt;&gt;  parse {123456} ["123" mark:]
== false
&gt;&gt; mark
== "456"
</code></pre>
<p>I can manipulate the current index that Parse uses too:</p>
<pre><code>&gt;&gt;  parse {1234567} ["123" mark: (mark: next next mark) :mark "67"]
== true
</code></pre>
<p>To explain. First "123" is matched, then the word mark is set to the reference.</p>
<p>Then the Rebol code between the parentheses is evaluated. This code manipulates the reference we hold by two characters. I return this modified reference to Parse using the get-word syntax. Parse seeing the get-word syntax knows that it must update it's reference to that given. Finally I match the "67".</p>
<h2>More Block examples ...</h2>

<p>An example that shows what can be achieved is Carl Sassenrath's stock transaction example which you can see below. Now what if "sell 300 shares at $89.08" came in via email?</p>
<p>If you study this example you will see that Carl, in a very small space, has created a small interpreter that parses, validates and performs computations. This is very powerful technology that is easily underestimated because it is so small and simple.</p>
<pre><code>rule: [
    set action ['buy | 'sell]
    set number integer!
    'shares 'at
    set price money!
    (either action = 'sell [
            print ["income" price * number]
            total: total + (price * number)
        ] [
            print ["cost" price * number]
            total: total - (price * number)
        ]
    )
]
total: 0
parse [sell 100 shares at $123.45] rule
print ["total:" total]
total: 0
parse [
    sell 300 shares at $89.08
    buy 100 shares at $120.45
    sell 400 shares at $270.89
] [some rule]
print ["total:" total]
</code></pre>
<p>Another powerful example of this is the VID dialect of Rebol/View 2. VID describes in a<br>
effective but simple way what should appear on screen. VID is actually a block using normal<br>
Rebol values such as words and strings. The LAYOUT function of Rebol/View 2 takes a VID<br>
block as an argument to construct the visual objects. Layout uses Parse to process the<br>
VID specification.</p>
<h1>Special situations</h1>
<h2>When you do NOT want to match a pattern</h2>

<p>NOT does not consume input, so you can use it one ore more times before matching something else:</p>
<pre><code>&gt;&gt; parse "bird" [not "big" "bird"]
== true
</code></pre>
<p>One situation where you might do this is when you have a sub rule that might "consume" something needed by an enclosing rule.</p>
<p>For my example, I'll Parse a block rather than text but the concept still applies.</p>
<p>I want to Parse the following block, and print out every word, but if I encounter a bar ("|") I'll print out the text "**********":</p>
<pre><code>my-block: [ the quick brown fox | jumped | over the lazy]
</code></pre>
<p>This next bit of code will not work. If you try it you will see that no "*" is printed, instead you will see the "|":</p>
<pre><code>single-word: [set item word! (print mold item)]
phrase: [some single-word]
parse my-block [ phrase some ['| (print "**********") phrase] ]
</code></pre>
<p>The thing to note is that the bar "|" is a word too. Therefore the bar is "consumed" by the rule called SINGLE-WORD.</p>
<p>So one way to solve this is to give SINGLE-WORD some indigestion (make it fail) when it encounters a bar.</p>
<p>You can force a rule to fail using the FAIL keyword but here we use AND and NOT to make the rule fail under a specific condition.</p>
<p>To make it clear what is happening here, I wrap SINGLE-WORD with a rule I call WORD-EXCEPT-BAR. The</p>
<p>purpose of this new rule is to fail if it finds the "|" word otherwise it goes ahead and runs SINGLE-WORD.</p>
<p>I've added comments to clarify how WORD-EXCEPT-BAR works:</p>
<pre><code>word-except-bar: [
    and not '| ; Without advancing the input position, is this not a bar?
    single-word ; Match single-word
]
</code></pre>
<p>The point to note here is that the rule AND NOT '| is a "guard" - it guards the next rule from consuming input under a specific condition.</p>
<p>I also need to modify PHRASE to call WORD-EXCEPT-BAR.</p>
<pre><code>phrase: [some word-except-bar]
</code></pre>
<p>Another way to describe the PHRASE rule, as it is now, is "a rule that matches a series of words which does not contain the word |."</p>
<p>To finish off I'll create a function to call parse with the correct rule and</p>
<p>wrap the whole lot in an object just to be tidy:</p>
<pre><code>word-parsing-object: context [
    single-word: [set item word! (print mold item)]
    word-except-bar: [and not '| single-word]
    phrase: [some word-except-bar]
    set 'parse-words func[ a-block [block!] ] [
        parse a-block [phrase some ['| (print "**********") phrase] ]
    ]
]
</code></pre>
<p>Here is a test run:</p>
<pre><code>&gt;&gt; parse-words [the quick brown fox | jumped | over the lazy]
the
quick
brown
fox
**********
jumped
**********
over
the
lazy
== true
</code></pre>
<p>In summary in this section I have demonstrated how one can match a specific pattern even when a more general pattern (that includes the specific pattern) gets to see the input first.</p>
<h2>Why didn't you just write...</h2>
<pre><code>parse-words: func [a-block [block!]] [
    parse a-block [
        some [
            '| (print "**********") |
            set item word! (print mold item)
        ]
    ]
]
</code></pre>
<p>That is the better way to solve the problem, but the point is to demonstrate the concept of preventing a subrule from consuming certain input and how to use AND as a guard. There are situations when you need these ideas.</p>
<h2>The BREAK keyword</h2>

<p>From RT's changes document:</p>
<pre><code>When the BREAK word is encountered within a rule block, the block is
immediately terminated regardless of the current input pointer.
Expressions that follow the BREAK within the same rule block will not
be evaluated.
</code></pre>
<p>BREAK is usually used with repetition. In this example the SOME rule is exited early:</p>
<pre><code>&gt;&gt; parse "X" [some [ (print "*Break*") break] "X"]
*Break*
== true
</code></pre>
<p>Here again the SOME rule is exited early just like the previous example. In this case the rule that SOME is processing is referred to by a word:</p>
<pre><code>&gt;&gt; rule-to-break: [(print "*Break*") break]
== [(print "*Break*") break]
&gt;&gt; parse "X" [some rule-to-break "X"]
*Break*
== true
</code></pre>
<h1>Related toolset</h1>
<p>I have written "Parse Analysis Toolset" to help learn and analyse the way Parse works. The Explain-parse function of the toolset should help with learning Parse. The script has related documentation. You can find the script and a linkg to the documentation at:</p>
<p><a href="http://www.rebol.org/cgi-bin/cgiwrap/rebol/view-script.r?script=parse-analysis.r">parse-analysis.r (at REBOL.org Script Library)</a></p>
<p>One more program I've made can return a parse tree of your input:</p>
<p><a href="http://www.rebol.org/cgi-bin/cgiwrap/rebol/documentation.r?script=load-parse-tree.r">load-parse-tree.r (at REBOL.org Script Library)</a></p>
<h1>Comments</h1>
<p>Parse is a key component Rebol. Rebol is promoted as a messaging<br>
language. Messages can come in many formats (syntaxes). Parse allows<br>
you to define the syntax of a message so that you can interpret the message and transform<br>
it to something else or act on it directly. That may sound complex, but it isn't really.</p>
<p>What are messages? Lots of things can be considered as messages. Basically if you can<br>
put it into a file and the format of the file has some rule to it, then I think you have<br>
a message. You don't have to put it in a file though to use Parse. Rebol's networking<br>
functions use Parse to interpret many of the internet protocols that Rebol provides<br>
access to.</p>
<p>With Rebol you can define a mini-language for a specific purpose - a dialect. Outside Rebol this would be called a domain-specific language or DSL.</p>
<p>Parse helps you to validate and process such dialects. You might want to design a dialect for creating web pages on your internet site. Or perhaps for controlling a special device you have attached to your computer.</p>
<h1>Acknowledgement</h1>
<p>Thank you to John Kenyon for his initiative, edits and effort as we updated this article from the original.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/old-parse-tutorial/1771">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/old-parse-tutorial/1771</link>
          <pubDate>Sun, 12 Dec 2021 00:08:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1771</guid>
          <source url="https://forum.rebol.info/t/old-parse-tutorial/1771.rss">Old Parse Tutorial</source>
        </item>
        <item>
          <title>Running URLs from the command line</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Console</category>
          <description><![CDATA[
            <p>I thought it would be neat to try out the new <a href="https://forum.rebol.info/t/do-or-import-of-github-gitlab-decorated-urls-on-desktop/1761">decorated URL redirection</a> in the console, by running a URL!.  So I tried:</p>
<blockquote>
<p><code>r3 https://github.com/metaeducation/rebol-odbc/blob/master/tests/odbc-test.reb rebol-firebird --firebird</code></p>
</blockquote>
<p>This didn't give me what I wanted:</p>
<pre><code>** Access Error: cannot open: %/https/github.com/metaeducation/rebol-odbc/blob/master/tests/odbc-test.reb
</code></pre>
<h2>It Thought That Was A Filename...</h2>
<p>And oddly enough, it could have been.</p>
<p>On Linux, you can make a directory called <strong><code>https:</code></strong>.  Double slashes are collapsed to assume you meant a single slash.  It could be interpreted as a path.</p>
<h2>We Should Default This To Treating It As A URL</h2>
<p>I think it's pretty obvious that should be running a script from a network location.  But if people want a file interpretation there should be a way to do that.  Should we let the % character disambiguate it?</p>
<pre><code>r3 %http://example.com/script.r
</code></pre>
<p>If so, how to deal with files that actually start with %?  %%?</p>
<p>Or maybe something like:</p>
<pre><code>r3 --file http://example.com/script.r
</code></pre>
<p>In any case, it's not entirely clear what program logic we should use here to interpret this.  Do we explicitly try to see if something can LOAD as a URL! and if not, assume it's a filename?  Do we look more narrowly for alphanumerics followed by a colon?  Special cases for http and https only, for now?</p>
<p>I'm hacking in the alphanumerics followed by colon.  But the edge case of a "weird" filename should be tended to someday.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/running-urls-from-the-command-line/1764">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/running-urls-from-the-command-line/1764</link>
          <pubDate>Wed, 01 Dec 2021 14:04:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1764</guid>
          <source url="https://forum.rebol.info/t/running-urls-from-the-command-line/1764.rss">Running URLs from the command line</source>
        </item>
        <item>
          <title>Dialecting URL!s...Should They Ever Be Strings?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>So I just tried to use a URL! in PARSE and found it was an error.  It's an error in R3-Alpha, too:</p>
<pre><code>r3-alpha&gt;&gt; parse http://example.com/foo [http://example.com "/foo"]
** Script error: PARSE - invalid rule or usage of rule: http://example.com
</code></pre>
<p>Red treats it as a string:</p>
<pre><code>red&gt;&gt; parse http://example.com/foo [http://example.com "/foo"]
== true
</code></pre>
<p><strong>But if you think about it, this is a pretty limited application of the datatype.</strong></p>
<ul>
<li>
<p>If your input is a string, you're saving two characters over putting it in braces or quotes, like <strong><code>["http://example.com" "/foo"]</code></strong></p>
<ul>
<li>Ren-C has generic quoting, so there's quoted URL!s with a single character as another option... <strong><code>['http://example.com "/foo"]</code></strong>
</li>
</ul>
</li>
<li>
<p>If what you're matching against is a URL it's only going to match the very beginning part.</p>
</li>
</ul>
<h2>Could It Fetch Rules From A Network?</h2>
<p>In some cases--like the COMPILE dialect--you can build a list of code and libraries to put together, along with user natives.  It's neat there to have URLs be interpreted as fetching from the network.</p>
<p>But that seems a bit strange for UPARSE.  You'd depend on caching <em>(you wouldn't want to do a network fetch each time you hit the URL! in the rule...?)</em>  In Ren-C you can kind of do this minus the caching, e.g.</p>
<pre><code>uparse data [... :(load http://example.com/rules/) ...]
</code></pre>
<h2>Could It Be Commentary?</h2>
<p>In the test dialect, I thought it might be nice to just be able to drop URLs in the middle of things without having to make them comments.  It doesn't save that much, but can look more clean:</p>
<pre><code>[
    #386
    http://en.wikipedia.org/wiki/Some_Related_Topic
    (1 + 1 = 2)
]
</code></pre>
<p>I've also sometimes wondered about this for function specifications.</p>
<pre><code>foo: func [
    http://example.com/this-explains-this-function
    return: [integer!]
    arg [integer!]
][
    ...
]
</code></pre>
<p>This doesn't seem a good fit for PARSE behavior, but I kind of want to mention the idea of different ways that URL! might be used.</p>
<h2>In UPARSE It's Customizable...Leave it Open?</h2>
<p>One possibility would be to say that URL! doesn't do anything by default, and you can make a URL! combinator that decides what it does do.</p>
<p>How useful would it be?  I don't know.</p>
<p><strong>I'm just questioning whether the knee-jerk response of treating URL! as a string (or matching a URL! value if block parsing) is obviously the way to go.</strong></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/dialecting-url-s-should-they-ever-be-strings/1763">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dialecting-url-s-should-they-ever-be-strings/1763</link>
          <pubDate>Mon, 29 Nov 2021 15:36:40 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1763</guid>
          <source url="https://forum.rebol.info/t/dialecting-url-s-should-they-ever-be-strings/1763.rss">Dialecting URL!s...Should They Ever Be Strings?</source>
        </item>
        <item>
          <title>How Would Stream PARSE Handle Positions?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Generically speaking: when dealing with a streaming data source, you often don't know how many bytes or characters you want to read in advance.  You're looking for some pattern in the input to delimit it.</p>
<p>(The simplest-yet-very-common example would be reading until a newline.)</p>
<p>Go has dedicated operations for reading up-until one certain byte (<a href="https://pkg.go.dev/bufio#Reader.ReadBytes">ReadBytes(byte)</a>) or one certain UTF-8 character byte sequence (<a href="https://pkg.go.dev/bufio#Reader.ReadString">ReadString(codepoint)</a>).  These are methods of the buffered IO abstraction, because if you didn't go through a buffering middleman you'd have to call a lower-level <code>Read()</code> just one byte at a time.  Otherwise the lack of a buffer would mean you wouldn't have anywhere to hold the queued-up extra data after a newline...if a Read() came back with a bigger chunk.</p>
<p>Rigging up anything more detailed in Go is harder.  <strong>So this is where I thought a streaming PARSE would offer an interesting answer for a lot of scenarios.</strong>  Getting PARSE worked out correctly would save people the trouble of having to drive the progressive Read process themselves, just to get a more nuanced condition than "until a certain byte is seen".</p>
<h2>But Streams Aren't Series...So How Would You Call PARSE?</h2>
<p>When you parse a <em>series</em>, you don't "consume" it:</p>
<pre><code>&gt;&gt; data: "aaa"

&gt;&gt; uparse data [some "a" (&lt;Yay, some A!&gt;)]
== &lt;Yay, some A!&gt;

&gt;&gt; data
== "aaa"  ; hasn't changed
</code></pre>
<p>And you can do partial processing and get a position via <code>&lt;here&gt;</code>:</p>
<pre><code>&gt;&gt; data: "aaabbb"

&gt;&gt; uparse data [some "a" &lt;here&gt;]
== "bbb"  ; this is a "position" that points into `data`

&gt;&gt; data
== "aaabbb"  ; again, the unchanged input
</code></pre>
<p><strong>However, streams don't have any position <em>but</em> "here".</strong>  So how would <code>&lt;here&gt;</code> be any different from <code>&lt;input&gt;</code>?</p>
<h2>Some Streams May Internally Know A Position, But Not All</h2>
<p>In Go we saw an example of how streaming is an interface that something can offer, while having other methods depending on the data source.  Those other methods can offer features like timeouts.  Or something like a file could offer the ability to re-seek so the next call reading from the stream would get from a random access position.</p>
<p><em>But that's all outside of the streaming interface.</em>  The stream itself is a black box.  And the position is "inside"...all references to the same stream interface will be updated if you read from any reference.</p>
<p>With Rebol series, the position is "outside"...each instance has its own index.  So when you NEXT a series, you have to save the result, or you will get the same thing again:</p>
<pre><code>&gt;&gt; series: [a b c]

&gt;&gt; next series
== [b c]

&gt;&gt; next series
== [b c]
</code></pre>
<p>If streams worked this way, you'd have to constantly be saving the new stream value every time you read from it, as another return value of the READ process.</p>
<pre><code>[data stream]: read/part stream 10
</code></pre>
<p>But if you did have to code like that, how would it react to a situation like this?</p>
<pre><code>&gt;&gt; [data newstream]: read/part oldstream 10

&gt;&gt; read/part oldstream 10
</code></pre>
<p>The (presumably) buffered stream no longer has the data on hand.  So it either preserves the data indefinitely or some of these calls would fail.</p>
<h2>So Parsing Consumes Streams, But Not Series?</h2>
<p>Right now, there's no way to leave a stream alone, because reading it consumes it.</p>
<p>The only way you'd be able to "consume" a series value--e.g. advance the index of the input--would be to pass into parse a variable holding the input.  Because the index of the series is an immediate in the value itself.</p>
<p>It seems unfortunate that something like a FILE! can know how to do random seeks, and not be able to save and restore positions in PARSE.  But if it did, what would the type of <code>&lt;here&gt;</code> be?  It would have to create a new stream instance into the same file...this would be like being able to say:</p>
<pre><code>&gt;&gt; s2: clone stream  ; maybe file reads support, but tcp reads don't?

&gt;&gt; read stream
== #{ABCD0102}

&gt;&gt; read s2
== #{ABCD0102}
</code></pre>
<p>It's probably bad for PARSE to be going this direction.</p>
<h2>A Better Idea (?) <em>some</em> Streams Offer <code>&lt;index&gt;</code>, Some Don't</h2>
<p>It's already the case that SEEK will accept either an index number or a series position.  So when you ask for <code>&lt;index&gt;</code> it could tell you the position in the file.</p>
<p><em>(Although I should mention that file seeking has historically always been offset-based, starting with zero.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:">  This was true in R3-Alpha and is also true in 1-based languages like Julia.)</em></p>
<p>This just rules out the idea of having <code>&lt;here&gt;</code> on a stream series altogether; to basically stamp out the concept that there is such a thing as a "stream-at-position".  You only deal with positions separate from streams...and only on the streams that happen to offer them.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/how-would-stream-parse-handle-positions/1740">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-would-stream-parse-handle-positions/1740</link>
          <pubDate>Wed, 06 Oct 2021 16:40:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1740</guid>
          <source url="https://forum.rebol.info/t/how-would-stream-parse-handle-positions/1740.rss">How Would Stream PARSE Handle Positions?</source>
        </item>
        <item>
          <title>Validating Subseries Data In PARSE... INPUT or INTO TAG!s?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>If you want to validate a block of input and return that block, how do you do it?</p>
<p>By default, UPARSE gives you the last rule match:</p>
<pre><code>&gt;&gt; uparse [1 2 &lt;three&gt; "four"] [some integer! tag! text!] 
== "four"
</code></pre>
<p>You can bend that last-result behavior to your advantage by invoking a rule that returns the input.  The tag! combinator <strong><code>&lt;input&gt;</code></strong> does exactly that!</p>
<pre><code>&gt;&gt; uparse [1 2 &lt;three&gt; "four"] [some integer! tag! text! &lt;input&gt;] 
== [1 2 &lt;three&gt; "four"]
</code></pre>
<p>Pretty slick.  But what if it's a <em>nested</em> block?  Does <code>&lt;input&gt;</code> give you the INTO series, or the original series?</p>
<p>Right now it gives you the INTO series.  e.g. what <code>&lt;input&gt;</code> returns is whatever the <em>currently parsed input</em> is:</p>
<pre><code>&gt;&gt; uparse [zero [1 2 &lt;three&gt; "four"]] [
      word: word!
      validated: into block! [some integer! tag! text! &lt;input&gt;]
      ("some overall result")
 ]
== "some overall result"

&gt;&gt; validated
== [1 2 &lt;three&gt; "four"]

&gt;&gt; word
== zero
</code></pre>
<p>That's nice, but... you can also imagine being inside some nested rule like this where you want to make a decision like <strong><code>return &lt;input&gt;</code></strong> which wants to imply accepting the original input to the parse.</p>
<p>Should <strong><code>&lt;input&gt;</code></strong> always return the overall parser input, and a separate rule like <strong><code>&lt;into&gt;</code></strong> give back the current sub-input?</p>
<ul>
<li>
<p>At a combinator level, the currently processed argument is always called INPUT.  So calling it <code>&lt;input&gt;</code> and returning the currently applicable input is consistent with the implementation.</p>
<ul>
<li>
<p>Well...it's actually only partially consistent.  Because the INPUT to each combinator actually is at the current position.  So it's more like HERE.</p>
<ul>
<li>I'm actually not that bothered by this</li>
</ul>
</li>
</ul>
</li>
<li>
<p>INTO is not the only combinator that we can conceive of can that can go to a nested level.  So calling the tag <code>&lt;into&gt;</code> might not be a good idea.  Also, that doesn't have the ring of generality to return the input at wherever you currently are...e.g. return the main input if you haven't done an INTO</p>
<ul>
<li>Shades of meaning are difficult here with other words, as <code>&lt;current&gt;</code> (for instance) is hard to distinguish from <code>&lt;here&gt;</code>... e.g. you'd think it would include the position.</li>
</ul>
</li>
</ul>
<p><strong>In any case...I lean toward thinking <code>&lt;input&gt;</code> reflecting the <em>current</em> input is the best answer.</strong>  I think this suggests a special term for the main input, like <code>&lt;main-input&gt;</code>.  A better choice for this would maybe be <code>&lt;original&gt;</code>.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/validating-subseries-data-in-parse-input-or-into-tag-s/1737">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/validating-subseries-data-in-parse-input-or-into-tag-s/1737</link>
          <pubDate>Mon, 04 Oct 2021 15:11:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1737</guid>
          <source url="https://forum.rebol.info/t/validating-subseries-data-in-parse-input-or-into-tag-s/1737.rss">Validating Subseries Data In PARSE... INPUT or INTO TAG!s?</source>
        </item>
        <item>
          <title>PATH! usage for Function Dispatch Only Unless in Redbol Mode</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>For a while now I've been a pretty big convert on the look of dots for member selection.  It's not just that it's more standard--I think it's visually better.  It also lets you be reassured that when you see a slash in a path, that the thing to the left of that slash was a function:</p>
<pre><code>foo.bar.baz
   ;
   ; ^-- I may not know what foo.bar.baz is, but at least I know that
   ; foo and foo.bar are *not* functions

foo.bar.baz/mumble
   ;
   ; ^-- Under the convention that slashes are for refinements only, I
   ; can tell the author intends that (foo.bar.baz) must be a function

foo.baz.bar/
   ;
   ; ^-- With Ren-C's path generality, you can even decorate a case
   ; without refinements to show it's a function.
</code></pre>
<h2>It Hasn't Been A <em>Rule</em>, but...</h2>
<p>So far Ren-C has been allowing you to use slashes wherever you historically could.  So the new rules were only applying to dots--restricting them on not being usable on functions.</p>
<pre><code>append.dup [a b c] [d] 2  ; this would cause an error, for instance
</code></pre>
<p>However, you could still pick members out of objects with slashes:</p>
<pre><code>&gt;&gt; obj: make object! [field: 10]

&gt;&gt; obj/field   ; not obj.field
== 10
</code></pre>
<p>I had a feeling this might be prohibited eventually...though it would need to be possible to make Redbol emulation work.  So there'd have to be some kind of flag for allowing it.</p>
<h2>...But Now, I Might Have A Good Reason To Enforce It</h2>
<p>The reason is that in trying to do a good job of building an extensibility mechanism for member selection, it is difficult to make that mechanism able to communicate information about specialized functions in a "light" way.</p>
<p>When pathing is done hardcoded in the evaluator, it can do little sneaky tricks to push the words of refinements onto a stack.  It doesn't have to create an entirely new specialized function.</p>
<p>But once you're using a generic interface to usermode functions which can extend <strong><code>PICK*</code></strong> and <strong><code>POKE*</code></strong>, that interface has to speak in "reified" forms.  We have partial specialization so these refied forms exist... I just feel like what's happening in that case isn't "picking" or "poking".  And it's tying my hands to make anything efficient if we say that path dispatch runs through code which might be usermode.</p>
<h2>The Flag Will Be Introduced Gradually</h2>
<p>I've been experimenting with the flag turning itself on automatically, and giving you a warning.  So you only hear about it the first time.</p>
<pre><code>&gt;&gt; obj: make object! [x: 10]

&gt;&gt; obj/x
The PATH! obj/x doesn't evaluate to an ACTION! in the first slot.
SYSTEM.OPTIONS.REDBOL-PATHS is FALSE so this is not allowed by default.
For now, we'll enable it automatically...but it will slow down the system!
Please use TUPLE! instead, like obj.x
== 10

&gt;&gt; obj/x
== 10
</code></pre>
<p>What happens when you enable the flag is that it actually turns any PATH! with no ACTION! in the first slot into a TUPLE!, and then permits you to use refinements in TUPLE!s like <code>append.dup</code>.  This is because I'm avoiding creating a separate extensibility mechanism for paths...it just does the not-easy-to-optimize extensibility.</p>
<p>I haven't committed this, and I'd be phasing it in slowly.  But as it's phased in, the performance of paths for member selections vs. tuples will degrade.  So it's worth knowing about.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/path-usage-for-function-dispatch-only-unless-in-redbol-mode/1723">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/path-usage-for-function-dispatch-only-unless-in-redbol-mode/1723</link>
          <pubDate>Wed, 22 Sep 2021 18:11:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1723</guid>
          <source url="https://forum.rebol.info/t/path-usage-for-function-dispatch-only-unless-in-redbol-mode/1723.rss">PATH! usage for Function Dispatch Only Unless in Redbol Mode</source>
        </item>
        <item>
          <title>Implicit Capture In PARSE - How To Get It?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>ISO-8601 dates are very close to Rebol dates, but just different enough to make it a pain.</p>
<pre><code>; ISO-8601
2021-09-15T12:20:53-04:00

; Rebol
15-Sep-2021/12:20:53-04:00
</code></pre>
<p>Are Rebol dates more readable?  Yes.  Are they so much better as to make it worthwhile to buck the standard?  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=9" title=":man_shrugging:" class="emoji" alt=":man_shrugging:">  Are they in conflict with generalized PATH! representation?  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=9" title=":man_shrugging:" class="emoji" alt=":man_shrugging:"></p>
<h2>Nevermind, This Post Is About Something Else</h2>
<p>Let's say I just want to capture the YEAR, the MONTH, and the DAY out of an ISO-8601 date.</p>
<pre><code>uparse isodate [
    year: between &lt;here&gt; "-"
    month: between &lt;here&gt; "-"
    day: between &lt;here&gt; "T"
    ...
 ]
</code></pre>
<p>Despite having BETWEEN, it's laborious.  <em>(Historical Rebol needs <code>copy to "-"</code> followed by a SKIP, even more convoluted).</em></p>
<p>It needs a shorthand.  We have TAG! at our disposal, still:</p>
<pre><code>uparse isodate [year: &lt;*&gt; "-" month: &lt;*&gt; "-" day: &lt;*&gt; "T" ...]
</code></pre>
<p>And it could be plain <strong><code>*</code></strong>:</p>
<pre><code>uparse isodate [year: *, "-", month: *, "-", day: *, "T", ...]
</code></pre>
<p>But I kind of find myself wishing for another lexical type that means "capture".  I'd thought about this as being the meaning of <code>@xxx</code> before the current interpretation.</p>
<p>I'm nearly certain we'll have <strong>$word</strong>, <strong>$[bl o ck]</strong>, <strong>$(gr o up)</strong> and friends.  Maybe that?</p>
<pre><code>uparse isodate [$year "-" $month "-" $day "T" ...]
</code></pre>
<p>Though since the general meaning would be "get-environment-variable" this would raise questions about dialects bending the meaning of things so severely.</p>
<h2>It Feels Weak To Not Have An Answer For This</h2>
<p>Other parsing systems will always seem like they have an edge if there isn't a shorthand for this "capture until the next rule".</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/implicit-capture-in-parse-how-to-get-it/1718">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/implicit-capture-in-parse-how-to-get-it/1718</link>
          <pubDate>Wed, 15 Sep 2021 16:40:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1718</guid>
          <source url="https://forum.rebol.info/t/implicit-capture-in-parse-how-to-get-it/1718.rss">Implicit Capture In PARSE - How To Get It?</source>
        </item>
  </channel>
</rss>

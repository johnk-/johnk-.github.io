<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Domains - AltRebol</title>
    <link>https://forum.rebol.info/c/domains/15</link>
    <description>Topics in the &#39;Domains&#39; category Applications of Rebol in various specialized subject domains.</description>
    
      <lastBuildDate>Tue, 20 Sep 2022 02:03:00 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/domains/15.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Series Switching in PARSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p><strong>Rebol2 Prohibited Series Switching During a PARSE</strong></p>
<pre><code>&gt;&gt; series1: [a a a]
== [a a a]

&gt;&gt; series2: [b b b]
== [b b b]

&gt;&gt; parse series1 ['a :series2 some 'b]
** Script Error: Invalid argument: b b b
</code></pre>
<p>The error wasn't particularly informative.  But it was trying to tell you that you couldn't do that.</p>
<p><strong>Red Chose to Follow Suit, and Prohibits Series Switching During a PARSE</strong></p>
<p>red&gt;&gt; series1: [a a a]<br>
== [a a a]</p>
<p>red&gt;&gt; series2: [b b b]<br>
== [b b b]</p>
<p>red&gt;&gt; parse series1 ['a :series2 some 'b]<br>
*** Script Error: PARSE - get-word refers to a different series! :series2</p>
<p><strong>R3-Alpha Decided To Make It Legal</strong></p>
<pre><code>r3-alpha&gt;&gt; series1: [a a a]
== [a a a]

r3-alpha&gt;&gt; series2: [b b b]
== [b b b]

r3-alpha&gt;&gt; parse series1 ['a :series2 some 'b]
== true
</code></pre>
<p>I wasn't aware the feature was used, but <a class="mention" href="/u/rgchris">@rgchris</a> used it in the Rebol3 version of altjson:</p>
<p><a href="https://github.com/rgchris/Scripts/blob/6fa69eabe11fe78b9fd0a7bd6bb17a923cee0b2b/r3-alpha/altjson.r3#L48">https://github.com/rgchris/Scripts/blob/6fa69eabe11fe78b9fd0a7bd6bb17a923cee0b2b/r3-alpha/altjson.r3#L48</a></p>
<h2>The Feature Was Added to R3-Alpha Circa 2009</h2>
<p>Carl's blog entry:</p>
<p><a href="http://www.rebol.net/r3blogs/0265.html">http://www.rebol.net/r3blogs/0265.html</a></p>
<p>He points out one fairly clear reason why this is sketchy:</p>
<blockquote>
<p>The problem is this: if you change the series but the rule fails, forcing a recovery to a prior index, <em>it's still the new series</em>. That is, we do not recover to the old series.</p>
<p>If advanced users are willing to live with that restriction, then this change can be made.</p>
</blockquote>
<p>Another comment says the opposite of what I would think:</p>
<blockquote>
<p>Input switching would make parsing of big (or streaming) files more easy, as we wouldn't have to keep the whole data in memory, and could read it as needed, without losing the current parse state.</p>
</blockquote>
<p>Doing streaming parsing <em>correctly</em> requires <em>tighter</em> control over the process... not less.</p>
<h2>Can The Desire Be Met Other Ways?</h2>
<p>Since you're basically destroying the ability to meaningfully backtrack, I don't know how this is that different from starting a new parse.</p>
<p>I'd like it to be easy to return results out of a parse (see the <a href="https://forum.rebol.info/t/uparses-spin-on-return/1589">RETURN/ACCEPT post</a>)</p>
<p>So why wouldn't you have some kind of driving loop on the outside of your parse that looks for a continuation signal, and then starts a new parse with what it's given?</p>
<p>I want to take a look at the cases and see if they could be done some other way.  So maybe <a class="mention" href="/u/rgchris">@rgchris</a> can explain the rational behind the choice in altjson, and if there's some feature that would be a better fit.</p>
            <p><small>7 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/series-switching-in-parse/1974">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/series-switching-in-parse/1974</link>
          <pubDate>Tue, 20 Sep 2022 02:03:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1974</guid>
          <source url="https://forum.rebol.info/t/series-switching-in-parse/1974.rss">Series Switching in PARSE</source>
        </item>
        <item>
          <title>Boron Language</title>
          <dc:creator><![CDATA[WickedSmoke]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>Hello, Boron author here.  I look in on the Ren-C project once a year or so to see what's going on.  A few times I have considered joining this forum but for various reasons have not done so.  Since you have made space for similar projects, now seems like a good time to touch base.</p>
<p>Boron is my daily driver for scripting and has been in a stable period for years.  Bugfix releases occur roughly once per year.  I should have been making release announcements on the mailing list, but as there is no community of active users I didn't bother.  To exercise the language I have used it in the <a href="http://xu4.sourceforge.net/" rel="noopener nofollow ugc">xu4 project</a> to replace the XML configuration and scripting.</p>
<p>The next period of change may include support for static strings (ala AltScript), optimized path! storage, and reworking the evaluator to support yielding.</p>
<p>Games and graphics are an interest of mine so the Boron-GL project is where I experiment with GUIs, shaders, and such.  Some of the work on xu4 such as font rendering and the <a href="https://wickedsmoke.github.io/faun/" rel="noopener nofollow ugc">Faun</a> library will make it's way into Boron-GL.  The GL code was part of the main Boron repository until the end of 2019.</p>
            <p><small>12 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/boron-language/1976">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/boron-language/1976</link>
          <pubDate>Sat, 17 Sep 2022 14:39:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1976</guid>
          <source url="https://forum.rebol.info/t/boron-language/1976.rss">Boron Language</source>
        </item>
        <item>
          <title>Dialecting With Quasiforms</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>In the list of potential ideas of the long forgotten past, there was a thought that strings would come in two forms... one that was compared case-sensitively, and another that was not.</p>
<p>The visual look of the case-insensitive form was suggested as having a leading tilde, as one representation.</p>
<pre><code>&gt;&gt; "a" = ~"A"
== #[true]
</code></pre>
<p>No one really went to bat for the idea or thought through its ramifications.  It wasn't particularly easy to test what that would be like.</p>
<h2>Quasiforms Make The Proposal Easier To Test</h2>
<p>We now basically have the implementation guts needed to where we could consider the bits passed on the value.  It even has a decent name:</p>
<pre><code>&gt;&gt; quasi "A"
== ~"A"~

 &gt;&gt; "a" = "A"
 == #[false]

 &gt;&gt; "a" = quasi "A"
 == #[true]
</code></pre>
<p>The principle meaning of a quasiform is as the ^META of an isotope form.  And what this would mean is, there's no such thing as a differentiation between an isotopic case-sensitive word/string and an isotopic case-insensitive word/string.</p>
<h2>I Don't Think I Like It, BUT...</h2>
<p>Regardless of me not liking it, it's a possibility for dialects.  If you wanted to mark some strings for case-insensitivity you have another option in the box.</p>
<p>The reason I don't like it is because the isotope and quasi forms are supposed to stand out and draw attention to weirdness.  This is too common an application.  And it would mean your case-insensitive forms would be evaluating to isotopes everywhere, unless the quasiform evaluation changed in some way to make quasi-strings inert.  This isn't in line with what I want to do.</p>
<p>But...your dialect can do it.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/dialecting-with-quasiforms/1960">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dialecting-with-quasiforms/1960</link>
          <pubDate>Mon, 05 Sep 2022 08:16:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1960</guid>
          <source url="https://forum.rebol.info/t/dialecting-with-quasiforms/1960.rss">Dialecting With Quasiforms</source>
        </item>
        <item>
          <title>Scheduler Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>I thought of the scheduler dialect today that DocKimbel had made, and went and looked it up.</p>
<p>This is something that should be able to run as-is in Ren-C under Redbol emulation--so I'll see what I can do about that.  But it would also be interesting to see what kinds of improvements could be made to it with a Ren-C specific version.</p>
<aside class="onebox githubgist">
  <header class="source">
      <a href="https://gist.github.com/greggirwin/63471784ace61153763f465c3ea37c98" target="_blank" rel="noopener">gist.github.com</a>
  </header>
  <article class="onebox-body">
    <h4><a href="https://gist.github.com/greggirwin/63471784ace61153763f465c3ea37c98" target="_blank" rel="noopener">https://gist.github.com/greggirwin/63471784ace61153763f465c3ea37c98</a></h4>
<h5>scheduler.r</h5>
<pre><code class="Rebol">REBOL [
	Title: "Scheduler"
	File: %scheduler.r
	Purpose: "Dialected task scheduling library"
	Author: ["SOFTINNOV / Nenad Rakocevic" "Pointillistic / Gregg Irwin"]
	Copyright: ["2009 SOFTINNOV" "2013 SOFTINNOV/POINTILLISTIC"]
	Email: [nr@softinnov.com gregg@pointillistic.com]
	Date: 28-Oct-2013
	Version: 0.9.5
	License: "BSD - see %LICENCE.txt file"</code></pre>
This file has been truncated. <a href="https://gist.github.com/greggirwin/63471784ace61153763f465c3ea37c98" target="_blank" rel="noopener">show original</a>

<p>
</p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/scheduler-dialect/1957">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/scheduler-dialect/1957</link>
          <pubDate>Sat, 03 Sep 2022 07:40:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1957</guid>
          <source url="https://forum.rebol.info/t/scheduler-dialect/1957.rss">Scheduler Dialect</source>
        </item>
        <item>
          <title>Code Golf Website</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Rebmu</category>
          <description><![CDATA[
            <p>Here's a competitive code golf site with a leaderboard:</p>
<p><a href="https://code.golf/">https://code.golf/</a></p>
<p>The site seems to be reasonably well done, puzzles look good:</p>
<p><a href="https://code.golf/qr-decoder#c" class="inline-onebox">QR Decoder</a></p>
<p>It has a different model than other sites, where the answers are secret:</p>
<blockquote>
<p><em>"Can I See Other People's Solutions?</em></p>
<p><em>No, that way all holes stay competitive. If you're stuck on how to shave a couple of strokes off your solution then why not visit our Discord server for some advice."</em></p>
</blockquote>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/code-golf-website/1952">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/code-golf-website/1952</link>
          <pubDate>Wed, 31 Aug 2022 15:21:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1952</guid>
          <source url="https://forum.rebol.info/t/code-golf-website/1952.rss">Code Golf Website</source>
        </item>
        <item>
          <title>SPREAD in PARSE: Isotopic Matching</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Remember that the <code>@var</code> rule will match the contents of variables literally, vs. running them as a rule:</p>
<pre><code>&gt;&gt; var: [some rule]
== [some rule]

&gt;&gt; parse [[some rule] [some rule]] [some @var]
== [some rule]
</code></pre>
<p>You can evaluate an expression to literally match, too:</p>
<pre><code>&gt;&gt; parse [[some rule] [some rule]] [some @(reverse copy [rule some])]
== [some rule]
</code></pre>
<p>Now there's a powerful new twist: <strong>You can match in a spliced fashion, using an isotopic block!</strong></p>
<pre><code>&gt;&gt; var: [some rule]

&gt;&gt; parse [some rule some rule] [some @(spread var)]
== ~[some rule]~  ; isotope
</code></pre>
<p><em>And you can synthesize a product that may be a splice or not!!!</em></p>
<pre><code>&gt;&gt; append [a b c] parse [1 2 3] [block! | spread across some integer!]
== [a b c 1 2 3]

&gt;&gt; append [a b c] parse [[x y z]] [block! | spread across some integer!]
== [a b c [x y z]]
</code></pre>
<p><strong><a href="https://forum.rebol.info/t/putting-splicing-intent-on-appended-value/1873">Encoding the splicing intent on the value is clearly the way to go.</a></strong>  Seems obvious now, but hindsight is 20/20.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/spread-in-parse-isotopic-matching/1949">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/spread-in-parse-isotopic-matching/1949</link>
          <pubDate>Wed, 31 Aug 2022 10:36:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1949</guid>
          <source url="https://forum.rebol.info/t/spread-in-parse-isotopic-matching/1949.rss">SPREAD in PARSE: Isotopic Matching</source>
        </item>
        <item>
          <title>Matching Characters in BINARY! PARSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>In Rebol2, you can't match a character (or string) against a binary!:</p>
<pre><code>rebol2&gt;&gt; to binary! " "
== #{20}

rebol2&gt;&gt; parse #{20} [" "]
== false

rebol2&gt;&gt; parse #{20} [#" "]
== false
</code></pre>
<p>In Red and R3-Alpha, you can do both...</p>
<pre><code>red&gt;&gt; parse #{20} [" "]
== true

red&gt;&gt; parse #{20} [#" "]
== true
</code></pre>
<p>But their unicode model means they really don't know what they're doing in any general sense, and I'm sure whatever's under the hood is incoherent:</p>
<pre><code>red&gt;&gt; to binary! "Æ"
== #{C386}

red&gt;&gt; parse #{C386} ["Æ"]
== false
</code></pre>
<p>Ren-C is much more coherent!</p>
<pre><code>&gt;&gt; did parse #{C386} ["Æ"]
== #[true]
</code></pre>
<h2>So the PARSE Succeeds, but... what should it return?</h2>
<p>Right now a parse on a string returns the <em>rule</em> when it matches.</p>
<pre><code>&gt;&gt; rule: "cd"

&gt;&gt; result: parse "abcd" ["ab" rule]
== "cd"

&gt;&gt; append result "ef"
== "cdef"

&gt;&gt; rule
"cdef"
</code></pre>
<p><strong>This is clearly correct, because you don't want it to make a copy if it doesn't know if you're going to use the copy.</strong>  Basic rule matching should not produce a new series.</p>
<p>The same logic applies to BINARY!...but should it give you the string as a string, or aliased to its binary form?</p>
<pre><code>&gt;&gt; parse #{C386} ["Æ"]
== "Æ"  ; option 1

&gt;&gt; parse #{C386} ["Æ"]
== #{C386}  ; option 2
</code></pre>
<p>I think the answer is that you should match it as whatever form it was in the rule.</p>
<p>But then...how about something like BLANK!, which acts equivalently to space if the input is a string... or BLANK! if it's an array?</p>
<pre><code>&gt;&gt; parse [_] [_]
== _

&gt;&gt; parse " " [_]
== ???

&gt;&gt; parse #{20} [_]
== ???
</code></pre>
<p>If we're going with the idea of rule as being primacy, then the language of the match should be the same as the language of the rule... e.g. the above all return blank.</p>
<p>But this is something of a gray area, IMO.  I feel like blank is acting as a stand-in for space and should probably be looked at as if you said space.</p>
<pre><code>&gt;&gt; parse " " [_]
== #" "

&gt;&gt; parse #{20} [_]
== #" "  ; instead of 32
</code></pre>
<p>So this is what I'm going with, unless someone has a really good argument for something else.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/matching-characters-in-binary-parse/1935">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/matching-characters-in-binary-parse/1935</link>
          <pubDate>Sun, 21 Aug 2022 05:43:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1935</guid>
          <source url="https://forum.rebol.info/t/matching-characters-in-binary-parse/1935.rss">Matching Characters in BINARY! PARSE</source>
        </item>
        <item>
          <title>Calling Ren Functions From Redbol</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>When you <strong><code>import @redbol</code></strong> the environment for your module is skinned with the Redbol definitions.  But it can run concurrently with non-Redbol modules in the same session.  This is very cool.</p>
<p>I've nudged it a little further into cool by having the definition of LIB in Redbol be the initial state of the Redbol definitions, and then REN is the Ren-C's version of LIB.</p>
<pre><code>&gt;&gt; import @redbol

&gt;&gt; append [a b c] [d e]
== [a b c d e]

&gt;&gt; append/only [a b c] [d e]
== [a b c [d e]]

&gt;&gt; ren/append [a b c] [d e]
== [a b c [d e]]

&gt;&gt; ren/append [a b c] ren/spread [d e]
== [a b c d e]

&gt;&gt; append: does [print "Overwritten"]
== #[action! {append} []]

&gt;&gt; append
Overwritten

&gt;&gt; lib/append [a b c] [d e]
== [a b c d e]
</code></pre>
<p><em>Pretty slick.</em></p>
<h2>But IMPORT is Ultimately Not The Right Mechanism</h2>
<p>Because it's done using import, Redbol does not "clear out" the space of all the Ren-Cisms.</p>
<p>In fact, I didn't actually have to say <strong>ren/spread</strong> because the spread definition is still available:</p>
<pre><code>&gt;&gt; ren/append [a b c] spread [d e]
== [a b c d e]
</code></pre>
<p>It's non-viable to ask Redbol to remove every Ren-C definition.  Instead, there needs to be a way to get a Redbol-using module to start from a fully clean slate where it explicitly exports everything it wants to make available.  This doesn't have to be that much work, it can just be a list of words in a block, with possible renamings:</p>
<pre><code>redbol-inherit [even?, odd?, value?: unset? ...]
</code></pre>
<h2>These Challenges Are Great For Vetting</h2>
<p>I don't throw softballs.  This is all truly attempting to live up to the hype of a language that you can bend and redefine at will, without constantly tripping over your own changes--and being able to build on top of existing functionality without being forced to rewrite it too.</p>
<p>Although things move slowly... the arrow of progress is in the right direction.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/calling-ren-functions-from-redbol/1934">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/calling-ren-functions-from-redbol/1934</link>
          <pubDate>Sat, 20 Aug 2022 21:05:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1934</guid>
          <source url="https://forum.rebol.info/t/calling-ren-functions-from-redbol/1934.rss">Calling Ren Functions From Redbol</source>
        </item>
        <item>
          <title>TRY PARSE + PARSE EXCEPT : *FAIL* On Mismatch</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>There's a snazzy new potential for giving more informative messages / logs from failed parses... which means we now have a more interesting option than we might have had before.</p>
<p>Imagine something like:</p>
<pre><code>&gt;&gt; parse "aaa" [some "a" some "b"]
** Error: SOME requires at least one match
** Where: [some "a" \\ some "b" \\]
; Note: this failure can be intercepted by TRY, EXCEPT, ATTEMPT
</code></pre>
<p>It can't be perfect unless it maintains some kind of large error tree that accumulates the list of all the reasons it decided to fail, so you might have to be in a debugging mode to ask it to give you a bigger diagnostic.  But we can build it now with the participation of the combinators themselves.</p>
<p><strong>But not only this, we could open up the full spectrum of return values.</strong>  Right now if your parse returns NULL, it has to be contorted into a null isotope to avoid accidentally cuing an ELSE.  Similar contortions for void, blank, and logic false.</p>
<pre><code>result: parse block rules except e -&gt; [print "Got an error", return]

; If you got here, you know result is good
; Even if it was a purposefully returned NULL, etc.
</code></pre>
<p>There'd be some way to rig this up without using enfix.  I might make things more lax about letting you assign error isotopes, because the isotope will bubble through and cause a problem anyway.  So you could write something like:</p>
<pre><code> if fail? result: parse block rules [
     print "You have a failure, use ^result to get it"
 ]
</code></pre>
<p>If you were willing to collapse failure down to a NULL or somesuch, or didn't even care about the result, you could just TRY it.</p>
<pre><code> try parse block rules
</code></pre>
<h2>Too Good Not To Be The Default</h2>
<p>Of course you'll be able to reskin it however you like for the R3C's or R3Chius out there.  But I think this looks like a perfect convergence to put in the box.</p>
<p>Errors aren't going to be that interesting on day one, but it's good to point the ship in the right direction.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/try-parse-parse-except-fail-on-mismatch/1924">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/try-parse-parse-except-fail-on-mismatch/1924</link>
          <pubDate>Fri, 19 Aug 2022 06:23:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1924</guid>
          <source url="https://forum.rebol.info/t/try-parse-parse-except-fail-on-mismatch/1924.rss">TRY PARSE + PARSE EXCEPT : *FAIL* On Mismatch</source>
        </item>
        <item>
          <title>Wish: Multi-Returns For UPARSE Combinators</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Every combinator has a synthesized value.  But some combinators throw away values synthesized by their parser parameters.</p>
<p>For instance, TALLY.</p>
<pre><code>&gt;&gt; parse [1020 304] [int: some integer!]
== 304

&gt;&gt; parse [1020 304] [count: tally some integer!]
== 2
</code></pre>
<p>TALLY knows what the result of the last call it made was, but doesn't preserve it.  What if you could?</p>
<pre><code>&gt;&gt; parse [1020 304] [[count int]: tally some integer!]
== 2

&gt;&gt; count
== 2

&gt;&gt; int
== 304
</code></pre>
<p>That particular one is not necessarily a very interesting example, since you could get it yourself...</p>
<pre><code>parse [1020 304] [count: tally int: some integer!]
</code></pre>
<p>I only mention it because it was in a comment in UPARSE I wanted to delete, because it's a long enough file without becoming a wishlist compilation.  :-/</p>
<p>But there are certainly going to be other examples of combinators that might want to synthesize more than one value.  So hopefully the feature can be implemented at some point...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/wish-multi-returns-for-uparse-combinators/1920">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/wish-multi-returns-for-uparse-combinators/1920</link>
          <pubDate>Wed, 17 Aug 2022 14:43:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1920</guid>
          <source url="https://forum.rebol.info/t/wish-multi-returns-for-uparse-combinators/1920.rss">Wish: Multi-Returns For UPARSE Combinators</source>
        </item>
        <item>
          <title>Calling Combinators (Decoders?) as Normal Functions</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>A few times I've talked about the potential of making it possible to call a COMBINATOR function from outside of PARSE.</p>
<p>This is to say that if some PARSE-specific parameter was missing (e.g. the "parse state") there'd be a mode in the guts of the COMBINATOR mechanic which cooked up something like a temporary parse session just for the input you passed in.</p>
<h2>Would It "Combinate" Parsers For You?</h2>
<p>The situations I had in mind weren't really combinators that take parsers as parameters.  And now that I look at it, I think that suggests that... no, you probably shouldn't call these kinds of combinators outside of parse.</p>
<p>Here's one imagination of calling a combinator like SOME:</p>
<pre><code>&gt;&gt; [value rest]: some "aaaabbb" [repeat 2 "a"]
== "a"

&gt;&gt; value
== "a"

&gt;&gt; rest
== "bbb"
</code></pre>
<p>This exposes how SOME is actually not arity-1.  Though it takes a "combinated parser" as a parameter, it also takes an INPUT...but that's usually implicit...specialized in by PARSE.  But calling directly from normal code it could offer that parameter being gathered normally.</p>
<p>it doesn't feel that compelling, since you're getting a synonym for:</p>
<pre><code>parse "aaaabbb" [some repeat 2 "a"]
</code></pre>
<p>But also, why would it take that interpretation instead of:</p>
<pre><code>parse "aaaabbb" [some ([repeat 2 "a"])]
</code></pre>
<p>One point of view would say it makes more sense to think of the expression as the product of evaluation, because the argument would presumably be otherwise evaluative:</p>
<pre><code>&gt;&gt; [value rest]: some "aaaabbb" append [repeat 2] "a"
== ??? ; infinite loop?
</code></pre>
<p>But this would make rule-taking combinators nearly useless.</p>
<h2>It Was Suggested For Sharing "Decoding", not "Combinating"</h2>
<p>Seeing how SOME isn't a good example for this, maybe the right way of saying what I'm trying to say here this is that there's some category of functions we might call "decoders"...and PARSE would be willing to call these.</p>
<p>They'd fit a standard format regarding things like taking an input series and giving back an amount of progress or an error.  But they would not be passed something like the parser stack or have any automatic composition of parsers as arguments.</p>
<p>Plain decoding operations--like <a href="https://forum.rebol.info/t/binary-dialected-encoding-decoding-instead-of-to-conversions/1270">ENBIN and DEBIN</a>--were the motivating cases:</p>
<pre><code>&gt;&gt; debin #{FEFFFF} [le + 3]
== 16777214

&gt;&gt; parse #{FEFFFFFEFFFF} [collect [keep debin [le + 3]]]
== [16777214 16777214]
</code></pre>
<p>The idea here was that you could write one version of DEBIN, and it would be able to implicitly pick up the INPUT when used in PARSE.</p>
<p>But because the input is an implicit parameter that you get automatically for all "decoders", then without extra information it would have to be at either the beginning or end of the parameter list.  Above it's at the beginning, which is different from how DEBIN was defined originally:</p>
<pre><code>&gt;&gt; debin [le + 3] #{FEFFFF}  ; original DEBIN design took dialect block first
== 16777214
</code></pre>
<p><em>(Note: I have a post about <a href="https://forum.rebol.info/t/parameter-order-in-rebol/1238">parameter ordering</a> which questions the series-first model.)</em></p>
<p>We could say that "decoders" have to manually mention their input parameter somewhere, and position it in the order that it would be consumed if it's used outside of PARSE...which would allow customization of this process.  It could default to being the first parameter if not positioned explicitly.  Not an idea-killer, in any case.</p>
<h2>If All The Input Wasn't Consumed, It Would Error</h2>
<p>One idea of calling these decoders on arbitrary input could be that if the end of input was not reached, it would give an error:</p>
<pre><code>&gt;&gt; debin [le + 3] #{FEFFFF00}  ; asking for 3 bytes of decode, passed 4
** Error: DEBIN did not consume all input, request remainder if intentional
</code></pre>
<p>Asking for a remainder could prevent the error:</p>
<pre><code>&gt;&gt; [value rest]: debin [le + 3] #{FEFFFF00}
== 16777214

&gt;&gt; rest
== #{00}
</code></pre>
<p>So this is kind of where the motivation is.  Once you've written the decoder version of DEBIN, you have everything you need to run a DEBIN operation inside or outside of PARSE.  So why should you need to write a separate combinator and non-combinator form?</p>
<h2>I Was Thinking About This Now Because of TRY</h2>
<p>I'm putting together some thoughts where if TRY is the way you say it's okay if a combinator doesn't succeed in PARSE, what would the behavior be outside of PARSE?</p>
<p>Up until now we've said that NULL is the reserved result for combinator failure.  But I've put forth the idea that NULL might be a legitimate combinator result, and so definitional errors could be used to say that an operation did not meet its requirements.</p>
<p>So now...how about these "decoders"?  Should a decoder run in isolation raise an error if it doesn't work, or should it just return NULL?</p>
<p><strong>It seems clear that at least <em>some</em> operations should raise errors instead of passively returning NULL.</strong>  If you ask to decode an invalid stream, it should be noisy about that failure.</p>
<p>I believe that some of these errors shouldn't be defused by TRY.  For instance, <strong>debin #{FEFFFF} [banana + 3]</strong>... that's an inability to understand what you're even asking.  To me this is on par with typos or passing invalid types; they are a sign of downright incorrect code, not the kind of thing that something like ATTEMPT should be able to ignore...much less should TRY quiet them.</p>
<h2>So...What Should Count As Things TRY Defuses?</h2>
<p>At first, the TRY error was specifically tied to the idea of a special error that happened when inputs were NULL.  This required special code in the FUNC typechecking, because by default a typechecking error does not produce a definitional error that can be trapped with something like EXCEPT.</p>
<p>Now I've expanded the idea that the word was short and useful enough that it might be used for any case where there were no adverse side effects, and a function wanted to say it simply couldn't do the thing it was asked to do.</p>
<p>Might we say that <em>all definitional errors</em> fit under this category?  That you shouldn't do <strong>return raise [...]</strong> unless the error can be swept under the rug by a TRY?  Does this suggest a "value surrogate" for TRY is a generic thing that any error can carry (if you TRY me, convert to this value).  Or is that just a characteristic of errors that TRY is willing to defuse?</p>
<p>As usual, more thought needed.  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_head_bandage.png?v=9" title=":face_with_head_bandage:" class="emoji" alt=":face_with_head_bandage:"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/calling-combinators-decoders-as-normal-functions/1914">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/calling-combinators-decoders-as-normal-functions/1914</link>
          <pubDate>Mon, 15 Aug 2022 07:39:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1914</guid>
          <source url="https://forum.rebol.info/t/calling-combinators-decoders-as-normal-functions/1914.rss">Calling Combinators (Decoders?) as Normal Functions</source>
        </item>
        <item>
          <title>What&#39;s Cool (According to Danny)</title>
          <dc:creator><![CDATA[Danny]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Photos are nice. complex. but some how easy to understand most of the time without having to know the "who, what, when, where, and why." Just by looking at them, you can kinda tell what it's trying to show you. I want Rebol coding to look like that while working with any data context in its original form as possible.</p>
<blockquote>
<p>**<br>
var {whats-cool 0: Brett}<br>
Var Rebdol: {Rebdol cool: "what's-cool"}**</p>
</blockquote>
<p>The <a href="http://www.rebol.org/view-script.r?script=rebol-dom.r" rel="noopener nofollow ugc">%Rebol-dom.r</a> Var is named from the associated value strings/words, unless you *!, select-all-fetch-as strings/words. Then you can, Rebdol."cool" -&gt;select &amp; load "what's-cool". Wich is, whats-cool: { 0: Brett}. Then .[0], and  you get Brett.</p>
<p>Or change the *value to Ren-C. **</p>
<blockquote>
<p>whats-cool [ /rebdol.cool.&amp;.0 = Ren-C] <em>messy, noisy example</em><br>
**</p>
</blockquote>
<p>Is this musing when the origonal data context does'nt need to be changed. And if parsed into a Dialect Object Model, without changing syntax, this data can be searched, updated with DOM functions.</p>
<p>Creating Vars out of molded data/code with foreign syntax, is its own Sequence built notation.</p>
<blockquote>
<pre><code>struct: :Var

 struct qwerty {
                   Int #1
                   Char "hello"
                   Float 9.0
                   Char "there"
                } *! 'qwerty

*variable: "request" new[qwerty]
</code></pre>
</blockquote>
<p>This data looks like and can be used to construct *New nodes that can run as code without creating defined functions but remain as sequence(molded) data that needs no bindings or loading to take place.</p>
<p>I hope this is musing, for others as it is for me. Rebol-dom.r Sequence/molded data, strings as *keys have context all without loading anything but the *value. It's what i found and fished out of that Deep Lake.</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/whats-cool-according-to-danny/1906">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/whats-cool-according-to-danny/1906</link>
          <pubDate>Fri, 29 Jul 2022 23:42:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1906</guid>
          <source url="https://forum.rebol.info/t/whats-cool-according-to-danny/1906.rss">What&#39;s Cool (According to Danny)</source>
        </item>
        <item>
          <title>Could we replace PARSE&#39;s OPT with TRY ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Just a week ago, things stood at the idea that TRY was for "defusing NULL" by turning it into a BLANK!:</p>
<pre><code>&gt;&gt; try null
== _  ; tolerated by some functions that would not tolerate NULL
</code></pre>
<p>But that's all out the window, now.  TRY is for saying <em>"hey, wait, don't fail... you can be a no-op, that's fine."</em>  Nothing to do with blanks anymore.</p>
<p><strong>This makes it a candidate for being a very literate alternative to OPT in parse!</strong></p>
<pre><code>&gt;&gt; parse "aaaccc" [some "a", try some "b", some "c"]
== "c"
</code></pre>
<p>It helps make the loss of "ANY" as a looping construct more palatable, as <strong><code>try some</code></strong>  is easier on the eyes than <strong><code>opt some</code></strong>.</p>
<p><strong>But...what about conflation with the purpose of defusing NULL arguments?</strong></p>
<pre><code>&gt;&gt; rule: null

&gt;&gt; parse "aaaccc" [some "a", try some rule, some "c"]
== "c"  ; ???
</code></pre>
<p>Hmmm.  And what if you wanted to require it <em>unless</em> it was null?</p>
<pre><code>&gt;&gt; rule: "b"

&gt;&gt; parse "aaaccc" [some "a", try some rule, some "c"]
; null  (e.g. conceptually I was TRY-ing RULE, not the SOME)
</code></pre>
<p>That doesn't feel right.  And I don't like the idea that we'd be seeing things like <strong>opt try some rule</strong> on any kind of regular basis.</p>
<h2>Let's Remember: This is a Dialect</h2>
<p>Things are already stretched around a bit, and we make things line up when they make sense...and unalign them when they do not.</p>
<p><strong>We're free to say that TRY has nothing (or little?) to do with tolerating NULL inputs to parse rules, but where it shares heritage in meaning is "a no-op here is okay".</strong></p>
<p>I think there are two reasonable options:</p>
<ol>
<li>
<p>Keep the current policy that most times, passing a NULL to rules is an error.  If you want a no-op rule, use <strong><code>[]</code></strong> or for more efficiency, <strong>(the ')</strong> (a quoted null)</p>
<ul>
<li>
<p>So this would mean that the decision is on a per-combinator basis, vs. saying all parser arguments to combinators are implicitly <code>[&lt;try&gt;]</code> ... and so things like SOME would not choose to label its argument that way.</p>
</li>
<li>
<p>Exceptions could be made for things like SEEK, where <strong>try seek (null)</strong> would be a way to say it's okay if you don't provide a seek position.</p>
</li>
</ul>
</li>
<li>
<p>Systemically allow conflation on all combinators, where <strong>some null</strong> errors but <strong>try some null</strong> is legal.</p>
</li>
</ol>
<p>Off the top of my head here, I think (1) is probably the better choice.  If someone disagrees, we might want to make it easier to change via a switch vs. having to copy all the combinators and add <code>&lt;try&gt;</code> to their arguments.</p>
<p>But I <em>definitely</em> don't like the idea that a rule prefaced with TRY would be expected to succeed if its argument were non-null.  TRY should mean the rule cannot fail its match (other than by raising an error).</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/could-we-replace-parses-opt-with-try/1888">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/could-we-replace-parses-opt-with-try/1888</link>
          <pubDate>Sat, 16 Jul 2022 15:36:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1888</guid>
          <source url="https://forum.rebol.info/t/could-we-replace-parses-opt-with-try/1888.rss">Could we replace PARSE&#39;s OPT with TRY ?</source>
        </item>
        <item>
          <title>VID/S or Spaces, from Red&#39;s hiiamboris</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>GUI</category>
          <description><![CDATA[
            <p>I haven't looked at it closely, but what I find interesting is that the demos are trying to show some non-trivial looking things:</p>
<p><a href="https://codeberg.org/hiiamboris/red-spaces" class="inline-onebox">hiiamboris/red-spaces: Draw based widgets for Red - red-spaces - Codeberg.org</a></p>
<p>Here's the code for editing text on a spiral:</p>
<p><a href="https://codeberg.org/hiiamboris/red-spaces/src/branch/master/tests/spiral-test.red" class="inline-onebox">red-spaces/spiral-test.red at master - red-spaces - Codeberg.org</a></p>
<p>I guess there's nothing particularly remarkable about it, in the sense that it's just a clickable canvas...drawing the whole thing every time.  Modern computers just happen to be pretty fast, so duplicating a couple of lorem ipsum texts 10 times isn't going to create all that much of a barrier to doing such a thing...even if Red is nothing special.</p>
<p>What I'd consider "remarkable" would be if there was some design whereby you were inheriting selection behavior...so it was doing some kind of behavior-preserving coordinate transformation on a fully functional text editor widget.  It's not.</p>
<p>So that sort of dampens my interest in looking too much deeper.</p>
<p>The "rotate a form" demo is a more behavior-preserving example, but not a particularly profound one.  I'm not completely sure what the pitch is.  CSS can do transforms, too.  3-D even.</p>
<p><a href="https://impress.js.org/#/bored" class="inline-onebox">impress.js | presentation tool based on the power of CSS3 transforms and transitions in modern browsers | by Bartek Szopka @bartaz</a></p>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/vid-s-or-spaces-from-reds-hiiamboris/1886">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/vid-s-or-spaces-from-reds-hiiamboris/1886</link>
          <pubDate>Sat, 16 Jul 2022 13:21:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1886</guid>
          <source url="https://forum.rebol.info/t/vid-s-or-spaces-from-reds-hiiamboris/1886.rss">VID/S or Spaces, from Red&#39;s hiiamboris</source>
        </item>
        <item>
          <title>`tac` : Implementation of UNIX&#39;s line reverser</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>System Tools</category>
          <description><![CDATA[
            <p>I mentioned I wanted to study some basic utilities...even more basic than <a href="https://forum.rebol.info/t/greb-grep-using-parse/1818">greb</a>.  Small codebases can put a focus on big design points.</p>
<p>Here was my off-the-cuff line-reverser (TAC ... reverse CAT, where CAT is like Windows Command Shell's TYPE).  I wrote it a year ago, while I was solely focused on getting READ-LINE to work from piped input cross platform at the time...so almost no thought went into it:</p>
<pre><code>; %tac.r, version 0.0.1
;
; * COLLECT the lines
; * REVERSE the collection
; * output the result DELIMIT-ed with newline
;
write-stdout try delimit/tail newline reverse collect [
    until [not keep line: try read-line]
]
</code></pre>
<p><em>Right off the bat, you can see it's using twice the memory it needs to.</em>   It's collecting a block of strings, and then while that whole block is in memory it merges it into one giant string before output.  At minimum, this should loop and write the strings out of the block out one at a time.  (Though doing it this way does draw attention to an interesting point about DELIMIT, which I'll get to later.)</p>
<blockquote>
<p>Note: This line-reversing task is one of those pathological cases that can't be done in a "streaming" way.  You can't start writing anything to the output until you've read the input to the end.  (Doing better needs a random-access I/O PORT! that can SEEK the end of the file and go backwards...but the standard input device can't do this.)</p>
</blockquote>
<h2>But First Things First: The Impact of <a href="https://forum.rebol.info/t/definitional-errors-as-blank-in-null-out-alternative/1880">the New TRY Rules</a>
</h2>
<p>Recall that the old behavior was that TRY would turn NULL into BLANK! in order to stop functions from raising an error on those NULLs.  So here:</p>
<ul>
<li>
<p>we'd stop KEEP from failing when there are no more lines to READ-LINE from, so it acts as a no-op instead</p>
</li>
<li>
<p>we'd stop WRITE-STDOUT from failing when an empty block is collected and DELIMIT returns NULL:</p>
<pre><code>write-stdout try delimit/tail newline reverse collect [  ; TRY DELIMIT =&gt; BLANK!
  until [not keep line: try read-line]  ; TRY READ-LINE =&gt; BLANK!
]
</code></pre>
</li>
</ul>
<p>The new way <img src="https://forum.rebol.info/images/emoji/twitter/sparkles.png?v=9" title=":sparkles:" class="emoji" alt=":sparkles:"> is you go ahead and pass the NULL, and the function raises a very narrow error.  This error is caught by a TRY on the function call itself.</p>
<p>So applying that transformation:</p>
<pre><code>try write-stdout delimit/tail newline reverse collect [  ; TRY WRITE-STDOUT =&gt; NULL
    until [not try keep line: read-line]  ; TRY KEEP =&gt; NULL
]
</code></pre>
<h2>Why Does DELIMIT Ever Return NULL ?</h2>
<p>One might ask if it should never be able to return NULL when you use /TAIL.  At the moment, it does:</p>
<pre><code>&gt;&gt; delimit/tail "," ["a" "b"]
== "a,b,"

&gt;&gt; delimit []
; null

&gt;&gt; delimit/tail "," []
; null
</code></pre>
<p>Maybe that last one should be "," ?  Perhaps when you have /HEAD or /TAIL, you never get null back.</p>
<p>But... let's stick to looking at the use cases.</p>
<h2>What Does %tac.r Want From DELIMIT/TAIL Here?</h2>
<p>If we look at the edge case here, there is a difference between these two situations:</p>
<ul>
<li>
<p>The first call to READ-LINE returns an empty string, and the second call returns NULL</p>
<ul>
<li>
<p>This happens when you pipe in a 1-byte file containing a single line feed, e.g. a file containing one line that's empty.</p>
</li>
<li>
<p>With the code above, COLLECT produces the block <strong><code>[""]</code></strong> for this case</p>
</li>
</ul>
</li>
<li>
<p>The first call to READ-LINE returns NULL</p>
<ul>
<li>
<p>This happens when you pipe in a 0-byte file, e.g. a file containing no lines at all</p>
</li>
<li>
<p>With the code above, COLLECT produces the block <strong><code>[]</code></strong> for this case.</p>
</li>
</ul>
</li>
</ul>
<p><strong>So perhaps you see why DELIMIT chooses to react with some kind of signal when the block contents vaporize.</strong>  It's precisely because cases like this tend to need some kind of special handling, and it's not good to gloss over that.</p>
<p>In this case, the empty block (which corresponds to the 0-byte file input, e.g. 0 lines) should result in there being no write to the output.  So the default behavior of TRY WRITE-STDOUT NULL is the right answer.</p>
<h2>More to Study, I Just Thought That Bit Was Interesting...</h2>
<hr>
<blockquote>
<p><em>"There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no obvious deficiencies. The first method is far more difficult."</em></p>
</blockquote>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/tac-implementation-of-unixs-line-reverser/1883">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/tac-implementation-of-unixs-line-reverser/1883</link>
          <pubDate>Sat, 16 Jul 2022 04:16:07 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1883</guid>
          <source url="https://forum.rebol.info/t/tac-implementation-of-unixs-line-reverser/1883.rss">`tac` : Implementation of UNIX&#39;s line reverser</source>
        </item>
        <item>
          <title>FIND treats TYPESET!s specially...why not functions?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>In Rebol2, R3-Alpha, and Red...doing a FIND searching for a TYPESET! will give you the first instance of that type in a block:</p>
<pre><code>&gt;&gt; find [1 2 "abc" 3 4] any-string!
== ["abc" 3 4]

&gt;&gt; find [1 2 &lt;abc&gt; 3 4] any-string!
== [&lt;abc&gt; 3 4]
</code></pre>
<p>One would think that you'd be able to search for the typeset literally by using /ONLY.  But that doesn't work <em>(though Red says <a href="https://github.com/red/red/issues/4911">they addressed this recently</a>)</em></p>
<h3>Why Wasn't This Taken Further?</h3>
<p>Trying to FIND a function is pretty rare.  So why didn't they make it so that passing a function to FIND makes it search?</p>
<pre><code>&gt;&gt; find [1 2 3 4] func [x] [x &gt; 2]
== [3 4]
</code></pre>
<p>If a function took multiple arguments, that could be asking it to effectively /SKIP and group items at a time:</p>
<pre><code>&gt;&gt; find [1 2 4 3 5 6] func [a b] [a &gt; b]
== [4 3 5 6]
</code></pre>
<p>/ONLY could have worked for finding a function literally:</p>
<pre><code>&gt;&gt; find/only reduce [:positive? :zero? :negative?] :zero?
== [#[native! zero?...] #[native! negative?...]]
</code></pre>
<h3>Ren-C goes with QUOTED! vs. /ONLY, but same basic premise</h3>
<pre><code>&gt;&gt; find [1 0 2 0] :zero?
== [0 2 0]

&gt;&gt; find reduce [:positive? :zero? :negative?] quote :zero?
== [#[native! zero?...] #[native! negative?...]]
</code></pre>
<h3>Though It Seems Easy To Make Mistakes...</h3>
<p>People are invariably going to write <strong>find data value</strong>...think it works for a few values they try...and assume it works for others.  Redbols are notorious for pulling the rug out from under you with such things.</p>
<p>But if you're willing to do this for typesets, I don't see why doing it for functions is that much worse.</p>
<p>Just something to think about.</p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/find-treats-typeset-s-specially-why-not-functions/1881">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/find-treats-typeset-s-specially-why-not-functions/1881</link>
          <pubDate>Thu, 14 Jul 2022 10:36:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1881</guid>
          <source url="https://forum.rebol.info/t/find-treats-typeset-s-specially-why-not-functions/1881.rss">FIND treats TYPESET!s specially...why not functions?</source>
        </item>
        <item>
          <title>DESTRUCTURE Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>I've talked about this.  But there's no excuse not to write it, when there's so much power in modern PARSE <em>(the engine we up until recently called UPARSE)</em>.</p>
<p>A simple motivating case was a desire for different behavior from PARSE alternates with <strong><code>|</code></strong>.  So while <strong>[word! | word! word!]</strong> is always considered to be a badly-written parse rule, you could get a different treatment in destructure...because it always assumes you mean to go to <code>&lt;end&gt;</code></p>
<pre><code>&gt;&gt; destructure [banana] [
      [word!] =&gt; [print "Just one word"]
      [word! word!] =&gt; [print "Two words"]
   ]
Just one word

&gt;&gt; destructure [apple banana] [
      [word!] =&gt; [print "Just one word"]  ; not complete, so no match
      [word! word!] =&gt; [print "Two words"]
   ]
Two words
</code></pre>
<p>But the dialect concept is more ambitious than that, allowing you to give names to capture rules.  Then when you use those names, that's the variable that is set:</p>
<pre><code>&gt;&gt; destructure [apple banana] [
      w1: [word!] w2: [word!]

      [w1] =&gt; [print ["One:" w1]]
      [w1 w2] =&gt; [print ["Two:" w1 w2]]
   ]
Two: apple banana
</code></pre>
<p>And because what's actually powering this behind the scenes is PARSE, you have all those tools at your disposal...including the just-added <a href="https://forum.rebol.info/t/the-yada-yada-yada-combinator/1876">ellipsis operator</a>!</p>
<pre><code>&gt;&gt; destructure [1 2 apple banana 3 4 5] [
      w1: [word!] w2: [word!]

      [w1] =&gt; [print ["One:" w1]]
      [w1 w2] =&gt; [print ["Two:" w1 w2]]
      [... w1 w2 ...] =&gt; [print ["Words and more stuff:" w1 w2]]
   ]
Words and more stuff: apple banana
</code></pre>
<h2>A Crazy Short Implementation!</h2>
<p>I'm sure it will receive some enhancements, but... this is pretty badass for something I wrote that worked more or less the first time!</p>
<pre><code>destructure: func [
    input [any-series!]
    dialect [block!]
    /multi "Run multiple branches"
    &lt;local&gt; result' name rule pattern branch combinators
][
    result': '~
    combinators: copy default-combinators
    parse dialect [while [not &lt;end&gt;] [
        name: to-word/ set-word!, rule: block! (
            combinators.(name): compose [(name): (rule)]
        )
        |
        pattern: block!, '=&gt;, branch: block!
        (
            parse/combinators input pattern combinators then (
                branch
            ) also ^r' -&gt; [
                if not multi [
                    return unmeta r'
                ]
                result': r'
            ]
        )
        |
        fail "Invalid DESTRUCTURE dialect entry"
    ]]
    return unmeta result'
]
</code></pre>
<h2>And It's Composable, Too!</h2>
<p>That's right... you can use DESTRUCTURE with ELSE and THEN.</p>
<p>It follows the rules; a destructure that does not match anything is void!</p>
<pre><code>&gt;&gt; 1 + 2 destructure [a] [[integer!] =&gt; [print "Not happening"]]
== 3
</code></pre>
<p>Notice I even threw a /MULTI feature in there, so you can match multiple ways!</p>
<pre><code>&gt;&gt; destructure/multi [apple banana] [
      w1: [word!] w2: [word!]

      [w1] =&gt; [print ["One:" w1]]
      [w1 w2] =&gt; [print ["Two:" w1 w2]]
      [repeat 2 &lt;any&gt;] =&gt; [print "Matching any two values also counts"]
   ]
Two: apple banana
Matching any two values also counts
</code></pre>
<hr>
<h1>
<img src="https://forum.rebol.info/images/emoji/twitter/boom.png?v=9" title=":boom:" class="emoji" alt=":boom:"> <img src="https://forum.rebol.info/images/emoji/twitter/raised_hand_with_fingers_splayed.png?v=9" title=":raised_hand_with_fingers_splayed:" class="emoji" alt=":raised_hand_with_fingers_splayed:"> <img src="https://forum.rebol.info/images/emoji/twitter/electric_plug.png?v=9" title=":electric_plug:" class="emoji" alt=":electric_plug:">  POWER, IN YOUR HANDS! <img src="https://forum.rebol.info/images/emoji/twitter/electric_plug.png?v=9" title=":electric_plug:" class="emoji" alt=":electric_plug:"> <img src="https://forum.rebol.info/images/emoji/twitter/raised_hand_with_fingers_splayed.png?v=9" title=":raised_hand_with_fingers_splayed:" class="emoji" alt=":raised_hand_with_fingers_splayed:">  <img src="https://forum.rebol.info/images/emoji/twitter/boom.png?v=9" title=":boom:" class="emoji" alt=":boom:">
</h1>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/destructure-dialect/1877">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/destructure-dialect/1877</link>
          <pubDate>Tue, 12 Jul 2022 15:52:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1877</guid>
          <source url="https://forum.rebol.info/t/destructure-dialect/1877.rss">DESTRUCTURE Dialect</source>
        </item>
        <item>
          <title>The &quot;Yada Yada Yada&quot; Operator (...)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>It seemed we could have a shorter way to say <strong><code>to &lt;end&gt;</code></strong> (or <strong><code>thru &lt;end&gt;</code></strong>, they act the same).</p>
<pre><code> &gt;&gt; parse "aabbcc" [some "a" to &lt;end&gt;]
 == ""
</code></pre>
<p>In fact, what you want more often is probably <strong><code>elide to &lt;end&gt;</code></strong>.  Because the <strong><code>&lt;end&gt;</code></strong> combinator currently evaluates to the end position of the series (hence the "" you see above, as the TO returns what its argument evaluates to.)</p>
<pre><code> &gt;&gt; parse "aabbbcc" [some "a" elide to &lt;end&gt;]
 == "a"
</code></pre>
<p>A kind of obvious choice for meaning this would be <strong><code>...</code></strong></p>
<pre><code> &gt;&gt; parse "aabbbcc" [some "a" ...]
 == "a"
</code></pre>
<p><sub><em>(Initially I was skeptical of using <code>...</code> without some decoration, and did this with the TAG! of <code>&lt;...&gt;</code>, but I think the reasons I was skeptical are probably not good reasons, and we should go ahead and make it  easier on the eyes and easier to type.)</em></sub></p>
<h2>But Why Should It Only Work At The End?</h2>
<p>This seems useful:</p>
<pre><code> &gt;&gt; parse "aabbbcc" [... some "b" ...]
 == "b"
</code></pre>
<p>But isn't that just a synonym for THRU, with the exception that if there's nothing to go THRU it assumes you mean <code>&lt;end&gt;</code> ?</p>
<p><em>Well, a synonym for THRU isn't really what you want.</em>  You'd probably like this to work:</p>
<pre><code> &gt;&gt; parse "aabbbcc" [... some "x" | some "b" ...]
 == "b"
</code></pre>
<p>In essence, you want it to implicitly wrap anything to the right--up to the next <code>&lt;...&gt;</code>--in a BLOCK!, so act equivalently to:</p>
<pre><code> &gt;&gt; parse "aabbbcc" [thru [some "x" | some "b"] elide to &lt;end&gt;]
 == "b"
</code></pre>
<p>That's not possible for a normal combinator, you'd need a variadic one.</p>
<p>Today's approximation of variadic combinators is to just special-case the implementation directly in the BLOCK! combinator.</p>
<p><strong>So...that's what I've done!</strong></p>
<p>A more elegant way of writing the feature may come down the pipe someday.  But this gives us a version we can use in the here and now.</p>
<p>It's experimental, so use with caution.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/man_scientist.png?v=9" title=":man_scientist:" class="emoji only-emoji" alt=":man_scientist:"></p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-yada-yada-yada-operator/1876">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-yada-yada-yada-operator/1876</link>
          <pubDate>Tue, 12 Jul 2022 14:55:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1876</guid>
          <source url="https://forum.rebol.info/t/the-yada-yada-yada-operator/1876.rss">The &quot;Yada Yada Yada&quot; Operator (...)</source>
        </item>
        <item>
          <title>Semantics of UPARSE&#39;s FURTHEST</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Upon the announcement of UPARSE, <a class="mention" href="/u/brett">@Brett</a> listed as his <a href="https://forum.rebol.info/t/introducing-uparse-the-hackable-usermode-parse/1529/4">secondmost missing feature</a> the idea of knowing "how far a parse got":</p>
<blockquote>
<ol start="2">
<li>An ability to return the furthest input point matched and the rule that caused rollback from there on parse failure. During development of rules this generally indicates the rule that is not properly specified.</li>
</ol>
</blockquote>
<p>I implemented a wrapper around combinators which basically got control before each combinator, and after.  Every parser that succeeded I'd look at how far it said it got in the input...and if that was further than the previous "furthest" it would bump it.</p>
<p><strong>But what happens when a combinator calls a parser that succeeds, but that success isn't used?</strong></p>
<p>Examples would be things like AHEAD, or TO:</p>
<pre><code> &gt;&gt; [result furthest]: uparse "aabbcc" [to "bb"]
 ; how can FURTHEST be "bbcc" and not "cc"
</code></pre>
<p>TO iterates, checking to see if "aabbcc" matches, then if "abbcc" matches, then finds a match at "bbcc".</p>
<p>But the reason it found a match at "bbcc" is that it ran "bb" on that and got "cc".  The "bb" combinator has the wrapper, and so FURTHEST got pushed.</p>
<p><strong>TO and AHEAD actually used to work on accident, before <a href="https://forum.rebol.info/t/output-variables-in-multi-return/1859">changing multi-returns</a>, because they didn't ask for the remainder from the parser parameter that they called.</strong></p>
<p>Previously the nature of multi-return was that you'd actually get the variable to write to as the multi-return parameter.  This made them compatible with historical refinements like /NEXT of DO that passed variables, and was just an alternative syntax for that.  It's far superior to do proxying to those variables at the end of the function...and allow the multi-return to be read and written as a normal variable.</p>
<p>But when you could see the variable, there was the ability to choose a different behavior when it was a "BLACKHOLE" indicator (#) that you weren't planning to use the result.</p>
<p>So the TO combinator would pass in a blackhole saying it wasn't planning on using the remainder of the parser it was calling on each iteration.  This meant the wrapper actually didn't find out how far the combinator TO called got, because there was no variable to write to.  If it tried to read the <strong>index of</strong> it would fail, so the protection of not updating furthest "just did the right thing".</p>
<p><strong>But that's not a general solution...</strong></p>
<p>There was a parallel problem with rollback, where not all succeeding parsers were supposed to contribute to an in-progress COLLECT.  This led to the PENDING mechanism, where some parsers had to explicitly route the output and say "yes, I want this to be collected".</p>
<p><em>(Hence combinators don't "roll back" collections, they just don't commit to routing what they aggregate from component parsers until they are finished.)</em></p>
<p>Which leads to the discovery of a quirk... TO does not manage its pending explicitly...it uses the default "auto-routing".  Hence the success of the last parser it calls--whose advancement it doesn't want--counts in a collect:</p>
<pre><code>&gt;&gt; uparse "aabbcc" [collect to [some keep "b"], elide [2 "b" 2 "c"]]
== ["b" "b"]
</code></pre>
<p>Is that right?  (cc: <a class="mention" href="/u/rgchris">@rgchris</a>)</p>
<p>If so, it means <em>"I want to consider the called parser's pending results, yet I don't want to incorporate its advancement in FURTHEST."</em></p>
<p>That would rule out something I was pondering, which was if there was some way of tying those two things together (only advance furthest if the pendings are used).</p>
<h2>Pathology Studies: How About MINMATCH?</h2>
<p>I made MAXMATCH as a case study of different approaches to influence on COLLECT:</p>
<p><strong><a href="https://github.com/metaeducation/ren-c/blob/8ed60125a473fe285e56213f82a6e7e4fa1d9e5a/tests/parse/examples/maxmatch.parse.test.reb">maxmatch.parse.test.reb</a></strong></p>
<p>Similarly we could ask about MINMATCH, and what its participation with FURTHEST should be.</p>
<p>MINMATCH wouldn't have the crutch of not having asked for the remainder from its component parsers.  So it wouldn't have worked accidentally.</p>
<p>It could call two parsers...have both succeed...and then only advance the smaller amount of the two.  We might say this "foils" a wrapper-based approach to updating furthest, as it would be advanced by the larger amount.</p>
<h2>At The Moment, TO and AHEAD Skew FURTHEST a Bit Far</h2>
<p>I can't stop the presses and not incorporate the multi-return change.  So right now, you get this:</p>
<pre><code>&gt;&gt; [result furthest]: uparse "aabbcc" [to "bb"]
; null

&gt;&gt; furthest
== "cc"
</code></pre>
<p>I'm hesitant to burden combinator authors with another parameterization just for this feature.</p>
<p>I am a little bit wondering if it's worth it to convey to a function that a multi-return result is "requested, but will not be written back to a variable".  There are some optimizations functions might make that are pertinent to that.  So we might be able to go back to how it used to be where if the remainder is requested as a "blackhole" then the furthest is not updated.  It could fix TO and AHEAD.</p>
<p>But MINMATCH would still be the kind of thing that would raise questions.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/semantics-of-uparses-furthest/1868">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/semantics-of-uparses-furthest/1868</link>
          <pubDate>Sat, 09 Jul 2022 12:21:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1868</guid>
          <source url="https://forum.rebol.info/t/semantics-of-uparses-furthest/1868.rss">Semantics of UPARSE&#39;s FURTHEST</source>
        </item>
        <item>
          <title>A Cry for HELP</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Help System</category>
          <description><![CDATA[
            <p><a class="mention" href="/u/jhgorse">@jhgorse</a>  was trying out <a href="https://forum.rebol.info/t/enter-the-dungeon-if-you-dare/1865">the Amazing 3-D Dungeon Simulator</a>, and wandered into the console to poke at the HELP.  Several things there don't work.</p>
<ul>
<li>
<p>Some of it is just weirdness people added and then never backed it up with their support, like <strong>help <a class="hashtag" href="https://forum.rebol.info/tag/compiling">#<span>compiling</span></a></strong> <em>(was that something I was supposed to write, about compiling the source?  well forget that, either way.)</em></p>
</li>
<li>
<p>Some commands aren't relevant (?), like UPGRADE</p>
<ul>
<li>
<p>Rather than have a different HELP summary for the console that removes these commands, they could just be stubs... like UPGRADE could say "you are already running the latest version".</p>
</li>
<li>
<p>...or perhaps it would do a force refresh of the page if it checks and notices a mismatch between the last greenlit version and your current one?  But that seems like make-work to me, at least at the moment.</p>
</li>
</ul>
</li>
<li>
<p>Some things suck, like SOURCE.  I wish we could do more here...especially in terms of pointing you at the GitHub or file location where something was defined.  <a href="https://forum.rebol.info/t/use-the-source/1212/5">But I've explained some of the difficulties.</a></p>
<ul>
<li>We need to put our heads together on that and get something that's useful.</li>
</ul>
</li>
</ul>
<p><em>I can't really chase down everything to make a polished experience AND do the core work.</em>  So I thought I'd pull out a call to <a class="mention" href="/u/iarnold">@iArnold</a>, <a class="mention" href="/u/ingohohmann">@IngoHohmann</a>, <a class="mention" href="/u/blackattr">@BlackATTR</a> and anyone else who can just <strong><a href="https://github.com/hostilefork/replpad-js/issues">start opening issues on the ReplPad GitHub</a></strong> and helping cross them off.</p>
<p>It would be great if there were PRs fixing the issues.  But a lot of it isn't even about writing the code, just inventorying and deciding what things should <em>do</em>.</p>
<p>Obviously there's a whole level beyond this of having a "interactive tutorial" or cool instructional YouTube videos that might be able play in a tab while you code on the right.  (Wonder if there's some easy way to get code snippets to sync with a video so people can copy from that part and try it themselves?)  Some experiments in those directions would be great.</p>
<p>But simple steps help too.  If people could get in the spirit of bug bashing and polishing...and then hopefully adding tests to make sure the efforts don't regress... I think things could get noticeably better step by step.</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/a-cry-for-help/1867">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/a-cry-for-help/1867</link>
          <pubDate>Wed, 06 Jul 2022 15:57:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1867</guid>
          <source url="https://forum.rebol.info/t/a-cry-for-help/1867.rss">A Cry for HELP</source>
        </item>
        <item>
          <title>Rebol2 Desktop... in a ReplPad tab?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Web</category>
          <description><![CDATA[
            <p>In a 2019 demo, <a class="mention" href="/u/rgchris">@rgchris</a> showed off his HTML Rebol2/View-like file browser:</p>
<div class="onebox lazyYT lazyYT-container" data-youtube-id="sM7uGKCZMl0" data-youtube-title="Chris Ross-Gill's Dialects and Personal Projects in Rebol" data-parameters="feature=oembed&amp;wmode=opaque&amp;start=153">
  <a href="https://www.youtube.com/watch?v=sM7uGKCZMl0" target="_blank" rel="noopener">
    <img class="ytp-thumbnail-image" src="https://i.ytimg.com/vi/sM7uGKCZMl0/maxresdefault.jpg" title="Chris Ross-Gill's Dialects and Personal Projects in Rebol" width="690" height="388">
  </a>
</div>

<p>With programs like <a href="https://forum.rebol.info/t/enter-the-dungeon-if-you-dare/1865">dungeon.reb</a> running in the browser, it seems we should have a list and let you browse them similarly...!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/rebol2-desktop-in-a-replpad-tab/1866">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rebol2-desktop-in-a-replpad-tab/1866</link>
          <pubDate>Wed, 06 Jul 2022 13:30:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1866</guid>
          <source url="https://forum.rebol.info/t/rebol2-desktop-in-a-replpad-tab/1866.rss">Rebol2 Desktop... in a ReplPad tab?</source>
        </item>
        <item>
          <title>Should &quot;Arity-2 INTO&quot; in UPARSE actually just be... PARSE?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>There's a cool feature that UPARSE's INTO is willing to take a rule that gives the boundaries of the data you want to copy, and will make the copy for you:</p>
<pre><code>&gt;&gt; uparse "(1 1 1)" [
    into [between "(" ")"] [data: &lt;here&gt; (print mold data) some integer!]
]
</code></pre>
<p>That will give you:</p>
<pre><code>"1 1 1"  ; notice no ")" because the INTO copied the data spanning the rule
== 1
</code></pre>
<p><em>(I threw in the INTEGER! transcode for fun there.  Note that Red allows the transcoding rules for datatypes as well, but only on BINARY! input series. It's because they don't have UTF-8 everywhere, they'd have to rewrite their scanner to process variable-width strings. One of the uncountable Ren-C design advantages...)</em></p>
<p>More generally, you can pass any variable you want to INTO.</p>
<pre><code>&gt;&gt; uparse [1 2 3] [some integer! into ("aaa") some "a"]
== "a"
</code></pre>
<h2>But... Couldn't We Just Call That PARSE?</h2>
<p>This arity-2 INTO takes an input, and rules.  Why isn't that just PARSE?</p>
<p>Difference is that since it's inside a parse already, its first parameter will be treated as a rule and use the synthesized result...unless you put it in a GROUP!.  But that's implicit.  Maybe call it SUBPARSE to be clear?</p>
<p>It would free up the keyword INTO, maybe to be compatible with historical single-arity version, for cases that have already figured out they're at a series value and don't want to repeat themselves by giving a rule that matches where they know they are.</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/should-arity-2-into-in-uparse-actually-just-be-parse/1864">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-arity-2-into-in-uparse-actually-just-be-parse/1864</link>
          <pubDate>Wed, 06 Jul 2022 03:53:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1864</guid>
          <source url="https://forum.rebol.info/t/should-arity-2-into-in-uparse-actually-just-be-parse/1864.rss">Should &quot;Arity-2 INTO&quot; in UPARSE actually just be... PARSE?</source>
        </item>
        <item>
          <title>&quot;Bincode&quot;</title>
          <dc:creator><![CDATA[rgchris]]></dc:creator>
          <category>R3C</category>
          <description><![CDATA[
            <p><a href="https://github.com/rgchris/Scripts/blob/master/rebol-2/bincode.r">'Bincode'</a> is the working name I've given to a pair (well, trio) of functions designed to work with binary formats. I know my general approach here isn't altogether unique, but I think in implementation it has some qualities of its own that I at least have found to be endearing.</p>
<h1>Consume (+ Advance)</h1>
<p>CONSUME takes a reference to a BINARY! and a named binary datatype (such as 'SIGNED-32, 'FLOAT-64, etc) or an INTEGER!, returns that value (or errors out if there's not enough input) and updates the reference to the point after said value.</p>
<pre><code class="lang-nohighlight">source: #{010003}
consume source 'signed-16
; returns 64, source =&gt; #{03}
</code></pre>
<p>Additionally CONSUME can take a BLOCK! in which shorthand functions for the various datatypes are available:</p>
<pre><code class="lang-nohighlight">source: #{03010203}
values: collect [
    consume source [
        loop unsigned-8 [
            keep unsigned-8
        ]
    ]
]
; values =&gt; [1 2 3], source =&gt; #{}
</code></pre>
<p>ADVANCE simply skips a given INTEGER! amount.</p>
<h1>Accumulate</h1>
<p>ACCUMULATE goes in the reverse direction using the same shorthand functions:</p>
<pre><code class="lang-nohighlight">accumulate #{} [
    utf-8 65
    utf-8 8212
    float-64 pi
    repeat x 3 [
        unsigned-8 x
    ]
]
; =&gt; #{41E28094400921FB54442D18010203}
</code></pre>
<p>This snippet is another pass at creating a single-pixel PNG image (with an assist from a R2 DEFLATE wrapper):</p>
<pre><code class="lang-nohighlight">chunkify: func [
    target [binary!]
    header [word!]
    data [binary!]
    /compress
][
    header: as-binary form header

    if compress [
        data: deflate/envelope data 'zlib
    ]

    accumulate target [
        unsigned-32 length? data
        accumulate header
        accumulate data
        accumulate crc32-checksum-of join header data
    ]
]

probe accumulate png: #{} [
    accumulate #{
        89504E47
        0D0A1A0A
    }

    chunkify png 'IHDR #{
        00000001
        00000001
        08 02 00 00 00
    }

    chunkify/compress png 'IDAT #{
        00 CC0000
    }
    
    chunkify png 'tEXt join #{} [
        "Title" null "Single Pixel!"
    ]

    chunkify png 'IEND #{}
]
</code></pre>
<h1>Notes</h1>
<p>Fairly sure this is bait for a lot of where Ren-C has gone with uparse/streaming/ports etc. That's fine, what I'm looking for is the vocabulary that stretches over a handful of common file formats (including <a href="https://forum.rebol.info/t/backtrack-zip/1860">Zip</a>). I don't necessarily think that this is a silver bullet, though it has worked well enough to be used in that domain with enough clarity to make adjustments and retain readability. Doesn't seem too much of a stretch to consider this sitting over a stream or even compressed stream too.</p>
            <p><small>7 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/bincode/1863">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/bincode/1863</link>
          <pubDate>Wed, 06 Jul 2022 01:00:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1863</guid>
          <source url="https://forum.rebol.info/t/bincode/1863.rss">&quot;Bincode&quot;</source>
        </item>
        <item>
          <title>Agree-To-Disagree Points: Places I See Both Sides</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>R3C</category>
          <description><![CDATA[
            <p>I thought I would make a thread for deviations from Rebol2 that I consider to be matters-of-taste, as opposed to where I think there's a hard "right vs. wrong", and provide the code to reverse the decision.</p>
<p><em>(Please discuss the issues on the linked posts--not here.)</em></p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/agree-to-disagree-points-places-i-see-both-sides/1862">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/agree-to-disagree-points-places-i-see-both-sides/1862</link>
          <pubDate>Tue, 05 Jul 2022 00:53:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1862</guid>
          <source url="https://forum.rebol.info/t/agree-to-disagree-points-places-i-see-both-sides/1862.rss">Agree-To-Disagree Points: Places I See Both Sides</source>
        </item>
        <item>
          <title>Backtrack: PDF</title>
          <dc:creator><![CDATA[rgchris]]></dc:creator>
          <category>R3C</category>
          <description><![CDATA[
            <p>This backtrack is semi-related to the <a href="https://forum.rebol.info/t/backtrack-zip/1860">Zip Backtrack</a> and expands on the dialect principle used for the Zip/Build function.</p>
<p>It's a departure from the Parse-approach to dialecting and one that I took to try to sail a little closer to the way PDFs are structured.</p>
<p><a href="https://gist.github.com/rgchris/884be89a396a7e4259d1197ad172fcf6">PDF Experiment</a></p>
<h1>Create</h1>
<p>The <code>pdf/create</code> function takes a <code>block!</code> and evaluates its contents in a context containing helper functions. The result should be a completely modeled PDF document ready for serialization:</p>
<pre><code class="lang-auto">doc: pdf/create [
    info [
        title "A Document"
        author "@rgchris"
    ]

    add-page 640x480 [
        ; supported colors:
        ; RGB 0.0.0 - 255.255.255
        ; Gray 0 - 100
        ; CMYK 0.0.0.0 - 100.100.100.100
        ;
        set-fill 0.100.100.0
        set-pen 0.0.0.0

        ; several helper functions are available in page context for
        ; altering the graphics state
        ;
        set-line-width 2

        ; other helper functions apply graphics to the page
        ;
        draw none non-zero [
            rectangle 20x20 600x440
        ]

        draw line none [
            rectangle 530x370 50x50
        ]

        set-dash-array [4 5] 2
        set-line-cap 'round

        draw line none [
            move-to 0x0
            curve-to
                as-pair 0 page/height
                as-pair page/width 0
                as-pair page/width page/height
        ]
    ]

    add-page 200x200 [
        set-pen 204.0.0
        set-fill 10
        set-line-width 2

        ; PUSH creates an isolated graphics state in which changes
        ; do not affect subsequent graphics operations
        ;
        push [
            set-pen 80

            draw line none [
                repeat offset 21 [
                    move-to as-pair 0 offset - 1 * 10 0
                    line-to as-pair 200 offset - 1 * -10 + page/height
                ]
            ]
        ]

        ; this retains the red pen from before the PUSH
        ;
        draw line even-odd [
            rectangle 20x85 30x30
        ]
    ]

    ; fonts/text not yet implemented, this is a no-op
    ;
    add-font /Helvetica [
        spec
    ]
]
</code></pre>
<p>Some functions can be used outside the <code>pdf/create</code> context:</p>
<pre><code class="lang-auto">pdf/add-page doc 400x200 [
    set-pen 10

    draw line non-zero [
        move-to reduce [
            50 page/height - 50
        ]

        line-to 50x100
        line-to 100x100
        line-to 100x50
        close-path
    ]
]
</code></pre>
<p>The model can be serialized using the <code>pdf/render</code> function:</p>
<pre><code class="lang-auto">probe pdf/render doc
</code></pre>
<h1>Relevance</h1>
<p>The context-sensitive functions give both an appearance of dialecting and the transparency and rigor of being regular functions. I think the function specialization in Ren-C would really make this an efficient and scalable approach.</p>
            <p><small>6 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/backtrack-pdf/1861">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/backtrack-pdf/1861</link>
          <pubDate>Mon, 04 Jul 2022 20:51:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1861</guid>
          <source url="https://forum.rebol.info/t/backtrack-pdf/1861.rss">Backtrack: PDF</source>
        </item>
  </channel>
</rss>

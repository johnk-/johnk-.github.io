<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Domains - AltRebol</title>
    <link>https://forum.rebol.info/c/domains/15</link>
    <description>Topics in the &#39;Domains&#39; category Applications of Rebol in various specialized subject domains.</description>
    
      <lastBuildDate>Fri, 06 Dec 2024 12:30:01 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/domains/15.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Should (1 + #A) Equal (#A + 1) ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>I ran across this peculiarity:</p>
<pre><code>rebol2&gt;&gt; 1 + #"A"
== 66

rebol2&gt;&gt; #"A" + 1
== #"B"
</code></pre>
<p>Red and R3-Alpha do this too.</p>
<p>Loosely speaking, there's an internal policy which is something along the lines of <em>"if the types don't match, convert the second operand into the type of the first, and then do the add"</em>.</p>
<p>Because of this, it's necessary to support the addition of characters to each other to get <strong>(<span class="hashtag-raw">#A</span> + 1)</strong> to work:</p>
<pre><code>red&gt;&gt; #"A" + #"B"
== #"^(83)"  ; only useful in implementation of old coercion rule
</code></pre>
<p>...which seems nonsensical to me.</p>
<h2><a name="p-7963-what-do-other-languages-do-1" class="anchor" href="https://forum.rebol.info#p-7963-what-do-other-languages-do-1"></a>What Do Other Languages Do?</h2>
<p>If "implicit type promotion" is supported, many languages, including C, C++, and Java, use a system where the "smaller" type is converted to the "larger" type (<a href="https://pages.mtu.edu/~shene/COURSES/cs201/NOTES/chap02/exp-2.html">e.g., int to float</a>).  Having an idea of what's bigger and what's smaller helps avoid the commutativity problem.</p>
<p>And in the specific case of adding characters to integers, Rebol is weird to give a different answer depending on order.</p>
<ul>
<li>
<p><strong>Python:</strong> In Python, adding an integer to a character (or vice versa) would raise a TypeError. Python doesn't implicitly convert between these types.</p>
</li>
<li>
<p><strong>JavaScript:</strong> JavaScript would convert the character to its ASCII value and perform integer addition in both cases, resulting in a number.</p>
</li>
<li>
<p><strong>Ruby:</strong> Similar to Python, Ruby would raise a TypeError when trying to add an integer to a character.</p>
</li>
<li>
<p><strong>Java:</strong> Java doesn't allow direct addition between char and int types without explicit casting.</p>
</li>
</ul>
<p>I think adding integers to characters and wanting a character back is the more common operation, so if it's legal, I'd advocate for:</p>
<pre><code>&gt;&gt; 1 + #A
== #B

&gt;&gt; #A + 1
== #B
</code></pre>
<p>But if we want to rule out addition of characters to characters (which I do) this commutative behavior doesn't fall out from a system of implicit conversion with an ordering on "bigger" types... since characters are smaller.</p>
<p>I don't see an obvious "rule" besides hardcoding it.</p>
<h2><a name="p-7963-what-about-commutativity-in-general-2" class="anchor" href="https://forum.rebol.info#p-7963-what-about-commutativity-in-general-2"></a>What About Commutativity In General?</h2>
<p>We can imagine decisions on what you would make <strong><code>+</code></strong> mean that would not be commutative.  For instance, if you were allowed to make it mean "join strings":</p>
<pre><code>&gt;&gt; "abc" + "def"
== "abcdef"

&gt;&gt; "def" + "abc"
== "defabc"
</code></pre>
<p>So you might try and argue that the rules for <strong>add</strong> are different than the rules for <strong>+</strong>, and it's only when + is acting as ADD that it enforces commutativity.  However... even in the domain of math, you have exceptions... e.g. matrix multiplication is not commutative.</p>
<p>The more general question of commutativity seems to be that there aren't any popular languages that do it automatically.  e.g. in C++ you have to overload <strong><code>operator+(T1,T2)</code></strong> and <strong><code>operator+(T2,T1)</code></strong> separately...one of them can call the other, but that never happens automatically.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-1-a-equal-a-1/2346">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-1-a-equal-a-1/2346</link>
          <pubDate>Fri, 06 Dec 2024 12:30:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2346</guid>
          <source url="https://forum.rebol.info/t/should-1-a-equal-a-1/2346.rss">Should (1 + #A) Equal (#A + 1) ?</source>
        </item>
        <item>
          <title>The %rebol.r Boot File From Rebol 1.0</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>While we don't have the C source code for Rebol 1.0, we do have the <code>%rebol.r</code> initialization file:</p>
<p><a href="https://gist.github.com/hostilefork/d6cfac90141688bd41b1b38a9a203b02" class="inline-onebox">Rebol 1.0.2 Initialization File (October 7, 1998) · GitHub</a></p>
<p>It would seem that if there were an ability to pack source code in with the executable, they would have done it...given that the Quick Start says <em>"do not modify <code>rebol.r</code>. If you accidentally do modify <code>rebol.r</code>, reinstall it."</em></p>
<p><em><strong>Hence this is probably the entire portion of Rebol 1.0 that's written in Rebol, e.g. the whole "Mezzanine".</strong></em></p>
<p>It says:</p>
<pre><code>;;; Note: Code in rebol.r runs in the system context.  The system
;;; context [has] all the built in bindings of the user context, but also
;;; has extra bindings to allow rebol to be bootstrapped.  Many of the 
;;; rebol functions available in user code are actually written in
;;; terms of simpler rebol natives, or in terms of special
;;; system natives.

;;; REBOL reserves the right to change the system natives at any time, 
;;; so you shouldn't depend on them for portable code.
</code></pre>
<h1><a name="p-7953-remarks-on-contents-in-no-particular-order-1" class="anchor" href="https://forum.rebol.info#p-7953-remarks-on-contents-in-no-particular-order-1"></a>Remarks On Contents, In No Particular Order</h1>
<h2><a name="p-7953-func-definition-2" class="anchor" href="https://forum.rebol.info#p-7953-func-definition-2"></a>FUNC Definition</h2>
<pre><code>func: make function! [args body] [make function! :args :body]
</code></pre>
<p>I found it a bit interesting that the <a href="https://forum.rebol.info/t/rebol-1-0-2-users-guide/2340/6#p-7944-func-shortcut-5">User Guide talked about how FUNC was defined</a>, as an illustrative example, of an important thing for users to know about.  (It turns out there's a <a href="https://www.rebol.com/docs/core23/rebolcore-9.html">brief mention in the Rebol2 User's Guide</a>, but the Rebol 1.0 Guide writes it up twice, probably on accident.)</p>
<p>It's worth pointing out that there's big questions even in this seemingly simple definition.  Such as, should a function copy its arguments or body?  What should this do?</p>
<pre><code> body: [print "Hello"]
 foo: func [] body
 append body [print "Goodbye"]
 bar: func [] body
</code></pre>
<p>Does <strong>foo</strong> print just "Hello", or does it print "Hello" and "Goodbye"?</p>
<p>I don't yet know what Rebol1 did, but Rebol2's MAKE FUNCTION! would <em>not</em> copy the body.  So FUNC would do a deep copy as the "higher level" operator, before passing it to MAKE FUNCTION!.</p>
<p>But during bootstrap, it used a definition of FUNC that <em>didn't</em> copy the body, for performance reasons...which it switched over to the copying implementation at the end of boot.  <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=12" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></p>
<p>Some version of these crazy optimizations are on the table for future Ren-C.</p>
<h2><a name="p-7953-print-prin-probe-3" class="anchor" href="https://forum.rebol.info#p-7953-print-prin-probe-3"></a>PRINT, PRIN, PROBE</h2>
<pre><code>write-block-or-element:
    make function! [port element] [
             do
                if block? :element [:write-block] else [:form-to-port]
                :port
                :element]

write-block: func [port block] [    ; !!! needs work
    foreach element :block [form-to-port :port :element form-to-port :port " "]
]

prin: func [value] [
    if block? :value [write-block output-port reduce :value]
    else [form-to-port output-port :value]
    exit
]

print: func [value] [
    prin :value
    linefeed-port output-port
    exit
]

probe: func [value] [
     prin " PROBE --&gt; "
     send output-port :value
     linefeed-port output-port
     :value
 ]
</code></pre>
<p>Weird.  (and prints a space after every element, so you get a space at the end of the line vs. just delimited between, etc.)</p>
<p>At least one interesting aspect of this is to see the rigid "EXIT" at the end to make sure that PRIN and PRINT don't leak a result on accident.  Things like this feel like a vindication of Ren-C's <a href="https://forum.rebol.info/t/implicit-execution-of-return-in-functions-bad/1656">requirement to use a RETURN</a> in order to give back a result from FUNC (but not LAMBDA).</p>
<h2><a name="p-7953-is-as-to-logic-4" class="anchor" href="https://forum.rebol.info#p-7953-is-as-to-logic-4"></a>IS? as TO-LOGIC</h2>
<pre><code>is?: func [value] [not not :value]
</code></pre>
<p>This was called TRUE? in Rebol2, and I very much disliked the ambiguity of that vs. testing to see if a value was <code>= #[true]</code> the LOGIC! literal.</p>
<p>I wrote something up about <a href="http://blog.hostilefork.com/did-programming-opposite-of-not/">how DID could be the opposite of NOT</a> (which even goes together as DIDN'T for DID NOT).  But due to some various shades of meaning the current state is that it means THEN? and DIDN'T means ELSE? as prefix tests for the trigger conditions that would run THEN or ELSE.  It needs thought.</p>
<p>Anyway, interesting to see the choice of <code>IS?</code> here.</p>
<h2><a name="p-7953-a-recursive-folding-any-and-all-interrobang-5" class="anchor" href="https://forum.rebol.info#p-7953-a-recursive-folding-any-and-all-interrobang-5"></a>A Recursive Folding ANY and ALL <img src="https://forum.rebol.info/images/emoji/twitter/interrobang.png?v=12" title=":interrobang:" class="emoji" alt=":interrobang:" loading="lazy" width="20" height="20"></h2>
<pre><code>any: func [block] [
    eval-one block
        make function! [value rest] [
            if not value [any rest]
            else [value]
        ]
        make function! [value] [value]
]

all: func [block] [
    eval-one block
        make function! [value rest] [
            if is? value [all rest]
            else [false]
        ]
        make function! [value] [value]
]
</code></pre>
<p>So this is based on a function called EVAL-ONE, that takes a list and two functions.  It isn't defined in %rebol.r and isn't in the reference guide either.  But it's a right fold with early termination.</p>
<p>One can definitely imagine the Joe Marshall and Carl friction on this (<em>"why are you making all these usermode functions and calls, why not just use a loop?"</em>).</p>
<p>While there's a time and a place for this, I do think that if you are starting to push out into the usermode layers and finding this mentality is driving it...you're going to end up with something that isn't hitting the mark that Rebol was aiming at.</p>
<h2><a name="p-7953-why-is-pick-so-weird-6" class="anchor" href="https://forum.rebol.info#p-7953-why-is-pick-so-weird-6"></a>Why Is PICK So Weird?</h2>
<pre><code>pick: func [series index] [
  do make function! [offset] [
    if (:offset + index? :series) &lt;= 1
        [none]
    else [do make function! [disp] [
            if (length? :disp) = 0 
               [none]
            else
               [&amp;peek :disp 0]
            ] skip :series if :offset &lt; 0 [:offset] else [:offset - 1]
         ]
    ] if logic? :index [if :index [1] else [2]] else [:index]
]
</code></pre>
<p>My guess here is that the pattern:</p>
<pre><code>do make function! [arg] [...code with arg...] value-for-arg
</code></pre>
<p>...is probably some holdover from before USE existed.  Or maybe USE is just an abstraction built on functions, and so it's done this way for optimization.  I dunno.</p>
<h2><a name="p-7953-poor-mans-export-7" class="anchor" href="https://forum.rebol.info#p-7953-poor-mans-export-7"></a>Poor-Man's EXPORT</h2>
<pre><code>;;; These functions can be defined in terms of system natives that are
;;; not available in the user context.  Since we made the functions in 
;;; this context, the values of the words in the body are relative to
;;; this context.  But we place the functions in the user context so
;;; that the users can call them.  This allows the user to call the
;;; system natives through a defined API in a controlled manner.

user-functions: [
    dir? [file] [do func [info] [info/dir?] info? :file]
    size? [file] [do func [info] [info/size] info? :file]
    ...
]

foreach [name args body] user-functions [
    context-set user-context name func args body
]
</code></pre>
<p>So the comment says what's going on here, it's the attempt to push functions out into the user context when they're implemented in terms of functions that aren't available in the user context.  I'm not sure what's not available <em>(these implementations of DIR? and FILE? are based on INFO?, is that not exported to the user context?)</em></p>
<p>As far as I know, there's nothing like this in Rebol2 (there's no separate <code>user-context</code> from a <code>system-context</code>, is there?)  Interesting if that was something that disappeared in Rebol2 and came back in Rebol3.</p>
<h2><a name="p-7953-more-modularization-eval-reduce-takes-context-8" class="anchor" href="https://forum.rebol.info#p-7953-more-modularization-eval-reduce-takes-context-8"></a>More Modularization: EVAL-REDUCE Takes Context</h2>
<pre><code>if not none? REBOL/script [
    if exists? REBOL/script [
        do make function! [] [
                top-level-continuation: :return
                if not REBOL/silent [
                        linefeed
                        prin "Loading script "
                        print REBOL/script]
                eval-reduce [do REBOL/script] user-context
                ]
        ]
    ]
</code></pre>
<p>Rebol1 seems to have been working with modularization ideas, because even during startup, the script you pass on the command line is run via something called EVAL-REDUCE that takes a parameter of where to do the evaluation.</p>
<p>So definitely a shame that Rebol2 seems to have moved away from the idea that evaluations needed to be done in a context.</p>
<h2><a name="p-7953-catch-is-defined-in-terms-of-catch-func-9" class="anchor" href="https://forum.rebol.info#p-7953-catch-is-defined-in-terms-of-catch-func-9"></a>CATCH is defined in terms of CATCH-FUNC</h2>
<p>We know from the <code>user-functions</code> exporting that this:</p>
<pre><code>catch [word block] [catch-func func reduce [word] :block]
</code></pre>
<p>Is actually:</p>
<pre><code>catch: func [word block] [catch-func func reduce [word] :block]
</code></pre>
<p>Since there's no type checking, there's a <code>:BLOCK</code> GET-WORD! just to be sure it's not a function, I guess?  And then it's FUNC's job to do a check in its implementation.  But then, why not <code>:WORD</code> just to be sure WORD! isn't a function you're calling?  <em>(I like pointing this out, due to Ren-C's better answers to this issue...avoiding the "pox of documenting what you <strong>don't</strong> know")</em></p>
<p>So the idea of using functions as proxies for "virtual binding" is the <em>old way</em>.  What's going on here is that the block contains code that wants to be bound to whatever the throw construct is, and so that block is made the body of a function, that you call and pass the thing you want bound to that name as the argument.  (COLLECT+KEEP worked this way).  But it's undesirable, because it means you've lost the fluidity of having the currency of a structural BLOCK!...replaced with the black box of a function just because you wanted to bind something.</p>
<p>I'm pretty sure this CATCH mechanic (being called a "continuation") is stackful and can't do anything too bizarre, but I'd like an executable to try and ensure that.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-rebol-r-boot-file-from-rebol-1-0/2344">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-rebol-r-boot-file-from-rebol-1-0/2344</link>
          <pubDate>Sun, 01 Dec 2024 12:40:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2344</guid>
          <source url="https://forum.rebol.info/t/the-rebol-r-boot-file-from-rebol-1-0/2344.rss">The %rebol.r Boot File From Rebol 1.0</source>
        </item>
        <item>
          <title>UPARSE Combinator Return Conventions: Reviewed</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>UPARSE was an early client of multiple return values, at a time when they worked by assigning variables local to your frame, which were then proxied to items in a SET-BLOCK!:</p>
<pre><code> /multi-returner: func [
     return: [integer!]
     secondary: [integer!]  ; SET-WORD! indicated another return
 ][
     secondary: 20
     return 10
 ]

 &gt;&gt; [ten twenty]: multi-returner
 == 10

 &gt;&gt; ten
 == 10

 &gt;&gt; twenty
 == 20
</code></pre>
<p>This basically made every multi-return function a kind of infix operation, that was able to take a SET-BLOCK! on its left hand side.  <a href="https://forum.rebol.info/t/multiple-return-values-via-infix/1257">(In fact, it was prototyped using infix.)</a></p>
<p>But this method had composability problems, and was defeated by abstraction of any sort, even the most minor forms:</p>
<pre><code> &gt;&gt; [ten twenty]: (multi-returner)
 ** Error: even this wouldn't work
</code></pre>
<p>So the method gave way to returning antiform BLOCK!s.  These represented parameter packs that would "decay" to their first item in most circumstances...but SET-BLOCK!s were one of the cases that could pick them apart (though you could design other operations as well).</p>
<pre><code> /multi-returner: func [
     return: [~[integer! integer!]~]
 ][
     return pack [10 20]
 ]
</code></pre>
<p>You can read all about it in <strong><a href="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134">The History of Multi-Return in Ren-C</a></strong></p>
<h2><a name="p-7932-so-local-proxies-diedbut-uparse-mimicked-them-1" class="anchor" href="https://forum.rebol.info#p-7932-so-local-proxies-diedbut-uparse-mimicked-them-1"></a>So Local Proxies Died...But UPARSE Mimicked Them</h2>
<p>Just because the mechanics got rid of local proxies doesn't mean you can't fake them.  All you have to do is hack up its RETURN function to make a PACK using a local variable.</p>
<p>Simplified example:</p>
<pre><code> /proxy-multi-func: adapt func/ [
      body: compose $() inside body '[
          /return: adapt return/ [
             atom: pack [(unmeta atom) secondary]
          ]
          (as group! unbind body)  ; I wish this pattern were simpler
      ]
 ]

 /multi-returner: proxy-multi-func [
     return: [integer!]
     &lt;local&gt; secondary  ; could be specially marked, if spec rewritten
 ][
     secondary: 20
     return 10
 ]
</code></pre>
<p>So when the multi-return-by-antiform-block change happened, this is what COMBINATOR did instead of transition to having every combinator do <strong><code>return pack [synthesized remainder]</code></strong></p>
<p>Instead it worked the same as before: you'd set <strong>remainder</strong> however you wished, do <strong>return synthesized</strong>.  Except now the specialization of RETURN would PACK things up.</p>
<h2><a name="p-7932-why-did-combinator-preserve-proxying-2" class="anchor" href="https://forum.rebol.info#p-7932-why-did-combinator-preserve-proxying-2"></a>Why Did COMBINATOR Preserve Proxying?</h2>
<p>Well... for starters, to show that it could be done.  You <em>should</em> be able to do it.  So having a living test case to hammer through any issues was good.</p>
<p>Also, because some combinators have two return values (synthesized and remainder), while others add a third (pending).  In truth the combinator always needs to return a pack of 3, it's just that some combinators automatically pipe the pending results from successful combinators to the output.  This means even if your combinator returned a pack of 2 in the piped case, that would have to be broken apart and turned into a pack of 3.  Having it in components helps.</p>
<p>But generally, I think it makes the code clearer as well.  Saying <strong><code>(return pack [x y])</code></strong> doesn't have any labeling, while <strong><code>(remainder: y, return x)</code></strong> is somewhat clearer, and you don't need to label the "primary" result because that's understood as what the combinator is synthesizing.</p>
<h2><a name="p-7932-synthesized-cant-be-proxied-unless-meta-3" class="anchor" href="https://forum.rebol.info#p-7932-synthesized-cant-be-proxied-unless-meta-3"></a>Synthesized Can't Be Proxied (unless ^META)</h2>
<p>It's worth pointing out that there's a sort of design constraint here, when you're going to break out multi-return results and have them represented by local variables which are proxied by an adjusted RETURN...</p>
<p>...and that constraint is that you can't put unstable antiforms in variables.  So if you have something you want to return like an antiform pack (as combinators can legitimately synthesize), it has to be the main return result.</p>
<p>So since they use this proxying, combinators kind of break the rule of thumb of "don't make unstable antiforms your primary return in a multi-return situation".  This is because if you do:</p>
<pre><code>return pack [pack [1 2] "a"]
</code></pre>
<p>Then you face some ambiguity in terms of what people might think <strong><code>([x y]: multi-return-func)</code></strong> should mean... or what <strong><code>(x: multi-return-func)</code></strong> should mean.</p>
<p>But really, this is still being worked out.</p>
<h2><a name="p-7932-anyway-just-wanted-to-sum-up-uparse-return-4" class="anchor" href="https://forum.rebol.info#p-7932-anyway-just-wanted-to-sum-up-uparse-return-4"></a>Anyway, Just Wanted To Sum Up UPARSE RETURN</h2>
<p>I was questioning it, and wanted to kind of work through why it is the way it is.  But I think it's right.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/uparse-combinator-return-conventions-reviewed/2337">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/uparse-combinator-return-conventions-reviewed/2337</link>
          <pubDate>Thu, 28 Nov 2024 00:35:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2337</guid>
          <source url="https://forum.rebol.info/t/uparse-combinator-return-conventions-reviewed/2337.rss">UPARSE Combinator Return Conventions: Reviewed</source>
        </item>
        <item>
          <title>Dimension Conversions in Arturo</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>Here is a table of dimensions used by <a href="https://forum.rebol.info/t/arturo-rebol-inspired-language/1370">Arturo</a>, expressed as a table in the Nim language:</p>
<p><a href="https://github.com/arturo-lang/arturo/blob/master/src/vm/values/custom/quantities/definitions.nim" class="inline-onebox">arturo/src/vm/values/custom/quantities/definitions.nim at master · arturo-lang/arturo · GitHub</a></p>
<p>It's a pretty impressive compendium.  And there's also some "heavily macro-driven" Nim code that implements conversion operations:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/970992fb6919f5b8f0bb350bcbff2390f350cab0.jpeg" data-download-href="https://forum.rebol.info/uploads/default/970992fb6919f5b8f0bb350bcbff2390f350cab0" title="Screenshot_2024-10-11_at_07.40.49"><img src="https://forum.rebol.info/uploads/default/optimized/1X/970992fb6919f5b8f0bb350bcbff2390f350cab0_2_371x375.jpeg" alt="Screenshot_2024-10-11_at_07.40.49" data-base62-sha1="ly8BQYMZcqhc44hu8VlGzNKezNS" width="371" height="375" srcset="https://forum.rebol.info/uploads/default/optimized/1X/970992fb6919f5b8f0bb350bcbff2390f350cab0_2_371x375.jpeg, https://forum.rebol.info/uploads/default/optimized/1X/970992fb6919f5b8f0bb350bcbff2390f350cab0_2_556x562.jpeg 1.5x, https://forum.rebol.info/uploads/default/original/1X/970992fb6919f5b8f0bb350bcbff2390f350cab0.jpeg 2x" data-dominant-color="312113"></a></div><p></p>
<p><a class="mention" href="https://forum.rebol.info/u/drkameleon">@drkameleon</a> cites <a href="https://frinklang.org/">Frink</a> as the main inspiration for this, though assembling the table and conversion code was original work on the order of months.</p>
<h2><a name="p-7841-why-not-use-arturo-for-the-table-1" class="anchor" href="https://forum.rebol.info#p-7841-why-not-use-arturo-for-the-table-1"></a>Why Not Use Arturo For The Table...?</h2>
<p>The table is Nim code...and as such, beholden to having a lot of repetition and commas.</p>
<p>So of course my first question was <em>"why not express it as Arturo, and then spit out the Nim table as part of the build process"</em>?</p>
<p>Instead of:</p>
<pre><code>#-----------------------------------------------------------------------
# Length units (base: m)
#-----------------------------------------------------------------------
#       name  symbol  prefix?    definition      aliases
#-----------------------------------------------------------------------
defUnit "in",  "in", false,  "127:5000 m",      "inch", "inches"
defUnit "ang",  "Å", false,  "1:10000000000 m", "angstrom", "angstroms"
defUnit "px",  "px", true,   "1:96 in",         "pixel", "pixels"
</code></pre>
<p>It could be reduced down to something more like this:</p>
<pre><code>    === LENGTH (base: m) ===

     in [127:5000 m] inch inches
    ang [1:10000000000 m] angstrom angstroms ("Å")
   */px [1:96 in] pixel pixels
</code></pre>
<p>The meaning of "prefix?" is actually "prefixable?" that a type can have a prefix. e.g. pixels is prefixable because you can say <strong><code>Mpx</code></strong> for "megapixels".  So I think some prefixing decoration on the type is a nice way to convey this.  I just threw in <strong><code>*/px</code></strong> as an example--though I gather that in Arturo that would be <strong><code>*\px</code></strong></p>
<p>Though when I first saw some isolated instance of the colon notation I didn't realize it was a ratio.  Ren-C could do this as a CHAIN! or as a PATH!.  I think my first instinct would have been path:</p>
<pre><code>     in [127/5000 m] inch inches
    ang [1/10000000000 m] angstrom angstroms ("Å")
   *.px [1/96 in] pixel pixels
</code></pre>
<p>But it actually looks a bit better with the colons I think.</p>
<p>Some notation would be nice for the pluralization.  It's one of the places where the <a href="https://forum.rebol.info/t/no-interstitial-delimiter-sequence-proposal-fused/1503">FUSED! proposal</a> might come in handy:</p>
<pre><code>     in [127:5000 m] inch{es}
    ang [1:10000000000 m] angstrom{s} ("Å")
   */px [1:96 in] pixel{s}
</code></pre>
<p>You can use tuples or paths, but it's not quite as neat...although the paths aren't terrible:</p>
<pre><code>     in [127:5000 m] inch.es
    ang [1:10000000000 m] angstrom.s ("Å")
   */px [1:96 in] pixel.s

     in [127:5000 m] inch/es
    ang [1:10000000000 m] angstrom/s ("Å")
   */px [1:96 in] pixel/s
</code></pre>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/dimension-conversions-in-arturo/2314">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dimension-conversions-in-arturo/2314</link>
          <pubDate>Fri, 11 Oct 2024 07:09:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2314</guid>
          <source url="https://forum.rebol.info/t/dimension-conversions-in-arturo/2314.rss">Dimension Conversions in Arturo</source>
        </item>
        <item>
          <title>Barriers to Source-To-Source Transformations</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>General Tools</category>
          <description><![CDATA[
            <p><strong>Doing source-to-source transformations <em>seems</em> like something Rebol would be great at.</strong></p>
<p>Why not LOAD your file (powered by TRANSCODE)... do some structural tweaks, and spit it back out again with SAVE (powered by MOLD).  What could be simpler?</p>
<p>But the first thing you'll notice is: <strong>Oops, all your comments are gone.</strong></p>
<p>Next you'll see <strong>the indentation and spacing is almost all thrown out</strong>.  Cells in arrays store a NEWLINE_BEFORE marker to record if they had a newline before them (and there's an additional NEWLINE_AT_TAIL marker on the array as a whole)...but that's all you get.  MOLD just uses some heuristics to indent the code in a canon style.</p>
<h2><a name="p-7839-vague-proposals-appear-then-fizzle-1" class="anchor" href="https://forum.rebol.info#p-7839-vague-proposals-appear-then-fizzle-1"></a>Vague Proposals Appear, Then Fizzle</h2>
<p>If you wait long enough, someone will suggest that there be a mode in which TRANSCODE doesn't toss out the whitespace information, but keeps it around somehow.</p>
<p>One terrible version of this idea actually interleaves weird values into the arrays, where your processing code would have to skip it:</p>
<pre><code>&gt;&gt; transcode:verbatim "a b  c   d"
== [a b #[space! 2] c #[space 3] d]
</code></pre>
<p>That is a complete dead end, as it would mean any transformation code you used could not be shared with "normal code".</p>
<p>So what you'd need instead would be some way to expand out that NEWLINE_BEFORE flag into richer information.  But cells use pretty much all their bits (although there are 32 bits free in the headers of cells in the 64 bit build...however I'd be loathe to use it for this.)</p>
<p>One idea would be to load the data into the cells as in the :VERBATIM example above, except have operations skip over them as if they weren't there.</p>
<ul>
<li>
<p>On the one hand, this this would fundamentally screw with the "simple" design the language is aiming for.</p>
</li>
<li>
<p>On the other hand, this is essentially what UTF-8 Everywhere does for <strong><code>String</code></strong> in managing the series length (in codepoints) as being independent of the number of physical units (in bytes).  It would just be extending that logic to <strong><code>Array</code></strong>, meaning arrays would have to be enumerated with a function like <code>Skip_Element()</code> or <code>Step_Back_Element()</code> instead of just incrementing a pointer with ++ and --.</p>
</li>
<li>
<p>I've actually thought about moving away from pure pointer incrementing and decrementing in order to allow arrays to be built out of discontiguous segments, which could help several scenarios in optimization...with reconciliation into contiguous bits being done on an as-needed basis.</p>
</li>
</ul>
<p>Another concept would be to have cells be able to "redirect" the <strong><code>Extra</code></strong> pointer in the second slot, and set a header flag saying "the Extra in this cell can be found by following the pointer in the extra slot".  And then that can point to an allocation somewhere that holds the formatting information.</p>
<h2><a name="p-7839-not-happening-any-time-soon-but-worth-remembering-2" class="anchor" href="https://forum.rebol.info#p-7839-not-happening-any-time-soon-but-worth-remembering-2"></a>Not Happening Any Time Soon, But Worth Remembering</h2>
<p>I can't hold Ren-C's interesting ideas hostage to such things, there's too much other stuff going on.</p>
<p>But noticing the similarity of the UTF-8 Everywhere transition to the idea of skipped formatting cells...and then tying that into what could be the advantages of discontiguous arrays...got me to think.</p>
<p>We could perhaps have discontiguous strings as well--leveraging illegal UTF-8 bytes as the signal of pointers embedded in the data.  It might be interesting if the mechanics could be merged.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/barriers-to-source-to-source-transformations/2313">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/barriers-to-source-to-source-transformations/2313</link>
          <pubDate>Fri, 11 Oct 2024 02:23:03 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2313</guid>
          <source url="https://forum.rebol.info/t/barriers-to-source-to-source-transformations/2313.rss">Barriers to Source-To-Source Transformations</source>
        </item>
        <item>
          <title>FENCE! In PARSE: What Should It Do?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>FENCE! is coming soon.  How soon?  ...soon.</p>
<p>When it gets here I'm going to want to kick the tires a bit with purposes in dialects.  And so of course a big question is: <strong>What will FENCE! do in PARSE?</strong>  <em>(By default, I mean...you can override it with whatever FENCE! combinator you want.)</em></p>
<p>It <em>might</em> seem an obvious use for it would be to make objects, e.g. act as GATHER:</p>
<p>So instead of:</p>
<pre><code>&gt;&gt; parse "aaabbb" [
      gather [
          emit x: collect some ["a", keep (&lt;a&gt;)]
          emit y: collect some ["b", keep (&lt;b&gt;)]
      ]
  ]
== make object! [
    x: [&lt;a&gt; &lt;a&gt; &lt;a&gt;]
    y: [&lt;b&gt; &lt;b&gt; &lt;b&gt;]
]
</code></pre>
<p>You might imagine writing:</p>
<pre><code>&gt;&gt; parse "aaabbb" [
      {
          x: collect some ["a", keep (&lt;a&gt;)]
          y: collect some ["b", keep (&lt;b&gt;)]
      }
  ]
== make object! [
    x: [&lt;a&gt; &lt;a&gt; &lt;a&gt;]
    y: [&lt;b&gt; &lt;b&gt; &lt;b&gt;]
]
</code></pre>
<p><strong>But I don't know if that's obviously a great application.</strong></p>
<p>We shouldn't be thinking inside-the-box that just because FENCE! is used for making objects sometimes, that's the most pressing need for them in dialects.  I actually think GATHER does a good enough job at what it does...and I think the above example reads more clearly with it.</p>
<p>But I've pointed to other rather weak areas, <strong><a href="https://forum.rebol.info/t/implicit-capture-in-parse-how-to-get-it/1718">like how we don't have implicit capture</a></strong>.</p>
<pre><code>parse isodate [
    year: between &lt;here&gt; "-"
    month: between &lt;here&gt; "-"
    day: between &lt;here&gt; "T"
    ...
]
</code></pre>
<p>I'm not saying this is what we should use fences for, but just to kick-off that "outside-the-box" brainstorm:</p>
<pre><code>parse isodate [{year} "-" {month} "-" {day} "T" ...]
</code></pre>
<p>If my only choices were between that and an alternate for GATHER+EMIT, I'd pick that, because I think we'd get a lot more mileage out of it.</p>
<p>Remember also that there are lots of variations, like <strong><code>${...}</code></strong> and <strong><code>:{...}</code></strong> and whatever combinations in paths in chains and tuples you can think of.  Ideally how it's used makes some sense across these variants.  But we should remember that dialecting is about serving the domain, not making sacrifices to some god-of-consistency.</p>
<p><strong>Anyway...it's going to take time to build up a sense of what being "fency" means.</strong></p>
<p>But if any pet applications start coming to mind, pitch them.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/fence-in-parse-what-should-it-do/2312">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/fence-in-parse-what-should-it-do/2312</link>
          <pubDate>Thu, 10 Oct 2024 18:52:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2312</guid>
          <source url="https://forum.rebol.info/t/fence-in-parse-what-should-it-do/2312.rss">FENCE! In PARSE: What Should It Do?</source>
        </item>
        <item>
          <title>Dialecting Function Calls: New, Weird, Powerful</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>The advent of the <a href="https://forum.rebol.info/t/introducingnew-chain-datatype/2226">CHAIN! datatype</a> has provoked the idea of <em>dialecting function calls themselves</em>.</p>
<p>I've given examples like pointing the variable to blame for a failure...because you often don't really want an error message to implicate the location where the error itself is raised, but rather some callsite arbitrarily far up the stack.</p>
<p>The proposal I had for this was to change:</p>
<pre><code>fail:blame ["This failure will implicate VAR at callsite"] $var
</code></pre>
<p>Into:</p>
<pre><code>fail:$var ["This failure will implicate VAR at callsite"]
</code></pre>
<p>Another idea I mentioned was the concept of folding the function you want to use as a predicate into the chain.  At first I suggested allowing these names to conflate with what looked like a refinement:</p>
<pre><code>&gt;&gt; any:even? [1 3 8 7 10]
== 8
</code></pre>
<p>The rationalizing I used was to say "Well, in dialects we have cases where if a keyword isn't recognized then it falls back to looking up the word."   That's how PARSE works... like in this historical case:</p>
<pre><code>red&gt;&gt; begin: "[" end: "]"
== "]"

red&gt;&gt; parse "[aaa]" [begin copy stuff to end skip]
== false
</code></pre>
<p>Er, so maybe I should say "that's how PARSE doesn't work".  In any case, the END keyword overrode the END variable definition.  But BEGIN matched, because there's no parse keyword for BEGIN.</p>
<p><em>(Note: This is a reason why Ren-C uses <strong><code>&lt;end&gt;</code></strong> the tag combinator instead of END the word combinator...and other tag combinators for noun-like things.)</em></p>
<p>So maybe it's not the best plan to follow the lead there.  Another idea would be to use a TYPE-WORD!</p>
<pre><code>&gt;&gt; any:&amp;even? [1 3 8 7 10]
== 8
</code></pre>
<p>It's a little clunkier, but it's clearer what's going on.  In this case, the predicate is a single arity function which returns NULL or OKAY...and that's what ANY wants, so it's a particularly good match.</p>
<p>That also works for my suggestion of <strong><code>quote:&amp;word?</code></strong> and <strong><code>meta:&amp;raised?</code></strong>.  Though it implies that if you composed them together you'd have to say <strong><code>quote:&amp;quote:&amp;word?</code></strong>, and it doesn't look as good as <strong><code>quote:quote:word?</code></strong></p>
<p>Also...in this case the predicate is a single arity function that returns a logic.  But other cases aren't, and wouldn't make sense to use <code>&amp;</code>.  What about them?</p>
<h2><a name="p-7835-is-conflation-stupid-or-outside-the-box-genius-1" class="anchor" href="https://forum.rebol.info#p-7835-is-conflation-stupid-or-outside-the-box-genius-1"></a>Is Conflation Stupid, Or Outside-The-Box Genius?</h2>
<p>I can't really tell if allowing you to write the likes of <strong><code>any:even?</code></strong> and proceeding blissfully along outweighs the missing "conscious marker" of why EVEN? wouldn't be any refinement you can find on the HELP for ANY.</p>
<p>Part of me thinks "that's the way this game is played".  Another part of me is thinking about how the system wouldn't know what to do with this.  How would the system know how to specialize that, and put EVEN? into the :PREDICATE slot?  Would <strong><code>any:even?/</code></strong> just throw up its hands and error?  For that matter, does <strong><code>any:&amp;even?/</code></strong> really get any easier?</p>
<p><strong>I guess that aspect of "it doesn't get any easier either way" suggests we have room to experiment and see how it feels.</strong></p>
<p>Actions would have to have some kind of "Interpret Chain" hook that would go from CHAIN! =&gt; FRAME!.  Because this is likely to be performance sensitive, the system should offer some kind of parameterization of the default hook (e.g. "if you don't recognize anything from the spec, fetch it and throw it into parameter named XXX" or "if you see something with a certain sigil, fetch it and throw it into a parameter named YYY")</p>
<p>I guess I'd like to try living in the <strong><code>any:even?</code></strong> and <strong><code>meta:raised?</code></strong> universe a bit and get a bit more informed before making the stupid vs. genius verdict.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/dialecting-function-calls-new-weird-powerful/2310">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dialecting-function-calls-new-weird-powerful/2310</link>
          <pubDate>Tue, 08 Oct 2024 17:59:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2310</guid>
          <source url="https://forum.rebol.info/t/dialecting-function-calls-new-weird-powerful/2310.rss">Dialecting Function Calls: New, Weird, Powerful</source>
        </item>
        <item>
          <title>Parsing/Destructuring a QUOTED! or QUASIFORM!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Quoteds (and quasiforms) can be seen kind of as containers...</p>
<p>But there isn't a good way to destructure them at the moment.</p>
<p>One off-the-cuff idea would be that you could SUBPARSE into them:</p>
<pre><code>&gt;&gt; parse ['a:] [subparse quoted! set-word!]
== a:

&gt;&gt; parse [''a:] [subparse quoted! subparse quoted! set-word!]
== a:

&gt;&gt; parse [~(a b c)~] [subparse quasiform! subparse group! [some word!]]
== c
</code></pre>
<p>A bit of a belabored method.  And because combinators require a series, I can't think of any efficient way to do that (vs. fabricating an array to hold a single item, and parsing that as a series.)  But it's better than no method at all.</p>
<p><strong>UPDATE:</strong> Having come up with a strategy for <a href="https://forum.rebol.info/t/typechecking-quoted-forms-quasiforms-antiforms/2298">doing constraints like <strong><code>quote:quote:block?</code></strong></a>, it seems that covers a lot of use cases:</p>
<pre><code>&gt;&gt; parse ['a:] [&amp;quote:set-word!]
== a:

&gt;&gt; parse [''a:] [&amp;quote:quote:set-word!]
== a:

&gt;&gt; parse [~(a b c)~] [subparse &amp;quasi:group! [some word!]]
== c
</code></pre>
<p>It would require SUBPARSE to be willing to go inside quoted lists, which is easy enough to permit (and no reason not to, since it has to pass the type check you know what you're doing).</p>
<p>Seems to be reasonably powerful...just have to make peace with this strange new world of <em>dialecting the act of calling functions itself.</em> (!)</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/parsing-destructuring-a-quoted-or-quasiform/2300">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/parsing-destructuring-a-quoted-or-quasiform/2300</link>
          <pubDate>Fri, 27 Sep 2024 21:59:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2300</guid>
          <source url="https://forum.rebol.info/t/parsing-destructuring-a-quoted-or-quasiform/2300.rss">Parsing/Destructuring a QUOTED! or QUASIFORM!</source>
        </item>
        <item>
          <title>ENVELOP (and COMPOSE!) By Example</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Prior to splices, we were considering rethinking <strong>append/only [a b c] [d e]</strong> as <strong>append [a b c] only [d e]</strong>, where ONLY would just envelop its argument in a block.</p>
<p><a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> didn't care for the name:</p>
<aside class="quote no-group" data-username="rgchris" data-post="1" data-topic="1873">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/48/14_2.png" class="avatar"><a href="https://forum.rebol.info/t/1873/1">On another topic</a></div>
<blockquote>
<p>Correct me if I'm wrong, but this proposed ONLY function would simply create a single value cell with the block reference, which would seem pretty efficient.</p>
<p>It'd be very easy to shim:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">only: func [value][
    reduce [value]
]
</code></pre>
<p>I'm still fond of ENVELOP over BLOCKIFY as a name. I don't think ONLY would make the cut. Naming is tricky as it is sort of a hack—it's purpose is to make a block a singular value but in actuality it is creating a new value of which the old one just happens to be the only content.</p>
</blockquote>
</aside>
<p>As it happens, ONLY defined in this way stuck around for a while.  (I actually thought it had been deleted, but it turns out it was hiding as **<code>only*</code>, so just finally deleted it now!)</p>
<p>I agree that ENVELOP is a better and more useful name for the category of operations.  Today we have ENBLOCK and ENGROUP:</p>
<pre><code>&gt;&gt; enblock [a b c]
== [[a b c]]

&gt;&gt; enblock &lt;tag&gt;
== [&lt;tag&gt;]

&gt;&gt; engroup [a b c]
== ([a b c])

&gt;&gt; engroup &lt;tag&gt;
== (&lt;tag&gt;)
</code></pre>
<p>But there's no generalized ENVELOP.</p>
<h2><a name="p-7757-envelop-by-example-seems-like-an-important-construct-1" class="anchor" href="https://forum.rebol.info#p-7757-envelop-by-example-seems-like-an-important-construct-1"></a>"Envelop by Example" Seems Like an Important Construct</h2>
<pre><code>&gt;&gt; something: 1020

&gt;&gt; word: 'something  ; demo behavior when unbound (binding from context)

&gt;&gt; envelop '[] word
== [something]

&gt;&gt; envelop '() word
== (something)

&gt;&gt; envelop '@[] word  ; would work with sigil-decorated types
== @[something]

&gt;&gt; envelop '(()) word  ; could work with nested envelopes
== ((something))
</code></pre>
<p>There's a big advantage in passing in a block or group "by example".  It means you can implicitly pass along a binding, which can be integrated in the same step...if that's what you want.  (The modern art of writing Ren-C code requires a lot of consciousness about the decision to use bound or unbound material.)</p>
<pre><code>&gt;&gt; eval envelop '(()) word  ; quoting means no binding
** Error: something not defined

&gt;&gt; eval envelop $(()) word  ; if binding passed in, it's used
== 1020
</code></pre>
<p>ENVELOP might even support <a href="https://forum.rebol.info/t/synthetic-asymmetric-delimiters/1893">Synthetic Asymmetric Delimiters</a></p>
<pre><code>&gt;&gt; envelop '(| |) word
== (| something |)

&gt;&gt; envelop '(|) word  ; shorthand--assume paired?
== (| something |)

&gt;&gt; envelop '(&lt;*&gt;) word  ; maybe not assume, for COMPOSE marker compatibility
== (&lt;*&gt; something)
</code></pre>
<h2><a name="p-7757-engroup-and-enblock-still-useful-2" class="anchor" href="https://forum.rebol.info#p-7757-engroup-and-enblock-still-useful-2"></a>ENGROUP and ENBLOCK Still Useful</h2>
<p>I do think that ENGROUP and ENBLOCK as specializations of ENVELOP turn out to be what you'll use at least 90% of the time...so they're worth having around.</p>
<p>But as arity-1 functions, the returned block or group would be unbound at its tip.  So you'd have to use the ENVELOP-by-example to pass in a binding.</p>
<h2><a name="p-7757-this-overlaps-the-morph-proposalhttpsforumrebolinfotsetify-plainify-getify-symify-or-morph1334-somewhat-3" class="anchor" href="https://forum.rebol.info#p-7757-this-overlaps-the-morph-proposalhttpsforumrebolinfotsetify-plainify-getify-symify-or-morph1334-somewhat-3"></a>This Overlaps <a href="https://forum.rebol.info/t/setify-plainify-getify-symify-or-morph/1334">the MORPH Proposal</a> Somewhat</h2>
<p>MORPH has the ability to change the decorations on the value you're passing in, whereas ENVELOP would assume you wanted the item as-is, just enclosed in some other stuff.</p>
<p>My instinct is to say that this takes the pressure off MORPH to be all things to all people... vs. the idea that we don't need ENVELOP and it should just become a subfeature of morph.  But I dunno.</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/envelop-and-compose-by-example/2294">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/envelop-and-compose-by-example/2294</link>
          <pubDate>Mon, 23 Sep 2024 12:43:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2294</guid>
          <source url="https://forum.rebol.info/t/envelop-and-compose-by-example/2294.rss">ENVELOP (and COMPOSE!) By Example</source>
        </item>
        <item>
          <title>Should AND + OR Handle VOID?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>Ren-C has infix AND and OR, which are conditional--not bitwise.  Since #[true] and #[false] no longer exist, they now act on things being "branch triggers" or not...which is basically "non-null things vs. null".</p>
<p>So we have for instance:</p>
<pre><code>      null and null   -&gt;   ~null~ antiform     
   null and (thing)   -&gt;   ~null~ antiform
   (thing) and null   -&gt;   ~null~ antiform
(thing) and (thing)   -&gt;   ~okay~ antiform
</code></pre>
<p>Today's rule is that THING is any non-null, non-void thing.  VOID causes an error.</p>
<h2>
<a name="including-void-would-be-more-flexible-worth-it-1" class="anchor" href="https://forum.rebol.info#including-void-would-be-more-flexible-worth-it-1"></a>Including VOID Would Be More Flexible.  Worth It?</h2>
<pre><code>      void and void   -&gt;   ~void~ antiform
      void and null   -&gt;   ~null~ antiform
      null and void   -&gt;   ~null~ antiform
   void and (thing)   -&gt;   ~okay~ antiform
   (thing) and void   -&gt;   ~okay~ antiform
</code></pre>
<p>The VOID*VOID=VOID would give you an error if you tried <strong><code>if void-thing and void-thing [...]</code></strong>, which seems good to me.</p>
<p>It's strictly more powerful.  Going along with the general idea that "Errors aren't big enablers of creativity", I am leaning toward endorsing it.</p>
<p>Particularly because accidental creation of VOID has been pruned further than ever.  It's not something you can ever pick out of blocks.  And with type checking there'll be even more confidence that those who are doing this are doing it intentionally.</p>
<p>It's not a priority.  But I can see how it could be useful.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-and-or-handle-void/2274">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-and-or-handle-void/2274</link>
          <pubDate>Fri, 13 Sep 2024 08:49:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2274</guid>
          <source url="https://forum.rebol.info/t/should-and-or-handle-void/2274.rss">Should AND + OR Handle VOID?</source>
        </item>
        <item>
          <title>GUI Example From Red&#39;s GitHub Issue Database</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>GUI</category>
          <description><![CDATA[
            <p>I've said I'm going to endure the pain of looking at GUI dialect code on a weekly basis, and my first attempt to do so was <a href="https://forum.rebol.info/t/cave-in-gui-game-in-red/2209/1">2 weeks ago</a>, so I guess I am overdue...</p>
<p>Here is some code from an Issue in Red's GitHub: <strong><a href="https://github.com/red/red/issues/5511">"VID on Ubuntu Doesn't Right Align"</a></strong></p>
<pre><code>view [
  group-box 3 [
    text blue white right "Before Stream: "
    beforeStreamDisplay: text blue white "None"
    button "Select file" [beforeStreamDisplay/text: (to string! request-file)]

    text blue white right "Delta Stream: "
    deltaStreamDisplay: text blue white "None"
    button "Select file" [deltaStreamDisplay/text: (to string! request-file)]
  ]
  panel 3 [
    text blue white right "Before Stream: "
    f-3: text blue white "None"
    button "Select file" [f-3/text: (to string! request-file)]

    text blue white right "Delta Stream: "
    f-4: text blue white "None"
    button "Select file" [f-4/text: (to string! request-file)]
  ] return
]
</code></pre>
<p>The result of that is:</p>
<p><img src="https://forum.rebol.info/uploads/default/original/1X/566c6c3f848924e0fee6bb811e5a0c1d46f33492.png" alt="340416458-8a27fe88-9fa4-4a08-9f82-cf0782e13b17" data-base62-sha1="ckxm9zYNEMxQIJISX5246OnJJPY" width="430" height="105"></p>
<p>I tried the code on my local Red EXE on Windows, and it did work.</p>
<hr>
<h2><a name="p-7590-lets-try-and-unpack-that-1" class="anchor" href="https://forum.rebol.info#p-7590-lets-try-and-unpack-that-1"></a>Let's Try And Unpack That</h2>
<p>So it says <strong>view [...]</strong>.  My understanding is that VIEW's job is to handle a tree of layout objects.  So I'm going to guess that the LAYOUT instruction is implicit, and that will do the same thing as <strong>view layout [...]</strong></p>
<hr>
<p><img src="https://forum.rebol.info/images/emoji/twitter/star.png?v=12" title=":star:" class="emoji" alt=":star:" loading="lazy" width="20" height="20"> <strong>YES</strong> ... I am correct</p>
<hr>
<h2><a name="p-7590-whats-the-point-of-the-return-at-the-end-of-the-layout-2" class="anchor" href="https://forum.rebol.info#p-7590-whats-the-point-of-the-return-at-the-end-of-the-layout-2"></a>What's The Point of the RETURN at the End of The Layout?</h2>
<p>I've never liked "RETURN" being reused to mean "end current row and start a new one".  Though it's a sort of in-your-face "the dialect can use words however it wants" example.</p>
<p>But the RETURN in this example has nothing that comes after it.  I'm assuming that if you delete that RETURN it has no effect.</p>
<hr>
<p><img src="https://forum.rebol.info/images/emoji/twitter/star.png?v=12" title=":star:" class="emoji" alt=":star:" loading="lazy" width="20" height="20"> <strong>YES</strong> ... as far as I can tell removing it has no effect.  But it seems to be put there intentionally.  Perhaps it's just a habit people get into in order to say "hey, this is as wide as this layout should be, if you're going to add any more stuff to this example it should be on a new 'line'."</p>
<p><img src="https://forum.rebol.info/uploads/default/original/1X/566c6c3f848924e0fee6bb811e5a0c1d46f33492.png" alt="340416458-8a27fe88-9fa4-4a08-9f82-cf0782e13b17" data-base62-sha1="ckxm9zYNEMxQIJISX5246OnJJPY" width="430" height="105"></p>
<hr>
<h2><a name="p-7590-whats-the-number-after-the-panel-or-group-box-3" class="anchor" href="https://forum.rebol.info#p-7590-whats-the-number-after-the-panel-or-group-box-3"></a>What's The Number After the Panel or Group-Box?</h2>
<p>So at the top level here, you've got two panel thingies.  One of these uses a group box and the other doesn't.</p>
<pre><code>view [
  group-box 3 [...]
  panel 3 [...]
  return
]
</code></pre>
<p>Hence I guess that GROUP-BOX is derived from or otherwise inherits its PANEL-ness?</p>
<p>Although what you're getting here are grids, they're passing just <strong>3</strong> instead of <strong>3x2</strong>.  I guess because the 3 is enough to say how many sub-elements you're going to have until kicking it over to a new row.  So if you left it off, that would just put everything all in a horizontal line?</p>
<hr>
<p><img src="https://forum.rebol.info/images/emoji/twitter/star.png?v=12" title=":star:" class="emoji" alt=":star:" loading="lazy" width="20" height="20"> <strong>YES</strong> ... well looky there, I guessed right.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/80ef66a274a8f35e1f148fb7b3651538b6748f2b.png" data-download-href="https://forum.rebol.info/uploads/default/80ef66a274a8f35e1f148fb7b3651538b6748f2b" title="image"><img src="https://forum.rebol.info/uploads/default/original/1X/80ef66a274a8f35e1f148fb7b3651538b6748f2b.png" alt="image" data-base62-sha1="ioC1SwYNNxCUREhStOiH3Prrmxt" width="690" height="66" data-dominant-color="CECEF1"></a></div><p></p>
<p>So supplying the INTEGER! argument to GROUP-BOX and PANEL saves you on the need to put a "RETURN" when you want there to be a break.</p>
<hr>
<h2><a name="p-7590-what-other-parameters-do-panel-and-group-box-have-4" class="anchor" href="https://forum.rebol.info#p-7590-what-other-parameters-do-panel-and-group-box-have-4"></a>What Other Parameters Do PANEL and GROUP-BOX Have?</h2>
<p>The <a href="https://github.com/red/docs/blob/master/en/vid.adoc#7-panels">Red Documentation for VID</a> tells us:</p>
<pre><code>panel &lt;options&gt; [&lt;content&gt;]

&lt;options&gt; : optional list of settings for the panel.
&lt;content&gt; : panel's VID content description (block!).
</code></pre>
<p>...and...</p>
<pre><code>group-box &lt;divider&gt; &lt;options&gt; [&lt;body&gt;]

&lt;divider&gt; : optional number of row or columns (integer!).
&lt;options&gt; : optional list of settings for the panel.
&lt;body&gt;    : panel's VID content description (block!).
</code></pre>
<p>Uh, okay.  Well it seems to me that PANEL was willing to take the "divider" INTEGER! even though it doesn't say it takes it.  And there's no mention of what <code>&lt;options&gt;</code> we have, here.  <a href="https://www.rebol.com/docs/view-guide.html">Rebol Documentation for VID</a> isn't much more helpful.</p>
<p>(But it seems that whatever <code>&lt;options&gt;</code> we do have, it would be confusing if any of them involved blocks.)</p>
<p>They set the color on TEXT with just naming colors after it (background, foreground).  Could I do that, e.g. <strong><code>group-box 3 orange purple</code></strong> and get the box outline to be drawn in purple on an orange background?  If I removed the colors from one of the texts, would it too be purple on orange?</p>
<hr>
<p><img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"> <strong>HALF-RIGHT</strong> ... background is orange, but it seems to ignore the purpleness entirely.  Neither the line drawing the group box nor the text inside the panel inherited the purple.</p>
<p><img src="https://forum.rebol.info/uploads/default/original/1X/9953a0e6e9f23aaa31e5b6915bb4bacdae40b86b.png" alt="image" data-base62-sha1="lSoe1L1ijaJCON5qK7H9HK5ExOX" width="428" height="105"></p>
<hr>
<h2><a name="p-7590-what-if-i-gave-an-invalid-color-5" class="anchor" href="https://forum.rebol.info#p-7590-what-if-i-gave-an-invalid-color-5"></a>What If I Gave an Invalid Color?</h2>
<p>Perhaps it doesn't know <code>purple</code> and wanted <code>magenta</code> or something, and just didn't give an error.  What happens if I give it mispelled colors, like <strong><code>group-box 3 ornage grene</code></strong>?</p>
<p>One would hope it would fail.  But would it fail at the LAYOUT level, or would LAYOUT build a structure that VIEW would choke on?</p>
<p>I'd idly guess that VIEW expects not color WORD!s but to have things resolved to TUPLE!s in the layout objects, so I'm going to guess that GET-ting the words in LAYOUT production would fail... so I'll just try that in a LAYOUT with no VIEW.</p>
<hr>
<p><img src="https://forum.rebol.info/images/emoji/twitter/star.png?v=12" title=":star:" class="emoji" alt=":star:" loading="lazy" width="20" height="20"> <strong>YES</strong> ... I am good at this guessing game.</p>
<pre><code>  red&gt;&gt; layout [group-box 3 ornage grene [...]]
  *** Script Error: VID - invalid syntax at: [
      ornage grene [
         text right "Before Stream: " beforeStreamDisplay: text blue white
</code></pre>
<hr>
<h2><a name="p-7590-button-runs-the-code-in-the-block-when-pushed-6" class="anchor" href="https://forum.rebol.info#p-7590-button-runs-the-code-in-the-block-when-pushed-6"></a>BUTTON Runs The Code In The Block When Pushed</h2>
<p>Okay, in the "fairly obvious" department, I am guessing that if I push the button, it will run the code in the block.</p>
<hr>
<p><img src="https://forum.rebol.info/images/emoji/twitter/neutral_face.png?v=12" title=":neutral_face:" class="emoji" alt=":neutral_face:" loading="lazy" width="20" height="20"> <strong>YES</strong> ... but don't think I deserve any particular gold star for that insight.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/68df1e138012f752c797df7d03ea46aa6d8901ca.png" data-download-href="https://forum.rebol.info/uploads/default/68df1e138012f752c797df7d03ea46aa6d8901ca" title="image"><img src="https://forum.rebol.info/uploads/default/optimized/1X/68df1e138012f752c797df7d03ea46aa6d8901ca_2_517x288.png" alt="image" data-base62-sha1="eXJGp2zqdx9SWPnitZVRwrjm7kS" width="517" height="288" srcset="https://forum.rebol.info/uploads/default/optimized/1X/68df1e138012f752c797df7d03ea46aa6d8901ca_2_517x288.png, https://forum.rebol.info/uploads/default/optimized/1X/68df1e138012f752c797df7d03ea46aa6d8901ca_2_775x432.png 1.5x, https://forum.rebol.info/uploads/default/original/1X/68df1e138012f752c797df7d03ea46aa6d8901ca.png 2x" data-dominant-color="F2F1F4"></a></div><p></p>
<p>The file selection box is the one provided by the OS.  It is modal--you can't move the Red window around or interact to it while the dialog is up.  Multiple selection of files is not enabled by default.  The options for REQUEST-FILE are:</p>
<pre><code>REFINEMENTS:
     /title       =&gt; Window title.
        text         [string!] 
     /file        =&gt; Default file name or directory.
        name         [string! file!] 
     /filter      =&gt; Block of filters (filter-name filter).
        list         [block!] 
     /save        =&gt; File save mode.
     /multi       =&gt; Allows multiple file selection, returned as a block.
</code></pre>
<p><em>(I'll mention that Ren-C has <a href="https://github.com/metaeducation/ren-c/blob/8516f0fca8ddce40a97e7647a087dc55e065cf3b/extensions/view/mod-view.c#L92">REQUEST-FILE for Windows and Linux/GTK</a>.  It was in the Atronix build and I retooled it to leverage the libRebol API pretty nicely, and improved some things about it.  But I don't use it for anything.)</em></p>
<hr>
<h2><a name="p-7590-okay-im-bored-7" class="anchor" href="https://forum.rebol.info#p-7590-okay-im-bored-7"></a>Okay, I'm Bored</h2>
<p>I think I pretty well understand this example.</p>
<p>Looking at the <a href="https://github.com/red/red/issues/5511">original issue</a>, though, I'm empathetic to SkySpiral7's complaint.</p>
<p>If you write:</p>
<pre><code>view [
   text right "Short" return
   text right "Much longer text"
]
</code></pre>
<p>And get:</p>
<p><img src="https://forum.rebol.info/uploads/default/original/1X/0d730c52ad4aab92b8539cab1df80139ef311aca.png" alt="340153948-e25ce4c2-8bef-492c-832d-e1af9f7f9547" data-base62-sha1="1UYHbM327G3gvu3gvN29gyl2Via" width="140" height="115"></p>
<p>Then that seems wrong to me.  If something that simple doesn't work how you'd <em>expect</em> it to, what good is this thing?</p>
<p>And it seems like something more semiotic could be used here for RETURN.</p>
<pre><code>view [
   text right "Short"
   |
   text right "Much longer text"
]
</code></pre>
<p>If single bar is too slight or used for something else, maybe double bar.</p>
<pre><code>view [
   text right "Short"
   ||
   text right "Much longer text"
]
</code></pre>
<p>Dashes? Equals?</p>
<pre><code>view [
   text right "Short"
   ===
   text right "Much longer text"
]
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/gui-example-from-reds-github-issue-database/2257">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/gui-example-from-reds-github-issue-database/2257</link>
          <pubDate>Sat, 07 Sep 2024 05:02:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2257</guid>
          <source url="https://forum.rebol.info/t/gui-example-from-reds-github-issue-database/2257.rss">GUI Example From Red&#39;s GitHub Issue Database</source>
        </item>
        <item>
          <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>R3-Alpha had an idea--carried forward by Red--of an <strong>arity-1</strong> IF combinator.</p>
<pre><code>red&gt;&gt; num: 1020

red&gt;&gt; parse [a a a] [if (even? num) some 'a]
== true

red&gt;&gt; parse [a a a] [if (odd? num) some 'a]
== false
</code></pre>
<p>As you see, if the expression you give it turns out to be "falsey" then it doesn't continue matching.  It skips to the next alternate--if there is one.</p>
<pre><code>red&gt;&gt; parse [a a a] [if (odd? num) some 'b | some 'a]
== true
</code></pre>
<p>But I always thought the arity-1 IF was a pretty alien thing that would confuse people.  You might think there's a branch, but there's no "branch"... just continuing along with the variadic list of everything that follows until the next <strong>|</strong> or end of BLOCK!.</p>
<p>I also wondered "where does it end?"  With an IF combinator, why not a CASE combinator, or SWITCH combinator?</p>
<p>So when I came up with GET-GROUP! doing arbitrary substitutions of the rule it evaluates to, I thought "hey, that's a lot more general!"  We could just say that ~true~ and ~void~ antiforms would continue the parse, ~false~ would stop it, and ~null~ antiforms would trigger an error in case you didn't mean to do that.</p>
<h3><a name="p-7569-what-that-get-group-concept-looked-like-1" class="anchor" href="https://forum.rebol.info#p-7569-what-that-get-group-concept-looked-like-1"></a>What That <code>:(GET-GROUP!)</code> Concept Looked Like</h3>
<p><em>(Note that <strong>if condition '[...]</strong> is equivalent to <strong>if condition [[...]]</strong>.  This is called <a href="https://forum.rebol.info/t/soft-quoted-branching-light-elegant-fast/1020">"soft-quoted branching"</a>)</em></p>
<pre><code>&gt;&gt; num: 1020, rule: null

; generated [some 'b] rule is treated as if it had been written there
&gt;&gt; parse [a a a b b b] [some 'a :(if even? num '[some 'b])]
== b 

; generated ~void~ from non-taken IF gets ignored, and it kept parsing
&gt;&gt; parse [a a a b b b] [some 'a :(if odd? num '[some 'c]) some 'b]
== b

; generated ~true~ signal continues parse, just as ~void~ did
&gt;&gt; parse [a a a b b b] [some 'a :(even? num) some 'b]
== b

; generated ~false~ skips to next alternate (isn't one, so parse fails)
&gt;&gt; parse [a a a b b b] [some 'a :(odd? num) some 'b]
** Error: PARSE BLOCK! combinator did not match input

; treat ~null~ conservatively, use :(maybe rule) for ~void~ to keep going 
&gt;&gt; parse [a a a b b b] [some 'a :(rule) some 'b]
** Error: ~null~ antiform generated by GET-GROUP! in PARSE
</code></pre>
<h2><a name="p-7569-flexible-logichttpsforumrebolinfotflexible-logic-system-terminology2252-kills-true-false-breaks-that-idea-2" class="anchor" href="https://forum.rebol.info#p-7569-flexible-logichttpsforumrebolinfotflexible-logic-system-terminology2252-kills-true-false-breaks-that-idea-2"></a><a href="https://forum.rebol.info/t/flexible-logic-system-terminology/2252">Flexible Logic</a> Kills <code>[~true~ ~false~]</code>... Breaks That Idea</h2>
<p>In the flexible logic model, <code>[TRUE FALSE ON OFF YES NO]</code> are WORD!s, and hence indiscriminately trigger taking the branch in something like an IF when used directly.  The ~null~ antiform is the "branch inhibitor", and it's what conditional expressions return when they don't match the condition.</p>
<pre><code>&gt;&gt; 10 &gt; 20
== ~null~  ; anti
</code></pre>
<p>I don't think it's a good idea to make substitions via GET-GROUP! (or whatever comes to replace it) silently continue on NULL.  If you forgot to set a variable that was supposed to hold something (as in <strong>rule</strong> above), that should give you an error.  But I don't think you should have to write <strong>:(maybe even? num)</strong> <img src="https://forum.rebol.info/images/emoji/twitter/nauseated_face.png?v=12" title=":nauseated_face:" class="emoji" alt=":nauseated_face:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-7569-so-having-a-conditional-logic-combinator-makes-sense-3" class="anchor" href="https://forum.rebol.info#p-7569-so-having-a-conditional-logic-combinator-makes-sense-3"></a>So Having A Conditional Logic Combinator Makes Sense</h2>
<p>I just think that IF is a rather lousy name for it.</p>
<p>So I'll suggest <strong>WHEN</strong>.</p>
<pre><code>&gt;&gt; parse [a a a b b b] [some 'a, when (even? num), some 'b]
== b 
</code></pre>
<p>It would be against the premise of flexible logic to have WHEN be biased and assume things like TRUE, YES, or NO should mean it continues or not.  I like the idea that you could hold a completely arbitrary word in a variable and say <strong><code>when (word)</code></strong>, that means <em>"continue matching when word is set to a non-null value"</em>.</p>
<p>Hence you'd have to say <strong><code>when (true? flag)</code></strong> or <strong><code>when (off? toggle)</code></strong> etc.  I'm not merely <em>comfortable</em> with this... I am gung-ho about it! <img src="https://forum.rebol.info/images/emoji/twitter/comet.png?v=12" title=":comet:" class="emoji" alt=":comet:" loading="lazy" width="20" height="20"></p>
<p>(Of course people can make their own combinators and build in biases of their choosing, the core just doesn't pick sides.)</p>
<h2><a name="p-7569-bypass-can-be-a-synonym-for-when-null-4" class="anchor" href="https://forum.rebol.info#p-7569-bypass-can-be-a-synonym-for-when-null-4"></a>BYPASS Can Be A Synonym For <code>[when (null)]</code></h2>
<p>I didn't like using FAIL for saying when to stop a rule chain and go to the next alternate, because that is used for causing "abrupt failures" in the system.</p>
<p>So I'd been using quasiform <code>~false~</code> the state in source (and the antiform if in a variable).</p>
<pre><code>&gt;&gt; parse [a a a b b b] [some 'a, :(if even? num [false]), some 'b]
** Error: PARSE BLOCK! combinator did not match input

&gt;&gt; parse [a a a b b b] [some 'a, ~false~, some 'b]
** Error: PARSE BLOCK! combinator did not match input
</code></pre>
<p>But that isn't the model anymore.  There is no ~false~ or ~true~ antiform.  And honestly it wasn't that literate anyway. <strong>when (...)</strong> makes it clearer when you're using a variable.  And the quasiform just looks confusing.</p>
<p>Searching for a good word that doesn't run into something serving other purposes (e.g. BREAK), I asked Claude.ai for suggestions, and one of those was BYPASS.</p>
<p>I like it.  So for example you could write:</p>
<pre><code>&gt;&gt; parse [a a a b b b] [some 'a [:(if even? num ['bypass]) some 'c] | some 'b]]
== b
</code></pre>
<p>Although that particular case is clearer as <strong><code>[when (odd? num) ...]</code></strong>, but sometimes you have to throw in a bypass rule.</p>
<p><em>(Amusingly, in Rebol2 the idiom for BYPASS was <strong><code>[end skip]</code></strong>, which was a rule guaranteed to mismatch at any position: either you weren't at the tail and the END wouldn't match, or you were at the tail and the END would match but then you couldn't SKIP.)</em></p>
<h2><a name="p-7569-where-does-it-stop-5" class="anchor" href="https://forum.rebol.info#p-7569-where-does-it-stop-5"></a>Where Does It Stop?</h2>
<blockquote>
<p>I also wondered "where does it end?"  With an IF combinator, why not a CASE combinator, or SWITCH combinator?</p>
</blockquote>
<p>So I think it's good to just say WHEN.</p>
<p>You don't <em>technically</em> need WHEN if you have BYPASS to skip to next alternate, and ~void~ to keep going (or empty block, if you like... <code>[]</code> will keep going too).</p>
<pre><code> when (cond) =&gt; :(if not cond ['bypass])  ; or :(if not cond 'bypass)
</code></pre>
<p>But that forces you to reverse the sense of your logic and write out something longer (and slower).  I think if you've got logic that's complex like a case or switch, then writing it out as a splicing rule would have negligible benefit to try and shoehorn as a combinator.</p>
<h2><a name="p-7569-a-potential-weak-spot-in-for-canon-branch-trigger-6" class="anchor" href="https://forum.rebol.info#p-7569-a-potential-weak-spot-in-for-canon-branch-trigger-6"></a>A Potential Weak Spot In <strong><code>#</code></strong> for Canon Branch Trigger</h2>
<p>It's a given that the ~null~ antiform is the canon "Branch Inhibitor".  It may well be the <em>only</em> branch inhibitor (though I'm considering <a href="https://forum.rebol.info/t/isotopes-and-nan-not-a-number/2245">~NaN~ antiforms</a> might also not trigger branches).</p>
<p>What's more up in the air is what the <em>canon branch trigger</em> is.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2250">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"><a href="https://forum.rebol.info/t/true-false-on-off-yes-no/2250/5">True, False, On, Off, Yes, No...?</a></div>
<blockquote>
<p>I think this all just points to <strong><code>#</code></strong> being the most sensible choice, even though it's not an antiform. You can't have everything.</p>
</blockquote>
</aside>
<p>Before considering WHEN--I was looking at the impacts of using <strong>#</strong> on the GET-GROUP! substitution rules that had been in place.</p>
<p>Previously you could do this:</p>
<pre><code>&gt;&gt; parse #{000000FFFFFF} [zeros: tally #{00} :(odd? zeros) some #{FF}]
== #{FF}

&gt;&gt; parse #{000000FFFFFF} [zeros: tally #{00} :(even? zeros) some #{FF}]
** Error: PARSE BLOCK! combinator did not match input
</code></pre>
<p>But this becomes <em>fully broken</em> with things like EVEN? and ODD? returning either <strong><code>~null~</code></strong> or <strong><code>#</code></strong>.</p>
<pre><code>&gt;&gt; parse #{000000FFFFFF} [zeros: tally #{00} :(odd? zeros) some #{FF}]
** Error: ~null~ antiform generated by GET-GROUP! in PARSE

&gt;&gt; parse #{000000FFFFFF} [zeros: tally #{00} :(even? zeros) some #{FF}]
** Error: PARSE BLOCK! combinator did not match input
</code></pre>
<p>The second case didn't match because since things like <strong><code>#a</code></strong> are character literals, <strong><code>#</code></strong> has been used to represent the 0 codepoint.  So in BINARY! it matches that.</p>
<pre><code>&gt;&gt; append #{DECAFBAD} #
== #{DECAFBAD00}

&gt;&gt; parse #{000000} [some #]
== #
</code></pre>
<p><em>(Having the # combinator synthesize # vs 0 is debatable.  But it wouldn't be #{00}.  We don't want matching combinators to make new series--they only return their own series argument which is already allocated.)</em></p>
<p>And if you had a BLOCK! it would match <strong>#</strong></p>
<pre><code>&gt;&gt; data: [a a a # b b b]

&gt;&gt; parse data [some 'a :(true? trailing-b) some 'b]
== b  ; great!  we know the block is all As and Bs!  (oh, WHOOPS!)
</code></pre>
<p>This is part of why I was saying the canon branch trigger should be an antiform--because it gets pushed out of band for things like this.</p>
<p>But the inconvenient truth is that tradeoffs are inevitable.  Here (and elsewhere) the problem can be addressed by not trying to mix conditional logic with substitution.  Substitution needs to be either a legal array element, or a ~void~ antiform to consciously opt out.  Conditional logic is now fully driven by non-nullity, meaning you need different instructions to contrast it with full-band substitution.</p>
<p>It still makes me a uneasy that the canon branch trigger isn't an antiform.  That will inevitably cause confusion... be accepted where it shouldn't, or have unintended meanings.</p>
<pre><code>&gt;&gt; num: 304

&gt;&gt; compose [flag: (odd? num)]
** Error: Cannot compose ~null~ antiform into array slot

&gt;&gt; compose [flag: (even? num)]
== [flag: #]  ; we allowed something that is likely not what you meant
</code></pre>
<p><strong>So perhaps people can be empathetic to why I thought NOTHING would be a better choice for the canon branch trigger!</strong></p>
<p>But this might be an unwinnable fight, and the consequences of reusing the NOTHING antiform are greater than that of getting the occasional # substituted where it should not be...with the burden of inventing a whole new antiform not giving the payoff that putting another part in the mix needs to have.</p>
            <p><small>12 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253</link>
          <pubDate>Thu, 05 Sep 2024 20:19:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2253</guid>
          <source url="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
        </item>
        <item>
          <title>Should Floating Point Really Be The Default?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p><a href="https://github.com/red/red/issues/3396#issuecomment-1654470030">In an issue on Red's GitHub</a>, Gregg gives this example:</p>
<pre><code>red&gt;&gt; n: 0  while [n &lt;= 0.3][print mold/all n  n: n + 0.1]
0
0.1
0.2
; Huh?

red&gt;&gt; n: 0  while [n &lt;= 3][print mold/all n  n: n + 1]
0
1
2
3
; OK. I'm not crazy

red&gt;&gt; n: 0  while [n &lt;= 0.4][print mold/all n  n: n + 0.1]
0
0.1
0.2
0.30000000000000004
0.4
; What... Oh... How do I work around that?
</code></pre>
<p>Sure, you can point everyone to <a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">"What Every Computer Scientist Should Know About Floating Point Arithmetic"</a> and say it's not your problem.  I mean geez, it's only a mere 50 or 60 pages long.</p>
<p>But as Gregg says:</p>
<blockquote>
<p><em>"Yes, we can explain it. Yes, not everyone will hit this. But [...] we don't just look like we're passing problems on and throwing our hands in the air, saying it's not our problem; it's part of our mission, and being empathetic to pain points is something people can hold up as examples of why <em>to</em> use Red, rather than why <em>not</em> to use Red."</em></p>
</blockquote>
<p>This makes me wonder about the choice to use floating point as a default.  Yes, it's in the hardware.  Yes you should be able to use them somehow.  But it may not be a fit for the language goals when considering examples like the above.  So I thought I'd ask the AIs about it.</p>
<hr>
<p><em>Note: The MONEY! datatype in R3-Alpha is not an IEEE floating point.  <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/f-deci.c#L27">It's something Ladislav wrote</a>:</em></p>
<pre><code>Deci significands are 87-bit long, unsigned, unnormalized, stored in
little endian order. (Maximal deci significand is 1e26 - 1, i.e. 26
nines)

Sign is one-bit, 1 means nonpositive, 0 means nonnegative.

Exponent is 8-bit, unbiased.
</code></pre>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-floating-point-really-be-the-default/2248">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-floating-point-really-be-the-default/2248</link>
          <pubDate>Wed, 04 Sep 2024 08:10:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2248</guid>
          <source url="https://forum.rebol.info/t/should-floating-point-really-be-the-default/2248.rss">Should Floating Point Really Be The Default?</source>
        </item>
        <item>
          <title>Isotopes and NaN (Not a Number)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>Prior to the existence of isotopes--when only VOID and NULL existed as outliers--I had an idea that VOIDs and NULLs could act as the <em>quiet NaN</em> and <em>signaling NaN</em> forms of  <a href="https://en.wikipedia.org/wiki/NaN">"not-a-number" (NaN)</a>.  The goal of this is to allow math handling to be more graceful, without needing to set up TRAPs and such--you can be selective about which operations you are willing to have fail, and supply code to fill in such cases.</p>
<h2><a name="p-7539-original-idea-math-ops-follow-void-in-null-outhttpsforumrebolinfotthe-void-in-null-out-protocol1880-1" class="anchor" href="https://forum.rebol.info#p-7539-original-idea-math-ops-follow-void-in-null-outhttpsforumrebolinfotthe-void-in-null-out-protocol1880-1"></a>Original Idea: Math Ops Follow <a href="https://forum.rebol.info/t/the-void-in-null-out-protocol/1880">VOID-IN-NULL-OUT</a></h2>
<p>This was the proposed behavior for NULL as signaling NaN and VOID as quiet NaN:</p>
<pre><code>&gt;&gt; square-root -1
== ~null~  ; anti

&gt;&gt; maybe square-root -1
== ~void~  ; anti

&gt;&gt; 1 + square-root -1
** Error: + doesn't accept NULL for its value2 argument

&gt;&gt; 1 + (square-root -1 else [10])  ; selective handling
== 11

&gt;&gt; 1 + maybe square-root -1  ; propagation
== ~null~  ; anti
</code></pre>
<h2><a name="p-7539-but-i-dont-like-void-as-quiet-nan-and-it-breaks-compares-2" class="anchor" href="https://forum.rebol.info#p-7539-but-i-dont-like-void-as-quiet-nan-and-it-breaks-compares-2"></a>But I Don't Like VOID as Quiet NaN (and It Breaks Compares)</h2>
<p>I prefer that when void arguments are received by math functions, <strong><a href="https://forum.rebol.info/t/opting-out-of-math-functions-with-void/2244">they return the other operand</a></strong> (with the exception of void divisors)...not a noisy NaN.</p>
<pre><code>&gt;&gt; 10 * if 1 &gt; 100 [20]
== 10
</code></pre>
<p>Also, Wikipedia has a little table about how NaNs work with comparisons:</p>
<blockquote>
<p>Comparison between NaN and any floating-point value  <em>x</em>  (including NaN and ±∞)</p>
<ul>
<li><strong>NaN ≥ x</strong> =&gt; <em>Always False</em></li>
<li><strong>NaN ≤  x</strong> =&gt; <em>Always False</em></li>
<li><strong>NaN &gt; x</strong> =&gt; <em>Always False</em></li>
<li><strong>NaN &lt; x</strong> =&gt; <em>Always False</em></li>
<li><strong>NaN = x</strong> =&gt; <em>Always False</em></li>
<li><strong>NaN ≠ x</strong> =&gt; <em>Always True</em></li>
</ul>
</blockquote>
<p>Look at that last case.  If VOID is the quiet NaN, you can't have that comparison returning NULL, because it would be falsey instead of truthy...so VOID-in-NULL-out breaks down here:</p>
<pre><code>&gt;&gt; 10 != (1 + try square-root -1)
** Error: != doesn't accept NULL for its value2 argument

&gt;&gt; 10 = (maybe 1 + maybe square-root -1)
== ~null~  ; anti  ...not a LOGIC!, but it is falsey, so uh...perhaps? :-/

&gt;&gt; 10 != (maybe 1 + maybe square-root -1)
== ~null~  ; anti  ...okay, now that's just wrong.
</code></pre>
<p><em>(I've made similar observations about <a href="https://forum.rebol.info/t/the-void-in-null-out-protocol/1880/8">VOID-in-NULL-out with LOGIC! returning functions</a> before.)</em></p>
<p>Beyond not liking VOID for quiet NaN, I'm not hot on NULL being the noisy NaN either.</p>
<h2><a name="p-7539-new-idea-signaling-is-error-antiform-quiet-is-nan-antiform-3" class="anchor" href="https://forum.rebol.info#p-7539-new-idea-signaling-is-error-antiform-quiet-is-nan-antiform-3"></a>New Idea: Signaling is Error Antiform, Quiet is ~NaN~ Antiform</h2>
<p>A lot of design space opened up with the <a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">introduction of generalized isotopes</a>.</p>
<p>So I think signaling NaN should be <a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-errors/1852">an error antiform</a>.  And quiet NaN should probably just be the ~NaN~ WORD! antiform.</p>
<p>TRY typically converts antiform errors to NULL, so they don't promote to abrupt failures.  But if TRY converted the specific NaN error antiform to the ~NaN~ word antiform, we could avoid having to come up with a special word for "MATH-TRY".</p>
<p>(This makes me think that quiet ~NaN~ word antiform should be falsey, so the usage pattern can line up with other null-bearing TRY instances...and I imagine MAYBE should also turn quiet ~NaN~ to VOID, for similar reasons.)</p>
<p>Anyway, here's how this would play out:</p>
<pre><code>&gt;&gt; square-root -1  ; unhandled raised error return promotes to abrupt failure
** Error: Not a Number

&gt;&gt; try square-root -1  ; TRY intercepts raised error before it abruptly fails
== ~NaN~  ; anti

&gt;&gt; 1 + square-root -1
** Error: Not a Number  ; was promoted to abrupt failure before + could see it

&gt;&gt; 1 + try square-root -1  ; TRY makes quiet ~NaN~, then + propagates
== ~NaN~  ; anti

&gt;&gt; 10 != (1 + try square-root -1)
== ~true~  ; anti

&gt;&gt; 10 = (1 + try square-root -1)
== ~false~  ; anti

&gt;&gt; 1 + ((try square-root -1) else [10])
== 11

&gt;&gt; 1 + any [square-root -1, 10]
** Error: Not a Number

&gt;&gt; 1 + any [try square-root -1, 10]
== 11
</code></pre>
<h2><a name="p-7539-i-think-that-looks-solid-4" class="anchor" href="https://forum.rebol.info#p-7539-i-think-that-looks-solid-4"></a>I Think That Looks Solid</h2>
<p>Another day, <a href="https://forum.rebol.info/t/the-theory-of-meta-representability/2217">another success story for isotopes</a>.  Definitionally raised error antiforms provide the mechanics to make an interceptible error by contract as a return value that isn't itself an abrupt failure, but promotes to abrupt failure when not anticipated.  <img src="https://forum.rebol.info/images/emoji/twitter/atom_symbol.png?v=12" title=":atom_symbol:" class="emoji" alt=":atom_symbol:" loading="lazy" width="20" height="20"></p>
<p>And it's cool that we have another WORD! antiform state that has the properties we want, while not being able to be put in blocks... but which has a quasi state that can, if you need to pipe things around:</p>
<pre><code>&gt;&gt; try sqrt -1
== ~NaN~  ; anti

&gt;&gt; block: append [1 2 3] try sqrt -1
** Error: append doesn't accept ~NaN~ antiform as its value argument

&gt;&gt; block: append [1 2 3] meta try sqrt -1
== [1 2 3 ~NaN~]

&gt;&gt; block.4
== ~NaN~

&gt;&gt; 10 + block.4
** Error: + doesn't accept ~NaN~ quasiform as its value2 argument

&gt;&gt; unmeta block.4
== ~NaN~  ; anti

&gt;&gt; 10 + unmeta block.4
== ~NaN~  ; anti
</code></pre>
<p>And heck, <strong><code>raise ~NaN~</code></strong> could produce the error antiform, bringing things full circle.</p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/isotopes-and-nan-not-a-number/2245">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/isotopes-and-nan-not-a-number/2245</link>
          <pubDate>Tue, 03 Sep 2024 19:51:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2245</guid>
          <source url="https://forum.rebol.info/t/isotopes-and-nan-not-a-number/2245.rss">Isotopes and NaN (Not a Number)</source>
        </item>
        <item>
          <title>Opting Out of Math Functions With VOID</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>It seems to me that it could be useful if math operations accepted VOID.</p>
<pre><code>&gt;&gt; factor: null

&gt;&gt; coefficient: 10

&gt;&gt; value: multiply factor coefficient
** Error: multiply doesn't allow ~null~ antiform for its value1 argument

&gt;&gt; multiply maybe factor coefficient
== 10

&gt;&gt; add coefficient maybe factor
== 10
</code></pre>
<p>If you opt out of the left hand side of a subtraction, you'd get negation:</p>
<pre><code>&gt;&gt; subtract maybe factor coefficient
== -10
</code></pre>
<p>If you opt out of the left side of a division, er... hm.  That should probably be an error.</p>
<pre><code>&gt;&gt; divide maybe factor coefficient
** Error: divide doesn't allow ~void~ antiform for its value1 argument
</code></pre>
<p>If you opt out of both arguments you get null.</p>
<pre><code>&gt;&gt; add maybe factor maybe factor
== ~null~  ; anti
</code></pre>
<p>I suppose divide can allow you to opt out of both arguments, though it makes the interface suggest the dividend can be opted out of in isolation since it would have void in the accepted types solely to handle the both-opt-out case.</p>
<h2>
<a name="seems-useful-and-supports-my-cautious-attitude-on-void-1" class="anchor" href="https://forum.rebol.info#seems-useful-and-supports-my-cautious-attitude-on-void-1"></a>Seems Useful and Supports My Cautious Attitude on VOID</h2>
<p>I now believe <a href="https://forum.rebol.info/t/maybe-if-conditionals-went-back-to-returning-null-on-failure/2047">CASE and SWITCH etc. that do not take any branches should return NULL</a>.  So you're less likely to be bitten by stray voids being tolerated in such situations, and need an explicit MAYBE.</p>
<p>But IF will still return void.</p>
<pre><code>&gt;&gt; multiply 10 (if 1 &gt; 100 [20])
== 10
</code></pre>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/opting-out-of-math-functions-with-void/2244">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/opting-out-of-math-functions-with-void/2244</link>
          <pubDate>Tue, 03 Sep 2024 18:02:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2244</guid>
          <source url="https://forum.rebol.info/t/opting-out-of-math-functions-with-void/2244.rss">Opting Out of Math Functions With VOID</source>
        </item>
        <item>
          <title>Dimensional Analysis with FUSED!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p><a href="https://forum.rebol.info/t/no-interstitial-delimiter-sequence-proposal-fused/1503">INTEGER!-led FUSED!</a> could have a pretty good default behavior in addition and subtraction...</p>
<pre><code>&gt;&gt; 10px + 20px
== 30px

&gt;&gt; 10px + 20em
** Error: Cannot add FUSED! unless non numeric portions match (px, em)
</code></pre>
<p>And with <a href="https://forum.rebol.info/t/backtick-literals-and-an-axis-of-extensibility/2235">Backtick Literals</a> it might give an answer for the longstanding question of putting units on currency.</p>
<pre><code>&gt;&gt; `$10.20`USD + `$3.04`CAN
** Error: Cannot add FUSED! unless non numeric portions match (USD, CAN)
</code></pre>
<p>So we'd get some very limited dimensional analysis.  There's nothing lower in sequence precedence than a FUSED! though...e.g. FUSED! lives under PATH!, so don't expect <strong><code>10m/s * 20s</code></strong> to work.</p>
<p>Although <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"> you could write <strong><code>10[m/s]</code></strong> ... but I'm not imagining the built-in multiplication working this out for you.  Just stopping you from adding 10[m/s] to 20s.  But who knows--maybe handling a tiny bit of this would be valuable.</p>
<p>The precedence of TUPLE! beneath PATH! might be an asset here:</p>
<pre><code>&gt;&gt; x: 10em * 20px
== 200[em.px]

&gt;&gt; x / 50
== 4[em.px/s]
</code></pre>
<p>Equality would bite you.  Structurally we can't say <strong><code>4[px.em/s]</code></strong> is equal to <strong><code>4[em.px/s]</code></strong>.  You'd need some kind of canonizing operation that would sort the sequences in a predictable order.  SORT:DEEP ?</p>
<pre><code>&gt;&gt; sort 'f.a:c.d/b.e:[h/g]
== b.e:[h/g]/f.a:c.d

&gt;&gt; sort:deep 'f.a:c.d/b.e:[h/g]
== 'b.e:[g/h]/a.f:c.d
</code></pre>
<p>All integers would have to be less than all WORD!s and LIST!s in sort order to use SORT:DEEP for this purpose.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/dimensional-analysis-with-fused/2239">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dimensional-analysis-with-fused/2239</link>
          <pubDate>Sat, 31 Aug 2024 17:36:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2239</guid>
          <source url="https://forum.rebol.info/t/dimensional-analysis-with-fused/2239.rss">Dimensional Analysis with FUSED!</source>
        </item>
        <item>
          <title>The Great Divide: Troubles Assigning Slash</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>So I apologize to <a class="mention" href="https://forum.rebol.info/u/giuliolunati">@giuliolunati</a> for making him have to put up with the <a href="https://forum.rebol.info/t/trying-as-a-path-of-two-blank-s-instead-of-a-word/798"><strong><code>/</code> is a 2-element path containing BLANK!s</strong> debacle back in 2018.</a> <img src="https://forum.rebol.info/images/emoji/twitter/see_no_evil.png?v=12" title=":see_no_evil:" class="emoji" alt=":see_no_evil:" loading="lazy" width="20" height="20"></p>
<p>On the positive side of me being mired in the implementation, I can see when something creates dissonance and edge cases...and know that things need to be avoided before someone in userspace would even know they needed to worry.  The compiler gives me type checking errors when things don't line up, and I try my best to leverage whatever tools to catch inconsistencies I can (as far as C building as C++ can do, anyway).</p>
<p>But on the negative side it means I might pick the wrong form of regularity to solve the problem.  This was such a case.  We simply needed rules at PATH! creation time that prohibit you from putting special-slash-words into a path... and that's that.</p>
<h2>
<a name="so-now-and-are-words-again-1" class="anchor" href="https://forum.rebol.info#so-now-and-are-words-again-1"></a>So Now <code>/</code> And <code>.</code> Are Words Again</h2>
<p>It's still going to be slippery.  There will be problems:</p>
<pre><code>math-context: make object! [
    /+: enfix add.
    /-: enfix subtract.
    /.: enfix multiply.
    /: enfix divide.   ; ooops
 ]
</code></pre>
<p>You won't be able to say <strong><code>(/: enfix divide.)</code></strong> to assign your division operator to a slash word!, <em>because that will execute the function in the colon word!</em>.  So if whatever the colon word does takes an action as an argument, you're going to take enfixed divide as a parameter to that function... not perform an assignment.  The PATH! is above the WORD!.</p>
<p>But things like (<strong><code>.:</code></strong>) and (<strong><code>...:</code></strong>) should work as expected.  The WORD! is below the CHAIN!.</p>
<h2>
<a name="is-too-misleading-to-execute-2" class="anchor" href="https://forum.rebol.info#is-too-misleading-to-execute-2"></a>Is  <strong><code>/:</code></strong> Too Misleading to Execute?</h2>
<p>It stands out a little as a mistake in the MATH-CONTEXT above next to the other assignments, when narrowly packed like that.  Of course, it wouldn't be narrowly packed.  And you could just be trying to assign an inert value and not a function:</p>
<p>What you wanted:</p>
<pre><code>&gt;&gt; /: 10
== 10

&gt;&gt; /
== 10
</code></pre>
<p>What you'll likely get:</p>
<pre><code>&gt;&gt; /: 10
** Error: Colon doesn't accept INTEGER! as its whatever argument
</code></pre>
<p>The evaluator could just refuse, and make you say <strong><code>run get $:</code></strong> or <strong><code>set get $/</code></strong></p>
<p>I'm tempted to say that's the right answer, because it seems like this will just lead to too much confusion otherwise.</p>
<h2>
<a name="that-wont-help-you-in-set-word-gathering-3" class="anchor" href="https://forum.rebol.info#that-wont-help-you-in-set-word-gathering-3"></a>That Won't Help You In "SET-WORD!" Gathering</h2>
<p>If you can't get a "SET-WORD!" form of the slash word, the object won't collect the member.</p>
<p>We could sacrifice something like SET-FENCE! for this purpose, and say that MAKE OBJECT! will treat the fence as its WORD! contents for gathering purposes:</p>
<pre><code>math-context: make object! [
    /+: enfix add.
    /-: enfix subtract.
    /.: enfix multiply.
    /{/}: enfix divide.
 ]
</code></pre>
<p>That's a pretty substantial sacrifice, to give up the meanings of all SET-FENCE! just for this one thing.</p>
<p>I don't have the answers.  If I had the answers I wouldn't have been trying to dodge it.  But I think the die is cast, and this needs some kind of creative solution.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/the-great-divide-troubles-assigning-slash/2230">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-great-divide-troubles-assigning-slash/2230</link>
          <pubDate>Fri, 30 Aug 2024 07:28:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2230</guid>
          <source url="https://forum.rebol.info/t/the-great-divide-troubles-assigning-slash/2230.rss">The Great Divide: Troubles Assigning Slash</source>
        </item>
        <item>
          <title>Cave-In: GUI Game In Red</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>GUI</category>
          <description><![CDATA[
            <p>Because I've idly started to think about what a Ren-C GUI dialect would look like (leveraging the web browser layout engine, of course), I've decided to reluctantly learn about Rebol's historical GUIs.  VID code has traditionally been an eyesore for me, but in the coming months I'll try to dedicate a little time to look at examples--both old and new--from all the various incarnations of the VID dialect <em>(<a href="https://www.rebol.com/docs/view-guide.html">VID</a>, <a href="https://github.com/red/docs/blob/master/en/vid.adoc">Red VID</a>, <a href="https://codeberg.org/hiiamboris/red-spaces/src/branch/master/vids.md">VID/S (Spaces)</a>, <a href="http://www.dobeash.com/rebgui.html">RebGUI</a>, <a href="http://www.rebol.org/view-script.r?script=glayout.r">GLASS</a>, and I've just found out that <a href="https://github.com/red/docs/blob/master/en/draw.adoc">DRAW is a different dialect from VID</a> so there's probably at least 12 more variants of all this stuff)</em></p>
<p>To try and have a little fun with my first one, I'll look at the game <strong>"Cave-In"</strong> by <span class="mention">@PlanetSizeCPU</span> from Red Gitter:</p>
<p><img src="https://gitter.ems.host/_matrix/media/v3/download/gitter.im/e0c12d3abca5509745b25a32a6866b3a502273791811281938799919104?allow_redirect=true" alt="Level.gif" width="637" height="500"></p>
<h2><a name="p-7366-the-code-1" class="anchor" href="https://forum.rebol.info#p-7366-the-code-1"></a>The Code</h2>
<p>The code is <a href="https://github.com/planetsizecpu/Cave-In">available on GitHub</a>, and it has been committed to as recently as July.</p>
<p>Curiously, the level definitions themselves <a href="https://github.com/planetsizecpu/Cave-In/blob/master/zLevelsDesign.txt">are not in Red syntax</a>.  They're like CSV files, except they use vertical bar as a separator instead of comma, and <strong>#</strong> for to-end-of-line comments</p>
<pre><code># ItemType|ObjectName|FaceName|FaceSize|FaceOffset|Rate|...
...
CAVERN|cavern1|cave|1599x600|0x0|0:0|0x0|0:0|0|0|cavern.png
GOLDBG|gold1|gld1|8x12|340x564|0:0|0x0|0:0|0|1|gold1.png
GOLDBG|gold2|gld2|8x12|310x461|0:0|0x0|0:0|0|1|gold1.png
GOLDBG|gold3|gld3|8x12|650x51|0:0|0x0|0:0|0|1|gold1.png
GOLDBG|gold4|gld4|8x12|200x185|0:0|0x0|0:0|0|1|gold1.png
...
</code></pre>
<p>The implementation is just <a href="https://github.com/planetsizecpu/Cave-In/tree/master/src">four<code> .red</code> source files</a>, three of which are small and the main implementation lives in something called <strong><code>makegame.red</code></strong></p>
<p><a href="https://github.com/planetsizecpu/Cave-In/blob/master/src/makegame.red">https://github.com/planetsizecpu/Cave-In/blob/master/src/makegame.red</a></p>
<h2><a name="p-7366-theres-an-observable-lack-of-rebolism-2" class="anchor" href="https://forum.rebol.info#p-7366-theres-an-observable-lack-of-rebolism-2"></a>There's an Observable Lack Of... <em>"Rebolism"</em></h2>
<p>I don't want to be too critical of someone's early efforts in programming.  This actually reminds me a lot of when I was a kid and got Turbo Pascal for a 286 PC, and tried to write a variation of <a href="http://blog.hostilefork.com/media/machine-language-commodore-64-128/react-compute-gazette.png">a Commodore 64 game called "React"</a>.  The example snippets I learned from were very simple and none even showed you how to break your code into different files, so I just had one long .PAS file... that grew and grew.  Instead of seeing the growing code with tons of conditionals as a problem, I was kind of excited about how big it was getting!</p>
<p>But that aside, there clearly are a lot of repetitive patterns and lack of abstraction.  To pick on <a href="https://github.com/planetsizecpu/Cave-In/blob/2ae789594f9bc38ff1fd310fbc184c9bc4452cd9/src/makegame.red#L462C1-L474C4">one short example at random</a>:</p>
<pre><code>if (first f/extra/name) = #"a" [
    foreach img GameData/AgentDead [f/image: get img wait GameData/AgentDeadDelay]		
]
if (first f/extra/name) = #"f" [
    foreach img GameData/FAgentDead [f/image: get img wait GameData/AgentDeadDelay]		
]
if (first f/extra/name) = #"p" [
   foreach img GameData/PAgentDead [f/image: get img wait GameData/AgentDeadDelay]		
]
if (first f/extra/name) = #"y" [
    foreach img GameData/YAgentDead [f/image: get img wait GameData/AgentDeadDelay]		
]
</code></pre>
<p>But you can see that large-scale repetition of this kind is pervasive.</p>
<p>What I find perplexing is that if people aren't using Rebol's mechanisms, what do they actually <em>like</em> about the language enough that keeps them going with it?</p>
<p>Ren-C takes the refactoring and streamlining potential to new heights.  It makes it easier to put expressions all on one line with good error locality with <a href="https://forum.rebol.info/t/the-void-in-null-out-protocol/1880">VOID-in-NULL-out</a>.  It gives you foolproof <a href="https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942/9">truthiness of any item you can put in a block</a> (only antiforms can be are falsey).  NIHIL lets you use <a href="https://forum.rebol.info/t/how-to-choose-between-returning-void-and-nihil/2171/2">put code midstream in any evaluative context without disturbing it</a>, for things like ASSERT and ELIDE to be anywhere you please.  <a href="https://forum.rebol.info/t/the-simple-yet-powerful-magic-of-the-loop-result-protocol/609">The loop result protocol is super neat</a>, and I could go on and on...</p>
<p>...but the basic idea of enabling smooth composition has been there since Rebol2, e.g. you could rewrite the above as:</p>
<pre><code>if (dead: select [
    #"a" AgentDead
    #"f" FAgentDead
    #"p" PAgentDead
    #"y" YAgentDead
] first f/extra/name) [
    foreach img GameData/(dead) [
       f/image: get img wait GameData/AgentDeadDelay
    ]
]
</code></pre>
<p>As Carl said in <a href="https://forum.rebol.info/t/rebols-target-market-newbies-experts-or-other/581"><strong>Rebol: Not for everyone?</strong></a>:</p>
<blockquote>
<p><em>"I've glanced over a lot of REBOL code written by a wide variety of programmers, and quite often I'm floored. Many programmers use REBOL like they're writing in C or BASIC. I can spot it in an instant; they did not bother to learn the fundamental concepts of the REBOL language. When I see that kind of code, I wonder why they bothered to use REBOL at all. C is better written in C. You will never hear me contest that fact."</em></p>
</blockquote>
<p>...but the appeal may be "I <strong>can</strong> Use It Like BASIC!"  I dunno.</p>
<h2><a name="p-7366-timers-and-frame-rates-3" class="anchor" href="https://forum.rebol.info#p-7366-timers-and-frame-rates-3"></a>Timers And Frame Rates</h2>
<p>The <a href="https://github.com/planetsizecpu/Cave-In/blob/2ae789594f9bc38ff1fd310fbc184c9bc4452cd9/src/cave.red#L113">definition of the main "layout" GameScr(een)</a> includes a size and position, and uses what appears to be a RATE dialect keyword:</p>
<pre><code>GameScr: layout [
    title "Cave-In"
    size 800x600
    origin 0x0
    space 0x0

    ; Info field is also used for event management!
    at 10x610 info: base 780x30 orange blue font [
        name: "Arial" size: 14 style: 'bold
    ] focus 
    rate GameData/GameRate on-time [
        info/rate: none 
        if CheckStatus [alert "END OF GAME" quit] 
        info/rate: GameData/GameRate
    ]
]
</code></pre>
<p>RATE is defined <a href="https://www.rebol.com/docs/view-guide.html">in the VID dialect</a> as:</p>
<blockquote>
<p><strong>rate</strong> - An INTEGER or TIME that specifies the rate of time events for a face. This is used for animation or repetitive events (such as holding the mouse down on certain types of user interface styles). An INTEGER indicates the number of events per second. A TIME provides the period between events.</p>
</blockquote>
<p>Cave-In apparently uses the time-based parameter, <a href="https://github.com/planetsizecpu/Cave-In/blob/2ae789594f9bc38ff1fd310fbc184c9bc4452cd9/src/cave.red#L29C2-L34C3">which it initializes and then overwites</a>.</p>
<pre><code>GameRate: 0:00:00.003
either system/platform = 'Windows [
    ; Win cant handle 3ms rate so it goes as fast as possible
    GameRate: 0:00:00.006
][
    ; For other OSs as GTK we must test this value as they handle right
    GameRate: 0:00:00.065
]
</code></pre>
<p>So I take it that <strong><code>rate &lt;time or integer&gt; on-time [...]</code></strong> means that you want callbacks to run the code in the block at the given rate.  I'm not clear on why you would say ON-TIME there vs. just put the block there.</p>
<p>Searching <a href="http://rebol.org">rebol.org</a> for other VID examples using rate, I found <a href="http://www.rebol.org/view-script.r?script=tweener.r"><code>tweener.r</code></a> that does:</p>
<pre><code> rate 1 feel [
     engage: func [face action event] [...]
 ]
</code></pre>
<p>I don't know if ON-TIME is Red-specific or what, or what other things you can put there, or what this means.</p>
<p>There is actually code here for <a href="https://github.com/planetsizecpu/Cave-In/blob/2ae789594f9bc38ff1fd310fbc184c9bc4452cd9/src/cave.red#L174">adjusting the timings for different CPUs</a>.  That seems to undercut Red's value proposition if that's necessary...isn't this supposed to be speaking about a concrete amount of time that works on all platforms?</p>
<h2><a name="p-7366-main-game-4" class="anchor" href="https://forum.rebol.info#p-7366-main-game-4"></a>Main Game</h2>
<p>Anyway, the spawning of a modal graphic window instance is done with VIEW.  There's a splashscreen instantiation via VIEW, then a settings instantiation via VIEW, then an instance of GameScr with:</p>
<pre><code>view/options GameScr [
    actors: context [on-key: func [face event][CheckKeyboard face event/key]]
]
</code></pre>
<p>So I'm not clear on what the /OPTIONS is for, that can't be specified in the layout itself.  The <a href="https://www.rebol.com/docs/words/wview.html">Rebol2 documentation for VIEW says</a>:</p>
<blockquote>
<p>Additionally, calls to view can specify options, such as whether the window has borders and is resizable. Single options are provided as a word and multiple options are specified in a block.</p>
<pre><code>out: layout [vh1 "This is a window."]
view/options out [resize no-title]
</code></pre>
</blockquote>
<p>As per usual, I'm baffled...what goes in the layout and what doesn't?  Why isn't Cave-In able to just <strong><code>view GameScr</code></strong> with the keyboard handler mentioned alongside the rate timer in the definitoin of GameScr?</p>
<p>In any case, the code that runs at the RATE calls <a href="https://github.com/planetsizecpu/Cave-In/blob/2ae789594f9bc38ff1fd310fbc184c9bc4452cd9/src/makegame.red#L15">a function <code>CheckStatus</code></a> that does some work, and returns a truthy value if the game is over or a falsey value to keep on going.</p>
<p>CheckStatus adds the effect of gravity to objects, but that particular global timed function doesn't do things like make the bad guys move around.  It seems individual objects have timers associated with them, e.g. when an "Agent" is being instantiated from a Level <a href="https://github.com/planetsizecpu/Cave-In/blob/2ae789594f9bc38ff1fd310fbc184c9bc4452cd9/src/loadlevel.red#L139">it makes a FACE! which has its own RATE set</a>, leading to callbacks of its own ON-TIME function:</p>
<pre><code>"A" [  ; "(A)gent"
    set (w) make face! [
        type: 'base
        size: ItemObj/size
        offset: ItemObj/offset
        image: copy ItemObj/image
        extra: ItemObj
        rate: ItemObj/rate
        actors: context [
            on-time: func [f e][AgentMotion f]
        ]
        ItemObj/lives: 64
    ]
    append cave/pane (get w)
]
</code></pre>
<p>So then <code>AgentMotion</code> does the updating.</p>
<h2><a name="p-7366-okay-i-understand-this-one-5" class="anchor" href="https://forum.rebol.info#p-7366-okay-i-understand-this-one-5"></a>Okay, I Understand This One</h2>
<p>I can see a little bit of the appeal for why someone would have fun hacking on it this way.  Red is giving you some game-engine type autonomy to all the objects, with each face its own timer.  You get some very simple things like an <a href="https://github.com/red/red/blob/dbc93da47047667023a66c5edf1aa1d63ff6f0d0/modules/view/utils.red#L44"><strong><code>overlap?</code></strong> utility function</a> to see if two faces overlap (though it just checks bounding boxes, not collision detection on non-transparent portions).</p>
<p>Now that I'm learning a bit of the terminology, this isn't really using "VID" the dialect hardly at all.  The only VID code is in <a href="https://github.com/planetsizecpu/Cave-In/blob/master/src/cave.red">%cave.red</a> and it does nearly nothing.</p>
<p>But it's using "View", which is kind of like a browser layout engine.  VID is a shorthand for building View code--it's maybe a little like HTML for declaratively specifying the starting point of the DOM...that then gets dynamically juggled all around as objects after that.</p>
<p>Cave-In basically is like one of those pages where if you "View Source" the .HTML is nearly empty, and everything is created dynamically with code.  But that code does not leverage small VID fragments, the way some dynamic JavaScript might use HTML snippets to build DOM code.  (Could it?)</p>
<p>I'll add that I notice nowhere in the source for Cave-In is the <strong><code>on-change*</code></strong> method used, so this isn't using the <a href="https://www.red-lang.org/2016/06/061-reactive-programming.html">"reactive programming" features added by Red</a>, FWIW.</p>
<p>Tune in next week (month?) when I set aside some time to look at another Rebol GUI thing.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/cave-in-gui-game-in-red/2209">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/cave-in-gui-game-in-red/2209</link>
          <pubDate>Fri, 23 Aug 2024 23:08:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2209</guid>
          <source url="https://forum.rebol.info/t/cave-in-gui-game-in-red/2209.rss">Cave-In: GUI Game In Red</source>
        </item>
        <item>
          <title>VID Expression Optimization</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>GUI</category>
          <description><![CDATA[
            <blockquote>
<p>I've really dodged looking at any of the GUI dialects and discussions, and the debates on <em>"what's a face, what's a pane, what's a panel"</em>...glancing at it I don't see any there, there.  My experience with the implementation of the GOB! left me thoroughly unimpressed and reinforced how likely non-interesting it is.  When it comes to UI, need I point out that <a href="https://www.youtube.com/watch?v=M-8k8GEGZPM">things like SeaDragon</a> were being demonstrated 17 years ago.</p>
<p>But given that I was <a href="https://forum.rebol.info/t/more-history-mining-rebol-3-0-front-line-blog/2199">going through all the Rebol 3.0 Front Line blog entries</a>, I did stop to look when a post ventured into some philosophy.</p>
<p>The post I stopped to read was <strong><a href="http://www.rebol.net/r3blogs/0135.html">VID Expression Optimization</a></strong>.  For commentary, I'll reproduce it below, all copyright to Carl.</p>
</blockquote>
<hr>
<p>When VID was created for R2, it was a revolutionary new approach to GUI construction, and we did not yet know what was common and what was not. Now, for R3, I think we know more, and we should use that knowledge.</p>
<p>In R2, VID faces were described mainly with a style name, followed by a sequence of datatypes. For example, you could write:</p>
<pre><code>button "Here" "There" red green 100x32 [browse home]
</code></pre>
<p>So, we placed a high value on expressing modifications in a minimal way. This made VID powerful for expression a great number of variations of styles easily, but we should ask, is that the most common usage?</p>
<p>Well, it's great for demos, but beyond that, most applications do not use that many variations of style, and when they do, they normally define them in a style-sheet for easier management, not within the description of a panel.</p>
<p>This is the CSS concept, where variations are provided via property names. I like this approach because it makes the GUI more readable to those who are not experts. You can see more than the value, you get to know what the value relates to.</p>
<p>For example it is clear to write variations of properties in this way:</p>
<pre><code>width: 20%
area-color: blue
text-color: white
edge-color: silver
</code></pre>
<p>So, indeed, that looks a lot like CSS (or should I say that CSS looks a lot like REBOL, interestingly enough), although not totally identical, it is close enough that HTML-aware users will not fear it.</p>
<p>In other words, we do not need to allow ten or more variations of face (style) properties via direct, unnamed datatypes. Instead, let's allow just a few of the main ones, and put the test into a property sheet format with named fields.</p>
<p>I mention this because as we move to the finalization of VID for the standard built-in GUI method, we want to evaluate the usage patterns and apply RISC concepts to make them optimal for users.</p>
<p>We can now re-examine and optimize the top level grammar of VID. I think we can say that, in order of importance, we have:</p>
<ol>
<li>
<p>style (the name, e.g. BUTTON, PANEL)</p>
</li>
<li>
<p>contents (e.g. button text, panel block)</p>
</li>
<li>
<p>name (the set-word label for it)</p>
</li>
<li>
<p>action (what to do on events)</p>
</li>
<li>
<p>variations (of the style)</p>
</li>
</ol>
<p>Let's take an example:</p>
<pre><code>user-name: field "default name"
</code></pre>
<p>Now, if for some reason you need that field to look different, such as use white text on black box area, you would first want to ask yourself if that should be defined as a new style in the style sheet. But, if not, you could write:</p>
<pre><code>user-name: field "default name" with [
    area-color: black
    text-color: white
]
</code></pre>
<p>This specification is simple and clear. Yes, it is a bit more wordy than VID in R2, but I think it is a better approach.</p>
<p>Some of you may be asking, is the word WITH really necessary? To that I would reply in RISCish way: "what is more common?" Is style variation the most common... probably not.</p>
<p>Something like this is will be much more common:</p>
<pre><code>panel [
    button "Yes"
    button "No"
]
</code></pre>
<p>It's quite common, so it seems to me it makes a better choice for the use of a block.</p>
<p>Finally, I want to mention that this subject can go on and on, and everyone will have their opinions. But, let's set opinions aside, because we must think in terms of usage, not in terms of REBOL dialecting capability, which we know is quite unbounded.</p>
<hr>
<p>Copyright © Carl Sassenrath 2008</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/vid-expression-optimization/2202">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/vid-expression-optimization/2202</link>
          <pubDate>Wed, 21 Aug 2024 00:30:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2202</guid>
          <source url="https://forum.rebol.info/t/vid-expression-optimization/2202.rss">VID Expression Optimization</source>
        </item>
        <item>
          <title>More History Mining: Rebol 3.0 Front Line Blog</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>I did a <a href="https://forum.rebol.info/t/mining-history-for-anything-relevant-carls-rebol-blog/2197">quick full skim-through of Carl's Rebol Blog</a>, which split off into a second blog to discuss technical issues in R3-Alpha.</p>
<p>The second blog kicked off on April 6, 2006:</p>
<p><a href="http://www.rebol.net/r3blogs/0001.html">http://www.rebol.net/r3blogs/0001.html - <strong>"Welcome to the REBOL 3.0 Front Line..."</strong></a></p>
<p>It got up to 352 entries, tapping out on February 20, 2011 (which was prior to the open-sourcing):</p>
<p><a href="http://www.rebol.net/r3blogs/0352.html">http://www.rebol.net/r3blogs/0352.html - <strong>"Relative speeds from compiler optimizations"</strong></a></p>
<h2>
<a name="again-im-skimming-it-for-anything-useful-1" class="anchor" href="https://forum.rebol.info#again-im-skimming-it-for-anything-useful-1"></a>Again, I'm Skimming It For Anything Useful</h2>
<p>However <strong>there is a lot more here to react to</strong>.  This could take days!</p>
<p>But I do think it's worth it, in part just to kind of help put together a big picture of where this project was and where it is now.</p>
<ul>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0002.html">Introduction of TYPESET!</a></strong> - Oh... Rebol2 didn't have them?  <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"> Well, neither does Ren-C... <a href="https://forum.rebol.info/t/the-typeset-representation-problem/1300/12">typesets are replaced by type constraints</a>.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0003.html">MAKE Function Used To Be Variadic</a></strong> - I don't think I'm a fan of MAKE being variadic, but I have questioned the idea that <a href="https://forum.rebol.info/t/debunking-the-arity-1-make/1591">there even need to <em>be</em> a MAKE FUNCTION!</a>, vs just having FUNC be an arity-2 native to start with.  This actually may be more prescient than I imagined, as there is no function datatype any longer... <a href="https://forum.rebol.info/t/taking-action-on-function-vs-action/596/6">functions are just antiform FRAME!s</a>.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0006.html">To COPY or not COPY</a></strong> - I've sometimes critiqued Carl for seeming to have not confronted Rebol's actual core flaws head on.  But here he does...mentioning new users getting bitten by mutability -and- also the problems from mutable binding on a block being passed in to two different MAKE OBJECT! calls.  I've been satisfied with Ren-C's answer to the first issue by the <a href="https://forum.rebol.info/t/value-vs-series-modification-bit-const-and-mutable/976">CONST implementation</a>--which has held up super well for years now.  And <a href="https://forum.rebol.info/t/member-functions-in-the-era-of-pure-virtual-binding/2190">how object creation works</a> is undergoing a renaissance as I type this...no mutable binding (or even virtual blanket binding) required.</p>
<ul>
<li>It turns out there was a period in R3-Alpha where it was deep copying object specs <a href="http://www.rebol.net/r3blogs/0212.html">and people eventually complained</a>.  He says he was waiting to see if anyone noticed.  I do think it goes to show how little truly sophisticated Rebol code there was in practice, for people to not be able to tell sooner.</li>
</ul>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0007.html">Hot Errors Removed</a></strong> - He says <em>"These hot errors turned out to be overkill, and the benefit of error locality was offset by the difficulty of handling error values in general."</em>  But in effect this is another decision where Ren-C went more in a Rebol2 direction, <a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-errors/1852">introducing a whole new antiform error design</a>.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0008.html">No Out Of Range Errors With FIRST, SECOND, etc.</a></strong> - Because an early development of Ren-C was to make FIRST, SECOND, etc. specializations of PICK... I'd always thought of them as being related.  Apparently at one time they were not.  In any case, the issue of range errors has been something that's crossed my mind... and I think I'd rather you have to say <strong><code>try fourth</code></strong> in order to tolerate out of range errors.  <a href="https://forum.rebol.info/t/why-doesnt-third-1-2-trigger-a-range-check-error/1825/4">But the unification of PICK mechanics and TUPLE! selection, e.g. <strong><code>block.3</code></strong> is the same as <strong><code>pick block 3</code></strong> throws a wrench in it.</a>  This is still an open question.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0009.html">The 64-bit question</a></strong> - Wow, this is still not decided.  Ren-C still uses 32-bit indices (but stores them as <code>int_fast32_t</code> etc. so they'll use 64 bits of space if the registers make it faster).  It hasn't been an issue at the forefront.  I'm more interested in distinguishing in the code distinct datatypes for 1-based "Index" vs. 0-based "Offset" and making sure those are distinct types that are harder to mix up.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0010.html">JIT Binding</a></strong> - I've never heard of this and don't believe I saw any code for it.  On the surface it sounds like a relative of virtual binding, but it mutates the bindings in the block permanently and just sounds like something strange that never saw the light of day.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0011.html">Debug Hook</a></strong> - Here he talks about being able to essentially break into the console at the moment of a FAIL and inspect the stack.  One thing about historical Rebol is that because error trapping was frequent (e.g. ATTEMPT etc.) and being used as a programming style, you'd be getting a lot of false hits.  Ren-C's error handling model is such that if you handle an error that is generally done by reacting to a RAISE before it's actually promoted to a FAIL, so you would not be getting broken into the debugger constantly in the casual operation of your code.  We do need this.  I believe in my heart that I am being attentive to the needs of a debugger, but there some more giant issues to knock down first.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0012.html">CLOSURE functions</a></strong> - nope, <a href="https://forum.rebol.info/t/relative-binding-and-frame-internals/1344">all functions are closure-semantics now</a>...without the crazy overhead of deep copying and binding the body of a function on every call!</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0013.html">ALIAS</a></strong> - Old ALIAS was removed long ago, because it was crazy.  I've written about <a href="https://forum.rebol.info/t/the-return-of-alias/2129">reviving this idea more reasonably for modern times</a>.</p>
<ul>
<li>When <a href="http://www.rebol.net/r3blogs/0242.html">Carl wrote about his feelings about removing ALIAS</a>, he said <em>"Perhaps you've seen a change in my attitude... considering how long it's taking to get R3 out the door!"</em>
</li>
</ul>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0014.html">HASH!</a></strong> - I covered this in the other blog response, but the comments here might be useful.  <a href="http://www.rebol.net/r3blogs/0052.html">He talks about it in a later post as well.</a>  And then again, <a href="http://www.rebol.net/r3blogs/0054.html">offers some conclusions</a></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0015.html">Getting More Information From FOR-EACH</a></strong> - Asking for not just the item but the series position is one idea.  But coming up with ways to ask for more information in enumerations has been explored a number of places.  I've wanted to be able to enumerate and know things like "is this the last element" or "is this the first element" and be able to check that easily.  <span class="mention">@hiiamboris</span> has a fancy FOR-EACH that <a href="https://codeberg.org/hiiamboris/red-common/src/branch/master/new-each.red#L613">if you use a refinement in the spec it assumes you want the index at that position</a>, etc.  These are interesting ideas, so definitely want to look into them.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0016.html">OBJECT! Field Type Constraints</a></strong> - I've wondered about this.  It's definitely the case that languages which don't support type information wind up having another language layered on top of it that does (e.g. TypeScript).  But this was never in R3-Alpha, and hasn't been a priority.  I note <a href="http://www.rebol.net/r3blogs/0042.html">he also mentions this kind of type constraint in module specs.</a></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0017.html">! and !=</a></strong> - I was never a fan of adding <strong><code>!</code></strong> but we do support <strong><code>!=</code></strong> My biggest problem is that != and == are a pair in C, but not a pair in Rebol: != is paired with = for lax equality, and !== is paired with == for strict equality.  That makes it more confusing than anything, and I've meant to resolve this but it's another thing that's slipped.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0019.html">Considering Setters</a></strong> - I've mentioned in the past that Ren-C might have an answer to this, where you could use something like <strong><code>obj.member.</code></strong> to get at the "real" value bypassing the functions that assign them.  There's a big bag of tricks in Ren-C to implement these kinds of features, but seems there's always something more foundational to attack. R3-Alpha had no code for it, though <a href="https://www.red-lang.org/2014/12/050-objects-support.html">Red has ON-CHANGE* to react to assignments</a>.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0020.html">Bye Bye System Object?</a></strong> - The idea of making changes to Rebol to support multitasking the way it was being done was fundamentally flawed.  Needless to say the system object is still there (though <a href="https://forum.rebol.info/t/system-object-vs-sys-context/1687">the "system context" is now SYSTEM.UTILITIES, or SYS.UTIL for short</a>.)</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0024.html">Should All Functions Return Values</a></strong> - Returning an UNSET! was a "value", just an ornery one historically, e.g. <strong><code>x: print "hello"</code></strong> was an error in Rebol2 and it remained one in R3-Alpha.  Though it has been debated, in Ren-C <a href="https://forum.rebol.info/t/why-doesnt-print-return-void-or-vaporize-via-nihil/1466">PRINT returns NOTHING</a> <em>(the moral equivalent of UNSET!)</em> and is legal to assign to a variable...it just unsets it.  The only thing that you can't assign is an empty block antiform (a multi-return parameter pack), because when empty it is considered to be holding no values.  This is called NIHIL and it is rarely returned.</p>
<ul>
<li>So... the answer here is "kind of" and the only remaining question is <a href="https://forum.rebol.info/t/the-truthiness-of-nothing/2180">should NOTHING be considered meaningfully truthy or falsey</a>  On a later blog <a href="http://www.rebol.net/r3blogs/0207.html">there was a vote taken</a> about how functions treat UNSET!</li>
</ul>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0025.html">Leaky Functions</a></strong> - Not knowing this discussion was taking place in May 2006, <a href="https://forum.rebol.info/t/how-attached-are-we-to-functions-return-last-result/1219">I made a similar argument here in September 2019</a>.  But there's <a href="https://forum.rebol.info/t/implicit-execution-of-return-in-functions-bad/1656">an additional wrinkle that Ren-C has unique customizable per-function RETURN definitions</a>.  So it's pretty much a slam dunk to make the change, and introduce LAMBDA as both returning its body result and not having a RETURN.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0026.html">BIND Expands Contexts</a></strong> - Carl says <em>"A few of you will ask: why does this matter? The main reason is memory (something we are optimizing on R3.0). Why force allocation for "free" variables (module variables) that are never used?"</em>  Everything is different in Ren-C, though it does deal with <a href="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128">something called "Attachment Binding"</a> where module variables actually are not allocated until they are used.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0029.html">Current Module</a></strong> - I actually thought he was speaking about there being something available in a module similar to a SELF or THIS, which seemed like a pretty good idea. But instead he's talking about running DO on something and it expanding the module you called it from.  Ren-C doesn't do this, DO runs its code isolated and can only give you back its final result.  You have to use IMPORT if you want to bring in new definitions to the module.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0032.html">UNICODE Support</a></strong> - It is interesting to see the considerations here, where it seems being able to load old LATIN-1 scripts was a concern.  No consideration of UTF-8 Everywhere is given for storage, <a href="https://forum.rebol.info/t/realistically-migrating-rebol-to-utf8-everywhere/374">but that's what Ren-C does</a>.  He's wary of allowing UTF-8 in scripts themselves: <em>"Another possibility would be to allow UTF-8 encoding within strings in the source code. The advantage is that you will be able to view the strings in the appropriate editor. The disadvantage is that the script would contain a range of odd looking characters."</em>  I have thought that being able to limit what Unicode is permitted as a kind of security measure might be important, but there are higher priority issues.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0034.html">"Scant" Evaluation</a></strong> - FWIW, I do not really believe in the premise of scant evaluation.  I think if you do something like <strong><code>construct/only [foo: true bar: 'f]</code></strong> then you get FOO as the WORD! true and not the logic, and you deal with it with tests like <strong><code>== 'true</code></strong>.  I guess I have to see more examples, but I've only seen this in module headers and I prefer the you-get-what-you-see version.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0035.html">At a Class Crossroads</a></strong> - <a href="https://forum.rebol.info/t/member-functions-in-the-era-of-pure-virtual-binding/2190">I just brought this post up recently.</a></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0045.html">Overwriting System Functions</a></strong> - He mentions the general problem that since modules import their own copy of system functions under a word in their own variable space, they won't see changes made to the variable in the system.  He talks about making some kind of "search and replace re-set" that would find all those imported stubs and fix them up.  I've been thinking in pursuing this through <a href="https://forum.rebol.info/t/the-return-of-alias/2129">allowing variables to alias other variables</a>, so what you import starts out by default as an indirection and sees changes in the original.  But sSo far, if you want to hook a system function, in Ren-C, <a href="https://forum.rebol.info/t/monitoring-a-single-function-with-enclose-and-hijack/425">you have the option of HIJACK-ing the identity of the function value itself</a></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0048.html">Free Variables in Modules</a></strong> - I dislike these but the codebase has not been retrofit to not use them.  Only LIB and SYS.UTIL are currently enforced to not be able to create them.  But I think you shouldn't be able to by default anywhere (e.g. "strict mode" in JavaScript).</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0049.html">Source Reflection Returning Unbound Copies</a></strong> - Again speaking somewhat from a security standpoint, Carl points out that if a module gives you a function you can get at its source code, and if you can get at its source code you can get at its bindings, and if you can get the bindings then you can reach the data.  I think being able to get the source code itself would be problematic in this adversarial situation--with or without the bindings.  It would be nice if some day people go over the language and make it secure, but I think we're well into the phase where making it good and interesting is far more important.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0050.html">Should a Module Be Loadable More Than Once</a></strong> - e.g. if you are using different versions as dependencies of other different modules.  Hmmm.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0057.html">Do We Dare Add ++ and --</a></strong> - Ren-C addresses this with ME and MY.  e.g. <strong><code>counter: me + 1</code></strong>, <strong><code>counter: me * 10</code></strong>.  It fetches the value of the SET-WORD! on the left and substitutes that for ME.  It's a lot nicer, and saves ++ and -- for weird symbolic purposes.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0059.html">Deprecating CONTEXT</a></strong> - He's opposed to it because CONTEXT creates an OBJECT!, but there's no such thing as a CONTEXT! datatype.  I'm opposed to it based on it being a noun.  I'm thinking WRAP might be best applied to what this does.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0063.html">How Best to Blockify?</a></strong> - He proposes BLOCKIZE for what I call ENBLOCK (e.g. envelope/enclose in a block).  BLOCKIFY is something where if what you have in your hand isn't already a block, it will wrap it it one. <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0064.html">DIR?</a></strong> - I came to be of the belief that all directories must end in a slash, and we enforce this systemically.  Hence DIR? is just a question of whether a FILE! ends in a slash or not.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0069.html">PORT! Redesign Objectives</a></strong> - This probably belongs in the <a href="https://forum.rebol.info/t/what-is-a-port/617">What is a PORT! discussion</a>.  More to add there:</p>
<ul>
<li><a href="http://www.rebol.net/r3blogs/0070.html">problem with DELETE</a></li>
<li><a href="http://www.rebol.net/r3blogs/0071.html">problem with RENAME</a></li>
<li><a href="http://www.rebol.net/r3blogs/0128.html">SKIP and SEEK</a></li>
<li><a href="http://www.rebol.net/r3blogs/0130.html">OSI Model and PORT!</a></li>
</ul>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0078.html">Lexical Exceptions in LOAD</a></strong> - I'm against finding a way to load e.g. <strong><code>1st</code></strong>.  Ren-C gives you <strong><code>1.st</code></strong> if you want it.  This isn't a good investment of energy.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0084.html">IO Devices in R3</a></strong> - And all of <a href="http://www.rebol.net/r3blogs/0087.html">the Device Model</a> is happily gone. <a href="https://forum.rebol.info/t/libuv-integration-has-started-an-i-o-renaissance/1694">We use libUV now</a>, and it's a lot better while still being standard C, cross-platform with many more features, and maintained by other people.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0085.html">None Propagation</a></strong> - <a href="https://forum.rebol.info/t/the-void-in-null-out-protocol/1880">Ren-C has VOID-in-NULL-out</a> and it's working splendidly.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0086.html">Explicit Evaluation Terminator</a></strong> - After a failed attempt to convince people that vertical bar <strong><code>|</code></strong> would be BAR! and serve this purpose, <a href="https://forum.rebol.info/t/the-language-worlds-weirdest-comma-mechanic/1387">we have COMMA!</a>, and it has turned out to be a lot better.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0091.html">R3-Alpha Released to Select Developers</a></strong> - This was June 2007.  <a href="http://www.rebol.net/r3blogs/0094.html">The Beta was expected on July 15, 2007, then delayed (?!)</a>  Well there never was a Beta.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0093.html">Changes in MAKE FUNCTION!</a></strong> - Related to this, I just wrote a sort of new <a href="https://forum.rebol.info/t/make-should-be-using-dialected-constructors/2196">Dialected MAKE Manifesto</a></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0097.html">WITH and IN</a></strong> - I do admit to liking the <strong><code>do in context [...]</code></strong> construct.  The IN construct is completely virtual binding now.  BIND is still around but uses have been dropping as more and more of the codebase is able to work with virtual binds on top of largely unbound blocks of code, "viewed" several different ways without touching the binding bits.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0100.html">UNSET! As An Argument</a></strong> - R3-Alpha got fairly permissive, e.g. allowing comparisons of UNSET! to other values.  I've brought up that I think it <a href="https://forum.rebol.info/t/the-truthiness-of-nothing/2180">may be a mistake to allow things like comparisons to take NOTHING</a>, and offered justifications for that.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0104.html">Modules Ripping Carl Apart</a></strong> - <em>"I have to admit that so far modules have been, well, too much like taming a tiger. And, so far, the tiger has been winning... often, ripping me to pieces. The tiger is the main reason R3 is running late. Yes, blame the tiger. I've got many scars."</em></p>
<ul>
<li>In 2010 <a href="http://www.rebol.net/r3blogs/0339.html">he blamed them again for another release delay</a>: <em>"Battling the Module Monster, Again"</em>
</li>
</ul>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0106.html">Admission that Unicode Was Harder Than Thought</a></strong> - <em>" So, Unicode is the focus of our current development, and it must be clearly stated, <em>this is a non-trivial project</em>. Our goal is to have it ready for initial testing by the end of the month. I'll admit that we under-estimated the magnitude of the Unicode project..."</em></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0107.html">R3 Alpha Public Release</a></strong> - This was in January 2008.  My first encounter with the Rebol language was <a href="http://blog.hostilefork.com/computer-languages-as-artistic-medium/">approximately April 2008</a>, and so I didn't use Rebol2 at all... believing from the community that Rebol3 was the hot new thing.  I didn't realize it had only become public that recently, because everyone else who was involved and talking about it was on the inside track I guess.  I don't know if this timing makes me fortunate or unfortunate, but it certainly explains why I never got attached to a Rebol GUI.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0108.html">ISSUE! as a WORD! datatype</a></strong> - I disagree with this decision (as many did), and in Ren-C it is an immutable textual type..used as the implementation for characters as well (characters are just single-character ISSUE!s).  I've proposed renaming these to TOKEN!.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0111.html">BITSET!s</a></strong> - BITSET! is terribly inefficient and buggy, if you try to do things like XOR a negated bitset with another <a href="http://www.rebol.net/r3blogs/0114.html">none of it works right</a>.  If your bitset is sparse (e.g. representing a Unicode character set, as one might do) then it will quickly consume megabytes.  I did some work with <a href="https://roaringbitmap.org/about/">Roaring Bitsets</a> and linked them up as the implementation for bitsets, which worked well but I didn't feel like maintaining the dependency given higher priorities.  But that branch is still around.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0112.html">The ZERO? Question</a></strong> - I hadn't thought of this.  POSITIVE? rejects non-numbers, NEGATIVE? as well, but ZERO? lets you test series as a simple synonym for <code>= 0</code> but then also considers 0:00 to be ZERO?  Ugh.  I like TRASH? (~) as a placeholder better than zero for many reasons, so the single-character-zero-filler argument doesn't apply.  I think ZERO? should apply to numbers only and error on other types.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0113.html">STRING! is not BINARY!</a></strong> - Because R3-Alpha used variable sized encoding for strings inside the system, it couldn't offer you a usefully invariant binary view of strings.  Ren-C can do it <a href="https://forum.rebol.info/t/realistically-migrating-rebol-to-utf8-everywhere/374">because it uses UTF-8 Everywhere</a>, and if you're looking at a BINARY! alias of a TEXT! you can make modifications only if that atomic modification leaves the result as valid UTF-8.  You can also alias WORD!s as TEXT! or as BINARY!, but it will be an immutable view.  The benefits inside the system of sticking to one string encoding are innumerable and well worth all the work.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0115.html">Script Error</a></strong> - Hadn't really thought about it but he has a point here.  Something to consider in an ERROR! redesign, if such a design ever happens.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0127.html">Pruning Down READ and WRITE</a></strong> - Despite <a href="http://www.rebol.net/r3blogs/0109.html">earlier assurances that READ and WRITE give BINARY! and it's LOAD that does the fancy work</a>, this shows some of the confusion slipping in about what READ is...and that's what provoked my own confusion at things like READ/STRING and READ/LINES and READ/AS.  Red has these refinements too.  It's all quite confusing, but Ren-C has the advantage of letting you do <strong><code>as text! read %some-file.txt</code></strong> which gives you a mutable alias over the UTF-8 data with no loss of efficiency.  I haven't killed off READ/STRING or READ/LINES but now I feel I really should... that's LOAD's business to have some convenient syntax for.  (Dialected? <strong><code>load %file.r</code></strong> or <strong><code>load [&lt;text-lines&gt; %file.txt]</code></strong>)</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0135.html">VID Expression Optimization</a></strong> - So this is the first time I've felt there was something to comment on in a GUI post, since it's dialect philosophy.  <a href="https://forum.rebol.info/t/vid-expression-optimization/2202">I started a thread on it</a></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0137.html">MAP! Indexing</a></strong> - Again, this is <a href="https://forum.rebol.info/t/how-much-determinism-should-be-pursued/2057/3">relevant to the determinism I've been discussing</a>, and it's interesting to see there was questioning about it.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0138.html">Multicontext Variable Lookup</a></strong> - Like it or not, this is what we have with Virtual Binding.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0139.html">Find on OBJECT!</a></strong> - He mentions using IN.  But with the binding logic of virtual binding, IN has to return the original item unbound if it wasn't found in the context... so it doesn't give a good answer.  Ren-C uses HAS for this (null if a word not present, vs. the unbound word) and disallows FIND on objects.  Use HAS.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0141.html">RFC: func-local, funclo, funco, funo, funx</a></strong> - Wow, I didn't know the name considerations were so bad...before FUNCTION was chosen.  Ren-C has virtually-bound LET and has dismissed with the bad idea of locals-gathering functions that gather all SET-WORD! as variables.  <a href="https://forum.rebol.info/t/rethinking-auto-gathered-set-word-locals/1150">That is not coherent...</a> SET-WORD!s are used in places where they should not create variables (object keys, other dialects).  So this idea is dead and will only be resurrected as a toy for code golf competitions or similar.  And <a href="https://forum.rebol.info/t/abbreviations-as-synonyms/1211">FUNC and FUNCTION are slated to be synonyms</a>, as all abbreviations are intended to be.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0142.html">Data Conversions that MAKE Sense</a></strong> - This definitely needs to be thought about, but also to eliminate needless duplication between TO and MAKE.  <a href="https://forum.rebol.info/t/hacking-away-on-the-to-and-make-matrix/649">I've written about the differences and the possible rules.</a></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0155.html">PARSE Project</a></strong> - While a lot of this has gone offline, I did <a href="https://trello.com/b/zt7KvVSl/rebol-parse-project-the-trello">preserve the remarks from the wiki on a Trello board</a> (that seriously needs updating, now!).  Sigh.  Hurry up AI, I need you to edit all this for me.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/cgi-bin/r3blog.r?view=0165#comments">Angry Comments About A30 Not-Quite-Public Release</a></strong> - Here it's January 2009.  Rebol 3.0 was certainly positioned in a promise-making and not-delivering way, and Red followed that pattern.  Part of what keeps Ren-C from being completely exhausting is not doing that.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0169.html">Inklings of REWORD</a></strong> - It seems the REWORD we have today started with this discussion, right on the heels of the previous feedback also in January 2009.  The design, authorship, and testing of these things simply add up to so much time... it should have been obvious to anyone reading this at the time this would never be finished.  (I wasn't reading it, I didn't get involved until Rebol became open source in 2012...)</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0173.html">PICKing Negatives and Zero</a></strong> - Have to admit I haven't thought about this at all in years.  Ren-C reverted to the Rebol2 behavior.  In practice, I don't think it comes up enough for people to care.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0178.html">Weird ASSERT/TYPE Refinement</a></strong> - I didn't like it and didn't see the point, so I killed /TYPE.  Ren-C lets you do <strong>ensure object! spec</strong> and <strong>ensure [~null~ tuple!] spec.version</strong> ... you can do your own FOR-EACH enumeration over a block of type/value pairs if you have enough of them to matter.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0179.html">Isolated Namespaces In Modules</a></strong> - <a href="https://forum.rebol.info/t/the-real-story-about-user-and-lib-contexts/764">Turning on isolation was horribly bloated</a>, but Ren-C has <a href="https://forum.rebol.info/t/a-quantum-leap-in-testing-isolating-into-contexts/1680">solved it efficiently</a> and makes it the default for all modules.</p>
<ul>
<li>
<p>May I just say that the code for all of the module stuff--especially isolation--<a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/c-frame.c#L679">is convoluted and buggy</a> with equally buggy usermode portions, and it literally made me give up trying to use my 2018 bootstrap executable for the FENCE! conversion.  I had to go gut the module system to make enough simplifications that it would work at all, and am still dealing with the issues of deploying new cross platform binaries that will serve for at least another year or two.</p>
</li>
<li>
<p>If you're wondering "why not just use a modern Ren-C for bootstrap" the answer is that in most areas unrelated to modules--e.g. places where I worked on hardening it--I can rely on it more than the dark corners of modern executables.  Bootstrap is rather demanding.  Also right now has various in flux instabilities and bad performance.</p>
</li>
</ul>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0184.html">DECODE and ENCODE</a></strong> - I never really got the split in responsibilities between ports and codecs.  We're told that if you want to do streaming hash calculations in chunks on large files to use a PORT! to do it.  But then DECODE and ENCODE aren't light wrappers over a chunking port but rather some very naive functions.  Trivial design that was used as an excuse to make some more weird monolithic C code... there's no architecture, it's just a function table.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0186.html">Read Only Strings, Blocks, and Objects</a></strong> - So apparently PROTECT came along in 2019.  The interesting thing about Rebol being a C codebase with limited type checking is that it was scout's honor for all the code in the system to remember to check the protection bits before making a modification.  Ren-C can build as C++, and <a href="https://forum.rebol.info/t/value-vs-series-modification-bit-const-and-mutable/976/5">enforces the checking of mutability bits before changes with the type system</a>...so if anyone doesn't use a check routine to transition from const to mutable in the C, then when building with C++ that will be caught.  I'm quite proud of that...and it has been working without bugs enforcing CONST as well as PROTECT (and evaluator holds, etc.)</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0189.html">PROTECT/HIDE</a></strong> - While I thought this was kind of cool when I first saw an example, it turns out that this is another features that was added on a whim without a systemic review of the implications.  But for this case I haven't come up with a way to really make it much other than the scout's honor I describe from R3-Alpha's basic protection bit.  I've not killed the feature because hidden bits are used to various effects in things like specializing fields out of frames, but I'm really not sure if it makes sense in other cases.</p>
</li>
</ul>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/more-history-mining-rebol-3-0-front-line-blog/2199">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/more-history-mining-rebol-3-0-front-line-blog/2199</link>
          <pubDate>Tue, 20 Aug 2024 19:49:55 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2199</guid>
          <source url="https://forum.rebol.info/t/more-history-mining-rebol-3-0-front-line-blog/2199.rss">More History Mining: Rebol 3.0 Front Line Blog</source>
        </item>
        <item>
          <title>DEFAULT as Dialect?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Flipping through the entirety of Carl's old Rebol blog, I came across a surprising post in which he considers <a href="https://www.rebol.com/article/0388.html">a trick for implementing DEFAULT using left-quoting in Rebol2</a>.</p>
<p>While it's very odd that there were ways to hack that in, I found myself more curious about the alternative proposal... to have DEFAULT work as a dialect.</p>
<pre><code> x: y: default [10 + 20]  ; can't set X
 default [x: y: 10 + 20]  ; dialect can offer handling of leading SET-WORD!s
</code></pre>
<p>This isn't a situation like comparing <strong>let x: 10</strong> and <strong>let [x: 10]</strong>.  LET doesn't need the block, so you get something inherently messier.  But because the nature of DEFAULT requires the block to suppress evaluation in the case that it doesn't need to do the defaulting, you have it either way. <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<pre><code>  &gt;&gt; x: null
  &gt;&gt; y: &lt;something&gt;

  &gt;&gt; default [x: y: 10 + 20]
  == ???  ; by convention, what's the answer?

  &gt;&gt; x
  == 30

  &gt;&gt; y
  == &lt;something&gt;
</code></pre>
<p>It's a bit of a problem on what the return result would be, and it's a bit misleading because you see on the screen [x: y: 10 + 20] but you get back something where after that <code>x &lt;&gt; y</code>.</p>
<p>I think I'm going to have to go with thinking that the current way is better.  But again, I was a bit surprised to see the Rebol2 backwards-quoting-hack.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/default-as-dialect/2198">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/default-as-dialect/2198</link>
          <pubDate>Tue, 20 Aug 2024 12:47:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2198</guid>
          <source url="https://forum.rebol.info/t/default-as-dialect/2198.rss">DEFAULT as Dialect?</source>
        </item>
        <item>
          <title>Mining History For Anything Relevant: Carl&#39;s Rebol Blog</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>Carl maintained two Rebol blogs.  One was specifically for <a href="https://forum.rebol.info/t/more-history-mining-rebol-3-0-front-line-blog/2199">Rebol 3.0 development issues</a>.  But the other was for more general topics, essays, thoughts.</p>
<p>Here is the first post from February 5, 2008:</p>
<p><a href="https://www.rebol.com/article/0001.html">https://www.rebol.com/article/0001.html : <strong>"Ok, Let's Try It"</strong></a></p>
<p>That blog apparently made it up to 554 posts, stalling out on February 25, 2018:</p>
<p><a href="https://www.rebol.com/article/0554.html">https://www.rebol.com/article/0554.html : <strong>Website Update, New Projects, Fresh Thoughts"</strong></a></p>
<p>But it had been stalling out long before that (post <span class="hashtag">#553</span> was in January of 2016 as part of a little spurt of notes.)</p>
<h2>
<a name="i-decided-to-skim-through-it-for-anything-useful-1" class="anchor" href="https://forum.rebol.info#i-decided-to-skim-through-it-for-anything-useful-1"></a>I Decided To Skim Through It For Anything Useful</h2>
<p>It's a lot of material, but many of them are short (or obviously not relevant to Ren-C's interests).  I'm in a mode of feeling like I'm seeing answers to old questions through the lens of what Ren-C can do today, so I thought I'd flip through them to see if anything caught my attention.</p>
<p>Here are some notes on any thoughts triggered...</p>
<ul>
<li>
<p><strong><a href="https://www.rebol.com/article/0004.html">IO Redirection</a></strong> - Rebol2 and R3-Alpha had many quirks and broken aspects in IO redirection.  Ren-C actually does a pretty good job and <a href="https://github.com/metaeducation/ren-c-stdio/blob/main/.github/workflows/test-stdio.yml">has tests of it</a> in various shells.  At least a bit in part due to my hassling them, PowerShell actually changed the way they did IO to accommodate making binary redirection accommodate us (<a href="https://github.com/PowerShell/PowerShell/issues/1908">many other people wanted it too</a>).</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0015.html">MakeDoc</a></strong> - I have never touched Rebol's MakeDoc, and pretty much only use MarkDown.  Maybe someone who uses MakeDoc needs to write a post about it and if it matters at all in the modern ecology of such standards.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0020.html">HASH!</a></strong> - The predecessor to Rebol's MAP! was a sort of optimization layer on top of blocks, where you still could enumerate them and experience them as blocks.  But people insisted that a conventional key/value store which was dissociated from any order or enumeration structure was better.  But in light of some recent findings about <a href="https://forum.rebol.info/t/how-much-determinism-should-be-pursued/2057/3">Python's Dict becoming order-preserving and deterministic</a>, I wonder if MAP! was a wrong turn after all.  Hmm.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0050.html">Async Ports</a></strong> - Oh my, the <a href="https://forum.rebol.info/t/semantics-of-read-and-tcp-streams-past-and-future/1733/2">beginnings of the nightmare</a>.  Thankfully that's over.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0059.html">NEW-LINE</a></strong> - Naming a function NEW-LINE when NEWLINE is a character constant is pretty confusing.  Ren-C has made a lot of progress here (including controlling terminal newlines in blocks) but never really came up with a good answer for how to better define functions to tweak the meta-formatting information.  There's also a lot to be said about <a href="https://forum.rebol.info/t/testing-generic-tuple-and-path-structuring/1353">newline marker significance in dialects</a>.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0059.html">Mixed Dialects and REDUCE/ONLY</a></strong> - The idea of providing constructs that are more careful about executing code is something I've gone after, but more in terms of primitives like GET and SET not running code in GROUP!s in paths or tuples unless you say so.  It's good to see Carl was thinking about "security" (or clarity).  Ren-C sort of <a href="https://forum.rebol.info/t/make-your-own-safety/1118">drifted away from thinking there's much hope in guessing what people will care about</a>.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0102.html">No Style Guide</a></strong> and <strong><a href="https://www.rebol.com/article/0103.html">Deep Lake</a></strong> - The idea that you use the style that fits you is very critical I think.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0104.html">Context-Dependent Language</a></strong> - Hadn't seen this particular post before.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0108.html">Was XML Flawed From The Start</a></strong> - Yes.  I didn't know it but there is apparently a <a href="https://www.rebol.com/article/0110.html">follow-up post</a>.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0126.html">Building in a DIFF Function</a></strong> - Hmmm.  Not necessarily the worst idea to have one... dialected diff sounds interesting.  But should probably be a module or extension.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0130.html">Rebol Internationalization</a></strong> - In the past I've said it might be interesting to "skin" Rebol in usermode to be in other languages.  Spanish or Chinese PARSE dialect, etc.  UPARSE would let you map the combinators to different words.  It's still interesting, but I think when it comes to stuff like internationalizing messages and error strings... it's probably time to just assume AI will be good enough for that.  I don't think this project is going to do any localization in my lifetime.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0144.html">Modules</a></strong> - <em>"I should mention that modules are the main point of the REBOL 3.0 version."</em> ... so unfortunate they <a href="https://forum.rebol.info/t/the-real-story-about-user-and-lib-contexts/764">more or less did not work at all</a>.  Ren-C has made great progress and things are much more promising, but there sure is a long way to go on the vision of a completely usermode module system that people can customize or override at will.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0153.html">SET and GET on Objects</a></strong> - I dropped this feature, but it does raise another question of determinism in field ordering, as to whether you should even be able to do such a thing.  It seems to me someone needs to lay down the fundamental philosophy about basic issues that persist in Redbols today, like:</p>
<pre><code>red&gt;&gt; obj1: make object! [a: 10 b: 20]
== make object! [
    a: 10
    b: 20
]

red&gt;&gt; obj2: make object! [b: 20 a: 10]
== make object! [
    b: 20
    a: 10
]

red&gt;&gt; obj1 = obj2
== false
</code></pre>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0177.html">Consistency in POKE</a></strong> - Aaah, this reminds me of all the <a href="https://forum.rebol.info/t/get-set-vs-pick-poke-whats-the-difference/1719">"what is picking and poking and setting and getting"</a> semantics issues.  The code is going to need to be revisited for the plan of <strong>obj.method</strong> passing the OBJ to the method as a "coupling".  It was a nightmare to work on, but maybe enough time has passed to where going in and cleaning it up will be "fun".</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0188.html">PARSE words are "commands"?</a></strong> - Hm.  Well, I like "combinators".  In any case, I don't know that I've used the word "command" much if ever.  Should I?</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0206.html">Is Rebol a Pure Functional Language?</a></strong> - No, but it does remind me that I was thinking of making a PURE designator where any function marked pure could only call other pure functions.  Could be a fun experiment.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0214.html">Rebcode</a></strong> - I don't think I ever heard of this (or if I did, confused it with the binary storage REBBIN format or something).  If I had infinite time I'd tinker with something like putting Red/System in the WebAssembly build and generating Wasm, but I don't.  It seems clear in retrospect that this tendency to drift off from language design issues really burned up RebolTech's time.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0229.html">BIND?</a></strong> - While Ren-C's Pure Virtual Binding is humming along running most code, being able to inquire and reflect the compounding environments is going to need a lot of deeper answers than this.  And I still don't know exactly what to do about <a href="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128">attached words</a>...they're just there to keep the ship afloat for the moment.  But worth pointing out that Rebol was pretty far along before it had the ability to query binding (AFAIK Red still doesn't have it, there's no BIND?)</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0233.html">Extending Objects</a></strong> - Thought is needed on this.  It should definitely be a different operation than APPEND.  My feeling is that APPEND on an OBJECT! should be reserved for interacting with that object's concept of what APPEND means (but does that mean it can't have its own idea of what EXTEND means?)</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0278.html">Checksum Ports</a></strong> - We have all the encryption code to do this but understanding what PORT!s are supposed to be keeps this on a very far back burner.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0284.html">RebolTech Priorities</a></strong> - Interesting in light of <a href="https://forum.rebol.info/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179">my own writing on the topic</a>.  It's a different era, where people have so many free tools to choose from... where the <em>only</em> relevance I see is whether the language design offers something truly unique and notable.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0288.html">Source For Carl's Blog</a></strong> - I didn't know he'd published it.  The link is dead, but the Internet Archive has it: <strong><a href="https://web.archive.org/web/20061218060625/http://www.rebol.net/cgi-bin/blog.r?get-source=1"><code>blog.r</code></a></strong>.  I never used the CGI facilities but it's interesting to see that it is indeed just one long single file.  (I'm idly curious about how this would compare to someone trying to do the same thing in PHP.)</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0294.html">Anthropomorphizing Errors</a></strong> - Interesting topic.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0316.html">Two Year Rebol Blog Anniversary</a></strong> - In two years from 2008-2010 the Rebol blog got to 316 out of its 554 total posts.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0338.html">FOLLOW was the original name of ALSO</a></strong> - Who knew.  <a href="https://forum.rebol.info/t/enfixing-also-stylizing-it-after-then-and-else/402">Either way, I don't like it.</a></p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0367.html">PICK with LOGIC!</a></strong> - I never really cared for this.  It's not obvious to me if true is the first item or the second one.  Ren-C has <a href="https://forum.rebol.info/t/soft-quoted-branching-light-elegant-fast/1020">soft-quoted branching</a>, so you can do <strong><code>either (cond) 'this 'that</code></strong> and I find it a lot clearer.  Now that logic is an antiform, it means the whole picking system gets messed up by needing to support antiforms.  Not sure why I didn't kill this off yet...</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0372.html">Reacting to Complaints About Not Communicating</a></strong> - Seems the natives are getting restless around August 2008.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0374.html">Rebol: Not For Everyone</a></strong> - <a href="https://forum.rebol.info/t/rebols-target-market-newbies-experts-or-other/581">I wrote a bit here about this post in 2018</a>.  Should probably see if I have any updated thoughts now that I know more.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0377.html">The GUI: Harder Than It Seems</a></strong> - I've often been puzzled by the obsession the Rebol community has on the cross-platform GUI.  Here we see an admission from Carl that it's harder than it seemed and eating up time.  A prelude to today, where Red seems to drag along indefinitely with it.  I'm pretty well-versed in Rebol design points, yet I find what they're making to largely be gibberish.  HTML and CSS are pervasive, have been modernized with time, and I don't really think the GUI work has shown to be markedly ahead for any non-trivial task.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0382.html">The suffix of Rebol Files</a></strong> - After having campaigned a bit on the side of saying Rebol should accept it doesn't own the "R" language term and use <strong><code>.reb</code></strong> <a href="https://forum.rebol.info/t/revisiting-the-riddle-of-the-r/1664">I changed my mind.</a>  I think it should be <strong><code>.r</code></strong>.  The reason I haven't gone around renaming things is because the disruption it would create doesn't make much sense to do until there's a good reason to go around and muck with all the file organization.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0388.html">Enfix DEFAULT Before Enfix existed</a></strong> - I didn't know this had been considered, much less that you do it in Rebol2.  That's surprising.  The idea of making DEFAULT a dialect taking a BLOCK! is actually not something I had considered, and I'm not completely sure I hate.  You get advantages in the sense that you could potentially default more than one thing...<a href="https://forum.rebol.info/t/default-as-dialect/2198">I'm going to have to think about it.</a></p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0459.html">Announcement of PowerMezz</a></strong> - <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> had at one time undertaken a porting of this to Rebol3, and don't really remember what was in it.  I didn't look too closely.  But it could be a very good place to look for challenging problems in binding and parsing to ask <em>"has Ren-C raised the bar so people trying to do these things can do them more clearly"</em>.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0467.html">CALL/SHOW</a></strong> - Never saw this.  I do think that for a GUI program, /SHOW should be the default.  Worth looking at.  I notice that <a href="https://github.com/microsoft/WSL/issues/6565"><code>call "explorer"</code> returns an exit code of 1</a>, which is now <a href="https://forum.rebol.info/t/making-call-raise-a-definitional-error-for-bad-exit-codes/2068">reported by CALL unless you do CALL/RELAX</a> (or intercept it with EXCEPT).</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0489.html">LIB and SYS</a></strong> - Since I started using Rebol only after R3-Alpha, I'm often surprised to find things that you can't do in Rebol2... such as get the original version of a function if you overwrite it.  I gather that to this day, in Red, if you say <code>append: func [] [print "Hi"]</code> without saving the old-append there's no way to get it back!</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0497.html">Fight Software Complexity Pollution</a></strong> - I cite this one a lot, I should cache it here on the forum and add some comments.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0508.html">Common PARSE Patterns</a></strong> - Link is broken, and internet archive is down, look these up when it comes back.  (Ok it's back and... <a href="https://web.archive.org/web/20110228053052/http://www.rebol.net/wiki/Common_Parse_Patterns">well, not much there</a>).</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0509.html">Simplicity Defined</a></strong> - While I respect that Carl certainly has thrown some unique vision into the mix of computing, no one knows the R3-Alpha code better than I do, and so sometimes these posts ring a bit hollow.  It may have been easier to ramble from on high before the code was open sourced, but really R3-Alpha is every bit the ball of mud he is critiquing!  But it is certainly the case that in its ideal form, Rebol is a rich-enough substrate for expressing one's domain knowledge simply... whereas other mediums (like say, bash) just are unsuitable...but people use them out of expedience or pragmatism.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0510.html">Carl Announces Giving Up</a></strong> - August 2012 solicits opinions on the future, stating: <em>"I also need to tell you that I don't have much time to help out with whatever the REBOL future may be."</em></p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0511.html">Open-Sourcing Announcement</a></strong> - There was a bunch of debate over licensing, I said use the LGPL, it was made Apache to "appeal to more contributors".  Yeah, right.  <a href="https://forum.rebol.info/t/ren-c-license-changed-to-lgpl-3-0/1342">Ren-C has been LGPL since September 2020</a></p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0515.html">Rebol C Documentation Style</a></strong> - Comments in R3-Alpha weren't particularly copious.  Ren-C has tons of them.  I'm pretty pleased with how they're done, and have been adopting a kind of "headnote" style where I don't mix too much commenting directly into the code, but just tack on the end of the line <strong><code>// don't accept groups [3]</code></strong> and then have a section above somewhere that says <code>// 3. The reason that we don't accept groups here is...</code>  Of course, Ren-C has much improved embedding of native function specs directly in the comments above natives as well.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0518.html">"We Need a New Rebol Forum"</a></strong> - I have to wonder how things would have gone if we'd used Discourse earlier.  This question was asked in November of 2012, and Discourse was released in August 2014.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0522.html">Comparing Rebol and JSON</a></strong> - This is interesting because he is using BLOCK! for both arrays and key/value stores.  He glosses over what that winds up meaning for systems interpreting the data.  I'm suspicious that it is insignificant, <a href="https://forum.rebol.info/t/json-envy-serialization-dialect-in-rebol/2140">I wrote a bit about this</a>.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0525.html">Calling REBOL, Rebol</a></strong> - Yes.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0537.html">Rebol Conference, Montreal, 2013</a></strong> - If not for me recording and editing the videos, there wouldn't be much left of it!</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0543.html">FUNCTION and CLOSURE</a></strong> - There's no more CLOSURE in Ren-C <a href="https://forum.rebol.info/t/relative-binding-and-frame-internals/1344">because all the good parts of it are subsumed into every function</a> <em>(at reasonable cost)</em>.  Now I worry over LETs.  Kind of funny to think how much I take for granted these days...</p>
</li>
</ul>
<hr>
<h2>
<a name="and-thats-about-it-2" class="anchor" href="https://forum.rebol.info#and-thats-about-it-2"></a>And That's About It...</h2>
<p>So that took me a few hours, and feels worth it to have done so.  He started a separate Rebol 3.0 tech blog, and after that it was mostly philosophy and administrivia posts.  I'll do a similar survey of the tech blog.</p>
<p>While it seems to me the GUI is the killer of Redbols, it probably is what allowed Rebol2 to get the popularity that it did.  Probably they shouldn't have made any changes to VID or the graphics.  I think there's this tendency to want to go deep and burn time on grid controls or whatever the "one missing thing" is, when if an application is truly of any sophistication then it's always going to run up against the limit of what Rebol can offer.</p>
<hr>
<p>I'll do some posts on the follow-up items here at some point.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/mining-history-for-anything-relevant-carls-rebol-blog/2197">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/mining-history-for-anything-relevant-carls-rebol-blog/2197</link>
          <pubDate>Tue, 20 Aug 2024 11:01:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2197</guid>
          <source url="https://forum.rebol.info/t/mining-history-for-anything-relevant-carls-rebol-blog/2197.rss">Mining History For Anything Relevant: Carl&#39;s Rebol Blog</source>
        </item>
        <item>
          <title>Rendering Difference For Bound/Unbound Code</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Console</category>
          <description><![CDATA[
            <p>With the new binding model tending to have things sparsely bound, it helps to know what is and isn't bound.</p>
<p>It seems to me it would be very useful (and educational) in rich consoles to make the rendering of code reflect the binding status.</p>
<p><img src="https://forum.rebol.info/uploads/default/original/1X/c7cac409fc3ebb1db0467fb9c8c94b531ff1ec11.png" alt="image" data-base62-sha1="svrriultuZqA01aLNlih32dDyRr" width="258" height="201"></p>
<p>So there you can see that a plain block will evaluate so the block itself is bound, while the contents are left unbound.  A quoted block will be all unbound.</p>
<p>Even better would be if you could hover over the bound bits and see what they were bound to.  It may be best if the coloring was very subtle by default (e.g. just bold black vs a dark gray) and then if you hovered, maybe it would colorize it... perhaps even making things bound the same match colors.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rendering-difference-for-bound-unbound-code/2142">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rendering-difference-for-bound-unbound-code/2142</link>
          <pubDate>Thu, 01 Feb 2024 00:13:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2142</guid>
          <source url="https://forum.rebol.info/t/rendering-difference-for-bound-unbound-code/2142.rss">Rendering Difference For Bound/Unbound Code</source>
        </item>
        <item>
          <title>hiiamboris&#39;s WITH</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>I've mentioned that binding might be helped by a dialect, and it turns out there is some precedent in <strong><a href="https://codeberg.org/hiiamboris/red-common/src/branch/master/with.red">hiiamboris's WITH</a></strong>:</p>
<blockquote>
<h3>USAGE SUMMARY</h3>
<pre><code>with x  [..]          == bind [..] x
with 'x [..]          == bind [..] 'x
with :fun [..]        == bind [..] :fun
with [:fun] [..]      == bind [..] :fun
with [x y 'z] [..]    == bind bind bind [..] 'z y x
with [x: 1 y: 2] [..] == bind [..] context [x: 1 y: 2]
</code></pre>
<h3>EXAMPLES</h3>
<h4>omit the path to an object, but work inside it's context:</h4>
<pre><code>do with face/parent/pane/1 [
    color: red
    text: mold color
    visible?: yes
]

if true with system/view/fonts [print [serif size]]

f: func [/- /+ /*] [        ;-- redefines important globals locally
    (do something with local flags)
    foreach x [set..] with system/words [
        (do something with global * + -)
    ]
]
</code></pre>
<h4>create static storage for functions where existing literal forms don't allow you to:</h4>
<pre><code>factorial: func [x] with [cache: make hash! [0 1]] [
    any [
        select/skip cache x 2
        put cache x x * factorial x - 1
    ]
]
</code></pre>
<h4>anonymize words used during initialization of the program:</h4>
<pre><code>first item in the block should be of set-word! type

do with [x: 1 y: 2] [
    z: x * y
    ... other code that uses x or y ...
]
</code></pre>
<h4>bind a block to multiple contexts at once (in the list order):</h4>
<p>First item in the block should be of word!/get-word!, path!/get-path! or lit-word! type</p>
<ol>
<li>
<p>words and paths values are fetched, while lit-words are converted into words<br>
get-words and get-paths should be used for function context, otherwise they get evaluated</p>
</li>
<li>
<p>if resulting value is a context, block is bound to it<br>
if resulting value is a word, block is bound to the context of this word</p>
<p>the following example illustrates usage of words and lit-words:</p>
<pre><code>a: b: x: y: none
c: context [
    a: 1
    b: 2
    f: func [x y] [
       ; calls `with` internally
       print composite [self 'x] "a=(a) b=(b) x*y=(x * y)"
       ; equivalent
       print composite [self :f] "a=(a) b=(b) x*y=(x * y)"
    ]
]
</code></pre>
</li>
</ol>
<p>Thus, <code>with [c]</code> is equivalent to <code>with c</code>, while <code>with ['c]</code> - to <code>with 'c</code>.</p>
<h3>WHY IS IT DESIGNED LIKE THIS?</h3>
<ol>
<li>
<p>It does not evaluate</p>
<p><code>with</code> does not evaluate the block, so:</p>
<ul>
<li>it can be used after <code>context</code>s, <code>if</code>s, <code>loop</code>s, <code>func</code>s, etc.</li>
<li>it can be chained <code>with x with y ...</code></li>
</ul>
<p>I've found that this makes code much more readable than it would be with <code>bind</code>.<br>
Prefix it with <code>do</code> if you want immediate evaluation.</p>
</li>
<li>
<p>It accepts blocks</p>
<p>Design question here was - if we allow block! for <code>ctx</code>, how should we treat it?</p>
<ul>
<li>
<p>convert it to a context? <code>ctx: context ctx</code></p>
<p>that shortens the <code>with context [locals...] [code]</code> idiom</p>
</li>
<li>
<p>list multiple contexts in a block as a sequence and bind to each one?</p>
<p>that shortens <code>with this with that [code]</code> idiom</p>
</li>
</ul>
<p>Personally, I've used the 1st at least a few times, but 2nd - never, though I admit there are use cases.<br>
This can be solved by checking type of the 1st item in the block is a set-word or not <img src="https://forum.rebol.info/images/emoji/twitter/wink.png?v=12" title=":wink:" class="emoji" alt=":wink:" loading="lazy" width="20" height="20"><br>
But still ambiguous! When <code>with</code> gets a <code>word!</code> argument it can:</p>
<ul>
<li>get the value of this word, which should be an <code>object!</code>, and bind to this object</li>
<li>get the context of this word, and bind to this context</li>
</ul>
<p>When inside a context, 2nd option is nice:</p>
<pre><code>context [
    a: 1
    f: func [x y] [
        with [self x] [x * y * a]
    ]
 ]
</code></pre>
<p>..where the alternative would be:</p>
<pre><code>context [
    a: 1
    f: func [x y] [
        with context? 'x with self [x * y * a]
    ]
]
</code></pre>
<p>When outside of it, 1st option is better:</p>
<pre><code>x: context [x: 10]
y: context [y: 20]
do with [x y] [x * y]
</code></pre>
<p>..where the alternative would be:</p>
<pre><code>x: context [x: 10]
y: context [y: 20]
do with in x 'x with in y 'y [x * y]
</code></pre>
<p>But this still can be solved: let <code>word!</code>s evaluate to contexts and <code>lit-word!</code>s, same as we have <code>bind code ctx</code> vs <code>bind code 'ctx</code>:</p>
<pre><code>context [
    a: 1
    f: func [x y] [
        with [self 'x] [x * y * a]
    ]
]

x: context [x: 10]
y: context [y: 20]
do with [x y] [x * y]
</code></pre>
</li>
</ol>
</blockquote>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/hiiamboriss-with/2138">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/hiiamboriss-with/2138</link>
          <pubDate>Tue, 30 Jan 2024 21:14:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2138</guid>
          <source url="https://forum.rebol.info/t/hiiamboriss-with/2138.rss">hiiamboris&#39;s WITH</source>
        </item>
        <item>
          <title>The Fate of Redbol Emulation In A Mostly Unbound World</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>100% Emulation of historical Rebol was always going to be impossible.  But if we go forward with the model that most code is unbound, that's going to break even code that didn't do anything sophisticated with binding.  Not only will any values you PICK out of a block or iterate over be unbound, but even basic quoting won't be bound:</p>
<p>e.g. this won't work:</p>
<pre><code>rebol2&gt;&gt; thing: 10

rebol2&gt;&gt; foo: func [w [word!]] [return get w]

rebol2&gt;&gt; foo 'thing
== 10
</code></pre>
<p>I had a problem with this in emulating my very, very old whitespace interpreter.  It <a href="https://github.com/hostilefork/rebol-whitespacers/blob/1d69ea0e79e60ba79fe680d3af657d0823dcbe9e/historical/whitespace-old.reb#L595">quoted ADD</a> and then <a href="https://github.com/hostilefork/rebol-whitespacers/blob/1d69ea0e79e60ba79fe680d3af657d0823dcbe9e/historical/whitespace-old.reb#L424">put it in a block</a>, expecting a DO of that block to run the ADD it meant.</p>
<h2>
<a name="simulating-waves-of-binding-probably-impractical-1" class="anchor" href="https://forum.rebol.info#simulating-waves-of-binding-probably-impractical-1"></a>Simulating Waves of Binding (Probably?) Impractical</h2>
<p>You might think that so long as every word can still hold a binding, then historical behavior could be simulated by manually binding everything.</p>
<p>When a module loads, you could walk through it binding every word.  Then when a function runs, you could copy its body and walk through it...overwriting those module bindings for functions and arguments.</p>
<p>But it would really mean rewriting everything.  You'd have to redo MAKE OBJECT!, otherwise the <a href="https://forum.rebol.info/t/sticky-set-word-binding-problem-in-make-object/2127">indiscriminate binding would break its expectations</a>--as it doesn't override explicit binding anymore.</p>
<h2>
<a name="hooked-evaluator-may-fix-some-cases-2" class="anchor" href="https://forum.rebol.info#hooked-evaluator-may-fix-some-cases-2"></a>Hooked Evaluator May Fix (Some) Cases</h2>
<p>We already are going to need a hooked evaluator to handle things like PATH! looking up in objects (done presently with a hack to the main evaluator).</p>
<p>Another hook could just say that quoted things wound up bound under the same rules that non-quoted things use.</p>
<p>That would make this one whitespace example work, and maybe it would be able to run some more simple historical example scripts.  But anything that mixes COMPOSE and DO is likely doomed.</p>
<p>This may just be the price of progress.  Rebol2 emulation remains a good experiment of changing your baseline library, and it still would be a good example of that... for all the changes to primitives like FUNC and APPEND etc.  It just may not be able to accommodate the different expectations of binding.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/the-fate-of-redbol-emulation-in-a-mostly-unbound-world/2131">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-fate-of-redbol-emulation-in-a-mostly-unbound-world/2131</link>
          <pubDate>Tue, 23 Jan 2024 15:11:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2131</guid>
          <source url="https://forum.rebol.info/t/the-fate-of-redbol-emulation-in-a-mostly-unbound-world/2131.rss">The Fate of Redbol Emulation In A Mostly Unbound World</source>
        </item>
  </channel>
</rss>

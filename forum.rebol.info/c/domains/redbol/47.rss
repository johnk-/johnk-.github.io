<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Redbol - AltRebol</title>
    <link>https://forum.rebol.info/c/domains/redbol/47</link>
    <description>Topics in the &#39;Redbol&#39; category Issues regarding compatibility and emulation of &lt;a href=&quot;http://www.rebol.com/docs/docs.html&quot;&gt;Rebol2&lt;/a&gt; and &lt;a href=&quot;https://www.red-lang.org/p/about.html&quot;&gt;Red&lt;/a&gt;.</description>
    
      <lastBuildDate>Tue, 23 Jan 2024 15:11:47 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/domains/redbol/47.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>The Fate of Redbol Emulation In A Mostly Unbound World</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>100% Emulation of historical Rebol was always going to be impossible.  But if we go forward with the model that most code is unbound, that's going to break even code that didn't do anything sophisticated with binding.  Not only will any values you PICK out of a block or iterate over be unbound, but even basic quoting won't be bound:</p>
<p>e.g. this won't work:</p>
<pre><code>rebol2&gt;&gt; thing: 10

rebol2&gt;&gt; foo: func [w [word!]] [return get w]

rebol2&gt;&gt; foo 'thing
== 10
</code></pre>
<p>I had a problem with this in emulating my very, very old whitespace interpreter.  It <a href="https://github.com/hostilefork/rebol-whitespacers/blob/1d69ea0e79e60ba79fe680d3af657d0823dcbe9e/historical/whitespace-old.reb#L595">quoted ADD</a> and then <a href="https://github.com/hostilefork/rebol-whitespacers/blob/1d69ea0e79e60ba79fe680d3af657d0823dcbe9e/historical/whitespace-old.reb#L424">put it in a block</a>, expecting a DO of that block to run the ADD it meant.</p>
<h2>
<a name="simulating-waves-of-binding-probably-impractical-1" class="anchor" href="https://forum.rebol.info#simulating-waves-of-binding-probably-impractical-1"></a>Simulating Waves of Binding (Probably?) Impractical</h2>
<p>You might think that so long as every word can still hold a binding, then historical behavior could be simulated by manually binding everything.</p>
<p>When a module loads, you could walk through it binding every word.  Then when a function runs, you could copy its body and walk through it...overwriting those module bindings for functions and arguments.</p>
<p>But it would really mean rewriting everything.  You'd have to redo MAKE OBJECT!, otherwise the <a href="https://forum.rebol.info/t/sticky-set-word-binding-problem-in-make-object/2127">indiscriminate binding would break its expectations</a>--as it doesn't override explicit binding anymore.</p>
<h2>
<a name="hooked-evaluator-may-fix-some-cases-2" class="anchor" href="https://forum.rebol.info#hooked-evaluator-may-fix-some-cases-2"></a>Hooked Evaluator May Fix (Some) Cases</h2>
<p>We already are going to need a hooked evaluator to handle things like PATH! looking up in objects (done presently with a hack to the main evaluator).</p>
<p>Another hook could just say that quoted things wound up bound under the same rules that non-quoted things use.</p>
<p>That would make this one whitespace example work, and maybe it would be able to run some more simple historical example scripts.  But anything that mixes COMPOSE and DO is likely doomed.</p>
<p>This may just be the price of progress.  Rebol2 emulation remains a good experiment of changing your baseline library, and it still would be a good example of that... for all the changes to primitives like FUNC and APPEND etc.  It just may not be able to accommodate the different expectations of binding.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-fate-of-redbol-emulation-in-a-mostly-unbound-world/2131">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-fate-of-redbol-emulation-in-a-mostly-unbound-world/2131</link>
          <pubDate>Tue, 23 Jan 2024 15:11:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2131</guid>
          <source url="https://forum.rebol.info/t/the-fate-of-redbol-emulation-in-a-mostly-unbound-world/2131.rss">The Fate of Redbol Emulation In A Mostly Unbound World</source>
        </item>
        <item>
          <title>Websocket Support in Oldes Rebol3</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>Looking to see what Oldes has been up to, he added some kind of minimal websocket support to the HTTP scheme:</p>
<p><a href="https://github.com/Oldes/Rebol3/commit/bae6cffe97e662ec9a727a01cdcc1fdd61455ea6#diff-490ba807ac4a5ee57e7a587ca0936d36e4c0ff2798b0652fdf791e758ce079c2R718" class="inline-onebox">FEAT: Minimalistic WebSocket support in the `httpd` scheme · Oldes/Rebol3@bae6cff · GitHub</a></p>
<p>Websockets isn't something I'm looking into at this time, but I wanted to bookmark it here in case it comes up later.</p>
<p>He also updated zlib to a new version released in 2022... and <a href="https://github.com/Oldes/Rebol3/commit/15fcc00b84f6d0e386f2ba2f4fc7bdc32ebff75d">used Ren-C's %make-zlib.r to do it!</a>.  But he edited it so he'd be able to run it under his Rebol3.  It's not a huge priority to do that update, but seems like since his ported script still worked, it might not be too hard.  (And a good reminder that script exists, and should be part of a CI test...)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/websocket-support-in-oldes-rebol3/2003">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/websocket-support-in-oldes-rebol3/2003</link>
          <pubDate>Fri, 06 Jan 2023 03:56:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2003</guid>
          <source url="https://forum.rebol.info/t/websocket-support-in-oldes-rebol3/2003.rss">Websocket Support in Oldes Rebol3</source>
        </item>
        <item>
          <title>R3-Alpha&#39;s DATATYPE! Definition</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>You likely know that DATATYPE! in R3-Alpha (Rebol 2, Red...) has a distinct "type byte" in the cell.  So the implementation can tell it's a different thing, even if not all representations show that:</p>
<pre><code>r3-alpha&gt;&gt; block: reduce ['integer! integer!]
== [integer! integer!]

r3-alpha&gt;&gt; type? first block
== word!

r3-alpha&gt;&gt; type? second block
== datatype!
</code></pre>
<p>One way R3-Alpha has to see the difference is with MOLD/ALL</p>
<pre><code>r3-alpha&gt;&gt; mold/all block
== "[integer! #[datatype! integer!]]"
</code></pre>
<h2>
<a name="but-whats-actually-in-a-datatype-cell-1" class="anchor" href="https://forum.rebol.info#but-whats-actually-in-a-datatype-cell-1"></a>But What's Actually <em>in</em> a DATATYPE! Cell?</h2>
<p>This was <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/include/sys-value.h#L106">the definition struct from R3-Alpha</a>:</p>
<pre><code>typedef struct Reb_Type {
    REBINT type;  // base type
    REBSER *spec;
    // REBINT min_type;
    // REBINT max_type;
} REBTYP;
</code></pre>
<p>So an integer to say what <strong><code>type</code></strong> it is (e.g. REB_INTEGER = 1, REB_LOGIC = 2, REB_BLOCK = 3 or whatever).  Note that this in the <em>payload</em> of the cell, not the header...because the type in the header is REB_DATATYPE to say it carries a "datatype payload".</p>
<p>Who knows what the commented-out <strong><code>min_type</code></strong> and <strong><code>max_type</code></strong> were.  But a remark says this payload is for a "Datatype or pseudo-datatype".  We can guess these were for pseudo-datatypes as a way of specifying a range of REB_XXX numbers to implement categories like ANY-SERIES!, as an alternative to typesets (?)</p>
<p>The <strong><code>spec</code></strong> is actually an object, that comes back as the answer to SPEC-OF:</p>
<pre><code>r3-alpha&gt;&gt; spec-of integer!
== make object! [
    title: "64 bit integer"
    type: 'scalar
]
</code></pre>
<p>This limited amount of information was built into the executable from the <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/boot/typespec.r#L24">Rebol-format table table in %typespec.r</a>.</p>
<p>You needed to use SPEC-OF to access these properties, but it could have been accessible with paths, e.g. <strong>integer!/title</strong>.  And it might have had more interesting properties:</p>
<pre><code>&gt;&gt; integer!/max-value
== 9223372036854775807
</code></pre>
<h2>
<a name="all-redbols-conflated-the-looks-of-datatype-and-word-2" class="anchor" href="https://forum.rebol.info#all-redbols-conflated-the-looks-of-datatype-and-word-2"></a>All Redbols Conflated The Looks of DATATYPE! and WORD!</h2>
<p>In lockstep, they all did it:</p>
<pre><code>rebol2&gt;&gt; integer!
== integer!

r3-alpha&gt;&gt; integer!
== integer!

red&gt;&gt; integer!
== integer!
</code></pre>
<p>Since I have <a href="https://forum.rebol.info/t/boron-language/1976">Boron</a> built, I find it renames integer! to int!, but otherwise the same:</p>
<pre><code>)&gt; int!
== int!

)&gt; type? int!
== datatype!

)&gt; type? first [int!]
== word!
</code></pre>
<p><strong>It seemed to me that this conflation couldn't possibly be the best answer.</strong>  So I made Ren-C buck this trend to use the R3-Alpha construction syntax, because it was something that could LOAD back:</p>
<pre><code>&gt;&gt; integer!
== #[datatype! integer!]

&gt;&gt; load "#[datatype! integer!]"
== [#[datatype! integer!]]
</code></pre>
<p><strong>Rendering differently was good, but the specific different rendering wasn't all that palatable.</strong>  And it wasn't showing it as any complex object.</p>
<h2>
<a name="where-to-go-from-there-3" class="anchor" href="https://forum.rebol.info#where-to-go-from-there-3"></a>Where To Go From There?</h2>
<p>There seemed to be two directions to go with this:</p>
<ul>
<li>
<p>Accept DATATYPE! as some kind of alien complex type which has ugly rendering</p>
</li>
<li>
<p>Fit it into the lexical space somewhere.</p>
</li>
</ul>
<p>Ren-C has moved toward the idea of making datatypes a BLOCK! variant, decorated with &amp;:</p>
<pre><code>&gt;&gt; type of integer!
== &amp;[integer]
</code></pre>
<p>The details of what structure is used on these type blocks is still under consideration at time of writing.  See the threads in the forum's <a href="https://forum.rebol.info/c/development/datatypes/45">Datatypes Category</a></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/r3-alphas-datatype-definition/1978">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/r3-alphas-datatype-definition/1978</link>
          <pubDate>Sat, 24 Sep 2022 08:02:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1978</guid>
          <source url="https://forum.rebol.info/t/r3-alphas-datatype-definition/1978.rss">R3-Alpha&#39;s DATATYPE! Definition</source>
        </item>
        <item>
          <title>Boron Language</title>
          <dc:creator><![CDATA[WickedSmoke]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>Hello, Boron author here.  I look in on the Ren-C project once a year or so to see what's going on.  A few times I have considered joining this forum but for various reasons have not done so.  Since you have made space for similar projects, now seems like a good time to touch base.</p>
<p>Boron is my daily driver for scripting and has been in a stable period for years.  Bugfix releases occur roughly once per year.  I should have been making release announcements on the mailing list, but as there is no community of active users I didn't bother.  To exercise the language I have used it in the <a href="http://xu4.sourceforge.net/" rel="noopener nofollow ugc">xu4 project</a> to replace the XML configuration and scripting.</p>
<p>The next period of change may include support for static strings (ala AltScript), optimized path! storage, and reworking the evaluator to support yielding.</p>
<p>Games and graphics are an interest of mine so the Boron-GL project is where I experiment with GUIs, shaders, and such.  Some of the work on xu4 such as font rendering and the <a href="https://wickedsmoke.github.io/faun/" rel="noopener nofollow ugc">Faun</a> library will make it's way into Boron-GL.  The GL code was part of the main Boron repository until the end of 2019.</p>
            <p><small>12 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/boron-language/1976">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/boron-language/1976</link>
          <pubDate>Sat, 17 Sep 2022 14:39:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1976</guid>
          <source url="https://forum.rebol.info/t/boron-language/1976.rss">Boron Language</source>
        </item>
        <item>
          <title>Calling Ren Functions From Redbol</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>When you <strong><code>import @redbol</code></strong> the environment for your module is skinned with the Redbol definitions.  But it can run concurrently with non-Redbol modules in the same session.  This is very cool.</p>
<p>I've nudged it a little further into cool by having the definition of LIB in Redbol be the initial state of the Redbol definitions, and then REN is the Ren-C's version of LIB.</p>
<pre><code>&gt;&gt; import @redbol

&gt;&gt; append [a b c] [d e]
== [a b c d e]

&gt;&gt; append/only [a b c] [d e]
== [a b c [d e]]

&gt;&gt; ren/append [a b c] [d e]
== [a b c [d e]]

&gt;&gt; ren/append [a b c] ren/spread [d e]
== [a b c d e]

&gt;&gt; append: does [print "Overwritten"]
== #[action! {append} []]

&gt;&gt; append
Overwritten

&gt;&gt; lib/append [a b c] [d e]
== [a b c d e]
</code></pre>
<p><em>Pretty slick.</em></p>
<h2>But IMPORT is Ultimately Not The Right Mechanism</h2>
<p>Because it's done using import, Redbol does not "clear out" the space of all the Ren-Cisms.</p>
<p>In fact, I didn't actually have to say <strong>ren/spread</strong> because the spread definition is still available:</p>
<pre><code>&gt;&gt; ren/append [a b c] spread [d e]
== [a b c d e]
</code></pre>
<p>It's non-viable to ask Redbol to remove every Ren-C definition.  Instead, there needs to be a way to get a Redbol-using module to start from a fully clean slate where it explicitly exports everything it wants to make available.  This doesn't have to be that much work, it can just be a list of words in a block, with possible renamings:</p>
<pre><code>redbol-inherit [even?, odd?, value?: unset? ...]
</code></pre>
<h2>These Challenges Are Great For Vetting</h2>
<p>I don't throw softballs.  This is all truly attempting to live up to the hype of a language that you can bend and redefine at will, without constantly tripping over your own changes--and being able to build on top of existing functionality without being forced to rewrite it too.</p>
<p>Although things move slowly... the arrow of progress is in the right direction.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/calling-ren-functions-from-redbol/1934">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/calling-ren-functions-from-redbol/1934</link>
          <pubDate>Sat, 20 Aug 2022 21:05:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1934</guid>
          <source url="https://forum.rebol.info/t/calling-ren-functions-from-redbol/1934.rss">Calling Ren Functions From Redbol</source>
        </item>
        <item>
          <title>Redbol Adaptation to get /ONLY on APPEND, INSERT...</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p><a href="https://forum.rebol.info/t/the-long-awaited-death-of-only/1607">/ONLY is Dead</a>...<em>but</em> Ren-C's flexibility means you can get it back if you want it, and not break a sweat doing so.   You just become responsible for figuring out what its universal meaning is.  (<span class="hashtag">#goodluckwiththat</span>)</p>
<p>Remember that AUGMENT lets you add parameters to functions.</p>
<pre><code>&gt;&gt; foo: func [x] [print ["x is" mold x]]
&gt;&gt; parameters of :foo
== [x]

&gt;&gt; foo+: augment :foo [/only "An ONLY parameter"]
&gt;&gt; parameters of :foo+
== [x /only]

&gt;&gt; foo+ 10
x is 10

&gt;&gt; foo+/only 10
x is 10
</code></pre>
<p>But adding parameters doesn't actually do anything but expand the specification.  You have to use another tool like ADAPT or ENCLOSE to make use of the new parameters that FOO never knew about.</p>
<pre><code>&gt;&gt; foo++: adapt :foo+ [print either only ["/ONLY!"] ["no /ONLY"]]

&gt;&gt; foo++ 10
no /ONLY
x is 10

&gt;&gt; foo++/only 10
/ONLY!
x is 10
</code></pre>
<p>So here's an ONLIFY transformer that adds a refinement to a function, and then injects a little code to pre-process the parameter to make a splice (group isotope) via SPREAD if needed.</p>
<pre><code>onlify: lambda [
    {Add /ONLY behavior to APPEND, INSERT, CHANGE}
    action [action?]
][
    adapt (augment :action [/only "Use quoted semantics for value"]) [
        all [not only, any-array? series, any-array? value] then [
            value: spread value
        ]
        ; ...fall through to normal handling
    ]
]
</code></pre>
<p>Then you can apply it to the functions:</p>
<pre><code>append: my onlify  ; e.g. `append: onlify :append` 
insert: my onlify
change: my onlify
</code></pre>
<p>And there you have it:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c d e]

&gt;&gt; append/only [a b c] [d e]
== [a b c [d e]]
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/redbol-adaptation-to-get-only-on-append-insert/2081">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/redbol-adaptation-to-get-only-on-append-insert/2081</link>
          <pubDate>Thu, 21 Jul 2022 09:11:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2081</guid>
          <source url="https://forum.rebol.info/t/redbol-adaptation-to-get-only-on-append-insert/2081.rss">Redbol Adaptation to get /ONLY on APPEND, INSERT...</source>
        </item>
        <item>
          <title>Old Idea from DocKimbel For Rebol2 =&gt; Rebol3/Red</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>This is something I just ran across from a long time ago, which I thought would be interesting to look at with modern eyes.</p>
<p>It's a Gist: <a href="https://gist.github.com/dockimbel/5083375">https://gist.github.com/dockimbel/5083375</a> of a proposal of actually making a DO variant that would rewrite the source of a script.</p>
<p>He is quoted as having said: <em>"A JIT-migration tool would be more accurate. It would run just after LOAD and before DO to rewrite part of the R2 sources in a R3 compatible format."</em></p>
<p>Static analysis of Turing-Complete programs is notoriously on the difficult-if-not-impossible scale, even for simple languages.  So JIT-rewriting even something like PARSE rules is only going to be feasible if those rules were not built by code.</p>
<p>His example just looks for one source pattern (negative literal indexing, so like translating between <strong><code>data/0</code></strong> and <strong><code>data/-1</code></strong>).  But determining what is "code" and what is "data" is deliberately more complex in Rebol than other language.</p>
<p>In Ren-C we have code like <code>enbin [BE +/- 32]</code> and that path is never meant to execute, it's just there to convey the notion of wanting to encode a signed number.  Going around and randomly turning all paths with 0 in them to be -1 misses the whole point of "relative expressions"; you don't know what they're relative to.</p>
<p>So the ironic point of preserving this is just to say "nothing to see, here".  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:">  <code>%redbol.reb</code> is a saner track.  But I do think it's going to wind up requiring DO itself being different... a DO2 (like UPARSE2).  It won't rewriting the code block given, but hook the evaluator with different rules.</p>
<pre><code>REBOL [
    Author:  "Nenad Rakocevic"
    Date:      04/03/2013
    Purpose: {
        Show how to achieve R2 source rewriting suitable for evaluation
        using R3 interpreter.
    }
        Note: "Use it from %Red/ folder"
]

context [
    do*: s: none
    
    path-rewrite: [
        some [
            s: integer! (if negative? s/1 [s/1: s/1 + 1])
            ;| handle other indexed-access cases here
            | skip
        ]
    ]

    patched-do: func [value /arg /local saved rule mark path file][
        unless file? :value [return do* value]

        saved: system/script/path
        set [path file] split-path :value
        change-dir path
        value: load file

        parse value rule: [
            any [
                mark: [path! | set-path! | lit-path!] :mark into path-rewrite
                ;; | mark: string! :mark into string-rewrite 
                ;; add more rewritting rules here
                | mark: any-block! :mark into rule
                | skip
            ]
        ]
        also 
            do* value
            system/script/path: saved
    ]
    
    set 'do-r2 func [blk [block!]][
        do*: :do
        set 'do :patched-do
        do blk
        set 'do :do*
    ]
]

do-r2 [
    do %red/compiler.r
]
save %red.new red  ;-- inspect the file to see the changes
halt</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/old-idea-from-dockimbel-for-rebol2-rebol3-red/1814">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/old-idea-from-dockimbel-for-rebol2-rebol3-red/1814</link>
          <pubDate>Sat, 14 May 2022 04:12:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1814</guid>
          <source url="https://forum.rebol.info/t/old-idea-from-dockimbel-for-rebol2-rebol3-red/1814.rss">Old Idea from DocKimbel For Rebol2 =&gt; Rebol3/Red</source>
        </item>
        <item>
          <title>Could Ren-C and Red Interoperate (and if so, *should* they?)</title>
          <dc:creator><![CDATA[Cplus]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>When this year can we expect to see full "message passing" inter-operability between Ren-C and Red?</p>
<p>The very basics - MOLD and SAVE are almost in place.</p>
<p>The "binary" equivalent with some form of compatible REBBIN is surely not that hard to agree between the two sets of developers.</p>
<p>Fuller, fluid, message passing - for example the seamless invoking of functions and continuations within a running instance of the other language would be an important demonstration of the REBOL cousins' languages abilities to do what they have stated is a desired characteristic of their respective dialects of REBOL.</p>
<p>This would also harness the strengths of both dialects - for each has been focused these last few years on different arenas. Together, they have the makings of a formidable whole.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/could-ren-c-and-red-interoperate-and-if-so-should-they/1787">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/could-ren-c-and-red-interoperate-and-if-so-should-they/1787</link>
          <pubDate>Fri, 04 Feb 2022 19:20:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1787</guid>
          <source url="https://forum.rebol.info/t/could-ren-c-and-red-interoperate-and-if-so-should-they/1787.rss">Could Ren-C and Red Interoperate (and if so, *should* they?)</source>
        </item>
        <item>
          <title>Rye Language (?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>So here's another language which doesn't look very Rebol-like but is by Refaktor who is Rebol-inspired:</p>
<aside class="onebox githubfolder">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/refaktor/rye" target="_blank" rel="noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/345;"><img src="https://opengraph.githubassets.com/3ad528c104949fae4387e929b09b31d12ba3905edeab545835a3510860186ae7/refaktor/rye" class="thumbnail" width="690" height="345"></div>

<h3><a href="https://github.com/refaktor/rye" target="_blank" rel="noopener">GitHub - refaktor/rye: work in progress dynamic programming language</a></h3>


  <p><span class="label1">work in progress dynamic programming language. Contribute to refaktor/rye development by creating an account on GitHub.</span></p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>Notably, it is written in Go.  <em>(I've mentioned that increasingly I have been leaning toward modeling things after Go for a runtime.  It would of course be easier to do by actually writing the runtime in Go, vs. trying to reproduce the effect in low-level C code.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"> )</em></p>
<p>It's probably very interesting, but I don't really feel like looking at it right at this moment.  Maybe someone else can study it and explain what it's about in a reply here.</p>
<p>The main carry-away I'll take for the moment is the 1:1 language-designer:user ratio that Rebol users are inevitably converging toward.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rye-language/1768">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rye-language/1768</link>
          <pubDate>Sun, 05 Dec 2021 16:21:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1768</guid>
          <source url="https://forum.rebol.info/t/rye-language/1768.rss">Rye Language (?)</source>
        </item>
        <item>
          <title>Kaj Gets on the Meta Train</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>So Kaj is still out there somewhere, working on a spiritual competitor to Red he is calling "Meta". <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=9" title=":roll_eyes:" class="emoji" alt=":roll_eyes:"></p>
<p><a href="https://language.metaproject.frl/">https://language.metaproject.frl/</a></p>
<p>His first target is the Atari 2600 <img src="https://forum.rebol.info/images/emoji/twitter/joystick.png?v=9" title=":joystick:" class="emoji" alt=":joystick:"><img src="https://forum.rebol.info/images/emoji/twitter/space_invader.png?v=9" title=":space_invader:" class="emoji" alt=":space_invader:">  so he's certainly starting from... the basics.</p>
<p><em>(For whatever it's worth, I actually am interested in things like Atari 2600 programming and seeing what you can do with modern tools.  e.g. there's a neat <a href="https://youtu.be/4X1NdKvNCYQ?t=459">reboot of PAC-MAN</a> and I think a lot of people would like to know what <strong>could</strong> have been done, theoretically.)</em></p>
<p>There's no source code by which to measure the amount of investment the project represents so far.  He's only giving out binaries, and says:</p>
<blockquote>
<p>"There will always be a free version of <em>Meta</em>. We will build a business on top of it, by offering paid premium versions and other products built with <em>Meta</em>."</p>
</blockquote>
<h2>What's The Mission Difference From Red?</h2>
<p>Seemingly not much.  But inevitably, one angle is going to be "faster":</p>
<blockquote>
<p>"Red/System is the wrong abstraction level and the wrong format for an intermediate language, certainly for a REBOL language. The abstraction level is that of C, which is too low for the intermediate layer. The format is that of REBOL, which is free form for human use. Red is parsed from free form to something more suitable for machine processing, then a lot of Red/System is generated, then all of that needs to be reparsed. The compiler is painfully slow."</p>
</blockquote>
<p>But he's willing to build on LLVM to start with.  I'd said that Red should aim for a LLVM-subset IR, that could then be built with either a simple/small custom emitter or the full "bloated" toolchain if one really wanted to.  That would have provided a fallback; but Nenad wasn't a fan of the LLVM instruction set for some reason, and had ideas about exposing lower-level CPU features (maybe that was why).</p>
<p>So at least in this sense Kaj's approach seems more pragmatic to me.</p>
<p>Also inevitably: having people to work with was slowing him down.  He'll make much more progress on his own, <a href="https://atariage.com/forums/topic/315558-a-new-language-for-the-atari/?tab=comments#comment-4719124">as we find from his Atari Forum post</a>:</p>
<blockquote>
<p>Red was launched on a REBOL conference of mine in the Netherlands. I helped launch the language and contributed to it for half a decade. After that I left the project, because I am disappointed that it hasn't fulfilled its promises.</p>
<p>Before all that, I contributed to the latest version of REBOL and lobbied its creator Carl Sassenrath to open-source it. It eventually was, and REBOL could have done most of what Red promised, but Carl abandoned it when his funding ran out. After the leader left, the project was torn apart by competing interests.</p>
<p>My language is meant to succeed both REBOL and Red.</p>
</blockquote>
<h2>There's only ONE Download for Windows, Linux, Mac...?</h2>
<p>On the surface this seems interesting: he's using something called the <a href="https://justine.lol/ape.html">"APE: Actually Portable Executable"</a> format.  You can use a single download for all platforms--the same single file.  It puts x86 code into a container that can run as either a Windows .COM file or a unix shell script.</p>
<p>It's a stunt which isn't really all <em>that</em> profound--though I'll admit I'd wondered if there was some polyglot trick that could do exactly this.  Turns out the answer is yes...so that's cool.  I'm glad someone did it.</p>
<p>But it has more relevance to writing viruses than it does to practical cross-platform development.  Launching the code is a drop in the bucket compared to all the other things you need to worry about in a useful platform abstraction layer.  Not to mention that obviously Macs are now on ARM, so the binaries would have to be emulated or include both instruction sets.</p>
<p>At this juncture, running WebAssembly in a browser is far more compelling a story...because you have the whole web runtime available.</p>
<p>Anyway I doubt he's married to the APE format and is just trying it out because it seems cool.  It's not something I want to worry over.  And for what it's worth, it doesn't work for me on Windows 11.  YMMV.</p>
<h2>Source Comparison?</h2>
<p>Not much is available to compare.  His examples don't have headers, which is one of the more defining historical properties of Rebol programs.  The word "header" is not mentioned in his manifesto, so it's not clear if that's temporary or permanent.</p>
<p>Here's a Fibonacci example:</p>
<pre><code>; Maximum 24 for natural16! result
; Max 47 for natural32! result
parameter= 24
 
print "Fibonacci "  print parameter  print ": "
 
natural! [Fibonacci previous]
; natural32! [Fibonacci previous]
 
either parameter &lt;= 1 [
    Fibonacci: parameter  ; Fibonacci 0 ... 1
][
    Fibonacci: previous: 1  ; Fibonacci 2

    loop parameter - 2 [
        previous: also
            Fibonacci
            Fibonacci: Fibonacci + previous
     ]
]
 
print/line Fibonacci 
</code></pre>
<p>So...</p>
<ul>
<li>
<p>It seems he wants PRINT to not include a newline, so you have to say PRINT/LINE to get it.</p>
<ul>
<li>I prefer the solution of asking those who really want partial line output (e.g. console prompts) to WRITE STDOUT directly...and that PRINT COLLECT be used as a pattern when your code is piecing together a full line from parts generated by distinct bits of code, KEEP-ing each part.</li>
</ul>
</li>
<li>
<p>Working on Atari means he's getting involved in things like INTEGER16!, and you optimize based on annotating datatypes like that.  I'm more of the "bignum by default" philosophy, so different indeed.</p>
<ul>
<li>Putting <strong>natural! [Fibonacci previous]</strong> in the middle of the code to constrain the type--not in a function spec--suggests this is really rather far afield from the evaluator-driven Rebol.</li>
</ul>
</li>
<li>
<p>He's trotting out historical ALSO in a first example.  No one in the Atari forum clapped with amazement at the genius several Rebolers seem to think it represents.  (So I feel pretty comfortable with <strong><a href="https://forum.rebol.info/t/enfixing-also-stylizing-it-after-then-and-else/402">Ren-C's ALSO and ELIDE</a></strong>.)</p>
</li>
</ul>
<p>Without more to look at I can't have more to say.</p>
            <p><small>7 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/kaj-gets-on-the-meta-train/1753">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/kaj-gets-on-the-meta-train/1753</link>
          <pubDate>Sat, 20 Nov 2021 23:44:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1753</guid>
          <source url="https://forum.rebol.info/t/kaj-gets-on-the-meta-train/1753.rss">Kaj Gets on the Meta Train</source>
        </item>
        <item>
          <title>PATH! usage for Function Dispatch Only Unless in Redbol Mode</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>For a while now I've been a pretty big convert on the look of dots for member selection.  It's not just that it's more standard--I think it's visually better.  It also lets you be reassured that when you see a slash in a path, that the thing to the left of that slash was a function:</p>
<pre><code>foo.bar.baz
   ;
   ; ^-- I may not know what foo.bar.baz is, but at least I know that
   ; foo and foo.bar are *not* functions

foo.bar.baz/mumble
   ;
   ; ^-- Under the convention that slashes are for refinements only, I
   ; can tell the author intends that (foo.bar.baz) must be a function

foo.baz.bar/
   ;
   ; ^-- With Ren-C's path generality, you can even decorate a case
   ; without refinements to show it's a function.
</code></pre>
<h2>It Hasn't Been A <em>Rule</em>, but...</h2>
<p>So far Ren-C has been allowing you to use slashes wherever you historically could.  So the new rules were only applying to dots--restricting them on not being usable on functions.</p>
<pre><code>append.dup [a b c] [d] 2  ; this would cause an error, for instance
</code></pre>
<p>However, you could still pick members out of objects with slashes:</p>
<pre><code>&gt;&gt; obj: make object! [field: 10]

&gt;&gt; obj/field   ; not obj.field
== 10
</code></pre>
<p>I had a feeling this might be prohibited eventually...though it would need to be possible to make Redbol emulation work.  So there'd have to be some kind of flag for allowing it.</p>
<h2>...But Now, I Might Have A Good Reason To Enforce It</h2>
<p>The reason is that in trying to do a good job of building an extensibility mechanism for member selection, it is difficult to make that mechanism able to communicate information about specialized functions in a "light" way.</p>
<p>When pathing is done hardcoded in the evaluator, it can do little sneaky tricks to push the words of refinements onto a stack.  It doesn't have to create an entirely new specialized function.</p>
<p>But once you're using a generic interface to usermode functions which can extend <strong><code>PICK*</code></strong> and <strong><code>POKE*</code></strong>, that interface has to speak in "reified" forms.  We have partial specialization so these refied forms exist... I just feel like what's happening in that case isn't "picking" or "poking".  And it's tying my hands to make anything efficient if we say that path dispatch runs through code which might be usermode.</p>
<h2>The Flag Will Be Introduced Gradually</h2>
<p>I've been experimenting with the flag turning itself on automatically, and giving you a warning.  So you only hear about it the first time.</p>
<pre><code>&gt;&gt; obj: make object! [x: 10]

&gt;&gt; obj/x
The PATH! obj/x doesn't evaluate to an ACTION! in the first slot.
SYSTEM.OPTIONS.REDBOL-PATHS is FALSE so this is not allowed by default.
For now, we'll enable it automatically...but it will slow down the system!
Please use TUPLE! instead, like obj.x
== 10

&gt;&gt; obj/x
== 10
</code></pre>
<p>What happens when you enable the flag is that it actually turns any PATH! with no ACTION! in the first slot into a TUPLE!, and then permits you to use refinements in TUPLE!s like <code>append.dup</code>.  This is because I'm avoiding creating a separate extensibility mechanism for paths...it just does the not-easy-to-optimize extensibility.</p>
<p>I haven't committed this, and I'd be phasing it in slowly.  But as it's phased in, the performance of paths for member selections vs. tuples will degrade.  So it's worth knowing about.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/path-usage-for-function-dispatch-only-unless-in-redbol-mode/1723">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/path-usage-for-function-dispatch-only-unless-in-redbol-mode/1723</link>
          <pubDate>Wed, 22 Sep 2021 18:11:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1723</guid>
          <source url="https://forum.rebol.info/t/path-usage-for-function-dispatch-only-unless-in-redbol-mode/1723.rss">PATH! usage for Function Dispatch Only Unless in Redbol Mode</source>
        </item>
        <item>
          <title>Red&#39;s REMOVE [OPT N rule] vs. REMOVE [OPT [N rule]]</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>I was doing some comparative behavior testing while looking at the <a href="https://forum.rebol.info/t/converting-trim-to-uparse-for-testing-and-inspiration/1660">UPARSE conversion of TRIM</a>.</p>
<p>As I mention in that post, the comparisons are now more-often-than-not pointing out bugs and inconsistencies in R3-Alpha and Red.  UPARSE is the new gold standard.  !</p>
<p>Here's a good example of R3-Alpha and Red being broken in their various ways, that will happen indefinitely... until the PARSE methodology changes from being ad-hoc to being architecturally sane.  :-/</p>
<pre><code>red&gt;&gt; parse s: "aab" [remove [opt 3 "a"] thru "b"]
== true

red&gt;&gt; s
== "b"
</code></pre>
<p><em>Why did it think there was 3 "a" to remove?</em>  I'd guess there are "repeat min-counts" and "repeat max-counts" and "optionality flags" being thrown about.  So it confused itself and put the optional flag on the "a", winding up interpreting the rule as:</p>
<pre><code>[remove [3 opt "a"] thru "b"]
</code></pre>
<p>How do you keep it from getting its flags crossed?  Throw in a block, because then it likely starts a genuine parse recursion and the flags won't mix:</p>
<pre><code>red&gt;&gt; parse s: "aab" [remove [opt [3 "a"]] thru "b"]
== true

red&gt;&gt; s
== "aab"
</code></pre>
<p>That's correct...and if you use a BLOCK! like that R3-Alpha also does the right thing:</p>
<pre><code>r3-alpha&gt;&gt; parse s: "aab" [remove [opt [3 "a"]] thru "b"]
== true

r3-alpha&gt;&gt; s
== "aab"
</code></pre>
<p>But predictably...without the block, you get an entirely different failure mode; the parse fails altogether:</p>
<pre><code>r3-alpha&gt;&gt; parse s: "aab" [remove [opt 3 "a"] thru "b"]
== false

r3-alpha&gt;&gt; s
== "aab"
</code></pre>
<p>Unless you explicitly try to make your combinators look literally at the items in the block--this category of distinction cannot exist in UPARSE.  <strong>[try repeat 3 "a"] and [try [repeat 3 "a"]] are equivalent in a correct-by-construction sense, and all the combinators that will ever be written get this benefit.</strong></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/reds-remove-opt-n-rule-vs-remove-opt-n-rule/1659">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/reds-remove-opt-n-rule-vs-remove-opt-n-rule/1659</link>
          <pubDate>Fri, 13 Aug 2021 20:10:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1659</guid>
          <source url="https://forum.rebol.info/t/reds-remove-opt-n-rule-vs-remove-opt-n-rule/1659.rss">Red&#39;s REMOVE [OPT N rule] vs. REMOVE [OPT [N rule]]</source>
        </item>
        <item>
          <title>Red changing FIND/MATCH to not default to /TAIL</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>Historically, the /MATCH option to FIND has implied returning the tail of the matched region.</p>
<pre><code>rebol2&gt;&gt; find/match "abc" "ab"
== "c"
</code></pre>
<p>That has been true despite the fact that there is a /TAIL option to FIND.  In trying to make FIND more orthogonal I have questioned this decision.</p>
<p><strong><a href="https://github.com/red/red/issues/4943">Red has made the move to say you have to provide /TAIL with /MATCH, otherwise you get the head of the match</a></strong>.  So now:</p>
<pre><code>red&gt;&gt; find/match "abc" "ab"
== "abc"

red&gt;&gt; find/match/tail "abc" "ab"
== "c"
</code></pre>
<p>I can agree with the intent behind this, although I wonder if it should accompany a changing of the refinement name.  /MATCH doesn't really fit with the meaning of "match" as I've been using it, e.g.</p>
<pre><code>&gt;&gt; match integer! 10
== 10

&gt;&gt; match integer! &lt;abc&gt;
; null
</code></pre>
<p>So maybe something like FIND/AT or FIND/STAY or FIND/HERE...something along those lines.  Then /MATCH could be deprecated in a more structured way.</p>
<p>But nope... they're pro breaking this for some reason.  Who am I to argue, especially given that I wanted it changed anyway?</p>
<p>It does underscore that Redbol emulation will need Red and Bol modes.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/red-changing-find-match-to-not-default-to-tail/1654">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/red-changing-find-match-to-not-default-to-tail/1654</link>
          <pubDate>Thu, 12 Aug 2021 06:52:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1654</guid>
          <source url="https://forum.rebol.info/t/red-changing-find-match-to-not-default-to-tail/1654.rss">Red changing FIND/MATCH to not default to /TAIL</source>
        </item>
        <item>
          <title>Red&#39;s Take on String Interpolation</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="8" data-topic="587">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/could-strings-have-context/587/8">Could strings have context?</a>
</div>
<blockquote>
<p><strong>I've started to feel that supporting string interpolation is fairly important.</strong></p>
</blockquote>
</aside>
<p>So Red is trying to attack string interpolation <a href="https://gitter.im/red/red?at=60d4df778a40b1172827e4ff">via a macro</a>, which apparently can happen "before word binding" in some way.</p>
<p>That kind of ties their hands representationally because macros always are signaled by ISSUE!s, so the callsites that want to use string interpolation must have a macro.</p>
<pre><code>&gt;&gt; probe expand-directives [#composite {"(player)" "(vfile)" --audio-file "(afile)"}]
[rejoin [{"} (player) {" "} (vfile) {" --audio-file "} (afile) {"}]]
</code></pre>
<p><a href="https://gitter.im/red/red?at=60d636eb8a40b117282ae530">Boris's remark about the usefulness of being able to do string interpolation</a> in Rebol sums up probably how most of those who reject the idea at first would eventually come around:</p>
<blockquote>
<p>can add that first time I saw Gregg's <code>#composite</code> my reaction was "why would we ever want that?". But then with every <code>print</code> or <code>rejoin</code> I was using in my code I had this thought "what if..". Then I started using my experimental implementation, and after some time I believe it's a total must have.</p>
</blockquote>
<p><strong>But I still think this should be approached as a binding question.</strong>   It's very difficult to play with bricks in the "native" way that Rebol has been and overlay a <em>predictable</em> and useful idea of a "binding environment".  And keeping an open mind about it is necessary.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/reds-take-on-string-interpolation/2121">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/reds-take-on-string-interpolation/2121</link>
          <pubDate>Sat, 26 Jun 2021 04:06:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2121</guid>
          <source url="https://forum.rebol.info/t/reds-take-on-string-interpolation/2121.rss">Red&#39;s Take on String Interpolation</source>
        </item>
        <item>
          <title>About the Redbol category</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>Issues regarding compatibility and emulation of <a href="http://www.rebol.com/docs/docs.html">Rebol2</a> and <a href="https://www.red-lang.org/p/about.html">Red</a>.</p>
<p>It's generally a goal that Ren-C be able to bend in order to do most anything that they can do...with modest effort.  Pursuant to that goal is the <a href="https://github.com/metaeducation/redbol/">Redbol module</a> to have an actual emulation of a reasonable compatible subset of the (non-GUI) portion of the languages.</p>
<p>More generally, this category is for discussing anything related to Rebol2 or Red semantics or features.</p>
<p><em>Note: R3-Alpha emulation is considered uninteresting, as it never gained much traction.  Most R3-Alpha codebases are either dead, <a href="https://github.com/Oldes/Rebol3">one of Oldes's projects</a>, or have been subsumed into Ren-C projects.</em></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/about-the-redbol-category/1312">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/about-the-redbol-category/1312</link>
          <pubDate>Tue, 28 Jul 2020 08:47:40 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1312</guid>
          <source url="https://forum.rebol.info/t/about-the-redbol-category/1312.rss">About the Redbol category</source>
        </item>
        <item>
          <title>Red&#39;s Design Issues Wiki</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>Here's a page posted on Red's GitHub:</p>
<h2><a href="https://github.com/red/red/wiki/%5BLINKS%5D-Design-questions">Red Design Questions Wiki</a></h2>
<p>I'm bookmarking it here, along with some quick review notes.</p>
<h4>Vector &amp; matrix DSL design</h4>
<p>No real comment, other than it's interesting that the order of the page ranks things as "most influential".  While in Ren-C, R3-Alpha's VECTOR! has been removed from the core (you can build a Ren-C without it).  Hence it isn't one of the built-in types identified by a byte in the header.  So it's <a href="https://forum.rebol.info/t/user-defined-datatype-discussion/1203">a primordial test of a custom type</a>, and that is the main lens through which its relevance is considered.</p>
<p>I'm sure if they want plenty of opinions on VECTOR! they can talk to Oldes.</p>
<h4>Parse DSL: simplify  <code>fail</code>  rule to  <code>[end skip]</code> ,  <code>break</code> / <code>reject</code>  to return success/failure  <em>from the loop (while/any/some)</em> ,  <code>break now</code>  as an emergency exit from the loop, bring  <code>also</code>  into parsing</h4>
<p>END SKIP as a way to force a fail is an amusing idea.  But much improvedly, Ren-C just gives meaning to LOGIC! true in PARSE as "keep parsing" and LOGIC! false as "fail here".  (See below for cool ramifications of that.)  So you can fail just by saying FALSE.  It takes away from the ability to match LOGIC! values literally, but you can't match INTEGER! values or BLOCK! values literally without a "QUOTE".  And with the <a href="https://forum.rebol.info/t/quoted-arrives-formerly-known-as-lit-bit/995/2">generic quoting Red argues against</a> you've got more convenience in that area, e.g. <strong>'#[true]</strong> or <strong>'[a b c]</strong> or <strong>'3</strong>.</p>
<p>It is good for naming reasons, too since FAIL has very specific meaning in Ren-C (way to raise errors, <strong>fail "msg"</strong> is nicer than <strong>do make error! "msg"</strong> and provides a dialecting opportunity).</p>
<p>The rest I'd have to look at in more detail to have an opinion on.</p>
<h4>Parse DSL: rules with arguments</h4>
<p>If I read this right...Ren-C has all this and more with GET-GROUP!.  <img src="https://forum.rebol.info/images/emoji/twitter/boxing_glove.png?v=9" title=":boxing_glove:" class="emoji" alt=":boxing_glove:">  This evaluates much like a plain GROUP! in a PARSE...but instead of the result vaporizing...it dynamically composes itself into the parse stream.  That makes it a full superset of PARSE's unusual IF...since in Ren-C LOGIC! true means "keep parsing" and LOGIC! false means "rule fails".  Thus <strong>:(mode = 'foo)</strong> gets you the continue-or-not you want.  But far more open-ended than that, especially since NULL vaporizes and continues the PARSE as #[true] would.  It's all kinds of keen:</p>
<p><a href="https://forum.rebol.info/t/get-group-s-in-parse-mean-execute-and-splice-as-rule/968">GET-GROUP!s in PARSE mean execute-and-splice-as-rule</a></p>
<p>So if you want a dynamically generated rule as a function, just say <strong>:(my-rule-maker arg1 arg2)</strong> and it will be spliced in.</p>
<p>I consider that bit solved.  But the part that isn't solved is saving you the trouble of capturing material to pass separately...kind of as if you could extend PARSE with your function acting kind of like a keyword.  Imaginative pseudocode:</p>
<pre><code> &gt;&gt; print-reverse: parse-func [x] [print reverse x]
 &gt;&gt; parse "aaabcdef" [3 "a" print-reverse [to end]]
 fedcb
</code></pre>
<p>e.g. the "argument fulfillment" phase is using parse rules--and not the evaluator--to do it.  But where I lean in this direction is asking about whether there is a model by which PARSE can be extensible in the same way DO of a BLOCK! is extensible... some kind of analogue to regular functions that lets you batch together "native" PARSE extensions (like THRU or INTO) along with user-added ones that speak the protocol (as if someone could add COLLECT after-the-fact).</p>
<blockquote>
<p><strong>UPDATE:</strong> This has been <a href="https://forum.rebol.info/t/introducing-uparse-the-hackable-usermode-parse/1529">hit with a bullseye by UPARSE</a>...and the problem of calling normal functions while passing them captured parse material is covered by <a href="https://forum.rebol.info/t/if-action-combinators-dont-impress-i-dont-know-what-will/1608">the ACTION! combinator</a></p>
<pre><code> &gt;&gt; print-reverse: func [x] [print reverse x]
 &gt;&gt; uparse "aaabcdef" [3 "a" print-reverse/ [across to &lt;end&gt;]]
 fedcb
</code></pre>
<p><em>Yes, that actually works in UPARSE!</em></p>
</blockquote>
<h4>Core: open problems of the object design</h4>
<p>Tip of the iceberg of the problems with the model.  <img src="https://forum.rebol.info/images/emoji/twitter/ice_cube.png?v=9" title=":ice_cube:" class="emoji" alt=":ice_cube:">  While Ren-C inherited the same object-model madness, techniques like generic quoting <a href="https://forum.rebol.info/t/generic-quoting-makes-headway-on-make-object/997">are making inroads representationally</a>, and things like <a href="https://github.com/metaeducation/ren-c/pull/727">derived binding</a> are aiding classic problems:</p>
<blockquote>
<p><em>"Derived binding is an interesting design that overcomes a serious weakness of historical Rebol combinatorics (where 1000 instances of an object with 50 member functions each had to make deep copies of the bodies of each function so the words in the bodies would point to the instance, so you're making 50,000 deep copies just to create those 1000 objects)."</em></p>
</blockquote>
<p>For a simple example, see <a href="https://github.com/metaeducation/ren-c/blob/3183acf3ee59e8ebc316ca5afeed09d493de8234/tests/datatypes/object.test.reb#L115">"O-Big"</a></p>
<h4>Core: efficient vector arithmetic</h4>
<p>Regarding their "<a href="https://github.com/red/red/issues/2216">Adding a number to a vector changes the vector itself #2216</a>", I have proposed a concept whereby operations like ADD and MULTIPLY follow Rebol's "mutate by default" rules, and PLUS (infix alias +) and TIMES (infix alias *) finesse the idea of not mutating.  These ideas originated in design for <a href="https://forum.rebol.info/t/planning-ahead-for-bignum-arithmetic/623">efficient BigNum arithmetic</a>, which shares many of the same issues.</p>
<p>Devil is in the details there, but it proposes building things on a model that is foundationally mutating.</p>
<h4>VID DSL: automatically bind (literal only?) actor &amp; reaction bodies to the face?</h4>
<p>N/A.</p>
<h4>Core: loop return values</h4>
<p>Ren-C has a systemic <a href="https://forum.rebol.info/t/the-simple-yet-powerful-magic-of-the-loop-result-protocol/609">loop return result protocol</a>.  All loops that BREAK return NULL, and there is no BREAK/RETURN.  If you wish to violate the protocol, you do so with THROW to a CATCH.</p>
<p>This is a helpful protocol for building your own loop constructs out of other loops...without having to reach in and figure out how to hook their BREAK.  Being able to tell from the outside if the loop was interrupted far outweighs the idea of BREAK/RETURN, and "heavy nulls" are an idea well worth it to ensure that pure NULL keeps its unique status for representing break.</p>
<h4>Core: behavior of series access outside the data boundaries</h4>
<p>I talk some about this in <a href="https://forum.rebol.info/t/where-the-series-ends-simplifying-out-of-bounds-rules/1141">"Where the Series Ends"</a> <em>(for you young folks, that's a <a href="https://en.wikipedia.org/wiki/Where_the_Sidewalk_Ends">Shel Silverstein reference</a>)</em>.</p>
<h4>VID DSL: should it allow to override already defined actors (e.g.  <code>base on-down [probe 1] [probe 2]</code> )?</h4>
<p>N/A</p>
<h4>Core: how to solve inelegancies and dangers of  <code>error? try</code> ,  <code>attempt</code>  and  <code>catch</code>  on  <em>arbitrary</em>  code?</h4>
<p>As usual, it is hiiamboris asking the good questions!</p>
<blockquote>
<p><strong>UPDATE 2022: <em>Ren-C has an answer</em> with <a href="https://forum.rebol.info/t/fail-vs-return-fail-the-new-age-of-definitional-failures/1852">"Definitional Failures"</a></strong> <img src="https://forum.rebol.info/images/emoji/twitter/boom.png?v=9" title=":boom:" class="emoji" alt=":boom:"></p>
<p>When originally writing this post in June 2020 all I said was that it was clear <em>"that conventional error-trapping should not conflate things that arise from "typos" with explicitly raised errors"</em>.</p>
<p>But I'm proud to say that yet another difficult question has been resolved with ^META/isotopic solutions (which during my brief conversations with Boris he did not appreciate, and I felt the dismissive attitude to another member of the Red audience was not worth trying to push through, vs. other uses of time).</p>
</blockquote>
<h4>Web: how should cached versions of remote files be named (considering user-friendliness, pathname length, sanitization of invalid chars)?</h4>
<p>Beyond the scope of current concerns, and likely not all that relevant as the main target is Wasm.</p>
<h4>Core: should operators use the result from funcs with literal arguments? (if  <code>f: func [:x][x * 2]</code> , should  <code>f 1 + 2</code>  be equivalent to  <code>(f 1) + 2</code> ?)</h4>
<p>Yes.  I won't delve into details on this esoteric (-seeming) point...other than to say that several features I'm very pleased with depend on this behavior.  <em>(For example: <a href="https://forum.rebol.info/t/soft-quoted-branching-light-elegant-fast/1020">soft-quoted branching</a>.)</em>  I find no compelling points in any counter-argument worth sacrificing the related features.</p>
<h4>Core: should percent type allow scientific notation, and should it be constrained in range?</h4>
<p>Don't care.</p>
<h4>VID DSL: should  <code>panel</code>  face draw a  <code>text</code>  facet on it?</h4>
<p>N/A</p>
<h4>Core: do we want  <code>/deep</code>  refinement for  <code>take</code> ?</h4>
<p>Doesn't seem like the worst idea.  But I think the better angle is just to make sure that even if TAKE didn't have it, that someone who wanted it could make it easily.  So <a href="https://forum.rebol.info/t/augment-add-parameters-and-refinements-after-the-fact/1216">features like AUGMENT</a> are geared in this direction.</p>
<h1>Historical questions &amp; explanations</h1>
<h4>Arguments on why paths evaluate picked items (so-called active accessors)</h4>
<p>It's a reasonable-sounding argument that it is "unlikely" that you want <strong>block/1</strong> to run the first function in a block.  But mechanically it's the simpler-seeming rule.  I guess it folds into a large part of the sketchiness that is path-processing.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=9" title=":man_shrugging:" class="emoji" alt=":man_shrugging:"></p>
<p>I will say that Ren-C's "get-pathing" and PICK-ing, and "set-pathing" and POKE-ing, are unified and run under the same dispatcher.  So <strong>:path/1</strong> and <strong>pick path 1</strong> are the same, and <strong>:path/x</strong> and <strong>pick path 'x</strong> are the same, for whatever those things happen to be.  There's not a separate codebase for getting paths from PICK or setting paths from POKE.  Hence it's called "path picking" and not "path selection".</p>
<h4>Command line argument parsing rules</h4>
<p><a href="https://github.com/metaeducation/ren-c/issues/996">This previously crossed my radar.</a>  If they do the work of writing test cases, sounds great.  Better them than me.</p>
<h4>Why word and a single-word path are different (despite the visual similarity)</h4>
<p>They shouldn't be, and single-word PATH!s should be outlawed...as WORD!s with all spaces are.  Ren-C has implemented PATH! immutability (at the "top level")...which isn't that unprecedented, as it makes them more parallel to TUPLE!.  By making paths immutable, it's possible to enforce a set of rules on them at the time of their creation (e.g. no PATH!s in their top level, that aren't inside GROUP!s, no FILE!s or URL!s, just GROUP!s/BLOCK!s/WORD!s/INTEGER!s etc.).</p>
<p>If this sounds constraining, consider the WORD! analogy again.  Making a PATH! with a PATH! in it like having a WORD! with a slash in it.  When things are immutable you have a moment of creation to enforce your check and then you just don't worry about it.  It works for WORD!, why not PATH!?</p>
<p>(You can still cheaply alias PATH!s via AS to get a BLOCK!...but the BLOCK! you get is simply read-only.  With "UTF-8 Everywhere" you can also alias WORD! as a string via AS, but once again the resulting value will be read-only.  <a href="https://forum.rebol.info/t/as-binary-view-of-strings-is-back-with-utf-8-thats-only-part/1186">You can even alias them all as BINARY!</a>, as in Rebol2.  :-P)</p>
<p>The idea that PATH!s are some kind of generic "ANY-BLOCK!" is not all that compelling.  DocKimbel himself has complained about people wanting long or multi-line paths.  If you really want to mutate a path freely and promise not to end in a bad state, then COPY AS BLOCK! your path...muck with it, and then AS PATH! it (which will mark the underlying array read only, and do an integrity check that you didn't reduce it to one word).</p>
<p><em>(Overall this ties into great work done in Ren-C on PATH!, which includes generalizing REFINEMENT! so there isn't just <strong><code>/a</code></strong> but also <strong><code>a/</code></strong> and <strong><code>a//b</code></strong> ... a BLANK! in a PATH! is simply not rendered.  The immutability of paths means that even though <strong><code>/a</code></strong> is a 2-element path with a blank in the first slot, it can still be represented in one cell and not worry about being unable to handle mutations.  See <a href="https://forum.rebol.info/t/heart-bytes-explained/1008">Heart <img src="https://forum.rebol.info/images/emoji/twitter/heart.png?v=9" title=":heart:" class="emoji" alt=":heart:"> Bytes</a>)</em></p>
<h4>Core: :get-word function argument evaluation semantics: R2- or R3-like? (final?)</h4>
<p>There absolutely has to be <em>some</em> way to literally get a symbol/value in the position, regardless of what it looks up to.  I don't know if I'm in love with the notation for <strong>:x</strong> for unescapable quoting and <strong>'x</strong> for escapable quoting, but that's a different question.</p>
<h4>Core: how to allow maps to have  <code>none</code>  values?</h4>
<p>Some day Red will realize how much they miss out on by not having NULL.  I guess it's kind of like societies that never grokked the invention of zero.</p>
<p><a href="https://forum.rebol.info/t/null-blank-void-history-under-scrutiny/1249">NULL, BLANK!, VOID!: History Under Scrutiny</a></p>
<h4>Core: how money datatype equality and comparison rules should work?</h4>
<p><a href="https://www.youtube.com/watch?v=qMkkfuSizc4">It's like the Joker says...</a></p>
<h4>Core: what should empty  <code>any []</code>  and  <code>all []</code>  return?</h4>
<p><strong><a href="https://forum.rebol.info/t/how-any-and-all-in-other-languages-act-on-empty-inputs/1830">UPDATE 2022: <em>both</em> Empty ANY and ALL return void.</a></strong>  When this post was originally written it was just ALL, and ANY returned null.  But it turns out to be so high leverage compared to the tiny benefit of making ANY null that we have to do it.  The proof is in the examples!</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/reds-design-issues-wiki/1282">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/reds-design-issues-wiki/1282</link>
          <pubDate>Sat, 06 Jun 2020 02:03:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1282</guid>
          <source url="https://forum.rebol.info/t/reds-design-issues-wiki/1282.rss">Red&#39;s Design Issues Wiki</source>
        </item>
        <item>
          <title>Analogue to Rebol2&#39;s Hidden Parameters</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>Rebol2 had the property that any refinements after a local would not show up in HELP...but still be available:</p>
<pre><code>rebol2&gt;&gt; foo: func [arg /local loc /bar baz] [
    print ["Unsurprisingly:" arg]
    if bar [print ["Surprise:" baz]]
]

rebol2&gt;&gt; help foo
USAGE:
    FOO arg

DESCRIPTION:
    (undocumented)
    FOO is a function value.
                           ; &lt;-- look, no /BAR...
ARGUMENTS:
     arg -- (Type: any)

rebol2&gt;&gt; foo/bar "Ordinary argument." "Hidden refinement!"
Unsurprisingly: Ordinary argument.
Surprise: Hidden refinement!
</code></pre>
<p>It's actually just exploiting the fact that HELP stops printing out everything after /LOCAL in the spec block.</p>
<p>While it may seem like a loophole that gave rise to a useless feature, <em><strong>there actually is a reasonable use case for functions having out-of-band arguments.</strong></em></p>
<p>The use case is when a function recurses, and wants to pass some private state into the recursion.  If you try to do this in C or some other language, you have to write two functions with two different interfaces.  Simplistic example:</p>
<pre><code>fiveprint-core: func [value depth] [
    print [value]
        if depth &lt;&gt; 0 [
            fiveprint-core value (depth - 1)
        ]
    ]

fiveprint: func [
    {Print a value five times (but use recursion to do it...)}
    value
][
    fiveprint-core value 5
]
</code></pre>
<p>Having a way to slip in hidden state gives you another option, <em>and it's an option that doesn't make you replicate the interface twice</em>.  This FIVEPRINT only takes one argument, but imagine if it had ten arguments with types and descriptions...and it's very helpful to not have to repeat that in a second function with a few extra internal parameters:</p>
<pre><code>fiveprint: func [
    {Print a value five times (but use recursion to do it...)}
    value
    /local /recurse depth
][
     either recurse [
         if depth &lt;&gt; 0 [
             print [value]
             fiveprint/recurse value (depth - 1)
         ]
     ][
         fiveprint/recurse value 5
     ]
]
</code></pre>
<h2>Ren-C Has Light-Years More Tools, but How To Apply Them Here?</h2>
<p>If we didn't clear local variables during <a href="https://trello.com/c/Bu40ecLC" rel="nofollow noopener">tail-calls</a>, you could slip state to a recursion that way.  I'm not crazy about the idea of having locals be anything but null at the outset of any call, though.</p>
<p>Maybe REDO could offer a refinement to request the locals be kept as-is (or name specific ones to keep?)</p>
<p>It's a low-priority feature, but I had to document what it was for Redbol...and I figured having a post to talk about it was better than writing an essay there.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/analogue-to-rebol2s-hidden-parameters/1273">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/analogue-to-rebol2s-hidden-parameters/1273</link>
          <pubDate>Fri, 10 Apr 2020 15:13:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1273</guid>
          <source url="https://forum.rebol.info/t/analogue-to-rebol2s-hidden-parameters/1273.rss">Analogue to Rebol2&#39;s Hidden Parameters</source>
        </item>
        <item>
          <title>Redbol Emulation Runs %pdf-maker.r...and now on the web!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>The <a href="https://forum.rebol.info/t/beginnings-of-the-redbol-module/755">Rebol2-ish-or-Red emulation layer "Redbol"</a> now runs on the web REPL!  There's a lot of caveats at this early stage, but it's still pretty interesting.</p>
<p>It was first developed to build the static <code>hostilefork.com</code> site, using the aging codebase from my early attempts at dialecting.  (The code is now being deliberately held back, so I have an incentive to make the Redbol layer work.)</p>
<p>Now it's run on its second not-insignificant-codebase, Gabriele's %pdf-maker.r... <a href="http://www.rebol.org/view-script.r?script=pdf-maker.r" rel="nofollow noopener">(the older, single-file version on the rebol script archive)</a>.  With only minor modifications, it successfully made a PDF from the dialect input:</p>
<pre><code>layout-pdf [[textbox ["This is some text."]]]
</code></pre>
<p>(With that working, I'm now looking at questions of how to run it with <em>zero</em> modifications.)</p>
<p>Despite the small size of the input, it does exercise a lot of the code paths from start to finish to make a PDF file.  I don't know that the rest of it (except possibly IMAGE! support) would exercise all that much more of the system.</p>
<p>Some points to raise:</p>
<ul>
<li>
<p><strong>The emulation is relatively slow.</strong>  The focus is on understanding what the compatibility issues are, and not on optimization.  Though I've mentioned that with Redbol as an extension, it would be able to do some of its work through natives.</p>
</li>
<li>
<p><strong>Redbol still takes over the whole user context</strong>.  It leaves all the lib definitions alone, but then skins the user context with its emulation.  But this means any other code you run in the user context will get the Rebol2 rules.  So it doesn't work with modules or running normal Ren-C code side-by-side.  What we'd rather do is have you put your code in a module and say "this uses Redbol" and let just that module get the definitions...which is the kind of thing the module system <em>should</em> be able to do, but it was missing a lot of these design points.  So this is a definite next step.</p>
</li>
<li>
<p><strong>We have to decide about Latin1 Redbol support</strong>.  Just because the default for LOAD/SAVE was Latin1 before, is that really what we want Redbol to do?  This PDF case is an odd one because it actually is using the Latin1 encoding for an embedded table with font metrics information.  Rather than modify Redbol's LOAD to take in and spit out Latin1, I just converted the table to UTF-8 and re-encoded it.  Is this the better idea than bending over backwards on this compatibility point?  Would people probably <em>prefer</em> a UTF-8 Everywhere Redbol?</p>
</li>
<li>
<p><strong>R3-Alpha bitsets were incomplete and buggy</strong>.  There was <a href="http://www.rebol.net/r3blogs/0114.html" rel="nofollow noopener">awareness of the issues involved in the representation that was chosen</a>.  Even so, the code to handle it was not written.  I don't know exactly where on the schedule something like that is supposed to go--it would be nice if someone who was not me could write a coherent solution and do all the tests for it.  It's a fairly standalone task.  Anyway, the PDF maker uses them--I hacked around the case that was using the negated bitsets.</p>
</li>
<li>
<p><strong>FORM is pretty different</strong>.  Decimal numbers print to a different number of digits in Rebol2 vs. R3-Alpha and Red--which is frustrating in the PDF output because hex differs get thrown off and think there's more difference than there really is.  ISSUE! formed without its # instead of with it.  I have not been pleased that <strong>form [1 2 [3 4]]</strong> is "1 2 3 4" while <strong>append "" [1 2 [3 4]]</strong> is "123 4"...there's just a lot of random-seeming behavior, where it needs to be straightened out.  But in an ad-hoc and as-needed manner, I'm adding the differences in behavior to Redbol.  This makes good documentation of the behavior, if nothing else.</p>
</li>
<li>
<p><strong>Things that depend on inheritance have to use METHOD</strong>.  It used to be that if you had any function that happened to be referenced from an object, deriving from that object would cause it to rebind.  It also deep copied every function in the process!  Design-wise, Ren-C's METHOD uses the strategy of looking to its left to see what set-word! you are assigning it to, and then binds the generated function to the context of that set-word!.  Right now this means such instances have to be changed to METHOD.</p>
</li>
</ul>
<p>On this latter point, I'm getting to wonder if we do need to make enfixedness a property of ACTION!s instead of words.  That way FUNC and DOES could be enfix and having some smarts about their left hand side being a skippable SET-WORD!...without people using them needing to know they are enfix.  With these tricks it seems that it's coming to be so entwined in a function's meaning that for many of them, you can't really divorce their enfixedness from the definition.</p>
<p>Back when trying to avoid a separate OP! datatype, I was wary of the bit living in the function at all.<br>
As a sample concern: I was thinking about a world where all functions were potentially enfix, but maybe would ignore their left argument.  Yet if everything were enfix there would be no EVALUATE (e.g. "DO/NEXT")...because these fake enfix functions would be forcing the entire operation to completion.  But there's been mountains of change since these questions were looked at...we have <code>&lt;skip&gt;</code>-able arguments and a lot more understanding.</p>
<p>But anyway, long story short is: Redbol has had its second demo codebase going and is on the web!</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/redbol-emulation-runs-pdf-maker-r-and-now-on-the-web/1142">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/redbol-emulation-runs-pdf-maker-r-and-now-on-the-web/1142</link>
          <pubDate>Tue, 09 Apr 2019 05:05:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1142</guid>
          <source url="https://forum.rebol.info/t/redbol-emulation-runs-pdf-maker-r-and-now-on-the-web/1142.rss">Redbol Emulation Runs %pdf-maker.r...and now on the web!</source>
        </item>
        <item>
          <title>Having unrefined fun: REDBOL-FUNC &amp; REDBOL-FUNCTION</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>I have implemented <a href="https://forum.rebol.info/t/pure-and-refined-simplifying-refinements-to-one-or-zero-args/1120">Pure and Refined: Simplifying Refinements to One or Zero Args</a>.  It's so much better in so many ways...usermode and internal...that it's essentially a bug that Rebol ever did it any other way.</p>
<p>Despite being a significant change, it's pretty easy to update client code to.  The majority of refinements don't actually take arguments in the first place--so there's nothing you need to do for those.  If a refinement took an argument but didn't give a datatype for it, you now have to...it's the type block's presence that indicates it needs an argument at all.  But maybe rather than just slapping <strong>[any-value!]</strong> on, it would be a good time to actually annotate with what the expected types are.</p>
<p>Because there's a goal to be able to emulate Rebol2/Red style in usermode, I decided that before committing the change I would update the Redbol emulation.  This would process a function defined in the historical way to a new spec and body for the new rules.  <em>(Though note that Redbol will be an extension, and fundamental transformations like this would be rewritten as natives--in whole or in part.)</em></p>
<p>Nothing too fancy...it transforms the ANY-WORD! refinement arguments into SET-WORD!s, and then when the body runs it moves the value from the refinement into the local and sets the refinement's variable to true or false.  A more complex one that allowed multiple refinement arguments would have to be variadic...I'm interested in the workings of that but it's low priority considering everything else.</p>
<p>Technique-wise, what I really like is how smooth it's getting to add set-ness/get-ness/lit-ness with COMPOSE:</p>
<pre><code>insert body compose/deep [
    (argument): :(refinement)
    if not blank? :(refinement) [(refinement): true]
]
</code></pre>
<p>REFINEMENT is a PATH! in this case (as /foo is a path).  While such paths with blanks at the head are inert, their GET-PATH! and SET-PATH! forms are active, so <strong>/foo:</strong> acts just like <strong>foo:</strong> and <strong>:/foo</strong> acts just like <strong>:foo</strong>.  Scenarios like this one motivate that.</p>
<p>Another thing that I'm getting comfortable with is the no-op status of NULL when used with things like the value to APPEND or the value to KEEP.  Historically I had some mixed feelings about it, but as NULL has become the true "non-thing" parallel to what NONE! was trying to signal, it would be a real waste to not be able to use its non-thing-ness.  And when you're doing operations like a REPLACE in a block and want to actually replace with nothing, a BLANK! won't do.  When you take that to its logical conclusion you realize that something like <strong>if keep match text! value [...]</strong> is a good thing.  VOID! is there to fill in the gaps if you want to have an "ornery" error-triggering value.</p>
<p>Anyway, this is just an example of how the state of everyday coding is evolving for the better.  It's a non-trivial function to write, but can be written without feeling in the dark about edge cases.</p>
<p>This includes the other parts of the transformation, like dealing with <code>/extern</code> on function, or making it so you can mutate the body by tweaking the <code>&lt;const&gt;</code> marker out of the spec for the <code>body</code> parameter.  It's actually working in practice, and I just ran the Rebol2-ish script to build <code>hostilefork.com</code> with it!</p>
<pre><code>rewrite-spec-and-body: function [
    spec "(modified)" [block!]
    body "(modified)" [block!]
][
    ; R3-Alpha didn't implement the Rebol2 `func [[throw catch] x y][...]`
    ; but it didn't error on the block in the first position.  It just
    ; ignored it.  For now, do the same in the emulation.
    ;
    if block? first spec [take spec]  ; skip Rebol2's [throw]

    spool-descriptions-and-locals: does [
        while [match [text! set-word!] first spec] [
            spec: my next
        ]
    ]

    while [not tail? spec] [
        refinement: try match path! spec/1

        ; Refinements with multiple arguments are no longer allowed, and
        ; there weren't many of those so it's not a big deal.  But there
        ; are *many* instances of the non-refinement usage of /LOCAL.
        ; These translate in Ren-C to the &lt;local&gt; tag.
        ;
        if refinement = lit /local [
            change spec &lt;local&gt;
            refinement: _
        ]

        spec: my next
        if not refinement [continue]

        if tail? spec [break]
        spool-descriptions-and-locals
        if tail? spec [break]

        if not argument: match [word! lit-word! get-word!] spec/1 [
            continue  ; refinement didn't take args, so leave it alone
        ]
        take spec ; don't want argument between refinement + type block

        if not tail? spec [spool-descriptions-and-locals]

        ; may be at tail, if so need the [any-value!] injection

        if types: match block! first spec [  ; explicit arg types
            spec: my next
        ]
        else [
            insert/only spec [any-value!]  ; old refinement-arg default
        ]

        append spec as set-word! argument  ; SET-WORD! in specs are locals

        ; Take the value of the refinement and assign it to the argument
        ; name that was in the spec.  Then set refinement to true/blank.
        ;
        ; (Rebol2 missing refinements are #[none], or #[true] if present
        ; Red missing refinements are #[false], or #[true] if present
        ; Rebol2 and Red arguments to unused refinements are #[none]
        ; Since there's no agreement, Redbol goes with the Rebol2 way,
        ; since NONE! is closer to Ren-C's BLANK! for unused refinements.)

        insert body compose/deep [
            (argument): :(refinement)
            if not blank? :(refinement) [(refinement): true]
        ]

        if tail? spec [break]
        spool-descriptions-and-locals
        if tail? spec [break]

        if extra: match any-word! first spec [
            fail [
                {Refinement} refinement {can't take more than one}
                {argument in the Redbol emulation, so} extra {must be}
                {done some other way.  (We should be *able* to do}
                {it via variadics, but woul be much more involved.)}
            ]
        ]
    ]

    spec: head spec  ; At tail, so seek head for any debugging!

    ; We don't go to an effort to provide a non-definitional return.  But
    ; add support for an EXIT that's a synonym for returning void.
    ;
    insert body [
        exit: specialize 'return [set/any (lit value:) void]
    ]
    append spec [&lt;local&gt; exit]  ; FUNC needs it (function doesn't...)
]

; If a Ren-C function suspects it is running code that may happen more than
; once (e.g. a loop or function body) it marks that parameter `&lt;const&gt;`.
; That prevents casual mutations.
;
 ; !!! See notes in RESKINNED for why an ADAPT must be used (for now)

func-nonconst: reskinned [
     body [block!]  ; no &lt;const&gt; tag
] adapt :func []

function-nonconst: reskinned [
    body [block!]  ; no &lt;const&gt; tag
] adapt :function []


redbol-func: function [
    return: [action!]
    spec [block!]
    body [block!]
][
    spec: copy spec
    body: copy body
    rewrite-spec-and-body spec body

    return func-nonconst spec body
]

redbol-function: function [
    return: [action!]
    spec [block!]
    body [block!]
    /with [object! block! map!]  ; from R3-Alpha, not adopted by Red
    /extern [block!]  ; from R3-Alpha, adopted by Red
][
    if block? with [with: make object! with]

    spec: copy spec
    body: copy body
    rewrite-spec-and-body spec body

    ; The shift in Ren-C is to remove the refinements from FUNCTION, and
    ; put everything into the spec dialect...marked with &lt;tags&gt;
    ;
    if with [
        append spec compose [&lt;in&gt; (with)]  ; &lt;in&gt; replaces /WITH
    ]
    if extern [
        append spec compose [&lt;with&gt; ((extern))]  ; &lt;with&gt; replaces /EXTERN
    ]

    return function-nonconst spec body
]</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/having-unrefined-fun-redbol-func-redbol-function/1137">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/having-unrefined-fun-redbol-func-redbol-function/1137</link>
          <pubDate>Thu, 04 Apr 2019 21:26:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1137</guid>
          <source url="https://forum.rebol.info/t/having-unrefined-fun-redbol-func-redbol-function/1137.rss">Having unrefined fun: REDBOL-FUNC &amp; REDBOL-FUNCTION</source>
        </item>
        <item>
          <title>User-Defined Types in R3-Alpha and Red</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <h2>
<a name="r3-alpha-user-defined-types-utype-were-vaporware-1" class="anchor" href="https://forum.rebol.info#r3-alpha-user-defined-types-utype-were-vaporware-1"></a>R3-Alpha user defined types (UTYPE!) were vaporware</h2>
<p>Prior to R3-Alpha's open sourcing, some of the loyal followers of Rebol were excited to hear that there was a plan for user-defined types.</p>
<p>Once it was released, it could be seen that all that existed of user-defined datatypes in R3-Alpha was <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/include/sys-value.h#L1059">a cell payload definition</a> ("REBUDT"), which was essentially two objects--the content (data/methods) and an additional object.  Then there was about a <a href="https://github.com/rebol/rebol/blob/master/src/core/t-utype.c">paragraph's worth of code</a>.</p>
<p>The code doesn't appear to even be trying to work.  :-/  But the gist is that you'd provide functions for each "type action".  A prototype object with a NONE! for each action name was initialized in <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/b-init.c#L432">Init_Utype_Proto()</a>, and your user defined type would run through the object creation process inheriting from that.</p>
<p>So maybe you'd say something like:</p>
<pre><code>matrix: make utype! compose/deep [
   [append: (func [matrix value] [print "this gets called on append"])] ;-- spec part
   [rows: 2 columns: 2 data: [[0 0] [0 0]]] ;-- data part
]
append matrix [10 10] ;-- perhaps should add a row to the matrix?  :-/
</code></pre>
<p>But even if that worked, there's pretty much nothing but unanswered questions.</p>
<ul>
<li>
<p>There was a stub for where molding/forming/comparison would provide hooks, but those stubs were empty.</p>
</li>
<li>
<p>How would path dispatch work?</p>
</li>
<li>
<p>Does every user-defined datatype report its TYPE? as UTYPE!...and implementers are responsible for doing some finer-grained type checking?</p>
</li>
</ul>
<p>So nothing to see, there.</p>
<h2>
<a name="red-recognizes-methods-with-certain-names-2" class="anchor" href="https://forum.rebol.info#red-recognizes-methods-with-certain-names-2"></a>Red recognizes methods with certain names</h2>
<p>When it comes to being able to "hook" a datatype, Red has at least one example mentioned when they <a href="https://www.red-lang.org/2014/12/050-objects-support.html">added object support</a>.  It was set up so that if you had a method called <code>on-change*</code> it would call it when the object changed.  Here's an example from their page:</p>
<pre><code>book: object [
    title: author: year: none

    on-change*: func [word old new /local msg][
        if all [
            word = 'year
            msg: case [
                new &gt;  2014 ["space-time anomaly detected!"]
                new &lt; -3000 ["papyrus scrolls not allowed!"]
             ]
        ][
           print ["Error:" msg]
        ]
    ]
]
</code></pre>
<p>This doesn't put the specially dispatched methods into another namespace (e.g. the "second object" of the UTYPE!'s REBUDT cell).  This puts them in-band.  So you couldn't have an object with field called <code>on-change*</code> that was just a regular data member.</p>
<p>I don't know how many of these they're planning on adding, but the idea of reserving names in the space where ordinary data fields live seems suspect to me.  It might seem harmless as there's no reason to have a plain data member called <code>on-change*</code> at the outset.  But whenever you introduce a meta thing like this you wind up wanting to make other objects that <em>mention</em> it, so <code>on-change*: true</code> can <em>become</em> interesting when making something that lists the meta methods something has--for example.</p>
<h2>
<a name="ren-c-added-out-of-band-adjunct-feature-3" class="anchor" href="https://forum.rebol.info#ren-c-added-out-of-band-adjunct-feature-3"></a>Ren-C added out-of-band ADJUNCT feature</h2>
<p>R3-Alpha's MODULE! data type was very much like an OBJECT!, but instead of just having one set of keys and values it had two.</p>
<ul>
<li>
<p>The first was the module contents</p>
</li>
<li>
<p>The second set of information held things like the module's title, list of exports...basically anything that it was keeping track of that it got out of the header.  But by putting it in a separate place, it wasn't stealing any potential key names from the module's content.  (e.g. if you put it in a field called "header", you couldn't have a top-level declaration in the module body called "header")</p>
</li>
</ul>
<p>In Ren-C, this module-only ability was turned into something more generalized, which allowed an ANY-CONTEXT! to have an associated "adjunct" context.  So this applied not just to MODULE!, but to OBJECT!, ERROR!, PORT!, and FRAME!.  It seemed like a step in the right direction.</p>
<h2>
<a name="could-the-adjunct-context-store-type-information-4" class="anchor" href="https://forum.rebol.info#could-the-adjunct-context-store-type-information-4"></a>Could the ADJUNCT context store type information?</h2>
<p>The thing that the meta object has in common with UTYPE! is that it's a second context associated with an ANY-CONTEXT!, whose fields don't interfere.  Should it be the place to look for methods the system might call, such as <code>on-change*</code>...or something for path dispatch, like <code>on-path*</code>?</p>
<p>This also raises some questions about how meta information should be handled in terms of COPY.  Does copying an object give you the same meta information, a copy of the meta information (deep? shallow?) or does the new object not have any meta information at all?  Most of those questions got punted on, but could be informed by what would be needed for the type handling.</p>
<p>Solving user-defined types is a big area, given that there really is no precedent in Rebol's class of languages.  We don't know how to say <code>b: make book! [author: {...} isbn: #...]</code> and then say <code>type of b</code> and get BOOK! back, or make a function like <code>checkout: function [b [book!]] [...]</code>.  But neither does JavaScript (its <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof">JavaScript typeof</a> only has 9 possibilities).  Nor does Ruby or Python.</p>
<h2>
<a name="extension-types-were-briefly-added-to-ren-c-5" class="anchor" href="https://forum.rebol.info#extension-types-were-briefly-added-to-ren-c-5"></a>Extension Types Were Briefly Added to Ren-C</h2>
<p>The type system wasn't mature enough to handle extension types, so they were removed in order to do more foundational work.</p>
<p>But something like them may be added back:</p>
<p><a href="https://forum.rebol.info/t/extension-types-implementation-on-hold/1203" class="inline-onebox">"Extension Types" Implementation (On Hold)</a></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/user-defined-types-in-r3-alpha-and-red/815">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/user-defined-types-in-r3-alpha-and-red/815</link>
          <pubDate>Sat, 15 Sep 2018 01:11:55 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-815</guid>
          <source url="https://forum.rebol.info/t/user-defined-types-in-r3-alpha-and-red/815.rss">User-Defined Types in R3-Alpha and Red</source>
        </item>
        <item>
          <title>Beginnings of the &quot;Redbol&quot; Module</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>There have been three areas of backwards compatibility effort so far:</p>
<ul>
<li>
<p><strong>r3-legacy</strong> - This started as a collection of runtime switches and shim code to revert Ren-C to act like R3-Alpha.  Over time the runtime switches were phased out, as more and more adaptation could be accomplished in usermode.</p>
</li>
<li>
<p><strong>warnings</strong> - Various constructs were changed to offer warnings or errors.  So rather than UNSET? just start acting completely different, it gave a deprecation message.</p>
</li>
<li>
<p><strong>r3-future</strong> - This is a shim which would allow an R3-Alpha to be used for bootstrap, so that the bootstrap code could be written in more modern/idiomatic Ren-C.</p>
</li>
</ul>
<hr>
<p>I've gone ahead and factored out r3-legacy to its own file, <a href="https://github.com/metaeducation/ren-c/blob/master/scripts/redbol.reb" rel="nofollow noopener">%redbol.reb</a> -- the renewed focus of this will be to be Rebol2/Red compatibility.</p>
<p>It's not a module yet, but it makes a pretty good pathological test case of a module...due to how much it alters the system.  It wants to export something like UNSET? with the "old" meaning (similar to NULL?), while at the same time use the current meaning within its own implementation.  Right now I've just boxed all the definitions inside of something called EMULATE which binds it into lib, but modules may need to offer support for this kind of situation more generally.</p>
<p>Then I've broken out the warnings into <a href="https://github.com/metaeducation/ren-c/blob/master/scripts/r2warn.reb" rel="nofollow noopener">%r2warn.reb</a>.  There really is overlap with what knowledge it takes to emulate Rebol2 along with what it would take to warn someone writing to new conventions where something might have a confusing new behavior.  So it would be nice to have whether there is emulation, warnings, or both... just as options on %redbol.reb.  But right now modules don't do parameterizations (beyond versioning) so let's hold that thought.</p>
<p>With the direction headed toward emulation and legacy support coming from files outside the core, I've gone ahead and bitten the bullet and pulled all the support for things like PAREN! or FOREACH or other things.  They "weren't causing any trouble", but they were cluttering things.  I'd like to see any hypothetical user who would be depending on those definitions to be hacking on %redbol.reb, to be able to pick all or part of what they wanted...and try and start getting the core tightened up so it's easy to see what's there.</p>
<h3>There's some really impressive stuff going on here</h3>
<p>When you look at the code, it's really pretty awesome.  Even something small, like <a href="https://forum.rebol.info/t/justifiable-asymmetry-to-on-block/751">the change to the splicing behavior</a>:</p>
<pre><code>oldsplicer: helper [
    func [action [action!]] [
        adapt :action [
            all [not only | any-array? :series | any-path? :value] then [
                value: as block! value ;-- guarantees splicing
            ]
            ;-- fall through to action's normal implementation
        ]
    ]
]

append: emulate [oldsplicer :append]
insert: emulate [oldsplicer :insert]
change: emulate [oldsplicer :change]
</code></pre>
<p>Ren-C's behavior changed to the point of being able to say appending a PATH! didn't splice unless it was to another path.  And here you have a surgical tweak that can reverse this--in usermode.  All while giving you the same interface and refinements for the functions.</p>
<p>You can try and imagine yourself what doing this would be like in Rebol2, R3-Alpha, or Red.</p>
<h3>Modules are hard and there's a long road ahead, there</h3>
<p>We see that JavaScript still doesn't have modules sorted out--and it's been quite a long time with a world of people working on it.  Rebol's landscape is even more complex.  And modules are very tied up in binding, which still has a lot of open questions.</p>
<p>What I think has to happen is that I have to sit down and look at the fundamentals.  I don't see how anything too big can happen too soon, so really it's probably just going to be one feature at a time.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/beginnings-of-the-redbol-module/755">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/beginnings-of-the-redbol-module/755</link>
          <pubDate>Wed, 25 Jul 2018 05:35:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-755</guid>
          <source url="https://forum.rebol.info/t/beginnings-of-the-redbol-module/755.rss">Beginnings of the &quot;Redbol&quot; Module</source>
        </item>
        <item>
          <title>Requirements List for the Redbol Compatibility Module</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>There needs to be some candidate Rebol2/Red/R3-Alpha-ish codebase to be the guinea pig for the "Redbol" emulation module.  I'm going to sacrifice my <a href="http://draem.hostilefork.com/" rel="nofollow noopener">Draem</a> blog generator to stay in the world of Redbol compatibility.  It doesn't make me tremendously happy to hold it back--but I've already been holding it back for the purposes of testing <code>&lt;r3-legacy&gt;</code>.  So this just means a little bit more holding back.</p>
<p>That will require backporting it to Rebol2.  Then I will twist up <code>&lt;r3-legacy&gt;</code> until it can run it also.  And if I haven't strangled myself with my own tongue by then, I will see what I can do to run it under Red.  Then rename <code>&lt;r3-legacy&gt;</code> to <code>&lt;redbol&gt;</code> and try and get the module-based approach going.</p>
<p>It's not terribly ambitious code, though it does need Markdown processing.  Hopefully that's already been addressed in Red or Rebol2 somewhere.</p>
<h3>"Redbol"</h3>
<p>In this sense I'm using the term "Redbol" to mean <em>"roughly the language agreed upon  represented by Rebol2 and Red"</em>.  If Red and Rebol2 agree on something, and R3-Alpha made another choice, it doesn't seem to me to make much sense for this compatibility layer to pick R3-Alpha's choice out of principle--even if it's arguably a better choice.  The point is emulation, not arguing.</p>
<p>This needs to be done with actual modules, isolating the behavior so that a Redbol module can be called from a Ren-C module, and vice-versa.  How things have been done so far with <code>&lt;r3-legacy&gt;</code> can't handle that.  It just mucks up the user context.</p>
<h3>Thoughts on baseline?</h3>
<p>Rebol2 was skinned to incorporate many of R3-Alpha features via something known as "R2/Forward".  Since we're not necessarily looking at <em>exact</em> compatibility with any of Rebol2/Red/R3-Alpha, it's reasonable to say that someone using the Redbol emulation would likely have a few little stubs loaded.</p>
<p><em>(So to run a Redbol codebase in Rebol2 you'd use <code>%redbol.r</code>, to run it in Red you'd use <code>%redbol.red</code>, and in Ren-C you'd tag your module as <code>Depends: &lt;redbol&gt;</code> or whatever the way that winds up working.  I don't think a <code>%redbol.r3</code> would be used by anyone, and things like the indexing are impractical to bend from within an R3-Alpha binary.)</em></p>
<p>So given that, does anyone have any "known" lists of tweaks they know each would need?  What did Red change from Rebol2 that's favorable, unfavorable?  Most of what I've got going on compatibility so far is code in the <a href="https://github.com/metaeducation/ren-c/blob/f2a4fa199eb341315d856563a50aee040855e49f/src/mezz/mezz-legacy.r#L625" rel="nofollow noopener"><code>%mezz-legacy.r</code></a>, so that's going to be the starting point for Ren-C's <code>&lt;redbol&gt;</code>...the question is just what more will be needed than that.</p>
<hr>
<p>My main intention is just to get a proof of concept going, and then those interested can see what's involved and hack on it as they notice things it could do more compatibly.  I'm not going to spearhead any protracted development process for it.</p>
<p>But if someone has a relatively simple Rebol2 script and wants to put in a bit of elbow grease to see it run under emulation, maybe you could post about it here and explain what challenges (if any) there would be.</p>
            <p><small>21 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/requirements-list-for-the-redbol-compatibility-module/722">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/requirements-list-for-the-redbol-compatibility-module/722</link>
          <pubDate>Tue, 03 Jul 2018 14:29:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-722</guid>
          <source url="https://forum.rebol.info/t/requirements-list-for-the-redbol-compatibility-module/722.rss">Requirements List for the Redbol Compatibility Module</source>
        </item>
        <item>
          <title>Rebol 3 compared with Red</title>
          <dc:creator><![CDATA[darrencruse]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>As someone somewhat new to the community here I'm maybe a tiny bit confused about the Rebol 3/Ren-C efforts as compared to Red.</p>
<p>Clearly it's a friendly relationship right.</p>
<p>But as someone new I confess for a bit I was thinking the message was that Red is the future and the Rebol 3 efforts were more or less defunct and replaced by Red.</p>
<p>I realize now that was mistaken, but can someone clarify for me - if both efforts are continuing into the future are there ways in which they are truly different/complementary?</p>
<p>Looking to the future when would I be likely to choose one versus the other?</p>
            <p><small>22 posts - 8 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rebol-3-compared-with-red/192">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rebol-3-compared-with-red/192</link>
          <pubDate>Fri, 07 Jul 2017 00:28:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-192</guid>
          <source url="https://forum.rebol.info/t/rebol-3-compared-with-red/192.rss">Rebol 3 compared with Red</source>
        </item>
        <item>
          <title>Forum name and Red</title>
          <dc:creator><![CDATA[asampal]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>It's been suggested that, in order to not be exclusive to Red users, the name of this forum shouldn't include just the word Rebol. <a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a>, would you be OK with this kind of change, for the reason mentioned? If there is a change to be made, it probably should be done sooner rather than later. What to do?</p>
            <p><small>16 posts - 5 participants</small></p>
            <p><a href="https://forum.rebol.info/t/forum-name-and-red/72">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/forum-name-and-red/72</link>
          <pubDate>Mon, 22 May 2017 17:20:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-72</guid>
          <source url="https://forum.rebol.info/t/forum-name-and-red/72.rss">Forum name and Red</source>
        </item>
  </channel>
</rss>

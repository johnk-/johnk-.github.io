<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest posts</title>
    <link>https://forum.rebol.info</link>
    <description>Latest posts</description>
      <item>
        <title>ChatGPT Speaking About Rebol</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>I'm going to ask it to create a GUI (replacement using Qt or GTK)</p> ]]></description>
        <link>https://forum.rebol.info/t/chatgpt-speaking-about-rebol/1997/2</link>
        <pubDate>Sun, 18 Dec 2022 19:15:40 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6528</guid>
      </item>
      <item>
        <title>ChatGPT Speaking About Rebol</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>So ChatGPT actually knows a bit about Rebol (at least Rebol2)</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/7b940f01f3801b53d0a1d4d412074bda30517443.png" data-download-href="https://forum.rebol.info/uploads/default/7b940f01f3801b53d0a1d4d412074bda30517443" title="image"><img src="https://forum.rebol.info/uploads/default/original/1X/7b940f01f3801b53d0a1d4d412074bda30517443.png" alt="image" data-base62-sha1="hDdWsU3sEBthVlysVvcHRLWmfWH" width="356" height="500" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/7b940f01f3801b53d0a1d4d412074bda30517443_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">image</span><span class="informations">634Ã—890 25 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p>This does raise some questions about the future of software, in general.  It's possible that AI models will plateau and maybe they'll never get too much better than this...</p>
<p>...but I don't think so.  I imagine year-over-year, we're going to see them learning.  I don't know exactly when they'd be able to come up with ideas like what I've been doing for Ren-C.</p>
<p>But something I did think about is that if they can write code, then giving them a super-expressive medium in which to do it could be very powerful.  If they can come up with the dialect and then use it, then they might be able to write concise programs that wind up being quite legible...whereas other languages might make them trade off length for clarity.</p>
<p>If you ask ChatGPT an interesting Rebol question, feel free to put it in this thread.</p> ]]></description>
        <link>https://forum.rebol.info/t/chatgpt-speaking-about-rebol/1997/1</link>
        <pubDate>Sat, 17 Dec 2022 15:53:35 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6527</guid>
      </item>
      <item>
        <title>Should ELSE be FALSE-reactive? (in addition to void and null?)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="IngoHohmann" data-post="3" data-topic="1991">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/40/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>should except react to the whole expression, or just to the branch it is tacked on?</p>
</blockquote>
</aside>
<p>Currently ELSE passes through an isotopic error.</p>
<p>As evidenced by my questioning of if ELSE with a parameter might act as EXCEPT, I'm not totally firm on this, I guess it really just comes down to what shows it works in practice.</p>
<p>But even though it's a bit messy and emergent, I think isotopic errors are a tremendous step up from the more or less untenable prior error situation.</p>
<p><a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852" class="inline-onebox">FAIL vs. RETURN RAISE: The New Age of Definitional Failures!</a></p> ]]></description>
        <link>https://forum.rebol.info/t/should-else-be-false-reactive-in-addition-to-void-and-null/1991/4</link>
        <pubDate>Mon, 05 Dec 2022 16:12:29 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6526</guid>
      </item>
      <item>
        <title>Should ELSE be FALSE-reactive? (in addition to void and null?)</title>
        <dc:creator><![CDATA[@IngoHohmann Ingo Hohmann]]></dc:creator>
        <description><![CDATA[ <p>I find it much clearer to use 'except for error handling, and it makes this possible:</p>
<pre><code>&gt;&gt; if true [1 / 0] else [ 2 / 0 ] except e -&gt; [print mold e]
    make error! [
    type: 'Math
    id: 'zero-divide
    message: "attempt to divide by zero"
    near: [1 / 0 **]
    where: [/ if console]
    file: _
    line: 1
]
</code></pre>
<p>The remaining question: should except react to the whole expression, or just to the branch it is tacked on?</p> ]]></description>
        <link>https://forum.rebol.info/t/should-else-be-false-reactive-in-addition-to-void-and-null/1991/3</link>
        <pubDate>Mon, 05 Dec 2022 11:15:26 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6525</guid>
      </item>
      <item>
        <title>What Should BLANK! in UPARSE Do?</title>
        <dc:creator><![CDATA[@IngoHohmann Ingo Hohmann]]></dc:creator>
        <description><![CDATA[ <p>That's how I see Blank as well. As a generic place holder: nothing interesting here (yet), but no need to worry, this is not an error.</p> ]]></description>
        <link>https://forum.rebol.info/t/what-should-blank-in-uparse-do/1821/4</link>
        <pubDate>Mon, 05 Dec 2022 08:50:57 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6524</guid>
      </item>
      <item>
        <title>Should ELSE be FALSE-reactive? (in addition to void and null?)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Another idea that has been simmering in my head: <strong>What if ELSE was ERROR!-isotope reactive, but only if you use it with a function that takes an argument?</strong></p>
<p>Today that requires you use EXCEPT.</p>
<pre><code>&gt;&gt; if true [1 / 0] except e -&gt; [print mold e]
make error! [
    type: 'Math
    id: 'zero-divide
    message: "attempt to divide by zero"
    near: [1 / 0 **]
    where: [/ if _]
    file: ~null~
    line: 1
]
</code></pre>
<p>But what if this happened?</p>
<pre><code>&gt;&gt; if true [1 / 0] else [print "not reached"]
** Math Error: attempt to divide by zero
** Where: / if
** Near: [1 / 0 **]
** Line: 1

&gt;&gt; if true [1 / 0] else e -&gt; [print mold e]
make error! [
    type: 'Math
    id: 'zero-divide
    message: "attempt to divide by zero"
    near: [1 / 0 **]
    where: [/ if _]
    file: ~null~
    line: 1
]
</code></pre>
<p>This would conflate errors with null and void.  But maybe that's all right.</p>
<p>In the case of UPARSE, pure null or pure void is not returned by combinators at this time.  So you'd be able to write combinators using ELSE instead of the uglier EXCEPT.  And I guess if you didn't actually feel like giving a full error explaining why you were failing a parse combinator, null isn't a terrible shorthand for "I am lazy"...but we'd have to allow <code>raise null</code> to work as just returning null.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-else-be-false-reactive-in-addition-to-void-and-null/1991/2</link>
        <pubDate>Fri, 02 Dec 2022 12:20:12 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6522</guid>
      </item>
      <item>
        <title>Thinking About Isotopes Logically: ~true~ and ~false~</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1944">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>All told, it seems simpler to just let a ~true~ isotope be truthy, ~false~ be falsey, all other word isotopes be neither conditional true nor false. And then make isotopic words an unusually friendly sort of isotope.</p>
</blockquote>
</aside>
<p>So I am pretty gung ho on this.  It has the feeling of a <em>right answer</em>.  As I've said, it was always really depressing to start reading the boot from the top and have a big essay on "we have no idea what logic literals are"... and now not only do we know, but there's a whole deep philosophy on the reified realm being truthy vs. the isotopic realm having some falsey things.  It's high-leverage, high-IQ stuff.  <img src="https://forum.rebol.info/images/emoji/twitter/brain.png?v=9" title=":brain:" class="emoji" alt=":brain:"></p>
<p>The question of just how friendly to make these isotopes runs up against some issues.</p>
<p>For instance, what about MOLDing?  In the bootstrap, we have for instance a <code>debug</code> flag which can be set to things like <strong><code>on</code></strong> or <strong><code>normal</code></strong> or <strong><code>symbols</code></strong> etc., but when it's set to ON in the default config it actually becomes a ~true~ isotope.</p>
<p>So that now causes an error, since MOLD refuses to turn an isotope into a word:</p>
<pre><code>print ["debug:" mold app-config/debug]
</code></pre>
<p>Historical Redbol is willing to wordify the logic:</p>
<pre><code>red&gt;&gt; mold on
== "true"
</code></pre>
<p>I think this intermixing of words with logic is flawed, <em>and I actually like how it gets caught here</em>.  The code which is assigning <strong>debug: on</strong> in the configuration is better as <strong>debug: 'normal</strong>.</p>
<p>For other cases, we've got REIFY if you are okay with ~true~ and ~false~... and it passes through non-isotopic things as-is:</p>
<pre><code>&gt;&gt; reify "hello"
== "hello"

&gt;&gt; reify true
== ~true~
</code></pre>
<p>If you want a word from something you know is a logic, there's LOGIC-TO-WORD</p>
<pre><code>&gt;&gt; logic-to-word true
== 'true
</code></pre>
<p>Overall there are a lot of issues like this, but I think that we want to keep MOLD and PRINT unwilling to do isotopes.  It's a little bit of a speedbump, but helps you get involved to make sure the right thing happens.</p> ]]></description>
        <link>https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944/5</link>
        <pubDate>Fri, 02 Dec 2022 11:48:44 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6521</guid>
      </item>
      <item>
        <title>Should Everything Have an Isotopic Form?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[  ]]></description>
        <link>https://forum.rebol.info/t/should-everything-have-an-isotopic-form/1889/8</link>
        <pubDate>Fri, 02 Dec 2022 11:15:04 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6520</guid>
      </item>
      <item>
        <title>Should Isotopes Be Legal in MAP! (Keys, Values?)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1995">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>null was the signal of not being in a map. Assigning a key null was a way of removing items from that map.</p>
</blockquote>
</aside>
<p>Now that null is implemented as an isotopic word, this feature is broken by a "no isotopes" rule.  So there would have to be an exception made just for null.</p>
<p><strong>But... what if we <em>didn't</em> make an exception, and used void (which isn't "isotopic") to remove elements?</strong>  We could still have the falsey null come back when items weren't found.  The asymmetry seems consistent in the era of void-in-null out.</p>
<p>This would introduce a little bit of a "hassle", e.g. by forcing you to throw in a MAYBE:</p>
<pre><code>&gt;&gt; m: make map! [key &lt;initial&gt;]
== make map! [key &lt;initial&gt;]

&gt;&gt; m.key
== &lt;initial&gt;

&gt;&gt; m.key: select [a 10 b 20] 'c
** Error: Can't put ~null~ isotopes in maps, use void to remove key

&gt;&gt; m.key: maybe select [a 10 b 20] 'c
; void

&gt;&gt; m.key
== ~null~  ; isotope
</code></pre>
<p>But it's probably a good hassle.  "Did you really mean to unset this key?"</p>
<p>If you're sure, it's not any harder... you just say <strong>m.key: void</strong> instead of <strong>m.key: null</strong>.  And it helps make the "you can't put isotopes in maps" rule universal... null just becomes the answer given back when nothing is there, kind of like how it's used in blocks.  This doesn't get cognitively mixed up with giving the appearance you're actually storing an isotope.</p>
<p>You can also make keys the direct product of a conditional, like <strong><code>m.key: case [... [&lt;whatever&gt;]]</code></strong> and if no cases are taken there won't be an addition done.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-isotopes-be-legal-in-map-keys-values/1995/2</link>
        <pubDate>Fri, 02 Dec 2022 10:08:02 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6519</guid>
      </item>
      <item>
        <title>BLANK! (_) as SPACE in String-Oriented Dialects</title>
        <dc:creator><![CDATA[@IngoHohmann Ingo Hohmann]]></dc:creator>
        <description><![CDATA[ <p>Makes sense for me like this.</p> ]]></description>
        <link>https://forum.rebol.info/t/blank-as-space-in-string-oriented-dialects/1885/5</link>
        <pubDate>Fri, 02 Dec 2022 10:03:18 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6518</guid>
      </item>
      <item>
        <title>Should Isotopes Be Legal in MAP! (Keys, Values?)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>In the pre-isotopic era, there was a concept that MAP! would not allow you to store nulls.  Because null was the signal of not being in a map.  Assigning a key null was a way of removing items from that map.</p>
<pre><code>&gt;&gt; m: make map! [x 20]
== make map! [
    x 20
]

&gt;&gt; m.x
== 20

&gt;&gt; m.y
; null

&gt;&gt; m.x: null
; null

&gt;&gt; m
== make map! [
]
</code></pre>
<p>Additionally, NULL was not allowed as a key.</p>
<h2>How Should This Change In The Isotopic Era?</h2>
<p>I'll make the point that not allowing you to store isotopes as keys or values isn't a fundamental problem, because you can META a value to put it in, and then UNMETA it when taking it out.</p>
<p>You wind up with a fundamental issue that actions from a MAP! won't be run implicitly this way, and you can't put any falsey values in a map this way (because false is the ~false~ word isotope, and ~null~ isotopes are representations of not being in the map).</p>
<p>But that limitation can be a benefit.  I already think of it as a benefit that you cannot run an action by doing access of items out of a block.  e.g. <strong>block.1</strong> could never run a function now (since blocks can't store isotopic actions).  If that was true of <strong>map.key</strong> as well, that could be seen as a good thing... you'd have to APPLY or RUN a plain ACTION! (or QUASI-ACTION!).</p>
<pre><code>&gt;&gt; m: make map! []

&gt;&gt; m.1: :append
** Error: Cannot put ACTION! isotope in map

&gt;&gt; m.1: ^append
== ~#[action! {append} [series value /part /dup /line]]~

&gt;&gt; m.1
== ~#[action! {append} [series value /part /dup /line]]~

&gt;&gt; run m.1 [a b c] [d e]
== [a b c [d e]]

&gt;&gt; apply m.1 [[a b c] [d e] /dup 2]
== [a b c [d e] [d e]

&gt;&gt; m.1/ [[a b c] [d e] /dup 2]
== [a b c [d e] [d e]
</code></pre>
<p>As with the peace of mind using BLOCK!, that seems like a good thing to me.</p>
<p><em>(I'm not entirely sure if RUN should allow QUASI-ACTION!s, or if you should have to UNQUASI it into a plain ACTION!.  Forcing the canonization might make more sane, so that routines that want to exchange actions as currency would have one standard they spoke.)</em></p>
<p>I also think it's likely a good thing that false isotopes wouldn't be in the map, only quasi-false and the word false.  So if you're putting logic into a map, you'd wind up writing <strong><code>if map.key = 'true [...]</code></strong> or <strong><code>if map.key = 'false [...]</code></strong> and save the <strong>if map.key</strong> and <strong>if not map.key</strong> for testing things being in the map.</p>
<h2>This Would Widen The Gap With Objects</h2>
<p>There have been questions about what the difference is between maps and objects, and this would be another: objects must be able to have members that are isotopes: action isotopes that can run implicitly, logic and null and other word isotopes, and I'm presuming splices and other stable forms as well.</p>
<p>It would mean a map has more in common with a block.</p>
<p>This doesn't strike me as being that much of a problem.</p>
<p><strong>So I'm going to be going ahead with the premise that isotopes can't be stored in maps, as either keys or values.</strong>  We'll see how it goes, but I think this is the right answer.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-isotopes-be-legal-in-map-keys-values/1995/1</link>
        <pubDate>Fri, 02 Dec 2022 09:28:15 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6517</guid>
      </item>
      <item>
        <title>Head-to-Head Battle of the Coding Fonts</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>So I don't think this did the best job of representing Inconsolata (the choice for the ReplPad), but it lets you pit monospace fonts against each other to find the one you like:</p>
<p><a href="https://www.codingfont.com/">https://www.codingfont.com/</a></p>
<p>I still think if the right weight of Inconsolata is chosen it's the best.</p>
<p><a href="https://fonts.google.com/specimen/Inconsolata?preview.text=0O1Iil&amp;preview.text_type=custom#styles" class="inline-onebox">Google Fonts: Inconsolata</a></p>
<p>For me, the competition would be Source Code Pro or Fira Code.</p> ]]></description>
        <link>https://forum.rebol.info/t/head-to-head-battle-of-the-coding-fonts/1994/1</link>
        <pubDate>Thu, 01 Dec 2022 14:43:59 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6516</guid>
      </item>
      <item>
        <title>What Should BLANK! in UPARSE Do?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1821">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>That's a slam dunk. So now we have the behavior tied up. <img src="https://forum.rebol.info/images/emoji/twitter/relieved.png?v=9" title=":relieved:" class="emoji" alt=":relieved:"></p>
</blockquote>
</aside>
<p><em>I'm...pretty sure (?) this is still the best plan.</em></p>
<p>So there's a new philosophy I've outlined for why BLANK! exists at all, and its purposes as being a kind of generic "nothing to see, here" is distinct from what might be thought of more as a disruptor like null or an unset variable.  It is not related at all to soft failure.  Blank is simply a wildcard that you can choose to treat equivalently to an empty series or missing value, without committing to being anything in particular.</p>
<p>I've also mentioned that in some mechanical contexts (like APPEND), we are simply more interested in blank's "thingness" than in its representation of nothingness.  So you have to DECAY it or SPREAD it or otherwise interact with it to get it to not act mechanically.</p>
<p><em>PARSE strikes me as one of the more mechanical contexts.</em></p>
<pre><code>parse [_ _ _] [repeat 3 _]
</code></pre>
<p>And I think the value of having it to represent space in string contexts is probably high.</p>
<p>It may be one of those things where to prevent accidents where you didn't mean it to be interpreted as a space, it shouldn't allow you to use it fetched from a WORD! in the rules.  You either use <code>@var</code> to say "I mean literally a blank" or you can make the rule contain a quoted value.</p>
<h2>But It's Important To Point Out There Are Other Tools</h2>
<p>Already, a lone apostrophe acts like an empty rule:</p>
<pre><code>&gt;&gt; parse "abc" ["a" ' "b" "c"]
== "c"
</code></pre>
<p>This makes even more sense than it used to, <a href="https://forum.rebol.info/t/how-became-quoted-void-and-became-quasi-void/1915">because a lone apostrophe is now a quoted void</a>.  And you can think of there being infinitely many voids at any position in a block.</p>
<p>Also already, <strong>~</strong> triggers a failure (though it should probably give a better message):</p>
<pre><code>&gt;&gt; parse "abc" ["a" ~ "b" "c"]
** Error: ~ encountered in parse rule
</code></pre>
<p>You could also use quasiwords for failures, e.g.:</p>
<pre><code>&gt;&gt; parse "ccc" [some "a" | some "b" | ~mismatch~]
** Error: ~mismatch~ in PARSE</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/what-should-blank-in-uparse-do/1821/3</link>
        <pubDate>Thu, 01 Dec 2022 09:51:02 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6515</guid>
      </item>
      <item>
        <title>How &#39; Became Quoted-Void (and ~ Became Quasi-Void)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><img src="https://forum.rebol.info/images/emoji/twitter/arrow_double_up.png?v=9" title=":arrow_double_up:" class="emoji only-emoji" alt=":arrow_double_up:"></p>
<p>I've streamlined the above thread of historical discussion-with-myself to remove the flip-flopping, and just chronicle the actual points.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1915">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>One of my early reasonings was that VOID was more "etheric" than NULL. <em>So perhaps void was actually the isotopic form of null,</em> and ~ could be null's quasiform:</p>
<pre><code> &gt;&gt; quasi null
 == ~

 &gt;&gt; ~
 ; void
</code></pre>
<p>But this was confusing, since if <code>~</code> was the meta of void, there really isn't any such thing as a "~ isotope". You could never make one, because I thought it needed to vaporize.</p>
<pre><code>&gt;&gt; 1 + 2 ~
== 3
</code></pre>
</blockquote>
</aside>
<p>This is a curious realization about how an early decision got stuck in my head.  NULL was the first thing I implemented that had "no representation", and I gave it the "privileged" state of being the vaporizing result of a quoted nothing:</p>
<pre><code>&gt;&gt; '
; null  (hmmmm...)
</code></pre>
<p>As the need to print out a comment there shows, it's not like I'd solved the "has no value representation" problem in some general sense by picking this particular choice.  And it turns out to be a pretty bad choice.</p>
<p>It's much better for void.  And having the isotopic state represent unset variables is a real joy in terms of the visuals and ergonomics.  Being able to say <strong><code>(x: ~)</code></strong> and unset a variable, and have that be the rendering in a list of unset variables draws the attention to the things that are set.</p> ]]></description>
        <link>https://forum.rebol.info/t/how-became-quoted-void-and-became-quasi-void/1915/6</link>
        <pubDate>Thu, 01 Dec 2022 09:02:11 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6514</guid>
      </item>
      <item>
        <title>NULL, BLANK!, NIHIL, VOID: History Under Scrutiny</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="rgchris" data-post="20" data-topic="1249">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I'm not saying you're wrong, I just don't understand why you're right</p>
</blockquote>
</aside>
<p>I'm glad you've been persistent in questioning non-ergonomic behaviors and terminology.  I think it has greatly helped aim the design toward meeting both the needs of system coherence (my specialty) and idiomatic Rebol user scenario aesthetics (your specialty).  As I've said--if I've been irritable about it, mostly it's been that I can't solve a problem of you not relating to what I write by writing more of the same.</p>
<p>But I think things are different now, and I think it's mostly hammered out.</p>
<p>I've vetted this historical thread and replaced references to "void" with "nihil", to avoid confusions with the modern sense of the word void you argued for <em>(the vanishing state, distinct from the contents of an unset variable--although the two are now linked together, as nihil is the isotopic state of void)</em>.</p>
<aside class="quote no-group" data-username="rgchris" data-post="15" data-topic="1249">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I'm just still trying to better understand the intersection of NIHIL/NULL/BLANK/LOGIC as it pertains to values and flowâ€”I don't yet have a settled story myself about why this is a necessary improvement over BLANK! as flow currency.</p>
</blockquote>
</aside>
<p>So the story to me all pulls together like this:</p>
<ul>
<li>
<p><strong>VOID</strong> - An intent of absolutely nothing, a desire for a no-op or vaporizing value.  If you pass to a function there may be a sensible return result, and if not you may return another signal (probably an ornery one and not another void, in order to get errors in sensible spots vs. generating a confusing chain that opts itself entirely out with no sign of where the trigger was)</p>
<pre><code>&gt;&gt; (comment "hi")
; void

&gt;&gt; 1 + 2 void
== 3

&gt;&gt; append [a b] void
== [a b]

&gt;&gt; append void 10
== ~null~  ; isotope
</code></pre>
</li>
<li>
<p><strong>NIHIL</strong> - The state of an unset variable, where you wish for it to cause an error merely by referencing a word.  You thus can't test an unset variable like <code>if asdfasdf [...]</code> because there will be an error on the <code>asdfasdf</code> reference.  But even if you get a NIHIL, it is still logically neither true nor false and will generate an error.</p>
<pre><code>&gt;&gt; if asdfasdf [print "never reached"]
** Error: asdfasdf is unset

&gt;&gt; get/any 'asdfasdf
== ~  ; isotope
          ^-- nihil is technically the isotopic state of void

&gt;&gt; if get/any 'asdfasdf [print "never reached, either"]
** Error: ~ isotopes are neither conditionally true nor false
</code></pre>
</li>
<li>
<p><strong>NULL</strong> - A signal of soft failure, such as a SELECT or PICK that did not succeed.  It does not cause errors to fetch it from a word, and it is logically false...so it's a good choice for initializing a variable that you plan to be testing in various places to see if it has been assigned yet or not.  Most routines will error if you try to pass a null to an argument that it expects, so you're supposed to be using that convenient testability to avoid branches which don't apply:</p>
<pre><code>&gt;&gt; third [a b]
== ~null~  ; isotope

&gt;&gt; if third [a b] [print "Never reached"]
; void

&gt;&gt; append [d e] third [a b]
** Error: APPEND cannot add a ~null~ isotope to a block
</code></pre>
</li>
</ul>
<h2>None of The Above States Can Be Put In Blocks</h2>
<p>VOID opts out of being appended, and NIHIL and NULL are isotopes.  Isotopes (stable ones, e.g. not errors or parameter packs) are states that variables can have, but can't be in blocks.</p>
<p><strong>Yet each of these cases reasonably needs a "proxy value" for representing their intent in a block.  The idea behind these proxy values is that under evaluation, each will produce the state.</strong></p>
<p>There is <strong>QUOTED VOID</strong>, which when evaluated drops the quote level and becomes void.</p>
<pre><code>&gt;&gt; quote void
== '

&gt;&gt; '
; void

&gt;&gt; 1 + 2 '
== 3

&gt;&gt; append [a b] '
== [a b]
</code></pre>
<p>There is <strong>QUASI VOID</strong>, which when evaluated becomes isotopic void (which is what I'm calling NIHIL).  Assigning it to a variable will unset that variable.</p>
<pre><code>&gt;&gt; quasi void
== ~

&gt;&gt; ~
== ~  ; isotope

&gt;&gt; foo: ~
== ~  ; isotope

&gt;&gt; foo
** Error: FOO is unset
</code></pre>
<p>There is the <strong>QUASI-WORD! WITH THE SPELLING "NULL"</strong>, which when evaluated becomes the isotopic word worm of ~null~.  <em>(The choice to make this literal english word isotope correspond to the null state is a pragmatic one, because something like ~_~ for isotopic blank being designated as null doesn't really offer appreciable benefit and would be a tax to explain.)</em></p>
<pre><code>&gt;&gt; quasi 'null
== ~null~

&gt;&gt; ~null~
== ~null~  ; isotope
</code></pre>
<p><strong>Mechanically, these proxy values are all as friendly as any other value in block manipulation.</strong>  There's nothing special about them when you're TAKE-ing or APPEND-ing or INSERT-ing them.  But functions can react differently to them in terms of the intent they are proxying.</p>
<pre><code>&gt;&gt; append [a b] second [d ']
== [a b ']

&gt;&gt; append [a b] decay second [d ']
== [a b]

&gt;&gt; append [a b] second [d ~]
== [a b ~]

&gt;&gt; append [a b] decay second [d ~]
** Error: Cannot APPEND ~ isotopes to blocks
</code></pre>
<h2>BLANK! Fills A Niche The Proxy Values Do Not Cover</h2>
<p>The idea behind blank as a placeholder is that it can stand in for values and then routines can fold its handling in as part of that routine's natural handling of no value.</p>
<p>I believe for example that blank should report TRUE back from EMPTY?, and that it should react to SPREAD the same as an empty block would:</p>
<pre><code> &gt;&gt; data: [Foo [10 20] Baz _ Bar [30]]

 &gt;&gt; map-each [name stuff] data [spread stuff]
 == [10 20 30]
</code></pre>
<p><em>(By contrast, I'd think that SPREAD of reified <strong><code>~</code></strong> or <strong><code>~null~</code></strong> should pretty clearly be errors.  A SPREAD of just <strong><code>'</code></strong> might reasonably be argued to act like void, but I'm not sure, so it's an error for now and you'd have to at least DECAY it for it to act like a void.)</em></p>
<p>In any case--this isn't to say BLANK! is synonymous with empty blocks...because it's not.  It's equally likely a placeholder for an empty string, or a slot which could be a WORD! or a TAG! or an INTEGER!.</p>
<p>So if its behaviors seem too "friendly" by answering a lot of basic questions and allowing FOR-EACH enumerations to be skipped without complaint, and you don't want such a friendly slot, then <strong>~</strong> may be a better choice for a reified nothing.</p>
<h2>Cross-Cutting Behaviors Are Better Than Making BLANK! False</h2>
<p>I've uncovered some pretty deep value from being able to say with confidence that anything you can pick out of a block or group is "truthy" from IF's point of view.</p>
<p>When you take a step out from mechanical block construction into the world of what's legal states for variables, then you get into isotopes... where we have isotopic ~null~ and ~false~ and so there are falsey states there.  Things are very pleasing.</p>
<p>I think the much more interesting things to say are these other properties like that BLANK! is EMPTY? or that it SPREADs equivalently with an empty block, rather than that it is falsey.  Those properties are where the leverage comes from.  And the leverage of saying everything reified in a block is truthy is tremendous.</p>
<p>However, I am going to want Redbol emulation to work...even if I think reified things all being truthy is the better answer.  I'll have to look into how to hook a TRUTHY? function used by a sort of "evaluative sub-universe"...maybe on a module level, and what hope that has vs. needing to rewrite every construct that acts on a concept of testing for truth and falsehood.</p>
<p>(You lose a lot of interesting correctness going against the all-block-reified-items are truthy rule... <strong>while [item: try take block] [...]</strong> is just the tip of the iceberg.)</p>
<h2>Distortion Of Return Results For THEN/ELSE Are Cleaned Up</h2>
<p>I won't rewrite it all here, but the idea of differentiating ~null~ isotopes signaling "no result" vs. being able to signal "there was a result and it was a null isotope" is folded in with the multi-return mechanics.</p>
<p>A parameter pack containing one null isotope will unpack that into a SET-WORD! or first multi-return in a SET-BLOCK!, and for almost any parameter it will act identically.  Only some routines like THEN and ELSE will be sensitive to a difference between these two.  Conditional constructs that wish to return null intentionally simply must box it up in a parameter pack to count as "an answer that is null" vs. returning a null in isolation.</p>
<p>Long story short: The various aspects of broken that were introduced by distorting return results in service of THEN and ELSE has been finessed and folds into a bigger story of multi-returns, <a href="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134/12">which by leveraging isotopes are able to be handled gracefully in compositions</a>.</p>
<h2>Pleasingly, This Is Only THREE Types (if you think of it that way).</h2>
<p>What you're seeing here is just VOID, BLANK!, and WORD!.</p>
<p>It just so happens that all datatypes now have isotopic forms, quasiforms, and quoted forms.</p>
<p>But there's full regularity in the behaviors:</p>
<ul>
<li>all quoted values evaluate by removing one quote level</li>
<li>all quasiforms evaluate by producing the isotopic form</li>
<li>no isotopic forms can be put in blocks</li>
<li>attempting to put a void in a block is a no-op</li>
<li>all non-isotopic forms are legal in blocks and act the same w.r.t. APPEND, TAKE, etc.</li>
</ul>
<p>There are nuances here, but, also some very strong anchor points for supporting the flow of engineering decision-making...</p> ]]></description>
        <link>https://forum.rebol.info/t/null-blank-nihil-void-history-under-scrutiny/1249/23</link>
        <pubDate>Thu, 01 Dec 2022 05:58:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6513</guid>
      </item>
      <item>
        <title>BLANK! (_) as SPACE in String-Oriented Dialects</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>With some of my observations on how we can use "single character intents of nothing" (<strong><code>[_ ' ~]</code></strong>), I think it's worth coming back to look at this BLANK!-as-space question one more time...<sub><em>(It's almost never just one more time, is it.  <img src="https://forum.rebol.info/images/emoji/twitter/man_facepalming.png?v=9" title=":man_facepalming:" class="emoji" alt=":man_facepalming:"> )</em><sub></sub></sub></p>
<p><a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604/3" class="inline-onebox">Shades of Distinction In Non-Valued Intents - #3 by hostilefork</a></p>
<p>I suggest that it would be nice if anywhere that <em>would</em> take a series, BLANK! acting like an empty series would be a cool behavior.</p>
<p><strong>So... how necessary is it that we give DELIMIT behavior for BLOCK!s or GROUP!s--empty or otherwise--that we would want to have parity with empty block for blanks?</strong></p>
<p>Looking at just what's there right now, today, we have this behavior:</p>
<pre><code>&gt;&gt; c: 1020
&gt;&gt; d: 304

&gt;&gt; unspaced ["a" ["b" c] d]
== "abc304"

&gt;&gt; spaced ["a" ["b" c] d]
== "a bc 304"
</code></pre>
<p>So it uses the contents of the block as raw material, but doesn't reduce it or obey the delimiter.  With GET-BLOCK! you have a shorthand to reduce it, if you like:</p>
<pre><code>&gt;&gt; unspaced ["a" :["b" c] d]
== "ab1020304"

&gt;&gt; spaced ["a" :["b" c] d]
== "a b1020 304"
</code></pre>
<p><strong>I've always tended to think that having automatic behavior for BLOCK! here does more harm than good.</strong>   More often than not, you just get nonsense when you wanted something else:</p>
<pre><code>&gt;&gt; block: [1 2 &lt;x&gt; hello]

&gt;&gt; print ["Your block is:" block]
Your block is: 12&lt;x&gt;hello  ; ugh.
</code></pre>
<p>It's bad enough when the results get printed and you see the garbage.  But worse when it just affects some string you're writing somewhere accidentally.</p>
<p>There's some efficiency gain if the enumeration of the block gets folded recursively into the process because you're not generating large intermediate strings and merging them... you're just building one big long string as you go.  So that led me to think it <em>might</em> have value, and implemented it.  But I've remained a skeptic... and...</p>
<h2>...I Don't Think DELIMIT Should Have a BLOCK! Behavior</h2>
<p>The case above shows the kind of nonsense I'm tired of.</p>
<p>Now that <a href="https://forum.rebol.info/t/should-reduce-heed-spread/1917">SPREAD Could Heed DELIMIT</a> that gives other ways to optimize the situation of wanting to fold a block's contents into a string formation.</p>
<p>There's a weird but kind of cool behavior that quoting an item will mold it.  And you can use ^META to take most types up a quoting level:</p>
<pre><code>&gt;&gt; str: "abc"
&gt;&gt; blk: [a b c]

&gt;&gt; print ["String is" ^str "and Block is" ^blk]
String is "abc" and Block is [a b c]
</code></pre>
<p>If you're wondering why not to use <span class="mention">@str</span> and <span class="mention">@blk</span>, it's because ECHO semantics used those for non-mold-oriented splicing, e.g. if you just had a plain string it would echo it:</p>
<pre><code>&gt;&gt; echo [String is @str]
String is abc
</code></pre>
<p>Not that PRINT and ECHO need to line up, but it's something to think about.</p>
<p><strong>I guess the long story short here being that I am not all <em>that</em> worked up over the loss of synonymousness between an empty block and blank in the DELIMIT dialect.</strong></p>
<p>If BLANK! did anything besides act as a space, it would probably need to be an error.  I guess I'll have to keep my eyes open for what the opportunities are for blank being synonymous with an empty block in these stringification scenarios... but my instinct is to say those aren't particularly interesting.</p>
<p>I think the apostrophe case could be used for when you really mean nothing--as a reified proxy for void--instead of blank.</p>
<p><strong>The big question may actually be at the topmost level of FORM, e.g. FORM of an empty block vs. FORM of a blank.</strong></p>
<pre><code>&gt;&gt; form [a b]
== "a b"

&gt;&gt; form [_]
== " "  ; we are presuming this direction

&gt;&gt; form []
== ""  ; (or possibly null ?)

&gt;&gt; form _
== " "  ; or should it be forced to match what empty block is?
</code></pre>
<p>But there's no rule that <strong>form [_]</strong> has to match <strong>form _</strong> any more than there is that <strong>form [[]]</strong> has to do the same thing as <strong>form []</strong>, so this needs to be weighed.</p> ]]></description>
        <link>https://forum.rebol.info/t/blank-as-space-in-string-oriented-dialects/1885/4</link>
        <pubDate>Wed, 30 Nov 2022 12:28:57 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6512</guid>
      </item>
      <item>
        <title>VID/S or Spaces, from Red&#39;s hiiamboris</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Helps as a calling card to tell which Red demos to pay attention to.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p> ]]></description>
        <link>https://forum.rebol.info/t/vid-s-or-spaces-from-reds-hiiamboris/1886/6</link>
        <pubDate>Wed, 30 Nov 2022 12:00:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6511</guid>
      </item>
      <item>
        <title>VID/S or Spaces, from Red&#39;s hiiamboris</title>
        <dc:creator><![CDATA[@gchiu]]></dc:creator>
        <description><![CDATA[ <p>I have no idea why he chooses these odd colour combinations</p> ]]></description>
        <link>https://forum.rebol.info/t/vid-s-or-spaces-from-reds-hiiamboris/1886/5</link>
        <pubDate>Wed, 30 Nov 2022 11:44:33 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6510</guid>
      </item>
      <item>
        <title>Shades of Distinction In Non-Valued Intents</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I've brought the above discussion up to date, and I think it paints a pretty clear picture of why things are the way they are.</p>
<p>But I realized while thinking about what the right default for ARRAY would be, that there are effectively three single-character reified non-values:</p>
<pre><code>[1]  &gt;&gt; array 3
     == [_ _ _]  ; BLANK!s

[2]  &gt;&gt; array 3
     == [~ ~ ~]  ; Quasi-VOID!s

[3]  &gt;&gt; array 3
     == [' ' ']  ; Quoted-VOID!s
</code></pre>
<h2>This Offers Us Some Nuance Even If A State Must Be Reified!</h2>
<p>When it comes to the direct behavior of APPEND to a block, all these states have to work the same.  In the era of isotopes, all reified values are appended as-is... it cannot (and should not) be any more complex:</p>
<pre><code>&gt;&gt; append [a b] second [c _]
== [a b _]

&gt;&gt; append [a b] second [c ~]
== [a b ~]

&gt;&gt; append [a b] second [c ']
== [a b ']

&gt;&gt; append [a b] second [c [d e]]
== [a b [d e]]
</code></pre>
<p><strong>But when we throw in an extra operation, we can imagine a difference.</strong>  For instance, we could make BLANK! semantically equivalent to an empty array for the purposes of things like SPREAD or EMPTY?</p>
<pre><code>&gt;&gt; spread second [c []]
== ~[]~  ; isotope

&gt;&gt; spread second [c _]
== ~[]~  ; isotope

&gt;&gt; append [a b] spread second [c _]
== [a b]

&gt;&gt; empty? second [c _]
== ~true~  ; isotope
</code></pre>
<p>...and then we'd say that if you tried to do such things with a quasi-void or a quoted-void, it would be an error:</p>
<pre><code>&gt;&gt; spread second [c ~]
** Error: SPREAD does not accept QUASI-void arguments

&gt;&gt; empty? second [c ']
** Error: EMPTY? does not accept QUOTED-void arguments
</code></pre>
<p><em>I think this suggests that <code>~</code> makes a better choice for the default value of ARRAY elements!</em>  We can't default to an isotope like the one representing unset variables, but it's the closest thing.</p>
<p><em>Ultimately it came to seem that having only the isotopes ~null~ and ~false~ be falsey was more valuable than having BLANK! be falsey.</em>  Simply being able to assume that anything you can find in an array is truthy offered more leverage.  So blanks are now truthy, BUT they're empty.</p>
<h2>What About Opting Out Of As-Is Appends, etc?</h2>
<p>I mentioned that all items that can be found in a block have to act mechanically identically when it comes to TAKE-ing and APPEND-ing them.  But what would XXX be if you wanted the following?</p>
<pre><code>&gt;&gt; append [a b] xxx second [c [d e]]
== [a b [d e]]

&gt;&gt; append [a b] xxx second [c _]
== [a b _]

&gt;&gt; append [a b] xxx second [c ~]
** Error: Cannot append NIHIL (~ isotope) to a block

&gt;&gt; append [a b] xxx second [c ']
== [a b]
</code></pre>
<p>I suggest this operator be called DECAY.  It would turn all quasiforms into their corresponding isotope, and its behavior of turning QUOTED! void into a void would be a unique behavior for which that is the only quoted form that it would do that for.</p>
<pre><code>&gt;&gt; decay first [~asdf~]
== ~asdf~  ; isotope

&gt;&gt; decay first ['foo]
== 'foo

&gt;&gt; decay first [123]
== 123

&gt;&gt; decay first [']
; void
</code></pre>
<p>The reverse of this operator would be REIFY.</p>
<h2>What About FOR-EACH Variations?</h2>
<p>I think an additionally neat spin on how these can be treated differently can be how FOR-EACH responds.</p>
<pre><code>&gt;&gt; for-each x (second [c []]) [
       print "Loop never runs"
   ]
; void

&gt;&gt; for-each x (second [c _]) [
       print "Loop never runs"
   ]
; void

&gt;&gt; for-each x (second [c ']) [
       print "Loop never runs"
   ]
== ~null~  ; isotope (like a void in, null out... or if a BREAK was hit)

&gt;&gt; for-each x (second [c ~]) [
       print "Loop never runs"
   ]
** Error: FOR-EACH does not accept QUASI-VOID as its data argument
</code></pre>
<p>This is a bit more speculative, but I like the general idea that a quoted void could let you have a kind of nothing that gave you the "opt out" ability in places where it could... and quasi void could give you an error, while blank acts like an empty series.  This seems to offer some nice invariants that reduce overall code you have to write handling edge cases.</p>
<hr>
<p><strong>I hope that this all plugs together, <a class="mention" href="/u/rgchris">@rgchris</a>.  Can you review this thread and tell me if I've finally gotten it all to gel for you?</strong></p> ]]></description>
        <link>https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604/3</link>
        <pubDate>Wed, 30 Nov 2022 04:00:22 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6508</guid>
      </item>
      <item>
        <title>The History of Multi-Return in Ren-C</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="12" data-topic="1134">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Casualties of Composability</p>
</blockquote>
</aside>
<p>One point to mention here is that as far as the core protocol goes, there's no names for the individual multi-return outputs.  If we wanted that, we'd have to make it so that if a function returned a "FRAME! isotope" with labeled fields.</p>
<p>This isn't silly vs. returning an OBJECT! by convention in the same way that it's not silly vs. returning a BLOCK! by convention.  You want that single-result default, and then more only if you ask for it.  So there's still a way the first field in the frame could be picked out via a SET-WORD! and the other fields by a SET-BLOCK!; or you could ^META it and access them by name.</p>
<p>It's something to keep in mind, but nothing being done currently rules it out as a future possibility.  The central point is the same--that there's an isotopic bundle that can't be interpreted as something you intend to store in a block or assign to a variable in and of itself.  The isotopic status decays to one item in the bundle in the absence of a specific unpacking intent.</p> ]]></description>
        <link>https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134/13</link>
        <pubDate>Mon, 28 Nov 2022 05:50:11 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6504</guid>
      </item>
      <item>
        <title>The Pending New Meaning of GET-XXX!</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="1901">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1901">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But Like I Said, You Can't Wish Away Complexity...</p>
</blockquote>
</aside>
<p>Indeed you cannot.</p>
</blockquote>
</aside>
<p>Why not? I think you can. It won't work, but you can wish it away.</p> ]]></description>
        <link>https://forum.rebol.info/t/the-pending-new-meaning-of-get-xxx/1901/3</link>
        <pubDate>Sun, 27 Nov 2022 21:09:03 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6503</guid>
      </item>
      <item>
        <title>BLANK! 2022: Revisiting The Datatype</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="7" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>While <strong>~null~</strong> is definitely more verbose than using <strong>_</strong> to null out variables, I'm not entirely sure that nulling out variables needs to be in the scheme of things any more succinct than setting a variable to false</p>
</blockquote>
</aside>
<p>I reverted the blank-evaluates-to-null change and examined all the callsites.  I definitely have some mixed feelings.</p>
<p>Turning <strong><code>_</code></strong> back into a WORD! vs a separate BLANK! type is the only thing that I might see as a reasonable alternative, and then setting it to be null by default, but then settable to anything else in contexts you wanted it.  You could then take it for granted that <strong><code>(x: _)</code></strong> would set X to null just as much as you would be that <strong><code>(x: null)</code></strong> would.</p>
<p>It's tempting to try picking something else to represent nothingness.  What if you could opt-out of a FOR-EACH variable using a lone apostrophe?</p>
<pre><code>&gt;&gt; for-each ' [1 2 3] [print "no variable"]
no variable
no variable
no variable
</code></pre>
<p>It's more slight than <strong><code>for-each _ [1 2 3]</code></strong>, but not awful.  And since voids are used to opt-out in slots it actually dovetails nicely with if the evaluated forms were allowed to opt out via void:</p>
<pre><code>for-each (if false ['x]) [1 2 3] [print "no variable"]
</code></pre>
<p>That seems to make perfect sense.  If your expression produces no iterative variables to bind in the body assume that you didn't need them.  The alternative of <strong><code>(if false ['x] else [_])</code></strong> or even <strong><code>(if false 'x else '_)</code></strong> seems like busywork.</p>
<p>This even would mean you could use <strong><code>()</code></strong> as a less slight alternative, if you didn't like the <strong><code>'</code></strong>  syntax:</p>
<pre><code>for-each () [1 2 3] [print "no variable"]  ; actually pretty nice!
</code></pre>
<p>The premise may hold for multi-returns also:</p>
<pre><code>&gt;&gt; [a ' c]: pack [1 2 3]
== 1

&gt;&gt; c
== 3

&gt;&gt; [a () c]: pack [4 5 6]
== 4

&gt;&gt; c
== 6
</code></pre>
<p>I'm not sure it looks worse than <strong><code>[a _ c]: pack [...]</code></strong>, and would open up:</p>
<pre><code>&gt;&gt; [a _ c]: pack [8 9 10]
== 8

&gt;&gt; _
== 9

&gt;&gt; c
== 10
</code></pre>
<p><em>One potential qualm:</em> a quoted word vs. a regular word is seen as a different instruction by both FOR-EACH and multi-return.  So from a type system perspective it's like you're conflating some meanings of what QUOTED! is supposed to signal when you use an apostrophe vs. a distinct BLANK! type.  e.g. there's no "unquoted void literal", only a quoted one.</p>
<p>In the case of how the mechanics of LET works, this is actually a problem, because the apostrophes escape things it's not supposed to consider part of the LET :-/</p>
<pre><code> let [a 'b]: multi-returner ...
 =&gt;
 let a, [a b]: multi-returner ...  ; just drops the quote level from quoted things

 let [a ' c]: multi-returner ...
 =&gt;
 let [a c], [a ??? c]: multi-returner ...  ; can't drop quote level from lone quote
</code></pre>
<p>Yes, it could say that there's an exception for lone quotes and they stay as is, but it sort of points to the general unease and "weird exceptions" you have to make when the quoted state of void is used to represent something that is only quoted at all because it's "probably not meaningful otherwise".  Just seems to lead to snakey rules that the more-visible blank doesn't require.</p>
<p>Or maybe we just say <strong><code>()</code></strong> is what you use, I don't know.</p>
<pre><code>let [a () c]: multi-returner ...
</code></pre>
<p>Thinking further... today BLANK! is the default used by things like ARRAY but that could have different choices too:</p>
<pre><code>&gt;&gt; array 3
== [' ' ']  ; quoted voids

&gt;&gt; array 3
== [~ ~ ~]  ; isotopic voids

&gt;&gt; array 3
== [# # #]  ; empty tokens
</code></pre>
<p>Of those choices, I'd probably say I like the isotopic voids, just because of how ornery they become when evaluated....and orneryness seems like a good characteristic for when you didn't specify an /INITIAL value to be used.</p>
<p>But just because we would return <strong>_</strong> to the WORD! pool... would making it defined to evaluate to a null isotope be a good thing?  People might want it for other purposes (consider things like the <a href="https://underscorejs.org/">underscore.js library</a>, where it's the name of a utility module that tries to disappear).</p>
<pre><code>&gt;&gt; _: import %my-utility-lib.r

&gt;&gt; _.sum [1020 304]
== 1234
</code></pre>
<p>If you're going to open <strong>_</strong> up for potentially interesting purposes, but then turn around and say everyone assumes it evaluates to null, then I'm not clear that the ability to redefine it is as much a benefit as a potential nuisance.  <img src="https://forum.rebol.info/images/emoji/twitter/angry.png?v=9" title=":angry:" class="emoji" alt=":angry:"></p>
<p><strong>Beyond the above arguments, having a special type to serve as BLANK! in PATH!s is kind of a killer case, which makes reserving it as an inert dialecting part that is used as a "spacer" as well as potentially meaning just "space" makes the most sense to me.</strong></p> ]]></description>
        <link>https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942/8</link>
        <pubDate>Sun, 27 Nov 2022 13:01:57 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6502</guid>
      </item>
      <item>
        <title>Python Speedup Proposals</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>The original "CPython" implementation is in some ways similar to Rebol/Red... though these days Ren-C is more aligned with the stackless Python implementation...which is also written in C, but distinct from CPython.</p>
<p><em>(But Ren-C's design overall is a lot less comparable to anything, due to the number of very "alien" ideas in it, but that I think are what gives it more notable properties.)</em></p>
<p>In any case, despite running an interpreter loop and doing kind-of-what-Rebol-does, they've committed themselves to doing some speedup proposals and apparently it's paying off:</p>
<p><a href="https://devblogs.microsoft.com/python/python-311-faster-cpython-team/" class="inline-onebox">A Team at Microsoft is Helping Make Python Faster - Python</a></p>
<p>Some of their proposals involve JIT-compiling things (which they know won't work on restrictive platforms like iOS).  But they apparently have done a lot of tweaks besides that which have turned out beneficial.  Because it's a C interpreter there might be something applicable to be learned by looking at their "Stage 1" and "Stage 2" changes.</p>
<blockquote>
<h3>Stage 1 -- Python 3.10</h3>
<p>The key improvement for 3.10 will be an adaptive, specializing interpreter. The interpreter will adapt to types and values during execution, exploiting type stability in the program, without needing runtime code generation.</p>
<h3>Stage 2 -- Python 3.11</h3>
<p>This stage will make many improvements to the runtime and key objects. Stage two will be characterized by lots of "tweaks", rather than any "headline" improvement. The planned improvements include:</p>
<ul>
<li>Improved performance for integers of less than one machine word.</li>
<li>Improved peformance for binary operators.</li>
<li>Faster calls and returns, through better handling of frames.</li>
<li>Better object memory layout and reduced memory management overhead.</li>
<li>Zero overhead exception handling.</li>
<li>Further enhancements to the interpreter</li>
<li>Other small enhancements.</li>
</ul>
<h3>Stage 3 -- Python 3.12 (requires runtime code generation)</h3>
<p>Simple "JIT" compiler for small regions. Compile small regions of specialized code, using a relatively simple, fast compiler.</p>
<h3>Stage 4 -- Python 3.13 (requires runtime code generation)</h3>
<p>Extend regions for compilation. Enhance compiler to generate superior machine code.</p>
</blockquote> ]]></description>
        <link>https://forum.rebol.info/t/python-speedup-proposals/1992/1</link>
        <pubDate>Sun, 27 Nov 2022 10:05:19 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6501</guid>
      </item>
      <item>
        <title>VID/S or Spaces, from Red&#39;s hiiamboris</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>There's now a 250-line VID/S markdown viewer example called "Redmark":</p>
<p><a href="https://codeberg.org/hiiamboris/red-spaces/src/branch/master/programs/redmark.red" class="inline-onebox">red-spaces/redmark.red at master - red-spaces - Codeberg.org</a></p>
<p>It depends on an external function called DECODE-MARKDOWN, which means its starting from a Red-friendly format of some kind.</p>
<p>If DECODE-MARKDOWN produces something parallel to an HTML DOM then this would basically be comparable to the CSS you'd need to render that on a page with proper resize behavior, I guess...</p>
<p><a href="https://codeberg.org/hiiamboris/red-spaces/src/branch/master/programs/#red-mark-redmark-red">Some notes about it here.</a></p>
<p>                    <a href="https://i.gyazo.com/548ce314237cf14e8daea7fd77503e13.gif" target="_blank" rel="noopener" class="onebox">
            <img src="https://i.gyazo.com/548ce314237cf14e8daea7fd77503e13.gif" width="690" height="497">
          </a>

</p> ]]></description>
        <link>https://forum.rebol.info/t/vid-s-or-spaces-from-reds-hiiamboris/1886/4</link>
        <pubDate>Sun, 27 Nov 2022 08:46:15 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6500</guid>
      </item>
      <item>
        <title>Should ELSE be FALSE-reactive? (in addition to void and null?)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Historically one might have asked why ELSE doesn't think falseness is something worth reacting to:</p>
<pre><code>&gt;&gt; 1 = 2 else [print "Why not print?"]
Why not print?  ; seems not so bad, right?
</code></pre>
<p>The idea was panned, because <code>#[false]</code> was <em>a value</em> and ELSE's main job was to react to the situation of a branching construct that didn't produce a value:</p>
<pre><code>&gt;&gt; math-broken: if 1 = 1 [false] else [true]
== #[false]  ; if this were #[true], math seems broken
</code></pre>
<p>But now, the actual falsey <code>~false~</code> state is isotopic.  And some years of struggle with the parallel problem of what to do with branches that returned "non-values" bore curious fruit: a box that could hold a "non-value" like a null.</p>
<pre><code>&gt;&gt; if false [null]
== ~null~  ; isotope
     ^-- there is no result

&gt;&gt; if true [null]
== ~[~null~]~  ; isotope
     ^-- there is a result and it is null
</code></pre>
<p>Isotopic blocks containing one element will decay to that one element in most situations.  But ELSE is sensitive to the difference via a ^META parameter.  If someone has gone through the effort to box up a null or void vs leave it as a plain isotope, the ELSE assumes it's a meaningful result and should pass it on.  And conditional expressions know to do this; they box up nulls and voids if they are produced by executing branches.</p>
<p><strong>The same technique could work for false.</strong></p>
<pre><code>&gt;&gt; if 1 = 1 [false]
== ~[~false~]~  ; isotope

&gt;&gt; if 1 = 1 [false] else [true]
== ~[~false~]~  ; isotope

&gt;&gt; math-broken: if 1 = 1 [false] else [true]
== ~false~  ; isotope
</code></pre>
<p>It's barely any additional work for conditionals to do on top of what they're doing already.  Although it can result in branches producing false to cost a small bit more than they do today <em>(I wouldn't worry about it, these single element boxes could be optimized if it was a problem)</em></p>
<p>But I don't know how useful it would actually be.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=9" title=":man_shrugging:" class="emoji" alt=":man_shrugging:">  Just writing down the observation.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-else-be-false-reactive-in-addition-to-void-and-null/1991/1</link>
        <pubDate>Sun, 27 Nov 2022 06:00:32 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6499</guid>
      </item>
      <item>
        <title>The History of Multi-Return in Ren-C</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="9" data-topic="1134">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But lingering issues regarding wrapping and composing multi-returns remained...</p>
</blockquote>
</aside>
<p>The proxying technique had shown clear advantages for the authors of functions, to be able to do direct assignments vs. need to remember to always <strong><code>SET</code></strong> the named variable passed in.</p>
<p>But underneath the hood, the names of the variables were still like inputs to the lower-level function.  This went as far as trying to act compatibly with the variable-passed-by-refinement trick that historical Redbol used for multiple returns.</p>
<p>Among the many problems were trying to write something like ENCLOSE.  An enclosing function could only influence the primary output, unless it went through some particularly convoluted work:</p>
<ul>
<li>
<p>It would have to capture the variable name passed in before delegating, because the name would be repurposed as the proxied value slot</p>
</li>
<li>
<p>The delegated function would be called and would update the variable as part of its RETURN</p>
</li>
<li>
<p>The encloser would then have to read back this written variable with GET to see it, and use SET to update it...again.</p>
</li>
</ul>
<p>Here's an example of what you could think you might have to do:</p>
<pre><code>multi-returner: func [
    return: [integer!]
    extra: [integer!]
][
    extra: 20  ; by this point, variable passed as /EXTRA hidden
    return 10  ; stowed /EXTRA variable written back using EXTRA's 20 value
]

wrapper: enclose :multi-returner func [f [frame!]] [
    let extra-var: f.extra  ; capture var before call via DO moves it aside
    result: do f  ; callee proxies input variable during RETURN
    set extra-var (get extra-var) + 1  ; get new written value and update it 
    return result + 1
]

&gt;&gt; [a b]: wrapper
== 11

&gt;&gt; a
== 11

&gt;&gt; b
== 21
</code></pre>
<p><em>The situation was actually even worse than that.</em>  All the complex logic for filling proxy slots with variable WORD!s was done during the frame building.  e.g. <strong><code>extra-var</code></strong> wasn't the hypothetical "parameter passed to extra before it got shifted into a hidden variable slot by FUNC", it was already the unset slot to be filled by the callee.  And the actual variable name was private, known only to the enclosed function.</p>
<p><em>And it's worse than that</em> if you want to preserve the ability to have behavior depending on how many inputs are requested, because there may be no variable at all... or an "opt in for the feature without a variable" placeholder.  Correct code would be much more convoluted, if meaningful code could be written at all.</p>
<p>The headaches go deeper.  Copying a frame and running it multiple times introduced semantic and ordering problems about the writing of these additional outputs!</p>
<h2>Simply Put: Variable Names As Inputs Make Poor Outputs</h2>
<p>All of this pointed to the inconvenient truth:</p>
<p><strong>Implementing a function's conceptual outputs by passing named variables as input that are imperatively written during the function's body--anywhere, even at the end--is something that will break composition.</strong></p>
<p><strong>It's also horrible for atomicity, because a SET of an output variable may happen but then there's an error which occurs before the final return result can be produced... so any multi-return function working in this way is either broken or bearing an undue burden to do its own "transaction management", which is to say probably also broken.</strong></p>
<p>Of course we knew this.  But to get the desired effects (single return unless you use a SET-BLOCK!), there's no other choice, right?</p>
<p>The idea of making an ANY-VALUE! which tried to bundle values was nixed in the beginning.  Because if we declared some new datatype to represent a multi-return pack that decays to its first value when assigned to a variable, you enter a catch-22, like this early puzzle when <strong><code>@[...]</code></strong> was being considered to denote multi-returns:</p>
<pre><code>multi-return: func [] [
    return @[10 20]  ; assume RETURN is "magic" and returns @[10 20] vs. 10
]

&gt;&gt; x: multi-return
== 10

&gt;&gt; [x y]: multi-return
== 10

&gt;&gt; x
== 10

&gt;&gt; y
== 20
</code></pre>
<p>The problems are apparent on even a trivial analysis.  These "highly reactive" <strong><code>@[...]</code></strong> values wreak havoc in a general system.  If you walked across a block and encountered one, trying to work with it to store them in a variable would introduce distortions on assignment when they "decayed" to their first element.</p>
<pre><code>for-each x [foo @[10 20] bar] [
    if integer? x [...]  ; INTEGER? sees @[10 20] as just 10
] 
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/man_facepalming.png?v=9" title=":man_facepalming:" class="emoji" alt=":man_facepalming:"> ...but gee... if only there were some variation of BLOCK! which you could be guaranteed not to encounter when enumerating other blocks, and that couldn't be stored in variables... and a method for dealing with transforming them into and out of reified states so you could work with them...</p>
<p><em>Hey, waitaminute...</em> <img src="https://forum.rebol.info/images/emoji/twitter/atom_symbol.png?v=9" title=":atom_symbol:" class="emoji" alt=":atom_symbol:"></p>
<h2>September 2022: Core Multi-Return via Isotopic BLOCK!</h2>
<p><a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">Generalized Isotopes</a> made longstanding problems seem to fall like dominos; like block splicing and error handling.  And they could be applied here, too... solving several profound problems:</p>
<ul>
<li>
<p>As with all isotopes, you wouldn't be able to put BLOCK! isotopes in blocks...alleviating many conceptual problems.</p>
</li>
<li>
<p>Yet even more severely, you wouldn't be able to put BLOCK! isotopes in <em>variables</em>.  Isotopic BLOCK!s would decay to their first value when assigned to <em>any</em> variable</p>
<ul>
<li>
<p>This turned out to be the <em>only</em> isotopic "decay" mechanism required, subsuming prior concepts like decaying "heavy null" to "light null".  Heavy null would simply be a null representation in an isotopic block.</p>
</li>
<li>
<p>Representing things like null would be possible since ^META values would be used in the multi-return convention, to afford the multi-return of isotopes themselves</p>
</li>
</ul>
</li>
<li>
<p>Fitting in with the general rules of isotopes, a QUASI-BLOCK! would evaluate to an isotopic block:</p>
<pre><code>&gt;&gt; ~['10 '20]~
== ~['10 '20]~  ; isotope

&gt;&gt; x: ~['10 '20]~
== 10
</code></pre>
</li>
<li>
<p>Functions that might be interested in the isotopic state would need to take a parameter via a ^META parameter, in which case they would receive a QUASI-BLOCK! vs the decayed parameter</p>
<ul>
<li>
<p>A good example of a function that would want this would be RETURN, in order to be able to have a forwarding mode that would return an isotopic result vs. its decayed first value</p>
</li>
<li>
<p><strong>This doesn't rule out the proxying-named-output-variable concept</strong>; in fact it fixes its problems, by limiting the relevance of the fact that proxying is being used to the interior of the function, and making its external speak the isotopic block protocol.  If you want a proxying-FUNC you can have it.</p>
</li>
<li>
<p>It also opens the doors to many other conceptions of how to abstract the multi-return process</p>
</li>
</ul>
</li>
<li>
<p>SET-BLOCK! assignments would have special understandings of how to decompose isotopic blocks and assign the component variables</p>
<ul>
<li>
<p>This would break the uneasy "backchannel" between caller and callee of variable names</p>
</li>
<li>
<p>The most obvious sign this had been a problem was that mere parenthesization would break historical multi-assignment:</p>
<pre><code>&gt;&gt; [a b]: multi-return   ; would work

&gt;&gt; [a b]: (multi-return)  ; would act like `(a: multi-return)`
</code></pre>
</li>
<li>
<p>Now any expression that doesn't store a variable as intermediate can act pass-thru (such as a conditional), and if a variable wanted to capture the multi-return character temporarily it could META it...potentially manipulate the QUASI-BLOCK!, and UNMETA it back</p>
</li>
</ul>
</li>
</ul>
<h2>Casualties of Composability</h2>
<p>One casualty of this was be the feature of being able to make a function's behavior depend on how many outputs were requested.  But the feature can still be achieved with enfix quoting left-hand-side and managing the assignment, it's just no longer be something the core attempts to generalize.</p>
<p>Another casualty is legacy compatibility with passing in variable names via refinement.  But again: this feature could be achieved by AUGMENT-ing the function with the refinement, then ENCLOSE-ing that with something that wrote the multi-return's output to the variable passed in via that augmented refinement.</p>
<p>But there's really no competition here.  As I've hopefully made clear, passing in a named variable via refinement is simply not in the same league as a mechanism which legitimately makes additional outputs.</p>
<p><strong>As usual with these things, I'll admit it may not be simple or obvious at first glance, but the results are speaking for themselves!</strong></p> ]]></description>
        <link>https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134/12</link>
        <pubDate>Sun, 27 Nov 2022 04:54:58 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6498</guid>
      </item>
      <item>
        <title>BLANK! 2022: Revisiting The Datatype</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Question 3: Should BLANK! Evaluate to NULL ?</p>
</blockquote>
</aside>
<p>Note: Some of the original motivators for the idea have been resolved, making it harder to argue for.  I reworked this thread to try and keep it relevant, but when it started the meta state of null was a single apostrophe:</p>
<pre><code>&gt;&gt; make object! [x: null]
== make object! [x: ']
</code></pre>
<p>That looks pretty slight for something I felt was as "important" as null.  New thinking is <a href="https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989"><strong><code>~null~</code></strong> is conveyed by an isotopic word</a>.  This gives us a convenient and relatively readable meta-representation for null isotopes... as the quasiform of null.</p>
<pre><code>&gt;&gt; make object! [x: null]
== make object! [
    x: ~null~
]
</code></pre>
<p>I tried this after feeling success from using isotopic WORD! forms for signaling <strong><code>~true~</code></strong> and <strong><code>~false~</code></strong>.  Being isotopic, none of these signaling words can be put in blocks directly... but must be transformed first.  (That's a new thing for a "logic!" representation, but not a new thing for nulls.)</p>
<p>Having them be word!s in their cell guts may seem odd vs. having a "distinct type" with a lexical form.  But I think this squares the circle with how words were often used in lieu of a lexical type in historical Redbol.  It's generalized and something that we could even imagine seeing internationalized.  <em>it all comes back to words</em>.</p>
<p>That enigmatic and slight single apostrophe is now taken as the meta form of void:</p>
<pre><code>&gt;&gt; '
; void

&gt;&gt; 1 + 2 '
== 3
</code></pre>
<p>While <strong>~null~</strong> is definitely more verbose than using <strong>_</strong> to null out variables, I'm not entirely sure that nulling out variables needs to be in the scheme of things any more succinct than setting a variable to false.  The uninitialized state of <strong><code>~</code></strong> is still succint:</p>
<pre><code>obj: make object! [
    foo: ~
    baz: null
    bar: ~
]
</code></pre>
<p><strong>Every experiment leads to a new thought...and trying blank led to seeing nulls as an isotopic state of blank, which led to the thought of being the isotopic state of the actual WORD! of "null"</strong>.  So in that sense it was a success.</p>
<p>Having a distinct BLANK! type which isn't a WORD! still seems like it offers us value... in being usable as a placeholder for where a variable would be, and a dialect part that can't be reassigned (so it can act as meaning "space" for instance, or an empty slot in block data).  So I think it's going to go back to serving that role.</p> ]]></description>
        <link>https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942/7</link>
        <pubDate>Wed, 16 Nov 2022 21:27:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6496</guid>
      </item>
      <item>
        <title>~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1989">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>My general intuition is that from a user's standpoint, it's an uphill battle to teach them isotopic blank is something called "null"... and that the majority of technical problems that are involved in making NULL be a word isotope are problems that have to be tackled anyway with true and false as word isotopes.</p>
<p>I'm going to likely give it a shot, when I get some programming time again, hopefully soon.</p>
</blockquote>
</aside>
<p>Just got snowed on.  <img src="https://forum.rebol.info/images/emoji/twitter/snowflake.png?v=9" title=":snowflake:" class="emoji" alt=":snowflake:"> So there's an incentive to stay inside and program...</p>
<p>Hence I've gone ahead and done this <strong>~null~</strong> change, and am looking over the implications.</p>
<hr>
<p>My first impressions are that it feels right, though I definitely will admit that there's a lot of <em>subtlety</em> to it.  To try and put the whole thing into perspective.</p>
<ul>
<li>
<p>The first attempt by Ren-C to make a state that could not be put in a block called it "void", and it was the <em>only</em> non-valued state.</p>
<ul>
<li>It was used as the contents of an uninitialized variable</li>
<li>It was the result of a function like HELP that didn't want to show a result</li>
<li>It was the result of a PICK out of a block which was out of range</li>
<li>It was the result of a SELECT out of a map when the key wasn't present</li>
</ul>
<p>This "non-valued" state took on a number of Redbol NONE!'s responsibilities, but was "ornery" in the way Redbol UNSET! was--hence it could not be tested for truth or falsehood.</p>
</li>
<li>
<p>Realizing that the orneryness of not being testable by logic was inconvenient, the concept was changed to be called "null" and be falsey</p>
<ul>
<li>The API exposed NULL results as C/Javascript <code>null</code> pointer
<ul>
<li>this was conveniently also falsey in those languages</li>
</ul>
</li>
<li>The term "void" was reclaimed to describe invisibles, like COMMENT</li>
<li>Unset variables held another ornery state called "nihil"
<ul>
<li>calling the state "unset" seemed semantically wrong</li>
<li>
<em>variables</em> are unset, not the <em>contents</em> of a variable</li>
</ul>
</li>
</ul>
<p>This was a great development for the API, and working with blocks was still rigorous.  But for some other questions, being able to tell the difference between "no answer" and "there's an answer, but it's null" still presented a puzzle.</p>
</li>
<li>
<p>Isotopes were introduced as a nuance on a value that would only be detectable by those who cared.</p>
<ul>
<li>"heavy null" and "light null" were the first isotopic concept
<ul>
<li>heavy null meant "there <em>is</em> an answer, but it's null"</li>
<li>ELSE would only react to light null (no answer, not even null)</li>
<li>heavy null would decay to light null on variable assignment</li>
</ul>
</li>
</ul>
<p>The isotope mechanic became generalized (as explained here):</p>
<p><a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918" class="inline-onebox">A Justification of Generalized Isotopes</a></p>
</li>
<li>
<p>With notable features pertaining to splicing intent (group isotopes) and errors (error isotopes), a new way of saying "there is no answer" vs. "there is an answer, but it's null" came out of using block isotopes as multi-return signals.</p>
<ul>
<li>null itself no longer needed an isotopic form</li>
<li>a block isotope with a null represented in it could be "heavy null"
<ul>
<li>this required null to have a meta-representation to be in a block</li>
<li>but META of NULL had been defined as NULL</li>
<li>null was thus rethought as being an isotope itself</li>
</ul>
</li>
<li>making NULL an isotope of the WORD! null seemed the cleanest answer</li>
</ul>
</li>
</ul>
<p><strong>An important point to make is that there's now only one form of isotopic decay:</strong> multiple return results, e.g. BLOCK! isotopes, will decay to their first result.  So you'll never find a block isotope in a variable.</p>
<p>It's pretty wild to look at how it all works.</p>
<pre><code>&gt;&gt; first [~null~]
== ~null~

&gt;&gt; ~null~
== ~null~  ; isotope

&gt;&gt; null
== ~null~  ; isotope (null WORD! is defined to be ~null~ isotope)

&gt;&gt; reify null
== null

&gt;&gt; meta null
== ~null~

&gt;&gt; third [a b]
== ~null~  ; isotope

&gt;&gt; third [a b] else ['c]
== c

&gt;&gt; if true [null]
; first in pack of length 1
== ~null~  ; isotope

&gt;&gt; meta if true [null]
== ~[~null~]~

&gt;&gt; if true [null] else [123]
; first in pack of length 1
== ~null~  ; isotope    
</code></pre>
<p>I know it's a lot to take in, but I feel like everything is there for a reason...</p> ]]></description>
        <link>https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989/3</link>
        <pubDate>Sat, 12 Nov 2022 22:08:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6495</guid>
      </item>
      <item>
        <title>~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1989">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So... Why Shouldn't NULL Be Done With <code>~null~</code> isotope ?</p>
</blockquote>
</aside>
<p>I might as well throw in the adjunct question of: <strong>"Why shouldn't VOID be done with ~void~ isotope?"</strong></p>
<p>It's worth noting that regardless of whether NULL is represented as <code>~_~</code> isotopes or <code>~null~</code> isotopes, it used to merely be said as having "no representation".  That's true of isotopes also, but there's been a standard that the interface shows an isotope by printing the quasiform and then commenting it as <em>"oh, it's actually an isotope state"</em></p>
<p>At that time, the console had a special exception for displaying nulls.  And the "quoted" form of null was just a single apostrophe with nothing after it:</p>
<pre><code>&gt;&gt; null
; null

&gt;&gt; quote null
== '

&gt;&gt; '
; null
</code></pre>
<p>This was all conceived before the idea of having a meta state for void, because voids just vanished.  But as things shuffled around, I came to think that this "no representation" made more sense for voids...</p>
<pre><code>&gt;&gt; '
; void

&gt;&gt; quote void
== '

&gt;&gt; meta void
== '

&gt;&gt; 1 + 2 '
== 3
</code></pre>
<p>Having a META state that is quoted vs. quasi puts VOID in a bizarre middle ground of not being isotopic.  Yet void can't be put in a block.  Though I've argued that we might also see it as that you can put infinitely many voids in a block...</p>
<pre><code>&gt;&gt; append [a b c] '
== [a b c]

 &gt;&gt; append [a b c] comment "hi"
 == [a b c]

 &gt;&gt; first []
 == ~null~  ; isotope (new proposal as word isotope vs isotopic blank)

 &gt;&gt; append [a b c] first []
 ** Error: Can't append ~null~ isotope (see MAYBE)

 &gt;&gt; maybe first []
 ; void

 &gt;&gt; append [a b c] maybe first []
 == [a b c]
</code></pre>
<p>Generally speaking I'm pleased with that.  Though it means if you wind up setting a variable to void, it will look kind of slight:</p>
<pre><code> &gt;&gt; make object! [x: comment "hi"]  ; might require a SET/ANY or similar
 == make object! [
     x: '
 ]
</code></pre>
<p>Why not push it the other way, and say that void states are isotopic?</p>
<p><strong>One key value of saying that void states are "ordinary" is that it means they have an isotopic form, and that isotopic form is rendered as just <code>~</code>.</strong></p>
<p>This isotopic void state of <strong><code>~</code></strong> is being used as the "truly unset" state.  An even meaner idea of complete absence of value than void.  I'm of the belief that it's important to have this not be the same thing as void, because the tolerance of void by so many constructs (including things like ANY and ALL to skip them, or opting out of APPENDs, or making SELECTs just return a null).</p>
<p>The design of the system is such that the quote byte of 0 means isotopic status (e.g. "quote level negative 1" is represented by 0), and the void type is a 0 byte.  So you can memset() an area to 0 and get all unset states (typically an optimized operation).  And the operating system clears all memory to 0 before giving it to your application as well.  It's kind of pleasing that such a representation gives you a nice unset state.</p>
<p>It seems to me that the pieces of the puzzle fit together better this way.</p> ]]></description>
        <link>https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989/2</link>
        <pubDate>Tue, 25 Oct 2022 13:14:24 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6494</guid>
      </item>
      <item>
        <title>On how to build REN-C on Windows</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>Well I told you that my time to work on hobby projects like this is very limited, even when I think I can spend over an hour, it will be likely that some interruption will occur within the next 5 minutes, dragging me away.<br>
Even a git workflow apparently changes over time and given the intervals between when I need to use this, keeping up with that is not worth the trouble and certainly not something I will remember how to do.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="10" data-topic="1845">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I think systems development seems to annoy you more than intrigue you.</p>
</blockquote>
</aside>
<p>Well let's say that I do want to spend my time on the real matters, not on the gits, githubs, and other obstacle courses to get to it.</p>
<p>AH, time's up, gotta run! cu later!</p> ]]></description>
        <link>https://forum.rebol.info/t/on-how-to-build-ren-c-on-windows/1845/11</link>
        <pubDate>Tue, 25 Oct 2022 07:21:17 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6493</guid>
      </item>
      <item>
        <title>~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>The concept of having isotopic <strong>~true~</strong> and <strong>~false~</strong> as WORD! isotopes instead of having a distinct LOGIC! type is admittedly somewhat weird.  It means they can't be put in blocks and need some sort of transformation if they're going to be put into blocks.</p>
<ul>
<li>
<p>The generic and reversible way to make them real it is to META them and get <code>~true~</code> and <code>~false~</code> quasiforms, which you can UNMETA back to the isotopes</p>
</li>
<li>
<p>The readable way to make them real is to REIFY them and get <code>true</code> and <code>false</code> as plain WORD!, which only gets turned back into the isotope form if they are bound to variables that hold the isotopes, and you evaluate them.</p>
</li>
<li>
<p>Your circumstance may mean that neither of those choices are what you want when in a situation where the isotopes can't work...maybe it means you have to rethink what you're doing, or maybe you want some other transformation.  It's good to be alerted to the fact that it's dodgy to put what you think of as a "logic" in a reified context.</p>
</li>
</ul>
<p>One should note that Lisp has no false at all, only NIL for false (since everything else is truthy, you could use anything else for true, but they have T predefined).  But their NIL isn't isotopic--so it can appear in lists literally.</p>
<p>And as I've repeatedly pointed out, Redbol's historical choice to render LOGIC! conflated with the words <code>true</code> and <code>false</code> (instead of <code>#[true]</code> and <code>#[false]</code>) shows a desire to avoid the logic literals "escaping" into the reified consciousness of the user.  Making the logic forms actually impossible to put into blocks without a conscious transformation feels like it's good.</p>
<p>I know it's a strange choice, but it's seeming like it fits with the territory.  It's a sort of tradeoff you need when you choose to be firm that TRUE and FALSE are redefinable words and not lexical forms of logic constants.</p>
<h2>So... Why Shouldn't NULL Be Done With <code>~null~</code> isotope ?</h2>
<p>Right now what I call "null" is isotopic BLANK!.  It is not pretty looking:</p>
<pre><code>&gt;&gt; null
== ~_~  ; isotope

&gt;&gt; _
== ~_~  ; isotope
</code></pre>
<p>But what <em>is</em> pretty looking is that if you assign a bunch of variables to null, the fact that blanks evaluate to the null isotope gives a great visibility to where the actual values to pay attention to are:</p>
<pre><code>obj: make object! [
    alpha: _
    beta: _
    delta: true
    epsilon: ~
    gamma: "nutty"
    rho: _
    omega: 'now
 ]
</code></pre>
<p>If we used a word isotope, then at source level we're writing:</p>
<pre><code>obj: make object! [
    alpha: null
    beta: null
    delta: true
    epsilon: ~
    gamma: "nutty"
    rho: null
    omega: 'now
 ]
</code></pre>
<p>And if we view it after evaluation that fetches (<code>null</code> =&gt; <code>~null~  ; isotope</code>), it gets uglier:</p>
<pre><code>make object! [
    alpha: ~null~
    beta: ~null~
    delta: ~true~
    epsilon: ~
    gamma: "nutty"
    rho: ~null~
    omega: 'now
 ]
</code></pre>
<p>We can't show it as the WORD! null because there's no guarantee that word always will evaluate back to the null isotope.  But the concept is that since BLANK! can't be redefined, we can put it in an evaluative context as a substitute for <code>~_~</code> if we want.</p>
<p>If we were "more honest" and just META'd the isotopic blank, we'd get renders like:</p>
<pre><code>make object! [
    alpha: ~_~
    beta: ~_~
    delta: ~true~
    epsilon: ~
    gamma: "nutty"
    rho: ~_~
    omega: 'now
 ]
</code></pre>
<p>But I might actually like that less than seeing <strong><code>~null~</code></strong> there.</p>
<h2>Things To Weigh In This Consideration</h2>
<p>I'm really torn.  Certainly having people be able to see ~null~ written out as a word corresponds to what we want to refer to the state as.  We aren't going to replace people's vernacular to say "isotopic blank" instead of null.  And trying to teach people "isotopic blank is null" is an uphill battle.</p>
<p>Let's look back at that seemingly beautiful situation with all the blanks-to-nulls at source level:</p>
<pre><code>obj: make object! [
    alpha: _
    beta: _
    delta: true
    epsilon: ~
    gamma: "nutty"
    rho: _
    omega: 'now
 ]
</code></pre>
<p>But, hmmm.  The <strong><code>~</code></strong> is now an assignable state meaning variable is not set.  How often will you want to set something to NULL...which won't generate an error on access like being unset would, but is falsey and can't be passed to many routines without a MAYBE?</p>
<p><strong>Statistically, we might often have a situation where NULL is the minority initialization, more like this:</strong></p>
<pre><code>obj: make object! [
    alpha: ~
    beta: ~
    delta: true
    epsilon: null
    gamma: "nutty"
    rho: ~
    omega: 'now
 ]
</code></pre>
<p>My point is that intentionally initializing things to null may not be as common as setting to an error-provoking unset state.  And when null happens it may be just as noteworthy to call out as setting something to true or false.</p>
<h2>Are There Technical Barriers To This?</h2>
<p>It has some of the same problems as having to deal with the type checking of LOGIC! actually being an isotopic subclass of two words.  It means <code>&lt;opt&gt;</code> is an isotopic subclass of one word, so there's no specific null datatype.  :-/</p>
<p>I was already saying that TYPE OF NULL was probably an error, and TYPE OF MAYBE NULL would be void... anyway, this fits into some of the same type issues that logic has.</p>
<p>Previously NULL cells held nothing, so I'd put a payload of the file and line that were in effect in the evaluator.  This was supposed to give better errors about where a null originated from.  This could still be done if NULL was a special case of WORD! isotope that said it was null via a flag vs. storing the symbol, but could be complicated.  None of the better error mechanics were done yet.</p>
<p><strong>My general intuition is that from a user's standpoint, it's an uphill battle to teach them isotopic blank is something called "null"... and that the majority of technical problems that are involved in making NULL be a word isotope are problems that have to be tackled anyway with true and false as word isotopes.</strong></p>
<p>Additionally, I've written about my desire for BLANK!s to serve in dialects as spaces.  That gets very screwed by the (<strong><code>_</code></strong> =&gt; <strong><code>~_~</code>  ; isotope</strong>) evaluation.  Recovering blank for space intent would be good.</p>
<p>I'm going to likely give it a shot, when I get some programming time again, hopefully soon.</p> ]]></description>
        <link>https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989/1</link>
        <pubDate>Tue, 25 Oct 2022 04:07:17 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6492</guid>
      </item>
      <item>
        <title>On how to build REN-C on Windows</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="iArnold" data-post="5" data-topic="1845">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/iarnold/40/226_2.png" class="avatar"> iArnold:</div>
<blockquote>
<p>Long time ago I tried building on Ubuntu myself, to find that something happened with the blanks! in the script not being accepted anymore.</p>
</blockquote>
</aside>
<p>That is because there were some changes to the bootstrap to make the older executable act more like the newer executable.  You'd written some extension configuration based on old build system files that needed to be updated.</p>
<p><a href="https://github.com/metaeducation/ren-c/compare/master...r3n:ren-c:gtk3and4">I did those changes in July</a>. And as I mentioned at the time, what was left was a linker error in the automated build related to GTK.  I said that was something you would need to research.</p>
<p>So resolving the linker error would have been a good thing to tackle before merging more things that would restart the situation again of needing me to sync it up.</p>
<p>In fact, the particular blank behavior may even <a href="https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989">wind up being undone</a>, due to new considerations.  :-/</p>
<aside class="quote no-group" data-username="iArnold" data-post="7" data-topic="1845">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/iarnold/40/226_2.png" class="avatar"> iArnold:</div>
<blockquote>
<p>I had some "fun" with github/git tonight that has cost me my time and energy</p>
</blockquote>
</aside>
<p>I generally do not use merging, but I rebase instead.  This allows you to play back each commit one at a time, and resolve the differences at every step.</p>
<p>If you're merging with 1000 commits--and things are added and removed at each intermediate point which conflict with your changes--then that may sound laborious.  You might find yourself resolving against things that ultimately get deleted, so it could seem like you wasted time.  It could seem that merging the final states together is less work.</p>
<p>But in practice, all those 1000 commits wouldn't conflict.  Just some of them--and I think it's much more sane and educational to resolve the individual commits "as they happen" and make sure you can get a working build each time.</p>
<p>However this requires understanding how to rebase and to have a really comfortable feeling with how branching and staging and "HEAD" and all of those other things work.</p>
<aside class="quote no-group" data-username="iArnold" data-post="9" data-topic="1845">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/iarnold/40/226_2.png" class="avatar"> iArnold:</div>
<blockquote>
<p>Yes, the odd thing here is how are you supposed to work from the command line if passwords are no longer accepted and my 2FA is not invoked?</p>
</blockquote>
</aside>
<p>These mechanisms do keep changing and evolving.</p>
<p>You can generate a personal access token and use it like a password, but it's not something you get to type and remember... so you have to copy/paste it from some local file you keep... and it expires so you have to keep regenerating it.</p>
<p>It's valid to be frustrated at technology and how the world is.  But... y'know, sometimes you just have to commit yourself to raising your level of understanding.  Git is one of those things where the payoff to mastering it is high.  And it's also a real liability in the software industry to not be fluent.</p>
<p>I go between SmartGit and the command line, and I'm sure that some 1-on-1 screencast tutoring of seeing my workflow for things would be informative for you...but...I'm busy these days.  Maybe there's some kind of online git school that gives you puzzles to sort out, and then shows the kinds of ways to solve them?</p>
<p><a href="https://learngitbranching.js.org/">https://learngitbranching.js.org/</a></p>
<p><a href="https://ohmygit.org/">https://ohmygit.org/</a></p>
<p><a href="https://github.com/git-game/git-game">https://github.com/git-game/git-game</a></p>
<aside class="quote no-group" data-username="iArnold" data-post="5" data-topic="1845">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/iarnold/40/226_2.png" class="avatar"> iArnold:</div>
<blockquote>
<p>Sure I know you cannot be bothered by me not being able to build REN-C. But if I can't chances are others also cannot build it. Which is good when "we" do not want too much activity in "our" world. Such a situation I would classify as unfortunate.</p>
</blockquote>
</aside>
<p>I'm bothered by a lot of things, but people not being able to build it isn't really that high on the list.  People familiar with what it takes to build interpreters and compilers would not find it that odd.</p>
<p>I think systems development seems to annoy you more than intrigue you.  It requires a certain kind of patience and willingness to go deep in the mastery of things.  And I can speak to the fact that much of it has gotten more annoying... and the only thing that shines a light on it is stuff that you would probably not enjoy either (e.g. modern C++, Haskell, Rust...)</p> ]]></description>
        <link>https://forum.rebol.info/t/on-how-to-build-ren-c-on-windows/1845/10</link>
        <pubDate>Tue, 25 Oct 2022 02:53:10 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6491</guid>
      </item>
      <item>
        <title>On how to build REN-C on Windows</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>Thanks Ingo,</p>
<p>Yes, the odd thing here is how are you supposed to work from the command line if passwords are no longer accepted and my 2FA is not invoked?</p>
<p>Now I had to accept a complete stranger website that happened to be home of a git gui client with my credentials to github, which personally I consider a HUGE LARGER security risk over a well chosen password.</p> ]]></description>
        <link>https://forum.rebol.info/t/on-how-to-build-ren-c-on-windows/1845/9</link>
        <pubDate>Fri, 21 Oct 2022 17:17:11 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6490</guid>
      </item>
      <item>
        <title>On how to build REN-C on Windows</title>
        <dc:creator><![CDATA[@IngoHohmann Ingo Hohmann]]></dc:creator>
        <description><![CDATA[ <p>If I run into problems updating a repo,I normally just delete it, and then clone anew.</p>
<p>Of course hoping I have not made any changes in said repo, which normally holds true.</p> ]]></description>
        <link>https://forum.rebol.info/t/on-how-to-build-ren-c-on-windows/1845/8</link>
        <pubDate>Fri, 21 Oct 2022 11:41:53 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6489</guid>
      </item>
      <item>
        <title>On how to build REN-C on Windows</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="IngoHohmann" data-post="6" data-topic="1845">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/40/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>It's not like we would expect a run on ren-c, just because binaries are downloadable.</p>
</blockquote>
</aside>
<p>LoL!<br>
I had some "fun" with github/git tonight that has cost me my time and energy to update my repo's and resulting in a merge mess of differences between HEAD and index and no clue as to which is which and smartgit not telling and not letting me select which version to pick over the other, and finally resulting in a failed build because it was the gtk branch that was probably suffering from a wrongly chosen update. But then again I have no idea what I have done, cause I had a proper script, sequence of instructions, to do my update but git wanted my password and then said "no more passwords accepted for updates". So completely lost again. My solution probably will be to go uninstall git and reinstall, if I could I would probably uninstall github itself <img src="https://forum.rebol.info/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:"></p>
<p>Well, git-hell.</p> ]]></description>
        <link>https://forum.rebol.info/t/on-how-to-build-ren-c-on-windows/1845/7</link>
        <pubDate>Thu, 20 Oct 2022 21:51:41 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6488</guid>
      </item>
      <item>
        <title>On how to build REN-C on Windows</title>
        <dc:creator><![CDATA[@IngoHohmann Ingo Hohmann]]></dc:creator>
        <description><![CDATA[ <p>I'm regularly building on Ubuntu and it works like charm. You may need the correct r3 executable for the make process, though.</p>
<p>Being able to download the binaries which are built anyway would be good. It might lead to some additional testing, and yes, these are debug builds and not optimized for speed.</p>
<p>It's not like we would expect a run on ren-c, just because binaries are downloadable.</p> ]]></description>
        <link>https://forum.rebol.info/t/on-how-to-build-ren-c-on-windows/1845/6</link>
        <pubDate>Thu, 20 Oct 2022 13:09:14 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6487</guid>
      </item>
      <item>
        <title>On how to build REN-C on Windows</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1845">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>To be clear, I build it every day...and there are <a href="https://github.com/metaeducation/ren-c/actions/workflows/windows-msvc-build.yml">GitHub Actions that keep it going</a>, demonstrating 32-bit and 64-bit builds.</p>
</blockquote>
</aside>
<p>Right what happens with the build executables? Are the most recent ones downloadable so nobody actually has to build them, unless they make changes in the sources to experiment / develop new features.</p>
<p>Running in the web/browser is not my cup of tea and certainly given the quirks of FireFox lately with mouseovers over links not even showing the links, and when reporting FF devs go "it is open source, you can fix it yourself" this feeling does nothing good to that. I feel much more like I need a tool in my toolbox and I want the tool to be on my platform of choice, not on the browser on the platform of my choice, if I wanted a tool on the browser platform perhaps I would already have gone with one of the alternatives.</p>
<p>My view is, the tool is available just on the platform (Windows and a Posix) and supporting it on the browser is good for the cases the platform itself is a more exotic one or to be used to prevent users from installing a thing. I should say I see users and developers as two categories, the second is a species that will be in danger of extinction because everything will be shielded off. It is also why I feel the need for a tool on the platform itself.</p>
<p>Long time ago I tried building on Ubuntu myself, to find that something happened with the blanks! in the script not being accepted anymore. I should try to build again, hope I find the time to do so soon, unfortunately my time is always fragmented into tiny chunks, and hope this has been fixed in the meantime.</p>
<p>Sure I know you cannot be bothered by me not being able to build REN-C. But if I can't chances are others also cannot build it. Which is good when "we" do not want too much activity in "our" world. Such a situation I would classify as unfortunate.</p> ]]></description>
        <link>https://forum.rebol.info/t/on-how-to-build-ren-c-on-windows/1845/5</link>
        <pubDate>Wed, 19 Oct 2022 12:50:41 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6486</guid>
      </item>
      <item>
        <title>Default Values And MAKE FRAME!</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="1412">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>Anyway, long story short, I think the baseline mechanics of FRAME! has to be as-is.</strong> Whatever else is an exception and should be handled specially. If you want a ^META parameter, that should be something that happens after the function starts running. This improves matters greatly.</p>
</blockquote>
</aside>
<p>As is often the case... the old way had right parts, the new way had right parts, and the answer is going to need... nuance.  <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=9" title=":roll_eyes:" class="emoji" alt=":roll_eyes:"></p>
<p>The way it works today, frames are initialized to "nihil" (the isotope of void), because <strong><code>~</code></strong> is what denotes the unset state.  For I-believe-to-be-good-reasons, it's no longer a synonym for void itself (the meta/quoted form of void is a single <strong><code>'</code></strong> apostrophe):</p>
<pre><code>&gt;&gt; f: make frame! :append
== make frame! [
    series: ~
    value: ~
    part: ~
    dup: ~
    line: ~
]
</code></pre>
<p>While fetching such variables should be an error by default, I've also said that I like the idea of this being an easy, legal assignment... so you can say <strong><code>(var: ~)</code></strong> to unset it.</p>
<p>I've also become attached to saying that true and false are actually WORD! isotopes, and although you can't put isotopes in blocks...you can freely assign these to variables, and retrieve them from variables.</p>
<pre><code>&gt;&gt; flag: true
== ~true~  ; isotope

&gt;&gt; flag
== ~true~  ; isotope

&gt;&gt; reify flag
== true

&gt;&gt; meta flag
== ~true~
</code></pre>
<p><em>It would be annoying if you could not directly assign a ~true~ or ~false~ isotope to a variable in a frame, and had to use some kind of ^META parameter convention to process it.</em></p>
<p>Yet I'm suspicious of being able to put parameter packs (isotopic blocks) or isotopic errors into a variable... <em>ever</em>:</p>
<pre><code>&gt;&gt; ~['10 '20]~
== ~['10 '20]~  ; isotope

&gt;&gt; value: ~['10 '20]~
== 10

&gt;&gt; set/any 'value ~['10 '20]~
== ~['10 '20]~  ; isotope (sketchy!)

&gt;&gt; :value
== ~['10 '20]~  ; isotope (sketchy!)
</code></pre>
<p>It is likely the case that isotopes fit into categories of things that can be assigned to variables literally, and things that cannot.  Keeping with the terminology, these might be called <strong>stable isotopes</strong> and <strong>unstable isotopes</strong>.  And the only way you can capture an unstable isotope is to transform it into some stable form, e.g. with META or REIFY:</p>
<pre><code>&gt;&gt; value: meta ~['10 '20]~
== ~['10 '20]~
</code></pre>
<p>Yet recall that with <strong><code>~</code></strong> and <strong><code>~true~</code></strong> and <strong><code>~false~</code></strong> (and <strong><code>~_~</code></strong> for null), it would seem we have a proof case that stable isotopes <em>exist</em>.</p>
<p>But there are other stable isotopes.  e.g. now ACTION! isotopes are used to be the form of action that runs from a variable reference.  Hence by definition you need to be able to store these in variables, and they are stable also.</p>
<p>How about splices?  Is there any great reason to make them unstable?  The following seems useful...</p>
<pre><code>&gt;&gt; data: spread [d e]
== ~(d e)~  ; isotope

&gt;&gt; append [a b c] data
== [a b c d e]
</code></pre>
<p>And if you're going to specialize a function like APPEND, shouldn't you be able to just write:</p>
<pre><code>apde: specialize :append [value: spread [d e]]
</code></pre>
<p>And this is where I was talking about the hassle of forcing these isotopes to be communicated by the ^META protocol, because if it meant you would sometimes take splices, you would <em>always</em> need to quote values you were appending... that was a headache.  So we want as few of these ^META functions as we can possibly have.</p>
<p>Yet fetching without complaint makes it very easy to unintentionally get effects you weren't intending, like if you didn't realize DATA was a splice isotope and expect exactly two items here:</p>
<pre><code>&gt;&gt; reduce [1 data]
== [1 d e]
</code></pre>
<p>We might say that the table stakes for showing you are aware that something "weird" is going on is on the access side, to use a GET-WORD!</p>
<pre><code>&gt;&gt; reduce [1 :data]
== [1 d e]
</code></pre>
<p>Yet do note that if DATA were bound to a function, that function could return an isotope like SPREAD does, putting you back at the point of being unable to tell from the callsite how many elements will be resolved to.</p>
<p>Hm.  Well, needing to use a GET-WORD! doesn't feel all that oppressive, and it offers some light protection that historical precedent has also offered (if a function in R3-Alpha/Red returns an UNSET! that's not an erroring condition, but if you get an unset out of a variable it will error without a GET-WORD!)</p>
<h2>This Means ^META Arguments Must Be Special</h2>
<p>I suggested this:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="1412">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Anyway, long story short, I think the baseline mechanics of FRAME! has to be as-is. Whatever else is an exception and should be handled specially. If you want a ^META parameter, that should be something that happens after the function starts running. This improves matters greatly.</p>
</blockquote>
</aside>
<p>But now I'm saying that really there are just more isotopes in the stable family, communicated "as-is" to functions.</p>
<p>Yet when unstable isotopes are needed to be considered as parameters, the inability to encode them in variables "as is" would necessitate passing them via ^META conventions.</p>
<p>Consider RETURN.  There is a RETURN/FORWARD that if you are returning a pack (isotopic block) actually returns the entire isotopic block, not just the first value.  So this falls under the "can't do it without meta" category.</p>
<p>What about SET?  At first it would seem to not have the problem, because it's setting a variable and everything it can take is representable in a variable (by definition).</p>
<p>But... if we leave <strong><code>~</code></strong> isotopes as the "I didn't specialize that" state of frames, and if <strong>SET</strong> doesn't take its argument as a <strong>^META</strong> parameter, then there's no way to SET something to an unset state... without some mitigation.</p>
<p>Possible mitigations:</p>
<ol>
<li>
<p>just make UNSET a distinct native that's a completely distinct entry point, and argue you don't use SET to unset variables with a function</p>
</li>
<li>
<p>during typechecking, nihil arguments are left as nihil if they're not refinements, vs. being set to null</p>
<ul>
<li>
<p>this means if you're trying to set a variable's state from a refinement instead of a normal argument, you would not get full coverage of all possible variable states</p>
</li>
<li>
<p>this also means that if a normal argument is marked as being optional/nullable, then not acting on it when doing a MAKE FRAME! would not wind up with it being null as default</p>
</li>
</ul>
</li>
<li>
<p>make the parameter ^META...then let SPECIALIZE compensate for it normally.  But when you want to write an UNSET function that is implemented as a specialization over SET, you build the frame directly and pass the value via ^META conventions</p>
<p>3a. Have a more foundational SET* that takes a ^META argument and lets you unset things, but the plain SET takes a normal argument and does not</p>
</li>
</ol>
<p>I'm rather attached to <strong>(var: ~)</strong> to unset things, so I feel (1) would be inconsistent with that mechanic.</p>
<p>With (3a), having SET* feels like a bad precedent.  It may seem like it's making life a little easier for some people who are writing ADAPT...but I don't think the net benefit outweighs making it a ^META argument.</p>
<p>(2) sounds good in theory, if we're just making a frame and DO'ing it:</p>
<pre><code>&gt;&gt; f: make frame! :set
== make frame! [
    target: ~
    value: ~
    groups: ~
]

&gt;&gt; x: 10
&gt;&gt; f.target: 'x
&gt;&gt; do f
&gt;&gt; x
** Error: x is ~ isotope (unset)
</code></pre>
<p>But if you try to turn a frame into an ACTION! and leave fields as <strong>~</strong>, it treats them as unspecialized.  This is designed to make it easier to write custom specialization functions, built on top of frame mechanics.</p>
<p><strong>It's annoying that this is in the vein of exact problems ^META exists to solve...but you're having to shift to the meta convention to get coverage for <em>just one</em> isotopic state, which almost no one will be specializing functions to use!</strong>  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>Annoying though it may be, I think it's going to have to be how it's done.  If this is the biggest problem the whole thing has, then it's not really that bad!</p> ]]></description>
        <link>https://forum.rebol.info/t/default-values-and-make-frame/1412/7</link>
        <pubDate>Tue, 18 Oct 2022 19:01:07 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6485</guid>
      </item>
      <item>
        <title>October 2022 General Status &amp; Reflection</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1988">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>With so many aspects of isotopes working out, it's unfortunate that the terrible type system is getting in the way. A dissatisfying answer would be just to say that all isotopes report that they are ISOTOPE! and you have to perform operations on them to find out the actual type... but this is what you historically have to do with items in BLOCK! (you can't typecheck for "block that contains one integer!" vs. "block that contains two strings").</p>
</blockquote>
</aside>
<p>When we think about this, it is the programmer that decides that the things an end-user selects get put inside a block to process the given information, it is also to the programmer to check on the validity of the items inside a block! (type! and value).<br>
That is thus okay.<br>
The problem is that even if the rest of the software development world thinks that fewer than 64 datatypes is sufficient, we the Redbol world occupants really want to expand beyond that limit. What you describe is the (non)solution of having ISOTOPE! call out "hey I am different, but you need to find out for yourself how different exactly". Which is surely not what we really want.<br>
Hence we need a way to expand beyond our 64 datatypes limit.<br>
When there is no room anymore, which is the case, I propose to follow some kind of ASCII to UTF extension trick. This will limit the number of primary datatypes (with a 0 in first position) even more, but other type would then make use of a follow up byte to mark the definitive datatype.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1988">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Also, I'm packing up and moving in less than two weeks and there's a lot to do for that.</p>
</blockquote>
</aside>
<p>Take care, hope you have found a great place to stay!</p> ]]></description>
        <link>https://forum.rebol.info/t/october-2022-general-status-reflection/1988/2</link>
        <pubDate>Sun, 16 Oct 2022 10:08:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6484</guid>
      </item>
      <item>
        <title>October 2022 General Status &amp; Reflection</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><em>Having hit up against some pretty deep questions about redesigning datatypes, I've been taking a break.</em>  It's good to clear one's head sometimes.  Also, I'm packing up and moving in less than two weeks and there's a lot to do for that.</p>
<p>I've been poking around some other languages and tools... tinkering with things like the Rust compiler sources... looking at Stable Diffusion and what sorts of trends are on the rise in open-source AI.  Reading a lot of articles and watching YouTube Videos.</p>
<p>Hopefully some of the datatype-related ideas will settle in my head and I'll be able to start making progress on those.  But I thought I'd review some of what's gone on the last months.</p>
<ul>
<li>
<p>It's certainly worth pointing out that the <a href="https://forum.rebol.info/t/stackless-is-here-today-now/1844">system is using "stackless" processing</a>... which is a significant change, that from a practical standpoint has let us get rid of costly workarounds needed for browser interop in the web build.</p>
</li>
<li>
<p>Changes were made to <a href="https://forum.rebol.info/t/ren-c-is-now-on-the-clouds-with-wasi/1854">permit executing in WASI runtimes</a>, enabling a new cross-platform target as well as being used in "serverless" cloud computing scenarios.</p>
</li>
<li>
<p><a href="https://forum.rebol.info/t/visual-parse-on-the-web-has-arrived/1837">Integrating a rich editor and tabbed interface to the web REPL</a> is a big cool thing.</p>
</li>
</ul>
<p>I could go on about every little thing (like updating the crypto, or that web tests now <a href="https://forum.rebol.info/t/js-testing-with-cypress-io/1778">run on cypress.io</a>) but there are posts and git commits for that.</p>
<p>Nearly every other major change worth discussing involves big changes surrounding isotopes.</p>
<h2>Generalized Isotopes Have Changed (Almost) Everything</h2>
<p>From the beginning, Ren-C's goal has been to attack the fundamental weaknesses in how Rebol works as a language.</p>
<p>Integral to attacks on several major problems has been the idea of <em>"generalized isotopes"</em>.  If anyone hasn't had a chance to read the thread describing the rationale, I suggest doing so now (or re-reading it):</p>
<p><strong><a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">"A Justification of Generalized Isotopes"</a></strong></p>
<p>This development kind of touches everything in the system:</p>
<ul>
<li>
<p><strong><a href="https://forum.rebol.info/t/the-long-awaited-death-of-only/1607">It strikes at the heart of the /ONLY issue</a></strong>.  When you see it used with something like REPLACE, you can really have that "A Ha" moment... that splicing intent should never have been carried by a refinement</p>
<pre><code>&gt;&gt; replace/all [[a b] a b a b] [a b] [c d e]
== [[c d e] a b a b] 

&gt;&gt; replace/all [[a b] a b a b] spread [a b] [c d e]
== [[a b] [c d e] [c d e]]

&gt;&gt; replace/all [[a b] a b a b] [a b] spread [c d e]
== [c d e a b a b]

&gt;&gt; replace/all [[a b] a b a b] spread [a b] spread [c d e]
== [[a b] c d e c d e]
</code></pre>
</li>
<li>
<p><strong><a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852">"Definitional Errors" have arisen</a></strong> as a crucial combination of solutions: one of the earliest Ren-C mechanics (definitional returns) mixes with a new idea (error isotopes), to give an actual viable answer for error handling in the system:</p>
<pre><code>&gt;&gt; attempt [print "Attempting to read file" read %nonexistent-file.txt]
Attempting to read file
; null

&gt;&gt; attempt [print "Attempting but made typos" rread %nonexistent-file.txt]
Attempting but made typos
** Script Error: rread word is attached to a context, but unassigned
** Near: [rread ** %nonexistent-file.txt]
</code></pre>
</li>
<li>
<p>Moving away from a dedicated "LOGIC!" datatype to <strong><a href="https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944">~true~ and ~false~ isotopes</a></strong> solves a "top-of-the-page" representational issue... giving an in-between state that can be held in a variable, but must undergo some reification process before being carried in an array:</p>
<pre><code>&gt;&gt; 1 = 2
== ~false~  ; isotope

&gt;&gt; append [a b c] 1 = 2
** Error: Arrays cannot hold ~false~ isotopes, must REIFY or META

&gt;&gt; append [a b c] meta 1 = 2
== [a b c ~false~]

&gt;&gt; append [a b c] reify 1 = 2
== [a b c false]
</code></pre>
</li>
<li>
<p>Treatment of <strong><a href="https://forum.rebol.info/t/thought-reimplementing-multi-return-via-isotopic-block/1955">BLOCK! isotopes as "packs"</a></strong> gives answers to how to pipe and transform multi-return expressions... and has also been leveraged as a way to tell the difference between "true null" (e.g. should trigger an else) and "packaged null" (a null packed into a block that is "a positive result that just happens to be null").</p>
</li>
<li>
<p>It has reshaped "voidness"--as something <strong><a href="https://forum.rebol.info/t/non-interstitial-invisibles-more-trouble-than-theyre-worth/1582">which only vanishes in interstitial slots</a></strong>, and can be manipulated conveniently in its isotopic form.</p>
<ul>
<li>Being able to pass voids as arguments enables fully functional compositions, <a href="https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833">like the infamous FOR-BOTH case</a> of writing a loop wrapper that preserves the loop behavior invariants.</li>
</ul>
</li>
<li>
<p>Isotopes are also covering things like being able to tell the difference between <strong><a href="https://forum.rebol.info/t/find-treats-typeset-s-specially-why-not-functions/1881/2">passing an ACTION! you want to run and an ACTION! you want to look for literally</a></strong> (by its identity)</p>
</li>
</ul>
<p>In some sense, this "discovery" has pushed a big reset button on the project... because it affects so many things.  Nearly everything has to be revisited.  But the biggest issue is with the type system.</p>
<h2>Isotopes Further Stress Weaknesses Of DATATYPE! / TYPESET!</h2>
<p>Rebol and all of its clones deal with datatypes in the exact same simplistic way, limiting it to 64 datatypes... with a TYPESET! being a 64-bit number with one bit for each type.</p>
<p>Perhaps there are those out there who think this is fine.  They may see it as like the <a href="https://www.danielsen.com/jokes/objecttoaster.txt">engineer and the toaster story</a>... where making a toaster with very few settings is virtuous, and it's unnecessary complexity to have any more complicated type system.</p>
<p>I've laid out some of my beliefs...such as that "kinds" of values (in a coarse sense) are at the very least based on WORD!, so you can add new things like <strong><code>vector</code></strong> and <strong><code>matrix</code></strong> and <strong><code>image</code></strong>...none of which I believe should be mandatory to build into the core...so lighter builds can be made.</p>
<p>Beyond that I have suggested that getting a full "type" description could be a more descriptive structure, telling you not only that something is a matrix but also giving you its dimensions.</p>
<p>The more these kinds of thoughts seem true, it makes TYPESET! seem like a bogus kind of thing... and type checking functions might make more sense.  Why not something like:</p>
<pre><code>foo: func [bar [integer! series? even?]] [...]
</code></pre>
<p>Performance aside, trading off typesets has some dangerous implications...such as what if a function gets specialized with a value that passes, but either the function or something about the value changes so it wouldn't pass?  As it happens, today's specialized values are written in the place where type information for a parameter would usually be--so you can't typecheck after the fact.</p>
<p>With so many aspects of isotopes working out, it's unfortunate that the terrible type system is getting in the way.  A dissatisfying answer would be just to say that all isotopes report that they are ISOTOPE! and you have to perform operations on them to find out the actual type... but this is what you historically have to do with items in BLOCK! (you can't typecheck for "block that contains one integer!" vs. "block that contains two strings").</p>
<p>Anyway: this is a longstanding problem area, that isotopes are now making it more imperative to solve.</p>
<h2>Still...There Are A Lot Of New And Interesting Things</h2>
<p>The biggest takeaway here is that isotopes have added new dimensions that are letting Ren-C bring really advanced capabilities within reach of very novice users.</p>
<p>There are many examples, but some of the most amazing to me are things like hooking the default UPARSE combinators--which have multiple return values--by being able to turn those return values into blocks and transform them.</p>
<p>So I'm still "finding the cool" in new behaviors, so that's motivating.  But maybe with the basics sorted out, it's getting closer to time to start ripping out some unnecessary parts, so that a committed subset can be pushed out to people on the web.  Will see what I can get done in the next couple of months--travels notwithstanding.</p> ]]></description>
        <link>https://forum.rebol.info/t/october-2022-general-status-reflection/1988/1</link>
        <pubDate>Sun, 16 Oct 2022 04:56:59 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6483</guid>
      </item>
      <item>
        <title>A Justification of Generalized Isotopes</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <h2>If Isotopes Are So Great, Why Don't Other Languages Have Them?</h2>
<p>In a way, Rebol2 had some inkling of isotopic ideas with errors.  Because an ERROR! couldn't be fetched from a WORD! without triggering an exception...you'd have to DISARM it, and that would convert it into an OBJECT!.</p>
<p>Early on when I was looking at the language, I did wonder if functions should have an "armed" vs. "disarmed" state--like errors.  This arose while trying to generate C code which assigned function variables...kind of along these lines:</p>
<pre><code>r3-alpha&gt;&gt; do compose/only [append-alias: (:append)]
; How to stop APPEND from running, by changing *only* inside the (...) ?
; (and still make APPEND-ALIAS act as a synonym for APPEND)
</code></pre>
<p>I talked myself out of it at the time...because I worried about "hidden bits" like the armed state.  But after years of building on incremental ideas like generic quoting, there are answers to such historical problems.  You can put a quasiform in that slot and it can evaluate to the isotope (itself having no representation, and can't be put in blocks, stopping the spread of this "invisibility").</p>
<p>But why didn't a parallel concept evolve in Lisp or other languages?  Here are some thoughts on reasons...</p>
<hr>
<p><strong>Lisp's quoting is a rendering trick on its list structures, there's not an actual place to store a negative quoting level.</strong></p>
<p>Isotopes are tied closely to the concept of generic quoting, and I've kind of said that they're akin to <em>"having a quoting level of negative one"</em>.</p>
<p>One thing that would hold Lisp back from seeing this as a natural possibility is that there isn't actually a "quoted value type".  When you see quotedness, it's just a rendering trick.  Something along these lines:</p>
<pre><code>lisp&gt;&gt; (print "Hi")
"Hi"

lisp&gt;&gt; '(print "Hi")
== (print "Hi")

lisp&gt;&gt; (quote abc)
== abc

lisp&gt;&gt; '(quote abc)
== 'abc

lisp&gt;&gt; '(quote (quote abc))
== ''abc

lisp&gt;&gt; (type-of '(print "hello"))
== cons  ; someting like "group!"

lisp&gt;&gt; (type of '''abc)
== cons
</code></pre>
<p>On the plus side of not building quote levels into the cells themselves, they can use the existing flexibility of lists to get arbitrarily high levels of quoting.  <em>(Right now Ren-C mechanics only allow 127 quote levels.)</em></p>
<p>But you can see how this would create a pretty big barrier to coming up with an idea like "negative quoting"; it would seem to make no sense.</p>
<p>Also: Like in Ren-C, if you evaluate a quoted structure in Lisp you drop one level of quoting.  But <a href="https://stackoverflow.com/questions/18515295/why-isnt-there-an-unquote-lisp-primitive">they didn't think it worth it to put an UNQUOTE in the box</a> as a narrowed form of EVAL that only took quoted structures.  Without that, one wouldn't be likely to think of wilder things like UNMETA.</p>
<hr>
<p><strong>Lisp's focus on compilation means they wouldn't like the idea of things like runtime conversions of normal values into states that would make a variable act undefined.</strong></p>
<p>This kind of fits in with the fact that a lot of things Rebol does would be off the table for many Lisp implementers.</p>
<p>For instance: Lisp <a href="http://web.cs.wpi.edu/~jshutt/kernel.html">dropped the idea of being able to mark a function's arguments as being quoted at the callsite</a>, because of how much that interferes with compilation:</p>
<blockquote>
<p><em>"The idea of first-class <em>operative</em> combiners, i.e., first-class combiners whose operands are never evaluated, has been around a long time. Such creatures were supported by mainstream Lisps through the 1970s, under the traditional name <code>fexprs</code>, but they made a mess out of the language semantics because they were non-orthogonal to the ordinary variety of procedures constructed via lambda â€” and, more insidiously, because at that time the mainstream Lisps were dynamically scoped (a language feature that causes more problems for fexprs than it does for the less powerful macros)."</em></p>
</blockquote>
<hr>
<p><strong>Most Languages Use Containers</strong></p>
<p>I've done a writeup of Haskell's Either and Rust's Result, showing some of what's similar about them to isotopes:</p>
<p><a href="https://forum.rebol.info/t/haskell-and-rust-error-handling/1987" class="inline-onebox">Haskell and Rust Error Handling</a></p>
<p>There are actually a fair number of nuances, but isotopes <em>kind of</em> like a container that's available system-wide on every variable... but <em>not</em> array slots.</p>
<p>And because it's systemic and built in, you don't have to think about this containership in advance.  Look at what it takes to return an Either from some sample Haskell code:</p>
<pre><code>parseDigit :: Char -&gt; Either ParseDigitError Int
parseDigit c =
  case c of
    '0' -&gt; Right 0
    '1' -&gt; Right 1
    '2' -&gt; Right 2
    '3' -&gt; Right 3
    '4' -&gt; Right 4
    '5' -&gt; Right 5
    '6' -&gt; Right 6
    '7' -&gt; Right 7
    '8' -&gt; Right 8
    '9' -&gt; Right 9
    _ -&gt; Left (NotADigit c)
</code></pre>
<p>The isotope model is more like letting you say <strong>(<code>'0' -&gt; 0</code>)</strong> and <strong>(_ -&gt; raise NotADigit c)</strong>, so you only have to call out the "weird" cases.</p>
<p>Though there's no truly silver bullet: if you're exchanging reified data via arrays, you can't use isotopes there.  So the convention of "containership" has to be decided on in advance for <em>fully</em> generic code.  (If the code isn't fully generic and you aren't using QUASI!-forms for something else, then the QUASI! can serve as a means of tunnel isotopic intent.)</p>
<hr>
<p><strong>It turns out to be actually really hard to tie these concepts together coherently, and people who undertake such challenges usually wouldn't bother with a runtime model as informal as a Redbol's.</strong></p>
<p>Newcomers to non-rigorous languages like JavaScript will often ask questions along the lines of "hey, why does JavaScript need both null and undefined".  This triggers a lot of conversation about the various practical problems that would happen if you only had one or the other, and usually people throw up their hands and say "what's done is done" and get on with their lives.</p>
<p>A much rarer question would be: <em>"might null and undefined be related in some transformative way, where certain basic operations naturally coerce and promote/demote between them in a meaningful pattern"</em>.  Because that's a sophisticated academic way to think, and people who care about that use "better" languages.  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_monocle.png?v=9" title=":face_with_monocle:" class="emoji" alt=":face_with_monocle:"></p>
<p>While someone might suggest this means the isotope design is thus a case of polishing a turd, my recent forays into Rust are reminding me of the unusual and distinct strengths that Ren-C has.  I'm withholding my verdict on whether its future is more than a kind of educational video game, but I think it's at least that... so making the design "click" where it can feels worth it.</p> ]]></description>
        <link>https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918/5</link>
        <pubDate>Sun, 16 Oct 2022 03:52:01 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6482</guid>
      </item>
      <item>
        <title>Haskell and Rust Error Handling</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Ren-C is shoring up Rebol's historically problematic exception-based error handling by blending together two mechanics: definitional returns and isotopic errors.  This gives what I'm calling "definitional failures":</p>
<p><a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852" class="inline-onebox">FAIL vs. RETURN RAISE: The New Age of Definitional Failures!</a></p>
<p>Pivoting to this line of thinking has some non-accidental similarity to <a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Data-Either.html">Haskell's <code>Either</code></a> and <a href="https://doc.rust-lang.org/std/result/">Rust's <code>Result</code></a>, which I mentioned when first sketching out the motivation for change:</p>
<p><a href="https://forum.rebol.info/t/the-need-to-rethink-error/1371" class="inline-onebox">The Need To Rethink ERROR!</a></p>
<p>I thought it would be worth it to make a thread for pointing out similarities and differences, and if there are libraries they use that might have relevant inspiration.</p>
<h2>An Out-Of-Band State On The Value Is... Like An Isotope?</h2>
<p>Either is fully generic beyond just allowing errors (and <a href="https://docs.rs/either/latest/either/">Rust has its own generic Either</a> as well).  So you can really say whatever you are returning can come in two forms: the left form vs. the right form.</p>
<p>But even Rust's <code>Result</code> container will permit you to make an Error class the "valid" result, as well as the "invalid" result.</p>
<p>So here we see generic way of letting a value carry a bit--independent of what the payload is--saying whether that is a "normal" state or a "weird" state.  Then, the system has an assortment of operations that are designed for directing program flow in different ways reacting to it.</p>
<p>Ren-C embraces this deeply: effectively saying that every variable and expression product has the potential of being in this "weird" state... and <em>no array can contain a value in the weird state</em>.  But you don't have to do anything special to a value that <em>isn't</em> weird to extract it... you just get runtime errors if you use the weird values where they're not expected.</p>
<h2>Rust Tackles Low-Hanging Fruit via <code>unwrap()</code> and <code>?</code>
</h2>
<p>In Ren-C, if you don't have handling at the callsite when a definitional error happens, it's promoted to being more like a throw--and most code should not intercept it.</p>
<p>Being more formal by nature, both Haskell and Rust force <em>some</em> handling at the callsite when an error result is possible.  You have to define a code path to take if there's an error, or a code path to take if there's not.</p>
<p>But Rust has a couple of conveniences.  If you want something like the Ren-C behavior, you can just call the <code>.unwrap()</code> method on the result.  It will give you the ordinary value if the function didn't return, otherwise raise the error as a "panic".</p>
<p>There's also a cool shortcut with a postfix operator of <strong>?</strong> on the call.  This makes it so that if you call a function that returns a <code>Result</code> type from inside another function that returns a <code>Result</code> type, it will automatically propagate the result if it's an error out of the calling function.</p>
<p>Getting this behavior is more laborious in Ren-C:</p>
<pre><code>foo: func [...] [
    x: bar (...) except e -&gt; [return raise e]
    ...
]
</code></pre>
<p>Implementing the feature as postfix raises its own problems, so let's just imagine we were trying it prefix:</p>
<pre><code>foo: func [...] [
    x: ? bar (...)  ; we want this to act the same as above
    ...
]
</code></pre>
<p>For this to work under the current system, each FUNC would have to define its own <strong>?</strong> operator... because much like definitional RETURN, it would have to know what it was returning <em>from</em> in case of a raised error.</p>
<h2>Haskell Has Generic Compositional Smarts</h2>
<p>As mentioned, the strict compile-time typing in Haskell forces you to be explicit about your reaction when a function returns one of these <code>Either</code> values.</p>
<p>But because Either fits in with monadic/applicative/functor stuff, you can have higher-order operations that <a href="https://lhbg-book.link/06-errors_and_files/01-either.html">can compose together</a> failure scenarios...and gather up failures from several functions or cascade the failure through to where you want.</p>
<p>Ren-C can do this kind of thing as well, such as how you can write higher-order functions like ATTEMPT in usermode, or REDUCE a block of values in one pass with META and get the errors, then react to them later.</p>
<p>But in practice, the lack of a static type system makes this more precarious.</p>
<h2>Links To Error Handling Libraries</h2>
<ul>
<li>Rust's ANYHOW!: <a href="https://docs.rs/anyhow/">https://docs.rs/anyhow/</a>
</li>
</ul> ]]></description>
        <link>https://forum.rebol.info/t/haskell-and-rust-error-handling/1987/1</link>
        <pubDate>Sun, 16 Oct 2022 02:17:44 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6481</guid>
      </item>
      <item>
        <title>Why (or why not) have UNSET! in Rebol-like Languages</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>A post was merged into an existing topic: <a href="/t/a-justification-of-generalized-isotopes/1918/4">A Justification of Generalized Isotopes</a></p> ]]></description>
        <link>https://forum.rebol.info/t/why-or-why-not-have-unset-in-rebol-like-languages/113/6</link>
        <pubDate>Sat, 15 Oct 2022 20:51:09 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6480</guid>
      </item>
      <item>
        <title>A Justification of Generalized Isotopes</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Looking back at a <a href="https://forum.rebol.info/t/why-or-why-not-have-unset-in-rebol-like-languages/113/2">quote from Nenad I have historically taken issue with</a>, we may not actually disagree as much as it first seems.  He said:</p>
<blockquote>
<p><em><strong>"Redbol languages are based on denotational semantics, where the meaning of every expression needs to have a representation in the language itself.</strong> Every expression needs to return a value. Without unset! there would be a hole in the language, several fundamental semantic rules would be collapsing, e.g. <code>reduce [1 print ""]</code> =&gt; <code>[1]</code> (reducing 2 expressions would return 1 expression)."</em></p>
</blockquote>
<p>We actually agree on the part in bold.  The twist is that he goes on from what I think is the true part (<em>"needs to have <strong>a</strong> representation"</em>), and conflates it with the idea that the direct use of an expression's result must behave as something you can put in a block.</p>
<p>I'm saying you should always be able to get to a value to put in a block... but you might need an additional step to get it.  That could be an operation like <code>META</code> or <code>^</code>, which gives a "friendly" (reified) value, but can then be reversed to provide an isotope back.</p>
<p>In Ren-C, PRINT returns not an "unset" state (that's a different isotope) but actually an empty parameter pack isotope (e.g. a multi-return with no returns in it)</p>
<pre><code>&gt;&gt; reduce [1 print ""] 
** Error: cannot splice empty pack ~[]~ isotope in REDUCE (0 results in pack)

&gt;&gt; reduce [1 meta print ""] 
== [1 ~[]~]

&gt;&gt; reduce [1 ^ print ""] 
== [1 ~[]~]
</code></pre>
<p>These are the problems that isotopes are designed to solve!  Without formalizing an isotope mechanism in the language, your choices are:</p>
<ul>
<li>
<p>Write your code manipulating Rebol structures in another language (like C or Red/System)...which is inherently "meta" and can handle the oddness of these states.</p>
<ul>
<li><em>(People should be suspicious when problems with the language are addressed by not using the language!)</em></li>
</ul>
</li>
<li>
<p>Make usermode code struggle with refinements like /ONLY that pushes the oddness off of the values and forces generalized code to shift into a different handling mode.</p>
</li>
</ul>
<p>It's a significant enough problem area to be worth attacking with a generalized solution, that keeps the oddness on the value states where it belongs.  People should have an "a ha" moment about that when seeing things like REPLACE:</p>
<pre><code>&gt;&gt; replace/all [[a b] a b a b] [a b] [c d e]
== [[c d e] a b a b] 

&gt;&gt; replace/all [[a b] a b a b] spread [a b] [c d e]
== [[a b] [c d e] [c d e]]

&gt;&gt; replace/all [[a b] a b a b] [a b] spread [c d e]
== [c d e a b a b]

&gt;&gt; replace/all [[a b] a b a b] spread [a b] spread [c d e]
== [[a b] c d e c d e]
</code></pre>
<p>As I say, when Red tries to solve these kinds of problems without isotopes--e.g. claiming UNSET! is "just another type"--it's like they're doing complex math without complex numbers.  You will hit limits when trying to do nontrivial things.</p> ]]></description>
        <link>https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918/4</link>
        <pubDate>Sat, 15 Oct 2022 20:13:06 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6479</guid>
      </item>
  </channel>
</rss>

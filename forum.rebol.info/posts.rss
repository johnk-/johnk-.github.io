<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest posts</title>
    <link>https://forum.rebol.info</link>
    <description>Latest posts</description>
      <item>
        <title>&quot;Quasiforms&quot;, &quot;Stable/Unstable Isotopes&quot;: Simpler Terminology?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>It's no secret that I'm proud of the way the <a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">design for generalized isotopes</a> is tearing through classic problems in Rebol.</p>
<p>At the same time, people's eyes can glaze over when you find yourself writing sentences like:</p>
<blockquote>
<p><em>"All quasiforms become isotopic forms when evaluated, and when going the other way through a meta operation on an isotope, you'll get a quasiform back."</em></p>
</blockquote>
<p>It all makes sense to me.  But I don't want to overlook better terms, if they exist.</p>
<h2>How Did "Isotopes" Come To Be Called That</h2>
<p>The term isotope originated from the "decaying" behavior, where a special form of null would run a THEN branch.  But this special form would not be something you could store in a variable...it would become an ordinary null at that point.  So getting stored in a variable would cause "decay".</p>
<pre><code>&gt;&gt; null
; null

&gt;&gt; if true [null]
; null isotope

&gt;&gt; x: if true [null]
; null isotope

&gt;&gt; x
; null
</code></pre>
<p>The decay means variables captured from expressions would have a different behavior when substituted for the expressions.  That was deemed to be an acceptable cost.</p>
<pre><code>&gt;&gt; if true [print "then", null] else [print "else"]
then

&gt;&gt; temp: if true [print "then", null]
then

&gt;&gt; temp else [print "else"]
else
</code></pre>
<p>The parallel with decay of atomic isotopes seemed pretty clear, at least to me.  Many places would see it as a normal null, but a few special sites could use a "sensor" to detect the difference.  ELSE was an example of something that could detect.</p>
<p>As things moved forward, and when logic variables became ~true~ and ~false~ isotopes, it became clear these isotopic states would need to be able to stored in variables.  That meant there were "unstable isotopes" and "stable isotopes"... e.g. WORD! isotopes were stable, ERROR! isotopes were not.</p>
<p><em><strong>Having these stable isotopes actually strengthened the analogy.</strong></em></p>
<h2>How Did "QUASI" Become Called That?</h2>
<p>Originally, things like <code>~foo~</code> were called "bad words", designed to cause errors when accessed through a variable by default.  They were like an old-school UNSET! where you could give it a custom label.  But eventually everything was generalized so that everything had an isotopic form.</p>
<p>The fact that these forms stopped conveying an error condition meant considering them "bad" wasn't sensible.  I kind of latched onto "quasi" in part because of the tilde's use in approximation, e.g. (3.0001 ~= 3).</p>
<p>(It also sounds a little like "queasy" and the squigglies look wavy and maybe a bit uncomfortable.  <img src="https://forum.rebol.info/images/emoji/twitter/nauseated_face.png?v=9" title=":nauseated_face:" class="emoji" alt=":nauseated_face:">)</p>
<h2>So... Speak Now Or Hold Your Peace?</h2>
<p>Bad naming can have an impact.  I think calling complex numbers "imaginary" is a good example of a bad name that probably caused a few problems.</p>
<p>But I think the names here are good.  It's just going to be a matter of figuring out how to teach people to not be afraid of them.</p> ]]></description>
        <link>https://forum.rebol.info/t/quasiforms-stable-unstable-isotopes-simpler-terminology/2005/1</link>
        <pubDate>Sun, 08 Jan 2023 21:18:39 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6550</guid>
      </item>
      <item>
        <title>The Canonical List of Non-Negotiables</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <h2>ATOMICITY OF ELEMENTS IN BLOCK!s AND GROUP!s</h2>
<p>A new non-negotiable for Ren-C is that for <em>any</em> BLOCK! (or blocklike thing) the following property holds:</p>
<pre><code>block2: copy []

for-each item block1 [append block2 item]

assert [block1 = block2]
</code></pre>
<p>Prior to isotopes, <em>it wasn't conceivable that such rules could hold.</em>  But after years scaling a mountain of design... I concluded this could be achieved, if all the tricky behaviors came from values "at quoting level -1" that could not be put into blocks.</p> ]]></description>
        <link>https://forum.rebol.info/t/the-canonical-list-of-non-negotiables/1244/9</link>
        <pubDate>Sat, 07 Jan 2023 23:35:01 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6548</guid>
      </item>
      <item>
        <title>Rebolbot future</title>
        <dc:creator><![CDATA[@johnk Johnk ]]></dc:creator>
        <description><![CDATA[ <p>FYI<br>
For Altme the important bit was setting up a lightweight headless display.<br>
We were using X virtual frame buffer then running jwm as a super light window manager.</p>
<pre><code class="lang-auto">Xvfb :0 -ac -screen 0 1024x768x24 &amp;
sleep 2
nohup /usr/bin/jwm -display :0 &amp; 
export DISPLAY=:0
./altme &amp;
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/rebolbot-future/1999/5</link>
        <pubDate>Sat, 07 Jan 2023 23:31:58 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6547</guid>
      </item>
      <item>
        <title>Rebolbot future</title>
        <dc:creator><![CDATA[@johnk Johnk ]]></dc:creator>
        <description><![CDATA[ <p>I don't think there is much more to save from the server. I will take a backup of the code and make sure that what is in <a href="https://github.com/rebolbot/rebolbot">https://github.com/rebolbot/rebolbot</a> is correct. I will also upload the headless scripts to get altme working as well, if anyone is still using it?<br>
I have to say that Digital Ocean have been absolutely rock solid. I do not remember the box being rebooted once, other than following updates that I initiated. As an example, the current uptime is 87 days. These LTS Ubuntu variants do seem to do exactly what they say on the box - if we wanted to keep this running it would still be supported and patched until 2026 (<a href="https://wiki.ubuntu.com/Releases" class="inline-onebox">Releases - Ubuntu Wiki</a>).</p> ]]></description>
        <link>https://forum.rebol.info/t/rebolbot-future/1999/4</link>
        <pubDate>Sat, 07 Jan 2023 23:19:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6546</guid>
      </item>
      <item>
        <title>Websocket Support in Oldes Rebol3</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Looking to see what Oldes has been up to, he added some kind of minimal websocket support to the HTTP scheme:</p>
<p><a href="https://github.com/Oldes/Rebol3/commit/bae6cffe97e662ec9a727a01cdcc1fdd61455ea6#diff-490ba807ac4a5ee57e7a587ca0936d36e4c0ff2798b0652fdf791e758ce079c2R718" class="inline-onebox">FEAT: Minimalistic WebSocket support in the `httpd` scheme · Oldes/Rebol3@bae6cff · GitHub</a></p>
<p>Websockets isn't something I'm looking into at this time, but I wanted to bookmark it here in case it comes up later.</p>
<p>He also updated zlib to a new version released in 2022... and <a href="https://github.com/Oldes/Rebol3/commit/15fcc00b84f6d0e386f2ba2f4fc7bdc32ebff75d">used Ren-C's %make-zlib.r to do it!</a>.  But he edited it so he'd be able to run it under his Rebol3.  It's not a huge priority to do that update, but seems like since his ported script still worked, it might not be too hard.  (And a good reminder that script exists, and should be part of a CI test...)</p> ]]></description>
        <link>https://forum.rebol.info/t/websocket-support-in-oldes-rebol3/2003/1</link>
        <pubDate>Fri, 06 Jan 2023 03:56:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6544</guid>
      </item>
      <item>
        <title>Picking ACTION!s from BLOCK!s In The Age of Isotopes</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>In <strong><a href="https://forum.rebol.info/t/reds-design-issues-wiki/1282">Red's Design Questions wiki</a></strong>, they bring up the issue of why picking functions out of blocks runs them:</p>
<pre><code>red&gt;&gt; block: reduce [does [print "Evaluated."]]
  == [func [][print "Evaluated."]]

red&gt;&gt; equal? block/1 first block
Evaluated.  ; d'oh
== false
</code></pre>
<p><a href="https://gitter.im/red/red?at=5c782ca0c1cab53d6f53dd6d">In the Gitter conversation</a>, Boris calls it a "shady area" that they can't get out of "under the current semantic model".  He suggests it is clear that <strong><code>block/1</code></strong> should not run an action, but possible that <strong>block/word</strong> would mean to.</p>
<p>They contemplate the idea that <strong>block/1</strong> would not run the action, but pick it:</p>
<pre><code>red&gt;&gt; block: reduce [does [print "Evaluated."]]
  == [func [][print "Evaluated."]]

red&gt;&gt; equal? block/1 first block  ; hypothetical behavior
== false
</code></pre>
<p><strong>I will argue this doesn't really help you much, the problem just becomes one step removed.</strong>  Quite often people are picking things out of blocks to put them in variables, and you'll just get bit there instead:</p>
<pre><code>red&gt;&gt; otherblock: copy []
== []

red&gt;&gt; temp: block/1
== func [][print "Evaluated."]

red&gt;&gt; append otherblock temp
Evaluated.  ; d'oh
== [unset]  ; double d'oh
</code></pre>
<h2>Isotopes Bring The Better Semantic Model!</h2>
<p>In Ren-C's concept (as I'm working on it), the only actions that will run from a word reference are those that are isotopic actions.  And FUNC or DOES creates an isotopic action.</p>
<p>So you would be stopped from making an illegal block up front:</p>
<pre><code>&gt;&gt; block: reduce [does [print "Evaluated."]]
** Script Error: Invalid use of ~#[action! []]~ isotope
</code></pre>
<p>You can put quasi-ACTION!s, plain ACTION!s, and quoted actions in blocks.  Just not isotopic ones.</p>
<p>Whichever you choose, the equality test will work... and picking out a value into a variable will give you an inert variable to work with, that can be used with things like append!</p>
<pre><code>&gt;&gt; block: reduce [reify does [print "Evaluated."]] 
== [~#[action! []]~]

&gt;&gt; equal? block.1 first block
== ~true~  ; isotope  &lt;-- didn't run and print "Evaluated", yay!

&gt;&gt; otherblock: copy []
== []

red&gt;&gt; temp: block.1
== ~#[action! []]~

red&gt;&gt; append otherblock temp
== [~#[action! []]~]   ; &lt;-- didn't run and gave sensible block out
</code></pre>
<p>I used REIFY there and got a quasi-action.  BUT which would you rather put in the block: a quasi-action or a plain one?  This depends on what you plan to do with the block.  A plain action will execute when encountered by the evaluator, while a quasi-action will evaluate to an isotopic action--suitable for assigning via SET-WORD! when you meant to make that word dispatch the function when referenced.</p>
<p>My leaning is to say that either form can be used with APPLY, RUN, or the terminal path form:</p>
<pre><code>&gt;&gt; block: reduce [reify does [print "Evaluated."]] 
== [~#[action! []]~]

&gt;&gt; run block.1
Evaluated.

&gt;&gt; block: reduce [concretize does [print "Evaluated."]] 
== [#[action! []]]

&gt;&gt; apply block.1 []
Evaluated.
</code></pre>
<p><em>(See post on <a href="https://forum.rebol.info/t/reify-vs-meta-vs-something/2001">difference between REIFY and CONCRETIZE</a>, and the search for a better term...)</em></p>
<p>If you want to pick an action out of a block and put it into a variable, where it will execute from that variable, there is the RUNS transformer.  It will turn a quasi or plain ACTION! into an action isotope:</p>
<pre><code> &gt;&gt; active-var: runs block.1
 == ~#[action! {active-var} []]~  ; isotope  &lt;-- note: also cached name, neat!

 &gt;&gt; active-var
 Evaluated.
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/clap.png?v=9" title=":clap:" class="emoji only-emoji" alt=":clap:"></p>
<p>You can use UNMETA more generically to get an isotope back from any quasi-form (not just actions), or ISOTOPIC to get an isotope from a plain form.</p>
<h2>The Invariant Is What Counts, Here!</h2>
<p>The mountain that has been climbed is that we can now say that for any block, this is true:</p>
<pre><code>block2: collect [
    for-each item block1 [keep item]
]

assert [equal? block1 block2]
</code></pre>
<ul>
<li>
<p>I've just covered that there are no isotopic actions to implicitly execute; you'd get an error trying to put them in the block.</p>
</li>
<li>
<p>There are no blocks/groups/paths that will splice into the target, because splicing requires an explicit conversion to an isotope.</p>
</li>
<li>
<p>There are no "unsets" to trip on that you can find in a block, because the state conveying "unsetness" (nihil) is an isotope.</p>
</li>
</ul>
<p>Of course with objects, it's going to be a different story.  I think we'll still want some safeguards:</p>
<pre><code>for-each [key value] object [...]  ; will error when value is action

for-each [key :value] object [...]  ; will allow action isotopes as-is

for-each [key ^value] object [...]  ; will give a meta value
</code></pre>
<p>A key problem here is I'm wondering how much to cross purposes of GET-WORD! between action disarming and the other isotopic states.  But, it just takes time to work through.</p> ]]></description>
        <link>https://forum.rebol.info/t/picking-action-s-from-block-s-in-the-age-of-isotopes/2002/1</link>
        <pubDate>Fri, 06 Jan 2023 03:16:23 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6543</guid>
      </item>
      <item>
        <title>REIFY vs. META vs. SOMETHING</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Originally I suggested that REIFY of an isotope would give its plain form, and you would META it if you wanted a quasiform:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1989">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989/1">~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</a>
</div>
<blockquote>
<ul>
<li>The generic and reversible way to make them real it is to META them and get <code>~true~</code> and <code>~false~</code> quasiforms, which you can UNMETA back to the isotopes</li>
<li>The readable way to make them real is to REIFY them and get <code>true</code> and <code>false</code> as plain WORD!, which only gets turned back into the isotope form if they are bound to variables that hold the isotopes, and you evaluate them.</li>
</ul>
</blockquote>
</aside>
<p><em>But that's not a full coverage answer.</em></p>
<ul>
<li>
<p>An operator that takes everything "one level up", where isotopes become quasiforms and everything else gets a quote level added.</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; meta true
== ~true~

&gt;&gt; meta 10
== '10
</code></pre>
</li>
<li>
<p>An operator that leaves non-isotopes as they are, but turns isotopes into their quasiforms (and I think this probably is best called REIFY):</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; reify true
== ~true~

&gt;&gt; reify 10
== 10
</code></pre>
</li>
<li>
<p>An operator that leaves non-isotopes as they are, but turns isotopes into their plain forms:</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; something true
== true

&gt;&gt; something 10
== 10
</code></pre>
</li>
</ul>
<p>Specifically for ACTION! isotopes being turned into plain actions, I used an interim term UNRUN, but that's pretty awful.</p>
<p>Making things into isotopes is done with ISOTOPIC:</p>
<pre><code>&gt;&gt; isotopic 10
== ~10~  ; isotope
</code></pre>
<p>It could be a refinement to REIFY, like REIFY/PLAIN.  But at that point it could be two steps that might be clearer: NOQUASI REIFY, where NOQUASI would be like NOQUOTE and not complain if the thing you passed it was not a quasiform.</p>
<p>Maybe... CONCRETIZE?  That sounds like it might do a bit more work than what REIFY does :-/</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; concretize true
== true

&gt;&gt; concretize 10
== 10
</code></pre>
<p>It's not awful.  Main thing is just to have <em>a</em> name for it while the gears turn.  But as usual, throw out suggestions if you have them...</p> ]]></description>
        <link>https://forum.rebol.info/t/reify-vs-meta-vs-something/2001/1</link>
        <pubDate>Thu, 05 Jan 2023 21:26:08 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6542</guid>
      </item>
      <item>
        <title>Concept: Filters</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="2000">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'm curious about this distinction... why wouldn't a filter that takes in UTF-8 and produces a block of transcoded data be covered here? What's the missing capability?</p>
</blockquote>
</aside>
<p>I think it's ultimately scope creep. In my proposal in the other thread, I'd conceived as such a mechanism as tokenizing as well, but in hashing out many of the data points I've been considering, it just became too convoluted. I feel in isolating binary/text it's really a clean separation that lends well to optimization and doesn't fall into the Codec black box that I think is ultimately problematic.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="2000">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>The umbrella term I tend to myself use above "Filter"/"Codecs"/"Ports" is "Streaming".</p>
</blockquote>
</aside>
<p><em>'Filter'</em> is the term used in PDF and I think lends itself to this specific isolation. <em>'Streaming'</em> would apply, but could also be saved for more appropriate use, such as the mechanism for moving data in from external sources. And one can apply <em>filters</em> to a <em>stream</em>...</p>
<aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="2000">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Maybe we could get examples worked up and see some contrast with how those would be done e.g. in C++ (with <a href="https://think-async.com/Asio/">Boost.Asio</a>) or in Conduit/Pipes/Machines/Streams of Haskell? I feel that really helped with UPARSE to drive the design from ideas that had already been worked out.</p>
</blockquote>
</aside>
<p>I'm still following through on my line of inquiry here and see if I can get some success in streamlining some of the <em>'Codec'</em> work I've been exploring. Certainly some of this thinking comes, again, from working a bit with Iterators in Javascript. I still think tokenization can be done in an iterative fashion as well, but that's a bit down the line.</p>
<hr>
<p>I'm inclined to think this concept offers something new and quite compelling that I don't see in these alternatives (or at least, <em>Pipes</em> would seem similar but I find the examples quite opaque). The ability to work through layered encoding in an incremental manner that would only place in memory the essential parts of a stream, and in a way that is really quite minimal in terms of its impact on the language. The mechanics for obtaining the stream are where they should be and it encourages a style of handling incoming data in a way that is incremental, precise and relatively non-blocking—180º from the traditional Rebol family model if nothing else.</p>
<p>Of course, it's easy to say so. Need to actually flex it a bit to back that up. And I haven't got to PostScript yet...</p> ]]></description>
        <link>https://forum.rebol.info/t/concept-filters/2000/5</link>
        <pubDate>Thu, 05 Jan 2023 20:33:44 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6541</guid>
      </item>
      <item>
        <title>Happy 2023, and 2022 General Status &amp; Reflection</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I mention up top that I have been busy for all of November and December, so I didn't do anything worth adding to the October status post in terms of <em>code progress</em>.</p>
<p>But putting some space between yourself and the code can offer other insights.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1988">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'm still "finding the cool" in new behaviors, so that's motivating. But maybe with the basics sorted out, it's getting closer to time to start ripping out some unnecessary parts, so that a committed subset can be pushed out to people on the web.</p>
</blockquote>
</aside>
<p><em>Definitely this:</em> <em><strong>I want to put the system into people's hands.</strong></em></p>
<p>We've reached a point where for once, we know how APPEND works.  That is no small feat... and the solution was a decade in the making.</p>
<p>I believe we now know how true and false work, with <code>~true~</code> and <code>~false~</code> being their meta state that evaluates to an isotopic state which can't be put into blocks.</p>
<p>There are so many neat solutions to old questions... like what is <strong><code>any []</code></strong> or <strong><code>all []</code></strong>, and having coherent answers to basic questions is something to stand on the shoulders of for the next tough question.  It all interlocks.</p>
<p><strong>I'm hard-pressed to say exactly what's going to happen with binding, but I'm wondering if there's any way to make a system that's useful even if we don't know how that will work.</strong></p>
<p>But I'm going to keep going at it, and start posting again here now that I'm getting more settled.  Again: Happy New Year!</p> ]]></description>
        <link>https://forum.rebol.info/t/happy-2023-and-2022-general-status-reflection/1988/3</link>
        <pubDate>Thu, 05 Jan 2023 19:43:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6540</guid>
      </item>
      <item>
        <title>Concept: Filters</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Related threads:</p>
<ul>
<li><a href="https://forum.rebol.info/t/streaming-mental-blocks-and-some-haskell-streaming-research/1325" class="inline-onebox">Streaming Mental Blocks, and some Haskell Streaming Research</a></li>
<li><a href="https://forum.rebol.info/t/streaming-survey-from-other-languages/1739" class="inline-onebox">"Streaming" Survey from Other Languages</a></li>
<li><a href="https://forum.rebol.info/t/parsing-giant-streams-without-consuming-tons-of-memory-how/1698" class="inline-onebox">Parsing Giant Streams Without Consuming Tons of Memory: How?</a></li>
</ul>
<hr>
<aside class="quote no-group quote-modified" data-username="rgchris" data-post="1" data-topic="2000">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>this concept is more focused on transcoding one series of numbers/characters to another. Filters are NOT scanners/tokenizers/lexers.</p>
</blockquote>
</aside>
<p>I'm curious about this distinction... why wouldn't a filter that takes in UTF-8 and produces a block of transcoded data be covered here?  What's the missing capability?</p>
<aside class="quote no-group" data-username="rgchris" data-post="1" data-topic="2000">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>A filter could conceivably be implemented as a distinct type that has object-like properties (as the PORT! type does) and could thus be acted upon by the appropriate Rebol actors (COPY/SKIP/NEXT/TAIL, etc.).</p>
</blockquote>
</aside>
<p>The umbrella term I tend to myself use above "Filter"/"Codecs"/"Ports" is "Streaming".  This is because of the use of the term in C++ and in Haskell in the cases I find interesting.  But even in Haskell it branches off into different models, such as <strong><a href="https://www.schoolofhaskell.com/school/advanced-haskell/conduit-overview">Conduit</a></strong>, <strong><a href="https://www.schoolofhaskell.com/user/Gabriel439/Pipes%20tutorial">Pipes</a></strong> and <strong><a href="https://statusfailed.com/blog/2014/09/02/practical-machines-in-60-seconds.html">Machines</a></strong></p>
<p>I'm glad you're putting down some concrete examples and experimenting with them.  Because if one stays fully general it gets hard to know what the limits are that would inform a useful design.</p>
<p>Maybe we could get examples worked up and see some contrast with how those would be done e.g. in C++ (with <a href="https://think-async.com/Asio/">Boost.Asio</a>) or in Conduit/Pipes/Machines/Streams of Haskell?  I feel that really helped with UPARSE to drive the design from ideas that had already been worked out.</p> ]]></description>
        <link>https://forum.rebol.info/t/concept-filters/2000/4</link>
        <pubDate>Thu, 05 Jan 2023 18:16:06 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6539</guid>
      </item>
      <item>
        <title>Concept: Filters</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>One interesting file format is that of <a href="http://site.xara.com/support/docs/webformat/spec/">Xara (XAR) vector images</a>. They consist of an eight-byte header followed by a collection of records. Records consist of two little-endian 32-bit integers denoting the record type and size followed by the record content. Presumably easy to traverse—however: the wrinkle here is that there is one record type that indicates that subsequent records are encoded in a single Deflate stream that terminates with both the end of the Deflate stream and a record type that indicates the end of the compressed section.</p>
<p>This is a simplified way of looking at it (each tag representing a whole record):</p>
<pre><code class="lang-nohighlight">---- regular byte stream ----
&lt;8-byte header&gt;
&lt;title&gt;
&lt;metadata&gt;
&lt;start-compressed-section&gt;
---- deflate compressed byte stream ----
&lt;thing&gt;
&lt;thing&gt;
...
&lt;end-compressed-section&gt;
---- regular byte stream ----
&lt;thing&gt;
&lt;thing&gt;
---- eof ----
</code></pre>
<p>This type of switch could be handled with filters.</p>
<pre><code class="lang-nohighlight">file-content: make filter! [
    source: open/direct %image.xar
]

content: file-content

consume content #{... magic number ...}

until [
    type: consume content 'unsigned-32-le
    size: consume content 'unsigned-32-le

    switch type [
        types/start-compressed-section [
            content: make filter! [
                type: 'deflate
                source: file-content
            ]
        ]

        types/end-compressed-section [
            assert [
                tail? content
            ]

            content: file-content
        ]
    ]

    ... record dispatcher ...

    type == types/end-of-file
]
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/concept-filters/2000/3</link>
        <pubDate>Thu, 05 Jan 2023 15:06:16 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6538</guid>
      </item>
      <item>
        <title>Concept: Filters</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>I'll spitball samples/test cases in replies. The example from the ports/streams/iterator posts was a layered encoding where an compressed encoding is in turn encoded as text:</p>
<pre><code class="lang-nohighlight">encoded: make filter! [
    ; implied type: 'text
    source: "start F3DI7!! end"
]

consume encoded "start"

encoded-ascii85: make filter! [
    type: 'ascii85
    source: encoded
]

encoded-deflate: make filter! [
    type: 'deflate
    source: encoded-ascii85
]

result: copy encoded-deflate

consume encoded " end"
=&gt; true
</code></pre>
<h2>Extracting from a large file</h2>
<pre><code class="lang-nohighlight">big-file: open/direct %big-file.txt

file-content: make filter! [
    ; implied type: 'stream
    source: big-file
]

copy/part skip file-content 1'000'000 25
</code></pre>
<p>As mentioned, ideally filter algorithms would have mechanisms to skip content without buffering, so you could do the following as fast as any other way of doing it:</p>
<pre><code class="lang-nohighlight">big-file: open/direct %big-file.txt

file-content-as-utf-8: make filter! [
    type: 'utf-8
    source: make filter! [
        ; implied type: 'stream
        source: big-file
    ]
]

copy/part skip file-content 1'000'000 25
; skips 1'000'000 UTF-8 characters without copying/buffering
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/concept-filters/2000/2</link>
        <pubDate>Thu, 05 Jan 2023 04:01:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6537</guid>
      </item>
      <item>
        <title>Concept: Filters</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>Filters are a means of incrementally transcoding data from source to brokered output (bytes/binary! or characters/text!). A goal is to provide a standard API for transcoding that can be implemented and used as efficiently as possible (e.g. extracting a portion of encoded data without extracting the whole; native transcoders for Deflate). A filter could conceivably be implemented as a distinct type that has object-like properties (as the PORT! type does) and could thus be acted upon by the appropriate Rebol actors (COPY/SKIP/NEXT/TAIL, etc.).</p>
<p><em>I've alluded to a similar idea in <a href="https://forum.rebol.info/t/semantics-of-port-s-vs-streams-vs-iterators/1689/4">an earlier post</a>, however this concept is more focussed on transcoding one series of numbers/characters to another. Filters are NOT scanners/tokenizers/lexers.</em></p>
<p>A filter source can be:</p>
<ul>
<li>BINARY! or TEXT! values</li>
<li>PORT! values that stream BINARY! or TEXT! (including files/network resources)</li>
<li>filter values (i.e. filters can be layered)</li>
</ul>
<p>Examples of filter types:</p>
<ul>
<li>Retrieves binary contained within a file/network resource</li>
<li>Decodes text encoded as UTF-8, UTF-16, ISO-8859-1, CP-1252, etc. (or even unspecified using something like Chardet)</li>
<li>Decodes binary compressed per Deflate, LZW, etc.</li>
<li>Decodes binary encoded as 'text' per Base64, Ascii85, Hexadecimal, etc.</li>
<li>Decrypts binary encrypted per e.g. Rebol 2 ENCLOAK/DECLOAK (but obviously more)</li>
<li>Decodes text encoded mostly literally but with escape sequences, e.g. JSON strings, Rebol strings, XML/HTML data sequences/attribute values</li>
</ul>
<p>Filters should have at least the following capabilities:</p>
<ul>
<li>Copy all encoded data</li>
<li>Copy part of the encoded data</li>
<li>Skip part of the encoded data (Deflate could potentially iterate faster if it wasn't emitting simultaneously)</li>
</ul>
<p>Filters should possibly have the following capabilities:</p>
<ul>
<li>BACK/HEAD/negative SKIP support</li>
<li>TAKE/REMOVE/CLEAR as a means of clearing buffers</li>
</ul>
<p>Functions that consume data should support filters as a pseudo-series type, e.g.</p>
<ul>
<li>Parse</li>
<li>BINARY/READ (from Oldes/Rebol3)</li>
<li>CONSUME (from <a href="https://forum.rebol.info/t/bincode/1863">rgchris/bincode</a>)</li>
</ul>
<p>Filter values are exhausted when:</p>
<ul>
<li>An end-of-content signal/delimiter has been found e.g. self-terminating formats such as Deflate; quote marks ending a JSON string</li>
<li>A filter cap has been reached e.g. the filter has a specified length</li>
<li>An unrecoverable error occurs (e.g. invalid UTF-8 sequences in strict mode; the 'g' character in a hexadecimal stream)</li>
<li>The source has been exhausted</li>
</ul>
<p>It should be possible to recover the current source at the corresponding index within a filter value though this may require additional state info, e.g. in Deflate or Base64 where a byte within an encoding has information pertaining to more than one decoded byte</p>
<p>Filter algorithms can be native (e.g. Deflate tied to Zlib, UTF-8) or in user-mode (thus extensible).</p> ]]></description>
        <link>https://forum.rebol.info/t/concept-filters/2000/1</link>
        <pubDate>Thu, 05 Jan 2023 03:49:47 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6536</guid>
      </item>
      <item>
        <title>JavaScript object notation shorthand</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>In essence, there's already three BLOCK! constructors in traditional Rebol (REDUCE, COMPOSE and COLLECT) of which COLLECT is perhaps the most versatile. It does require KEEP for most values which is likely why it's not the only one, but gives you access to all of the other language features:</p>
<pre><code class="lang-nohighlight">; alt-ARRAY
;
collect [
    repeat value 4 [
        keep value
    ]
]
</code></pre>
<p>A few variations on KEEP would be similarly useful in OBJECT! and MAP! creation:</p>
<pre><code class="lang-nohighlight">collect-map [
    keep "key" "value"
    spread another-map
]

collect-object [
    keep foo: "Bar"
    keep ["a" 123] "A value"
    spread another-object
]
</code></pre>
<p>I do like the idea of implicit collection though as well. I don't know if it's at all possible to mix implicit/explicit collection in any sane way.</p>
<hr>
<p>This would completely mess with any trivial noodling around with the language, but you could use A in place of CONSTRUCTOR in the previous posting:</p>
<pre><code class="lang-nohighlight">a block! [
    1 2 [3 4] spread [5 6] a map! [
        combine ["a" 123] "A value"
        from another-key
        spread another-map
    ]
]
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/javascript-object-notation-shorthand/1836/4</link>
        <pubDate>Mon, 02 Jan 2023 14:06:32 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6535</guid>
      </item>
      <item>
        <title>JavaScript object notation shorthand</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="rgchris" data-post="2" data-topic="1836">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I had to unlearn the idea that <code>[ ]</code> and <code>{ }</code> notation were <em>literals</em>; rather they are <em>constructors</em>.</p>
</blockquote>
</aside>
<p>I am not completely settled on my ideas about what I have called "fences":</p>
<p><a href="https://forum.rebol.info/t/rethinking-braces-as-an-array-type/1727" class="inline-onebox">{ Rethinking Braces }... as an array type?</a></p>
<p>The idea that braces evaluate to unstable fence isotopes and then decay into objects is so strange that I want to try it just to know what that might be like (!)</p> ]]></description>
        <link>https://forum.rebol.info/t/javascript-object-notation-shorthand/1836/3</link>
        <pubDate>Mon, 02 Jan 2023 14:01:59 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6534</guid>
      </item>
      <item>
        <title>JavaScript object notation shorthand</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>In understanding JavaScript more from a Rebol-brain (or even just with JSON priors), I had to unlearn the idea that <code>[ ]</code> and <code>{ }</code> notation were <em>literals</em>; rather they are <em>constructors</em>. I think this distinction is why JavaScript is at best awkwardly Lispy. Also constructors can't self-reference so e.g. within an object you can't reference a prior key set in the same construction (<code>{'a': 123, 'b': &lt; no way to get 'a' &gt;}</code>), although one 'benefit' to this is you can't inadvertently create a circularly referenced structure.</p>
<p>I do like the constructors in principle, but again in Rebol-land my inclination is to do this with language rather than syntax—the question is given how much heavy lifting syntax does in constructors, how much language/convention would need to be used to get some a degree of parity without being overly verbose:</p>
<pre><code class="lang-nohighlight">[
    1, 2, [3, 4], ...[5, 6], {
        ["a" + 123]: "A value",
        anotherKey,
        ...anotherMap
    }
]

constructor block! [
    1 2 [3 4] spread [5 6] constructor map! [
        combine ["a" 123] "A value"
        from another-key
        spread another-map
    ]
]
</code></pre>
<p>I don't suppose it's a trivial exercise.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1836">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It may be that there should be a less freeform alternative to MAKE OBJECT! which doesn't let you put arbitrary code in the middle of it.</p>
</blockquote>
</aside>
<p>This sounds like CONSTRUCT as was.</p> ]]></description>
        <link>https://forum.rebol.info/t/javascript-object-notation-shorthand/1836/2</link>
        <pubDate>Mon, 02 Jan 2023 13:36:39 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6533</guid>
      </item>
      <item>
        <title>Rebolbot future</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>Thanks for keeping this going for so long! I will likely try and recreate bits and pieces from the <strong>rebol.info</strong> site elsewhere. I may need help getting headless <strong>altme</strong> running somehow—I'm not really sure if there's too much point but nice to have the option.</p>
<p>I have the list of <a href="http://rebol.info/bot/links.r">Rebolbot links</a> saved, is there any other Rebolbot data worth holding on to?</p> ]]></description>
        <link>https://forum.rebol.info/t/rebolbot-future/1999/3</link>
        <pubDate>Sun, 01 Jan 2023 17:53:43 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6532</guid>
      </item>
      <item>
        <title>Rebolbot future</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Thanks for keeping it up... I didn't know it was around still!</p>
<p>We don't need an active RebolBot server.  But it might be nice to put it under GitHub CI to prevent the code from rotting (any more than it has), at some point.  Just something that asks it to do a few tasks and makes sure it can do them in a container.</p>
<p>I've been relatively inactive on Rebol the last couple of months, but expect this to change in the New Year.  I'll write up a post shortly...</p>
<p>Thanks again for keeping tabs and your help!</p> ]]></description>
        <link>https://forum.rebol.info/t/rebolbot-future/1999/2</link>
        <pubDate>Fri, 30 Dec 2022 17:12:40 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6531</guid>
      </item>
      <item>
        <title>Rebolbot future</title>
        <dc:creator><![CDATA[@johnk Johnk ]]></dc:creator>
        <description><![CDATA[ <p>Hi guys<br>
I think it is time to turn off the old rebolbot server as I have not been using it for a while. <a class="mention" href="/u/rgchris">@rgchris</a> may still have a few things running on it, so this is a heads up that I plan to turn it off in the next month or so.<br>
All the best,<br>
John</p> ]]></description>
        <link>https://forum.rebol.info/t/rebolbot-future/1999/1</link>
        <pubDate>Thu, 29 Dec 2022 07:31:51 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6530</guid>
      </item>
      <item>
        <title>SPLIT Semantics</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><a href="https://gitter.im/red/red?at=63523097f00b697fec501c7a">On Red Gitter</a>, it was discussed "which of the following is 'correct'":</p>
<pre><code>Red&gt; split "" ","
== [""]

R3&gt; split "" ","
== []
</code></pre>
<p>Rebolek thinks R3 is right.  Boris says:</p>
<blockquote>
<p>I don't think there's a correct answer, just choices. I prefer the Red version because:<br>
it strictly follows the rule: `number-of-segments = 1 + number-of-delimiters", no exceptions, so it's easier to reason about</p>
<p>it should be able thus to preserve the type in case one wants to rejoin it later (that it doesn't is a bug, try split %"" ",")</p>
</blockquote>
<p>So there's a couple of ways to look at it.</p>
<p>But I have a philosophy about these things where I want edge cases to be "noisy", because usually they require special handling.  I might even say:</p>
<pre><code>&gt;&gt; split "" ","
== ~null~  ; isotope</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/split-semantics/1998/1</link>
        <pubDate>Thu, 22 Dec 2022 04:04:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6529</guid>
      </item>
      <item>
        <title>ChatGPT Speaking About Rebol</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>I'm going to ask it to create a GUI (replacement using Qt or GTK)</p> ]]></description>
        <link>https://forum.rebol.info/t/chatgpt-speaking-about-rebol/1997/2</link>
        <pubDate>Sun, 18 Dec 2022 19:15:40 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6528</guid>
      </item>
      <item>
        <title>ChatGPT Speaking About Rebol</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>So ChatGPT actually knows a bit about Rebol (at least Rebol2)</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/7b940f01f3801b53d0a1d4d412074bda30517443.png" data-download-href="https://forum.rebol.info/uploads/default/7b940f01f3801b53d0a1d4d412074bda30517443" title="image"><img src="https://forum.rebol.info/uploads/default/original/1X/7b940f01f3801b53d0a1d4d412074bda30517443.png" alt="image" data-base62-sha1="hDdWsU3sEBthVlysVvcHRLWmfWH" width="356" height="500" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/7b940f01f3801b53d0a1d4d412074bda30517443_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">image</span><span class="informations">634×890 25 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p>This does raise some questions about the future of software, in general.  It's possible that AI models will plateau and maybe they'll never get too much better than this...</p>
<p>...but I don't think so.  I imagine year-over-year, we're going to see them learning.  I don't know exactly when they'd be able to come up with ideas like what I've been doing for Ren-C.</p>
<p>But something I did think about is that if they can write code, then giving them a super-expressive medium in which to do it could be very powerful.  If they can come up with the dialect and then use it, then they might be able to write concise programs that wind up being quite legible...whereas other languages might make them trade off length for clarity.</p>
<p>If you ask ChatGPT an interesting Rebol question, feel free to put it in this thread.</p> ]]></description>
        <link>https://forum.rebol.info/t/chatgpt-speaking-about-rebol/1997/1</link>
        <pubDate>Sat, 17 Dec 2022 15:53:35 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6527</guid>
      </item>
      <item>
        <title>Should ELSE be FALSE-reactive? (in addition to void and null?)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="IngoHohmann" data-post="3" data-topic="1991">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/40/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>should except react to the whole expression, or just to the branch it is tacked on?</p>
</blockquote>
</aside>
<p>Currently ELSE passes through an isotopic error.</p>
<p>As evidenced by my questioning of if ELSE with a parameter might act as EXCEPT, I'm not totally firm on this, I guess it really just comes down to what shows it works in practice.</p>
<p>But even though it's a bit messy and emergent, I think isotopic errors are a tremendous step up from the more or less untenable prior error situation.</p>
<p><a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852" class="inline-onebox">FAIL vs. RETURN RAISE: The New Age of Definitional Failures!</a></p> ]]></description>
        <link>https://forum.rebol.info/t/should-else-be-false-reactive-in-addition-to-void-and-null/1991/4</link>
        <pubDate>Mon, 05 Dec 2022 16:12:29 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6526</guid>
      </item>
      <item>
        <title>Should ELSE be FALSE-reactive? (in addition to void and null?)</title>
        <dc:creator><![CDATA[@IngoHohmann Ingo Hohmann]]></dc:creator>
        <description><![CDATA[ <p>I find it much clearer to use 'except for error handling, and it makes this possible:</p>
<pre><code>&gt;&gt; if true [1 / 0] else [ 2 / 0 ] except e -&gt; [print mold e]
    make error! [
    type: 'Math
    id: 'zero-divide
    message: "attempt to divide by zero"
    near: [1 / 0 **]
    where: [/ if console]
    file: _
    line: 1
]
</code></pre>
<p>The remaining question: should except react to the whole expression, or just to the branch it is tacked on?</p> ]]></description>
        <link>https://forum.rebol.info/t/should-else-be-false-reactive-in-addition-to-void-and-null/1991/3</link>
        <pubDate>Mon, 05 Dec 2022 11:15:26 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6525</guid>
      </item>
      <item>
        <title>What Should BLANK! in UPARSE Do?</title>
        <dc:creator><![CDATA[@IngoHohmann Ingo Hohmann]]></dc:creator>
        <description><![CDATA[ <p>That's how I see Blank as well. As a generic place holder: nothing interesting here (yet), but no need to worry, this is not an error.</p> ]]></description>
        <link>https://forum.rebol.info/t/what-should-blank-in-uparse-do/1821/4</link>
        <pubDate>Mon, 05 Dec 2022 08:50:57 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6524</guid>
      </item>
      <item>
        <title>Should ELSE be FALSE-reactive? (in addition to void and null?)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Another idea that has been simmering in my head: <strong>What if ELSE was ERROR!-isotope reactive, but only if you use it with a function that takes an argument?</strong></p>
<p>Today that requires you use EXCEPT.</p>
<pre><code>&gt;&gt; if true [1 / 0] except e -&gt; [print mold e]
make error! [
    type: 'Math
    id: 'zero-divide
    message: "attempt to divide by zero"
    near: [1 / 0 **]
    where: [/ if _]
    file: ~null~
    line: 1
]
</code></pre>
<p>But what if this happened?</p>
<pre><code>&gt;&gt; if true [1 / 0] else [print "not reached"]
** Math Error: attempt to divide by zero
** Where: / if
** Near: [1 / 0 **]
** Line: 1

&gt;&gt; if true [1 / 0] else e -&gt; [print mold e]
make error! [
    type: 'Math
    id: 'zero-divide
    message: "attempt to divide by zero"
    near: [1 / 0 **]
    where: [/ if _]
    file: ~null~
    line: 1
]
</code></pre>
<p>This would conflate errors with null and void.  But maybe that's all right.</p>
<p>In the case of UPARSE, pure null or pure void is not returned by combinators at this time.  So you'd be able to write combinators using ELSE instead of the uglier EXCEPT.  And I guess if you didn't actually feel like giving a full error explaining why you were failing a parse combinator, null isn't a terrible shorthand for "I am lazy"...but we'd have to allow <code>raise null</code> to work as just returning null.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-else-be-false-reactive-in-addition-to-void-and-null/1991/2</link>
        <pubDate>Fri, 02 Dec 2022 12:20:12 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6522</guid>
      </item>
      <item>
        <title>Thinking About Isotopes Logically: ~true~ and ~false~</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1944">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>All told, it seems simpler to just let a ~true~ isotope be truthy, ~false~ be falsey, all other word isotopes be neither conditional true nor false. And then make isotopic words an unusually friendly sort of isotope.</p>
</blockquote>
</aside>
<p>So I am pretty gung ho on this.  It has the feeling of a <em>right answer</em>.  As I've said, it was always really depressing to start reading the boot from the top and have a big essay on "we have no idea what logic literals are"... and now not only do we know, but there's a whole deep philosophy on the reified realm being truthy vs. the isotopic realm having some falsey things.  It's high-leverage, high-IQ stuff.  <img src="https://forum.rebol.info/images/emoji/twitter/brain.png?v=9" title=":brain:" class="emoji" alt=":brain:"></p>
<p>The question of just how friendly to make these isotopes runs up against some issues.</p>
<p>For instance, what about MOLDing?  In the bootstrap, we have for instance a <code>debug</code> flag which can be set to things like <strong><code>on</code></strong> or <strong><code>normal</code></strong> or <strong><code>symbols</code></strong> etc., but when it's set to ON in the default config it actually becomes a ~true~ isotope.</p>
<p>So that now causes an error, since MOLD refuses to turn an isotope into a word:</p>
<pre><code>print ["debug:" mold app-config/debug]
</code></pre>
<p>Historical Redbol is willing to wordify the logic:</p>
<pre><code>red&gt;&gt; mold on
== "true"
</code></pre>
<p>I think this intermixing of words with logic is flawed, <em>and I actually like how it gets caught here</em>.  The code which is assigning <strong>debug: on</strong> in the configuration is better as <strong>debug: 'normal</strong>.</p>
<p>For other cases, we've got REIFY if you are okay with ~true~ and ~false~... and it passes through non-isotopic things as-is:</p>
<pre><code>&gt;&gt; reify "hello"
== "hello"

&gt;&gt; reify true
== ~true~
</code></pre>
<p>If you want a word from something you know is a logic, there's LOGIC-TO-WORD</p>
<pre><code>&gt;&gt; logic-to-word true
== 'true
</code></pre>
<p>Overall there are a lot of issues like this, but I think that we want to keep MOLD and PRINT unwilling to do isotopes.  It's a little bit of a speedbump, but helps you get involved to make sure the right thing happens.</p> ]]></description>
        <link>https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944/5</link>
        <pubDate>Fri, 02 Dec 2022 11:48:44 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6521</guid>
      </item>
      <item>
        <title>Should Everything Have an Isotopic Form?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[  ]]></description>
        <link>https://forum.rebol.info/t/should-everything-have-an-isotopic-form/1889/8</link>
        <pubDate>Fri, 02 Dec 2022 11:15:04 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6520</guid>
      </item>
      <item>
        <title>Should Isotopes Be Legal in MAP! (Keys, Values?)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1995">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>null was the signal of not being in a map. Assigning a key null was a way of removing items from that map.</p>
</blockquote>
</aside>
<p>Now that null is implemented as an isotopic word, this feature is broken by a "no isotopes" rule.  So there would have to be an exception made just for null.</p>
<p><strong>But... what if we <em>didn't</em> make an exception, and used void (which isn't "isotopic") to remove elements?</strong>  We could still have the falsey null come back when items weren't found.  The asymmetry seems consistent in the era of void-in-null out.</p>
<p>This would introduce a little bit of a "hassle", e.g. by forcing you to throw in a MAYBE:</p>
<pre><code>&gt;&gt; m: make map! [key &lt;initial&gt;]
== make map! [key &lt;initial&gt;]

&gt;&gt; m.key
== &lt;initial&gt;

&gt;&gt; m.key: select [a 10 b 20] 'c
** Error: Can't put ~null~ isotopes in maps, use void to remove key

&gt;&gt; m.key: maybe select [a 10 b 20] 'c
; void

&gt;&gt; m.key
== ~null~  ; isotope
</code></pre>
<p>But it's probably a good hassle.  "Did you really mean to unset this key?"</p>
<p>If you're sure, it's not any harder... you just say <strong>m.key: void</strong> instead of <strong>m.key: null</strong>.  And it helps make the "you can't put isotopes in maps" rule universal... null just becomes the answer given back when nothing is there, kind of like how it's used in blocks.  This doesn't get cognitively mixed up with giving the appearance you're actually storing an isotope.</p>
<p>You can also make keys the direct product of a conditional, like <strong><code>m.key: case [... [&lt;whatever&gt;]]</code></strong> and if no cases are taken there won't be an addition done.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-isotopes-be-legal-in-map-keys-values/1995/2</link>
        <pubDate>Fri, 02 Dec 2022 10:08:02 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6519</guid>
      </item>
      <item>
        <title>BLANK! (_) as SPACE in String-Oriented Dialects</title>
        <dc:creator><![CDATA[@IngoHohmann Ingo Hohmann]]></dc:creator>
        <description><![CDATA[ <p>Makes sense for me like this.</p> ]]></description>
        <link>https://forum.rebol.info/t/blank-as-space-in-string-oriented-dialects/1885/5</link>
        <pubDate>Fri, 02 Dec 2022 10:03:18 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6518</guid>
      </item>
      <item>
        <title>Should Isotopes Be Legal in MAP! (Keys, Values?)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>In the pre-isotopic era, there was a concept that MAP! would not allow you to store nulls.  Because null was the signal of not being in a map.  Assigning a key null was a way of removing items from that map.</p>
<pre><code>&gt;&gt; m: make map! [x 20]
== make map! [
    x 20
]

&gt;&gt; m.x
== 20

&gt;&gt; m.y
; null

&gt;&gt; m.x: null
; null

&gt;&gt; m
== make map! [
]
</code></pre>
<p>Additionally, NULL was not allowed as a key.</p>
<h2>How Should This Change In The Isotopic Era?</h2>
<p>I'll make the point that not allowing you to store isotopes as keys or values isn't a fundamental problem, because you can META a value to put it in, and then UNMETA it when taking it out.</p>
<p>You wind up with a fundamental issue that actions from a MAP! won't be run implicitly this way, and you can't put any falsey values in a map this way (because false is the ~false~ word isotope, and ~null~ isotopes are representations of not being in the map).</p>
<p>But that limitation can be a benefit.  I already think of it as a benefit that you cannot run an action by doing access of items out of a block.  e.g. <strong>block.1</strong> could never run a function now (since blocks can't store isotopic actions).  If that was true of <strong>map.key</strong> as well, that could be seen as a good thing... you'd have to APPLY or RUN a plain ACTION! (or QUASI-ACTION!).</p>
<pre><code>&gt;&gt; m: make map! []

&gt;&gt; m.1: :append
** Error: Cannot put ACTION! isotope in map

&gt;&gt; m.1: ^append
== ~#[action! {append} [series value /part /dup /line]]~

&gt;&gt; m.1
== ~#[action! {append} [series value /part /dup /line]]~

&gt;&gt; run m.1 [a b c] [d e]
== [a b c [d e]]

&gt;&gt; apply m.1 [[a b c] [d e] /dup 2]
== [a b c [d e] [d e]

&gt;&gt; m.1/ [[a b c] [d e] /dup 2]
== [a b c [d e] [d e]
</code></pre>
<p>As with the peace of mind using BLOCK!, that seems like a good thing to me.</p>
<p><em>(I'm not entirely sure if RUN should allow QUASI-ACTION!s, or if you should have to UNQUASI it into a plain ACTION!.  Forcing the canonization might make more sane, so that routines that want to exchange actions as currency would have one standard they spoke.)</em></p>
<p>I also think it's likely a good thing that false isotopes wouldn't be in the map, only quasi-false and the word false.  So if you're putting logic into a map, you'd wind up writing <strong><code>if map.key = 'true [...]</code></strong> or <strong><code>if map.key = 'false [...]</code></strong> and save the <strong>if map.key</strong> and <strong>if not map.key</strong> for testing things being in the map.</p>
<h2>This Would Widen The Gap With Objects</h2>
<p>There have been questions about what the difference is between maps and objects, and this would be another: objects must be able to have members that are isotopes: action isotopes that can run implicitly, logic and null and other word isotopes, and I'm presuming splices and other stable forms as well.</p>
<p>It would mean a map has more in common with a block.</p>
<p>This doesn't strike me as being that much of a problem.</p>
<p><strong>So I'm going to be going ahead with the premise that isotopes can't be stored in maps, as either keys or values.</strong>  We'll see how it goes, but I think this is the right answer.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-isotopes-be-legal-in-map-keys-values/1995/1</link>
        <pubDate>Fri, 02 Dec 2022 09:28:15 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6517</guid>
      </item>
      <item>
        <title>Head-to-Head Battle of the Coding Fonts</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>So I don't think this did the best job of representing Inconsolata (the choice for the ReplPad), but it lets you pit monospace fonts against each other to find the one you like:</p>
<p><a href="https://www.codingfont.com/">https://www.codingfont.com/</a></p>
<p>I still think if the right weight of Inconsolata is chosen it's the best.</p>
<p><a href="https://fonts.google.com/specimen/Inconsolata?preview.text=0O1Iil&amp;preview.text_type=custom#styles" class="inline-onebox">Google Fonts: Inconsolata</a></p>
<p>For me, the competition would be Source Code Pro or Fira Code.</p> ]]></description>
        <link>https://forum.rebol.info/t/head-to-head-battle-of-the-coding-fonts/1994/1</link>
        <pubDate>Thu, 01 Dec 2022 14:43:59 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6516</guid>
      </item>
      <item>
        <title>What Should BLANK! in UPARSE Do?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1821">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>That's a slam dunk. So now we have the behavior tied up. <img src="https://forum.rebol.info/images/emoji/twitter/relieved.png?v=9" title=":relieved:" class="emoji" alt=":relieved:"></p>
</blockquote>
</aside>
<p><em>I'm...pretty sure (?) this is still the best plan.</em></p>
<p>So there's a new philosophy I've outlined for why BLANK! exists at all, and its purposes as being a kind of generic "nothing to see, here" is distinct from what might be thought of more as a disruptor like null or an unset variable.  It is not related at all to soft failure.  Blank is simply a wildcard that you can choose to treat equivalently to an empty series or missing value, without committing to being anything in particular.</p>
<p>I've also mentioned that in some mechanical contexts (like APPEND), we are simply more interested in blank's "thingness" than in its representation of nothingness.  So you have to DECAY it or SPREAD it or otherwise interact with it to get it to not act mechanically.</p>
<p><em>PARSE strikes me as one of the more mechanical contexts.</em></p>
<pre><code>parse [_ _ _] [repeat 3 _]
</code></pre>
<p>And I think the value of having it to represent space in string contexts is probably high.</p>
<p>It may be one of those things where to prevent accidents where you didn't mean it to be interpreted as a space, it shouldn't allow you to use it fetched from a WORD! in the rules.  You either use <code>@var</code> to say "I mean literally a blank" or you can make the rule contain a quoted value.</p>
<h2>But It's Important To Point Out There Are Other Tools</h2>
<p>Already, a lone apostrophe acts like an empty rule:</p>
<pre><code>&gt;&gt; parse "abc" ["a" ' "b" "c"]
== "c"
</code></pre>
<p>This makes even more sense than it used to, <a href="https://forum.rebol.info/t/how-became-quoted-void-and-became-quasi-void/1915">because a lone apostrophe is now a quoted void</a>.  And you can think of there being infinitely many voids at any position in a block.</p>
<p>Also already, <strong>~</strong> triggers a failure (though it should probably give a better message):</p>
<pre><code>&gt;&gt; parse "abc" ["a" ~ "b" "c"]
** Error: ~ encountered in parse rule
</code></pre>
<p>You could also use quasiwords for failures, e.g.:</p>
<pre><code>&gt;&gt; parse "ccc" [some "a" | some "b" | ~mismatch~]
** Error: ~mismatch~ in PARSE</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/what-should-blank-in-uparse-do/1821/3</link>
        <pubDate>Thu, 01 Dec 2022 09:51:02 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6515</guid>
      </item>
      <item>
        <title>How &#39; Became Quoted-Void (and ~ Became Quasi-Void)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><img src="https://forum.rebol.info/images/emoji/twitter/arrow_double_up.png?v=9" title=":arrow_double_up:" class="emoji only-emoji" alt=":arrow_double_up:"></p>
<p>I've streamlined the above thread of historical discussion-with-myself to remove the flip-flopping, and just chronicle the actual points.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1915">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>One of my early reasonings was that VOID was more "etheric" than NULL. <em>So perhaps void was actually the isotopic form of null,</em> and ~ could be null's quasiform:</p>
<pre><code> &gt;&gt; quasi null
 == ~

 &gt;&gt; ~
 ; void
</code></pre>
<p>But this was confusing, since if <code>~</code> was the meta of void, there really isn't any such thing as a "~ isotope". You could never make one, because I thought it needed to vaporize.</p>
<pre><code>&gt;&gt; 1 + 2 ~
== 3
</code></pre>
</blockquote>
</aside>
<p>This is a curious realization about how an early decision got stuck in my head.  NULL was the first thing I implemented that had "no representation", and I gave it the "privileged" state of being the vaporizing result of a quoted nothing:</p>
<pre><code>&gt;&gt; '
; null  (hmmmm...)
</code></pre>
<p>As the need to print out a comment there shows, it's not like I'd solved the "has no value representation" problem in some general sense by picking this particular choice.  And it turns out to be a pretty bad choice.</p>
<p>It's much better for void.  And having the isotopic state represent unset variables is a real joy in terms of the visuals and ergonomics.  Being able to say <strong><code>(x: ~)</code></strong> and unset a variable, and have that be the rendering in a list of unset variables draws the attention to the things that are set.</p> ]]></description>
        <link>https://forum.rebol.info/t/how-became-quoted-void-and-became-quasi-void/1915/6</link>
        <pubDate>Thu, 01 Dec 2022 09:02:11 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6514</guid>
      </item>
      <item>
        <title>NULL, BLANK!, NIHIL, VOID: History Under Scrutiny</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="rgchris" data-post="20" data-topic="1249">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I'm not saying you're wrong, I just don't understand why you're right</p>
</blockquote>
</aside>
<p>I'm glad you've been persistent in questioning non-ergonomic behaviors and terminology.  I think it has greatly helped aim the design toward meeting both the needs of system coherence (my specialty) and idiomatic Rebol user scenario aesthetics (your specialty).  As I've said--if I've been irritable about it, mostly it's been that I can't solve a problem of you not relating to what I write by writing more of the same.</p>
<p>But I think things are different now, and I think it's mostly hammered out.</p>
<p>I've vetted this historical thread and replaced references to "void" with "nihil", to avoid confusions with the modern sense of the word void you argued for <em>(the vanishing state, distinct from the contents of an unset variable--although the two are now linked together, as nihil is the isotopic state of void)</em>.</p>
<aside class="quote no-group" data-username="rgchris" data-post="15" data-topic="1249">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I'm just still trying to better understand the intersection of NIHIL/NULL/BLANK/LOGIC as it pertains to values and flow—I don't yet have a settled story myself about why this is a necessary improvement over BLANK! as flow currency.</p>
</blockquote>
</aside>
<p>So the story to me all pulls together like this:</p>
<ul>
<li>
<p><strong>VOID</strong> - An intent of absolutely nothing, a desire for a no-op or vaporizing value.  If you pass to a function there may be a sensible return result, and if not you may return another signal (probably an ornery one and not another void, in order to get errors in sensible spots vs. generating a confusing chain that opts itself entirely out with no sign of where the trigger was)</p>
<pre><code>&gt;&gt; (comment "hi")
; void

&gt;&gt; 1 + 2 void
== 3

&gt;&gt; append [a b] void
== [a b]

&gt;&gt; append void 10
== ~null~  ; isotope
</code></pre>
</li>
<li>
<p><strong>NIHIL</strong> - The state of an unset variable, where you wish for it to cause an error merely by referencing a word.  You thus can't test an unset variable like <code>if asdfasdf [...]</code> because there will be an error on the <code>asdfasdf</code> reference.  But even if you get a NIHIL, it is still logically neither true nor false and will generate an error.</p>
<pre><code>&gt;&gt; if asdfasdf [print "never reached"]
** Error: asdfasdf is unset

&gt;&gt; get/any 'asdfasdf
== ~  ; isotope
          ^-- nihil is technically the isotopic state of void

&gt;&gt; if get/any 'asdfasdf [print "never reached, either"]
** Error: ~ isotopes are neither conditionally true nor false
</code></pre>
</li>
<li>
<p><strong>NULL</strong> - A signal of soft failure, such as a SELECT or PICK that did not succeed.  It does not cause errors to fetch it from a word, and it is logically false...so it's a good choice for initializing a variable that you plan to be testing in various places to see if it has been assigned yet or not.  Most routines will error if you try to pass a null to an argument that it expects, so you're supposed to be using that convenient testability to avoid branches which don't apply:</p>
<pre><code>&gt;&gt; third [a b]
== ~null~  ; isotope

&gt;&gt; if third [a b] [print "Never reached"]
; void

&gt;&gt; append [d e] third [a b]
** Error: APPEND cannot add a ~null~ isotope to a block
</code></pre>
</li>
</ul>
<h2>None of The Above States Can Be Put In Blocks</h2>
<p>VOID opts out of being appended, and NIHIL and NULL are isotopes.  Isotopes (stable ones, e.g. not errors or parameter packs) are states that variables can have, but can't be in blocks.</p>
<p><strong>Yet each of these cases reasonably needs a "proxy value" for representing their intent in a block.  The idea behind these proxy values is that under evaluation, each will produce the state.</strong></p>
<p>There is <strong>QUOTED VOID</strong>, which when evaluated drops the quote level and becomes void.</p>
<pre><code>&gt;&gt; quote void
== '

&gt;&gt; '
; void

&gt;&gt; 1 + 2 '
== 3

&gt;&gt; append [a b] '
== [a b]
</code></pre>
<p>There is <strong>QUASI VOID</strong>, which when evaluated becomes isotopic void (which is what I'm calling NIHIL).  Assigning it to a variable will unset that variable.</p>
<pre><code>&gt;&gt; quasi void
== ~

&gt;&gt; ~
== ~  ; isotope

&gt;&gt; foo: ~
== ~  ; isotope

&gt;&gt; foo
** Error: FOO is unset
</code></pre>
<p>There is the <strong>QUASI-WORD! WITH THE SPELLING "NULL"</strong>, which when evaluated becomes the isotopic word worm of ~null~.  <em>(The choice to make this literal english word isotope correspond to the null state is a pragmatic one, because something like ~_~ for isotopic blank being designated as null doesn't really offer appreciable benefit and would be a tax to explain.)</em></p>
<pre><code>&gt;&gt; quasi 'null
== ~null~

&gt;&gt; ~null~
== ~null~  ; isotope
</code></pre>
<p><strong>Mechanically, these proxy values are all as friendly as any other value in block manipulation.</strong>  There's nothing special about them when you're TAKE-ing or APPEND-ing or INSERT-ing them.  But functions can react differently to them in terms of the intent they are proxying.</p>
<pre><code>&gt;&gt; append [a b] second [d ']
== [a b ']

&gt;&gt; append [a b] decay second [d ']
== [a b]

&gt;&gt; append [a b] second [d ~]
== [a b ~]

&gt;&gt; append [a b] decay second [d ~]
** Error: Cannot APPEND ~ isotopes to blocks
</code></pre>
<h2>BLANK! Fills A Niche The Proxy Values Do Not Cover</h2>
<p>The idea behind blank as a placeholder is that it can stand in for values and then routines can fold its handling in as part of that routine's natural handling of no value.</p>
<p>I believe for example that blank should report TRUE back from EMPTY?, and that it should react to SPREAD the same as an empty block would:</p>
<pre><code> &gt;&gt; data: [Foo [10 20] Baz _ Bar [30]]

 &gt;&gt; map-each [name stuff] data [spread stuff]
 == [10 20 30]
</code></pre>
<p><em>(By contrast, I'd think that SPREAD of reified <strong><code>~</code></strong> or <strong><code>~null~</code></strong> should pretty clearly be errors.  A SPREAD of just <strong><code>'</code></strong> might reasonably be argued to act like void, but I'm not sure, so it's an error for now and you'd have to at least DECAY it for it to act like a void.)</em></p>
<p>In any case--this isn't to say BLANK! is synonymous with empty blocks...because it's not.  It's equally likely a placeholder for an empty string, or a slot which could be a WORD! or a TAG! or an INTEGER!.</p>
<p>So if its behaviors seem too "friendly" by answering a lot of basic questions and allowing FOR-EACH enumerations to be skipped without complaint, and you don't want such a friendly slot, then <strong>~</strong> may be a better choice for a reified nothing.</p>
<h2>Cross-Cutting Behaviors Are Better Than Making BLANK! False</h2>
<p>I've uncovered some pretty deep value from being able to say with confidence that anything you can pick out of a block or group is "truthy" from IF's point of view.</p>
<p>When you take a step out from mechanical block construction into the world of what's legal states for variables, then you get into isotopes... where we have isotopic ~null~ and ~false~ and so there are falsey states there.  Things are very pleasing.</p>
<p>I think the much more interesting things to say are these other properties like that BLANK! is EMPTY? or that it SPREADs equivalently with an empty block, rather than that it is falsey.  Those properties are where the leverage comes from.  And the leverage of saying everything reified in a block is truthy is tremendous.</p>
<p>However, I am going to want Redbol emulation to work...even if I think reified things all being truthy is the better answer.  I'll have to look into how to hook a TRUTHY? function used by a sort of "evaluative sub-universe"...maybe on a module level, and what hope that has vs. needing to rewrite every construct that acts on a concept of testing for truth and falsehood.</p>
<p>(You lose a lot of interesting correctness going against the all-block-reified-items are truthy rule... <strong>while [item: try take block] [...]</strong> is just the tip of the iceberg.)</p>
<h2>Distortion Of Return Results For THEN/ELSE Are Cleaned Up</h2>
<p>I won't rewrite it all here, but the idea of differentiating ~null~ isotopes signaling "no result" vs. being able to signal "there was a result and it was a null isotope" is folded in with the multi-return mechanics.</p>
<p>A parameter pack containing one null isotope will unpack that into a SET-WORD! or first multi-return in a SET-BLOCK!, and for almost any parameter it will act identically.  Only some routines like THEN and ELSE will be sensitive to a difference between these two.  Conditional constructs that wish to return null intentionally simply must box it up in a parameter pack to count as "an answer that is null" vs. returning a null in isolation.</p>
<p>Long story short: The various aspects of broken that were introduced by distorting return results in service of THEN and ELSE has been finessed and folds into a bigger story of multi-returns, <a href="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134/12">which by leveraging isotopes are able to be handled gracefully in compositions</a>.</p>
<h2>Pleasingly, This Is Only THREE Types (if you think of it that way).</h2>
<p>What you're seeing here is just VOID, BLANK!, and WORD!.</p>
<p>It just so happens that all datatypes now have isotopic forms, quasiforms, and quoted forms.</p>
<p>But there's full regularity in the behaviors:</p>
<ul>
<li>all quoted values evaluate by removing one quote level</li>
<li>all quasiforms evaluate by producing the isotopic form</li>
<li>no isotopic forms can be put in blocks</li>
<li>attempting to put a void in a block is a no-op</li>
<li>all non-isotopic forms are legal in blocks and act the same w.r.t. APPEND, TAKE, etc.</li>
</ul>
<p>There are nuances here, but, also some very strong anchor points for supporting the flow of engineering decision-making...</p> ]]></description>
        <link>https://forum.rebol.info/t/null-blank-nihil-void-history-under-scrutiny/1249/23</link>
        <pubDate>Thu, 01 Dec 2022 05:58:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6513</guid>
      </item>
      <item>
        <title>BLANK! (_) as SPACE in String-Oriented Dialects</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>With some of my observations on how we can use "single character intents of nothing" (<strong><code>[_ ' ~]</code></strong>), I think it's worth coming back to look at this BLANK!-as-space question one more time...<sub><em>(It's almost never just one more time, is it.  <img src="https://forum.rebol.info/images/emoji/twitter/man_facepalming.png?v=9" title=":man_facepalming:" class="emoji" alt=":man_facepalming:"> )</em><sub></sub></sub></p>
<p><a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604/3" class="inline-onebox">Shades of Distinction In Non-Valued Intents - #3 by hostilefork</a></p>
<p>I suggest that it would be nice if anywhere that <em>would</em> take a series, BLANK! acting like an empty series would be a cool behavior.</p>
<p><strong>So... how necessary is it that we give DELIMIT behavior for BLOCK!s or GROUP!s--empty or otherwise--that we would want to have parity with empty block for blanks?</strong></p>
<p>Looking at just what's there right now, today, we have this behavior:</p>
<pre><code>&gt;&gt; c: 1020
&gt;&gt; d: 304

&gt;&gt; unspaced ["a" ["b" c] d]
== "abc304"

&gt;&gt; spaced ["a" ["b" c] d]
== "a bc 304"
</code></pre>
<p>So it uses the contents of the block as raw material, but doesn't reduce it or obey the delimiter.  With GET-BLOCK! you have a shorthand to reduce it, if you like:</p>
<pre><code>&gt;&gt; unspaced ["a" :["b" c] d]
== "ab1020304"

&gt;&gt; spaced ["a" :["b" c] d]
== "a b1020 304"
</code></pre>
<p><strong>I've always tended to think that having automatic behavior for BLOCK! here does more harm than good.</strong>   More often than not, you just get nonsense when you wanted something else:</p>
<pre><code>&gt;&gt; block: [1 2 &lt;x&gt; hello]

&gt;&gt; print ["Your block is:" block]
Your block is: 12&lt;x&gt;hello  ; ugh.
</code></pre>
<p>It's bad enough when the results get printed and you see the garbage.  But worse when it just affects some string you're writing somewhere accidentally.</p>
<p>There's some efficiency gain if the enumeration of the block gets folded recursively into the process because you're not generating large intermediate strings and merging them... you're just building one big long string as you go.  So that led me to think it <em>might</em> have value, and implemented it.  But I've remained a skeptic... and...</p>
<h2>...I Don't Think DELIMIT Should Have a BLOCK! Behavior</h2>
<p>The case above shows the kind of nonsense I'm tired of.</p>
<p>Now that <a href="https://forum.rebol.info/t/should-reduce-heed-spread/1917">SPREAD Could Heed DELIMIT</a> that gives other ways to optimize the situation of wanting to fold a block's contents into a string formation.</p>
<p>There's a weird but kind of cool behavior that quoting an item will mold it.  And you can use ^META to take most types up a quoting level:</p>
<pre><code>&gt;&gt; str: "abc"
&gt;&gt; blk: [a b c]

&gt;&gt; print ["String is" ^str "and Block is" ^blk]
String is "abc" and Block is [a b c]
</code></pre>
<p>If you're wondering why not to use <span class="mention">@str</span> and <span class="mention">@blk</span>, it's because ECHO semantics used those for non-mold-oriented splicing, e.g. if you just had a plain string it would echo it:</p>
<pre><code>&gt;&gt; echo [String is @str]
String is abc
</code></pre>
<p>Not that PRINT and ECHO need to line up, but it's something to think about.</p>
<p><strong>I guess the long story short here being that I am not all <em>that</em> worked up over the loss of synonymousness between an empty block and blank in the DELIMIT dialect.</strong></p>
<p>If BLANK! did anything besides act as a space, it would probably need to be an error.  I guess I'll have to keep my eyes open for what the opportunities are for blank being synonymous with an empty block in these stringification scenarios... but my instinct is to say those aren't particularly interesting.</p>
<p>I think the apostrophe case could be used for when you really mean nothing--as a reified proxy for void--instead of blank.</p>
<p><strong>The big question may actually be at the topmost level of FORM, e.g. FORM of an empty block vs. FORM of a blank.</strong></p>
<pre><code>&gt;&gt; form [a b]
== "a b"

&gt;&gt; form [_]
== " "  ; we are presuming this direction

&gt;&gt; form []
== ""  ; (or possibly null ?)

&gt;&gt; form _
== " "  ; or should it be forced to match what empty block is?
</code></pre>
<p>But there's no rule that <strong>form [_]</strong> has to match <strong>form _</strong> any more than there is that <strong>form [[]]</strong> has to do the same thing as <strong>form []</strong>, so this needs to be weighed.</p> ]]></description>
        <link>https://forum.rebol.info/t/blank-as-space-in-string-oriented-dialects/1885/4</link>
        <pubDate>Wed, 30 Nov 2022 12:28:57 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6512</guid>
      </item>
      <item>
        <title>VID/S or Spaces, from Red&#39;s hiiamboris</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Helps as a calling card to tell which Red demos to pay attention to.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p> ]]></description>
        <link>https://forum.rebol.info/t/vid-s-or-spaces-from-reds-hiiamboris/1886/6</link>
        <pubDate>Wed, 30 Nov 2022 12:00:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6511</guid>
      </item>
      <item>
        <title>VID/S or Spaces, from Red&#39;s hiiamboris</title>
        <dc:creator><![CDATA[@gchiu]]></dc:creator>
        <description><![CDATA[ <p>I have no idea why he chooses these odd colour combinations</p> ]]></description>
        <link>https://forum.rebol.info/t/vid-s-or-spaces-from-reds-hiiamboris/1886/5</link>
        <pubDate>Wed, 30 Nov 2022 11:44:33 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6510</guid>
      </item>
      <item>
        <title>Shades of Distinction In Non-Valued Intents</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I've brought the above discussion up to date, and I think it paints a pretty clear picture of why things are the way they are.</p>
<p>But I realized while thinking about what the right default for ARRAY would be, that there are effectively three single-character reified non-values:</p>
<pre><code>[1]  &gt;&gt; array 3
     == [_ _ _]  ; BLANK!s

[2]  &gt;&gt; array 3
     == [~ ~ ~]  ; Quasi-VOID!s

[3]  &gt;&gt; array 3
     == [' ' ']  ; Quoted-VOID!s
</code></pre>
<h2>This Offers Us Some Nuance Even If A State Must Be Reified!</h2>
<p>When it comes to the direct behavior of APPEND to a block, all these states have to work the same.  In the era of isotopes, all reified values are appended as-is... it cannot (and should not) be any more complex:</p>
<pre><code>&gt;&gt; append [a b] second [c _]
== [a b _]

&gt;&gt; append [a b] second [c ~]
== [a b ~]

&gt;&gt; append [a b] second [c ']
== [a b ']

&gt;&gt; append [a b] second [c [d e]]
== [a b [d e]]
</code></pre>
<p><strong>But when we throw in an extra operation, we can imagine a difference.</strong>  For instance, we could make BLANK! semantically equivalent to an empty array for the purposes of things like SPREAD or EMPTY?</p>
<pre><code>&gt;&gt; spread second [c []]
== ~[]~  ; isotope

&gt;&gt; spread second [c _]
== ~[]~  ; isotope

&gt;&gt; append [a b] spread second [c _]
== [a b]

&gt;&gt; empty? second [c _]
== ~true~  ; isotope
</code></pre>
<p>...and then we'd say that if you tried to do such things with a quasi-void or a quoted-void, it would be an error:</p>
<pre><code>&gt;&gt; spread second [c ~]
** Error: SPREAD does not accept QUASI-void arguments

&gt;&gt; empty? second [c ']
** Error: EMPTY? does not accept QUOTED-void arguments
</code></pre>
<p><em>I think this suggests that <code>~</code> makes a better choice for the default value of ARRAY elements!</em>  We can't default to an isotope like the one representing unset variables, but it's the closest thing.</p>
<p><em>Ultimately it came to seem that having only the isotopes ~null~ and ~false~ be falsey was more valuable than having BLANK! be falsey.</em>  Simply being able to assume that anything you can find in an array is truthy offered more leverage.  So blanks are now truthy, BUT they're empty.</p>
<h2>What About Opting Out Of As-Is Appends, etc?</h2>
<p>I mentioned that all items that can be found in a block have to act mechanically identically when it comes to TAKE-ing and APPEND-ing them.  But what would XXX be if you wanted the following?</p>
<pre><code>&gt;&gt; append [a b] xxx second [c [d e]]
== [a b [d e]]

&gt;&gt; append [a b] xxx second [c _]
== [a b _]

&gt;&gt; append [a b] xxx second [c ~]
** Error: Cannot append NIHIL (~ isotope) to a block

&gt;&gt; append [a b] xxx second [c ']
== [a b]
</code></pre>
<p>I suggest this operator be called DECAY.  It would turn all quasiforms into their corresponding isotope, and its behavior of turning QUOTED! void into a void would be a unique behavior for which that is the only quoted form that it would do that for.</p>
<pre><code>&gt;&gt; decay first [~asdf~]
== ~asdf~  ; isotope

&gt;&gt; decay first ['foo]
== 'foo

&gt;&gt; decay first [123]
== 123

&gt;&gt; decay first [']
; void
</code></pre>
<p>The reverse of this operator would be REIFY.</p>
<h2>What About FOR-EACH Variations?</h2>
<p>I think an additionally neat spin on how these can be treated differently can be how FOR-EACH responds.</p>
<pre><code>&gt;&gt; for-each x (second [c []]) [
       print "Loop never runs"
   ]
; void

&gt;&gt; for-each x (second [c _]) [
       print "Loop never runs"
   ]
; void

&gt;&gt; for-each x (second [c ']) [
       print "Loop never runs"
   ]
== ~null~  ; isotope (like a void in, null out... or if a BREAK was hit)

&gt;&gt; for-each x (second [c ~]) [
       print "Loop never runs"
   ]
** Error: FOR-EACH does not accept QUASI-VOID as its data argument
</code></pre>
<p>This is a bit more speculative, but I like the general idea that a quoted void could let you have a kind of nothing that gave you the "opt out" ability in places where it could... and quasi void could give you an error, while blank acts like an empty series.  This seems to offer some nice invariants that reduce overall code you have to write handling edge cases.</p>
<hr>
<p><strong>I hope that this all plugs together, <a class="mention" href="/u/rgchris">@rgchris</a>.  Can you review this thread and tell me if I've finally gotten it all to gel for you?</strong></p> ]]></description>
        <link>https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604/3</link>
        <pubDate>Wed, 30 Nov 2022 04:00:22 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6508</guid>
      </item>
      <item>
        <title>The History of Multi-Return in Ren-C</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="12" data-topic="1134">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Casualties of Composability</p>
</blockquote>
</aside>
<p>One point to mention here is that as far as the core protocol goes, there's no names for the individual multi-return outputs.  If we wanted that, we'd have to make it so that if a function returned a "FRAME! isotope" with labeled fields.</p>
<p>This isn't silly vs. returning an OBJECT! by convention in the same way that it's not silly vs. returning a BLOCK! by convention.  You want that single-result default, and then more only if you ask for it.  So there's still a way the first field in the frame could be picked out via a SET-WORD! and the other fields by a SET-BLOCK!; or you could ^META it and access them by name.</p>
<p>It's something to keep in mind, but nothing being done currently rules it out as a future possibility.  The central point is the same--that there's an isotopic bundle that can't be interpreted as something you intend to store in a block or assign to a variable in and of itself.  The isotopic status decays to one item in the bundle in the absence of a specific unpacking intent.</p> ]]></description>
        <link>https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134/13</link>
        <pubDate>Mon, 28 Nov 2022 05:50:11 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6504</guid>
      </item>
      <item>
        <title>The Pending New Meaning of GET-XXX!</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="1901">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1901">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But Like I Said, You Can't Wish Away Complexity...</p>
</blockquote>
</aside>
<p>Indeed you cannot.</p>
</blockquote>
</aside>
<p>Why not? I think you can. It won't work, but you can wish it away.</p> ]]></description>
        <link>https://forum.rebol.info/t/the-pending-new-meaning-of-get-xxx/1901/3</link>
        <pubDate>Sun, 27 Nov 2022 21:09:03 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6503</guid>
      </item>
      <item>
        <title>BLANK! 2022: Revisiting The Datatype</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="7" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>While <strong>~null~</strong> is definitely more verbose than using <strong>_</strong> to null out variables, I'm not entirely sure that nulling out variables needs to be in the scheme of things any more succinct than setting a variable to false</p>
</blockquote>
</aside>
<p>I reverted the blank-evaluates-to-null change and examined all the callsites.  I definitely have some mixed feelings.</p>
<p>Turning <strong><code>_</code></strong> back into a WORD! vs a separate BLANK! type is the only thing that I might see as a reasonable alternative, and then setting it to be null by default, but then settable to anything else in contexts you wanted it.  You could then take it for granted that <strong><code>(x: _)</code></strong> would set X to null just as much as you would be that <strong><code>(x: null)</code></strong> would.</p>
<p>It's tempting to try picking something else to represent nothingness.  What if you could opt-out of a FOR-EACH variable using a lone apostrophe?</p>
<pre><code>&gt;&gt; for-each ' [1 2 3] [print "no variable"]
no variable
no variable
no variable
</code></pre>
<p>It's more slight than <strong><code>for-each _ [1 2 3]</code></strong>, but not awful.  And since voids are used to opt-out in slots it actually dovetails nicely with if the evaluated forms were allowed to opt out via void:</p>
<pre><code>for-each (if false ['x]) [1 2 3] [print "no variable"]
</code></pre>
<p>That seems to make perfect sense.  If your expression produces no iterative variables to bind in the body assume that you didn't need them.  The alternative of <strong><code>(if false ['x] else [_])</code></strong> or even <strong><code>(if false 'x else '_)</code></strong> seems like busywork.</p>
<p>This even would mean you could use <strong><code>()</code></strong> as a less slight alternative, if you didn't like the <strong><code>'</code></strong>  syntax:</p>
<pre><code>for-each () [1 2 3] [print "no variable"]  ; actually pretty nice!
</code></pre>
<p>The premise may hold for multi-returns also:</p>
<pre><code>&gt;&gt; [a ' c]: pack [1 2 3]
== 1

&gt;&gt; c
== 3

&gt;&gt; [a () c]: pack [4 5 6]
== 4

&gt;&gt; c
== 6
</code></pre>
<p>I'm not sure it looks worse than <strong><code>[a _ c]: pack [...]</code></strong>, and would open up:</p>
<pre><code>&gt;&gt; [a _ c]: pack [8 9 10]
== 8

&gt;&gt; _
== 9

&gt;&gt; c
== 10
</code></pre>
<p><em>One potential qualm:</em> a quoted word vs. a regular word is seen as a different instruction by both FOR-EACH and multi-return.  So from a type system perspective it's like you're conflating some meanings of what QUOTED! is supposed to signal when you use an apostrophe vs. a distinct BLANK! type.  e.g. there's no "unquoted void literal", only a quoted one.</p>
<p>In the case of how the mechanics of LET works, this is actually a problem, because the apostrophes escape things it's not supposed to consider part of the LET :-/</p>
<pre><code> let [a 'b]: multi-returner ...
 =&gt;
 let a, [a b]: multi-returner ...  ; just drops the quote level from quoted things

 let [a ' c]: multi-returner ...
 =&gt;
 let [a c], [a ??? c]: multi-returner ...  ; can't drop quote level from lone quote
</code></pre>
<p>Yes, it could say that there's an exception for lone quotes and they stay as is, but it sort of points to the general unease and "weird exceptions" you have to make when the quoted state of void is used to represent something that is only quoted at all because it's "probably not meaningful otherwise".  Just seems to lead to snakey rules that the more-visible blank doesn't require.</p>
<p>Or maybe we just say <strong><code>()</code></strong> is what you use, I don't know.</p>
<pre><code>let [a () c]: multi-returner ...
</code></pre>
<p>Thinking further... today BLANK! is the default used by things like ARRAY but that could have different choices too:</p>
<pre><code>&gt;&gt; array 3
== [' ' ']  ; quoted voids

&gt;&gt; array 3
== [~ ~ ~]  ; isotopic voids

&gt;&gt; array 3
== [# # #]  ; empty tokens
</code></pre>
<p>Of those choices, I'd probably say I like the isotopic voids, just because of how ornery they become when evaluated....and orneryness seems like a good characteristic for when you didn't specify an /INITIAL value to be used.</p>
<p>But just because we would return <strong>_</strong> to the WORD! pool... would making it defined to evaluate to a null isotope be a good thing?  People might want it for other purposes (consider things like the <a href="https://underscorejs.org/">underscore.js library</a>, where it's the name of a utility module that tries to disappear).</p>
<pre><code>&gt;&gt; _: import %my-utility-lib.r

&gt;&gt; _.sum [1020 304]
== 1234
</code></pre>
<p>If you're going to open <strong>_</strong> up for potentially interesting purposes, but then turn around and say everyone assumes it evaluates to null, then I'm not clear that the ability to redefine it is as much a benefit as a potential nuisance.  <img src="https://forum.rebol.info/images/emoji/twitter/angry.png?v=9" title=":angry:" class="emoji" alt=":angry:"></p>
<p><strong>Beyond the above arguments, having a special type to serve as BLANK! in PATH!s is kind of a killer case, which makes reserving it as an inert dialecting part that is used as a "spacer" as well as potentially meaning just "space" makes the most sense to me.</strong></p> ]]></description>
        <link>https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942/8</link>
        <pubDate>Sun, 27 Nov 2022 13:01:57 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6502</guid>
      </item>
  </channel>
</rss>

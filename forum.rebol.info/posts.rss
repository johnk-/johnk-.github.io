<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest posts</title>
    <link>https://forum.rebol.info</link>
    <description>Latest posts</description>
      <item>
        <title>RE: The Ordering and Priorities of the Ren-C Project</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="bradrn" data-post="6" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/speed-of-uparse/2177/6">Speed of UPARSE</a>
</div>
<blockquote>
<p>Remember, I come from well outside the Rebol world.</p>
</blockquote>
</aside>
<p>Yes, though also remember... <img src="https://forum.rebol.info/images/emoji/twitter/warning.png?v=12" title=":warning:" class="emoji" alt=":warning:" loading="lazy" width="20" height="20">  I'm not advertising anything here...not fit for any purpose, or any use!</p>
<p>(I also didn't make this forum.  That was done by <a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a>, and I initially protested it as something that would fall in my lap as yet-another-maintenance-headache.  But I found Discourse could be a rather good notebook, with easy wiki-like reorganization features to mean the site wouldn't wind up stale and useless.  So I ended up embracing it.)</p>
<aside class="quote no-group quote-modified" data-username="bradrn" data-post="6" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/speed-of-uparse/2177/6">Speed of UPARSE</a>
</div>
<blockquote>
<p>The reason I don’t understand is, to a large extent, because this way of reasoning about code is one I’ve never seen before in my life.</p>
</blockquote>
</aside>
<p>I first met Carl Sassenrath at a party in Los Angeles.  Rebol was not open source at the time. I'm a pretty big believer in Stallman's <a href="https://www.gnu.org/philosophy/shouldbefree.en.html">"Why Software Should Be Free"</a></p>
<p><em>(I also believe FSF should flip the acronym as "Foundation for Software Freedom", and that generally "Freedom" should be used where "Free" creates many confusions with "Gratis".  But Stallman's idealism/autism makes him convinced that retaking the term "Free" to mean "Freedom" is so inherently logical that putting his thumb on the scale will change how everyone else hears the word.)</em></p>
<p>Carl had resisted open-sourcing Rebol.  Over whiskey at the party's open bar, I lobbied him on the inevitability of developer tools as open source, and that closed-source couldn't be profitable.  Much more profit would be opened up by being a steward of a successful open source project.</p>
<p>He said he didn't keep it closed-source to make money, rather that he <em>"didn't want anybody messing with his art."</em>  Rebol was his "grand experiment" and he had very specific opinions about what was or wasn't an improvement of it.</p>
<p>Eventually it was open sourced.  He came to face the fact he wasn't going to be able to deliver Rebol 3 himself, in the time he had, with the methods he'd been using.  He wanted to move on with other things (went to work for Roku, on embedded-C products, closer to his EE background).  So now it's in the hands of others.</p>
<p>While Carl and I may disagree about what exactly the artistic vision is, we do agree that it is an art... the medium is unique... and driven by a certain <em>je ne sais quoi</em> of what makes a good or bad decision.  A big part of what we both believe is that dependency control is critical, and that a useful implementation can be made and understood without requiring a very advanced toolchain (and that the substrate not be intrinsically obfuscating, <a href="https://arstechnica.com/security/2024/04/what-we-know-about-the-xz-utils-backdoor-that-almost-infected-the-world/">see recent xz hack</a> for how important this all is).</p>
<p>The time I can put into the project is not infinite...and I haven't had much time in March (and will likely not have a whole lot in April, either).  And I am a semi-retired person who is not paid to do this, so I heavily prioritize whether I'm having fun or not.  It can be a real slog at times, and if a novel mechanism doesn't pop up every now and then to renew my interest...I can lose motivation.</p>
<p>I'm grateful that this year started off with cracking some of the rationale for how binding has to work, so thank you for your contributions to that!  It gave a boost and a renewed faith that good-enough answers are possible.  I've been letting that settle a bit, and sometimes these things take time to shake out vs. being able to finish the design all at one time.  So I work on other things--sometimes just what interests me--while experience is gathered to realize where to point the big design questions.</p>
<p>But I don't expect anything to happen overnight.  This has been a long haul project which needs a marathon mentality, and so patience is mandatory.</p> ]]></description>
        <link>https://forum.rebol.info/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179#post_2</link>
        <pubDate>Tue, 09 Apr 2024 13:19:16 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7285</guid>
      </item>
      <item>
        <title>RE: The Ordering and Priorities of the Ren-C Project</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="5" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/speed-of-uparse/2177/5">Speed of UPARSE</a>
</div>
<blockquote>
<aside class="quote no-group" data-username="bradrn" data-post="4" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/speed-of-uparse/2177/4">Speed of UPARSE</a>
</div>
<blockquote>
<p>I’ll be blunt: this, to me, sounds unusably slow. Beyond the very simplest tasks, I can’t imagine a situation where I’d deliberately choose to take a 250× performance drop.</p>
</blockquote>
</aside>
<p>This is a first-of-its-kind design. And if you don't understand why I'm building things the way I'm building them, then...to be blunt...there's not much point in me listening to your feedback regarding the order in which I do things.</p>
</blockquote>
</aside>
<p>Remember, I come from well outside the Rebol world. The reason I don’t understand is, to a large extent, because this way of reasoning about code is one I’ve never seen before in my life. This is the reason I’m asking so many questions, setting out my opinions, and having these discussions with you… precisely so that I can begin to understand why it is that way.</p> ]]></description>
        <link>https://forum.rebol.info/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179#post_1</link>
        <pubDate>Sat, 06 Apr 2024 19:16:35 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7284</guid>
      </item>
      <item>
        <title>Double Negation in PARSE is NOT NOT NOT Cool</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="Brett" data-post="9" data-topic="1536">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/brett/40/177_2.png" class="avatar"> Brett:</div>
<blockquote>
<p><code>; Yen is in whole numbers.</code></p>
</blockquote>
</aside>
<p>You keep your money in Yen?  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<aside class="quote no-group" data-username="Brett" data-post="9" data-topic="1536">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/brett/40/177_2.png" class="avatar"> Brett:</div>
<blockquote>
<p>I guess UPARSE wouldn't have that problem if an <code>UNLESS</code> took some of the role of <code>NOT</code>.</p>
</blockquote>
</aside>
<p>I don't know that people would comprehend the difference between UNLESS vs. NOT.</p>
<p>If we're looking for uniform operators, it seems there are NOT-AHEAD and ONE-IF-NOT-AHEAD, where ONE-IF-NOT-AHEAD simply takes the next single item if the rule doesn't match:</p>
<pre><code>&gt;&gt; parse ["a"] [one-if-not-ahead [integer! integer!]]
== "a"
</code></pre>
<p>This ONE-IF-NOT-AHEAD operator is kind of clunky, though similar to how SET works in Rebol2/Red, to take the first item of a match (vs UPARSE's last synthesized product of "a block combinator").</p>
<pre><code>rebol2&gt;&gt; parse ["a" "b"] [set x [string! string!]]
== true

rebol2&gt;&gt; x
== "a"
</code></pre>
<p><strong>one-if-not-ahead rule</strong> is simply <strong>[not-ahead rule, one]</strong> (in the current <a href="https://forum.rebol.info/t/killing-off-historical-skip-in-parse/1557/15">ONE-is-historical-SKIP</a> model)</p>
<p>It would work with anything... but I'd personally rather have a NOT that wasn't compatible with everything, but covered common cases.  And if someone actually wanted ONE-IF-NOT-AHEAD they could write <strong>[not ahead rule, one]</strong> for themselves.</p>
<aside class="quote no-group" data-username="bradrn" data-post="8" data-topic="1536">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I’m still not sure I see why NOT should exist as its own combinator.</p>
</blockquote>
</aside>
<p>It wouldn't really be a combinator, but a "combinator modifier".</p>
<p>Let me reiterate it's simply about being able to pass a refinement to combinators, even if they are triggered by a datatype and hence nowhere to put the refinement.</p>
<p>e.g. you can write <strong><code>ahead/not</code></strong> but you can't write <strong><code>#a/not</code></strong></p>
<p>I think <strong><code>not *combinator*</code></strong> being able to do this modification is a cool idea.</p>
<p>Though of course allowing general "combinator modifiers" creates a lot of obfuscations, due to the backchannel.  If I'm trying to make a debugger, then these refinements slipping in have to be presented somehow... otherwise once you've stepped into the <strong>not</strong> and all you see is <strong><span class="hashtag">#a</span></strong> it will be confusing when <strong><span class="hashtag">#b</span></strong> looks to be a match of <strong><span class="hashtag">#a</span></strong>.</p>
<p>Maybe negation is the <em>only</em> combinator modifier, so the system can account for it.</p>
<h2>
<a name="conservative-choice-for-now-1" class="anchor" href="https://forum.rebol.info#conservative-choice-for-now-1"></a>Conservative Choice For Now</h2>
<p>A conservative thing to do may just be to rename NOT as NOT-AHEAD and work on higher priority tasks.</p> ]]></description>
        <link>https://forum.rebol.info/t/double-negation-in-parse-is-not-not-not-cool/1536#post_10</link>
        <pubDate>Wed, 03 Apr 2024 07:56:08 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7283</guid>
      </item>
      <item>
        <title>Double Negation in PARSE is NOT NOT NOT Cool</title>
        <dc:creator><![CDATA[@Brett]]></dc:creator>
        <description><![CDATA[ <p>In case it's of relevance or interest..</p>
<p>In Rebol 2 parse does not have a not, so <code>parsing-unless</code> is the function I use to implement the guard behaviour of <code>not ahead</code>.  I use it a lot, like in this code to parse the adhoc syntax of my bank account transactions:</p>
<pre><code>fxamt: [opt sp some digit opt [#"." some digit] sp cur-code] ; Yen is in whole numbers.
not-fxamt: parsing-unless [fxamt]
not-br: parsing-unless [{&lt;BR&gt;}]
nsp: complement charset { }

loc-word: [not-fxamt some [not-br nsp]]
</code></pre>
<p>So the <code>nsp</code> here is indeed a <code>some not space</code> in the positive sense. I use that a lot too but for my complex rules for me in Rebol 2 it will be some <code>[not-thing skip]</code></p>
<p>I do use the two senses a lot in practice:</p>
<ul>
<li>the negative/guard sense - I'm guarding the rest of the rule with the negated result of the match - the "unless".</li>
<li>the positive sense - I want the positive match of something that isn't the thing.</li>
</ul>
<p>The wrinkle I've had with guard rules is when I'm using some <a href="http://www.rebol.org/documentation.r?script=load-parse-tree.r">routine</a> that collects the input matched by rules that succeed - the guard rules succeed but I don't want their matching input (even if empty). For example, if I specified that I want to collect FXAMT then my routine will match when the <code>fxamt</code> inside <code>not-fxamt</code> succeeds.  My simple workaround is to create another rule with the same structure but different name.  I guess UPARSE wouldn't have that problem if an <code>UNLESS</code> took some of the role of <code>NOT</code>.</p> ]]></description>
        <link>https://forum.rebol.info/t/double-negation-in-parse-is-not-not-not-cool/1536#post_9</link>
        <pubDate>Sun, 31 Mar 2024 04:16:24 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7282</guid>
      </item>
      <item>
        <title>Speed of UPARSE</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Rules of program optimization:</p>
<ol>
<li>Don't do it.</li>
<li>(Experts Only) Don't do it... yet.</li>
</ol>
</blockquote>
</aside>
<p>And that’s how you end up with slow software!</p>
<p>To make myself entirely clear, this is certainly a position I can sympathise with. My main language is Haskell, which is difficult to optimise, so often I don’t bother. But Haskell still makes it <em>possible</em> to write fast programs, and eventually there comes a time when I do need to dig into the internals and speed up my code. It’s hard, but certainly worth the effort.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But to give you a sense of the tip of the iceberg: UPARSE uses raised ERROR! object antiforms on each unsuccessful match. This means that other values are "in-band" as potential synthesized combinator results (including packs). But it also means that for a combinator to fail, it has to make an object.</p>
</blockquote>
</aside>
<p>This is interesting… to me, this sounds more like an issue with the interpreter being too slow, rather than UPARSE itself. What makes objects so slow to construct?</p>
<aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Perhaps it's time for you to get your hands dirty and read to understand what UPARSE is doing in terms of how it is implemented</p>
</blockquote>
</aside>
<p>I have been doing so, on and off, when I get the time. It’s difficult code to understand, and I can’t say I understand precisely how it works yet, but I do at least have some vague idea of what the major components are.</p> ]]></description>
        <link>https://forum.rebol.info/t/speed-of-uparse/2177#post_6</link>
        <pubDate>Sat, 30 Mar 2024 14:56:44 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7281</guid>
      </item>
      <item>
        <title>Speed of UPARSE</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="4" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>UPARSE is such a key part of Ren-C that I think time spent optimising it would be time well spent.</p>
</blockquote>
</aside>
<p>UPARSE is a flagship dialect, where getting the design correct--including making sure all the necessary infrastructure for debug stepping and proper error delivery--is time well spent...</p>
<p>Rules of program optimization:</p>
<ol>
<li>Don't do it.</li>
<li>(Experts Only) Don't do it... yet.</li>
</ol>
<aside class="quote no-group" data-username="bradrn" data-post="4" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I’m wondering, then… to what extent would it be possible to optimise it without nativising? It would be very interesting to see how far we could get with just Ren-C.</p>
</blockquote>
</aside>
<p>Optimizing before nativizing is certainly a good first pass.</p>
<p>But to give you a sense of the tip of the iceberg: UPARSE uses raised ERROR! object antiforms on each unsuccessful match.  This means that other values are "in-band" as potential synthesized combinator results (including packs).  But it also means that for a combinator to fail, it has to make an object.</p>
<p>It is possible for the objects to be created once and then reused, but that wouldn't permit parametrization.  An error can say "didn't match" or it can say "didn't match the character <span class="hashtag">#a</span>" with a parameter, and the latter is more informative.</p>
<p>Generating an error object isn't particularly cheap, even natively.  And if you look at the usermode RAISE function <em>(was FAIL, which is now built on top of RAISE, so comments a bit out of date there)</em>, you can see that the process for going from a text string to an error isn't trivial:</p>
<p><a href="https://github.com/metaeducation/ren-c/blob/d8212c6d2de996f33f2142ebce40c328088f24bf/src/mezz/base-funcs.r#L777" class="inline-onebox">ren-c/src/mezz/base-funcs.r at d8212c6d2de996f33f2142ebce40c328088f24bf · metaeducation/ren-c · GitHub</a></p>
<p>Does this mean that the concept to use custom raised errors as a signal for parser mismatching is fundamentally flawed?  I don't think so.  As I say, this is a flagship for exploring the concepts of what's possible in the medium.  It's supposed to have the bells and the whistles and show what you can really accomplish if you stretch.</p>
<p>Making a crappier version of UPARSE that cheaps out on features and can't be stepwise debugged will be a trivial exercise for those who want to do it.  Red has every opportunity to go after the market of people who thirst for that school of thought.  I'm happy to let them.</p>
<aside class="quote no-group" data-username="bradrn" data-post="4" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I’ll be blunt: this, to me, sounds unusably slow. Beyond the very simplest tasks, I can’t imagine a situation where I’d deliberately choose to take a 250× performance drop.</p>
</blockquote>
</aside>
<p>Perhaps it's time for you to get your hands dirty and read to understand what UPARSE is doing in terms of how it is implemented, to get a sense of the kinds of power I'm trying to put in the hands of people using a new kind of technology...and why I'm interested in this kind of prototyping ability regardless of its initial costs.</p>
<p>This is a first-of-its-kind design.  And if you don't understand why I'm building things the way I'm building them, then...to be blunt...there's not much point in me listening to your feedback regarding the order in which I do things.</p> ]]></description>
        <link>https://forum.rebol.info/t/speed-of-uparse/2177#post_5</link>
        <pubDate>Sat, 30 Mar 2024 14:22:05 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7280</guid>
      </item>
      <item>
        <title>Speed of UPARSE</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>I’m wondering, then… to what extent would it be possible to optimise it without nativising? It would be very interesting to see how far we could get with just Ren-C.</p>
<p>(Of course, it’s perfectly possible to get good performance by writing the important bits in a fast language — it’s what Python does. But I have a great dislike of Python, and this is one of the reasons why.)</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Several orders of magnitude slower. When I first tinkered with nativizing it, it was about 700x slower just on some arbitrary case:</p>
<p><a href="https://forum.rebol.info/t/progress-on-nativizing-parser-combinators/1636">Progress on Nativizing Parser Combinators</a></p>
<p>But, an hour of tinkering at the time got it to 250x slower.</p>
</blockquote>
</aside>
<p>I’ll be blunt: this, to me, sounds unusably slow. Beyond the very simplest tasks, I can’t imagine a situation where I’d deliberately choose to take a 250× performance drop. UPARSE is such a key part of Ren-C that I think time spent optimising it would be time well spent.</p> ]]></description>
        <link>https://forum.rebol.info/t/speed-of-uparse/2177#post_4</link>
        <pubDate>Sat, 30 Mar 2024 01:31:32 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7279</guid>
      </item>
      <item>
        <title>Should SET-WORD!s Propagate Undecayed Packs?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Packs are antiform blocks, which decay if not specifically handled.</p>
<pre><code>&gt;&gt; pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; a: pack [1 2]
== 1

&gt;&gt; a
== 1
</code></pre>
<p>From time to time, I've wondered if there's a good reason why the plain SET-WORD! shouldn't propagate the pack:</p>
<pre><code>&gt;&gt; a: pack [1 2]
== ~['1 '2]~  ; anti  (hypothetical)

&gt;&gt; a
== 1
</code></pre>
<p>One rationale is that intuitively, <strong>a:</strong> should be a synonym for <strong>[a]:</strong>, e.g. "unpack one item" is implicit.</p>
<p>But that just bumps the question to the next one we might ask: why doesn't a multi-return without a "circled" result just evaluate to the whole pack?</p>
<p>It looks to make some sense at first, it allows you to chain indefinitely:</p>
<pre><code>&gt;&gt; [a b]: [c d]: pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; a
== 1

&gt;&gt; b
== 2

&gt;&gt; c
== 1

&gt;&gt; d
== 2
</code></pre>
<p>Though it feels a little bit unsettling when you drop it down:</p>
<pre><code>&gt;&gt; [a b]: [c]: pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; a
== 1

&gt;&gt; b
== 2

&gt;&gt; c
== 1
</code></pre>
<p>But we could argue that if you're bothered, then you use circling (currently <code>@c</code>, but with FENCE! proposed to be <code>{c}</code>).  Note in the below example you'd have to use <code>/b</code> in order to indicate you were okay with unpacking more values than available.</p>
<pre><code>&gt;&gt; [a /b]: [{c}]: pack [1 2]
== 1

&gt;&gt; a
== 1

&gt;&gt; b
== ~null~  ; anti

&gt;&gt; c
== 1
</code></pre>
<p>We could then make a choice if <strong>a:</strong> was a synonym for <strong>[a]:</strong> or for <strong>[{a}]:</strong></p>
<h2>
<a name="most-recent-motivation-for-thinking-about-this-1" class="anchor" href="https://forum.rebol.info#most-recent-motivation-for-thinking-about-this-1"></a>Most Recent Motivation For Thinking About This</h2>
<p>I rewrote <a href="https://forum.rebol.info/t/speed-of-uparse/2177/3">some code in an example</a> from this:</p>
<pre><code>[^result' remainder]: parser input except e -&gt; [
    remainder: input  ; succeed on parser fail but don't advance input
    return null
]
return unmeta result'  ; return successful parser result
</code></pre>
<p>...to this:</p>
<pre><code>return [@ remainder]: parser input except [
    remainder: input  ; succeed on parser fail but don't advance input
    return null
]
</code></pre>
<p>The idea is that the parser being called has multiple return results... the first is the synthesized value, the second is the amount it advanced.  <em>(There's a third result on some parsers of "pending items", but this OPTIONAL combinator has an "autopipe" which is just bubbling the pending items through in the order of successful parsers called...so the third result is specialized out on its interface and on the parsers it calls.)</em></p>
<p><strong>However, the synthesized value can itself be a pack.</strong>  This means that if we named a variable in the slot where the <code>@</code> is, then that pack would be decayed to store in the variable unless we used a ^META result.</p>
<p>So does the act of not-naming and just circling subvert the decay?  Or should the circled result not be decayed even if the variable is?</p>
<pre><code>&gt;&gt; [{a} b]: pack [pack [1 2] 3]
== ~['1 '2]~  ; anti  (or should it be decayed to 1?)

&gt;&gt; a
== 1

&gt;&gt; b
== 3
</code></pre>
<p>It's a different--but related--question.  It seems it should align with the behavior of plain assignments:</p>
<pre><code>&gt;&gt; a: pack [1 2]
== ~['1 '2]~  ; anti  (implied if the above behavior is chosen)

&gt;&gt; a
== 1
</code></pre>
<h2>
<a name="not-100-certain-but-i-think-undecayed-propagation-is-good-2" class="anchor" href="https://forum.rebol.info#not-100-certain-but-i-think-undecayed-propagation-is-good-2"></a>Not 100% Certain, But I Think Undecayed Propagation Is Good</h2>
<p>I'll point out that it's possible to DECAY things pretty easily, but you can't recover a pack after it has been decayed.</p>
<p>So I'm getting the feeling that it's probably best to decay the assignments, but propagate the undecayed pack.  It looks like the more general and useful behavior...even if it seems a bit confusing.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-set-word-s-propagate-undecayed-packs/2178#post_1</link>
        <pubDate>Fri, 29 Mar 2024 21:22:15 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7278</guid>
      </item>
      <item>
        <title>Speed of UPARSE</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre><code class="lang-plaintext">'optional combinator [
    "If applying parser fails, succeed and return NULL; don't advance input"
    return: "PARSER's result if it succeeds, otherwise NULL"
        [any-value? pack?]
    parser [action?]
    &lt;local&gt; result'
][
    [^result' remainder]: parser input except e -&gt; [
        remainder: input  ; succeed on parser fail but don't advance input
        return null
    ]
    return unmeta result'  ; return successful parser result
]
</code></pre>
</blockquote>
</aside>
<p>Speaking of optimizations, this doesn't even need the <strong>result'</strong> temporary.  Nor does it care what the raised error is, so the branch doesn't need to be a lambda:</p>
<pre><code>return [@ remainder]: parser input except [
    remainder: input  ; succeed on parser fail but don't advance input
    return null
]
</code></pre>
<p><em>(Truly being equivalent <a href="https://forum.rebol.info/t/should-set-word-s-propagate-undecayed-packs/2178">requires the @ to not decay synthesized pack results</a>, which should possibly be the same behavior you get if you'd named a variable, I need to look into this.)</em></p>
<p>Instead of a preemptive RETURN inside a RETURN, you could write that instead so the branch gives back the result and remainder as a pack (antiform block):</p>
<pre><code>return [@ remainder]: parser input except [
    pack [null input]
]
</code></pre>
<p>But I happen to be certain that would be slower... you pay to reduce <strong>[null input]</strong>, and then you have to pay for SET-BLOCK! to unpack the multi-return.</p>
<p>Neat as all that is (and I think it <em>is</em> neat), worrying over such details isn't really where I want to focus right now.</p>
<hr>
<p><em>Note that usermode micro-optimization can get fairly crazy, e.g. you know that NULL needs to do a WORD! lookup to fetch the value of NULL... but the quasiform <code>~null~</code> has a rote evaluative rule of just setting the quote byte of the quasiform from 2 to 0 to be an antiform... so <strong><code>return ~null~</code></strong> is faster than <strong><code>return null</code></strong>.  Many historical Rebol programmers were obsessed with this kind of detail...</em></p> ]]></description>
        <link>https://forum.rebol.info/t/speed-of-uparse/2177#post_3</link>
        <pubDate>Fri, 29 Mar 2024 14:38:32 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7277</guid>
      </item>
      <item>
        <title>Speed of UPARSE</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Several orders of magnitude slower.  When I first tinkered with nativizing it, it was about 700x slower just on some arbitrary case:</p>
<p><a href="https://forum.rebol.info/t/progress-on-nativizing-parser-combinators/1636" class="inline-onebox">Progress on Nativizing Parser Combinators</a></p>
<p>But, an hour of tinkering at the time got it to 250x slower.</p>
<p>However, predictably that tinkering was quickly out of date, so that early nativization is inactive.  Things aren't set up to maintain nativized code in parallel to the usermode code, and it would be too much work to be justified until fully stable.</p>
<p>The baseline will be even slower today... because binding is slower, and because there's more hooking in it which was added for the <a href="https://forum.rebol.info/t/replpad-visual-parse-debugger/2063">debugging demo</a>.</p>
<p>If you watch the debugging video, it explains that the debugger works because each call to a combinated parser can be hooked... such that the hook is responsible for invoking the frame.  It can inspect the frame beforehand, and examine the multi-return result after it does the invocation.  (Or it can skip the invocation entirely, or duplicate the frame and invoke it twice, or mutate the frame before it runs it, etc.)  Each combinator just directly calls its subparser, but the subparser has been ENCLOSE'd with a wrapper:</p>
<pre><code> wrapper: func [
    "Enclosing function for hooking all combinators"
    return: [pack?]
    f [frame!]
][
    return either f.state.hook [
        run f.state.hook f
    ][
        run f
    ]
]
</code></pre>
<p>So that's overhead on each call to a parser that any other parser makes.  Of course the pattern of <strong><code>enclose :combinator :wrapper</code></strong> itself could be partially nativized in a semi-generic way, as something like:</p>
<pre><code>hookify :combinator 'f [f.state.hook]
</code></pre>
<p>But these things are patterns which should inform how to design the system in a more general sense.  I am trying to get some kind of story together for how dialects are debugged... as I've said, it's sort of like you make a choice if you want to take "assembly level stepping" (e.g. debug the Rebol instructions) or if you want to debug at the higher level of the dialect.  So I expect this hook to be a sunk cost of some kind.</p>
<p>Right now I'm doing other things, though <em>(as well as non-Rebol-related life stuff, which is going to mean Rebol development will get a bit more sporadic than it was in the first couple of months of the year.)</em></p>
<h2>
<a name="nativizing-plan-1" class="anchor" href="https://forum.rebol.info#nativizing-plan-1"></a>Nativizing Plan</h2>
<p>Ultimately, what I plan to do is make it so that all the combinators are in their own C files, where the usermode form is in a comment, something like:</p>
<pre><code>//
// File: %src/core/parse/optional-combinator.c
//

/* &lt;BEGIN USERMODE COMBINATOR&gt;

'optional combinator [
    "If applying parser fails, succeed and return NULL; don't advance input"
    return: "PARSER's result if it succeeds, otherwise NULL"
        [any-value? pack?]
    parser [action?]
    &lt;local&gt; result'
][
    [^result' remainder]: parser input except e -&gt; [
        remainder: input  ; succeed on parser fail but don't advance input
        return null
    ]
    return unmeta result'  ; return successful parser result
]

&lt;/END USERMODE COMBINATOR&gt; */

//
//  optional-combinator: native/combinator [
//
//  "If applying parser fails, succeed and return NULL; don't advance input"
//
//      return: "PARSER's result if it succeeds, otherwise NULL"
//          [any-value? pack?]
//      parser [action?]
//  ]
//
DECLARE_NATIVE(optional_combinator)
{
    INCLUDE_PARAMS_OF_OPTIONAL_COMBINATOR;

    Value* remainder = ARG(remainder);  // output (combinator implicit)

    Value* input = ARG(input);  // combinator implicit
    Value* parser = ARG(parser);
    UNUSED(ARG(state));  // combinator implicit

    enum {
        ST_OPT_COMBINATOR_INITIAL_ENTRY = STATE_0,
        ST_OPT_COMBINATOR_RUNNING_PARSER
    };

    switch (STATE) {
      case ST_OPT_COMBINATOR_INITIAL_ENTRY :
        goto initial_entry;

      case ST_OPT_COMBINATOR_RUNNING_PARSER :
        goto parser_result_in_out;

      default : assert(false);
    }

  initial_entry: {  //////////////////////////////////////////////////////////

    Push_Parser_Sublevel(OUT, remainder, parser, input);

    STATE = ST_OPT_COMBINATOR_RUNNING_PARSER;
    return CATCH_CONTINUE_SUBLEVEL(SUBLEVEL);

} parser_result_in_out: {  ///////////////////////////////////////////////////

    if (not Is_Raised(OUT))  // parser succeeded...
        return OUT;  // so return its result

    Set_Var_May_Fail(remainder, SPECIFIED, input);  // convey no progress made
    return Init_Nulled(OUT);  // null result
}}
</code></pre>
<p>This way the two can be maintained in parallel, and a debug mode could switch between them to make sure they produce identical results in the tests.</p> ]]></description>
        <link>https://forum.rebol.info/t/speed-of-uparse/2177#post_2</link>
        <pubDate>Fri, 29 Mar 2024 14:34:36 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7276</guid>
      </item>
      <item>
        <title>Speed of UPARSE</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>I’m just wondering if any benchmarking has been done on UPARSE. How does it compare to PARSE in Red or in Rebol? Or to parser combinators in Haskell? For that matter, how does it compare to an ordinary recursive-descent parser handwritten in Ren-C?</p>
<p>(Yes, I know UPARSE is unoptimised and slow. But it would be interesting to know <em>how</em> slow.)</p> ]]></description>
        <link>https://forum.rebol.info/t/speed-of-uparse/2177#post_1</link>
        <pubDate>Fri, 29 Mar 2024 06:47:47 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7275</guid>
      </item>
      <item>
        <title>VOID Branches (not branches that evaluate to void)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I've mentioned before that <a href="https://forum.rebol.info/t/augment-add-parameters-and-refinements-after-the-fact/1216">AUGMENT can be used to implement the legacy SWITCH/DEFAULT behavior</a>.</p>
<p>But looking at what seems like the "correct" formulation of that code today, we get:</p>
<pre><code>switch-d: enclose (augment :switch [
    /default "Default case if no others are found"
        [block!]
]) lambda [f [frame!]] [
    let def: f.default
    eval f else (maybe def)
]
</code></pre>
<p>It points out the existence of <em>void branches</em>... so not branches that evaluate to void (e.g. <code>[void]</code>) but code that evaluates to a branch to run, and that branch is void.</p>
<p>Considering this specific usage only, it suggests a semantic for ELSE of a VOID branch, which is that you want it to act like there was no branch at all.  e.g. as if you'd written just <strong><code>eval f</code></strong> with no ELSE.</p>
<pre><code> &gt;&gt; if false [1 + 2]
 == ~void~  ; anti

 &gt;&gt; if false [1 + 2] else [10 + 20]
 == 30

 &gt;&gt; if false [1 + 2] else (void)
 == ~void~  ; anti
</code></pre>
<p>Would the same apply to THEN?</p>
<pre><code> &gt;&gt; if true [1 + 2]
 == 3

 &gt;&gt; if true [1 + 2] then [10 + 20]
 == 30

 &gt;&gt; if true [1 + 2] then (void)
 == 3
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>I don't know if it's great, but it's certainly better than evaluating to NULL (via some void-in-null-out rationale) because that would trigger an ELSE branch.</p>
<pre><code> &gt;&gt; if true [1 + 2] then (void) else [print "we don't want this."]
 we don't want this.
</code></pre>
<p>But what should other branching constructs do, like CASE or SWITCH?  Might a void branch suggest "opting out" of that particular branch?</p>
<pre><code> case [
     1 &lt; 2 (void)
     3 &lt; 4 [print "Should this run?"]
 ]
</code></pre>
<p>A CASE (at least CASE/ALL) is supposed to be synonymous with a series of IF statements.  And IF can't exactly do that, unless it decided to be NIHIL...</p>
<pre><code>&gt;&gt; 1 + 2 if false (void)
== 3
</code></pre>
<p>That would be a bit weird, but, it does sort of parallel what happens when ELSE and THEN effectively vaporize themselves.</p>
<p>As with most things on the edge of usefulness, I don't know about this... other than the situation of wanting to revoke the ELSE branch in SWITCH-D.  I'll keep an eye on it.</p> ]]></description>
        <link>https://forum.rebol.info/t/void-branches-not-branches-that-evaluate-to-void/2176#post_1</link>
        <pubDate>Thu, 28 Mar 2024 13:07:17 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7274</guid>
      </item>
      <item>
        <title>Double Negation in PARSE is NOT NOT NOT Cool</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>I’m still not sure I see why NOT should exist as its own combinator. The disadvantages seem to outweigh the disadvantages: it adds a lot of complexity, and as you note there’s some cases where it doesn’t even seem to make sense.</p> ]]></description>
        <link>https://forum.rebol.info/t/double-negation-in-parse-is-not-not-not-cool/1536#post_8</link>
        <pubDate>Tue, 26 Mar 2024 02:32:29 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7273</guid>
      </item>
      <item>
        <title>Double Negation in PARSE is NOT NOT NOT Cool</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="1536">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So my main concern is just the mechanics:</p>
</blockquote>
</aside>
<p>One observation is that it probably breaks the ability to take any isolated rule and put it in a BLOCK!, since the block combinator isn't generically negatable.</p>
<p>So <strong><code>not [integer!]</code></strong> wouldn't work, when <strong><code>not integer!</code></strong> would.</p>
<p>I don't know that trying to special case it works.  e.g. hacking it up to do <strong><code>not [integer! | word!]</code></strong>.  That case may seem to work, but what if you mixed concepts of negation... like <strong><code>not [integer! | ahead word!]</code></strong> ?</p>
<p>It's sort of like I said: that NOT becomes a way to slipstream a refinement into a single combinator for its meaning of negation.  You can't do that with a composite rule.</p> ]]></description>
        <link>https://forum.rebol.info/t/double-negation-in-parse-is-not-not-not-cool/1536#post_7</link>
        <pubDate>Tue, 26 Mar 2024 02:13:54 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7272</guid>
      </item>
      <item>
        <title>Double Negation in PARSE is NOT NOT NOT Cool</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="5" data-topic="1536">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>But then there’s the other problem I mentioned: what if you <em>do</em> want to invert the parser’s failure state?</p>
</blockquote>
</aside>
<p>I think that's covered well enough by NOT AHEAD.</p>
<p>AHEAD is a nice generic combinator for <em>"take your combinated parser argument, apply it, but don't advance the input (or apply any 'pending' effects).  just stop the match if it didn't succeed, or continue if it did."</em></p>
<p>So having NOT AHEAD be the implementation of NOT-FOLLOWED-BY feels good.</p>
<aside class="quote no-group" data-username="bradrn" data-post="5" data-topic="1536">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I see no particular reason to merge all these things under a single NOT combinator.</p>
</blockquote>
</aside>
<p>I like the brevity, and it feels "English-like" to me to be context-sensitive.</p>
<pre><code>&gt;&gt; parse ["a"] [not ahead integer!, text!]
== "a"

&gt;&gt; parse ["a"] [not integer!]
== "a"

&gt;&gt; parse ["a"] [not some integer!]
** Error: SOME combinator cannot be negated with NOT
</code></pre>
<p>So my main concern is just the mechanics: does it break something interesting.  (And as usual I'm suggesting it before actually trying it, which means I do not know if I will hit a contradiction while implementing it.)</p> ]]></description>
        <link>https://forum.rebol.info/t/double-negation-in-parse-is-not-not-not-cool/1536#post_6</link>
        <pubDate>Sun, 24 Mar 2024 05:50:46 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7271</guid>
      </item>
      <item>
        <title>Double Negation in PARSE is NOT NOT NOT Cool</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1536">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>A little touchy-feely perhaps that each parser can decide if there's a meaning to its negation (or if negation has no meaning at all) as opposed to something that has to be black-box decided from the parameterized parser's result. But it seems learnable to me.</p>
</blockquote>
</aside>
<p>But then there’s the other problem I mentioned: what if you <em>do</em> want to invert the parser’s failure state? For instance, in <a href="https://github.com/bradrn/brassica/blob/b627a345043760a3b403bdbacf0c56c47f7ca992/src/Brassica/SoundChange/Parse.hs#L218">this parser</a> I used <code>notFollowedBy (symbol "//")</code> to match only the case with a single slash. But if <code>not "/"</code> instead matches anything except for <code>"/"</code>, then that leaves me no easy way to get that logic.</p>
<p>I think the cleanest design here would be to recognise that there’s two very different cases here, and therefore treat them differently:</p>
<ul>
<li>The ‘fail on success’ logic can apply to any other combinator, so give it its own dedicated name, like NOT-FOLLOWED-BY or something. (That name’s verbose, but this combinator is uncommon, so it wouldn’t matter a huge amount.)</li>
<li>Other meanings of ‘negation’ are essentially parser-specific, so treat them as refinements for the individual parsers, like AHEAD/NOT. Characters can’t be refined, so we could make a new combinator for them (call it something like EXCEPT-FOR). I see no particular reason to merge all these things under a single NOT combinator.</li>
</ul> ]]></description>
        <link>https://forum.rebol.info/t/double-negation-in-parse-is-not-not-not-cool/1536#post_5</link>
        <pubDate>Sun, 24 Mar 2024 05:46:34 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7270</guid>
      </item>
      <item>
        <title>Double Negation in PARSE is NOT NOT NOT Cool</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="3" data-topic="1536">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>But especially the last quoted paragraph seems to be conflating them. It sounds like you want NOT to sometimes invert the failure state, and sometimes change the characters that are matched. That strikes me as possibly being quite difficult to reason about.</p>
</blockquote>
</aside>
<p>You're more or less giving some parsers a refinement.  So AHEAD has AHEAD/NOT.  But it's letting people write that out as <strong>not ahead</strong>.  And when combinators are triggered by datatype, you can get the feature of slipstreaming that refinement to the combinator when there's nowhere to put the /NOT.</p>
<p>A little touchy-feely perhaps that each parser can decide if there's a meaning to its negation (or if negation has no meaning at all) as opposed to something that has to be black-box decided from the parameterized parser's result.  But it seems learnable to me.</p>
<p>The question of if this little backdoor communication breaks some other more interesting composability feature in UPARSE is the main one to answer.  <em>(It isn't the only such suggestion... I've wondered about a similar backchannel to suppress an error from the "null combinator", which a MAYBE combinator could uniquely suppress an error from.)</em></p> ]]></description>
        <link>https://forum.rebol.info/t/double-negation-in-parse-is-not-not-not-cool/1536#post_4</link>
        <pubDate>Sun, 24 Mar 2024 04:08:59 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7269</guid>
      </item>
      <item>
        <title>Double Negation in PARSE is NOT NOT NOT Cool</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="1536">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I was reading some code using NOT that was like <strong>some [not space, one]</strong>.</p>
<p>Hence effectively this is <strong>some [not ahead space, one]</strong> e.g. some number of times look ahead to see a thing isn't a space, then consume one item (whatever the not space thing was).</p>
<p>This made me a bit disgruntled that I couldn't write <strong>some not space</strong>, which on the surface seems like a coherent thought... vs. something that acts like an <strong>some not ahead space</strong> e.g. an infinite loop.</p>
<p>[…]</p>
<p>e.g. AHEAD could be a negatable combinator, producing a negatable parser. And maybe a single character, single byte, or single value combinator would be willing to be negated--with the negated rule being any single value that's not that. We could also negate character sets in the same way.</p>
</blockquote>
</aside>
<p>I feel there’s some confusion between two completely different notions of negation here:</p>
<ul>
<li>Complement of a character set: that is, ‘match any character which is not in this set’</li>
<li>Inversion of parser success: that is, ‘make a parser which fails when another succeeds’</li>
</ul>
<p>In Haskell, the latter is (as you note) <a href="https://hackage.haskell.org/package/megaparsec-9.6.1/docs/Text-Megaparsec.html#v:notFollowedBy"><code>notFollowedBy</code></a>, and the former needs to be created ad-hoc using combinators like <a href="https://hackage.haskell.org/package/megaparsec-9.6.1/docs/Text-Megaparsec.html#v:satisfy"><code>satisfy</code></a>. Ren-C could do a bit better than Haskell there, since it reifies character sets as values.</p>
<p>But especially the last quoted paragraph seems to be conflating them. It sounds like you want NOT to sometimes invert the failure state, and sometimes change the characters that are matched. That strikes me as possibly being quite difficult to reason about. Not only that, it would create difficulties in cases where both are plausible — e.g. if <code>not space</code> matches everything except spaces, then how do I create a parser which fails if a space is present?</p> ]]></description>
        <link>https://forum.rebol.info/t/double-negation-in-parse-is-not-not-not-cool/1536#post_3</link>
        <pubDate>Sun, 24 Mar 2024 03:52:11 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7268</guid>
      </item>
      <item>
        <title>Rye Language (?)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Glad to hear there's a move to the environment/inheritance idea.  Suggests moving in a direction of greater restraint with binding is a recognized need...at least somewhere else.</p>
<p>Stopping to briefly look over the language further now, I don't really see much Rebol in it.  Can't find any dialects, e.g. no PARSE equivalent.  No COMPOSE?</p>
<p>It's piping-focused, in a way I can hardly read (English-like readability is supposed to be a goal in Rebol, that's clearly not a goal in Rye).  The idea of piping things seems better addressed to me by a construct like:</p>
<pre><code>&gt;&gt; chain [
       [1 2 3]
       reverse &lt;$&gt;
       map-each x &lt;$&gt; [x * 10]
   ]
== [30 20 10]
</code></pre>
<p><em>(Choice of <code>&lt;$&gt;</code> here is arbitrary and something you should be able to override.)</em></p>
<p>It could be useful, so I should probably rename what's called CHAIN today as CHAINER since it produces a function.  Then CHAIN can be used for one-offs.</p>
<p>But I think people who find data piping is their true quest in programming would go for paradigms that are more mature at that.</p> ]]></description>
        <link>https://forum.rebol.info/t/rye-language/1768#post_4</link>
        <pubDate>Sun, 24 Mar 2024 03:51:49 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7267</guid>
      </item>
      <item>
        <title>Rye Language (?)</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>I just had <a href="https://news.ycombinator.com/item?id=39804156">an interesting discussion</a> with the creator of Rye about how they implement binding. It’s a little hard to tell, but it sounds like Rye uses basically the same system as R does, with some additional restrictions to keep it more tractable. It’s certainly less flexible about it than most Rebol languages are.</p> ]]></description>
        <link>https://forum.rebol.info/t/rye-language/1768#post_3</link>
        <pubDate>Sun, 24 Mar 2024 02:09:45 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7266</guid>
      </item>
      <item>
        <title>Double Negation in PARSE is NOT NOT NOT Cool</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1536">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Here are the options for dealing with this in the combinator model:</p>
<ol>
<li>Change the name of NOT to NOT-AHEAD. This is how Haskell does it (they call it <a href="https://hackage.haskell.org/package/parsers-0.12.10/docs/Text-Parser-Combinators.html#v:notFollowedBy"><strong>notFollowedBy</strong> </a>... that combinator list is good to look at, by the way).</li>
<li>Leave it as-is and assume that it's the kind of thing you can just learn.</li>
<li>Rig up a hack to make the specific case of NOT immediately followed by NOT a no-op.</li>
<li>Systematically build into the protocol the idea that a rule can separately signal that it failed as well as "how much input it would have consumed if it had succeeded"</li>
</ol>
<p>I think (3) as in Red is a bad idea.</p>
</blockquote>
</aside>
<p>I was reading some code using NOT that was like <strong>some [not space, one]</strong>.</p>
<p>Hence effectively this is <strong>some [not ahead space, one]</strong> e.g. some number of times look ahead to see a thing isn't a space, then consume one item (whatever the not space thing was).</p>
<p>This made me a bit disgruntled that I couldn't write <strong>some not space</strong>, which on the surface seems like a coherent thought... vs. something that acts like an <strong>some not ahead space</strong> e.g. an infinite loop.</p>
<p>In practice any input-consuming combinator has a bit of a coherence problem... because while the letter "A" is not a space, neither is reaching the end of input.  So to stop the infinite loop problem you'd have to at the very least omit a test against end.</p>
<blockquote>
<p>I'm not even sure what (4) would mean...?</p>
</blockquote>
<p>Maybe it means we're missing a concept like <em>negatable combinators</em>, which you can call as <strong>parser/not</strong> instead of just <strong>parser</strong>.  Then NOT would call the parser negatedly (maybe it's the only combinator that would do so, or maybe there would be others?)</p>
<p>e.g. AHEAD could be a negatable combinator, producing a negatable parser.  And maybe a single character, single byte, or single value combinator would be willing to be negated--with the negated rule being any single value that's not that.  We could also negate character sets in the same way.</p>
<p>So a string combinator <em>when matching in a BLOCK!</em> could be negated, and matching the end would not count:</p>
<pre><code>&gt;&gt; parse ["alpha"] [not "beta"]
== "alpha"

&gt;&gt; parse [] [not "beta"]  ; behave same as e.g. `parse [] ["alpha"]`
** Error: PARSE BLOCK! combinator did not match input
</code></pre>
<p>But when matching in a string, it couldn't</p>
<pre><code>&gt;&gt; parse "alpha" [not "beta"]
** Error: TEXT! combinator not negatable when parsing TEXT!
</code></pre>
<p>So there'd be a narrow interpretation of cases where it was clear how much a combinator intended to test and consume.  If you could say how much it intended to consume... and make a reasoned argument it could consume an equal amount in the negated case.  (Any combinator that consumed no input could thus be negatable.)</p>
<p>This strikes me as valuable, as it would give meaning to things like <strong>some not space</strong> that people would want, and dismiss with the confusion over NOT being implicitly NOT AHEAD.</p>
<p>It may mean that <strong><code>some not space</code></strong> would work, and <strong><code>some not " "</code></strong> would be different in string parsing, e.g. characters would be treated differently than strings of length 1.  Or perhaps a NOT of a string that didn't match would always advance one character?  :-/</p>
<hr>
<p>Observation: NOT could itself be a negatable combinator, making NOT NOT work.  It just would notice when it was called with /NOT and then use that as a signal to call its combinated parser parameter plainly, vs. using /NOT.</p> ]]></description>
        <link>https://forum.rebol.info/t/double-negation-in-parse-is-not-not-not-cool/1536#post_2</link>
        <pubDate>Sun, 24 Mar 2024 01:09:54 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7265</guid>
      </item>
      <item>
        <title>Feb 2024 Talk, Functional Programming Sydney</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2175">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Curious how it was received, any general comments or reactions?</p>
</blockquote>
</aside>
<p>Generally people seemed interested. None of them are at all likely to use a Rebol language, of course, but they appreciated learning about a new paradigm.</p>
<p>One factor, I think, is the attendees mostly are Haskell or OCaml programmers, and few if any seemed familiar with Lisp. I’ve noticed that when talking about Rebol online, the most negative comments tend to come from Lispers, who are already familiar with how Lisps approach these concepts, and find Rebol weird and unprincipled. (And they may even be right — Lisps are generally far more rigorous than Ren-C, which is the best of the Rebols in this regard.)</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2175">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Whenever I look at just the basic stuff these days I think: <a href="https://en.wikipedia.org/wiki/Where%27s_the_beef%3F"><em>"Where's the beef?"</em></a></p>
</blockquote>
</aside>
<p>In my presentation I was quite clear about this: the ‘beef’ is being able to manipulate code at runtime, allowing you to craft your own syntax for whichever problem is at hand. Other languages can do that to some extent (notably Lisps, R and Forth), but Rebols are best-in-class. People can disagree on whether that compensates for the various other oddities of Rebol, but either way, that’s where the key advantage lies.</p> ]]></description>
        <link>https://forum.rebol.info/t/feb-2024-talk-functional-programming-sydney/2175#post_3</link>
        <pubDate>Sat, 23 Mar 2024 01:42:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7264</guid>
      </item>
      <item>
        <title>Feb 2024 Talk, Functional Programming Sydney</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Curious how it was received, any general comments or reactions?</p>
<p>Whenever I look at just the basic stuff these days I think: <a href="https://en.wikipedia.org/wiki/Where%27s_the_beef%3F"><em>"Where's the beef?"</em></a>  There's just too much unresolved in it.  In my book, Ren-C is what gives the idea any credence.</p> ]]></description>
        <link>https://forum.rebol.info/t/feb-2024-talk-functional-programming-sydney/2175#post_2</link>
        <pubDate>Fri, 22 Mar 2024 22:55:22 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7263</guid>
      </item>
      <item>
        <title>Killing Off Historical &quot;SKIP&quot; in PARSE</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1557">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>After contemplation of many possibilities for what this might be (including <strong><code>*</code></strong>, or <strong><code>&lt;*&gt;</code></strong>, or <strong><code>?</code></strong>, or just plain period (<strong><code>.</code></strong>), I settled on <strong><code>&lt;any&gt;</code></strong>.</p>
<pre><code class="lang-plaintext">&gt;&gt; parse [1] [x: &lt;any&gt;]
&gt;&gt; x
== 1
</code></pre>
<p>I'm quite happy with it--especially in light of removing ANY as a looping combinator from the default combinator set. It brings ANY to its coherent systemic meaning of ANY-ONE-OF... as opposed to ANY-NUMBER-OF.</p>
</blockquote>
</aside>
<p>Since I'm making a new bootstrap executable to facilitate FENCE!, I'm patching it to modern behaviors for PARSE3.  This includes the behavior of SKIP as being arity-1 and taking how much to skip.</p>
<p>I'm quite pleased with most UPARSE redesigns, including that one.  But the substitute for <em>"match any single item"</em> being the <strong><code>&lt;any&gt;</code></strong> tag gave me pause to ask "does this feel right, in light of modern understandings?"</p>
<p>I think I've come to believe that TAG! combinators are all arity-0, which <code>&lt;any&gt;</code> is.  But most other tag combinators synthesize things from midair without advancing the input.  Not advancing the input might be a good rule for a tag combinator?.  Perhaps that's over-restrictive.</p>
<p>Might it be better if it were just <strong><code>one</code></strong>?</p>
<pre><code>&gt;&gt; parse [1020] [x: one]
&gt;&gt; x
== 1020
</code></pre>
<p>It might suggest a class of combinators that captured more items (<strong>two</strong>, <strong>three</strong>, etc.).  Hence they would be a worse choice than e.g. <strong>skip 2</strong> if you didn't want to synthesize the values, so hopefully people wouldn't reach for them unless they really wanted blocks.  But that would create an irregularity that ONE wouldn't make a block when the others did (if ONE gave back a block, it means the captured thing was itself a block).  Or maybe it's a PICK where the series is implicit?</p>
<pre><code>&gt;&gt; parse [1020 304] [x: two]
&gt;&gt; x
== 304
</code></pre>
<p>(That would make it seem like it should be FIRST and SECOND instead of ONE and TWO, but I don't particularly like FIRST for this... I don't think.)</p>
<p>I think I like <strong><code>ONE</code></strong>.  It's easy to type, and I think it seems more meaningful than <code>&lt;any&gt;</code>.  <a href="https://forum.rebol.info/t/the-cool-new-repurposing-of-any-in-parse/1662">Especially when there is an ANY combinator</a> that does something more related to the non-PARSE ANY.</p>
<p>We could also have an arity-0 NEXT combinator that could return the next position, if you were trying to convey more that you were just skipping ahead and not intending to take any input.</p> ]]></description>
        <link>https://forum.rebol.info/t/killing-off-historical-skip-in-parse/1557#post_15</link>
        <pubDate>Fri, 22 Mar 2024 14:36:03 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7261</guid>
      </item>
      <item>
        <title>Feb 2024 Talk, Functional Programming Sydney</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2136">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/fundamental-distinguishing-features-of-rebol/2136/1">Fundamental distinguishing features of Rebol</a>
</div>
<blockquote>
<p>I offered to give a talk at my local Functional Programming meetup next month. Given my recent interests, I’m thinking of giving an intro to Rebol and its basic concepts.</p>
</blockquote>
</aside>
<p>As a follow-up to this, the talk slides are now online: <a href="https://github.com/fp-syd/meetings/blob/master/2024/2024-02-Neimann-Computing-with-eval.pdf">https://github.com/fp-syd/meetings/blob/master/2024/2024-02-Neimann-Computing-with-eval.pdf</a></p> ]]></description>
        <link>https://forum.rebol.info/t/feb-2024-talk-functional-programming-sydney/2175#post_1</link>
        <pubDate>Fri, 22 Mar 2024 00:19:14 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7260</guid>
      </item>
      <item>
        <title>&quot;More arguments for a function on request&quot; (Variadics)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>On Red's Gitter, <a href="https://matrix.to/#/!EorVRCzrVpjojJtctJ:gitter.im/$9hee8CVtrrHeVB7GTvPmKo2hV04eYAjOrhH64C3j5kY?via=gitter.im&amp;via=matrix.org&amp;via=chat.weho.st">@GiuseppeChillemi asked</a>:</p>
<blockquote>
<p>Do you think it would be possible to get more arguments for a function on request?</p>
<p>Example:</p>
<pre><code>aaa: 1
bbb: 2
ccc: 3
f: func [arg1] [other-args: get-args 3]
f arg1-val aaa bbb ccc
</code></pre>
</blockquote>
<p>And Gregg says "oh that would make Red unsafe" (as if Red were somehow "safe").</p>
<p>Anyway, Ren-C has some support for variadics.  While the implementation hasn't gotten a lot of attention in a while, it's no less safe than anything else--the mechanisms used are the same ones that gather ordinary arguments.</p>
<pre><code> aaa: 1
 bbb: 2
 ccc: 3
 f: func [arg1 others [&lt;variadic&gt; any-value?]] [
     return collect [keep arg1, repeat 3 [keep take others]]
 ]

 &gt;&gt; f 1020 aaa bbb ccc
 == [1020 1 2 3]
</code></pre>
<p>The interface is probably not what it's going to ultimately be.  But for now, you can mark a parameter <code>&lt;variadic&gt;</code> and it will be a VARARGS!, that supports TAKE to acquire parameters after the call is made.</p>
<p>Variadics should be used sparingly, because they are difficult to wrap and abstract.  There are some mechanisms for APPLY'ing variadics using a BLOCK! to supply the variadic arguments, but the interface for that is also likely to change.</p> ]]></description>
        <link>https://forum.rebol.info/t/more-arguments-for-a-function-on-request-variadics/2174#post_1</link>
        <pubDate>Tue, 19 Mar 2024 09:51:31 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7259</guid>
      </item>
      <item>
        <title>Switching to Stackless: Why this, Why now?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>For historical reference, here's what C_STACK_OVERFLOWING() comments (my explanation) said:</p>
<pre><code>//=////////////////////////////////////////////////////////////////////////=//
//
//  C STACK
//
//=////////////////////////////////////////////////////////////////////////=//
//
// Rebol doesn't want to crash in the event of a stack overflow, but would
// like to gracefully error and return the user to the console.  While it
// is possible for Rebol to set a limit to how deeply it allows function
// calls in the interpreter to recurse, there's no *portable* way to
// catch a stack overflow in the C code of the interpreter itself.
//
// Hence, by default Rebol will use a non-standard heuristic.  A flag is
// passed to say if OS_STACK_GROWS_UP.  If so, it then extrapolates that C
// function call frames will be laid out consecutively, and the memory
// difference between a stack variable in the topmost stacks can be checked
// against some limit.
//
// This has nothing to do with guarantees in the C standard, and compilers
// can really put variables at any address they feel like:
//
// http://stackoverflow.com/a/1677482/211160
//
// Additionally, it puts the burden on every recursive or deeply nested
// routine to sprinkle calls to the C_STACK_OVERFLOWING macro somewhere
// in it.  The ideal answer is to make Rebol itself corral an interpreted
// script such that it can't cause the C code to stack overflow.  Lacking
// that ideal this technique could break, so build configurations should
// be able to turn it off if needed.
//
// In the meantime, C_STACK_OVERFLOWING is a macro which takes the
// address of some variable local to the currently executed function.
// Note that because the limit is noticed before the C stack has *actually*
// overflowed, you still have a bit of stack room to do the cleanup and
// raise the failure.  (You need to take care of any unmanaged series
// allocations, etc).  So cleaning up that state should be doable without
// making deep function calls.
//
// !!! Future approaches should look into use of Windows stack exceptions
// or libsigsegv:
//
// http://stackoverflow.com/questions/5013806/
//

#if TO_EMSCRIPTEN || TO_WASI
    //
    // !!! Catching stack overflows in emscripten stopped working in the
    // BinaryEn build; the stack seems to not grow up or down specifically.
    // As a temporary non-solution, see what happens to just let it crash.
    //
    #define C_STACK_OVERFLOWING(address_of_local_var) \
        false

#elif defined(OS_STACK_GROWS_UP)

    #define C_STACK_OVERFLOWING(address_of_local_var) \
        (i_cast(uintptr_t, (address_of_local_var)) &gt;= g_ts.C_stack_limit_addr)

#elif defined(OS_STACK_GROWS_DOWN)

    #define C_STACK_OVERFLOWING(address_of_local_var) \
        (i_cast(uintptr_t, (address_of_local_var)) &lt;= g_ts.C_stack_limit_addr)

#else

    #define C_STACK_OVERFLOWING(local_var_addr) \
        (g_ts.C_stack_grows_up \
            ? i_cast(uintptr_t, (local_var_addr)) &gt;= g_ts.C_stack_limit_addr \
            : i_cast(uintptr_t, (local_var_addr)) &lt;= g_ts.C_stack_limit_addr)
#endif
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/switching-to-stackless-why-this-why-now/1247#post_9</link>
        <pubDate>Tue, 19 Mar 2024 06:51:09 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7258</guid>
      </item>
      <item>
        <title>PARSE vs. Haskell&#39;s (X)PARSEC</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="5" data-topic="1321">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I find it much more rewarding to think about how to design languages to solve real-world problems.</p>
</blockquote>
</aside>
<p>Certainly "real" problems are being attacked.  I just question the idea of solving problems <em>at scale</em> with such a tool.</p>
<p>But many real-world problems don't need to work at scale.  I probably shouldn't say they're "toy" problems just because they're kind of small, but it certainly opens the field to using quirkier interpreted languages.</p> ]]></description>
        <link>https://forum.rebol.info/t/parse-vs-haskells-x-parsec/1321#post_6</link>
        <pubDate>Tue, 19 Mar 2024 06:39:20 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7257</guid>
      </item>
      <item>
        <title>Switching to Stackless: Why this, Why now?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1247">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>We could put in a recursion counter and call that good enough...like old CPython does.</p>
<p>But...the problem with pressing on when you know something is wrong, is that there's some fairly deep impact on how the system and APIs work. If enough groundwork isn't laid to know where the stackless influence is, we might write bad extensions or interoperability that fundamentally won't work later.</p>
</blockquote>
</aside>
<p>Further validation...</p>
<p>...I moved up to GCC 13, and address sanitizer now breaks the assumptions of Rebol's old C_STACK_OVERFLOWING() check.</p>
<p><strong><a href="https://bugs.mysql.com/bug.php?id=111432">MySQL got bit by it</a></strong> (June 2023, they jumped compilers earlier than me):</p>
<blockquote>
<p>There is another problem with stack growth detection under Address Sanitizer on modern gcc and clang compilers (possibly under other sanitizers as well but this hasn't been tested).</p>
<p>Starting from clang version 15 and gcc version 13, both of these compilers are using custom technique for allocating stack frames when Asan is enabled (-fsanitize=address compiler flag is specified).</p>
<p><a href="https://github.com/google/sanitizers/wiki/AddressSanitizerUseAfterReturn">https://github.com/google/sanitizers/wiki/AddressSanitizerUseAfterReturn</a></p>
<p>They rely on a custom function __asan_stack_malloc() that allocates a block of memory from an internal ASan memory pool.</p>
<p>The problem is that this __asan_stack_malloc() may return absolutely random (or, I would at least say, unordered memory addresses) even for consequent calls.</p>
<p>In other words, there is no such thing as "stack growth direction" in this case and we just simply cannot rely on this concept in the MySQL code.</p>
</blockquote>
<p>As I mention, modern Ren-C isn't <em>completely</em> free from "stackful" recursions yet.  But we're not really that reliant on catching those cases overflowing in everyday code.  We can live without C_STACK_OVERFLOWING(), and it's probably time we do.  All the documentation and writeup of how bad it is and how it can't work in the webassembly build and it's not in the C standard is an unnecessary weight at this point.</p>
<p><strong>But the bootstrap executable isn't stackless at all.</strong>  So if we tossed the check there, a simple usermode recursion can crash the interpreter--without providing any feedback about what happened.  That's... not great.  And I do like running address sanitizer on the bootstrap build as much as anywhere else.</p>
<p>For now, it seems I can bypass the arbitrary C stack frame allocations with:</p>
<pre><code>export ASAN_OPTIONS=detect_stack_use_after_return=0
</code></pre>
<p>And that's fine for the bootstrap executable.  But on balance, I think we're better served by getting rid of the C_STACK_OVERFLOWING() check in the main code, and enabling the new address sanitizer check.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="1247">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>Scanning</strong> - If you imagine writing something like <strong>load "[[[[[[[[[[[[[..."</strong> there is going to be a limit somewhere. Red seems to use a specialized stack for this vs. doing recursions (the error you get for deep scans is <code>PARSE - stack limit reached</code>, and not a typical <code>stack overflow</code>). But Rebol's scanner was based on plain C recursion.</p>
</blockquote>
</aside>
<p>FWIW, Ren-C's scanner is now stackless.  (Doesn't sound like a necessity on the surface, but bear in mind API calls use the scanner, so it's kind of entwined in the evaluation model... this lets you unwind mid-API call with a partial scan.)</p> ]]></description>
        <link>https://forum.rebol.info/t/switching-to-stackless-why-this-why-now/1247#post_8</link>
        <pubDate>Tue, 19 Mar 2024 06:25:55 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7256</guid>
      </item>
      <item>
        <title>PARSE vs. Haskell&#39;s (X)PARSEC</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1321">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>A constrained parse dialect could be a parser generator, and the constrained dialect could probably subset the unconstrained one pretty closely.</p>
<p>But unconstrained PARSE as-we've-known-it is quite dynamic.</p>
</blockquote>
</aside>
<p>One subtle thing to note here is that it is possible to inspect a parse block to determine how dynamic it is. This is something which Haskell simply cannot do at all.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1321">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I've tried to nail down some minimal rules for the sake of coherence:</p>
<p><a href="https://forum.rebol.info/t/when-should-parse-notice-changes/1528">When Should PARSE Notice Changes</a></p>
</blockquote>
</aside>
<p>I think this is a really important thing to do. The reason Haskell’s parser combinators are so extensible is that they’re built on abstractions with very well-defined laws, so they can make assumptions about how other parser combinators can behave. By contrast, it seems to me that many UPARSE combinators behave have somewhat idiosyncratic behaviour, which makes them more difficult to combine. Having a more rigorous foundation for UPARSE combinators would be well worth the effort, I think.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1321">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>My main point of view that where this fits in the "Loom of Language" is packaging this kind of methodology in a way that brings it to the common programmer, using naught but mostly-C89. A kind of <em>"organic, locally-sourced software"</em> without inscrutable additives and preservatives. I want it to be constructed obviously and my performance goals are modest--seeing it as a toy almost more than anything.</p>
</blockquote>
</aside>
<p>This would explain a lot of our disagreements, then… I don’t particularly like ‘toy languages’, except insofar as they have interesting ideas I can use elsewhere. I find it much more rewarding to think about how to design languages to solve real-world problems.</p> ]]></description>
        <link>https://forum.rebol.info/t/parse-vs-haskells-x-parsec/1321#post_5</link>
        <pubDate>Sun, 17 Mar 2024 03:12:34 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7255</guid>
      </item>
      <item>
        <title>PARSE vs. Haskell&#39;s (X)PARSEC</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="3" data-topic="1321">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>By contrast, Rebol parsers are completely specified ahead of time.</p>
</blockquote>
</aside>
<p>A constrained parse dialect could be a parser generator, and the constrained dialect could probably subset the unconstrained one pretty closely.</p>
<p>But unconstrained PARSE as-we've-known-it is quite dynamic.  I've tried to nail down some minimal rules for the sake of coherence:</p>
<p><a href="https://forum.rebol.info/t/when-should-parse-notice-changes/1528" class="inline-onebox">When Should PARSE Notice Changes</a></p>
<aside class="quote no-group" data-username="bradrn" data-post="3" data-topic="1321">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I think there is definite untapped potential for Ren-C to be better than Haskell, at least in one of these metrics.</p>
</blockquote>
</aside>
<p>My main point of view that where this fits in the "Loom of Language" is packaging this kind of methodology in a way that brings it to the common programmer, using naught but mostly-C89.  A kind of <em>"organic, locally-sourced software"</em> without inscrutable additives and preservatives.  I want it to be constructed obviously and my performance goals are modest--seeing it as a toy almost more than anything.</p>
<p>This is in contrast to fairly bold claims about the pervasive applicability of the medium, believed by Carl and Red.</p>
<p>Ultimately if it gets used by others, it won't be up to me.  I don't know if you read Graydon Hoare's bit on Rust going in a direction he didn't envision--but that his vision probably had no realistic future:</p>
<p><a href="https://graydon2.dreamwidth.org/307291.html">https://graydon2.dreamwidth.org/307291.html</a></p>
<p>Maybe my more humble framing isn't the way the world will take it.  I don't know, but I'm glad you see potential in it!</p> ]]></description>
        <link>https://forum.rebol.info/t/parse-vs-haskells-x-parsec/1321#post_4</link>
        <pubDate>Fri, 15 Mar 2024 00:19:05 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7254</guid>
      </item>
      <item>
        <title>PARSE vs. Haskell&#39;s (X)PARSEC</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1321">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Forget the idea of ever competing on performance or rigor. No way.</p>
</blockquote>
</aside>
<p>As a Haskeller, I don’t actually think this is valid. I think there is definite untapped potential for Ren-C to be better than Haskell, at least in one of these metrics.</p>
<p>Firstly: note that parser combinators were not always ‘blazing fast’. There was a time when they were considered almost unusably slow. <a href="https://forum.rebol.info/t/haskell-parser-combinators/2173">As I’ve said</a>, the Haskell community needed to find the right trade-offs to get the speed up to where it is now… and I’ve definitely met people who think those trade-offs aren’t worth it (even if I personally do).</p>
<p>But also: it’s worth thinking a little closely about how Haskell parser combinators get that ‘rigor’. In large part, they do it by building everything off a set of well-defined abstractions: <code>Monad</code>, <code>Alternative</code>, and so on. This gives a flexible and reliable toolkit for composing parsers together, from which flows many other advantages.</p>
<p>But this approach has some disadvantages as well. The most prominent is that these particular abstractions can be, in some sense, ‘<em>too</em> big’: they might give parsers capabilities you might not want. In this case, the main culprit is <code>Monad</code>, which gives parsers the ability to depend arbitrarily on the results of earlier parsers. On the one hand, this allows context-sensitive parsing — but on the other, it makes static analysis impossible.</p>
<p>By contrast, Rebol parsers are completely specified ahead of time. You can inspect at the BLOCK! which is passed to PARSE or UPARSE, and see ahead-of-time the entire control flow of the parser. That gives you the opportunity to do clever optimisations… such as, let’s say, precompiling the whole parser into an ultra-fast LR lookup table. Even in Haskell, many people prefer to use such <a href="https://en.wikipedia.org/wiki/Compiler-compiler">parser generators</a> over parser combinators, despite the clunkiness it adds — a parser generator <em>embedded into the language itself</em> would be pretty amazing to use.</p>
<p>You can think of more creative uses too, of course. For instance, the Red people have used this capability <a href="https://www.red-lang.org/2020/03/gtk-fast-lexer-money-deep-testing-and.html">to generate railroad diagrams</a>, another thing Haskell parser combinator libraries can’t do.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1321">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But since Haskell is compiled, you don't get the opportunity to build parse rules dynamically.</p>
</blockquote>
</aside>
<p>I’m not <em>quite</em> sure what you’re referring to here… but if I understand you correctly, this sounds equivalent in power to what the <code>Monad</code> interface gives you. Most parser combinator libraries will allow you to alter the parser on-the-fly in crazy ways, if you really want to do so.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1321">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I thought Haskell parsers were network-stream-capable out of the box...e.g. that they would have an intelligent formulation so you could parse an infinite number of data items one at a time. But nearly all of the parsers--including Megaparsec--require all the data to be in memory from the beginning (the way Rebol PARSE does today). Even the parsers that are "incremental" hold onto all the historical input in case they need to backtrack...whether the rules need to or not. <em>I've found some research pointing to architectures of doing this better...<a href="https://www.cs.tufts.edu/~nr/cs257/archive/doaitse-swierstra/combinator-parsing-tutorial.pdf">see Section 4 of this paper</a></em></p>
</blockquote>
</aside>
<p>This is another one of those tradeoffs. To support arbitrary backtracking in a parser combinator system, you need to store the text to backtrack over. You can just <em>not store</em> that text, but then you can’t do any backtracking (or in more technical terms, you’re restricted to LL(1) grammars). So this is another place where Rebol potentially has an advantage, since it can analyse the parser before running it.</p> ]]></description>
        <link>https://forum.rebol.info/t/parse-vs-haskells-x-parsec/1321#post_3</link>
        <pubDate>Tue, 12 Mar 2024 08:58:27 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7253</guid>
      </item>
      <item>
        <title>Haskell parser combinators</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I've written a little here before:</p>
<p><a href="https://forum.rebol.info/t/parse-vs-haskells-x-parsec/1321">PARSE vs. Haskell's (X)PARSEC</a></p>
</blockquote>
</aside>
<p>Interesting, thanks! After reading it, I do have a few thoughts, but I’ll reply in that thread.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>One thing to notice is that UPARSE doesn't have a <em><strong>sequencing</strong></em> combinator. Instead, it has a <em><strong>BLOCK!</strong></em> combinator.</p>
</blockquote>
</aside>
<p>Sure, but I wasn’t aiming to describe Rebol there.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>UPARSE adds in another element to BLOCK!'s recognized-literally vocabulary of <strong><code>||</code></strong></p>
</blockquote>
</aside>
<p>This certainly is neat. Reminds me a bit of Haskell’s <code>($)</code> operator, but more flexible.</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p><code>string "word 1" &lt;|&gt; string "word 2"</code> no longer works: as soon as this parser sees <code>'w'</code>, it matches the first parser, so the second parser will never be run.</p>
</blockquote>
</aside>
<p>Seems unfortunate that the default is biased that way, and you have to tack on more to get the likely-intended meaning.</p>
</blockquote>
</aside>
<p>But on the other hand, this approach greatly improves performance, and makes control flow far more manageable. From my experience using parser combinators, the trade-off is well worth it.</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>There was significant discussion on what to call the "0 or more" combinator. Historical Redbol called this ANY and I did not like that […] But I do not like MANY either--it might be worse. Ultimately I decided that OPTIONAL SOME (or OPT SOME) is just what you would write out.</p>
</blockquote>
</aside>
<p>In Haskell, <code>many</code> is just the conventional term which has stuck. Haskell tends to care much less about names than Rebol does, probably because the types and the syntax carry so much more information.</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<pre><code class="lang-plaintext">return :: a -&gt; Parser a
return a = Parser $ \input -&gt; Just (input, a)
</code></pre>
</blockquote>
</aside>
<p>To prematurely return a result from UPARSE (without requiring reaching the end of input), the ACCEPT combinator can be used.</p>
</blockquote>
</aside>
<p>Apologies, I should have made this clearer. <code>return</code> in Haskell does <strong>not</strong> prematurely return a result. It simply takes a value and hoists it into a monadic context. In this case, <code>return value</code> is a parser which consumes no characters and always succeeds, yielding the result <code>value</code> as it does so.</p>
<p>(Note that <code>return</code> has the alias name <code>pure</code>. Arguably that’s a less confusing name, and I should have used it.)</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<pre><code class="lang-plaintext">-- sequencing ignoring result
(&gt;&gt;) :: Parser a -&gt; Parser b -&gt; Parser b
p &gt;&gt; q = p &gt;&gt;= \_ -&gt; q
</code></pre>
</blockquote>
</aside>
<p>UPARSE combinators can synthesize antiforms, including NIHIL. So there's an ELIDE combinator.</p>
<pre><code class="lang-plaintext">&gt;&gt; parse [a b a b b c c] [accumulate ['a | 'b], some 'c]
== c

&gt;&gt; parse [a b a b b c c] [accumulate ['a | 'b], elide some 'c]
== [a b a b b]
</code></pre>
</blockquote>
</aside>
<p>Again, this is something I should have been clearer about. Haskell <code>(&gt;&gt;)</code> is simply the equivalent of  Rebol COMMA!.</p>
<p>In this case, <code>(&gt;&gt;)</code> is used to write the equivalent of your first example, not your second. In Haskell, these would be:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">parser1 = many (char 'a' &lt;|&gt; char 'b') &gt;&gt; some (char 'c')
parser2 = many (char 'a' &lt;|&gt; char 'b') &gt;&gt;= \result -&gt; (some (char 'c') &gt;&gt; return result)
</code></pre>
<p>Although in practice we have another operator <code>(&lt;*)</code> to make that second example a bit shorter: <code>many (…) &lt;* some (char 'c')</code>.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>The most useful thing is bringing this outside perspective to the sort of "people who grew up on C64 BASIC" who tend to populate and design Rebol.</p>
</blockquote>
</aside>
<p>Yep, you understand my intentions!</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>The big areas where ideas are needed most are in error delivery</p>
</blockquote>
</aside>
<p>Some parser combinator libraries have interesting strategies for error handling, so that might be worth a look. I know that the paper I linked summarises the basic ideas around how that works. (If I get time, perhaps I can investigate further and write it up here.)</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>what the story is for binding tools within parse to help dialect authors accomplish cool things easily</p>
</blockquote>
</aside>
<p>Haskell is well-suited in this regard, because it has so many well-specified abstractions for combining things together. (e.g., many libraries implement parsers as monad transformers.) And of course parsers are simply ordinary values, so it’s easy to manipulate them using the rest of the language.</p>
<p>By contrast, I’ve always felt this is the limitation of dialecting: the elements of a dialect are just words in a block, rather than first-class values of the language. Rebol has parse specifications, but the ‘parsers’ themselves don’t actually exist outside the call to <code>uparse</code>. There may be some solution to this problem, but I’m not sure what it is.</p> ]]></description>
        <link>https://forum.rebol.info/t/haskell-parser-combinators/2173#post_3</link>
        <pubDate>Tue, 12 Mar 2024 08:29:40 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7252</guid>
      </item>
      <item>
        <title>Haskell parser combinators</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Thank you for summarizing!  I've written a little here before:</p>
<p><a href="https://forum.rebol.info/t/parse-vs-haskells-x-parsec/1321" class="inline-onebox">PARSE vs. Haskell's (X)PARSEC</a></p>
<p>Parser combinators were not an influence on the original Rebol PARSE (circa 90s), but were what I drew inspiration from for UPARSE.</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<pre><code class="lang-plaintext">(&lt;|&gt;) :: Parser a -&gt; Parser a -&gt; Parser a
p &lt;|&gt; q = Parser $ \input -&gt;
    case runParser p input of
        Just result -&gt; Just result
        Nothing -&gt; runParser q input
</code></pre>
</blockquote>
</aside>
<p>One thing to notice is that UPARSE doesn't have a <em><strong>sequencing</strong></em> combinator.  Instead, it has a <em><strong>BLOCK!</strong></em> combinator.</p>
<p>And it's the BLOCK! combinator that generally does the "combinating".  It can technically be replaced, but it is the most complex combinator and so difficult to replace entirely... it's almost like the block combinator <em>is</em> UPARSE.  So it is more likely that it would be augmented vs. people wanting to rewrite it entirely.</p>
<p>When one of the parsers the block combinator has "combinated" fails, it then scans literally for the next <strong><code>|</code></strong> in the input and starts applying rules there.  This is true also historical Redbol, in that you can write any old (LOAD-able) gibberish after a failing rule, due to the skipping:</p>
<pre><code>red&gt;&gt; parse "aaa" [some "b" fhqwhgads ??? | some "a"]
== true
</code></pre>
<p>(Should a debug mode exist that runs through and ensures these regions will combinate, just not call the parsers?  Probably not in this language paradigm.  Mismatching rules can guard against dereferencing undefined variables and such, and that's kind of how the whole language works... it's modeling clay.)</p>
<p>UPARSE adds in another element to BLOCK!'s recognized-literally vocabulary of <strong><code>||</code></strong>, that is a synonym for putting everything to the left of it in a block:</p>
<pre><code>[rule1 | rule2 | rule3 || rule4]
=&gt;
[[rule1 | rule2 | rule3] rule4]

[rule1 | rule2 || rule3 | rule4 || rule5]
=&gt;
[[rule1 | rule2] [rule3 | rule4] rule5]
</code></pre>
<p>(Well, it's a synonym so long as you haven't redefined the BLOCK! combinator itself to other meanings, but if you did you might also redefine <code>||</code> while you're at it.)</p>
<p>Anyway, I'm rather fond of <code>||</code>.</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p><code>string "word 1" &lt;|&gt; string "word 2"</code> no longer works: as soon as this parser sees <code>'w'</code>, it matches the first parser, so the second parser will never be run.</p>
</blockquote>
</aside>
<p>Seems unfortunate that the default is biased that way, and you have to tack on more to get the likely-intended meaning.</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<pre><code class="lang-plaintext">-- 0 or more
many :: Parser a -&gt; Parser [a]
many p = some p &lt;|&gt; return []
</code></pre>
</blockquote>
</aside>
<p>There was significant discussion on what to call the "0 or more" combinator.  Historical Redbol called this ANY and I did not like that (<a href="https://forum.rebol.info/t/the-cool-new-repurposing-of-any-in-parse/1662">instead pursuing an ANY that is aligned with the ANY construct in the language</a>).</p>
<p>But I do not like MANY either--it might be worse.  Ultimately I decided that OPTIONAL SOME (or OPT SOME) is just what you would write out.</p>
<p>On the linguistic front, we don't have a word for "zero or more" in English, and maybe there is a reason for that.  What I found in going through replacing the old "ANY"=&gt;"OPT SOME" was that there were a lot of cases where someone reached for ANY when it actually wasn't a zero-or-more situation, so I liked it being explicit.</p>
<p>Many cases I looked at tidied up (and by many I mean many, not zero). I found this code removing 0 or more newlines at the head of a series via ANY:</p>
<pre><code class="lang-plaintext">parse series [
    remove [any newline]
    ...
]
</code></pre>
<p>But when you rephrase this with OPT SOME it suggests a better factoring:</p>
<pre><code class="lang-plaintext">parse series [
    remove [opt some newline]
    ...
]
</code></pre>
<p>It reads clearest when you bring the OPT outside, to say you're <em>optionally removing some newlines</em>:</p>
<pre><code class="lang-plaintext">parse series [
    opt remove [some newline]
    ...
]
</code></pre>
<p>Plus it's now more obvious that the whole expression will be NULL in the case when no newlines are removed, and leverage that.</p>
<p>Note that the block is not necessary there:</p>
<pre><code class="lang-plaintext">parse series [
    opt remove some newline
    ...
]
</code></pre>
<p>And shows a bit of the dynamics of choice we like about the medium.</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<pre><code class="lang-plaintext">return :: a -&gt; Parser a
return a = Parser $ \input -&gt; Just (input, a)
</code></pre>
</blockquote>
</aside>
<p>To prematurely return a result from UPARSE (without requiring reaching the end of input), the ACCEPT combinator can be used.</p>
<pre><code>&gt;&gt; parse [a b c 10 20 &lt;d&gt;] [some [word! | integer!]]
** Error: PARSE partially matched the input, but didn't reach the tail

&gt;&gt; parse [a b c 10 20 &lt;d&gt;] [some [word! | accept integer!]]
== 10

&gt;&gt; parse [a b c 10 20 &lt;d&gt;] [some [word! | accept [let i: integer! accept (i * 3)]]]
== 30
</code></pre>
<p>R3-Alpha added this as "RETURN", but Red doesn't seem to have carried that forward.  I like using a different word.</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<pre><code class="lang-plaintext">-- sequencing ignoring result
(&gt;&gt;) :: Parser a -&gt; Parser b -&gt; Parser b
p &gt;&gt; q = p &gt;&gt;= \_ -&gt; q
</code></pre>
</blockquote>
</aside>
<p>UPARSE combinators can synthesize antiforms, including NIHIL.  So there's an ELIDE combinator.</p>
<pre><code>&gt;&gt; parse [a b a b b c c] [accumulate ['a | 'b], some 'c]
== c

&gt;&gt; parse [a b a b b c c] [accumulate ['a | 'b], elide some 'c]
== [a b a b b]
</code></pre>
<p>This is particularly helpful to reach for in cases where an ACCEPT that returned prematurely would not complete your match.  e.g. you synthesized your result, but you still have more matching to do, and want to avoid the inconvenience of making and naming a variable for the synthesized result and then evaluating to it at the end.</p>
<p><em>(Note that COMMA! doesn't do anything, they are skipped by the BLOCK! combinator so long as they are between combinated parsers.  <strong>some "a", some "b"</strong> is legal but not <strong>some, "a" some, "b"</strong>).</em></p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>It holds onto the input string during the whole time <code>p</code> is executing. This creates a space leak, which grows larger the more nested choices you have.</p>
</blockquote>
</aside>
<p>Rebol PARSE has lots of performance issues.  e.g. when doing something like a seek, a block rule is re-applied at each location:</p>
<pre><code>red&gt;&gt; parse "aaaaab" [thru [(print "testing") "b"]]
testing
testing
testing
testing
testing
testing
== true
</code></pre>
<p>There are attempts in historical Rebol and Red to try and optimize where possible, e.g. the implementation of <strong><code>to "b"</code></strong> optimizes the find to do a faster seek for the pattern.  But you lose that optimization as soon as you change it to <strong><code>to ["b"]</code></strong>, and it recurses the parser.</p>
<p>Ren-C dials things up to 11, including the crappy performance.  UPARSE is knowingly painfully turtle slow, because it is really just a sketch of the architecture for how parser combinators would be done.  But as its broken up into functions, those functions can be rewritten as native C when the time comes (though I want to make sure the usermode implementations are kept in sync and can be swapped in and still work equivalently--so I imagine maintaining each usermode combinator and its C implementation in the same file).</p>
<p>I also want to make sure all the right hooks are in place to do things like stepwise debugging:</p>
<p><a href="https://forum.rebol.info/t/replpad-visual-parse-debugger/2063" class="inline-onebox">ReplPad Visual PARSE Debugger</a></p>
<p>But I'm trying to put that together as part of a bigger story of what kind of infrastructure exists for dialect debugging and debugging in the main language (e.g. you'd be able to "step in" to a dialect at the Rebol instructions--like an assembly view--or at the level the dialect offers).</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>What use is this for Rebol?</p>
<p>Quite probably, none at all.</p>
</blockquote>
</aside>
<p>The most useful thing is bringing this outside perspective to the sort of "people who grew up on C64 BASIC" who tend to populate and design Rebol.  (You've already usefully pointed out that OPTIONAL is a perfectly acceptable word and explained the Haskell sense of TRY...)</p>
<p>Like I say above, the UPARSE design is still very much prototype-y.  It's at the "amazing it works at all" phase, though it's already the most tested PARSE variant by far (e.g. <a href="https://forum.rebol.info/t/making-red-tests-useful-starting-uparse-on-the-right-foot/1649">by subsuming Red's PARSE tests</a>).  But by being all usermode code, it's still at the point where there's plasticity in the design to incorporate new ideas.</p>
<p>The big areas where ideas are needed most are in error delivery, and what the story is for binding tools within parse to help dialect authors accomplish cool things easily.  And any architectural ideas to bolster performance (while still keeping the pleasing ergonomics) would be welcome.</p> ]]></description>
        <link>https://forum.rebol.info/t/haskell-parser-combinators/2173#post_2</link>
        <pubDate>Tue, 12 Mar 2024 05:24:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7251</guid>
      </item>
      <item>
        <title>Haskell parser combinators</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>I’ve seen a few parsing-related threads recently in this forum. I haven’t been commenting much on them, since I don’t have enough experience with UPARSE (or for that matter historical PARSE) to say anything helpful.</p>
<p>On the other hand, I <em>do</em> have a lot of experience with parser combinators in Haskell. In terms of structure and purpose, they’re probably the concept most similar to UPARSE that I’ve seen from another language. So I thought I’d write this post in the hope that something, somewhere, might eventually prove useful somehow.</p>
<h2>
<a name="high-level-overview-1" class="anchor" href="https://forum.rebol.info#high-level-overview-1"></a>High-level overview</h2>
<p>The first and most important thing to realise about parser combinators is that <strong>they’re not built into the language</strong>. They’re simply ordinary libraries which make it easy to construct parsers compositionally.</p>
<p>(I mean, for that matter, UPARSE isn’t built in either. But there’s a different level of integration with the rest of the language.)</p>
<p>The basic approach is to define a new datatype for parsers, usually called something like <code>Parser a</code>. This is a parser which can process a string (or other datatype), returning a result of type <code>a</code> if it succeeds. Alongside this there will be a set of primitive parsers, most notably <code>char</code> (to parse single characters), <code>return</code> (which always succeeds with a result), and <code>empty</code> (which always fails).</p>
<p>(Of course, practical libraries will have more primitives. <code>megaparsec</code> has <a href="https://hackage.haskell.org/package/megaparsec-9.6.1/docs/Text-Megaparsec.html#g:4">a nice selection</a>, with good comments.)</p>
<p>The most interesting bit is the way these parser combinators are combined to create larger parsers. This, of course, relies on the standard abstractions of Haskell. Two operators are particularly important:</p>
<ul>
<li>Sequencing: <code>p &gt;&gt;= f</code> is a parser which runs <code>p</code> and passes the result to function <code>f</code>, then runs the resulting parser.</li>
<li>Choice: <code>p &lt;|&gt; q</code> is a parser which runs <code>p</code>, then backtracks and runs <code>q</code> if that failed.</li>
</ul>
<p>From these basic elements you can define a very wide range of generic combinators, for instance these useful ones:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">-- sequencing ignoring result
(&gt;&gt;) :: Parser a -&gt; Parser b -&gt; Parser b
p &gt;&gt; q = p &gt;&gt;= \_ -&gt; q

-- Match a whole string
string :: String -&gt; Parser ()
string "" = return ()
string (c:cs) = char c &gt;&gt; string cs

-- 1 or more
some :: Parser a -&gt; Parser [a]
some p =
    p &gt;&gt;= \first -&gt;
    many p &gt;&gt;= \rest -&gt;
    return (first : rest)

-- 0 or more
many :: Parser a -&gt; Parser [a]
many p = some p &lt;|&gt; return []
</code></pre>
<h2>
<a name="a-basic-implementation-2" class="anchor" href="https://forum.rebol.info#a-basic-implementation-2"></a>A basic implementation</h2>
<p>This is all a little abstract, though. Probably the easiest way to understand parser combinators is to implement them.</p>
<p>A basic implementation is quite simple. A parser is just a function which takes in a string, and on success returns the result alongside the unparsed portion of the string:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">newtype Parser a = Parser (String -&gt; Maybe (String, a))
</code></pre>
<p>You then run the parser simply by unwrapping the function and applying it to your input:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">runParser :: Parser a -&gt; String -&gt; Maybe (String, a)
runParser (Parser p) input = p input
</code></pre>
<p>Simple parsers work as you’d expect:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">char :: Char -&gt; Parser ()
char c = Parser $ \input -&gt; case input of
    (c':cs) | c == c' -&gt; Just (cs, ())
    _ -&gt; Nothing

return :: a -&gt; Parser a
return a = Parser $ \input -&gt; Just (input, a)

empty :: Parser a
empty = Parser $ \_ -&gt; Nothing
</code></pre>
<p>The combinators require more elaborate state-threading, but are still straightforward:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">(&gt;&gt;=) :: Parser a -&gt; (a -&gt; Parser b) -&gt; Parser b
p &gt;&gt;= f = Parser $ \input -&gt;
    case runParser p input of
        Nothing -&gt; Nothing
        Just (partiallyParsed, a) -&gt;
            runParser (f a) partiallyParsed

(&lt;|&gt;) :: Parser a -&gt; Parser a -&gt; Parser a
p &lt;|&gt; q = Parser $ \input -&gt;
    case runParser p input of
        Just result -&gt; Just result
        Nothing -&gt; runParser q input
</code></pre>
<p>This simple code suffices for a surprisingly wide variety of tasks. For instance, a slight variant is present in the base library as <a href="https://hackage.haskell.org/package/base-4.16.3.0/docs/Text-Read.html#t:ReadS"><code>ReadS</code></a>. (The variation is that <code>ReadS</code> can produce multiple results.)</p>
<h2>
<a name="managing-backtracking-3" class="anchor" href="https://forum.rebol.info#managing-backtracking-3"></a>Managing backtracking</h2>
<p>Unfortunately, <strong>this has serious problems with any larger-scale use</strong>. For one thing, it can’t do error reporting beyond ‘it failed somewhere’. But there are even bigger problems with this implementation of the choice combinator <code>(&lt;|&gt;)</code>:</p>
<ol>
<li>It behaves unpredictably: any error anywhere will result in the parser backtracking to the last choice, and so on until every single choice has been exhausted. This is bad for the time complexity, plus it leaves you no chance of ever reporting errors nicely.</li>
<li>It holds onto the input string during the whole time <code>p</code> is executing. This creates a space leak, which grows larger the more nested choices you have.</li>
</ol>
<p>The first parser combinator library to solve these issues was <code>Parsec</code>. Its design is described in <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/parsec-paper-letter.pdf">this paper</a> (which seems very readable). I won’t describe its implementation here… but the basic idea is simple to summarise: each parser keeps track of what it’s consumed, and <strong>commits to a parser as soon as it’s consumed any characters</strong>.</p>
<p>Some parsers require no changes under this new semantics. For instance, <code>string "first word" &lt;|&gt; string "second word"</code> works without problems. If it sees an input character <code>f</code>, the first choice <code>string "first word"</code> matches immediately, meaning the library can commit to the first parser, and know that the second parser never needs to run. On the other hand, upon seeing an input character <code>'s'</code>, that first parser will fail on that very first character: since no characters have been consumed, control passes over to the second parser to succeed or fail.</p>
<p>On the other hand, more elaborate lookahead becomes more difficult. For instance, <code>string "word 1" &lt;|&gt; string "word 2"</code> no longer works: as soon as this parser sees <code>'w'</code>, it matches the first parser, so the second parser will never be run.</p>
<p>To solve this, Parsec introduces a new primitive combinator: <code>try</code>, which creates a parser which never consumes characters on failure. The effect of this is to allow backtracking over whatever is in the <code>try</code>. For this example, <code>try (string "word 1") &lt;|&gt; string "word 2"</code> would work as expected.</p>
<p>The nice thing about this approach is the control it gives you. For instance, I can write things like:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">(try (string "App") &gt;&gt; string "le") &lt;|&gt; string "Apricot"
</code></pre>
<p>Here, as soon as the parser reaches a second <code>'p'</code>, it can commit to the first branch. But if it sees another character, it’s still able to backtrack through the <code>string "App"</code> and move on to the second branch. Of course, this is a contrived example — but in general, being able to specify the control flow of your parser like this is exceedingly useful in larger parsers.</p>
<h2>
<a name="what-use-is-this-for-rebol-4" class="anchor" href="https://forum.rebol.info#what-use-is-this-for-rebol-4"></a>What use is this for Rebol?</h2>
<p>Quite probably, none at all.</p>
<p>But like I said, I’m hoping potentially some of this might end up useful somewhere. If it can act as inspiration which helps solve any problems, I’m happy.</p>
<p>And, of course, now that we have this thread for it, feel free to ask me any questions about parser combinators you might have!</p> ]]></description>
        <link>https://forum.rebol.info/t/haskell-parser-combinators/2173#post_1</link>
        <pubDate>Mon, 11 Mar 2024 15:08:10 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7250</guid>
      </item>
      <item>
        <title>-&gt; for LAMBDA (or... &quot;LAMBDA-Lite?&quot;)</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2172">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><a class="mention" href="https://forum.rebol.info/u/bradrn">@bradrn</a> might argue such mechanics shouldn't be necessary, because source-level non-evaluation should be explicit, e.g. <strong><code>'x -&gt; [...]</code></strong></p>
</blockquote>
</aside>
<p>I’ve come to accept that this idea has valid usecases. It’s still not my favourite design choice, but I’m OK with it.</p> ]]></description>
        <link>https://forum.rebol.info/t/for-lambda-or-lambda-lite/2172#post_3</link>
        <pubDate>Mon, 11 Mar 2024 00:37:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7249</guid>
      </item>
      <item>
        <title>Implicit Capture In PARSE - How To Get It?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1718">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'm nearly certain we'll have <strong>$word</strong>, <strong>$[bl o ck]</strong>, <strong>$(gr o up)</strong> and friends. Maybe that?</p>
<pre><code>parse isodate [$year "-" $month "-" $day "T" ...]
</code></pre>
<p>Though since the general meaning would be "get-environment-variable" this would raise questions about dialects bending the meaning of things so severely.</p>
<p><em>It Feels Weak To Not Have An Answer For This</em></p>
</blockquote>
</aside>
<p>As it happens, we do now have the $XXX types.  And they do not mean "environment variable" in the main evaluator... they relate to applying the "current binding" of the evaluator onto the thing in hand.</p>
<pre><code>&gt;&gt; x: 10

&gt;&gt; get 'x
** Error: x is not bound

&gt;&gt; get $x
== 10
</code></pre>
<p>As far as PARSE goes, "capture thing at current position into a variable" is still a compelling thing to do succinctly.  Though having $ not related to binding would be a loss (given that we know that there need to be some binding assistance for propagating binding while parsing, to keep dialect implementation from being too much of a hassle.)</p>
<p><em>So could it be both?</em>  Could $xxx capture the current thing, and apply the binding (if applicable?)  Binding wouldn't be applicable to strings (though it could if you reached the string via a SUBPARSE of a block).</p>
<p>Don't know, just wanted to give this thread a bump since $ types exist now.</p> ]]></description>
        <link>https://forum.rebol.info/t/implicit-capture-in-parse-how-to-get-it/1718#post_2</link>
        <pubDate>Sun, 10 Mar 2024 20:57:20 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7248</guid>
      </item>
      <item>
        <title>-&gt; for LAMBDA (or... &quot;LAMBDA-Lite?&quot;)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2172">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre><code class="lang-plaintext">y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then (lambda [x] [
    assert [x = &lt;yes&gt;]
    1000 + 20
])
assert [y = 1020]
</code></pre>
</blockquote>
</aside>
<p>I remembered while writing this that you have to put branches in GROUP!s, because branches are "soft-quoted" slots (or, more accurately "soft literal") slots.</p>
<p>The reason you don't have to put the <strong><code>-&gt;</code></strong> form in groups when you use them as branches is because there's deference to a leftward-literal operation in a soft-literal slot.  The left literal beats the right literal.</p>
<p>But this has a cost: <em>you're paying to generate the function whether it gets called or not</em>.</p>
<p>Historical Rebol has this problem anywhere functions are passed as handlers.  Consider TRY/EXCEPT in R3-Alpha:</p>
<pre><code>r3-alpha&gt;&gt; try/except [1 / 0] func [e] [print ["Error Handler:" form e/id]]  
Error Handler: zero-divide
</code></pre>
<p>Putting it in a GROUP! won't help there, because /EXCEPT doesn't suppress any evaluation from that GROUP!.  But in Ren-C, branches are literal, so the groups can be used to suppress the evaluation unless the branch runs.</p>
<h2>
<a name="is-making-uncalled-unpacking-lambdas-a-problem-1" class="anchor" href="https://forum.rebol.info#is-making-uncalled-unpacking-lambdas-a-problem-1"></a>Is Making Uncalled (Unpacking-) Lambdas A Problem?</h2>
<p>That depends...</p>
<ol>
<li>
<p>does an unpacking lambda make a deep copy of the block?</p>
</li>
<li>
<p>or does it just make a small structure that pairs the name of the parameter(s) with the body of code?</p>
</li>
</ol>
<p>Today's it's [2]... <strong><code>-&gt;</code></strong> just makes that small structure (while LAMBDA makes the full copy).  But this means you get the semantics of a non-copying construct:</p>
<pre><code>&gt;&gt; block: [print ["Hello" x]]

&gt;&gt; one: x -&gt; block

&gt;&gt; append block spread [print ["Goodbye" x]]

&gt;&gt; two: x -&gt; block

&gt;&gt; one 1020
Hello 1020
Goodbye 1020

&gt;&gt; two 1020
Hello 1020
Goodbye 1020
</code></pre>
<p>So you would have to say <strong><code>x -&gt; copy/deep block</code></strong> to get a unique copy of the body.</p>
<p>Beyond the semantic implications of not copying, there's a performance implication if you call it more than once... because the <a href="https://forum.rebol.info/t/semantics-and-optimization-of-copying-function-bodies/2119">preparations that make the body a little faster to call</a> that happen during the copy are not done.</p>
<p>There are some other options like going in some strange "branch dialected" direction, and say that BLOCK!s with a certain format were "parameterized", moving the parameter name into the block somehow, not necessarily this but like this:</p>
<pre><code>y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then [x -&gt;
    assert [x = &lt;yes&gt;]
    1000 + 20
]
</code></pre>
<p>I'd rather put every parameterized branch in a group than do that.</p>
<pre><code>y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then (x -&gt; [
    assert [x = &lt;yes&gt;]
    1000 + 20
])
</code></pre>
<p>But still, no.  It's much better to push on optimizations of the stylized function generation so that it's cheap as can be to make regardless of the branch being taken, <em>it's the source we want to write</em>:</p>
<pre><code>y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then x -&gt; [
    assert [x = &lt;yes&gt;]
    1000 + 20
]
</code></pre>
<p>Just another devil in the details to worry over.  But wanted to write up a reminder of why plain LAMBDA has to be in a GROUP! if you're going to use it in a branch, because I'd forgotten you had to do that.</p> ]]></description>
        <link>https://forum.rebol.info/t/for-lambda-or-lambda-lite/2172#post_2</link>
        <pubDate>Sun, 10 Mar 2024 19:02:47 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7247</guid>
      </item>
      <item>
        <title>-&gt; for LAMBDA (or... &quot;LAMBDA-Lite?&quot;)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>So I'm still shoring up a new bootstrap executable, patching around in a 6-years-out-of-date codebase.   It's in some ways a cruel and unusual punishment... but in other ways a good trip down memory lane to revisit decisions that were made, and ask "was that the right decision?"</p>
<p>The 6-year-old EXE defined an enfix form of lambda as <strong><code>=&gt;</code></strong>.  I shifted it to the lighter form as <strong><code>-&gt;</code></strong>.  Contrast:</p>
<pre><code>y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then (lambda [x] [
    assert [x = &lt;yes&gt;]
    1000 + 20
])
assert [y = 1020]

y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then x =&gt; [
    assert [x = &lt;yes&gt;]
    1000 + 20
]
assert [y = 1020]

y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then x -&gt; [
    assert [x = &lt;yes&gt;]
    1000 + 20
]
assert [y = 1020]
</code></pre>
<p><em>(Supplemental: Reddit post on <a href="https://www.reddit.com/r/ProgrammingLanguages/comments/shllr3/whats_the_syntax_of_lambda_expressions_in_your/">"What's the syntax of lambda expressions in your language"</a>)</em></p>
<p><strong>I like the <code>-&gt;</code> and don't think there's a greater purpose for it in the box.</strong>  As with everything else, overriding it is a personal choice.</p>
<h2>
<a name="a-speaking-with-ticshttpsforumrebolinfotspeaking-with-tics-should-quoted-arguments-always-be-apostrophed1359-note-1" class="anchor" href="https://forum.rebol.info#a-speaking-with-ticshttpsforumrebolinfotspeaking-with-tics-should-quoted-arguments-always-be-apostrophed1359-note-1"></a>A <a href="https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359">Speaking-With-Tics</a> Note</h2>
<p>Mechanically getting this to work is non-trivial:</p>
<p><a href="https://forum.rebol.info/t/the-most-vexing-evaluation-lambda-meets-then-else/1361" class="inline-onebox">The Most Vexing Evaluation: LAMBDA meets THEN/ELSE</a></p>
<p>Part of what makes it non-trivial is the "literal lookback" by which <strong><code>-&gt;</code></strong> infixedly snatches the X without letting it evaluate.</p>
<p><a class="mention" href="https://forum.rebol.info/u/bradrn">@bradrn</a> might argue such mechanics shouldn't be necessary, because source-level non-evaluation should be explicit, e.g. <strong><code>'x -&gt; [...]</code></strong></p>
<pre><code>y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then 'x -&gt; [
    assert [x = &lt;yes&gt;]
    1000 + 20
]
assert [y = 1020]
</code></pre>
<p>But that's one more stroke of key than I want, and one more piece of dirt than I want to see.  <em>I know from context that slot is a variable name, in the most common case.</em>  I'm not upset by intricate work to faciliate it, if it actually works (and empowers other creative things).  So I need to see hard disproofs before sacrificing what I consider to be "the point" of the design.</p>
<p>I'm always ready to look at it from a further perspective to see a "greater point".  But still--from where I stand--that apostrophe sucks relative to not having it.  (And if you read the details of the implementation post, the only reason it's allowed to work in a quoted slot is because of left literalism, so...)</p>
<h2>
<a name="what-about-multiple-arguments-2" class="anchor" href="https://forum.rebol.info#what-about-multiple-arguments-2"></a>What About Multiple Arguments?</h2>
<p>Notationally there are questions about this form of lambda.  Does it use a block for multiple arguments?</p>
<pre><code>&gt;&gt; foo: [a b] -&gt; [a + b + 20]

&gt;&gt; foo 400 600
== 1020
</code></pre>
<p>It could, but you could be weirder:</p>
<pre><code>foo: a.b -&gt; [a + b + 20]

foo: a/b -&gt; [a + b + 20]
</code></pre>
<p>This would look a little tighter with branching, I think, since it wouldn't compete with the branches:</p>
<pre><code>case [
    ...
] then [a b] -&gt; [
    ...
]

case [
    ...
] then a.b -&gt; [
    ...
]
</code></pre>
<p><em>But wait, you'd never use it with a branch... because a branch only produces one value.</em></p>
<p>UNLESS... what if what this form of lambda did was unpack packs?</p>
<pre><code>case [
    true [pack [10 + 20, 3 + 4]]  ; makes antiform ~['30 '7]~
    ...
] then [a b] -&gt; [
    assert [a = 30, b = 7]
]

case [
    true [pack [10 + 20, 3 + 4]]
    ...
] then a -&gt; [
    assert [a = 30]
]
</code></pre>
<p>So I've been thinking this is what it should actually do.  It means -&gt; won't be a good way to define functions or lambdas generally, but you have FUNC(TION) and LAMBDA for that.</p>
<p>I don't know that enabling a lighter notation like <strong><code>a.b</code></strong> or <strong><code>a/b</code></strong> is worth it.</p>
<pre><code>case [
    true [pack [10 + 20, 3 + 4]]
    ...
] then a.b -&gt; [
    assert [a = 30, b = 7]
]

case [
    true [pack [10 + 20, 3 + 4]]
    ...
] then a/b -&gt; [
    assert [a = 30, b = 7]
]
</code></pre>
<p>Maybe just confusing, and limits what you can put in the spec.  Easier to add later if it seems useful than put it in now and take out later.</p>
<h2>
<a name="is-there-a-good-name-for-lambda-lite-3" class="anchor" href="https://forum.rebol.info#is-there-a-good-name-for-lambda-lite-3"></a>Is There A Good Name For "Lambda Lite"?</h2>
<p>We could call it an "unpacking lambda".  Maybe it's controlled with a refinement:</p>
<pre><code> &gt;&gt; foo: lambda/unpack [a b] [a + b + 20]

 &gt;&gt; foo pack [400 600]
 == 1020
</code></pre>
<p>Then <strong><code>-&gt;: :lambda/unpack</code></strong></p>
<p>We could just call it <em>"an unpacker"</em>.</p>
<pre><code> &gt;&gt; foo: unpacker [a b] [a + b + 20]

 &gt;&gt; foo pack [400 600]
 == 1020
</code></pre>
<p>Then <strong><code>-&gt;: :unpacker</code></strong></p>
<p>The problem with calling it an "unpacker" is that 9 (or more) times out of 10 it will only take a single argument and not unpack anything.  So it seems better to classify it as a shade of distinction on lambda, but still when you point to an <code>-&gt;</code> on the screen say <em>"then it passes the argument to the lambda..."</em></p> ]]></description>
        <link>https://forum.rebol.info/t/for-lambda-or-lambda-lite/2172#post_1</link>
        <pubDate>Sun, 10 Mar 2024 15:21:58 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7246</guid>
      </item>
      <item>
        <title>REIFY and DEGRADE: a Narrower META and UNMETA</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2163">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I think that I've settled on the name for the function that turns quasiforms into antiforms, but leaves everything else alone: <strong>DEGRADE</strong>...and its complement <strong>REIFY</strong></p>
</blockquote>
</aside>
<p>I guess I should have an answer to the question of why I didn't pair REIFY with UNREIFY.</p>
<p>Uh, maybe it should be called that?</p>
<p>The rationale in my head was something like:</p>
<ul>
<li>
<p>"oh, it's not always UNREIFY-ing, it leaves non-quasi things in their plain forms".  But it's not "always degrading" either.</p>
</li>
<li>
<p>UNREIFY doesn't scan well as a word (but UNMETA does?)</p>
</li>
</ul>
<p>There's an implicit meaning here where it's "REIFY-ANTIFORMS" and "UNREIFY-QUASIFORMS".  Something about REIFY only applying to antiforms makes clear intuitive sense (you don't need to reify a WORD!, it's already reified).  But you could imagine UNREIFY-ing a WORD! and getting an antiform word.  So the "-QUASIFORMS" is not as obvious.</p>
<p>I'm not 100% confident that the benefit of choosing a word besides UNREIFY is worth breaking the pairing, but DEGRADE is less off-putting in the source.  So it's what I went with.</p> ]]></description>
        <link>https://forum.rebol.info/t/reify-and-degrade-a-narrower-meta-and-unmeta/2163#post_2</link>
        <pubDate>Sat, 09 Mar 2024 15:32:23 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7245</guid>
      </item>
      <item>
        <title>Could we replace PARSE&#39;s OPT with TRY ?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1888">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Haskell has <strong><a href="https://hackage.haskell.org/package/parsers-0.12.10/docs/Text-Parser-Combinators.html#v:try">try</a></strong> defined as <em>"Take a parser that may consume input, and on failure, go back to where we started and fail as if we didn't consume input."</em></p>
<p>If I'm reading that correctly, this is a parallel meaning to OPT.</p>
</blockquote>
</aside>
<p>Just as a quick note: you’ve read this wrong. (Though to be fair it’s a bad comment from a little-used library.) The <em>actual</em> function of <code>try</code> is, ‘allow this parser to be rolled back on failure’. The stuff about ‘consuming input’ comes from a subtlety of parser combinator implementation, which is that they commit to a sub-parser as soon as it consumes a single element.</p>
<p>Of course, Haskell libraries must still offer a combinator for optional elements, which may be either present or absent. It’s an important aspect of parsing, after all. And they call it… <a href="https://hackage.haskell.org/package/parser-combinators-1.3.0/docs/Control-Monad-Combinators.html#v:optional"><code>optional</code></a>.</p> ]]></description>
        <link>https://forum.rebol.info/t/could-we-replace-parses-opt-with-try/1888#post_7</link>
        <pubDate>Sat, 09 Mar 2024 12:40:26 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7244</guid>
      </item>
      <item>
        <title>Could we replace PARSE&#39;s OPT with TRY ?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="1888">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'd been letting this turn over in my head a bit before committing to it</p>
</blockquote>
</aside>
<p>So...we've had a good 7 months of TRY replacing OPT for me to get a truly informed feeling.</p>
<p><em><strong>Getting cold feet... <img src="https://forum.rebol.info/images/emoji/twitter/ice_cube.png?v=12" title=":ice_cube:" class="emoji" alt=":ice_cube:" loading="lazy" width="20" height="20"> <img src="https://forum.rebol.info/images/emoji/twitter/footprints.png?v=12" title=":footprints:" class="emoji" alt=":footprints:" loading="lazy" width="20" height="20"> I don't 100% love it.</strong></em></p>
<aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="1888">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Yet it still felt a bit strange to me at first to say you were "trying S".</p>
<p>I think this is just a lack of familiarity, and it will seem more natural with time.</p>
</blockquote>
</aside>
<p>Nope.  Still feels like the wrong part of speech.</p>
<p>And I don't think the idea that it relates to error suppression comes across meaningfully to users, especially since the errors of combinators already are suppressed and translated into mismatch-and-continue.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="1888">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I think the OPT is ugly</p>
</blockquote>
</aside>
<p>Beauty is in the eye of the beholder, I guess.  People in Red certainly aren't bothered, and I'm probably the only person to have complained loudly about it.</p>
<p>If we made OPTIONAL a PARSE keyword and then said OPT was a shorthand for it, then that would at least offer a full-"English" choice:</p>
<pre><code>parse url ["http" optional "s" "://gitlab.com/" ...]

parse url ["http" opt "s" "://gitlab.com/" ...]
</code></pre>
<p>I can see using it in tutorials, so it's less jarring.  People would probably quickly switch to the abbreviation in practice.  But I can't say that for sure... looking at the above, I might well write it out.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p>
<p>Guess it depends on how many times I'm using it.  UPARSE offers more factoring capability than historical PARSE, so you don't wind up repeating yourself as often... and maybe being super brief in saying something is optional isn't that necessary.</p>
<aside class="quote no-group" data-username="gchiu" data-post="3" data-topic="1888">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/gchiu/40/22_2.png" class="avatar"> gchiu:</div>
<blockquote>
<p>If you wanted one could try <code>MAYBE</code></p>
</blockquote>
</aside>
<p>Coming back to this... I still don't feel like I can justify it.  MAYBE is for null-defusing.  If it had a parse analogue, it would be more like this:</p>
<pre><code>&gt;&gt; rule: null

&gt;&gt; parse "aaaccc" [some "a", some maybe rule, some "c"]
== "c"
</code></pre>
<p>I've said that we could not do this, because RULE fails at the moment of "combinating"... it can't look up the rule to form the subparser for <code>[maybe rule]</code>, during the build of the parser for <code>[some maybe rule]</code>.  So SOME is never called, hence it can never call MAYBE, where the logic to disable the error would live.</p>
<p><em>But...what if NULL did "combinate", just to a parser raising a specific error related to null combinators?</em>  Hm.  The problem would be that parsers would have to default to promoting that error to a failure somehow.  E.g. MAYBE would need to call its combinated parser with <strong><code>parser/null-error-ok</code></strong> or somesuch, to distinguish it from all the other parsers that don't want to be tolerant.</p>
<p>Or... maybe there's a specific recognition of the null-producing parser by its identity?  e.g. the "null combinator" builds a parser that hard fails if it gets called, but MAYBE never makes that call...doing an inspection of it through some other means.</p>
<p>Though notice this usage wouldn't actually work anyway... SOME MAYBE RULE would make MAYBE RULE succeed without advancing, and be an infinite loop.  (You can't use SOME OPT either with that meaning, for that matter...so not a complete indictment of the concept, just pointing out that it's not necessarily as useful as it seems at first.)</p>
<p><strong>In any case, my bigger point being that I think this is the spirit of what a MAYBE combinator would be for... not imply generic mismatch tolerance.</strong>  Just because it can't work mechanically for its natural meaning doesn't mean the word is up for grabs.  And weighing it in my head right now, I kind of think it may be worth pushing through some tricks to do it...the idea of making the hard-failing combinator that's noticed by MAYBE's identity inspection on the parser sounds like it could work.</p>
<h2>
<a name="odds-are-im-swapping-the-trys-back-out-1" class="anchor" href="https://forum.rebol.info#odds-are-im-swapping-the-trys-back-out-1"></a>Odds Are, I'm Swapping The TRYs Back Out</h2>
<p>Likely going back to a mix of OPTIONALs and OPTs... maybe see how favoring OPTIONAL works out in real code.</p> ]]></description>
        <link>https://forum.rebol.info/t/could-we-replace-parses-opt-with-try/1888#post_6</link>
        <pubDate>Sat, 09 Mar 2024 11:29:39 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7243</guid>
      </item>
      <item>
        <title>How To Choose Between Returning VOID and NIHIL?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2171">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Both seem to vaporise in lists, after all.</p>
</blockquote>
</aside>
<p>There's some touchy-feely choices made in the constructs regarding voids.</p>
<p>I think it's important that they're not truthy or falsey.</p>
<pre><code>&gt;&gt; if void [print "This is important."]
** Script Error: Invalid use of void
</code></pre>
<p>Which rules out IF on an IF, since failed IF returns void:</p>
<pre><code>&gt;&gt; if (if false [&lt;a&gt;]) [&lt;b&gt;]
** Script Error: Invalid use of void
</code></pre>
<p>However, ALL is kind of like a chain of IF statements testing for logic.  Given the existence of NIHIL, should it demand that for opting out?</p>
<pre><code>&gt;&gt; all [if true [1 &lt; 2] if false [3 &gt; 4] if true [5 &lt; 6]]
** Script Error: Invalid use of void
</code></pre>
<p>If it wasn't willing to erase voids, you'd need to use ELIDE-IF-VOID to erase the voids:</p>
<pre><code>&gt;&gt; all [if true [1 &lt; 2] elide-if-void if false [3 &gt; 4] if true [5 &lt; 6]]
== ~true~  ; anti
</code></pre>
<p>But I feel like it works out better in practice if ANY and ALL consider void as no vote.  Also, if all the expressions opt out of voting, the ANY or ALL overall is void.</p>
<pre><code>&gt;&gt; any [void, all [if false [1 &lt; 2] if false [3 &gt; 4] if false [5 &lt; 6]], void]
== ~void~  ; anti
</code></pre>
<p>But other constructs--like CASE--do not erase voids...only NIHIL.  They have a "structure" to them, and it's desirable to not disrupt that structure too easily, e.g. by looking up a variable which could be void.  (variables cannot be NIHIL, it's an unstable isotope)</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2171">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Though this does now raise the question of whether a function should return nihil or void.</p>
</blockquote>
</aside>
<p>I think it should be a very rare choice to make things return VOID unconditionally.</p>
<p>And I think it should be an even rarer choice to return NIHIL (e.g. because of the damage it can do to things like CASE or SWITCH structure).  And when NIHIL is returned it should almost always be unconditional.</p>
<p>NIHIL is nice for debugging statements, because you can throw them in without disrupting the surrounding code</p>
<pre><code>&gt;&gt; y: 10 + do [x: 1 + 2, dump x]
x: 3
== 13
</code></pre>
<p>Because of this, there's been some pressure to say that PRINT return NIHIL.  <a href="https://forum.rebol.info/t/why-doesnt-print-return-void-or-vaporize-via-nihil/1466">So far, I've rejected that</a>.</p>
<pre><code>append [a b c] print "I think this should error"  ; rules out void

message: null
(print maybe message) else [print "I like reacting to no output"]
</code></pre>
<p>Also, though people reach for PRINT for debug output, I think it's poor for that.  The fact that it evaluates blocks means I don't like the idea of <strong>print x</strong> taking too many kinds of input, that could one day become a block and surprise you by evaluating.  So it's already a bad generic "debug dump".  And logging with the same thing you use for committed output makes it hard to search for debug code and remove or disable it.</p>
<p>I like there being relatively few NIHIL-returning operations, and if you want to erase something use ELIDE.</p>
<p>But ASSERT returns NIHIL and that's neat in things like CASE or SWITCH for asserting something as true when you've gotten to a certain point:</p>
<pre><code>case/all [  ; /ALL -&gt; don't stop on first condition matched
    x &lt; 10 [y: &lt;lesser&gt;]
    x &gt; 10 [y: &lt;greater&gt;]
    assert [(x = 10) or (find [&lt;lesser&gt; &lt;greater&gt;] y)]
    x = 10 [print "You can imagine this kind of thing being useful"]
]
</code></pre>
<p><sub><em>I should go through and replace these with real useful examples someday, but my hope is people get the point abstractly.</em></sub></p>
<p>Anyway, I think it's nice to be able to do that particular thing without saying ELIDE ASSERT.  A few other constructs make the cut of justifying NIHIL.</p>
<p>Hopefully it's clear why I don't think there are that many applications for functions that return nihil conditionally.  ELIDE-IF-VOID is a very niche function that I don't think there are that many legitimate uses for.  If you're going to come up with a construct that does return nihil conditionally, it should be discernible from the source-level syntax if it's a vanishing or non-vanishing invocation.</p> ]]></description>
        <link>https://forum.rebol.info/t/how-to-choose-between-returning-void-and-nihil/2171#post_2</link>
        <pubDate>Sat, 09 Mar 2024 09:41:57 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7242</guid>
      </item>
      <item>
        <title>Antiform TAG! As &quot;Triggers an Error On Access&quot; Type</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2170">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>TAG! does feel like the right type for this.</p>
</blockquote>
</aside>
<p>I actually got the original idea for having "named trash" from some scripts <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> had where he had configuration in the header of a script, something in the spirit of:</p>
<pre><code>Rebol [
    Title: "Configurable Foo Interface Script"
    DLL-Directory: &lt;directory where FOO.DLL lives&gt;
]

...stuff...

if tag? system.script.header.DLL-Directory [
    fail "Set the DLL-Directory in the header to where FOO.DLL lives"
]
libfoo: make library! system.script.header.DLL-Directory
</code></pre>
<p>I thought <em>"hm, that's an interesting idea, a sort of placeholder...would be better if it errored on accidental access"</em>.</p>
<p>So when TRASH! was initially conceived--prior to isotopes--it was a reified type that started and ended with tilde (actually called BAD-WORD!)</p>
<pre><code> DLL-Directory: ~directory-where-FOO-DLL-lives~
</code></pre>
<p>That does show weaknesses in having to convert the dots and spaces to dashes.  So going back to the original placeholder type of TAG! is an interesting move.</p>
<p>It's tempting to say that the whole category would be called TRASH! and take over that role.  But unfortunately <strong><code>&lt;&gt;</code></strong> is a WORD!, so there'd be no slight-looking <strong>~&lt;&gt;~</strong> trash for unset variables.  It would have to be <strong><code>~&lt;unset&gt;~</code></strong> or something like that, which doesn't have the brevity of <strong>~</strong> that I am very attached to now... though there is a slightness to it which can <em>sometimes</em> be undesirable.</p>
<p>It seems to me that DEFAULT should treat these as unassigned:</p>
<pre><code>&gt;&gt; x: ~&lt;some placeholder&gt;~
== ~&lt;some placeholder&gt;~  ; anti

&gt;&gt; x: default [10 + 20]
== 30

&gt;&gt; x
== 30

&gt;&gt; x: default [3 + 4]
== 30
</code></pre>
<p>But does that mean UNSET? should return true, had you asked <strong>unset? 'x</strong> ?</p>
<p>So some issues to sort through here regarding what to call it and how it acts.</p> ]]></description>
        <link>https://forum.rebol.info/t/antiform-tag-as-triggers-an-error-on-access-type/2170#post_3</link>
        <pubDate>Sat, 09 Mar 2024 09:11:42 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7240</guid>
      </item>
      <item>
        <title>Antiform TAG! As &quot;Triggers an Error On Access&quot; Type</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="6" data-topic="1604">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604/6">Shades of Distinction In Non-Valued Intents</a>
</div>
<blockquote>
<p>I've come to question this as things have gone on, to where I'm wondering if all antiform words should be reserved by the system (there are system purposes for the ~end~ antiform, for instance).</p>
<p>A generic "error trigger" might come from something like antiform TAG!, permitting spaces</p>
</blockquote>
</aside>
<p>I like this idea! TAG! does feel like the right type for this.</p> ]]></description>
        <link>https://forum.rebol.info/t/antiform-tag-as-triggers-an-error-on-access-type/2170#post_2</link>
        <pubDate>Sat, 09 Mar 2024 08:50:26 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7239</guid>
      </item>
      <item>
        <title>Antiform TAG! As &quot;Triggers an Error On Access&quot; Type</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>In the post <a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604">"Shades of Distinction In Non-Valued Intents"</a>, I had originally written:</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1604">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604/1">Shades of Distinction In Non-Valued Intents</a>
</div>
<blockquote>
<p>Eventually the NULL state became the isotopic status of the WORD! null, so a <strong>~null~</strong> antiform.</p>
<p>It joined <strong>~true~</strong> and <strong>~false~</strong> as being antiforms you could test for truthiness and falseyness. But if you were okay with getting an error on conditional testing, any other word could be used:</p>
<pre><code class="lang-plaintext">  config: ~initialize-system-not-called~

  initialize-system: func [
      {Let's say this function reads the config file}
  ][
      ...
      config: [...]
  ]
</code></pre>
<p>This usually causes a nice labeled message anytime someone tries to use CONFIG:</p>
<p>Going this route would create a pain point for anyone who thought they were going to test for whether you had a config initialized by testing <strong>if config [...]</strong>. So that has to be considered as whether it's what you want.</p>
</blockquote>
</aside>
<p>I've come to question this as things have gone on, to where I'm wondering if all antiform words should be reserved by the system (there are system purposes for the ~end~ antiform, for instance).</p>
<p>A generic "error trigger" might come from something like antiform TAG!, permitting spaces:</p>
<pre><code>config: ~&lt;INITIALIZE-SYSTEM not called&gt;~

initialize-system: func [
    {Let's say this function reads the config file}
][
    ...
    config: [...]
]

&gt;&gt; config
** Error: INITIALIZE-SYSTEM not called
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/antiform-tag-as-triggers-an-error-on-access-type/2170#post_1</link>
        <pubDate>Sat, 09 Mar 2024 08:49:19 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7238</guid>
      </item>
      <item>
        <title>Getting an unset variable</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Attachment binding is just something that had to be done in order to get the system to boot under new binding rules.  I don't have a coherent theory for it.</p>
<p>As such, I can't offhand immediately name "here's a thing that fundamentally doesn't work about equating attachment-bound things with being unset".</p>
<p>I can tell you that at least for my sake in debugging things, I like to know the difference.</p>
<p>But more generally, I can tell you that attachment binding is dodgy.  If you try to pretend attachment-bound things are real variables that are backed by a memory location, then you'll be lying when you answer various questions like BINDING OF (not a great question to ask these days, crashes on things).</p> ]]></description>
        <link>https://forum.rebol.info/t/getting-an-unset-variable/2169#post_4</link>
        <pubDate>Sat, 09 Mar 2024 03:03:59 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7237</guid>
      </item>
      <item>
        <title>Getting an unset variable</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2169">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It's possible to not draw a distinction in the UI, and treat these as existing but unset... but I suspect that's not a good thing to do.</p>
</blockquote>
</aside>
<p>What’s wrong with that? To me it seems the most logical approach. If I mention a variable which has never been set, I’d <em>expect</em> it to behave as if it were unset.</p> ]]></description>
        <link>https://forum.rebol.info/t/getting-an-unset-variable/2169#post_3</link>
        <pubDate>Sat, 09 Mar 2024 02:50:49 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7236</guid>
      </item>
  </channel>
</rss>
